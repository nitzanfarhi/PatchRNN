commit 51655771af791109551020506371a4f4f72d1aa3
Author: Daniel-Constantin Mierla <miconda@gmail.com>
Date:   Fri Jan 13 12:46:20 2012 +0100

    core: two more events for handling http and msrp
    
    - one to be called for http/1.1 end of headers for checking on '100
      Continue' request
    - one to be called when a msrp message is received

diff --git a/events.c b/events.c
index 0b78df83f..5ad2b44c5 100644
--- a/events.c
+++ b/events.c
@@ -86,6 +86,16 @@ int sr_event_register_cb(int type, sr_event_cb_f f)
 					_sr_events_list.net_dgram_in = f;
 				else return -1;
 			break;
+		case SREV_TCP_HTTP_100C:
+				if(_sr_events_list.tcp_http_100c==0)
+					_sr_events_list.tcp_http_100c = f;
+				else return -1;
+			break;
+		case SREV_TCP_MSRP_FRAME:
+				if(_sr_events_list.tcp_msrp_frame==0)
+					_sr_events_list.tcp_msrp_frame = f;
+				else return -1;
+			break;
 		default:
 			return -1;
 	}
@@ -165,6 +175,18 @@ int sr_event_exec(int type, void *data)
 					ret = _sr_events_list.net_dgram_in(data);
 					return ret;
 				} else return 1;
+		case SREV_TCP_HTTP_100C:
+				if(unlikely(_sr_events_list.tcp_http_100c!=0))
+				{
+					ret = _sr_events_list.tcp_http_100c(data);
+					return ret;
+				} else return 1;
+		case SREV_TCP_MSRP_FRAME:
+				if(unlikely(_sr_events_list.tcp_msrp_frame!=0))
+				{
+					ret = _sr_events_list.tcp_msrp_frame(data);
+					return ret;
+				} else return 1;
 		default:
 			return -1;
 	}
@@ -190,6 +212,10 @@ int sr_event_enabled(int type)
 				return (_sr_events_list.pkg_set_real_used!=0)?1:0;
 		case SREV_NET_DGRAM_IN:
 				return (_sr_events_list.net_dgram_in!=0)?1:0;
+		case SREV_TCP_HTTP_100C:
+				return (_sr_events_list.tcp_http_100c!=0)?1:0;
+		case SREV_TCP_MSRP_FRAME:
+				return (_sr_events_list.tcp_msrp_frame!=0)?1:0;
 	}
 	return 0;
 }
diff --git a/events.h b/events.h
index 465976f43..1a4c5e089 100644
--- a/events.h
+++ b/events.h
@@ -30,6 +30,9 @@
 #define SREV_PKG_SET_USED		5
 #define SREV_PKG_SET_REAL_USED	6
 #define SREV_NET_DGRAM_IN		7
+#define SREV_TCP_HTTP_100C		8
+#define SREV_TCP_MSRP_FRAME		9
+
 
 typedef int (*sr_event_cb_f)(void *data);
 
@@ -41,6 +44,8 @@ typedef struct sr_event_cb {
 	sr_event_cb_f pkg_set_used;
 	sr_event_cb_f pkg_set_real_used;
 	sr_event_cb_f net_dgram_in;
+	sr_event_cb_f tcp_http_100c;
+	sr_event_cb_f tcp_msrp_frame;
 } sr_event_cb_t;
 
 void sr_event_cb_init(void);
diff --git a/tcp_conn.h b/tcp_conn.h
index fe9cc002d..a8a7e04fc 100644
--- a/tcp_conn.h
+++ b/tcp_conn.h
@@ -342,6 +342,14 @@ struct tcp_connection* tcpconn_get(int id, struct ip_addr* ip, int port,
 									union sockaddr_union* local_addr,
 									ticks_t timeout);
 
+typedef struct tcp_event_info {
+	int type;
+	char *buf;
+	unsigned int len;
+	struct receive_info *rcv;
+	struct tcp_connection *con;
+} tcp_event_info_t;
+
 #endif
 
 
diff --git a/tcp_read.c b/tcp_read.c
index bdbd0419e..41fbbf7c3 100644
--- a/tcp_read.c
+++ b/tcp_read.c
@@ -96,6 +96,7 @@
 #include <fcntl.h> /* must be included after io_wait.h if SIGIO_RT is used */
 #include "tsend.h"
 #include "forward.h"
+#include "events.h"
 
 #ifdef USE_STUN
 #include "ser_stun.h"
@@ -994,8 +995,23 @@ skip:
 int msrp_process_msg(char* tcpbuf, unsigned int len,
 		struct receive_info* rcv_info, struct tcp_connection* con)
 {
+	int ret;
+	tcp_event_info_t tev;
+
+	ret = 0;
 	LM_DBG("MSRP Message: [[>>>\n%.*s<<<]]\n", len, tcpbuf);
-	return 0;
+	if(likely(sr_event_enabled(SREV_TCP_MSRP_FRAME))) {
+		memset(&tev, 0, sizeof(tcp_event_info_t));
+		tev.type = SREV_TCP_MSRP_FRAME;
+		tev.buf = tcpbuf;
+		tev.len = len;
+		tev.rcv = rcv_info;
+		tev.con = con;
+		ret = sr_event_exec(SREV_TCP_MSRP_FRAME, (void*)(&tev));
+	} else {
+		LM_DBG("no callback registering for handling MSRP - dropping!\n");
+	}
+	return ret;
 }
 #endif
 

