commit cc824534d4fef0e46e4486d5c1e10d3c6b1ebadc
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Aug 25 16:15:35 2014 -0700

    ARM: OMAP2+: hwmod: Rearm wake-up interrupts for DT when MUSB is idled
    
    Looks like MUSB cable removal can cause wake-up interrupts to
    stop working for device tree based booting at least for UART3
    even as nothing is dynamically remuxed. This can be fixed by
    calling reconfigure_io_chain() for device tree based booting
    in hwmod code. Note that we already do that for legacy booting
    if the legacy mux is configured.
    
    My guess is that this is related to UART3 and MUSB ULPI
    hsusb0_data0 and hsusb0_data1 support for Carkit mode that
    somehow affect the configured IO chain for UART3 and require
    rearming the wake-up interrupts.
    
    In general, for device tree based booting, pinctrl-single
    calls the rearm hook that in turn calls reconfigure_io_chain
    so calling reconfigure_io_chain should not be needed from the
    hwmod code for other events.
    
    So let's limit the hwmod rearming of iochain only to
    HWMOD_FORCE_MSTANDBY where MUSB is currently the only user
    of it. If we see other devices needing similar changes we can
    add more checks for it.
    
    Cc: Paul Walmsley <paul@pwsan.com>
    Cc: stable@vger.kernel.org # v3.16
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 6c074f37cdd2..da1b256caccc 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -2185,6 +2185,8 @@ static int _enable(struct omap_hwmod *oh)
 			 oh->mux->pads_dynamic))) {
 		omap_hwmod_mux(oh->mux, _HWMOD_STATE_ENABLED);
 		_reconfigure_io_chain();
+	} else if (oh->flags & HWMOD_FORCE_MSTANDBY) {
+		_reconfigure_io_chain();
 	}
 
 	_add_initiator_dep(oh, mpu_oh);
@@ -2291,6 +2293,8 @@ static int _idle(struct omap_hwmod *oh)
 	if (oh->mux && oh->mux->pads_dynamic) {
 		omap_hwmod_mux(oh->mux, _HWMOD_STATE_IDLE);
 		_reconfigure_io_chain();
+	} else if (oh->flags & HWMOD_FORCE_MSTANDBY) {
+		_reconfigure_io_chain();
 	}
 
 	oh->_state = _HWMOD_STATE_IDLE;

