commit 9f2df8ce248bbe17fd1afd563e9858ce80e077d9
Author: jeljeli <ahmedjeljeli@gmail.com>
Date:   Mon Dec 12 15:31:59 2016 +0100

    Improved mediacodec performances

diff --git a/include/gpac/internal/media_dev.h b/include/gpac/internal/media_dev.h
index f477c8a46..4ce3bb335 100644
--- a/include/gpac/internal/media_dev.h
+++ b/include/gpac/internal/media_dev.h
@@ -106,6 +106,16 @@ typedef struct
 	/*to be eventually completed by other vui members*/
 } AVC_VUI;
 
+typedef struct 
+{
+	u32 left;
+	u32 right;
+	u32 top;
+	u32 bottom;
+	
+} AVC_CROP;
+
+
 typedef struct
 {
 	s32 profile_idc;
@@ -126,6 +136,7 @@ typedef struct
 	u32 width, height;
 
 	AVC_VUI vui;
+	AVC_CROP crop;
 
 	/*used to discard repeated SPSs - 0: not parsed, 1 parsed, 2 sent*/
 	u32 state;
diff --git a/modules/mediacodec_dec/mediacodec_dec.c b/modules/mediacodec_dec/mediacodec_dec.c
index 45b7bac80..1951b7e0d 100644
--- a/modules/mediacodec_dec/mediacodec_dec.c
+++ b/modules/mediacodec_dec/mediacodec_dec.c
@@ -25,24 +25,31 @@ typedef struct
 {
     AMediaCodec *codec;
     AMediaFormat *format;
+	char * frame;
+	
     u32 dequeue_timeout;
 
     u32 width, height, stride, out_size;
     u32 pixel_ar, pix_fmt;
+	u32 crop_left, crop_right, crop_top, crop_bottom;
+	int crop_unitX, crop_unitY;
 
     const char *mime;
 
     u8 chroma_format, luma_bit_depth, chroma_bit_depth;
     GF_ESD *esd;
-
-    u32 counter;
-    u16 frame_rate;
-
+	u16 frame_rate;
+	Bool frame_size_changed;
     Bool inputEOS, outputEOS;
-
+	Bool raw_frame_dispatch;
     //NAL-based specific
+	GF_List *SPSs, *PPSs;
+	s32 active_sps, active_pps;
     char *sps, *pps;
     u32 sps_size, pps_size;
+	AVCState avc;
+	u32 decoded_frames_pending;
+	Bool reconfig_needed;
     u32 nalu_size_length;
 
     //hevc
@@ -51,10 +58,16 @@ typedef struct
     u8 chroma_format_idc;
     u16 ES_ID;
     u32 vps_size;
+	AMediaCodecBufferInfo info;
+	ssize_t outIndex;
 
 } MCDec;
-
-
+typedef struct {
+	char * frame;
+	MCDec * ctx;
+	ssize_t outIndex;
+	
+} MC_Frame;
 u8 sdkInt() 
 {
     char sdk_str[3] = "0";
@@ -93,28 +106,54 @@ void initMediaFormat(MCDec *ctx, AMediaFormat *format)
 
 GF_Err MCDec_InitAvcDecoder(MCDec *ctx) 
 {
-    if (ctx->sps && ctx->pps) {
-        AVCState avc;
-        s32 idx;
-        memset(&avc, 0, sizeof(AVCState));
-        avc.sps_active_idx = -1;
-
-        idx = gf_media_avc_read_sps(ctx->sps, ctx->sps_size, &avc, 0, NULL);
-
-        assert(ctx->sps);
-        ctx->width = avc.sps[idx].width;
-        ctx->height = avc.sps[idx].height;
-
-        ctx->out_size = ctx->height * ctx->width * 3/2 ;
-
-        if (avc.sps[idx].vui.par_num && avc.sps[idx].vui.par_den) {
-            ctx->pixel_ar = avc.sps[idx].vui.par_num;
+	s32 idx;
+	char *dsi_data = NULL;
+	u32 dsi_data_size = 0;
+	 
+		if (gf_list_count(ctx->SPSs) && gf_list_count(ctx->PPSs)) {
+			u32 i;
+			GF_AVCConfig *cfg;
+			GF_AVCConfigSlot *sps = NULL;
+			GF_AVCConfigSlot *pps = NULL;
+
+			for (i=0; i<gf_list_count(ctx->SPSs); i++) {
+				sps = gf_list_get(ctx->SPSs, i);
+				if (ctx->active_sps<0) ctx->active_sps = sps->id;
+
+				if (sps->id==ctx->active_sps) break;
+				sps = NULL;
+			}
+			if (!sps) return GF_NON_COMPLIANT_BITSTREAM;
+			for (i=0; i<gf_list_count(ctx->PPSs); i++) {
+				pps = gf_list_get(ctx->PPSs, i);
+				if (ctx->active_pps<0) ctx->active_pps = pps->id;
+
+				if (pps->id==ctx->active_pps) break;
+				pps = NULL;
+			}
+			if (!pps) return GF_NON_COMPLIANT_BITSTREAM;
+			ctx->reconfig_needed = GF_FALSE;
+			
+		idx = ctx->active_sps;
+        ctx->width = ctx->avc.sps[idx].width;
+        ctx->height = ctx->avc.sps[idx].height;
+		ctx->crop_left = ctx->avc.sps[idx].crop.left;
+		ctx->crop_right = ctx->avc.sps[idx].crop.right;
+		ctx->crop_top = ctx->avc.sps[idx].crop.top;
+		ctx->crop_bottom = ctx->avc.sps[idx].crop.bottom;
+		ctx->crop_left = ctx->avc.sps[idx].crop.left;
+		ctx->width +=  ctx->crop_left  + ctx->crop_right;
+		ctx->height += ctx->crop_top + ctx->crop_bottom;
+		ctx->out_size = ctx->height * ctx->width * 3/2 ;
+
+        if (ctx->avc.sps[idx].vui.par_num && ctx->avc.sps[idx].vui.par_den) {
+            ctx->pixel_ar = ctx->avc.sps[idx].vui.par_num;
             ctx->pixel_ar <<= 16;
-            ctx->pixel_ar |= avc.sps[idx].vui.par_den;
+            ctx->pixel_ar |= ctx->avc.sps[idx].vui.par_den;
         }
-        ctx->chroma_format = avc.sps[idx].chroma_format;
-        ctx->luma_bit_depth = 8 + avc.sps[idx].luma_bit_depth_m8;
-        ctx->chroma_bit_depth = 8 + avc.sps[idx].chroma_bit_depth_m8;
+        ctx->chroma_format = ctx->avc.sps[idx].chroma_format;
+        ctx->luma_bit_depth = 8 + ctx->avc.sps[idx].luma_bit_depth_m8;
+        ctx->chroma_bit_depth = 8 + ctx->avc.sps[idx].chroma_bit_depth_m8;
        switch (ctx->chroma_format) {
         case 2:
             if (ctx->luma_bit_depth>8) {
@@ -136,21 +175,8 @@ GF_Err MCDec_InitAvcDecoder(MCDec *ctx)
             }
             break;
         }
-    
-        ctx->mime = "video/avc";
-
-        u32 sps_size = 4 + ctx->sps_size;
-        u32 pps_size = 4 + ctx->pps_size;   
-        char *sps = (char *)malloc(sps_size);
-        char *pps = (char *)malloc(pps_size);
-        
-        prependStartCode(ctx->sps, sps, &ctx->sps_size);
-        prependStartCode(ctx->pps, pps, &ctx->pps_size);
-
-        AMediaFormat_setBuffer(ctx->format, "csd-0", sps, sps_size);
-        AMediaFormat_setBuffer(ctx->format, "csd-1", pps, pps_size);
-    }
-
+	} 
+	ctx->frame_size_changed = GF_TRUE;
     return GF_OK;
 }
 
@@ -355,16 +381,58 @@ static GF_Err MCDec_InitDecoder(MCDec *ctx) {
     if( AMediaCodec_start(ctx->codec) != AMEDIA_OK){
         LOGE("AMediaCodec_start failed");
         return GF_BAD_PARAM;
-    }
-
-    ctx->inputEOS = GF_FALSE;
+    } 
+	
+	ctx->inputEOS = GF_FALSE;
     ctx->outputEOS = GF_FALSE;
-    ctx->counter = 0;
-
-    LOGI("Video size: %d x %d", ctx->width, ctx->height);
+	LOGI("Video size: %d x %d", ctx->width, ctx->height);
     return GF_OK;
 }
-
+static void MCDec_RegisterParameterSet(MCDec *ctx, char *data, u32 size, Bool is_sps)
+{
+	Bool add = GF_TRUE;
+	u32 i, count;
+	s32 ps_id;
+	GF_List *dest = is_sps ? ctx->SPSs : ctx->PPSs;
+
+	if (is_sps) {
+		ps_id = gf_media_avc_read_sps(data, size, &ctx->avc, 0, NULL);
+		if (ps_id<0) return;
+	}
+	else {
+		ps_id = gf_media_avc_read_pps(data, size, &ctx->avc);
+		if (ps_id<0) return;
+	}
+	count = gf_list_count(dest);
+	for (i = 0; i<count; i++) {
+		GF_AVCConfigSlot *a_slc = gf_list_get(dest, i);
+		if (a_slc->id != ps_id) continue;
+		//not same size or different content but same ID, remove old xPS
+		if ((a_slc->size != size) || memcmp(a_slc->data, data, size)) {
+			gf_free(a_slc->data);
+			gf_free(a_slc);
+			gf_list_rem(dest, i);
+			break;
+		}
+		else {
+			add = GF_FALSE;
+		}
+		break;
+	}
+	if (add) {
+		GF_AVCConfigSlot *slc;
+		GF_SAFEALLOC(slc, GF_AVCConfigSlot);
+		slc->data = gf_malloc(size);
+		memcpy(slc->data, data, size);
+		slc->size = size;
+		slc->id = ps_id;
+		gf_list_add(dest, slc);
+	
+		//force re-activation of sps/pps
+		if (is_sps) ctx->active_sps = -1;
+		else ctx->active_pps = -1;
+	}
+}
 
 static GF_Err MCDec_AttachStream(GF_BaseDecoder *ifcg, GF_ESD *esd)
 {
@@ -374,34 +442,50 @@ static GF_Err MCDec_AttachStream(GF_BaseDecoder *ifcg, GF_ESD *esd)
 
     //check AVC config
     if (esd->decoderConfig->objectTypeIndication == GPAC_OTI_VIDEO_AVC) {
+		ctx->SPSs = gf_list_new();
+		ctx->PPSs = gf_list_new();
+		ctx->mime = "video/avc";
+		ctx->avc.sps_active_idx = -1;
+		ctx->active_sps = ctx->active_pps = -1;
         if (!esd->decoderConfig->decoderSpecificInfo || !esd->decoderConfig->decoderSpecificInfo->data) {
             ctx->width=ctx->height=128;
             ctx->out_size = ctx->width*ctx->height*3/2;
             ctx->pix_fmt = GF_PIXEL_NV12;
             return GF_OK;
         } else {
-            GF_AVCConfigSlot *slc;
-            GF_AVCConfig *cfg = gf_odf_avc_cfg_read(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);
-            slc = gf_list_get(cfg->sequenceParameterSets, 0);
-            if (slc) {
-                ctx->sps = slc->data;
-                ctx->sps_size = slc->size;
-            }
-            slc = gf_list_get(cfg->pictureParameterSets, 0);
-            if (slc) {
-                ctx->pps = slc->data;
-                ctx->pps_size = slc->size;
-            }
-            
-            if (ctx->sps && ctx->pps) {
-                e = MCDec_InitDecoder(ctx);
-            } else {
-                ctx->nalu_size_length = cfg->nal_unit_size;
-                e = GF_OK;
-            }
-            gf_odf_avc_cfg_del(cfg);
-            return e;
-        }
+			u32 i;
+			GF_AVCConfigSlot *slc;
+			GF_AVCConfig *cfg = gf_odf_avc_cfg_read(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);
+			for (i = 0; i<gf_list_count(cfg->sequenceParameterSets); i++) {
+				slc = gf_list_get(cfg->sequenceParameterSets, i);
+				slc->id = -1;
+				MCDec_RegisterParameterSet(ctx, slc->data, slc->size, GF_TRUE);
+			}
+
+			for (i = 0; i<gf_list_count(cfg->pictureParameterSets); i++) {
+				slc = gf_list_get(cfg->pictureParameterSets, i);
+				slc->id = -1;
+				MCDec_RegisterParameterSet(ctx, slc->data, slc->size, GF_FALSE);
+			}
+
+			slc = gf_list_get(ctx->SPSs, 0);
+			if (slc) ctx->active_sps = slc->id;
+
+			slc = gf_list_get(ctx->PPSs, 0);
+			if (slc) ctx->active_pps = slc->id;
+			
+			ctx->nalu_size_length = cfg->nal_unit_size;
+		
+			
+			if (gf_list_count(ctx->SPSs) && gf_list_count(ctx->PPSs)) {
+				e = MCDec_InitDecoder(ctx);
+			}
+			else {
+				e = GF_OK;
+			}
+			gf_odf_avc_cfg_del(cfg);
+			return e;
+		}
     }
 
     if (esd->decoderConfig->objectTypeIndication == GPAC_OTI_VIDEO_MPEG4_PART2) {
@@ -458,14 +542,14 @@ static GF_Err MCDec_GetCapabilities(GF_BaseDecoder *ifcg, GF_CodecCapability *ca
         capability->cap.valueInt = 1;                   
         break;
     case GF_CODEC_WIDTH:
-        capability->cap.valueInt = ctx->width;          
-        break;
+        capability->cap.valueInt = ctx->width;  
+		break;
     case GF_CODEC_HEIGHT:
         capability->cap.valueInt = ctx->height;         
         break;
     case GF_CODEC_STRIDE:
-        capability->cap.valueInt = ctx->stride;         
-        break;
+        capability->cap.valueInt = ctx->stride;
+		break;
     case GF_CODEC_FPS:
         capability->cap.valueFloat = ctx->frame_rate;
         break;
@@ -477,21 +561,21 @@ static GF_Err MCDec_GetCapabilities(GF_BaseDecoder *ifcg, GF_CodecCapability *ca
         capability->cap.valueInt = ctx->out_size;
         break;
     case GF_CODEC_PIXEL_FORMAT:
-        capability->cap.valueInt = ctx->pix_fmt;        
-        break;
+        capability->cap.valueInt = ctx->pix_fmt;    
+		break;
     case GF_CODEC_BUFFER_MIN:
         capability->cap.valueInt = 1;                   
         break;
     case GF_CODEC_BUFFER_MAX:
-        capability->cap.valueInt = 6;
+        capability->cap.valueInt = 4;
         break;
     /*by default we use 4 bytes padding (otherwise it happens that XviD crashes on some videos...)*/
     case GF_CODEC_PADDING_BYTES:
         capability->cap.valueInt = 0;                   
         break;
-    /*reorder is up to us*/
+    /*reorder is up to mediacodec*/
     case GF_CODEC_REORDER:
-        capability->cap.valueInt = 0;                   
+        capability->cap.valueInt = 1;                   
         break;
     case GF_CODEC_WANTS_THREAD:
         capability->cap.valueInt = 0;                   
@@ -499,8 +583,7 @@ static GF_Err MCDec_GetCapabilities(GF_BaseDecoder *ifcg, GF_CodecCapability *ca
     case GF_CODEC_FRAME_OUTPUT:
         capability->cap.valueInt = 1;                   
         break;
-    
-    /*not known at our level...*/
+	/*not known at our level...*/
     case GF_CODEC_CU_DURATION:                             
     default:
         capability->cap.valueInt = 0;
@@ -509,10 +592,120 @@ static GF_Err MCDec_GetCapabilities(GF_BaseDecoder *ifcg, GF_CodecCapability *ca
     return GF_OK;
 }
 
-
+static GF_Err MCDec_ParseNALs(MCDec *ctx, char *inBuffer, u32 inBufferLength, char **out_buffer, u32 *out_size)
+{
+	u32 i, sc_size;
+	char *ptr = inBuffer;
+	u32 nal_size;
+	GF_Err e = GF_OK;
+	GF_BitStream *bs = NULL;
+
+	if (out_buffer) {
+		*out_buffer = NULL;
+		*out_size = 0;
+	}
+	
+	if (!ctx->nalu_size_length) {
+		sc_size = 0;
+		nal_size = gf_media_nalu_next_start_code((u8 *)inBuffer, inBufferLength, &sc_size);
+		if (!sc_size) return GF_NON_COMPLIANT_BITSTREAM;
+		ptr += nal_size + sc_size;
+		assert(inBufferLength >= nal_size + sc_size);
+		inBufferLength -= nal_size + sc_size;
+	}
+	
+	while (inBufferLength) {
+		Bool add_nal = GF_TRUE;
+		u8 nal_type, nal_hdr;
+		GF_BitStream *nal_bs = NULL;
+		if (ctx->nalu_size_length) {
+			nal_size = 0;
+			for (i = 0; i<ctx->nalu_size_length; i++) {
+				nal_size = (nal_size << 8) + ((u8)ptr[i]);
+			}
+			ptr += ctx->nalu_size_length;
+		}
+		else {
+			nal_size = gf_media_nalu_next_start_code(ptr, inBufferLength, &sc_size);
+		}
+		nal_bs = gf_bs_new(ptr, nal_size, GF_BITSTREAM_READ);
+		nal_hdr = gf_bs_read_u8(nal_bs);
+		nal_type = nal_hdr & 0x1F;
+		switch (nal_type) {
+			case GF_AVC_NALU_SEQ_PARAM:
+				MCDec_RegisterParameterSet(ctx, ptr, nal_size, GF_TRUE);
+				add_nal = GF_FALSE;
+				break;
+			case GF_AVC_NALU_PIC_PARAM:
+				MCDec_RegisterParameterSet(ctx, ptr, nal_size, GF_FALSE);
+				add_nal = GF_FALSE;
+				break;
+			case GF_AVC_NALU_ACCESS_UNIT:
+			case GF_AVC_NALU_END_OF_SEQ:
+			case GF_AVC_NALU_END_OF_STREAM:
+			case GF_AVC_NALU_FILLER_DATA:
+				add_nal = GF_FALSE;
+				break;
+			default:
+				break;
+		}
+		gf_media_avc_parse_nalu(nal_bs, nal_hdr, &ctx->avc);
+		gf_bs_del(nal_bs);
+		if ((nal_type <= GF_AVC_NALU_IDR_SLICE) && ctx->avc.s_info.sps) {
+			if (ctx->avc.sps_active_idx != ctx->active_sps) {
+				ctx->reconfig_needed = 1;
+				ctx->active_sps = ctx->avc.sps_active_idx;
+				ctx->active_pps = ctx->avc.s_info.pps->id;
+				return GF_OK;
+			}
+		}
+
+		//if sps and pps are ready, init decoder
+		if (!ctx->codec && gf_list_count(ctx->SPSs) && gf_list_count(ctx->PPSs)) {
+			e = MCDec_InitDecoder(ctx);
+			if (e) return e;
+		}
+		if (!out_buffer) add_nal = GF_FALSE;
+		else if (add_nal && !ctx->codec) add_nal = GF_FALSE;
+		if (add_nal) {
+			if (!bs) bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
+			gf_bs_write_u32(bs, nal_size);
+			gf_bs_write_data(bs, ptr, nal_size);
+		}
+
+		ptr += nal_size;
+		if (ctx->nalu_size_length) {
+			if (inBufferLength < nal_size + ctx->nalu_size_length) break;
+			inBufferLength -= nal_size + ctx->nalu_size_length;
+		}
+		else {
+			
+			if (!sc_size || (inBufferLength < nal_size + sc_size)) break;
+			inBufferLength -= nal_size + sc_size;
+			ptr += sc_size;
+		}
+	}
+	
+	if (bs) {
+		gf_bs_get_content(bs, out_buffer, out_size);
+		gf_bs_del(bs);
+	}
+	return e;
+}
 static GF_Err MCDec_SetCapabilities(GF_BaseDecoder *ifcg, GF_CodecCapability capability)
 {
-    return GF_NOT_SUPPORTED;
+    MCDec *ctx = (MCDec *)ifcg->privateStack;
+	
+	switch (capability.CapCode) {
+		case GF_CODEC_FRAME_OUTPUT:
+			ctx->raw_frame_dispatch = capability.cap.valueInt ? GF_TRUE : GF_FALSE;
+
+			return GF_OK;
+	}
+
+	/*return unsupported to avoid confusion by the player (like color space changing ...) */
+	return GF_NOT_SUPPORTED;
+
 }
 
 
@@ -523,14 +716,35 @@ static GF_Err MCDec_ProcessData(GF_MediaDecoder *ifcg,
                                u8 PaddingBits, u32 mmlevel)
 {
     MCDec *ctx = (MCDec *)ifcg->privateStack;
-    *outBufferLength = 0;
-
+	ctx->nalu_size_length = 0;
+	if (!ctx->reconfig_needed)
+		MCDec_ParseNALs(ctx, inBuffer, inBufferLength, NULL, NULL);
+	
+	if (ctx->reconfig_needed) {
+		if (ctx->raw_frame_dispatch && ctx->decoded_frames_pending) {
+			*outBufferLength = 1;
+			return GF_BUFFER_TOO_SMALL;
+		}
+		
+		if (ctx->codec) {
+			AMediaCodec_flush(ctx->codec);
+			AMediaCodec_stop(ctx->codec);
+			AMediaCodec_delete(ctx->codec);
+			ctx->codec = NULL;
+		}
+		MCDec_InitDecoder(ctx);
+			 if (ctx->out_size != *outBufferLength) {
+				 *outBufferLength = ctx->out_size;
+				 return GF_BUFFER_TOO_SMALL;
+			 }
+		 }
+			 
+	
+	
     if(!ctx->inputEOS) {
-
-        ssize_t inIndex = AMediaCodec_dequeueInputBuffer(ctx->codec, ctx->dequeue_timeout);
-        //LOGV("Input Buffer Index: %d", inIndex);
-
-        if (inIndex >= 0) {
+		ssize_t inIndex = AMediaCodec_dequeueInputBuffer(ctx->codec,ctx->dequeue_timeout);
+		
+		if (inIndex >= 0) {
 
             size_t inSize;
             char *buffer = (char *)AMediaCodec_getInputBuffer(ctx->codec, inIndex, &inSize);
@@ -543,26 +757,8 @@ static GF_Err MCDec_ProcessData(GF_MediaDecoder *ifcg,
         switch (ctx->esd->decoderConfig->objectTypeIndication) {
 
             case GPAC_OTI_VIDEO_AVC:
-                
-                if(inBuffer[4] == 0x67) { //check for sps
-
-                    u32 start = ctx->sps_size + ctx->pps_size;
-
-                    u32 i;    
-                    for (i = start; i < inBufferLength ; ++i) {
-                        buffer[i - start] = inBuffer[i];
-                    }
-                }
-
-                else {
-                    memcpy(buffer, inBuffer, inBufferLength);
-                }
-
-                buffer[0] = 0x00;
-                buffer[1] = 0x00;
-                buffer[2] = 0x00;
-                buffer[3] = 0x01;
-                break;
+					memcpy(buffer, inBuffer, inBufferLength);
+					break;
 
 
             case GPAC_OTI_VIDEO_HEVC:
@@ -574,16 +770,16 @@ static GF_Err MCDec_ProcessData(GF_MediaDecoder *ifcg,
                     for (i = start; i < inBufferLength ; ++i) {
                         buffer[i - start] = inBuffer[i];
                     }
+					buffer[0] = 0x00;
+					buffer[1] = 0x00;
+					buffer[2] = 0x00;
+					buffer[3] = 0x01;
                 }
                 else {
                     memcpy(buffer, inBuffer, inBufferLength);
                 }
-
-                buffer[0] = 0x00;
-                buffer[1] = 0x00;
-                buffer[2] = 0x00;
-                buffer[3] = 0x01;
-                break;
+				
+				break;
 
            default:
                 memcpy(buffer, inBuffer, inBufferLength);
@@ -592,17 +788,13 @@ static GF_Err MCDec_ProcessData(GF_MediaDecoder *ifcg,
 
             if(!inBuffer || inBufferLength == 0){
                 LOGI("AMEDIACODEC_BUFFER_FLAG_END_OF_STREAM input");
-                ctx->inputEOS = true;
+				 ctx->inputEOS = GF_TRUE;
             }
-    
-            u64 presentationTimeUs = ctx->counter * 1000000 / ctx->frame_rate;
-            ctx->counter++;
-                
-            if(AMediaCodec_queueInputBuffer(ctx->codec,
+			if(AMediaCodec_queueInputBuffer(ctx->codec,
                                     inIndex,
                                     0, 
                                     inBufferLength,
-                                    ctx->inputEOS ? 0 : presentationTimeUs,
+                                    0,
                                     inBuffer ? 0 : AMEDIACODEC_BUFFER_FLAG_END_OF_STREAM
                 ) != AMEDIA_OK)
                 {
@@ -617,12 +809,12 @@ static GF_Err MCDec_ProcessData(GF_MediaDecoder *ifcg,
     }
 
     if(!ctx->outputEOS) {
-
-        AMediaCodecBufferInfo info;
-        ssize_t outIndex = AMediaCodec_dequeueOutputBuffer(ctx->codec, &info, ctx->dequeue_timeout);
-        //LOGV("OutputIndex: %d", outIndex);
-
-        switch(outIndex) {
+		
+       
+        ctx->outIndex = AMediaCodec_dequeueOutputBuffer(ctx->codec, &ctx->info, ctx->dequeue_timeout);
+      
+		
+		switch(ctx->outIndex) {
 
             case AMEDIACODEC_INFO_OUTPUT_FORMAT_CHANGED:
                 LOGI("AMEDIACODEC_INFO_OUTPUT_FORMAT_CHANGED");
@@ -638,38 +830,36 @@ static GF_Err MCDec_ProcessData(GF_MediaDecoder *ifcg,
                 break;
 
             default:
+				if (ctx->outIndex >= 0) {
 
-                if (outIndex >= 0) {
-
-                    if(info.flags & AMEDIACODEC_BUFFER_FLAG_END_OF_STREAM) {
+                    if(ctx->info.flags & AMEDIACODEC_BUFFER_FLAG_END_OF_STREAM) {
                         LOGI("AMEDIACODEC_BUFFER_FLAG_END_OF_STREAM output");
                         ctx->outputEOS = true;
                     }
-
+					 LOGI("OutputIndex: %d", ctx->outIndex);
                     size_t outSize;
-                    uint8_t *buffer = AMediaCodec_getOutputBuffer(ctx->codec, outIndex, &outSize);
-
-                    if(!buffer) {
-                        LOGE("AMediaCodec_getOutputBuffer failed");
+                    uint8_t * buffer = AMediaCodec_getOutputBuffer(ctx->codec, ctx->outIndex, &outSize);
+					ctx->frame = buffer + ctx->info.offset;
+					
+                    if(!ctx->frame) {
+                        LOGI("AMediaCodec_getOutputBuffer failed");
                         *outBufferLength = 0;
                     } else {
-                        
-                        if(info.size < ctx->out_size)
-                            *outBufferLength = info.size;
+						
+                        if(ctx->info.size < ctx->out_size)
+                            *outBufferLength = ctx->info.size;
 
                         else *outBufferLength = ctx->out_size;
                     }
-
-                    memcpy(outBuffer, buffer, *outBufferLength);
-                    AMediaCodec_releaseOutputBuffer(ctx->codec, outIndex, false); 
-
-                } else{
-                    LOGE("Output Buffer not available");
-                }
+			}
+					
+			break;
+					
         }
 
     }
-    return GF_OK;        
+	
+	return GF_OK;        
 }
 
 
@@ -700,7 +890,80 @@ static u32 MCDec_CanHandleStream(GF_BaseDecoder *dec, u32 StreamType, GF_ESD *es
 
     return GF_CODEC_NOT_SUPPORTED;
 }
-
+void MCFrame_Release(GF_MediaDecoderFrame *frame)
+{	
+	MC_Frame *f = (MC_Frame *)frame->user_data;
+	if(f->ctx->codec )  {
+		if ( AMediaCodec_releaseOutputBuffer(f->ctx->codec, f->outIndex, false) != AMEDIA_OK) {
+			LOGI(" NOT Release Output Buffer Index: %d", f->outIndex);
+	}
+	f->ctx->decoded_frames_pending--;
+	}
+}
+GF_Err MCFrame_GetPlane(GF_MediaDecoderFrame *frame, u32 plane_idx, const char **outPlane, u32 *outStride)
+{
+	
+	GF_Err e;
+	MC_Frame *f = (MC_Frame *)frame->user_data;
+	int color;
+	if (! outPlane || !outStride) return GF_BAD_PARAM;
+	*outPlane = NULL;
+	*outStride = 0;
+	f->ctx->format = AMediaCodec_getOutputFormat(f->ctx->codec);
+	AMediaFormat_getInt32(f->ctx->format, AMEDIAFORMAT_KEY_STRIDE, outStride);
+	
+	switch(plane_idx) {
+		case 0 :
+			*outPlane = f->frame ;
+			break;
+		case 1 :
+			*outPlane = f->frame + *outStride * f->ctx->height ;
+			*outStride/=2;
+			break;
+		case 2: 
+			*outPlane = f->frame + 5 * *outStride * f->ctx->height/4 ;
+			*outStride/=2;
+			break;
+		default :
+			return GF_BAD_PARAM;
+			
+	}
+	
+	return GF_OK;
+}
+GF_Err MCDec_GetOutputFrame(GF_MediaDecoder *dec, u16 ES_ID, GF_MediaDecoderFrame **frame, Bool *needs_resize)
+{
+	GF_MediaDecoderFrame *a_frame;
+	MC_Frame *mc_frame;
+	ssize_t outSize;
+	MCDec *ctx = (MCDec *)dec->privateStack;
+
+	*needs_resize = GF_FALSE;
+	
+	
+	if (!ctx->frame) return GF_BAD_PARAM;
+	GF_SAFEALLOC(a_frame, GF_MediaDecoderFrame);
+	if (!a_frame) return GF_OUT_OF_MEM;
+	GF_SAFEALLOC(mc_frame, MC_Frame);
+	if (!mc_frame) {
+		gf_free(a_frame);
+		return GF_OUT_OF_MEM;
+	}
+	a_frame->user_data = mc_frame;
+	mc_frame->ctx = ctx;
+	mc_frame->frame = ctx->frame;
+	mc_frame->outIndex = ctx->outIndex;
+	ctx->frame = NULL;
+	a_frame->Release = MCFrame_Release;
+	a_frame->GetPlane = MCFrame_GetPlane;
+	*frame = a_frame;
+	if (ctx->frame_size_changed) {
+		ctx->frame_size_changed = GF_FALSE;
+		*needs_resize = GF_TRUE;
+	}
+	ctx->decoded_frames_pending++;
+	return GF_OK;
+}
 
 static const char *MCDec_GetCodecName(GF_BaseDecoder *dec)
 {   
@@ -743,24 +1006,41 @@ GF_BaseDecoder *NewMCDec()
     ifcd->GetName = MCDec_GetCodecName;
     ifcd->CanHandleStream = MCDec_CanHandleStream;
     ifcd->ProcessData = MCDec_ProcessData;
+	ifcd->GetOutputFrame = MCDec_GetOutputFrame;
     return (GF_BaseDecoder *) ifcd;
 }
-
+static void MCDec_DelParamList(GF_List *list)
+{
+	while (gf_list_count(list)) {
+		GF_AVCConfigSlot *slc = gf_list_get(list, 0);
+		gf_free(slc->data);
+		gf_free(slc);
+		gf_list_rem(list, 0);
+	}
+	
+	gf_list_del(list);
+	
+}
 
 void DeleteMCDec(GF_BaseDecoder *ifcg)
 {
     MCDec *ctx = (MCDec *)ifcg->privateStack;
 
-    if(AMediaFormat_delete(ctx->format) != AMEDIA_OK){
+    if(ctx->format && AMediaFormat_delete(ctx->format) != AMEDIA_OK){
         LOGE("AMediaFormat_delete failed");
     }
-    
+   
     if(ctx->codec && AMediaCodec_delete(ctx->codec) != AMEDIA_OK) {
         LOGE("AMediaCodec_delete failed");
     }
-
+	
     gf_free(ctx);
     gf_free(ifcg);
+	
+	MCDec_DelParamList(ctx->SPSs);
+	ctx->SPSs = NULL;
+	MCDec_DelParamList(ctx->PPSs);
+	ctx->PPSs = NULL;
 }
 
 
diff --git a/src/media_tools/av_parsers.c b/src/media_tools/av_parsers.c
index eae559dd2..5dbfef54b 100644
--- a/src/media_tools/av_parsers.c
+++ b/src/media_tools/av_parsers.c
@@ -2272,7 +2272,7 @@ s32 gf_media_avc_read_sps(const char *sps_data, u32 sps_size, AVCState *avc, u32
 	AVC_SPS *sps;
 	u32 ChromaArrayType = 0;
 	s32 mb_width, mb_height, sps_id = -1;
-	u32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl, cr, ct, cb, luma_bd, chroma_bd;
+	u32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl=0, cr=0, ct=0, cb=0, luma_bd, chroma_bd;
 	u8 separate_colour_plane_flag = 0;
 	GF_BitStream *bs;
 	char *sps_data_without_emulation_bytes = NULL;
@@ -2428,7 +2428,15 @@ s32 gf_media_avc_read_sps(const char *sps_data, u32 sps_size, AVCState *avc, u32
 
 		sps->width -= CropUnitX * (cl + cr);
 		sps->height -= CropUnitY * (ct + cb);
-	}
+		cl *= CropUnitX;
+		cr *= CropUnitX;
+		ct *= CropUnitY;
+		cb *= CropUnitY;
+	} 
+	sps->crop.left = cl;
+	sps->crop.right = cr;
+	sps->crop.top = ct;
+	sps->crop.bottom = cb;
 
 	if (vui_flag_pos) {
 		*vui_flag_pos = (u32) gf_bs_get_bit_offset(bs);
diff --git a/src/terminal/decoder.c b/src/terminal/decoder.c
index 2db7df145..de759716e 100644
--- a/src/terminal/decoder.c
+++ b/src/terminal/decoder.c
@@ -182,11 +182,12 @@ GF_Err gf_codec_add_channel(GF_Codec *codec, GF_Channel *ch)
 			ch->esd->service_url = (ch->odm && ch->odm->net_service) ? ch->odm->net_service->url : NULL;
 
 		//test code to force annexB format for AVC/SVC or HEVC/LHEVC streams
-#if 0
+#if GPAC_ANDROID
 			{
 				char *dsi = NULL;
 				GF_NetworkCommand com;
 				u32 len = 0;
+#if 0
 				if (ch->esd->decoderConfig->decoderSpecificInfo) {
 					dsi = ch->esd->decoderConfig->decoderSpecificInfo->data;
 					ch->esd->decoderConfig->decoderSpecificInfo->data = NULL;
@@ -198,6 +199,7 @@ GF_Err gf_codec_add_channel(GF_Codec *codec, GF_Channel *ch)
 					ch->esd->decoderConfig->decoderSpecificInfo->data = dsi;
 					ch->esd->decoderConfig->decoderSpecificInfo->dataLength = 0;
 				}
+#endif
 				memset(&com, 0, sizeof(GF_NetworkCommand));
 				com.command_type = GF_NET_CHAN_NALU_MODE;
 				com.nalu_mode.extract_mode = 1;
@@ -205,6 +207,8 @@ GF_Err gf_codec_add_channel(GF_Codec *codec, GF_Channel *ch)
 				gf_term_service_command(ch->service, &com);
 
 			}
+
+			e = codec->decio->AttachStream(codec->decio, ch->esd);
 #else
 			e = codec->decio->AttachStream(codec->decio, ch->esd);
 #endif

