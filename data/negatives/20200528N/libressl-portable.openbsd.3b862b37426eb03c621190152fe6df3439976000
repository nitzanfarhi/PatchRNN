commit 3b862b37426eb03c621190152fe6df3439976000
Author: jsing <>
Date:   Mon Apr 21 15:39:52 2014 +0000

    KNF.

diff --git a/src/lib/libcrypto/pem/pem.h b/src/lib/libcrypto/pem/pem.h
index e27440330..4af2db4b3 100644
--- a/src/lib/libcrypto/pem/pem.h
+++ b/src/lib/libcrypto/pem/pem.h
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -139,12 +139,11 @@ extern "C" {
 
   /* Note that this structure is initialised by PEM_SealInit and cleaned up
      by PEM_SealFinal (at least for now) */
-typedef struct PEM_Encode_Seal_st
-	{
+typedef struct PEM_Encode_Seal_st {
 	EVP_ENCODE_CTX encode;
 	EVP_MD_CTX md;
 	EVP_CIPHER_CTX cipher;
-	} PEM_ENCODE_SEAL_CTX;
+} PEM_ENCODE_SEAL_CTX;
 
 /* enc_type is one off */
 #define PEM_TYPE_ENCRYPTED      10
@@ -152,24 +151,22 @@ typedef struct PEM_Encode_Seal_st
 #define PEM_TYPE_MIC_CLEAR      30
 #define PEM_TYPE_CLEAR		40
 
-typedef struct pem_recip_st
-	{
+typedef struct pem_recip_st {
 	char *name;
 	X509_NAME *dn;
 
 	int cipher;
 	int key_enc;
 	/*	char iv[8]; unused and wrong size */
-	} PEM_USER;
+} PEM_USER;
 
-typedef struct pem_ctx_st
-	{
+typedef struct pem_ctx_st {
 	int type;		/* what type of object */
 
 	struct	{
-		int version;	
-		int mode;		
-		} proc_type;
+		int version;
+		int mode;
+	} proc_type;
 
 	char *domain;
 
@@ -177,14 +174,14 @@ typedef struct pem_ctx_st
 		int cipher;
 	/* unused, and wrong size
 	   unsigned char iv[8]; */
-		} DEK_info;
-		
+	} DEK_info;
+
 	PEM_USER *originator;
 
 	int num_recipient;
 	PEM_USER **recipient;
 
-	/* XXX(ben): don#t think this is used! 
+	/* XXX(ben): don#t think this is used!
 		STACK *x509_chain;	/ * certificate chain */
 	EVP_MD *md;		/* signature type */
 
@@ -198,11 +195,10 @@ typedef struct pem_ctx_st
 	/* unused, and wrong size
 	   unsigned char iv[8]; */
 
-	
 	int  data_enc;		/* is the data encrypted */
 	int data_len;
 	unsigned char *data;
-	} PEM_CTX;
+} PEM_CTX;
 
 /* These macros make the PEM_read/PEM_write functions easier to maintain and
  * write. Now they are all implemented with either:
@@ -223,7 +219,7 @@ typedef struct pem_ctx_st
 type *PEM_read_##name(FILE *fp, type **x, pem_password_cb *cb, void *u)\
 { \
 return PEM_ASN1_read((d2i_of_void *)d2i_##asn1, str,fp,(void **)x,cb,u); \
-} 
+}
 
 #define IMPLEMENT_PEM_write_fp(name, type, str, asn1) \
 int PEM_write_##name(FILE *fp, type *x) \
@@ -289,23 +285,23 @@ int PEM_write_bio_##name(BIO *bp, type *x, const EVP_CIPHER *enc, \
 
 #define IMPLEMENT_PEM_write(name, type, str, asn1) \
 	IMPLEMENT_PEM_write_bio(name, type, str, asn1) \
-	IMPLEMENT_PEM_write_fp(name, type, str, asn1) 
+	IMPLEMENT_PEM_write_fp(name, type, str, asn1)
 
 #define IMPLEMENT_PEM_write_const(name, type, str, asn1) \
 	IMPLEMENT_PEM_write_bio_const(name, type, str, asn1) \
-	IMPLEMENT_PEM_write_fp_const(name, type, str, asn1) 
+	IMPLEMENT_PEM_write_fp_const(name, type, str, asn1)
 
 #define IMPLEMENT_PEM_write_cb(name, type, str, asn1) \
 	IMPLEMENT_PEM_write_cb_bio(name, type, str, asn1) \
-	IMPLEMENT_PEM_write_cb_fp(name, type, str, asn1) 
+	IMPLEMENT_PEM_write_cb_fp(name, type, str, asn1)
 
 #define IMPLEMENT_PEM_write_cb_const(name, type, str, asn1) \
 	IMPLEMENT_PEM_write_cb_bio_const(name, type, str, asn1) \
-	IMPLEMENT_PEM_write_cb_fp_const(name, type, str, asn1) 
+	IMPLEMENT_PEM_write_cb_fp_const(name, type, str, asn1)
 
 #define IMPLEMENT_PEM_read(name, type, str, asn1) \
 	IMPLEMENT_PEM_read_bio(name, type, str, asn1) \
-	IMPLEMENT_PEM_read_fp(name, type, str, asn1) 
+	IMPLEMENT_PEM_read_fp(name, type, str, asn1)
 
 #define IMPLEMENT_PEM_rw(name, type, str, asn1) \
 	IMPLEMENT_PEM_read(name, type, str, asn1) \
@@ -369,7 +365,7 @@ int PEM_write_bio_##name(BIO *bp, type *x, const EVP_CIPHER *enc, \
 
 #define DECLARE_PEM_write(name, type) \
 	DECLARE_PEM_write_bio(name, type) \
-	DECLARE_PEM_write_fp(name, type) 
+	DECLARE_PEM_write_fp(name, type)
 
 #define DECLARE_PEM_write_const(name, type) \
 	DECLARE_PEM_write_bio_const(name, type) \
@@ -377,7 +373,7 @@ int PEM_write_bio_##name(BIO *bp, type *x, const EVP_CIPHER *enc, \
 
 #define DECLARE_PEM_write_cb(name, type) \
 	DECLARE_PEM_write_cb_bio(name, type) \
-	DECLARE_PEM_write_cb_fp(name, type) 
+	DECLARE_PEM_write_cb_fp(name, type)
 
 #define DECLARE_PEM_read(name, type) \
 	DECLARE_PEM_read_bio(name, type) \
@@ -404,50 +400,52 @@ typedef int pem_password_cb(char *buf, int size, int rwflag);
 #endif
 
 int	PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher);
-int	PEM_do_header (EVP_CIPHER_INFO *cipher, unsigned char *data,long *len,
-	pem_password_cb *callback,void *u);
+int	PEM_do_header (EVP_CIPHER_INFO *cipher, unsigned char *data, long *len,
+	    pem_password_cb *callback, void *u);
 
 #ifndef OPENSSL_NO_BIO
 int	PEM_read_bio(BIO *bp, char **name, char **header,
-		unsigned char **data,long *len);
-int	PEM_write_bio(BIO *bp,const char *name,char *hdr,unsigned char *data,
-		long len);
-int PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm, const char *name, BIO *bp,
-	     pem_password_cb *cb, void *u);
+	    unsigned char **data, long *len);
+int	PEM_write_bio(BIO *bp, const char *name, char *hdr, unsigned char *data,
+	    long len);
+int	PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm,
+	    const char *name, BIO *bp, pem_password_cb *cb, void *u);
 void *	PEM_ASN1_read_bio(d2i_of_void *d2i, const char *name, BIO *bp,
-			  void **x, pem_password_cb *cb, void *u);
-int	PEM_ASN1_write_bio(i2d_of_void *i2d,const char *name,BIO *bp, void *x,
-			   const EVP_CIPHER *enc,unsigned char *kstr,int klen,
-			   pem_password_cb *cb, void *u);
-
-STACK_OF(X509_INFO) *	PEM_X509_INFO_read_bio(BIO *bp, STACK_OF(X509_INFO) *sk, pem_password_cb *cb, void *u);
-int	PEM_X509_INFO_write_bio(BIO *bp,X509_INFO *xi, EVP_CIPHER *enc,
-		unsigned char *kstr, int klen, pem_password_cb *cd, void *u);
+	    void **x, pem_password_cb *cb, void *u);
+int	PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp, void *x,
+	    const EVP_CIPHER *enc, unsigned char *kstr, int klen,
+	    pem_password_cb *cb, void *u);
+
+STACK_OF(X509_INFO) *	PEM_X509_INFO_read_bio(BIO *bp,
+	    STACK_OF(X509_INFO) *sk, pem_password_cb *cb, void *u);
+int	PEM_X509_INFO_write_bio(BIO *bp, X509_INFO *xi, EVP_CIPHER *enc,
+	    unsigned char *kstr, int klen, pem_password_cb *cd, void *u);
 #endif
 
 int	PEM_read(FILE *fp, char **name, char **header,
-		unsigned char **data,long *len);
-int	PEM_write(FILE *fp,char *name,char *hdr,unsigned char *data,long len);
+	    unsigned char **data, long *len);
+int	PEM_write(FILE *fp, char *name, char *hdr, unsigned char *data,
+	    long len);
 void *  PEM_ASN1_read(d2i_of_void *d2i, const char *name, FILE *fp, void **x,
-		      pem_password_cb *cb, void *u);
-int	PEM_ASN1_write(i2d_of_void *i2d,const char *name,FILE *fp,
-		       void *x,const EVP_CIPHER *enc,unsigned char *kstr,
-		       int klen,pem_password_cb *callback, void *u);
+	    pem_password_cb *cb, void *u);
+int	PEM_ASN1_write(i2d_of_void *i2d, const char *name, FILE *fp,
+	    void *x, const EVP_CIPHER *enc, unsigned char *kstr,
+	    int klen, pem_password_cb *callback, void *u);
 STACK_OF(X509_INFO) *	PEM_X509_INFO_read(FILE *fp, STACK_OF(X509_INFO) *sk,
-	pem_password_cb *cb, void *u);
+	    pem_password_cb *cb, void *u);
 
 int	PEM_SealInit(PEM_ENCODE_SEAL_CTX *ctx, EVP_CIPHER *type,
-		EVP_MD *md_type, unsigned char **ek, int *ekl,
-		unsigned char *iv, EVP_PKEY **pubk, int npubk);
+	    EVP_MD *md_type, unsigned char **ek, int *ekl,
+	    unsigned char *iv, EVP_PKEY **pubk, int npubk);
 void	PEM_SealUpdate(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *out, int *outl,
-		unsigned char *in, int inl);
-int	PEM_SealFinal(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *sig,int *sigl,
-		unsigned char *out, int *outl, EVP_PKEY *priv);
+	    unsigned char *in, int inl);
+int	PEM_SealFinal(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *sig, int *sigl,
+	    unsigned char *out, int *outl, EVP_PKEY *priv);
 
 void    PEM_SignInit(EVP_MD_CTX *ctx, EVP_MD *type);
-void    PEM_SignUpdate(EVP_MD_CTX *ctx,unsigned char *d,unsigned int cnt);
+void    PEM_SignUpdate(EVP_MD_CTX *ctx, unsigned char *d, unsigned int cnt);
 int	PEM_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret,
-		unsigned int *siglen, EVP_PKEY *pkey);
+	    unsigned int *siglen, EVP_PKEY *pkey);
 
 int	PEM_def_callback(char *buf, int num, int w, void *key);
 void	PEM_proc_type(char *buf, int type);
@@ -509,32 +507,34 @@ DECLARE_PEM_rw_cb(PrivateKey, EVP_PKEY)
 DECLARE_PEM_rw(PUBKEY, EVP_PKEY)
 
 int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u);
+    char *kstr, int klen,
+    pem_password_cb *cb, void *u);
 int PEM_write_bio_PKCS8PrivateKey(BIO *, EVP_PKEY *, const EVP_CIPHER *,
-                                  char *, int, pem_password_cb *, void *);
+    char *, int, pem_password_cb *, void *);
 int i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u);
+    char *kstr, int klen,
+    pem_password_cb *cb, void *u);
 int i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u);
-EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u);
+    char *kstr, int klen,
+    pem_password_cb *cb, void *u);
+EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
+    void *u);
 
 int i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u);
+    char *kstr, int klen,
+    pem_password_cb *cb, void *u);
 int i2d_PKCS8PrivateKey_nid_fp(FILE *fp, EVP_PKEY *x, int nid,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u);
+    char *kstr, int klen,
+    pem_password_cb *cb, void *u);
 int PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u);
+    char *kstr, int klen,
+    pem_password_cb *cb, void *u);
 
-EVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u);
+EVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb,
+    void *u);
 
-int PEM_write_PKCS8PrivateKey(FILE *fp,EVP_PKEY *x,const EVP_CIPHER *enc,
-			      char *kstr,int klen, pem_password_cb *cd, void *u);
+int PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
+    char *kstr, int klen, pem_password_cb *cd, void *u);
 
 EVP_PKEY *PEM_read_bio_Parameters(BIO *bp, EVP_PKEY **x);
 int PEM_write_bio_Parameters(BIO *bp, EVP_PKEY *x);
@@ -548,8 +548,8 @@ int i2b_PrivateKey_bio(BIO *out, EVP_PKEY *pk);
 int i2b_PublicKey_bio(BIO *out, EVP_PKEY *pk);
 #ifndef OPENSSL_NO_RC4
 EVP_PKEY *b2i_PVK_bio(BIO *in, pem_password_cb *cb, void *u);
-int i2b_PVK_bio(BIO *out, EVP_PKEY *pk, int enclevel,
-		pem_password_cb *cb, void *u);
+int i2b_PVK_bio(BIO *out, EVP_PKEY *pk, int enclevel, pem_password_cb *cb,
+    void *u);
 #endif
 
 
diff --git a/src/lib/libcrypto/pem/pem2.h b/src/lib/libcrypto/pem/pem2.h
index f31790d69..84897d5ec 100644
--- a/src/lib/libcrypto/pem/pem2.h
+++ b/src/lib/libcrypto/pem/pem2.h
@@ -6,7 +6,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
+ *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
diff --git a/src/lib/libcrypto/pem/pem_all.c b/src/lib/libcrypto/pem/pem_all.c
index 6ff6be7fb..8b54d1a69 100644
--- a/src/lib/libcrypto/pem/pem_all.c
+++ b/src/lib/libcrypto/pem/pem_all.c
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -63,7 +63,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
+ *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -146,7 +146,7 @@ IMPLEMENT_PEM_rw(X509_CRL, X509_CRL, PEM_STRING_X509_CRL, X509_CRL)
 IMPLEMENT_PEM_rw(PKCS7, PKCS7, PEM_STRING_PKCS7, PKCS7)
 
 IMPLEMENT_PEM_rw(NETSCAPE_CERT_SEQUENCE, NETSCAPE_CERT_SEQUENCE,
-					PEM_STRING_X509, NETSCAPE_CERT_SEQUENCE)
+    PEM_STRING_X509, NETSCAPE_CERT_SEQUENCE)
 
 
 #ifndef OPENSSL_NO_RSA
@@ -159,34 +159,40 @@ IMPLEMENT_PEM_rw(NETSCAPE_CERT_SEQUENCE, NETSCAPE_CERT_SEQUENCE,
  * transparently.
  */
 
-static RSA *pkey_get_rsa(EVP_PKEY *key, RSA **rsa)
+static RSA *
+pkey_get_rsa(EVP_PKEY *key, RSA **rsa)
 {
 	RSA *rtmp;
-	if(!key) return NULL;
+
+	if (!key)
+		return NULL;
 	rtmp = EVP_PKEY_get1_RSA(key);
 	EVP_PKEY_free(key);
-	if(!rtmp) return NULL;
-	if(rsa) {
+	if (!rtmp)
+		return NULL;
+	if (rsa) {
 		RSA_free(*rsa);
 		*rsa = rtmp;
 	}
 	return rtmp;
 }
 
-RSA *PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **rsa, pem_password_cb *cb,
-								void *u)
+RSA *
+PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **rsa, pem_password_cb *cb, void *u)
 {
 	EVP_PKEY *pktmp;
+
 	pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
 	return pkey_get_rsa(pktmp, rsa);
 }
 
 #ifndef OPENSSL_NO_FP_API
 
-RSA *PEM_read_RSAPrivateKey(FILE *fp, RSA **rsa, pem_password_cb *cb,
-								void *u)
+RSA *
+PEM_read_RSAPrivateKey(FILE *fp, RSA **rsa, pem_password_cb *cb, void *u)
 {
 	EVP_PKEY *pktmp;
+
 	pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
 	return pkey_get_rsa(pktmp, rsa);
 }
@@ -202,24 +208,29 @@ IMPLEMENT_PEM_rw(RSA_PUBKEY, RSA, PEM_STRING_PUBLIC, RSA_PUBKEY)
 
 #ifndef OPENSSL_NO_DSA
 
-static DSA *pkey_get_dsa(EVP_PKEY *key, DSA **dsa)
+static DSA *
+pkey_get_dsa(EVP_PKEY *key, DSA **dsa)
 {
 	DSA *dtmp;
-	if(!key) return NULL;
+
+	if (!key)
+		return NULL;
 	dtmp = EVP_PKEY_get1_DSA(key);
 	EVP_PKEY_free(key);
-	if(!dtmp) return NULL;
-	if(dsa) {
+	if (!dtmp)
+		return NULL;
+	if (dsa) {
 		DSA_free(*dsa);
 		*dsa = dtmp;
 	}
 	return dtmp;
 }
 
-DSA *PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **dsa, pem_password_cb *cb,
-								void *u)
+DSA *
+PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **dsa, pem_password_cb *cb, void *u)
 {
 	EVP_PKEY *pktmp;
+
 	pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
 	return pkey_get_dsa(pktmp, dsa);	/* will free pktmp */
 }
@@ -230,10 +241,11 @@ IMPLEMENT_PEM_rw(DSA_PUBKEY, DSA, PEM_STRING_PUBLIC, DSA_PUBKEY)
 
 #ifndef OPENSSL_NO_FP_API
 
-DSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **dsa, pem_password_cb *cb,
-								void *u)
+DSA *
+PEM_read_DSAPrivateKey(FILE *fp, DSA **dsa, pem_password_cb *cb, void *u)
 {
 	EVP_PKEY *pktmp;
+
 	pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
 	return pkey_get_dsa(pktmp, dsa);	/* will free pktmp */
 }
@@ -246,43 +258,47 @@ IMPLEMENT_PEM_rw_const(DSAparams, DSA, PEM_STRING_DSAPARAMS, DSAparams)
 
 
 #ifndef OPENSSL_NO_EC
-static EC_KEY *pkey_get_eckey(EVP_PKEY *key, EC_KEY **eckey)
+static EC_KEY *
+pkey_get_eckey(EVP_PKEY *key, EC_KEY **eckey)
 {
 	EC_KEY *dtmp;
-	if(!key) return NULL;
+
+	if (!key)
+		return NULL;
 	dtmp = EVP_PKEY_get1_EC_KEY(key);
 	EVP_PKEY_free(key);
-	if(!dtmp) return NULL;
-	if(eckey) 
-	{
- 		EC_KEY_free(*eckey);
+	if (!dtmp)
+		return NULL;
+	if (eckey) {
+		EC_KEY_free(*eckey);
 		*eckey = dtmp;
 	}
 	return dtmp;
 }
 
-EC_KEY *PEM_read_bio_ECPrivateKey(BIO *bp, EC_KEY **key, pem_password_cb *cb,
-							void *u)
+EC_KEY *
+PEM_read_bio_ECPrivateKey(BIO *bp, EC_KEY **key, pem_password_cb *cb, void *u)
 {
 	EVP_PKEY *pktmp;
 	pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
 	return pkey_get_eckey(pktmp, key);	/* will free pktmp */
 }
 
-IMPLEMENT_PEM_rw_const(ECPKParameters, EC_GROUP, PEM_STRING_ECPARAMETERS, ECPKParameters)
+IMPLEMENT_PEM_rw_const(ECPKParameters, EC_GROUP, PEM_STRING_ECPARAMETERS,
+    ECPKParameters)
 
-
-
-IMPLEMENT_PEM_write_cb(ECPrivateKey, EC_KEY, PEM_STRING_ECPRIVATEKEY, ECPrivateKey)
+IMPLEMENT_PEM_write_cb(ECPrivateKey, EC_KEY, PEM_STRING_ECPRIVATEKEY,
+    ECPrivateKey)
 
 IMPLEMENT_PEM_rw(EC_PUBKEY, EC_KEY, PEM_STRING_PUBLIC, EC_PUBKEY)
 
 #ifndef OPENSSL_NO_FP_API
- 
-EC_KEY *PEM_read_ECPrivateKey(FILE *fp, EC_KEY **eckey, pem_password_cb *cb,
- 								void *u)
+
+EC_KEY *
+PEM_read_ECPrivateKey(FILE *fp, EC_KEY **eckey, pem_password_cb *cb, void *u)
 {
 	EVP_PKEY *pktmp;
+
 	pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
 	return pkey_get_eckey(pktmp, eckey);	/* will free pktmp */
 }
diff --git a/src/lib/libcrypto/pem/pem_err.c b/src/lib/libcrypto/pem/pem_err.c
index d644aeedd..8fa292fa3 100644
--- a/src/lib/libcrypto/pem/pem_err.c
+++ b/src/lib/libcrypto/pem/pem_err.c
@@ -7,7 +7,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
+ *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -68,94 +68,91 @@
 #define ERR_FUNC(func) ERR_PACK(ERR_LIB_PEM,func,0)
 #define ERR_REASON(reason) ERR_PACK(ERR_LIB_PEM,0,reason)
 
-static ERR_STRING_DATA PEM_str_functs[]=
-	{
-{ERR_FUNC(PEM_F_B2I_DSS),	"B2I_DSS"},
-{ERR_FUNC(PEM_F_B2I_PVK_BIO),	"b2i_PVK_bio"},
-{ERR_FUNC(PEM_F_B2I_RSA),	"B2I_RSA"},
-{ERR_FUNC(PEM_F_CHECK_BITLEN_DSA),	"CHECK_BITLEN_DSA"},
-{ERR_FUNC(PEM_F_CHECK_BITLEN_RSA),	"CHECK_BITLEN_RSA"},
-{ERR_FUNC(PEM_F_D2I_PKCS8PRIVATEKEY_BIO),	"d2i_PKCS8PrivateKey_bio"},
-{ERR_FUNC(PEM_F_D2I_PKCS8PRIVATEKEY_FP),	"d2i_PKCS8PrivateKey_fp"},
-{ERR_FUNC(PEM_F_DO_B2I),	"DO_B2I"},
-{ERR_FUNC(PEM_F_DO_B2I_BIO),	"DO_B2I_BIO"},
-{ERR_FUNC(PEM_F_DO_BLOB_HEADER),	"DO_BLOB_HEADER"},
-{ERR_FUNC(PEM_F_DO_PK8PKEY),	"DO_PK8PKEY"},
-{ERR_FUNC(PEM_F_DO_PK8PKEY_FP),	"DO_PK8PKEY_FP"},
-{ERR_FUNC(PEM_F_DO_PVK_BODY),	"DO_PVK_BODY"},
-{ERR_FUNC(PEM_F_DO_PVK_HEADER),	"DO_PVK_HEADER"},
-{ERR_FUNC(PEM_F_I2B_PVK),	"I2B_PVK"},
-{ERR_FUNC(PEM_F_I2B_PVK_BIO),	"i2b_PVK_bio"},
-{ERR_FUNC(PEM_F_LOAD_IV),	"LOAD_IV"},
-{ERR_FUNC(PEM_F_PEM_ASN1_READ),	"PEM_ASN1_read"},
-{ERR_FUNC(PEM_F_PEM_ASN1_READ_BIO),	"PEM_ASN1_read_bio"},
-{ERR_FUNC(PEM_F_PEM_ASN1_WRITE),	"PEM_ASN1_write"},
-{ERR_FUNC(PEM_F_PEM_ASN1_WRITE_BIO),	"PEM_ASN1_write_bio"},
-{ERR_FUNC(PEM_F_PEM_DEF_CALLBACK),	"PEM_def_callback"},
-{ERR_FUNC(PEM_F_PEM_DO_HEADER),	"PEM_do_header"},
-{ERR_FUNC(PEM_F_PEM_F_PEM_WRITE_PKCS8PRIVATEKEY),	"PEM_F_PEM_WRITE_PKCS8PRIVATEKEY"},
-{ERR_FUNC(PEM_F_PEM_GET_EVP_CIPHER_INFO),	"PEM_get_EVP_CIPHER_INFO"},
-{ERR_FUNC(PEM_F_PEM_PK8PKEY),	"PEM_PK8PKEY"},
-{ERR_FUNC(PEM_F_PEM_READ),	"PEM_read"},
-{ERR_FUNC(PEM_F_PEM_READ_BIO),	"PEM_read_bio"},
-{ERR_FUNC(PEM_F_PEM_READ_BIO_PARAMETERS),	"PEM_read_bio_Parameters"},
-{ERR_FUNC(PEM_F_PEM_READ_BIO_PRIVATEKEY),	"PEM_READ_BIO_PRIVATEKEY"},
-{ERR_FUNC(PEM_F_PEM_READ_PRIVATEKEY),	"PEM_READ_PRIVATEKEY"},
-{ERR_FUNC(PEM_F_PEM_SEALFINAL),	"PEM_SealFinal"},
-{ERR_FUNC(PEM_F_PEM_SEALINIT),	"PEM_SealInit"},
-{ERR_FUNC(PEM_F_PEM_SIGNFINAL),	"PEM_SignFinal"},
-{ERR_FUNC(PEM_F_PEM_WRITE),	"PEM_write"},
-{ERR_FUNC(PEM_F_PEM_WRITE_BIO),	"PEM_write_bio"},
-{ERR_FUNC(PEM_F_PEM_WRITE_PRIVATEKEY),	"PEM_WRITE_PRIVATEKEY"},
-{ERR_FUNC(PEM_F_PEM_X509_INFO_READ),	"PEM_X509_INFO_read"},
-{ERR_FUNC(PEM_F_PEM_X509_INFO_READ_BIO),	"PEM_X509_INFO_read_bio"},
-{ERR_FUNC(PEM_F_PEM_X509_INFO_WRITE_BIO),	"PEM_X509_INFO_write_bio"},
-{0,NULL}
-	};
+static ERR_STRING_DATA PEM_str_functs[] = {
+	{ERR_FUNC(PEM_F_B2I_DSS),	"B2I_DSS"},
+	{ERR_FUNC(PEM_F_B2I_PVK_BIO),	"b2i_PVK_bio"},
+	{ERR_FUNC(PEM_F_B2I_RSA),	"B2I_RSA"},
+	{ERR_FUNC(PEM_F_CHECK_BITLEN_DSA),	"CHECK_BITLEN_DSA"},
+	{ERR_FUNC(PEM_F_CHECK_BITLEN_RSA),	"CHECK_BITLEN_RSA"},
+	{ERR_FUNC(PEM_F_D2I_PKCS8PRIVATEKEY_BIO),	"d2i_PKCS8PrivateKey_bio"},
+	{ERR_FUNC(PEM_F_D2I_PKCS8PRIVATEKEY_FP),	"d2i_PKCS8PrivateKey_fp"},
+	{ERR_FUNC(PEM_F_DO_B2I),	"DO_B2I"},
+	{ERR_FUNC(PEM_F_DO_B2I_BIO),	"DO_B2I_BIO"},
+	{ERR_FUNC(PEM_F_DO_BLOB_HEADER),	"DO_BLOB_HEADER"},
+	{ERR_FUNC(PEM_F_DO_PK8PKEY),	"DO_PK8PKEY"},
+	{ERR_FUNC(PEM_F_DO_PK8PKEY_FP),	"DO_PK8PKEY_FP"},
+	{ERR_FUNC(PEM_F_DO_PVK_BODY),	"DO_PVK_BODY"},
+	{ERR_FUNC(PEM_F_DO_PVK_HEADER),	"DO_PVK_HEADER"},
+	{ERR_FUNC(PEM_F_I2B_PVK),	"I2B_PVK"},
+	{ERR_FUNC(PEM_F_I2B_PVK_BIO),	"i2b_PVK_bio"},
+	{ERR_FUNC(PEM_F_LOAD_IV),	"LOAD_IV"},
+	{ERR_FUNC(PEM_F_PEM_ASN1_READ),	"PEM_ASN1_read"},
+	{ERR_FUNC(PEM_F_PEM_ASN1_READ_BIO),	"PEM_ASN1_read_bio"},
+	{ERR_FUNC(PEM_F_PEM_ASN1_WRITE),	"PEM_ASN1_write"},
+	{ERR_FUNC(PEM_F_PEM_ASN1_WRITE_BIO),	"PEM_ASN1_write_bio"},
+	{ERR_FUNC(PEM_F_PEM_DEF_CALLBACK),	"PEM_def_callback"},
+	{ERR_FUNC(PEM_F_PEM_DO_HEADER),	"PEM_do_header"},
+	{ERR_FUNC(PEM_F_PEM_F_PEM_WRITE_PKCS8PRIVATEKEY),	"PEM_F_PEM_WRITE_PKCS8PRIVATEKEY"},
+	{ERR_FUNC(PEM_F_PEM_GET_EVP_CIPHER_INFO),	"PEM_get_EVP_CIPHER_INFO"},
+	{ERR_FUNC(PEM_F_PEM_PK8PKEY),	"PEM_PK8PKEY"},
+	{ERR_FUNC(PEM_F_PEM_READ),	"PEM_read"},
+	{ERR_FUNC(PEM_F_PEM_READ_BIO),	"PEM_read_bio"},
+	{ERR_FUNC(PEM_F_PEM_READ_BIO_PARAMETERS),	"PEM_read_bio_Parameters"},
+	{ERR_FUNC(PEM_F_PEM_READ_BIO_PRIVATEKEY),	"PEM_READ_BIO_PRIVATEKEY"},
+	{ERR_FUNC(PEM_F_PEM_READ_PRIVATEKEY),	"PEM_READ_PRIVATEKEY"},
+	{ERR_FUNC(PEM_F_PEM_SEALFINAL),	"PEM_SealFinal"},
+	{ERR_FUNC(PEM_F_PEM_SEALINIT),	"PEM_SealInit"},
+	{ERR_FUNC(PEM_F_PEM_SIGNFINAL),	"PEM_SignFinal"},
+	{ERR_FUNC(PEM_F_PEM_WRITE),	"PEM_write"},
+	{ERR_FUNC(PEM_F_PEM_WRITE_BIO),	"PEM_write_bio"},
+	{ERR_FUNC(PEM_F_PEM_WRITE_PRIVATEKEY),	"PEM_WRITE_PRIVATEKEY"},
+	{ERR_FUNC(PEM_F_PEM_X509_INFO_READ),	"PEM_X509_INFO_read"},
+	{ERR_FUNC(PEM_F_PEM_X509_INFO_READ_BIO),	"PEM_X509_INFO_read_bio"},
+	{ERR_FUNC(PEM_F_PEM_X509_INFO_WRITE_BIO),	"PEM_X509_INFO_write_bio"},
+	{0, NULL}
+};
 
-static ERR_STRING_DATA PEM_str_reasons[]=
-	{
-{ERR_REASON(PEM_R_BAD_BASE64_DECODE)     ,"bad base64 decode"},
-{ERR_REASON(PEM_R_BAD_DECRYPT)           ,"bad decrypt"},
-{ERR_REASON(PEM_R_BAD_END_LINE)          ,"bad end line"},
-{ERR_REASON(PEM_R_BAD_IV_CHARS)          ,"bad iv chars"},
-{ERR_REASON(PEM_R_BAD_MAGIC_NUMBER)      ,"bad magic number"},
-{ERR_REASON(PEM_R_BAD_PASSWORD_READ)     ,"bad password read"},
-{ERR_REASON(PEM_R_BAD_VERSION_NUMBER)    ,"bad version number"},
-{ERR_REASON(PEM_R_BIO_WRITE_FAILURE)     ,"bio write failure"},
-{ERR_REASON(PEM_R_CIPHER_IS_NULL)        ,"cipher is null"},
-{ERR_REASON(PEM_R_ERROR_CONVERTING_PRIVATE_KEY),"error converting private key"},
-{ERR_REASON(PEM_R_EXPECTING_PRIVATE_KEY_BLOB),"expecting private key blob"},
-{ERR_REASON(PEM_R_EXPECTING_PUBLIC_KEY_BLOB),"expecting public key blob"},
-{ERR_REASON(PEM_R_INCONSISTENT_HEADER)   ,"inconsistent header"},
-{ERR_REASON(PEM_R_KEYBLOB_HEADER_PARSE_ERROR),"keyblob header parse error"},
-{ERR_REASON(PEM_R_KEYBLOB_TOO_SHORT)     ,"keyblob too short"},
-{ERR_REASON(PEM_R_NOT_DEK_INFO)          ,"not dek info"},
-{ERR_REASON(PEM_R_NOT_ENCRYPTED)         ,"not encrypted"},
-{ERR_REASON(PEM_R_NOT_PROC_TYPE)         ,"not proc type"},
-{ERR_REASON(PEM_R_NO_START_LINE)         ,"no start line"},
-{ERR_REASON(PEM_R_PROBLEMS_GETTING_PASSWORD),"problems getting password"},
-{ERR_REASON(PEM_R_PUBLIC_KEY_NO_RSA)     ,"public key no rsa"},
-{ERR_REASON(PEM_R_PVK_DATA_TOO_SHORT)    ,"pvk data too short"},
-{ERR_REASON(PEM_R_PVK_TOO_SHORT)         ,"pvk too short"},
-{ERR_REASON(PEM_R_READ_KEY)              ,"read key"},
-{ERR_REASON(PEM_R_SHORT_HEADER)          ,"short header"},
-{ERR_REASON(PEM_R_UNSUPPORTED_CIPHER)    ,"unsupported cipher"},
-{ERR_REASON(PEM_R_UNSUPPORTED_ENCRYPTION),"unsupported encryption"},
-{ERR_REASON(PEM_R_UNSUPPORTED_KEY_COMPONENTS),"unsupported key components"},
-{0,NULL}
-	};
+static ERR_STRING_DATA PEM_str_reasons[] = {
+	{ERR_REASON(PEM_R_BAD_BASE64_DECODE)     , "bad base64 decode"},
+	{ERR_REASON(PEM_R_BAD_DECRYPT)           , "bad decrypt"},
+	{ERR_REASON(PEM_R_BAD_END_LINE)          , "bad end line"},
+	{ERR_REASON(PEM_R_BAD_IV_CHARS)          , "bad iv chars"},
+	{ERR_REASON(PEM_R_BAD_MAGIC_NUMBER)      , "bad magic number"},
+	{ERR_REASON(PEM_R_BAD_PASSWORD_READ)     , "bad password read"},
+	{ERR_REASON(PEM_R_BAD_VERSION_NUMBER)    , "bad version number"},
+	{ERR_REASON(PEM_R_BIO_WRITE_FAILURE)     , "bio write failure"},
+	{ERR_REASON(PEM_R_CIPHER_IS_NULL)        , "cipher is null"},
+	{ERR_REASON(PEM_R_ERROR_CONVERTING_PRIVATE_KEY), "error converting private key"},
+	{ERR_REASON(PEM_R_EXPECTING_PRIVATE_KEY_BLOB), "expecting private key blob"},
+	{ERR_REASON(PEM_R_EXPECTING_PUBLIC_KEY_BLOB), "expecting public key blob"},
+	{ERR_REASON(PEM_R_INCONSISTENT_HEADER)   , "inconsistent header"},
+	{ERR_REASON(PEM_R_KEYBLOB_HEADER_PARSE_ERROR), "keyblob header parse error"},
+	{ERR_REASON(PEM_R_KEYBLOB_TOO_SHORT)     , "keyblob too short"},
+	{ERR_REASON(PEM_R_NOT_DEK_INFO)          , "not dek info"},
+	{ERR_REASON(PEM_R_NOT_ENCRYPTED)         , "not encrypted"},
+	{ERR_REASON(PEM_R_NOT_PROC_TYPE)         , "not proc type"},
+	{ERR_REASON(PEM_R_NO_START_LINE)         , "no start line"},
+	{ERR_REASON(PEM_R_PROBLEMS_GETTING_PASSWORD), "problems getting password"},
+	{ERR_REASON(PEM_R_PUBLIC_KEY_NO_RSA)     , "public key no rsa"},
+	{ERR_REASON(PEM_R_PVK_DATA_TOO_SHORT)    , "pvk data too short"},
+	{ERR_REASON(PEM_R_PVK_TOO_SHORT)         , "pvk too short"},
+	{ERR_REASON(PEM_R_READ_KEY)              , "read key"},
+	{ERR_REASON(PEM_R_SHORT_HEADER)          , "short header"},
+	{ERR_REASON(PEM_R_UNSUPPORTED_CIPHER)    , "unsupported cipher"},
+	{ERR_REASON(PEM_R_UNSUPPORTED_ENCRYPTION), "unsupported encryption"},
+	{ERR_REASON(PEM_R_UNSUPPORTED_KEY_COMPONENTS), "unsupported key components"},
+	{0, NULL}
+};
 
 #endif
 
-void ERR_load_PEM_strings(void)
-	{
+void
+ERR_load_PEM_strings(void)
+{
 #ifndef OPENSSL_NO_ERR
-
-	if (ERR_func_error_string(PEM_str_functs[0].error) == NULL)
-		{
-		ERR_load_strings(0,PEM_str_functs);
-		ERR_load_strings(0,PEM_str_reasons);
-		}
-#endif
+	if (ERR_func_error_string(PEM_str_functs[0].error) == NULL) {
+		ERR_load_strings(0, PEM_str_functs);
+		ERR_load_strings(0, PEM_str_reasons);
 	}
+#endif
+}
diff --git a/src/lib/libcrypto/pem/pem_info.c b/src/lib/libcrypto/pem/pem_info.c
index 4351260df..967d6d2d4 100644
--- a/src/lib/libcrypto/pem/pem_info.c
+++ b/src/lib/libcrypto/pem/pem_info.c
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -71,324 +71,315 @@
 #endif
 
 #ifndef OPENSSL_NO_FP_API
-STACK_OF(X509_INFO) *PEM_X509_INFO_read(FILE *fp, STACK_OF(X509_INFO) *sk, pem_password_cb *cb, void *u)
-	{
-        BIO *b;
-        STACK_OF(X509_INFO) *ret;
+STACK_OF(X509_INFO) *
+PEM_X509_INFO_read(FILE *fp, STACK_OF(X509_INFO) *sk, pem_password_cb *cb,
+    void *u)
+{
+	BIO *b;
+	STACK_OF(X509_INFO) *ret;
 
-        if ((b=BIO_new(BIO_s_file())) == NULL)
-		{
-		PEMerr(PEM_F_PEM_X509_INFO_READ,ERR_R_BUF_LIB);
-                return(0);
-		}
-        BIO_set_fp(b,fp,BIO_NOCLOSE);
-        ret=PEM_X509_INFO_read_bio(b,sk,cb,u);
-        BIO_free(b);
-        return(ret);
+	if ((b = BIO_new(BIO_s_file())) == NULL) {
+		PEMerr(PEM_F_PEM_X509_INFO_READ, ERR_R_BUF_LIB);
+		return (0);
 	}
+	BIO_set_fp(b, fp, BIO_NOCLOSE);
+	ret = PEM_X509_INFO_read_bio(b, sk, cb, u);
+	BIO_free(b);
+	return (ret);
+}
 #endif
 
-STACK_OF(X509_INFO) *PEM_X509_INFO_read_bio(BIO *bp, STACK_OF(X509_INFO) *sk, pem_password_cb *cb, void *u)
-	{
-	X509_INFO *xi=NULL;
-	char *name=NULL,*header=NULL;
+STACK_OF(X509_INFO) *
+PEM_X509_INFO_read_bio(BIO *bp, STACK_OF(X509_INFO) *sk, pem_password_cb *cb,
+    void *u)
+{
+	X509_INFO *xi = NULL;
+	char *name = NULL, *header = NULL;
 	void *pp;
-	unsigned char *data=NULL;
+	unsigned char *data = NULL;
 	const unsigned char *p;
-	long len,error=0;
-	int ok=0;
-	STACK_OF(X509_INFO) *ret=NULL;
-	unsigned int i,raw,ptype;
+	long len, error = 0;
+	int ok = 0;
+	STACK_OF(X509_INFO) *ret = NULL;
+	unsigned int i, raw, ptype;
 	d2i_of_void *d2i = 0;
 
-	if (sk == NULL)
-		{
-		if ((ret=sk_X509_INFO_new_null()) == NULL)
-			{
-			PEMerr(PEM_F_PEM_X509_INFO_READ_BIO,ERR_R_MALLOC_FAILURE);
+	if (sk == NULL) {
+		if ((ret = sk_X509_INFO_new_null()) == NULL) {
+			PEMerr(PEM_F_PEM_X509_INFO_READ_BIO,
+			    ERR_R_MALLOC_FAILURE);
 			goto err;
-			}
 		}
-	else
-		ret=sk;
+	} else
+		ret = sk;
 
-	if ((xi=X509_INFO_new()) == NULL) goto err;
-	for (;;)
-		{
-		raw=0;
+	if ((xi = X509_INFO_new()) == NULL)
+		goto err;
+	for (;;) {
+		raw = 0;
 		ptype = 0;
-		i=PEM_read_bio(bp,&name,&header,&data,&len);
-		if (i == 0)
-			{
-			error=ERR_GET_REASON(ERR_peek_last_error());
-			if (error == PEM_R_NO_START_LINE)
-				{
+		i = PEM_read_bio(bp, &name, &header, &data, &len);
+		if (i == 0) {
+			error = ERR_GET_REASON(ERR_peek_last_error());
+			if (error == PEM_R_NO_START_LINE) {
 				ERR_clear_error();
 				break;
-				}
-			goto err;
 			}
+			goto err;
+		}
 start:
-		if (	(strcmp(name,PEM_STRING_X509) == 0) ||
-			(strcmp(name,PEM_STRING_X509_OLD) == 0))
-			{
-			d2i=(D2I_OF(void))d2i_X509;
-			if (xi->x509 != NULL)
-				{
-				if (!sk_X509_INFO_push(ret,xi)) goto err;
-				if ((xi=X509_INFO_new()) == NULL) goto err;
+		if ((strcmp(name, PEM_STRING_X509) == 0) ||
+		    (strcmp(name, PEM_STRING_X509_OLD) == 0)) {
+			d2i = (D2I_OF(void))d2i_X509;
+			if (xi->x509 != NULL) {
+				if (!sk_X509_INFO_push(ret, xi))
+					goto err;
+				if ((xi = X509_INFO_new()) == NULL)
+					goto err;
 				goto start;
-				}
-			pp=&(xi->x509);
 			}
-		else if ((strcmp(name,PEM_STRING_X509_TRUSTED) == 0))
-			{
-			d2i=(D2I_OF(void))d2i_X509_AUX;
-			if (xi->x509 != NULL)
-				{
-				if (!sk_X509_INFO_push(ret,xi)) goto err;
-				if ((xi=X509_INFO_new()) == NULL) goto err;
+			pp = &(xi->x509);
+		} else if ((strcmp(name, PEM_STRING_X509_TRUSTED) == 0)) {
+			d2i = (D2I_OF(void))d2i_X509_AUX;
+			if (xi->x509 != NULL) {
+				if (!sk_X509_INFO_push(ret, xi))
+					goto err;
+				if ((xi = X509_INFO_new()) == NULL)
+					goto err;
 				goto start;
-				}
-			pp=&(xi->x509);
 			}
-		else if (strcmp(name,PEM_STRING_X509_CRL) == 0)
-			{
-			d2i=(D2I_OF(void))d2i_X509_CRL;
-			if (xi->crl != NULL)
-				{
-				if (!sk_X509_INFO_push(ret,xi)) goto err;
-				if ((xi=X509_INFO_new()) == NULL) goto err;
+			pp = &(xi->x509);
+		} else if (strcmp(name, PEM_STRING_X509_CRL) == 0) {
+			d2i = (D2I_OF(void))d2i_X509_CRL;
+			if (xi->crl != NULL) {
+				if (!sk_X509_INFO_push(ret, xi))
+					goto err;
+				if ((xi = X509_INFO_new()) == NULL)
+					goto err;
 				goto start;
-				}
-			pp=&(xi->crl);
 			}
-		else
+			pp = &(xi->crl);
+		} else
 #ifndef OPENSSL_NO_RSA
-			if (strcmp(name,PEM_STRING_RSA) == 0)
-			{
-			d2i=(D2I_OF(void))d2i_RSAPrivateKey;
-			if (xi->x_pkey != NULL) 
-				{
-				if (!sk_X509_INFO_push(ret,xi)) goto err;
-				if ((xi=X509_INFO_new()) == NULL) goto err;
+		if (strcmp(name, PEM_STRING_RSA) == 0) {
+			d2i = (D2I_OF(void))d2i_RSAPrivateKey;
+			if (xi->x_pkey != NULL) {
+				if (!sk_X509_INFO_push(ret, xi))
+					goto err;
+				if ((xi = X509_INFO_new()) == NULL)
+					goto err;
 				goto start;
-				}
+			}
 
-			xi->enc_data=NULL;
-			xi->enc_len=0;
+			xi->enc_data = NULL;
+			xi->enc_len = 0;
 
-			xi->x_pkey=X509_PKEY_new();
-			ptype=EVP_PKEY_RSA;
-			pp=&xi->x_pkey->dec_pkey;
+			xi->x_pkey = X509_PKEY_new();
+			ptype = EVP_PKEY_RSA;
+			pp = &xi->x_pkey->dec_pkey;
 			if ((int)strlen(header) > 10) /* assume encrypted */
-				raw=1;
-			}
-		else
+				raw = 1;
+		} else
 #endif
 #ifndef OPENSSL_NO_DSA
-			if (strcmp(name,PEM_STRING_DSA) == 0)
-			{
-			d2i=(D2I_OF(void))d2i_DSAPrivateKey;
-			if (xi->x_pkey != NULL) 
-				{
-				if (!sk_X509_INFO_push(ret,xi)) goto err;
-				if ((xi=X509_INFO_new()) == NULL) goto err;
+		if (strcmp(name, PEM_STRING_DSA) == 0) {
+			d2i = (D2I_OF(void))d2i_DSAPrivateKey;
+			if (xi->x_pkey != NULL) {
+				if (!sk_X509_INFO_push(ret, xi))
+					goto err;
+				if ((xi = X509_INFO_new()) == NULL)
+					goto err;
 				goto start;
-				}
+			}
 
-			xi->enc_data=NULL;
-			xi->enc_len=0;
+			xi->enc_data = NULL;
+			xi->enc_len = 0;
 
-			xi->x_pkey=X509_PKEY_new();
+			xi->x_pkey = X509_PKEY_new();
 			ptype = EVP_PKEY_DSA;
-			pp=&xi->x_pkey->dec_pkey;
+			pp = &xi->x_pkey->dec_pkey;
 			if ((int)strlen(header) > 10) /* assume encrypted */
-				raw=1;
-			}
-		else
+				raw = 1;
+		} else
 #endif
 #ifndef OPENSSL_NO_EC
- 			if (strcmp(name,PEM_STRING_ECPRIVATEKEY) == 0)
- 			{
- 				d2i=(D2I_OF(void))d2i_ECPrivateKey;
- 				if (xi->x_pkey != NULL) 
- 				{
- 					if (!sk_X509_INFO_push(ret,xi)) goto err;
- 					if ((xi=X509_INFO_new()) == NULL) goto err;
- 						goto start;
- 				}
- 
- 			xi->enc_data=NULL;
- 			xi->enc_len=0;
- 
- 			xi->x_pkey=X509_PKEY_new();
-			ptype = EVP_PKEY_EC;
- 			pp=&xi->x_pkey->dec_pkey;
- 			if ((int)strlen(header) > 10) /* assume encrypted */
- 				raw=1;
+		if (strcmp(name, PEM_STRING_ECPRIVATEKEY) == 0) {
+			d2i = (D2I_OF(void))d2i_ECPrivateKey;
+			if (xi->x_pkey != NULL) {
+				if (!sk_X509_INFO_push(ret, xi))
+					goto err;
+				if ((xi = X509_INFO_new()) == NULL)
+					goto err;
+				goto start;
 			}
-		else
+
+			xi->enc_data = NULL;
+			xi->enc_len = 0;
+
+			xi->x_pkey = X509_PKEY_new();
+			ptype = EVP_PKEY_EC;
+			pp = &xi->x_pkey->dec_pkey;
+			if ((int)strlen(header) > 10) /* assume encrypted */
+				raw = 1;
+		} else
 #endif
-			{
-			d2i=NULL;
-			pp=NULL;
-			}
+		{
+			d2i = NULL;
+			pp = NULL;
+		}
 
-		if (d2i != NULL)
-			{
-			if (!raw)
-				{
+		if (d2i != NULL) {
+			if (!raw) {
 				EVP_CIPHER_INFO cipher;
 
-				if (!PEM_get_EVP_CIPHER_INFO(header,&cipher))
+				if (!PEM_get_EVP_CIPHER_INFO(header, &cipher))
 					goto err;
-				if (!PEM_do_header(&cipher,data,&len,cb,u))
+				if (!PEM_do_header(&cipher, data, &len, cb, u))
 					goto err;
-				p=data;
-				if (ptype)
-					{
-					if (!d2i_PrivateKey(ptype, pp, &p, len))
-						{
-						PEMerr(PEM_F_PEM_X509_INFO_READ_BIO,ERR_R_ASN1_LIB);
+				p = data;
+				if (ptype) {
+					if (!d2i_PrivateKey(ptype, pp, &p,
+					    len)) {
+						PEMerr(PEM_F_PEM_X509_INFO_READ_BIO, ERR_R_ASN1_LIB);
 						goto err;
-						}
 					}
-				else if (d2i(pp,&p,len) == NULL)
-					{
-					PEMerr(PEM_F_PEM_X509_INFO_READ_BIO,ERR_R_ASN1_LIB);
+				} else if (d2i(pp, &p, len) == NULL) {
+					PEMerr(PEM_F_PEM_X509_INFO_READ_BIO, ERR_R_ASN1_LIB);
 					goto err;
-					}
 				}
-			else
-				{ /* encrypted RSA data */
+			} else { /* encrypted RSA data */
 				if (!PEM_get_EVP_CIPHER_INFO(header,
-					&xi->enc_cipher)) goto err;
-				xi->enc_data=(char *)data;
-				xi->enc_len=(int)len;
-				data=NULL;
-				}
+				    &xi->enc_cipher))
+					goto err;
+				xi->enc_data = (char *)data;
+				xi->enc_len = (int)len;
+				data = NULL;
 			}
-		else	{
+		} else {
 			/* unknown */
-			}
-		if (name != NULL) free(name);
-		if (header != NULL) free(header);
-		if (data != NULL) free(data);
-		name=NULL;
-		header=NULL;
-		data=NULL;
 		}
+		if (name != NULL)
+			free(name);
+		if (header != NULL)
+			free(header);
+		if (data != NULL)
+			free(data);
+		name = NULL;
+		header = NULL;
+		data = NULL;
+	}
 
 	/* if the last one hasn't been pushed yet and there is anything
-	 * in it then add it to the stack ... 
+	 * in it then add it to the stack ...
 	 */
 	if ((xi->x509 != NULL) || (xi->crl != NULL) ||
-		(xi->x_pkey != NULL) || (xi->enc_data != NULL))
-		{
-		if (!sk_X509_INFO_push(ret,xi)) goto err;
-		xi=NULL;
-		}
-	ok=1;
+	    (xi->x_pkey != NULL) || (xi->enc_data != NULL)) {
+		if (!sk_X509_INFO_push(ret, xi))
+			goto err;
+		xi = NULL;
+	}
+	ok = 1;
+
 err:
-	if (xi != NULL) X509_INFO_free(xi);
-	if (!ok)
-		{
-		for (i=0; ((int)i)<sk_X509_INFO_num(ret); i++)
-			{
-			xi=sk_X509_INFO_value(ret,i);
+	if (xi != NULL)
+		X509_INFO_free(xi);
+	if (!ok) {
+		for (i = 0; ((int)i) < sk_X509_INFO_num(ret); i++) {
+			xi = sk_X509_INFO_value(ret, i);
 			X509_INFO_free(xi);
-			}
-		if (ret != sk) sk_X509_INFO_free(ret);
-		ret=NULL;
 		}
-		
-	if (name != NULL) free(name);
-	if (header != NULL) free(header);
-	if (data != NULL) free(data);
-	return(ret);
+		if (ret != sk)
+			sk_X509_INFO_free(ret);
+		ret = NULL;
 	}
 
+	if (name != NULL)
+		free(name);
+	if (header != NULL)
+		free(header);
+	if (data != NULL)
+		free(data);
+	return (ret);
+}
+
 
 /* A TJH addition */
-int PEM_X509_INFO_write_bio(BIO *bp, X509_INFO *xi, EVP_CIPHER *enc,
-	     unsigned char *kstr, int klen, pem_password_cb *cb, void *u)
-	{
+int
+PEM_X509_INFO_write_bio(BIO *bp, X509_INFO *xi, EVP_CIPHER *enc,
+    unsigned char *kstr, int klen, pem_password_cb *cb, void *u)
+{
 	EVP_CIPHER_CTX ctx;
-	int i,ret=0;
-	unsigned char *data=NULL;
-	const char *objstr=NULL;
+	int i, ret = 0;
+	unsigned char *data = NULL;
+	const char *objstr = NULL;
 	char buf[PEM_BUFSIZE];
-	unsigned char *iv=NULL;
-	
-	if (enc != NULL)
-		{
-		objstr=OBJ_nid2sn(EVP_CIPHER_nid(enc));
-		if (objstr == NULL)
-			{
-			PEMerr(PEM_F_PEM_X509_INFO_WRITE_BIO,PEM_R_UNSUPPORTED_CIPHER);
+	unsigned char *iv = NULL;
+
+	if (enc != NULL) {
+		objstr = OBJ_nid2sn(EVP_CIPHER_nid(enc));
+		if (objstr == NULL) {
+			PEMerr(PEM_F_PEM_X509_INFO_WRITE_BIO,
+			    PEM_R_UNSUPPORTED_CIPHER);
 			goto err;
-			}
 		}
+	}
 
-	/* now for the fun part ... if we have a private key then 
+	/* now for the fun part ... if we have a private key then
 	 * we have to be able to handle a not-yet-decrypted key
 	 * being written out correctly ... if it is decrypted or
 	 * it is non-encrypted then we use the base code
 	 */
-	if (xi->x_pkey!=NULL)
-		{
-		if ( (xi->enc_data!=NULL) && (xi->enc_len>0) )
-			{
-			if (enc == NULL)
-				{
-				PEMerr(PEM_F_PEM_X509_INFO_WRITE_BIO,PEM_R_CIPHER_IS_NULL);
+	if (xi->x_pkey != NULL) {
+		if ((xi->enc_data != NULL) && (xi->enc_len > 0) ) {
+			if (enc == NULL) {
+				PEMerr(PEM_F_PEM_X509_INFO_WRITE_BIO,
+				    PEM_R_CIPHER_IS_NULL);
 				goto err;
-				}
+			}
 
 			/* copy from weirdo names into more normal things */
-			iv=xi->enc_cipher.iv;
-			data=(unsigned char *)xi->enc_data;
-			i=xi->enc_len;
+			iv = xi->enc_cipher.iv;
+			data = (unsigned char *)xi->enc_data;
+			i = xi->enc_len;
 
 			/* we take the encryption data from the
 			 * internal stuff rather than what the
-			 * user has passed us ... as we have to 
+			 * user has passed us ... as we have to
 			 * match exactly for some strange reason
 			 */
-			objstr=OBJ_nid2sn(
-				EVP_CIPHER_nid(xi->enc_cipher.cipher));
-			if (objstr == NULL)
-				{
-				PEMerr(PEM_F_PEM_X509_INFO_WRITE_BIO,PEM_R_UNSUPPORTED_CIPHER);
+			objstr = OBJ_nid2sn(
+			    EVP_CIPHER_nid(xi->enc_cipher.cipher));
+			if (objstr == NULL) {
+				PEMerr(PEM_F_PEM_X509_INFO_WRITE_BIO,
+				    PEM_R_UNSUPPORTED_CIPHER);
 				goto err;
-				}
+			}
 
 			/* create the right magic header stuff */
-			OPENSSL_assert(strlen(objstr)+23+2*enc->iv_len+13 <= sizeof buf);
-			buf[0]='\0';
-			PEM_proc_type(buf,PEM_TYPE_ENCRYPTED);
-			PEM_dek_info(buf,objstr,enc->iv_len,(char *)iv);
+			OPENSSL_assert(strlen(objstr) + 23 +
+			    2 * enc->iv_len + 13 <= sizeof buf);
+			buf[0] = '\0';
+			PEM_proc_type(buf, PEM_TYPE_ENCRYPTED);
+			PEM_dek_info(buf, objstr, enc->iv_len, (char *)iv);
 
 			/* use the normal code to write things out */
-			i=PEM_write_bio(bp,PEM_STRING_RSA,buf,data,i);
-			if (i <= 0) goto err;
-			}
-		else
-			{
+			i = PEM_write_bio(bp, PEM_STRING_RSA, buf, data, i);
+			if (i <= 0)
+				goto err;
+		} else {
 			/* Add DSA/DH */
 #ifndef OPENSSL_NO_RSA
 			/* normal optionally encrypted stuff */
 			if (PEM_write_bio_RSAPrivateKey(bp,
-				xi->x_pkey->dec_pkey->pkey.rsa,
-				enc,kstr,klen,cb,u)<=0)
+			    xi->x_pkey->dec_pkey->pkey.rsa,
+			    enc, kstr, klen, cb, u) <= 0)
 				goto err;
 #endif
-			}
 		}
+	}
 
 	/* if we have a certificate then write it out now */
-	if ((xi->x509 != NULL) && (PEM_write_bio_X509(bp,xi->x509) <= 0))
+	if ((xi->x509 != NULL) && (PEM_write_bio_X509(bp, xi->x509) <= 0))
 		goto err;
 
 	/* we are ignoring anything else that is loaded into the X509_INFO
@@ -397,10 +388,10 @@ int PEM_X509_INFO_write_bio(BIO *bp, X509_INFO *xi, EVP_CIPHER *enc,
 	 * base library --tjh
 	 */
 
-	ret=1;
+	ret = 1;
 
 err:
-	OPENSSL_cleanse((char *)&ctx,sizeof(ctx));
-	OPENSSL_cleanse(buf,PEM_BUFSIZE);
-	return(ret);
-	}
+	OPENSSL_cleanse((char *)&ctx, sizeof(ctx));
+	OPENSSL_cleanse(buf, PEM_BUFSIZE);
+	return (ret);
+}
diff --git a/src/lib/libcrypto/pem/pem_lib.c b/src/lib/libcrypto/pem/pem_lib.c
index 93736455f..9d5d8e714 100644
--- a/src/lib/libcrypto/pem/pem_lib.c
+++ b/src/lib/libcrypto/pem/pem_lib.c
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -74,132 +74,132 @@
 #include <openssl/engine.h>
 #endif
 
-const char PEM_version[]="PEM" OPENSSL_VERSION_PTEXT;
+const char PEM_version[] = "PEM" OPENSSL_VERSION_PTEXT;
 
 #define MIN_LENGTH	4
 
-static int load_iv(char **fromp,unsigned char *to, int num);
+static int load_iv(char **fromp, unsigned char *to, int num);
 static int check_pem(const char *nm, const char *name);
 int pem_check_suffix(const char *pem_str, const char *suffix);
 
-int PEM_def_callback(char *buf, int num, int w, void *key)
-	{
+int
+PEM_def_callback(char *buf, int num, int w, void *key)
+{
 #ifdef OPENSSL_NO_FP_API
 	/* We should not ever call the default callback routine from
 	 * windows. */
-	PEMerr(PEM_F_PEM_DEF_CALLBACK,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
-	return(-1);
+	PEMerr(PEM_F_PEM_DEF_CALLBACK, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+	return (-1);
 #else
-	int i,j;
+	int i, j;
 	const char *prompt;
-	if(key) {
-		i=strlen(key);
-		i=(i > num)?num:i;
-		memcpy(buf,key,i);
-		return(i);
+
+	if (key) {
+		i = strlen(key);
+		i = (i > num) ? num : i;
+		memcpy(buf, key, i);
+		return (i);
 	}
 
-	prompt=EVP_get_pw_prompt();
+	prompt = EVP_get_pw_prompt();
 	if (prompt == NULL)
-		prompt="Enter PEM pass phrase:";
-
-	for (;;)
-		{
-		i=EVP_read_pw_string_min(buf,MIN_LENGTH,num,prompt,w);
-		if (i != 0)
-			{
-			PEMerr(PEM_F_PEM_DEF_CALLBACK,PEM_R_PROBLEMS_GETTING_PASSWORD);
-			memset(buf,0,(unsigned int)num);
-			return(-1);
-			}
-		j=strlen(buf);
-		if (j < MIN_LENGTH)
-			{
-			fprintf(stderr,"phrase is too short, needs to be at least %d chars\n",MIN_LENGTH);
-			}
-		else
+		prompt = "Enter PEM pass phrase:";
+
+	for (;;) {
+		i = EVP_read_pw_string_min(buf, MIN_LENGTH, num, prompt, w);
+		if (i != 0) {
+			PEMerr(PEM_F_PEM_DEF_CALLBACK,
+			    PEM_R_PROBLEMS_GETTING_PASSWORD);
+			memset(buf, 0, (unsigned int)num);
+			return (-1);
+		}
+		j = strlen(buf);
+		if (j < MIN_LENGTH) {
+			fprintf(stderr, "phrase is too short, needs to be at least %d chars\n", MIN_LENGTH);
+		} else
 			break;
-		}
-	return(j);
-#endif
 	}
+	return (j);
+#endif
+}
 
-void PEM_proc_type(char *buf, int type)
-	{
+void
+PEM_proc_type(char *buf, int type)
+{
 	const char *str;
 
 	if (type == PEM_TYPE_ENCRYPTED)
-		str="ENCRYPTED";
+		str = "ENCRYPTED";
 	else if (type == PEM_TYPE_MIC_CLEAR)
-		str="MIC-CLEAR";
+		str = "MIC-CLEAR";
 	else if (type == PEM_TYPE_MIC_ONLY)
-		str="MIC-ONLY";
+		str = "MIC-ONLY";
 	else
-		str="BAD-TYPE";
-		
-	strlcat(buf,"Proc-Type: 4,",PEM_BUFSIZE);
-	strlcat(buf,str,PEM_BUFSIZE);
-	strlcat(buf,"\n",PEM_BUFSIZE);
-	}
+		str = "BAD-TYPE";
+
+	strlcat(buf, "Proc-Type: 4,", PEM_BUFSIZE);
+	strlcat(buf, str, PEM_BUFSIZE);
+	strlcat(buf, "\n", PEM_BUFSIZE);
+}
 
-void PEM_dek_info(char *buf, const char *type, int len, char *str)
-	{
-	static const unsigned char map[17]="0123456789ABCDEF";
+void
+PEM_dek_info(char *buf, const char *type, int len, char *str)
+{
+	static const unsigned char map[17] = "0123456789ABCDEF";
 	long i;
 	int j;
 
-	strlcat(buf,"DEK-Info: ",PEM_BUFSIZE);
-	strlcat(buf,type,PEM_BUFSIZE);
-	strlcat(buf,",",PEM_BUFSIZE);
-	j=strlen(buf);
+	strlcat(buf, "DEK-Info: ", PEM_BUFSIZE);
+	strlcat(buf, type, PEM_BUFSIZE);
+	strlcat(buf, ",", PEM_BUFSIZE);
+	j = strlen(buf);
 	if (j + (len * 2) + 1 > PEM_BUFSIZE)
-        	return;
-	for (i=0; i<len; i++)
-		{
-		buf[j+i*2]  =map[(str[i]>>4)&0x0f];
-		buf[j+i*2+1]=map[(str[i]   )&0x0f];
-		}
-	buf[j+i*2]='\n';
-	buf[j+i*2+1]='\0';
+		return;
+	for (i = 0; i < len; i++) {
+		buf[j + i * 2] = map[(str[i] >> 4) & 0x0f];
+		buf[j + i * 2 + 1] = map[(str[i]) & 0x0f];
 	}
+	buf[j + i * 2] = '\n';
+	buf[j + i * 2 + 1] = '\0';
+}
 
 #ifndef OPENSSL_NO_FP_API
-void *PEM_ASN1_read(d2i_of_void *d2i, const char *name, FILE *fp, void **x,
-		    pem_password_cb *cb, void *u)
-	{
-        BIO *b;
-        void *ret;
-
-        if ((b=BIO_new(BIO_s_file())) == NULL)
-		{
-		PEMerr(PEM_F_PEM_ASN1_READ,ERR_R_BUF_LIB);
-                return(0);
-		}
-        BIO_set_fp(b,fp,BIO_NOCLOSE);
-        ret=PEM_ASN1_read_bio(d2i,name,b,x,cb,u);
-        BIO_free(b);
-        return(ret);
+void *
+PEM_ASN1_read(d2i_of_void *d2i, const char *name, FILE *fp, void **x,
+    pem_password_cb *cb, void *u)
+{
+	BIO *b;
+	void *ret;
+
+	if ((b = BIO_new(BIO_s_file())) == NULL) {
+		PEMerr(PEM_F_PEM_ASN1_READ, ERR_R_BUF_LIB);
+		return (0);
 	}
+	BIO_set_fp(b, fp, BIO_NOCLOSE);
+	ret = PEM_ASN1_read_bio(d2i, name, b, x, cb, u);
+	BIO_free(b);
+	return (ret);
+}
 #endif
 
-static int check_pem(const char *nm, const char *name)
+static int
+check_pem(const char *nm, const char *name)
 {
 	/* Normal matching nm and name */
-	if (!strcmp(nm,name)) return 1;
+	if (!strcmp(nm, name))
+		return 1;
 
 	/* Make PEM_STRING_EVP_PKEY match any private key */
 
-	if(!strcmp(name,PEM_STRING_EVP_PKEY))
-		{
+	if (!strcmp(name, PEM_STRING_EVP_PKEY)) {
 		int slen;
 		const EVP_PKEY_ASN1_METHOD *ameth;
-		if(!strcmp(nm,PEM_STRING_PKCS8))
+		if (!strcmp(nm, PEM_STRING_PKCS8))
 			return 1;
-		if(!strcmp(nm,PEM_STRING_PKCS8INF))
+		if (!strcmp(nm, PEM_STRING_PKCS8INF))
 			return 1;
-		slen = pem_check_suffix(nm, "PRIVATE KEY"); 
-		if (slen > 0)
-			{
+		slen = pem_check_suffix(nm, "PRIVATE KEY");
+		if (slen > 0) {
 			/* NB: ENGINE implementations wont contain
 			 * a deprecated old private key decode function
 			 * so don't look for them.
@@ -207,21 +207,18 @@ static int check_pem(const char *nm, const char *name)
 			ameth = EVP_PKEY_asn1_find_str(NULL, nm, slen);
 			if (ameth && ameth->old_priv_decode)
 				return 1;
-			}
-		return 0;
 		}
+		return 0;
+	}
 
-	if(!strcmp(name,PEM_STRING_PARAMETERS))
-		{
+	if (!strcmp(name, PEM_STRING_PARAMETERS)) {
 		int slen;
 		const EVP_PKEY_ASN1_METHOD *ameth;
-		slen = pem_check_suffix(nm, "PARAMETERS"); 
-		if (slen > 0)
-			{
+		slen = pem_check_suffix(nm, "PARAMETERS");
+		if (slen > 0) {
 			ENGINE *e;
 			ameth = EVP_PKEY_asn1_find_str(&e, nm, slen);
-			if (ameth)
-				{
+			if (ameth) {
 				int r;
 				if (ameth->param_decode)
 					r = 1;
@@ -232,68 +229,79 @@ static int check_pem(const char *nm, const char *name)
 					ENGINE_finish(e);
 #endif
 				return r;
-				}
 			}
-		return 0;
 		}
+		return 0;
+	}
 
 	/* Permit older strings */
 
-	if(!strcmp(nm,PEM_STRING_X509_OLD) &&
-		!strcmp(name,PEM_STRING_X509)) return 1;
+	if (!strcmp(nm, PEM_STRING_X509_OLD) &&
+	    !strcmp(name, PEM_STRING_X509))
+		return 1;
 
-	if(!strcmp(nm,PEM_STRING_X509_REQ_OLD) &&
-		!strcmp(name,PEM_STRING_X509_REQ)) return 1;
+	if (!strcmp(nm, PEM_STRING_X509_REQ_OLD) &&
+	    !strcmp(name, PEM_STRING_X509_REQ))
+		return 1;
 
 	/* Allow normal certs to be read as trusted certs */
-	if(!strcmp(nm,PEM_STRING_X509) &&
-		!strcmp(name,PEM_STRING_X509_TRUSTED)) return 1;
+	if (!strcmp(nm, PEM_STRING_X509) &&
+	    !strcmp(name, PEM_STRING_X509_TRUSTED))
+		return 1;
 
-	if(!strcmp(nm,PEM_STRING_X509_OLD) &&
-		!strcmp(name,PEM_STRING_X509_TRUSTED)) return 1;
+	if (!strcmp(nm, PEM_STRING_X509_OLD) &&
+	    !strcmp(name, PEM_STRING_X509_TRUSTED))
+		return 1;
 
 	/* Some CAs use PKCS#7 with CERTIFICATE headers */
-	if(!strcmp(nm, PEM_STRING_X509) &&
-		!strcmp(name, PEM_STRING_PKCS7)) return 1;
+	if (!strcmp(nm, PEM_STRING_X509) &&
+	    !strcmp(name, PEM_STRING_PKCS7))
+		return 1;
 
-	if(!strcmp(nm, PEM_STRING_PKCS7_SIGNED) &&
-		!strcmp(name, PEM_STRING_PKCS7)) return 1;
+	if (!strcmp(nm, PEM_STRING_PKCS7_SIGNED) &&
+	    !strcmp(name, PEM_STRING_PKCS7))
+		return 1;
 
 #ifndef OPENSSL_NO_CMS
-	if(!strcmp(nm, PEM_STRING_X509) &&
-		!strcmp(name, PEM_STRING_CMS)) return 1;
+	if (!strcmp(nm, PEM_STRING_X509) &&
+	    !strcmp(name, PEM_STRING_CMS))
+		return 1;
 	/* Allow CMS to be read from PKCS#7 headers */
-	if(!strcmp(nm, PEM_STRING_PKCS7) &&
-		!strcmp(name, PEM_STRING_CMS)) return 1;
+	if (!strcmp(nm, PEM_STRING_PKCS7) &&
+	    !strcmp(name, PEM_STRING_CMS))
+		return 1;
 #endif
 
 	return 0;
 }
 
-int PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm, const char *name, BIO *bp,
-	     pem_password_cb *cb, void *u)
-	{
+int
+PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm,
+    const char *name, BIO *bp, pem_password_cb *cb, void *u)
+{
 	EVP_CIPHER_INFO cipher;
-	char *nm=NULL,*header=NULL;
-	unsigned char *data=NULL;
+	char *nm = NULL, *header = NULL;
+	unsigned char *data = NULL;
 	long len;
 	int ret = 0;
 
-	for (;;)
-		{
-		if (!PEM_read_bio(bp,&nm,&header,&data,&len)) {
-			if(ERR_GET_REASON(ERR_peek_error()) ==
-				PEM_R_NO_START_LINE)
+	for (;;) {
+		if (!PEM_read_bio(bp, &nm, &header, &data, &len)) {
+			if (ERR_GET_REASON(ERR_peek_error()) ==
+			    PEM_R_NO_START_LINE)
 				ERR_add_error_data(2, "Expecting: ", name);
 			return 0;
 		}
-		if(check_pem(nm, name)) break;
+		if (check_pem(nm, name))
+			break;
 		free(nm);
 		free(header);
 		free(data);
-		}
-	if (!PEM_get_EVP_CIPHER_INFO(header,&cipher)) goto err;
-	if (!PEM_do_header(&cipher,data,&len,cb,u)) goto err;
+	}
+	if (!PEM_get_EVP_CIPHER_INFO(header, &cipher))
+		goto err;
+	if (!PEM_do_header(&cipher, data, &len, cb, u))
+		goto err;
 
 	*pdata = data;
 	*plen = len;
@@ -304,532 +312,553 @@ int PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm, const char
 	ret = 1;
 
 err:
-	if (!ret || !pnm) free(nm);
+	if (!ret || !pnm)
+		free(nm);
 	free(header);
-	if (!ret) free(data);
+	if (!ret)
+		free(data);
 	return ret;
-	}
+}
 
 #ifndef OPENSSL_NO_FP_API
-int PEM_ASN1_write(i2d_of_void *i2d, const char *name, FILE *fp,
-		   void *x, const EVP_CIPHER *enc, unsigned char *kstr,
-		   int klen, pem_password_cb *callback, void *u)
-        {
-        BIO *b;
-        int ret;
-
-        if ((b=BIO_new(BIO_s_file())) == NULL)
-		{
-		PEMerr(PEM_F_PEM_ASN1_WRITE,ERR_R_BUF_LIB);
-                return(0);
-		}
-        BIO_set_fp(b,fp,BIO_NOCLOSE);
-        ret=PEM_ASN1_write_bio(i2d,name,b,x,enc,kstr,klen,callback,u);
-        BIO_free(b);
-        return(ret);
-        }
+int
+PEM_ASN1_write(i2d_of_void *i2d, const char *name, FILE *fp, void *x,
+    const EVP_CIPHER *enc, unsigned char *kstr, int klen,
+    pem_password_cb *callback, void *u)
+{
+	BIO *b;
+	int ret;
+
+	if ((b = BIO_new(BIO_s_file())) == NULL) {
+		PEMerr(PEM_F_PEM_ASN1_WRITE, ERR_R_BUF_LIB);
+		return (0);
+	}
+	BIO_set_fp(b, fp, BIO_NOCLOSE);
+	ret = PEM_ASN1_write_bio(i2d, name, b, x, enc, kstr, klen, callback, u);
+	BIO_free(b);
+	return (ret);
+}
 #endif
 
-int PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp,
-		       void *x, const EVP_CIPHER *enc, unsigned char *kstr,
-		       int klen, pem_password_cb *callback, void *u)
-	{
+int
+PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp, void *x,
+    const EVP_CIPHER *enc, unsigned char *kstr, int klen,
+    pem_password_cb *callback, void *u)
+{
 	EVP_CIPHER_CTX ctx;
-	int dsize=0,i,j,ret=0;
-	unsigned char *p,*data=NULL;
-	const char *objstr=NULL;
+	int dsize = 0, i, j, ret = 0;
+	unsigned char *p, *data = NULL;
+	const char *objstr = NULL;
 	char buf[PEM_BUFSIZE];
 	unsigned char key[EVP_MAX_KEY_LENGTH];
 	unsigned char iv[EVP_MAX_IV_LENGTH];
-	
-	if (enc != NULL)
-		{
-		objstr=OBJ_nid2sn(EVP_CIPHER_nid(enc));
-		if (objstr == NULL)
-			{
-			PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,PEM_R_UNSUPPORTED_CIPHER);
+
+	if (enc != NULL) {
+		objstr = OBJ_nid2sn(EVP_CIPHER_nid(enc));
+		if (objstr == NULL) {
+			PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,
+			    PEM_R_UNSUPPORTED_CIPHER);
 			goto err;
-			}
 		}
+	}
 
-	if ((dsize=i2d(x,NULL)) < 0)
-		{
-		PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,ERR_R_ASN1_LIB);
-		dsize=0;
+	if ((dsize = i2d(x, NULL)) < 0) {
+		PEMerr(PEM_F_PEM_ASN1_WRITE_BIO, ERR_R_ASN1_LIB);
+		dsize = 0;
 		goto err;
-		}
+	}
 	/* dzise + 8 bytes are needed */
 	/* actually it needs the cipher block size extra... */
-	data=(unsigned char *)malloc((unsigned int)dsize+20);
-	if (data == NULL)
-		{
-		PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,ERR_R_MALLOC_FAILURE);
+	data = (unsigned char *)malloc((unsigned int)dsize + 20);
+	if (data == NULL) {
+		PEMerr(PEM_F_PEM_ASN1_WRITE_BIO, ERR_R_MALLOC_FAILURE);
 		goto err;
-		}
-	p=data;
-	i=i2d(x,&p);
+	}
+	p = data;
+	i = i2d(x, &p);
 
-	if (enc != NULL)
-		{
-		if (kstr == NULL)
-			{
+	if (enc != NULL) {
+		if (kstr == NULL) {
 			if (callback == NULL)
-				klen=PEM_def_callback(buf,PEM_BUFSIZE,1,u);
+				klen = PEM_def_callback(buf, PEM_BUFSIZE, 1, u);
 			else
-				klen=(*callback)(buf,PEM_BUFSIZE,1,u);
-			if (klen <= 0)
-				{
-				PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,PEM_R_READ_KEY);
+				klen = (*callback)(buf, PEM_BUFSIZE, 1, u);
+			if (klen <= 0) {
+				PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,
+				    PEM_R_READ_KEY);
 				goto err;
-				}
-			kstr=(unsigned char *)buf;
 			}
+			kstr = (unsigned char *)buf;
+		}
 		OPENSSL_assert(enc->iv_len <= (int)sizeof(iv));
-		if (RAND_pseudo_bytes(iv,enc->iv_len) < 0) /* Generate a salt */
+		if (RAND_pseudo_bytes(iv, enc->iv_len) < 0) /* Generate a salt */
 			goto err;
 		/* The 'iv' is used as the iv and as a salt.  It is
 		 * NOT taken from the BytesToKey function */
-		if (!EVP_BytesToKey(enc,EVP_md5(),iv,kstr,klen,1,key,NULL))
+		if (!EVP_BytesToKey(enc, EVP_md5(), iv, kstr, klen, 1,
+		    key, NULL))
 			goto err;
 
-		if (kstr == (unsigned char *)buf) OPENSSL_cleanse(buf,PEM_BUFSIZE);
+		if (kstr == (unsigned char *)buf)
+			OPENSSL_cleanse(buf, PEM_BUFSIZE);
 
-		OPENSSL_assert(strlen(objstr)+23+2*enc->iv_len+13 <= sizeof buf);
+		OPENSSL_assert(strlen(objstr) + 23 +
+		    2 * enc->iv_len + 13 <= sizeof buf);
 
-		buf[0]='\0';
-		PEM_proc_type(buf,PEM_TYPE_ENCRYPTED);
-		PEM_dek_info(buf,objstr,enc->iv_len,(char *)iv);
+		buf[0] = '\0';
+		PEM_proc_type(buf, PEM_TYPE_ENCRYPTED);
+		PEM_dek_info(buf, objstr, enc->iv_len, (char *)iv);
 		/* k=strlen(buf); */
 
 		EVP_CIPHER_CTX_init(&ctx);
 		ret = 1;
-		if (!EVP_EncryptInit_ex(&ctx,enc,NULL,key,iv)
-			|| !EVP_EncryptUpdate(&ctx,data,&j,data,i)
-			|| !EVP_EncryptFinal_ex(&ctx,&(data[j]),&i))
+		if (!EVP_EncryptInit_ex(&ctx, enc, NULL, key, iv) ||
+		    !EVP_EncryptUpdate(&ctx, data, &j, data, i) ||
+		    !EVP_EncryptFinal_ex(&ctx, &(data[j]), &i))
 			ret = 0;
 		EVP_CIPHER_CTX_cleanup(&ctx);
 		if (ret == 0)
 			goto err;
-		i+=j;
-		}
-	else
-		{
-		ret=1;
-		buf[0]='\0';
-		}
-	i=PEM_write_bio(bp,name,buf,data,i);
-	if (i <= 0) ret=0;
+		i += j;
+	} else {
+		ret = 1;
+		buf[0] = '\0';
+	}
+	i = PEM_write_bio(bp, name, buf, data, i);
+	if (i <= 0)
+		ret = 0;
 err:
-	OPENSSL_cleanse(key,sizeof(key));
-	OPENSSL_cleanse(iv,sizeof(iv));
-	OPENSSL_cleanse((char *)&ctx,sizeof(ctx));
-	OPENSSL_cleanse(buf,PEM_BUFSIZE);
-	if (data != NULL)
-		{
-		OPENSSL_cleanse(data,(unsigned int)dsize);
+	OPENSSL_cleanse(key, sizeof(key));
+	OPENSSL_cleanse(iv, sizeof(iv));
+	OPENSSL_cleanse((char *)&ctx, sizeof(ctx));
+	OPENSSL_cleanse(buf, PEM_BUFSIZE);
+	if (data != NULL) {
+		OPENSSL_cleanse(data, (unsigned int)dsize);
 		free(data);
-		}
-	return(ret);
 	}
+	return (ret);
+}
 
-int PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *plen,
-	     pem_password_cb *callback,void *u)
-	{
-	int i,j,o,klen;
+int
+PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *plen,
+    pem_password_cb *callback, void *u)
+{
+	int i, j, o, klen;
 	long len;
 	EVP_CIPHER_CTX ctx;
 	unsigned char key[EVP_MAX_KEY_LENGTH];
 	char buf[PEM_BUFSIZE];
 
-	len= *plen;
+	len = *plen;
 
-	if (cipher->cipher == NULL) return(1);
+	if (cipher->cipher == NULL)
+		return (1);
 	if (callback == NULL)
-		klen=PEM_def_callback(buf,PEM_BUFSIZE,0,u);
+		klen = PEM_def_callback(buf, PEM_BUFSIZE, 0, u);
 	else
-		klen=callback(buf,PEM_BUFSIZE,0,u);
-	if (klen <= 0)
-		{
-		PEMerr(PEM_F_PEM_DO_HEADER,PEM_R_BAD_PASSWORD_READ);
-		return(0);
-		}
-	if (!EVP_BytesToKey(cipher->cipher,EVP_md5(),&(cipher->iv[0]),
-		(unsigned char *)buf,klen,1,key,NULL))
+		klen = callback(buf, PEM_BUFSIZE, 0, u);
+	if (klen <= 0) {
+		PEMerr(PEM_F_PEM_DO_HEADER, PEM_R_BAD_PASSWORD_READ);
+		return (0);
+	}
+	if (!EVP_BytesToKey(cipher->cipher, EVP_md5(), &(cipher->iv[0]),
+	    (unsigned char *)buf, klen, 1, key, NULL))
 		return 0;
 
-	j=(int)len;
+	j = (int)len;
 	EVP_CIPHER_CTX_init(&ctx);
-	o = EVP_DecryptInit_ex(&ctx,cipher->cipher,NULL, key,&(cipher->iv[0]));
+	o = EVP_DecryptInit_ex(&ctx, cipher->cipher, NULL, key,
+	    &(cipher->iv[0]));
 	if (o)
-		o = EVP_DecryptUpdate(&ctx,data,&i,data,j);
+		o = EVP_DecryptUpdate(&ctx, data, &i, data, j);
 	if (o)
-		o = EVP_DecryptFinal_ex(&ctx,&(data[i]),&j);
+		o = EVP_DecryptFinal_ex(&ctx, &(data[i]), &j);
 	EVP_CIPHER_CTX_cleanup(&ctx);
-	OPENSSL_cleanse((char *)buf,sizeof(buf));
-	OPENSSL_cleanse((char *)key,sizeof(key));
-	j+=i;
-	if (!o)
-		{
-		PEMerr(PEM_F_PEM_DO_HEADER,PEM_R_BAD_DECRYPT);
-		return(0);
-		}
-	*plen=j;
-	return(1);
+	OPENSSL_cleanse((char *)buf, sizeof(buf));
+	OPENSSL_cleanse((char *)key, sizeof(key));
+	j += i;
+	if (!o) {
+		PEMerr(PEM_F_PEM_DO_HEADER, PEM_R_BAD_DECRYPT);
+		return (0);
 	}
+	*plen = j;
+	return (1);
+}
 
-int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)
-	{
-	const EVP_CIPHER *enc=NULL;
-	char *p,c;
+int
+PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)
+{
+	const EVP_CIPHER *enc = NULL;
+	char *p, c;
 	char **header_pp = &header;
 
-	cipher->cipher=NULL;
+	cipher->cipher = NULL;
 	if ((header == NULL) || (*header == '\0') || (*header == '\n'))
-		return(1);
-	if (strncmp(header,"Proc-Type: ",11) != 0)
-		{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_NOT_PROC_TYPE); return(0); }
-	header+=11;
-	if (*header != '4') return(0); header++;
-	if (*header != ',') return(0); header++;
-	if (strncmp(header,"ENCRYPTED",9) != 0)
-		{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_NOT_ENCRYPTED); return(0); }
+		return (1);
+	if (strncmp(header, "Proc-Type: ", 11) != 0) {
+		PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_NOT_PROC_TYPE);
+		return (0);
+	}
+	header += 11;
+	if (*header != '4')
+		return(0);
+	header++;
+	if (*header != ',')
+		return(0);
+	header++;
+	if (strncmp(header, "ENCRYPTED", 9) != 0) {
+		PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_NOT_ENCRYPTED);
+		return (0);
+	}
 	for (; (*header != '\n') && (*header != '\0'); header++)
 		;
-	if (*header == '\0')
-		{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_SHORT_HEADER); return(0); }
+	if (*header == '\0') {
+		PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_SHORT_HEADER);
+		return (0);
+	}
 	header++;
-	if (strncmp(header,"DEK-Info: ",10) != 0)
-		{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_NOT_DEK_INFO); return(0); }
-	header+=10;
+	if (strncmp(header, "DEK-Info: ", 10) != 0) {
+		PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_NOT_DEK_INFO);
+		return (0);
+	}
+	header += 10;
 
-	p=header;
-	for (;;)
-		{
+	p = header;
+	for (;;) {
 		c= *header;
 		if (!(	((c >= 'A') && (c <= 'Z')) || (c == '-') ||
-			((c >= '0') && (c <= '9'))))
+		    ((c >= '0') && (c <= '9'))))
 			break;
 		header++;
-		}
-	*header='\0';
-	cipher->cipher=enc=EVP_get_cipherbyname(p);
-	*header=c;
+	}
+	*header = '\0';
+	cipher->cipher = enc = EVP_get_cipherbyname(p);
+	*header = c;
 	header++;
 
-	if (enc == NULL)
-		{
-		PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_UNSUPPORTED_ENCRYPTION);
-		return(0);
-		}
-	if (!load_iv(header_pp,&(cipher->iv[0]),enc->iv_len))
-		return(0);
-
-	return(1);
+	if (enc == NULL) {
+		PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,
+		    PEM_R_UNSUPPORTED_ENCRYPTION);
+		return (0);
 	}
+	if (!load_iv(header_pp, &(cipher->iv[0]), enc->iv_len))
+		return (0);
+
+	return (1);
+}
 
-static int load_iv(char **fromp, unsigned char *to, int num)
-	{
-	int v,i;
+static int
+load_iv(char **fromp, unsigned char *to, int num)
+{
+	int v, i;
 	char *from;
 
 	from= *fromp;
-	for (i=0; i<num; i++) to[i]=0;
-	num*=2;
-	for (i=0; i<num; i++)
-		{
+	for (i = 0; i < num; i++)
+		to[i] = 0;
+	num *= 2;
+	for (i = 0; i < num; i++) {
 		if ((*from >= '0') && (*from <= '9'))
-			v= *from-'0';
+			v = *from - '0';
 		else if ((*from >= 'A') && (*from <= 'F'))
-			v= *from-'A'+10;
+			v = *from - 'A' + 10;
 		else if ((*from >= 'a') && (*from <= 'f'))
-			v= *from-'a'+10;
-		else
-			{
-			PEMerr(PEM_F_LOAD_IV,PEM_R_BAD_IV_CHARS);
-			return(0);
-			}
-		from++;
-		to[i/2]|=v<<(long)((!(i&1))*4);
+			v = *from - 'a' + 10;
+		else {
+			PEMerr(PEM_F_LOAD_IV, PEM_R_BAD_IV_CHARS);
+			return (0);
 		}
-
-	*fromp=from;
-	return(1);
+		from++;
+		to[i / 2] |= v << (long)((!(i & 1)) * 4);
 	}
 
+	*fromp = from;
+	return (1);
+}
+
 #ifndef OPENSSL_NO_FP_API
-int PEM_write(FILE *fp, char *name, char *header, unsigned char *data,
-	     long len)
-        {
-        BIO *b;
-        int ret;
-
-        if ((b=BIO_new(BIO_s_file())) == NULL)
-		{
-		PEMerr(PEM_F_PEM_WRITE,ERR_R_BUF_LIB);
-                return(0);
-		}
-        BIO_set_fp(b,fp,BIO_NOCLOSE);
-        ret=PEM_write_bio(b, name, header, data,len);
-        BIO_free(b);
-        return(ret);
-        }
+int
+PEM_write(FILE *fp, char *name, char *header, unsigned char *data, long len)
+{
+	BIO *b;
+	int ret;
+
+	if ((b = BIO_new(BIO_s_file())) == NULL) {
+		PEMerr(PEM_F_PEM_WRITE, ERR_R_BUF_LIB);
+		return (0);
+	}
+	BIO_set_fp(b, fp, BIO_NOCLOSE);
+	ret = PEM_write_bio(b, name, header, data, len);
+	BIO_free(b);
+	return (ret);
+}
 #endif
 
-int PEM_write_bio(BIO *bp, const char *name, char *header, unsigned char *data,
-	     long len)
-	{
-	int nlen,n,i,j,outl;
+int
+PEM_write_bio(BIO *bp, const char *name, char *header, unsigned char *data,
+    long len)
+{
+	int nlen, n, i, j, outl;
 	unsigned char *buf = NULL;
 	EVP_ENCODE_CTX ctx;
-	int reason=ERR_R_BUF_LIB;
-	
+	int reason = ERR_R_BUF_LIB;
+
 	EVP_EncodeInit(&ctx);
-	nlen=strlen(name);
+	nlen = strlen(name);
 
-	if (	(BIO_write(bp,"-----BEGIN ",11) != 11) ||
-		(BIO_write(bp,name,nlen) != nlen) ||
-		(BIO_write(bp,"-----\n",6) != 6))
+	if ((BIO_write(bp, "-----BEGIN ", 11) != 11) ||
+	    (BIO_write(bp, name, nlen) != nlen) ||
+	    (BIO_write(bp, "-----\n", 6) != 6))
 		goto err;
-		
-	i=strlen(header);
-	if (i > 0)
-		{
-		if (	(BIO_write(bp,header,i) != i) ||
-			(BIO_write(bp,"\n",1) != 1))
+
+	i = strlen(header);
+	if (i > 0) {
+		if ((BIO_write(bp, header, i) != i) ||
+		    (BIO_write(bp, "\n", 1) != 1))
 			goto err;
-		}
+	}
 
-	buf = malloc(PEM_BUFSIZE*8);
-	if (buf == NULL)
-		{
-		reason=ERR_R_MALLOC_FAILURE;
+	buf = malloc(PEM_BUFSIZE * 8);
+	if (buf == NULL) {
+		reason = ERR_R_MALLOC_FAILURE;
 		goto err;
-		}
+	}
 
-	i=j=0;
-	while (len > 0)
-		{
-		n=(int)((len>(PEM_BUFSIZE*5))?(PEM_BUFSIZE*5):len);
-		EVP_EncodeUpdate(&ctx,buf,&outl,&(data[j]),n);
-		if ((outl) && (BIO_write(bp,(char *)buf,outl) != outl))
+	i = j = 0;
+	while (len > 0) {
+		n = (int)((len > (PEM_BUFSIZE * 5)) ? (PEM_BUFSIZE * 5) : len);
+		EVP_EncodeUpdate(&ctx, buf, &outl, &(data[j]), n);
+		if ((outl) && (BIO_write(bp, (char *)buf, outl) != outl))
 			goto err;
-		i+=outl;
-		len-=n;
-		j+=n;
-		}
-	EVP_EncodeFinal(&ctx,buf,&outl);
-	if ((outl > 0) && (BIO_write(bp,(char *)buf,outl) != outl)) goto err;
-	OPENSSL_cleanse(buf, PEM_BUFSIZE*8);
+		i += outl;
+		len -= n;
+		j += n;
+	}
+	EVP_EncodeFinal(&ctx, buf, &outl);
+	if ((outl > 0) && (BIO_write(bp, (char *)buf, outl) != outl))
+		goto err;
+	OPENSSL_cleanse(buf, PEM_BUFSIZE * 8);
 	free(buf);
 	buf = NULL;
-	if (	(BIO_write(bp,"-----END ",9) != 9) ||
-		(BIO_write(bp,name,nlen) != nlen) ||
-		(BIO_write(bp,"-----\n",6) != 6))
+	if ((BIO_write(bp, "-----END ", 9) != 9) ||
+	    (BIO_write(bp, name, nlen) != nlen) ||
+	    (BIO_write(bp, "-----\n", 6) != 6))
 		goto err;
-	return(i+outl);
+	return (i + outl);
+
 err:
 	if (buf) {
-		OPENSSL_cleanse(buf, PEM_BUFSIZE*8);
+		OPENSSL_cleanse(buf, PEM_BUFSIZE * 8);
 		free(buf);
 	}
-	PEMerr(PEM_F_PEM_WRITE_BIO,reason);
-	return(0);
-	}
+	PEMerr(PEM_F_PEM_WRITE_BIO, reason);
+	return (0);
+}
 
 #ifndef OPENSSL_NO_FP_API
-int PEM_read(FILE *fp, char **name, char **header, unsigned char **data,
-	     long *len)
-        {
-        BIO *b;
-        int ret;
-
-        if ((b=BIO_new(BIO_s_file())) == NULL)
-		{
-		PEMerr(PEM_F_PEM_READ,ERR_R_BUF_LIB);
-                return(0);
-		}
-        BIO_set_fp(b,fp,BIO_NOCLOSE);
-        ret=PEM_read_bio(b, name, header, data,len);
-        BIO_free(b);
-        return(ret);
-        }
+int
+PEM_read(FILE *fp, char **name, char **header, unsigned char **data, long *len)
+{
+	BIO *b;
+	int ret;
+
+	if ((b = BIO_new(BIO_s_file())) == NULL) {
+		PEMerr(PEM_F_PEM_READ, ERR_R_BUF_LIB);
+		return (0);
+	}
+	BIO_set_fp(b, fp, BIO_NOCLOSE);
+	ret = PEM_read_bio(b, name, header, data, len);
+	BIO_free(b);
+	return (ret);
+}
 #endif
 
-int PEM_read_bio(BIO *bp, char **name, char **header, unsigned char **data,
-	     long *len)
-	{
+int
+PEM_read_bio(BIO *bp, char **name, char **header, unsigned char **data,
+    long *len)
+{
 	EVP_ENCODE_CTX ctx;
-	int end=0,i,k,bl=0,hl=0,nohead=0;
+	int end = 0, i, k, bl = 0, hl = 0, nohead = 0;
 	char buf[256];
 	BUF_MEM *nameB;
 	BUF_MEM *headerB;
-	BUF_MEM *dataB,*tmpB;
-	
-	nameB=BUF_MEM_new();
-	headerB=BUF_MEM_new();
-	dataB=BUF_MEM_new();
-	if ((nameB == NULL) || (headerB == NULL) || (dataB == NULL))
-		{
+	BUF_MEM *dataB, *tmpB;
+
+	nameB = BUF_MEM_new();
+	headerB = BUF_MEM_new();
+	dataB = BUF_MEM_new();
+	if ((nameB == NULL) || (headerB == NULL) || (dataB == NULL)) {
 		BUF_MEM_free(nameB);
 		BUF_MEM_free(headerB);
 		BUF_MEM_free(dataB);
-		PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE);
-		return(0);
-		}
+		PEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);
+		return (0);
+	}
 
-	buf[254]='\0';
-	for (;;)
-		{
-		i=BIO_gets(bp,buf,254);
+	buf[254] = '\0';
+	for (;;) {
+		i = BIO_gets(bp, buf, 254);
 
-		if (i <= 0)
-			{
-			PEMerr(PEM_F_PEM_READ_BIO,PEM_R_NO_START_LINE);
+		if (i <= 0) {
+			PEMerr(PEM_F_PEM_READ_BIO, PEM_R_NO_START_LINE);
 			goto err;
-			}
+		}
 
-		while ((i >= 0) && (buf[i] <= ' ')) i--;
-		buf[++i]='\n'; buf[++i]='\0';
+		while ((i >= 0) && (buf[i] <= ' '))
+			i--;
+		buf[++i] = '\n';
+		buf[++i] = '\0';
 
-		if (strncmp(buf,"-----BEGIN ",11) == 0)
-			{
-			i=strlen(&(buf[11]));
+		if (strncmp(buf, "-----BEGIN ", 11) == 0) {
+			i = strlen(&(buf[11]));
 
-			if (strncmp(&(buf[11+i-6]),"-----\n",6) != 0)
+			if (strncmp(&(buf[11 + i - 6]), "-----\n", 6) != 0)
 				continue;
-			if (!BUF_MEM_grow(nameB,i+9))
-				{
-				PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE);
+			if (!BUF_MEM_grow(nameB, i + 9)) {
+				PEMerr(PEM_F_PEM_READ_BIO,
+				    ERR_R_MALLOC_FAILURE);
 				goto err;
-				}
-			memcpy(nameB->data,&(buf[11]),i-6);
-			nameB->data[i-6]='\0';
-			break;
 			}
+			memcpy(nameB->data, &(buf[11]), i - 6);
+			nameB->data[i - 6] = '\0';
+			break;
 		}
-	hl=0;
-	if (!BUF_MEM_grow(headerB,256))
-		{ PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE); goto err; }
-	headerB->data[0]='\0';
-	for (;;)
-		{
-		i=BIO_gets(bp,buf,254);
-		if (i <= 0) break;
-
-		while ((i >= 0) && (buf[i] <= ' ')) i--;
-		buf[++i]='\n'; buf[++i]='\0';
-
-		if (buf[0] == '\n') break;
-		if (!BUF_MEM_grow(headerB,hl+i+9))
-			{ PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE); goto err; }
-		if (strncmp(buf,"-----END ",9) == 0)
-			{
-			nohead=1;
+	}
+	hl = 0;
+	if (!BUF_MEM_grow(headerB, 256)) {
+		PEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+	headerB->data[0] = '\0';
+	for (;;) {
+		i = BIO_gets(bp, buf, 254);
+		if (i <= 0)
 			break;
-			}
-		memcpy(&(headerB->data[hl]),buf,i);
-		headerB->data[hl+i]='\0';
-		hl+=i;
+
+		while ((i >= 0) && (buf[i] <= ' '))
+			i--;
+		buf[++i] = '\n';
+		buf[++i] = '\0';
+
+		if (buf[0] == '\n')
+			break;
+		if (!BUF_MEM_grow(headerB, hl + i + 9)) {
+			PEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);
+			goto err;
 		}
+		if (strncmp(buf, "-----END ", 9) == 0) {
+			nohead = 1;
+			break;
+		}
+		memcpy(&(headerB->data[hl]), buf, i);
+		headerB->data[hl + i] = '\0';
+		hl += i;
+	}
+
+	bl = 0;
+	if (!BUF_MEM_grow(dataB, 1024)) {
+		PEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+	dataB->data[0] = '\0';
+	if (!nohead) {
+		for (;;) {
+			i = BIO_gets(bp, buf, 254);
+			if (i <= 0)
+				break;
+
+			while ((i >= 0) && (buf[i] <= ' '))
+				i--;
+			buf[++i] = '\n';
+			buf[++i] = '\0';
 
-	bl=0;
-	if (!BUF_MEM_grow(dataB,1024))
-		{ PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE); goto err; }
-	dataB->data[0]='\0';
-	if (!nohead)
-		{
-		for (;;)
-			{
-			i=BIO_gets(bp,buf,254);
-			if (i <= 0) break;
-
-			while ((i >= 0) && (buf[i] <= ' ')) i--;
-			buf[++i]='\n'; buf[++i]='\0';
-
-			if (i != 65) end=1;
-			if (strncmp(buf,"-----END ",9) == 0)
+			if (i != 65)
+				end = 1;
+			if (strncmp(buf, "-----END ", 9) == 0)
 				break;
-			if (i > 65) break;
-			if (!BUF_MEM_grow_clean(dataB,i+bl+9))
-				{
-				PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE);
+			if (i > 65)
+				break;
+			if (!BUF_MEM_grow_clean(dataB, i + bl + 9)) {
+				PEMerr(PEM_F_PEM_READ_BIO,
+				    ERR_R_MALLOC_FAILURE);
 				goto err;
-				}
-			memcpy(&(dataB->data[bl]),buf,i);
-			dataB->data[bl+i]='\0';
-			bl+=i;
-			if (end)
-				{
-				buf[0]='\0';
-				i=BIO_gets(bp,buf,254);
-				if (i <= 0) break;
-
-				while ((i >= 0) && (buf[i] <= ' ')) i--;
-				buf[++i]='\n'; buf[++i]='\0';
+			}
+			memcpy(&(dataB->data[bl]), buf, i);
+			dataB->data[bl + i] = '\0';
+			bl += i;
+			if (end) {
+				buf[0] = '\0';
+				i = BIO_gets(bp, buf, 254);
+				if (i <= 0)
+					break;
+
+				while ((i >= 0) && (buf[i] <= ' '))
+					i--;
+				buf[++i] = '\n';
+				buf[++i] = '\0';
 
 				break;
-				}
 			}
 		}
-	else
-		{
-		tmpB=headerB;
-		headerB=dataB;
-		dataB=tmpB;
-		bl=hl;
-		}
-	i=strlen(nameB->data);
-	if (	(strncmp(buf,"-----END ",9) != 0) ||
-		(strncmp(nameB->data,&(buf[9]),i) != 0) ||
-		(strncmp(&(buf[9+i]),"-----\n",6) != 0))
-		{
-		PEMerr(PEM_F_PEM_READ_BIO,PEM_R_BAD_END_LINE);
+	} else {
+		tmpB = headerB;
+		headerB = dataB;
+		dataB = tmpB;
+		bl = hl;
+	}
+	i = strlen(nameB->data);
+	if ((strncmp(buf, "-----END ", 9) != 0) ||
+	    (strncmp(nameB->data, &(buf[9]), i) != 0) ||
+	    (strncmp(&(buf[9 + i]), "-----\n", 6) != 0)) {
+		PEMerr(PEM_F_PEM_READ_BIO, PEM_R_BAD_END_LINE);
 		goto err;
-		}
+	}
 
 	EVP_DecodeInit(&ctx);
-	i=EVP_DecodeUpdate(&ctx,
-		(unsigned char *)dataB->data,&bl,
-		(unsigned char *)dataB->data,bl);
-	if (i < 0)
-		{
-		PEMerr(PEM_F_PEM_READ_BIO,PEM_R_BAD_BASE64_DECODE);
+	i = EVP_DecodeUpdate(&ctx,
+	    (unsigned char *)dataB->data, &bl,
+	    (unsigned char *)dataB->data, bl);
+	if (i < 0) {
+		PEMerr(PEM_F_PEM_READ_BIO, PEM_R_BAD_BASE64_DECODE);
 		goto err;
-		}
-	i=EVP_DecodeFinal(&ctx,(unsigned char *)&(dataB->data[bl]),&k);
-	if (i < 0)
-		{
-		PEMerr(PEM_F_PEM_READ_BIO,PEM_R_BAD_BASE64_DECODE);
+	}
+	i = EVP_DecodeFinal(&ctx, (unsigned char *)&(dataB->data[bl]), &k);
+	if (i < 0) {
+		PEMerr(PEM_F_PEM_READ_BIO, PEM_R_BAD_BASE64_DECODE);
 		goto err;
-		}
-	bl+=k;
+	}
+	bl += k;
 
-	if (bl == 0) goto err;
-	*name=nameB->data;
-	*header=headerB->data;
-	*data=(unsigned char *)dataB->data;
-	*len=bl;
+	if (bl == 0)
+		goto err;
+	*name = nameB->data;
+	*header = headerB->data;
+	*data = (unsigned char *)dataB->data;
+	*len = bl;
 	free(nameB);
 	free(headerB);
 	free(dataB);
-	return(1);
+	return (1);
+
 err:
 	BUF_MEM_free(nameB);
 	BUF_MEM_free(headerB);
 	BUF_MEM_free(dataB);
-	return(0);
-	}
+	return (0);
+}
 
 /* Check pem string and return prefix length.
  * If for example the pem_str == "RSA PRIVATE KEY" and suffix = "PRIVATE KEY"
  * the return value is 3 for the string "RSA".
  */
 
-int pem_check_suffix(const char *pem_str, const char *suffix)
-	{
+int
+pem_check_suffix(const char *pem_str, const char *suffix)
+{
 	int pem_len = strlen(pem_str);
 	int suffix_len = strlen(suffix);
 	const char *p;
+
 	if (suffix_len + 1 >= pem_len)
 		return 0;
 	p = pem_str + pem_len - suffix_len;
@@ -839,5 +868,4 @@ int pem_check_suffix(const char *pem_str, const char *suffix)
 	if (*p != ' ')
 		return 0;
 	return p - pem_str;
-	}
-
+}
diff --git a/src/lib/libcrypto/pem/pem_oth.c b/src/lib/libcrypto/pem/pem_oth.c
index 69d281aa9..5787dc2f3 100644
--- a/src/lib/libcrypto/pem/pem_oth.c
+++ b/src/lib/libcrypto/pem/pem_oth.c
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -67,20 +67,21 @@
 
 /* Handle 'other' PEMs: not private keys */
 
-void *PEM_ASN1_read_bio(d2i_of_void *d2i, const char *name, BIO *bp, void **x,
-			pem_password_cb *cb, void *u)
-	{
-	const unsigned char *p=NULL;
-	unsigned char *data=NULL;
+void *
+PEM_ASN1_read_bio(d2i_of_void *d2i, const char *name, BIO *bp, void **x,
+    pem_password_cb *cb, void *u)
+{
+	const unsigned char *p = NULL;
+	unsigned char *data = NULL;
 	long len;
-	char *ret=NULL;
+	char *ret = NULL;
 
 	if (!PEM_bytes_read_bio(&data, &len, NULL, name, bp, cb, u))
 		return NULL;
 	p = data;
-	ret=d2i(x,&p,len);
+	ret = d2i(x, &p, len);
 	if (ret == NULL)
-		PEMerr(PEM_F_PEM_ASN1_READ_BIO,ERR_R_ASN1_LIB);
+		PEMerr(PEM_F_PEM_ASN1_READ_BIO, ERR_R_ASN1_LIB);
 	free(data);
-	return(ret);
-	}
+	return (ret);
+}
diff --git a/src/lib/libcrypto/pem/pem_pk8.c b/src/lib/libcrypto/pem/pem_pk8.c
index 6deab8c33..228ecfcea 100644
--- a/src/lib/libcrypto/pem/pem_pk8.c
+++ b/src/lib/libcrypto/pem/pem_pk8.c
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -66,14 +66,10 @@
 #include <openssl/pkcs12.h>
 #include <openssl/pem.h>
 
-static int do_pk8pkey(BIO *bp, EVP_PKEY *x, int isder,
-				int nid, const EVP_CIPHER *enc,
-				char *kstr, int klen,
-				pem_password_cb *cb, void *u);
-static int do_pk8pkey_fp(FILE *bp, EVP_PKEY *x, int isder,
-				int nid, const EVP_CIPHER *enc,
-				char *kstr, int klen,
-				pem_password_cb *cb, void *u);
+static int do_pk8pkey(BIO *bp, EVP_PKEY *x, int isder, int nid,
+    const EVP_CIPHER *enc, char *kstr, int klen, pem_password_cb *cb, void *u);
+static int do_pk8pkey_fp(FILE *bp, EVP_PKEY *x, int isder, int nid,
+    const EVP_CIPHER *enc, char *kstr, int klen, pem_password_cb *cb, void *u);
 
 /* These functions write a private key in PKCS#8 format: it is a "drop in"
  * replacement for PEM_write_bio_PrivateKey() and friends. As usual if 'enc'
@@ -81,98 +77,114 @@ static int do_pk8pkey_fp(FILE *bp, EVP_PKEY *x, int isder,
  * uses PKCS#5 v1.5 PBE algorithms whereas the others use PKCS#5 v2.0.
  */
 
-int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u)
+int
+PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid, char *kstr,
+    int klen, pem_password_cb *cb, void *u)
 {
 	return do_pk8pkey(bp, x, 0, nid, NULL, kstr, klen, cb, u);
 }
 
-int PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u)
+int
+PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
+    char *kstr, int klen, pem_password_cb *cb, void *u)
 {
 	return do_pk8pkey(bp, x, 0, -1, enc, kstr, klen, cb, u);
 }
 
-int i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u)
+int
+i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
+    char *kstr, int klen, pem_password_cb *cb, void *u)
 {
 	return do_pk8pkey(bp, x, 1, -1, enc, kstr, klen, cb, u);
 }
 
-int i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u)
+int
+i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid,
+    char *kstr, int klen, pem_password_cb *cb, void *u)
 {
 	return do_pk8pkey(bp, x, 1, nid, NULL, kstr, klen, cb, u);
 }
 
-static int do_pk8pkey(BIO *bp, EVP_PKEY *x, int isder, int nid, const EVP_CIPHER *enc,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u)
+static int
+do_pk8pkey(BIO *bp, EVP_PKEY *x, int isder, int nid, const EVP_CIPHER *enc,
+    char *kstr, int klen, pem_password_cb *cb, void *u)
 {
 	X509_SIG *p8;
 	PKCS8_PRIV_KEY_INFO *p8inf;
 	char buf[PEM_BUFSIZE];
 	int ret;
-	if(!(p8inf = EVP_PKEY2PKCS8(x))) {
+
+	if (!(p8inf = EVP_PKEY2PKCS8(x))) {
 		PEMerr(PEM_F_DO_PK8PKEY,
-					PEM_R_ERROR_CONVERTING_PRIVATE_KEY);
+		    PEM_R_ERROR_CONVERTING_PRIVATE_KEY);
 		return 0;
 	}
-	if(enc || (nid != -1)) {
-		if(!kstr) {
-			if(!cb) klen = PEM_def_callback(buf, PEM_BUFSIZE, 1, u);
-			else klen = cb(buf, PEM_BUFSIZE, 1, u);
-			if(klen <= 0) {
-				PEMerr(PEM_F_DO_PK8PKEY,PEM_R_READ_KEY);
+	if (enc || (nid != -1)) {
+		if (!kstr) {
+			if (!cb)
+				klen = PEM_def_callback(buf, PEM_BUFSIZE, 1, u);
+			else
+				klen = cb(buf, PEM_BUFSIZE, 1, u);
+			if (klen <= 0) {
+				PEMerr(PEM_F_DO_PK8PKEY, PEM_R_READ_KEY);
 				PKCS8_PRIV_KEY_INFO_free(p8inf);
 				return 0;
 			}
-				
+
 			kstr = buf;
 		}
 		p8 = PKCS8_encrypt(nid, enc, kstr, klen, NULL, 0, 0, p8inf);
-		if(kstr == buf) OPENSSL_cleanse(buf, klen);
+		if (kstr == buf)
+			OPENSSL_cleanse(buf, klen);
 		PKCS8_PRIV_KEY_INFO_free(p8inf);
-		if(isder) ret = i2d_PKCS8_bio(bp, p8);
-		else ret = PEM_write_bio_PKCS8(bp, p8);
+		if (isder)
+			ret = i2d_PKCS8_bio(bp, p8);
+		else
+			ret = PEM_write_bio_PKCS8(bp, p8);
 		X509_SIG_free(p8);
 		return ret;
 	} else {
-		if(isder) ret = i2d_PKCS8_PRIV_KEY_INFO_bio(bp, p8inf);
-		else ret = PEM_write_bio_PKCS8_PRIV_KEY_INFO(bp, p8inf);
+		if (isder)
+			ret = i2d_PKCS8_PRIV_KEY_INFO_bio(bp, p8inf);
+		else
+			ret = PEM_write_bio_PKCS8_PRIV_KEY_INFO(bp, p8inf);
 		PKCS8_PRIV_KEY_INFO_free(p8inf);
 		return ret;
 	}
 }
 
-EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)
+EVP_PKEY *
+d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)
 {
 	PKCS8_PRIV_KEY_INFO *p8inf = NULL;
 	X509_SIG *p8 = NULL;
 	int klen;
 	EVP_PKEY *ret;
 	char psbuf[PEM_BUFSIZE];
+
 	p8 = d2i_PKCS8_bio(bp, NULL);
-	if(!p8) return NULL;
-	if (cb) klen=cb(psbuf,PEM_BUFSIZE,0,u);
-	else klen=PEM_def_callback(psbuf,PEM_BUFSIZE,0,u);
+	if (!p8)
+		return NULL;
+	if (cb)
+		klen = cb(psbuf, PEM_BUFSIZE, 0, u);
+	else
+		klen = PEM_def_callback(psbuf, PEM_BUFSIZE, 0, u);
 	if (klen <= 0) {
 		PEMerr(PEM_F_D2I_PKCS8PRIVATEKEY_BIO, PEM_R_BAD_PASSWORD_READ);
 		X509_SIG_free(p8);
-		return NULL;	
+		return NULL;
 	}
 	p8inf = PKCS8_decrypt(p8, psbuf, klen);
 	X509_SIG_free(p8);
-	if(!p8inf) return NULL;
+	if (!p8inf)
+		return NULL;
 	ret = EVP_PKCS82PKEY(p8inf);
 	PKCS8_PRIV_KEY_INFO_free(p8inf);
-	if(!ret) return NULL;
-	if(x) {
-		if(*x) EVP_PKEY_free(*x);
+	if (!ret)
+		return NULL;
+	if (x) {
+		if (*x)
+			EVP_PKEY_free(*x);
 		*x = ret;
 	}
 	return ret;
@@ -180,55 +192,59 @@ EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, vo
 
 #ifndef OPENSSL_NO_FP_API
 
-int i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u)
+int
+i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
+    char *kstr, int klen, pem_password_cb *cb, void *u)
 {
 	return do_pk8pkey_fp(fp, x, 1, -1, enc, kstr, klen, cb, u);
 }
 
-int i2d_PKCS8PrivateKey_nid_fp(FILE *fp, EVP_PKEY *x, int nid,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u)
+int
+i2d_PKCS8PrivateKey_nid_fp(FILE *fp, EVP_PKEY *x, int nid, char *kstr,
+    int klen, pem_password_cb *cb, void *u)
 {
 	return do_pk8pkey_fp(fp, x, 1, nid, NULL, kstr, klen, cb, u);
 }
 
-int PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u)
+int
+PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid, char *kstr,
+    int klen, pem_password_cb *cb, void *u)
 {
 	return do_pk8pkey_fp(fp, x, 0, nid, NULL, kstr, klen, cb, u);
 }
 
-int PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
-			      char *kstr, int klen, pem_password_cb *cb, void *u)
+int
+PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
+    char *kstr, int klen, pem_password_cb *cb, void *u)
 {
 	return do_pk8pkey_fp(fp, x, 0, -1, enc, kstr, klen, cb, u);
 }
 
-static int do_pk8pkey_fp(FILE *fp, EVP_PKEY *x, int isder, int nid, const EVP_CIPHER *enc,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u)
+static int
+do_pk8pkey_fp(FILE *fp, EVP_PKEY *x, int isder, int nid, const EVP_CIPHER *enc,
+    char *kstr, int klen, pem_password_cb *cb, void *u)
 {
 	BIO *bp;
 	int ret;
-	if(!(bp = BIO_new_fp(fp, BIO_NOCLOSE))) {
-		PEMerr(PEM_F_DO_PK8PKEY_FP,ERR_R_BUF_LIB);
-                return(0);
+
+	if (!(bp = BIO_new_fp(fp, BIO_NOCLOSE))) {
+		PEMerr(PEM_F_DO_PK8PKEY_FP, ERR_R_BUF_LIB);
+		return (0);
 	}
 	ret = do_pk8pkey(bp, x, isder, nid, enc, kstr, klen, cb, u);
 	BIO_free(bp);
 	return ret;
 }
 
-EVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u)
+EVP_PKEY *
+d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u)
 {
 	BIO *bp;
 	EVP_PKEY *ret;
-	if(!(bp = BIO_new_fp(fp, BIO_NOCLOSE))) {
-		PEMerr(PEM_F_D2I_PKCS8PRIVATEKEY_FP,ERR_R_BUF_LIB);
-                return NULL;
+
+	if (!(bp = BIO_new_fp(fp, BIO_NOCLOSE))) {
+		PEMerr(PEM_F_D2I_PKCS8PRIVATEKEY_FP, ERR_R_BUF_LIB);
+		return NULL;
 	}
 	ret = d2i_PKCS8PrivateKey_bio(bp, x, cb, u);
 	BIO_free(bp);
@@ -239,4 +255,4 @@ EVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, vo
 
 IMPLEMENT_PEM_rw(PKCS8, X509_SIG, PEM_STRING_PKCS8, X509_SIG)
 IMPLEMENT_PEM_rw(PKCS8_PRIV_KEY_INFO, PKCS8_PRIV_KEY_INFO, PEM_STRING_PKCS8INF,
-							 PKCS8_PRIV_KEY_INFO)
+    PKCS8_PRIV_KEY_INFO)
diff --git a/src/lib/libcrypto/pem/pem_pkey.c b/src/lib/libcrypto/pem/pem_pkey.c
index 5274447b2..9aaff6e51 100644
--- a/src/lib/libcrypto/pem/pem_pkey.c
+++ b/src/lib/libcrypto/pem/pem_pkey.c
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -72,173 +72,182 @@
 
 int pem_check_suffix(const char *pem_str, const char *suffix);
 
-EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)
-	{
-	char *nm=NULL;
-	const unsigned char *p=NULL;
-	unsigned char *data=NULL;
+EVP_PKEY *
+PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)
+{
+	char *nm = NULL;
+	const unsigned char *p = NULL;
+	unsigned char *data = NULL;
 	long len;
 	int slen;
-	EVP_PKEY *ret=NULL;
+	EVP_PKEY *ret = NULL;
 
-	if (!PEM_bytes_read_bio(&data, &len, &nm, PEM_STRING_EVP_PKEY, bp, cb, u))
+	if (!PEM_bytes_read_bio(&data, &len, &nm, PEM_STRING_EVP_PKEY,
+	    bp, cb, u))
 		return NULL;
 	p = data;
 
-	if (strcmp(nm,PEM_STRING_PKCS8INF) == 0) {
+	if (strcmp(nm, PEM_STRING_PKCS8INF) == 0) {
 		PKCS8_PRIV_KEY_INFO *p8inf;
-		p8inf=d2i_PKCS8_PRIV_KEY_INFO(NULL, &p, len);
-		if(!p8inf) goto p8err;
+		p8inf = d2i_PKCS8_PRIV_KEY_INFO(NULL, &p, len);
+		if (!p8inf)
+			goto p8err;
 		ret = EVP_PKCS82PKEY(p8inf);
-		if(x) {
-			if(*x) EVP_PKEY_free((EVP_PKEY *)*x);
+		if (x) {
+			if (*x)
+				EVP_PKEY_free((EVP_PKEY *)*x);
 			*x = ret;
 		}
 		PKCS8_PRIV_KEY_INFO_free(p8inf);
-	} else if (strcmp(nm,PEM_STRING_PKCS8) == 0) {
+	} else if (strcmp(nm, PEM_STRING_PKCS8) == 0) {
 		PKCS8_PRIV_KEY_INFO *p8inf;
 		X509_SIG *p8;
 		int klen;
 		char psbuf[PEM_BUFSIZE];
 		p8 = d2i_X509_SIG(NULL, &p, len);
-		if(!p8) goto p8err;
-		if (cb) klen=cb(psbuf,PEM_BUFSIZE,0,u);
-		else klen=PEM_def_callback(psbuf,PEM_BUFSIZE,0,u);
+		if (!p8)
+			goto p8err;
+		if (cb)
+			klen = cb(psbuf, PEM_BUFSIZE, 0, u);
+		else
+			klen = PEM_def_callback(psbuf, PEM_BUFSIZE, 0, u);
 		if (klen <= 0) {
 			PEMerr(PEM_F_PEM_READ_BIO_PRIVATEKEY,
-					PEM_R_BAD_PASSWORD_READ);
+			    PEM_R_BAD_PASSWORD_READ);
 			X509_SIG_free(p8);
 			goto err;
 		}
 		p8inf = PKCS8_decrypt(p8, psbuf, klen);
 		X509_SIG_free(p8);
-		if(!p8inf) goto p8err;
+		if (!p8inf)
+			goto p8err;
 		ret = EVP_PKCS82PKEY(p8inf);
-		if(x) {
-			if(*x) EVP_PKEY_free((EVP_PKEY *)*x);
+		if (x) {
+			if (*x)
+				EVP_PKEY_free((EVP_PKEY *)*x);
 			*x = ret;
 		}
 		PKCS8_PRIV_KEY_INFO_free(p8inf);
-	} else if ((slen = pem_check_suffix(nm, "PRIVATE KEY")) > 0)
-		{
+	} else if ((slen = pem_check_suffix(nm, "PRIVATE KEY")) > 0) {
 		const EVP_PKEY_ASN1_METHOD *ameth;
 		ameth = EVP_PKEY_asn1_find_str(NULL, nm, slen);
 		if (!ameth || !ameth->old_priv_decode)
 			goto p8err;
-		ret=d2i_PrivateKey(ameth->pkey_id,x,&p,len);
-		}
+		ret = d2i_PrivateKey(ameth->pkey_id, x,&p, len);
+	}
+
 p8err:
 	if (ret == NULL)
-		PEMerr(PEM_F_PEM_READ_BIO_PRIVATEKEY,ERR_R_ASN1_LIB);
+		PEMerr(PEM_F_PEM_READ_BIO_PRIVATEKEY, ERR_R_ASN1_LIB);
 err:
 	free(nm);
 	OPENSSL_cleanse(data, len);
 	free(data);
-	return(ret);
-	}
+	return (ret);
+}
 
-int PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
-                                               unsigned char *kstr, int klen,
-                                               pem_password_cb *cb, void *u)
-	{
+int
+PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
+    unsigned char *kstr, int klen, pem_password_cb *cb, void *u)
+{
 	char pem_str[80];
+
 	if (!x->ameth || x->ameth->priv_encode)
 		return PEM_write_bio_PKCS8PrivateKey(bp, x, enc,
-							(char *)kstr, klen,
-							cb, u);
+		    (char *)kstr, klen, cb, u);
 
 	(void) snprintf(pem_str, sizeof(pem_str), "%s PRIVATE KEY",
 	    x->ameth->pem_str);
 	return PEM_ASN1_write_bio((i2d_of_void *)i2d_PrivateKey,
-				pem_str,bp,x,enc,kstr,klen,cb,u);
-	}
-
-EVP_PKEY *PEM_read_bio_Parameters(BIO *bp, EVP_PKEY **x)
-	{
-	char *nm=NULL;
-	const unsigned char *p=NULL;
-	unsigned char *data=NULL;
+	    pem_str, bp, x,enc, kstr, klen, cb, u);
+}
+
+EVP_PKEY *
+PEM_read_bio_Parameters(BIO *bp, EVP_PKEY **x)
+{
+	char *nm = NULL;
+	const unsigned char *p = NULL;
+	unsigned char *data = NULL;
 	long len;
 	int slen;
-	EVP_PKEY *ret=NULL;
+	EVP_PKEY *ret = NULL;
 
 	if (!PEM_bytes_read_bio(&data, &len, &nm, PEM_STRING_PARAMETERS,
-								bp, 0, NULL))
+	    bp, 0, NULL))
 		return NULL;
 	p = data;
 
-	if ((slen = pem_check_suffix(nm, "PARAMETERS")) > 0)
-		{
+	if ((slen = pem_check_suffix(nm, "PARAMETERS")) > 0) {
 		ret = EVP_PKEY_new();
 		if (!ret)
 			goto err;
-		if (!EVP_PKEY_set_type_str(ret, nm, slen)
-			|| !ret->ameth->param_decode
-			|| !ret->ameth->param_decode(ret, &p, len))
-			{
+		if (!EVP_PKEY_set_type_str(ret, nm, slen) ||
+		    !ret->ameth->param_decode ||
+		    !ret->ameth->param_decode(ret, &p, len)) {
 			EVP_PKEY_free(ret);
 			ret = NULL;
 			goto err;
-			}
-		if(x)
-			{
-			if(*x) EVP_PKEY_free((EVP_PKEY *)*x);
+		}
+		if (x) {
+			if (*x)
+				EVP_PKEY_free((EVP_PKEY *)*x);
 			*x = ret;
-			}
 		}
+	}
+
 err:
 	if (ret == NULL)
-		PEMerr(PEM_F_PEM_READ_BIO_PARAMETERS,ERR_R_ASN1_LIB);
+		PEMerr(PEM_F_PEM_READ_BIO_PARAMETERS, ERR_R_ASN1_LIB);
 	free(nm);
 	free(data);
-	return(ret);
-	}
+	return (ret);
+}
 
-int PEM_write_bio_Parameters(BIO *bp, EVP_PKEY *x)
-	{
+int
+PEM_write_bio_Parameters(BIO *bp, EVP_PKEY *x)
+{
 	char pem_str[80];
+
 	if (!x->ameth || !x->ameth->param_encode)
 		return 0;
 
 	(void) snprintf(pem_str, sizeof(pem_str), "%s PARAMETERS",
 	    x->ameth->pem_str);
-	return PEM_ASN1_write_bio(
-		(i2d_of_void *)x->ameth->param_encode,
-				pem_str,bp,x,NULL,NULL,0,0,NULL);
-	}
+	return PEM_ASN1_write_bio((i2d_of_void *)x->ameth->param_encode,
+	    pem_str, bp, x,NULL, NULL, 0,0, NULL);
+}
 
 #ifndef OPENSSL_NO_FP_API
-EVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u)
-	{
-        BIO *b;
-        EVP_PKEY *ret;
-
-        if ((b=BIO_new(BIO_s_file())) == NULL)
-		{
-		PEMerr(PEM_F_PEM_READ_PRIVATEKEY,ERR_R_BUF_LIB);
-                return(0);
-		}
-        BIO_set_fp(b,fp,BIO_NOCLOSE);
-        ret=PEM_read_bio_PrivateKey(b,x,cb,u);
-        BIO_free(b);
-        return(ret);
+EVP_PKEY *
+PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u)
+{
+	BIO *b;
+	EVP_PKEY *ret;
+
+	if ((b = BIO_new(BIO_s_file())) == NULL) {
+		PEMerr(PEM_F_PEM_READ_PRIVATEKEY, ERR_R_BUF_LIB);
+		return (0);
 	}
-
-int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
-                                               unsigned char *kstr, int klen,
-                                               pem_password_cb *cb, void *u)
-	{
-        BIO *b;
-        int ret;
-
-        if ((b=BIO_new_fp(fp, BIO_NOCLOSE)) == NULL)
-		{
-		PEMerr(PEM_F_PEM_WRITE_PRIVATEKEY,ERR_R_BUF_LIB);
-                return 0;
-		}
-        ret=PEM_write_bio_PrivateKey(b, x, enc, kstr, klen, cb, u);
-        BIO_free(b);
-        return ret;
+	BIO_set_fp(b, fp, BIO_NOCLOSE);
+	ret = PEM_read_bio_PrivateKey(b, x,cb, u);
+	BIO_free(b);
+	return (ret);
+}
+
+int
+PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
+    unsigned char *kstr, int klen, pem_password_cb *cb, void *u)
+{
+	BIO *b;
+	int ret;
+
+	if ((b = BIO_new_fp(fp, BIO_NOCLOSE)) == NULL) {
+		PEMerr(PEM_F_PEM_WRITE_PRIVATEKEY, ERR_R_BUF_LIB);
+		return 0;
 	}
+	ret = PEM_write_bio_PrivateKey(b, x, enc, kstr, klen, cb, u);
+	BIO_free(b);
+	return ret;
+}
 
 #endif
diff --git a/src/lib/libcrypto/pem/pem_seal.c b/src/lib/libcrypto/pem/pem_seal.c
index bac7b16b4..e39de08c9 100644
--- a/src/lib/libcrypto/pem/pem_seal.c
+++ b/src/lib/libcrypto/pem/pem_seal.c
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -67,125 +67,129 @@
 #include <openssl/pem.h>
 #include <openssl/rsa.h>
 
-int PEM_SealInit(PEM_ENCODE_SEAL_CTX *ctx, EVP_CIPHER *type, EVP_MD *md_type,
-	     unsigned char **ek, int *ekl, unsigned char *iv, EVP_PKEY **pubk,
-	     int npubk)
-	{
+int
+PEM_SealInit(PEM_ENCODE_SEAL_CTX *ctx, EVP_CIPHER *type, EVP_MD *md_type,
+    unsigned char **ek, int *ekl, unsigned char *iv, EVP_PKEY **pubk, int npubk)
+{
 	unsigned char key[EVP_MAX_KEY_LENGTH];
-	int ret= -1;
-	int i,j,max=0;
-	char *s=NULL;
-
-	for (i=0; i<npubk; i++)
-		{
-		if (pubk[i]->type != EVP_PKEY_RSA)
-			{
-			PEMerr(PEM_F_PEM_SEALINIT,PEM_R_PUBLIC_KEY_NO_RSA);
+	int ret = -1;
+	int i, j, max = 0;
+	char *s = NULL;
+
+	for (i = 0; i < npubk; i++) {
+		if (pubk[i]->type != EVP_PKEY_RSA) {
+			PEMerr(PEM_F_PEM_SEALINIT, PEM_R_PUBLIC_KEY_NO_RSA);
 			goto err;
-			}
-		j=RSA_size(pubk[i]->pkey.rsa);
-		if (j > max) max=j;
 		}
-	s=(char *)malloc(max*2);
-	if (s == NULL)
-		{
-		PEMerr(PEM_F_PEM_SEALINIT,ERR_R_MALLOC_FAILURE);
+		j = RSA_size(pubk[i]->pkey.rsa);
+		if (j > max)
+			max = j;
+	}
+	s = (char *)malloc(max*2);
+	if (s == NULL) {
+		PEMerr(PEM_F_PEM_SEALINIT, ERR_R_MALLOC_FAILURE);
 		goto err;
-		}
+	}
 
 	EVP_EncodeInit(&ctx->encode);
 
 	EVP_MD_CTX_init(&ctx->md);
-	if (!EVP_SignInit(&ctx->md,md_type))
+	if (!EVP_SignInit(&ctx->md, md_type))
 		goto err;
 
 	EVP_CIPHER_CTX_init(&ctx->cipher);
-	ret=EVP_SealInit(&ctx->cipher,type,ek,ekl,iv,pubk,npubk);
-	if (ret <= 0) goto err;
+	ret = EVP_SealInit(&ctx->cipher, type, ek, ekl, iv, pubk, npubk);
+	if (ret <= 0)
+		goto err;
 
 	/* base64 encode the keys */
-	for (i=0; i<npubk; i++)
-		{
-		j=EVP_EncodeBlock((unsigned char *)s,ek[i],
-			RSA_size(pubk[i]->pkey.rsa));
-		ekl[i]=j;
-		memcpy(ek[i],s,j+1);
-		}
-
-	ret=npubk;
-err:
-	if (s != NULL) free(s);
-	OPENSSL_cleanse(key,EVP_MAX_KEY_LENGTH);
-	return(ret);
+	for (i = 0; i < npubk; i++) {
+		j = EVP_EncodeBlock((unsigned char *)s, ek[i],
+		    RSA_size(pubk[i]->pkey.rsa));
+		ekl[i] = j;
+		memcpy(ek[i], s, j + 1);
 	}
 
-void PEM_SealUpdate(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *out, int *outl,
-	     unsigned char *in, int inl)
-	{
+	ret = npubk;
+
+err:
+	if (s != NULL)
+		free(s);
+	OPENSSL_cleanse(key, EVP_MAX_KEY_LENGTH);
+	return (ret);
+}
+
+void
+PEM_SealUpdate(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *out, int *outl,
+    unsigned char *in, int inl)
+{
 	unsigned char buffer[1600];
-	int i,j;
+	int i, j;
 
-	*outl=0;
-	EVP_SignUpdate(&ctx->md,in,inl);
-	for (;;)
-		{
-		if (inl <= 0) break;
+	*outl = 0;
+	EVP_SignUpdate(&ctx->md, in, inl);
+	for (;;) {
+		if (inl <= 0)
+			break;
 		if (inl > 1200)
-			i=1200;
+			i = 1200;
 		else
-			i=inl;
-		EVP_EncryptUpdate(&ctx->cipher,buffer,&j,in,i);
-		EVP_EncodeUpdate(&ctx->encode,out,&j,buffer,j);
-		*outl+=j;
-		out+=j;
-		in+=i;
-		inl-=i;
-		}
+			i = inl;
+		EVP_EncryptUpdate(&ctx->cipher, buffer, &j, in, i);
+		EVP_EncodeUpdate(&ctx->encode, out, &j, buffer, j);
+		*outl += j;
+		out += j;
+		in += i;
+		inl -= i;
 	}
-
-int PEM_SealFinal(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *sig, int *sigl,
-	     unsigned char *out, int *outl, EVP_PKEY *priv)
-	{
-	unsigned char *s=NULL;
-	int ret=0,j;
+}
+
+int
+PEM_SealFinal(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *sig, int *sigl,
+    unsigned char *out, int *outl, EVP_PKEY *priv)
+{
+	unsigned char *s = NULL;
+	int ret = 0, j;
 	unsigned int i;
 
-	if (priv->type != EVP_PKEY_RSA)
-		{
-		PEMerr(PEM_F_PEM_SEALFINAL,PEM_R_PUBLIC_KEY_NO_RSA);
+	if (priv->type != EVP_PKEY_RSA) {
+		PEMerr(PEM_F_PEM_SEALFINAL, PEM_R_PUBLIC_KEY_NO_RSA);
 		goto err;
-		}
-	i=RSA_size(priv->pkey.rsa);
-	if (i < 100) i=100;
-	s=(unsigned char *)malloc(i*2);
-	if (s == NULL)
-		{
-		PEMerr(PEM_F_PEM_SEALFINAL,ERR_R_MALLOC_FAILURE);
+	}
+	i = RSA_size(priv->pkey.rsa);
+	if (i < 100)
+		i = 100;
+	s = (unsigned char *)malloc(i*2);
+	if (s == NULL) {
+		PEMerr(PEM_F_PEM_SEALFINAL, ERR_R_MALLOC_FAILURE);
 		goto err;
-		}
+	}
 
-	if (!EVP_EncryptFinal_ex(&ctx->cipher,s,(int *)&i))
+	if (!EVP_EncryptFinal_ex(&ctx->cipher, s, (int *)&i))
 		goto err;
-	EVP_EncodeUpdate(&ctx->encode,out,&j,s,i);
-	*outl=j;
-	out+=j;
-	EVP_EncodeFinal(&ctx->encode,out,&j);
-	*outl+=j;
+	EVP_EncodeUpdate(&ctx->encode, out, &j, s, i);
+	*outl = j;
+	out += j;
+	EVP_EncodeFinal(&ctx->encode, out, &j);
+	*outl += j;
 
-	if (!EVP_SignFinal(&ctx->md,s,&i,priv)) goto err;
-	*sigl=EVP_EncodeBlock(sig,s,i);
+	if (!EVP_SignFinal(&ctx->md, s,&i, priv))
+		goto err;
+	*sigl = EVP_EncodeBlock(sig, s, i);
+
+	ret = 1;
 
-	ret=1;
 err:
 	EVP_MD_CTX_cleanup(&ctx->md);
 	EVP_CIPHER_CTX_cleanup(&ctx->cipher);
-	if (s != NULL) free(s);
-	return(ret);
-	}
+	if (s != NULL)
+		free(s);
+	return (ret);
+}
 #else /* !OPENSSL_NO_RSA */
 
 # if PEDANTIC
-static void *dummy=&dummy;
+static void *dummy = &dummy;
 # endif
 
 #endif
diff --git a/src/lib/libcrypto/pem/pem_sign.c b/src/lib/libcrypto/pem/pem_sign.c
index cbd3cd079..ab3e5ebc6 100644
--- a/src/lib/libcrypto/pem/pem_sign.c
+++ b/src/lib/libcrypto/pem/pem_sign.c
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -64,39 +64,43 @@
 #include <openssl/x509.h>
 #include <openssl/pem.h>
 
-void PEM_SignInit(EVP_MD_CTX *ctx, EVP_MD *type)
-	{
+void
+PEM_SignInit(EVP_MD_CTX *ctx, EVP_MD *type)
+{
 	EVP_DigestInit_ex(ctx, type, NULL);
-	}
+}
 
-void PEM_SignUpdate(EVP_MD_CTX *ctx, unsigned char *data,
-	     unsigned int count)
-	{
-	EVP_DigestUpdate(ctx,data,count);
-	}
+void
+PEM_SignUpdate(EVP_MD_CTX *ctx, unsigned char *data,
+    unsigned int count)
+{
+	EVP_DigestUpdate(ctx, data, count);
+}
 
-int PEM_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret, unsigned int *siglen,
-	     EVP_PKEY *pkey)
-	{
+int
+PEM_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret, unsigned int *siglen,
+    EVP_PKEY *pkey)
+{
 	unsigned char *m;
-	int i,ret=0;
+	int i, ret = 0;
 	unsigned int m_len;
 
-	m=(unsigned char *)malloc(EVP_PKEY_size(pkey)+2);
-	if (m == NULL)
-		{
-		PEMerr(PEM_F_PEM_SIGNFINAL,ERR_R_MALLOC_FAILURE);
+	m = (unsigned char *)malloc(EVP_PKEY_size(pkey) + 2);
+	if (m == NULL) {
+		PEMerr(PEM_F_PEM_SIGNFINAL, ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+
+	if (EVP_SignFinal(ctx, m,&m_len, pkey) <= 0)
 		goto err;
-		}
 
-	if (EVP_SignFinal(ctx,m,&m_len,pkey) <= 0) goto err;
+	i = EVP_EncodeBlock(sigret, m, m_len);
+	*siglen = i;
+	ret = 1;
 
-	i=EVP_EncodeBlock(sigret,m,m_len);
-	*siglen=i;
-	ret=1;
 err:
 	/* ctx has been zeroed by EVP_SignFinal() */
-	if (m != NULL) free(m);
-	return(ret);
-	}
-
+	if (m != NULL)
+		free(m);
+	return (ret);
+}
diff --git a/src/lib/libcrypto/pem/pem_x509.c b/src/lib/libcrypto/pem/pem_x509.c
index b531057dc..57b7d1d53 100644
--- a/src/lib/libcrypto/pem/pem_x509.c
+++ b/src/lib/libcrypto/pem/pem_x509.c
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
+ *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -65,4 +65,3 @@
 #include <openssl/pem.h>
 
 IMPLEMENT_PEM_rw(X509, X509, PEM_STRING_X509, X509)
-
diff --git a/src/lib/libcrypto/pem/pem_xaux.c b/src/lib/libcrypto/pem/pem_xaux.c
index 328f79620..ae381ce54 100644
--- a/src/lib/libcrypto/pem/pem_xaux.c
+++ b/src/lib/libcrypto/pem/pem_xaux.c
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
+ *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -65,4 +65,5 @@
 #include <openssl/pem.h>
 
 IMPLEMENT_PEM_rw(X509_AUX, X509, PEM_STRING_X509_TRUSTED, X509_AUX)
-IMPLEMENT_PEM_rw(X509_CERT_PAIR, X509_CERT_PAIR, PEM_STRING_X509_PAIR, X509_CERT_PAIR)
+IMPLEMENT_PEM_rw(X509_CERT_PAIR, X509_CERT_PAIR, PEM_STRING_X509_PAIR,
+    X509_CERT_PAIR)
diff --git a/src/lib/libcrypto/pem/pvkfmt.c b/src/lib/libcrypto/pem/pvkfmt.c
index 59af2020a..a7815a237 100644
--- a/src/lib/libcrypto/pem/pvkfmt.c
+++ b/src/lib/libcrypto/pem/pvkfmt.c
@@ -9,7 +9,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
+ *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -71,27 +71,31 @@
  * format
  */
 
-static unsigned int read_ledword(const unsigned char **in)
-	{
+static unsigned int
+read_ledword(const unsigned char **in)
+{
 	const unsigned char *p = *in;
 	unsigned int ret;
+
 	ret = *p++;
 	ret |= (*p++ << 8);
 	ret |= (*p++ << 16);
 	ret |= (*p++ << 24);
 	*in = p;
 	return ret;
-	}
+}
 
-/* Read a BIGNUM in little endian format. The docs say that this should take up 
+/* Read a BIGNUM in little endian format. The docs say that this should take up
  * bitlen/8 bytes.
  */
 
-static int read_lebn(const unsigned char **in, unsigned int nbyte, BIGNUM **r)
-	{
+static int
+read_lebn(const unsigned char **in, unsigned int nbyte, BIGNUM **r)
+{
 	const unsigned char *p;
 	unsigned char *tmpbuf, *q;
 	unsigned int i;
+
 	p = *in + nbyte - 1;
 	tmpbuf = malloc(nbyte);
 	if (!tmpbuf)
@@ -101,14 +105,12 @@ static int read_lebn(const unsigned char **in, unsigned int nbyte, BIGNUM **r)
 		*q++ = *p--;
 	*r = BN_bin2bn(tmpbuf, nbyte, NULL);
 	free(tmpbuf);
-	if (*r)
-		{
+	if (*r) {
 		*in += nbyte;
 		return 1;
-		}
-	else
+	} else
 		return 0;
-	}
+}
 
 
 /* Convert private key blob to EVP_PKEY: RSA and DSA keys supported */
@@ -132,106 +134,96 @@ static int read_lebn(const unsigned char **in, unsigned int nbyte, BIGNUM **r)
 #define PVK_SALTLEN		0x10
 
 static EVP_PKEY *b2i_rsa(const unsigned char **in, unsigned int length,
-						unsigned int bitlen, int ispub);
+    unsigned int bitlen, int ispub);
 static EVP_PKEY *b2i_dss(const unsigned char **in, unsigned int length,
-						unsigned int bitlen, int ispub);
+    unsigned int bitlen, int ispub);
 
-static int do_blob_header(const unsigned char **in, unsigned int length,
-				unsigned int *pmagic, unsigned int *pbitlen,
-				int *pisdss, int *pispub)
-	{
+static int
+do_blob_header(const unsigned char **in, unsigned int length,
+    unsigned int *pmagic, unsigned int *pbitlen, int *pisdss, int *pispub)
+{
 	const unsigned char *p = *in;
+
 	if (length < 16)
 		return 0;
 	/* bType */
-	if (*p == MS_PUBLICKEYBLOB)
-		{
-		if (*pispub == 0)
-			{
+	if (*p == MS_PUBLICKEYBLOB) {
+		if (*pispub == 0) {
 			PEMerr(PEM_F_DO_BLOB_HEADER,
-					PEM_R_EXPECTING_PRIVATE_KEY_BLOB);
+			    PEM_R_EXPECTING_PRIVATE_KEY_BLOB);
 			return 0;
-			}
-		*pispub = 1;
 		}
-	else if (*p == MS_PRIVATEKEYBLOB)
-		{
-		if (*pispub == 1)
-			{
+		*pispub = 1;
+	} else if (*p == MS_PRIVATEKEYBLOB) {
+		if (*pispub == 1) {
 			PEMerr(PEM_F_DO_BLOB_HEADER,
-					PEM_R_EXPECTING_PUBLIC_KEY_BLOB);
+			    PEM_R_EXPECTING_PUBLIC_KEY_BLOB);
 			return 0;
-			}
-		*pispub = 0;
 		}
-	else
+		*pispub = 0;
+	} else
 		return 0;
 	p++;
 	/* Version */
-	if (*p++ != 0x2)
-		{
+	if (*p++ != 0x2) {
 		PEMerr(PEM_F_DO_BLOB_HEADER, PEM_R_BAD_VERSION_NUMBER);
 		return 0;
-		}
+	}
 	/* Ignore reserved, aiKeyAlg */
-	p+= 6;
+	p += 6;
 	*pmagic = read_ledword(&p);
 	*pbitlen = read_ledword(&p);
 	*pisdss = 0;
-	switch (*pmagic)
-		{
+	switch (*pmagic) {
 
-		case MS_DSS1MAGIC:
+	case MS_DSS1MAGIC:
 		*pisdss = 1;
-		case MS_RSA1MAGIC:
-		if (*pispub == 0)
-			{
+	case MS_RSA1MAGIC:
+		if (*pispub == 0) {
 			PEMerr(PEM_F_DO_BLOB_HEADER,
-					PEM_R_EXPECTING_PRIVATE_KEY_BLOB);
+			    PEM_R_EXPECTING_PRIVATE_KEY_BLOB);
 			return 0;
-			}
+		}
 		break;
 
-		case MS_DSS2MAGIC:
+	case MS_DSS2MAGIC:
 		*pisdss = 1;
-		case MS_RSA2MAGIC:
-		if (*pispub == 1)
-			{
+	case MS_RSA2MAGIC:
+		if (*pispub == 1) {
 			PEMerr(PEM_F_DO_BLOB_HEADER,
-					PEM_R_EXPECTING_PUBLIC_KEY_BLOB);
+			    PEM_R_EXPECTING_PUBLIC_KEY_BLOB);
 			return 0;
-			}
+		}
 		break;
 
-		default:
+	default:
 		PEMerr(PEM_F_DO_BLOB_HEADER, PEM_R_BAD_MAGIC_NUMBER);
 		return -1;
-		}
+	}
 	*in = p;
 	return 1;
-	}
+}
 
-static unsigned int blob_length(unsigned bitlen, int isdss, int ispub)
-	{
+static unsigned int
+blob_length(unsigned bitlen, int isdss, int ispub)
+{
 	unsigned int nbyte, hnbyte;
+
 	nbyte = (bitlen + 7) >> 3;
 	hnbyte = (bitlen + 15) >> 4;
-	if (isdss)
-		{
+	if (isdss) {
 
 		/* Expected length: 20 for q + 3 components bitlen each + 24
 		 * for seed structure.
 		 */
 		if (ispub)
-			return  44 + 3 * nbyte;
+			return 44 + 3 * nbyte;
 		/* Expected length: 20 for q, priv, 2 bitlen components + 24
 		 * for seed structure.
 		 */
 		else
 			return 64 + 2 * nbyte;
-		}
-	else
-		{
+	} else {
 		/* Expected length: 4 for 'e' + 'n' */
 		if (ispub)
 			return 4 + nbyte;
@@ -239,83 +231,83 @@ static unsigned int blob_length(unsigned bitlen, int isdss, int ispub)
 		/* Expected length: 4 for 'e' and 7 other components.
 		 * 2 components are bitlen size, 5 are bitlen/2
 		 */
-			return 4 + 2*nbyte + 5*hnbyte;
-		}
-
+				return 4 + 2*nbyte + 5*hnbyte;
 	}
 
-static EVP_PKEY *do_b2i(const unsigned char **in, unsigned int length,
-								int ispub)
-	{
+}
+
+static EVP_PKEY *
+do_b2i(const unsigned char **in, unsigned int length, int ispub)
+{
 	const unsigned char *p = *in;
 	unsigned int bitlen, magic;
 	int isdss;
-	if (do_blob_header(&p, length, &magic, &bitlen, &isdss, &ispub) <= 0)
-		{
+
+	if (do_blob_header(&p, length, &magic, &bitlen, &isdss, &ispub) <= 0) {
 		PEMerr(PEM_F_DO_B2I, PEM_R_KEYBLOB_HEADER_PARSE_ERROR);
 		return NULL;
-		}
+	}
 	length -= 16;
-	if (length < blob_length(bitlen, isdss, ispub))
-		{
+	if (length < blob_length(bitlen, isdss, ispub)) {
 		PEMerr(PEM_F_DO_B2I, PEM_R_KEYBLOB_TOO_SHORT);
 		return NULL;
-		}
+	}
 	if (isdss)
 		return b2i_dss(&p, length, bitlen, ispub);
 	else
 		return b2i_rsa(&p, length, bitlen, ispub);
-	}
+}
 
-static EVP_PKEY *do_b2i_bio(BIO *in, int ispub)
-	{
+static EVP_PKEY *
+do_b2i_bio(BIO *in, int ispub)
+{
 	const unsigned char *p;
 	unsigned char hdr_buf[16], *buf = NULL;
 	unsigned int bitlen, magic, length;
 	int isdss;
 	EVP_PKEY *ret = NULL;
-	if (BIO_read(in, hdr_buf, 16) != 16)
-		{
+
+	if (BIO_read(in, hdr_buf, 16) != 16) {
 		PEMerr(PEM_F_DO_B2I_BIO, PEM_R_KEYBLOB_TOO_SHORT);
 		return NULL;
-		}
+	}
 	p = hdr_buf;
 	if (do_blob_header(&p, 16, &magic, &bitlen, &isdss, &ispub) <= 0)
 		return NULL;
 
 	length = blob_length(bitlen, isdss, ispub);
 	buf = malloc(length);
-	if (!buf)
-		{
+	if (!buf) {
 		PEMerr(PEM_F_DO_B2I_BIO, ERR_R_MALLOC_FAILURE);
 		goto err;
-		}
+	}
 	p = buf;
-	if (BIO_read(in, buf, length) != (int)length)
-		{
+	if (BIO_read(in, buf, length) != (int)length) {
 		PEMerr(PEM_F_DO_B2I_BIO, PEM_R_KEYBLOB_TOO_SHORT);
 		goto err;
-		}
+	}
 
 	if (isdss)
 		ret = b2i_dss(&p, length, bitlen, ispub);
 	else
 		ret = b2i_rsa(&p, length, bitlen, ispub);
 
-	err:
+err:
 	if (buf)
 		free(buf);
 	return ret;
-	}
+}
 
-static EVP_PKEY *b2i_dss(const unsigned char **in, unsigned int length,
-						unsigned int bitlen, int ispub)
-	{
+static EVP_PKEY *
+b2i_dss(const unsigned char **in, unsigned int length, unsigned int bitlen,
+    int ispub)
+{
 	const unsigned char *p = *in;
 	EVP_PKEY *ret = NULL;
 	DSA *dsa = NULL;
 	BN_CTX *ctx = NULL;
 	unsigned int nbyte;
+
 	nbyte = (bitlen + 7) >> 3;
 
 	dsa = DSA_new();
@@ -328,13 +320,10 @@ static EVP_PKEY *b2i_dss(const unsigned char **in, unsigned int length,
 		goto memerr;
 	if (!read_lebn(&p, nbyte, &dsa->g))
 		goto memerr;
-	if (ispub)
-		{
+	if (ispub) {
 		if (!read_lebn(&p, nbyte, &dsa->pub_key))
 			goto memerr;
-		}
-	else
-		{
+	} else {
 		if (!read_lebn(&p, 20, &dsa->priv_key))
 			goto memerr;
 		/* Calculate public key */
@@ -342,20 +331,18 @@ static EVP_PKEY *b2i_dss(const unsigned char **in, unsigned int length,
 			goto memerr;
 		if (!(ctx = BN_CTX_new()))
 			goto memerr;
-			
 		if (!BN_mod_exp(dsa->pub_key, dsa->g,
-						 dsa->priv_key, dsa->p, ctx))
-			
+		    dsa->priv_key, dsa->p, ctx))
 			goto memerr;
 		BN_CTX_free(ctx);
-		}
+	}
 
 	EVP_PKEY_set1_DSA(ret, dsa);
 	DSA_free(dsa);
 	*in = p;
 	return ret;
 
-	memerr:
+memerr:
 	PEMerr(PEM_F_B2I_DSS, ERR_R_MALLOC_FAILURE);
 	if (dsa)
 		DSA_free(dsa);
@@ -364,16 +351,17 @@ static EVP_PKEY *b2i_dss(const unsigned char **in, unsigned int length,
 	if (ctx)
 		BN_CTX_free(ctx);
 	return NULL;
-	}
+}
 
-static EVP_PKEY *b2i_rsa(const unsigned char **in, unsigned int length,
-						unsigned int bitlen, int ispub)
-		
-	{
+static EVP_PKEY *
+b2i_rsa(const unsigned char **in, unsigned int length, unsigned int bitlen,
+    int ispub)
+{
 	const unsigned char *p = *in;
 	EVP_PKEY *ret = NULL;
 	RSA *rsa = NULL;
 	unsigned int nbyte, hnbyte;
+
 	nbyte = (bitlen + 7) >> 3;
 	hnbyte = (bitlen + 15) >> 4;
 	rsa = RSA_new();
@@ -387,8 +375,7 @@ static EVP_PKEY *b2i_rsa(const unsigned char **in, unsigned int length,
 		goto memerr;
 	if (!read_lebn(&p, nbyte, &rsa->n))
 		goto memerr;
-	if (!ispub)
-		{
+	if (!ispub) {
 		if (!read_lebn(&p, hnbyte, &rsa->p))
 			goto memerr;
 		if (!read_lebn(&p, hnbyte, &rsa->q))
@@ -401,78 +388,83 @@ static EVP_PKEY *b2i_rsa(const unsigned char **in, unsigned int length,
 			goto memerr;
 		if (!read_lebn(&p, nbyte, &rsa->d))
 			goto memerr;
-		}
+	}
 
 	EVP_PKEY_set1_RSA(ret, rsa);
 	RSA_free(rsa);
 	*in = p;
 	return ret;
-	memerr:
+
+memerr:
 	PEMerr(PEM_F_B2I_RSA, ERR_R_MALLOC_FAILURE);
 	if (rsa)
 		RSA_free(rsa);
 	if (ret)
 		EVP_PKEY_free(ret);
 	return NULL;
-	}
+}
 
-EVP_PKEY *b2i_PrivateKey(const unsigned char **in, long length)
-	{
+EVP_PKEY *
+b2i_PrivateKey(const unsigned char **in, long length)
+{
 	return do_b2i(in, length, 0);
-	}
+}
 
-EVP_PKEY *b2i_PublicKey(const unsigned char **in, long length)
-	{
+EVP_PKEY *
+b2i_PublicKey(const unsigned char **in, long length)
+{
 	return do_b2i(in, length, 1);
-	}
+}
 
-
-EVP_PKEY *b2i_PrivateKey_bio(BIO *in)
-	{
+EVP_PKEY *
+b2i_PrivateKey_bio(BIO *in)
+{
 	return do_b2i_bio(in, 0);
-	}
+}
 
-EVP_PKEY *b2i_PublicKey_bio(BIO *in)
-	{
+EVP_PKEY *
+b2i_PublicKey_bio(BIO *in)
+{
 	return do_b2i_bio(in, 1);
-	}
+}
 
-static void write_ledword(unsigned char **out, unsigned int dw)
-	{
+static void
+write_ledword(unsigned char **out, unsigned int dw)
+{
 	unsigned char *p = *out;
+
 	*p++ = dw & 0xff;
-	*p++ = (dw>>8) & 0xff;
-	*p++ = (dw>>16) & 0xff;
-	*p++ = (dw>>24) & 0xff;
+	*p++ = (dw >> 8) & 0xff;
+	*p++ = (dw >> 16) & 0xff;
+	*p++ = (dw >> 24) & 0xff;
 	*out = p;
-	}
+}
 
-static void write_lebn(unsigned char **out, const BIGNUM *bn, int len)
-	{
+static void
+write_lebn(unsigned char **out, const BIGNUM *bn, int len)
+{
 	int nb, i;
 	unsigned char *p = *out, *q, c;
+
 	nb = BN_num_bytes(bn);
 	BN_bn2bin(bn, p);
 	q = p + nb - 1;
 	/* In place byte order reversal */
-	for (i = 0; i < nb/2; i++)
-		{
+	for (i = 0; i < nb / 2; i++) {
 		c = *p;
 		*p++ = *q;
 		*q-- = c;
-		}
+	}
 	*out += nb;
 	/* Pad with zeroes if we have to */
-	if (len > 0)
-		{
+	if (len > 0) {
 		len -= nb;
-		if (len > 0)
-			{
+		if (len > 0) {
 			memset(*out, 0, len);
 			*out += len;
-			}
 		}
 	}
+}
 
 
 static int check_bitlen_rsa(RSA *rsa, int ispub, unsigned int *magic);
@@ -480,40 +472,37 @@ static int check_bitlen_dsa(DSA *dsa, int ispub, unsigned int *magic);
 
 static void write_rsa(unsigned char **out, RSA *rsa, int ispub);
 static void write_dsa(unsigned char **out, DSA *dsa, int ispub);
-	
-static int do_i2b(unsigned char **out, EVP_PKEY *pk, int ispub)
-	{
+
+static int
+do_i2b(unsigned char **out, EVP_PKEY *pk, int ispub)
+{
 	unsigned char *p;
 	unsigned int bitlen, magic = 0, keyalg;
 	int outlen, noinc = 0;
-	if (pk->type == EVP_PKEY_DSA)
-		{
+
+	if (pk->type == EVP_PKEY_DSA) {
 		bitlen = check_bitlen_dsa(pk->pkey.dsa, ispub, &magic);
 		keyalg = MS_KEYALG_DSS_SIGN;
-		}
-	else if (pk->type == EVP_PKEY_RSA)
-		{
+	} else if (pk->type == EVP_PKEY_RSA) {
 		bitlen = check_bitlen_rsa(pk->pkey.rsa, ispub, &magic);
 		keyalg = MS_KEYALG_RSA_KEYX;
-		}
-	else
+	} else
 		return -1;
 	if (bitlen == 0)
 		return -1;
 	outlen = 16 + blob_length(bitlen,
-			keyalg == MS_KEYALG_DSS_SIGN ? 1 : 0, ispub);
+	    keyalg == MS_KEYALG_DSS_SIGN ? 1 : 0, ispub);
 	if (out == NULL)
 		return outlen;
 	if (*out)
 		p = *out;
-	else
-		{
+	else {
 		p = malloc(outlen);
 		if (!p)
 			return -1;
 		*out = p;
 		noinc = 1;
-		}
+	}
 	if (ispub)
 		*p++ = MS_PUBLICKEYBLOB;
 	else
@@ -531,12 +520,14 @@ static int do_i2b(unsigned char **out, EVP_PKEY *pk, int ispub)
 	if (!noinc)
 		*out += outlen;
 	return outlen;
-	}
+}
 
-static int do_i2b_bio(BIO *out, EVP_PKEY *pk, int ispub)
-	{
+static int
+do_i2b_bio(BIO *out, EVP_PKEY *pk, int ispub)
+{
 	unsigned char *tmp = NULL;
 	int outlen, wrlen;
+
 	outlen = do_i2b(&tmp, pk, ispub);
 	if (outlen < 0)
 		return -1;
@@ -545,72 +536,73 @@ static int do_i2b_bio(BIO *out, EVP_PKEY *pk, int ispub)
 	if (wrlen == outlen)
 		return outlen;
 	return -1;
-	}
+}
 
-static int check_bitlen_dsa(DSA *dsa, int ispub, unsigned int *pmagic)
-	{
+static int
+check_bitlen_dsa(DSA *dsa, int ispub, unsigned int *pmagic)
+{
 	int bitlen;
+
 	bitlen = BN_num_bits(dsa->p);
-	if ((bitlen & 7) || (BN_num_bits(dsa->q) != 160)
-		|| (BN_num_bits(dsa->g) > bitlen))
+	if ((bitlen & 7) || (BN_num_bits(dsa->q) != 160) ||
+	    (BN_num_bits(dsa->g) > bitlen))
 		goto badkey;
-	if (ispub)
-		{
+	if (ispub) {
 		if (BN_num_bits(dsa->pub_key) > bitlen)
 			goto badkey;
 		*pmagic = MS_DSS1MAGIC;
-		}
-	else
-		{
+	} else {
 		if (BN_num_bits(dsa->priv_key) > 160)
 			goto badkey;
 		*pmagic = MS_DSS2MAGIC;
-		}
-	
+	}
+
 	return bitlen;
-	badkey:
+
+badkey:
 	PEMerr(PEM_F_CHECK_BITLEN_DSA, PEM_R_UNSUPPORTED_KEY_COMPONENTS);
 	return 0;
-	}
+}
 
-static int check_bitlen_rsa(RSA *rsa, int ispub, unsigned int *pmagic)
-	{
+static int
+check_bitlen_rsa(RSA *rsa, int ispub, unsigned int *pmagic)
+{
 	int nbyte, hnbyte, bitlen;
+
 	if (BN_num_bits(rsa->e) > 32)
 		goto badkey;
 	bitlen = BN_num_bits(rsa->n);
 	nbyte = BN_num_bytes(rsa->n);
 	hnbyte = (BN_num_bits(rsa->n) + 15) >> 4;
-	if (ispub)
-		{
+	if (ispub) {
 		*pmagic = MS_RSA1MAGIC;
 		return bitlen;
-		}
-	else
-	{
+	} else {
 		*pmagic = MS_RSA2MAGIC;
 		/* For private key each component must fit within nbyte or
 		 * hnbyte.
 		 */
 		if (BN_num_bytes(rsa->d) > nbyte)
 			goto badkey;
-		if ((BN_num_bytes(rsa->iqmp) > hnbyte)
-			|| (BN_num_bytes(rsa->p) > hnbyte)
-			|| (BN_num_bytes(rsa->q) > hnbyte)
-			|| (BN_num_bytes(rsa->dmp1) > hnbyte)
-			|| (BN_num_bytes(rsa->dmq1) > hnbyte))
+		if ((BN_num_bytes(rsa->iqmp) > hnbyte) ||
+		    (BN_num_bytes(rsa->p) > hnbyte) ||
+		    (BN_num_bytes(rsa->q) > hnbyte) ||
+		    (BN_num_bytes(rsa->dmp1) > hnbyte) ||
+		    (BN_num_bytes(rsa->dmq1) > hnbyte))
 			goto badkey;
 	}
 	return bitlen;
-	badkey:
+
+badkey:
 	PEMerr(PEM_F_CHECK_BITLEN_RSA, PEM_R_UNSUPPORTED_KEY_COMPONENTS);
 	return 0;
-	}
-
+}
 
-static void write_rsa(unsigned char **out, RSA *rsa, int ispub)
-	{
+static void
+write_rsa(unsigned char **out, RSA *rsa, int ispub)
+{
 	int nbyte, hnbyte;
+
 	nbyte = BN_num_bytes(rsa->n);
 	hnbyte = (BN_num_bits(rsa->n) + 15) >> 4;
 	write_lebn(out, rsa->e, 4);
@@ -623,12 +615,13 @@ static void write_rsa(unsigned char **out, RSA *rsa, int ispub)
 	write_lebn(out, rsa->dmq1, hnbyte);
 	write_lebn(out, rsa->iqmp, hnbyte);
 	write_lebn(out, rsa->d, nbyte);
-	}
+}
 
-	
-static void write_dsa(unsigned char **out, DSA *dsa, int ispub)
-	{
+static void
+write_dsa(unsigned char **out, DSA *dsa, int ispub)
+{
 	int nbyte;
+
 	nbyte = BN_num_bytes(dsa->p);
 	write_lebn(out, dsa->p, nbyte);
 	write_lebn(out, dsa->q, 20);
@@ -641,52 +634,47 @@ static void write_dsa(unsigned char **out, DSA *dsa, int ispub)
 	memset(*out, 0xff, 24);
 	*out += 24;
 	return;
-	}
-	
+}
 
-int i2b_PrivateKey_bio(BIO *out, EVP_PKEY *pk)
-	{
+int
+i2b_PrivateKey_bio(BIO *out, EVP_PKEY *pk)
+{
 	return do_i2b_bio(out, pk, 0);
-	}
+}
 
-int i2b_PublicKey_bio(BIO *out, EVP_PKEY *pk)
-	{
+int
+i2b_PublicKey_bio(BIO *out, EVP_PKEY *pk)
+{
 	return do_i2b_bio(out, pk, 1);
-	}
+}
 
 #ifndef OPENSSL_NO_RC4
 
-static int do_PVK_header(const unsigned char **in, unsigned int length,
-		int skip_magic,
-	       	unsigned int *psaltlen, unsigned int *pkeylen)
-		
-	{
+static int
+do_PVK_header(const unsigned char **in, unsigned int length, int skip_magic,
+    unsigned int *psaltlen, unsigned int *pkeylen)
+{
 	const unsigned char *p = *in;
 	unsigned int pvk_magic, is_encrypted;
-	if (skip_magic)
-		{
-		if (length < 20)
-			{
+
+	if (skip_magic) {
+		if (length < 20) {
 			PEMerr(PEM_F_DO_PVK_HEADER, PEM_R_PVK_TOO_SHORT);
 			return 0;
-			}
-		length -= 20;
 		}
-	else
-		{
-		if (length < 24)
-			{
+		length -= 20;
+	} else {
+		if (length < 24) {
 			PEMerr(PEM_F_DO_PVK_HEADER, PEM_R_PVK_TOO_SHORT);
 			return 0;
-			}
+		}
 		length -= 24;
 		pvk_magic = read_ledword(&p);
-		if (pvk_magic != MS_PVKMAGIC)
-			{
+		if (pvk_magic != MS_PVKMAGIC) {
 			PEMerr(PEM_F_DO_PVK_HEADER, PEM_R_BAD_MAGIC_NUMBER);
 			return 0;
-			}
 		}
+	}
 	/* Skip reserved */
 	p += 4;
 	/*keytype = */read_ledword(&p);
@@ -694,64 +682,61 @@ static int do_PVK_header(const unsigned char **in, unsigned int length,
 	*psaltlen = read_ledword(&p);
 	*pkeylen = read_ledword(&p);
 
-	if (is_encrypted && !*psaltlen)
-		{
+	if (is_encrypted && !*psaltlen) {
 		PEMerr(PEM_F_DO_PVK_HEADER, PEM_R_INCONSISTENT_HEADER);
 		return 0;
-		}
+	}
 
 	*in = p;
 	return 1;
-	}
+}
 
-static int derive_pvk_key(unsigned char *key, 
-			const unsigned char *salt, unsigned int saltlen,
-			const unsigned char *pass, int passlen)
-	{
+static int
+derive_pvk_key(unsigned char *key, const unsigned char *salt,
+    unsigned int saltlen, const unsigned char *pass, int passlen)
+{
 	EVP_MD_CTX mctx;
 	int rv = 1;
+
 	EVP_MD_CTX_init(&mctx);
-	if (!EVP_DigestInit_ex(&mctx, EVP_sha1(), NULL)
-		|| !EVP_DigestUpdate(&mctx, salt, saltlen)
-		|| !EVP_DigestUpdate(&mctx, pass, passlen)
-		|| !EVP_DigestFinal_ex(&mctx, key, NULL))
-			rv = 0;
+	if (!EVP_DigestInit_ex(&mctx, EVP_sha1(), NULL) ||
+	    !EVP_DigestUpdate(&mctx, salt, saltlen) ||
+	    !EVP_DigestUpdate(&mctx, pass, passlen) ||
+	    !EVP_DigestFinal_ex(&mctx, key, NULL))
+		rv = 0;
 
 	EVP_MD_CTX_cleanup(&mctx);
 	return rv;
-	}
-	
+}
 
-static EVP_PKEY *do_PVK_body(const unsigned char **in,
-		unsigned int saltlen, unsigned int keylen,
-		pem_password_cb *cb, void *u)
-	{
+static EVP_PKEY *
+do_PVK_body(const unsigned char **in, unsigned int saltlen,
+    unsigned int keylen, pem_password_cb *cb, void *u)
+{
 	EVP_PKEY *ret = NULL;
 	const unsigned char *p = *in;
 	unsigned int magic;
 	unsigned char *enctmp = NULL, *q;
+
 	EVP_CIPHER_CTX cctx;
 	EVP_CIPHER_CTX_init(&cctx);
-	if (saltlen)
-		{
+	if (saltlen) {
 		char psbuf[PEM_BUFSIZE];
 		unsigned char keybuf[20];
 		int enctmplen, inlen;
 		if (cb)
-			inlen=cb(psbuf,PEM_BUFSIZE,0,u);
+			inlen = cb(psbuf, PEM_BUFSIZE, 0, u);
 		else
-			inlen=PEM_def_callback(psbuf,PEM_BUFSIZE,0,u);
-		if (inlen <= 0)
-			{
-			PEMerr(PEM_F_DO_PVK_BODY,PEM_R_BAD_PASSWORD_READ);
+			inlen = PEM_def_callback(psbuf, PEM_BUFSIZE, 0, u);
+		if (inlen <= 0) {
+			PEMerr(PEM_F_DO_PVK_BODY, PEM_R_BAD_PASSWORD_READ);
 			return NULL;
-			}
+		}
 		enctmp = malloc(keylen + 8);
-		if (!enctmp)
-			{
+		if (!enctmp) {
 			PEMerr(PEM_F_DO_PVK_BODY, ERR_R_MALLOC_FAILURE);
 			return NULL;
-			}
+		}
 		if (!derive_pvk_key(keybuf, p, saltlen,
 			    (unsigned char *)psbuf, inlen)) {
 			free(enctmp);
@@ -770,88 +755,84 @@ static EVP_PKEY *do_PVK_body(const unsigned char **in,
 		if (!EVP_DecryptFinal_ex(&cctx, q + enctmplen, &enctmplen))
 			goto err;
 		magic = read_ledword((const unsigned char **)&q);
-		if (magic != MS_RSA2MAGIC && magic != MS_DSS2MAGIC)
-			{
+		if (magic != MS_RSA2MAGIC && magic != MS_DSS2MAGIC) {
 			q = enctmp + 8;
 			memset(keybuf + 5, 0, 11);
 			if (!EVP_DecryptInit_ex(&cctx, EVP_rc4(), NULL, keybuf,
-								NULL))
+			    NULL))
 				goto err;
 			OPENSSL_cleanse(keybuf, 20);
 			if (!EVP_DecryptUpdate(&cctx, q, &enctmplen, p, inlen))
 				goto err;
 			if (!EVP_DecryptFinal_ex(&cctx, q + enctmplen,
-								&enctmplen))
+			    &enctmplen))
 				goto err;
 			magic = read_ledword((const unsigned char **)&q);
-			if (magic != MS_RSA2MAGIC && magic != MS_DSS2MAGIC)
-				{
+			if (magic != MS_RSA2MAGIC && magic != MS_DSS2MAGIC) {
 				PEMerr(PEM_F_DO_PVK_BODY, PEM_R_BAD_DECRYPT);
 				goto err;
-				}
 			}
-		else
+		} else
 			OPENSSL_cleanse(keybuf, 20);
 		p = enctmp;
-		}
+	}
 
 	ret = b2i_PrivateKey(&p, keylen);
-	err:
+
+err:
 	EVP_CIPHER_CTX_cleanup(&cctx);
 	if (enctmp && saltlen)
 		free(enctmp);
 	return ret;
-	}
+}
 
 
-EVP_PKEY *b2i_PVK_bio(BIO *in, pem_password_cb *cb, void *u)
-	{
+EVP_PKEY *
+b2i_PVK_bio(BIO *in, pem_password_cb *cb, void *u)
+{
 	unsigned char pvk_hdr[24], *buf = NULL;
 	const unsigned char *p;
 	int buflen;
 	EVP_PKEY *ret = NULL;
 	unsigned int saltlen, keylen;
-	if (BIO_read(in, pvk_hdr, 24) != 24)
-		{
+
+	if (BIO_read(in, pvk_hdr, 24) != 24) {
 		PEMerr(PEM_F_B2I_PVK_BIO, PEM_R_PVK_DATA_TOO_SHORT);
 		return NULL;
-		}
+	}
 	p = pvk_hdr;
 
 	if (!do_PVK_header(&p, 24, 0, &saltlen, &keylen))
 		return 0;
 	buflen = (int) keylen + saltlen;
 	buf = malloc(buflen);
-	if (!buf)
-		{
+	if (!buf) {
 		PEMerr(PEM_F_B2I_PVK_BIO, ERR_R_MALLOC_FAILURE);
 		return 0;
-		}
+	}
 	p = buf;
-	if (BIO_read(in, buf, buflen) != buflen)
-		{
+	if (BIO_read(in, buf, buflen) != buflen) {
 		PEMerr(PEM_F_B2I_PVK_BIO, PEM_R_PVK_DATA_TOO_SHORT);
 		goto err;
-		}
+	}
 	ret = do_PVK_body(&p, saltlen, keylen, cb, u);
 
-	err:
-	if (buf)
-		{
+err:
+	if (buf) {
 		OPENSSL_cleanse(buf, buflen);
 		free(buf);
-		}
-	return ret;
 	}
+	return ret;
+}
 
-	
-	
-static int i2b_PVK(unsigned char **out, EVP_PKEY*pk, int enclevel,
-		pem_password_cb *cb, void *u)
-	{
+static int
+i2b_PVK(unsigned char **out, EVP_PKEY*pk, int enclevel, pem_password_cb *cb,
+    void *u)
+{
 	int outlen = 24, pklen;
 	unsigned char *p, *salt = NULL;
 	EVP_CIPHER_CTX cctx;
+
 	EVP_CIPHER_CTX_init(&cctx);
 	if (enclevel)
 		outlen += PVK_SALTLEN;
@@ -863,16 +844,14 @@ static int i2b_PVK(unsigned char **out, EVP_PKEY*pk, int enclevel,
 		return outlen;
 	if (*out)
 		p = *out;
-	else
-		{
+	else {
 		p = malloc(outlen);
-		if (!p)
-			{
-			PEMerr(PEM_F_I2B_PVK,ERR_R_MALLOC_FAILURE);
+		if (!p) {
+			PEMerr(PEM_F_I2B_PVK, ERR_R_MALLOC_FAILURE);
 			return -1;
-			}
-		*out = p;
 		}
+		*out = p;
+	}
 
 	write_ledword(&p, MS_PVKMAGIC);
 	write_ledword(&p, 0);
@@ -881,34 +860,31 @@ static int i2b_PVK(unsigned char **out, EVP_PKEY*pk, int enclevel,
 	else
 		write_ledword(&p, MS_KEYTYPE_KEYX);
 	write_ledword(&p, enclevel ? 1 : 0);
-	write_ledword(&p, enclevel ? PVK_SALTLEN: 0);
+	write_ledword(&p, enclevel ? PVK_SALTLEN : 0);
 	write_ledword(&p, pklen);
-	if (enclevel)
-		{
+	if (enclevel) {
 		if (RAND_bytes(p, PVK_SALTLEN) <= 0)
 			goto error;
 		salt = p;
 		p += PVK_SALTLEN;
-		}
+	}
 	do_i2b(&p, pk, 0);
 	if (enclevel == 0)
 		return outlen;
-	else
-		{
+	else {
 		char psbuf[PEM_BUFSIZE];
 		unsigned char keybuf[20];
 		int enctmplen, inlen;
 		if (cb)
-			inlen=cb(psbuf,PEM_BUFSIZE,1,u);
+			inlen = cb(psbuf, PEM_BUFSIZE, 1, u);
 		else
-			inlen=PEM_def_callback(psbuf,PEM_BUFSIZE,1,u);
-		if (inlen <= 0)
-			{
-			PEMerr(PEM_F_I2B_PVK,PEM_R_BAD_PASSWORD_READ);
+			inlen = PEM_def_callback(psbuf, PEM_BUFSIZE, 1, u);
+		if (inlen <= 0) {
+			PEMerr(PEM_F_I2B_PVK, PEM_R_BAD_PASSWORD_READ);
 			goto error;
-			}
+		}
 		if (!derive_pvk_key(keybuf, salt, PVK_SALTLEN,
-			    (unsigned char *)psbuf, inlen))
+		    (unsigned char *)psbuf, inlen))
 			goto error;
 		if (enclevel == 1)
 			memset(keybuf + 5, 0, 11);
@@ -920,32 +896,32 @@ static int i2b_PVK(unsigned char **out, EVP_PKEY*pk, int enclevel,
 			goto error;
 		if (!EVP_DecryptFinal_ex(&cctx, p + enctmplen, &enctmplen))
 			goto error;
-		}
+	}
 	EVP_CIPHER_CTX_cleanup(&cctx);
 	return outlen;
 
-	error:
+error:
 	EVP_CIPHER_CTX_cleanup(&cctx);
 	return -1;
-	}
+}
 
-int i2b_PVK_bio(BIO *out, EVP_PKEY *pk, int enclevel,
-		pem_password_cb *cb, void *u)
-	{
+int
+i2b_PVK_bio(BIO *out, EVP_PKEY *pk, int enclevel, pem_password_cb *cb, void *u)
+{
 	unsigned char *tmp = NULL;
 	int outlen, wrlen;
+
 	outlen = i2b_PVK(&tmp, pk, enclevel, cb, u);
 	if (outlen < 0)
 		return -1;
 	wrlen = BIO_write(out, tmp, outlen);
 	free(tmp);
-	if (wrlen == outlen)
-		{
+	if (wrlen == outlen) {
 		PEMerr(PEM_F_I2B_PVK_BIO, PEM_R_BIO_WRITE_FAILURE);
 		return outlen;
-		}
-	return -1;
 	}
+	return -1;
+}
 
 #endif
 
diff --git a/src/lib/libssl/src/crypto/pem/pem.h b/src/lib/libssl/src/crypto/pem/pem.h
index e27440330..4af2db4b3 100644
--- a/src/lib/libssl/src/crypto/pem/pem.h
+++ b/src/lib/libssl/src/crypto/pem/pem.h
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -139,12 +139,11 @@ extern "C" {
 
   /* Note that this structure is initialised by PEM_SealInit and cleaned up
      by PEM_SealFinal (at least for now) */
-typedef struct PEM_Encode_Seal_st
-	{
+typedef struct PEM_Encode_Seal_st {
 	EVP_ENCODE_CTX encode;
 	EVP_MD_CTX md;
 	EVP_CIPHER_CTX cipher;
-	} PEM_ENCODE_SEAL_CTX;
+} PEM_ENCODE_SEAL_CTX;
 
 /* enc_type is one off */
 #define PEM_TYPE_ENCRYPTED      10
@@ -152,24 +151,22 @@ typedef struct PEM_Encode_Seal_st
 #define PEM_TYPE_MIC_CLEAR      30
 #define PEM_TYPE_CLEAR		40
 
-typedef struct pem_recip_st
-	{
+typedef struct pem_recip_st {
 	char *name;
 	X509_NAME *dn;
 
 	int cipher;
 	int key_enc;
 	/*	char iv[8]; unused and wrong size */
-	} PEM_USER;
+} PEM_USER;
 
-typedef struct pem_ctx_st
-	{
+typedef struct pem_ctx_st {
 	int type;		/* what type of object */
 
 	struct	{
-		int version;	
-		int mode;		
-		} proc_type;
+		int version;
+		int mode;
+	} proc_type;
 
 	char *domain;
 
@@ -177,14 +174,14 @@ typedef struct pem_ctx_st
 		int cipher;
 	/* unused, and wrong size
 	   unsigned char iv[8]; */
-		} DEK_info;
-		
+	} DEK_info;
+
 	PEM_USER *originator;
 
 	int num_recipient;
 	PEM_USER **recipient;
 
-	/* XXX(ben): don#t think this is used! 
+	/* XXX(ben): don#t think this is used!
 		STACK *x509_chain;	/ * certificate chain */
 	EVP_MD *md;		/* signature type */
 
@@ -198,11 +195,10 @@ typedef struct pem_ctx_st
 	/* unused, and wrong size
 	   unsigned char iv[8]; */
 
-	
 	int  data_enc;		/* is the data encrypted */
 	int data_len;
 	unsigned char *data;
-	} PEM_CTX;
+} PEM_CTX;
 
 /* These macros make the PEM_read/PEM_write functions easier to maintain and
  * write. Now they are all implemented with either:
@@ -223,7 +219,7 @@ typedef struct pem_ctx_st
 type *PEM_read_##name(FILE *fp, type **x, pem_password_cb *cb, void *u)\
 { \
 return PEM_ASN1_read((d2i_of_void *)d2i_##asn1, str,fp,(void **)x,cb,u); \
-} 
+}
 
 #define IMPLEMENT_PEM_write_fp(name, type, str, asn1) \
 int PEM_write_##name(FILE *fp, type *x) \
@@ -289,23 +285,23 @@ int PEM_write_bio_##name(BIO *bp, type *x, const EVP_CIPHER *enc, \
 
 #define IMPLEMENT_PEM_write(name, type, str, asn1) \
 	IMPLEMENT_PEM_write_bio(name, type, str, asn1) \
-	IMPLEMENT_PEM_write_fp(name, type, str, asn1) 
+	IMPLEMENT_PEM_write_fp(name, type, str, asn1)
 
 #define IMPLEMENT_PEM_write_const(name, type, str, asn1) \
 	IMPLEMENT_PEM_write_bio_const(name, type, str, asn1) \
-	IMPLEMENT_PEM_write_fp_const(name, type, str, asn1) 
+	IMPLEMENT_PEM_write_fp_const(name, type, str, asn1)
 
 #define IMPLEMENT_PEM_write_cb(name, type, str, asn1) \
 	IMPLEMENT_PEM_write_cb_bio(name, type, str, asn1) \
-	IMPLEMENT_PEM_write_cb_fp(name, type, str, asn1) 
+	IMPLEMENT_PEM_write_cb_fp(name, type, str, asn1)
 
 #define IMPLEMENT_PEM_write_cb_const(name, type, str, asn1) \
 	IMPLEMENT_PEM_write_cb_bio_const(name, type, str, asn1) \
-	IMPLEMENT_PEM_write_cb_fp_const(name, type, str, asn1) 
+	IMPLEMENT_PEM_write_cb_fp_const(name, type, str, asn1)
 
 #define IMPLEMENT_PEM_read(name, type, str, asn1) \
 	IMPLEMENT_PEM_read_bio(name, type, str, asn1) \
-	IMPLEMENT_PEM_read_fp(name, type, str, asn1) 
+	IMPLEMENT_PEM_read_fp(name, type, str, asn1)
 
 #define IMPLEMENT_PEM_rw(name, type, str, asn1) \
 	IMPLEMENT_PEM_read(name, type, str, asn1) \
@@ -369,7 +365,7 @@ int PEM_write_bio_##name(BIO *bp, type *x, const EVP_CIPHER *enc, \
 
 #define DECLARE_PEM_write(name, type) \
 	DECLARE_PEM_write_bio(name, type) \
-	DECLARE_PEM_write_fp(name, type) 
+	DECLARE_PEM_write_fp(name, type)
 
 #define DECLARE_PEM_write_const(name, type) \
 	DECLARE_PEM_write_bio_const(name, type) \
@@ -377,7 +373,7 @@ int PEM_write_bio_##name(BIO *bp, type *x, const EVP_CIPHER *enc, \
 
 #define DECLARE_PEM_write_cb(name, type) \
 	DECLARE_PEM_write_cb_bio(name, type) \
-	DECLARE_PEM_write_cb_fp(name, type) 
+	DECLARE_PEM_write_cb_fp(name, type)
 
 #define DECLARE_PEM_read(name, type) \
 	DECLARE_PEM_read_bio(name, type) \
@@ -404,50 +400,52 @@ typedef int pem_password_cb(char *buf, int size, int rwflag);
 #endif
 
 int	PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher);
-int	PEM_do_header (EVP_CIPHER_INFO *cipher, unsigned char *data,long *len,
-	pem_password_cb *callback,void *u);
+int	PEM_do_header (EVP_CIPHER_INFO *cipher, unsigned char *data, long *len,
+	    pem_password_cb *callback, void *u);
 
 #ifndef OPENSSL_NO_BIO
 int	PEM_read_bio(BIO *bp, char **name, char **header,
-		unsigned char **data,long *len);
-int	PEM_write_bio(BIO *bp,const char *name,char *hdr,unsigned char *data,
-		long len);
-int PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm, const char *name, BIO *bp,
-	     pem_password_cb *cb, void *u);
+	    unsigned char **data, long *len);
+int	PEM_write_bio(BIO *bp, const char *name, char *hdr, unsigned char *data,
+	    long len);
+int	PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm,
+	    const char *name, BIO *bp, pem_password_cb *cb, void *u);
 void *	PEM_ASN1_read_bio(d2i_of_void *d2i, const char *name, BIO *bp,
-			  void **x, pem_password_cb *cb, void *u);
-int	PEM_ASN1_write_bio(i2d_of_void *i2d,const char *name,BIO *bp, void *x,
-			   const EVP_CIPHER *enc,unsigned char *kstr,int klen,
-			   pem_password_cb *cb, void *u);
-
-STACK_OF(X509_INFO) *	PEM_X509_INFO_read_bio(BIO *bp, STACK_OF(X509_INFO) *sk, pem_password_cb *cb, void *u);
-int	PEM_X509_INFO_write_bio(BIO *bp,X509_INFO *xi, EVP_CIPHER *enc,
-		unsigned char *kstr, int klen, pem_password_cb *cd, void *u);
+	    void **x, pem_password_cb *cb, void *u);
+int	PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp, void *x,
+	    const EVP_CIPHER *enc, unsigned char *kstr, int klen,
+	    pem_password_cb *cb, void *u);
+
+STACK_OF(X509_INFO) *	PEM_X509_INFO_read_bio(BIO *bp,
+	    STACK_OF(X509_INFO) *sk, pem_password_cb *cb, void *u);
+int	PEM_X509_INFO_write_bio(BIO *bp, X509_INFO *xi, EVP_CIPHER *enc,
+	    unsigned char *kstr, int klen, pem_password_cb *cd, void *u);
 #endif
 
 int	PEM_read(FILE *fp, char **name, char **header,
-		unsigned char **data,long *len);
-int	PEM_write(FILE *fp,char *name,char *hdr,unsigned char *data,long len);
+	    unsigned char **data, long *len);
+int	PEM_write(FILE *fp, char *name, char *hdr, unsigned char *data,
+	    long len);
 void *  PEM_ASN1_read(d2i_of_void *d2i, const char *name, FILE *fp, void **x,
-		      pem_password_cb *cb, void *u);
-int	PEM_ASN1_write(i2d_of_void *i2d,const char *name,FILE *fp,
-		       void *x,const EVP_CIPHER *enc,unsigned char *kstr,
-		       int klen,pem_password_cb *callback, void *u);
+	    pem_password_cb *cb, void *u);
+int	PEM_ASN1_write(i2d_of_void *i2d, const char *name, FILE *fp,
+	    void *x, const EVP_CIPHER *enc, unsigned char *kstr,
+	    int klen, pem_password_cb *callback, void *u);
 STACK_OF(X509_INFO) *	PEM_X509_INFO_read(FILE *fp, STACK_OF(X509_INFO) *sk,
-	pem_password_cb *cb, void *u);
+	    pem_password_cb *cb, void *u);
 
 int	PEM_SealInit(PEM_ENCODE_SEAL_CTX *ctx, EVP_CIPHER *type,
-		EVP_MD *md_type, unsigned char **ek, int *ekl,
-		unsigned char *iv, EVP_PKEY **pubk, int npubk);
+	    EVP_MD *md_type, unsigned char **ek, int *ekl,
+	    unsigned char *iv, EVP_PKEY **pubk, int npubk);
 void	PEM_SealUpdate(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *out, int *outl,
-		unsigned char *in, int inl);
-int	PEM_SealFinal(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *sig,int *sigl,
-		unsigned char *out, int *outl, EVP_PKEY *priv);
+	    unsigned char *in, int inl);
+int	PEM_SealFinal(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *sig, int *sigl,
+	    unsigned char *out, int *outl, EVP_PKEY *priv);
 
 void    PEM_SignInit(EVP_MD_CTX *ctx, EVP_MD *type);
-void    PEM_SignUpdate(EVP_MD_CTX *ctx,unsigned char *d,unsigned int cnt);
+void    PEM_SignUpdate(EVP_MD_CTX *ctx, unsigned char *d, unsigned int cnt);
 int	PEM_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret,
-		unsigned int *siglen, EVP_PKEY *pkey);
+	    unsigned int *siglen, EVP_PKEY *pkey);
 
 int	PEM_def_callback(char *buf, int num, int w, void *key);
 void	PEM_proc_type(char *buf, int type);
@@ -509,32 +507,34 @@ DECLARE_PEM_rw_cb(PrivateKey, EVP_PKEY)
 DECLARE_PEM_rw(PUBKEY, EVP_PKEY)
 
 int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u);
+    char *kstr, int klen,
+    pem_password_cb *cb, void *u);
 int PEM_write_bio_PKCS8PrivateKey(BIO *, EVP_PKEY *, const EVP_CIPHER *,
-                                  char *, int, pem_password_cb *, void *);
+    char *, int, pem_password_cb *, void *);
 int i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u);
+    char *kstr, int klen,
+    pem_password_cb *cb, void *u);
 int i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u);
-EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u);
+    char *kstr, int klen,
+    pem_password_cb *cb, void *u);
+EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
+    void *u);
 
 int i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u);
+    char *kstr, int klen,
+    pem_password_cb *cb, void *u);
 int i2d_PKCS8PrivateKey_nid_fp(FILE *fp, EVP_PKEY *x, int nid,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u);
+    char *kstr, int klen,
+    pem_password_cb *cb, void *u);
 int PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u);
+    char *kstr, int klen,
+    pem_password_cb *cb, void *u);
 
-EVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u);
+EVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb,
+    void *u);
 
-int PEM_write_PKCS8PrivateKey(FILE *fp,EVP_PKEY *x,const EVP_CIPHER *enc,
-			      char *kstr,int klen, pem_password_cb *cd, void *u);
+int PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
+    char *kstr, int klen, pem_password_cb *cd, void *u);
 
 EVP_PKEY *PEM_read_bio_Parameters(BIO *bp, EVP_PKEY **x);
 int PEM_write_bio_Parameters(BIO *bp, EVP_PKEY *x);
@@ -548,8 +548,8 @@ int i2b_PrivateKey_bio(BIO *out, EVP_PKEY *pk);
 int i2b_PublicKey_bio(BIO *out, EVP_PKEY *pk);
 #ifndef OPENSSL_NO_RC4
 EVP_PKEY *b2i_PVK_bio(BIO *in, pem_password_cb *cb, void *u);
-int i2b_PVK_bio(BIO *out, EVP_PKEY *pk, int enclevel,
-		pem_password_cb *cb, void *u);
+int i2b_PVK_bio(BIO *out, EVP_PKEY *pk, int enclevel, pem_password_cb *cb,
+    void *u);
 #endif
 
 
diff --git a/src/lib/libssl/src/crypto/pem/pem2.h b/src/lib/libssl/src/crypto/pem/pem2.h
index f31790d69..84897d5ec 100644
--- a/src/lib/libssl/src/crypto/pem/pem2.h
+++ b/src/lib/libssl/src/crypto/pem/pem2.h
@@ -6,7 +6,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
+ *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
diff --git a/src/lib/libssl/src/crypto/pem/pem_all.c b/src/lib/libssl/src/crypto/pem/pem_all.c
index 6ff6be7fb..8b54d1a69 100644
--- a/src/lib/libssl/src/crypto/pem/pem_all.c
+++ b/src/lib/libssl/src/crypto/pem/pem_all.c
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -63,7 +63,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
+ *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -146,7 +146,7 @@ IMPLEMENT_PEM_rw(X509_CRL, X509_CRL, PEM_STRING_X509_CRL, X509_CRL)
 IMPLEMENT_PEM_rw(PKCS7, PKCS7, PEM_STRING_PKCS7, PKCS7)
 
 IMPLEMENT_PEM_rw(NETSCAPE_CERT_SEQUENCE, NETSCAPE_CERT_SEQUENCE,
-					PEM_STRING_X509, NETSCAPE_CERT_SEQUENCE)
+    PEM_STRING_X509, NETSCAPE_CERT_SEQUENCE)
 
 
 #ifndef OPENSSL_NO_RSA
@@ -159,34 +159,40 @@ IMPLEMENT_PEM_rw(NETSCAPE_CERT_SEQUENCE, NETSCAPE_CERT_SEQUENCE,
  * transparently.
  */
 
-static RSA *pkey_get_rsa(EVP_PKEY *key, RSA **rsa)
+static RSA *
+pkey_get_rsa(EVP_PKEY *key, RSA **rsa)
 {
 	RSA *rtmp;
-	if(!key) return NULL;
+
+	if (!key)
+		return NULL;
 	rtmp = EVP_PKEY_get1_RSA(key);
 	EVP_PKEY_free(key);
-	if(!rtmp) return NULL;
-	if(rsa) {
+	if (!rtmp)
+		return NULL;
+	if (rsa) {
 		RSA_free(*rsa);
 		*rsa = rtmp;
 	}
 	return rtmp;
 }
 
-RSA *PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **rsa, pem_password_cb *cb,
-								void *u)
+RSA *
+PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **rsa, pem_password_cb *cb, void *u)
 {
 	EVP_PKEY *pktmp;
+
 	pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
 	return pkey_get_rsa(pktmp, rsa);
 }
 
 #ifndef OPENSSL_NO_FP_API
 
-RSA *PEM_read_RSAPrivateKey(FILE *fp, RSA **rsa, pem_password_cb *cb,
-								void *u)
+RSA *
+PEM_read_RSAPrivateKey(FILE *fp, RSA **rsa, pem_password_cb *cb, void *u)
 {
 	EVP_PKEY *pktmp;
+
 	pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
 	return pkey_get_rsa(pktmp, rsa);
 }
@@ -202,24 +208,29 @@ IMPLEMENT_PEM_rw(RSA_PUBKEY, RSA, PEM_STRING_PUBLIC, RSA_PUBKEY)
 
 #ifndef OPENSSL_NO_DSA
 
-static DSA *pkey_get_dsa(EVP_PKEY *key, DSA **dsa)
+static DSA *
+pkey_get_dsa(EVP_PKEY *key, DSA **dsa)
 {
 	DSA *dtmp;
-	if(!key) return NULL;
+
+	if (!key)
+		return NULL;
 	dtmp = EVP_PKEY_get1_DSA(key);
 	EVP_PKEY_free(key);
-	if(!dtmp) return NULL;
-	if(dsa) {
+	if (!dtmp)
+		return NULL;
+	if (dsa) {
 		DSA_free(*dsa);
 		*dsa = dtmp;
 	}
 	return dtmp;
 }
 
-DSA *PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **dsa, pem_password_cb *cb,
-								void *u)
+DSA *
+PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **dsa, pem_password_cb *cb, void *u)
 {
 	EVP_PKEY *pktmp;
+
 	pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
 	return pkey_get_dsa(pktmp, dsa);	/* will free pktmp */
 }
@@ -230,10 +241,11 @@ IMPLEMENT_PEM_rw(DSA_PUBKEY, DSA, PEM_STRING_PUBLIC, DSA_PUBKEY)
 
 #ifndef OPENSSL_NO_FP_API
 
-DSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **dsa, pem_password_cb *cb,
-								void *u)
+DSA *
+PEM_read_DSAPrivateKey(FILE *fp, DSA **dsa, pem_password_cb *cb, void *u)
 {
 	EVP_PKEY *pktmp;
+
 	pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
 	return pkey_get_dsa(pktmp, dsa);	/* will free pktmp */
 }
@@ -246,43 +258,47 @@ IMPLEMENT_PEM_rw_const(DSAparams, DSA, PEM_STRING_DSAPARAMS, DSAparams)
 
 
 #ifndef OPENSSL_NO_EC
-static EC_KEY *pkey_get_eckey(EVP_PKEY *key, EC_KEY **eckey)
+static EC_KEY *
+pkey_get_eckey(EVP_PKEY *key, EC_KEY **eckey)
 {
 	EC_KEY *dtmp;
-	if(!key) return NULL;
+
+	if (!key)
+		return NULL;
 	dtmp = EVP_PKEY_get1_EC_KEY(key);
 	EVP_PKEY_free(key);
-	if(!dtmp) return NULL;
-	if(eckey) 
-	{
- 		EC_KEY_free(*eckey);
+	if (!dtmp)
+		return NULL;
+	if (eckey) {
+		EC_KEY_free(*eckey);
 		*eckey = dtmp;
 	}
 	return dtmp;
 }
 
-EC_KEY *PEM_read_bio_ECPrivateKey(BIO *bp, EC_KEY **key, pem_password_cb *cb,
-							void *u)
+EC_KEY *
+PEM_read_bio_ECPrivateKey(BIO *bp, EC_KEY **key, pem_password_cb *cb, void *u)
 {
 	EVP_PKEY *pktmp;
 	pktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);
 	return pkey_get_eckey(pktmp, key);	/* will free pktmp */
 }
 
-IMPLEMENT_PEM_rw_const(ECPKParameters, EC_GROUP, PEM_STRING_ECPARAMETERS, ECPKParameters)
+IMPLEMENT_PEM_rw_const(ECPKParameters, EC_GROUP, PEM_STRING_ECPARAMETERS,
+    ECPKParameters)
 
-
-
-IMPLEMENT_PEM_write_cb(ECPrivateKey, EC_KEY, PEM_STRING_ECPRIVATEKEY, ECPrivateKey)
+IMPLEMENT_PEM_write_cb(ECPrivateKey, EC_KEY, PEM_STRING_ECPRIVATEKEY,
+    ECPrivateKey)
 
 IMPLEMENT_PEM_rw(EC_PUBKEY, EC_KEY, PEM_STRING_PUBLIC, EC_PUBKEY)
 
 #ifndef OPENSSL_NO_FP_API
- 
-EC_KEY *PEM_read_ECPrivateKey(FILE *fp, EC_KEY **eckey, pem_password_cb *cb,
- 								void *u)
+
+EC_KEY *
+PEM_read_ECPrivateKey(FILE *fp, EC_KEY **eckey, pem_password_cb *cb, void *u)
 {
 	EVP_PKEY *pktmp;
+
 	pktmp = PEM_read_PrivateKey(fp, NULL, cb, u);
 	return pkey_get_eckey(pktmp, eckey);	/* will free pktmp */
 }
diff --git a/src/lib/libssl/src/crypto/pem/pem_err.c b/src/lib/libssl/src/crypto/pem/pem_err.c
index d644aeedd..8fa292fa3 100644
--- a/src/lib/libssl/src/crypto/pem/pem_err.c
+++ b/src/lib/libssl/src/crypto/pem/pem_err.c
@@ -7,7 +7,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
+ *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -68,94 +68,91 @@
 #define ERR_FUNC(func) ERR_PACK(ERR_LIB_PEM,func,0)
 #define ERR_REASON(reason) ERR_PACK(ERR_LIB_PEM,0,reason)
 
-static ERR_STRING_DATA PEM_str_functs[]=
-	{
-{ERR_FUNC(PEM_F_B2I_DSS),	"B2I_DSS"},
-{ERR_FUNC(PEM_F_B2I_PVK_BIO),	"b2i_PVK_bio"},
-{ERR_FUNC(PEM_F_B2I_RSA),	"B2I_RSA"},
-{ERR_FUNC(PEM_F_CHECK_BITLEN_DSA),	"CHECK_BITLEN_DSA"},
-{ERR_FUNC(PEM_F_CHECK_BITLEN_RSA),	"CHECK_BITLEN_RSA"},
-{ERR_FUNC(PEM_F_D2I_PKCS8PRIVATEKEY_BIO),	"d2i_PKCS8PrivateKey_bio"},
-{ERR_FUNC(PEM_F_D2I_PKCS8PRIVATEKEY_FP),	"d2i_PKCS8PrivateKey_fp"},
-{ERR_FUNC(PEM_F_DO_B2I),	"DO_B2I"},
-{ERR_FUNC(PEM_F_DO_B2I_BIO),	"DO_B2I_BIO"},
-{ERR_FUNC(PEM_F_DO_BLOB_HEADER),	"DO_BLOB_HEADER"},
-{ERR_FUNC(PEM_F_DO_PK8PKEY),	"DO_PK8PKEY"},
-{ERR_FUNC(PEM_F_DO_PK8PKEY_FP),	"DO_PK8PKEY_FP"},
-{ERR_FUNC(PEM_F_DO_PVK_BODY),	"DO_PVK_BODY"},
-{ERR_FUNC(PEM_F_DO_PVK_HEADER),	"DO_PVK_HEADER"},
-{ERR_FUNC(PEM_F_I2B_PVK),	"I2B_PVK"},
-{ERR_FUNC(PEM_F_I2B_PVK_BIO),	"i2b_PVK_bio"},
-{ERR_FUNC(PEM_F_LOAD_IV),	"LOAD_IV"},
-{ERR_FUNC(PEM_F_PEM_ASN1_READ),	"PEM_ASN1_read"},
-{ERR_FUNC(PEM_F_PEM_ASN1_READ_BIO),	"PEM_ASN1_read_bio"},
-{ERR_FUNC(PEM_F_PEM_ASN1_WRITE),	"PEM_ASN1_write"},
-{ERR_FUNC(PEM_F_PEM_ASN1_WRITE_BIO),	"PEM_ASN1_write_bio"},
-{ERR_FUNC(PEM_F_PEM_DEF_CALLBACK),	"PEM_def_callback"},
-{ERR_FUNC(PEM_F_PEM_DO_HEADER),	"PEM_do_header"},
-{ERR_FUNC(PEM_F_PEM_F_PEM_WRITE_PKCS8PRIVATEKEY),	"PEM_F_PEM_WRITE_PKCS8PRIVATEKEY"},
-{ERR_FUNC(PEM_F_PEM_GET_EVP_CIPHER_INFO),	"PEM_get_EVP_CIPHER_INFO"},
-{ERR_FUNC(PEM_F_PEM_PK8PKEY),	"PEM_PK8PKEY"},
-{ERR_FUNC(PEM_F_PEM_READ),	"PEM_read"},
-{ERR_FUNC(PEM_F_PEM_READ_BIO),	"PEM_read_bio"},
-{ERR_FUNC(PEM_F_PEM_READ_BIO_PARAMETERS),	"PEM_read_bio_Parameters"},
-{ERR_FUNC(PEM_F_PEM_READ_BIO_PRIVATEKEY),	"PEM_READ_BIO_PRIVATEKEY"},
-{ERR_FUNC(PEM_F_PEM_READ_PRIVATEKEY),	"PEM_READ_PRIVATEKEY"},
-{ERR_FUNC(PEM_F_PEM_SEALFINAL),	"PEM_SealFinal"},
-{ERR_FUNC(PEM_F_PEM_SEALINIT),	"PEM_SealInit"},
-{ERR_FUNC(PEM_F_PEM_SIGNFINAL),	"PEM_SignFinal"},
-{ERR_FUNC(PEM_F_PEM_WRITE),	"PEM_write"},
-{ERR_FUNC(PEM_F_PEM_WRITE_BIO),	"PEM_write_bio"},
-{ERR_FUNC(PEM_F_PEM_WRITE_PRIVATEKEY),	"PEM_WRITE_PRIVATEKEY"},
-{ERR_FUNC(PEM_F_PEM_X509_INFO_READ),	"PEM_X509_INFO_read"},
-{ERR_FUNC(PEM_F_PEM_X509_INFO_READ_BIO),	"PEM_X509_INFO_read_bio"},
-{ERR_FUNC(PEM_F_PEM_X509_INFO_WRITE_BIO),	"PEM_X509_INFO_write_bio"},
-{0,NULL}
-	};
+static ERR_STRING_DATA PEM_str_functs[] = {
+	{ERR_FUNC(PEM_F_B2I_DSS),	"B2I_DSS"},
+	{ERR_FUNC(PEM_F_B2I_PVK_BIO),	"b2i_PVK_bio"},
+	{ERR_FUNC(PEM_F_B2I_RSA),	"B2I_RSA"},
+	{ERR_FUNC(PEM_F_CHECK_BITLEN_DSA),	"CHECK_BITLEN_DSA"},
+	{ERR_FUNC(PEM_F_CHECK_BITLEN_RSA),	"CHECK_BITLEN_RSA"},
+	{ERR_FUNC(PEM_F_D2I_PKCS8PRIVATEKEY_BIO),	"d2i_PKCS8PrivateKey_bio"},
+	{ERR_FUNC(PEM_F_D2I_PKCS8PRIVATEKEY_FP),	"d2i_PKCS8PrivateKey_fp"},
+	{ERR_FUNC(PEM_F_DO_B2I),	"DO_B2I"},
+	{ERR_FUNC(PEM_F_DO_B2I_BIO),	"DO_B2I_BIO"},
+	{ERR_FUNC(PEM_F_DO_BLOB_HEADER),	"DO_BLOB_HEADER"},
+	{ERR_FUNC(PEM_F_DO_PK8PKEY),	"DO_PK8PKEY"},
+	{ERR_FUNC(PEM_F_DO_PK8PKEY_FP),	"DO_PK8PKEY_FP"},
+	{ERR_FUNC(PEM_F_DO_PVK_BODY),	"DO_PVK_BODY"},
+	{ERR_FUNC(PEM_F_DO_PVK_HEADER),	"DO_PVK_HEADER"},
+	{ERR_FUNC(PEM_F_I2B_PVK),	"I2B_PVK"},
+	{ERR_FUNC(PEM_F_I2B_PVK_BIO),	"i2b_PVK_bio"},
+	{ERR_FUNC(PEM_F_LOAD_IV),	"LOAD_IV"},
+	{ERR_FUNC(PEM_F_PEM_ASN1_READ),	"PEM_ASN1_read"},
+	{ERR_FUNC(PEM_F_PEM_ASN1_READ_BIO),	"PEM_ASN1_read_bio"},
+	{ERR_FUNC(PEM_F_PEM_ASN1_WRITE),	"PEM_ASN1_write"},
+	{ERR_FUNC(PEM_F_PEM_ASN1_WRITE_BIO),	"PEM_ASN1_write_bio"},
+	{ERR_FUNC(PEM_F_PEM_DEF_CALLBACK),	"PEM_def_callback"},
+	{ERR_FUNC(PEM_F_PEM_DO_HEADER),	"PEM_do_header"},
+	{ERR_FUNC(PEM_F_PEM_F_PEM_WRITE_PKCS8PRIVATEKEY),	"PEM_F_PEM_WRITE_PKCS8PRIVATEKEY"},
+	{ERR_FUNC(PEM_F_PEM_GET_EVP_CIPHER_INFO),	"PEM_get_EVP_CIPHER_INFO"},
+	{ERR_FUNC(PEM_F_PEM_PK8PKEY),	"PEM_PK8PKEY"},
+	{ERR_FUNC(PEM_F_PEM_READ),	"PEM_read"},
+	{ERR_FUNC(PEM_F_PEM_READ_BIO),	"PEM_read_bio"},
+	{ERR_FUNC(PEM_F_PEM_READ_BIO_PARAMETERS),	"PEM_read_bio_Parameters"},
+	{ERR_FUNC(PEM_F_PEM_READ_BIO_PRIVATEKEY),	"PEM_READ_BIO_PRIVATEKEY"},
+	{ERR_FUNC(PEM_F_PEM_READ_PRIVATEKEY),	"PEM_READ_PRIVATEKEY"},
+	{ERR_FUNC(PEM_F_PEM_SEALFINAL),	"PEM_SealFinal"},
+	{ERR_FUNC(PEM_F_PEM_SEALINIT),	"PEM_SealInit"},
+	{ERR_FUNC(PEM_F_PEM_SIGNFINAL),	"PEM_SignFinal"},
+	{ERR_FUNC(PEM_F_PEM_WRITE),	"PEM_write"},
+	{ERR_FUNC(PEM_F_PEM_WRITE_BIO),	"PEM_write_bio"},
+	{ERR_FUNC(PEM_F_PEM_WRITE_PRIVATEKEY),	"PEM_WRITE_PRIVATEKEY"},
+	{ERR_FUNC(PEM_F_PEM_X509_INFO_READ),	"PEM_X509_INFO_read"},
+	{ERR_FUNC(PEM_F_PEM_X509_INFO_READ_BIO),	"PEM_X509_INFO_read_bio"},
+	{ERR_FUNC(PEM_F_PEM_X509_INFO_WRITE_BIO),	"PEM_X509_INFO_write_bio"},
+	{0, NULL}
+};
 
-static ERR_STRING_DATA PEM_str_reasons[]=
-	{
-{ERR_REASON(PEM_R_BAD_BASE64_DECODE)     ,"bad base64 decode"},
-{ERR_REASON(PEM_R_BAD_DECRYPT)           ,"bad decrypt"},
-{ERR_REASON(PEM_R_BAD_END_LINE)          ,"bad end line"},
-{ERR_REASON(PEM_R_BAD_IV_CHARS)          ,"bad iv chars"},
-{ERR_REASON(PEM_R_BAD_MAGIC_NUMBER)      ,"bad magic number"},
-{ERR_REASON(PEM_R_BAD_PASSWORD_READ)     ,"bad password read"},
-{ERR_REASON(PEM_R_BAD_VERSION_NUMBER)    ,"bad version number"},
-{ERR_REASON(PEM_R_BIO_WRITE_FAILURE)     ,"bio write failure"},
-{ERR_REASON(PEM_R_CIPHER_IS_NULL)        ,"cipher is null"},
-{ERR_REASON(PEM_R_ERROR_CONVERTING_PRIVATE_KEY),"error converting private key"},
-{ERR_REASON(PEM_R_EXPECTING_PRIVATE_KEY_BLOB),"expecting private key blob"},
-{ERR_REASON(PEM_R_EXPECTING_PUBLIC_KEY_BLOB),"expecting public key blob"},
-{ERR_REASON(PEM_R_INCONSISTENT_HEADER)   ,"inconsistent header"},
-{ERR_REASON(PEM_R_KEYBLOB_HEADER_PARSE_ERROR),"keyblob header parse error"},
-{ERR_REASON(PEM_R_KEYBLOB_TOO_SHORT)     ,"keyblob too short"},
-{ERR_REASON(PEM_R_NOT_DEK_INFO)          ,"not dek info"},
-{ERR_REASON(PEM_R_NOT_ENCRYPTED)         ,"not encrypted"},
-{ERR_REASON(PEM_R_NOT_PROC_TYPE)         ,"not proc type"},
-{ERR_REASON(PEM_R_NO_START_LINE)         ,"no start line"},
-{ERR_REASON(PEM_R_PROBLEMS_GETTING_PASSWORD),"problems getting password"},
-{ERR_REASON(PEM_R_PUBLIC_KEY_NO_RSA)     ,"public key no rsa"},
-{ERR_REASON(PEM_R_PVK_DATA_TOO_SHORT)    ,"pvk data too short"},
-{ERR_REASON(PEM_R_PVK_TOO_SHORT)         ,"pvk too short"},
-{ERR_REASON(PEM_R_READ_KEY)              ,"read key"},
-{ERR_REASON(PEM_R_SHORT_HEADER)          ,"short header"},
-{ERR_REASON(PEM_R_UNSUPPORTED_CIPHER)    ,"unsupported cipher"},
-{ERR_REASON(PEM_R_UNSUPPORTED_ENCRYPTION),"unsupported encryption"},
-{ERR_REASON(PEM_R_UNSUPPORTED_KEY_COMPONENTS),"unsupported key components"},
-{0,NULL}
-	};
+static ERR_STRING_DATA PEM_str_reasons[] = {
+	{ERR_REASON(PEM_R_BAD_BASE64_DECODE)     , "bad base64 decode"},
+	{ERR_REASON(PEM_R_BAD_DECRYPT)           , "bad decrypt"},
+	{ERR_REASON(PEM_R_BAD_END_LINE)          , "bad end line"},
+	{ERR_REASON(PEM_R_BAD_IV_CHARS)          , "bad iv chars"},
+	{ERR_REASON(PEM_R_BAD_MAGIC_NUMBER)      , "bad magic number"},
+	{ERR_REASON(PEM_R_BAD_PASSWORD_READ)     , "bad password read"},
+	{ERR_REASON(PEM_R_BAD_VERSION_NUMBER)    , "bad version number"},
+	{ERR_REASON(PEM_R_BIO_WRITE_FAILURE)     , "bio write failure"},
+	{ERR_REASON(PEM_R_CIPHER_IS_NULL)        , "cipher is null"},
+	{ERR_REASON(PEM_R_ERROR_CONVERTING_PRIVATE_KEY), "error converting private key"},
+	{ERR_REASON(PEM_R_EXPECTING_PRIVATE_KEY_BLOB), "expecting private key blob"},
+	{ERR_REASON(PEM_R_EXPECTING_PUBLIC_KEY_BLOB), "expecting public key blob"},
+	{ERR_REASON(PEM_R_INCONSISTENT_HEADER)   , "inconsistent header"},
+	{ERR_REASON(PEM_R_KEYBLOB_HEADER_PARSE_ERROR), "keyblob header parse error"},
+	{ERR_REASON(PEM_R_KEYBLOB_TOO_SHORT)     , "keyblob too short"},
+	{ERR_REASON(PEM_R_NOT_DEK_INFO)          , "not dek info"},
+	{ERR_REASON(PEM_R_NOT_ENCRYPTED)         , "not encrypted"},
+	{ERR_REASON(PEM_R_NOT_PROC_TYPE)         , "not proc type"},
+	{ERR_REASON(PEM_R_NO_START_LINE)         , "no start line"},
+	{ERR_REASON(PEM_R_PROBLEMS_GETTING_PASSWORD), "problems getting password"},
+	{ERR_REASON(PEM_R_PUBLIC_KEY_NO_RSA)     , "public key no rsa"},
+	{ERR_REASON(PEM_R_PVK_DATA_TOO_SHORT)    , "pvk data too short"},
+	{ERR_REASON(PEM_R_PVK_TOO_SHORT)         , "pvk too short"},
+	{ERR_REASON(PEM_R_READ_KEY)              , "read key"},
+	{ERR_REASON(PEM_R_SHORT_HEADER)          , "short header"},
+	{ERR_REASON(PEM_R_UNSUPPORTED_CIPHER)    , "unsupported cipher"},
+	{ERR_REASON(PEM_R_UNSUPPORTED_ENCRYPTION), "unsupported encryption"},
+	{ERR_REASON(PEM_R_UNSUPPORTED_KEY_COMPONENTS), "unsupported key components"},
+	{0, NULL}
+};
 
 #endif
 
-void ERR_load_PEM_strings(void)
-	{
+void
+ERR_load_PEM_strings(void)
+{
 #ifndef OPENSSL_NO_ERR
-
-	if (ERR_func_error_string(PEM_str_functs[0].error) == NULL)
-		{
-		ERR_load_strings(0,PEM_str_functs);
-		ERR_load_strings(0,PEM_str_reasons);
-		}
-#endif
+	if (ERR_func_error_string(PEM_str_functs[0].error) == NULL) {
+		ERR_load_strings(0, PEM_str_functs);
+		ERR_load_strings(0, PEM_str_reasons);
 	}
+#endif
+}
diff --git a/src/lib/libssl/src/crypto/pem/pem_info.c b/src/lib/libssl/src/crypto/pem/pem_info.c
index 4351260df..967d6d2d4 100644
--- a/src/lib/libssl/src/crypto/pem/pem_info.c
+++ b/src/lib/libssl/src/crypto/pem/pem_info.c
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -71,324 +71,315 @@
 #endif
 
 #ifndef OPENSSL_NO_FP_API
-STACK_OF(X509_INFO) *PEM_X509_INFO_read(FILE *fp, STACK_OF(X509_INFO) *sk, pem_password_cb *cb, void *u)
-	{
-        BIO *b;
-        STACK_OF(X509_INFO) *ret;
+STACK_OF(X509_INFO) *
+PEM_X509_INFO_read(FILE *fp, STACK_OF(X509_INFO) *sk, pem_password_cb *cb,
+    void *u)
+{
+	BIO *b;
+	STACK_OF(X509_INFO) *ret;
 
-        if ((b=BIO_new(BIO_s_file())) == NULL)
-		{
-		PEMerr(PEM_F_PEM_X509_INFO_READ,ERR_R_BUF_LIB);
-                return(0);
-		}
-        BIO_set_fp(b,fp,BIO_NOCLOSE);
-        ret=PEM_X509_INFO_read_bio(b,sk,cb,u);
-        BIO_free(b);
-        return(ret);
+	if ((b = BIO_new(BIO_s_file())) == NULL) {
+		PEMerr(PEM_F_PEM_X509_INFO_READ, ERR_R_BUF_LIB);
+		return (0);
 	}
+	BIO_set_fp(b, fp, BIO_NOCLOSE);
+	ret = PEM_X509_INFO_read_bio(b, sk, cb, u);
+	BIO_free(b);
+	return (ret);
+}
 #endif
 
-STACK_OF(X509_INFO) *PEM_X509_INFO_read_bio(BIO *bp, STACK_OF(X509_INFO) *sk, pem_password_cb *cb, void *u)
-	{
-	X509_INFO *xi=NULL;
-	char *name=NULL,*header=NULL;
+STACK_OF(X509_INFO) *
+PEM_X509_INFO_read_bio(BIO *bp, STACK_OF(X509_INFO) *sk, pem_password_cb *cb,
+    void *u)
+{
+	X509_INFO *xi = NULL;
+	char *name = NULL, *header = NULL;
 	void *pp;
-	unsigned char *data=NULL;
+	unsigned char *data = NULL;
 	const unsigned char *p;
-	long len,error=0;
-	int ok=0;
-	STACK_OF(X509_INFO) *ret=NULL;
-	unsigned int i,raw,ptype;
+	long len, error = 0;
+	int ok = 0;
+	STACK_OF(X509_INFO) *ret = NULL;
+	unsigned int i, raw, ptype;
 	d2i_of_void *d2i = 0;
 
-	if (sk == NULL)
-		{
-		if ((ret=sk_X509_INFO_new_null()) == NULL)
-			{
-			PEMerr(PEM_F_PEM_X509_INFO_READ_BIO,ERR_R_MALLOC_FAILURE);
+	if (sk == NULL) {
+		if ((ret = sk_X509_INFO_new_null()) == NULL) {
+			PEMerr(PEM_F_PEM_X509_INFO_READ_BIO,
+			    ERR_R_MALLOC_FAILURE);
 			goto err;
-			}
 		}
-	else
-		ret=sk;
+	} else
+		ret = sk;
 
-	if ((xi=X509_INFO_new()) == NULL) goto err;
-	for (;;)
-		{
-		raw=0;
+	if ((xi = X509_INFO_new()) == NULL)
+		goto err;
+	for (;;) {
+		raw = 0;
 		ptype = 0;
-		i=PEM_read_bio(bp,&name,&header,&data,&len);
-		if (i == 0)
-			{
-			error=ERR_GET_REASON(ERR_peek_last_error());
-			if (error == PEM_R_NO_START_LINE)
-				{
+		i = PEM_read_bio(bp, &name, &header, &data, &len);
+		if (i == 0) {
+			error = ERR_GET_REASON(ERR_peek_last_error());
+			if (error == PEM_R_NO_START_LINE) {
 				ERR_clear_error();
 				break;
-				}
-			goto err;
 			}
+			goto err;
+		}
 start:
-		if (	(strcmp(name,PEM_STRING_X509) == 0) ||
-			(strcmp(name,PEM_STRING_X509_OLD) == 0))
-			{
-			d2i=(D2I_OF(void))d2i_X509;
-			if (xi->x509 != NULL)
-				{
-				if (!sk_X509_INFO_push(ret,xi)) goto err;
-				if ((xi=X509_INFO_new()) == NULL) goto err;
+		if ((strcmp(name, PEM_STRING_X509) == 0) ||
+		    (strcmp(name, PEM_STRING_X509_OLD) == 0)) {
+			d2i = (D2I_OF(void))d2i_X509;
+			if (xi->x509 != NULL) {
+				if (!sk_X509_INFO_push(ret, xi))
+					goto err;
+				if ((xi = X509_INFO_new()) == NULL)
+					goto err;
 				goto start;
-				}
-			pp=&(xi->x509);
 			}
-		else if ((strcmp(name,PEM_STRING_X509_TRUSTED) == 0))
-			{
-			d2i=(D2I_OF(void))d2i_X509_AUX;
-			if (xi->x509 != NULL)
-				{
-				if (!sk_X509_INFO_push(ret,xi)) goto err;
-				if ((xi=X509_INFO_new()) == NULL) goto err;
+			pp = &(xi->x509);
+		} else if ((strcmp(name, PEM_STRING_X509_TRUSTED) == 0)) {
+			d2i = (D2I_OF(void))d2i_X509_AUX;
+			if (xi->x509 != NULL) {
+				if (!sk_X509_INFO_push(ret, xi))
+					goto err;
+				if ((xi = X509_INFO_new()) == NULL)
+					goto err;
 				goto start;
-				}
-			pp=&(xi->x509);
 			}
-		else if (strcmp(name,PEM_STRING_X509_CRL) == 0)
-			{
-			d2i=(D2I_OF(void))d2i_X509_CRL;
-			if (xi->crl != NULL)
-				{
-				if (!sk_X509_INFO_push(ret,xi)) goto err;
-				if ((xi=X509_INFO_new()) == NULL) goto err;
+			pp = &(xi->x509);
+		} else if (strcmp(name, PEM_STRING_X509_CRL) == 0) {
+			d2i = (D2I_OF(void))d2i_X509_CRL;
+			if (xi->crl != NULL) {
+				if (!sk_X509_INFO_push(ret, xi))
+					goto err;
+				if ((xi = X509_INFO_new()) == NULL)
+					goto err;
 				goto start;
-				}
-			pp=&(xi->crl);
 			}
-		else
+			pp = &(xi->crl);
+		} else
 #ifndef OPENSSL_NO_RSA
-			if (strcmp(name,PEM_STRING_RSA) == 0)
-			{
-			d2i=(D2I_OF(void))d2i_RSAPrivateKey;
-			if (xi->x_pkey != NULL) 
-				{
-				if (!sk_X509_INFO_push(ret,xi)) goto err;
-				if ((xi=X509_INFO_new()) == NULL) goto err;
+		if (strcmp(name, PEM_STRING_RSA) == 0) {
+			d2i = (D2I_OF(void))d2i_RSAPrivateKey;
+			if (xi->x_pkey != NULL) {
+				if (!sk_X509_INFO_push(ret, xi))
+					goto err;
+				if ((xi = X509_INFO_new()) == NULL)
+					goto err;
 				goto start;
-				}
+			}
 
-			xi->enc_data=NULL;
-			xi->enc_len=0;
+			xi->enc_data = NULL;
+			xi->enc_len = 0;
 
-			xi->x_pkey=X509_PKEY_new();
-			ptype=EVP_PKEY_RSA;
-			pp=&xi->x_pkey->dec_pkey;
+			xi->x_pkey = X509_PKEY_new();
+			ptype = EVP_PKEY_RSA;
+			pp = &xi->x_pkey->dec_pkey;
 			if ((int)strlen(header) > 10) /* assume encrypted */
-				raw=1;
-			}
-		else
+				raw = 1;
+		} else
 #endif
 #ifndef OPENSSL_NO_DSA
-			if (strcmp(name,PEM_STRING_DSA) == 0)
-			{
-			d2i=(D2I_OF(void))d2i_DSAPrivateKey;
-			if (xi->x_pkey != NULL) 
-				{
-				if (!sk_X509_INFO_push(ret,xi)) goto err;
-				if ((xi=X509_INFO_new()) == NULL) goto err;
+		if (strcmp(name, PEM_STRING_DSA) == 0) {
+			d2i = (D2I_OF(void))d2i_DSAPrivateKey;
+			if (xi->x_pkey != NULL) {
+				if (!sk_X509_INFO_push(ret, xi))
+					goto err;
+				if ((xi = X509_INFO_new()) == NULL)
+					goto err;
 				goto start;
-				}
+			}
 
-			xi->enc_data=NULL;
-			xi->enc_len=0;
+			xi->enc_data = NULL;
+			xi->enc_len = 0;
 
-			xi->x_pkey=X509_PKEY_new();
+			xi->x_pkey = X509_PKEY_new();
 			ptype = EVP_PKEY_DSA;
-			pp=&xi->x_pkey->dec_pkey;
+			pp = &xi->x_pkey->dec_pkey;
 			if ((int)strlen(header) > 10) /* assume encrypted */
-				raw=1;
-			}
-		else
+				raw = 1;
+		} else
 #endif
 #ifndef OPENSSL_NO_EC
- 			if (strcmp(name,PEM_STRING_ECPRIVATEKEY) == 0)
- 			{
- 				d2i=(D2I_OF(void))d2i_ECPrivateKey;
- 				if (xi->x_pkey != NULL) 
- 				{
- 					if (!sk_X509_INFO_push(ret,xi)) goto err;
- 					if ((xi=X509_INFO_new()) == NULL) goto err;
- 						goto start;
- 				}
- 
- 			xi->enc_data=NULL;
- 			xi->enc_len=0;
- 
- 			xi->x_pkey=X509_PKEY_new();
-			ptype = EVP_PKEY_EC;
- 			pp=&xi->x_pkey->dec_pkey;
- 			if ((int)strlen(header) > 10) /* assume encrypted */
- 				raw=1;
+		if (strcmp(name, PEM_STRING_ECPRIVATEKEY) == 0) {
+			d2i = (D2I_OF(void))d2i_ECPrivateKey;
+			if (xi->x_pkey != NULL) {
+				if (!sk_X509_INFO_push(ret, xi))
+					goto err;
+				if ((xi = X509_INFO_new()) == NULL)
+					goto err;
+				goto start;
 			}
-		else
+
+			xi->enc_data = NULL;
+			xi->enc_len = 0;
+
+			xi->x_pkey = X509_PKEY_new();
+			ptype = EVP_PKEY_EC;
+			pp = &xi->x_pkey->dec_pkey;
+			if ((int)strlen(header) > 10) /* assume encrypted */
+				raw = 1;
+		} else
 #endif
-			{
-			d2i=NULL;
-			pp=NULL;
-			}
+		{
+			d2i = NULL;
+			pp = NULL;
+		}
 
-		if (d2i != NULL)
-			{
-			if (!raw)
-				{
+		if (d2i != NULL) {
+			if (!raw) {
 				EVP_CIPHER_INFO cipher;
 
-				if (!PEM_get_EVP_CIPHER_INFO(header,&cipher))
+				if (!PEM_get_EVP_CIPHER_INFO(header, &cipher))
 					goto err;
-				if (!PEM_do_header(&cipher,data,&len,cb,u))
+				if (!PEM_do_header(&cipher, data, &len, cb, u))
 					goto err;
-				p=data;
-				if (ptype)
-					{
-					if (!d2i_PrivateKey(ptype, pp, &p, len))
-						{
-						PEMerr(PEM_F_PEM_X509_INFO_READ_BIO,ERR_R_ASN1_LIB);
+				p = data;
+				if (ptype) {
+					if (!d2i_PrivateKey(ptype, pp, &p,
+					    len)) {
+						PEMerr(PEM_F_PEM_X509_INFO_READ_BIO, ERR_R_ASN1_LIB);
 						goto err;
-						}
 					}
-				else if (d2i(pp,&p,len) == NULL)
-					{
-					PEMerr(PEM_F_PEM_X509_INFO_READ_BIO,ERR_R_ASN1_LIB);
+				} else if (d2i(pp, &p, len) == NULL) {
+					PEMerr(PEM_F_PEM_X509_INFO_READ_BIO, ERR_R_ASN1_LIB);
 					goto err;
-					}
 				}
-			else
-				{ /* encrypted RSA data */
+			} else { /* encrypted RSA data */
 				if (!PEM_get_EVP_CIPHER_INFO(header,
-					&xi->enc_cipher)) goto err;
-				xi->enc_data=(char *)data;
-				xi->enc_len=(int)len;
-				data=NULL;
-				}
+				    &xi->enc_cipher))
+					goto err;
+				xi->enc_data = (char *)data;
+				xi->enc_len = (int)len;
+				data = NULL;
 			}
-		else	{
+		} else {
 			/* unknown */
-			}
-		if (name != NULL) free(name);
-		if (header != NULL) free(header);
-		if (data != NULL) free(data);
-		name=NULL;
-		header=NULL;
-		data=NULL;
 		}
+		if (name != NULL)
+			free(name);
+		if (header != NULL)
+			free(header);
+		if (data != NULL)
+			free(data);
+		name = NULL;
+		header = NULL;
+		data = NULL;
+	}
 
 	/* if the last one hasn't been pushed yet and there is anything
-	 * in it then add it to the stack ... 
+	 * in it then add it to the stack ...
 	 */
 	if ((xi->x509 != NULL) || (xi->crl != NULL) ||
-		(xi->x_pkey != NULL) || (xi->enc_data != NULL))
-		{
-		if (!sk_X509_INFO_push(ret,xi)) goto err;
-		xi=NULL;
-		}
-	ok=1;
+	    (xi->x_pkey != NULL) || (xi->enc_data != NULL)) {
+		if (!sk_X509_INFO_push(ret, xi))
+			goto err;
+		xi = NULL;
+	}
+	ok = 1;
+
 err:
-	if (xi != NULL) X509_INFO_free(xi);
-	if (!ok)
-		{
-		for (i=0; ((int)i)<sk_X509_INFO_num(ret); i++)
-			{
-			xi=sk_X509_INFO_value(ret,i);
+	if (xi != NULL)
+		X509_INFO_free(xi);
+	if (!ok) {
+		for (i = 0; ((int)i) < sk_X509_INFO_num(ret); i++) {
+			xi = sk_X509_INFO_value(ret, i);
 			X509_INFO_free(xi);
-			}
-		if (ret != sk) sk_X509_INFO_free(ret);
-		ret=NULL;
 		}
-		
-	if (name != NULL) free(name);
-	if (header != NULL) free(header);
-	if (data != NULL) free(data);
-	return(ret);
+		if (ret != sk)
+			sk_X509_INFO_free(ret);
+		ret = NULL;
 	}
 
+	if (name != NULL)
+		free(name);
+	if (header != NULL)
+		free(header);
+	if (data != NULL)
+		free(data);
+	return (ret);
+}
+
 
 /* A TJH addition */
-int PEM_X509_INFO_write_bio(BIO *bp, X509_INFO *xi, EVP_CIPHER *enc,
-	     unsigned char *kstr, int klen, pem_password_cb *cb, void *u)
-	{
+int
+PEM_X509_INFO_write_bio(BIO *bp, X509_INFO *xi, EVP_CIPHER *enc,
+    unsigned char *kstr, int klen, pem_password_cb *cb, void *u)
+{
 	EVP_CIPHER_CTX ctx;
-	int i,ret=0;
-	unsigned char *data=NULL;
-	const char *objstr=NULL;
+	int i, ret = 0;
+	unsigned char *data = NULL;
+	const char *objstr = NULL;
 	char buf[PEM_BUFSIZE];
-	unsigned char *iv=NULL;
-	
-	if (enc != NULL)
-		{
-		objstr=OBJ_nid2sn(EVP_CIPHER_nid(enc));
-		if (objstr == NULL)
-			{
-			PEMerr(PEM_F_PEM_X509_INFO_WRITE_BIO,PEM_R_UNSUPPORTED_CIPHER);
+	unsigned char *iv = NULL;
+
+	if (enc != NULL) {
+		objstr = OBJ_nid2sn(EVP_CIPHER_nid(enc));
+		if (objstr == NULL) {
+			PEMerr(PEM_F_PEM_X509_INFO_WRITE_BIO,
+			    PEM_R_UNSUPPORTED_CIPHER);
 			goto err;
-			}
 		}
+	}
 
-	/* now for the fun part ... if we have a private key then 
+	/* now for the fun part ... if we have a private key then
 	 * we have to be able to handle a not-yet-decrypted key
 	 * being written out correctly ... if it is decrypted or
 	 * it is non-encrypted then we use the base code
 	 */
-	if (xi->x_pkey!=NULL)
-		{
-		if ( (xi->enc_data!=NULL) && (xi->enc_len>0) )
-			{
-			if (enc == NULL)
-				{
-				PEMerr(PEM_F_PEM_X509_INFO_WRITE_BIO,PEM_R_CIPHER_IS_NULL);
+	if (xi->x_pkey != NULL) {
+		if ((xi->enc_data != NULL) && (xi->enc_len > 0) ) {
+			if (enc == NULL) {
+				PEMerr(PEM_F_PEM_X509_INFO_WRITE_BIO,
+				    PEM_R_CIPHER_IS_NULL);
 				goto err;
-				}
+			}
 
 			/* copy from weirdo names into more normal things */
-			iv=xi->enc_cipher.iv;
-			data=(unsigned char *)xi->enc_data;
-			i=xi->enc_len;
+			iv = xi->enc_cipher.iv;
+			data = (unsigned char *)xi->enc_data;
+			i = xi->enc_len;
 
 			/* we take the encryption data from the
 			 * internal stuff rather than what the
-			 * user has passed us ... as we have to 
+			 * user has passed us ... as we have to
 			 * match exactly for some strange reason
 			 */
-			objstr=OBJ_nid2sn(
-				EVP_CIPHER_nid(xi->enc_cipher.cipher));
-			if (objstr == NULL)
-				{
-				PEMerr(PEM_F_PEM_X509_INFO_WRITE_BIO,PEM_R_UNSUPPORTED_CIPHER);
+			objstr = OBJ_nid2sn(
+			    EVP_CIPHER_nid(xi->enc_cipher.cipher));
+			if (objstr == NULL) {
+				PEMerr(PEM_F_PEM_X509_INFO_WRITE_BIO,
+				    PEM_R_UNSUPPORTED_CIPHER);
 				goto err;
-				}
+			}
 
 			/* create the right magic header stuff */
-			OPENSSL_assert(strlen(objstr)+23+2*enc->iv_len+13 <= sizeof buf);
-			buf[0]='\0';
-			PEM_proc_type(buf,PEM_TYPE_ENCRYPTED);
-			PEM_dek_info(buf,objstr,enc->iv_len,(char *)iv);
+			OPENSSL_assert(strlen(objstr) + 23 +
+			    2 * enc->iv_len + 13 <= sizeof buf);
+			buf[0] = '\0';
+			PEM_proc_type(buf, PEM_TYPE_ENCRYPTED);
+			PEM_dek_info(buf, objstr, enc->iv_len, (char *)iv);
 
 			/* use the normal code to write things out */
-			i=PEM_write_bio(bp,PEM_STRING_RSA,buf,data,i);
-			if (i <= 0) goto err;
-			}
-		else
-			{
+			i = PEM_write_bio(bp, PEM_STRING_RSA, buf, data, i);
+			if (i <= 0)
+				goto err;
+		} else {
 			/* Add DSA/DH */
 #ifndef OPENSSL_NO_RSA
 			/* normal optionally encrypted stuff */
 			if (PEM_write_bio_RSAPrivateKey(bp,
-				xi->x_pkey->dec_pkey->pkey.rsa,
-				enc,kstr,klen,cb,u)<=0)
+			    xi->x_pkey->dec_pkey->pkey.rsa,
+			    enc, kstr, klen, cb, u) <= 0)
 				goto err;
 #endif
-			}
 		}
+	}
 
 	/* if we have a certificate then write it out now */
-	if ((xi->x509 != NULL) && (PEM_write_bio_X509(bp,xi->x509) <= 0))
+	if ((xi->x509 != NULL) && (PEM_write_bio_X509(bp, xi->x509) <= 0))
 		goto err;
 
 	/* we are ignoring anything else that is loaded into the X509_INFO
@@ -397,10 +388,10 @@ int PEM_X509_INFO_write_bio(BIO *bp, X509_INFO *xi, EVP_CIPHER *enc,
 	 * base library --tjh
 	 */
 
-	ret=1;
+	ret = 1;
 
 err:
-	OPENSSL_cleanse((char *)&ctx,sizeof(ctx));
-	OPENSSL_cleanse(buf,PEM_BUFSIZE);
-	return(ret);
-	}
+	OPENSSL_cleanse((char *)&ctx, sizeof(ctx));
+	OPENSSL_cleanse(buf, PEM_BUFSIZE);
+	return (ret);
+}
diff --git a/src/lib/libssl/src/crypto/pem/pem_lib.c b/src/lib/libssl/src/crypto/pem/pem_lib.c
index 93736455f..9d5d8e714 100644
--- a/src/lib/libssl/src/crypto/pem/pem_lib.c
+++ b/src/lib/libssl/src/crypto/pem/pem_lib.c
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -74,132 +74,132 @@
 #include <openssl/engine.h>
 #endif
 
-const char PEM_version[]="PEM" OPENSSL_VERSION_PTEXT;
+const char PEM_version[] = "PEM" OPENSSL_VERSION_PTEXT;
 
 #define MIN_LENGTH	4
 
-static int load_iv(char **fromp,unsigned char *to, int num);
+static int load_iv(char **fromp, unsigned char *to, int num);
 static int check_pem(const char *nm, const char *name);
 int pem_check_suffix(const char *pem_str, const char *suffix);
 
-int PEM_def_callback(char *buf, int num, int w, void *key)
-	{
+int
+PEM_def_callback(char *buf, int num, int w, void *key)
+{
 #ifdef OPENSSL_NO_FP_API
 	/* We should not ever call the default callback routine from
 	 * windows. */
-	PEMerr(PEM_F_PEM_DEF_CALLBACK,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
-	return(-1);
+	PEMerr(PEM_F_PEM_DEF_CALLBACK, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+	return (-1);
 #else
-	int i,j;
+	int i, j;
 	const char *prompt;
-	if(key) {
-		i=strlen(key);
-		i=(i > num)?num:i;
-		memcpy(buf,key,i);
-		return(i);
+
+	if (key) {
+		i = strlen(key);
+		i = (i > num) ? num : i;
+		memcpy(buf, key, i);
+		return (i);
 	}
 
-	prompt=EVP_get_pw_prompt();
+	prompt = EVP_get_pw_prompt();
 	if (prompt == NULL)
-		prompt="Enter PEM pass phrase:";
-
-	for (;;)
-		{
-		i=EVP_read_pw_string_min(buf,MIN_LENGTH,num,prompt,w);
-		if (i != 0)
-			{
-			PEMerr(PEM_F_PEM_DEF_CALLBACK,PEM_R_PROBLEMS_GETTING_PASSWORD);
-			memset(buf,0,(unsigned int)num);
-			return(-1);
-			}
-		j=strlen(buf);
-		if (j < MIN_LENGTH)
-			{
-			fprintf(stderr,"phrase is too short, needs to be at least %d chars\n",MIN_LENGTH);
-			}
-		else
+		prompt = "Enter PEM pass phrase:";
+
+	for (;;) {
+		i = EVP_read_pw_string_min(buf, MIN_LENGTH, num, prompt, w);
+		if (i != 0) {
+			PEMerr(PEM_F_PEM_DEF_CALLBACK,
+			    PEM_R_PROBLEMS_GETTING_PASSWORD);
+			memset(buf, 0, (unsigned int)num);
+			return (-1);
+		}
+		j = strlen(buf);
+		if (j < MIN_LENGTH) {
+			fprintf(stderr, "phrase is too short, needs to be at least %d chars\n", MIN_LENGTH);
+		} else
 			break;
-		}
-	return(j);
-#endif
 	}
+	return (j);
+#endif
+}
 
-void PEM_proc_type(char *buf, int type)
-	{
+void
+PEM_proc_type(char *buf, int type)
+{
 	const char *str;
 
 	if (type == PEM_TYPE_ENCRYPTED)
-		str="ENCRYPTED";
+		str = "ENCRYPTED";
 	else if (type == PEM_TYPE_MIC_CLEAR)
-		str="MIC-CLEAR";
+		str = "MIC-CLEAR";
 	else if (type == PEM_TYPE_MIC_ONLY)
-		str="MIC-ONLY";
+		str = "MIC-ONLY";
 	else
-		str="BAD-TYPE";
-		
-	strlcat(buf,"Proc-Type: 4,",PEM_BUFSIZE);
-	strlcat(buf,str,PEM_BUFSIZE);
-	strlcat(buf,"\n",PEM_BUFSIZE);
-	}
+		str = "BAD-TYPE";
+
+	strlcat(buf, "Proc-Type: 4,", PEM_BUFSIZE);
+	strlcat(buf, str, PEM_BUFSIZE);
+	strlcat(buf, "\n", PEM_BUFSIZE);
+}
 
-void PEM_dek_info(char *buf, const char *type, int len, char *str)
-	{
-	static const unsigned char map[17]="0123456789ABCDEF";
+void
+PEM_dek_info(char *buf, const char *type, int len, char *str)
+{
+	static const unsigned char map[17] = "0123456789ABCDEF";
 	long i;
 	int j;
 
-	strlcat(buf,"DEK-Info: ",PEM_BUFSIZE);
-	strlcat(buf,type,PEM_BUFSIZE);
-	strlcat(buf,",",PEM_BUFSIZE);
-	j=strlen(buf);
+	strlcat(buf, "DEK-Info: ", PEM_BUFSIZE);
+	strlcat(buf, type, PEM_BUFSIZE);
+	strlcat(buf, ",", PEM_BUFSIZE);
+	j = strlen(buf);
 	if (j + (len * 2) + 1 > PEM_BUFSIZE)
-        	return;
-	for (i=0; i<len; i++)
-		{
-		buf[j+i*2]  =map[(str[i]>>4)&0x0f];
-		buf[j+i*2+1]=map[(str[i]   )&0x0f];
-		}
-	buf[j+i*2]='\n';
-	buf[j+i*2+1]='\0';
+		return;
+	for (i = 0; i < len; i++) {
+		buf[j + i * 2] = map[(str[i] >> 4) & 0x0f];
+		buf[j + i * 2 + 1] = map[(str[i]) & 0x0f];
 	}
+	buf[j + i * 2] = '\n';
+	buf[j + i * 2 + 1] = '\0';
+}
 
 #ifndef OPENSSL_NO_FP_API
-void *PEM_ASN1_read(d2i_of_void *d2i, const char *name, FILE *fp, void **x,
-		    pem_password_cb *cb, void *u)
-	{
-        BIO *b;
-        void *ret;
-
-        if ((b=BIO_new(BIO_s_file())) == NULL)
-		{
-		PEMerr(PEM_F_PEM_ASN1_READ,ERR_R_BUF_LIB);
-                return(0);
-		}
-        BIO_set_fp(b,fp,BIO_NOCLOSE);
-        ret=PEM_ASN1_read_bio(d2i,name,b,x,cb,u);
-        BIO_free(b);
-        return(ret);
+void *
+PEM_ASN1_read(d2i_of_void *d2i, const char *name, FILE *fp, void **x,
+    pem_password_cb *cb, void *u)
+{
+	BIO *b;
+	void *ret;
+
+	if ((b = BIO_new(BIO_s_file())) == NULL) {
+		PEMerr(PEM_F_PEM_ASN1_READ, ERR_R_BUF_LIB);
+		return (0);
 	}
+	BIO_set_fp(b, fp, BIO_NOCLOSE);
+	ret = PEM_ASN1_read_bio(d2i, name, b, x, cb, u);
+	BIO_free(b);
+	return (ret);
+}
 #endif
 
-static int check_pem(const char *nm, const char *name)
+static int
+check_pem(const char *nm, const char *name)
 {
 	/* Normal matching nm and name */
-	if (!strcmp(nm,name)) return 1;
+	if (!strcmp(nm, name))
+		return 1;
 
 	/* Make PEM_STRING_EVP_PKEY match any private key */
 
-	if(!strcmp(name,PEM_STRING_EVP_PKEY))
-		{
+	if (!strcmp(name, PEM_STRING_EVP_PKEY)) {
 		int slen;
 		const EVP_PKEY_ASN1_METHOD *ameth;
-		if(!strcmp(nm,PEM_STRING_PKCS8))
+		if (!strcmp(nm, PEM_STRING_PKCS8))
 			return 1;
-		if(!strcmp(nm,PEM_STRING_PKCS8INF))
+		if (!strcmp(nm, PEM_STRING_PKCS8INF))
 			return 1;
-		slen = pem_check_suffix(nm, "PRIVATE KEY"); 
-		if (slen > 0)
-			{
+		slen = pem_check_suffix(nm, "PRIVATE KEY");
+		if (slen > 0) {
 			/* NB: ENGINE implementations wont contain
 			 * a deprecated old private key decode function
 			 * so don't look for them.
@@ -207,21 +207,18 @@ static int check_pem(const char *nm, const char *name)
 			ameth = EVP_PKEY_asn1_find_str(NULL, nm, slen);
 			if (ameth && ameth->old_priv_decode)
 				return 1;
-			}
-		return 0;
 		}
+		return 0;
+	}
 
-	if(!strcmp(name,PEM_STRING_PARAMETERS))
-		{
+	if (!strcmp(name, PEM_STRING_PARAMETERS)) {
 		int slen;
 		const EVP_PKEY_ASN1_METHOD *ameth;
-		slen = pem_check_suffix(nm, "PARAMETERS"); 
-		if (slen > 0)
-			{
+		slen = pem_check_suffix(nm, "PARAMETERS");
+		if (slen > 0) {
 			ENGINE *e;
 			ameth = EVP_PKEY_asn1_find_str(&e, nm, slen);
-			if (ameth)
-				{
+			if (ameth) {
 				int r;
 				if (ameth->param_decode)
 					r = 1;
@@ -232,68 +229,79 @@ static int check_pem(const char *nm, const char *name)
 					ENGINE_finish(e);
 #endif
 				return r;
-				}
 			}
-		return 0;
 		}
+		return 0;
+	}
 
 	/* Permit older strings */
 
-	if(!strcmp(nm,PEM_STRING_X509_OLD) &&
-		!strcmp(name,PEM_STRING_X509)) return 1;
+	if (!strcmp(nm, PEM_STRING_X509_OLD) &&
+	    !strcmp(name, PEM_STRING_X509))
+		return 1;
 
-	if(!strcmp(nm,PEM_STRING_X509_REQ_OLD) &&
-		!strcmp(name,PEM_STRING_X509_REQ)) return 1;
+	if (!strcmp(nm, PEM_STRING_X509_REQ_OLD) &&
+	    !strcmp(name, PEM_STRING_X509_REQ))
+		return 1;
 
 	/* Allow normal certs to be read as trusted certs */
-	if(!strcmp(nm,PEM_STRING_X509) &&
-		!strcmp(name,PEM_STRING_X509_TRUSTED)) return 1;
+	if (!strcmp(nm, PEM_STRING_X509) &&
+	    !strcmp(name, PEM_STRING_X509_TRUSTED))
+		return 1;
 
-	if(!strcmp(nm,PEM_STRING_X509_OLD) &&
-		!strcmp(name,PEM_STRING_X509_TRUSTED)) return 1;
+	if (!strcmp(nm, PEM_STRING_X509_OLD) &&
+	    !strcmp(name, PEM_STRING_X509_TRUSTED))
+		return 1;
 
 	/* Some CAs use PKCS#7 with CERTIFICATE headers */
-	if(!strcmp(nm, PEM_STRING_X509) &&
-		!strcmp(name, PEM_STRING_PKCS7)) return 1;
+	if (!strcmp(nm, PEM_STRING_X509) &&
+	    !strcmp(name, PEM_STRING_PKCS7))
+		return 1;
 
-	if(!strcmp(nm, PEM_STRING_PKCS7_SIGNED) &&
-		!strcmp(name, PEM_STRING_PKCS7)) return 1;
+	if (!strcmp(nm, PEM_STRING_PKCS7_SIGNED) &&
+	    !strcmp(name, PEM_STRING_PKCS7))
+		return 1;
 
 #ifndef OPENSSL_NO_CMS
-	if(!strcmp(nm, PEM_STRING_X509) &&
-		!strcmp(name, PEM_STRING_CMS)) return 1;
+	if (!strcmp(nm, PEM_STRING_X509) &&
+	    !strcmp(name, PEM_STRING_CMS))
+		return 1;
 	/* Allow CMS to be read from PKCS#7 headers */
-	if(!strcmp(nm, PEM_STRING_PKCS7) &&
-		!strcmp(name, PEM_STRING_CMS)) return 1;
+	if (!strcmp(nm, PEM_STRING_PKCS7) &&
+	    !strcmp(name, PEM_STRING_CMS))
+		return 1;
 #endif
 
 	return 0;
 }
 
-int PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm, const char *name, BIO *bp,
-	     pem_password_cb *cb, void *u)
-	{
+int
+PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm,
+    const char *name, BIO *bp, pem_password_cb *cb, void *u)
+{
 	EVP_CIPHER_INFO cipher;
-	char *nm=NULL,*header=NULL;
-	unsigned char *data=NULL;
+	char *nm = NULL, *header = NULL;
+	unsigned char *data = NULL;
 	long len;
 	int ret = 0;
 
-	for (;;)
-		{
-		if (!PEM_read_bio(bp,&nm,&header,&data,&len)) {
-			if(ERR_GET_REASON(ERR_peek_error()) ==
-				PEM_R_NO_START_LINE)
+	for (;;) {
+		if (!PEM_read_bio(bp, &nm, &header, &data, &len)) {
+			if (ERR_GET_REASON(ERR_peek_error()) ==
+			    PEM_R_NO_START_LINE)
 				ERR_add_error_data(2, "Expecting: ", name);
 			return 0;
 		}
-		if(check_pem(nm, name)) break;
+		if (check_pem(nm, name))
+			break;
 		free(nm);
 		free(header);
 		free(data);
-		}
-	if (!PEM_get_EVP_CIPHER_INFO(header,&cipher)) goto err;
-	if (!PEM_do_header(&cipher,data,&len,cb,u)) goto err;
+	}
+	if (!PEM_get_EVP_CIPHER_INFO(header, &cipher))
+		goto err;
+	if (!PEM_do_header(&cipher, data, &len, cb, u))
+		goto err;
 
 	*pdata = data;
 	*plen = len;
@@ -304,532 +312,553 @@ int PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm, const char
 	ret = 1;
 
 err:
-	if (!ret || !pnm) free(nm);
+	if (!ret || !pnm)
+		free(nm);
 	free(header);
-	if (!ret) free(data);
+	if (!ret)
+		free(data);
 	return ret;
-	}
+}
 
 #ifndef OPENSSL_NO_FP_API
-int PEM_ASN1_write(i2d_of_void *i2d, const char *name, FILE *fp,
-		   void *x, const EVP_CIPHER *enc, unsigned char *kstr,
-		   int klen, pem_password_cb *callback, void *u)
-        {
-        BIO *b;
-        int ret;
-
-        if ((b=BIO_new(BIO_s_file())) == NULL)
-		{
-		PEMerr(PEM_F_PEM_ASN1_WRITE,ERR_R_BUF_LIB);
-                return(0);
-		}
-        BIO_set_fp(b,fp,BIO_NOCLOSE);
-        ret=PEM_ASN1_write_bio(i2d,name,b,x,enc,kstr,klen,callback,u);
-        BIO_free(b);
-        return(ret);
-        }
+int
+PEM_ASN1_write(i2d_of_void *i2d, const char *name, FILE *fp, void *x,
+    const EVP_CIPHER *enc, unsigned char *kstr, int klen,
+    pem_password_cb *callback, void *u)
+{
+	BIO *b;
+	int ret;
+
+	if ((b = BIO_new(BIO_s_file())) == NULL) {
+		PEMerr(PEM_F_PEM_ASN1_WRITE, ERR_R_BUF_LIB);
+		return (0);
+	}
+	BIO_set_fp(b, fp, BIO_NOCLOSE);
+	ret = PEM_ASN1_write_bio(i2d, name, b, x, enc, kstr, klen, callback, u);
+	BIO_free(b);
+	return (ret);
+}
 #endif
 
-int PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp,
-		       void *x, const EVP_CIPHER *enc, unsigned char *kstr,
-		       int klen, pem_password_cb *callback, void *u)
-	{
+int
+PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp, void *x,
+    const EVP_CIPHER *enc, unsigned char *kstr, int klen,
+    pem_password_cb *callback, void *u)
+{
 	EVP_CIPHER_CTX ctx;
-	int dsize=0,i,j,ret=0;
-	unsigned char *p,*data=NULL;
-	const char *objstr=NULL;
+	int dsize = 0, i, j, ret = 0;
+	unsigned char *p, *data = NULL;
+	const char *objstr = NULL;
 	char buf[PEM_BUFSIZE];
 	unsigned char key[EVP_MAX_KEY_LENGTH];
 	unsigned char iv[EVP_MAX_IV_LENGTH];
-	
-	if (enc != NULL)
-		{
-		objstr=OBJ_nid2sn(EVP_CIPHER_nid(enc));
-		if (objstr == NULL)
-			{
-			PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,PEM_R_UNSUPPORTED_CIPHER);
+
+	if (enc != NULL) {
+		objstr = OBJ_nid2sn(EVP_CIPHER_nid(enc));
+		if (objstr == NULL) {
+			PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,
+			    PEM_R_UNSUPPORTED_CIPHER);
 			goto err;
-			}
 		}
+	}
 
-	if ((dsize=i2d(x,NULL)) < 0)
-		{
-		PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,ERR_R_ASN1_LIB);
-		dsize=0;
+	if ((dsize = i2d(x, NULL)) < 0) {
+		PEMerr(PEM_F_PEM_ASN1_WRITE_BIO, ERR_R_ASN1_LIB);
+		dsize = 0;
 		goto err;
-		}
+	}
 	/* dzise + 8 bytes are needed */
 	/* actually it needs the cipher block size extra... */
-	data=(unsigned char *)malloc((unsigned int)dsize+20);
-	if (data == NULL)
-		{
-		PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,ERR_R_MALLOC_FAILURE);
+	data = (unsigned char *)malloc((unsigned int)dsize + 20);
+	if (data == NULL) {
+		PEMerr(PEM_F_PEM_ASN1_WRITE_BIO, ERR_R_MALLOC_FAILURE);
 		goto err;
-		}
-	p=data;
-	i=i2d(x,&p);
+	}
+	p = data;
+	i = i2d(x, &p);
 
-	if (enc != NULL)
-		{
-		if (kstr == NULL)
-			{
+	if (enc != NULL) {
+		if (kstr == NULL) {
 			if (callback == NULL)
-				klen=PEM_def_callback(buf,PEM_BUFSIZE,1,u);
+				klen = PEM_def_callback(buf, PEM_BUFSIZE, 1, u);
 			else
-				klen=(*callback)(buf,PEM_BUFSIZE,1,u);
-			if (klen <= 0)
-				{
-				PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,PEM_R_READ_KEY);
+				klen = (*callback)(buf, PEM_BUFSIZE, 1, u);
+			if (klen <= 0) {
+				PEMerr(PEM_F_PEM_ASN1_WRITE_BIO,
+				    PEM_R_READ_KEY);
 				goto err;
-				}
-			kstr=(unsigned char *)buf;
 			}
+			kstr = (unsigned char *)buf;
+		}
 		OPENSSL_assert(enc->iv_len <= (int)sizeof(iv));
-		if (RAND_pseudo_bytes(iv,enc->iv_len) < 0) /* Generate a salt */
+		if (RAND_pseudo_bytes(iv, enc->iv_len) < 0) /* Generate a salt */
 			goto err;
 		/* The 'iv' is used as the iv and as a salt.  It is
 		 * NOT taken from the BytesToKey function */
-		if (!EVP_BytesToKey(enc,EVP_md5(),iv,kstr,klen,1,key,NULL))
+		if (!EVP_BytesToKey(enc, EVP_md5(), iv, kstr, klen, 1,
+		    key, NULL))
 			goto err;
 
-		if (kstr == (unsigned char *)buf) OPENSSL_cleanse(buf,PEM_BUFSIZE);
+		if (kstr == (unsigned char *)buf)
+			OPENSSL_cleanse(buf, PEM_BUFSIZE);
 
-		OPENSSL_assert(strlen(objstr)+23+2*enc->iv_len+13 <= sizeof buf);
+		OPENSSL_assert(strlen(objstr) + 23 +
+		    2 * enc->iv_len + 13 <= sizeof buf);
 
-		buf[0]='\0';
-		PEM_proc_type(buf,PEM_TYPE_ENCRYPTED);
-		PEM_dek_info(buf,objstr,enc->iv_len,(char *)iv);
+		buf[0] = '\0';
+		PEM_proc_type(buf, PEM_TYPE_ENCRYPTED);
+		PEM_dek_info(buf, objstr, enc->iv_len, (char *)iv);
 		/* k=strlen(buf); */
 
 		EVP_CIPHER_CTX_init(&ctx);
 		ret = 1;
-		if (!EVP_EncryptInit_ex(&ctx,enc,NULL,key,iv)
-			|| !EVP_EncryptUpdate(&ctx,data,&j,data,i)
-			|| !EVP_EncryptFinal_ex(&ctx,&(data[j]),&i))
+		if (!EVP_EncryptInit_ex(&ctx, enc, NULL, key, iv) ||
+		    !EVP_EncryptUpdate(&ctx, data, &j, data, i) ||
+		    !EVP_EncryptFinal_ex(&ctx, &(data[j]), &i))
 			ret = 0;
 		EVP_CIPHER_CTX_cleanup(&ctx);
 		if (ret == 0)
 			goto err;
-		i+=j;
-		}
-	else
-		{
-		ret=1;
-		buf[0]='\0';
-		}
-	i=PEM_write_bio(bp,name,buf,data,i);
-	if (i <= 0) ret=0;
+		i += j;
+	} else {
+		ret = 1;
+		buf[0] = '\0';
+	}
+	i = PEM_write_bio(bp, name, buf, data, i);
+	if (i <= 0)
+		ret = 0;
 err:
-	OPENSSL_cleanse(key,sizeof(key));
-	OPENSSL_cleanse(iv,sizeof(iv));
-	OPENSSL_cleanse((char *)&ctx,sizeof(ctx));
-	OPENSSL_cleanse(buf,PEM_BUFSIZE);
-	if (data != NULL)
-		{
-		OPENSSL_cleanse(data,(unsigned int)dsize);
+	OPENSSL_cleanse(key, sizeof(key));
+	OPENSSL_cleanse(iv, sizeof(iv));
+	OPENSSL_cleanse((char *)&ctx, sizeof(ctx));
+	OPENSSL_cleanse(buf, PEM_BUFSIZE);
+	if (data != NULL) {
+		OPENSSL_cleanse(data, (unsigned int)dsize);
 		free(data);
-		}
-	return(ret);
 	}
+	return (ret);
+}
 
-int PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *plen,
-	     pem_password_cb *callback,void *u)
-	{
-	int i,j,o,klen;
+int
+PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *plen,
+    pem_password_cb *callback, void *u)
+{
+	int i, j, o, klen;
 	long len;
 	EVP_CIPHER_CTX ctx;
 	unsigned char key[EVP_MAX_KEY_LENGTH];
 	char buf[PEM_BUFSIZE];
 
-	len= *plen;
+	len = *plen;
 
-	if (cipher->cipher == NULL) return(1);
+	if (cipher->cipher == NULL)
+		return (1);
 	if (callback == NULL)
-		klen=PEM_def_callback(buf,PEM_BUFSIZE,0,u);
+		klen = PEM_def_callback(buf, PEM_BUFSIZE, 0, u);
 	else
-		klen=callback(buf,PEM_BUFSIZE,0,u);
-	if (klen <= 0)
-		{
-		PEMerr(PEM_F_PEM_DO_HEADER,PEM_R_BAD_PASSWORD_READ);
-		return(0);
-		}
-	if (!EVP_BytesToKey(cipher->cipher,EVP_md5(),&(cipher->iv[0]),
-		(unsigned char *)buf,klen,1,key,NULL))
+		klen = callback(buf, PEM_BUFSIZE, 0, u);
+	if (klen <= 0) {
+		PEMerr(PEM_F_PEM_DO_HEADER, PEM_R_BAD_PASSWORD_READ);
+		return (0);
+	}
+	if (!EVP_BytesToKey(cipher->cipher, EVP_md5(), &(cipher->iv[0]),
+	    (unsigned char *)buf, klen, 1, key, NULL))
 		return 0;
 
-	j=(int)len;
+	j = (int)len;
 	EVP_CIPHER_CTX_init(&ctx);
-	o = EVP_DecryptInit_ex(&ctx,cipher->cipher,NULL, key,&(cipher->iv[0]));
+	o = EVP_DecryptInit_ex(&ctx, cipher->cipher, NULL, key,
+	    &(cipher->iv[0]));
 	if (o)
-		o = EVP_DecryptUpdate(&ctx,data,&i,data,j);
+		o = EVP_DecryptUpdate(&ctx, data, &i, data, j);
 	if (o)
-		o = EVP_DecryptFinal_ex(&ctx,&(data[i]),&j);
+		o = EVP_DecryptFinal_ex(&ctx, &(data[i]), &j);
 	EVP_CIPHER_CTX_cleanup(&ctx);
-	OPENSSL_cleanse((char *)buf,sizeof(buf));
-	OPENSSL_cleanse((char *)key,sizeof(key));
-	j+=i;
-	if (!o)
-		{
-		PEMerr(PEM_F_PEM_DO_HEADER,PEM_R_BAD_DECRYPT);
-		return(0);
-		}
-	*plen=j;
-	return(1);
+	OPENSSL_cleanse((char *)buf, sizeof(buf));
+	OPENSSL_cleanse((char *)key, sizeof(key));
+	j += i;
+	if (!o) {
+		PEMerr(PEM_F_PEM_DO_HEADER, PEM_R_BAD_DECRYPT);
+		return (0);
 	}
+	*plen = j;
+	return (1);
+}
 
-int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)
-	{
-	const EVP_CIPHER *enc=NULL;
-	char *p,c;
+int
+PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)
+{
+	const EVP_CIPHER *enc = NULL;
+	char *p, c;
 	char **header_pp = &header;
 
-	cipher->cipher=NULL;
+	cipher->cipher = NULL;
 	if ((header == NULL) || (*header == '\0') || (*header == '\n'))
-		return(1);
-	if (strncmp(header,"Proc-Type: ",11) != 0)
-		{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_NOT_PROC_TYPE); return(0); }
-	header+=11;
-	if (*header != '4') return(0); header++;
-	if (*header != ',') return(0); header++;
-	if (strncmp(header,"ENCRYPTED",9) != 0)
-		{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_NOT_ENCRYPTED); return(0); }
+		return (1);
+	if (strncmp(header, "Proc-Type: ", 11) != 0) {
+		PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_NOT_PROC_TYPE);
+		return (0);
+	}
+	header += 11;
+	if (*header != '4')
+		return(0);
+	header++;
+	if (*header != ',')
+		return(0);
+	header++;
+	if (strncmp(header, "ENCRYPTED", 9) != 0) {
+		PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_NOT_ENCRYPTED);
+		return (0);
+	}
 	for (; (*header != '\n') && (*header != '\0'); header++)
 		;
-	if (*header == '\0')
-		{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_SHORT_HEADER); return(0); }
+	if (*header == '\0') {
+		PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_SHORT_HEADER);
+		return (0);
+	}
 	header++;
-	if (strncmp(header,"DEK-Info: ",10) != 0)
-		{ PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_NOT_DEK_INFO); return(0); }
-	header+=10;
+	if (strncmp(header, "DEK-Info: ", 10) != 0) {
+		PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_NOT_DEK_INFO);
+		return (0);
+	}
+	header += 10;
 
-	p=header;
-	for (;;)
-		{
+	p = header;
+	for (;;) {
 		c= *header;
 		if (!(	((c >= 'A') && (c <= 'Z')) || (c == '-') ||
-			((c >= '0') && (c <= '9'))))
+		    ((c >= '0') && (c <= '9'))))
 			break;
 		header++;
-		}
-	*header='\0';
-	cipher->cipher=enc=EVP_get_cipherbyname(p);
-	*header=c;
+	}
+	*header = '\0';
+	cipher->cipher = enc = EVP_get_cipherbyname(p);
+	*header = c;
 	header++;
 
-	if (enc == NULL)
-		{
-		PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,PEM_R_UNSUPPORTED_ENCRYPTION);
-		return(0);
-		}
-	if (!load_iv(header_pp,&(cipher->iv[0]),enc->iv_len))
-		return(0);
-
-	return(1);
+	if (enc == NULL) {
+		PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO,
+		    PEM_R_UNSUPPORTED_ENCRYPTION);
+		return (0);
 	}
+	if (!load_iv(header_pp, &(cipher->iv[0]), enc->iv_len))
+		return (0);
+
+	return (1);
+}
 
-static int load_iv(char **fromp, unsigned char *to, int num)
-	{
-	int v,i;
+static int
+load_iv(char **fromp, unsigned char *to, int num)
+{
+	int v, i;
 	char *from;
 
 	from= *fromp;
-	for (i=0; i<num; i++) to[i]=0;
-	num*=2;
-	for (i=0; i<num; i++)
-		{
+	for (i = 0; i < num; i++)
+		to[i] = 0;
+	num *= 2;
+	for (i = 0; i < num; i++) {
 		if ((*from >= '0') && (*from <= '9'))
-			v= *from-'0';
+			v = *from - '0';
 		else if ((*from >= 'A') && (*from <= 'F'))
-			v= *from-'A'+10;
+			v = *from - 'A' + 10;
 		else if ((*from >= 'a') && (*from <= 'f'))
-			v= *from-'a'+10;
-		else
-			{
-			PEMerr(PEM_F_LOAD_IV,PEM_R_BAD_IV_CHARS);
-			return(0);
-			}
-		from++;
-		to[i/2]|=v<<(long)((!(i&1))*4);
+			v = *from - 'a' + 10;
+		else {
+			PEMerr(PEM_F_LOAD_IV, PEM_R_BAD_IV_CHARS);
+			return (0);
 		}
-
-	*fromp=from;
-	return(1);
+		from++;
+		to[i / 2] |= v << (long)((!(i & 1)) * 4);
 	}
 
+	*fromp = from;
+	return (1);
+}
+
 #ifndef OPENSSL_NO_FP_API
-int PEM_write(FILE *fp, char *name, char *header, unsigned char *data,
-	     long len)
-        {
-        BIO *b;
-        int ret;
-
-        if ((b=BIO_new(BIO_s_file())) == NULL)
-		{
-		PEMerr(PEM_F_PEM_WRITE,ERR_R_BUF_LIB);
-                return(0);
-		}
-        BIO_set_fp(b,fp,BIO_NOCLOSE);
-        ret=PEM_write_bio(b, name, header, data,len);
-        BIO_free(b);
-        return(ret);
-        }
+int
+PEM_write(FILE *fp, char *name, char *header, unsigned char *data, long len)
+{
+	BIO *b;
+	int ret;
+
+	if ((b = BIO_new(BIO_s_file())) == NULL) {
+		PEMerr(PEM_F_PEM_WRITE, ERR_R_BUF_LIB);
+		return (0);
+	}
+	BIO_set_fp(b, fp, BIO_NOCLOSE);
+	ret = PEM_write_bio(b, name, header, data, len);
+	BIO_free(b);
+	return (ret);
+}
 #endif
 
-int PEM_write_bio(BIO *bp, const char *name, char *header, unsigned char *data,
-	     long len)
-	{
-	int nlen,n,i,j,outl;
+int
+PEM_write_bio(BIO *bp, const char *name, char *header, unsigned char *data,
+    long len)
+{
+	int nlen, n, i, j, outl;
 	unsigned char *buf = NULL;
 	EVP_ENCODE_CTX ctx;
-	int reason=ERR_R_BUF_LIB;
-	
+	int reason = ERR_R_BUF_LIB;
+
 	EVP_EncodeInit(&ctx);
-	nlen=strlen(name);
+	nlen = strlen(name);
 
-	if (	(BIO_write(bp,"-----BEGIN ",11) != 11) ||
-		(BIO_write(bp,name,nlen) != nlen) ||
-		(BIO_write(bp,"-----\n",6) != 6))
+	if ((BIO_write(bp, "-----BEGIN ", 11) != 11) ||
+	    (BIO_write(bp, name, nlen) != nlen) ||
+	    (BIO_write(bp, "-----\n", 6) != 6))
 		goto err;
-		
-	i=strlen(header);
-	if (i > 0)
-		{
-		if (	(BIO_write(bp,header,i) != i) ||
-			(BIO_write(bp,"\n",1) != 1))
+
+	i = strlen(header);
+	if (i > 0) {
+		if ((BIO_write(bp, header, i) != i) ||
+		    (BIO_write(bp, "\n", 1) != 1))
 			goto err;
-		}
+	}
 
-	buf = malloc(PEM_BUFSIZE*8);
-	if (buf == NULL)
-		{
-		reason=ERR_R_MALLOC_FAILURE;
+	buf = malloc(PEM_BUFSIZE * 8);
+	if (buf == NULL) {
+		reason = ERR_R_MALLOC_FAILURE;
 		goto err;
-		}
+	}
 
-	i=j=0;
-	while (len > 0)
-		{
-		n=(int)((len>(PEM_BUFSIZE*5))?(PEM_BUFSIZE*5):len);
-		EVP_EncodeUpdate(&ctx,buf,&outl,&(data[j]),n);
-		if ((outl) && (BIO_write(bp,(char *)buf,outl) != outl))
+	i = j = 0;
+	while (len > 0) {
+		n = (int)((len > (PEM_BUFSIZE * 5)) ? (PEM_BUFSIZE * 5) : len);
+		EVP_EncodeUpdate(&ctx, buf, &outl, &(data[j]), n);
+		if ((outl) && (BIO_write(bp, (char *)buf, outl) != outl))
 			goto err;
-		i+=outl;
-		len-=n;
-		j+=n;
-		}
-	EVP_EncodeFinal(&ctx,buf,&outl);
-	if ((outl > 0) && (BIO_write(bp,(char *)buf,outl) != outl)) goto err;
-	OPENSSL_cleanse(buf, PEM_BUFSIZE*8);
+		i += outl;
+		len -= n;
+		j += n;
+	}
+	EVP_EncodeFinal(&ctx, buf, &outl);
+	if ((outl > 0) && (BIO_write(bp, (char *)buf, outl) != outl))
+		goto err;
+	OPENSSL_cleanse(buf, PEM_BUFSIZE * 8);
 	free(buf);
 	buf = NULL;
-	if (	(BIO_write(bp,"-----END ",9) != 9) ||
-		(BIO_write(bp,name,nlen) != nlen) ||
-		(BIO_write(bp,"-----\n",6) != 6))
+	if ((BIO_write(bp, "-----END ", 9) != 9) ||
+	    (BIO_write(bp, name, nlen) != nlen) ||
+	    (BIO_write(bp, "-----\n", 6) != 6))
 		goto err;
-	return(i+outl);
+	return (i + outl);
+
 err:
 	if (buf) {
-		OPENSSL_cleanse(buf, PEM_BUFSIZE*8);
+		OPENSSL_cleanse(buf, PEM_BUFSIZE * 8);
 		free(buf);
 	}
-	PEMerr(PEM_F_PEM_WRITE_BIO,reason);
-	return(0);
-	}
+	PEMerr(PEM_F_PEM_WRITE_BIO, reason);
+	return (0);
+}
 
 #ifndef OPENSSL_NO_FP_API
-int PEM_read(FILE *fp, char **name, char **header, unsigned char **data,
-	     long *len)
-        {
-        BIO *b;
-        int ret;
-
-        if ((b=BIO_new(BIO_s_file())) == NULL)
-		{
-		PEMerr(PEM_F_PEM_READ,ERR_R_BUF_LIB);
-                return(0);
-		}
-        BIO_set_fp(b,fp,BIO_NOCLOSE);
-        ret=PEM_read_bio(b, name, header, data,len);
-        BIO_free(b);
-        return(ret);
-        }
+int
+PEM_read(FILE *fp, char **name, char **header, unsigned char **data, long *len)
+{
+	BIO *b;
+	int ret;
+
+	if ((b = BIO_new(BIO_s_file())) == NULL) {
+		PEMerr(PEM_F_PEM_READ, ERR_R_BUF_LIB);
+		return (0);
+	}
+	BIO_set_fp(b, fp, BIO_NOCLOSE);
+	ret = PEM_read_bio(b, name, header, data, len);
+	BIO_free(b);
+	return (ret);
+}
 #endif
 
-int PEM_read_bio(BIO *bp, char **name, char **header, unsigned char **data,
-	     long *len)
-	{
+int
+PEM_read_bio(BIO *bp, char **name, char **header, unsigned char **data,
+    long *len)
+{
 	EVP_ENCODE_CTX ctx;
-	int end=0,i,k,bl=0,hl=0,nohead=0;
+	int end = 0, i, k, bl = 0, hl = 0, nohead = 0;
 	char buf[256];
 	BUF_MEM *nameB;
 	BUF_MEM *headerB;
-	BUF_MEM *dataB,*tmpB;
-	
-	nameB=BUF_MEM_new();
-	headerB=BUF_MEM_new();
-	dataB=BUF_MEM_new();
-	if ((nameB == NULL) || (headerB == NULL) || (dataB == NULL))
-		{
+	BUF_MEM *dataB, *tmpB;
+
+	nameB = BUF_MEM_new();
+	headerB = BUF_MEM_new();
+	dataB = BUF_MEM_new();
+	if ((nameB == NULL) || (headerB == NULL) || (dataB == NULL)) {
 		BUF_MEM_free(nameB);
 		BUF_MEM_free(headerB);
 		BUF_MEM_free(dataB);
-		PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE);
-		return(0);
-		}
+		PEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);
+		return (0);
+	}
 
-	buf[254]='\0';
-	for (;;)
-		{
-		i=BIO_gets(bp,buf,254);
+	buf[254] = '\0';
+	for (;;) {
+		i = BIO_gets(bp, buf, 254);
 
-		if (i <= 0)
-			{
-			PEMerr(PEM_F_PEM_READ_BIO,PEM_R_NO_START_LINE);
+		if (i <= 0) {
+			PEMerr(PEM_F_PEM_READ_BIO, PEM_R_NO_START_LINE);
 			goto err;
-			}
+		}
 
-		while ((i >= 0) && (buf[i] <= ' ')) i--;
-		buf[++i]='\n'; buf[++i]='\0';
+		while ((i >= 0) && (buf[i] <= ' '))
+			i--;
+		buf[++i] = '\n';
+		buf[++i] = '\0';
 
-		if (strncmp(buf,"-----BEGIN ",11) == 0)
-			{
-			i=strlen(&(buf[11]));
+		if (strncmp(buf, "-----BEGIN ", 11) == 0) {
+			i = strlen(&(buf[11]));
 
-			if (strncmp(&(buf[11+i-6]),"-----\n",6) != 0)
+			if (strncmp(&(buf[11 + i - 6]), "-----\n", 6) != 0)
 				continue;
-			if (!BUF_MEM_grow(nameB,i+9))
-				{
-				PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE);
+			if (!BUF_MEM_grow(nameB, i + 9)) {
+				PEMerr(PEM_F_PEM_READ_BIO,
+				    ERR_R_MALLOC_FAILURE);
 				goto err;
-				}
-			memcpy(nameB->data,&(buf[11]),i-6);
-			nameB->data[i-6]='\0';
-			break;
 			}
+			memcpy(nameB->data, &(buf[11]), i - 6);
+			nameB->data[i - 6] = '\0';
+			break;
 		}
-	hl=0;
-	if (!BUF_MEM_grow(headerB,256))
-		{ PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE); goto err; }
-	headerB->data[0]='\0';
-	for (;;)
-		{
-		i=BIO_gets(bp,buf,254);
-		if (i <= 0) break;
-
-		while ((i >= 0) && (buf[i] <= ' ')) i--;
-		buf[++i]='\n'; buf[++i]='\0';
-
-		if (buf[0] == '\n') break;
-		if (!BUF_MEM_grow(headerB,hl+i+9))
-			{ PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE); goto err; }
-		if (strncmp(buf,"-----END ",9) == 0)
-			{
-			nohead=1;
+	}
+	hl = 0;
+	if (!BUF_MEM_grow(headerB, 256)) {
+		PEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+	headerB->data[0] = '\0';
+	for (;;) {
+		i = BIO_gets(bp, buf, 254);
+		if (i <= 0)
 			break;
-			}
-		memcpy(&(headerB->data[hl]),buf,i);
-		headerB->data[hl+i]='\0';
-		hl+=i;
+
+		while ((i >= 0) && (buf[i] <= ' '))
+			i--;
+		buf[++i] = '\n';
+		buf[++i] = '\0';
+
+		if (buf[0] == '\n')
+			break;
+		if (!BUF_MEM_grow(headerB, hl + i + 9)) {
+			PEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);
+			goto err;
 		}
+		if (strncmp(buf, "-----END ", 9) == 0) {
+			nohead = 1;
+			break;
+		}
+		memcpy(&(headerB->data[hl]), buf, i);
+		headerB->data[hl + i] = '\0';
+		hl += i;
+	}
+
+	bl = 0;
+	if (!BUF_MEM_grow(dataB, 1024)) {
+		PEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+	dataB->data[0] = '\0';
+	if (!nohead) {
+		for (;;) {
+			i = BIO_gets(bp, buf, 254);
+			if (i <= 0)
+				break;
+
+			while ((i >= 0) && (buf[i] <= ' '))
+				i--;
+			buf[++i] = '\n';
+			buf[++i] = '\0';
 
-	bl=0;
-	if (!BUF_MEM_grow(dataB,1024))
-		{ PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE); goto err; }
-	dataB->data[0]='\0';
-	if (!nohead)
-		{
-		for (;;)
-			{
-			i=BIO_gets(bp,buf,254);
-			if (i <= 0) break;
-
-			while ((i >= 0) && (buf[i] <= ' ')) i--;
-			buf[++i]='\n'; buf[++i]='\0';
-
-			if (i != 65) end=1;
-			if (strncmp(buf,"-----END ",9) == 0)
+			if (i != 65)
+				end = 1;
+			if (strncmp(buf, "-----END ", 9) == 0)
 				break;
-			if (i > 65) break;
-			if (!BUF_MEM_grow_clean(dataB,i+bl+9))
-				{
-				PEMerr(PEM_F_PEM_READ_BIO,ERR_R_MALLOC_FAILURE);
+			if (i > 65)
+				break;
+			if (!BUF_MEM_grow_clean(dataB, i + bl + 9)) {
+				PEMerr(PEM_F_PEM_READ_BIO,
+				    ERR_R_MALLOC_FAILURE);
 				goto err;
-				}
-			memcpy(&(dataB->data[bl]),buf,i);
-			dataB->data[bl+i]='\0';
-			bl+=i;
-			if (end)
-				{
-				buf[0]='\0';
-				i=BIO_gets(bp,buf,254);
-				if (i <= 0) break;
-
-				while ((i >= 0) && (buf[i] <= ' ')) i--;
-				buf[++i]='\n'; buf[++i]='\0';
+			}
+			memcpy(&(dataB->data[bl]), buf, i);
+			dataB->data[bl + i] = '\0';
+			bl += i;
+			if (end) {
+				buf[0] = '\0';
+				i = BIO_gets(bp, buf, 254);
+				if (i <= 0)
+					break;
+
+				while ((i >= 0) && (buf[i] <= ' '))
+					i--;
+				buf[++i] = '\n';
+				buf[++i] = '\0';
 
 				break;
-				}
 			}
 		}
-	else
-		{
-		tmpB=headerB;
-		headerB=dataB;
-		dataB=tmpB;
-		bl=hl;
-		}
-	i=strlen(nameB->data);
-	if (	(strncmp(buf,"-----END ",9) != 0) ||
-		(strncmp(nameB->data,&(buf[9]),i) != 0) ||
-		(strncmp(&(buf[9+i]),"-----\n",6) != 0))
-		{
-		PEMerr(PEM_F_PEM_READ_BIO,PEM_R_BAD_END_LINE);
+	} else {
+		tmpB = headerB;
+		headerB = dataB;
+		dataB = tmpB;
+		bl = hl;
+	}
+	i = strlen(nameB->data);
+	if ((strncmp(buf, "-----END ", 9) != 0) ||
+	    (strncmp(nameB->data, &(buf[9]), i) != 0) ||
+	    (strncmp(&(buf[9 + i]), "-----\n", 6) != 0)) {
+		PEMerr(PEM_F_PEM_READ_BIO, PEM_R_BAD_END_LINE);
 		goto err;
-		}
+	}
 
 	EVP_DecodeInit(&ctx);
-	i=EVP_DecodeUpdate(&ctx,
-		(unsigned char *)dataB->data,&bl,
-		(unsigned char *)dataB->data,bl);
-	if (i < 0)
-		{
-		PEMerr(PEM_F_PEM_READ_BIO,PEM_R_BAD_BASE64_DECODE);
+	i = EVP_DecodeUpdate(&ctx,
+	    (unsigned char *)dataB->data, &bl,
+	    (unsigned char *)dataB->data, bl);
+	if (i < 0) {
+		PEMerr(PEM_F_PEM_READ_BIO, PEM_R_BAD_BASE64_DECODE);
 		goto err;
-		}
-	i=EVP_DecodeFinal(&ctx,(unsigned char *)&(dataB->data[bl]),&k);
-	if (i < 0)
-		{
-		PEMerr(PEM_F_PEM_READ_BIO,PEM_R_BAD_BASE64_DECODE);
+	}
+	i = EVP_DecodeFinal(&ctx, (unsigned char *)&(dataB->data[bl]), &k);
+	if (i < 0) {
+		PEMerr(PEM_F_PEM_READ_BIO, PEM_R_BAD_BASE64_DECODE);
 		goto err;
-		}
-	bl+=k;
+	}
+	bl += k;
 
-	if (bl == 0) goto err;
-	*name=nameB->data;
-	*header=headerB->data;
-	*data=(unsigned char *)dataB->data;
-	*len=bl;
+	if (bl == 0)
+		goto err;
+	*name = nameB->data;
+	*header = headerB->data;
+	*data = (unsigned char *)dataB->data;
+	*len = bl;
 	free(nameB);
 	free(headerB);
 	free(dataB);
-	return(1);
+	return (1);
+
 err:
 	BUF_MEM_free(nameB);
 	BUF_MEM_free(headerB);
 	BUF_MEM_free(dataB);
-	return(0);
-	}
+	return (0);
+}
 
 /* Check pem string and return prefix length.
  * If for example the pem_str == "RSA PRIVATE KEY" and suffix = "PRIVATE KEY"
  * the return value is 3 for the string "RSA".
  */
 
-int pem_check_suffix(const char *pem_str, const char *suffix)
-	{
+int
+pem_check_suffix(const char *pem_str, const char *suffix)
+{
 	int pem_len = strlen(pem_str);
 	int suffix_len = strlen(suffix);
 	const char *p;
+
 	if (suffix_len + 1 >= pem_len)
 		return 0;
 	p = pem_str + pem_len - suffix_len;
@@ -839,5 +868,4 @@ int pem_check_suffix(const char *pem_str, const char *suffix)
 	if (*p != ' ')
 		return 0;
 	return p - pem_str;
-	}
-
+}
diff --git a/src/lib/libssl/src/crypto/pem/pem_oth.c b/src/lib/libssl/src/crypto/pem/pem_oth.c
index 69d281aa9..5787dc2f3 100644
--- a/src/lib/libssl/src/crypto/pem/pem_oth.c
+++ b/src/lib/libssl/src/crypto/pem/pem_oth.c
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -67,20 +67,21 @@
 
 /* Handle 'other' PEMs: not private keys */
 
-void *PEM_ASN1_read_bio(d2i_of_void *d2i, const char *name, BIO *bp, void **x,
-			pem_password_cb *cb, void *u)
-	{
-	const unsigned char *p=NULL;
-	unsigned char *data=NULL;
+void *
+PEM_ASN1_read_bio(d2i_of_void *d2i, const char *name, BIO *bp, void **x,
+    pem_password_cb *cb, void *u)
+{
+	const unsigned char *p = NULL;
+	unsigned char *data = NULL;
 	long len;
-	char *ret=NULL;
+	char *ret = NULL;
 
 	if (!PEM_bytes_read_bio(&data, &len, NULL, name, bp, cb, u))
 		return NULL;
 	p = data;
-	ret=d2i(x,&p,len);
+	ret = d2i(x, &p, len);
 	if (ret == NULL)
-		PEMerr(PEM_F_PEM_ASN1_READ_BIO,ERR_R_ASN1_LIB);
+		PEMerr(PEM_F_PEM_ASN1_READ_BIO, ERR_R_ASN1_LIB);
 	free(data);
-	return(ret);
-	}
+	return (ret);
+}
diff --git a/src/lib/libssl/src/crypto/pem/pem_pk8.c b/src/lib/libssl/src/crypto/pem/pem_pk8.c
index 6deab8c33..228ecfcea 100644
--- a/src/lib/libssl/src/crypto/pem/pem_pk8.c
+++ b/src/lib/libssl/src/crypto/pem/pem_pk8.c
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -66,14 +66,10 @@
 #include <openssl/pkcs12.h>
 #include <openssl/pem.h>
 
-static int do_pk8pkey(BIO *bp, EVP_PKEY *x, int isder,
-				int nid, const EVP_CIPHER *enc,
-				char *kstr, int klen,
-				pem_password_cb *cb, void *u);
-static int do_pk8pkey_fp(FILE *bp, EVP_PKEY *x, int isder,
-				int nid, const EVP_CIPHER *enc,
-				char *kstr, int klen,
-				pem_password_cb *cb, void *u);
+static int do_pk8pkey(BIO *bp, EVP_PKEY *x, int isder, int nid,
+    const EVP_CIPHER *enc, char *kstr, int klen, pem_password_cb *cb, void *u);
+static int do_pk8pkey_fp(FILE *bp, EVP_PKEY *x, int isder, int nid,
+    const EVP_CIPHER *enc, char *kstr, int klen, pem_password_cb *cb, void *u);
 
 /* These functions write a private key in PKCS#8 format: it is a "drop in"
  * replacement for PEM_write_bio_PrivateKey() and friends. As usual if 'enc'
@@ -81,98 +77,114 @@ static int do_pk8pkey_fp(FILE *bp, EVP_PKEY *x, int isder,
  * uses PKCS#5 v1.5 PBE algorithms whereas the others use PKCS#5 v2.0.
  */
 
-int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u)
+int
+PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid, char *kstr,
+    int klen, pem_password_cb *cb, void *u)
 {
 	return do_pk8pkey(bp, x, 0, nid, NULL, kstr, klen, cb, u);
 }
 
-int PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u)
+int
+PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
+    char *kstr, int klen, pem_password_cb *cb, void *u)
 {
 	return do_pk8pkey(bp, x, 0, -1, enc, kstr, klen, cb, u);
 }
 
-int i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u)
+int
+i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
+    char *kstr, int klen, pem_password_cb *cb, void *u)
 {
 	return do_pk8pkey(bp, x, 1, -1, enc, kstr, klen, cb, u);
 }
 
-int i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u)
+int
+i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid,
+    char *kstr, int klen, pem_password_cb *cb, void *u)
 {
 	return do_pk8pkey(bp, x, 1, nid, NULL, kstr, klen, cb, u);
 }
 
-static int do_pk8pkey(BIO *bp, EVP_PKEY *x, int isder, int nid, const EVP_CIPHER *enc,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u)
+static int
+do_pk8pkey(BIO *bp, EVP_PKEY *x, int isder, int nid, const EVP_CIPHER *enc,
+    char *kstr, int klen, pem_password_cb *cb, void *u)
 {
 	X509_SIG *p8;
 	PKCS8_PRIV_KEY_INFO *p8inf;
 	char buf[PEM_BUFSIZE];
 	int ret;
-	if(!(p8inf = EVP_PKEY2PKCS8(x))) {
+
+	if (!(p8inf = EVP_PKEY2PKCS8(x))) {
 		PEMerr(PEM_F_DO_PK8PKEY,
-					PEM_R_ERROR_CONVERTING_PRIVATE_KEY);
+		    PEM_R_ERROR_CONVERTING_PRIVATE_KEY);
 		return 0;
 	}
-	if(enc || (nid != -1)) {
-		if(!kstr) {
-			if(!cb) klen = PEM_def_callback(buf, PEM_BUFSIZE, 1, u);
-			else klen = cb(buf, PEM_BUFSIZE, 1, u);
-			if(klen <= 0) {
-				PEMerr(PEM_F_DO_PK8PKEY,PEM_R_READ_KEY);
+	if (enc || (nid != -1)) {
+		if (!kstr) {
+			if (!cb)
+				klen = PEM_def_callback(buf, PEM_BUFSIZE, 1, u);
+			else
+				klen = cb(buf, PEM_BUFSIZE, 1, u);
+			if (klen <= 0) {
+				PEMerr(PEM_F_DO_PK8PKEY, PEM_R_READ_KEY);
 				PKCS8_PRIV_KEY_INFO_free(p8inf);
 				return 0;
 			}
-				
+
 			kstr = buf;
 		}
 		p8 = PKCS8_encrypt(nid, enc, kstr, klen, NULL, 0, 0, p8inf);
-		if(kstr == buf) OPENSSL_cleanse(buf, klen);
+		if (kstr == buf)
+			OPENSSL_cleanse(buf, klen);
 		PKCS8_PRIV_KEY_INFO_free(p8inf);
-		if(isder) ret = i2d_PKCS8_bio(bp, p8);
-		else ret = PEM_write_bio_PKCS8(bp, p8);
+		if (isder)
+			ret = i2d_PKCS8_bio(bp, p8);
+		else
+			ret = PEM_write_bio_PKCS8(bp, p8);
 		X509_SIG_free(p8);
 		return ret;
 	} else {
-		if(isder) ret = i2d_PKCS8_PRIV_KEY_INFO_bio(bp, p8inf);
-		else ret = PEM_write_bio_PKCS8_PRIV_KEY_INFO(bp, p8inf);
+		if (isder)
+			ret = i2d_PKCS8_PRIV_KEY_INFO_bio(bp, p8inf);
+		else
+			ret = PEM_write_bio_PKCS8_PRIV_KEY_INFO(bp, p8inf);
 		PKCS8_PRIV_KEY_INFO_free(p8inf);
 		return ret;
 	}
 }
 
-EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)
+EVP_PKEY *
+d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)
 {
 	PKCS8_PRIV_KEY_INFO *p8inf = NULL;
 	X509_SIG *p8 = NULL;
 	int klen;
 	EVP_PKEY *ret;
 	char psbuf[PEM_BUFSIZE];
+
 	p8 = d2i_PKCS8_bio(bp, NULL);
-	if(!p8) return NULL;
-	if (cb) klen=cb(psbuf,PEM_BUFSIZE,0,u);
-	else klen=PEM_def_callback(psbuf,PEM_BUFSIZE,0,u);
+	if (!p8)
+		return NULL;
+	if (cb)
+		klen = cb(psbuf, PEM_BUFSIZE, 0, u);
+	else
+		klen = PEM_def_callback(psbuf, PEM_BUFSIZE, 0, u);
 	if (klen <= 0) {
 		PEMerr(PEM_F_D2I_PKCS8PRIVATEKEY_BIO, PEM_R_BAD_PASSWORD_READ);
 		X509_SIG_free(p8);
-		return NULL;	
+		return NULL;
 	}
 	p8inf = PKCS8_decrypt(p8, psbuf, klen);
 	X509_SIG_free(p8);
-	if(!p8inf) return NULL;
+	if (!p8inf)
+		return NULL;
 	ret = EVP_PKCS82PKEY(p8inf);
 	PKCS8_PRIV_KEY_INFO_free(p8inf);
-	if(!ret) return NULL;
-	if(x) {
-		if(*x) EVP_PKEY_free(*x);
+	if (!ret)
+		return NULL;
+	if (x) {
+		if (*x)
+			EVP_PKEY_free(*x);
 		*x = ret;
 	}
 	return ret;
@@ -180,55 +192,59 @@ EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, vo
 
 #ifndef OPENSSL_NO_FP_API
 
-int i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u)
+int
+i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
+    char *kstr, int klen, pem_password_cb *cb, void *u)
 {
 	return do_pk8pkey_fp(fp, x, 1, -1, enc, kstr, klen, cb, u);
 }
 
-int i2d_PKCS8PrivateKey_nid_fp(FILE *fp, EVP_PKEY *x, int nid,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u)
+int
+i2d_PKCS8PrivateKey_nid_fp(FILE *fp, EVP_PKEY *x, int nid, char *kstr,
+    int klen, pem_password_cb *cb, void *u)
 {
 	return do_pk8pkey_fp(fp, x, 1, nid, NULL, kstr, klen, cb, u);
 }
 
-int PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u)
+int
+PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid, char *kstr,
+    int klen, pem_password_cb *cb, void *u)
 {
 	return do_pk8pkey_fp(fp, x, 0, nid, NULL, kstr, klen, cb, u);
 }
 
-int PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
-			      char *kstr, int klen, pem_password_cb *cb, void *u)
+int
+PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
+    char *kstr, int klen, pem_password_cb *cb, void *u)
 {
 	return do_pk8pkey_fp(fp, x, 0, -1, enc, kstr, klen, cb, u);
 }
 
-static int do_pk8pkey_fp(FILE *fp, EVP_PKEY *x, int isder, int nid, const EVP_CIPHER *enc,
-				  char *kstr, int klen,
-				  pem_password_cb *cb, void *u)
+static int
+do_pk8pkey_fp(FILE *fp, EVP_PKEY *x, int isder, int nid, const EVP_CIPHER *enc,
+    char *kstr, int klen, pem_password_cb *cb, void *u)
 {
 	BIO *bp;
 	int ret;
-	if(!(bp = BIO_new_fp(fp, BIO_NOCLOSE))) {
-		PEMerr(PEM_F_DO_PK8PKEY_FP,ERR_R_BUF_LIB);
-                return(0);
+
+	if (!(bp = BIO_new_fp(fp, BIO_NOCLOSE))) {
+		PEMerr(PEM_F_DO_PK8PKEY_FP, ERR_R_BUF_LIB);
+		return (0);
 	}
 	ret = do_pk8pkey(bp, x, isder, nid, enc, kstr, klen, cb, u);
 	BIO_free(bp);
 	return ret;
 }
 
-EVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u)
+EVP_PKEY *
+d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u)
 {
 	BIO *bp;
 	EVP_PKEY *ret;
-	if(!(bp = BIO_new_fp(fp, BIO_NOCLOSE))) {
-		PEMerr(PEM_F_D2I_PKCS8PRIVATEKEY_FP,ERR_R_BUF_LIB);
-                return NULL;
+
+	if (!(bp = BIO_new_fp(fp, BIO_NOCLOSE))) {
+		PEMerr(PEM_F_D2I_PKCS8PRIVATEKEY_FP, ERR_R_BUF_LIB);
+		return NULL;
 	}
 	ret = d2i_PKCS8PrivateKey_bio(bp, x, cb, u);
 	BIO_free(bp);
@@ -239,4 +255,4 @@ EVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, vo
 
 IMPLEMENT_PEM_rw(PKCS8, X509_SIG, PEM_STRING_PKCS8, X509_SIG)
 IMPLEMENT_PEM_rw(PKCS8_PRIV_KEY_INFO, PKCS8_PRIV_KEY_INFO, PEM_STRING_PKCS8INF,
-							 PKCS8_PRIV_KEY_INFO)
+    PKCS8_PRIV_KEY_INFO)
diff --git a/src/lib/libssl/src/crypto/pem/pem_pkey.c b/src/lib/libssl/src/crypto/pem/pem_pkey.c
index 5274447b2..9aaff6e51 100644
--- a/src/lib/libssl/src/crypto/pem/pem_pkey.c
+++ b/src/lib/libssl/src/crypto/pem/pem_pkey.c
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -72,173 +72,182 @@
 
 int pem_check_suffix(const char *pem_str, const char *suffix);
 
-EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)
-	{
-	char *nm=NULL;
-	const unsigned char *p=NULL;
-	unsigned char *data=NULL;
+EVP_PKEY *
+PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)
+{
+	char *nm = NULL;
+	const unsigned char *p = NULL;
+	unsigned char *data = NULL;
 	long len;
 	int slen;
-	EVP_PKEY *ret=NULL;
+	EVP_PKEY *ret = NULL;
 
-	if (!PEM_bytes_read_bio(&data, &len, &nm, PEM_STRING_EVP_PKEY, bp, cb, u))
+	if (!PEM_bytes_read_bio(&data, &len, &nm, PEM_STRING_EVP_PKEY,
+	    bp, cb, u))
 		return NULL;
 	p = data;
 
-	if (strcmp(nm,PEM_STRING_PKCS8INF) == 0) {
+	if (strcmp(nm, PEM_STRING_PKCS8INF) == 0) {
 		PKCS8_PRIV_KEY_INFO *p8inf;
-		p8inf=d2i_PKCS8_PRIV_KEY_INFO(NULL, &p, len);
-		if(!p8inf) goto p8err;
+		p8inf = d2i_PKCS8_PRIV_KEY_INFO(NULL, &p, len);
+		if (!p8inf)
+			goto p8err;
 		ret = EVP_PKCS82PKEY(p8inf);
-		if(x) {
-			if(*x) EVP_PKEY_free((EVP_PKEY *)*x);
+		if (x) {
+			if (*x)
+				EVP_PKEY_free((EVP_PKEY *)*x);
 			*x = ret;
 		}
 		PKCS8_PRIV_KEY_INFO_free(p8inf);
-	} else if (strcmp(nm,PEM_STRING_PKCS8) == 0) {
+	} else if (strcmp(nm, PEM_STRING_PKCS8) == 0) {
 		PKCS8_PRIV_KEY_INFO *p8inf;
 		X509_SIG *p8;
 		int klen;
 		char psbuf[PEM_BUFSIZE];
 		p8 = d2i_X509_SIG(NULL, &p, len);
-		if(!p8) goto p8err;
-		if (cb) klen=cb(psbuf,PEM_BUFSIZE,0,u);
-		else klen=PEM_def_callback(psbuf,PEM_BUFSIZE,0,u);
+		if (!p8)
+			goto p8err;
+		if (cb)
+			klen = cb(psbuf, PEM_BUFSIZE, 0, u);
+		else
+			klen = PEM_def_callback(psbuf, PEM_BUFSIZE, 0, u);
 		if (klen <= 0) {
 			PEMerr(PEM_F_PEM_READ_BIO_PRIVATEKEY,
-					PEM_R_BAD_PASSWORD_READ);
+			    PEM_R_BAD_PASSWORD_READ);
 			X509_SIG_free(p8);
 			goto err;
 		}
 		p8inf = PKCS8_decrypt(p8, psbuf, klen);
 		X509_SIG_free(p8);
-		if(!p8inf) goto p8err;
+		if (!p8inf)
+			goto p8err;
 		ret = EVP_PKCS82PKEY(p8inf);
-		if(x) {
-			if(*x) EVP_PKEY_free((EVP_PKEY *)*x);
+		if (x) {
+			if (*x)
+				EVP_PKEY_free((EVP_PKEY *)*x);
 			*x = ret;
 		}
 		PKCS8_PRIV_KEY_INFO_free(p8inf);
-	} else if ((slen = pem_check_suffix(nm, "PRIVATE KEY")) > 0)
-		{
+	} else if ((slen = pem_check_suffix(nm, "PRIVATE KEY")) > 0) {
 		const EVP_PKEY_ASN1_METHOD *ameth;
 		ameth = EVP_PKEY_asn1_find_str(NULL, nm, slen);
 		if (!ameth || !ameth->old_priv_decode)
 			goto p8err;
-		ret=d2i_PrivateKey(ameth->pkey_id,x,&p,len);
-		}
+		ret = d2i_PrivateKey(ameth->pkey_id, x,&p, len);
+	}
+
 p8err:
 	if (ret == NULL)
-		PEMerr(PEM_F_PEM_READ_BIO_PRIVATEKEY,ERR_R_ASN1_LIB);
+		PEMerr(PEM_F_PEM_READ_BIO_PRIVATEKEY, ERR_R_ASN1_LIB);
 err:
 	free(nm);
 	OPENSSL_cleanse(data, len);
 	free(data);
-	return(ret);
-	}
+	return (ret);
+}
 
-int PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
-                                               unsigned char *kstr, int klen,
-                                               pem_password_cb *cb, void *u)
-	{
+int
+PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
+    unsigned char *kstr, int klen, pem_password_cb *cb, void *u)
+{
 	char pem_str[80];
+
 	if (!x->ameth || x->ameth->priv_encode)
 		return PEM_write_bio_PKCS8PrivateKey(bp, x, enc,
-							(char *)kstr, klen,
-							cb, u);
+		    (char *)kstr, klen, cb, u);
 
 	(void) snprintf(pem_str, sizeof(pem_str), "%s PRIVATE KEY",
 	    x->ameth->pem_str);
 	return PEM_ASN1_write_bio((i2d_of_void *)i2d_PrivateKey,
-				pem_str,bp,x,enc,kstr,klen,cb,u);
-	}
-
-EVP_PKEY *PEM_read_bio_Parameters(BIO *bp, EVP_PKEY **x)
-	{
-	char *nm=NULL;
-	const unsigned char *p=NULL;
-	unsigned char *data=NULL;
+	    pem_str, bp, x,enc, kstr, klen, cb, u);
+}
+
+EVP_PKEY *
+PEM_read_bio_Parameters(BIO *bp, EVP_PKEY **x)
+{
+	char *nm = NULL;
+	const unsigned char *p = NULL;
+	unsigned char *data = NULL;
 	long len;
 	int slen;
-	EVP_PKEY *ret=NULL;
+	EVP_PKEY *ret = NULL;
 
 	if (!PEM_bytes_read_bio(&data, &len, &nm, PEM_STRING_PARAMETERS,
-								bp, 0, NULL))
+	    bp, 0, NULL))
 		return NULL;
 	p = data;
 
-	if ((slen = pem_check_suffix(nm, "PARAMETERS")) > 0)
-		{
+	if ((slen = pem_check_suffix(nm, "PARAMETERS")) > 0) {
 		ret = EVP_PKEY_new();
 		if (!ret)
 			goto err;
-		if (!EVP_PKEY_set_type_str(ret, nm, slen)
-			|| !ret->ameth->param_decode
-			|| !ret->ameth->param_decode(ret, &p, len))
-			{
+		if (!EVP_PKEY_set_type_str(ret, nm, slen) ||
+		    !ret->ameth->param_decode ||
+		    !ret->ameth->param_decode(ret, &p, len)) {
 			EVP_PKEY_free(ret);
 			ret = NULL;
 			goto err;
-			}
-		if(x)
-			{
-			if(*x) EVP_PKEY_free((EVP_PKEY *)*x);
+		}
+		if (x) {
+			if (*x)
+				EVP_PKEY_free((EVP_PKEY *)*x);
 			*x = ret;
-			}
 		}
+	}
+
 err:
 	if (ret == NULL)
-		PEMerr(PEM_F_PEM_READ_BIO_PARAMETERS,ERR_R_ASN1_LIB);
+		PEMerr(PEM_F_PEM_READ_BIO_PARAMETERS, ERR_R_ASN1_LIB);
 	free(nm);
 	free(data);
-	return(ret);
-	}
+	return (ret);
+}
 
-int PEM_write_bio_Parameters(BIO *bp, EVP_PKEY *x)
-	{
+int
+PEM_write_bio_Parameters(BIO *bp, EVP_PKEY *x)
+{
 	char pem_str[80];
+
 	if (!x->ameth || !x->ameth->param_encode)
 		return 0;
 
 	(void) snprintf(pem_str, sizeof(pem_str), "%s PARAMETERS",
 	    x->ameth->pem_str);
-	return PEM_ASN1_write_bio(
-		(i2d_of_void *)x->ameth->param_encode,
-				pem_str,bp,x,NULL,NULL,0,0,NULL);
-	}
+	return PEM_ASN1_write_bio((i2d_of_void *)x->ameth->param_encode,
+	    pem_str, bp, x,NULL, NULL, 0,0, NULL);
+}
 
 #ifndef OPENSSL_NO_FP_API
-EVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u)
-	{
-        BIO *b;
-        EVP_PKEY *ret;
-
-        if ((b=BIO_new(BIO_s_file())) == NULL)
-		{
-		PEMerr(PEM_F_PEM_READ_PRIVATEKEY,ERR_R_BUF_LIB);
-                return(0);
-		}
-        BIO_set_fp(b,fp,BIO_NOCLOSE);
-        ret=PEM_read_bio_PrivateKey(b,x,cb,u);
-        BIO_free(b);
-        return(ret);
+EVP_PKEY *
+PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u)
+{
+	BIO *b;
+	EVP_PKEY *ret;
+
+	if ((b = BIO_new(BIO_s_file())) == NULL) {
+		PEMerr(PEM_F_PEM_READ_PRIVATEKEY, ERR_R_BUF_LIB);
+		return (0);
 	}
-
-int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
-                                               unsigned char *kstr, int klen,
-                                               pem_password_cb *cb, void *u)
-	{
-        BIO *b;
-        int ret;
-
-        if ((b=BIO_new_fp(fp, BIO_NOCLOSE)) == NULL)
-		{
-		PEMerr(PEM_F_PEM_WRITE_PRIVATEKEY,ERR_R_BUF_LIB);
-                return 0;
-		}
-        ret=PEM_write_bio_PrivateKey(b, x, enc, kstr, klen, cb, u);
-        BIO_free(b);
-        return ret;
+	BIO_set_fp(b, fp, BIO_NOCLOSE);
+	ret = PEM_read_bio_PrivateKey(b, x,cb, u);
+	BIO_free(b);
+	return (ret);
+}
+
+int
+PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
+    unsigned char *kstr, int klen, pem_password_cb *cb, void *u)
+{
+	BIO *b;
+	int ret;
+
+	if ((b = BIO_new_fp(fp, BIO_NOCLOSE)) == NULL) {
+		PEMerr(PEM_F_PEM_WRITE_PRIVATEKEY, ERR_R_BUF_LIB);
+		return 0;
 	}
+	ret = PEM_write_bio_PrivateKey(b, x, enc, kstr, klen, cb, u);
+	BIO_free(b);
+	return ret;
+}
 
 #endif
diff --git a/src/lib/libssl/src/crypto/pem/pem_seal.c b/src/lib/libssl/src/crypto/pem/pem_seal.c
index bac7b16b4..e39de08c9 100644
--- a/src/lib/libssl/src/crypto/pem/pem_seal.c
+++ b/src/lib/libssl/src/crypto/pem/pem_seal.c
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -67,125 +67,129 @@
 #include <openssl/pem.h>
 #include <openssl/rsa.h>
 
-int PEM_SealInit(PEM_ENCODE_SEAL_CTX *ctx, EVP_CIPHER *type, EVP_MD *md_type,
-	     unsigned char **ek, int *ekl, unsigned char *iv, EVP_PKEY **pubk,
-	     int npubk)
-	{
+int
+PEM_SealInit(PEM_ENCODE_SEAL_CTX *ctx, EVP_CIPHER *type, EVP_MD *md_type,
+    unsigned char **ek, int *ekl, unsigned char *iv, EVP_PKEY **pubk, int npubk)
+{
 	unsigned char key[EVP_MAX_KEY_LENGTH];
-	int ret= -1;
-	int i,j,max=0;
-	char *s=NULL;
-
-	for (i=0; i<npubk; i++)
-		{
-		if (pubk[i]->type != EVP_PKEY_RSA)
-			{
-			PEMerr(PEM_F_PEM_SEALINIT,PEM_R_PUBLIC_KEY_NO_RSA);
+	int ret = -1;
+	int i, j, max = 0;
+	char *s = NULL;
+
+	for (i = 0; i < npubk; i++) {
+		if (pubk[i]->type != EVP_PKEY_RSA) {
+			PEMerr(PEM_F_PEM_SEALINIT, PEM_R_PUBLIC_KEY_NO_RSA);
 			goto err;
-			}
-		j=RSA_size(pubk[i]->pkey.rsa);
-		if (j > max) max=j;
 		}
-	s=(char *)malloc(max*2);
-	if (s == NULL)
-		{
-		PEMerr(PEM_F_PEM_SEALINIT,ERR_R_MALLOC_FAILURE);
+		j = RSA_size(pubk[i]->pkey.rsa);
+		if (j > max)
+			max = j;
+	}
+	s = (char *)malloc(max*2);
+	if (s == NULL) {
+		PEMerr(PEM_F_PEM_SEALINIT, ERR_R_MALLOC_FAILURE);
 		goto err;
-		}
+	}
 
 	EVP_EncodeInit(&ctx->encode);
 
 	EVP_MD_CTX_init(&ctx->md);
-	if (!EVP_SignInit(&ctx->md,md_type))
+	if (!EVP_SignInit(&ctx->md, md_type))
 		goto err;
 
 	EVP_CIPHER_CTX_init(&ctx->cipher);
-	ret=EVP_SealInit(&ctx->cipher,type,ek,ekl,iv,pubk,npubk);
-	if (ret <= 0) goto err;
+	ret = EVP_SealInit(&ctx->cipher, type, ek, ekl, iv, pubk, npubk);
+	if (ret <= 0)
+		goto err;
 
 	/* base64 encode the keys */
-	for (i=0; i<npubk; i++)
-		{
-		j=EVP_EncodeBlock((unsigned char *)s,ek[i],
-			RSA_size(pubk[i]->pkey.rsa));
-		ekl[i]=j;
-		memcpy(ek[i],s,j+1);
-		}
-
-	ret=npubk;
-err:
-	if (s != NULL) free(s);
-	OPENSSL_cleanse(key,EVP_MAX_KEY_LENGTH);
-	return(ret);
+	for (i = 0; i < npubk; i++) {
+		j = EVP_EncodeBlock((unsigned char *)s, ek[i],
+		    RSA_size(pubk[i]->pkey.rsa));
+		ekl[i] = j;
+		memcpy(ek[i], s, j + 1);
 	}
 
-void PEM_SealUpdate(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *out, int *outl,
-	     unsigned char *in, int inl)
-	{
+	ret = npubk;
+
+err:
+	if (s != NULL)
+		free(s);
+	OPENSSL_cleanse(key, EVP_MAX_KEY_LENGTH);
+	return (ret);
+}
+
+void
+PEM_SealUpdate(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *out, int *outl,
+    unsigned char *in, int inl)
+{
 	unsigned char buffer[1600];
-	int i,j;
+	int i, j;
 
-	*outl=0;
-	EVP_SignUpdate(&ctx->md,in,inl);
-	for (;;)
-		{
-		if (inl <= 0) break;
+	*outl = 0;
+	EVP_SignUpdate(&ctx->md, in, inl);
+	for (;;) {
+		if (inl <= 0)
+			break;
 		if (inl > 1200)
-			i=1200;
+			i = 1200;
 		else
-			i=inl;
-		EVP_EncryptUpdate(&ctx->cipher,buffer,&j,in,i);
-		EVP_EncodeUpdate(&ctx->encode,out,&j,buffer,j);
-		*outl+=j;
-		out+=j;
-		in+=i;
-		inl-=i;
-		}
+			i = inl;
+		EVP_EncryptUpdate(&ctx->cipher, buffer, &j, in, i);
+		EVP_EncodeUpdate(&ctx->encode, out, &j, buffer, j);
+		*outl += j;
+		out += j;
+		in += i;
+		inl -= i;
 	}
-
-int PEM_SealFinal(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *sig, int *sigl,
-	     unsigned char *out, int *outl, EVP_PKEY *priv)
-	{
-	unsigned char *s=NULL;
-	int ret=0,j;
+}
+
+int
+PEM_SealFinal(PEM_ENCODE_SEAL_CTX *ctx, unsigned char *sig, int *sigl,
+    unsigned char *out, int *outl, EVP_PKEY *priv)
+{
+	unsigned char *s = NULL;
+	int ret = 0, j;
 	unsigned int i;
 
-	if (priv->type != EVP_PKEY_RSA)
-		{
-		PEMerr(PEM_F_PEM_SEALFINAL,PEM_R_PUBLIC_KEY_NO_RSA);
+	if (priv->type != EVP_PKEY_RSA) {
+		PEMerr(PEM_F_PEM_SEALFINAL, PEM_R_PUBLIC_KEY_NO_RSA);
 		goto err;
-		}
-	i=RSA_size(priv->pkey.rsa);
-	if (i < 100) i=100;
-	s=(unsigned char *)malloc(i*2);
-	if (s == NULL)
-		{
-		PEMerr(PEM_F_PEM_SEALFINAL,ERR_R_MALLOC_FAILURE);
+	}
+	i = RSA_size(priv->pkey.rsa);
+	if (i < 100)
+		i = 100;
+	s = (unsigned char *)malloc(i*2);
+	if (s == NULL) {
+		PEMerr(PEM_F_PEM_SEALFINAL, ERR_R_MALLOC_FAILURE);
 		goto err;
-		}
+	}
 
-	if (!EVP_EncryptFinal_ex(&ctx->cipher,s,(int *)&i))
+	if (!EVP_EncryptFinal_ex(&ctx->cipher, s, (int *)&i))
 		goto err;
-	EVP_EncodeUpdate(&ctx->encode,out,&j,s,i);
-	*outl=j;
-	out+=j;
-	EVP_EncodeFinal(&ctx->encode,out,&j);
-	*outl+=j;
+	EVP_EncodeUpdate(&ctx->encode, out, &j, s, i);
+	*outl = j;
+	out += j;
+	EVP_EncodeFinal(&ctx->encode, out, &j);
+	*outl += j;
 
-	if (!EVP_SignFinal(&ctx->md,s,&i,priv)) goto err;
-	*sigl=EVP_EncodeBlock(sig,s,i);
+	if (!EVP_SignFinal(&ctx->md, s,&i, priv))
+		goto err;
+	*sigl = EVP_EncodeBlock(sig, s, i);
+
+	ret = 1;
 
-	ret=1;
 err:
 	EVP_MD_CTX_cleanup(&ctx->md);
 	EVP_CIPHER_CTX_cleanup(&ctx->cipher);
-	if (s != NULL) free(s);
-	return(ret);
-	}
+	if (s != NULL)
+		free(s);
+	return (ret);
+}
 #else /* !OPENSSL_NO_RSA */
 
 # if PEDANTIC
-static void *dummy=&dummy;
+static void *dummy = &dummy;
 # endif
 
 #endif
diff --git a/src/lib/libssl/src/crypto/pem/pem_sign.c b/src/lib/libssl/src/crypto/pem/pem_sign.c
index cbd3cd079..ab3e5ebc6 100644
--- a/src/lib/libssl/src/crypto/pem/pem_sign.c
+++ b/src/lib/libssl/src/crypto/pem/pem_sign.c
@@ -5,21 +5,21 @@
  * This package is an SSL implementation written
  * by Eric Young (eay@cryptsoft.com).
  * The implementation was written so as to conform with Netscapes SSL.
- * 
+ *
  * This library is free for commercial and non-commercial use as long as
  * the following conditions are aheared to.  The following conditions
  * apply to all code found in this distribution, be it the RC4, RSA,
  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
  * included with this distribution is covered by the same copyright terms
  * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
+ *
  * Copyright remains Eric Young's, and as such any Copyright notices in
  * the code are not to be removed.
  * If this package is used in a product, Eric Young should be given attribution
  * as the author of the parts of the library used.
  * This can be in the form of a textual message at program startup or
  * in documentation (online or textual) provided with the package.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -34,10 +34,10 @@
  *     Eric Young (eay@cryptsoft.com)"
  *    The word 'cryptographic' can be left out if the rouines from the library
  *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
+ * 4. If you include any Windows specific code (or a derivative thereof) from
  *    the apps directory (application code) you must include an acknowledgement:
  *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -49,7 +49,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
- * 
+ *
  * The licence and distribution terms for any publically available version or
  * derivative of this code cannot be changed.  i.e. this code cannot simply be
  * copied and put under another distribution licence
@@ -64,39 +64,43 @@
 #include <openssl/x509.h>
 #include <openssl/pem.h>
 
-void PEM_SignInit(EVP_MD_CTX *ctx, EVP_MD *type)
-	{
+void
+PEM_SignInit(EVP_MD_CTX *ctx, EVP_MD *type)
+{
 	EVP_DigestInit_ex(ctx, type, NULL);
-	}
+}
 
-void PEM_SignUpdate(EVP_MD_CTX *ctx, unsigned char *data,
-	     unsigned int count)
-	{
-	EVP_DigestUpdate(ctx,data,count);
-	}
+void
+PEM_SignUpdate(EVP_MD_CTX *ctx, unsigned char *data,
+    unsigned int count)
+{
+	EVP_DigestUpdate(ctx, data, count);
+}
 
-int PEM_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret, unsigned int *siglen,
-	     EVP_PKEY *pkey)
-	{
+int
+PEM_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret, unsigned int *siglen,
+    EVP_PKEY *pkey)
+{
 	unsigned char *m;
-	int i,ret=0;
+	int i, ret = 0;
 	unsigned int m_len;
 
-	m=(unsigned char *)malloc(EVP_PKEY_size(pkey)+2);
-	if (m == NULL)
-		{
-		PEMerr(PEM_F_PEM_SIGNFINAL,ERR_R_MALLOC_FAILURE);
+	m = (unsigned char *)malloc(EVP_PKEY_size(pkey) + 2);
+	if (m == NULL) {
+		PEMerr(PEM_F_PEM_SIGNFINAL, ERR_R_MALLOC_FAILURE);
+		goto err;
+	}
+
+	if (EVP_SignFinal(ctx, m,&m_len, pkey) <= 0)
 		goto err;
-		}
 
-	if (EVP_SignFinal(ctx,m,&m_len,pkey) <= 0) goto err;
+	i = EVP_EncodeBlock(sigret, m, m_len);
+	*siglen = i;
+	ret = 1;
 
-	i=EVP_EncodeBlock(sigret,m,m_len);
-	*siglen=i;
-	ret=1;
 err:
 	/* ctx has been zeroed by EVP_SignFinal() */
-	if (m != NULL) free(m);
-	return(ret);
-	}
-
+	if (m != NULL)
+		free(m);
+	return (ret);
+}
diff --git a/src/lib/libssl/src/crypto/pem/pem_x509.c b/src/lib/libssl/src/crypto/pem/pem_x509.c
index b531057dc..57b7d1d53 100644
--- a/src/lib/libssl/src/crypto/pem/pem_x509.c
+++ b/src/lib/libssl/src/crypto/pem/pem_x509.c
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
+ *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -65,4 +65,3 @@
 #include <openssl/pem.h>
 
 IMPLEMENT_PEM_rw(X509, X509, PEM_STRING_X509, X509)
-
diff --git a/src/lib/libssl/src/crypto/pem/pem_xaux.c b/src/lib/libssl/src/crypto/pem/pem_xaux.c
index 328f79620..ae381ce54 100644
--- a/src/lib/libssl/src/crypto/pem/pem_xaux.c
+++ b/src/lib/libssl/src/crypto/pem/pem_xaux.c
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
+ *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -65,4 +65,5 @@
 #include <openssl/pem.h>
 
 IMPLEMENT_PEM_rw(X509_AUX, X509, PEM_STRING_X509_TRUSTED, X509_AUX)
-IMPLEMENT_PEM_rw(X509_CERT_PAIR, X509_CERT_PAIR, PEM_STRING_X509_PAIR, X509_CERT_PAIR)
+IMPLEMENT_PEM_rw(X509_CERT_PAIR, X509_CERT_PAIR, PEM_STRING_X509_PAIR,
+    X509_CERT_PAIR)
diff --git a/src/lib/libssl/src/crypto/pem/pvkfmt.c b/src/lib/libssl/src/crypto/pem/pvkfmt.c
index 59af2020a..a7815a237 100644
--- a/src/lib/libssl/src/crypto/pem/pvkfmt.c
+++ b/src/lib/libssl/src/crypto/pem/pvkfmt.c
@@ -9,7 +9,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
+ *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -71,27 +71,31 @@
  * format
  */
 
-static unsigned int read_ledword(const unsigned char **in)
-	{
+static unsigned int
+read_ledword(const unsigned char **in)
+{
 	const unsigned char *p = *in;
 	unsigned int ret;
+
 	ret = *p++;
 	ret |= (*p++ << 8);
 	ret |= (*p++ << 16);
 	ret |= (*p++ << 24);
 	*in = p;
 	return ret;
-	}
+}
 
-/* Read a BIGNUM in little endian format. The docs say that this should take up 
+/* Read a BIGNUM in little endian format. The docs say that this should take up
  * bitlen/8 bytes.
  */
 
-static int read_lebn(const unsigned char **in, unsigned int nbyte, BIGNUM **r)
-	{
+static int
+read_lebn(const unsigned char **in, unsigned int nbyte, BIGNUM **r)
+{
 	const unsigned char *p;
 	unsigned char *tmpbuf, *q;
 	unsigned int i;
+
 	p = *in + nbyte - 1;
 	tmpbuf = malloc(nbyte);
 	if (!tmpbuf)
@@ -101,14 +105,12 @@ static int read_lebn(const unsigned char **in, unsigned int nbyte, BIGNUM **r)
 		*q++ = *p--;
 	*r = BN_bin2bn(tmpbuf, nbyte, NULL);
 	free(tmpbuf);
-	if (*r)
-		{
+	if (*r) {
 		*in += nbyte;
 		return 1;
-		}
-	else
+	} else
 		return 0;
-	}
+}
 
 
 /* Convert private key blob to EVP_PKEY: RSA and DSA keys supported */
@@ -132,106 +134,96 @@ static int read_lebn(const unsigned char **in, unsigned int nbyte, BIGNUM **r)
 #define PVK_SALTLEN		0x10
 
 static EVP_PKEY *b2i_rsa(const unsigned char **in, unsigned int length,
-						unsigned int bitlen, int ispub);
+    unsigned int bitlen, int ispub);
 static EVP_PKEY *b2i_dss(const unsigned char **in, unsigned int length,
-						unsigned int bitlen, int ispub);
+    unsigned int bitlen, int ispub);
 
-static int do_blob_header(const unsigned char **in, unsigned int length,
-				unsigned int *pmagic, unsigned int *pbitlen,
-				int *pisdss, int *pispub)
-	{
+static int
+do_blob_header(const unsigned char **in, unsigned int length,
+    unsigned int *pmagic, unsigned int *pbitlen, int *pisdss, int *pispub)
+{
 	const unsigned char *p = *in;
+
 	if (length < 16)
 		return 0;
 	/* bType */
-	if (*p == MS_PUBLICKEYBLOB)
-		{
-		if (*pispub == 0)
-			{
+	if (*p == MS_PUBLICKEYBLOB) {
+		if (*pispub == 0) {
 			PEMerr(PEM_F_DO_BLOB_HEADER,
-					PEM_R_EXPECTING_PRIVATE_KEY_BLOB);
+			    PEM_R_EXPECTING_PRIVATE_KEY_BLOB);
 			return 0;
-			}
-		*pispub = 1;
 		}
-	else if (*p == MS_PRIVATEKEYBLOB)
-		{
-		if (*pispub == 1)
-			{
+		*pispub = 1;
+	} else if (*p == MS_PRIVATEKEYBLOB) {
+		if (*pispub == 1) {
 			PEMerr(PEM_F_DO_BLOB_HEADER,
-					PEM_R_EXPECTING_PUBLIC_KEY_BLOB);
+			    PEM_R_EXPECTING_PUBLIC_KEY_BLOB);
 			return 0;
-			}
-		*pispub = 0;
 		}
-	else
+		*pispub = 0;
+	} else
 		return 0;
 	p++;
 	/* Version */
-	if (*p++ != 0x2)
-		{
+	if (*p++ != 0x2) {
 		PEMerr(PEM_F_DO_BLOB_HEADER, PEM_R_BAD_VERSION_NUMBER);
 		return 0;
-		}
+	}
 	/* Ignore reserved, aiKeyAlg */
-	p+= 6;
+	p += 6;
 	*pmagic = read_ledword(&p);
 	*pbitlen = read_ledword(&p);
 	*pisdss = 0;
-	switch (*pmagic)
-		{
+	switch (*pmagic) {
 
-		case MS_DSS1MAGIC:
+	case MS_DSS1MAGIC:
 		*pisdss = 1;
-		case MS_RSA1MAGIC:
-		if (*pispub == 0)
-			{
+	case MS_RSA1MAGIC:
+		if (*pispub == 0) {
 			PEMerr(PEM_F_DO_BLOB_HEADER,
-					PEM_R_EXPECTING_PRIVATE_KEY_BLOB);
+			    PEM_R_EXPECTING_PRIVATE_KEY_BLOB);
 			return 0;
-			}
+		}
 		break;
 
-		case MS_DSS2MAGIC:
+	case MS_DSS2MAGIC:
 		*pisdss = 1;
-		case MS_RSA2MAGIC:
-		if (*pispub == 1)
-			{
+	case MS_RSA2MAGIC:
+		if (*pispub == 1) {
 			PEMerr(PEM_F_DO_BLOB_HEADER,
-					PEM_R_EXPECTING_PUBLIC_KEY_BLOB);
+			    PEM_R_EXPECTING_PUBLIC_KEY_BLOB);
 			return 0;
-			}
+		}
 		break;
 
-		default:
+	default:
 		PEMerr(PEM_F_DO_BLOB_HEADER, PEM_R_BAD_MAGIC_NUMBER);
 		return -1;
-		}
+	}
 	*in = p;
 	return 1;
-	}
+}
 
-static unsigned int blob_length(unsigned bitlen, int isdss, int ispub)
-	{
+static unsigned int
+blob_length(unsigned bitlen, int isdss, int ispub)
+{
 	unsigned int nbyte, hnbyte;
+
 	nbyte = (bitlen + 7) >> 3;
 	hnbyte = (bitlen + 15) >> 4;
-	if (isdss)
-		{
+	if (isdss) {
 
 		/* Expected length: 20 for q + 3 components bitlen each + 24
 		 * for seed structure.
 		 */
 		if (ispub)
-			return  44 + 3 * nbyte;
+			return 44 + 3 * nbyte;
 		/* Expected length: 20 for q, priv, 2 bitlen components + 24
 		 * for seed structure.
 		 */
 		else
 			return 64 + 2 * nbyte;
-		}
-	else
-		{
+	} else {
 		/* Expected length: 4 for 'e' + 'n' */
 		if (ispub)
 			return 4 + nbyte;
@@ -239,83 +231,83 @@ static unsigned int blob_length(unsigned bitlen, int isdss, int ispub)
 		/* Expected length: 4 for 'e' and 7 other components.
 		 * 2 components are bitlen size, 5 are bitlen/2
 		 */
-			return 4 + 2*nbyte + 5*hnbyte;
-		}
-
+				return 4 + 2*nbyte + 5*hnbyte;
 	}
 
-static EVP_PKEY *do_b2i(const unsigned char **in, unsigned int length,
-								int ispub)
-	{
+}
+
+static EVP_PKEY *
+do_b2i(const unsigned char **in, unsigned int length, int ispub)
+{
 	const unsigned char *p = *in;
 	unsigned int bitlen, magic;
 	int isdss;
-	if (do_blob_header(&p, length, &magic, &bitlen, &isdss, &ispub) <= 0)
-		{
+
+	if (do_blob_header(&p, length, &magic, &bitlen, &isdss, &ispub) <= 0) {
 		PEMerr(PEM_F_DO_B2I, PEM_R_KEYBLOB_HEADER_PARSE_ERROR);
 		return NULL;
-		}
+	}
 	length -= 16;
-	if (length < blob_length(bitlen, isdss, ispub))
-		{
+	if (length < blob_length(bitlen, isdss, ispub)) {
 		PEMerr(PEM_F_DO_B2I, PEM_R_KEYBLOB_TOO_SHORT);
 		return NULL;
-		}
+	}
 	if (isdss)
 		return b2i_dss(&p, length, bitlen, ispub);
 	else
 		return b2i_rsa(&p, length, bitlen, ispub);
-	}
+}
 
-static EVP_PKEY *do_b2i_bio(BIO *in, int ispub)
-	{
+static EVP_PKEY *
+do_b2i_bio(BIO *in, int ispub)
+{
 	const unsigned char *p;
 	unsigned char hdr_buf[16], *buf = NULL;
 	unsigned int bitlen, magic, length;
 	int isdss;
 	EVP_PKEY *ret = NULL;
-	if (BIO_read(in, hdr_buf, 16) != 16)
-		{
+
+	if (BIO_read(in, hdr_buf, 16) != 16) {
 		PEMerr(PEM_F_DO_B2I_BIO, PEM_R_KEYBLOB_TOO_SHORT);
 		return NULL;
-		}
+	}
 	p = hdr_buf;
 	if (do_blob_header(&p, 16, &magic, &bitlen, &isdss, &ispub) <= 0)
 		return NULL;
 
 	length = blob_length(bitlen, isdss, ispub);
 	buf = malloc(length);
-	if (!buf)
-		{
+	if (!buf) {
 		PEMerr(PEM_F_DO_B2I_BIO, ERR_R_MALLOC_FAILURE);
 		goto err;
-		}
+	}
 	p = buf;
-	if (BIO_read(in, buf, length) != (int)length)
-		{
+	if (BIO_read(in, buf, length) != (int)length) {
 		PEMerr(PEM_F_DO_B2I_BIO, PEM_R_KEYBLOB_TOO_SHORT);
 		goto err;
-		}
+	}
 
 	if (isdss)
 		ret = b2i_dss(&p, length, bitlen, ispub);
 	else
 		ret = b2i_rsa(&p, length, bitlen, ispub);
 
-	err:
+err:
 	if (buf)
 		free(buf);
 	return ret;
-	}
+}
 
-static EVP_PKEY *b2i_dss(const unsigned char **in, unsigned int length,
-						unsigned int bitlen, int ispub)
-	{
+static EVP_PKEY *
+b2i_dss(const unsigned char **in, unsigned int length, unsigned int bitlen,
+    int ispub)
+{
 	const unsigned char *p = *in;
 	EVP_PKEY *ret = NULL;
 	DSA *dsa = NULL;
 	BN_CTX *ctx = NULL;
 	unsigned int nbyte;
+
 	nbyte = (bitlen + 7) >> 3;
 
 	dsa = DSA_new();
@@ -328,13 +320,10 @@ static EVP_PKEY *b2i_dss(const unsigned char **in, unsigned int length,
 		goto memerr;
 	if (!read_lebn(&p, nbyte, &dsa->g))
 		goto memerr;
-	if (ispub)
-		{
+	if (ispub) {
 		if (!read_lebn(&p, nbyte, &dsa->pub_key))
 			goto memerr;
-		}
-	else
-		{
+	} else {
 		if (!read_lebn(&p, 20, &dsa->priv_key))
 			goto memerr;
 		/* Calculate public key */
@@ -342,20 +331,18 @@ static EVP_PKEY *b2i_dss(const unsigned char **in, unsigned int length,
 			goto memerr;
 		if (!(ctx = BN_CTX_new()))
 			goto memerr;
-			
 		if (!BN_mod_exp(dsa->pub_key, dsa->g,
-						 dsa->priv_key, dsa->p, ctx))
-			
+		    dsa->priv_key, dsa->p, ctx))
 			goto memerr;
 		BN_CTX_free(ctx);
-		}
+	}
 
 	EVP_PKEY_set1_DSA(ret, dsa);
 	DSA_free(dsa);
 	*in = p;
 	return ret;
 
-	memerr:
+memerr:
 	PEMerr(PEM_F_B2I_DSS, ERR_R_MALLOC_FAILURE);
 	if (dsa)
 		DSA_free(dsa);
@@ -364,16 +351,17 @@ static EVP_PKEY *b2i_dss(const unsigned char **in, unsigned int length,
 	if (ctx)
 		BN_CTX_free(ctx);
 	return NULL;
-	}
+}
 
-static EVP_PKEY *b2i_rsa(const unsigned char **in, unsigned int length,
-						unsigned int bitlen, int ispub)
-		
-	{
+static EVP_PKEY *
+b2i_rsa(const unsigned char **in, unsigned int length, unsigned int bitlen,
+    int ispub)
+{
 	const unsigned char *p = *in;
 	EVP_PKEY *ret = NULL;
 	RSA *rsa = NULL;
 	unsigned int nbyte, hnbyte;
+
 	nbyte = (bitlen + 7) >> 3;
 	hnbyte = (bitlen + 15) >> 4;
 	rsa = RSA_new();
@@ -387,8 +375,7 @@ static EVP_PKEY *b2i_rsa(const unsigned char **in, unsigned int length,
 		goto memerr;
 	if (!read_lebn(&p, nbyte, &rsa->n))
 		goto memerr;
-	if (!ispub)
-		{
+	if (!ispub) {
 		if (!read_lebn(&p, hnbyte, &rsa->p))
 			goto memerr;
 		if (!read_lebn(&p, hnbyte, &rsa->q))
@@ -401,78 +388,83 @@ static EVP_PKEY *b2i_rsa(const unsigned char **in, unsigned int length,
 			goto memerr;
 		if (!read_lebn(&p, nbyte, &rsa->d))
 			goto memerr;
-		}
+	}
 
 	EVP_PKEY_set1_RSA(ret, rsa);
 	RSA_free(rsa);
 	*in = p;
 	return ret;
-	memerr:
+
+memerr:
 	PEMerr(PEM_F_B2I_RSA, ERR_R_MALLOC_FAILURE);
 	if (rsa)
 		RSA_free(rsa);
 	if (ret)
 		EVP_PKEY_free(ret);
 	return NULL;
-	}
+}
 
-EVP_PKEY *b2i_PrivateKey(const unsigned char **in, long length)
-	{
+EVP_PKEY *
+b2i_PrivateKey(const unsigned char **in, long length)
+{
 	return do_b2i(in, length, 0);
-	}
+}
 
-EVP_PKEY *b2i_PublicKey(const unsigned char **in, long length)
-	{
+EVP_PKEY *
+b2i_PublicKey(const unsigned char **in, long length)
+{
 	return do_b2i(in, length, 1);
-	}
+}
 
-
-EVP_PKEY *b2i_PrivateKey_bio(BIO *in)
-	{
+EVP_PKEY *
+b2i_PrivateKey_bio(BIO *in)
+{
 	return do_b2i_bio(in, 0);
-	}
+}
 
-EVP_PKEY *b2i_PublicKey_bio(BIO *in)
-	{
+EVP_PKEY *
+b2i_PublicKey_bio(BIO *in)
+{
 	return do_b2i_bio(in, 1);
-	}
+}
 
-static void write_ledword(unsigned char **out, unsigned int dw)
-	{
+static void
+write_ledword(unsigned char **out, unsigned int dw)
+{
 	unsigned char *p = *out;
+
 	*p++ = dw & 0xff;
-	*p++ = (dw>>8) & 0xff;
-	*p++ = (dw>>16) & 0xff;
-	*p++ = (dw>>24) & 0xff;
+	*p++ = (dw >> 8) & 0xff;
+	*p++ = (dw >> 16) & 0xff;
+	*p++ = (dw >> 24) & 0xff;
 	*out = p;
-	}
+}
 
-static void write_lebn(unsigned char **out, const BIGNUM *bn, int len)
-	{
+static void
+write_lebn(unsigned char **out, const BIGNUM *bn, int len)
+{
 	int nb, i;
 	unsigned char *p = *out, *q, c;
+
 	nb = BN_num_bytes(bn);
 	BN_bn2bin(bn, p);
 	q = p + nb - 1;
 	/* In place byte order reversal */
-	for (i = 0; i < nb/2; i++)
-		{
+	for (i = 0; i < nb / 2; i++) {
 		c = *p;
 		*p++ = *q;
 		*q-- = c;
-		}
+	}
 	*out += nb;
 	/* Pad with zeroes if we have to */
-	if (len > 0)
-		{
+	if (len > 0) {
 		len -= nb;
-		if (len > 0)
-			{
+		if (len > 0) {
 			memset(*out, 0, len);
 			*out += len;
-			}
 		}
 	}
+}
 
 
 static int check_bitlen_rsa(RSA *rsa, int ispub, unsigned int *magic);
@@ -480,40 +472,37 @@ static int check_bitlen_dsa(DSA *dsa, int ispub, unsigned int *magic);
 
 static void write_rsa(unsigned char **out, RSA *rsa, int ispub);
 static void write_dsa(unsigned char **out, DSA *dsa, int ispub);
-	
-static int do_i2b(unsigned char **out, EVP_PKEY *pk, int ispub)
-	{
+
+static int
+do_i2b(unsigned char **out, EVP_PKEY *pk, int ispub)
+{
 	unsigned char *p;
 	unsigned int bitlen, magic = 0, keyalg;
 	int outlen, noinc = 0;
-	if (pk->type == EVP_PKEY_DSA)
-		{
+
+	if (pk->type == EVP_PKEY_DSA) {
 		bitlen = check_bitlen_dsa(pk->pkey.dsa, ispub, &magic);
 		keyalg = MS_KEYALG_DSS_SIGN;
-		}
-	else if (pk->type == EVP_PKEY_RSA)
-		{
+	} else if (pk->type == EVP_PKEY_RSA) {
 		bitlen = check_bitlen_rsa(pk->pkey.rsa, ispub, &magic);
 		keyalg = MS_KEYALG_RSA_KEYX;
-		}
-	else
+	} else
 		return -1;
 	if (bitlen == 0)
 		return -1;
 	outlen = 16 + blob_length(bitlen,
-			keyalg == MS_KEYALG_DSS_SIGN ? 1 : 0, ispub);
+	    keyalg == MS_KEYALG_DSS_SIGN ? 1 : 0, ispub);
 	if (out == NULL)
 		return outlen;
 	if (*out)
 		p = *out;
-	else
-		{
+	else {
 		p = malloc(outlen);
 		if (!p)
 			return -1;
 		*out = p;
 		noinc = 1;
-		}
+	}
 	if (ispub)
 		*p++ = MS_PUBLICKEYBLOB;
 	else
@@ -531,12 +520,14 @@ static int do_i2b(unsigned char **out, EVP_PKEY *pk, int ispub)
 	if (!noinc)
 		*out += outlen;
 	return outlen;
-	}
+}
 
-static int do_i2b_bio(BIO *out, EVP_PKEY *pk, int ispub)
-	{
+static int
+do_i2b_bio(BIO *out, EVP_PKEY *pk, int ispub)
+{
 	unsigned char *tmp = NULL;
 	int outlen, wrlen;
+
 	outlen = do_i2b(&tmp, pk, ispub);
 	if (outlen < 0)
 		return -1;
@@ -545,72 +536,73 @@ static int do_i2b_bio(BIO *out, EVP_PKEY *pk, int ispub)
 	if (wrlen == outlen)
 		return outlen;
 	return -1;
-	}
+}
 
-static int check_bitlen_dsa(DSA *dsa, int ispub, unsigned int *pmagic)
-	{
+static int
+check_bitlen_dsa(DSA *dsa, int ispub, unsigned int *pmagic)
+{
 	int bitlen;
+
 	bitlen = BN_num_bits(dsa->p);
-	if ((bitlen & 7) || (BN_num_bits(dsa->q) != 160)
-		|| (BN_num_bits(dsa->g) > bitlen))
+	if ((bitlen & 7) || (BN_num_bits(dsa->q) != 160) ||
+	    (BN_num_bits(dsa->g) > bitlen))
 		goto badkey;
-	if (ispub)
-		{
+	if (ispub) {
 		if (BN_num_bits(dsa->pub_key) > bitlen)
 			goto badkey;
 		*pmagic = MS_DSS1MAGIC;
-		}
-	else
-		{
+	} else {
 		if (BN_num_bits(dsa->priv_key) > 160)
 			goto badkey;
 		*pmagic = MS_DSS2MAGIC;
-		}
-	
+	}
+
 	return bitlen;
-	badkey:
+
+badkey:
 	PEMerr(PEM_F_CHECK_BITLEN_DSA, PEM_R_UNSUPPORTED_KEY_COMPONENTS);
 	return 0;
-	}
+}
 
-static int check_bitlen_rsa(RSA *rsa, int ispub, unsigned int *pmagic)
-	{
+static int
+check_bitlen_rsa(RSA *rsa, int ispub, unsigned int *pmagic)
+{
 	int nbyte, hnbyte, bitlen;
+
 	if (BN_num_bits(rsa->e) > 32)
 		goto badkey;
 	bitlen = BN_num_bits(rsa->n);
 	nbyte = BN_num_bytes(rsa->n);
 	hnbyte = (BN_num_bits(rsa->n) + 15) >> 4;
-	if (ispub)
-		{
+	if (ispub) {
 		*pmagic = MS_RSA1MAGIC;
 		return bitlen;
-		}
-	else
-	{
+	} else {
 		*pmagic = MS_RSA2MAGIC;
 		/* For private key each component must fit within nbyte or
 		 * hnbyte.
 		 */
 		if (BN_num_bytes(rsa->d) > nbyte)
 			goto badkey;
-		if ((BN_num_bytes(rsa->iqmp) > hnbyte)
-			|| (BN_num_bytes(rsa->p) > hnbyte)
-			|| (BN_num_bytes(rsa->q) > hnbyte)
-			|| (BN_num_bytes(rsa->dmp1) > hnbyte)
-			|| (BN_num_bytes(rsa->dmq1) > hnbyte))
+		if ((BN_num_bytes(rsa->iqmp) > hnbyte) ||
+		    (BN_num_bytes(rsa->p) > hnbyte) ||
+		    (BN_num_bytes(rsa->q) > hnbyte) ||
+		    (BN_num_bytes(rsa->dmp1) > hnbyte) ||
+		    (BN_num_bytes(rsa->dmq1) > hnbyte))
 			goto badkey;
 	}
 	return bitlen;
-	badkey:
+
+badkey:
 	PEMerr(PEM_F_CHECK_BITLEN_RSA, PEM_R_UNSUPPORTED_KEY_COMPONENTS);
 	return 0;
-	}
-
+}
 
-static void write_rsa(unsigned char **out, RSA *rsa, int ispub)
-	{
+static void
+write_rsa(unsigned char **out, RSA *rsa, int ispub)
+{
 	int nbyte, hnbyte;
+
 	nbyte = BN_num_bytes(rsa->n);
 	hnbyte = (BN_num_bits(rsa->n) + 15) >> 4;
 	write_lebn(out, rsa->e, 4);
@@ -623,12 +615,13 @@ static void write_rsa(unsigned char **out, RSA *rsa, int ispub)
 	write_lebn(out, rsa->dmq1, hnbyte);
 	write_lebn(out, rsa->iqmp, hnbyte);
 	write_lebn(out, rsa->d, nbyte);
-	}
+}
 
-	
-static void write_dsa(unsigned char **out, DSA *dsa, int ispub)
-	{
+static void
+write_dsa(unsigned char **out, DSA *dsa, int ispub)
+{
 	int nbyte;
+
 	nbyte = BN_num_bytes(dsa->p);
 	write_lebn(out, dsa->p, nbyte);
 	write_lebn(out, dsa->q, 20);
@@ -641,52 +634,47 @@ static void write_dsa(unsigned char **out, DSA *dsa, int ispub)
 	memset(*out, 0xff, 24);
 	*out += 24;
 	return;
-	}
-	
+}
 
-int i2b_PrivateKey_bio(BIO *out, EVP_PKEY *pk)
-	{
+int
+i2b_PrivateKey_bio(BIO *out, EVP_PKEY *pk)
+{
 	return do_i2b_bio(out, pk, 0);
-	}
+}
 
-int i2b_PublicKey_bio(BIO *out, EVP_PKEY *pk)
-	{
+int
+i2b_PublicKey_bio(BIO *out, EVP_PKEY *pk)
+{
 	return do_i2b_bio(out, pk, 1);
-	}
+}
 
 #ifndef OPENSSL_NO_RC4
 
-static int do_PVK_header(const unsigned char **in, unsigned int length,
-		int skip_magic,
-	       	unsigned int *psaltlen, unsigned int *pkeylen)
-		
-	{
+static int
+do_PVK_header(const unsigned char **in, unsigned int length, int skip_magic,
+    unsigned int *psaltlen, unsigned int *pkeylen)
+{
 	const unsigned char *p = *in;
 	unsigned int pvk_magic, is_encrypted;
-	if (skip_magic)
-		{
-		if (length < 20)
-			{
+
+	if (skip_magic) {
+		if (length < 20) {
 			PEMerr(PEM_F_DO_PVK_HEADER, PEM_R_PVK_TOO_SHORT);
 			return 0;
-			}
-		length -= 20;
 		}
-	else
-		{
-		if (length < 24)
-			{
+		length -= 20;
+	} else {
+		if (length < 24) {
 			PEMerr(PEM_F_DO_PVK_HEADER, PEM_R_PVK_TOO_SHORT);
 			return 0;
-			}
+		}
 		length -= 24;
 		pvk_magic = read_ledword(&p);
-		if (pvk_magic != MS_PVKMAGIC)
-			{
+		if (pvk_magic != MS_PVKMAGIC) {
 			PEMerr(PEM_F_DO_PVK_HEADER, PEM_R_BAD_MAGIC_NUMBER);
 			return 0;
-			}
 		}
+	}
 	/* Skip reserved */
 	p += 4;
 	/*keytype = */read_ledword(&p);
@@ -694,64 +682,61 @@ static int do_PVK_header(const unsigned char **in, unsigned int length,
 	*psaltlen = read_ledword(&p);
 	*pkeylen = read_ledword(&p);
 
-	if (is_encrypted && !*psaltlen)
-		{
+	if (is_encrypted && !*psaltlen) {
 		PEMerr(PEM_F_DO_PVK_HEADER, PEM_R_INCONSISTENT_HEADER);
 		return 0;
-		}
+	}
 
 	*in = p;
 	return 1;
-	}
+}
 
-static int derive_pvk_key(unsigned char *key, 
-			const unsigned char *salt, unsigned int saltlen,
-			const unsigned char *pass, int passlen)
-	{
+static int
+derive_pvk_key(unsigned char *key, const unsigned char *salt,
+    unsigned int saltlen, const unsigned char *pass, int passlen)
+{
 	EVP_MD_CTX mctx;
 	int rv = 1;
+
 	EVP_MD_CTX_init(&mctx);
-	if (!EVP_DigestInit_ex(&mctx, EVP_sha1(), NULL)
-		|| !EVP_DigestUpdate(&mctx, salt, saltlen)
-		|| !EVP_DigestUpdate(&mctx, pass, passlen)
-		|| !EVP_DigestFinal_ex(&mctx, key, NULL))
-			rv = 0;
+	if (!EVP_DigestInit_ex(&mctx, EVP_sha1(), NULL) ||
+	    !EVP_DigestUpdate(&mctx, salt, saltlen) ||
+	    !EVP_DigestUpdate(&mctx, pass, passlen) ||
+	    !EVP_DigestFinal_ex(&mctx, key, NULL))
+		rv = 0;
 
 	EVP_MD_CTX_cleanup(&mctx);
 	return rv;
-	}
-	
+}
 
-static EVP_PKEY *do_PVK_body(const unsigned char **in,
-		unsigned int saltlen, unsigned int keylen,
-		pem_password_cb *cb, void *u)
-	{
+static EVP_PKEY *
+do_PVK_body(const unsigned char **in, unsigned int saltlen,
+    unsigned int keylen, pem_password_cb *cb, void *u)
+{
 	EVP_PKEY *ret = NULL;
 	const unsigned char *p = *in;
 	unsigned int magic;
 	unsigned char *enctmp = NULL, *q;
+
 	EVP_CIPHER_CTX cctx;
 	EVP_CIPHER_CTX_init(&cctx);
-	if (saltlen)
-		{
+	if (saltlen) {
 		char psbuf[PEM_BUFSIZE];
 		unsigned char keybuf[20];
 		int enctmplen, inlen;
 		if (cb)
-			inlen=cb(psbuf,PEM_BUFSIZE,0,u);
+			inlen = cb(psbuf, PEM_BUFSIZE, 0, u);
 		else
-			inlen=PEM_def_callback(psbuf,PEM_BUFSIZE,0,u);
-		if (inlen <= 0)
-			{
-			PEMerr(PEM_F_DO_PVK_BODY,PEM_R_BAD_PASSWORD_READ);
+			inlen = PEM_def_callback(psbuf, PEM_BUFSIZE, 0, u);
+		if (inlen <= 0) {
+			PEMerr(PEM_F_DO_PVK_BODY, PEM_R_BAD_PASSWORD_READ);
 			return NULL;
-			}
+		}
 		enctmp = malloc(keylen + 8);
-		if (!enctmp)
-			{
+		if (!enctmp) {
 			PEMerr(PEM_F_DO_PVK_BODY, ERR_R_MALLOC_FAILURE);
 			return NULL;
-			}
+		}
 		if (!derive_pvk_key(keybuf, p, saltlen,
 			    (unsigned char *)psbuf, inlen)) {
 			free(enctmp);
@@ -770,88 +755,84 @@ static EVP_PKEY *do_PVK_body(const unsigned char **in,
 		if (!EVP_DecryptFinal_ex(&cctx, q + enctmplen, &enctmplen))
 			goto err;
 		magic = read_ledword((const unsigned char **)&q);
-		if (magic != MS_RSA2MAGIC && magic != MS_DSS2MAGIC)
-			{
+		if (magic != MS_RSA2MAGIC && magic != MS_DSS2MAGIC) {
 			q = enctmp + 8;
 			memset(keybuf + 5, 0, 11);
 			if (!EVP_DecryptInit_ex(&cctx, EVP_rc4(), NULL, keybuf,
-								NULL))
+			    NULL))
 				goto err;
 			OPENSSL_cleanse(keybuf, 20);
 			if (!EVP_DecryptUpdate(&cctx, q, &enctmplen, p, inlen))
 				goto err;
 			if (!EVP_DecryptFinal_ex(&cctx, q + enctmplen,
-								&enctmplen))
+			    &enctmplen))
 				goto err;
 			magic = read_ledword((const unsigned char **)&q);
-			if (magic != MS_RSA2MAGIC && magic != MS_DSS2MAGIC)
-				{
+			if (magic != MS_RSA2MAGIC && magic != MS_DSS2MAGIC) {
 				PEMerr(PEM_F_DO_PVK_BODY, PEM_R_BAD_DECRYPT);
 				goto err;
-				}
 			}
-		else
+		} else
 			OPENSSL_cleanse(keybuf, 20);
 		p = enctmp;
-		}
+	}
 
 	ret = b2i_PrivateKey(&p, keylen);
-	err:
+
+err:
 	EVP_CIPHER_CTX_cleanup(&cctx);
 	if (enctmp && saltlen)
 		free(enctmp);
 	return ret;
-	}
+}
 
 
-EVP_PKEY *b2i_PVK_bio(BIO *in, pem_password_cb *cb, void *u)
-	{
+EVP_PKEY *
+b2i_PVK_bio(BIO *in, pem_password_cb *cb, void *u)
+{
 	unsigned char pvk_hdr[24], *buf = NULL;
 	const unsigned char *p;
 	int buflen;
 	EVP_PKEY *ret = NULL;
 	unsigned int saltlen, keylen;
-	if (BIO_read(in, pvk_hdr, 24) != 24)
-		{
+
+	if (BIO_read(in, pvk_hdr, 24) != 24) {
 		PEMerr(PEM_F_B2I_PVK_BIO, PEM_R_PVK_DATA_TOO_SHORT);
 		return NULL;
-		}
+	}
 	p = pvk_hdr;
 
 	if (!do_PVK_header(&p, 24, 0, &saltlen, &keylen))
 		return 0;
 	buflen = (int) keylen + saltlen;
 	buf = malloc(buflen);
-	if (!buf)
-		{
+	if (!buf) {
 		PEMerr(PEM_F_B2I_PVK_BIO, ERR_R_MALLOC_FAILURE);
 		return 0;
-		}
+	}
 	p = buf;
-	if (BIO_read(in, buf, buflen) != buflen)
-		{
+	if (BIO_read(in, buf, buflen) != buflen) {
 		PEMerr(PEM_F_B2I_PVK_BIO, PEM_R_PVK_DATA_TOO_SHORT);
 		goto err;
-		}
+	}
 	ret = do_PVK_body(&p, saltlen, keylen, cb, u);
 
-	err:
-	if (buf)
-		{
+err:
+	if (buf) {
 		OPENSSL_cleanse(buf, buflen);
 		free(buf);
-		}
-	return ret;
 	}
+	return ret;
+}
 
-	
-	
-static int i2b_PVK(unsigned char **out, EVP_PKEY*pk, int enclevel,
-		pem_password_cb *cb, void *u)
-	{
+static int
+i2b_PVK(unsigned char **out, EVP_PKEY*pk, int enclevel, pem_password_cb *cb,
+    void *u)
+{
 	int outlen = 24, pklen;
 	unsigned char *p, *salt = NULL;
 	EVP_CIPHER_CTX cctx;
+
 	EVP_CIPHER_CTX_init(&cctx);
 	if (enclevel)
 		outlen += PVK_SALTLEN;
@@ -863,16 +844,14 @@ static int i2b_PVK(unsigned char **out, EVP_PKEY*pk, int enclevel,
 		return outlen;
 	if (*out)
 		p = *out;
-	else
-		{
+	else {
 		p = malloc(outlen);
-		if (!p)
-			{
-			PEMerr(PEM_F_I2B_PVK,ERR_R_MALLOC_FAILURE);
+		if (!p) {
+			PEMerr(PEM_F_I2B_PVK, ERR_R_MALLOC_FAILURE);
 			return -1;
-			}
-		*out = p;
 		}
+		*out = p;
+	}
 
 	write_ledword(&p, MS_PVKMAGIC);
 	write_ledword(&p, 0);
@@ -881,34 +860,31 @@ static int i2b_PVK(unsigned char **out, EVP_PKEY*pk, int enclevel,
 	else
 		write_ledword(&p, MS_KEYTYPE_KEYX);
 	write_ledword(&p, enclevel ? 1 : 0);
-	write_ledword(&p, enclevel ? PVK_SALTLEN: 0);
+	write_ledword(&p, enclevel ? PVK_SALTLEN : 0);
 	write_ledword(&p, pklen);
-	if (enclevel)
-		{
+	if (enclevel) {
 		if (RAND_bytes(p, PVK_SALTLEN) <= 0)
 			goto error;
 		salt = p;
 		p += PVK_SALTLEN;
-		}
+	}
 	do_i2b(&p, pk, 0);
 	if (enclevel == 0)
 		return outlen;
-	else
-		{
+	else {
 		char psbuf[PEM_BUFSIZE];
 		unsigned char keybuf[20];
 		int enctmplen, inlen;
 		if (cb)
-			inlen=cb(psbuf,PEM_BUFSIZE,1,u);
+			inlen = cb(psbuf, PEM_BUFSIZE, 1, u);
 		else
-			inlen=PEM_def_callback(psbuf,PEM_BUFSIZE,1,u);
-		if (inlen <= 0)
-			{
-			PEMerr(PEM_F_I2B_PVK,PEM_R_BAD_PASSWORD_READ);
+			inlen = PEM_def_callback(psbuf, PEM_BUFSIZE, 1, u);
+		if (inlen <= 0) {
+			PEMerr(PEM_F_I2B_PVK, PEM_R_BAD_PASSWORD_READ);
 			goto error;
-			}
+		}
 		if (!derive_pvk_key(keybuf, salt, PVK_SALTLEN,
-			    (unsigned char *)psbuf, inlen))
+		    (unsigned char *)psbuf, inlen))
 			goto error;
 		if (enclevel == 1)
 			memset(keybuf + 5, 0, 11);
@@ -920,32 +896,32 @@ static int i2b_PVK(unsigned char **out, EVP_PKEY*pk, int enclevel,
 			goto error;
 		if (!EVP_DecryptFinal_ex(&cctx, p + enctmplen, &enctmplen))
 			goto error;
-		}
+	}
 	EVP_CIPHER_CTX_cleanup(&cctx);
 	return outlen;
 
-	error:
+error:
 	EVP_CIPHER_CTX_cleanup(&cctx);
 	return -1;
-	}
+}
 
-int i2b_PVK_bio(BIO *out, EVP_PKEY *pk, int enclevel,
-		pem_password_cb *cb, void *u)
-	{
+int
+i2b_PVK_bio(BIO *out, EVP_PKEY *pk, int enclevel, pem_password_cb *cb, void *u)
+{
 	unsigned char *tmp = NULL;
 	int outlen, wrlen;
+
 	outlen = i2b_PVK(&tmp, pk, enclevel, cb, u);
 	if (outlen < 0)
 		return -1;
 	wrlen = BIO_write(out, tmp, outlen);
 	free(tmp);
-	if (wrlen == outlen)
-		{
+	if (wrlen == outlen) {
 		PEMerr(PEM_F_I2B_PVK_BIO, PEM_R_BIO_WRITE_FAILURE);
 		return outlen;
-		}
-	return -1;
 	}
+	return -1;
+}
 
 #endif
 

