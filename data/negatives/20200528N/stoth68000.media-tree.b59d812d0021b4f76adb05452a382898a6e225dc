commit b59d812d0021b4f76adb05452a382898a6e225dc
Author: Jinshan Xiong <jinshan.xiong@intel.com>
Date:   Tue Apr 12 16:14:11 2016 -0400

    staging: lustre: osc: osc_extent_wait() shouldn't be interruptible
    
    Otherwise it will hit the assertion at cl_lock.c:
    
     cl_lock.c:1967:discard_cb())
      ASSERTION( (!(page->cp_type == CPT_CACHEABLE) ||
      (!PageWriteback(cl_page_vmpage(env, page)))) ) failed:
    
    This is because in osc_lock_flush() we have to make sure the IO
    is finished before discarding the pages.
    
    Signed-off-by: Jinshan Xiong <jinshan.xiong@intel.com>
    Intel-bug-id: https://jira.hpdd.intel.com/browse/LU-2779
    Reviewed-on: http://review.whamcloud.com/5419
    Reviewed-by: Bobi Jam <bobijam@gmail.com>
    Reviewed-by: Oleg Drokin <oleg.drokin@intel.com>
    Signed-off-by: James Simmons <jsimmons@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/lustre/lustre/osc/osc_cache.c b/drivers/staging/lustre/lustre/osc/osc_cache.c
index 8263a85495ac..43d8bcc3dbdb 100644
--- a/drivers/staging/lustre/lustre/osc/osc_cache.c
+++ b/drivers/staging/lustre/lustre/osc/osc_cache.c
@@ -965,7 +965,7 @@ static int osc_extent_wait(const struct lu_env *env, struct osc_extent *ext,
 			"%s: wait ext to %d timedout, recovery in progress?\n",
 			osc_export(obj)->exp_obd->obd_name, state);
 
-		lwi = LWI_INTR(LWI_ON_SIGNAL_NOOP, NULL);
+		lwi = LWI_INTR(NULL, NULL);
 		rc = l_wait_event(ext->oe_waitq, extent_wait_cb(ext, state),
 				  &lwi);
 	}

