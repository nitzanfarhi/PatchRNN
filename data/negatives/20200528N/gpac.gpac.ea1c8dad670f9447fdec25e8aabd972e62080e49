commit ea1c8dad670f9447fdec25e8aabd972e62080e49
Author: jeanlf <jeanlf@users.sourceforge.net>
Date:   Wed Sep 7 17:21:55 2016 +0200

    Added SRD+360 support for tiled HEVC streams

diff --git a/include/gpac/internal/terminal_dev.h b/include/gpac/internal/terminal_dev.h
index 3d338e874..84640540e 100644
--- a/include/gpac/internal/terminal_dev.h
+++ b/include/gpac/internal/terminal_dev.h
@@ -210,7 +210,7 @@ struct _scene
 	/*URLs of current video, audio and subs (we can't store objects since they may be destroyed when seeking)*/
 	SFURL visual_url, audio_url, text_url, dims_url;
 
-	Bool is_srd;
+	Bool is_srd, is_tiled_srd;
 	s32 srd_min_x, srd_max_x, srd_min_y, srd_max_y;
 
 
@@ -1187,7 +1187,7 @@ struct _mediaobj
 	u32 srd_x, srd_y, srd_w, srd_h;
 	
 	u32 quality_degradation_hint;
-	
+	u32 view_min_x, view_max_x, view_min_y, view_max_y;
 	GF_MediaDecoderFrame *media_frame;
 };
 
diff --git a/include/gpac/mediaobject.h b/include/gpac/mediaobject.h
index a6ae2bf2c..46842b927 100644
--- a/include/gpac/mediaobject.h
+++ b/include/gpac/mediaobject.h
@@ -204,7 +204,8 @@ typedef struct
 	
 	u32 scene_width;
 	u32 scene_height;
-	
+
+	Bool is_tiled_srd;
 } GF_MediaObjectVRInfo;
 
 //get SRD and VR info for this object. Returns FALSE if no VR and no SRD info
@@ -213,6 +214,8 @@ Bool gf_mo_get_srd_info(GF_MediaObject *mo, GF_MediaObjectVRInfo *vr_info);
 /*sets quality degradation hint for this media object  - quality_rank is between 0 (max quality) and 100 (worst quality)*/
 void gf_mo_hint_quality_degradation(GF_MediaObject *mo, u32 quality_degradation);
 
+/*sets visible rectangle for the object - only used in 360 videos for now*/
+void gf_mo_hint_visible_rect(GF_MediaObject *mo, u32 min_x, u32 max_x, u32 min_y, u32 max_y);
 
 #include <gpac/scenegraph_svg.h>
 void gf_mo_del(GF_MediaObject *mo);
diff --git a/include/gpac/modules/service.h b/include/gpac/modules/service.h
index 3808daf95..1c482d7f6 100644
--- a/include/gpac/modules/service.h
+++ b/include/gpac/modules/service.h
@@ -145,6 +145,8 @@ typedef enum
 	//sets nalu mode
 	GF_NET_CHAN_NALU_MODE,
 
+	/*indicates visible part of the visual object associated with the channel*/
+	GF_NET_CHAN_VISIBILITY_HINT,
 	/*request current position in TSB - 0 means 'at the live point'*/
 	GF_NET_GET_TIMESHIFT,
 
@@ -378,6 +380,17 @@ typedef struct
 	u32 dependent_group_index;
 } GF_NetComSRDInfo;
 
+/*GF_NET_CHAN_VISIBILITY_HINT*/
+typedef struct
+{
+	u32 command_type;
+	LPNETCHANNEL on_channel;
+	//gives min_max coords of the visible rectangle associated with channels.
+	//min_x may be greater than max_x in case of 360 videos
+	u32 min_x, max_x, min_y, max_y;
+} GF_NetComVisibililityHint;
+
+
 /*GF_NET_SERVICE_INFO*/
 typedef struct __netinfocom
 {
@@ -641,6 +654,7 @@ typedef union __netcommand
 	GF_NetQualityQuery quality_query;
 	GF_CodecStat codec_stat;
 	GF_NetComSRDInfo srd;
+	GF_NetComVisibililityHint visibility_hint;
 } GF_NetworkCommand;
 
 /*
diff --git a/modules/mpd_in/mpd_in.c b/modules/mpd_in/mpd_in.c
index bf9de93fe..7f831c360 100644
--- a/modules/mpd_in/mpd_in.c
+++ b/modules/mpd_in/mpd_in.c
@@ -1347,7 +1347,7 @@ GF_Err MPD_ServiceCommand(GF_InputService *plug, GF_NetworkCommand *com)
 		if (idx < 0) return GF_BAD_PARAM;
 		com->net_stats.bw_down = 8 * gf_dash_group_get_download_rate(mpdin->dash, idx);
 	}
-	return GF_OK;
+		return GF_OK;
 
 	case GF_NET_SERVICE_QUALITY_QUERY:
 	{
@@ -1401,8 +1401,11 @@ GF_Err MPD_ServiceCommand(GF_InputService *plug, GF_NetworkCommand *com)
 		com->quality_query.tile_adaptation_mode = (u32) gf_dash_get_tile_adaptation_mode(mpdin->dash);
 		return GF_OK;
 	}
+	case GF_NET_CHAN_VISIBILITY_HINT:
+		idx = MPD_GetGroupIndexForChannel(mpdin, com->base.on_channel);
+		if (idx < 0) return GF_BAD_PARAM;
 
-	break;
+		return gf_dash_group_set_visible_rect(mpdin->dash, idx, com->visibility_hint.min_x, com->visibility_hint.max_x, com->visibility_hint.min_y, com->visibility_hint.max_y);
 
 	case GF_NET_CHAN_BUFFER:
 		/*get it from MPD minBufferTime - if not in low latency mode, indicate the value given in MPD (not possible to fetch segments earlier) - to be more precise we should get the min segment duration for this group*/
diff --git a/src/compositor/hardcoded_protos.c b/src/compositor/hardcoded_protos.c
index 7507edabb..950240a7b 100644
--- a/src/compositor/hardcoded_protos.c
+++ b/src/compositor/hardcoded_protos.c
@@ -1375,7 +1375,7 @@ static void TraverseVRGeometry(GF_Node *node, void *rs, Bool is_destroy)
 				visible = GF_TRUE;
 			}
 			
-//			fprintf(stderr, "Angle center-cam is %.02f h %.02f v - visible %d\n", theta_angle, phi_angle, visible);
+			GF_LOG(GF_LOG_DEBUG, GF_LOG_COMPOSE, ("[Compositor] Texure %d Partial sphere is %s - Angle center-cam is %.02f h %.02f v\n", txh->stream->OD_ID, visible ? "visible" : "hidden",  theta_angle, phi_angle));
 
 			if (visible) {
 				gf_mo_hint_quality_degradation(asp.fill_texture->stream, 0);
diff --git a/src/compositor/mpeg4_geometry_3d.c b/src/compositor/mpeg4_geometry_3d.c
index 875aef4cd..597192a1b 100644
--- a/src/compositor/mpeg4_geometry_3d.c
+++ b/src/compositor/mpeg4_geometry_3d.c
@@ -120,9 +120,94 @@ static void build_shape_sphere(GF_Node *n, Drawable3D *stack, GF_TraverseState *
 	mesh_new_sphere(stack->mesh, sp->radius, tr_state->visual->compositor->high_speed, NULL);
 }
 
+static void get_tx_coords_from_angle(GF_TraverseState *tr_state, GF_TextureHandler *txh, Bool horizontal, u32 *min_coord, u32 *max_coord)
+{
+	GF_Vec target, ref, cross;
+	Fixed dot, det, hfov, theta_angle, angle_start, angle_end, min_tx, max_tx;
+	u32 dim;
+	
+	ref.x = horizontal ? FIX_ONE : 0;
+	ref.y = horizontal ? 0 : FIX_ONE;
+	ref.z = 0;
+
+	target = camera_get_target_dir(tr_state->camera);
+	if (horizontal) target.y = 0;
+	else target.x = 0;
+	
+	gf_vec_norm(&target);
+	dot = gf_vec_dot(target, ref);
+	if (horizontal) {
+		det = target.x*ref.z - target.z*ref.x;
+	} else {
+		det = target.y*ref.z - target.z*ref.y;
+	}
+	theta_angle = gf_atan2(det, dot);
+	//sphere starts horizontally at -PI/2
+	if (horizontal) {
+		theta_angle -= GF_PI2;
+		hfov = tr_state->camera->fieldOfView*tr_state->camera->width/tr_state->camera->height/2;
+	} else {
+		hfov = tr_state->camera->fieldOfView/2;
+	}
+
+	angle_start = theta_angle - hfov;
+	angle_end = theta_angle + hfov;
+
+	//move everything in [-PI,PI]
+	if (angle_start < -GF_PI) angle_start += GF_2PI;
+	if (angle_start > GF_PI) angle_start -= GF_2PI;
+	if (angle_end < -GF_PI) angle_end += GF_2PI;
+	if (angle_end > GF_PI) angle_end -= GF_2PI;
+	
+	if (horizontal) {
+		//start angle corresponds to max tx horiz coord, left to min
+		max_tx = FIX_ONE - (angle_start + GF_PI) / GF_2PI;
+		min_tx = FIX_ONE - (angle_end + GF_PI) / GF_2PI;
+		//we wrap horizontally, which means we may have min_tx > max_tx, in which case we need both [min_tx, WIDTH] and [0, max_tx] parts of the texture
+		dim = txh->width;
+	} else {
+		//-angle is the same position as +angle
+		if (angle_start<0) angle_start = -angle_start;
+		if (angle_end<0) angle_end = -angle_end;
+		//SRD x=0 is the top of the sphere - we don't wrap vertically
+		if (angle_start<angle_end) {
+			min_tx = angle_start / GF_PI;
+			max_tx = angle_end / GF_PI;
+		} else {
+			max_tx = angle_start / GF_PI;
+			min_tx = angle_end / GF_PI;
+		}
+		dim = txh->height;
+	}
+	*min_coord= (u32) (min_tx*dim);
+	*max_coord= (u32) (max_tx*dim);
+
+//	fprintf(stderr, "%s Angle is %g (%g <-> %g) - min tx %g (%u) - max tx %g (%u)\n", horizontal ? "X" : "Y", theta_angle, angle_start, angle_end, min_tx, *min_coord, max_tx, *max_coord);
+}
+
 static void TraverseSphere(GF_Node *n, void *rs, Bool is_destroy)
 {
+	GF_TraverseState *tr_state = (GF_TraverseState *)rs;
 	drawable_3d_base_traverse(n, rs, is_destroy, build_shape_sphere);
+
+	if (!is_destroy && tr_state->traversing_mode == TRAVERSE_DRAW_3D) {
+		GF_MediaObjectVRInfo vrinfo;
+		u32 min_x, max_x, min_y, max_y;
+		GF_TextureHandler *txh = gf_sc_texture_get_handler( ((M_Appearance *) tr_state->appear)->texture );
+		
+		if (!txh->stream) return;
+		
+		if (! gf_mo_get_srd_info(txh->stream, &vrinfo) || !vrinfo.is_tiled_srd)
+			return;
+		
+		//we need to compute min/max tex coords visible for that sphere
+		
+		get_tx_coords_from_angle(tr_state, txh, GF_TRUE, &min_x, &max_x);
+		get_tx_coords_from_angle(tr_state, txh, GF_FALSE, &min_y, &max_y);
+		
+		gf_mo_hint_visible_rect(txh->stream, min_x, max_x, min_y, max_y);
+		GF_LOG(GF_LOG_DEBUG, GF_LOG_COMPOSE, ("[Compositor] Visible texture rectangle of sphere is %u,%u,%u,%u\n", min_x, max_x, min_y, max_y));
+	}
 }
 
 void compositor_init_sphere(GF_Compositor *compositor, GF_Node *node)
diff --git a/src/compositor/navigate.c b/src/compositor/navigate.c
index 493b60584..74da815b5 100644
--- a/src/compositor/navigate.c
+++ b/src/compositor/navigate.c
@@ -145,9 +145,21 @@ static void view_pan_x(GF_Compositor *compositor, GF_Camera *cam, Fixed dx)
 static void view_pan_y(GF_Compositor *compositor, GF_Camera *cam, Fixed dy)
 {
 	GF_Matrix mx;
+	GF_Vec prev_target = cam->target;
 	if (!dy) return;
 	gf_mx_rotation_matrix(&mx, cam->position, camera_get_right_dir(cam), dy);
 	gf_mx_apply_vec(&mx, &cam->target);
+	switch (cam->navigate_mode) {
+	case GF_NAVIGATE_WALK:
+	case GF_NAVIGATE_VR:
+	case GF_NAVIGATE_GAME:
+		if (cam->target.z*prev_target.z<0) {
+			cam->target = prev_target;
+			return;
+		}
+	default:
+		break;
+	}
 
 	update_pan_up(compositor, cam);
 }
diff --git a/src/media_tools/dash_client.c b/src/media_tools/dash_client.c
index 8d686716d..39f8c8c88 100644
--- a/src/media_tools/dash_client.c
+++ b/src/media_tools/dash_client.c
@@ -2406,7 +2406,6 @@ static void dash_do_rate_adaptation(GF_DashClient *dash, GF_DASH_Group *group)
 
 			if (dl_rate >= arep->bandwidth) {
 				if (force_below_resolution && !dash->disable_speed_adaptation) {
-					if (!k) GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Speed adaptation\n"));
 					/*try to switch to highest quality below the current one*/
 					if ((arep->quality_ranking < rep->quality_ranking) || (arep->width < rep->width) || (arep->height < rep->height)) {
 						if (!new_rep)
@@ -2417,7 +2416,6 @@ static void dash_do_rate_adaptation(GF_DashClient *dash, GF_DASH_Group *group)
 					rep->playback.prev_max_available_speed = max_available_speed;
 					go_up_bitrate = GF_FALSE;
 				} else {
-					if (!k) GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Bitrate adaptation\n"));
 					if (!new_rep) new_rep = arep;
 					else if (go_up_bitrate) {
 						if (dash->agressive_switching) {
@@ -2449,7 +2447,7 @@ static void dash_do_rate_adaptation(GF_DashClient *dash, GF_DASH_Group *group)
 		}
 
 		if (!new_rep || (new_rep==rep)) {
-			GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[DASH] AS#%d no rep found better matching requested bandwidth %d - not switching !\n", 1+gf_list_find(group->period->adaptation_sets, group->adaptation_set), dl_rate));
+			GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[DASH] AS#%d no better match for requested bandwidth %d - not switching (AS bitrate %d)!\n", 1+gf_list_find(group->period->adaptation_sets, group->adaptation_set), dl_rate, rep->bandwidth));
 			do_switch=GF_FALSE;
 		}
 	}
@@ -3707,6 +3705,7 @@ static u32 gf_dash_get_tiles_quality_rank(GF_DashClient *dash, GF_DASH_Group *ti
 	
 	//no SRD is max quality for now
 	if (!srd) return 0;
+	if (!tile_group->srd_w || !tile_group->srd_h) return 0;
 	
 	if (tile_group->quality_degradation_hint) {
 		u32 v = tile_group->quality_degradation_hint * MAX(srd->srd_nb_rows, srd->srd_nb_cols);
@@ -4094,6 +4093,8 @@ select_active_rep:
 			Bool found = GF_FALSE;
 			GF_DASH_Group *group = gf_list_get(dash->groups, group_i);
 			if (group->srd_desc != srd) continue;
+			
+			if (!group->srd_w || !group->srd_h) continue;
 
 			for (k=0; k<srd->srd_nb_cols; k++) {
 				if (cols[k]==group->srd_x) {
@@ -4734,6 +4735,7 @@ static void dash_global_rate_adaptation(GF_DashClient *dash)
 					if (group->selection != GF_DASH_GROUP_SELECTED) continue;
 
 					quality_rank = gf_dash_get_tiles_quality_rank(dash, group);
+					if (quality_rank >= nb_qualities) quality_rank = nb_qualities-1;
 					if (quality_rank != q_idx) continue;
 
 					if (group->target_new_rep + 1 == gf_list_count(group->adaptation_set->representations))
@@ -4808,6 +4810,7 @@ static void dash_global_rate_adaptation(GF_DashClient *dash)
 		//decrease by quality level
 		else if (dash->tile_rate_decrease) {
 			quality_rank = gf_dash_get_tiles_quality_rank(dash, group);
+			if (quality_rank >= nb_qualities) quality_rank = nb_qualities-1;
 			assert(groups_per_quality[quality_rank]);
 			group->bytes_per_sec = bandwidths[quality_rank] / groups_per_quality[quality_rank];
 		}
@@ -7025,14 +7028,19 @@ GF_EXPORT
 Bool gf_dash_group_get_srd_info(GF_DashClient *dash, u32 idx, u32 *srd_id, u32 *srd_x, u32 *srd_y, u32 *srd_w, u32 *srd_h, u32 *srd_width, u32 *srd_height)
 {
 	GF_DASH_Group *group = gf_list_get(dash->groups, idx);
-	if (!group || !group->srd_w) return GF_FALSE;
-	if (srd_id) (*srd_id) = 0;
+	if (!group || !group->srd_desc) return GF_FALSE;
+	
+	if (group->srd_desc) {
+		if (srd_id) (*srd_id) = group->srd_desc->id;
+		if (srd_width) (*srd_width) = group->srd_desc->width;
+		if (srd_height) (*srd_height) = group->srd_desc->height;
+	}
+	
 	if (srd_x) (*srd_x) = group->srd_x;
 	if (srd_y) (*srd_y) = group->srd_y;
 	if (srd_w) (*srd_w) = group->srd_w;
 	if (srd_h) (*srd_h) = group->srd_h;
-	if (srd_width) (*srd_width) = 0;
-	if (srd_height) (*srd_height) = 0;
+
 
 	return GF_TRUE;
 }
@@ -7055,4 +7063,42 @@ GF_Err gf_dash_group_set_quality_degradation_hint(GF_DashClient *dash, u32 idx,
 }
 
 
+GF_EXPORT
+GF_Err gf_dash_group_set_visible_rect(GF_DashClient *dash, u32 idx, u32 min_x, u32 max_x, u32 min_y, u32 max_y)
+{
+	u32 i, count;
+	GF_DASH_Group *group = gf_list_get(dash->groups, idx);
+	if (!group) return GF_BAD_PARAM;
+
+	//TODO - single video, we may want to switch down quality if not a lot of the video is visible
+	//we will need the zoom factor as well
+	if (!group->groups_depending_on) return GF_OK;
+
+	GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Group Visible rect %d,%d,%d,%d \n", min_x, max_x, min_y, max_y));
+	count = gf_list_count(group->groups_depending_on);
+	for (i=0; i<count; i++) {
+		Bool is_visible = GF_TRUE;
+		GF_DASH_Group *a_group = gf_list_get(group->groups_depending_on, i);
+		if (!a_group->srd_w || !a_group->srd_h) continue;
+
+		//single rectangle case
+		if (min_x<max_x) {
+			if (a_group->srd_x+a_group->srd_h <min_x) is_visible = GF_FALSE;
+			else if (a_group->srd_x>max_x) is_visible = GF_FALSE;
+		} else {
+			if ( (a_group->srd_x>max_x) && (a_group->srd_x+a_group->srd_w<min_x)) is_visible = GF_FALSE;
+		}
+		
+		if (a_group->srd_y>max_y) is_visible = GF_FALSE;
+		else if (a_group->srd_y+a_group->srd_h < min_y) is_visible = GF_FALSE;
+		
+		a_group->quality_degradation_hint = is_visible ? 0 : 100;
+		
+		GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Group SRD %d,%d,%d,%d is %s\n", a_group->srd_x, a_group->srd_w, a_group->srd_y, a_group->srd_h, is_visible ? "visible" : "hidden"));
+	}
+	return GF_OK;
+}
+
+
+
 #endif //GPAC_DISABLE_DASH_CLIENT
diff --git a/src/terminal/media_object.c b/src/terminal/media_object.c
index 42529d9a0..034207158 100644
--- a/src/terminal/media_object.c
+++ b/src/terminal/media_object.c
@@ -330,14 +330,23 @@ static void gf_mo_update_visual_info(GF_MediaObject *mo)
 	}
 
 	com.base.command_type = GF_NET_CHAN_GET_SRD;
-	if ((gf_term_service_command(ch->service, &com) == GF_OK) && com.srd.w && com.srd.h) {
-		mo->srd_x = com.srd.x;
-		mo->srd_y = com.srd.y;
-		mo->srd_w = com.srd.w;
-		mo->srd_h = com.srd.h;
-
-		if (mo->odm->parentscene->is_dynamic_scene && !mo->odm->parentscene->is_srd) {
-			mo->odm->parentscene->is_srd = GF_TRUE;
+	if ((gf_term_service_command(ch->service, &com) == GF_OK)) {
+		//regular SRD object
+		if (com.srd.w && com.srd.h) {
+			mo->srd_x = com.srd.x;
+			mo->srd_y = com.srd.y;
+			mo->srd_w = com.srd.w;
+			mo->srd_h = com.srd.h;
+
+			if (mo->odm->parentscene->is_dynamic_scene && !mo->odm->parentscene->is_srd) {
+				mo->odm->parentscene->is_srd = GF_TRUE;
+			}
+		}
+		// SRD object with no size but global scene size: HEVC tiled bas object
+		else if (com.srd.width && com.srd.height) {
+			if (mo->odm->parentscene->is_dynamic_scene && !mo->odm->parentscene->is_srd) {
+				mo->odm->parentscene->is_tiled_srd = GF_TRUE;
+			}
 		}
 	}
 }
@@ -1474,6 +1483,8 @@ Bool gf_mo_get_srd_info(GF_MediaObject *mo, GF_MediaObjectVRInfo *vr_info)
 	vr_info->srd_min_y = scene->srd_min_y;
 	vr_info->srd_max_x = scene->srd_max_x;
 	vr_info->srd_max_y = scene->srd_max_y;
+	vr_info->is_tiled_srd = scene->is_tiled_srd;
+	
 	gf_sg_get_scene_size_info(scene->graph, &vr_info->scene_width, &vr_info->scene_height);
 
 	gf_odm_lock(mo->odm, 0);
@@ -1502,4 +1513,33 @@ void gf_mo_hint_quality_degradation(GF_MediaObject *mo, u32 quality_degradation)
 	gf_odm_lock(mo->odm, 0);
 }
 
+void gf_mo_hint_visible_rect(GF_MediaObject *mo, u32 min_x, u32 max_x, u32 min_y, u32 max_y)
+{
+	
+	if (!gf_odm_lock_mo(mo)) return;
+	if (!mo->odm || !mo->odm->codec) {
+		gf_odm_lock(mo->odm, 0);
+		return;
+	}
+	if ((mo->view_min_x!=min_x) || (mo->view_max_x!=max_x) || (mo->view_min_y!=min_y) || (mo->view_max_y!=max_y)) {
+		GF_NetworkCommand com;
+		mo->view_min_x = min_x;
+		mo->view_max_x = max_x;
+		mo->view_min_y = min_y;
+		mo->view_max_y = max_y;
+		
+		memset(&com, 0, sizeof(GF_NetworkCommand));
+		com.base.command_type = GF_NET_CHAN_VISIBILITY_HINT;
+		com.base.on_channel = gf_list_get(mo->odm->codec->inChannels, 0);
+		com.visibility_hint.min_x = min_x;
+		com.visibility_hint.max_x = max_x;
+		com.visibility_hint.min_y = min_y;
+		com.visibility_hint.max_y = max_y;
+		gf_term_service_command(mo->odm->net_service, &com);
+	}
+	
+	gf_odm_lock(mo->odm, 0);
+}
+
+
 
diff --git a/src/terminal/scene.c b/src/terminal/scene.c
index fd440c5cc..58cc72ff8 100644
--- a/src/terminal/scene.c
+++ b/src/terminal/scene.c
@@ -1171,6 +1171,7 @@ static void set_media_url(GF_Scene *scene, SFURL *media_url, GF_Node *node,  MFU
 			if (odm->mo && (type==GF_STREAM_VISUAL)) {
 				gf_scene_get_video_size(odm->mo, &w, &h);
 				if (w && h) {
+					scene->force_size_set = 0;
 					gf_sg_set_scene_size_info(scene->graph, w, h, 1);
 					gf_scene_force_size(scene, w, h);
 				}
@@ -2070,9 +2071,11 @@ void gf_scene_force_size(GF_Scene *scene, u32 width, u32 height)
 		GF_NetworkCommand com;
 
 		memset(&com, 0, sizeof(GF_NetworkCommand));
-		com.base.command_type = GF_NET_SERVICE_HAS_FORCED_VIDEO_SIZE;
-		gf_term_service_command(scene->root_od->net_service, &com);
-
+		if (!scene->vr_type) {
+			com.base.command_type = GF_NET_SERVICE_HAS_FORCED_VIDEO_SIZE;
+			gf_term_service_command(scene->root_od->net_service, &com);
+		}
+		
 		if (scene->root_od->term->root_scene == scene) {
 			if (com.par.width && com.par.height) {
 				gf_sc_set_scene_size(scene->root_od->term->compositor, width, height, 1);

