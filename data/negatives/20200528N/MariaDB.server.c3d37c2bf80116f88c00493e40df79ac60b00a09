commit c3d37c2bf80116f88c00493e40df79ac60b00a09
Author: unknown <msvensson@neptunus.(none)>
Date:   Tue Apr 11 20:41:05 2006 +0200

    Bug#18474 Unlistable directories yield no info from information_schema, part2
     - Improved solution by adding an else stetment so that do find next is avoided if erorr occurs, but we still return zero files found instaed of an error
    
    
    mysys/my_lib.c:
      Add else statment so that if a directory can't be read because of access denied it will be skipped and zero files returned.
      Use strnmov instead of strmov to avoid writing after end of buffer

diff --git a/mysys/my_lib.c b/mysys/my_lib.c
index 522fa56cbf1..03f2d91916d 100644
--- a/mysys/my_lib.c
+++ b/mysys/my_lib.c
@@ -384,11 +384,10 @@ MY_DIR	*my_dir(const char *path, myf MyFlags)
   DBUG_PRINT("my",("path: '%s' stat: %d  MyFlags: %d",path,MyFlags));
 
   /* Put LIB-CHAR as last path-character if not there */
-
   tmp_file=tmp_path;
   if (!*path)
     *tmp_file++ ='.';				/* From current dir */
-  tmp_file= strmov(tmp_file,path);
+  tmp_file= strnmov(tmp_file, path, FN_REFLEN-5);
   if (tmp_file[-1] == FN_DEVCHAR)
     *tmp_file++= '.';				/* From current dev-dir */
   if (tmp_file[-1] != FN_LIBCHAR)
@@ -424,7 +423,7 @@ MY_DIR	*my_dir(const char *path, myf MyFlags)
   if ((handle=_findfirst(tmp_path,&find)) == -1L)
 #endif
   {
-    DBUG_PRINT("info", ("find_first returned error"));
+    DBUG_PRINT("info", ("findfirst returned error, errno: %d", errno));
     if  (errno != EINVAL)
       goto error;
     /*
@@ -433,72 +432,76 @@ MY_DIR	*my_dir(const char *path, myf MyFlags)
       continue and return zero files in dir
     */
   }
-
-  do
+  else
   {
+
+    do
+    {
 #ifdef __BORLANDC__
-    attrib= find.ff_attrib;
+      attrib= find.ff_attrib;
 #else
-    attrib= find.attrib;
-    /*
-      Do not show hidden and system files which Windows sometimes create.
-      Note. Because Borland's findfirst() is called with the third
-      argument = 0 hidden/system files are excluded from the search.
-    */
-    if (attrib & (_A_HIDDEN | _A_SYSTEM))
-      continue;
-#endif    
+      attrib= find.attrib;
+      /*
+        Do not show hidden and system files which Windows sometimes create.
+        Note. Because Borland's findfirst() is called with the third
+        argument = 0 hidden/system files are excluded from the search.
+      */
+      if (attrib & (_A_HIDDEN | _A_SYSTEM))
+        continue;
+#endif
 #ifdef __BORLANDC__
-    if (!(finfo.name= strdup_root(names_storage, find.ff_name)))
-      goto error;
+      if (!(finfo.name= strdup_root(names_storage, find.ff_name)))
+        goto error;
 #else
-    if (!(finfo.name= strdup_root(names_storage, find.name)))
-      goto error;
-#endif    
-    if (MyFlags & MY_WANT_STAT)
-    {
-      if (!(finfo.mystat= (MY_STAT*)alloc_root(names_storage, 
-                                               sizeof(MY_STAT))))
+      if (!(finfo.name= strdup_root(names_storage, find.name)))
         goto error;
-      
-      bzero(finfo.mystat, sizeof(MY_STAT));
+#endif
+      if (MyFlags & MY_WANT_STAT)
+      {
+        if (!(finfo.mystat= (MY_STAT*)alloc_root(names_storage,
+                                                 sizeof(MY_STAT))))
+          goto error;
+
+        bzero(finfo.mystat, sizeof(MY_STAT));
 #ifdef __BORLANDC__
-      finfo.mystat->st_size=find.ff_fsize;
+        finfo.mystat->st_size=find.ff_fsize;
 #else
-      finfo.mystat->st_size=find.size;
+        finfo.mystat->st_size=find.size;
 #endif
-      mode=MY_S_IREAD;
-      if (!(attrib & _A_RDONLY))
-	mode|=MY_S_IWRITE;
-      if (attrib & _A_SUBDIR)
-	mode|=MY_S_IFDIR;
-      finfo.mystat->st_mode=mode;
+        mode= MY_S_IREAD;
+        if (!(attrib & _A_RDONLY))
+          mode|= MY_S_IWRITE;
+        if (attrib & _A_SUBDIR)
+          mode|= MY_S_IFDIR;
+        finfo.mystat->st_mode= mode;
 #ifdef __BORLANDC__
-      finfo.mystat->st_mtime=((uint32) find.ff_ftime);
+        finfo.mystat->st_mtime= ((uint32) find.ff_ftime);
 #else
-      finfo.mystat->st_mtime=((uint32) find.time_write);
+        finfo.mystat->st_mtime= ((uint32) find.time_write);
 #endif
-    }
-    else
-      finfo.mystat= NULL;
+      }
+      else
+        finfo.mystat= NULL;
 
-    if (push_dynamic(dir_entries_storage, (gptr)&finfo))
-      goto error;
-    
+      if (push_dynamic(dir_entries_storage, (gptr)&finfo))
+        goto error;
+    }
 #ifdef __BORLANDC__
-  } while (findnext(&find) == 0);
+    while (findnext(&find) == 0);
 #else
-  } while (_findnext(handle,&find) == 0);
-  
-  _findclose(handle);
+    while (_findnext(handle,&find) == 0);
+
+    _findclose(handle);
 #endif
+  }
 
   result->dir_entry= (FILEINFO *)dir_entries_storage->buffer;
   result->number_off_files= dir_entries_storage->elements;
-  
+
   if (!(MyFlags & MY_DONT_SORT))
     qsort((void *) result->dir_entry, result->number_off_files,
           sizeof(FILEINFO), (qsort_cmp) comp_names);
+  DBUG_PRINT(exit, ("found %d files", result->number_off_files));
   DBUG_RETURN(result);
 error:
   my_errno=errno;

