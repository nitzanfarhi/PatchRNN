commit 514ab34dbad6c6fa824a1f56984c196e59082346
Author: Ian Jamison <ian.dev@arkver.com>
Date:   Fri Jul 14 17:31:57 2017 +0100

    serial: imx: Prevent TX buffer PIO write when a DMA has been started
    
    Function imx_transmit_buffer starts a TX DMA if DMA is enabled, since
    commit 91a1a909f921 ("serial: imx: Support sw flow control in DMA mode").
    It also carries on and attempts to write the same TX buffer using PIO.
    This results in TX data corruption and double-incrementing xmit->tail
    with the knock-on effect of tail passing head and a page of garbage
    being sent out.
    
    This seems to be triggered mostly when using RS485 half duplex on SMP
    systems, but is probably not limited to just those.
    
    Tested locally on an i.MX6Q with an RS485 half duplex transceiver on
    UART3, and also by Clemens Gruber.
    
    Tested-by: Clemens Gruber <clemens.gruber@pqgruber.com>
    Signed-off-by: Ian Jamison <ian.dev@arkver.com>
    Reviewed-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c
index e33da75ceac5..80934e7bd67f 100644
--- a/drivers/tty/serial/imx.c
+++ b/drivers/tty/serial/imx.c
@@ -458,7 +458,7 @@ static inline void imx_transmit_buffer(struct imx_port *sport)
 		}
 	}
 
-	while (!uart_circ_empty(xmit) &&
+	while (!uart_circ_empty(xmit) && !sport->dma_is_txing &&
 	       !(readl(sport->port.membase + uts_reg(sport)) & UTS_TXFULL)) {
 		/* send xmit->buf[xmit->tail]
 		 * out the port here */

