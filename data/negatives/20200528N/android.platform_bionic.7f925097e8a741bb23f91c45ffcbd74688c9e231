commit 7f925097e8a741bb23f91c45ffcbd74688c9e231
Author: Elliott Hughes <enh@google.com>
Date:   Tue Feb 10 14:15:33 2015 -0800

    Fix our ftw tests.
    
    SELinux denies access to some files in /sys, so we can't just trawl
    through that asserting general truths. Instead, create a small known
    tree.
    
    Sadly neither ftw nor nftw takes user callback data, otherwise it would
    be nice to assert that we visit all the expected nodes.
    
    Bug: 19252748
    Change-Id: Ib5309c38aaef53e6030281191a265a8d5a619044

diff --git a/tests/ftw_test.cpp b/tests/ftw_test.cpp
index 38b3d49de..6741d003e 100644
--- a/tests/ftw_test.cpp
+++ b/tests/ftw_test.cpp
@@ -16,34 +16,53 @@
 
 #include <ftw.h>
 
+#include <stdio.h>
 #include <stdlib.h>
 #include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include "TemporaryFile.h"
 
 #include <gtest/gtest.h>
 
+static void MakeTree(const char* root) {
+  char path[PATH_MAX];
+
+  snprintf(path, sizeof(path), "%s/dir", root);
+  ASSERT_EQ(0, mkdir(path, 0555));
+  snprintf(path, sizeof(path), "%s/dir/sub", root);
+  ASSERT_EQ(0, mkdir(path, 0555));
+  snprintf(path, sizeof(path), "%s/unreadable-dir", root);
+  ASSERT_EQ(0, mkdir(path, 0000));
+
+  snprintf(path, sizeof(path), "%s/dangler", root);
+  ASSERT_EQ(0, symlink("/does-not-exist", path));
+  snprintf(path, sizeof(path), "%s/symlink", root);
+  ASSERT_EQ(0, symlink("sub2", path));
+
+  int fd;
+  snprintf(path, sizeof(path), "%s/regular", root);
+  ASSERT_NE(-1, fd = open(path, O_CREAT|O_TRUNC, 0666));
+  ASSERT_EQ(0, close(fd));
+}
+
 void sanity_check_ftw(const char* fpath, const struct stat* sb, int tflag) {
   ASSERT_TRUE(fpath != NULL);
   ASSERT_TRUE(sb != NULL);
+
   if (S_ISDIR(sb->st_mode)) {
-    ASSERT_TRUE(tflag == FTW_D || tflag == FTW_DNR || tflag == FTW_DP) << fpath;
+    EXPECT_TRUE(tflag == FTW_D || tflag == FTW_DNR || tflag == FTW_DP) << fpath;
   } else if (S_ISLNK(sb->st_mode)) {
-    ASSERT_EQ(FTW_SL, tflag) << fpath;
+    EXPECT_EQ(FTW_SL, tflag) << fpath;
   } else {
-    ASSERT_EQ(FTW_F, tflag) << fpath;
+    EXPECT_EQ(FTW_F, tflag) << fpath;
   }
 }
 
 void sanity_check_nftw(const char* fpath, const struct stat* sb, int tflag, struct FTW* ftwbuf) {
   sanity_check_ftw(fpath, sb, tflag);
-
-  size_t slash_count = 0;
-  const char* p = fpath;
-  while ((p = strchr(p + 1, '/')) != NULL) {
-    ++slash_count;
-  }
-
   ASSERT_EQ('/', fpath[ftwbuf->base - 1]) << fpath;
-  ASSERT_EQ(slash_count, static_cast<size_t>(ftwbuf->level)) << fpath;
 }
 
 int check_ftw(const char* fpath, const struct stat* sb, int tflag) {
@@ -67,17 +86,25 @@ int check_nftw64(const char* fpath, const struct stat64* sb, int tflag, struct F
 }
 
 TEST(ftw, ftw) {
-  ASSERT_EQ(0, ftw("/sys", check_ftw, 128));
+  TemporaryDir root;
+  MakeTree(root.dirname);
+  ASSERT_EQ(0, ftw(root.dirname, check_ftw, 128));
 }
 
 TEST(ftw, ftw64) {
-  ASSERT_EQ(0, ftw64("/sys", check_ftw64, 128));
+  TemporaryDir root;
+  MakeTree(root.dirname);
+  ASSERT_EQ(0, ftw64(root.dirname, check_ftw64, 128));
 }
 
 TEST(ftw, nftw) {
-  ASSERT_EQ(0, nftw("/sys", check_nftw, 128, 0));
+  TemporaryDir root;
+  MakeTree(root.dirname);
+  ASSERT_EQ(0, nftw(root.dirname, check_nftw, 128, 0));
 }
 
 TEST(ftw, nftw64) {
-  ASSERT_EQ(0, nftw64("/sys", check_nftw64, 128, 0));
+  TemporaryDir root;
+  MakeTree(root.dirname);
+  ASSERT_EQ(0, nftw64(root.dirname, check_nftw64, 128, 0));
 }

