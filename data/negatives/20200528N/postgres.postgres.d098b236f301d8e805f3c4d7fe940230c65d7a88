commit d098b236f301d8e805f3c4d7fe940230c65d7a88
Author: Noah Misch <noah@leadboat.com>
Date:   Wed Jun 11 19:50:29 2014 -0400

    Fix typos in comments.

diff --git a/src/backend/catalog/namespace.c b/src/backend/catalog/namespace.c
index 89df585b87..db2bafd4fa 100644
--- a/src/backend/catalog/namespace.c
+++ b/src/backend/catalog/namespace.c
@@ -260,7 +260,7 @@ RangeVarGetRelidExtended(const RangeVar *relation, LOCKMODE lockmode,
 	 * with the answer changing under them, or that they already hold some
 	 * appropriate lock, and therefore return the first answer we get without
 	 * checking for invalidation messages.  Also, if the requested lock is
-	 * already held, no LockRelationOid will not AcceptInvalidationMessages,
+	 * already held, LockRelationOid will not AcceptInvalidationMessages,
 	 * so we may fail to notice a change.  We could protect against that case
 	 * by calling AcceptInvalidationMessages() before beginning this loop, but
 	 * that would add a significant amount overhead, so for now we don't.
@@ -502,7 +502,7 @@ RangeVarGetCreationNamespace(const RangeVar *newRelation)
  * the same name which already exists in that namespace, or to InvalidOid if
  * no such relation exists.
  *
- * If lockmode != NoLock, the specified lock mode is acquire on the existing
+ * If lockmode != NoLock, the specified lock mode is acquired on the existing
  * relation, if any, provided that the current user owns the target relation.
  * However, if lockmode != NoLock and the user does not own the target
  * relation, we throw an ERROR, as we must not try to lock relations the
diff --git a/src/backend/port/win32/socket.c b/src/backend/port/win32/socket.c
index 7b0f71b65d..6a518e5b6d 100644
--- a/src/backend/port/win32/socket.c
+++ b/src/backend/port/win32/socket.c
@@ -177,7 +177,7 @@ pgwin32_waitforsinglesocket(SOCKET s, int what, int timeout)
 	 * Just a workaround of unknown locking problem with writing in UDP socket
 	 * under high load: Client's pgsql backend sleeps infinitely in
 	 * WaitForMultipleObjectsEx, pgstat process sleeps in pgwin32_select().
-	 * So, we will wait with small timeout(0.1 sec) and if sockect is still
+	 * So, we will wait with small timeout(0.1 sec) and if socket is still
 	 * blocked, try WSASend (see comments in pgwin32_select) and wait again.
 	 */
 	if ((what & FD_WRITE) && isUDP)
diff --git a/src/backend/utils/mb/encnames.c b/src/backend/utils/mb/encnames.c
index 38fae001eb..94334c47b6 100644
--- a/src/backend/utils/mb/encnames.c
+++ b/src/backend/utils/mb/encnames.c
@@ -1,6 +1,6 @@
 /*
  * Encoding names and routines for work with it. All
- * in this file is shared bedween FE and BE.
+ * in this file is shared between FE and BE.
  *
  * src/backend/utils/mb/encnames.c
  */
diff --git a/src/bin/pg_dump/pg_dump.c b/src/bin/pg_dump/pg_dump.c
index e52591606f..67a93a305d 100644
--- a/src/bin/pg_dump/pg_dump.c
+++ b/src/bin/pg_dump/pg_dump.c
@@ -11332,7 +11332,7 @@ dumpCollation(Archive *fout, CollInfo *collinfo)
 	/* Make sure we are in proper schema */
 	selectSourceSchema(fout, collinfo->dobj.namespace->dobj.name);
 
-	/* Get conversion-specific details */
+	/* Get collation-specific details */
 	appendPQExpBuffer(query, "SELECT "
 					  "collcollate, "
 					  "collctype "

