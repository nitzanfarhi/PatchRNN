commit a3f7ce2336caed59119e152225bdbfa3a7c6942e
Author: emvivre <emvivre@urdn.com.ua>
Date:   Tue Jan 9 20:17:28 2018 +0100

    Add several operators for x86 assembly (LLDT, LMSW, LGDT/LIDT) (#9165)
    
    * Add LLDT operator for x86 assembler (Load Local Descriptor Table Register)
    
    * Add LMSW operator for x86 assembler (Load Machine Status Word)
    
    * Add LGDT/LIDT operator for x86 assembler (Load Global/Interrupt Descriptor Table Register)

diff --git a/libr/asm/p/asm_x86_nz.c b/libr/asm/p/asm_x86_nz.c
index 0923da115..533d4d74e 100644
--- a/libr/asm/p/asm_x86_nz.c
+++ b/libr/asm/p/asm_x86_nz.c
@@ -3270,6 +3270,86 @@ static int opfsave(RAsm *a, ut8 *data, const Opcode *op) {
 	return l;
 }
 
+static int oplldt(RAsm *a, ut8 *data, const Opcode *op) {
+	int l = 0;
+	switch (op->operands_count) {
+	case 1:
+		if ( op->operands[0].type & OT_WORD ) {
+			data[l++] = 0x0f;
+			data[l++] = 0x00;
+			if ( op->operands[0].type & OT_MEMORY ) {
+				data[l++] = 0x10 | op->operands[0].regs[0];
+			} else {
+				data[l++] = 0xd0 | op->operands[0].reg;
+			}
+		} else {
+			return -1;
+		}
+		break;
+	default:
+		return -1;
+	}
+	return l;
+}
+
+static int oplmsw(RAsm *a, ut8 *data, const Opcode *op) {
+	int l = 0;
+	switch (op->operands_count) {
+	case 1:
+		if ( op->operands[0].type & OT_WORD ) {
+			data[l++] = 0x0f;
+			data[l++] = 0x01;
+			if ( op->operands[0].type & OT_MEMORY ) {
+				data[l++] = 0x30 | op->operands[0].regs[0];
+			} else {
+				data[l++] = 0xf0 | op->operands[0].reg;
+			}
+		} else {
+			return -1;
+		}
+		break;
+	default:
+		return -1;
+	}
+	return l;
+}
+
+static int oplgdt(RAsm *a, ut8 *data, const Opcode *op) {
+	int l = 0;
+	switch (op->operands_count) {
+	case 1:
+		if ( op->operands[0].type & OT_MEMORY ) {
+			data[l++] = 0x0f;
+			data[l++] = 0x01;
+			data[l++] = 0x10 | op->operands[0].regs[0];
+		} else {
+			return -1;
+		}
+		break;
+	default:
+		return -1;
+	}
+	return l;
+}
+
+static int oplidt(RAsm *a, ut8 *data, const Opcode *op) {
+	int l = 0;
+	switch (op->operands_count) {
+	case 1:
+		if ( op->operands[0].type & OT_MEMORY ) {
+			data[l++] = 0x0f;
+			data[l++] = 0x01;
+			data[l++] = 0x18 | op->operands[0].regs[0];
+		} else {
+			return -1;
+		}
+		break;
+	default:
+		return -1;
+	}
+	return l;
+}
+
 typedef struct lookup_t {
 	char mnemonic[12];
 	int only_x32;
@@ -3484,6 +3564,10 @@ LookupTable oplookup[] = {
 	{"leave", 0, NULL, 0xc9, 1},
 	{"les", 0, &oples, 0},
 	{"lfence", 0, NULL, 0x0faee8, 3},
+	{"lgdt", 0, &oplgdt, 0},
+	{"lidt", 0, &oplidt, 0},
+	{"lldt", 0, &oplldt, 0},
+	{"lmsw", 0, &oplmsw, 0},
 	{"lodsb", 0, NULL, 0xac, 1},
 	{"lodsd", 0, NULL, 0xad, 1},
 	{"lodsw", 0, NULL, 0x66ad, 2},

