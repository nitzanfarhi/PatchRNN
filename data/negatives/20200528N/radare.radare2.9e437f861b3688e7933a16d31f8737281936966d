commit 9e437f861b3688e7933a16d31f8737281936966d
Author: Srimanta Barua <srimanta.barua1@gmail.com>
Date:   Sat Jul 8 13:59:11 2017 +0530

    Added qRcmd monitor commands to io_gdb (#7877)
    
    * Added qRcmd to io_gdb
    
    * Printing reply to pkt and prompting for ack if required. Also adhering to r2 coding conventions

diff --git a/libr/io/p/io_gdb.c b/libr/io/p/io_gdb.c
index 9704ae649..663217add 100644
--- a/libr/io/p/io_gdb.c
+++ b/libr/io/p/io_gdb.c
@@ -191,27 +191,44 @@ static int __system(RIO *io, RIODesc *fd, const char *cmd) {
         /* XXX ugly hack for testing purposes */
         if (!cmd[0] || cmd[0] == '?' || !strcmp (cmd, "help")) {
                 eprintf ("Usage: =!cmd args\n"
-                         " =!pid      - show targeted pid\n"
-                         " =!pkt s    - send packet 's'\n"
-                         " =!inv.reg  - invalidate reg cache\n");
-	} else if (!strncmp (cmd, "pkt ", 4)) {
+                         " =!pid       - show targeted pid\n"
+                         " =!pkt s     - send packet 's'\n"
+                         " =!qRcmd cmd - hex-encode cmd and pass to target interpreter\n"
+                         " =!inv.reg   - invalidate reg cache\n");
+		return true;
+	}
+	if (!strncmp (cmd, "pkt ", 4)) {
 		if (send_msg (desc, cmd + 4) == -1) {
 			return false;
 		}
 		int r = read_packet (desc);
-		eprintf ("r = %d\n", r);
-	} else if (!strncmp (cmd, "pid", 3)) {
+		desc->data[desc->data_len] = '\0';
+		eprintf ("reply:\n\n%s\n", desc->data);
+		if (!desc->no_ack) {
+			eprintf ("[waiting for ack]\n");
+		}
+		return r >= 0;
+	}
+	if (!strncmp (cmd, "pid", 3)) {
 		int pid = desc ? desc->pid : -1;
 		if (!cmd[3]) {
 			io->cb_printf ("%d\n", pid);
 		}
 		return pid;
-	} else if (!strncmp (cmd, "inv.reg", 7)) {
+	}
+	if (!strncmp (cmd, "qRcmd ", 6)) {
+		if (gdbr_send_qRcmd (desc, cmd + 6) < 0) {
+			eprintf ("remote error\n");
+			return false;
+		}
+		return true;
+	}
+	if (!strncmp (cmd, "inv.reg", 7)) {
 		gdbr_invalidate_reg_cache ();
-	} else {
-		eprintf ("Try: '=!?'\n");
+		return true;
 	}
-        return true;
+	eprintf ("Try: '=!?'\n");
+	return true;
 }
 
 RIOPlugin r_io_plugin_gdb = {
diff --git a/shlr/gdb/include/gdbclient/commands.h b/shlr/gdb/include/gdbclient/commands.h
index afa9fdd10..07014fc80 100644
--- a/shlr/gdb/include/gdbclient/commands.h
+++ b/shlr/gdb/include/gdbclient/commands.h
@@ -40,6 +40,13 @@ int gdbr_check_extended_mode(libgdbr_t *g);
  */
 int gdbr_check_vcont(libgdbr_t *g);
 
+/*!
+ * \brief sends a qRcmd packet which basically passes a command to the
+ * remote target's interpreter.
+ * \returns 0 on success and -1 on failure
+ */
+int gdbr_send_qRcmd(libgdbr_t *g, const char *cmd);
+
 /*!
  * \brief attaches to a process
  * \param pid of the process to attach to
diff --git a/shlr/gdb/src/gdbclient/core.c b/shlr/gdb/src/gdbclient/core.c
index d6151c826..8eedc19e5 100644
--- a/shlr/gdb/src/gdbclient/core.c
+++ b/shlr/gdb/src/gdbclient/core.c
@@ -1013,3 +1013,55 @@ int gdbr_close_file(libgdbr_t *g) {
 void gdbr_invalidate_reg_cache() {
 	reg_cache.valid = false;
 }
+
+int gdbr_send_qRcmd(libgdbr_t *g, const char *cmd) {
+	if (!g || !cmd) {
+		return -1;
+	}
+	char *buf;
+	size_t len = strlen (cmd) * 2 + 8;
+	if (!(buf = calloc (len, sizeof (char)))) {
+		return -1;
+	}
+	strncpy (buf, "qRcmd,", 6);
+	pack_hex (cmd, strlen (cmd), buf + 6);
+	if (send_msg (g, buf) < 0) {
+		free (buf);
+		return -1;
+	}
+	if (read_packet (g) < 0) {
+		free (buf);
+		return -1;
+	}
+	while (1) {
+		if (send_ack (g) < 0) {
+			free (buf);
+			return -1;
+		}
+		if (g->data_len == 0) {
+			free (buf);
+			return -1;
+		}
+		if (g->data_len == 3 && g->data[0] == 'E'
+		    && isxdigit (g->data[1]) && isxdigit (g->data[2])) {
+			free (buf);
+			return -1;
+		}
+		if (!strncmp (g->data, "OK", 2)) {
+			free (buf);
+			return 0;
+		}
+		if (g->data[0] == 'O' && g->data_len % 2 == 1) {
+			// Console output from gdbserver
+			unpack_hex (g->data + 1, g->data_len - 1, g->data + 1);
+			g->data[g->data_len - 1] = '\0';
+			eprintf ("%s", g->data + 1);
+		}
+		if (read_packet (g) < 0) {
+			free (buf);
+			return -1;
+		}
+	}
+	free (buf);
+	return -1;
+}

