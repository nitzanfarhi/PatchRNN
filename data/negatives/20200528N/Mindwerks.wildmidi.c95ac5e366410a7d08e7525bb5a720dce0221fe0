commit c95ac5e366410a7d08e7525bb5a720dce0221fe0
Author: chrisisonwildcode <chrisisonwildcode@gmail.com>
Date:   Mon Jan 26 14:33:22 2015 +1000

    Fixed a bug with the gus_pat autofix that was still making some faulty instruments sound bad and hold to long after release.
    Fixed a bug with channel pressure when set without any active notes.
    Added function to strip '\r' and '\n' from meta text events and replace with ' '.
    Playing around with the look of the player.
    Pausing now displays a P where the spinner normally is.
    Removed and additional space per cycle from the hidden feature.

diff --git a/src/gus_pat.c b/src/gus_pat.c
index 44bb43b..dd9d433 100644
--- a/src/gus_pat.c
+++ b/src/gus_pat.c
@@ -840,6 +840,26 @@ struct _sample * _WM_load_gus_pat(const char *filename, int fix_release) {
          Lets make this automatic ...
          */
         {
+            if (env_time_table[gus_patch[gus_ptr + 40]] < env_time_table[gus_patch[gus_ptr + 41]]) {
+                uint8_t tmp_hack_rate = 0;
+                /*
+                 After studying faulty gus_pats this way may work better
+                 
+                 Testing to determine if any further adjustments are required
+                 */
+                
+                if (env_time_table[gus_patch[gus_ptr + 41]] < env_time_table[gus_patch[gus_ptr + 42]]) {
+                    tmp_hack_rate = gus_patch[gus_ptr + 40];
+                    gus_patch[gus_ptr + 40] = gus_patch[gus_ptr + 42];
+                    gus_patch[gus_ptr + 42] = tmp_hack_rate;
+                } else {
+                    tmp_hack_rate = gus_patch[gus_ptr + 40];
+                    gus_patch[gus_ptr + 40] = gus_patch[gus_ptr + 41];
+                    gus_patch[gus_ptr + 41] = tmp_hack_rate;
+                }
+                
+            }
+#if 0
             if ((env_time_table[gus_patch[gus_ptr + 40]] < env_time_table[gus_patch[gus_ptr + 41]]) && (env_time_table[gus_patch[gus_ptr + 41]] == env_time_table[gus_patch[gus_ptr + 42]])) {
                 uint8_t tmp_hack_rate = 0;
                 tmp_hack_rate = gus_patch[gus_ptr + 41];
@@ -851,6 +871,7 @@ struct _sample * _WM_load_gus_pat(const char *filename, int fix_release) {
                 gus_patch[gus_ptr + 48] = gus_patch[gus_ptr + 46];
                 gus_patch[gus_ptr + 46] = tmp_hack_rate;
             }
+#endif
         }
         
 		for (i = 0; i < 6; i++) {
diff --git a/src/internal_midi.c b/src/internal_midi.c
index 70fe23a..adbd822 100644
--- a/src/internal_midi.c
+++ b/src/internal_midi.c
@@ -1066,7 +1066,8 @@ void _WM_do_channel_pressure(struct _mdi *mdi, struct _event_data *data) {
 
 	mdi->channel[ch].pressure = data->data.value;
 
-    do {
+    
+    while (note_data) {
         if ((note_data->noteid >> 8) == ch) {
             note_data->velocity = data->data.value & 0xff;
             _WM_AdjustNoteVolumes(mdi, ch, note_data);
@@ -1076,7 +1077,7 @@ void _WM_do_channel_pressure(struct _mdi *mdi, struct _event_data *data) {
             }
         }
         note_data = note_data->next;
-    } while (note_data);
+    }
 }
 
 void _WM_do_pitch(struct _mdi *mdi, struct _event_data *data) {
@@ -1873,8 +1874,24 @@ static int midi_setup_smpteoffset(struct _mdi *mdi, uint32_t setting) {
     return (0);
 }
 
+static void strip_text(char * text) {
+    char * ch_loc = NULL;
+    
+    ch_loc = strrchr(text, '\n');
+    while (ch_loc != NULL) {
+        *ch_loc = ' ';
+        ch_loc = strrchr(text, '\n');
+    }
+    ch_loc = strrchr(text, '\r');
+    while (ch_loc != NULL) {
+        *ch_loc = ' ';
+        ch_loc = strrchr(text, '\r');
+    }
+}
+
 static int midi_setup_text(struct _mdi *mdi, char * text) {
     MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);
+    strip_text(text);
     if ((mdi->event_count)
         && (mdi->events[mdi->event_count - 1].do_event == NULL)) {
         mdi->events[mdi->event_count - 1].do_event = *_WM_do_meta_text;
@@ -1893,6 +1910,7 @@ static int midi_setup_text(struct _mdi *mdi, char * text) {
 
 static int midi_setup_copyright(struct _mdi *mdi, char * text) {
     MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);
+    strip_text(text);
     if ((mdi->event_count)
         && (mdi->events[mdi->event_count - 1].do_event == NULL)) {
         mdi->events[mdi->event_count - 1].do_event = *_WM_do_meta_copyright;
@@ -1911,6 +1929,7 @@ static int midi_setup_copyright(struct _mdi *mdi, char * text) {
 
 static int midi_setup_trackname(struct _mdi *mdi, char * text) {
     MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);
+    strip_text(text);
     if ((mdi->event_count)
         && (mdi->events[mdi->event_count - 1].do_event == NULL)) {
         mdi->events[mdi->event_count - 1].do_event = *_WM_do_meta_trackname;
@@ -1929,6 +1948,7 @@ static int midi_setup_trackname(struct _mdi *mdi, char * text) {
 
 static int midi_setup_instrumentname(struct _mdi *mdi, char * text) {
     MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);
+    strip_text(text);
     if ((mdi->event_count)
         && (mdi->events[mdi->event_count - 1].do_event == NULL)) {
         mdi->events[mdi->event_count - 1].do_event = *_WM_do_meta_instrumentname;
@@ -1947,6 +1967,7 @@ static int midi_setup_instrumentname(struct _mdi *mdi, char * text) {
 
 static int midi_setup_lyric(struct _mdi *mdi, char * text) {
     MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);
+    strip_text(text);
     if ((mdi->event_count)
         && (mdi->events[mdi->event_count - 1].do_event == NULL)) {
         mdi->events[mdi->event_count - 1].do_event = *_WM_do_meta_lyric;
@@ -1965,6 +1986,7 @@ static int midi_setup_lyric(struct _mdi *mdi, char * text) {
 
 static int midi_setup_marker(struct _mdi *mdi, char * text) {
     MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);
+    strip_text(text);
     if ((mdi->event_count)
         && (mdi->events[mdi->event_count - 1].do_event == NULL)) {
         mdi->events[mdi->event_count - 1].do_event = *_WM_do_meta_marker;
@@ -1983,6 +2005,7 @@ static int midi_setup_marker(struct _mdi *mdi, char * text) {
 
 static int midi_setup_cuepoint(struct _mdi *mdi, char * text) {
     MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);
+    strip_text(text);
     if ((mdi->event_count)
         && (mdi->events[mdi->event_count - 1].do_event == NULL)) {
         mdi->events[mdi->event_count - 1].do_event = *_WM_do_meta_cuepoint;
diff --git a/src/wildmidi.c b/src/wildmidi.c
index fe496d7..e863108 100644
--- a/src/wildmidi.c
+++ b/src/wildmidi.c
@@ -1371,9 +1371,12 @@ int main(int argc, char **argv) {
 		modes[2] = (mixer_options & WM_MO_ENHANCED_RESAMPLING)? 'e' : ' ';
 		modes[3] = '\0';
 		
-        printf(" [Approx %2um %2us Total]\r\n",
+        printf("\r\n[Approx %2um %2us Total]\r\n",
                 apr_mins, apr_secs);
         fprintf(stderr, "\r");
+        
+        memset(lyrics,' ',MAX_LYRIC_CHAR);
+        memset(display_lyrics,' ',MAX_DISPLAY_LYRICS);
 
 		while (1) {
 			count_diff = wm_info->approx_total_samples
@@ -1506,9 +1509,10 @@ int main(int argc, char **argv) {
 				pro_mins = wm_info->current_sample / (rate * 60);
 				pro_secs = (wm_info->current_sample % (rate * 60)) / rate;
                 fprintf(stderr,
-                        "%s [%s] [%3i] [%2um %2us Processed] [%2u%%] %c  \r",
+                        "%s [%s] [%3i] [%2um %2us Processed] [%2u%%] P  \r",
                         display_lyrics, modes, master_volume, pro_mins,
-                        pro_secs, perc_play, spinner[spinpoint++ % 4]);				msleep(5);
+                        pro_secs, perc_play);
+                msleep(5);
 				continue;
 			}
 
@@ -1531,8 +1535,6 @@ int main(int argc, char **argv) {
                 memcpy(&lyrics[MAX_DISPLAY_LYRICS], lyric, strlen(lyric));
                 last_lyric_length = strlen(lyric);
             } else {
-                memcpy(lyrics, &lyrics[1], MAX_LYRIC_CHAR - 1);
-                lyrics[MAX_LYRIC_CHAR - 1] = ' ';
                 if (last_lyric_length != 0) last_lyric_length--;
             }
             

