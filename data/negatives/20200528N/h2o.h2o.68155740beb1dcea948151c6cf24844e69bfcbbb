commit 68155740beb1dcea948151c6cf24844e69bfcbbb
Author: Kazuho Oku <kazuhooku@gmail.com>
Date:   Tue May 29 14:41:39 2018 +0900

    extract https://github.com/h2o/neverbleed @ 1e9b518 () at deps/neverbleed

diff --git a/deps/neverbleed/neverbleed.c b/deps/neverbleed/neverbleed.c
index 42356a62..b6972bb2 100644
--- a/deps/neverbleed/neverbleed.c
+++ b/deps/neverbleed/neverbleed.c
@@ -368,13 +368,25 @@ static void get_privsep_data(const RSA *rsa, struct st_neverbleed_rsa_exdata_t *
     *thdata = get_thread_data((*exdata)->nb);
 }
 
+static const size_t default_reserved_size = 8192;
+
+struct key_slots {
+    size_t size;
+    size_t reserved_size;
+    /* bit array slots:
+     *   1-bit slot available
+     *   0-bit slot unavailable
+     */
+    uint8_t *bita_avail;
+};
+
 static struct {
     struct {
         pthread_mutex_t lock;
-        size_t size;
         RSA **keys;
-        size_t ecdsa_size;
+        struct key_slots rsa_slots;
         EC_KEY **ecdsa_keys;
+        struct key_slots ecdsa_slots;
     } keys;
     neverbleed_t *nb;
 } daemon_vars = {{PTHREAD_MUTEX_INITIALIZER}};
@@ -385,20 +397,89 @@ static RSA *daemon_get_rsa(size_t key_index)
 
     pthread_mutex_lock(&daemon_vars.keys.lock);
     rsa = daemon_vars.keys.keys[key_index];
+    if (rsa)
+        RSA_up_ref(rsa);
     pthread_mutex_unlock(&daemon_vars.keys.lock);
 
     return rsa;
 }
 
-static size_t daemon_set_rsa(RSA *rsa)
+/*
+ *  Returns an available slot in bit array B
+ *  or if not found, returns SIZE_MAX
+ */
+static size_t bita_ffirst(const uint8_t *b, const size_t tot, size_t bits)
 {
-    size_t index;
+    if (bits >= tot)
+        return SIZE_MAX;
+
+    uint64_t w = *((uint64_t *) b);
+    /* __builtin_ffsll returns one plus the index of the least significant 1-bit, or zero if not found */
+    uint32_t r = __builtin_ffsll(w);
+    if (r)
+        return bits + r - 1; /* adjust result */
+
+    return bita_ffirst(&b[8], tot, bits + 64);
+}
+
+/*
+ * bit operation helpers for the bit-array in key_slots
+ */
+#define BITMASK(b) (1 << ((b) % CHAR_BIT))
+#define BITBYTE(b) ((b) / CHAR_BIT)
+#define BITSET(a, b) ((a)[BITBYTE(b)] |= BITMASK(b))
+#define BITUNSET(a, b) ((a)[BITBYTE(b)] &= ~BITMASK(b))
+#define BITBYTES(nb) ((nb + CHAR_BIT - 1) / CHAR_BIT)
+#define BITCHECK(a, b) ((a)[BITBYTE(b)] & BITMASK(b))
+
+static void adjust_slots_reserved_size(int type, struct key_slots *slots)
+{
+#define ROUND2WORD(n) (n + 64 - 1 - (n + 64 - 1) % 64)
+    if (!slots->reserved_size || (slots->size >= slots->reserved_size)) {
+        size_t size = slots->reserved_size ? ROUND2WORD((size_t)(slots->reserved_size * 0.50) + slots->reserved_size)
+                : default_reserved_size;
+#undef ROUND2WORD
+
+        switch (type) {
+        case NEVERBLEED_TYPE_RSA:
+            if ((daemon_vars.keys.keys = realloc(daemon_vars.keys.keys, sizeof(*daemon_vars.keys.keys) * size)) == NULL)
+                dief("no memory");
+            break;
+        case NEVERBLEED_TYPE_ECDSA:
+            if ((daemon_vars.keys.ecdsa_keys = realloc(daemon_vars.keys.ecdsa_keys, sizeof(*daemon_vars.keys.ecdsa_keys) * size)) == NULL)
+                dief("no memory");
+            break;
+        default:
+            dief("invalid type adjusting reserved");
+        }
+
+        uint8_t *b;
+        if ((b = realloc(slots->bita_avail, BITBYTES(size))) == NULL)
+            dief("no memory");
+
+        /* set all bits to 1 making all slots available */
+        memset(&b[BITBYTES(slots->reserved_size)], 0xff, BITBYTES(size - slots->reserved_size));
 
+        slots->bita_avail = b;
+        slots->reserved_size = size;
+    }
+}
+
+static size_t daemon_set_rsa(RSA *rsa)
+{
     pthread_mutex_lock(&daemon_vars.keys.lock);
-    if ((daemon_vars.keys.keys = realloc(daemon_vars.keys.keys, sizeof(*daemon_vars.keys.keys) * (daemon_vars.keys.size + 1))) ==
-        NULL)
-        dief("no memory");
-    index = daemon_vars.keys.size++;
+
+    adjust_slots_reserved_size(NEVERBLEED_TYPE_RSA, &daemon_vars.keys.rsa_slots);
+
+    size_t index = bita_ffirst(daemon_vars.keys.rsa_slots.bita_avail, daemon_vars.keys.rsa_slots.reserved_size, 0);
+
+    if (index == SIZE_MAX)
+        dief("no available slot for key");
+
+    /* set slot as unavailable */
+    BITUNSET(daemon_vars.keys.rsa_slots.bita_avail, index);
+
+    daemon_vars.keys.rsa_slots.size++;
     daemon_vars.keys.keys[index] = rsa;
     RSA_up_ref(rsa);
     pthread_mutex_unlock(&daemon_vars.keys.lock);
@@ -460,6 +541,7 @@ static int priv_encdec_stub(const char *name,
     }
     ret = func((int)flen, from, to, rsa, (int)padding);
     expbuf_dispose(buf);
+    RSA_free(rsa);
 
     expbuf_push_num(buf, ret);
     expbuf_push_bytes(buf, to, ret > 0 ? ret : 0);
@@ -540,6 +622,7 @@ static int sign_stub(struct expbuf_t *buf)
     }
     ret = RSA_sign((int)type, m, (unsigned)m_len, sigret, &siglen, rsa);
     expbuf_dispose(buf);
+    RSA_free(rsa);
 
     expbuf_push_num(buf, ret);
     expbuf_push_bytes(buf, sigret, ret == 1 ? siglen : 0);
@@ -628,6 +711,8 @@ static EC_KEY *daemon_get_ecdsa(size_t key_index)
 
     pthread_mutex_lock(&daemon_vars.keys.lock);
     ec_key = daemon_vars.keys.ecdsa_keys[key_index];
+    if (ec_key)
+        EC_KEY_up_ref(ec_key);
     pthread_mutex_unlock(&daemon_vars.keys.lock);
 
     return ec_key;
@@ -635,13 +720,19 @@ static EC_KEY *daemon_get_ecdsa(size_t key_index)
 
 static size_t daemon_set_ecdsa(EC_KEY *ec_key)
 {
-    size_t index;
-
     pthread_mutex_lock(&daemon_vars.keys.lock);
-    if ((daemon_vars.keys.ecdsa_keys = realloc(daemon_vars.keys.ecdsa_keys,
-                                               sizeof(*daemon_vars.keys.ecdsa_keys) * (daemon_vars.keys.ecdsa_size + 1))) == NULL)
-        dief("no memory");
-    index = daemon_vars.keys.ecdsa_size++;
+
+    adjust_slots_reserved_size(NEVERBLEED_TYPE_ECDSA, &daemon_vars.keys.ecdsa_slots);
+
+    size_t index = bita_ffirst(daemon_vars.keys.ecdsa_slots.bita_avail, daemon_vars.keys.ecdsa_slots.reserved_size, 0);
+
+    if (index == SIZE_MAX)
+        dief("no available slot for key");
+
+    /* set slot as unavailable */
+    BITUNSET(daemon_vars.keys.ecdsa_slots.bita_avail, index);
+
+    daemon_vars.keys.ecdsa_slots.size++;
     daemon_vars.keys.ecdsa_keys[index] = ec_key;
     EC_KEY_up_ref(ec_key);
     pthread_mutex_unlock(&daemon_vars.keys.lock);
@@ -672,6 +763,8 @@ static int ecdsa_sign_stub(struct expbuf_t *buf)
     ret = ECDSA_sign((int)type, m, (unsigned)m_len, sigret, &siglen, ec_key);
     expbuf_dispose(buf);
 
+    EC_KEY_free(ec_key);
+
     expbuf_push_num(buf, ret);
     expbuf_push_bytes(buf, sigret, ret == 1 ? siglen : 0);
 
@@ -779,6 +872,69 @@ static EVP_PKEY *ecdsa_create_pkey(neverbleed_t *nb, size_t key_index, int curve
     return pkey;
 }
 
+static void priv_ecdsa_finish(EC_KEY *key)
+{
+    struct st_neverbleed_rsa_exdata_t *exdata;
+    struct st_neverbleed_thread_data_t *thdata;
+
+    ecdsa_get_privsep_data(key, &exdata, &thdata);
+
+    struct expbuf_t buf = {NULL};
+    size_t ret;
+
+    expbuf_push_str(&buf, "del_ecdsa_key");
+    expbuf_push_num(&buf, exdata->key_index);
+    if (expbuf_write(&buf, thdata->fd) != 0)
+        dief(errno != 0 ? "write error" : "connection closed by daemon");
+    expbuf_dispose(&buf);
+
+    if (expbuf_read(&buf, thdata->fd) != 0)
+        dief(errno != 0 ? "read error" : "connection closed by daemon");
+    if (expbuf_shift_num(&buf, &ret) != 0) {
+        errno = 0;
+        dief("failed to parse response");
+    }
+    expbuf_dispose(&buf);
+}
+
+static int del_ecdsa_key_stub(struct expbuf_t *buf)
+{
+    size_t key_index;
+    int ret = 0;
+
+    if (expbuf_shift_num(buf, &key_index) != 0) {
+        errno = 0;
+        warnf("%s: failed to parse request", __FUNCTION__);
+        return -1;
+    }
+
+    if (!daemon_vars.keys.ecdsa_keys || key_index >= daemon_vars.keys.ecdsa_slots.reserved_size) {
+        errno = 0;
+        warnf("%s: invalid key index %zu", __FUNCTION__, key_index);
+        goto respond;
+    }
+
+    if (BITCHECK(daemon_vars.keys.ecdsa_slots.bita_avail, key_index)) {
+        warnf("%s: index not in use %zu", __FUNCTION__, key_index);
+        goto respond;
+    }
+
+    pthread_mutex_lock(&daemon_vars.keys.lock);
+    /* set slot as available */
+    BITSET(daemon_vars.keys.ecdsa_slots.bita_avail, key_index);
+    daemon_vars.keys.ecdsa_slots.size--;
+    EC_KEY_free(daemon_vars.keys.ecdsa_keys[key_index]);
+    daemon_vars.keys.ecdsa_keys[key_index] = NULL;
+    pthread_mutex_unlock(&daemon_vars.keys.lock);
+
+    ret = 1;
+
+respond:
+    expbuf_dispose(buf);
+    expbuf_push_num(buf, ret);
+    return 0;
+}
+
 #endif
 
 int neverbleed_load_private_key_file(neverbleed_t *nb, SSL_CTX *ctx, const char *fn, char *errbuf)
@@ -786,7 +942,7 @@ int neverbleed_load_private_key_file(neverbleed_t *nb, SSL_CTX *ctx, const char
     struct st_neverbleed_thread_data_t *thdata = get_thread_data(nb);
     struct expbuf_t buf = {NULL};
     int ret = 1;
-    size_t key_index, type;
+    size_t index, type;
     EVP_PKEY *pkey;
 
     expbuf_push_str(&buf, "load_key");
@@ -797,7 +953,7 @@ int neverbleed_load_private_key_file(neverbleed_t *nb, SSL_CTX *ctx, const char
 
     if (expbuf_read(&buf, thdata->fd) != 0)
         dief(errno != 0 ? "read error" : "connection closed by daemon");
-    if (expbuf_shift_num(&buf, &type) != 0 || expbuf_shift_num(&buf, &key_index) != 0) {
+    if (expbuf_shift_num(&buf, &type) != 0 || expbuf_shift_num(&buf, &index) != 0) {
         errno = 0;
         dief("failed to parse response");
     }
@@ -810,7 +966,7 @@ int neverbleed_load_private_key_file(neverbleed_t *nb, SSL_CTX *ctx, const char
             errno = 0;
             dief("failed to parse response");
         }
-        pkey = create_pkey(nb, key_index, estr, nstr);
+        pkey = create_pkey(nb, index, estr, nstr);
         break;
     }
 #if OPENSSL_1_1_API
@@ -822,7 +978,7 @@ int neverbleed_load_private_key_file(neverbleed_t *nb, SSL_CTX *ctx, const char
             errno = 0;
             dief("failed to parse response");
         }
-        pkey = ecdsa_create_pkey(nb, key_index, curve_name, ec_pubkeystr);
+        pkey = ecdsa_create_pkey(nb, index, curve_name, ec_pubkeystr);
         break;
     }
 #endif
@@ -1052,6 +1208,72 @@ Redo:
     _exit(0);
 }
 
+static int priv_rsa_finish(RSA *rsa)
+{
+    struct st_neverbleed_rsa_exdata_t *exdata;
+    struct st_neverbleed_thread_data_t *thdata;
+
+    get_privsep_data(rsa, &exdata, &thdata);
+
+    struct expbuf_t buf = {NULL};
+    size_t ret;
+
+    expbuf_push_str(&buf, "del_rsa_key");
+    expbuf_push_num(&buf, exdata->key_index);
+    if (expbuf_write(&buf, thdata->fd) != 0)
+        dief(errno != 0 ? "write error" : "connection closed by daemon");
+    expbuf_dispose(&buf);
+
+    if (expbuf_read(&buf, thdata->fd) != 0)
+        dief(errno != 0 ? "read error" : "connection closed by daemon");
+    if (expbuf_shift_num(&buf, &ret) != 0) {
+        errno = 0;
+        dief("failed to parse response");
+    }
+    expbuf_dispose(&buf);
+
+    return (int)ret;
+}
+
+static int del_rsa_key_stub(struct expbuf_t *buf)
+{
+    size_t key_index;
+
+    int ret = 0;
+
+    if (expbuf_shift_num(buf, &key_index) != 0) {
+        errno = 0;
+        warnf("%s: failed to parse request", __FUNCTION__);
+        return -1;
+    }
+
+    if (!daemon_vars.keys.keys || key_index >= daemon_vars.keys.rsa_slots.reserved_size) {
+        errno = 0;
+        warnf("%s: invalid key index %zu", __FUNCTION__, key_index);
+        goto respond;
+    }
+
+    if (BITCHECK(daemon_vars.keys.rsa_slots.bita_avail, key_index)) {
+        warnf("%s: index not in use %zu", __FUNCTION__, key_index);
+        goto respond;
+    }
+
+    pthread_mutex_lock(&daemon_vars.keys.lock);
+    /* set slot as available */
+    BITSET(daemon_vars.keys.rsa_slots.bita_avail, key_index);
+    daemon_vars.keys.rsa_slots.size--;
+    RSA_free(daemon_vars.keys.keys[key_index]);
+    daemon_vars.keys.keys[key_index] = NULL;
+    pthread_mutex_unlock(&daemon_vars.keys.lock);
+
+    ret = 1;
+
+respond:
+    expbuf_dispose(buf);
+    expbuf_push_num(buf, ret);
+    return 0;
+}
+
 static void *daemon_conn_thread(void *_sock_fd)
 {
     int sock_fd = (int)((char *)_sock_fd - (char *)NULL);
@@ -1093,10 +1315,16 @@ static void *daemon_conn_thread(void *_sock_fd)
         } else if (strcmp(cmd, "ecdsa_sign") == 0) {
             if (ecdsa_sign_stub(&buf) != 0)
                 break;
+        } else if (strcmp(cmd, "del_ecdsa_key") == 0) {
+            if (del_ecdsa_key_stub(&buf) != 0)
+                break;
 #endif
         } else if (strcmp(cmd, "load_key") == 0) {
             if (load_key_stub(&buf) != 0)
                 break;
+        } else if (strcmp(cmd, "del_rsa_key") == 0) {
+            if (del_rsa_key_stub(&buf) != 0)
+                break;
         } else if (strcmp(cmd, "setuidgid") == 0) {
             if (setuidgid_stub(&buf) != 0)
                 break;
@@ -1158,7 +1386,7 @@ static RSA_METHOD static_rsa_method = {
     NULL,                 /* rsa_mod_exp */
     NULL,                 /* bn_mod_exp */
     NULL,                 /* init */
-    NULL,                 /* finish */
+    priv_rsa_finish,      /* finish */
     RSA_FLAG_SIGN_VER,    /* flags */
     NULL,                 /* app data */
     sign_proxy,           /* rsa_sign */
@@ -1186,6 +1414,8 @@ int neverbleed_init(neverbleed_t *nb, char *errbuf)
     RSA_meth_set_pub_dec(rsa_method, RSA_meth_get_pub_dec(default_method));
     RSA_meth_set_verify(rsa_method, RSA_meth_get_verify(default_method));
 
+    RSA_meth_set_finish(rsa_method, priv_rsa_finish);
+
     /* setup EC_KEY_METHOD for ECDSA */
     ecdsa_default_method = EC_KEY_get_default_method();
     ecdsa_method = EC_KEY_METHOD_new(ecdsa_default_method);
@@ -1194,6 +1424,7 @@ int neverbleed_init(neverbleed_t *nb, char *errbuf)
     EC_KEY_METHOD_set_compute_key(ecdsa_method, NULL);
     /* it seems sign_sig and sign_setup is not used in TLS ECDSA. */
     EC_KEY_METHOD_set_sign(ecdsa_method, ecdsa_sign_proxy, NULL, NULL);
+    EC_KEY_METHOD_set_init(ecdsa_method, NULL, priv_ecdsa_finish, NULL, NULL, NULL, NULL);
 #else
     const RSA_METHOD *default_method = RSA_PKCS1_SSLeay();
     RSA_METHOD *rsa_method = &static_rsa_method;

