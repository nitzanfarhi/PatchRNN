commit d5194decd0a6f792b2789eebd4ddf022a248f655
Author: Thomas Renninger <trenn@suse.de>
Date:   Wed Jul 29 11:26:20 2009 +0200

    [CPUFREQ] Fix a kobject reference bug related to managed CPUs
    
    The first offline/online cycle is successful, the second not.
    Doing:
    echo 0 >cpu1/online
    echo 1 >cpu1/online
    echo 0 >cpu1/online
    
    The last command will trigger:
    Jul 22 14:39:50 linux kernel: [  593.210125] ------------[ cut here ]------------
    Jul 22 14:39:50 linux kernel: [  593.210139] WARNING: at lib/kref.c:43 kref_get+0x23/0x2b()
    Jul 22 14:39:50 linux kernel: [  593.210144] Hardware name: To Be Filled By O.E.M.
    Jul 22 14:39:50 linux kernel: [  593.210148] Modules linked in: powernow_k8
    Jul 22 14:39:50 linux kernel: [  593.210158] Pid: 378, comm: kondemand/2 Tainted: G        W  2.6.31-rc2 #38
    Jul 22 14:39:50 linux kernel: [  593.210163] Call Trace:
    Jul 22 14:39:50 linux kernel: [  593.210171]  [<ffffffff812008e8>] ? kref_get+0x23/0x2b
    Jul 22 14:39:50 linux kernel: [  593.210181]  [<ffffffff81041926>] warn_slowpath_common+0x77/0xa4
    Jul 22 14:39:50 linux kernel: [  593.210190]  [<ffffffff81041962>] warn_slowpath_null+0xf/0x11
    Jul 22 14:39:50 linux kernel: [  593.210198]  [<ffffffff812008e8>] kref_get+0x23/0x2b
    Jul 22 14:39:50 linux kernel: [  593.210206]  [<ffffffff811ffa19>] kobject_get+0x1a/0x22
    Jul 22 14:39:50 linux kernel: [  593.210214]  [<ffffffff813e815d>] cpufreq_cpu_get+0x8a/0xcb
    Jul 22 14:39:50 linux kernel: [  593.210222]  [<ffffffff813e87d1>] __cpufreq_driver_getavg+0x1d/0x67
    Jul 22 14:39:50 linux kernel: [  593.210231]  [<ffffffff813ea18f>] do_dbs_timer+0x158/0x27f
    Jul 22 14:39:50 linux kernel: [  593.210240]  [<ffffffff810529ea>] worker_thread+0x200/0x313
    ...
    
    The output continues on every do_dbs_timer ondemand freq checking poll.
    This regression was introduced by git commit:
    3f4a782b5ce2698b1870b5a7b573cd721d4fce33
    
    The policy is released when the cpufreq device is removed in:
    __cpufreq_remove_dev():
            /* if this isn't the CPU which is the parent of the kobj, we
             * only need to unlink, put and exit
             */
    
    Not creating the symlink is not sever at all.
    As long as:
    sysfs_remove_link(&sys_dev->kobj, "cpufreq");
    handles it gracefully that the symlink did not exist.
    Possibly no error should be returned at all, because ondemand
    governor would still provide the same functionality.
    Userspace in userspace gov case might be confused if the link
    is missing.
    
    Resolves http://bugzilla.kernel.org/show_bug.cgi?id=13903
    
    CC: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    CC: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index 120d236c0ffb..bd74a0b12176 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -858,6 +858,8 @@ static int cpufreq_add_dev(struct sys_device *sys_dev)
 
 		/* Check for existing affected CPUs.
 		 * They may not be aware of it due to CPU Hotplug.
+		 * cpufreq_cpu_put is called when the device is removed
+		 * in __cpufreq_remove_dev()
 		 */
 		managed_policy = cpufreq_cpu_get(j);
 		if (unlikely(managed_policy)) {
@@ -884,7 +886,7 @@ static int cpufreq_add_dev(struct sys_device *sys_dev)
 			ret = sysfs_create_link(&sys_dev->kobj,
 						&managed_policy->kobj,
 						"cpufreq");
-			if (!ret)
+			if (ret)
 				cpufreq_cpu_put(managed_policy);
 			/*
 			 * Success. We only needed to be added to the mask.

