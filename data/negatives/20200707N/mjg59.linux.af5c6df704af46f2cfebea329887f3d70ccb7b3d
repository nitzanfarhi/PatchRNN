commit af5c6df704af46f2cfebea329887f3d70ccb7b3d
Author: Mugunthan V N <mugunthanvnm@ti.com>
Date:   Thu May 2 01:52:11 2013 +0000

    drivers: net: cpsw: irq not disabled in cpsw isr in particular sequence
    
    In CPSW NAPI, after processing all interrupts IRQ is enabled and then book
    keeping irq_enabled is updated. In random cases when a packet is transmitted
    or received between processing packets and IRQ enabled, then just after
    enabled IRQ and before irq_enabled is updated, ISR is called so IRQs are
    not disabled as irq_enabled is still false and CPU gets locked in CPSW ISR.
    
    By changing the sequence as update the irq_enabled and then enable IRQ
    fixes the issue. This issue is not captured always as it is a timing issue
    whether Tx or Rx IRQ is invoked between packet processing and enable IRQ.
    
    Cc: Sebastian Siewior <bigeasy@linutronix.de>
    Signed-off-by: Mugunthan V N <mugunthanvnm@ti.com>
    Acked-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c
index 59c43918883e..21a5b291b4b3 100644
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@ -555,8 +555,8 @@ static int cpsw_poll(struct napi_struct *napi, int budget)
 		cpdma_ctlr_eoi(priv->dma, CPDMA_EOI_RX);
 		prim_cpsw = cpsw_get_slave_priv(priv, 0);
 		if (prim_cpsw->irq_enabled == false) {
-			cpsw_enable_irq(priv);
 			prim_cpsw->irq_enabled = true;
+			cpsw_enable_irq(priv);
 		}
 	}
 

