commit 6c61f2a69ef49581c5dd3fb80834d4b2fba4bdc8
Author: Ken <knielson@adaptivecomputing.com>
Date:   Thu Feb 27 14:27:40 2014 -0700

    Added unit tests for log_remove_old. TRQ-1305

diff --git a/src/lib/Liblog/test/pbs_log/scaffolding.c b/src/lib/Liblog/test/pbs_log/scaffolding.c
index cac521ab6..fc5878c60 100644
--- a/src/lib/Liblog/test/pbs_log/scaffolding.c
+++ b/src/lib/Liblog/test/pbs_log/scaffolding.c
@@ -1,6 +1,20 @@
 #include "license_pbs.h" /* See here for the software license */
 #include <stdlib.h>
 #include <stdio.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <time.h>
+#include <string.h>
+
+bool dot = false;
+bool double_dot = false;
+bool first_time = true;
+bool dir_is_null = false;
+bool time_expired = false;
+bool stat_fail = false;
+
 
 extern "C"
 {
@@ -9,4 +23,86 @@ char *pbse_to_txt(int err)
   fprintf(stderr, "The call to pbse_to_txt needs to be mocked!!\n");
   exit(1);
   }
+
+DIR *opendir(const char *name)
+  {
+  DIR *pointer;
+
+  if (dir_is_null == true)
+    return(NULL);
+
+  pointer = (DIR *)malloc(10);
+  return(pointer);
+  }
+
+int closedir(DIR *dirp)
+  {
+  if (dirp != NULL)
+    free(dirp);
+  return(0);
+  }
+
+struct dirent *readdir(DIR *dirp)
+  {
+  struct dirent *d_entry;
+
+  if (dir_is_null == true)
+    return(NULL);
+
+  d_entry = (struct dirent *)malloc(sizeof(struct dirent));
+
+  if ((dot == true) && (first_time == true))
+    {
+    first_time = false;
+    d_entry->d_name[0] = '.';
+    d_entry->d_name[2] = '\0';
+    return(d_entry);
+    }
+
+  if ((double_dot == true) && (first_time == true))
+    {
+    first_time = false;
+    d_entry->d_name[0] = '.';
+    d_entry->d_name[1] = '.';
+    d_entry->d_name[2] = '\0';
+
+    return(d_entry);
+    }
+
+  if (first_time == true)
+    {
+    first_time = false;
+    strcpy(d_entry->d_name, "somefile");
+    return(d_entry);
+    }
+
+  return(NULL);
+  }
+
 }
+
+int stat(const char *path, struct stat *buf) throw()
+  {
+
+  if (stat_fail == true)
+    return(-1);
+
+  if (time_expired == false)
+    {
+    buf->st_mtime  = time((time_t *)NULL);
+
+    return(0);
+    }
+
+  buf->st_mtime = 10;
+ 
+
+  return (0);
+  }
+
+int remove(const char *path) throw()
+  {
+  return(0);
+  }
+
+
diff --git a/src/lib/Liblog/test/pbs_log/test_pbs_log.c b/src/lib/Liblog/test/pbs_log/test_pbs_log.c
index befbb3499..4edb92caa 100644
--- a/src/lib/Liblog/test/pbs_log/test_pbs_log.c
+++ b/src/lib/Liblog/test/pbs_log/test_pbs_log.c
@@ -3,12 +3,85 @@
 #include "test_pbs_log.h"
 #include <stdlib.h>
 #include <stdio.h>
+#include <sys/types.h>
+#include <dirent.h>
 
+#include <string>
 
 #include "pbs_error.h"
 
+extern bool dot;
+extern bool double_dot;
+extern bool first_time;
+extern bool dir_is_null;
+extern bool time_expired;
+extern bool stat_fail;
+
 START_TEST(test_one)
   {
+  int rc;
+  char *null_path = NULL;
+  char path[20];
+
+  /* Validate input */
+  /* NULL path */
+  rc = log_remove_old(null_path, 100);
+  fail_unless(rc == -1);
+
+  /* Expire time of 0 */
+  strcpy(path, "some_dir");
+  rc = log_remove_old(path, 0);
+  fail_unless(rc == 0);
+
+  dir_is_null = true;
+  rc = log_remove_old(path, 10);
+  fail_unless(rc == -1);
+
+  /* get just a . for the directory entry */
+  stat_fail = false;
+  dir_is_null = false;
+  dot = true;
+  double_dot = false;
+  first_time = true;
+
+  rc = log_remove_old(path, 100);
+  fail_unless(rc == 0);
+
+  /* get just a .. for the directory entry */
+  dot = false;
+  double_dot = true;
+  first_time = true;
+
+  rc = log_remove_old(path, 100);
+  fail_unless(rc == 0);
+
+  /* Time not yet expired */
+  dot = false;
+  double_dot = false;
+  first_time = true;
+  time_expired = false;
+
+  rc = log_remove_old(path, 100);
+  fail_unless(rc == 0);
+
+   /* Time expired */
+  dot = false;
+  double_dot = false;
+  first_time = true;
+  time_expired = true;
+
+  rc = log_remove_old(path, 100);
+  fail_unless(rc == 0);
+
+   /* stat failure  */
+  stat_fail = true;
+  dot = false;
+  double_dot = false;
+  first_time = true;
+  time_expired = true;
+
+  rc = log_remove_old(path, 100);
+  fail_unless(rc == 0);
 
 
   }

