commit 976c06bcccc50573997609fa7ec842479bd96ffb
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 5 09:16:59 2012 -0800

    cgroup: use cgroup_lock_live_group(parent) in cgroup_create()
    
    This patch makes cgroup_create() fail if @parent is marked removed.
    This is to prepare for further updates to cgroup_rmdir() path.
    
    Note that this change isn't strictly necessary.  cgroup can only be
    created via mkdir and the removed marking and dentry removal happen
    without releasing cgroup_mutex, so cgroup_create() can never race with
    cgroup_rmdir().  Even after the scheduled updates to cgroup_rmdir(),
    cgroup_mkdir() and cgroup_rmdir() are synchronized by i_mutex
    rendering the added liveliness check unnecessary.
    
    Do it anyway such that locking is contained inside cgroup proper and
    we don't get nasty surprises if we ever grow another caller of
    cgroup_create().
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Michal Hocko <mhocko@suse.cz>
    Reviewed-by: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Acked-by: Li Zefan <lizefan@huawei.com>

diff --git a/kernel/cgroup.c b/kernel/cgroup.c
index c194f9e4fc7b..f22e3cd1978b 100644
--- a/kernel/cgroup.c
+++ b/kernel/cgroup.c
@@ -3927,6 +3927,18 @@ static long cgroup_create(struct cgroup *parent, struct dentry *dentry,
 	if (!cgrp)
 		return -ENOMEM;
 
+	/*
+	 * Only live parents can have children.  Note that the liveliness
+	 * check isn't strictly necessary because cgroup_mkdir() and
+	 * cgroup_rmdir() are fully synchronized by i_mutex; however, do it
+	 * anyway so that locking is contained inside cgroup proper and we
+	 * don't get nasty surprises if we ever grow another caller.
+	 */
+	if (!cgroup_lock_live_group(parent)) {
+		err = -ENODEV;
+		goto err_free;
+	}
+
 	/* Grab a reference on the superblock so the hierarchy doesn't
 	 * get deleted on unmount if there are child cgroups.  This
 	 * can be done outside cgroup_mutex, since the sb can't
@@ -3934,8 +3946,6 @@ static long cgroup_create(struct cgroup *parent, struct dentry *dentry,
 	 * fs */
 	atomic_inc(&sb->s_active);
 
-	mutex_lock(&cgroup_mutex);
-
 	init_cgroup_housekeeping(cgrp);
 
 	cgrp->parent = parent;
@@ -4006,7 +4016,7 @@ static long cgroup_create(struct cgroup *parent, struct dentry *dentry,
 
 	/* Release the reference count that we took on the superblock */
 	deactivate_super(sb);
-
+err_free:
 	kfree(cgrp);
 	return err;
 }

