commit 08890d355ec4f31196e24049462a82710b5fe967
Author: Anton Khirnov <anton@khirnov.net>
Date:   Tue Aug 30 15:23:51 2011 +0200

    ffmpeg: : rescue poor abused recording_time global.
    
    Keep a per-OutputFile instance of it, thus making -t work with multiple
    output files.

diff --git a/ffmpeg.c b/ffmpeg.c
index 9e270e8e9d..072bbb59db 100644
--- a/ffmpeg.c
+++ b/ffmpeg.c
@@ -290,6 +290,7 @@ typedef struct OutputStream {
 
    int sws_flags;
    AVDictionary *opts;
+   int is_past_recording_time;
 } OutputStream;
 
 typedef struct InputStream {
@@ -306,7 +307,6 @@ typedef struct InputStream {
     double ts_scale;
     int is_start;            /* is 1 at the start and after a discontinuity */
     int showed_multi_packet_warning;
-    int is_past_recording_time;
     AVDictionary *opts;
 } InputStream;
 
@@ -329,6 +329,7 @@ typedef struct OutputFile {
     AVFormatContext *ctx;
     AVDictionary *opts;
     int ost_index;       /* index of the first stream in output_streams */
+    int64_t recording_time; /* desired length of the resulting file in microseconds */
 } OutputFile;
 
 static InputStream *input_streams = NULL;
@@ -1641,19 +1642,19 @@ static int output_packet(InputStream *ist, int ist_index,
            encode packets and output them */
         if (start_time == 0 || ist->pts >= start_time)
             for(i=0;i<nb_ostreams;i++) {
+                OutputFile *of = &output_files[ost_table[i].file_index];
                 int frame_size;
 
                 ost = &ost_table[i];
+                if (ost->source_index != ist_index)
+                    continue;
 
-                /* finish if recording time exhausted */
-                if (recording_time != INT64_MAX &&
-                        av_compare_ts(ist->pts, AV_TIME_BASE_Q, recording_time + start_time, (AVRational){1, 1000000})
-                    >= 0) {
-                    ist->is_past_recording_time = 1;
+                if (of->recording_time != INT64_MAX &&
+                    av_compare_ts(ist->pts, AV_TIME_BASE_Q, of->recording_time + start_time,
+                                  (AVRational){1, 1000000}) >= 0) {
+                    ost->is_past_recording_time = 1;
                     continue;
                 }
-                if (ost->source_index != ist_index)
-                    continue;
 
 #if CONFIG_AVFILTER
                 frame_available = ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO ||
@@ -2374,7 +2375,7 @@ static int transcode(OutputFile *output_files,
             ost = &output_streams[i];
             os = output_files[ost->file_index].ctx;
             ist = &input_streams[ost->source_index];
-            if(ist->is_past_recording_time || no_packet[ist->file_index])
+            if(ost->is_past_recording_time || no_packet[ist->file_index])
                 continue;
                 opts = ost->st->pts.val * av_q2d(ost->st->time_base);
             ipts = ist->pts;
@@ -3722,6 +3723,7 @@ static int opt_output_file(const char *opt, const char *filename)
     output_files = grow_array(output_files, sizeof(*output_files), &nb_output_files, nb_output_files + 1);
     output_files[nb_output_files - 1].ctx       = oc;
     output_files[nb_output_files - 1].ost_index = nb_output_streams - oc->nb_streams;
+    output_files[nb_output_files - 1].recording_time = recording_time;
     av_dict_copy(&output_files[nb_output_files - 1].opts, format_opts, 0);
 
     /* check filename in case of an image number is expected */
@@ -3851,6 +3853,7 @@ static int opt_output_file(const char *opt, const char *filename)
     audio_channels    = 0;
     audio_sample_fmt  = AV_SAMPLE_FMT_NONE;
     chapters_input_file = INT_MAX;
+    recording_time = INT64_MAX;
 
     av_freep(&meta_data_maps);
     nb_meta_data_maps = 0;

