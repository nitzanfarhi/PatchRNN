commit c4fc298ab44011a7f7a391bf00350acf481eeaeb
Author: Erik Hugne <erik.hugne@ericsson.com>
Date:   Tue Oct 16 16:47:06 2012 +0200

    tipc: return POLLOUT for sockets in an unconnected state
    
    If an implied connect is attempted on a nonblocking STREAM/SEQPACKET
    socket during link congestion, the connect message will be discarded
    and sendmsg will return EAGAIN. This is normal behavior, and the
    application is expected to poll the socket until POLLOUT is set,
    after which the connection attempt can be retried.
    However, the POLLOUT flag is never set for unconnected sockets and
    poll() always returns a zero mask. The application is then left without
    a trigger for when it can make another attempt at sending the message.
    
    The solution is to check if we're polling on an unconnected socket
    and set the POLLOUT flag if the TIPC port owned by this socket
    is not congested. The TIPC ports waiting on a specific link will be
    marked as 'not congested' when the link congestion have abated.
    
    Signed-off-by: Erik Hugne <erik.hugne@ericsson.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/net/tipc/socket.c b/net/tipc/socket.c
index b5fc8ed1d1fe..59adc76905e0 100644
--- a/net/tipc/socket.c
+++ b/net/tipc/socket.c
@@ -412,7 +412,7 @@ static int get_name(struct socket *sock, struct sockaddr *uaddr,
  * socket state		flags set
  * ------------		---------
  * unconnected		no read flags
- *			no write flags
+ *			POLLOUT if port is not congested
  *
  * connecting		POLLIN/POLLRDNORM if ACK/NACK in rx queue
  *			no write flags
@@ -442,6 +442,10 @@ static unsigned int poll(struct file *file, struct socket *sock,
 	sock_poll_wait(file, sk_sleep(sk), wait);
 
 	switch ((int)sock->state) {
+	case SS_UNCONNECTED:
+		if (!tipc_sk_port(sk)->congested)
+			mask |= POLLOUT;
+		break;
 	case SS_READY:
 	case SS_CONNECTED:
 		if (!tipc_sk_port(sk)->congested)

