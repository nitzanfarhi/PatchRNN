commit 4d69de5fd5a24a88746eeb130ca830ba813e7210
Author: Andrew Cagney <cagney@gnu.org>
Date:   Fri Jan 12 13:39:47 2018 -0500

    crypto: suspend the MD in complete_*_state_transition() when STF_SUSPEND
    
    This replaces set_suspended() with suspend_md() where the latter
    transfers ownership of MD from *MDP to .st_suspended_md as a single
    operation.  The old macro - set_suspended() - would start the transfer
    but not finish it.
    
    The only quirk here is with crypto continue functions which need to
    submit more crypto - the MD needs to be re-suspended (by calling
    suspend_md()).
    
    The crypto offload code no longer uses its MD parameter.

diff --git a/programs/pluto/ikev1.c b/programs/pluto/ikev1.c
index c2c4aaa78..67514102f 100644
--- a/programs/pluto/ikev1.c
+++ b/programs/pluto/ikev1.c
@@ -1710,8 +1710,9 @@ void process_v1_packet(struct msg_digest **mdp)
 				(unsigned)hportof(&md->sender));
 		});
 
-		/* if there was a previous packet, let it go, and go with most
-		 * recent one.
+		/*
+		 * if there was a previous packet, let it go, and go
+		 * with most recent one.
 		 */
 		if (st->st_suspended_md != NULL) {
 			DBG(DBG_CONTROL,
@@ -1719,9 +1720,7 @@ void process_v1_packet(struct msg_digest **mdp)
 				    st->st_suspended_md));
 			release_any_md(&st->st_suspended_md);
 		}
-
-		set_suspended(st, md);
-		*mdp = NULL;
+		suspend_md(st, mdp);
 		return;
 	}
 
@@ -2285,7 +2284,18 @@ void complete_v1_state_transition(struct msg_digest **mdp, stf_status result)
 	switch (result) {
 	case STF_SUSPEND:
 		set_cur_state(md->st);	/* might have changed */
-		*mdp = NULL;	/* take md away from parent */
+		if (*mdp != NULL) {
+			/*
+			 * If this transition was triggered by an
+			 * incoming packet, save it.
+			 *
+			 * XXX: some initiator code creates a fake MD
+			 * (there isn't a real one); save that as
+			 * well.
+			 */
+			suspend_md(md->st, mdp);
+			passert(*mdp == NULL); /* ownership transfered */
+		}
 		return;
 	case STF_IGNORE:
 		return;
diff --git a/programs/pluto/ikev1_aggr.c b/programs/pluto/ikev1_aggr.c
index ce6536b66..002f079bd 100644
--- a/programs/pluto/ikev1_aggr.c
+++ b/programs/pluto/ikev1_aggr.c
@@ -142,9 +142,14 @@ static void aggr_inI1_outR1_continue1(struct state *st, struct msg_digest *md,
 	struct pluto_crypto_req_cont *dh = new_pcrc(aggr_inI1_outR1_continue2,
 						    "aggr outR1 DH",
 						    st, md);
-
 	start_dh_secretiv(dh, st, ORIGINAL_RESPONDER,
 			  st->st_oakley.ta_dh);
+	/*
+	 * XXX: Since more crypto has been requsted, MD needs to be re
+	 * suspended.  If the original crypto request did everything
+	 * this wouldn't be needed.
+	 */
+	suspend_md(st, &md);
 }
 
 /* STATE_AGGR_R0:
diff --git a/programs/pluto/ikev1_quick.c b/programs/pluto/ikev1_quick.c
index 7bb4a278d..ed06be053 100644
--- a/programs/pluto/ikev1_quick.c
+++ b/programs/pluto/ikev1_quick.c
@@ -1455,10 +1455,6 @@ static stf_status quick_inI1_outR1_authtail(struct verify_oppo_bundle *b)
 
 		passert(st->st_connection != NULL);
 
-		/*
-		 * ??? this code did NOT have a set_suspended(st, md).
-		 * Now that is perfomed by new_pcrc.  Correct?
-		 */
 		if (st->st_pfs_group != NULL) {
 			request_ke_and_nonce("quick_outI1 KE", st, md,
 					     st->st_pfs_group,
@@ -1495,6 +1491,12 @@ static void quick_inI1_outR1_cryptocontinue1(struct state *st, struct msg_digest
 				 st, md);
 		start_dh_secret(dh, st, ORIGINAL_RESPONDER,
 				st->st_pfs_group);
+		/*
+		 * XXX: Since more crypto has been requsted, MD needs
+		 * to be re suspended.  If the original crypto request
+		 * did everything this wouldn't be needed.
+		 */
+		suspend_md(st, &md);
 	} else {
 		/* but if PFS is off, we don't do a second DH, so just
 		 * call the continuation with NULL struct pluto_crypto_req *
diff --git a/programs/pluto/ikev1_xauth.c b/programs/pluto/ikev1_xauth.c
index f12dff6b1..4e08906e9 100644
--- a/programs/pluto/ikev1_xauth.c
+++ b/programs/pluto/ikev1_xauth.c
@@ -1416,8 +1416,7 @@ stf_status xauth_inR0(struct state *st, struct msg_digest *md)
 		}
 	} else {
 		xauth_launch_authent(st, &name, &password);
-		set_suspended(st, md);
-		return STF_IGNORE;
+		return STF_SUSPEND;
 	}
 }
 
diff --git a/programs/pluto/ikev2.c b/programs/pluto/ikev2.c
index 9a03b88af..0950cfd12 100644
--- a/programs/pluto/ikev2.c
+++ b/programs/pluto/ikev2.c
@@ -2303,8 +2303,19 @@ void complete_v2_state_transition(struct msg_digest **mdp,
 
 	switch (result) {
 	case STF_SUSPEND:
+		if (*mdp != NULL) {
+			/*
+			 * If this transition was triggered by an
+			 * incoming packet, save it.
+			 *
+			 * XXX: some initiator code creates a fake MD
+			 * (there isn't a real one); save that as
+			 * well.
+			 */
+			suspend_md(md->st, mdp);
+			passert(*mdp == NULL); /* ownership transfered */
+		}
 		log_stf_suspend(md->st, result);
-		*mdp = NULL;    /* take md away from parent */
 		return;
 
 	case STF_IGNORE:
diff --git a/programs/pluto/ikev2_ipseckey.c b/programs/pluto/ikev2_ipseckey.c
index 3ff5bd240..b80278b61 100644
--- a/programs/pluto/ikev2_ipseckey.c
+++ b/programs/pluto/ikev2_ipseckey.c
@@ -930,7 +930,6 @@ stf_status idi_ipseckey_fetch(struct msg_digest *md)
 		/* all success */
 		st->ipseckey_dnsr = dnsr_idi;
 		st->ipseckey_fwd_dnsr = dnsr_a;
-		set_suspended(st, md);
 		ret = STF_SUSPEND;
 	}
 
diff --git a/programs/pluto/ikev2_parent.c b/programs/pluto/ikev2_parent.c
index 22547fe01..66bbe36b9 100644
--- a/programs/pluto/ikev2_parent.c
+++ b/programs/pluto/ikev2_parent.c
@@ -336,8 +336,6 @@ static void ikev2_crypto_continue(struct state *st, struct msg_digest *md,
 			unpack_KE_from_helper(st, r, &st->st_gi);
 
 		e = add_st_send_list(st, pst);
-		if (e == STF_SUSPEND)
-			set_suspended(st, md);
 		break;
 
 	case STATE_V2_REKEY_IKE_I0:
@@ -3532,7 +3530,6 @@ static void ikev2_pam_continue(struct state *st, const char *name UNUSED,
 static stf_status ikev2_start_pam_authorize(struct msg_digest *md)
 {
 	struct state *st = md->st;
-	set_suspended(md->st, md);
 
 	char thatid[IDTOA_BUF];
 	idtoa(&st->st_connection->spd.that.id, thatid, sizeof(thatid));
diff --git a/programs/pluto/pluto_crypt.c b/programs/pluto/pluto_crypt.c
index 7e59078e5..cd1d1870e 100644
--- a/programs/pluto/pluto_crypt.c
+++ b/programs/pluto/pluto_crypt.c
@@ -140,7 +140,7 @@ struct pluto_crypto_req_cont *new_pcrc(
 	crypto_req_cont_func fn,
 	const char *name,
 	struct state *st,
-	struct msg_digest *md)
+	struct msg_digest *md UNUSED)
 {
 	struct pluto_crypto_req_cont *r = alloc_thing(struct pluto_crypto_req_cont, name);
 
@@ -149,15 +149,6 @@ struct pluto_crypto_req_cont *new_pcrc(
 	r->pcrc_cancelled = false;
 	r->pcrc_name = name;
 	r->pcrc_backlog = list_entry(&backlog_info, r);
-
-	/*
-	 * There is almost always a non-NULL md.
-	 * Exception: main_inI2_outR2_tail initiates DH calculation
-	 * in parallel with normal processing that needs the md exclusively.
-	 */
-	if (md != NULL) {
-		set_suspended(st, md);
-	}
 	return r;
 }
 
diff --git a/programs/pluto/state.h b/programs/pluto/state.h
index 4ec525328..f3ef33ec5 100644
--- a/programs/pluto/state.h
+++ b/programs/pluto/state.h
@@ -242,12 +242,23 @@ struct hidden_variables {
 };
 
 struct msg_digest *unsuspend_md(struct state *st);
-#define set_suspended(st, md) { \
-	passert((st)->st_suspended_md == NULL); \
-	(st)->st_suspended_md = (md); \
-	(st)->st_suspended_md_func = __FUNCTION__; \
-	(st)->st_suspended_md_line = __LINE__; \
-    }
+
+/*
+ * On entry to this macro, when crypto has been off loaded then
+ * st_offloaded_task is non-NULL.  However, with XAUTH immediate,
+ * there's nothing to check.
+ */
+#define suspend_md(ST, MDP) {						\
+		DBG(DBG_CONTROL,					\
+		    DBG_log("suspending state #%lu and saving MD",	\
+			    (ST)->st_serialno));			\
+		passert((ST)->st_suspended_md == NULL);			\
+		(ST)->st_suspended_md = *(MDP);				\
+		*(MDP) = NULL; /* take ownership */			\
+		(ST)->st_suspended_md_func = __FUNCTION__;		\
+		(ST)->st_suspended_md_line = __LINE__;			\
+		passert(state_is_busy(ST));				\
+	}
 
 /* IKEv2, this struct will be mapped into a ikev2_ts1 payload  */
 struct traffic_selector {

