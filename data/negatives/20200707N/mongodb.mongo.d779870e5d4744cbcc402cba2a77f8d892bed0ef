commit d779870e5d4744cbcc402cba2a77f8d892bed0ef
Author: Dianna Hohensee <dianna.hohensee@10gen.com>
Date:   Mon Jan 9 13:23:16 2017 -0500

    SERVER-25673 Remove redundant ChunkManager access in MigrationManager

diff --git a/src/mongo/db/s/active_migrations_registry_test.cpp b/src/mongo/db/s/active_migrations_registry_test.cpp
index c5eb63f71a..7907434e0d 100644
--- a/src/mongo/db/s/active_migrations_registry_test.cpp
+++ b/src/mongo/db/s/active_migrations_registry_test.cpp
@@ -65,19 +65,17 @@ protected:
 };
 
 MoveChunkRequest createMoveChunkRequest(const NamespaceString& nss) {
-    const ChunkVersion collectionVersion(2, 3, OID::gen());
     const ChunkVersion chunkVersion(1, 2, OID::gen());
 
     BSONObjBuilder builder;
     MoveChunkRequest::appendAsCommand(
         &builder,
         nss,
-        collectionVersion,
+        chunkVersion,
         assertGet(ConnectionString::parse("TestConfigRS/CS1:12345,CS2:12345,CS3:12345")),
         ShardId("shard0001"),
         ShardId("shard0002"),
         ChunkRange(BSON("Key" << -100), BSON("Key" << 100)),
-        chunkVersion,
         1024,
         MigrationSecondaryThrottleOptions::create(MigrationSecondaryThrottleOptions::kOff),
         true);
diff --git a/src/mongo/db/s/balancer/migration_manager.cpp b/src/mongo/db/s/balancer/migration_manager.cpp
index 6bccabf732..02c9fece76 100644
--- a/src/mongo/db/s/balancer/migration_manager.cpp
+++ b/src/mongo/db/s/balancer/migration_manager.cpp
@@ -454,29 +454,6 @@ shared_ptr<Notification<RemoteCommandResponse>> MigrationManager::_schedule(
         }
     }
 
-
-    // Sanity checks that the chunk being migrated is actually valid. These will be repeated at the
-    // shard as well, but doing them here saves an extra network call, which might otherwise fail.
-    auto statusWithScopedChunkManager = ScopedChunkManager::refreshAndGet(txn, nss);
-    if (!statusWithScopedChunkManager.isOK()) {
-        return std::make_shared<Notification<RemoteCommandResponse>>(
-            std::move(statusWithScopedChunkManager.getStatus()));
-    }
-
-    ChunkManager* const chunkManager = statusWithScopedChunkManager.getValue().cm();
-
-    auto chunk = chunkManager->findIntersectingChunkWithSimpleCollation(txn, migrateInfo.minKey);
-    invariant(chunk);
-
-    // If the chunk is not found exactly as requested, the caller must have stale data
-    if (SimpleBSONObjComparator::kInstance.evaluate(chunk->getMin() != migrateInfo.minKey) ||
-        SimpleBSONObjComparator::kInstance.evaluate(chunk->getMax() != migrateInfo.maxKey)) {
-        return std::make_shared<Notification<RemoteCommandResponse>>(Status(
-            ErrorCodes::IncompatibleShardingMetadata,
-            stream() << "Chunk " << ChunkRange(migrateInfo.minKey, migrateInfo.maxKey).toString()
-                     << " does not exist."));
-    }
-
     const auto fromShardStatus = Grid::get(txn)->shardRegistry()->getShard(txn, migrateInfo.from);
     if (!fromShardStatus.isOK()) {
         return std::make_shared<Notification<RemoteCommandResponse>>(
@@ -495,12 +472,11 @@ shared_ptr<Notification<RemoteCommandResponse>> MigrationManager::_schedule(
     MoveChunkRequest::appendAsCommand(
         &builder,
         nss,
-        chunkManager->getVersion(),
+        migrateInfo.version,
         Grid::get(txn)->shardRegistry()->getConfigServerConnectionString(),
         migrateInfo.from,
         migrateInfo.to,
         ChunkRange(migrateInfo.minKey, migrateInfo.maxKey),
-        chunk->getLastmod(),
         maxChunkSizeBytes,
         secondaryThrottle,
         waitForDelete);
diff --git a/src/mongo/db/s/migration_chunk_cloner_source_legacy_test.cpp b/src/mongo/db/s/migration_chunk_cloner_source_legacy_test.cpp
index fa83a3bd69..94188337f6 100644
--- a/src/mongo/db/s/migration_chunk_cloner_source_legacy_test.cpp
+++ b/src/mongo/db/s/migration_chunk_cloner_source_legacy_test.cpp
@@ -142,7 +142,6 @@ protected:
             kDonorConnStr.getSetName(),
             kRecipientConnStr.getSetName(),
             chunkRange,
-            ChunkVersion(1, 0, OID::gen()),
             1024 * 1024,
             MigrationSecondaryThrottleOptions::create(MigrationSecondaryThrottleOptions::kDefault),
             false);
diff --git a/src/mongo/db/s/migration_source_manager.cpp b/src/mongo/db/s/migration_source_manager.cpp
index 3cca060618..d9cc1c3626 100644
--- a/src/mongo/db/s/migration_source_manager.cpp
+++ b/src/mongo/db/s/migration_source_manager.cpp
@@ -91,15 +91,8 @@ MigrationSourceManager::MigrationSourceManager(OperationContext* txn,
             "Destination shard cannot be the same as source",
             _args.getFromShardId() != _args.getToShardId());
 
-    const auto& oss = OperationShardingState::get(txn);
-    uassert(ErrorCodes::InvalidOptions, "collection version is missing", oss.hasShardVersion());
-
-    // Even though the moveChunk command transmits a value in the operation's shardVersion field,
-    // this value does not actually contain the shard version, but the global collection version.
-    const ChunkVersion expectedCollectionVersion = oss.getShardVersion(getNss());
-
     log() << "Starting chunk migration " << redact(_args.toString())
-          << " with expected collection version " << expectedCollectionVersion;
+          << " with expected collection version epoch" << _args.getVersionEpoch();
 
     // Now that the collection is locked, snapshot the metadata and fetch the latest versions
     ShardingState* const shardingState = ShardingState::get(txn);
@@ -134,13 +127,13 @@ MigrationSourceManager::MigrationSourceManager(OperationContext* txn,
     const ChunkVersion collectionVersion = _collectionMetadata->getCollVersion();
 
     uassert(ErrorCodes::StaleEpoch,
-            str::stream() << "cannot move chunk " << _args.toString()
+            str::stream() << "cannot move chunk " << redact(_args.toString())
                           << " because collection may have been dropped. "
                           << "current epoch: "
                           << collectionVersion.epoch()
                           << ", cmd epoch: "
-                          << expectedCollectionVersion.epoch(),
-            expectedCollectionVersion.epoch() == collectionVersion.epoch());
+                          << _args.getVersionEpoch(),
+            _args.getVersionEpoch() == collectionVersion.epoch());
 
     // With nonzero shard version, we must have a coll version >= our shard version
     invariant(collectionVersion >= shardVersion);
@@ -155,9 +148,10 @@ MigrationSourceManager::MigrationSourceManager(OperationContext* txn,
     Status chunkValidateStatus = _collectionMetadata->checkChunkIsValid(chunkToMove);
     if (!chunkValidateStatus.isOK()) {
         uasserted(chunkValidateStatus.code(),
-                  str::stream() << "Unable to move chunk with arguments '" << _args.toString()
+                  str::stream() << "Unable to move chunk with arguments '"
+                                << redact(_args.toString())
                                 << "' due to error "
-                                << chunkValidateStatus.reason());
+                                << redact(chunkValidateStatus.reason()));
     }
 }
 
diff --git a/src/mongo/s/move_chunk_request.cpp b/src/mongo/s/move_chunk_request.cpp
index 67174f7124..40e342a7d7 100644
--- a/src/mongo/s/move_chunk_request.cpp
+++ b/src/mongo/s/move_chunk_request.cpp
@@ -107,13 +107,11 @@ StatusWith<MoveChunkRequest> MoveChunkRequest::createFromCommand(NamespaceString
     }
 
     {
-        auto statusWithChunkVersion =
-            ChunkVersion::parseFromBSONWithFieldForCommands(obj, kChunkVersion);
-        if (statusWithChunkVersion.isOK()) {
-            request._chunkVersion = std::move(statusWithChunkVersion.getValue());
-        } else if (statusWithChunkVersion != ErrorCodes::NoSuchKey) {
-            return statusWithChunkVersion.getStatus();
-        }
+        BSONElement epochElem;
+        Status status = bsonExtractTypedField(obj, kEpoch, BSONType::jstOID, &epochElem);
+        if (!status.isOK())
+            return status;
+        request._versionEpoch = epochElem.OID();
     }
 
     {
@@ -149,12 +147,11 @@ StatusWith<MoveChunkRequest> MoveChunkRequest::createFromCommand(NamespaceString
 
 void MoveChunkRequest::appendAsCommand(BSONObjBuilder* builder,
                                        const NamespaceString& nss,
-                                       ChunkVersion collectionVersion,
+                                       ChunkVersion chunkVersion,
                                        const ConnectionString& configServerConnectionString,
                                        const ShardId& fromShardId,
                                        const ShardId& toShardId,
                                        const ChunkRange& range,
-                                       ChunkVersion chunkVersion,
                                        int64_t maxChunkSizeBytes,
                                        const MigrationSecondaryThrottleOptions& secondaryThrottle,
                                        bool waitForDelete) {
@@ -162,13 +159,12 @@ void MoveChunkRequest::appendAsCommand(BSONObjBuilder* builder,
     invariant(nss.isValid());
 
     builder->append(kMoveChunk, nss.ns());
-    collectionVersion.appendForCommands(builder);
-    builder->append(kEpoch, collectionVersion.epoch());
+    chunkVersion.appendForCommands(builder);  // 3.4 shard compatibility
+    builder->append(kEpoch, chunkVersion.epoch());
     builder->append(kConfigServerConnectionString, configServerConnectionString.toString());
     builder->append(kFromShardId, fromShardId.toString());
     builder->append(kToShardId, toShardId.toString());
     range.append(builder);
-    chunkVersion.appendWithFieldForCommands(builder, kChunkVersion);
     builder->append(kMaxChunkSizeBytes, static_cast<long long>(maxChunkSizeBytes));
     secondaryThrottle.append(builder);
     builder->append(kWaitForDelete, waitForDelete);
diff --git a/src/mongo/s/move_chunk_request.h b/src/mongo/s/move_chunk_request.h
index 3851acb703..196f09b848 100644
--- a/src/mongo/s/move_chunk_request.h
+++ b/src/mongo/s/move_chunk_request.h
@@ -59,17 +59,17 @@ public:
      * without closing the builder. The builder must be empty, but callers are free to append more
      * fields once the command has been constructed.
      *
-     * The collectionVersion argument is appended, but not parsed by the createFromCommand method
-     * above, because it is processed by the mongod generic command parsing code.
+     * The chunkVersion argument is appended as 'chunkVersion', but not parsed by the
+     * createFromCommand method above, because it is needed for backwards compatibility with 3.4.
+     * However, the 'epoch' field created from the chunkVersion argument is parsed.
      */
     static void appendAsCommand(BSONObjBuilder* builder,
                                 const NamespaceString& nss,
-                                ChunkVersion collectionVersion,
+                                ChunkVersion chunkVersion,
                                 const ConnectionString& configServerConnectionString,
                                 const ShardId& fromShardId,
                                 const ShardId& toShardId,
                                 const ChunkRange& range,
-                                ChunkVersion chunkVersion,
                                 int64_t maxChunkSizeBytes,
                                 const MigrationSecondaryThrottleOptions& secondaryThrottle,
                                 bool waitForDelete);
@@ -98,12 +98,8 @@ public:
         return _range.getMax();
     }
 
-    bool hasChunkVersion() const {
-        return _chunkVersion.is_initialized();
-    }
-
-    ChunkVersion getChunkVersion() const {
-        return *_chunkVersion;
+    const OID getVersionEpoch() const {
+        return _versionEpoch;
     }
 
     int64_t getMaxChunkSizeBytes() const {
@@ -152,10 +148,8 @@ private:
     // Range of the chunk being moved
     ChunkRange _range;
 
-    // Version of the chunk being moved. Optional for backwards compatibility with 3.2 mongos
-    // instances.
-    // TODO: Make non-optional after 3.4 is released.
-    boost::optional<ChunkVersion> _chunkVersion;
+    // Assures the collection has not been dropped and recreated since the moveChunk was sent.
+    OID _versionEpoch;
 
     // This value is used by the migration source to determine the data size threshold above which a
     // chunk would be considered jumbo and migrations will not proceed.
diff --git a/src/mongo/s/move_chunk_request_test.cpp b/src/mongo/s/move_chunk_request_test.cpp
index 9605308283..8385cd93ac 100644
--- a/src/mongo/s/move_chunk_request_test.cpp
+++ b/src/mongo/s/move_chunk_request_test.cpp
@@ -39,145 +39,107 @@ using unittest::assertGet;
 
 namespace {
 
-const ConnectionString kTestConnectionString =
+const ConnectionString kTestConfigServerConnectionString =
     assertGet(ConnectionString::parse("TestConfigRS/CS1:12345,CS2:12345,CS3:12345"));
+const NamespaceString kNs("TestDB.TestColl");
+const BSONObj kMin = BSON("Key" << -100);
+const BSONObj kMax = BSON("Key" << 100);
+const ShardId kFromShard("shard0001");
+const ShardId kToShard("shard0002");
+const int kMaxChunkSizeBytes = 1024;
+const bool kWaitForDelete = true;
 
 TEST(MoveChunkRequest, Roundtrip) {
-    const ChunkVersion collectionVersion(3, 1, OID::gen());
-    const ChunkVersion chunkVersion(2, 3, OID::gen());
+    const ChunkVersion chunkVersion(3, 1, OID::gen());
 
     BSONObjBuilder builder;
     MoveChunkRequest::appendAsCommand(
         &builder,
-        NamespaceString("TestDB", "TestColl"),
-        collectionVersion,
-        kTestConnectionString,
-        ShardId("shard0001"),
-        ShardId("shard0002"),
-        ChunkRange(BSON("Key" << -100), BSON("Key" << 100)),
+        kNs,
         chunkVersion,
-        1024,
+        kTestConfigServerConnectionString,
+        kFromShard,
+        kToShard,
+        ChunkRange(kMin, kMax),
+        kMaxChunkSizeBytes,
         MigrationSecondaryThrottleOptions::create(MigrationSecondaryThrottleOptions::kOff),
-        true);
+        kWaitForDelete);
 
     BSONObj cmdObj = builder.obj();
 
+    ASSERT_TRUE(cmdObj.hasField("shardVersion"));
+
     auto request = assertGet(
         MoveChunkRequest::createFromCommand(NamespaceString(cmdObj["moveChunk"].String()), cmdObj));
-    ASSERT_EQ("TestDB.TestColl", request.getNss().ns());
-    ASSERT_EQ(kTestConnectionString.toString(), request.getConfigServerCS().toString());
-    ASSERT_EQ(ShardId("shard0001"), request.getFromShardId());
-    ASSERT_EQ(ShardId("shard0002"), request.getToShardId());
-    ASSERT_BSONOBJ_EQ(BSON("Key" << -100), request.getMinKey());
-    ASSERT_BSONOBJ_EQ(BSON("Key" << 100), request.getMaxKey());
-    ASSERT(request.hasChunkVersion());
-    ASSERT_EQ(chunkVersion, request.getChunkVersion());
-    ASSERT_EQ(1024, request.getMaxChunkSizeBytes());
+    ASSERT_EQ(kNs, request.getNss().ns());
+    ASSERT_EQ(kTestConfigServerConnectionString.toString(), request.getConfigServerCS().toString());
+    ASSERT_EQ(kFromShard, request.getFromShardId());
+    ASSERT_EQ(kToShard, request.getToShardId());
+    ASSERT_BSONOBJ_EQ(kMin, request.getMinKey());
+    ASSERT_BSONOBJ_EQ(kMax, request.getMaxKey());
+    ASSERT_EQ(chunkVersion.epoch(), request.getVersionEpoch());
+    ASSERT_EQ(kMaxChunkSizeBytes, request.getMaxChunkSizeBytes());
     ASSERT_EQ(MigrationSecondaryThrottleOptions::kOff,
               request.getSecondaryThrottle().getSecondaryThrottle());
-    ASSERT_EQ(true, request.getWaitForDelete());
-}
-
-TEST(MoveChunkRequest, BackwardsCompatibilityNoChunkVersionAndDefaults) {
-    const ChunkVersion collectionVersion(3, 1, OID::gen());
-
-    auto request =
-        assertGet(MoveChunkRequest::createFromCommand(NamespaceString("TestDB", "TestColl"),
-                                                      BSON("moveChunk"
-                                                           << "TestDB.TestColl"
-                                                           << "shardVersion"
-                                                           << collectionVersion.toBSON()
-                                                           << "configdb"
-                                                           << kTestConnectionString.toString()
-                                                           << "fromShard"
-                                                           << "shard0001"
-                                                           << "toShard"
-                                                           << "shard0002"
-                                                           << "min"
-                                                           << BSON("Key" << -1)
-                                                           << "max"
-                                                           << BSON("Key" << 1)
-                                                           // Omit the chunkVersion
-                                                           << "maxChunkSizeBytes"
-                                                           << 1024)));
-
-    ASSERT_EQ("TestDB.TestColl", request.getNss().ns());
-    ASSERT_EQ(kTestConnectionString.toString(), request.getConfigServerCS().toString());
-    ASSERT_EQ(ShardId("shard0001"), request.getFromShardId());
-    ASSERT_EQ(ShardId("shard0002"), request.getToShardId());
-    ASSERT_BSONOBJ_EQ(BSON("Key" << -1), request.getMinKey());
-    ASSERT_BSONOBJ_EQ(BSON("Key" << 1), request.getMaxKey());
-    ASSERT(!request.hasChunkVersion());
-    ASSERT_EQ(MigrationSecondaryThrottleOptions::kDefault,
-              request.getSecondaryThrottle().getSecondaryThrottle());
-    ASSERT_EQ(false, request.getWaitForDelete());
+    ASSERT_EQ(kWaitForDelete, request.getWaitForDelete());
 }
 
 TEST(MoveChunkRequest, EqualityOperatorSameValue) {
-    const ChunkVersion collectionVersion(3, 1, OID::gen());
-    const ChunkVersion chunkVersion(2, 3, OID::gen());
+    const ChunkVersion chunkVersion(3, 1, OID::gen());
 
     BSONObjBuilder builder;
     MoveChunkRequest::appendAsCommand(
         &builder,
-        NamespaceString("TestDB", "TestColl"),
-        collectionVersion,
-        assertGet(ConnectionString::parse("TestConfigRS/CS1:12345,CS2:12345,CS3:12345")),
-        ShardId("shard0001"),
-        ShardId("shard0002"),
-        ChunkRange(BSON("Key" << -100), BSON("Key" << 100)),
+        kNs,
         chunkVersion,
-        1024,
+        kTestConfigServerConnectionString,
+        kFromShard,
+        kToShard,
+        ChunkRange(kMin, kMax),
+        kMaxChunkSizeBytes,
         MigrationSecondaryThrottleOptions::create(MigrationSecondaryThrottleOptions::kOff),
-        true);
+        kWaitForDelete);
 
     BSONObj obj = builder.obj();
 
-    auto value1 =
-        assertGet(MoveChunkRequest::createFromCommand(NamespaceString("TestDB", "TestColl"), obj));
-    auto value2 =
-        assertGet(MoveChunkRequest::createFromCommand(NamespaceString("TestDB", "TestColl"), obj));
+    auto value1 = assertGet(MoveChunkRequest::createFromCommand(kNs, obj));
+    auto value2 = assertGet(MoveChunkRequest::createFromCommand(kNs, obj));
 
     ASSERT(value1 == value2);
     ASSERT_FALSE(value1 != value2);
 }
 
 TEST(MoveChunkRequest, EqualityOperatorDifferentValues) {
-    const ChunkVersion collectionVersion(3, 1, OID::gen());
-    const ChunkVersion chunkVersion(2, 3, OID::gen());
+    const ChunkVersion chunkVersion(3, 1, OID::gen());
 
     BSONObjBuilder builder1;
     MoveChunkRequest::appendAsCommand(
         &builder1,
-        NamespaceString("TestDB", "TestColl"),
-        collectionVersion,
-        assertGet(ConnectionString::parse("TestConfigRS/CS1:12345,CS2:12345,CS3:12345")),
-        ShardId("shard0001"),
-        ShardId("shard0002"),
-        ChunkRange(BSON("Key" << -100), BSON("Key" << 100)),
+        kNs,
         chunkVersion,
-        1024,
+        kTestConfigServerConnectionString,
+        kFromShard,
+        kToShard,
+        ChunkRange(kMin, kMax),
+        kMaxChunkSizeBytes,
         MigrationSecondaryThrottleOptions::create(MigrationSecondaryThrottleOptions::kOff),
-        true);
+        kWaitForDelete);
 
-    auto value1 = assertGet(
-        MoveChunkRequest::createFromCommand(NamespaceString("TestDB", "TestColl"), builder1.obj()));
+    auto value1 = assertGet(MoveChunkRequest::createFromCommand(kNs, builder1.obj()));
 
     BSONObjBuilder builder2;
     MoveChunkRequest::appendAsCommand(
         &builder2,
-        NamespaceString("TestDB", "TestColl"),
-        collectionVersion,
-        assertGet(ConnectionString::parse("TestConfigRS/CS1:12345,CS2:12345,CS3:12345")),
-        ShardId("shard0001"),
-        ShardId("shard0002"),
-        ChunkRange(BSON("Key" << 100), BSON("Key" << 200)),  // Different key ranges
+        kNs,
         chunkVersion,
-        1024,
+        kTestConfigServerConnectionString,
+        kFromShard,
+        kToShard,
+        ChunkRange(BSON("Key" << 100), BSON("Key" << 200)),  // Different key ranges
+        kMaxChunkSizeBytes,
         MigrationSecondaryThrottleOptions::create(MigrationSecondaryThrottleOptions::kOff),
-        true);
-    auto value2 = assertGet(
-        MoveChunkRequest::createFromCommand(NamespaceString("TestDB", "TestColl"), builder2.obj()));
+        kWaitForDelete);
+    auto value2 = assertGet(MoveChunkRequest::createFromCommand(kNs, builder2.obj()));
 
     ASSERT_FALSE(value1 == value2);
     ASSERT(value1 != value2);

