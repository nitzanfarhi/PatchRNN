commit 3d287de3b828226e5a450c7fd5bf4283792dc2b0
Author: Dmitry Monakhov <dmonakhov@openvz.org>
Date:   Wed Oct 27 22:08:46 2010 -0400

    ext4: optimize orphan_list handling for ext4_setattr
    
    Surprisingly chown() on ext4 is not SMP scalable operation.
    Due to unconditional orphan_del(NULL, inode) in ext4_setattr()
    result in significant performance overhead because of global orphan
    mutex, especially in no-journal mode (where orphan_add() is noop).
    It is possible to skip explicit orphan_del if possible.
    Results of fchown() micro-benchmark in no-journal mode
    while (1) {
       iteration++;
       fchown(fd, uid, gid);
       fchown(fd, uid + 1, gid + 1)
    }
    measured: iterations per millisecond
    | nr_tasks | w/o patch | with patch |
    |        1 |       142 |        185 |
    |        4 |       109 |        642 |
    
    Signed-off-by: Dmitry Monakhov <dmonakhov@openvz.org>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 9e60d0b8fa75..3ba237b0b2aa 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -5281,6 +5281,7 @@ int ext4_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	struct inode *inode = dentry->d_inode;
 	int error, rc = 0;
+	int orphan = 0;
 	const unsigned int ia_valid = attr->ia_valid;
 
 	error = inode_change_ok(inode, attr);
@@ -5336,8 +5337,10 @@ int ext4_setattr(struct dentry *dentry, struct iattr *attr)
 			error = PTR_ERR(handle);
 			goto err_out;
 		}
-
-		error = ext4_orphan_add(handle, inode);
+		if (ext4_handle_valid(handle)) {
+			error = ext4_orphan_add(handle, inode);
+			orphan = 1;
+		}
 		EXT4_I(inode)->i_disksize = attr->ia_size;
 		rc = ext4_mark_inode_dirty(handle, inode);
 		if (!error)
@@ -5355,6 +5358,7 @@ int ext4_setattr(struct dentry *dentry, struct iattr *attr)
 					goto err_out;
 				}
 				ext4_orphan_del(handle, inode);
+				orphan = 0;
 				ext4_journal_stop(handle);
 				goto err_out;
 			}
@@ -5377,7 +5381,7 @@ int ext4_setattr(struct dentry *dentry, struct iattr *attr)
 	 * If the call to ext4_truncate failed to get a transaction handle at
 	 * all, we need to clean up the in-core orphan list manually.
 	 */
-	if (inode->i_nlink)
+	if (orphan && inode->i_nlink)
 		ext4_orphan_del(NULL, inode);
 
 	if (!rc && (ia_valid & ATTR_MODE))

