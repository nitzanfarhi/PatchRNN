commit 286405167e815adc4ae0132214246a350b0208bc
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Mon Dec 5 09:20:25 2011 +0800

    [SCSI] check runtime PM status in system PM
    
    The only high-level SCSI driver that currently implements runtime PM is
    sd, and sd treats runtime suspend exactly the same as the SUSPEND and
    HIBERNATE stages of system sleep, but not the same as the FREEZE stage.
    
    Therefore, when entering the SUSPEND or HIBERNATE stages of system
    sleep, we can skip the callback to the driver if the device is already
    in runtime suspend.  When entering the FREEZE stage, however, we should
    first issue a runtime resume.  The overhead of doing this is
    negligible, because a suspended drive would be spun up during the THAW
    stage of hibernation anyway.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/scsi/scsi_pm.c b/drivers/scsi/scsi_pm.c
index d329f8b12e2b..a633076e5622 100644
--- a/drivers/scsi/scsi_pm.c
+++ b/drivers/scsi/scsi_pm.c
@@ -49,8 +49,22 @@ static int scsi_bus_suspend_common(struct device *dev, pm_message_t msg)
 {
 	int err = 0;
 
-	if (scsi_is_sdev_device(dev))
+	if (scsi_is_sdev_device(dev)) {
+		/*
+		 * sd is the only high-level SCSI driver to implement runtime
+		 * PM, and sd treats runtime suspend, system suspend, and
+		 * system hibernate identically (but not system freeze).
+		 */
+		if (pm_runtime_suspended(dev)) {
+			if (msg.event == PM_EVENT_SUSPEND ||
+			    msg.event == PM_EVENT_HIBERNATE)
+				return 0;	/* already suspended */
+
+			/* wake up device so that FREEZE will succeed */
+			pm_runtime_resume(dev);
+		}
 		err = scsi_dev_type_suspend(dev, msg);
+	}
 	return err;
 }
 

