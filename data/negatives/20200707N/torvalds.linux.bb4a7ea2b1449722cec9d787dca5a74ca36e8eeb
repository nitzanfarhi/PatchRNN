commit bb4a7ea2b1449722cec9d787dca5a74ca36e8eeb
Author: Shakeel Butt <shakeelb@google.com>
Date:   Thu Jun 7 17:07:27 2018 -0700

    mm: memcontrol: drain stocks on resize limit
    
    Resizing the memcg limit for cgroup-v2 drains the stocks before
    triggering the memcg reclaim.  Do the same for cgroup-v1 to make the
    behavior consistent.
    
    Link: http://lkml.kernel.org/r/20180504205548.110696-1-shakeelb@google.com
    Signed-off-by: Shakeel Butt <shakeelb@google.com>
    Acked-by: Johannes Weiner <hannes@cmpxchg.org>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Greg Thelen <gthelen@google.com>
    Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/mm/memcontrol.c b/mm/memcontrol.c
index 847a775af225..18dcdac0b158 100644
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -2450,6 +2450,7 @@ static int mem_cgroup_resize_max(struct mem_cgroup *memcg,
 				 unsigned long max, bool memsw)
 {
 	bool enlarge = false;
+	bool drained = false;
 	int ret;
 	bool limits_invariant;
 	struct page_counter *counter = memsw ? &memcg->memsw : &memcg->memory;
@@ -2480,6 +2481,12 @@ static int mem_cgroup_resize_max(struct mem_cgroup *memcg,
 		if (!ret)
 			break;
 
+		if (!drained) {
+			drain_all_stock(memcg);
+			drained = true;
+			continue;
+		}
+
 		if (!try_to_free_mem_cgroup_pages(memcg, 1,
 					GFP_KERNEL, !memsw)) {
 			ret = -EBUSY;

