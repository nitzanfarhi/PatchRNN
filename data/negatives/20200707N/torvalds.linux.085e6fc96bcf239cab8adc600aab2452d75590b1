commit 085e6fc96bcf239cab8adc600aab2452d75590b1
Author: Colin Leroy <colin@colino.net>
Date:   Sun May 1 08:58:43 2005 -0700

    [PATCH] pmac: save master volume on sleep
    
    Ben's patch that shutdowns master switch and restores it after resume
    ("pmac: Improve sleep code of tumbler driver") isn't enough here on an
    iBook (snapper chip).
    
    The master switch is correctly saved and restored, but somehow
    tumbler_put_master_volume() gets called just after
    tumbler_set_master_volume() and sets mix->master_vol[*] to 0.  So, on
    resuming, the master switch is reenabled, but the volume is set to 0.
    
    Here's a patch that also saves and restores master_vol.
    
    Signed-off-by: Colin Leroy <colin@colino.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/sound/ppc/tumbler.c b/sound/ppc/tumbler.c
index f3e010793a6a..9332237cb6a4 100644
--- a/sound/ppc/tumbler.c
+++ b/sound/ppc/tumbler.c
@@ -99,6 +99,7 @@ typedef struct pmac_tumbler_t {
 	pmac_gpio_t hp_detect;
 	int headphone_irq;
 	int lineout_irq;
+	unsigned int save_master_vol[2];
 	unsigned int master_vol[2];
 	unsigned int save_master_switch[2];
 	unsigned int master_switch[2];
@@ -1139,6 +1140,8 @@ static void tumbler_suspend(pmac_t *chip)
 		disable_irq(mix->lineout_irq);
 	mix->save_master_switch[0] = mix->master_switch[0];
 	mix->save_master_switch[1] = mix->master_switch[1];
+	mix->save_master_vol[0] = mix->master_vol[0];
+	mix->save_master_vol[1] = mix->master_vol[1];
 	mix->master_switch[0] = mix->master_switch[1] = 0;
 	tumbler_set_master_volume(mix);
 	if (!mix->anded_reset) {
@@ -1166,6 +1169,8 @@ static void tumbler_resume(pmac_t *chip)
 	mix->acs &= ~1;
 	mix->master_switch[0] = mix->save_master_switch[0];
 	mix->master_switch[1] = mix->save_master_switch[1];
+	mix->master_vol[0] = mix->save_master_vol[0];
+	mix->master_vol[1] = mix->save_master_vol[1];
 	tumbler_reset_audio(chip);
 	if (mix->i2c.client && mix->i2c.init_client) {
 		if (mix->i2c.init_client(&mix->i2c) < 0)

