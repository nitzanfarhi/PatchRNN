commit bf5b478a0ca2c4f73f1d9619c2d0db95df402c52
Author: Ian Darwin <ian@darwinsys.com>
Date:   Fri Feb 19 14:22:42 1993 +0000

    Part of Guy Harris' Jan-93 rewrite, including:
    Add in support for multiple levels of continuation.
    
    Add in support for "beshort", "belong", "bedate", "leshort",
    "lelong", and "ledate" types.
    
    Fix the old-style ANDing - don't change it to a MASK op
    relation, because:
    
            there's already code to handle old-style ANDing and there's no
            need to use the MASK op code to implement this;
    
            the parser that used to be there assumed that there was a
            *second* number that represented a value against which
            to compare the ANDed value, and the old-style ANDing
            *didn't* have that so lines containing the old-style
            syntax "0 byte &0x80 dynamically linked" turned into
            lines containing the new-style syntax "0 byte&0x80 0
            dynamically linked", as the missing second value
            defaulted to 0.
    
    That may be where that bizarro "!074000,000000" stuff from the
    Clipper magic number stuff came, but since you can just
    *explicitly* implement that with new-style ANDing, one might as
    well just do that....
    
    Also, make old-style "not set"ting - "0 byte ^0x80 statically
    linked", meaning "this line matches if any of the bits in the
    value *aren't* set in the number from the file" - work.

diff --git a/src/apprentice.c b/src/apprentice.c
index 6171a08c..11eaff1a 100644
--- a/src/apprentice.c
+++ b/src/apprentice.c
@@ -33,7 +33,7 @@
 
 #ifndef	lint
 static char *moduleid = 
-	"@(#)$Id: apprentice.c,v 1.15 1993/02/19 14:10:50 ian Exp $";
+	"@(#)$Id: apprentice.c,v 1.16 1993/02/19 14:22:42 ian Exp $";
 #endif	/* lint */
 
 #define	EATAB {while (isascii((unsigned char) *l) && \
@@ -120,13 +120,14 @@ int *ndx, check;
 	}
 	m = &magic[*ndx];
 	m->flag = 0;
+	m->cont_level = 0;
 
-	if (*l == '>') {
+	while (*l == '>') {
 		++l;		/* step over */
-		m->flag |= CONT;
+		m->cont_level++; 
 	}
 
-	if ((m->flag & CONT) && *l == '(') {
+	if (m->cont_level != 0 && *l == '(') {
 		++l;		/* step over */
 		m->flag |= INDIR;
 	}
@@ -176,11 +177,17 @@ int *ndx, check;
 		++l;
 	EATAB;
 
-#define NBYTE	4
-#define NSHORT	5
-#define NLONG	4
-#define NSTRING 6
-#define NDATE	4
+#define NBYTE		4
+#define NSHORT		5
+#define NLONG		4
+#define NSTRING 	6
+#define NDATE		4
+#define NBESHORT	7
+#define NBELONG		6
+#define NBEDATE		6
+#define NLESHORT	7
+#define NLELONG		6
+#define NLEDATE		6
 
 	/* get type, skip it */
 	if (strncmp(l, "byte", NBYTE)==0) {
@@ -198,6 +205,24 @@ int *ndx, check;
 	} else if (strncmp(l, "date", NDATE)==0) {
 		m->type = DATE;
 		l += NDATE;
+	} else if (strncmp(l, "beshort", NBESHORT)==0) {
+		m->type = BESHORT;
+		l += NBESHORT;
+	} else if (strncmp(l, "belong", NBELONG)==0) {
+		m->type = BELONG;
+		l += NBELONG;
+	} else if (strncmp(l, "bedate", NBEDATE)==0) {
+		m->type = BEDATE;
+		l += NBEDATE;
+	} else if (strncmp(l, "leshort", NLESHORT)==0) {
+		m->type = LESHORT;
+		l += NLESHORT;
+	} else if (strncmp(l, "lelong", NLELONG)==0) {
+		m->type = LELONG;
+		l += NLELONG;
+	} else if (strncmp(l, "ledate", NLEDATE)==0) {
+		m->type = LEDATE;
+		l += NLEDATE;
 	} else {
 		magwarn("type %s invalid", l);
 		return -1;
@@ -213,14 +238,14 @@ int *ndx, check;
 	switch (*l) {
 	case '>':
 	case '<':
-	/* Old-style anding: "0 byte &0x80 dynamically linked" - not working */
+	/* Old-style anding: "0 byte &0x80 dynamically linked" */
 	case '&':
+	case '^':
 	case '=':
   		m->reln = *l;
   		++l;
 		break;
 	case '!':
-	case '^':
 		if (m->type != STRING) {
 			m->reln = *l;
 			++l;
@@ -247,23 +272,6 @@ int *ndx, check;
 	 *	magwarn("offset too big"); }
 	 */
 
-	/* 
-	 * if the relation was ``&'',
-	 * change it to a MASK op relation.
-	 */
-	EATAB;
-	if (m->reln == '&') {
-		if (*l == '>' || *l == '<' || *l == '=') {
-			m->reln = *l | MASK;
-			++l;
-		} else
-			m->reln = '=' | MASK;
-		m->mask = m->value.l;
-		EATAB;
-		if (getvalue(m, &l))
-			return -1;
-	}
-
 	/*
 	 * now get last part - the description
 	 */
@@ -315,10 +323,16 @@ char **p;
 				m->value.l = (char) strtol(*p,p,0);
 				break;
 			case SHORT:
+			case BESHORT:
+			case LESHORT:
 				m->value.l = (short) strtol(*p,p,0);
 				break;
 			case DATE:
+			case BEDATE:
+			case LEDATE:
 			case LONG:
+			case BELONG:
+			case LELONG:
 				m->value.l = (long) strtol(*p,p,0);
 				break;
 			default:

