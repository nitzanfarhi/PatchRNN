commit 13212b54d18d5235fb97fbdcba8ae453fd2a3a51
Author: Zhao Lei <zhaolei@cn.fujitsu.com>
Date:   Thu Feb 12 14:18:17 2015 +0800

    btrfs: Fix out-of-space bug
    
    Btrfs will report NO_SPACE when we create and remove files for several times,
    and we can't write to filesystem until mount it again.
    
    Steps to reproduce:
     1: Create a single-dev btrfs fs with default option
     2: Write a file into it to take up most fs space
     3: Delete above file
     4: Wait about 100s to let chunk removed
     5: goto 2
    
    Script is like following:
     #!/bin/bash
    
     # Recommend 1.2G space, too large disk will make test slow
     DEV="/dev/sda16"
     MNT="/mnt/tmp"
    
     dev_size="$(lsblk -bn -o SIZE "$DEV")" || exit 2
     file_size_m=$((dev_size * 75 / 100 / 1024 / 1024))
    
     echo "Loop write ${file_size_m}M file on $((dev_size / 1024 / 1024))M dev"
    
     for ((i = 0; i < 10; i++)); do umount "$MNT" 2>/dev/null; done
     echo "mkfs $DEV"
     mkfs.btrfs -f "$DEV" >/dev/null || exit 2
     echo "mount $DEV $MNT"
     mount "$DEV" "$MNT" || exit 2
    
     for ((loop_i = 0; loop_i < 20; loop_i++)); do
         echo
         echo "loop $loop_i"
    
         echo "dd file..."
         cmd=(dd if=/dev/zero of="$MNT"/file0 bs=1M count="$file_size_m")
         "${cmd[@]}" 2>/dev/null || {
             # NO_SPACE error triggered
             echo "dd failed: ${cmd[*]}"
             exit 1
         }
    
         echo "rm file..."
         rm -f "$MNT"/file0 || exit 2
    
         for ((i = 0; i < 10; i++)); do
             df "$MNT" | tail -1
             sleep 10
         done
     done
    
    Reason:
     It is triggered by commit: 47ab2a6c689913db23ccae38349714edf8365e0a
     which is used to remove empty block groups automatically, but the
     reason is not in that patch. Code before works well because btrfs
     don't need to create and delete chunks so many times with high
     complexity.
     Above bug is caused by many reason, any of them can trigger it.
    
    Reason1:
     When we remove some continuous chunks but leave other chunks after,
     these disk space should be used by chunk-recreating, but in current
     code, only first create will successed.
     Fixed by Forrest Liu <forrestl@synology.com> in:
     Btrfs: fix find_free_dev_extent() malfunction in case device tree has hole
    
    Reason2:
     contains_pending_extent() return wrong value in calculation.
     Fixed by Forrest Liu <forrestl@synology.com> in:
     Btrfs: fix find_free_dev_extent() malfunction in case device tree has hole
    
    Reason3:
     btrfs_check_data_free_space() try to commit transaction and retry
     allocating chunk when the first allocating failed, but space_info->full
     is set in first allocating, and prevent second allocating in retry.
     Fixed in this patch by clear space_info->full in commit transaction.
    
     Tested for severial times by above script.
    
    Changelog v3->v4:
     use light weight int instead of atomic_t to record have_remove_bgs in
     transaction, suggested by:
     Josef Bacik <jbacik@fb.com>
    
    Changelog v2->v3:
     v2 fixed the bug by adding more commit-transaction, but we
     only need to reclaim space when we are really have no space for
     new chunk, noticed by:
     Filipe David Manana <fdmanana@gmail.com>
    
     Actually, our code already have this type of commit-and-retry,
     we only need to make it working with removed-bgs.
     v3 fixed the bug with above way.
    
    Changelog v1->v2:
     v1 will introduce a new bug when delete and create chunk in same disk
     space in same transaction, noticed by:
     Filipe David Manana <fdmanana@gmail.com>
     V2 fix this bug by commit transaction after remove block grops.
    
    Reported-by: Tsutomu Itoh <t-itoh@jp.fujitsu.com>
    Suggested-by: Filipe David Manana <fdmanana@gmail.com>
    Suggested-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Zhao Lei <zhaolei@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/transaction.c b/fs/btrfs/transaction.c
index e0faf803513a..038fcf6051e0 100644
--- a/fs/btrfs/transaction.c
+++ b/fs/btrfs/transaction.c
@@ -220,6 +220,7 @@ loop:
 	 * commit the transaction.
 	 */
 	atomic_set(&cur_trans->use_count, 2);
+	cur_trans->have_free_bgs = 0;
 	cur_trans->start_time = get_seconds();
 
 	cur_trans->delayed_refs.href_root = RB_ROOT;
@@ -2037,6 +2038,9 @@ int btrfs_commit_transaction(struct btrfs_trans_handle *trans,
 
 	btrfs_finish_extent_commit(trans, root);
 
+	if (cur_trans->have_free_bgs)
+		btrfs_clear_space_info_full(root->fs_info);
+
 	root->fs_info->last_trans_committed = cur_trans->transid;
 	/*
 	 * We needn't acquire the lock here because there is no other task
diff --git a/fs/btrfs/transaction.h b/fs/btrfs/transaction.h
index 3305451451ca..937050a2b68e 100644
--- a/fs/btrfs/transaction.h
+++ b/fs/btrfs/transaction.h
@@ -47,6 +47,11 @@ struct btrfs_transaction {
 	atomic_t num_writers;
 	atomic_t use_count;
 
+	/*
+	 * true if there is free bgs operations in this transaction
+	 */
+	int have_free_bgs;
+
 	/* Be protected by fs_info->trans_lock when we want to change it. */
 	enum btrfs_trans_state state;
 	struct list_head list;
diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index 2c4cab2dbd1a..cd4d1315aaa9 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -1310,6 +1310,8 @@ again:
 	if (ret) {
 		btrfs_error(root->fs_info, ret,
 			    "Failed to remove dev extent item");
+	} else {
+		trans->transaction->have_free_bgs = 1;
 	}
 out:
 	btrfs_free_path(path);

