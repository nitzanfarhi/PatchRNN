commit ff2f8e5ffb23de6e2284f31651447cb80a4c9d1b
Author: Charulatha V <charu@ti.com>
Date:   Tue Sep 13 18:32:37 2011 +0530

    ARM: OMAP3: PM: fix pwrdm_post_transition call sequence
    
    The context lost count is modified in omap_sram_idle() path when
    pwrdm_post_transition() is called. But pwrdm_post_transition() is called
    only after omap_gpio_resume_after_idle() is called. Correct this so that
    context lost count is modified before calling omap_gpio_resume_after_idle().
    
    This would be useful when OMAP GPIO save/restore context is called by
    the OMAP GPIO driver itself.
    
    Signed-off-by: Charulatha V <charu@ti.com>
    Reviewed-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index 7255d9bce868..1915050e9401 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -363,7 +363,6 @@ void omap_sram_idle(void)
 		printk(KERN_ERR "Invalid mpu state in sram_idle\n");
 		return;
 	}
-	pwrdm_pre_transition();
 
 	/* NEON control */
 	if (pwrdm_read_pwrst(neon_pwrdm) == PWRDM_POWER_ON)
@@ -386,6 +385,8 @@ void omap_sram_idle(void)
 			if (!console_trylock())
 				goto console_still_active;
 
+	pwrdm_pre_transition();
+
 	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {
 		per_going_off = (per_next_state == PWRDM_POWER_OFF) ? 1 : 0;
@@ -455,6 +456,8 @@ void omap_sram_idle(void)
 	}
 	omap3_intc_resume_idle();
 
+	pwrdm_post_transition();
+
 	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {
 		per_prev_state = pwrdm_read_prev_pwrst(per_pwrdm);
@@ -478,8 +481,6 @@ void omap_sram_idle(void)
 		omap3_disable_io_chain();
 	}
 
-	pwrdm_post_transition();
-
 	clkdm_allow_idle(mpu_pwrdm->pwrdm_clkdms[0]);
 }
 

