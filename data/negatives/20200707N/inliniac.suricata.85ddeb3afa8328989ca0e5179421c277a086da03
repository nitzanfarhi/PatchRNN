commit 85ddeb3afa8328989ca0e5179421c277a086da03
Author: Giuseppe Longo <glongo@stamus-networks.com>
Date:   Mon Nov 20 15:06:54 2017 +0100

    htp: get/set memcap value
    
    This adds new functions that will be called
    through unix-socket and permit to update
    and show memcap value.
    
    The memcap value needs to be handled in a
    thread safe way, so for this reason it is
    declared as atomic var.

diff --git a/src/app-layer-htp-mem.c b/src/app-layer-htp-mem.c
index 37ac6db1..a6b37ac2 100644
--- a/src/app-layer-htp-mem.c
+++ b/src/app-layer-htp-mem.c
@@ -38,8 +38,7 @@
 
 #include "app-layer-htp-mem.h"
 
-uint64_t htp_config_memcap = 0;
-
+SC_ATOMIC_DECLARE(uint64_t, htp_config_memcap);
 SC_ATOMIC_DECLARE(uint64_t, htp_memuse);
 SC_ATOMIC_DECLARE(uint64_t, htp_memcap);
 
@@ -47,19 +46,24 @@ void HTPParseMemcap()
 {
     const char *conf_val;
 
+    SC_ATOMIC_INIT(htp_config_memcap);
+
     /** set config values for memcap, prealloc and hash_size */
+    uint64_t memcap;
     if ((ConfGet("app-layer.protocols.http.memcap", &conf_val)) == 1)
     {
-        if (ParseSizeStringU64(conf_val, &htp_config_memcap) < 0) {
+        if (ParseSizeStringU64(conf_val, &memcap) < 0) {
             SCLogError(SC_ERR_SIZE_PARSE, "Error parsing http.memcap "
                        "from conf file - %s.  Killing engine",
                        conf_val);
             exit(EXIT_FAILURE);
+        } else {
+            SC_ATOMIC_SET(htp_config_memcap, memcap);
         }
-        SCLogInfo("HTTP memcap: %"PRIu64, htp_config_memcap);
+        SCLogInfo("HTTP memcap: %"PRIu64, SC_ATOMIC_GET(htp_config_memcap));
     } else {
         /* default to unlimited */
-        htp_config_memcap = 0;
+        SC_ATOMIC_SET(htp_config_memcap, 0);
     }
 
     SC_ATOMIC_INIT(htp_memuse);
@@ -98,12 +102,38 @@ uint64_t HTPMemcapGlobalCounter(void)
  */
 static int HTPCheckMemcap(uint64_t size)
 {
-    if (htp_config_memcap == 0 || size + SC_ATOMIC_GET(htp_memuse) <= htp_config_memcap)
+    uint64_t memcapcopy = SC_ATOMIC_GET(htp_config_memcap);
+    if (memcapcopy == 0 || size + SC_ATOMIC_GET(htp_memuse) <= memcapcopy)
         return 1;
     (void) SC_ATOMIC_ADD(htp_memcap, 1);
     return 0;
 }
 
+/**
+ *  \brief Update memcap value
+ *
+ *  \param size new memcap value
+ */
+int HTPSetMemcap(uint64_t size)
+{
+    if (size == 0 || (uint64_t)SC_ATOMIC_GET(htp_memuse) < size) {
+        SC_ATOMIC_SET(htp_config_memcap, size);
+        return 1;
+    }
+    return 0;
+}
+
+/**
+ *  \brief Update memcap value
+ *
+ *  \retval memcap value
+ */
+uint64_t HTPGetMemcap(void)
+{
+    uint64_t memcapcopy = SC_ATOMIC_GET(htp_config_memcap);
+    return memcapcopy;
+}
+
 void *HTPMalloc(size_t size)
 {
     void *ptr = NULL;
diff --git a/src/app-layer-htp-mem.h b/src/app-layer-htp-mem.h
index 8ac36057..414b4882 100644
--- a/src/app-layer-htp-mem.h
+++ b/src/app-layer-htp-mem.h
@@ -23,5 +23,8 @@ void *HTPCalloc(size_t n, size_t size);
 void *HTPRealloc(void *ptr, size_t orig_size, size_t size);
 void HTPFree(void *ptr, size_t size);
 
+int HTPSetMemcap(uint64_t size);
+uint64_t HTPGetMemcap(void);
+
 uint64_t HTPMemuseGlobalCounter(void);
 uint64_t HTPMemcapGlobalCounter(void);

