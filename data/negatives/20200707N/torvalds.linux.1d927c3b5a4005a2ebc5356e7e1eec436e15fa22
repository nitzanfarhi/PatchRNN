commit 1d927c3b5a4005a2ebc5356e7e1eec436e15fa22
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Aug 18 10:06:53 2011 +0200

    apm-emulation: use wait_event_freezable() instead of freezer_[do_not_]count()
    
    vfork is moving away from freezer_[do_not_]count() one way or the
    other leaving apm_ioctl() as the only user.  apm_ioctl() just wants to
    wait for suspend/resume cycle to complete without hindering the
    freezer.  Use wait_event_freezable() instead.
    
    The only annoyance is that wait_event_freezable() wakes up with
    -ERESTART if there are pending signals while apm_ioctl() wants to
    ignore all signals until suspend is complete.  We can play with
    @current->[real_]blocked but this is hardly a performance or latency
    critical path - simply chill a bit on each iteration until
    SUSPEND_DONE for unlikely cases where there are pending signals.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/char/apm-emulation.c b/drivers/char/apm-emulation.c
index 548708c4b2b8..7e2709c35fcf 100644
--- a/drivers/char/apm-emulation.c
+++ b/drivers/char/apm-emulation.c
@@ -300,17 +300,13 @@ apm_ioctl(struct file *filp, u_int cmd, u_long arg)
 			/*
 			 * Wait for the suspend/resume to complete.  If there
 			 * are pending acknowledges, we wait here for them.
+			 * wait_event_freezable() is interruptible and pending
+			 * signal can cause busy looping.  We aren't doing
+			 * anything critical, chill a bit on each iteration.
 			 */
-			freezer_do_not_count();
-
-			wait_event(apm_suspend_waitqueue,
-				   as->suspend_state == SUSPEND_DONE);
-
-			/*
-			 * Since we are waiting until the suspend is done, the
-			 * try_to_freeze() in freezer_count() will not trigger
-			 */
-			freezer_count();
+			while (wait_event_freezable(apm_suspend_waitqueue,
+					as->suspend_state == SUSPEND_DONE))
+				msleep(10);
 			break;
 		case SUSPEND_ACKTO:
 			as->suspend_result = -ETIMEDOUT;

