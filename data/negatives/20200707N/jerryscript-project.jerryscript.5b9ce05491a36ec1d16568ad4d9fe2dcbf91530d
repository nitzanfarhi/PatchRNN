commit 5b9ce05491a36ec1d16568ad4d9fe2dcbf91530d
Author: Ruben Ayrapetyan <r.ayrapetyan@samsung.com>
Date:   Fri Aug 21 14:19:04 2015 +0300

    Introduce parser-time optimization that replaces a function's local variables with registers.
    
    JerryScript-DCO-1.0-Signed-off-by: Ruben Ayrapetyan r.ayrapetyan@samsung.com

diff --git a/jerry-core/config.h b/jerry-core/config.h
index c877cb4e..37178ffa 100644
--- a/jerry-core/config.h
+++ b/jerry-core/config.h
@@ -167,4 +167,9 @@
  */
 // #define CONFIG_VM_RUN_GC_AFTER_EACH_OPCODE
 
+/**
+ * Flag, indicating whether to enable parser-time byte-code optimizations
+ */
+#define CONFIG_PARSER_ENABLE_PARSE_TIME_BYTE_CODE_OPTIMIZER
+
 #endif /* !CONFIG_H */
diff --git a/jerry-core/parser/js/opcodes-dumper.cpp b/jerry-core/parser/js/opcodes-dumper.cpp
index 63cc0af2..9e2da73e 100644
--- a/jerry-core/parser/js/opcodes-dumper.cpp
+++ b/jerry-core/parser/js/opcodes-dumper.cpp
@@ -19,7 +19,32 @@
 #include "stack.h"
 #include "jsp-early-error.h"
 
-static idx_t temp_name, max_temp_name;
+/**
+ * Register allocator's counter
+ */
+static idx_t jsp_reg_next;
+
+/**
+ * Maximum identifier of a register, allocated for intermediate value storage
+ *
+ * See also:
+ *          dumper_new_scope, dumper_finish_scope
+ */
+static idx_t jsp_reg_max_for_temps;
+
+/**
+ * Maximum identifier of a register, allocated for storage of a variable value.
+ *
+ * The value can be INVALID_VALUE, indicating that no registers were allocated for variable values.
+ *
+ * Note:
+ *      Registers for variable values are always allocated after registers for temporary values,
+ *      so the value, if not equal to INVALID_VALUE, is always greater than jsp_reg_max_for_temps.
+ *
+ * See also:
+ *          dumper_try_replace_var_with_reg
+ */
+static idx_t jsp_reg_max_for_local_var;
 
 enum
 {
@@ -101,9 +126,9 @@ STATIC_STACK (finallies, vm_instr_counter_t)
 
 enum
 {
-  temp_names_global_size
+  jsp_reg_id_stack_global_size
 };
-STATIC_STACK (temp_names, idx_t)
+STATIC_STACK (jsp_reg_id_stack, idx_t)
 
 enum
 {
@@ -112,24 +137,16 @@ enum
 STATIC_STACK (reg_var_decls, vm_instr_counter_t)
 
 /**
- * Reset counter of register variables allocator
- * to identifier of first general register
- */
-static void
-reset_temp_name (void)
-{
-  temp_name = OPCODE_REG_GENERAL_FIRST;
-} /* reset_temp_name */
-
-/**
- * Allocate next register variable
+ * Allocate next register for intermediate value
  *
- * @return identifier of the allocated variable
+ * @return identifier of the allocated register
  */
 static idx_t
-next_temp_name (void)
+jsp_alloc_reg_for_temp (void)
 {
-  idx_t next_reg = temp_name++;
+  JERRY_ASSERT (jsp_reg_max_for_local_var == INVALID_VALUE);
+
+  idx_t next_reg = jsp_reg_next++;
 
   if (next_reg > OPCODE_REG_GENERAL_LAST)
   {
@@ -140,13 +157,172 @@ next_temp_name (void)
     PARSE_ERROR (JSP_EARLY_ERROR_SYNTAX, "Not enough register variables", LIT_ITERATOR_POS_ZERO);
   }
 
-  if (max_temp_name < next_reg)
+  if (jsp_reg_max_for_temps < next_reg)
   {
-    max_temp_name = next_reg;
+    jsp_reg_max_for_temps = next_reg;
   }
 
   return next_reg;
-} /* next_temp_name */
+} /* jsp_alloc_reg_for_temp */
+
+#ifdef CONFIG_PARSER_ENABLE_PARSE_TIME_BYTE_CODE_OPTIMIZER
+/**
+ * Try to move local variable to a register
+ *
+ * Note:
+ *      First instruction of the scope should be either func_decl_n or func_expr_n, as the scope is function scope,
+ *      and the optimization is not applied to 'new Function ()'-like constructed functions.
+ *
+ * See also:
+ *          parse_source_element_list
+ *          parser_parse_program
+ *
+ * @return true, if optimization performed successfully, i.e.:
+ *                - there is a free register to use;
+ *                - the variable name is not equal to any of the function's argument names;
+ *         false - otherwise.
+ */
+bool
+dumper_try_replace_var_with_reg (scopes_tree tree, /**< a function scope, created for
+                                                    *   function declaration or function expresssion */
+                                 op_meta *var_decl_om_p) /**< operation meta of corresponding variable declaration */
+{
+  JERRY_ASSERT (tree->type == SCOPE_TYPE_FUNCTION);
+
+  JERRY_ASSERT (var_decl_om_p->op.op_idx == VM_OP_VAR_DECL);
+  JERRY_ASSERT (var_decl_om_p->lit_id[0].packed_value != NOT_A_LITERAL.packed_value);
+  JERRY_ASSERT (var_decl_om_p->lit_id[1].packed_value == NOT_A_LITERAL.packed_value);
+  JERRY_ASSERT (var_decl_om_p->lit_id[2].packed_value == NOT_A_LITERAL.packed_value);
+
+  vm_instr_counter_t instr_pos = 0;
+
+  op_meta header_opm = scopes_tree_op_meta (tree, instr_pos++);
+  JERRY_ASSERT (header_opm.op.op_idx == VM_OP_FUNC_EXPR_N || header_opm.op.op_idx == VM_OP_FUNC_DECL_N);
+
+  while (true)
+  {
+    op_meta meta_opm = scopes_tree_op_meta (tree, instr_pos++);
+    JERRY_ASSERT (meta_opm.op.op_idx == VM_OP_META);
+
+    opcode_meta_type meta_type = (opcode_meta_type) meta_opm.op.data.meta.type;
+
+    if (meta_type == OPCODE_META_TYPE_FUNCTION_END)
+    {
+      /* marker of function argument list end reached */
+      break;
+    }
+    else
+    {
+      JERRY_ASSERT (meta_type == OPCODE_META_TYPE_VARG);
+
+      /* the varg specifies argument name, and so should be a string literal */
+      JERRY_ASSERT (meta_opm.op.data.meta.data_1 == LITERAL_TO_REWRITE);
+      JERRY_ASSERT (meta_opm.lit_id[1].packed_value != NOT_A_LITERAL.packed_value);
+
+      if (meta_opm.lit_id[1].packed_value == var_decl_om_p->lit_id[0].packed_value)
+      {
+        /*
+         * Optimization is not performed, because the variable's name is equal to an argument name,
+         * and the argument's value would be initialized by its name in run-time.
+         *
+         * See also:
+         *          parser_parse_program
+         */
+        return false;
+      }
+    }
+  }
+
+  if (jsp_reg_max_for_local_var == INVALID_VALUE)
+  {
+    jsp_reg_max_for_local_var = jsp_reg_max_for_temps;
+  }
+
+  if (jsp_reg_max_for_local_var == OPCODE_REG_GENERAL_LAST)
+  {
+    /* not enough registers */
+    return false;
+  }
+  JERRY_ASSERT (jsp_reg_max_for_local_var < OPCODE_REG_GENERAL_LAST);
+
+  idx_t reg = ++jsp_reg_max_for_local_var;
+
+  lit_cpointer_t lit_cp = var_decl_om_p->lit_id[0];
+
+  for (vm_instr_counter_t instr_pos = 0;
+       instr_pos < tree->instrs_count;
+       instr_pos++)
+  {
+    op_meta om = scopes_tree_op_meta (tree, instr_pos);
+
+    vm_op_t opcode = (vm_op_t) om.op.op_idx;
+
+    int args_num = 0;
+
+#define VM_OP_0(opcode_name, opcode_name_uppercase) \
+    if (opcode == VM_OP_ ## opcode_name_uppercase) \
+    { \
+      args_num = 0; \
+    }
+#define VM_OP_1(opcode_name, opcode_name_uppercase, arg1, arg1_type) \
+    if (opcode == VM_OP_ ## opcode_name_uppercase) \
+    { \
+      JERRY_STATIC_ASSERT (((arg1_type) & VM_OP_ARG_TYPE_TYPE_OF_NEXT) == 0); \
+      args_num = 1; \
+    }
+#define VM_OP_2(opcode_name, opcode_name_uppercase, arg1, arg1_type, arg2, arg2_type) \
+    if (opcode == VM_OP_ ## opcode_name_uppercase) \
+    { \
+      JERRY_STATIC_ASSERT (((arg1_type) & VM_OP_ARG_TYPE_TYPE_OF_NEXT) == 0); \
+      JERRY_STATIC_ASSERT (((arg2_type) & VM_OP_ARG_TYPE_TYPE_OF_NEXT) == 0); \
+      args_num = 2; \
+    }
+#define VM_OP_3(opcode_name, opcode_name_uppercase, arg1, arg1_type, arg2, arg2_type, arg3, arg3_type) \
+    if (opcode == VM_OP_ ## opcode_name_uppercase) \
+    { \
+      JERRY_STATIC_ASSERT (((arg1_type) & VM_OP_ARG_TYPE_TYPE_OF_NEXT) == 0); \
+      \
+      /*
+       * See also:
+       *          The loop below
+       */ \
+      \
+      JERRY_ASSERT ((opcode == VM_OP_ASSIGNMENT && (arg2_type) == VM_OP_ARG_TYPE_TYPE_OF_NEXT) \
+                    || (opcode != VM_OP_ASSIGNMENT && ((arg2_type) & VM_OP_ARG_TYPE_TYPE_OF_NEXT) == 0)); \
+      JERRY_STATIC_ASSERT (((arg3_type) & VM_OP_ARG_TYPE_TYPE_OF_NEXT) == 0); \
+      args_num = 3; \
+    }
+
+#include "vm-opcodes.inc.h"
+
+    for (int arg_index = 0; arg_index < args_num; arg_index++)
+    {
+      /*
+       * This is the only opcode with statically unspecified argument type (checked by assertions above)
+       */
+      if (opcode == VM_OP_ASSIGNMENT
+          && arg_index == 1
+          && om.op.data.assignment.type_value_right != VM_OP_ARG_TYPE_VARIABLE)
+      {
+        break;
+      }
+
+      if (om.lit_id[arg_index].packed_value == lit_cp.packed_value)
+      {
+        om.lit_id[arg_index] = NOT_A_LITERAL;
+
+        raw_instr *raw_p = (raw_instr *) (&om.op);
+        JERRY_ASSERT (raw_p->uids[arg_index + 1] == LITERAL_TO_REWRITE);
+        raw_p->uids[arg_index + 1] = reg;
+      }
+    }
+
+    scopes_tree_set_op_meta (tree, instr_pos, om);
+  }
+
+  return true;
+} /* dumper_try_replace_var_with_reg */
+#endif /* CONFIG_PARSER_ENABLE_PARSE_TIME_BYTE_CODE_OPTIMIZER */
 
 static op_meta
 create_op_meta (vm_instr_t op, lit_cpointer_t lit_id1, lit_cpointer_t lit_id2, lit_cpointer_t lit_id3)
@@ -215,7 +391,7 @@ tmp_operand (void)
   operand ret;
 
   ret.type = OPERAND_TMP;
-  ret.data.uid = next_temp_name ();
+  ret.data.uid = jsp_alloc_reg_for_temp ();
 
   return ret;
 }
@@ -672,25 +848,30 @@ operand_is_empty (operand op)
 void
 dumper_new_statement (void)
 {
-  reset_temp_name ();
+  jsp_reg_next = OPCODE_REG_GENERAL_FIRST;
 }
 
 void
 dumper_new_scope (void)
 {
-  STACK_PUSH (temp_names, temp_name);
-  STACK_PUSH (temp_names, max_temp_name);
-  reset_temp_name ();
-  max_temp_name = temp_name;
+  JERRY_ASSERT (jsp_reg_max_for_local_var == INVALID_VALUE);
+
+  STACK_PUSH (jsp_reg_id_stack, jsp_reg_next);
+  STACK_PUSH (jsp_reg_id_stack, jsp_reg_max_for_temps);
+
+  jsp_reg_next = OPCODE_REG_GENERAL_FIRST;
+  jsp_reg_max_for_temps = jsp_reg_next;
 }
 
 void
 dumper_finish_scope (void)
 {
-  max_temp_name = STACK_TOP (temp_names);
-  STACK_DROP (temp_names, 1);
-  temp_name = STACK_TOP (temp_names);
-  STACK_DROP (temp_names, 1);
+  JERRY_ASSERT (jsp_reg_max_for_local_var == INVALID_VALUE);
+
+  jsp_reg_max_for_temps = STACK_TOP (jsp_reg_id_stack);
+  STACK_DROP (jsp_reg_id_stack, 1);
+  jsp_reg_next = STACK_TOP (jsp_reg_id_stack);
+  STACK_DROP (jsp_reg_id_stack, 1);
 }
 
 /**
@@ -712,7 +893,7 @@ dumper_finish_scope (void)
 void
 dumper_start_varg_code_sequence (void)
 {
-  STACK_PUSH (temp_names, temp_name);
+  STACK_PUSH (jsp_reg_id_stack, jsp_reg_next);
 } /* dumper_start_varg_code_sequence */
 
 /**
@@ -724,8 +905,8 @@ dumper_start_varg_code_sequence (void)
 void
 dumper_finish_varg_code_sequence (void)
 {
-  temp_name = STACK_TOP (temp_names);
-  STACK_DROP (temp_names, 1);
+  jsp_reg_next = STACK_TOP (jsp_reg_id_stack);
+  STACK_DROP (jsp_reg_id_stack, 1);
 } /* dumper_finish_varg_code_sequence */
 
 /**
@@ -2606,7 +2787,7 @@ void
 dump_reg_var_decl_for_rewrite (void)
 {
   STACK_PUSH (reg_var_decls, serializer_get_current_instr_counter ());
-  serializer_dump_op_meta (create_op_meta_000 (getop_reg_var_decl (OPCODE_REG_FIRST, INVALID_VALUE)));
+  serializer_dump_op_meta (create_op_meta_000 (getop_reg_var_decl (OPCODE_REG_FIRST, INVALID_VALUE, INVALID_VALUE)));
 }
 
 void
@@ -2615,7 +2796,20 @@ rewrite_reg_var_decl (void)
   vm_instr_counter_t reg_var_decl_oc = STACK_TOP (reg_var_decls);
   op_meta opm = serializer_get_op_meta (reg_var_decl_oc);
   JERRY_ASSERT (opm.op.op_idx == VM_OP_REG_VAR_DECL);
-  opm.op.data.reg_var_decl.max = max_temp_name;
+
+  if (jsp_reg_max_for_local_var != INVALID_VALUE)
+  {
+    JERRY_ASSERT (jsp_reg_max_for_local_var >= jsp_reg_max_for_temps);
+    opm.op.data.reg_var_decl.local_var_regs_num = (idx_t) (jsp_reg_max_for_local_var - jsp_reg_max_for_temps);
+    opm.op.data.reg_var_decl.max = jsp_reg_max_for_local_var;
+
+    jsp_reg_max_for_local_var = INVALID_VALUE;
+  }
+  else
+  {
+    opm.op.data.reg_var_decl.max = jsp_reg_max_for_temps;
+    opm.op.data.reg_var_decl.local_var_regs_num = 0;
+  }
   serializer_rewrite_op_meta (reg_var_decl_oc, opm);
   STACK_DROP (reg_var_decls, 1);
 }
@@ -2629,8 +2823,10 @@ dump_retval (operand op)
 void
 dumper_init (void)
 {
-  max_temp_name = 0;
-  reset_temp_name ();
+  jsp_reg_next = OPCODE_REG_GENERAL_FIRST;
+  jsp_reg_max_for_temps = OPCODE_REG_GENERAL_FIRST;
+  jsp_reg_max_for_local_var = INVALID_VALUE;
+
   STACK_INIT (U8);
   STACK_INIT (varg_headers);
   STACK_INIT (function_ends);
@@ -2644,7 +2840,7 @@ dumper_init (void)
   STACK_INIT (catches);
   STACK_INIT (finallies);
   STACK_INIT (tries);
-  STACK_INIT (temp_names);
+  STACK_INIT (jsp_reg_id_stack);
   STACK_INIT (reg_var_decls);
 }
 
@@ -2664,6 +2860,6 @@ dumper_free (void)
   STACK_FREE (catches);
   STACK_FREE (finallies);
   STACK_FREE (tries);
-  STACK_FREE (temp_names);
+  STACK_FREE (jsp_reg_id_stack);
   STACK_FREE (reg_var_decls);
 }
diff --git a/jerry-core/parser/js/opcodes-dumper.h b/jerry-core/parser/js/opcodes-dumper.h
index 111fd18b..15e9b971 100644
--- a/jerry-core/parser/js/opcodes-dumper.h
+++ b/jerry-core/parser/js/opcodes-dumper.h
@@ -19,6 +19,7 @@
 #include "opcodes.h"
 #include "ecma-globals.h"
 #include "lexer.h"
+#include "scopes-tree.h"
 
 typedef enum __attr_packed___
 {
@@ -55,6 +56,8 @@ bool operand_is_empty (operand);
 void dumper_init (void);
 void dumper_free (void);
 
+bool dumper_try_replace_var_with_reg (scopes_tree, op_meta *);
+
 void dumper_new_statement (void);
 void dumper_new_scope (void);
 void dumper_finish_scope (void);
diff --git a/jerry-core/parser/js/parser.cpp b/jerry-core/parser/js/parser.cpp
index e71d5489..aa90ec71 100644
--- a/jerry-core/parser/js/parser.cpp
+++ b/jerry-core/parser/js/parser.cpp
@@ -63,7 +63,7 @@ STATIC_STACK (scopes, scopes_tree)
 static operand parse_expression (bool, jsp_eval_ret_store_t);
 static void parse_statement (jsp_label_t *outermost_stmt_label_p);
 static operand parse_assignment_expression (bool);
-static void parse_source_element_list (bool);
+static void parse_source_element_list (bool, bool);
 static operand parse_argument_list (varg_list_type, operand, operand *);
 
 static bool
@@ -404,7 +404,7 @@ parse_property_assignment (void)
 
     jsp_label_t *masked_label_set_p = jsp_label_mask_set ();
 
-    parse_source_element_list (false);
+    parse_source_element_list (false, true);
 
     jsp_label_restore_set (masked_label_set_p);
 
@@ -677,7 +677,7 @@ parse_function_declaration (void)
   bool was_in_function = inside_function;
   inside_function = true;
 
-  parse_source_element_list (false);
+  parse_source_element_list (false, true);
 
   next_token_must_be (TOK_CLOSE_BRACE);
 
@@ -743,7 +743,7 @@ parse_function_expression (void)
 
   jsp_label_t *masked_label_set_p = jsp_label_mask_set ();
 
-  parse_source_element_list (false);
+  parse_source_element_list (false, true);
 
   jsp_label_restore_set (masked_label_set_p);
 
@@ -2965,7 +2965,10 @@ check_directive_prologue_for_use_strict ()
  *   ;
  */
 static void
-parse_source_element_list (bool is_global) /**< flag, indicating that we parsing global context */
+parse_source_element_list (bool is_global, /**< flag, indicating that we parsing global context */
+                           bool is_try_replace_local_vars_with_regs) /**< flag, indicating whether
+                                                                      *   to try moving local function
+                                                                      *   variables to registers */
 {
   const token_type end_tt = is_global ? TOK_EOF : TOK_CLOSE_BRACE;
 
@@ -3014,8 +3017,69 @@ parse_source_element_list (bool is_global) /**< flag, indicating that we parsing
   {
     scope_flags = (opcode_scope_code_flags_t) (scope_flags | OPCODE_SCOPE_CODE_FLAGS_NOT_REF_EVAL_IDENTIFIER);
   }
+
   rewrite_scope_code_flags (scope_code_flags_oc, scope_flags);
 
+#ifdef CONFIG_PARSER_ENABLE_PARSE_TIME_BYTE_CODE_OPTIMIZER
+  if (is_try_replace_local_vars_with_regs
+      && fe_scope_tree->type == SCOPE_TYPE_FUNCTION)
+  {
+    bool may_replace_vars_with_regs = (!inside_eval
+                                       && !fe_scope_tree->ref_eval /* 'eval' can reference variables in a way,
+                                                                    * that can't be figured out through static
+                                                                    * analysis */
+                                       && !fe_scope_tree->ref_arguments /* 'arguments' variable, if declared,
+                                                                         * should not be moved to a register,
+                                                                         * as it is currently declared in
+                                                                         * function's lexical environment
+                                                                         * (generally, the problem is the same,
+                                                                         *   as with function's arguments) */
+                                       && !fe_scope_tree->contains_with /* 'with' create new lexical environment
+                                                                         *  and so can change way identifier
+                                                                         *  is evaluated */
+                                       && !fe_scope_tree->contains_try /* same for 'catch' */
+                                       && !fe_scope_tree->contains_delete /* 'delete' handles variable's names,
+                                                                           * not values */
+                                       && !fe_scope_tree->contains_functions); /* nested functions can reference
+                                                                                * variables of current function */
+
+    if (may_replace_vars_with_regs)
+    {
+      /* no subscopes, as no function declarations / eval etc. in the scope */
+      JERRY_ASSERT (fe_scope_tree->t.children_num == 0);
+
+      bool are_all_vars_replaced = true;
+      for (vm_instr_counter_t var_decl_pos = 0;
+           var_decl_pos < fe_scope_tree->var_decls_cout;
+           var_decl_pos++)
+      {
+        op_meta *om_p = (op_meta *) linked_list_element (fe_scope_tree->var_decls, var_decl_pos);
+
+        if (!dumper_try_replace_var_with_reg (fe_scope_tree, om_p))
+        {
+          are_all_vars_replaced = false;
+        }
+      }
+
+      if (are_all_vars_replaced)
+      {
+        /*
+         * All local variables were replaced with registers, so variable declarations could be removed.
+         *
+         * TODO:
+         *      Support removal of a particular variable declaration, without removing the whole list.
+         */
+
+        linked_list_free (fe_scope_tree->var_decls);
+        fe_scope_tree->var_decls = linked_list_init (sizeof (op_meta));
+        fe_scope_tree->var_decls_cout = 0;
+      }
+    }
+  }
+#else /* CONFIG_PARSER_ENABLE_PARSE_TIME_BYTE_CODE_OPTIMIZER */
+  (void) is_try_replace_local_vars_with_regs;
+#endif /* !CONFIG_PARSER_ENABLE_PARSE_TIME_BYTE_CODE_OPTIMIZER */
+
   rewrite_reg_var_decl ();
   dumper_finish_scope ();
 } /* parse_source_element_list */
@@ -3087,7 +3151,22 @@ parser_parse_program (const jerry_api_char_t *source_p, /**< source code buffer
     lexer_set_strict_mode (scopes_tree_strict_mode (STACK_TOP (scopes)));
 
     skip_newlines ();
-    parse_source_element_list (true);
+
+    /*
+     * We don't try to perform replacement of local variables with registers for global code, eval code,
+     * and code of dynamically constructed functions.
+     *
+     * For global and eval code the replacement can be connected with side effects,
+     * that currently can only be figured out in runtime. For example, a variable
+     * can be redefined as accessor property of the Global object.
+     *
+     * For dynamically constructed functions replacement is not performed due to missing
+     * information about argument names (the names array is not passed to parser_parse_program).
+     * This could be solved by providing general way to iterate argument names during the optimization,
+     * or by expanding the optimization to run-time. In the second case, argument values could also
+     * be moved to registers.
+     */
+    parse_source_element_list (true, false);
 
     skip_newlines ();
     JERRY_ASSERT (token_is (TOK_EOF));
diff --git a/jerry-core/vm/opcodes-helpers-variables.cpp b/jerry-core/vm/opcodes-helpers-variables.cpp
index 3f79e556..c2d6e51d 100644
--- a/jerry-core/vm/opcodes-helpers-variables.cpp
+++ b/jerry-core/vm/opcodes-helpers-variables.cpp
@@ -62,7 +62,7 @@ bool
 is_reg_variable (vm_frame_ctx_t *frame_ctx_p, /**< interpreter context */
                  idx_t var_idx) /**< variable identifier */
 {
-  return (var_idx >= frame_ctx_p->min_reg_num && var_idx <= frame_ctx_p->max_reg_num);
+  return (var_idx >= frame_ctx_p->min_reg_idx && var_idx <= frame_ctx_p->max_reg_idx);
 } /* is_reg_variable */
 
 /**
@@ -82,7 +82,7 @@ get_variable_value (vm_frame_ctx_t *frame_ctx_p, /**< interpreter context */
   if (is_reg_variable (frame_ctx_p, var_idx))
   {
     ecma_value_t reg_value = vm_stack_frame_get_reg_value (&frame_ctx_p->stack_frame,
-                                                           var_idx - frame_ctx_p->min_reg_num);
+                                                           var_idx - frame_ctx_p->min_reg_idx);
 
     JERRY_ASSERT (!ecma_is_value_empty (reg_value));
 
@@ -136,7 +136,7 @@ set_variable_value (vm_frame_ctx_t *frame_ctx_p, /**< interpreter context */
     ret_value = ecma_make_empty_completion_value ();
 
     ecma_value_t reg_value = vm_stack_frame_get_reg_value (&frame_ctx_p->stack_frame,
-                                                           var_idx - frame_ctx_p->min_reg_num);
+                                                           var_idx - frame_ctx_p->min_reg_idx);
 
     if (ecma_is_value_number (reg_value)
         && ecma_is_value_number (value))
@@ -151,8 +151,8 @@ set_variable_value (vm_frame_ctx_t *frame_ctx_p, /**< interpreter context */
       }
 
       vm_stack_frame_set_reg_value (&frame_ctx_p->stack_frame,
-                                    var_idx - frame_ctx_p->min_reg_num,
-                                      ecma_copy_value (value, false));
+                                    var_idx - frame_ctx_p->min_reg_idx,
+                                    ecma_copy_value (value, false));
     }
   }
   else
diff --git a/jerry-core/vm/opcodes.h b/jerry-core/vm/opcodes.h
index 7c690686..cee54a7a 100644
--- a/jerry-core/vm/opcodes.h
+++ b/jerry-core/vm/opcodes.h
@@ -163,8 +163,8 @@ typedef struct
   bool is_eval_code; /**< is current code executed with eval */
   bool is_call_in_direct_eval_form; /** flag, indicating if there is call of 'Direct call to eval' form in
                                      *  process (see also: OPCODE_CALL_FLAGS_DIRECT_CALL_TO_EVAL_FORM) */
-  idx_t min_reg_num; /**< minimum idx used for register identification */
-  idx_t max_reg_num; /**< maximum idx used for register identification */
+  idx_t min_reg_idx; /**< minimum idx used for register identification */
+  idx_t max_reg_idx; /**< maximum idx used for register identification */
   ecma_number_t* tmp_num_p; /**< an allocated number (to reduce temporary allocations) */
   vm_stack_frame_t stack_frame; /**< stack frame associated with the context */
 
diff --git a/jerry-core/vm/vm-opcodes.inc.h b/jerry-core/vm/vm-opcodes.inc.h
index 50c5e36b..33c72e1d 100644
--- a/jerry-core/vm/vm-opcodes.inc.h
+++ b/jerry-core/vm/vm-opcodes.inc.h
@@ -295,9 +295,10 @@ VM_OP_3 (is_false_jmp_down,     IS_FALSE_JMP_DOWN,
 VM_OP_1 (var_decl,              VAR_DECL,
          variable_name,         VM_OP_ARG_TYPE_STRING)
 
-VM_OP_2 (reg_var_decl,          REG_VAR_DECL,
+VM_OP_3 (reg_var_decl,          REG_VAR_DECL,
          min,                   VM_OP_ARG_TYPE_REGISTER,
-         max,                   VM_OP_ARG_TYPE_REGISTER)
+         max,                   VM_OP_ARG_TYPE_REGISTER,
+         local_var_regs_num,    VM_OP_ARG_TYPE_INTEGER_CONST)
 
 VM_OP_3 (meta,                  META,
          type,                  VM_OP_ARG_TYPE_INTEGER_CONST,
diff --git a/jerry-core/vm/vm-stack.cpp b/jerry-core/vm/vm-stack.cpp
index 58e49eed..984079a4 100644
--- a/jerry-core/vm/vm-stack.cpp
+++ b/jerry-core/vm/vm-stack.cpp
@@ -76,7 +76,9 @@ vm_stack_get_top_frame (void)
 void
 vm_stack_add_frame (vm_stack_frame_t *frame_p, /**< frame to initialize */
                     ecma_value_t *regs_p, /**< array of register variables' values */
-                    int32_t regs_num) /**< number of register variables */
+                    int32_t regs_num, /**< total number of register variables */
+                    int32_t local_vars_regs_num) /**< number of register variables,
+                                                  *   used for local variables */
 {
   frame_p->prev_frame_p = vm_stack_top_frame_p;
   vm_stack_top_frame_p = frame_p;
@@ -87,10 +89,17 @@ vm_stack_add_frame (vm_stack_frame_t *frame_p, /**< frame to initialize */
   frame_p->regs_p = regs_p;
   frame_p->regs_number = regs_num;
 
-  for (int32_t i = 0; i < regs_num; i++)
+  for (int32_t i = 0; i < regs_num - local_vars_regs_num; i++)
   {
     regs_p[i] = ecma_make_simple_value (ECMA_SIMPLE_VALUE_EMPTY);
   }
+
+  for (int32_t i = regs_num - local_vars_regs_num;
+       i < regs_num;
+       i++)
+  {
+    regs_p[i] = ecma_make_simple_value (ECMA_SIMPLE_VALUE_UNDEFINED);
+  }
 } /* vm_stack_add_frame */
 
 /**
diff --git a/jerry-core/vm/vm-stack.h b/jerry-core/vm/vm-stack.h
index 8484af33..e9b11c49 100644
--- a/jerry-core/vm/vm-stack.h
+++ b/jerry-core/vm/vm-stack.h
@@ -62,7 +62,8 @@ vm_stack_get_top_frame (void);
 extern void
 vm_stack_add_frame (vm_stack_frame_t *frame_p,
                       ecma_value_t *regs_p,
-                      int32_t regs_num);
+                      int32_t regs_num,
+                      int32_t local_vars_regs_num);
 extern void vm_stack_free_frame (vm_stack_frame_t *frame_p);
 extern ecma_value_t vm_stack_frame_get_reg_value (vm_stack_frame_t *frame_p, int32_t reg_index);
 extern void vm_stack_frame_set_reg_value (vm_stack_frame_t *frame_p, int32_t reg_index, ecma_value_t value);
diff --git a/jerry-core/vm/vm.cpp b/jerry-core/vm/vm.cpp
index 00683f16..8ce18c0b 100644
--- a/jerry-core/vm/vm.cpp
+++ b/jerry-core/vm/vm.cpp
@@ -543,11 +543,12 @@ vm_run_from_pos (const vm_instr_t *instrs_p, /**< byte-code array */
   const vm_instr_t *curr = &instrs_p[start_pos];
   JERRY_ASSERT (curr->op_idx == VM_OP_REG_VAR_DECL);
 
-  const idx_t min_reg_num = curr->data.reg_var_decl.min;
-  const idx_t max_reg_num = curr->data.reg_var_decl.max;
-  JERRY_ASSERT (max_reg_num >= min_reg_num);
+  const idx_t min_reg_idx = curr->data.reg_var_decl.min;
+  const idx_t max_reg_idx = curr->data.reg_var_decl.max;
+  const idx_t local_var_regs_num = curr->data.reg_var_decl.local_var_regs_num;
+  JERRY_ASSERT (max_reg_idx >= min_reg_idx);
 
-  const int32_t regs_num = max_reg_num - min_reg_num + 1;
+  int32_t regs_num = max_reg_idx - min_reg_idx + 1;
 
   MEM_DEFINE_LOCAL_ARRAY (regs, regs_num, ecma_value_t);
 
@@ -559,10 +560,10 @@ vm_run_from_pos (const vm_instr_t *instrs_p, /**< byte-code array */
   frame_ctx.is_strict = is_strict;
   frame_ctx.is_eval_code = is_eval_code;
   frame_ctx.is_call_in_direct_eval_form = false;
-  frame_ctx.min_reg_num = min_reg_num;
-  frame_ctx.max_reg_num = max_reg_num;
+  frame_ctx.min_reg_idx = min_reg_idx;
+  frame_ctx.max_reg_idx = max_reg_idx;
   frame_ctx.tmp_num_p = ecma_alloc_number ();
-  vm_stack_add_frame (&frame_ctx.stack_frame, regs, regs_num);
+  vm_stack_add_frame (&frame_ctx.stack_frame, regs, regs_num, local_var_regs_num);
 
   vm_frame_ctx_t *prev_context_p = vm_top_context_p;
   vm_top_context_p = &frame_ctx;
diff --git a/tests/unit/test-parser.cpp b/tests/unit/test-parser.cpp
index 6fea79c7..ba743183 100644
--- a/tests/unit/test-parser.cpp
+++ b/tests/unit/test-parser.cpp
@@ -64,7 +64,7 @@ main (int __attr_unused___ argc,
                 OPCODE_SCOPE_CODE_FLAGS_NOT_REF_ARGUMENTS_IDENTIFIER
                 | OPCODE_SCOPE_CODE_FLAGS_NOT_REF_EVAL_IDENTIFIER,
                 INVALID_VALUE),
-    getop_reg_var_decl (OPCODE_REG_FIRST, OPCODE_REG_GENERAL_FIRST),
+    getop_reg_var_decl (OPCODE_REG_FIRST, OPCODE_REG_GENERAL_FIRST, 0),
     getop_var_decl (0),             // var a;
     getop_assignment (130, 1, 1),   // $tmp0 = 1;
     getop_assignment (0, 6, 130),   // a = $tmp0;

