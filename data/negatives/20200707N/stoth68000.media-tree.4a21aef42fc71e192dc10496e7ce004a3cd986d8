commit 4a21aef42fc71e192dc10496e7ce004a3cd986d8
Author: Bobi Jam <bobijam.xu@intel.com>
Date:   Wed Nov 2 21:25:02 2016 -0400

    staging/lustre/llite: update ras window correctly
    
    When stride-RA hit case miss, we only reset normal sequential
    read-ahead window, but not reset the stride IO to avoid the overhead
    of re-detecting stride IO. While when the normal RA window is set
    to not insect with the stride-RA window, when we try to increase
    the stride-RA window length later, the presumption does not hold.
    
    This patch resets the stride IO as well in this case.
    
    Signed-off-by: Bobi Jam <bobijam.xu@intel.com>
    Reviewed-on: http://review.whamcloud.com/23032
    Intel-bug-id: https://jira.hpdd.intel.com/browse/LU-8683
    Reviewed-by: wangdi <di.wang@intel.com>
    Reviewed-by: Jinshan Xiong <jinshan.xiong@intel.com>
    Signed-off-by: Oleg Drokin <green@linuxhacker.ru>
    Reviewed-by: James Simmons <jsimmons@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/lustre/lustre/llite/rw.c b/drivers/staging/lustre/lustre/llite/rw.c
index d2515a8005d3..e34017d7c8da 100644
--- a/drivers/staging/lustre/lustre/llite/rw.c
+++ b/drivers/staging/lustre/lustre/llite/rw.c
@@ -809,13 +809,20 @@ static void ras_update(struct ll_sb_info *sbi, struct inode *inode,
 		if (ra_miss) {
 			if (index_in_stride_window(ras, index) &&
 			    stride_io_mode(ras)) {
-				/*If stride-RA hit cache miss, the stride dector
-				 *will not be reset to avoid the overhead of
-				 *redetecting read-ahead mode
-				 */
 				if (index != ras->ras_last_readpage + 1)
 					ras->ras_consecutive_pages = 0;
 				ras_reset(inode, ras, index);
+
+				/* If stride-RA hit cache miss, the stride
+				 * detector will not be reset to avoid the
+				 * overhead of redetecting read-ahead mode,
+				 * but on the condition that the stride window
+				 * is still intersect with normal sequential
+				 * read-ahead window.
+				 */
+				if (ras->ras_window_start <
+				    ras->ras_stride_offset)
+					ras_stride_reset(ras);
 				RAS_CDEBUG(ras);
 			} else {
 				/* Reset both stride window and normal RA

