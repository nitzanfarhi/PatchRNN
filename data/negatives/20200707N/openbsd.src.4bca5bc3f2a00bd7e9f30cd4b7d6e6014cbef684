commit 4bca5bc3f2a00bd7e9f30cd4b7d6e6014cbef684
Author: kjell <kjell@openbsd.org>
Date:   Sun Nov 13 07:49:02 2005 +0000

    Better error checking of snprintfs. From Han Boetes.

diff --git a/usr.bin/mg/buffer.c b/usr.bin/mg/buffer.c
index 6cf407598fc..0f912c97a36 100644
--- a/usr.bin/mg/buffer.c
+++ b/usr.bin/mg/buffer.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: buffer.c,v 1.50 2005/10/14 19:46:46 kjell Exp $	*/
+/*	$OpenBSD: buffer.c,v 1.51 2005/11/13 07:49:02 kjell Exp $	*/
 
 /* This file is in the public domain. */
 
@@ -417,22 +417,26 @@ addlinef(BUFFER *bp, char *fmt, ...)
 
 /*
  * Look through the list of buffers, giving the user a chance to save them.
- * Return TRUE if there are any changed buffers afterwards.  Buffers that
- * don't have an associated file don't count.  Return FALSE if there are
- * no changed buffers.
+ * Return TRUE if there are any changed buffers afterwards.  Buffers that don't
+ * have an associated file don't count.  Return FALSE if there are no changed
+ * buffers.  Return ABORT if an error occurs or if the user presses c-g.
  */
 int
 anycb(int f)
 {
 	BUFFER *bp;
-	int	s = FALSE, save = FALSE;
+	int	s = FALSE, save = FALSE, ret;
 	char	prompt[NFILEN + 11];
 
 	for (bp = bheadp; bp != NULL; bp = bp->b_bufp) {
 		if (bp->b_fname != NULL && *(bp->b_fname) != '\0' &&
 		    (bp->b_flag & BFCHG) != 0) {
-			snprintf(prompt, sizeof(prompt), "Save file %s",
+			ret = snprintf(prompt, sizeof(prompt), "Save file %s",
 			    bp->b_fname);
+			if (ret < 0 || ret >= sizeof(prompt)) {
+				ewprintf("Error: filename too long!");
+				return (ABORT);
+			}
 			if ((f == TRUE || (save = eyorn(prompt)) == TRUE) &&
 			    buffsave(bp) == TRUE) {
 				bp->b_flag &= ~BFCHG;
diff --git a/usr.bin/mg/dired.c b/usr.bin/mg/dired.c
index ef78710417a..18de56e82fb 100644
--- a/usr.bin/mg/dired.c
+++ b/usr.bin/mg/dired.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: dired.c,v 1.29 2005/11/12 20:13:47 deraadt Exp $	*/
+/*	$OpenBSD: dired.c,v 1.30 2005/11/13 07:49:02 kjell Exp $	*/
 
 /* This file is in the public domain. */
 
@@ -590,7 +590,7 @@ dired_(char *dirname)
 	BUFFER	*bp;
 	FILE	*dirpipe;
 	char	 line[256];
-	int	 len;
+	int	 len, ret;
 
 	if ((dirname = adjustname(dirname)) == NULL) {
 		ewprintf("Bad directory name");
@@ -609,8 +609,8 @@ dired_(char *dirname)
 	if (bclear(bp) != TRUE)
 		return (NULL);
 	bp->b_flag |= BFREADONLY;
-	if (snprintf(line, sizeof(line), "ls -al %s", dirname)
-	    >= sizeof(line)) {
+	ret = snprintf(line, sizeof(line), "ls -al %s", dirname);
+	if (ret < 0 || ret  >= sizeof(line)) {
 		ewprintf("Path too long");
 		return (NULL);
 	}
diff --git a/usr.bin/mg/fileio.c b/usr.bin/mg/fileio.c
index 35604d56aae..8300bb43842 100644
--- a/usr.bin/mg/fileio.c
+++ b/usr.bin/mg/fileio.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: fileio.c,v 1.60 2005/11/11 18:51:49 kjell Exp $	*/
+/*	$OpenBSD: fileio.c,v 1.61 2005/11/13 07:49:02 kjell Exp $	*/
 
 /* This file is in the public domain. */
 
@@ -322,17 +322,18 @@ startupfile(char *suffix)
 {
 	static char	 file[NFILEN];
 	char		*home;
+	int		 ret;
 
 	if ((home = getenv("HOME")) == NULL || *home == '\0')
 		goto nohome;
 
 	if (suffix == NULL) {
-		if (snprintf(file, sizeof(file), "%s/.mg", home)
-		    >= sizeof(file))
+		ret = snprintf(file, sizeof(file), "%s/.mg", home);
+		if (ret < 0 || ret >= sizeof(file))
 			return (NULL);
 	} else {
-		if (snprintf(file, sizeof(file), "%s/.mg-%s", home, suffix)
-		    >= sizeof(file))
+		ret = snprintf(file, sizeof(file), "%s/.mg-%s", home, suffix);
+		if (ret < 0 || ret >= sizeof(file))
 			return (NULL);
 	}
 
@@ -341,21 +342,22 @@ startupfile(char *suffix)
 nohome:
 #ifdef STARTUPFILE
 	if (suffix == NULL) {
-		if (snprintf(file, sizeof(file), "%s", STARTUPFILE)
-		    >= sizeof(file))
+		ret = snprintf(file, sizeof(file), "%s", STARTUPFILE);
+		if (ret < 0 || ret >= sizeof(file))
 			return (NULL);
 	} else {
-		if (snprintf(file, sizeof(file), "%s%s", STARTUPFILE, suffix)
-		    >= sizeof(file))
+		ret = snprintf(file, sizeof(file), "%s%s", STARTUPFILE,
+		    suffix);
+		if (ret < 0 || ret >= sizeof(file))
 			return (NULL);
 	}
 
 	if (access(file, R_OK) == 0)
 		return (file);
-#endif
+#endif /* STARTUPFILE */
 	return (NULL);
 }
-#endif
+#endif /* !NO_STARTUP */
 
 #ifndef NO_DIRED
 
@@ -421,7 +423,7 @@ LIST *
 make_file_list(char *buf)
 {
 	char		*dir, *file, *cp;
-	int		 len, preflen;
+	int		 len, preflen, ret;
 	DIR		*dirp;
 	struct dirent	*dent;
 	LIST		*last;
@@ -516,10 +518,10 @@ make_file_list(char *buf)
 			char		statname[NFILEN + 2];
 
 			statbuf.st_mode = 0;
-			if (snprintf(statname, sizeof(statname), "%s/%s",
-			    dir, dent->d_name) > sizeof(statname) - 1) {
+			ret = snprintf(statname, sizeof(statname), "%s/%s",
+			    dir, dent->d_name);
+			if (ret < 0 || ret > sizeof(statname) - 1)
 				continue;
-			}
 			if (stat(statname, &statbuf) < 0)
 				continue;
 			if (statbuf.st_mode & S_IFDIR)
@@ -530,9 +532,9 @@ make_file_list(char *buf)
 		if (current == NULL)
 			break;
 
-		if (snprintf(current->fl_name, sizeof(current->fl_name),
-		    "%s%s%s", prefixx, dent->d_name, isdir ? "/" : "")
-		    >= sizeof(current->fl_name)) {
+		ret = snprintf(current->fl_name, sizeof(current->fl_name),
+		    "%s%s%s", prefixx, dent->d_name, isdir ? "/" : "");
+		if (ret < 0 || ret >= sizeof(current->fl_name)) {
 			free(current);
 			continue;
 		}

