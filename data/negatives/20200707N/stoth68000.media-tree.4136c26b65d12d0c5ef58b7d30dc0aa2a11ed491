commit 4136c26b65d12d0c5ef58b7d30dc0aa2a11ed491
Author: Michal Hocko <mhocko@suse.com>
Date:   Mon May 23 16:25:57 2016 -0700

    coredump: make coredump_wait wait for mmap_sem for write killable
    
    coredump_wait waits for mmap_sem for write currently which can prevent
    oom_reaper to reclaim the oom victims address space asynchronously
    because that requires mmap_sem for read.  This might happen if the oom
    victim is multi threaded and some thread(s) is holding mmap_sem for read
    (e.g.  page fault) and it is stuck in the page allocator while other
    thread(s) reached coredump_wait already.
    
    This patch simply uses down_write_killable and bails out with EINTR if
    the lock got interrupted by the fatal signal.  do_coredump will return
    right away and do_group_exit will take care to zap the whole thread
    group.
    
    Signed-off-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Oleg Nesterov <oleg@redhat.com>
    Acked-by: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/coredump.c b/fs/coredump.c
index 492c2db25dc9..38a7ab87e10a 100644
--- a/fs/coredump.c
+++ b/fs/coredump.c
@@ -413,7 +413,9 @@ static int coredump_wait(int exit_code, struct core_state *core_state)
 	core_state->dumper.task = tsk;
 	core_state->dumper.next = NULL;
 
-	down_write(&mm->mmap_sem);
+	if (down_write_killable(&mm->mmap_sem))
+		return -EINTR;
+
 	if (!mm->core_state)
 		core_waiters = zap_threads(tsk, mm, core_state, exit_code);
 	up_write(&mm->mmap_sem);

