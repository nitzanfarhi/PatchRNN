commit be2736adcf8ac583c2d56e37db9ef01f391913f9
Author: Guy Harris <guy@alum.mit.edu>
Date:   Wed Oct 1 07:11:49 2003 +0000

    Have a pseudo-header for Ethernet packets, giving the size of the FCS -
    0 means "there is no FCS in the packet data", 4 means "there is an FCS
    in the packet data", -1 means "I don't know whether there's an FCS in
    the packet data, guess based on the packet size".
    
    Assume that Ethernet encapsulated inside other protocols has no FCS, by
    having the "eth" dissector assume that (and not check for an Ethernet
    pseudo-header).
    
    Have "ethertype()" take an argument giving the FCS size; pass 0 when
    appropriate.
    
    Fix up Wiretap routines to set the pseudo-header.  This means we no
    longer use the "generic" seek-and-read routine, so get rid of it.
    
    svn path=/trunk/; revision=8574

diff --git a/epan/packet.h b/epan/packet.h
index 0ccc23a655..494e4271e7 100644
--- a/epan/packet.h
+++ b/epan/packet.h
@@ -1,7 +1,7 @@
 /* packet.h
  * Definitions for packet disassembly structures and routines
  *
- * $Id: packet.h,v 1.71 2003/09/09 18:09:42 guy Exp $
+ * $Id: packet.h,v 1.72 2003/10/01 07:11:45 guy Exp $
  *
  * Ethereal - Network traffic analyzer
  * By Gerald Combs <gerald@ethereal.com>
@@ -331,6 +331,6 @@ extern void capture_ethertype(guint16 etype, const guchar *pd, int offset,
 		int len, packet_counts *ld);
 extern void ethertype(guint16 etype, tvbuff_t *tvb, int offset_after_ethertype,
 		packet_info *pinfo, proto_tree *tree, proto_tree *fh_tree,
-		int etype_id, int trailer_id);
+		int etype_id, int trailer_id, int fcs_len);
 
 #endif /* packet.h */
diff --git a/packet-eth.c b/packet-eth.c
index e8d1a9d7ea..dbe2e8a6b7 100644
--- a/packet-eth.c
+++ b/packet-eth.c
@@ -1,7 +1,7 @@
 /* packet-eth.c
  * Routines for ethernet packet disassembly
  *
- * $Id: packet-eth.c,v 1.87 2003/08/27 21:12:27 guy Exp $
+ * $Id: packet-eth.c,v 1.88 2003/10/01 07:11:44 guy Exp $
  *
  * Ethereal - Network traffic analyzer
  * By Gerald Combs <gerald@ethereal.com>
@@ -157,7 +157,8 @@ capture_eth(const guchar *pd, int offset, int len, packet_counts *ld)
 }
 
 static void
-dissect_eth(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
+dissect_eth_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
+	int fcs_len)
 {
   proto_item		*ti;
   eth_hdr 		*ehdr;
@@ -255,7 +256,7 @@ dissect_eth(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
     proto_tree_add_ether_hidden(fh_tree, hf_eth_addr, tvb, 6, 6, src_addr);
 
     dissect_802_3(ehdr->type, is_802_2, tvb, ETH_HEADER_SIZE, pinfo, tree, fh_tree,
-		  hf_eth_len, hf_eth_trailer);
+		  hf_eth_len, hf_eth_trailer, fcs_len);
   } else {
     if (eth_interpret_as_fw1_monitor) {
       call_dissector(fw1_handle, tvb, pinfo, tree);
@@ -279,7 +280,7 @@ dissect_eth(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
     proto_tree_add_ether_hidden(fh_tree, hf_eth_addr, tvb, 6, 6, src_addr);
 
     ethertype(ehdr->type, tvb, ETH_HEADER_SIZE, pinfo, tree, fh_tree, hf_eth_type,
-          hf_eth_trailer);
+          hf_eth_trailer, fcs_len);
   }
 
 end_of_eth:
@@ -290,10 +291,14 @@ end_of_eth:
 /*
  * Add an Ethernet trailer - which, for some captures, might be the FCS
  * rather than a pad-to-60-bytes trailer.
+ *
+ * If fcs_len is 0, we assume the frame has no FCS; if it's 4, we assume
+ * it has an FCS; if it's anything else (such as -1, which means "maybe
+ * it does, maybe it doesn't"), we try to infer whether it has an FCS.
  */
 void
 add_ethernet_trailer(proto_tree *fh_tree, int trailer_id, tvbuff_t *tvb,
-		     tvbuff_t *trailer_tvb)
+		     tvbuff_t *trailer_tvb, int fcs_len)
 {
   /* If there're some bytes left over, show those bytes as a trailer.
 
@@ -307,15 +312,23 @@ add_ethernet_trailer(proto_tree *fh_tree, int trailer_id, tvbuff_t *tvb,
 
     trailer_length = tvb_length(trailer_tvb);
     trailer_reported_length = tvb_reported_length(trailer_tvb);
-    if (tvb_reported_length(tvb) >= 64) {
-      /* OK, the frame is big enough that, if we have a trailer, it
-	 probably includes an FCS; there's no need to pad an Ethernet
+    if (fcs_len != 0) {
+      /* If fcs_len is 4, we assume we definitely have an FCS.
+         Otherwise, then, if the frame is big enough that, if we
+         have a trailer, it probably inclues an FCS, and we have
+         enough space in the trailer for the FCS, we assume we
+         have an FCS.
+
+	 "Big enough" means 64 bytes or more; any frame that big
+	 needs no trailer, as there's no need to pad an Ethernet
 	 packet past 60 bytes.
 
-	 Do we have enough space in the trailer for an FCS? */
-      if (trailer_reported_length >= 4) {
-	/* Yes, as the claimed trailer length is at least as big as
-	   a 4-byte FCS. */
+	 The trailer must be at least 4 bytes long to have enough
+	 space for an FCS. */
+
+      if (fcs_len == 4 || (tvb_reported_length(tvb) >= 64 &&
+			   trailer_reported_length >= 4)) {
+	/* Either we know we have an FCS, or we believe we have an FCS. */
 	if (trailer_length < trailer_reported_length) {
 	  /* The packet is claimed to have enough data for a 4-byte FCS,
 	     but we didn't capture all of the packet.
@@ -356,6 +369,22 @@ add_ethernet_trailer(proto_tree *fh_tree, int trailer_id, tvbuff_t *tvb,
   }
 }
 
+/* Called for the Ethernet Wiretap encapsulation type; pass the FCS length
+   reported to us. */
+static void
+dissect_eth_maybefcs(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
+{
+  dissect_eth_common(tvb, pinfo, tree, pinfo->pseudo_header->eth.fcs_len);
+}
+
+/* Called by other dissectors - for now, we assume Ethernet encapsulated
+   inside other protocols doesn't include the FCS. */
+static void
+dissect_eth(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
+{
+  dissect_eth_common(tvb, pinfo, tree, 0);
+}
+
 void
 proto_register_eth(void)
 {
@@ -410,7 +439,7 @@ proto_register_eth(void)
 void
 proto_reg_handoff_eth(void)
 {
-	dissector_handle_t eth_handle;
+	dissector_handle_t eth_handle, eth_maybefcs_handle;
 
 	/*
 	 * Get a handle for the ISL dissector.
@@ -418,8 +447,11 @@ proto_reg_handoff_eth(void)
 	isl_handle = find_dissector("isl");
 	fw1_handle = find_dissector("fw1");
 
+	eth_maybefcs_handle = create_dissector_handle(dissect_eth_maybefcs,
+	    proto_eth);
+	dissector_add("wtap_encap", WTAP_ENCAP_ETHERNET, eth_maybefcs_handle);
+
 	eth_handle = find_dissector("eth");
-	dissector_add("wtap_encap", WTAP_ENCAP_ETHERNET, eth_handle);
 	dissector_add("ethertype", ETHERTYPE_ETHBRIDGE, eth_handle);
 	dissector_add("chdlctype", ETHERTYPE_ETHBRIDGE, eth_handle);
 	dissector_add("gre.proto", ETHERTYPE_ETHBRIDGE, eth_handle);
diff --git a/packet-eth.h b/packet-eth.h
index 86b1fd7be6..d775264269 100644
--- a/packet-eth.h
+++ b/packet-eth.h
@@ -1,6 +1,6 @@
 /* packet-eth.h
  *
- * $Id: packet-eth.h,v 1.12 2003/08/23 09:09:32 sahlberg Exp $
+ * $Id: packet-eth.h,v 1.13 2003/10/01 07:11:44 guy Exp $
  *
  * Ethereal - Network traffic analyzer
  * By Gerald Combs <gerald@ethereal.com>
@@ -33,6 +33,6 @@ typedef struct _eth_hdr {
 void capture_eth(const guchar *, int, int, packet_counts *);
 
 void add_ethernet_trailer(proto_tree *fh_tree, int trailer_id, tvbuff_t *tvb,
-			  tvbuff_t *trailer_tvb);
+			  tvbuff_t *trailer_tvb, int fcs_len);
 
 #endif
diff --git a/packet-ethertype.c b/packet-ethertype.c
index 89642bbc1f..9170757b7e 100644
--- a/packet-ethertype.c
+++ b/packet-ethertype.c
@@ -1,7 +1,7 @@
 /* ethertype.c
  * Routines for calling the right protocol for the ethertype.
  *
- * $Id: packet-ethertype.c,v 1.37 2003/08/21 21:05:29 guy Exp $
+ * $Id: packet-ethertype.c,v 1.38 2003/10/01 07:11:44 guy Exp $
  *
  * Gilbert Ramirez <gram@alumni.rice.edu>
  *
@@ -103,7 +103,8 @@ const value_string etype_vals[] = {
     {0,				NULL				} };
 
 static void add_dix_trailer(proto_tree *fh_tree, int trailer_id, tvbuff_t *tvb,
-    tvbuff_t *next_tvb, int offset_after_etype, guint length_before);
+    tvbuff_t *next_tvb, int offset_after_etype, guint length_before,
+    gint fcs_len);
 
 void
 capture_ethertype(guint16 etype, const guchar *pd, int offset, int len,
@@ -138,7 +139,7 @@ capture_ethertype(guint16 etype, const guchar *pd, int offset, int len,
 void
 ethertype(guint16 etype, tvbuff_t *tvb, int offset_after_etype,
 		packet_info *pinfo, proto_tree *tree, proto_tree *fh_tree,
-		int etype_id, int trailer_id)
+		int etype_id, int trailer_id, int fcs_len)
 {
 	char			*description;
 	tvbuff_t		*next_tvb;
@@ -188,7 +189,7 @@ ethertype(guint16 etype, tvbuff_t *tvb, int offset_after_etype,
 
 		/* Add the trailer, if appropriate. */
 		add_dix_trailer(fh_tree, trailer_id, tvb, next_tvb,
-		    offset_after_etype, length_before);
+		    offset_after_etype, length_before, fcs_len);
 
 		/* Put back the protocol for which the exception is
 		   thrown, and rethrow the exception, so the
@@ -233,12 +234,13 @@ ethertype(guint16 etype, tvbuff_t *tvb, int offset_after_etype,
 	}
 
 	add_dix_trailer(fh_tree, trailer_id, tvb, next_tvb, offset_after_etype,
-	    length_before);
+	    length_before, fcs_len);
 }
 
 static void
 add_dix_trailer(proto_tree *fh_tree, int trailer_id, tvbuff_t *tvb,
-    tvbuff_t *next_tvb, int offset_after_etype, guint length_before)
+    tvbuff_t *next_tvb, int offset_after_etype, guint length_before,
+    gint fcs_len)
 {
 	guint		length;
 	tvbuff_t	*volatile trailer_tvb;
@@ -271,10 +273,9 @@ add_dix_trailer(proto_tree *fh_tree, int trailer_id, tvbuff_t *tvb,
 	} else
 		trailer_tvb = NULL;	/* no trailer */
 
-	add_ethernet_trailer(fh_tree, trailer_id, tvb, trailer_tvb);
+	add_ethernet_trailer(fh_tree, trailer_id, tvb, trailer_tvb, fcs_len);
 }
 
-
 void
 proto_register_ethertype(void)
 {
@@ -284,6 +285,7 @@ proto_register_ethertype(void)
 }
 
 void
-proto_reg_handoff_ethertype(void){
-  data_handle = find_dissector("data");
+proto_reg_handoff_ethertype(void)
+{
+	data_handle = find_dissector("data");
 }
diff --git a/packet-fw1.c b/packet-fw1.c
index 55f2d3e183..5795e29b61 100644
--- a/packet-fw1.c
+++ b/packet-fw1.c
@@ -2,7 +2,7 @@
  * Routines for Ethernet header disassembly of FW1 "monitor" files
  * Copyright 2002,2003, Alfred Koebler <ako@icon.de>
  *
- * $Id: packet-fw1.c,v 1.8 2003/08/16 00:29:15 guy Exp $
+ * $Id: packet-fw1.c,v 1.9 2003/10/01 07:11:44 guy Exp $
  *
  * Ethereal - Network traffic analyzer
  * By Alfred Koebler <ako@icon.de>
@@ -233,7 +233,7 @@ dissect_fw1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
     }
   }
   ethertype(etype, tvb, ETH_HEADER_SIZE, pinfo, tree, fh_tree, hf_fw1_type,
-          hf_fw1_trailer);
+          hf_fw1_trailer, 0);
 }
 
 void
diff --git a/packet-ieee8023.c b/packet-ieee8023.c
index 3822bcf8bf..0fd484f988 100644
--- a/packet-ieee8023.c
+++ b/packet-ieee8023.c
@@ -1,7 +1,7 @@
 /* packet-ieee8023.c
  * Routine for dissecting 802.3 (as opposed to D/I/X Ethernet) packets.
  *
- * $Id: packet-ieee8023.c,v 1.5 2003/08/21 21:05:30 guy Exp $
+ * $Id: packet-ieee8023.c,v 1.6 2003/10/01 07:11:44 guy Exp $
  *
  * Ethereal - Network traffic analyzer
  * By Gerald Combs <gerald@ethereal.com>
@@ -37,7 +37,8 @@ static dissector_handle_t llc_handle;
 void
 dissect_802_3(int length, gboolean is_802_2, tvbuff_t *tvb,
 	      int offset_after_length, packet_info *pinfo, proto_tree *tree,
-	      proto_tree *fh_tree, int length_id, int trailer_id)
+	      proto_tree *fh_tree, int length_id, int trailer_id,
+	      int fcs_len)
 {
   tvbuff_t		*volatile next_tvb;
   tvbuff_t		*volatile trailer_tvb;
@@ -87,7 +88,7 @@ dissect_802_3(int length, gboolean is_802_2, tvbuff_t *tvb,
   }
   CATCH2(BoundsError, ReportedBoundsError) {
     /* Well, somebody threw an exception.  Add the trailer, if appropriate. */
-    add_ethernet_trailer(fh_tree, trailer_id, tvb, trailer_tvb);
+    add_ethernet_trailer(fh_tree, trailer_id, tvb, trailer_tvb, fcs_len);
 
     /* Rethrow the exception, so the "Short Frame" or "Mangled Frame"
        indication can be put into the tree. */
@@ -98,7 +99,7 @@ dissect_802_3(int length, gboolean is_802_2, tvbuff_t *tvb,
   }
   ENDTRY;
 
-  add_ethernet_trailer(fh_tree, trailer_id, tvb, trailer_tvb);
+  add_ethernet_trailer(fh_tree, trailer_id, tvb, trailer_tvb, fcs_len);
 }
 
 void
diff --git a/packet-ieee8023.h b/packet-ieee8023.h
index 60ad4d329f..533b59cd96 100644
--- a/packet-ieee8023.h
+++ b/packet-ieee8023.h
@@ -2,7 +2,7 @@
  * Declaration of routine for dissecting 802.3 (as opposed to D/I/X Ethernet)
  * packets.
  *
- * $Id: packet-ieee8023.h,v 1.2 2002/08/28 21:00:17 jmayer Exp $
+ * $Id: packet-ieee8023.h,v 1.3 2003/10/01 07:11:44 guy Exp $
  *
  * Ethereal - Network traffic analyzer
  * By Gerald Combs <gerald@zing.org>
@@ -29,6 +29,6 @@
 
 void dissect_802_3(int length, gboolean is_802_2, tvbuff_t *tvb,
     int offset_after_length, packet_info *pinfo, proto_tree *tree,
-    proto_tree *fh_tree, int length_id, int trailer_id);
+    proto_tree *fh_tree, int length_id, int trailer_id, int fcs_len);
 
 #endif
diff --git a/packet-llc.c b/packet-llc.c
index aa06bb5e07..3bd505e93d 100644
--- a/packet-llc.c
+++ b/packet-llc.c
@@ -2,7 +2,7 @@
  * Routines for IEEE 802.2 LLC layer
  * Gilbert Ramirez <gram@alumni.rice.edu>
  *
- * $Id: packet-llc.c,v 1.115 2003/09/03 06:38:15 guy Exp $
+ * $Id: packet-llc.c,v 1.116 2003/10/01 07:11:44 guy Exp $
  *
  * Ethereal - Network traffic analyzer
  * By Gerald Combs <gerald@ethereal.com>
@@ -446,7 +446,7 @@ dissect_snap(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree,
 		   packet type for AARP packets. */
 		if (XDLC_IS_INFORMATION(control)) {
 			ethertype(etype, tvb, offset+5,
-			    pinfo, tree, snap_tree, hf_type, -1);
+			    pinfo, tree, snap_tree, hf_type, -1, 0);
 		} else {
 			next_tvb = tvb_new_subset(tvb, offset+5, -1, -1);
 			call_dissector(data_handle,next_tvb, pinfo, tree);
diff --git a/packet-null.c b/packet-null.c
index 56256fbaa7..77e9022419 100644
--- a/packet-null.c
+++ b/packet-null.c
@@ -1,7 +1,7 @@
 /* packet-null.c
  * Routines for null packet disassembly
  *
- * $Id: packet-null.c,v 1.59 2003/08/26 05:52:50 guy Exp $
+ * $Id: packet-null.c,v 1.60 2003/10/01 07:11:44 guy Exp $
  *
  * Ethereal - Network traffic analyzer
  * By Gerald Combs <gerald@ethereal.com>
@@ -264,7 +264,8 @@ dissect_null(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
         fh_tree = proto_item_add_subtree(ti, ett_null);
       } else
       	fh_tree = NULL;
-      ethertype(null_header, tvb, 4, pinfo, tree, fh_tree, hf_null_etype, -1);
+      ethertype(null_header, tvb, 4, pinfo, tree, fh_tree, hf_null_etype, -1,
+	0);
     } else {
       /* populate a tree in the second pane with the status of the link
          layer (ie none) */
diff --git a/packet-sll.c b/packet-sll.c
index da07b71394..a8787a1f98 100644
--- a/packet-sll.c
+++ b/packet-sll.c
@@ -1,7 +1,7 @@
 /* packet-sll.c
  * Routines for disassembly of packets from Linux "cooked mode" captures
  *
- * $Id: packet-sll.c,v 1.19 2002/08/28 21:00:31 jmayer Exp $
+ * $Id: packet-sll.c,v 1.20 2003/10/01 07:11:44 guy Exp $
  *
  * Ethereal - Network traffic analyzer
  * By Gerald Combs <gerald@ethereal.com>
@@ -218,7 +218,7 @@ dissect_sll(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
 		}
 	} else {
 		ethertype(protocol, tvb, SLL_HEADER_SIZE, pinfo, tree,
-		    fh_tree, hf_sll_etype, hf_sll_trailer);
+		    fh_tree, hf_sll_etype, hf_sll_trailer, 0);
 	}
 }
 
diff --git a/packet-vlan.c b/packet-vlan.c
index cfc6bb1a0e..5a43b697fb 100644
--- a/packet-vlan.c
+++ b/packet-vlan.c
@@ -1,7 +1,7 @@
 /* packet-vlan.c
  * Routines for VLAN 802.1Q ethernet header disassembly
  *
- * $Id: packet-vlan.c,v 1.42 2003/01/31 03:17:47 guy Exp $
+ * $Id: packet-vlan.c,v 1.43 2003/10/01 07:11:45 guy Exp $
  *
  * Ethereal - Network traffic analyzer
  * By Gerald Combs <gerald@ethereal.com>
@@ -116,10 +116,10 @@ dissect_vlan(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
     ENDTRY;
 
     dissect_802_3(encap_proto, is_802_2, tvb, 4, pinfo, tree, vlan_tree,
-		  hf_vlan_len, hf_vlan_trailer);
+		  hf_vlan_len, hf_vlan_trailer, 0);
   } else {
     ethertype(encap_proto, tvb, 4, pinfo, tree, vlan_tree,
-		       hf_vlan_etype, hf_vlan_trailer);
+		       hf_vlan_etype, hf_vlan_trailer, 0);
   }
 }
 
diff --git a/wiretap/5views.c b/wiretap/5views.c
index baf70a3112..327653e8f2 100644
--- a/wiretap/5views.c
+++ b/wiretap/5views.c
@@ -1,6 +1,6 @@
 /* 5views.c
  *
- * $Id: 5views.c,v 1.2 2003/07/29 20:26:34 guy Exp $
+ * $Id: 5views.c,v 1.3 2003/10/01 07:11:46 guy Exp $
  *
  * Wiretap Library
  * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>
@@ -251,6 +251,14 @@ _5views_read(wtap *wth, int *err, long *data_offset)
 	wth->phdr.len = orig_size;
 	wth->phdr.pkt_encap = wth->file_encap;
 
+	switch (wth->file_encap) {
+
+	case WTAP_ENCAP_ETHERNET:
+		/* We assume there's no FCS in this frame. */
+		wth->pseudo_header.eth.fcs_len = 0;
+		break;
+	}
+
 	return TRUE;
 }
 
@@ -301,7 +309,7 @@ _5views_read_header(wtap *wth _U_, FILE_T fh, t_5VW_TimeStamped_Header  *hdr,
 
 static gboolean
 _5views_seek_read(wtap *wth, long seek_off,
-    union wtap_pseudo_header *pseudo_header _U_, guchar *pd, int length, int *err)
+    union wtap_pseudo_header *pseudo_header, guchar *pd, int length, int *err)
 {
 	if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)
 		return FALSE;
@@ -311,6 +319,13 @@ _5views_seek_read(wtap *wth, long seek_off,
 	if (!_5views_read_rec_data(wth->random_fh, pd, length, err))
 		return FALSE;
 
+	switch (wth->file_encap) {
+
+	case WTAP_ENCAP_ETHERNET:
+		/* We assume there's no FCS in this frame. */
+		pseudo_header->eth.fcs_len = 0;
+		break;
+	}
 
 	return TRUE;
 }
diff --git a/wiretap/erf.c b/wiretap/erf.c
index ac1cd7eff3..6c650b9b16 100644
--- a/wiretap/erf.c
+++ b/wiretap/erf.c
@@ -32,7 +32,7 @@
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
-* $Id: erf.c,v 1.3 2003/09/19 04:08:11 guy Exp $
+* $Id: erf.c,v 1.4 2003/10/01 07:11:46 guy Exp $
 */
 
 /* 
@@ -69,7 +69,7 @@ static gboolean erf_seek_read(wtap *wth, long seek_off,
 		int length, int *err);
 static void erf_close(wtap *wth);
 static int erf_encap_to_wtap_encap(erf_t *erf, guint8 erf_encap);
-static void erf_guess_atm_traffic_type(
+static void erf_set_pseudo_header(
 		guint8 type,
 		erf_t *erf,
 		guchar *pd,
@@ -245,7 +245,7 @@ static gboolean erf_read(wtap *wth, int *err, long *data_offset)
 	);
 	wth->data_offset += packet_size;
 
-	erf_guess_atm_traffic_type(
+	erf_set_pseudo_header(
 			erf_header.type, wth->capture.erf,
 			buffer_start_ptr(wth->frame_buffer), packet_size, &wth->pseudo_header
 	);
@@ -274,7 +274,7 @@ static gboolean erf_seek_read(wtap *wth, long seek_off,
 
 	wtap_file_read_expected_bytes(pd+offset, (int)packet_size, wth->random_fh, err);
 
-	erf_guess_atm_traffic_type(erf_header.type, wth->capture.erf, pd, length, pseudo_header);
+	erf_set_pseudo_header(erf_header.type, wth->capture.erf, pd, length, pseudo_header);
 
 	return TRUE;
 }
@@ -435,9 +435,15 @@ static int erf_encap_to_wtap_encap(erf_t *erf, guint8 erf_encap)
 	return wtap_encap;
 }
 
-static void erf_guess_atm_traffic_type(
+static void erf_set_pseudo_header(
 	guint8 type, erf_t *erf, guchar *pd, int length, union wtap_pseudo_header *pseudo_header)
 {
+	if (type == TYPE_ETH) {
+		/*
+		 * We don't know whether there's an FCS in this frame or not.
+		 */
+		pseudo_header->eth.fcs_len = -1;
+	} else
 	if (!erf->is_rawatm &&
 			(type == TYPE_ATM || type == TYPE_AAL5) &&
 			(erf->atm_encap == WTAP_ENCAP_ATM_PDUS ||
@@ -450,5 +456,3 @@ static void erf_guess_atm_traffic_type(
 		pseudo_header->atm.subtype = TRAF_ST_UNKNOWN;
 	}
 }
-
-
diff --git a/wiretap/etherpeek.c b/wiretap/etherpeek.c
index 6cf684a5cb..13591ab523 100644
--- a/wiretap/etherpeek.c
+++ b/wiretap/etherpeek.c
@@ -2,7 +2,7 @@
  * Routines for opening EtherPeek (and TokenPeek?) files
  * Copyright (c) 2001, Daniel Thompson <d.thompson@gmx.net>
  *
- * $Id: etherpeek.c,v 1.23 2003/06/25 17:35:16 guy Exp $
+ * $Id: etherpeek.c,v 1.24 2003/10/01 07:11:46 guy Exp $
  *
  * Wiretap Library
  * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>
@@ -140,6 +140,8 @@ static gboolean etherpeek_read_v7(wtap *wth, int *err, long *data_offset);
 static gboolean etherpeek_seek_read_v7(wtap *wth, long seek_off,
     union wtap_pseudo_header *pseudo_header, guchar *pd, int length, int *err);
 static gboolean etherpeek_read_v56(wtap *wth, int *err, long *data_offset);
+static gboolean etherpeek_seek_read_v56(wtap *wth, long seek_off,
+    union wtap_pseudo_header *pseudo_header, guchar *pd, int length, int *err);
 static void etherpeek_close(wtap *wth);
 
 int etherpeek_open(wtap *wth, int *err)
@@ -308,7 +310,7 @@ int etherpeek_open(wtap *wth, int *err)
 		 */
 		wth->file_encap = WTAP_ENCAP_PER_PACKET;
 		wth->subtype_read = etherpeek_read_v56;
-		wth->subtype_seek_read = wtap_def_seek_read;
+		wth->subtype_seek_read = etherpeek_seek_read_v56;
 		break;
 
 	case 7:
@@ -345,6 +347,8 @@ static gboolean etherpeek_read_v7(wtap *wth, int *err, long *data_offset)
 	double  t;
 	airopeek_radio_hdr_t radio_hdr;
 
+	*data_offset = wth->data_offset;
+
 	wtap_file_read_expected_bytes(ep_pkt, sizeof(ep_pkt), wth->fh, err);
 	wth->data_offset += sizeof(ep_pkt);
 
@@ -362,8 +366,6 @@ static gboolean etherpeek_read_v7(wtap *wth, int *err, long *data_offset)
 		sliceLength = length;
 	}
 
-	*data_offset = wth->data_offset;
-
 	/* fill in packet header length values before slicelength may be
 	   adjusted */
 	wth->phdr.len    = length;
@@ -372,7 +374,9 @@ static gboolean etherpeek_read_v7(wtap *wth, int *err, long *data_offset)
 	if (sliceLength % 2) /* packets are padded to an even length */
 		sliceLength++;
 
-	if (wth->file_encap == WTAP_ENCAP_IEEE_802_11_WITH_RADIO) {
+	switch (wth->file_encap) {
+
+	case WTAP_ENCAP_IEEE_802_11_WITH_RADIO:
 		/*
 		 * The first 4 bytes of the packet data are radio
 		 * information (including a reserved byte).
@@ -397,6 +401,14 @@ static gboolean etherpeek_read_v7(wtap *wth, int *err, long *data_offset)
 		wth->pseudo_header.ieee_802_11.channel = radio_hdr.channel;
 		wth->pseudo_header.ieee_802_11.data_rate = radio_hdr.data_rate;
 		wth->pseudo_header.ieee_802_11.signal_level = radio_hdr.signal_level;
+		break;
+
+	case WTAP_ENCAP_ETHERNET:
+		/* XXX - it appears that if the low-order bit of
+		   "status" is 0, there's an FCS in this frame,
+		   and if it's 1, there's 4 bytes of 0. */
+		wth->pseudo_header.eth.fcs_len = (status & 0x01) ? 0 : 4;
+		break;
 	}
 
 	/* read the frame data */
@@ -434,12 +446,21 @@ static gboolean
 etherpeek_seek_read_v7(wtap *wth, long seek_off,
     union wtap_pseudo_header *pseudo_header, guchar *pd, int length, int *err)
 {
+	guchar ep_pkt[ETHERPEEK_V7_PKT_SIZE];
+	guint8  status;
 	airopeek_radio_hdr_t radio_hdr;
 
 	if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)
 		return FALSE;
 
-	if (wth->file_encap == WTAP_ENCAP_IEEE_802_11_WITH_RADIO) {
+	/* Read the packet header. */
+	wtap_file_read_expected_bytes(ep_pkt, sizeof(ep_pkt), wth->random_fh,
+	    err);
+	status = ep_pkt[ETHERPEEK_V7_STATUS_OFFSET];
+
+	switch (wth->file_encap) {
+
+	case WTAP_ENCAP_IEEE_802_11_WITH_RADIO:
 		/*
 		 * The first 4 bytes of the packet data are radio
 		 * information (including a reserved byte).
@@ -457,6 +478,14 @@ etherpeek_seek_read_v7(wtap *wth, long seek_off,
 		pseudo_header->ieee_802_11.channel = radio_hdr.channel;
 		pseudo_header->ieee_802_11.data_rate = radio_hdr.data_rate;
 		pseudo_header->ieee_802_11.signal_level = radio_hdr.signal_level;
+		break;
+
+	case WTAP_ENCAP_ETHERNET:
+		/* XXX - it appears that if the low-order bit of
+		   "status" is 0, there's an FCS in this frame,
+		   and if it's 1, there's 4 bytes of 0. */
+		pseudo_header->eth.fcs_len = (status & 0x01) ? 0 : 4;
+		break;
 	}
 
 	/*
@@ -481,6 +510,18 @@ static gboolean etherpeek_read_v56(wtap *wth, int *err, long *data_offset)
 	char    protoStr[8];
 	unsigned int i;
 
+	/*
+	 * XXX - in order to figure out whether this packet is an
+	 * Ethernet packet or not, we have to look at the packet
+	 * header, so we have to remember the address of the header,
+	 * not the address of the data, for random access.
+	 *
+	 * If we can determine that from the file header, rather than
+	 * the packet header, we can remember the offset of the data,
+	 * and not have the seek_read routine read the header.
+	 */
+	*data_offset = wth->data_offset;
+
 	wtap_file_read_expected_bytes(ep_pkt, sizeof(ep_pkt), wth->fh, err);
 	wth->data_offset += sizeof(ep_pkt);
 
@@ -506,7 +547,11 @@ static gboolean etherpeek_read_v56(wtap *wth, int *err, long *data_offset)
 		sliceLength = length;
 	}
 
-	*data_offset = wth->data_offset;
+	/* read the frame data */
+	buffer_assure_space(wth->frame_buffer, sliceLength);
+	wtap_file_read_expected_bytes(buffer_start_ptr(wth->frame_buffer),
+	                              sliceLength, wth->fh, err);
+	wth->data_offset += sliceLength;
 
 	/* fill in packet header values */
 	wth->phdr.len        = length;
@@ -523,5 +568,51 @@ static gboolean etherpeek_read_v56(wtap *wth, int *err, long *data_offset)
 		}
 	}
 
+	switch (wth->phdr.pkt_encap) {
+
+	case WTAP_ENCAP_ETHERNET:
+		/* We assume there's no FCS in this frame. */
+		wth->pseudo_header.eth.fcs_len = 0;
+		break;
+	}
+	return TRUE;
+}
+
+static gboolean
+etherpeek_seek_read_v56(wtap *wth, long seek_off,
+    union wtap_pseudo_header *pseudo_header, guchar *pd, int length, int *err)
+{
+	guchar ep_pkt[ETHERPEEK_V56_PKT_SIZE];
+	int pkt_encap;
+	guint16 protoNum;
+	unsigned int i;
+
+	if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)
+		return FALSE;
+
+	wtap_file_read_expected_bytes(ep_pkt, sizeof(ep_pkt), wth->random_fh,
+	    err);
+
+	protoNum = pntohs(&ep_pkt[ETHERPEEK_V56_PROTONUM_OFFSET]);
+	pkt_encap = WTAP_ENCAP_UNKNOWN;
+	for (i=0; i<NUM_ETHERPEEK_ENCAPS; i++) {
+		if (etherpeek_encap[i].protoNum == protoNum) {
+			pkt_encap = etherpeek_encap[i].encap;
+		}
+	}
+
+	switch (pkt_encap) {
+
+	case WTAP_ENCAP_ETHERNET:
+		/* We assume there's no FCS in this frame. */
+		pseudo_header->eth.fcs_len = 0;
+		break;
+	}
+
+	/*
+	 * XXX - should "errno" be set in "wtap_file_read_expected_bytes()"?
+	 */
+	errno = WTAP_ERR_CANT_READ;
+	wtap_file_read_expected_bytes(pd, length, wth->random_fh, err);
 	return TRUE;
 }
diff --git a/wiretap/file_access.c b/wiretap/file_access.c
index 25d7a92584..74e4bb6260 100644
--- a/wiretap/file_access.c
+++ b/wiretap/file_access.c
@@ -1,6 +1,6 @@
 /* file_access.c
  *
- * $Id: file_access.c,v 1.2 2003/08/26 07:10:38 guy Exp $
+ * $Id: file_access.c,v 1.3 2003/10/01 07:11:47 guy Exp $
  *
  * Wiretap Library
  * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>
@@ -124,25 +124,6 @@ static int (*const open_routines[])(wtap *, int *) = {
 
 #define	N_FILE_TYPES	(sizeof open_routines / sizeof open_routines[0])
 
-gboolean wtap_def_seek_read(wtap *wth, long seek_off,
-	union wtap_pseudo_header *pseudo_header _U_,
-	guint8 *pd, int len, int *err)
-{
-	int bytes_read;
-
-	if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)
-		return FALSE;
-
-	bytes_read = file_read(pd, sizeof(guint8), len, wth->random_fh);
-	if (bytes_read != len) {
-		*err = file_error(wth->random_fh);
-		if (*err == 0)
-			*err = WTAP_ERR_SHORT_READ;
-		return FALSE;
-	}
-	return TRUE;
-}
-
 /*
  * Visual C++ on Win32 systems doesn't define these.  (Old UNIX systems don't
  * define them either.)
diff --git a/wiretap/iptrace.c b/wiretap/iptrace.c
index 8f5d2a9775..ddf2f1e114 100644
--- a/wiretap/iptrace.c
+++ b/wiretap/iptrace.c
@@ -1,6 +1,6 @@
 /* iptrace.c
  *
- * $Id: iptrace.c,v 1.47 2003/01/10 04:04:41 guy Exp $
+ * $Id: iptrace.c,v 1.48 2003/10/01 07:11:47 guy Exp $
  *
  * Wiretap Library
  * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>
@@ -46,7 +46,7 @@ static int iptrace_read_rec_header(FILE_T fh, guint8 *header, int header_len,
     int *err);
 static gboolean iptrace_read_rec_data(FILE_T fh, guint8 *data_ptr,
     int packet_size, int *err);
-static void get_atm_pseudo_header(const guint8 *pd, guint32 len,
+static void fill_in_pseudo_header(int encap, const guint8 *pd, guint32 len,
     union wtap_pseudo_header *pseudo_header, guint8 *header);
 static int wtap_encap_ift(unsigned int  ift);
 
@@ -186,10 +186,9 @@ static gboolean iptrace_read_1_0(wtap *wth, int *err, long *data_offset)
 		return FALSE;
 	}
 
-	if (wth->phdr.pkt_encap == WTAP_ENCAP_ATM_PDUS) {
-		get_atm_pseudo_header(data_ptr, wth->phdr.caplen,
-		    &wth->pseudo_header, header);
-	}
+	/* Fill in the pseudo-header. */
+	fill_in_pseudo_header(wth->phdr.pkt_encap, data_ptr, wth->phdr.caplen,
+	    &wth->pseudo_header, header);
 
 	/* If the per-file encapsulation isn't known, set it to this
 	   packet's encapsulation.
@@ -252,9 +251,9 @@ static gboolean iptrace_seek_read_1_0(wtap *wth, long seek_off,
 	if (!iptrace_read_rec_data(wth->random_fh, pd, packet_size, err))
 		return FALSE;
 
-	/* Get the ATM pseudo-header, if this is ATM traffic. */
-	if (pkt_encap == WTAP_ENCAP_ATM_PDUS)
-		get_atm_pseudo_header(pd, packet_size, pseudo_header, header);
+	/* Fill in the pseudo_header. */
+	fill_in_pseudo_header(pkt_encap, pd, packet_size, pseudo_header,
+	    header);
 
 	return TRUE;
 }
@@ -369,10 +368,9 @@ static gboolean iptrace_read_2_0(wtap *wth, int *err, long *data_offset)
 		return FALSE;
 	}
 
-	if (wth->phdr.pkt_encap == WTAP_ENCAP_ATM_PDUS) {
-		get_atm_pseudo_header(data_ptr, wth->phdr.caplen,
-		    &wth->pseudo_header, header);
-	}
+	/* Fill in the pseudo-header. */
+	fill_in_pseudo_header(wth->phdr.pkt_encap, data_ptr, wth->phdr.caplen,
+	    &wth->pseudo_header, header);
 
 	/* If the per-file encapsulation isn't known, set it to this
 	   packet's encapsulation.
@@ -435,9 +433,9 @@ static gboolean iptrace_seek_read_2_0(wtap *wth, long seek_off,
 	if (!iptrace_read_rec_data(wth->random_fh, pd, packet_size, err))
 		return FALSE;
 
-	/* Get the ATM pseudo-header, if this is ATM traffic. */
-	if (pkt_encap == WTAP_ENCAP_ATM_PDUS)
-		get_atm_pseudo_header(pd, packet_size, pseudo_header, header);
+	/* Fill in the pseudo-header. */
+	fill_in_pseudo_header(pkt_encap, pd, packet_size, pseudo_header,
+	    header);
 
 	return TRUE;
 }
@@ -480,15 +478,16 @@ iptrace_read_rec_data(FILE_T fh, guint8 *data_ptr, int packet_size, int *err)
 }
 
 /*
- * Fill in the pseudo-header information we can; alas, "iptrace" doesn't
- * tell us what type of traffic is in the packet - it was presumably
- * run on a machine that was one of the endpoints of the connection, so
- * in theory it could presumably have told us, but, for whatever reason,
- * it failed to do so - perhaps the low-level mechanism that feeds the
- * presumably-AAL5 frames to us doesn't have access to that information
- * (e.g., because it's in the ATM driver, and the ATM driver merely knows
- * that stuff on VPI/VCI X.Y should be handed up to some particular
- * client, it doesn't know what that client is).
+ * Fill in the pseudo-header information we can.
+ *
+ * For ATM traffic, "iptrace", alas, doesn't tell us what type of traffic
+ * is in the packet - it was presumably run on a machine that was one of
+ * the endpoints of the connection, so in theory it could presumably have
+ * told us, but, for whatever reason, it failed to do so - perhaps the
+ * low-level mechanism that feeds the presumably-AAL5 frames to us doesn't
+ * have access to that information (e.g., because it's in the ATM driver,
+ * and the ATM driver merely knows that stuff on VPI/VCI X.Y should be
+ * handed up to some particular client, it doesn't know what that client is).
  *
  * We let our caller try to figure out what kind of traffic it is, either
  * by guessing based on the VPI/VCI, guessing based on the header of the
@@ -496,7 +495,7 @@ iptrace_read_rec_data(FILE_T fh, guint8 *data_ptr, int packet_size, int *err)
  * in some fashion what sort of traffic it is, or being told by the user.
  */
 static void
-get_atm_pseudo_header(const guint8 *pd, guint32 len,
+fill_in_pseudo_header(int encap, const guint8 *pd, guint32 len,
     union wtap_pseudo_header *pseudo_header, guint8 *header)
 {
 	char	if_text[9];
@@ -504,38 +503,48 @@ get_atm_pseudo_header(const guint8 *pd, guint32 len,
 	int	Vpi = 0;
 	int	Vci = 0;
 
-	/* Rip apart the "x.y" text into Vpi/Vci numbers */
-	memcpy(if_text, &header[20], 8);
-	if_text[8] = '\0';
-	decimal = strchr(if_text, '.');
-	if (decimal) {
-		*decimal = '\0';
-		Vpi = strtoul(if_text, NULL, 10);
-		decimal++;
-		Vci = strtoul(decimal, NULL, 10);
-	}
+	switch (encap) {
+
+	case WTAP_ENCAP_ATM_PDUS:
+		/* Rip apart the "x.y" text into Vpi/Vci numbers */
+		memcpy(if_text, &header[20], 8);
+		if_text[8] = '\0';
+		decimal = strchr(if_text, '.');
+		if (decimal) {
+			*decimal = '\0';
+			Vpi = strtoul(if_text, NULL, 10);
+			decimal++;
+			Vci = strtoul(decimal, NULL, 10);
+		}
 
-	/*
-	 * OK, which value means "DTE->DCE" and which value means
-	 * "DCE->DTE"?
-	 */
-	pseudo_header->atm.channel = header[29];
+		/*
+		 * OK, which value means "DTE->DCE" and which value means
+		 * "DCE->DTE"?
+		 */
+		pseudo_header->atm.channel = header[29];
 
-	pseudo_header->atm.vpi = Vpi;
-	pseudo_header->atm.vci = Vci;
+		pseudo_header->atm.vpi = Vpi;
+		pseudo_header->atm.vci = Vci;
 
-	/*
-	 * Attempt to guess from the packet data, the VPI, and the VCI
-	 * information about the type of traffic.
-	 */
-	atm_guess_traffic_type(pd, len, pseudo_header);
-
-	/* We don't have this information */
-	pseudo_header->atm.flags = 0;
-	pseudo_header->atm.cells = 0;
-	pseudo_header->atm.aal5t_u2u = 0;
-	pseudo_header->atm.aal5t_len = 0;
-	pseudo_header->atm.aal5t_chksum = 0;
+		/*
+		 * Attempt to guess from the packet data, the VPI,
+		 * and the VCI information about the type of traffic.
+		 */
+		atm_guess_traffic_type(pd, len, pseudo_header);
+
+		/* We don't have this information */
+		pseudo_header->atm.flags = 0;
+		pseudo_header->atm.cells = 0;
+		pseudo_header->atm.aal5t_u2u = 0;
+		pseudo_header->atm.aal5t_len = 0;
+		pseudo_header->atm.aal5t_chksum = 0;
+		break;
+
+	case WTAP_ENCAP_ETHERNET:
+		/* We assume there's no FCS in this frame. */
+		pseudo_header->eth.fcs_len = 0;
+		break;
+	}
 }
 
 /* Given an RFC1573 (SNMP ifType) interface type,
diff --git a/wiretap/lanalyzer.c b/wiretap/lanalyzer.c
index 0675da026d..6b27df5b18 100644
--- a/wiretap/lanalyzer.c
+++ b/wiretap/lanalyzer.c
@@ -1,6 +1,6 @@
 /* lanalyzer.c
  *
- * $Id: lanalyzer.c,v 1.39 2003/07/29 20:30:00 guy Exp $
+ * $Id: lanalyzer.c,v 1.40 2003/10/01 07:11:47 guy Exp $
  *
  * Wiretap Library
  * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>
@@ -118,6 +118,8 @@ static const gint8 LA_CyclicInformationFake[] = {
       };
 
 static gboolean lanalyzer_read(wtap *wth, int *err, long *data_offset);
+static gboolean lanalyzer_seek_read(wtap *wth, long seek_off,
+    union wtap_pseudo_header *pseudo_header, guchar *pd, int length, int *err);
 static void     lanalyzer_close(wtap *wth);
 static gboolean lanalyzer_dump_close(wtap_dumper *wdh, int *err);
 
@@ -155,7 +157,7 @@ int lanalyzer_open(wtap *wth, int *err)
 	wth->file_type = WTAP_FILE_LANALYZER;
 	wth->capture.lanalyzer = g_malloc(sizeof(lanalyzer_t));
 	wth->subtype_read = lanalyzer_read;
-	wth->subtype_seek_read = wtap_def_seek_read;
+	wth->subtype_seek_read = lanalyzer_seek_read;
 	wth->subtype_close = lanalyzer_close;
 	wth->snapshot_length = 0;
 
@@ -384,6 +386,44 @@ static gboolean lanalyzer_read(wtap *wth, int *err, long *data_offset)
 	wth->phdr.caplen = packet_size;
 	wth->phdr.pkt_encap = wth->file_encap;
 
+	switch (wth->file_encap) {
+
+	case WTAP_ENCAP_ETHERNET:
+		/* We assume there's no FCS in this frame. */
+		wth->pseudo_header.eth.fcs_len = 0;
+		break;
+	}
+
+	return TRUE;
+}
+
+static gboolean lanalyzer_seek_read(wtap *wth, long seek_off,
+    union wtap_pseudo_header *pseudo_header, guchar *pd, int length, int *err)
+{
+	int bytes_read;
+
+	if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)
+		return FALSE;
+
+	/*
+	 * Read the packet data.
+	 */
+	bytes_read = file_read(pd, sizeof(guint8), length, wth->random_fh);
+	if (bytes_read != length) {
+		*err = file_error(wth->random_fh);
+		if (*err == 0)
+			*err = WTAP_ERR_SHORT_READ;
+		return FALSE;
+	}
+
+	switch (wth->file_encap) {
+
+	case WTAP_ENCAP_ETHERNET:
+		/* We assume there's no FCS in this frame. */
+		pseudo_header->eth.fcs_len = 0;
+		break;
+	}
+
 	return TRUE;
 }
 
diff --git a/wiretap/libpcap.c b/wiretap/libpcap.c
index 9d488c6835..269a7e6afe 100644
--- a/wiretap/libpcap.c
+++ b/wiretap/libpcap.c
@@ -1,6 +1,6 @@
 /* libpcap.c
  *
- * $Id: libpcap.c,v 1.97 2003/09/04 06:40:45 guy Exp $
+ * $Id: libpcap.c,v 1.98 2003/10/01 07:11:47 guy Exp $
  *
  * Wiretap Library
  * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>
@@ -949,7 +949,9 @@ static gboolean libpcap_read(wtap *wth, int *err, long *data_offset)
 	 * the VCI; read them and generate the pseudo-header from
 	 * them.
 	 */
-	if (wth->file_encap == WTAP_ENCAP_ATM_PDUS) {
+	switch (wth->file_encap) {
+
+	case WTAP_ENCAP_ATM_PDUS:
 		if (packet_size < sizeof (struct sunatm_hdr)) {
 			/*
 			 * Uh-oh, the packet isn't big enough to even
@@ -970,6 +972,14 @@ static gboolean libpcap_read(wtap *wth, int *err, long *data_offset)
 		orig_size -= sizeof (struct sunatm_hdr);
 		packet_size -= sizeof (struct sunatm_hdr);
 		wth->data_offset += sizeof (struct sunatm_hdr);
+		break;
+
+	case WTAP_ENCAP_ETHERNET:
+		/*
+		 * We don't know whether there's an FCS in this frame or not.
+		 */
+		wth->pseudo_header.eth.fcs_len = -1;
+		break;
 	}
 
 	buffer_assure_space(wth->frame_buffer, packet_size);
@@ -1004,12 +1014,22 @@ libpcap_seek_read(wtap *wth, long seek_off,
 	if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)
 		return FALSE;
 
-	if (wth->file_encap == WTAP_ENCAP_ATM_PDUS) {
+	switch (wth->file_encap) {
+
+	case WTAP_ENCAP_ATM_PDUS:
 		if (!libpcap_read_atm_pseudoheader(wth->random_fh, pseudo_header,
 		    err)) {
 			/* Read error */
 			return FALSE;
 		}
+		break;
+
+	case WTAP_ENCAP_ETHERNET:
+		/*
+		 * We don't know whether there's an FCS in this frame or not.
+		 */
+		pseudo_header->eth.fcs_len = -1;
+		break;
 	}
 
 	/*
diff --git a/wiretap/netmon.c b/wiretap/netmon.c
index d760f59054..c5a2e96504 100644
--- a/wiretap/netmon.c
+++ b/wiretap/netmon.c
@@ -1,6 +1,6 @@
 /* netmon.c
  *
- * $Id: netmon.c,v 1.64 2003/01/10 04:04:41 guy Exp $
+ * $Id: netmon.c,v 1.65 2003/10/01 07:11:48 guy Exp $
  *
  * Wiretap Library
  * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>
@@ -392,7 +392,9 @@ static gboolean netmon_read(wtap *wth, int *err, long *data_offset)
 	 * and the VPI and VCI; read them and generate the pseudo-header
 	 * from them.
 	 */
-	if (wth->file_encap == WTAP_ENCAP_ATM_PDUS) {
+	switch (wth->file_encap) {
+
+	case WTAP_ENCAP_ATM_PDUS:
 		if (packet_size < sizeof (struct netmon_atm_hdr)) {
 			/*
 			 * Uh-oh, the packet isn't big enough to even
@@ -413,6 +415,14 @@ static gboolean netmon_read(wtap *wth, int *err, long *data_offset)
 		orig_size -= sizeof (struct netmon_atm_hdr);
 		packet_size -= sizeof (struct netmon_atm_hdr);
 		wth->data_offset += sizeof (struct netmon_atm_hdr);
+		break;
+
+	case WTAP_ENCAP_ETHERNET:
+		/*
+		 * We assume there's no FCS in this frame.
+		 */
+		wth->pseudo_header.eth.fcs_len = 0;
+		break;
 	}
 
 	buffer_assure_space(wth->frame_buffer, packet_size);
@@ -460,12 +470,22 @@ netmon_seek_read(wtap *wth, long seek_off,
 	if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)
 		return FALSE;
 
-	if (wth->file_encap == WTAP_ENCAP_ATM_PDUS) {
+	switch (wth->file_encap) {
+
+	case WTAP_ENCAP_ATM_PDUS:
 		if (!netmon_read_atm_pseudoheader(wth->random_fh, pseudo_header,
 		    err)) {
 			/* Read error */
 			return FALSE;
 		}
+		break;
+
+	case WTAP_ENCAP_ETHERNET:
+		/*
+		 * We assume there's no FCS in this frame.
+		 */
+		pseudo_header->eth.fcs_len = 0;
+		break;
 	}
 
 	/*
diff --git a/wiretap/nettl.c b/wiretap/nettl.c
index 0096b98a3a..a4252d4c06 100644
--- a/wiretap/nettl.c
+++ b/wiretap/nettl.c
@@ -1,6 +1,6 @@
 /* nettl.c
  *
- * $Id: nettl.c,v 1.32 2003/05/05 01:01:36 guy Exp $
+ * $Id: nettl.c,v 1.33 2003/10/01 07:11:48 guy Exp $
  *
  * Wiretap Library
  * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>
@@ -291,6 +291,8 @@ nettl_read_rec_header(wtap *wth, FILE_T fh, struct wtap_pkthdr *phdr,
 	    } else {
 		wth->file_encap = WTAP_ENCAP_ETHERNET;
 		phdr->pkt_encap = WTAP_ENCAP_ETHERNET;
+		/* We assume there's no FCS in this frame. */
+		pseudo_header->eth.fcs_len = 0;
 	    }
 
 	    bytes_read = file_read(&ip_hdr, 1, sizeof ip_hdr, fh);
@@ -368,6 +370,8 @@ nettl_read_rec_header(wtap *wth, FILE_T fh, struct wtap_pkthdr *phdr,
 	       we assumes everything is. We will crash and burn for anything else */
 	    /* for encapsulated 100baseT we do this */
 	    phdr->pkt_encap = WTAP_ENCAP_ETHERNET;
+	    /* We assume there's no FCS in this frame. */
+	    pseudo_header->eth.fcs_len = 0;
 	    bytes_read = file_read(&drv_eth_hdr, 1, sizeof drv_eth_hdr, fh);
 	    if (bytes_read != sizeof drv_eth_hdr) {
 		*err = file_error(fh);
diff --git a/wiretap/netxray.c b/wiretap/netxray.c
index 80f525b291..45f2a9044d 100644
--- a/wiretap/netxray.c
+++ b/wiretap/netxray.c
@@ -1,6 +1,6 @@
 /* netxray.c
  *
- * $Id: netxray.c,v 1.83 2003/09/28 23:15:40 guy Exp $
+ * $Id: netxray.c,v 1.84 2003/10/01 07:11:48 guy Exp $
  *
  * Wiretap Library
  * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>
@@ -156,7 +156,7 @@ static gboolean netxray_seek_read(wtap *wth, long seek_off,
     union wtap_pseudo_header *pseudo_header, guchar *pd, int length, int *err);
 static int netxray_read_rec_header(wtap *wth, FILE_T fh,
     union netxrayrec_hdr *hdr, int *err);
-static void netxray_set_pseudo_header(wtap *wth, const guint8 *pd, int len,
+static guint netxray_set_pseudo_header(wtap *wth, const guint8 *pd, int len,
     union wtap_pseudo_header *pseudo_header, union netxrayrec_hdr *hdr);
 static gboolean netxray_read_rec_data(FILE_T fh, guint8 *data_ptr,
     guint32 packet_size, int *err);
@@ -481,31 +481,33 @@ int netxray_open(wtap *wth, int *err)
 	wth->capture.netxray->version_major = version_major;
 
 	/*
-	 * End-of-packet padding.  802.11 captures appear to have four
-	 * bytes of it, as do some ISDN captures; those 4 bytes don't
-	 * show up as frame data.
-	 *
-	 * We've seen what appears to be an FCS at the end of some frames
-	 * in some Ethernet captures, but this stuff appears to be just
-	 * padding - Sniffers don't show it, and it doesn't have values
-	 * that look like FCS values, so it looks like padding.
+	 * If frames have an extra 4 bytes of stuff at the end, is
+	 * it an FCS, or just junk?
 	 */
-	wth->capture.netxray->padding = 0;
+	wth->capture.netxray->fcs_valid = FALSE;
 	switch (file_encap) {
 
+	case WTAP_ENCAP_ETHERNET:
 	case WTAP_ENCAP_IEEE_802_11_WITH_RADIO:
-		wth->capture.netxray->padding = 4;
-		break;
-
-	case WTAP_ENCAP_ISDN:
 		/*
-		 * The only captures we've seen with padding are PRI
-		 * captures; until we see PRI captures with no padding,
-		 * or BRI captures with padding, we assume that PRI
-		 * captures have padding and BRI captures don't.
+		 * It appears that, in at least some version 2 Ethernet
+		 * captures, for frames that have 0xff in hdr_2_x.xxx[2]
+		 * and hdr_2_x.xxx[3] in the per-packet header:
+		 *
+		 *	if, in the file header, hdr.xxb[13] is 0x34 and
+		 *	hdr.xxb[14] is 0x12, the frames have an FCS at
+		 *	the end;
+		 *
+		 *	otherwise, they have 4 bytes of junk at the end.
+		 *
+		 * For now, we assume that to be true for 802.11 captures
+		 * as well; it appears to be the case for at least one
+		 * such capture.
 		 */
-		if (isdn_type == 1 || isdn_type == 2)
-			wth->capture.netxray->padding = 4;
+		if (version_major == 2) {
+			if (hdr.xxb[13] == 0x34 && hdr.xxb[14] == 0x12)
+				wth->capture.netxray->fcs_valid = TRUE;
+		}
 		break;
 	}
 
@@ -539,6 +541,7 @@ static gboolean netxray_read(wtap *wth, int *err, long *data_offset)
 	int	hdr_size;
 	double	t;
 	guint8  *pd;
+	guint	padding;
 
 reread:
 	/* Have we reached the end of the packet data? */
@@ -598,8 +601,8 @@ reread:
 	/*
 	 * Set the pseudo-header.
 	 */
-	netxray_set_pseudo_header(wth, pd, packet_size, &wth->pseudo_header,
-	    &hdr);
+	padding = netxray_set_pseudo_header(wth, pd, packet_size,
+	    &wth->pseudo_header, &hdr);
 
 	if (wth->capture.netxray->version_major == 0) {
 		t = (double)pletohl(&hdr.old_hdr.timelo)
@@ -613,7 +616,7 @@ reread:
 		 * We subtract the padding from the packet size, so our caller
 		 * doesn't see it.
 		 */
-		wth->phdr.caplen = packet_size - wth->capture.netxray->padding;
+		wth->phdr.caplen = packet_size - padding;
 		wth->phdr.len = wth->phdr.caplen;
 	} else {
 		t = (double)pletohl(&hdr.hdr_1_x.timelo)
@@ -627,8 +630,8 @@ reread:
 		 * We subtract the padding from the packet size, so our caller
 		 * doesn't see it.
 		 */
-		wth->phdr.caplen = packet_size - wth->capture.netxray->padding;
-		wth->phdr.len = pletohs(&hdr.hdr_1_x.orig_len) - wth->capture.netxray->padding;
+		wth->phdr.caplen = packet_size - padding;
+		wth->phdr.len = pletohs(&hdr.hdr_1_x.orig_len) - padding;
 	}
 	wth->phdr.pkt_encap = wth->file_encap;
 
@@ -663,6 +666,7 @@ netxray_seek_read(wtap *wth, long seek_off,
 	ret = netxray_read_rec_data(wth->random_fh, pd, length, err);
 	if (!ret)
 		return FALSE;
+
 	/*
 	 * Set the pseudo-header.
 	 */
@@ -712,16 +716,75 @@ netxray_read_rec_header(wtap *wth, FILE_T fh, union netxrayrec_hdr *hdr,
 	return hdr_size;
 }
 
-static void
+static guint
 netxray_set_pseudo_header(wtap *wth, const guint8 *pd, int len,
     union wtap_pseudo_header *pseudo_header, union netxrayrec_hdr *hdr)
 {
+	guint padding = 0;
+
 	/*
-	 * If this is 802.11, ISDN, X.25, or ATM, set the pseudo-header.
+	 * If this is Ethernet, 802.11, ISDN, X.25, or ATM, set the
+	 * pseudo-header.
 	 */
-	if (wth->capture.netxray->version_major == 2) {
+	switch (wth->capture.netxray->version_major) {
+
+	case 1:
+		switch (wth->file_encap) {
+
+		case WTAP_ENCAP_ETHERNET:
+			/*
+			 * XXX - if hdr->hdr_1_x.xxx[15] is 1
+			 * the frame appears not to have any extra
+			 * stuff at the end, but if it's 0,
+			 * there appears to be 4 bytes of stuff
+			 * at the end, but it's not an FCS.
+			 *
+			 * Or is that just the low-order bit?
+			 *
+			 * For now, we just say "no FCS".
+			 */
+			pseudo_header->eth.fcs_len = 0;
+			break;
+		}
+		break;
+
+	case 2:
 		switch (wth->file_encap) {
 
+		case WTAP_ENCAP_ETHERNET:
+			/*
+			 * It appears, at least with version 2 captures,
+			 * that we have 4 bytes of stuff (which might be
+			 * a valid FCS or might be junk) at the end of
+			 * the packet if hdr->hdr_2_x.xxx[2] and
+			 * hdr->hdr_2_x.xxx[3] are 0xff, and we don't if
+			 * they don't.
+			 *
+			 * It also appears that if the low-order bit of
+			 * hdr->hdr_2_x.xxx[8] is set, the packet has a
+			 * bad FCS.
+			 */
+			if (hdr->hdr_2_x.xxx[2] == 0xff &&
+			    hdr->hdr_2_x.xxx[3] == 0xff) {
+				/*
+				 * We have 4 bytes of stuff at the
+				 * end of the frame - FCS, or junk?
+				 */
+			    	if (wth->capture.netxray->fcs_valid) {
+					/*
+					 * FCS.
+					 */
+					pseudo_header->eth.fcs_len = 4;
+				} else {
+					/*
+					 * Junk.
+					 */
+					padding = 4;
+				}
+			} else
+				pseudo_header->eth.fcs_len = 0;
+			break;
+
 		case WTAP_ENCAP_IEEE_802_11_WITH_RADIO:
 			pseudo_header->ieee_802_11.channel =
 			    hdr->hdr_2_x.xxx[12];
@@ -729,6 +792,33 @@ netxray_set_pseudo_header(wtap *wth, const guint8 *pd, int len,
 			    hdr->hdr_2_x.xxx[13];
 			pseudo_header->ieee_802_11.signal_level =
 			    hdr->hdr_2_x.xxx[14];
+
+			/*
+			 * It appears, in one 802.11 capture, that
+			 * we have 4 bytes of junk at the ends of
+			 * frames in which hdr->hdr_2_x.xxx[2] and
+			 * hdr->hdr_2_x.xxx[3] are 0xff; we assume
+			 * for now that it works like Ethernet.
+			 */
+			if (hdr->hdr_2_x.xxx[2] == 0xff &&
+			    hdr->hdr_2_x.xxx[3] == 0xff) {
+				/*
+				 * We have 4 bytes of stuff at the
+				 * end of the frame - FCS, or junk?
+				 */
+			    	if (wth->capture.netxray->fcs_valid) {
+					/*
+					 * FCS.
+					 */
+					pseudo_header->eth.fcs_len = 4;
+				} else {
+					/*
+					 * Junk.
+					 */
+					padding = 4;
+				}
+			} else
+				pseudo_header->eth.fcs_len = 0;
 			break;
 
 		case WTAP_ENCAP_ISDN:
@@ -761,6 +851,12 @@ netxray_set_pseudo_header(wtap *wth, const guint8 *pd, int len,
 					pseudo_header->isdn.channel = 0;
 				else if (pseudo_header->isdn.channel > 16)
 					pseudo_header->isdn.channel -= 1;
+
+				/*
+				 * PRI captures appear to have 4 bytes of
+				 * stuff at the end - FCS, or padding?
+				 */
+				padding = 4;
 				break;
 
 			case 2:
@@ -773,6 +869,12 @@ netxray_set_pseudo_header(wtap *wth, const guint8 *pd, int len,
 					pseudo_header->isdn.channel = 0;
 				else if (pseudo_header->isdn.channel > 24)
 					pseudo_header->isdn.channel -= 1;
+
+				/*
+				 * PRI captures appear to have 4 bytes of
+				 * stuff at the end - FCS, or padding?
+				 */
+				padding = 4;
 				break;
 			}
 			break;
@@ -880,7 +982,9 @@ netxray_set_pseudo_header(wtap *wth, const guint8 *pd, int len,
 			}
 			break;
 		}
+		break;
 	}
+	return padding;
 }
 
 static gboolean
@@ -1300,6 +1404,10 @@ static gboolean netxray_dump_close_2_0(wtap_dumper *wdh, int *err)
     case WTAP_ENCAP_SDLC:
 	file_hdr.xxb[20] = CAPTYPE_SDLC;
 	break;
+
+    default:
+	file_hdr.xxb[20] = CAPTYPE_NDIS;
+	break;
     }
 
     memset(hdr_buf, '\0', sizeof hdr_buf);
diff --git a/wiretap/ngsniffer.c b/wiretap/ngsniffer.c
index bb369f5ceb..798f0cde01 100644
--- a/wiretap/ngsniffer.c
+++ b/wiretap/ngsniffer.c
@@ -1,6 +1,6 @@
 /* ngsniffer.c
  *
- * $Id: ngsniffer.c,v 1.110 2003/03/03 23:29:59 guy Exp $
+ * $Id: ngsniffer.c,v 1.111 2003/10/01 07:11:48 guy Exp $
  *
  * Wiretap Library
  * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>
@@ -374,8 +374,8 @@ static void set_pseudo_header_frame4(union wtap_pseudo_header *pseudo_header,
     struct frame4_rec *frame4);
 static gboolean ngsniffer_read_frame6(wtap *wth, gboolean is_random,
     struct frame6_rec *frame6, int *err);
-static void set_pseudo_header_frame6(union wtap_pseudo_header *pseudo_header,
-    struct frame6_rec *frame6);
+static void set_pseudo_header_frame6(wtap *wth,
+    union wtap_pseudo_header *pseudo_header, struct frame6_rec *frame6);
 static gboolean ngsniffer_read_rec_data(wtap *wth, gboolean is_random,
     guchar *pd, int length, int *err);
 static int infer_pkt_encap(const guint8 *pd, int len);
@@ -1014,7 +1014,8 @@ static gboolean ngsniffer_read(wtap *wth, int *err, long *data_offset)
 			t = (double)time_low+(double)(time_med)*65536.0 +
 			    (double)time_high*4294967296.0;
 
-			set_pseudo_header_frame6(&wth->pseudo_header, &frame6);
+			set_pseudo_header_frame6(wth, &wth->pseudo_header,
+			    &frame6);
 			goto found;
 
 		case REC_EOF:
@@ -1133,7 +1134,7 @@ static gboolean ngsniffer_seek_read(wtap *wth, long seek_off,
 
 		length -= sizeof frame6;	/* we already read that much */
 
-		set_pseudo_header_frame6(pseudo_header, &frame6);
+		set_pseudo_header_frame6(wth, pseudo_header, &frame6);
 		break;
 
 	default:
@@ -1250,6 +1251,17 @@ static void set_pseudo_header_frame2(wtap *wth,
 	 */
 	switch (wth->file_encap) {
 
+	case WTAP_ENCAP_ETHERNET:
+		/*
+		 * XXX - do we ever have an FCS?  If not, why do we often
+		 * have 4 extra bytes of stuff at the end?  Do some
+		 * PC Ethernet interfaces report the length including the
+		 * FCS but not store the FCS in the packet, or do some
+		 * Ethernet drivers work that way?
+		 */
+		pseudo_header->eth.fcs_len = 0;
+		break;
+
 	case WTAP_ENCAP_PPP_WITH_PHDR:
 	case WTAP_ENCAP_SDLC:
 		pseudo_header->p2p.sent = (frame2->fs & 0x80) ? TRUE : FALSE;
@@ -1569,11 +1581,19 @@ static gboolean ngsniffer_read_frame6(wtap *wth, gboolean is_random,
 	return TRUE;
 }
 
-static void set_pseudo_header_frame6(
-	union wtap_pseudo_header *pseudo_header _U_,
+static void set_pseudo_header_frame6(wtap *wth,
+	union wtap_pseudo_header *pseudo_header,
 	struct frame6_rec *frame6 _U_)
 {
 	/* XXX - Once the frame format is divined, something will most likely go here */
+
+	switch (wth->file_encap) {
+
+	case WTAP_ENCAP_ETHERNET:
+		/* XXX - is there an FCS? */
+		pseudo_header->eth.fcs_len = -1;
+		break;
+	}
 }
 
 static gboolean ngsniffer_read_rec_data(wtap *wth, gboolean is_random,
diff --git a/wiretap/radcom.c b/wiretap/radcom.c
index a2ac904c66..64ad916c0e 100644
--- a/wiretap/radcom.c
+++ b/wiretap/radcom.c
@@ -1,6 +1,6 @@
 /* radcom.c
  *
- * $Id: radcom.c,v 1.41 2003/01/07 08:41:23 guy Exp $
+ * $Id: radcom.c,v 1.42 2003/10/01 07:11:48 guy Exp $
  *
  * Wiretap Library
  * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>
@@ -316,6 +316,11 @@ static gboolean radcom_read(wtap *wth, int *err, long *data_offset)
 
 	switch (wth->file_encap) {
 
+	case WTAP_ENCAP_ETHERNET:
+		/* XXX - is there an FCS? */
+		wth->pseudo_header.eth.fcs_len = -1;
+		break;
+
 	case WTAP_ENCAP_LAPB:
 		wth->pseudo_header.x25.flags = (hdr.dce & 0x1) ?
 		    0x00 : FROM_DCE;
@@ -389,6 +394,11 @@ radcom_seek_read(wtap *wth, long seek_off,
 
 	switch (wth->file_encap) {
 
+	case WTAP_ENCAP_ETHERNET:
+		/* XXX - is there an FCS? */
+		pseudo_header->eth.fcs_len = -1;
+		break;
+
 	case WTAP_ENCAP_LAPB:
 		pseudo_header->x25.flags = (hdr.dce & 0x1) ? 0x00 : FROM_DCE;
 		break;
diff --git a/wiretap/snoop.c b/wiretap/snoop.c
index 6be6cd406d..d8fad35dcd 100644
--- a/wiretap/snoop.c
+++ b/wiretap/snoop.c
@@ -1,6 +1,6 @@
 /* snoop.c
  *
- * $Id: snoop.c,v 1.62 2003/02/18 19:59:00 guy Exp $
+ * $Id: snoop.c,v 1.63 2003/10/01 07:11:48 guy Exp $
  *
  * Wiretap Library
  * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>
@@ -405,7 +405,9 @@ static gboolean snoop_read(wtap *wth, int *err, long *data_offset)
 	 * the VCI; read them and generate the pseudo-header from
 	 * them.
 	 */
-	if (wth->file_encap == WTAP_ENCAP_ATM_PDUS) {
+	switch (wth->file_encap) {
+
+	case WTAP_ENCAP_ATM_PDUS:
 		if (packet_size < sizeof (struct snoop_atm_hdr)) {
 			/*
 			 * Uh-oh, the packet isn't big enough to even
@@ -427,6 +429,19 @@ static gboolean snoop_read(wtap *wth, int *err, long *data_offset)
 		orig_size -= sizeof (struct snoop_atm_hdr);
 		packet_size -= sizeof (struct snoop_atm_hdr);
 		wth->data_offset += sizeof (struct snoop_atm_hdr);
+		break;
+
+	case WTAP_ENCAP_ETHERNET:
+		/*
+		 * If this is a snoop file, we assume there's no FCS in
+		 * this frame; if this is a Shomit file, we assume there
+		 * is.  (XXX - or should we treat it a "maybe"?)
+		 */
+		if (wth->file_type == WTAP_FILE_SHOMITI)
+			wth->pseudo_header.eth.fcs_len = 4;
+		else
+			wth->pseudo_header.eth.fcs_len = 0;
+		break;
 	}
 
 	buffer_assure_space(wth->frame_buffer, packet_size);
@@ -485,12 +500,27 @@ snoop_seek_read(wtap *wth, long seek_off,
 	if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)
 		return FALSE;
 
-	if (wth->file_encap == WTAP_ENCAP_ATM_PDUS) {
+	switch (wth->file_encap) {
+
+	case WTAP_ENCAP_ATM_PDUS:
 		if (!snoop_read_atm_pseudoheader(wth->random_fh, pseudo_header,
 		    err)) {
 			/* Read error */
 			return FALSE;
 		}
+		break;
+
+	case WTAP_ENCAP_ETHERNET:
+		/*
+		 * If this is a snoop file, we assume there's no FCS in
+		 * this frame; if this is a Shomit file, we assume there
+		 * is.  (XXX - or should we treat it a "maybe"?)
+		 */
+		if (wth->file_type == WTAP_FILE_SHOMITI)
+			pseudo_header->eth.fcs_len = 4;
+		else
+			pseudo_header->eth.fcs_len = 0;
+		break;
 	}
 
 	/*
diff --git a/wiretap/toshiba.c b/wiretap/toshiba.c
index ab37d00523..064d5d969f 100644
--- a/wiretap/toshiba.c
+++ b/wiretap/toshiba.c
@@ -1,6 +1,6 @@
 /* toshiba.c
  *
- * $Id: toshiba.c,v 1.26 2002/10/31 07:12:42 guy Exp $
+ * $Id: toshiba.c,v 1.27 2003/10/01 07:11:48 guy Exp $
  *
  * Wiretap Library
  * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>
@@ -367,6 +367,8 @@ parse_toshiba_rec_hdr(wtap *wth, FILE_T fh,
 		default:
 			if (wth)
 				wth->phdr.pkt_encap = WTAP_ENCAP_ETHERNET;
+			/* XXX - is there an FCS in the frame? */
+			pseudo_header->eth.fcs_len = -1;
 			break;
 	}
 	return pkt_len;
diff --git a/wiretap/visual.c b/wiretap/visual.c
index 18af191d0d..c023cd5e16 100644
--- a/wiretap/visual.c
+++ b/wiretap/visual.c
@@ -2,7 +2,7 @@
  * File read and write routines for Visual Networks cap files.
  * Copyright (c) 2001, Tom Nisbet  tnisbet@visualnetworks.com
  *
- * $Id: visual.c,v 1.12 2003/01/31 01:02:11 guy Exp $
+ * $Id: visual.c,v 1.13 2003/10/01 07:11:48 guy Exp $
  *
  * Wiretap Library
  * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>
@@ -117,6 +117,8 @@ static void visual_close(wtap *wth);
 static gboolean visual_seek_read(wtap *wth, long seek_off,
     union wtap_pseudo_header *pseudo_header, guchar *pd, int packet_size,
     int *err);
+static void visual_set_pseudo_header(int encap, struct visual_pkt_hdr *vpkt_hdr,
+    union wtap_pseudo_header *pseudo_header);
 static gboolean visual_dump(wtap_dumper *wdh, const struct wtap_pkthdr *phdr,
     const union wtap_pseudo_header *pseudo_header, const guchar *pd, int *err);
 static gboolean visual_dump_close(wtap_dumper *wdh, int *err);
@@ -232,7 +234,6 @@ static gboolean visual_read(wtap *wth, int *err, long *data_offset)
 {
     struct visual_read_info *visual = wth->capture.generic;
     guint32 packet_size = 0;
-    guint32 packet_status;
     int bytes_read;
     struct visual_pkt_hdr vpkt_hdr;
     int phdr_size = sizeof(vpkt_hdr);
@@ -300,24 +301,8 @@ static gboolean visual_read(wtap *wth, int *err, long *data_offset)
     wth->phdr.caplen = packet_size;
     wth->phdr.len = pletohs(&vpkt_hdr.orig_len);
 
-    /* Set status flags.  The only status currently supported for all
-       encapsulations is direction.  This either goes in the p2p or the
-       X.25 pseudo header.  It would probably be better to move this up
-       into the phdr. */
-    packet_status = pletohl(&vpkt_hdr.status);
-    switch (wth->file_encap)
-    {
-    case WTAP_ENCAP_CHDLC:
-    case WTAP_ENCAP_PPP_WITH_PHDR:
-        wth->pseudo_header.p2p.sent = (packet_status & PS_SENT) ? TRUE : FALSE;
-        break;
-
-    case WTAP_ENCAP_FRELAY_WITH_PHDR:
-    case WTAP_ENCAP_LAPB:
-        wth->pseudo_header.x25.flags =
-            (packet_status & PS_SENT) ? 0x00 : FROM_DCE;
-        break;
-    }
+    /* Set the pseudo_header. */
+    visual_set_pseudo_header(wth->file_encap, &vpkt_hdr, &wth->pseudo_header);
 
     /* Fill in the encapsulation.  Visual files have a media type in the
        file header and an encapsulation type in each packet header.  Files
@@ -349,7 +334,6 @@ static gboolean visual_seek_read (wtap *wth, long seek_off,
 {
     struct visual_pkt_hdr vpkt_hdr;
     int phdr_size = sizeof(vpkt_hdr);
-    guint32 packet_status;
     int bytes_read;
 
     /* Seek to the packet header */
@@ -376,13 +360,29 @@ static gboolean visual_seek_read (wtap *wth, long seek_off,
         return FALSE;
     }
 
+    /* Set the pseudo_header. */
+    visual_set_pseudo_header(wth->file_encap, &vpkt_hdr, pseudo_header);
+
+    return TRUE;
+}
+
+static void visual_set_pseudo_header(int encap, struct visual_pkt_hdr *vpkt_hdr,
+    union wtap_pseudo_header *pseudo_header)
+{
+    guint32 packet_status;
+
     /* Set status flags.  The only status currently supported for all
        encapsulations is direction.  This either goes in the p2p or the
        X.25 pseudo header.  It would probably be better to move this up
        into the phdr. */
-    packet_status = pletohl(&vpkt_hdr.status);
-    switch (wth->file_encap)
+    packet_status = pletohl(&vpkt_hdr->status);
+    switch (encap)
     {
+    case WTAP_ENCAP_ETHERNET:
+        /* XXX - is there an FCS in the frame? */
+        pseudo_header->eth.fcs_len = -1;
+        break;
+
     case WTAP_ENCAP_CHDLC:
     case WTAP_ENCAP_PPP_WITH_PHDR:
         pseudo_header->p2p.sent = (packet_status & PS_SENT) ? TRUE : FALSE;
@@ -390,14 +390,12 @@ static gboolean visual_seek_read (wtap *wth, long seek_off,
 
     case WTAP_ENCAP_FRELAY_WITH_PHDR:
     case WTAP_ENCAP_LAPB:
-        pseudo_header->x25.flags = (packet_status & PS_SENT) ? 0x00 : FROM_DCE;
+        pseudo_header->x25.flags =
+            (packet_status & PS_SENT) ? 0x00 : FROM_DCE;
         break;
     }
-
-    return TRUE;
 }
 
-
 /* Check for media types that may be written in Visual file format.
    Returns 0 if the specified encapsulation type is supported,
    an error indication otherwise. */
diff --git a/wiretap/wtap-int.h b/wiretap/wtap-int.h
index 47c4389cab..47b594cd24 100644
--- a/wiretap/wtap-int.h
+++ b/wiretap/wtap-int.h
@@ -1,6 +1,6 @@
 /* wtap-int.h
  *
- * $Id: wtap-int.h,v 1.39 2003/08/26 07:10:39 guy Exp $
+ * $Id: wtap-int.h,v 1.40 2003/10/01 07:11:49 guy Exp $
  *
  * Wiretap Library
  * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>
@@ -99,7 +99,7 @@ typedef struct {
 	gboolean	wrapped;
 	int		end_offset;
 	int		version_major;
-	guint		padding;	/* end-of-packet padding */
+	gboolean	fcs_valid;	/* if packets have valid FCS at the end */
 	guint		isdn_type;	/* 1 = E1 PRI, 2 = T1 PRI, 3 = BRI */
 } netxray_t;
 
diff --git a/wiretap/wtap.h b/wiretap/wtap.h
index 98d8f8a02f..54be05aea6 100644
--- a/wiretap/wtap.h
+++ b/wiretap/wtap.h
@@ -1,6 +1,6 @@
 /* wtap.h
  *
- * $Id: wtap.h,v 1.140 2003/08/26 07:10:39 guy Exp $
+ * $Id: wtap.h,v 1.141 2003/10/01 07:11:49 guy Exp $
  *
  * Wiretap Library
  * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>
@@ -197,6 +197,11 @@
  * of that.
  */
 
+/* Packet "pseudo-header" information for Ethernet capture files. */
+struct eth_phdr {
+	gint	fcs_len;	/* Number of bytes of FCS - -1 means "unknown" */
+};
+
 /* Packet "pseudo-header" information for X.25 capture files. */
 #define FROM_DCE			0x80
 struct x25_phdr {
@@ -353,6 +358,7 @@ struct cosine_phdr {
 };
 
 union wtap_pseudo_header {
+	struct eth_phdr		eth;
 	struct x25_phdr		x25;
 	struct isdn_phdr	isdn;
 	struct atm_phdr		atm;
@@ -420,8 +426,6 @@ void wtap_sequential_close(wtap *wth);
 void wtap_close(wtap *wth);
 gboolean wtap_seek_read (wtap *wth, long seek_off,
 	union wtap_pseudo_header *pseudo_header, guint8 *pd, int len, int *err);
-gboolean wtap_def_seek_read (wtap *wth, long seek_off,
-	union wtap_pseudo_header *pseudo_header, guint8 *pd, int len, int *err);
 
 gboolean wtap_dump_can_open(int filetype);
 gboolean wtap_dump_can_write_encap(int filetype, int encap);

