commit 08d2ca300a45b3e6340253f989523d6e3ab87648
Author: Simon McVittie <simon.mcvittie@collabora.co.uk>
Date:   Thu Nov 15 15:07:33 2012 +0000

    st_theme_node_copy_cached_paint_state: allow self-assignment
    
    If you copy a theme node's paint state into itself, it should be an
    inexpensive no-op. What actually happened was that we destroyed the
    old paint state, re-initialized to blank, then copied the blank state
    back into itself. In the process, we lost (for instance) the textures
    for rounded corners.
    
    Until I introduced the texture cache, this never actually happened,
    because when st_widget_recompute_style() calls st_widget_get_theme_node(),
    we'd always get a fresh theme node. Now, we get a theme node T back
    from the cache, notice that paint_equal(T, T) is true, short-circuit
    slightly by copying its drawing state into itself, and destroy drawing
    state that we still needed.
    
    I'm going to fix this in recompute_style() too, but as a general
    principle, self-assignment ought to be harmless.
    
    Bug: https://bugzilla.gnome.org/show_bug.cgi?id=687465
    Reviewed-by: Jasper St. Pierre <jstpierre@mecheye.net>

diff --git a/src/st/st-theme-node-drawing.c b/src/st/st-theme-node-drawing.c
index c3424f9fd..429cc53b3 100644
--- a/src/st/st-theme-node-drawing.c
+++ b/src/st/st-theme-node-drawing.c
@@ -2060,6 +2060,9 @@ st_theme_node_copy_cached_paint_state (StThemeNode *node,
   g_return_if_fail (ST_IS_THEME_NODE (node));
   g_return_if_fail (ST_IS_THEME_NODE (other));
 
+  if (node == other)
+    return;
+
   /* Check omitted for speed: */
   /* g_return_if_fail (st_theme_node_paint_equal (node, other)); */
 

