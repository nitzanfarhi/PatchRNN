commit 41c7f7424259ff11009449f87c95656f69f9b186
Author: Rabin Vincent <rabin.vincent@stericsson.com>
Date:   Tue Nov 22 11:03:14 2011 +0100

    rtc: Disable the alarm in the hardware (v2)
    
    Currently, the RTC code does not disable the alarm in the hardware.
    
    This means that after a sequence such as the one below (the files are in the
    RTC sysfs), the box will boot up after 2 minutes even though we've
    asked for the alarm to be turned off.
    
            # echo $((`cat since_epoch`)+120) > wakealarm
            # echo 0 > wakealarm
            # poweroff
    
    Fix this by disabling the alarm when there are no timers to run.
    
    The original version of this patch was reverted. This version
    disables the irq directly instead of setting a disabled timer
    in the future.
    
    Cc: stable@kernel.org
    Cc: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Rabin Vincent <rabin.vincent@stericsson.com>
    [Merged in the second revision from Rabin]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/drivers/rtc/interface.c b/drivers/rtc/interface.c
index 167e68a9ffda..dc87eda65814 100644
--- a/drivers/rtc/interface.c
+++ b/drivers/rtc/interface.c
@@ -776,6 +776,14 @@ static int rtc_timer_enqueue(struct rtc_device *rtc, struct rtc_timer *timer)
 	return 0;
 }
 
+static void rtc_alarm_disable(struct rtc_device *rtc)
+{
+	if (!rtc->ops || !rtc->ops->alarm_irq_enable)
+		return;
+
+	rtc->ops->alarm_irq_enable(rtc->dev.parent, false);
+}
+
 /**
  * rtc_timer_remove - Removes a rtc_timer from the rtc_device timerqueue
  * @rtc rtc device
@@ -797,8 +805,10 @@ static void rtc_timer_remove(struct rtc_device *rtc, struct rtc_timer *timer)
 		struct rtc_wkalrm alarm;
 		int err;
 		next = timerqueue_getnext(&rtc->timerqueue);
-		if (!next)
+		if (!next) {
+			rtc_alarm_disable(rtc);
 			return;
+		}
 		alarm.time = rtc_ktime_to_tm(next->expires);
 		alarm.enabled = 1;
 		err = __rtc_set_alarm(rtc, &alarm);
@@ -860,7 +870,8 @@ void rtc_timer_do_work(struct work_struct *work)
 		err = __rtc_set_alarm(rtc, &alarm);
 		if (err == -ETIME)
 			goto again;
-	}
+	} else
+		rtc_alarm_disable(rtc);
 
 	mutex_unlock(&rtc->ops_lock);
 }

