commit 4e7ed2d1d396feac872c727a0700fdb5a86641e2
Author: aurel32 <aurel32@c046a42c-6fe2-441c-8c8c-71466251a162>
Date:   Fri Nov 21 21:06:51 2008 +0000

    SH4: Switch serial emulation to qemu_irq
    
    This patches makes SH serial emulation use qemu_irq in its interface.
    
            * hw/sh.h (sh_serial_init): Take qemu_irq, not intc_source.
            * hw/sh7750.c (sh7750_init): Adjust.
            * hw/sh_intc.c (sh_intc_set_irq): Don't assert or deassert
            irq more than once.
            * hw/sh_serial.c (sh_serial_state): Use qemu_irq, not intc_source.
            (sh_serial_clear_fifo, sh_serial_ioport_write)
            (sh_serial_receive_byte): Adjust.
            (sh_serial_init): Take qemu_irq, not intc_source.
    
    (Vladimir Prus)
    
    git-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@5769 c046a42c-6fe2-441c-8c8c-71466251a162

diff --git a/hw/sh.h b/hw/sh.h
index 800b2a1e3f..15c58cb91c 100644
--- a/hw/sh.h
+++ b/hw/sh.h
@@ -36,11 +36,11 @@ void tmu012_init(target_phys_addr_t base, int feat, uint32_t freq,
 #define SH_SERIAL_FEAT_SCIF (1 << 0)
 void sh_serial_init (target_phys_addr_t base, int feat,
 		     uint32_t freq, CharDriverState *chr,
-		     struct intc_source *eri_source,
-		     struct intc_source *rxi_source,
-		     struct intc_source *txi_source,
-		     struct intc_source *tei_source,
-		     struct intc_source *bri_source);
+		     qemu_irq eri_source,
+		     qemu_irq rxi_source,
+		     qemu_irq txi_source,
+		     qemu_irq tei_source,
+		     qemu_irq bri_source);
 
 /* tc58128.c */
 int tc58128_init(struct SH7750State *s, const char *zone1, const char *zone2);
diff --git a/hw/sh7750.c b/hw/sh7750.c
index f04d13a6f6..33e733704e 100644
--- a/hw/sh7750.c
+++ b/hw/sh7750.c
@@ -662,18 +662,18 @@ SH7750State *sh7750_init(CPUSH4State * cpu)
     cpu->intc_handle = &s->intc;
 
     sh_serial_init(0x1fe00000, 0, s->periph_freq, serial_hds[0],
-		   sh_intc_source(&s->intc, SCI1_ERI),
-		   sh_intc_source(&s->intc, SCI1_RXI),
-		   sh_intc_source(&s->intc, SCI1_TXI),
-		   sh_intc_source(&s->intc, SCI1_TEI),
+		   s->intc.irqs[SCI1_ERI],
+		   s->intc.irqs[SCI1_RXI],
+		   s->intc.irqs[SCI1_TXI],
+		   s->intc.irqs[SCI1_TEI],
 		   NULL);
     sh_serial_init(0x1fe80000, SH_SERIAL_FEAT_SCIF,
 		   s->periph_freq, serial_hds[1],
-		   sh_intc_source(&s->intc, SCIF_ERI),
-		   sh_intc_source(&s->intc, SCIF_RXI),
-		   sh_intc_source(&s->intc, SCIF_TXI),
+		   s->intc.irqs[SCIF_ERI],
+		   s->intc.irqs[SCIF_RXI],
+		   s->intc.irqs[SCIF_TXI],
 		   NULL,
-		   sh_intc_source(&s->intc, SCIF_BRI));
+		   s->intc.irqs[SCIF_BRI]);
 
     tmu012_init(0x1fd80000,
 		TMU012_FEAT_TOCR | TMU012_FEAT_3CHAN | TMU012_FEAT_EXTCLK,
diff --git a/hw/sh_intc.c b/hw/sh_intc.c
index 3c6809ac5f..a78419bede 100644
--- a/hw/sh_intc.c
+++ b/hw/sh_intc.c
@@ -78,7 +78,10 @@ void sh_intc_set_irq (void *opaque, int n, int level)
   struct intc_desc *desc = opaque;
   struct intc_source *source = &(desc->sources[n]);
 
-  sh_intc_toggle_source(source, 0, level ? 1 : -1);  
+  if (level && !source->asserted)
+    sh_intc_toggle_source(source, 0, 1);
+  else if (!level && source->asserted)
+    sh_intc_toggle_source(source, 0, -1);
 }
 
 int sh_intc_get_pending_vector(struct intc_desc *desc, int imask)
diff --git a/hw/sh_serial.c b/hw/sh_serial.c
index 9b2dcc17bb..814bd38a5a 100644
--- a/hw/sh_serial.c
+++ b/hw/sh_serial.c
@@ -61,11 +61,11 @@ typedef struct {
 
     CharDriverState *chr;
 
-    struct intc_source *eri;
-    struct intc_source *rxi;
-    struct intc_source *txi;
-    struct intc_source *tei;
-    struct intc_source *bri;
+    qemu_irq eri;
+    qemu_irq rxi;
+    qemu_irq txi;
+    qemu_irq tei;
+    qemu_irq bri;
 } sh_serial_state;
 
 static void sh_serial_clear_fifo(sh_serial_state * s)
@@ -98,13 +98,10 @@ static void sh_serial_ioport_write(void *opaque, uint32_t offs, uint32_t val)
         if (!(val & (1 << 5)))
             s->flags |= SH_SERIAL_FLAG_TEND;
         if ((s->feat & SH_SERIAL_FEAT_SCIF) && s->txi) {
-            if ((val & (1 << 7)) && !(s->txi->asserted))
-                sh_intc_toggle_source(s->txi, 0, 1);
-            else if (!(val & (1 << 7)) && s->txi->asserted)
-                sh_intc_toggle_source(s->txi, 0, -1);
+	    qemu_set_irq(s->txi, val & (1 << 7));
         }
-        if (!(val & (1 << 6)) && s->rxi->asserted) {
-	    sh_intc_toggle_source(s->rxi, 0, -1);
+        if (!(val & (1 << 6))) {
+	    qemu_set_irq(s->rxi, 0);
         }
         return;
     case 0x0c: /* FTDR / TDR */
@@ -136,8 +133,8 @@ static void sh_serial_ioport_write(void *opaque, uint32_t offs, uint32_t val)
                 s->flags &= ~SH_SERIAL_FLAG_DR;
 
             if (!(val & (1 << 1)) || !(val & (1 << 0))) {
-                if (s->rxi && s->rxi->asserted) {
-                    sh_intc_toggle_source(s->rxi, 0, -1);
+                if (s->rxi) {
+                    qemu_set_irq(s->rxi, 0);
                 }
             }
             return;
@@ -309,7 +306,7 @@ static void sh_serial_receive_byte(sh_serial_state *s, int ch)
             if (s->rx_cnt >= s->rtrg) {
                 s->flags |= SH_SERIAL_FLAG_RDF;
                 if (s->scr & (1 << 6) && s->rxi) {
-                    sh_intc_toggle_source(s->rxi, 0, 1);
+                    qemu_set_irq(s->rxi, 1);
                 }
             }
         }
@@ -370,11 +367,11 @@ static CPUWriteMemoryFunc *sh_serial_writefn[] = {
 
 void sh_serial_init (target_phys_addr_t base, int feat,
 		     uint32_t freq, CharDriverState *chr,
-		     struct intc_source *eri_source,
-		     struct intc_source *rxi_source,
-		     struct intc_source *txi_source,
-		     struct intc_source *tei_source,
-		     struct intc_source *bri_source)
+		     qemu_irq eri_source,
+		     qemu_irq rxi_source,
+		     qemu_irq txi_source,
+		     qemu_irq tei_source,
+		     qemu_irq bri_source)
 {
     sh_serial_state *s;
     int s_io_memory;

