commit e3569aeb23884abfc50ff32135055441a691142d
Author: Shaun Verch <shaun.verch@10gen.com>
Date:   Tue Jan 14 17:37:19 2014 -0800

    SERVER-11814 Support new strict date format in JSON parser

diff --git a/src/mongo/db/json.cpp b/src/mongo/db/json.cpp
index 3bd0adefa5..0203bc8293 100644
--- a/src/mongo/db/json.cpp
+++ b/src/mongo/db/json.cpp
@@ -22,6 +22,7 @@
 #include "mongo/util/base64.h"
 #include "mongo/util/hex.h"
 #include "mongo/util/mongoutils/str.h"
+#include "mongo/util/time_support.h"
 
 namespace mongo {
 
@@ -48,7 +49,8 @@ namespace mongo {
         BINDATATYPE_RESERVE_SIZE = 4096,
         NS_RESERVE_SIZE = 64,
         DB_RESERVE_SIZE = 64,
-        NUMBERLONG_RESERVE_SIZE = 64
+        NUMBERLONG_RESERVE_SIZE = 64,
+        DATE_RESERVE_SIZE = 64
     };
 
     static const char* LBRACE = "{",
@@ -380,24 +382,72 @@ namespace mongo {
         }
         errno = 0;
         char* endptr;
-        // SERVER-11920: We should use parseNumberFromString here, but that function requires that
-        // we know ahead of time where the number ends, which is not currently the case.
-        Date_t date = static_cast<unsigned long long>(strtoll(_input, &endptr, 10));
-        if (_input == endptr) {
-            return parseError("Date expecting integer milliseconds");
+        Date_t date;
+
+        if (peekToken(DOUBLEQUOTE)) {
+            std::string dateString;
+            dateString.reserve(DATE_RESERVE_SIZE);
+            Status ret = quotedString(&dateString);
+            if (!ret.isOK()) {
+                return ret;
+            }
+            StatusWith<Date_t> dateRet = dateFromISOString(dateString);
+            if (!dateRet.isOK()) {
+                return dateRet.getStatus();
+            }
+            date = dateRet.getValue();
         }
-        if (errno == ERANGE) {
-            /* Need to handle this because jsonString outputs the value of Date_t as unsigned.
-            * See SERVER-8330 and SERVER-8573 */
-            errno = 0;
+        else if (readToken(LBRACE)) {
+            std::string fieldName;
+            fieldName.reserve(FIELD_RESERVE_SIZE);
+            Status ret = field(&fieldName);
+            if (ret != Status::OK()) {
+                return ret;
+            }
+            if (fieldName != "$numberLong") {
+                return parseError("Expected field name: $numberLong for $date value object");
+            }
+            if (!readToken(COLON)) {
+                return parseError("Expecting ':'");
+            }
+
+            // The number must be a quoted string, since large long numbers could overflow a double
+            // and thus may not be valid JSON
+            std::string numberLongString;
+            numberLongString.reserve(NUMBERLONG_RESERVE_SIZE);
+            ret = quotedString(&numberLongString);
+            if (!ret.isOK()) {
+                return ret;
+            }
+
+            long long numberLong;
+            ret = parseNumberFromString(numberLongString, &numberLong);
+            if (!ret.isOK()) {
+                return ret;
+            }
+            date = numberLong;
+        }
+        else {
             // SERVER-11920: We should use parseNumberFromString here, but that function requires
             // that we know ahead of time where the number ends, which is not currently the case.
-            date = strtoull(_input, &endptr, 10);
+            date = static_cast<unsigned long long>(strtoll(_input, &endptr, 10));
+            if (_input == endptr) {
+                return parseError("Date expecting integer milliseconds");
+            }
             if (errno == ERANGE) {
-                return parseError("Date milliseconds overflow");
+                /* Need to handle this because jsonString outputs the value of Date_t as unsigned.
+                * See SERVER-8330 and SERVER-8573 */
+                errno = 0;
+                // SERVER-11920: We should use parseNumberFromString here, but that function
+                // requires that we know ahead of time where the number ends, which is not currently
+                // the case.
+                date = strtoull(_input, &endptr, 10);
+                if (errno == ERANGE) {
+                    return parseError("Date milliseconds overflow");
+                }
             }
+            _input = endptr;
         }
-        _input = endptr;
         builder.appendDate(fieldName, date);
         return Status::OK();
     }
diff --git a/src/mongo/dbtests/jsontests.cpp b/src/mongo/dbtests/jsontests.cpp
index 22449b988a..c5d6373920 100644
--- a/src/mongo/dbtests/jsontests.cpp
+++ b/src/mongo/dbtests/jsontests.cpp
@@ -1510,11 +1510,11 @@ namespace JsonTests {
         class DateNonzero : public Base {
             virtual BSONObj bson() const {
                 BSONObjBuilder b;
-                b.appendDate( "a", 100 );
+                b.appendDate( "a", 1000000000 );
                 return b.obj();
             }
             virtual string json() const {
-                return "{ \"a\" : { \"$date\" : 100 } }";
+                return "{ \"a\" : { \"$date\" : 1000000000 } }";
             }
         };
 
@@ -2726,10 +2726,13 @@ namespace JsonTests {
             add< FromJsonTests::BinDataEmptyType >();
             add< FromJsonTests::BinDataNoType >();
             add< FromJsonTests::BinDataInvalidType >();
-            // TODO: The JSON parser doesn't yet support parsing our strict JSON format for dates.
-            // See SERVER-11814.
-            /*add< FromJsonTests::Date >();
-            add< FromJsonTests::DateNegZero >();
+            // DOCS-2539:  We cannot parse dates generated with a Unix timestamp of zero in local
+            // time, since the body of the date may be before the Unix Epoch.  This causes parsing
+            // to fail even if the offset would properly adjust the time.  For example,
+            // "1969-12-31T19:00:00-05:00" actually represents the Unix timestamp of zero, but we
+            // cannot parse it because the body of the date is before 1970.
+            //add< FromJsonTests::Date >();
+            //add< FromJsonTests::DateNegZero >();
             add< FromJsonTests::DateNonzero >();
             add< FromJsonTests::DateStrictTooLong >();
             add< FromJsonTests::DateTooLong >();
@@ -2745,7 +2748,7 @@ namespace JsonTests {
             add< FromJsonTests::DateStrictMaxUnsigned >();
             add< FromJsonTests::DateMaxUnsigned >();
             add< FromJsonTests::DateStrictNegative >();
-            add< FromJsonTests::DateNegative >();*/
+            add< FromJsonTests::DateNegative >();
             add< FromJsonTests::NumberLongTest >();
             add< FromJsonTests::NumberLongMin >();
             add< FromJsonTests::NumberIntTest >();
@@ -2848,11 +2851,9 @@ namespace JsonTests {
             add< FromJsonTests::NumericLimitsBad >();
             add< FromJsonTests::NumericLimitsBad1 >();
             add< FromJsonTests::NegativeNumericTypes >();
-            // TODO: The JSON parser doesn't yet support parsing our strict JSON format for dates.
-            // See SERVER-11814.
-            /*add< FromJsonTests::EmbeddedDatesFormat1 >();
+            add< FromJsonTests::EmbeddedDatesFormat1 >();
             add< FromJsonTests::EmbeddedDatesFormat2 >();
-            add< FromJsonTests::EmbeddedDatesFormat3 >();*/
+            add< FromJsonTests::EmbeddedDatesFormat3 >();
             add< FromJsonTests::NullString >();
             add< FromJsonTests::NullFieldUnquoted >();
         }

