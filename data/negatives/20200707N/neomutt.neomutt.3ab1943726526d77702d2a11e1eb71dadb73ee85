commit 3ab1943726526d77702d2a11e1eb71dadb73ee85
Author: Brendan Cully <brendan@kublai.com>
Date:   Thu Apr 12 09:16:06 2007 -0700

    Handle a missing or corrupted header cache entry (closes #2676)
    If imap_hcache_get fails, stop parsing the header cache and simply
    refetch from that point on.

diff --git a/imap/message.c b/imap/message.c
index 10ebd0fbc..a7e2df148 100644
--- a/imap/message.c
+++ b/imap/message.c
@@ -161,6 +161,10 @@ int imap_read_headers (IMAP_DATA* idata, int msgbegin, int msgend)
           break;
 	}
 
+        /* hole in the header cache */
+        if (!evalhc)
+          continue;
+
         if ((mfhrc = msg_fetch_header (ctx, &h, idata->buf, NULL)) == -1)
           continue;
         else if (mfhrc < 0)
@@ -190,9 +194,12 @@ int imap_read_headers (IMAP_DATA* idata, int msgbegin, int msgend)
           ctx->size += ctx->hdrs[idx]->content->length;
         }
 	else
-	  /* bad header in the cache, we'll have to refetch.
-	   * TODO: consider the possibility of a holey cache. */
+        {
+	  /* bad header in the cache, we'll have to refetch. */
+          dprint (3, (debugfile, "bad cache entry at %d, giving up\n", h.sid - 1));
           imap_free_header_data((void**) (void*) &h.data);
+          evalhc = 0;
+        }
       }
       while (rc != IMAP_CMD_OK && mfhrc == -1);
       if (rc == IMAP_CMD_OK)

