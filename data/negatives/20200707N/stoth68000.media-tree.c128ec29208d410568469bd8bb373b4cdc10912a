commit c128ec29208d410568469bd8bb373b4cdc10912a
Author: Florian Mickler <florian@mickler.org>
Date:   Mon Aug 2 14:27:00 2010 +0000

    e1000e: register pm_qos request on hardware activation
    
    The pm_qos_add_request call has to register the pm_qos request with the pm_qos
    susbsystem before first use of the pm_qos request via
    pm_qos_update_request.
    
    As pm_qos changed to use plists there is no benefit in registering and
    unregistering the pm_qos request on ifup/ifdown and thus we move the
    registering into e1000_open and the unregistering in e1000_close.
    
    This fixes the following warning:
    
    [    1.786060] WARNING: at kernel/pm_qos_params.c:264
    pm_qos_update_request+0x28/0x54()
    [    1.786088] Hardware name: Latitude E6500
    [    1.787045] pm_qos_update_request() called for unknown object
    [    1.787966] Modules linked in:
    [    1.788940] Pid: 1, comm: swapper Not tainted 2.6.35-rc5-mmotm0719 #1
    [    1.790035] Call Trace:
    [    1.791121]  [<ffffffff81037335>] warn_slowpath_common+0x80/0x98
    [    1.792205]  [<ffffffff810373e1>] warn_slowpath_fmt+0x41/0x43
    [    1.793279]  [<ffffffff81057c14>] pm_qos_update_request+0x28/0x54
    [    1.794347]  [<ffffffff8134889e>] e1000_configure+0x421/0x459
    [    1.795393]  [<ffffffff8134afbd>] e1000_open+0xbd/0x37c
    [    1.796436]  [<ffffffff8105743a>] ? raw_notifier_call_chain+0xf/0x11
    [    1.797491]  [<ffffffff8145f948>] __dev_open+0xae/0xe2
    [    1.798547]  [<ffffffff8145f997>] dev_open+0x1b/0x49
    [    1.799612]  [<ffffffff8146e36e>] netpoll_setup+0x84/0x259
    [    1.800685]  [<ffffffff81b5037c>] init_netconsole+0xbc/0x21f
    [    1.801744]  [<ffffffff81b5026c>] ? sir_wq_init+0x0/0x35
    [    1.802793]  [<ffffffff81b502c0>] ? init_netconsole+0x0/0x21f
    [    1.803845]  [<ffffffff810002ff>] do_one_initcall+0x7a/0x12f
    [    1.804885]  [<ffffffff81b2ccae>] kernel_init+0x138/0x1c2
    [    1.805915]  [<ffffffff81003554>] kernel_thread_helper+0x4/0x10
    [    1.806937]  [<ffffffff81590e00>] ? restore_args+0x0/0x30
    [    1.807955]  [<ffffffff81b2cb76>] ? kernel_init+0x0/0x1c2
    [    1.808958]  [<ffffffff81003550>] ? kernel_thread_helper+0x0/0x10
    [    1.809958] ---[ end trace 84b562a00a60539e ]---
    
    Signed-off-by: Florian Mickler <florian@mickler.org>
    Tested-by: Valdis Kletnieks <valdis.kletnieks@vt.edu>
    Tested-by: Jeff Pieper <jeffrey.e.pieper@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/e1000e/netdev.c b/drivers/net/e1000e/netdev.c
index afd01295fbec..464c9a28f1ba 100644
--- a/drivers/net/e1000e/netdev.c
+++ b/drivers/net/e1000e/netdev.c
@@ -3218,12 +3218,6 @@ int e1000e_up(struct e1000_adapter *adapter)
 {
 	struct e1000_hw *hw = &adapter->hw;
 
-	/* DMA latency requirement to workaround early-receive/jumbo issue */
-	if (adapter->flags & FLAG_HAS_ERT)
-		adapter->netdev->pm_qos_req =
-			pm_qos_add_request(PM_QOS_CPU_DMA_LATENCY,
-				       PM_QOS_DEFAULT_VALUE);
-
 	/* hardware has been reset, we need to reload some things */
 	e1000_configure(adapter);
 
@@ -3287,12 +3281,6 @@ void e1000e_down(struct e1000_adapter *adapter)
 	e1000_clean_tx_ring(adapter);
 	e1000_clean_rx_ring(adapter);
 
-	if (adapter->flags & FLAG_HAS_ERT) {
-		pm_qos_remove_request(
-			      adapter->netdev->pm_qos_req);
-		adapter->netdev->pm_qos_req = NULL;
-	}
-
 	/*
 	 * TODO: for power management, we could drop the link and
 	 * pci_disable_device here.
@@ -3527,6 +3515,12 @@ static int e1000_open(struct net_device *netdev)
 	     E1000_MNG_DHCP_COOKIE_STATUS_VLAN))
 		e1000_update_mng_vlan(adapter);
 
+	/* DMA latency requirement to workaround early-receive/jumbo issue */
+	if (adapter->flags & FLAG_HAS_ERT)
+		adapter->netdev->pm_qos_req =
+		                    pm_qos_add_request(PM_QOS_CPU_DMA_LATENCY,
+		                                       PM_QOS_DEFAULT_VALUE);
+
 	/*
 	 * before we allocate an interrupt, we must be ready to handle it.
 	 * Setting DEBUG_SHIRQ in the kernel makes it fire an interrupt
@@ -3631,6 +3625,11 @@ static int e1000_close(struct net_device *netdev)
 	if (adapter->flags & FLAG_HAS_AMT)
 		e1000_release_hw_control(adapter);
 
+	if (adapter->flags & FLAG_HAS_ERT) {
+		pm_qos_remove_request(adapter->netdev->pm_qos_req);
+		adapter->netdev->pm_qos_req = NULL;
+	}
+
 	pm_runtime_put_sync(&pdev->dev);
 
 	return 0;

