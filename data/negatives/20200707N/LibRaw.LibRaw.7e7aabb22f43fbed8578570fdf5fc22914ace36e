commit 7e7aabb22f43fbed8578570fdf5fc22914ace36e
Author: Alex Tutubalin <lexa@lexa.ru>
Date:   Fri Dec 17 20:18:16 2010 +0300

    new huffman for most unpackers(2)

diff --git a/dcraw/dcraw.c b/dcraw/dcraw.c
index 8a163ce..2fbc71d 100644
--- a/dcraw/dcraw.c
+++ b/dcraw/dcraw.c
@@ -1013,12 +1013,10 @@ ushort * CLASS ljpeg_row_new (int jrow, struct jhead *jh, LibRaw_bit_buffer& bit
   if (jrow * jh->wide % jh->restart == 0) {
     FORC(6) jh->vpred[c] = 1 << (jh->bits-1);
     if (jrow) {
-//        fseek (ifp, -2, SEEK_CUR); // we need to change it to bytes!!!!
         bytes->unseek2();
-      do mark = (mark << 8) + (c = bytes->get_byte());
-      while (c != EOF && mark >> 4 != 0xffd);
+        do mark = (mark << 8) + (c = bytes->get_byte());
+        while (c != EOF && mark >> 4 != 0xffd);
     }
-//    getbits(-1);
     bits.reset();
   }
   FORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);
@@ -1367,18 +1365,41 @@ void CLASS adobe_dng_load_raw_nc()
 
   pixel = (ushort *) calloc (raw_width * tiff_samples, sizeof *pixel);
   merror (pixel, "adobe_dng_load_raw_nc()");
+
+#ifdef LIBRAW_LIBRARY_BUILD
+  LibRaw_byte_buffer *buf = NULL;
+  if (tiff_bps != 16)
+      {
+          if(!data_size)
+              throw LIBRAW_EXCEPTION_IO_BADFILE;
+          buf = ifp->make_byte_buffer(data_size);
+      }
+  LibRaw_bit_buffer bits;
+#endif
+
   for (row=0; row < raw_height; row++) {
     if (tiff_bps == 16)
       read_shorts (pixel, raw_width * tiff_samples);
     else {
+#ifdef LIBRAW_LIBRARY_BUILD
+        bits.reset();
+        for (col=0; col < raw_width * tiff_samples; col++)
+            pixel[col] = bits._getbits(buf,tiff_bps,zero_after_ff);
+
+#else
       getbits(-1);
       for (col=0; col < raw_width * tiff_samples; col++)
 	pixel[col] = getbits(tiff_bps);
+#endif
     }
     for (rp=pixel, col=0; col < raw_width; col++)
       adobe_copy_pixel (row, col, &rp);
   }
   free (pixel);
+#ifdef LIBRAW_LIBRARY_BUILD
+    if(buf)
+        delete buf;
+#endif
 }
 
 void CLASS pentax_load_raw()
@@ -2513,18 +2534,34 @@ void CLASS olympus_load_raw()
   for (i=12; i--; )
     FORC(2048 >> i) huff[++n] = (i+1) << 8 | i;
   fseek (ifp, 7, SEEK_CUR);
+#ifdef LIBRAW_LIBRARY_BUILD
+  if(!data_size)
+      throw LIBRAW_EXCEPTION_IO_BADFILE;
+  LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);
+  LibRaw_bit_buffer bits;
+  bits.reset();
+#else
   getbits(-1);
+#endif
   for (row=0; row < height; row++) {
     memset (acarry, 0, sizeof acarry);
     for (col=0; col < raw_width; col++) {
       carry = acarry[col & 1];
       i = 2 * (carry[2] < 3);
       for (nbits=2+i; (ushort) carry[0] >> (nbits+i); nbits++);
+#ifdef LIBRAW_LIBRARY_BUILD
+      low = (sign = bits._getbits(buf,3,zero_after_ff)) & 3;
+      sign = sign << 29 >> 31;
+      if ((high = bits._gethuff(buf,12,huff,zero_after_ff)) == 12)
+          high = bits._getbits(buf,16-nbits,zero_after_ff) >> 1;
+      carry[0] = (high << nbits) | bits._getbits(buf,nbits,zero_after_ff);
+#else
       low = (sign = getbits(3)) & 3;
       sign = sign << 29 >> 31;
       if ((high = getbithuff(12,huff)) == 12)
 	high = getbits(16-nbits) >> 1;
       carry[0] = (high << nbits) | getbits(nbits);
+#endif
       diff = (carry[0] ^ sign) + carry[1];
       carry[1] = (diff*3 + carry[1]) >> 5;
       carry[2] = carry[0] > 16 ? 0 : carry[2]+1;
@@ -2555,6 +2592,9 @@ void CLASS olympus_load_raw()
 #endif
     }
   }
+#ifdef LIBRAW_LIBRARY_BUILD
+  delete buf;
+#endif
 }
 
 void CLASS minolta_rd175_load_raw()
@@ -3280,12 +3320,25 @@ void CLASS sony_arw_load_raw()
 
   for (n=i=0; i < 18; i++)
     FORC(32768 >> (tab[i] >> 8)) huff[n++] = tab[i];
+#ifdef LIBRAW_LIBRARY_BUILD
+  if(!data_size)
+      throw LIBRAW_EXCEPTION_IO_BADFILE;
+  LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);
+  LibRaw_bit_buffer bits;
+  bits.reset();
+#else
   getbits(-1);
+#endif
   for (col = raw_width; col--; )
     for (row=0; row < raw_height+1; row+=2) {
       if (row == raw_height) row = 1;
+#ifdef LIBRAW_LIBRARY_BUILD
+      len = bits._gethuff(buf,15,huff,zero_after_ff);
+      diff = bits._getbits(buf,len,zero_after_ff);
+#else
       len = getbithuff(15,huff);
       diff = getbits(len);
+#endif
       if ((diff & (1 << (len-1))) == 0)
 	diff -= (1 << len) - 1;
       if ((sum += diff) >> 12) derror();
@@ -3305,6 +3358,9 @@ void CLASS sony_arw_load_raw()
           }
 #endif
     }
+#ifdef LIBRAW_LIBRARY_BUILD
+  delete buf;
+#endif
 }
 
 void CLASS sony_arw2_load_raw()
diff --git a/internal/dcraw_common.cpp b/internal/dcraw_common.cpp
index f651c44..df56db2 100644
--- a/internal/dcraw_common.cpp
+++ b/internal/dcraw_common.cpp
@@ -737,12 +737,10 @@ ushort * CLASS ljpeg_row_new (int jrow, struct jhead *jh, LibRaw_bit_buffer& bit
   if (jrow * jh->wide % jh->restart == 0) {
     FORC(6) jh->vpred[c] = 1 << (jh->bits-1);
     if (jrow) {
-//        fseek (ifp, -2, SEEK_CUR); // we need to change it to bytes!!!!
         bytes->unseek2();
-      do mark = (mark << 8) + (c = bytes->get_byte());
-      while (c != EOF && mark >> 4 != 0xffd);
+        do mark = (mark << 8) + (c = bytes->get_byte());
+        while (c != EOF && mark >> 4 != 0xffd);
     }
-//    getbits(-1);
     bits.reset();
   }
   FORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);
@@ -1091,18 +1089,41 @@ void CLASS adobe_dng_load_raw_nc()
 
   pixel = (ushort *) calloc (raw_width * tiff_samples, sizeof *pixel);
   merror (pixel, "adobe_dng_load_raw_nc()");
+
+#ifdef LIBRAW_LIBRARY_BUILD
+  LibRaw_byte_buffer *buf = NULL;
+  if (tiff_bps != 16)
+      {
+          if(!data_size)
+              throw LIBRAW_EXCEPTION_IO_BADFILE;
+          buf = ifp->make_byte_buffer(data_size);
+      }
+  LibRaw_bit_buffer bits;
+#endif
+
   for (row=0; row < raw_height; row++) {
     if (tiff_bps == 16)
       read_shorts (pixel, raw_width * tiff_samples);
     else {
+#ifdef LIBRAW_LIBRARY_BUILD
+        bits.reset();
+        for (col=0; col < raw_width * tiff_samples; col++)
+            pixel[col] = bits._getbits(buf,tiff_bps,zero_after_ff);
+
+#else
       getbits(-1);
       for (col=0; col < raw_width * tiff_samples; col++)
 	pixel[col] = getbits(tiff_bps);
+#endif
     }
     for (rp=pixel, col=0; col < raw_width; col++)
       adobe_copy_pixel (row, col, &rp);
   }
   free (pixel);
+#ifdef LIBRAW_LIBRARY_BUILD
+    if(buf)
+        delete buf;
+#endif
 }
 
 void CLASS pentax_load_raw()
@@ -1423,7 +1444,7 @@ void CLASS fuji_load_raw()
   free (pixel);
 #endif
 }
-#line 1707 "dcraw/dcraw.c"
+#line 1728 "dcraw/dcraw.c"
 void CLASS ppm_thumb()
 {
   char *thumb;
@@ -1958,7 +1979,7 @@ void CLASS leaf_hdr_load_raw()
   }
 }
 
-#line 2245 "dcraw/dcraw.c"
+#line 2266 "dcraw/dcraw.c"
 void CLASS sinar_4shot_load_raw()
 {
   ushort *pixel;
@@ -2230,18 +2251,34 @@ void CLASS olympus_load_raw()
   for (i=12; i--; )
     FORC(2048 >> i) huff[++n] = (i+1) << 8 | i;
   fseek (ifp, 7, SEEK_CUR);
+#ifdef LIBRAW_LIBRARY_BUILD
+  if(!data_size)
+      throw LIBRAW_EXCEPTION_IO_BADFILE;
+  LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);
+  LibRaw_bit_buffer bits;
+  bits.reset();
+#else
   getbits(-1);
+#endif
   for (row=0; row < height; row++) {
     memset (acarry, 0, sizeof acarry);
     for (col=0; col < raw_width; col++) {
       carry = acarry[col & 1];
       i = 2 * (carry[2] < 3);
       for (nbits=2+i; (ushort) carry[0] >> (nbits+i); nbits++);
+#ifdef LIBRAW_LIBRARY_BUILD
+      low = (sign = bits._getbits(buf,3,zero_after_ff)) & 3;
+      sign = sign << 29 >> 31;
+      if ((high = bits._gethuff(buf,12,huff,zero_after_ff)) == 12)
+          high = bits._getbits(buf,16-nbits,zero_after_ff) >> 1;
+      carry[0] = (high << nbits) | bits._getbits(buf,nbits,zero_after_ff);
+#else
       low = (sign = getbits(3)) & 3;
       sign = sign << 29 >> 31;
       if ((high = getbithuff(12,huff)) == 12)
 	high = getbits(16-nbits) >> 1;
       carry[0] = (high << nbits) | getbits(nbits);
+#endif
       diff = (carry[0] ^ sign) + carry[1];
       carry[1] = (diff*3 + carry[1]) >> 5;
       carry[2] = carry[0] > 16 ? 0 : carry[2]+1;
@@ -2272,6 +2309,9 @@ void CLASS olympus_load_raw()
 #endif
     }
   }
+#ifdef LIBRAW_LIBRARY_BUILD
+  delete buf;
+#endif
 }
 
 void CLASS minolta_rd175_load_raw()
@@ -2997,12 +3037,25 @@ void CLASS sony_arw_load_raw()
 
   for (n=i=0; i < 18; i++)
     FORC(32768 >> (tab[i] >> 8)) huff[n++] = tab[i];
+#ifdef LIBRAW_LIBRARY_BUILD
+  if(!data_size)
+      throw LIBRAW_EXCEPTION_IO_BADFILE;
+  LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);
+  LibRaw_bit_buffer bits;
+  bits.reset();
+#else
   getbits(-1);
+#endif
   for (col = raw_width; col--; )
     for (row=0; row < raw_height+1; row+=2) {
       if (row == raw_height) row = 1;
+#ifdef LIBRAW_LIBRARY_BUILD
+      len = bits._gethuff(buf,15,huff,zero_after_ff);
+      diff = bits._getbits(buf,len,zero_after_ff);
+#else
       len = getbithuff(15,huff);
       diff = getbits(len);
+#endif
       if ((diff & (1 << (len-1))) == 0)
 	diff -= (1 << len) - 1;
       if ((sum += diff) >> 12) derror();
@@ -3022,6 +3075,9 @@ void CLASS sony_arw_load_raw()
           }
 #endif
     }
+#ifdef LIBRAW_LIBRARY_BUILD
+  delete buf;
+#endif
 }
 
 void CLASS sony_arw2_load_raw()
@@ -3220,7 +3276,7 @@ void CLASS smal_v9_load_raw()
     smal_decode_segment (seg+i, holes);
   if (holes) fill_holes (holes);
 }
-#line 3671 "dcraw/dcraw.c"
+#line 3727 "dcraw/dcraw.c"
 
 void CLASS crop_pixels()
 {
@@ -4611,7 +4667,7 @@ void CLASS parse_thumb_note (int base, unsigned toff, unsigned tlen)
   }
 }
 
-#line 5065 "dcraw/dcraw.c"
+#line 5121 "dcraw/dcraw.c"
 void CLASS parse_makernote (int base, int uptag)
 {
   static const uchar xlat[2][256] = {
@@ -5167,7 +5223,7 @@ void CLASS parse_kodak_ifd (int base)
   }
 }
 
-#line 5625 "dcraw/dcraw.c"
+#line 5681 "dcraw/dcraw.c"
 int CLASS parse_tiff_ifd (int base)
 {
   unsigned entries, tag, type, len, plen=16, save;
@@ -6416,7 +6472,7 @@ void CLASS parse_cine()
   data_offset  = (INT64) get4() + 8;
   data_offset += (INT64) get4() << 32;
 }
-#line 6880 "dcraw/dcraw.c"
+#line 6936 "dcraw/dcraw.c"
 void CLASS adobe_coeff (const char *p_make, const char *p_model)
 {
   static const struct {
@@ -7049,7 +7105,7 @@ short CLASS guess_byte_order (int words)
   return sum[0] < sum[1] ? 0x4d4d : 0x4949;
 }
 
-#line 7516 "dcraw/dcraw.c"
+#line 7572 "dcraw/dcraw.c"
 
 float CLASS find_green (int bps, int bite, int off0, int off1)
 {
@@ -8835,7 +8891,7 @@ else if (!strcmp(model,"QV-2000UX")) {
   }
 }
 
-#line 9395 "dcraw/dcraw.c"
+#line 9451 "dcraw/dcraw.c"
 void CLASS convert_to_rgb()
 {
   int row, col, c, i, j, k;
@@ -9054,7 +9110,7 @@ int CLASS flip_index (int row, int col)
   return row * iwidth + col;
 }
 
-#line 9638 "dcraw/dcraw.c"
+#line 9694 "dcraw/dcraw.c"
 void CLASS tiff_set (ushort *ntag,
 	ushort tag, ushort type, int count, int val)
 {
diff --git a/internal/dcraw_fileio.cpp b/internal/dcraw_fileio.cpp
index 7ac4f15..c6d1f44 100644
--- a/internal/dcraw_fileio.cpp
+++ b/internal/dcraw_fileio.cpp
@@ -21,14 +21,14 @@ it under the terms of the one of three licenses as you choose:
    for more information
 */
 
-#line 3510 "dcraw/dcraw.c"
+#line 3566 "dcraw/dcraw.c"
 #define CLASS LibRaw::
 #include "libraw/libraw_types.h"
 #define LIBRAW_LIBRARY_BUILD
 #include "libraw/libraw.h"
 #include "internal/defines.h"
 #include "internal/var_defines.h"
-#line 3520 "dcraw/dcraw.c"
+#line 3576 "dcraw/dcraw.c"
 
 /*
    Seach from the current directory up to the root looking for
@@ -54,7 +54,7 @@ void CLASS bad_pixels (const char *cfname)
 #endif
   if (cfname)
     fp = fopen (cfname, "r");
-#line 3571 "dcraw/dcraw.c"
+#line 3627 "dcraw/dcraw.c"
   if (!fp) 
       {
 #ifdef LIBRAW_LIBRARY_BUILD
@@ -152,7 +152,7 @@ void CLASS subtract (const char *fname)
   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);
 #endif
 }
-#line 9304 "dcraw/dcraw.c"
+#line 9360 "dcraw/dcraw.c"
 
 #ifndef NO_LCMS
 void CLASS apply_profile (const char *input, const char *output)
diff --git a/libraw/libraw_datastream.h b/libraw/libraw_datastream.h
index 7f09e8b..fdd3da2 100644
--- a/libraw/libraw_datastream.h
+++ b/libraw/libraw_datastream.h
@@ -154,7 +154,6 @@ class LibRaw_abstract_datastream
     LibRaw_abstract_datastream *substream;
 };
 
-#if 0
 class LibRaw_file_datastream: public LibRaw_abstract_datastream
 {
   protected:
@@ -279,7 +278,6 @@ class LibRaw_file_datastream: public LibRaw_abstract_datastream
     }
 };
 #undef LR_STREAM_CHK
-#endif
 
 class LibRaw_buffer_datastream : public LibRaw_abstract_datastream
 {
diff --git a/src/libraw_cxx.cpp b/src/libraw_cxx.cpp
index 918eb23..2b29bfb 100644
--- a/src/libraw_cxx.cpp
+++ b/src/libraw_cxx.cpp
@@ -566,15 +566,10 @@ int LibRaw::open_file(const char *fname, INT64 max_buf_size)
 
     LibRaw_abstract_datastream *stream;
     try {
-#if 0
         if(big)
          stream = new LibRaw_bigfile_datastream(fname);
         else
          stream = new LibRaw_file_datastream(fname);
-#else
-         stream = new LibRaw_bigfile_datastream(fname);
-
-#endif
     }
 
     catch (std::bad_alloc)

