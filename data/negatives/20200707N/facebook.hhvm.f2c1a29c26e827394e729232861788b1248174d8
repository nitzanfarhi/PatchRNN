commit f2c1a29c26e827394e729232861788b1248174d8
Author: ervan <ervan@facebook.com>
Date:   Tue Aug 10 18:05:09 2010 -0700

    Rebuild system files after merge
    
    Summary:
    A last minute merge of Fast Method Call needed a rebuild of the system files,
    which didn't happen.  This fixes that.
    
    Test Plan:
    fast_tests.  This was already tested with the Fast Method Call
    check-in.  All this does is add hphp_set_error_page to system files,
    and that is checked directly by running
    
    DiffCamp Revision: 144138
    Reviewed By: iproctor
    CC: hphp-diffs@lists, iproctor, bill
    Tasks:
    
    Revert Plan:
    OK

diff --git a/src/system/gen/cls/__php_incomplete_class.h b/src/system/gen/cls/__php_incomplete_class.h
index 178a40b870..6e757c46a6 100644
--- a/src/system/gen/cls/__php_incomplete_class.h
+++ b/src/system/gen/cls/__php_incomplete_class.h
@@ -38,16 +38,16 @@ class c___php_incomplete_class : public ExtObjectData {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY___php_incomplete_class 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY___php_incomplete_class 1
-  #define OMIT_JUMP_TABLE_CLASS_exists___php_incomplete_class 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE___php_incomplete_class 1
-  #define OMIT_JUMP_TABLE_CLASS_get___php_incomplete_class 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE___php_incomplete_class 1
-  #define OMIT_JUMP_TABLE_CLASS_set___php_incomplete_class 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE___php_incomplete_class 1
-  #define OMIT_JUMP_TABLE_CLASS_lval___php_incomplete_class 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE___php_incomplete_class 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY___php_incomplete_class 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY___php_incomplete_class 1
+#define OMIT_JUMP_TABLE_CLASS_exists___php_incomplete_class 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE___php_incomplete_class 1
+#define OMIT_JUMP_TABLE_CLASS_get___php_incomplete_class 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE___php_incomplete_class 1
+#define OMIT_JUMP_TABLE_CLASS_set___php_incomplete_class 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE___php_incomplete_class 1
+#define OMIT_JUMP_TABLE_CLASS_lval___php_incomplete_class 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE___php_incomplete_class 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/badfunctioncallexception.h b/src/system/gen/cls/badfunctioncallexception.h
index 2c5c4a2764..ff80f776a9 100644
--- a/src/system/gen/cls/badfunctioncallexception.h
+++ b/src/system/gen/cls/badfunctioncallexception.h
@@ -41,16 +41,16 @@ class c_badfunctioncallexception : public c_logicexception {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_badfunctioncallexception 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_badfunctioncallexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_badfunctioncallexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_badfunctioncallexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_badfunctioncallexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_badfunctioncallexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_badfunctioncallexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_badfunctioncallexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_badfunctioncallexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_badfunctioncallexception 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_badfunctioncallexception 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_badfunctioncallexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_badfunctioncallexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_badfunctioncallexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_badfunctioncallexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_badfunctioncallexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_badfunctioncallexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_badfunctioncallexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_badfunctioncallexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_badfunctioncallexception 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/badmethodcallexception.h b/src/system/gen/cls/badmethodcallexception.h
index ec837f8302..760c536187 100644
--- a/src/system/gen/cls/badmethodcallexception.h
+++ b/src/system/gen/cls/badmethodcallexception.h
@@ -42,16 +42,16 @@ class c_badmethodcallexception : public c_badfunctioncallexception {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_badmethodcallexception 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_badmethodcallexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_badmethodcallexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_badmethodcallexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_badmethodcallexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_badmethodcallexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_badmethodcallexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_badmethodcallexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_badmethodcallexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_badmethodcallexception 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_badmethodcallexception 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_badmethodcallexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_badmethodcallexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_badmethodcallexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_badmethodcallexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_badmethodcallexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_badmethodcallexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_badmethodcallexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_badmethodcallexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_badmethodcallexception 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/directory.h b/src/system/gen/cls/directory.h
index 61c83ae20e..52bc73cd71 100644
--- a/src/system/gen/cls/directory.h
+++ b/src/system/gen/cls/directory.h
@@ -39,15 +39,15 @@ class c_directory : public ExtObjectData {
   // DECLARE_INSTANCE_PROP_OPS
   public:
   virtual void o_getArray(Array &props) const;
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_directory 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_directory 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_directory 1
-  #define OMIT_JUMP_TABLE_CLASS_get_directory 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_directory 1
-  #define OMIT_JUMP_TABLE_CLASS_set_directory 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_directory 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_directory 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_directory 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_directory 1
+#define OMIT_JUMP_TABLE_CLASS_exists_directory 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_directory 1
+#define OMIT_JUMP_TABLE_CLASS_get_directory 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_directory 1
+#define OMIT_JUMP_TABLE_CLASS_set_directory 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_directory 1
+#define OMIT_JUMP_TABLE_CLASS_lval_directory 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_directory 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/directoryiterator.h b/src/system/gen/cls/directoryiterator.h
index ac8ed13ebe..29522e4703 100644
--- a/src/system/gen/cls/directoryiterator.h
+++ b/src/system/gen/cls/directoryiterator.h
@@ -45,16 +45,16 @@ class c_directoryiterator : public c_splfileinfo {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_directoryiterator 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_directoryiterator 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_directoryiterator 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_directoryiterator 1
-  #define OMIT_JUMP_TABLE_CLASS_get_directoryiterator 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_directoryiterator 1
-  #define OMIT_JUMP_TABLE_CLASS_set_directoryiterator 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_directoryiterator 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_directoryiterator 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_directoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_directoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_directoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_exists_directoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_directoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_get_directoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_directoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_set_directoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_directoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_lval_directoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_directoryiterator 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/domainexception.h b/src/system/gen/cls/domainexception.h
index 58eb84a9f8..d35133a570 100644
--- a/src/system/gen/cls/domainexception.h
+++ b/src/system/gen/cls/domainexception.h
@@ -41,16 +41,16 @@ class c_domainexception : public c_logicexception {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_domainexception 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_domainexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_domainexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domainexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_domainexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domainexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_domainexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domainexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_domainexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domainexception 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_domainexception 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_domainexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_domainexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_domainexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_domainexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_domainexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_domainexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_domainexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_domainexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_domainexception 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/errorexception.h b/src/system/gen/cls/errorexception.h
index 27788cde69..b7791861f9 100644
--- a/src/system/gen/cls/errorexception.h
+++ b/src/system/gen/cls/errorexception.h
@@ -41,15 +41,15 @@ class c_errorexception : public c_exception {
   // DECLARE_INSTANCE_PROP_OPS
   public:
   virtual void o_getArray(Array &props) const;
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_errorexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_errorexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_errorexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_errorexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_errorexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_errorexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_errorexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_errorexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_errorexception 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_errorexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_errorexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_errorexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_errorexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_errorexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_errorexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_errorexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_errorexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_errorexception 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/exception.h b/src/system/gen/cls/exception.h
index 62d0db719a..1dc22e1467 100644
--- a/src/system/gen/cls/exception.h
+++ b/src/system/gen/cls/exception.h
@@ -39,15 +39,15 @@ class c_exception : public ExtObjectData {
   // DECLARE_INSTANCE_PROP_OPS
   public:
   virtual void o_getArray(Array &props) const;
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_exception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_exception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_exception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_exception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_exception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_exception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_exception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_exception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_exception 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_exception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_exception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_exception 1
+#define OMIT_JUMP_TABLE_CLASS_get_exception 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_exception 1
+#define OMIT_JUMP_TABLE_CLASS_set_exception 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_exception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_exception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_exception 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/filteriterator.h b/src/system/gen/cls/filteriterator.h
index 2fb38cfa63..0a01da98f4 100644
--- a/src/system/gen/cls/filteriterator.h
+++ b/src/system/gen/cls/filteriterator.h
@@ -42,16 +42,16 @@ class c_filteriterator : public ExtObjectData {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_filteriterator 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_filteriterator 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_filteriterator 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_filteriterator 1
-  #define OMIT_JUMP_TABLE_CLASS_get_filteriterator 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_filteriterator 1
-  #define OMIT_JUMP_TABLE_CLASS_set_filteriterator 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_filteriterator 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_filteriterator 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_filteriterator 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_filteriterator 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_filteriterator 1
+#define OMIT_JUMP_TABLE_CLASS_exists_filteriterator 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_filteriterator 1
+#define OMIT_JUMP_TABLE_CLASS_get_filteriterator 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_filteriterator 1
+#define OMIT_JUMP_TABLE_CLASS_set_filteriterator 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_filteriterator 1
+#define OMIT_JUMP_TABLE_CLASS_lval_filteriterator 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_filteriterator 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/invalidargumentexception.h b/src/system/gen/cls/invalidargumentexception.h
index 5e05d70f37..1c869e835b 100644
--- a/src/system/gen/cls/invalidargumentexception.h
+++ b/src/system/gen/cls/invalidargumentexception.h
@@ -41,16 +41,16 @@ class c_invalidargumentexception : public c_logicexception {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_invalidargumentexception 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_invalidargumentexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_invalidargumentexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_invalidargumentexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_invalidargumentexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_invalidargumentexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_invalidargumentexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_invalidargumentexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_invalidargumentexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_invalidargumentexception 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_invalidargumentexception 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_invalidargumentexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_invalidargumentexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_invalidargumentexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_invalidargumentexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_invalidargumentexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_invalidargumentexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_invalidargumentexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_invalidargumentexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_invalidargumentexception 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/lengthexception.h b/src/system/gen/cls/lengthexception.h
index cc940fd9de..bc899f679f 100644
--- a/src/system/gen/cls/lengthexception.h
+++ b/src/system/gen/cls/lengthexception.h
@@ -41,16 +41,16 @@ class c_lengthexception : public c_logicexception {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_lengthexception 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_lengthexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_lengthexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_lengthexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_lengthexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_lengthexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_lengthexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_lengthexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_lengthexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_lengthexception 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_lengthexception 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_lengthexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_lengthexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_lengthexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_lengthexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_lengthexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_lengthexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_lengthexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_lengthexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_lengthexception 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/logicexception.h b/src/system/gen/cls/logicexception.h
index 738e218792..20ea36853a 100644
--- a/src/system/gen/cls/logicexception.h
+++ b/src/system/gen/cls/logicexception.h
@@ -40,16 +40,16 @@ class c_logicexception : public c_exception {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_logicexception 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_logicexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_logicexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_logicexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_logicexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_logicexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_logicexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_logicexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_logicexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_logicexception 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_logicexception 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_logicexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_logicexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_logicexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_logicexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_logicexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_logicexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_logicexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_logicexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_logicexception 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/outofboundsexception.h b/src/system/gen/cls/outofboundsexception.h
index a99d326975..ac5915b585 100644
--- a/src/system/gen/cls/outofboundsexception.h
+++ b/src/system/gen/cls/outofboundsexception.h
@@ -41,16 +41,16 @@ class c_outofboundsexception : public c_runtimeexception {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_outofboundsexception 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_outofboundsexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_outofboundsexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_outofboundsexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_outofboundsexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_outofboundsexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_outofboundsexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_outofboundsexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_outofboundsexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_outofboundsexception 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_outofboundsexception 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_outofboundsexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_outofboundsexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_outofboundsexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_outofboundsexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_outofboundsexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_outofboundsexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_outofboundsexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_outofboundsexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_outofboundsexception 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/outofrangeexception.h b/src/system/gen/cls/outofrangeexception.h
index 84394923d4..6c1b7d253b 100644
--- a/src/system/gen/cls/outofrangeexception.h
+++ b/src/system/gen/cls/outofrangeexception.h
@@ -41,16 +41,16 @@ class c_outofrangeexception : public c_logicexception {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_outofrangeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_outofrangeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_outofrangeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_outofrangeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_outofrangeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_outofrangeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_outofrangeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_outofrangeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_outofrangeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_outofrangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_outofrangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_outofrangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_outofrangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_outofrangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_outofrangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_outofrangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_outofrangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_outofrangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_outofrangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_outofrangeexception 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/overflowexception.h b/src/system/gen/cls/overflowexception.h
index a2fe5d3fbb..6cad5e5016 100644
--- a/src/system/gen/cls/overflowexception.h
+++ b/src/system/gen/cls/overflowexception.h
@@ -41,16 +41,16 @@ class c_overflowexception : public c_runtimeexception {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_overflowexception 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_overflowexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_overflowexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_overflowexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_overflowexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_overflowexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_overflowexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_overflowexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_overflowexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_overflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_overflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_overflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_overflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_overflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_overflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_overflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_overflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_overflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_overflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_overflowexception 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/pear_error.h b/src/system/gen/cls/pear_error.h
index e6218c4392..fe25fcf5c6 100644
--- a/src/system/gen/cls/pear_error.h
+++ b/src/system/gen/cls/pear_error.h
@@ -38,16 +38,16 @@ class c_pear_error : public ExtObjectData {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_pear_error 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_pear_error 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_pear_error 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pear_error 1
-  #define OMIT_JUMP_TABLE_CLASS_get_pear_error 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pear_error 1
-  #define OMIT_JUMP_TABLE_CLASS_set_pear_error 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pear_error 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_pear_error 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pear_error 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_pear_error 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_pear_error 1
+#define OMIT_JUMP_TABLE_CLASS_exists_pear_error 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_pear_error 1
+#define OMIT_JUMP_TABLE_CLASS_get_pear_error 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_pear_error 1
+#define OMIT_JUMP_TABLE_CLASS_set_pear_error 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_pear_error 1
+#define OMIT_JUMP_TABLE_CLASS_lval_pear_error 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_pear_error 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/rangeexception.h b/src/system/gen/cls/rangeexception.h
index 17d04fd0ca..3cd2d3ab9d 100644
--- a/src/system/gen/cls/rangeexception.h
+++ b/src/system/gen/cls/rangeexception.h
@@ -41,16 +41,16 @@ class c_rangeexception : public c_runtimeexception {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_rangeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_rangeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_rangeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_rangeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_rangeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_rangeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_rangeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_rangeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_rangeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_rangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_rangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_rangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_rangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_rangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_rangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_rangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_rangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_rangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_rangeexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_rangeexception 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/recursivedirectoryiterator.h b/src/system/gen/cls/recursivedirectoryiterator.h
index 1728ea315b..1733a24da4 100644
--- a/src/system/gen/cls/recursivedirectoryiterator.h
+++ b/src/system/gen/cls/recursivedirectoryiterator.h
@@ -46,16 +46,16 @@ class c_recursivedirectoryiterator : public c_directoryiterator {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_recursivedirectoryiterator 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_recursivedirectoryiterator 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_recursivedirectoryiterator 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_recursivedirectoryiterator 1
-  #define OMIT_JUMP_TABLE_CLASS_get_recursivedirectoryiterator 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_recursivedirectoryiterator 1
-  #define OMIT_JUMP_TABLE_CLASS_set_recursivedirectoryiterator 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_recursivedirectoryiterator 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_recursivedirectoryiterator 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_recursivedirectoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_recursivedirectoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_recursivedirectoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_exists_recursivedirectoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_recursivedirectoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_get_recursivedirectoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_recursivedirectoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_set_recursivedirectoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_recursivedirectoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_lval_recursivedirectoryiterator 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_recursivedirectoryiterator 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/recursiveiteratoriterator.h b/src/system/gen/cls/recursiveiteratoriterator.h
index 8362da67d3..d0c8223463 100644
--- a/src/system/gen/cls/recursiveiteratoriterator.h
+++ b/src/system/gen/cls/recursiveiteratoriterator.h
@@ -43,16 +43,16 @@ class c_recursiveiteratoriterator : public ExtObjectData {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_recursiveiteratoriterator 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_recursiveiteratoriterator 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_recursiveiteratoriterator 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_recursiveiteratoriterator 1
-  #define OMIT_JUMP_TABLE_CLASS_get_recursiveiteratoriterator 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_recursiveiteratoriterator 1
-  #define OMIT_JUMP_TABLE_CLASS_set_recursiveiteratoriterator 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_recursiveiteratoriterator 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_recursiveiteratoriterator 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_recursiveiteratoriterator 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_recursiveiteratoriterator 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_recursiveiteratoriterator 1
+#define OMIT_JUMP_TABLE_CLASS_exists_recursiveiteratoriterator 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_recursiveiteratoriterator 1
+#define OMIT_JUMP_TABLE_CLASS_get_recursiveiteratoriterator 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_recursiveiteratoriterator 1
+#define OMIT_JUMP_TABLE_CLASS_set_recursiveiteratoriterator 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_recursiveiteratoriterator 1
+#define OMIT_JUMP_TABLE_CLASS_lval_recursiveiteratoriterator 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_recursiveiteratoriterator 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/reflectionexception.h b/src/system/gen/cls/reflectionexception.h
index 0d4778c778..290e1758b5 100644
--- a/src/system/gen/cls/reflectionexception.h
+++ b/src/system/gen/cls/reflectionexception.h
@@ -40,16 +40,16 @@ class c_reflectionexception : public c_exception {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionexception 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_reflectionexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_reflectionexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_reflectionexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_reflectionexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_reflectionexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionexception 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionexception 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_reflectionexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_reflectionexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_reflectionexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_reflectionexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_reflectionexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionexception 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/reflectionfunction.h b/src/system/gen/cls/reflectionfunction.h
index 45271eeb5a..6cf9c012d8 100644
--- a/src/system/gen/cls/reflectionfunction.h
+++ b/src/system/gen/cls/reflectionfunction.h
@@ -42,16 +42,16 @@ class c_reflectionfunction : public c_reflectionfunctionabstract {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionfunction 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_reflectionfunction 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_reflectionfunction 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionfunction 1
-  #define OMIT_JUMP_TABLE_CLASS_get_reflectionfunction 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionfunction 1
-  #define OMIT_JUMP_TABLE_CLASS_set_reflectionfunction 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionfunction 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_reflectionfunction 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionfunction 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionfunction 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_reflectionfunction 1
+#define OMIT_JUMP_TABLE_CLASS_exists_reflectionfunction 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionfunction 1
+#define OMIT_JUMP_TABLE_CLASS_get_reflectionfunction 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionfunction 1
+#define OMIT_JUMP_TABLE_CLASS_set_reflectionfunction 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionfunction 1
+#define OMIT_JUMP_TABLE_CLASS_lval_reflectionfunction 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionfunction 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/reflectionfunctionabstract.h b/src/system/gen/cls/reflectionfunctionabstract.h
index 6fb68c30b9..50c3d92c9f 100644
--- a/src/system/gen/cls/reflectionfunctionabstract.h
+++ b/src/system/gen/cls/reflectionfunctionabstract.h
@@ -39,15 +39,15 @@ class c_reflectionfunctionabstract : public ExtObjectData {
   // DECLARE_INSTANCE_PROP_OPS
   public:
   virtual void o_getArray(Array &props) const;
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_reflectionfunctionabstract 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_reflectionfunctionabstract 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionfunctionabstract 1
-  #define OMIT_JUMP_TABLE_CLASS_get_reflectionfunctionabstract 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionfunctionabstract 1
-  #define OMIT_JUMP_TABLE_CLASS_set_reflectionfunctionabstract 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionfunctionabstract 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_reflectionfunctionabstract 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionfunctionabstract 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_reflectionfunctionabstract 1
+#define OMIT_JUMP_TABLE_CLASS_exists_reflectionfunctionabstract 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionfunctionabstract 1
+#define OMIT_JUMP_TABLE_CLASS_get_reflectionfunctionabstract 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionfunctionabstract 1
+#define OMIT_JUMP_TABLE_CLASS_set_reflectionfunctionabstract 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionfunctionabstract 1
+#define OMIT_JUMP_TABLE_CLASS_lval_reflectionfunctionabstract 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionfunctionabstract 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/reflectionmethod.h b/src/system/gen/cls/reflectionmethod.h
index bf62ebc2e6..dc3e855a85 100644
--- a/src/system/gen/cls/reflectionmethod.h
+++ b/src/system/gen/cls/reflectionmethod.h
@@ -43,15 +43,15 @@ class c_reflectionmethod : public c_reflectionfunctionabstract {
   // DECLARE_INSTANCE_PROP_OPS
   public:
   virtual void o_getArray(Array &props) const;
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_reflectionmethod 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_reflectionmethod 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionmethod 1
-  #define OMIT_JUMP_TABLE_CLASS_get_reflectionmethod 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionmethod 1
-  #define OMIT_JUMP_TABLE_CLASS_set_reflectionmethod 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionmethod 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_reflectionmethod 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionmethod 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_reflectionmethod 1
+#define OMIT_JUMP_TABLE_CLASS_exists_reflectionmethod 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionmethod 1
+#define OMIT_JUMP_TABLE_CLASS_get_reflectionmethod 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionmethod 1
+#define OMIT_JUMP_TABLE_CLASS_set_reflectionmethod 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionmethod 1
+#define OMIT_JUMP_TABLE_CLASS_lval_reflectionmethod 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionmethod 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/reflectionobject.h b/src/system/gen/cls/reflectionobject.h
index 7ea718007a..306611313f 100644
--- a/src/system/gen/cls/reflectionobject.h
+++ b/src/system/gen/cls/reflectionobject.h
@@ -41,24 +41,24 @@ class c_reflectionobject : public c_reflectionclass {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionobject 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_reflectionobject 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_reflectionobject 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_reflectionobject 1
   bool o_exists(CStrRef s, int64 hash, CStrRef context = null_string) const
 { return ObjectData::o_exists(s, hash, context); }
     virtual bool o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const;
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionobject 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionobject 1
   Variant o_get(CStrRef s, int64 hash, bool error = true, CStrRef context = null_string)
 { return ObjectData::o_get(s, hash, error, context); }
     virtual Variant o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash);
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionobject 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionobject 1
   Variant o_set(CStrRef s, int64 hash, CVarRef v, bool forInit = false, CStrRef context = null_string)
 { return ObjectData::o_set(s, hash, v, forInit, context); }
     virtual Variant o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash);
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionobject 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionobject 1
   Variant &o_lval(CStrRef s, int64 hash, CStrRef context = null_string)
 { return ObjectData::o_lval(s, hash, context); }
     virtual Variant &o_lval(CStrRef prop, int64 phash, const char *context, int64 hash);
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionobject 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionobject 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/reflectionparameter.h b/src/system/gen/cls/reflectionparameter.h
index d74bf23ba9..87b4596360 100644
--- a/src/system/gen/cls/reflectionparameter.h
+++ b/src/system/gen/cls/reflectionparameter.h
@@ -41,15 +41,15 @@ class c_reflectionparameter : public ExtObjectData {
   // DECLARE_INSTANCE_PROP_OPS
   public:
   virtual void o_getArray(Array &props) const;
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_reflectionparameter 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_reflectionparameter 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionparameter 1
-  #define OMIT_JUMP_TABLE_CLASS_get_reflectionparameter 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionparameter 1
-  #define OMIT_JUMP_TABLE_CLASS_set_reflectionparameter 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionparameter 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_reflectionparameter 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionparameter 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_reflectionparameter 1
+#define OMIT_JUMP_TABLE_CLASS_exists_reflectionparameter 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionparameter 1
+#define OMIT_JUMP_TABLE_CLASS_get_reflectionparameter 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionparameter 1
+#define OMIT_JUMP_TABLE_CLASS_set_reflectionparameter 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionparameter 1
+#define OMIT_JUMP_TABLE_CLASS_lval_reflectionparameter 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionparameter 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/reflectionproperty.h b/src/system/gen/cls/reflectionproperty.h
index 46e7c8b74b..1bf67143d9 100644
--- a/src/system/gen/cls/reflectionproperty.h
+++ b/src/system/gen/cls/reflectionproperty.h
@@ -41,15 +41,15 @@ class c_reflectionproperty : public ExtObjectData {
   // DECLARE_INSTANCE_PROP_OPS
   public:
   virtual void o_getArray(Array &props) const;
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_reflectionproperty 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_reflectionproperty 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionproperty 1
-  #define OMIT_JUMP_TABLE_CLASS_get_reflectionproperty 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionproperty 1
-  #define OMIT_JUMP_TABLE_CLASS_set_reflectionproperty 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionproperty 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_reflectionproperty 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionproperty 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_reflectionproperty 1
+#define OMIT_JUMP_TABLE_CLASS_exists_reflectionproperty 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_reflectionproperty 1
+#define OMIT_JUMP_TABLE_CLASS_get_reflectionproperty 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_reflectionproperty 1
+#define OMIT_JUMP_TABLE_CLASS_set_reflectionproperty 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_reflectionproperty 1
+#define OMIT_JUMP_TABLE_CLASS_lval_reflectionproperty 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_reflectionproperty 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/runtimeexception.h b/src/system/gen/cls/runtimeexception.h
index dd4f259ce1..51558dcac7 100644
--- a/src/system/gen/cls/runtimeexception.h
+++ b/src/system/gen/cls/runtimeexception.h
@@ -40,16 +40,16 @@ class c_runtimeexception : public c_exception {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_runtimeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_runtimeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_runtimeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_runtimeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_runtimeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_runtimeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_runtimeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_runtimeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_runtimeexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_runtimeexception 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_runtimeexception 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_runtimeexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_runtimeexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_runtimeexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_runtimeexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_runtimeexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_runtimeexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_runtimeexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_runtimeexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_runtimeexception 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/splfileinfo.h b/src/system/gen/cls/splfileinfo.h
index 9dfd94816b..f8bff24511 100644
--- a/src/system/gen/cls/splfileinfo.h
+++ b/src/system/gen/cls/splfileinfo.h
@@ -38,16 +38,16 @@ class c_splfileinfo : public ExtObjectData {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_splfileinfo 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_splfileinfo 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_splfileinfo 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_splfileinfo 1
-  #define OMIT_JUMP_TABLE_CLASS_get_splfileinfo 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_splfileinfo 1
-  #define OMIT_JUMP_TABLE_CLASS_set_splfileinfo 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_splfileinfo 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_splfileinfo 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_splfileinfo 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_splfileinfo 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_splfileinfo 1
+#define OMIT_JUMP_TABLE_CLASS_exists_splfileinfo 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_splfileinfo 1
+#define OMIT_JUMP_TABLE_CLASS_get_splfileinfo 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_splfileinfo 1
+#define OMIT_JUMP_TABLE_CLASS_set_splfileinfo 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_splfileinfo 1
+#define OMIT_JUMP_TABLE_CLASS_lval_splfileinfo 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_splfileinfo 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/splfileobject.h b/src/system/gen/cls/splfileobject.h
index 30a992937d..78fc02bff7 100644
--- a/src/system/gen/cls/splfileobject.h
+++ b/src/system/gen/cls/splfileobject.h
@@ -47,16 +47,16 @@ class c_splfileobject : public c_splfileinfo {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_splfileobject 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_splfileobject 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_splfileobject 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_splfileobject 1
-  #define OMIT_JUMP_TABLE_CLASS_get_splfileobject 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_splfileobject 1
-  #define OMIT_JUMP_TABLE_CLASS_set_splfileobject 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_splfileobject 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_splfileobject 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_splfileobject 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_splfileobject 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_splfileobject 1
+#define OMIT_JUMP_TABLE_CLASS_exists_splfileobject 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_splfileobject 1
+#define OMIT_JUMP_TABLE_CLASS_get_splfileobject 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_splfileobject 1
+#define OMIT_JUMP_TABLE_CLASS_set_splfileobject 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_splfileobject 1
+#define OMIT_JUMP_TABLE_CLASS_lval_splfileobject 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_splfileobject 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/stdclass.h b/src/system/gen/cls/stdclass.h
index d58055b56d..3ff7e9d94c 100644
--- a/src/system/gen/cls/stdclass.h
+++ b/src/system/gen/cls/stdclass.h
@@ -38,16 +38,16 @@ class c_stdclass : public ExtObjectData {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_stdclass 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_stdclass 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_stdclass 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_stdclass 1
-  #define OMIT_JUMP_TABLE_CLASS_get_stdclass 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_stdclass 1
-  #define OMIT_JUMP_TABLE_CLASS_set_stdclass 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_stdclass 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_stdclass 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_stdclass 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_stdclass 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_stdclass 1
+#define OMIT_JUMP_TABLE_CLASS_exists_stdclass 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_stdclass 1
+#define OMIT_JUMP_TABLE_CLASS_get_stdclass 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_stdclass 1
+#define OMIT_JUMP_TABLE_CLASS_set_stdclass 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_stdclass 1
+#define OMIT_JUMP_TABLE_CLASS_lval_stdclass 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_stdclass 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/underflowexception.h b/src/system/gen/cls/underflowexception.h
index 124d813a76..665ad71d55 100644
--- a/src/system/gen/cls/underflowexception.h
+++ b/src/system/gen/cls/underflowexception.h
@@ -41,16 +41,16 @@ class c_underflowexception : public c_runtimeexception {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_underflowexception 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_underflowexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_underflowexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_underflowexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_underflowexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_underflowexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_underflowexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_underflowexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_underflowexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_underflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_underflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_underflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_underflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_underflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_underflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_underflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_underflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_underflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_underflowexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_underflowexception 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/cls/unexpectedvalueexception.h b/src/system/gen/cls/unexpectedvalueexception.h
index 2d3a3bacc3..776a1208a1 100644
--- a/src/system/gen/cls/unexpectedvalueexception.h
+++ b/src/system/gen/cls/unexpectedvalueexception.h
@@ -41,16 +41,16 @@ class c_unexpectedvalueexception : public c_runtimeexception {
 
   // DECLARE_INSTANCE_PROP_OPS
   public:
-  #define OMIT_JUMP_TABLE_CLASS_GETARRAY_unexpectedvalueexception 1
-  #define OMIT_JUMP_TABLE_CLASS_SETARRAY_unexpectedvalueexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_unexpectedvalueexception 1
-  #define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_unexpectedvalueexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_unexpectedvalueexception 1
-  #define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_unexpectedvalueexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_unexpectedvalueexception 1
-  #define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_unexpectedvalueexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_unexpectedvalueexception 1
-  #define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_unexpectedvalueexception 1
+#define OMIT_JUMP_TABLE_CLASS_GETARRAY_unexpectedvalueexception 1
+#define OMIT_JUMP_TABLE_CLASS_SETARRAY_unexpectedvalueexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_unexpectedvalueexception 1
+#define OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_unexpectedvalueexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_unexpectedvalueexception 1
+#define OMIT_JUMP_TABLE_CLASS_get_PRIVATE_unexpectedvalueexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_unexpectedvalueexception 1
+#define OMIT_JUMP_TABLE_CLASS_set_PRIVATE_unexpectedvalueexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_unexpectedvalueexception 1
+#define OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_unexpectedvalueexception 1
 
   // DECLARE_INSTANCE_PUBLIC_PROP_OPS
   public:
diff --git a/src/system/gen/php/classes/directory.cpp b/src/system/gen/php/classes/directory.cpp
index 24d99dab6d..740d7de34e 100644
--- a/src/system/gen/php/classes/directory.cpp
+++ b/src/system/gen/php/classes/directory.cpp
@@ -246,25 +246,30 @@ Variant c_directory::o_invoke(MethodIndex methodIndex, const char *s, CArrRef pa
   switch (methodIndex.m_callIndex) {
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("directory::__construct", count, 1, 1, 2);
-        return (t___construct(params[0]), null);
+        if (count != 1) return throw_wrong_arguments("Directory::__construct", count, 1, 1, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t___construct(arg0), null);
+        }
       }
       break;
     case 0x25:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directory::close", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Directory::close", 0, 1);
         return (t_close());
       }
       break;
     case 0x26:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directory::read", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Directory::read", 0, 1);
         return (t_read());
       }
       break;
     case 0x9:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directory::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Directory::rewind", 0, 1);
         return (t_rewind());
       }
       break;
@@ -314,25 +319,25 @@ Variant c_directory::o_invoke_few_args(MethodIndex methodIndex, const char *s, i
   switch (methodIndex.m_callIndex) {
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("directory::__construct", count, 1, 1, 2);
+        if (count != 1) return throw_wrong_arguments("Directory::__construct", count, 1, 1, 2);
         return (t___construct(a0), null);
       }
       break;
     case 0x25:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directory::close", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Directory::close", 0, 1);
         return (t_close());
       }
       break;
     case 0x26:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directory::read", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Directory::read", 0, 1);
         return (t_read());
       }
       break;
     case 0x9:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directory::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Directory::rewind", 0, 1);
         return (t_rewind());
       }
       break;
@@ -389,7 +394,7 @@ Variant c_directory::o_invoke_from_eval(const char *s, Eval::VariableEnvironment
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("directory::__construct", count, 1, 1, 2);
+        if (count != 1) return throw_wrong_arguments("Directory::__construct", count, 1, 1, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -406,7 +411,7 @@ Variant c_directory::o_invoke_from_eval(const char *s, Eval::VariableEnvironment
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("directory::close", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Directory::close", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -420,7 +425,7 @@ Variant c_directory::o_invoke_from_eval(const char *s, Eval::VariableEnvironment
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("directory::read", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Directory::read", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -434,7 +439,7 @@ Variant c_directory::o_invoke_from_eval(const char *s, Eval::VariableEnvironment
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("directory::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Directory::rewind", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
diff --git a/src/system/gen/php/classes/exception.cpp b/src/system/gen/php/classes/exception.cpp
index 3ba1a3abb7..9f9c775c78 100644
--- a/src/system/gen/php/classes/exception.cpp
+++ b/src/system/gen/php/classes/exception.cpp
@@ -131,57 +131,63 @@ Variant c_unexpectedvalueexception::o_invoke(MethodIndex methodIndex, const char
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
-        if (count <= 0) return (t___construct(), null);
-        if (count == 1) return (t___construct(params[0]), null);
-        return (t___construct(params[0], params[1]), null);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t___construct(), null);
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -266,19 +272,19 @@ Variant c_unexpectedvalueexception::o_invoke_few_args(MethodIndex methodIndex, c
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         if (count <= 0) return (t___construct(), null);
         if (count == 1) return (t___construct(a0), null);
         return (t___construct(a0, a1), null);
@@ -286,37 +292,37 @@ Variant c_unexpectedvalueexception::o_invoke_few_args(MethodIndex methodIndex, c
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -406,7 +412,7 @@ Variant c_unexpectedvalueexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -420,7 +426,7 @@ Variant c_unexpectedvalueexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -436,7 +442,7 @@ Variant c_unexpectedvalueexception::o_invoke_from_eval(const char *s, Eval::Vari
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -458,7 +464,7 @@ Variant c_unexpectedvalueexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -472,7 +478,7 @@ Variant c_unexpectedvalueexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -486,7 +492,7 @@ Variant c_unexpectedvalueexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -500,7 +506,7 @@ Variant c_unexpectedvalueexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -514,7 +520,7 @@ Variant c_unexpectedvalueexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -528,7 +534,7 @@ Variant c_unexpectedvalueexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -810,57 +816,63 @@ Variant c_overflowexception::o_invoke(MethodIndex methodIndex, const char *s, CA
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
-        if (count <= 0) return (t___construct(), null);
-        if (count == 1) return (t___construct(params[0]), null);
-        return (t___construct(params[0], params[1]), null);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t___construct(), null);
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -945,19 +957,19 @@ Variant c_overflowexception::o_invoke_few_args(MethodIndex methodIndex, const ch
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         if (count <= 0) return (t___construct(), null);
         if (count == 1) return (t___construct(a0), null);
         return (t___construct(a0, a1), null);
@@ -965,37 +977,37 @@ Variant c_overflowexception::o_invoke_few_args(MethodIndex methodIndex, const ch
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -1085,7 +1097,7 @@ Variant c_overflowexception::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1099,7 +1111,7 @@ Variant c_overflowexception::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1115,7 +1127,7 @@ Variant c_overflowexception::o_invoke_from_eval(const char *s, Eval::VariableEnv
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -1137,7 +1149,7 @@ Variant c_overflowexception::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1151,7 +1163,7 @@ Variant c_overflowexception::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1165,7 +1177,7 @@ Variant c_overflowexception::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1179,7 +1191,7 @@ Variant c_overflowexception::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1193,7 +1205,7 @@ Variant c_overflowexception::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1207,7 +1219,7 @@ Variant c_overflowexception::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1489,57 +1501,63 @@ Variant c_outofboundsexception::o_invoke(MethodIndex methodIndex, const char *s,
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
-        if (count <= 0) return (t___construct(), null);
-        if (count == 1) return (t___construct(params[0]), null);
-        return (t___construct(params[0], params[1]), null);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t___construct(), null);
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -1624,19 +1642,19 @@ Variant c_outofboundsexception::o_invoke_few_args(MethodIndex methodIndex, const
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         if (count <= 0) return (t___construct(), null);
         if (count == 1) return (t___construct(a0), null);
         return (t___construct(a0, a1), null);
@@ -1644,37 +1662,37 @@ Variant c_outofboundsexception::o_invoke_few_args(MethodIndex methodIndex, const
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -1764,7 +1782,7 @@ Variant c_outofboundsexception::o_invoke_from_eval(const char *s, Eval::Variable
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1778,7 +1796,7 @@ Variant c_outofboundsexception::o_invoke_from_eval(const char *s, Eval::Variable
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1794,7 +1812,7 @@ Variant c_outofboundsexception::o_invoke_from_eval(const char *s, Eval::Variable
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -1816,7 +1834,7 @@ Variant c_outofboundsexception::o_invoke_from_eval(const char *s, Eval::Variable
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1830,7 +1848,7 @@ Variant c_outofboundsexception::o_invoke_from_eval(const char *s, Eval::Variable
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1844,7 +1862,7 @@ Variant c_outofboundsexception::o_invoke_from_eval(const char *s, Eval::Variable
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1858,7 +1876,7 @@ Variant c_outofboundsexception::o_invoke_from_eval(const char *s, Eval::Variable
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1872,7 +1890,7 @@ Variant c_outofboundsexception::o_invoke_from_eval(const char *s, Eval::Variable
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1886,7 +1904,7 @@ Variant c_outofboundsexception::o_invoke_from_eval(const char *s, Eval::Variable
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2168,57 +2186,63 @@ Variant c_logicexception::o_invoke(MethodIndex methodIndex, const char *s, CArrR
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
-        if (count <= 0) return (t___construct(), null);
-        if (count == 1) return (t___construct(params[0]), null);
-        return (t___construct(params[0], params[1]), null);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t___construct(), null);
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -2303,19 +2327,19 @@ Variant c_logicexception::o_invoke_few_args(MethodIndex methodIndex, const char
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         if (count <= 0) return (t___construct(), null);
         if (count == 1) return (t___construct(a0), null);
         return (t___construct(a0, a1), null);
@@ -2323,37 +2347,37 @@ Variant c_logicexception::o_invoke_few_args(MethodIndex methodIndex, const char
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -2443,7 +2467,7 @@ Variant c_logicexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2457,7 +2481,7 @@ Variant c_logicexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2473,7 +2497,7 @@ Variant c_logicexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2495,7 +2519,7 @@ Variant c_logicexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2509,7 +2533,7 @@ Variant c_logicexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2523,7 +2547,7 @@ Variant c_logicexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2537,7 +2561,7 @@ Variant c_logicexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2551,7 +2575,7 @@ Variant c_logicexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2565,7 +2589,7 @@ Variant c_logicexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2847,57 +2871,63 @@ Variant c_rangeexception::o_invoke(MethodIndex methodIndex, const char *s, CArrR
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
-        if (count <= 0) return (t___construct(), null);
-        if (count == 1) return (t___construct(params[0]), null);
-        return (t___construct(params[0], params[1]), null);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t___construct(), null);
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -2982,19 +3012,19 @@ Variant c_rangeexception::o_invoke_few_args(MethodIndex methodIndex, const char
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         if (count <= 0) return (t___construct(), null);
         if (count == 1) return (t___construct(a0), null);
         return (t___construct(a0, a1), null);
@@ -3002,37 +3032,37 @@ Variant c_rangeexception::o_invoke_few_args(MethodIndex methodIndex, const char
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -3122,7 +3152,7 @@ Variant c_rangeexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3136,7 +3166,7 @@ Variant c_rangeexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3152,7 +3182,7 @@ Variant c_rangeexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -3174,7 +3204,7 @@ Variant c_rangeexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3188,7 +3218,7 @@ Variant c_rangeexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3202,7 +3232,7 @@ Variant c_rangeexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3216,7 +3246,7 @@ Variant c_rangeexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3230,7 +3260,7 @@ Variant c_rangeexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3244,7 +3274,7 @@ Variant c_rangeexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3526,57 +3556,63 @@ Variant c_invalidargumentexception::o_invoke(MethodIndex methodIndex, const char
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
-        if (count <= 0) return (t___construct(), null);
-        if (count == 1) return (t___construct(params[0]), null);
-        return (t___construct(params[0], params[1]), null);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t___construct(), null);
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -3661,19 +3697,19 @@ Variant c_invalidargumentexception::o_invoke_few_args(MethodIndex methodIndex, c
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         if (count <= 0) return (t___construct(), null);
         if (count == 1) return (t___construct(a0), null);
         return (t___construct(a0, a1), null);
@@ -3681,37 +3717,37 @@ Variant c_invalidargumentexception::o_invoke_few_args(MethodIndex methodIndex, c
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -3801,7 +3837,7 @@ Variant c_invalidargumentexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3815,7 +3851,7 @@ Variant c_invalidargumentexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3831,7 +3867,7 @@ Variant c_invalidargumentexception::o_invoke_from_eval(const char *s, Eval::Vari
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -3853,7 +3889,7 @@ Variant c_invalidargumentexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3867,7 +3903,7 @@ Variant c_invalidargumentexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3881,7 +3917,7 @@ Variant c_invalidargumentexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3895,7 +3931,7 @@ Variant c_invalidargumentexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3909,7 +3945,7 @@ Variant c_invalidargumentexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3923,7 +3959,7 @@ Variant c_invalidargumentexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4205,57 +4241,63 @@ Variant c_underflowexception::o_invoke(MethodIndex methodIndex, const char *s, C
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
-        if (count <= 0) return (t___construct(), null);
-        if (count == 1) return (t___construct(params[0]), null);
-        return (t___construct(params[0], params[1]), null);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t___construct(), null);
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -4340,19 +4382,19 @@ Variant c_underflowexception::o_invoke_few_args(MethodIndex methodIndex, const c
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         if (count <= 0) return (t___construct(), null);
         if (count == 1) return (t___construct(a0), null);
         return (t___construct(a0, a1), null);
@@ -4360,37 +4402,37 @@ Variant c_underflowexception::o_invoke_few_args(MethodIndex methodIndex, const c
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -4480,7 +4522,7 @@ Variant c_underflowexception::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4494,7 +4536,7 @@ Variant c_underflowexception::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4510,7 +4552,7 @@ Variant c_underflowexception::o_invoke_from_eval(const char *s, Eval::VariableEn
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -4532,7 +4574,7 @@ Variant c_underflowexception::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4546,7 +4588,7 @@ Variant c_underflowexception::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4560,7 +4602,7 @@ Variant c_underflowexception::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4574,7 +4616,7 @@ Variant c_underflowexception::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4588,7 +4630,7 @@ Variant c_underflowexception::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4602,7 +4644,7 @@ Variant c_underflowexception::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4884,57 +4926,63 @@ Variant c_outofrangeexception::o_invoke(MethodIndex methodIndex, const char *s,
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
-        if (count <= 0) return (t___construct(), null);
-        if (count == 1) return (t___construct(params[0]), null);
-        return (t___construct(params[0], params[1]), null);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t___construct(), null);
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -5019,19 +5067,19 @@ Variant c_outofrangeexception::o_invoke_few_args(MethodIndex methodIndex, const
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         if (count <= 0) return (t___construct(), null);
         if (count == 1) return (t___construct(a0), null);
         return (t___construct(a0, a1), null);
@@ -5039,37 +5087,37 @@ Variant c_outofrangeexception::o_invoke_few_args(MethodIndex methodIndex, const
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -5159,7 +5207,7 @@ Variant c_outofrangeexception::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5173,7 +5221,7 @@ Variant c_outofrangeexception::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5189,7 +5237,7 @@ Variant c_outofrangeexception::o_invoke_from_eval(const char *s, Eval::VariableE
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -5211,7 +5259,7 @@ Variant c_outofrangeexception::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5225,7 +5273,7 @@ Variant c_outofrangeexception::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5239,7 +5287,7 @@ Variant c_outofrangeexception::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5253,7 +5301,7 @@ Variant c_outofrangeexception::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5267,7 +5315,7 @@ Variant c_outofrangeexception::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5281,7 +5329,7 @@ Variant c_outofrangeexception::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5563,57 +5611,63 @@ Variant c_badmethodcallexception::o_invoke(MethodIndex methodIndex, const char *
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
-        if (count <= 0) return (t___construct(), null);
-        if (count == 1) return (t___construct(params[0]), null);
-        return (t___construct(params[0], params[1]), null);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t___construct(), null);
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -5698,19 +5752,19 @@ Variant c_badmethodcallexception::o_invoke_few_args(MethodIndex methodIndex, con
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         if (count <= 0) return (t___construct(), null);
         if (count == 1) return (t___construct(a0), null);
         return (t___construct(a0, a1), null);
@@ -5718,37 +5772,37 @@ Variant c_badmethodcallexception::o_invoke_few_args(MethodIndex methodIndex, con
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -5838,7 +5892,7 @@ Variant c_badmethodcallexception::o_invoke_from_eval(const char *s, Eval::Variab
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5852,7 +5906,7 @@ Variant c_badmethodcallexception::o_invoke_from_eval(const char *s, Eval::Variab
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5868,7 +5922,7 @@ Variant c_badmethodcallexception::o_invoke_from_eval(const char *s, Eval::Variab
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -5890,7 +5944,7 @@ Variant c_badmethodcallexception::o_invoke_from_eval(const char *s, Eval::Variab
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5904,7 +5958,7 @@ Variant c_badmethodcallexception::o_invoke_from_eval(const char *s, Eval::Variab
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5918,7 +5972,7 @@ Variant c_badmethodcallexception::o_invoke_from_eval(const char *s, Eval::Variab
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5932,7 +5986,7 @@ Variant c_badmethodcallexception::o_invoke_from_eval(const char *s, Eval::Variab
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5946,7 +6000,7 @@ Variant c_badmethodcallexception::o_invoke_from_eval(const char *s, Eval::Variab
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5960,7 +6014,7 @@ Variant c_badmethodcallexception::o_invoke_from_eval(const char *s, Eval::Variab
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6242,57 +6296,63 @@ Variant c_runtimeexception::o_invoke(MethodIndex methodIndex, const char *s, CAr
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
-        if (count <= 0) return (t___construct(), null);
-        if (count == 1) return (t___construct(params[0]), null);
-        return (t___construct(params[0], params[1]), null);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t___construct(), null);
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -6377,19 +6437,19 @@ Variant c_runtimeexception::o_invoke_few_args(MethodIndex methodIndex, const cha
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         if (count <= 0) return (t___construct(), null);
         if (count == 1) return (t___construct(a0), null);
         return (t___construct(a0, a1), null);
@@ -6397,37 +6457,37 @@ Variant c_runtimeexception::o_invoke_few_args(MethodIndex methodIndex, const cha
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -6517,7 +6577,7 @@ Variant c_runtimeexception::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6531,7 +6591,7 @@ Variant c_runtimeexception::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6547,7 +6607,7 @@ Variant c_runtimeexception::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6569,7 +6629,7 @@ Variant c_runtimeexception::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6583,7 +6643,7 @@ Variant c_runtimeexception::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6597,7 +6657,7 @@ Variant c_runtimeexception::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6611,7 +6671,7 @@ Variant c_runtimeexception::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6625,7 +6685,7 @@ Variant c_runtimeexception::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6639,7 +6699,7 @@ Variant c_runtimeexception::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -7125,57 +7185,63 @@ Variant c_exception::o_invoke(MethodIndex methodIndex, const char *s, CArrRef pa
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
-        if (count <= 0) return (t___construct(), null);
-        if (count == 1) return (t___construct(params[0]), null);
-        return (t___construct(params[0], params[1]), null);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t___construct(), null);
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -7260,19 +7326,19 @@ Variant c_exception::o_invoke_few_args(MethodIndex methodIndex, const char *s, i
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         if (count <= 0) return (t___construct(), null);
         if (count == 1) return (t___construct(a0), null);
         return (t___construct(a0, a1), null);
@@ -7280,37 +7346,37 @@ Variant c_exception::o_invoke_few_args(MethodIndex methodIndex, const char *s, i
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -7400,7 +7466,7 @@ Variant c_exception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -7414,7 +7480,7 @@ Variant c_exception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -7430,7 +7496,7 @@ Variant c_exception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -7452,7 +7518,7 @@ Variant c_exception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -7466,7 +7532,7 @@ Variant c_exception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -7480,7 +7546,7 @@ Variant c_exception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -7494,7 +7560,7 @@ Variant c_exception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -7508,7 +7574,7 @@ Variant c_exception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -7522,7 +7588,7 @@ Variant c_exception::o_invoke_from_eval(const char *s, Eval::VariableEnvironment
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -8130,66 +8196,75 @@ Variant c_errorexception::o_invoke(MethodIndex methodIndex, const char *s, CArrR
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 5) return throw_toomany_arguments("errorexception::__construct", 5, 2);
-        if (count <= 0) return (t___construct(), null);
-        if (count == 1) return (t___construct(params[0]), null);
-        if (count == 2) return (t___construct(params[0], params[1]), null);
-        if (count == 3) return (t___construct(params[0], params[1], params[2]), null);
-        if (count == 4) return (t___construct(params[0], params[1], params[2], params[3]), null);
-        return (t___construct(params[0], params[1], params[2], params[3], params[4]), null);
+        if (count > 5) return throw_toomany_arguments("ErrorException::__construct", 5, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t___construct(), null);
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          if (count == 2) return (t___construct(arg0, arg1), null);
+          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
+          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          if (count == 4) return (t___construct(arg0, arg1, arg2, arg3), null);
+          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1, arg2, arg3, arg4), null);
+        }
       }
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x42:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("errorexception::getseverity", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ErrorException::getSeverity", 0, 1);
         return (t_getseverity());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -8284,19 +8359,19 @@ Variant c_errorexception::o_invoke_few_args(MethodIndex methodIndex, const char
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 5) return throw_toomany_arguments("errorexception::__construct", 5, 2);
+        if (count > 5) return throw_toomany_arguments("ErrorException::__construct", 5, 2);
         if (count <= 0) return (t___construct(), null);
         if (count == 1) return (t___construct(a0), null);
         if (count == 2) return (t___construct(a0, a1), null);
@@ -8307,43 +8382,43 @@ Variant c_errorexception::o_invoke_few_args(MethodIndex methodIndex, const char
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x42:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("errorexception::getseverity", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ErrorException::getSeverity", 0, 1);
         return (t_getseverity());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -8440,7 +8515,7 @@ Variant c_errorexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -8454,7 +8529,7 @@ Variant c_errorexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -8473,7 +8548,7 @@ Variant c_errorexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
         Variant a4;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 5) return throw_toomany_arguments("errorexception::__construct", 5, 2);
+        if (count > 5) return throw_toomany_arguments("ErrorException::__construct", 5, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -8507,7 +8582,7 @@ Variant c_errorexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -8521,7 +8596,7 @@ Variant c_errorexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -8535,7 +8610,7 @@ Variant c_errorexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -8549,7 +8624,7 @@ Variant c_errorexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -8563,7 +8638,7 @@ Variant c_errorexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -8577,7 +8652,7 @@ Variant c_errorexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("errorexception::getseverity", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ErrorException::getSeverity", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -8591,7 +8666,7 @@ Variant c_errorexception::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -8929,57 +9004,63 @@ Variant c_badfunctioncallexception::o_invoke(MethodIndex methodIndex, const char
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
-        if (count <= 0) return (t___construct(), null);
-        if (count == 1) return (t___construct(params[0]), null);
-        return (t___construct(params[0], params[1]), null);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t___construct(), null);
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -9064,19 +9145,19 @@ Variant c_badfunctioncallexception::o_invoke_few_args(MethodIndex methodIndex, c
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         if (count <= 0) return (t___construct(), null);
         if (count == 1) return (t___construct(a0), null);
         return (t___construct(a0, a1), null);
@@ -9084,37 +9165,37 @@ Variant c_badfunctioncallexception::o_invoke_few_args(MethodIndex methodIndex, c
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -9204,7 +9285,7 @@ Variant c_badfunctioncallexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -9218,7 +9299,7 @@ Variant c_badfunctioncallexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -9234,7 +9315,7 @@ Variant c_badfunctioncallexception::o_invoke_from_eval(const char *s, Eval::Vari
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -9256,7 +9337,7 @@ Variant c_badfunctioncallexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -9270,7 +9351,7 @@ Variant c_badfunctioncallexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -9284,7 +9365,7 @@ Variant c_badfunctioncallexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -9298,7 +9379,7 @@ Variant c_badfunctioncallexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -9312,7 +9393,7 @@ Variant c_badfunctioncallexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -9326,7 +9407,7 @@ Variant c_badfunctioncallexception::o_invoke_from_eval(const char *s, Eval::Vari
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -9608,57 +9689,63 @@ Variant c_lengthexception::o_invoke(MethodIndex methodIndex, const char *s, CArr
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
-        if (count <= 0) return (t___construct(), null);
-        if (count == 1) return (t___construct(params[0]), null);
-        return (t___construct(params[0], params[1]), null);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t___construct(), null);
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -9743,19 +9830,19 @@ Variant c_lengthexception::o_invoke_few_args(MethodIndex methodIndex, const char
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         if (count <= 0) return (t___construct(), null);
         if (count == 1) return (t___construct(a0), null);
         return (t___construct(a0, a1), null);
@@ -9763,37 +9850,37 @@ Variant c_lengthexception::o_invoke_few_args(MethodIndex methodIndex, const char
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -9883,7 +9970,7 @@ Variant c_lengthexception::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -9897,7 +9984,7 @@ Variant c_lengthexception::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -9913,7 +10000,7 @@ Variant c_lengthexception::o_invoke_from_eval(const char *s, Eval::VariableEnvir
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -9935,7 +10022,7 @@ Variant c_lengthexception::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -9949,7 +10036,7 @@ Variant c_lengthexception::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -9963,7 +10050,7 @@ Variant c_lengthexception::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -9977,7 +10064,7 @@ Variant c_lengthexception::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -9991,7 +10078,7 @@ Variant c_lengthexception::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10005,7 +10092,7 @@ Variant c_lengthexception::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10287,57 +10374,63 @@ Variant c_domainexception::o_invoke(MethodIndex methodIndex, const char *s, CArr
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
-        if (count <= 0) return (t___construct(), null);
-        if (count == 1) return (t___construct(params[0]), null);
-        return (t___construct(params[0], params[1]), null);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t___construct(), null);
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -10422,19 +10515,19 @@ Variant c_domainexception::o_invoke_few_args(MethodIndex methodIndex, const char
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         if (count <= 0) return (t___construct(), null);
         if (count == 1) return (t___construct(a0), null);
         return (t___construct(a0, a1), null);
@@ -10442,37 +10535,37 @@ Variant c_domainexception::o_invoke_few_args(MethodIndex methodIndex, const char
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -10562,7 +10655,7 @@ Variant c_domainexception::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10576,7 +10669,7 @@ Variant c_domainexception::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10592,7 +10685,7 @@ Variant c_domainexception::o_invoke_from_eval(const char *s, Eval::VariableEnvir
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -10614,7 +10707,7 @@ Variant c_domainexception::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10628,7 +10721,7 @@ Variant c_domainexception::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10642,7 +10735,7 @@ Variant c_domainexception::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10656,7 +10749,7 @@ Variant c_domainexception::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10670,7 +10763,7 @@ Variant c_domainexception::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10684,7 +10777,7 @@ Variant c_domainexception::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
diff --git a/src/system/gen/php/classes/iterator.cpp b/src/system/gen/php/classes/iterator.cpp
index c71dd30fdf..57b418f0ec 100644
--- a/src/system/gen/php/classes/iterator.cpp
+++ b/src/system/gen/php/classes/iterator.cpp
@@ -304,135 +304,187 @@ Variant c_arrayiterator::o_invoke(MethodIndex methodIndex, const char *s, CArrRe
   switch (methodIndex.m_callIndex) {
     case 0xe:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::getarraycopy", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::getArrayCopy", 0, 1);
         return (t_getarraycopy());
       }
       break;
     case 0x1:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::next", 0, 1);
         return (t_next());
       }
       break;
     case 0xf:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::count", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::count", 0, 1);
         return (t_count());
       }
       break;
     case 0x10:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::natsort", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::natsort", 0, 1);
         return (t_natsort());
       }
       break;
     case 0x2:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::key", 0, 1);
         return (t_key());
       }
       break;
     case 0x3:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::valid", 0, 1);
         return (t_valid());
       }
       break;
     case 0x5:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("arrayiterator::append", count, 1, 1, 1);
-        return (t_append(params[0]), null);
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::append", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_append(arg0), null);
+        }
       }
       break;
     case 0x11:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("arrayiterator::setflags", count, 1, 1, 1);
-        return (t_setflags(params[0]), null);
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::setFlags", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_setflags(arg0), null);
+        }
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count < 1 || count > 2) return throw_wrong_arguments("arrayiterator::__construct", count, 1, 2, 2);
-        if (count <= 1) return (t___construct(params[0]), null);
-        return (t___construct(params[0], params[1]), null);
+        if (count < 1 || count > 2) return throw_wrong_arguments("ArrayIterator::__construct", count, 1, 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          if (count <= 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0xa:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("arrayiterator::offsetexists", count, 1, 1, 1);
-        return (t_offsetexists(params[0]));
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::offsetExists", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_offsetexists(arg0));
+        }
       }
       break;
     case 0x12:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("arrayiterator::uksort", count, 1, 1, 1);
-        return (t_uksort(params[0]));
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::uksort", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_uksort(arg0));
+        }
       }
       break;
     case 0xb:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("arrayiterator::offsetget", count, 1, 1, 1);
-        return (t_offsetget(params[0]));
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::offsetGet", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_offsetget(arg0));
+        }
       }
       break;
     case 0x13:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::natcasesort", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::natcasesort", 0, 1);
         return (t_natcasesort());
       }
       break;
     case 0x14:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::asort", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::asort", 0, 1);
         return (t_asort());
       }
       break;
     case 0xc:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("arrayiterator::offsetunset", count, 1, 1, 1);
-        return (t_offsetunset(params[0]));
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::offsetUnset", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_offsetunset(arg0));
+        }
       }
       break;
     case 0x15:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("arrayiterator::seek", count, 1, 1, 1);
-        return (t_seek(params[0]), null);
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::seek", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_seek(arg0), null);
+        }
       }
       break;
     case 0x16:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::getflags", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::getFlags", 0, 1);
         return (t_getflags());
       }
       break;
     case 0x7:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::current", 0, 1);
         return (t_current());
       }
       break;
     case 0x17:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::ksort", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::ksort", 0, 1);
         return (t_ksort());
       }
       break;
     case 0x18:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("arrayiterator::uasort", count, 1, 1, 1);
-        return (t_uasort(params[0]));
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::uasort", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_uasort(arg0));
+        }
       }
       break;
     case 0x9:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::rewind", 0, 1);
         return (t_rewind());
       }
       break;
     case 0xd:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("arrayiterator::offsetset", count, 2, 2, 1);
-        return (t_offsetset(params[0], params[1]));
+        if (count != 2) return throw_wrong_arguments("ArrayIterator::offsetSet", count, 2, 2, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t_offsetset(arg0, arg1));
+        }
       }
       break;
     default:
@@ -631,134 +683,134 @@ Variant c_arrayiterator::o_invoke_few_args(MethodIndex methodIndex, const char *
   switch (methodIndex.m_callIndex) {
     case 0xe:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::getarraycopy", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::getArrayCopy", 0, 1);
         return (t_getarraycopy());
       }
       break;
     case 0x1:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::next", 0, 1);
         return (t_next());
       }
       break;
     case 0xf:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::count", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::count", 0, 1);
         return (t_count());
       }
       break;
     case 0x10:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::natsort", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::natsort", 0, 1);
         return (t_natsort());
       }
       break;
     case 0x2:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::key", 0, 1);
         return (t_key());
       }
       break;
     case 0x3:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::valid", 0, 1);
         return (t_valid());
       }
       break;
     case 0x5:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("arrayiterator::append", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::append", count, 1, 1, 1);
         return (t_append(a0), null);
       }
       break;
     case 0x11:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("arrayiterator::setflags", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::setFlags", count, 1, 1, 1);
         return (t_setflags(a0), null);
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count < 1 || count > 2) return throw_wrong_arguments("arrayiterator::__construct", count, 1, 2, 2);
+        if (count < 1 || count > 2) return throw_wrong_arguments("ArrayIterator::__construct", count, 1, 2, 2);
         if (count <= 1) return (t___construct(a0), null);
         return (t___construct(a0, a1), null);
       }
       break;
     case 0xa:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("arrayiterator::offsetexists", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::offsetExists", count, 1, 1, 1);
         return (t_offsetexists(a0));
       }
       break;
     case 0x12:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("arrayiterator::uksort", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::uksort", count, 1, 1, 1);
         return (t_uksort(a0));
       }
       break;
     case 0xb:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("arrayiterator::offsetget", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::offsetGet", count, 1, 1, 1);
         return (t_offsetget(a0));
       }
       break;
     case 0x13:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::natcasesort", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::natcasesort", 0, 1);
         return (t_natcasesort());
       }
       break;
     case 0x14:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::asort", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::asort", 0, 1);
         return (t_asort());
       }
       break;
     case 0xc:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("arrayiterator::offsetunset", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::offsetUnset", count, 1, 1, 1);
         return (t_offsetunset(a0));
       }
       break;
     case 0x15:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("arrayiterator::seek", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::seek", count, 1, 1, 1);
         return (t_seek(a0), null);
       }
       break;
     case 0x16:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::getflags", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::getFlags", 0, 1);
         return (t_getflags());
       }
       break;
     case 0x7:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::current", 0, 1);
         return (t_current());
       }
       break;
     case 0x17:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::ksort", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::ksort", 0, 1);
         return (t_ksort());
       }
       break;
     case 0x18:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("arrayiterator::uasort", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::uasort", count, 1, 1, 1);
         return (t_uasort(a0));
       }
       break;
     case 0x9:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("arrayiterator::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::rewind", 0, 1);
         return (t_rewind());
       }
       break;
     case 0xd:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("arrayiterator::offsetset", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ArrayIterator::offsetSet", count, 2, 2, 1);
         return (t_offsetset(a0, a1));
       }
       break;
@@ -917,7 +969,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("arrayiterator::getarraycopy", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::getArrayCopy", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -931,7 +983,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("arrayiterator::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::next", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -945,7 +997,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("arrayiterator::count", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::count", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -959,7 +1011,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("arrayiterator::natsort", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::natsort", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -973,7 +1025,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("arrayiterator::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::key", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -987,7 +1039,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("arrayiterator::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::valid", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1002,7 +1054,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("arrayiterator::append", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::append", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -1020,7 +1072,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("arrayiterator::setflags", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::setFlags", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -1039,7 +1091,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count < 1 || count > 2) return throw_wrong_arguments("arrayiterator::__construct", count, 1, 2, 2);
+        if (count < 1 || count > 2) return throw_wrong_arguments("ArrayIterator::__construct", count, 1, 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -1061,7 +1113,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("arrayiterator::offsetexists", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::offsetExists", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -1079,7 +1131,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("arrayiterator::uksort", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::uksort", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -1097,7 +1149,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("arrayiterator::offsetget", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::offsetGet", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -1114,7 +1166,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("arrayiterator::natcasesort", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::natcasesort", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1128,7 +1180,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("arrayiterator::asort", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::asort", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1143,7 +1195,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("arrayiterator::offsetunset", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::offsetUnset", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -1161,7 +1213,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("arrayiterator::seek", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::seek", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -1178,7 +1230,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("arrayiterator::getflags", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::getFlags", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1192,7 +1244,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("arrayiterator::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::current", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1206,7 +1258,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("arrayiterator::ksort", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::ksort", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1221,7 +1273,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("arrayiterator::uasort", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ArrayIterator::uasort", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -1238,7 +1290,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("arrayiterator::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ArrayIterator::rewind", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1254,7 +1306,7 @@ Variant c_arrayiterator::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("arrayiterator::offsetset", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ArrayIterator::offsetSet", count, 2, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2033,55 +2085,66 @@ Variant c_appenditerator::o_invoke(MethodIndex methodIndex, const char *s, CArrR
   switch (methodIndex.m_callIndex) {
     case 0x1:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("appenditerator::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::next", 0, 1);
         return (t_next(), null);
       }
       break;
     case 0x2:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("appenditerator::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::key", 0, 1);
         return (t_key());
       }
       break;
     case 0x3:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("appenditerator::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::valid", 0, 1);
         return (t_valid());
       }
       break;
     case 0x4:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("appenditerator::getinneriterator", 0, 1);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::getInnerIterator", 0, 1);
         return (t_getinneriterator());
       }
       break;
     case 0x5:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("appenditerator::append", count, 1, 1, 1);
-        return (t_append(params[0]), null);
+        if (count != 1) return throw_wrong_arguments("AppendIterator::append", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_append(arg0), null);
+        }
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("appenditerator::__construct", 0, 2);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::__construct", 0, 2);
         return (t___construct(), null);
       }
       break;
     case 0x7:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("appenditerator::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::current", 0, 1);
         return (t_current());
       }
       break;
     case 0x8:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("appenditerator::__call", count, 2, 2, 1);
-        return (t___call(params[0], params[1]));
+        if (count != 2) return throw_wrong_arguments("AppendIterator::__call", count, 2, 2, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___call(arg0, arg1));
+        }
       }
       break;
     case 0x9:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("appenditerator::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::rewind", 0, 1);
         return (t_rewind(), null);
       }
       break;
@@ -2167,55 +2230,55 @@ Variant c_appenditerator::o_invoke_few_args(MethodIndex methodIndex, const char
   switch (methodIndex.m_callIndex) {
     case 0x1:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("appenditerator::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::next", 0, 1);
         return (t_next(), null);
       }
       break;
     case 0x2:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("appenditerator::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::key", 0, 1);
         return (t_key());
       }
       break;
     case 0x3:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("appenditerator::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::valid", 0, 1);
         return (t_valid());
       }
       break;
     case 0x4:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("appenditerator::getinneriterator", 0, 1);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::getInnerIterator", 0, 1);
         return (t_getinneriterator());
       }
       break;
     case 0x5:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("appenditerator::append", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("AppendIterator::append", count, 1, 1, 1);
         return (t_append(a0), null);
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("appenditerator::__construct", 0, 2);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::__construct", 0, 2);
         return (t___construct(), null);
       }
       break;
     case 0x7:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("appenditerator::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::current", 0, 1);
         return (t_current());
       }
       break;
     case 0x8:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("appenditerator::__call", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("AppendIterator::__call", count, 2, 2, 1);
         return (t___call(a0, a1));
       }
       break;
     case 0x9:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("appenditerator::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::rewind", 0, 1);
         return (t_rewind(), null);
       }
       break;
@@ -2301,7 +2364,7 @@ Variant c_appenditerator::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("appenditerator::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::next", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2315,7 +2378,7 @@ Variant c_appenditerator::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("appenditerator::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::key", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2329,7 +2392,7 @@ Variant c_appenditerator::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("appenditerator::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::valid", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2343,7 +2406,7 @@ Variant c_appenditerator::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("appenditerator::getinneriterator", 0, 1);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::getInnerIterator", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2358,7 +2421,7 @@ Variant c_appenditerator::o_invoke_from_eval(const char *s, Eval::VariableEnviro
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("appenditerator::append", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("AppendIterator::append", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2375,7 +2438,7 @@ Variant c_appenditerator::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("appenditerator::__construct", 0, 2);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::__construct", 0, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2389,7 +2452,7 @@ Variant c_appenditerator::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("appenditerator::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::current", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2405,7 +2468,7 @@ Variant c_appenditerator::o_invoke_from_eval(const char *s, Eval::VariableEnviro
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("appenditerator::__call", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("AppendIterator::__call", count, 2, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2425,7 +2488,7 @@ Variant c_appenditerator::o_invoke_from_eval(const char *s, Eval::VariableEnviro
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("appenditerator::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("AppendIterator::rewind", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2888,244 +2951,287 @@ Variant c_recursivedirectoryiterator::o_invoke(MethodIndex methodIndex, const ch
   switch (methodIndex.m_callIndex) {
     case 0x27:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getperms", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
         return (t_getperms());
       }
       break;
     case 0x28:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::iswritable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
         return (t_iswritable());
       }
       break;
     case 0x29:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getbasename", 1, 1);
-        if (count <= 0) return (t_getbasename());
-        return (t_getbasename(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_getbasename());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getbasename(arg0));
+        }
       }
       break;
     case 0x2a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpathname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
         return (t_getpathname());
       }
       break;
     case 0x1:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::next", 0, 1);
         return (t_next());
       }
       break;
     case 0x2b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getgroup", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
         return (t_getgroup());
       }
       break;
     case 0x2:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::key", 0, 1);
         return (t_key());
       }
       break;
     case 0x2c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setfileclass", 1, 1);
-        if (count <= 0) return (t_setfileclass());
-        return (t_setfileclass(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_setfileclass());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_setfileclass(arg0));
+        }
       }
       break;
     case 0x2d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setinfoclass", 1, 1);
-        if (count <= 0) return (t_setinfoclass());
-        return (t_setinfoclass(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_setinfoclass());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_setinfoclass(arg0));
+        }
       }
       break;
     case 0x3:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::valid", 0, 1);
         return (t_valid());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x2e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getlinktarget", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
         return (t_getlinktarget());
       }
       break;
     case 0x2f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isreadable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
         return (t_isreadable());
       }
       break;
     case 0x30:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getrealpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
         return (t_getrealpath());
       }
       break;
     case 0x44:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::getsubpathname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::getSubPathname", 0, 1);
         return (t_getsubpathname());
       }
       break;
     case 0x45:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::getsubpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::getSubPath", 0, 1);
         return (t_getsubpath());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count < 1 || count > 2) return throw_wrong_arguments("recursivedirectoryiterator::__construct", count, 1, 2, 2);
-        if (count <= 1) return (t___construct(params[0]), null);
-        return (t___construct(params[0], params[1]), null);
+        if (count < 1 || count > 2) return throw_wrong_arguments("RecursiveDirectoryIterator::__construct", count, 1, 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          if (count <= 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0x31:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getpathinfo", 1, 1);
-        if (count <= 0) return (t_getpathinfo());
-        return (t_getpathinfo(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_getpathinfo());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getpathinfo(arg0));
+        }
       }
       break;
     case 0x32:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getctime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
         return (t_getctime());
       }
       break;
     case 0x33:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
         return (t_getpath());
       }
       break;
     case 0x34:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getinode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
         return (t_getinode());
       }
       break;
     case 0x35:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::islink", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
         return (t_islink());
       }
       break;
     case 0x36:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getsize", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
         return (t_getsize());
       }
       break;
     case 0x38:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
         return (t_isfile());
       }
       break;
     case 0x37:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
         return (t_getfilename());
       }
       break;
     case 0x39:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getowner", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
         return (t_getowner());
       }
       break;
     case 0x46:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::haschildren", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::hasChildren", 0, 1);
         return (t_haschildren());
       }
       break;
     case 0x15:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("recursivedirectoryiterator::seek", count, 1, 1, 1);
-        return (t_seek(params[0]));
+        if (count != 1) return throw_wrong_arguments("RecursiveDirectoryIterator::seek", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_seek(arg0));
+        }
       }
       break;
     case 0x3a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getmtime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
         return (t_getmtime());
       }
       break;
     case 0x3b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isdir", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
         return (t_isdir());
       }
       break;
     case 0x3c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getfileinfo", 1, 1);
-        if (count <= 0) return (t_getfileinfo());
-        return (t_getfileinfo(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_getfileinfo());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getfileinfo(arg0));
+        }
       }
       break;
     case 0x47:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::getchildren", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::getChildren", 0, 1);
         return (t_getchildren());
       }
       break;
     case 0x7:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::current", 0, 1);
         return (t_current());
       }
       break;
     case 0x3e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isexecutable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
         return (t_isexecutable());
       }
       break;
     case 0x3d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getatime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
         return (t_getatime());
       }
       break;
     case 0x3f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 3) return throw_toomany_arguments("splfileinfo::openfile", 3, 1);
-        if (count <= 0) return (t_openfile());
-        if (count == 1) return (t_openfile(params[0]));
-        if (count == 2) return (t_openfile(params[0], params[1]));
-        return (t_openfile(params[0], params[1], params[2]));
+        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_openfile());
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t_openfile(arg0));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          if (count == 2) return (t_openfile(arg0, arg1));
+          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t_openfile(arg0, arg1, arg2));
+        }
       }
       break;
     case 0x40:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directoryiterator::isdot", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::isDot", 0, 1);
         return (t_isdot());
       }
       break;
     case 0x9:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::rewind", 0, 1);
         return (t_rewind());
       }
       break;
     case 0x41:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::gettype", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
         return (t_gettype());
       }
       break;
@@ -3422,223 +3528,223 @@ Variant c_recursivedirectoryiterator::o_invoke_few_args(MethodIndex methodIndex,
   switch (methodIndex.m_callIndex) {
     case 0x27:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getperms", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
         return (t_getperms());
       }
       break;
     case 0x28:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::iswritable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
         return (t_iswritable());
       }
       break;
     case 0x29:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getbasename", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
         if (count <= 0) return (t_getbasename());
         return (t_getbasename(a0));
       }
       break;
     case 0x2a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpathname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
         return (t_getpathname());
       }
       break;
     case 0x1:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::next", 0, 1);
         return (t_next());
       }
       break;
     case 0x2b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getgroup", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
         return (t_getgroup());
       }
       break;
     case 0x2:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::key", 0, 1);
         return (t_key());
       }
       break;
     case 0x2c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setfileclass", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
         if (count <= 0) return (t_setfileclass());
         return (t_setfileclass(a0));
       }
       break;
     case 0x2d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setinfoclass", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
         if (count <= 0) return (t_setinfoclass());
         return (t_setinfoclass(a0));
       }
       break;
     case 0x3:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::valid", 0, 1);
         return (t_valid());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x2e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getlinktarget", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
         return (t_getlinktarget());
       }
       break;
     case 0x2f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isreadable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
         return (t_isreadable());
       }
       break;
     case 0x30:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getrealpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
         return (t_getrealpath());
       }
       break;
     case 0x44:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::getsubpathname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::getSubPathname", 0, 1);
         return (t_getsubpathname());
       }
       break;
     case 0x45:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::getsubpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::getSubPath", 0, 1);
         return (t_getsubpath());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count < 1 || count > 2) return throw_wrong_arguments("recursivedirectoryiterator::__construct", count, 1, 2, 2);
+        if (count < 1 || count > 2) return throw_wrong_arguments("RecursiveDirectoryIterator::__construct", count, 1, 2, 2);
         if (count <= 1) return (t___construct(a0), null);
         return (t___construct(a0, a1), null);
       }
       break;
     case 0x31:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getpathinfo", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
         if (count <= 0) return (t_getpathinfo());
         return (t_getpathinfo(a0));
       }
       break;
     case 0x32:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getctime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
         return (t_getctime());
       }
       break;
     case 0x33:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
         return (t_getpath());
       }
       break;
     case 0x34:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getinode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
         return (t_getinode());
       }
       break;
     case 0x35:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::islink", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
         return (t_islink());
       }
       break;
     case 0x36:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getsize", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
         return (t_getsize());
       }
       break;
     case 0x38:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
         return (t_isfile());
       }
       break;
     case 0x37:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
         return (t_getfilename());
       }
       break;
     case 0x39:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getowner", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
         return (t_getowner());
       }
       break;
     case 0x46:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::haschildren", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::hasChildren", 0, 1);
         return (t_haschildren());
       }
       break;
     case 0x15:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("recursivedirectoryiterator::seek", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("RecursiveDirectoryIterator::seek", count, 1, 1, 1);
         return (t_seek(a0));
       }
       break;
     case 0x3a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getmtime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
         return (t_getmtime());
       }
       break;
     case 0x3b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isdir", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
         return (t_isdir());
       }
       break;
     case 0x3c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getfileinfo", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
         if (count <= 0) return (t_getfileinfo());
         return (t_getfileinfo(a0));
       }
       break;
     case 0x47:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::getchildren", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::getChildren", 0, 1);
         return (t_getchildren());
       }
       break;
     case 0x7:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::current", 0, 1);
         return (t_current());
       }
       break;
     case 0x3e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isexecutable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
         return (t_isexecutable());
       }
       break;
     case 0x3d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getatime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
         return (t_getatime());
       }
       break;
     case 0x3f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 3) return throw_toomany_arguments("splfileinfo::openfile", 3, 1);
+        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
         if (count <= 0) return (t_openfile());
         if (count == 1) return (t_openfile(a0));
         if (count == 2) return (t_openfile(a0, a1));
@@ -3647,19 +3753,19 @@ Variant c_recursivedirectoryiterator::o_invoke_few_args(MethodIndex methodIndex,
       break;
     case 0x40:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directoryiterator::isdot", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::isDot", 0, 1);
         return (t_isdot());
       }
       break;
     case 0x9:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::rewind", 0, 1);
         return (t_rewind());
       }
       break;
     case 0x41:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::gettype", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
         return (t_gettype());
       }
       break;
@@ -3924,7 +4030,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getperms", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3938,7 +4044,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::iswritable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3953,7 +4059,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getbasename", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -3971,7 +4077,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpathname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3985,7 +4091,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::next", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3999,7 +4105,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getgroup", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4013,7 +4119,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::key", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4028,7 +4134,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setfileclass", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -4047,7 +4153,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setinfoclass", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -4065,7 +4171,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::valid", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4079,7 +4185,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4093,7 +4199,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getlinktarget", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4107,7 +4213,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isreadable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4121,7 +4227,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getrealpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4135,7 +4241,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::getsubpathname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::getSubPathname", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4149,7 +4255,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::getsubpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::getSubPath", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4165,7 +4271,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count < 1 || count > 2) return throw_wrong_arguments("recursivedirectoryiterator::__construct", count, 1, 2, 2);
+        if (count < 1 || count > 2) return throw_wrong_arguments("RecursiveDirectoryIterator::__construct", count, 1, 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -4187,7 +4293,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getpathinfo", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -4205,7 +4311,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getctime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4219,7 +4325,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4233,7 +4339,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getinode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4247,7 +4353,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::islink", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4261,7 +4367,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getsize", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4275,7 +4381,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4289,7 +4395,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4303,7 +4409,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getowner", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4317,7 +4423,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::haschildren", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::hasChildren", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4332,7 +4438,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("recursivedirectoryiterator::seek", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("RecursiveDirectoryIterator::seek", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -4349,7 +4455,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getmtime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4363,7 +4469,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isdir", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4378,7 +4484,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getfileinfo", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -4396,7 +4502,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::getchildren", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::getChildren", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4410,7 +4516,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::current", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4424,7 +4530,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isexecutable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4438,7 +4544,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getatime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4455,7 +4561,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
         Variant a2;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 3) return throw_toomany_arguments("splfileinfo::openfile", 3, 1);
+        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -4481,7 +4587,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("directoryiterator::isdot", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::isDot", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4495,7 +4601,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("recursivedirectoryiterator::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveDirectoryIterator::rewind", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4509,7 +4615,7 @@ Variant c_recursivedirectoryiterator::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::gettype", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5359,219 +5465,261 @@ Variant c_directoryiterator::o_invoke(MethodIndex methodIndex, const char *s, CA
   switch (methodIndex.m_callIndex) {
     case 0x27:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getperms", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
         return (t_getperms());
       }
       break;
     case 0x28:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::iswritable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
         return (t_iswritable());
       }
       break;
     case 0x29:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getbasename", 1, 1);
-        if (count <= 0) return (t_getbasename());
-        return (t_getbasename(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_getbasename());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getbasename(arg0));
+        }
       }
       break;
     case 0x2a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpathname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
         return (t_getpathname());
       }
       break;
     case 0x1:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directoryiterator::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::next", 0, 1);
         return (t_next());
       }
       break;
     case 0x2b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getgroup", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
         return (t_getgroup());
       }
       break;
     case 0x2:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directoryiterator::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::key", 0, 1);
         return (t_key());
       }
       break;
     case 0x2c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setfileclass", 1, 1);
-        if (count <= 0) return (t_setfileclass());
-        return (t_setfileclass(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_setfileclass());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_setfileclass(arg0));
+        }
       }
       break;
     case 0x2d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setinfoclass", 1, 1);
-        if (count <= 0) return (t_setinfoclass());
-        return (t_setinfoclass(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_setinfoclass());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_setinfoclass(arg0));
+        }
       }
       break;
     case 0x3:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directoryiterator::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::valid", 0, 1);
         return (t_valid());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directoryiterator::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x2e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getlinktarget", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
         return (t_getlinktarget());
       }
       break;
     case 0x2f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isreadable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
         return (t_isreadable());
       }
       break;
     case 0x30:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getrealpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
         return (t_getrealpath());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("directoryiterator::__construct", count, 1, 1, 2);
-        return (t___construct(params[0]), null);
+        if (count != 1) return throw_wrong_arguments("DirectoryIterator::__construct", count, 1, 1, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t___construct(arg0), null);
+        }
       }
       break;
     case 0x31:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getpathinfo", 1, 1);
-        if (count <= 0) return (t_getpathinfo());
-        return (t_getpathinfo(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_getpathinfo());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getpathinfo(arg0));
+        }
       }
       break;
     case 0x32:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getctime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
         return (t_getctime());
       }
       break;
     case 0x33:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
         return (t_getpath());
       }
       break;
     case 0x34:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getinode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
         return (t_getinode());
       }
       break;
     case 0x35:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::islink", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
         return (t_islink());
       }
       break;
     case 0x36:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getsize", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
         return (t_getsize());
       }
       break;
     case 0x38:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
         return (t_isfile());
       }
       break;
     case 0x37:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
         return (t_getfilename());
       }
       break;
     case 0x39:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getowner", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
         return (t_getowner());
       }
       break;
     case 0x15:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("directoryiterator::seek", count, 1, 1, 1);
-        return (t_seek(params[0]));
+        if (count != 1) return throw_wrong_arguments("DirectoryIterator::seek", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_seek(arg0));
+        }
       }
       break;
     case 0x3a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getmtime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
         return (t_getmtime());
       }
       break;
     case 0x3b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isdir", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
         return (t_isdir());
       }
       break;
     case 0x3c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getfileinfo", 1, 1);
-        if (count <= 0) return (t_getfileinfo());
-        return (t_getfileinfo(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_getfileinfo());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getfileinfo(arg0));
+        }
       }
       break;
     case 0x7:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directoryiterator::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::current", 0, 1);
         return (t_current());
       }
       break;
     case 0x3e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isexecutable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
         return (t_isexecutable());
       }
       break;
     case 0x3d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getatime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
         return (t_getatime());
       }
       break;
     case 0x3f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 3) return throw_toomany_arguments("splfileinfo::openfile", 3, 1);
-        if (count <= 0) return (t_openfile());
-        if (count == 1) return (t_openfile(params[0]));
-        if (count == 2) return (t_openfile(params[0], params[1]));
-        return (t_openfile(params[0], params[1], params[2]));
+        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_openfile());
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t_openfile(arg0));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          if (count == 2) return (t_openfile(arg0, arg1));
+          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t_openfile(arg0, arg1, arg2));
+        }
       }
       break;
     case 0x40:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directoryiterator::isdot", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::isDot", 0, 1);
         return (t_isdot());
       }
       break;
     case 0x9:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directoryiterator::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::rewind", 0, 1);
         return (t_rewind());
       }
       break;
     case 0x41:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::gettype", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
         return (t_gettype());
       }
       break;
@@ -5842,198 +5990,198 @@ Variant c_directoryiterator::o_invoke_few_args(MethodIndex methodIndex, const ch
   switch (methodIndex.m_callIndex) {
     case 0x27:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getperms", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
         return (t_getperms());
       }
       break;
     case 0x28:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::iswritable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
         return (t_iswritable());
       }
       break;
     case 0x29:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getbasename", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
         if (count <= 0) return (t_getbasename());
         return (t_getbasename(a0));
       }
       break;
     case 0x2a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpathname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
         return (t_getpathname());
       }
       break;
     case 0x1:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directoryiterator::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::next", 0, 1);
         return (t_next());
       }
       break;
     case 0x2b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getgroup", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
         return (t_getgroup());
       }
       break;
     case 0x2:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directoryiterator::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::key", 0, 1);
         return (t_key());
       }
       break;
     case 0x2c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setfileclass", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
         if (count <= 0) return (t_setfileclass());
         return (t_setfileclass(a0));
       }
       break;
     case 0x2d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setinfoclass", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
         if (count <= 0) return (t_setinfoclass());
         return (t_setinfoclass(a0));
       }
       break;
     case 0x3:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directoryiterator::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::valid", 0, 1);
         return (t_valid());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directoryiterator::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x2e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getlinktarget", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
         return (t_getlinktarget());
       }
       break;
     case 0x2f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isreadable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
         return (t_isreadable());
       }
       break;
     case 0x30:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getrealpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
         return (t_getrealpath());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("directoryiterator::__construct", count, 1, 1, 2);
+        if (count != 1) return throw_wrong_arguments("DirectoryIterator::__construct", count, 1, 1, 2);
         return (t___construct(a0), null);
       }
       break;
     case 0x31:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getpathinfo", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
         if (count <= 0) return (t_getpathinfo());
         return (t_getpathinfo(a0));
       }
       break;
     case 0x32:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getctime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
         return (t_getctime());
       }
       break;
     case 0x33:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
         return (t_getpath());
       }
       break;
     case 0x34:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getinode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
         return (t_getinode());
       }
       break;
     case 0x35:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::islink", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
         return (t_islink());
       }
       break;
     case 0x36:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getsize", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
         return (t_getsize());
       }
       break;
     case 0x38:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
         return (t_isfile());
       }
       break;
     case 0x37:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
         return (t_getfilename());
       }
       break;
     case 0x39:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getowner", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
         return (t_getowner());
       }
       break;
     case 0x15:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("directoryiterator::seek", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("DirectoryIterator::seek", count, 1, 1, 1);
         return (t_seek(a0));
       }
       break;
     case 0x3a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getmtime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
         return (t_getmtime());
       }
       break;
     case 0x3b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isdir", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
         return (t_isdir());
       }
       break;
     case 0x3c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getfileinfo", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
         if (count <= 0) return (t_getfileinfo());
         return (t_getfileinfo(a0));
       }
       break;
     case 0x7:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directoryiterator::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::current", 0, 1);
         return (t_current());
       }
       break;
     case 0x3e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isexecutable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
         return (t_isexecutable());
       }
       break;
     case 0x3d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getatime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
         return (t_getatime());
       }
       break;
     case 0x3f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 3) return throw_toomany_arguments("splfileinfo::openfile", 3, 1);
+        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
         if (count <= 0) return (t_openfile());
         if (count == 1) return (t_openfile(a0));
         if (count == 2) return (t_openfile(a0, a1));
@@ -6042,19 +6190,19 @@ Variant c_directoryiterator::o_invoke_few_args(MethodIndex methodIndex, const ch
       break;
     case 0x40:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directoryiterator::isdot", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::isDot", 0, 1);
         return (t_isdot());
       }
       break;
     case 0x9:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("directoryiterator::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::rewind", 0, 1);
         return (t_rewind());
       }
       break;
     case 0x41:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::gettype", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
         return (t_gettype());
       }
       break;
@@ -6294,7 +6442,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getperms", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6308,7 +6456,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::iswritable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6323,7 +6471,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getbasename", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6341,7 +6489,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpathname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6355,7 +6503,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("directoryiterator::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::next", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6369,7 +6517,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getgroup", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6383,7 +6531,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("directoryiterator::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::key", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6398,7 +6546,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setfileclass", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6417,7 +6565,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setinfoclass", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6435,7 +6583,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("directoryiterator::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::valid", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6449,7 +6597,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("directoryiterator::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6463,7 +6611,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getlinktarget", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6477,7 +6625,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isreadable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6491,7 +6639,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getrealpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6506,7 +6654,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("directoryiterator::__construct", count, 1, 1, 2);
+        if (count != 1) return throw_wrong_arguments("DirectoryIterator::__construct", count, 1, 1, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6524,7 +6672,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getpathinfo", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6542,7 +6690,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getctime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6556,7 +6704,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6570,7 +6718,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getinode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6584,7 +6732,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::islink", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6598,7 +6746,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getsize", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6612,7 +6760,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6626,7 +6774,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6640,7 +6788,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getowner", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6655,7 +6803,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("directoryiterator::seek", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("DirectoryIterator::seek", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6672,7 +6820,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getmtime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6686,7 +6834,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isdir", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6701,7 +6849,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getfileinfo", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6719,7 +6867,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("directoryiterator::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::current", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6733,7 +6881,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isexecutable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6747,7 +6895,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getatime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6764,7 +6912,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
         Variant a2;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 3) return throw_toomany_arguments("splfileinfo::openfile", 3, 1);
+        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6790,7 +6938,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("directoryiterator::isdot", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::isDot", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6804,7 +6952,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("directoryiterator::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("DirectoryIterator::rewind", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6818,7 +6966,7 @@ Variant c_directoryiterator::o_invoke_from_eval(const char *s, Eval::VariableEnv
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::gettype", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -7642,45 +7790,52 @@ Variant c_recursiveiteratoriterator::o_invoke(MethodIndex methodIndex, const cha
   switch (methodIndex.m_callIndex) {
     case 0x1:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursiveiteratoriterator::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveIteratorIterator::next", 0, 1);
         return (t_next());
       }
       break;
     case 0x2:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursiveiteratoriterator::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveIteratorIterator::key", 0, 1);
         return (t_key());
       }
       break;
     case 0x3:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursiveiteratoriterator::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveIteratorIterator::valid", 0, 1);
         return (t_valid());
       }
       break;
     case 0x4:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursiveiteratoriterator::getinneriterator", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveIteratorIterator::getInnerIterator", 0, 1);
         return (t_getinneriterator());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count < 1 || count > 3) return throw_wrong_arguments("recursiveiteratoriterator::__construct", count, 1, 3, 2);
-        if (count <= 1) return (t___construct(params[0]), null);
-        if (count == 2) return (t___construct(params[0], params[1]), null);
-        return (t___construct(params[0], params[1], params[2]), null);
+        if (count < 1 || count > 3) return throw_wrong_arguments("RecursiveIteratorIterator::__construct", count, 1, 3, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          if (count <= 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          if (count == 2) return (t___construct(arg0, arg1), null);
+          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1, arg2), null);
+        }
       }
       break;
     case 0x7:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursiveiteratoriterator::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveIteratorIterator::current", 0, 1);
         return (t_current());
       }
       break;
     case 0x9:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursiveiteratoriterator::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveIteratorIterator::rewind", 0, 1);
         return (t_rewind());
       }
       break;
@@ -7752,31 +7907,31 @@ Variant c_recursiveiteratoriterator::o_invoke_few_args(MethodIndex methodIndex,
   switch (methodIndex.m_callIndex) {
     case 0x1:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursiveiteratoriterator::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveIteratorIterator::next", 0, 1);
         return (t_next());
       }
       break;
     case 0x2:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursiveiteratoriterator::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveIteratorIterator::key", 0, 1);
         return (t_key());
       }
       break;
     case 0x3:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursiveiteratoriterator::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveIteratorIterator::valid", 0, 1);
         return (t_valid());
       }
       break;
     case 0x4:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursiveiteratoriterator::getinneriterator", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveIteratorIterator::getInnerIterator", 0, 1);
         return (t_getinneriterator());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count < 1 || count > 3) return throw_wrong_arguments("recursiveiteratoriterator::__construct", count, 1, 3, 2);
+        if (count < 1 || count > 3) return throw_wrong_arguments("RecursiveIteratorIterator::__construct", count, 1, 3, 2);
         if (count <= 1) return (t___construct(a0), null);
         if (count == 2) return (t___construct(a0, a1), null);
         return (t___construct(a0, a1, a2), null);
@@ -7784,13 +7939,13 @@ Variant c_recursiveiteratoriterator::o_invoke_few_args(MethodIndex methodIndex,
       break;
     case 0x7:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursiveiteratoriterator::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveIteratorIterator::current", 0, 1);
         return (t_current());
       }
       break;
     case 0x9:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("recursiveiteratoriterator::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveIteratorIterator::rewind", 0, 1);
         return (t_rewind());
       }
       break;
@@ -7866,7 +8021,7 @@ Variant c_recursiveiteratoriterator::o_invoke_from_eval(const char *s, Eval::Var
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("recursiveiteratoriterator::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveIteratorIterator::next", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -7880,7 +8035,7 @@ Variant c_recursiveiteratoriterator::o_invoke_from_eval(const char *s, Eval::Var
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("recursiveiteratoriterator::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveIteratorIterator::key", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -7894,7 +8049,7 @@ Variant c_recursiveiteratoriterator::o_invoke_from_eval(const char *s, Eval::Var
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("recursiveiteratoriterator::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveIteratorIterator::valid", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -7908,7 +8063,7 @@ Variant c_recursiveiteratoriterator::o_invoke_from_eval(const char *s, Eval::Var
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("recursiveiteratoriterator::getinneriterator", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveIteratorIterator::getInnerIterator", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -7925,7 +8080,7 @@ Variant c_recursiveiteratoriterator::o_invoke_from_eval(const char *s, Eval::Var
         Variant a2;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count < 1 || count > 3) return throw_wrong_arguments("recursiveiteratoriterator::__construct", count, 1, 3, 2);
+        if (count < 1 || count > 3) return throw_wrong_arguments("RecursiveIteratorIterator::__construct", count, 1, 3, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -7950,7 +8105,7 @@ Variant c_recursiveiteratoriterator::o_invoke_from_eval(const char *s, Eval::Var
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("recursiveiteratoriterator::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveIteratorIterator::current", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -7964,7 +8119,7 @@ Variant c_recursiveiteratoriterator::o_invoke_from_eval(const char *s, Eval::Var
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("recursiveiteratoriterator::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("RecursiveIteratorIterator::rewind", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
diff --git a/src/system/gen/php/classes/pear_error.cpp b/src/system/gen/php/classes/pear_error.cpp
index 9a864faef6..49838a6bee 100644
--- a/src/system/gen/php/classes/pear_error.cpp
+++ b/src/system/gen/php/classes/pear_error.cpp
@@ -252,73 +252,92 @@ Variant c_pear_error::o_invoke(MethodIndex methodIndex, const char *s, CArrRef p
   switch (methodIndex.m_callIndex) {
     case 0x156:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("pear_error::getuserinfo", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getUserInfo", 0, 1);
         return (t_getuserinfo(), null);
       }
       break;
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("pear_error::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getMessage", 0, 1);
         return (t_getmessage(), null);
       }
       break;
     case 0x157:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("pear_error::getcallback", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getCallback", 0, 1);
         return (t_getcallback(), null);
       }
       break;
     case 0x158:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("pear_error::getdebuginfo", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getDebugInfo", 0, 1);
         return (t_getdebuginfo(), null);
       }
       break;
     case 0x159:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("pear_error::adduserinfo", count, 1, 1, 1);
-        return (t_adduserinfo(params[0]), null);
+        if (count != 1) return throw_wrong_arguments("pear_error::addUserInfo", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_adduserinfo(arg0), null);
+        }
       }
       break;
     case 0x15a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("pear_error::getbacktrace", 1, 1);
-        if (count <= 0) return (t_getbacktrace(), null);
-        return (t_getbacktrace(params[0]), null);
+        if (count > 1) return throw_toomany_arguments("pear_error::getBacktrace", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_getbacktrace(), null);
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getbacktrace(arg0), null);
+        }
       }
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("pear_error::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getCode", 0, 1);
         return (t_getcode(), null);
       }
       break;
     case 0x15b:
       if (methodIndex.m_overloadIndex == 0x1) { 
         if (count > 5) return throw_toomany_arguments("pear_error::pear_error", 5, 2);
-        if (count <= 0) return (t_pear_error(), null);
-        if (count == 1) return (t_pear_error(params[0]), null);
-        if (count == 2) return (t_pear_error(params[0], params[1]), null);
-        if (count == 3) return (t_pear_error(params[0], params[1], params[2]), null);
-        if (count == 4) return (t_pear_error(params[0], params[1], params[2], params[3]), null);
-        return (t_pear_error(params[0], params[1], params[2], params[3], params[4]), null);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_pear_error(), null);
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t_pear_error(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          if (count == 2) return (t_pear_error(arg0, arg1), null);
+          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          if (count == 3) return (t_pear_error(arg0, arg1, arg2), null);
+          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          if (count == 4) return (t_pear_error(arg0, arg1, arg2, arg3), null);
+          CVarRef arg4((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t_pear_error(arg0, arg1, arg2, arg3, arg4), null);
+        }
       }
       break;
     case 0x15c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("pear_error::getmode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getMode", 0, 1);
         return (t_getmode(), null);
       }
       break;
     case 0x15d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("pear_error::tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::toString", 0, 1);
         return (t_tostring(), null);
       }
       break;
     case 0x41:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("pear_error::gettype", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getType", 0, 1);
         return (t_gettype(), null);
       }
       break;
@@ -430,44 +449,44 @@ Variant c_pear_error::o_invoke_few_args(MethodIndex methodIndex, const char *s,
   switch (methodIndex.m_callIndex) {
     case 0x156:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("pear_error::getuserinfo", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getUserInfo", 0, 1);
         return (t_getuserinfo(), null);
       }
       break;
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("pear_error::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getMessage", 0, 1);
         return (t_getmessage(), null);
       }
       break;
     case 0x157:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("pear_error::getcallback", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getCallback", 0, 1);
         return (t_getcallback(), null);
       }
       break;
     case 0x158:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("pear_error::getdebuginfo", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getDebugInfo", 0, 1);
         return (t_getdebuginfo(), null);
       }
       break;
     case 0x159:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("pear_error::adduserinfo", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("pear_error::addUserInfo", count, 1, 1, 1);
         return (t_adduserinfo(a0), null);
       }
       break;
     case 0x15a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("pear_error::getbacktrace", 1, 1);
+        if (count > 1) return throw_toomany_arguments("pear_error::getBacktrace", 1, 1);
         if (count <= 0) return (t_getbacktrace(), null);
         return (t_getbacktrace(a0), null);
       }
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("pear_error::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getCode", 0, 1);
         return (t_getcode(), null);
       }
       break;
@@ -484,19 +503,19 @@ Variant c_pear_error::o_invoke_few_args(MethodIndex methodIndex, const char *s,
       break;
     case 0x15c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("pear_error::getmode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getMode", 0, 1);
         return (t_getmode(), null);
       }
       break;
     case 0x15d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("pear_error::tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::toString", 0, 1);
         return (t_tostring(), null);
       }
       break;
     case 0x41:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("pear_error::gettype", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getType", 0, 1);
         return (t_gettype(), null);
       }
       break;
@@ -600,7 +619,7 @@ Variant c_pear_error::o_invoke_from_eval(const char *s, Eval::VariableEnvironmen
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("pear_error::getuserinfo", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getUserInfo", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -614,7 +633,7 @@ Variant c_pear_error::o_invoke_from_eval(const char *s, Eval::VariableEnvironmen
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("pear_error::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getMessage", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -628,7 +647,7 @@ Variant c_pear_error::o_invoke_from_eval(const char *s, Eval::VariableEnvironmen
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("pear_error::getcallback", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getCallback", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -642,7 +661,7 @@ Variant c_pear_error::o_invoke_from_eval(const char *s, Eval::VariableEnvironmen
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("pear_error::getdebuginfo", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getDebugInfo", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -657,7 +676,7 @@ Variant c_pear_error::o_invoke_from_eval(const char *s, Eval::VariableEnvironmen
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("pear_error::adduserinfo", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("pear_error::addUserInfo", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -675,7 +694,7 @@ Variant c_pear_error::o_invoke_from_eval(const char *s, Eval::VariableEnvironmen
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("pear_error::getbacktrace", 1, 1);
+        if (count > 1) return throw_toomany_arguments("pear_error::getBacktrace", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -693,7 +712,7 @@ Variant c_pear_error::o_invoke_from_eval(const char *s, Eval::VariableEnvironmen
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("pear_error::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getCode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -746,7 +765,7 @@ Variant c_pear_error::o_invoke_from_eval(const char *s, Eval::VariableEnvironmen
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("pear_error::getmode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getMode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -760,7 +779,7 @@ Variant c_pear_error::o_invoke_from_eval(const char *s, Eval::VariableEnvironmen
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("pear_error::tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -774,7 +793,7 @@ Variant c_pear_error::o_invoke_from_eval(const char *s, Eval::VariableEnvironmen
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("pear_error::gettype", 0, 1);
+        if (count > 0) return throw_toomany_arguments("pear_error::getType", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
diff --git a/src/system/gen/php/classes/reflection.cpp b/src/system/gen/php/classes/reflection.cpp
index 884b5ec37f..31c1c9d698 100644
--- a/src/system/gen/php/classes/reflection.cpp
+++ b/src/system/gen/php/classes/reflection.cpp
@@ -180,79 +180,79 @@ Variant c_reflectionfunctionabstract::o_invoke(MethodIndex methodIndex, const ch
   switch (methodIndex.m_callIndex) {
     case 0x75:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofrequiredparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
         return (t_getnumberofrequiredparameters());
       }
       break;
     case 0x4b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isuserdefined", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
         return (t_isuserdefined());
       }
       break;
     case 0x76:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
         return (t_getnumberofparameters());
       }
       break;
     case 0x50:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getendline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
         return (t_getendline());
       }
       break;
     case 0x77:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstaticvariables", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
         return (t_getstaticvariables());
       }
       break;
     case 0x78:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
         return (t_getparameters());
       }
       break;
     case 0x7a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::returnsreference", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
         return (t_returnsreference());
       }
       break;
     case 0x37:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
         return (t_getfilename());
       }
       break;
     case 0x5d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstartline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
         return (t_getstartline());
       }
       break;
     case 0x60:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getdoccomment", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
         return (t_getdoccomment());
       }
       break;
     case 0x7c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getclosure", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getClosure", 0, 1);
         return (t_getclosure());
       }
       break;
     case 0x6c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
         return (t_getname());
       }
       break;
     case 0x6d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isinternal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
         return (t_isinternal());
       }
       break;
@@ -347,79 +347,79 @@ Variant c_reflectionfunctionabstract::o_invoke_few_args(MethodIndex methodIndex,
   switch (methodIndex.m_callIndex) {
     case 0x75:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofrequiredparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
         return (t_getnumberofrequiredparameters());
       }
       break;
     case 0x4b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isuserdefined", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
         return (t_isuserdefined());
       }
       break;
     case 0x76:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
         return (t_getnumberofparameters());
       }
       break;
     case 0x50:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getendline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
         return (t_getendline());
       }
       break;
     case 0x77:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstaticvariables", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
         return (t_getstaticvariables());
       }
       break;
     case 0x78:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
         return (t_getparameters());
       }
       break;
     case 0x7a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::returnsreference", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
         return (t_returnsreference());
       }
       break;
     case 0x37:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
         return (t_getfilename());
       }
       break;
     case 0x5d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstartline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
         return (t_getstartline());
       }
       break;
     case 0x60:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getdoccomment", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
         return (t_getdoccomment());
       }
       break;
     case 0x7c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getclosure", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getClosure", 0, 1);
         return (t_getclosure());
       }
       break;
     case 0x6c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
         return (t_getname());
       }
       break;
     case 0x6d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isinternal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
         return (t_isinternal());
       }
       break;
@@ -525,7 +525,7 @@ Variant c_reflectionfunctionabstract::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofrequiredparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -539,7 +539,7 @@ Variant c_reflectionfunctionabstract::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isuserdefined", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -553,7 +553,7 @@ Variant c_reflectionfunctionabstract::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -567,7 +567,7 @@ Variant c_reflectionfunctionabstract::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getendline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -581,7 +581,7 @@ Variant c_reflectionfunctionabstract::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstaticvariables", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -595,7 +595,7 @@ Variant c_reflectionfunctionabstract::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -609,7 +609,7 @@ Variant c_reflectionfunctionabstract::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::returnsreference", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -623,7 +623,7 @@ Variant c_reflectionfunctionabstract::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -637,7 +637,7 @@ Variant c_reflectionfunctionabstract::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstartline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -651,7 +651,7 @@ Variant c_reflectionfunctionabstract::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getdoccomment", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -665,7 +665,7 @@ Variant c_reflectionfunctionabstract::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getclosure", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getClosure", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -679,7 +679,7 @@ Variant c_reflectionfunctionabstract::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -693,7 +693,7 @@ Variant c_reflectionfunctionabstract::o_invoke_from_eval(const char *s, Eval::Va
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isinternal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1168,27 +1168,38 @@ Variant c_reflectionobject::o_invoke(MethodIndex methodIndex, const char *s, CAr
   switch (methodIndex.m_callIndex) {
     case 0x48:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("reflectionclass::getmethods", 1, 1);
-        if (count <= 0) return (t_getmethods());
-        return (t_getmethods(params[0]));
+        if (count > 1) return throw_toomany_arguments("ReflectionClass::getMethods", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_getmethods());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getmethods(arg0));
+        }
       }
       break;
     case 0x49:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isiterateable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isIterateable", 0, 1);
         return (t_isiterateable());
       }
       break;
     case 0x4a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count < 1 || count > 2) return throw_wrong_arguments("reflectionclass::getstaticpropertyvalue", count, 1, 2, 1);
-        if (count <= 1) return (t_getstaticpropertyvalue(params[0]));
-        return (t_getstaticpropertyvalue(params[0], params[1]));
+        if (count < 1 || count > 2) return throw_wrong_arguments("ReflectionClass::getStaticPropertyValue", count, 1, 2, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          if (count <= 1) return (t_getstaticpropertyvalue(arg0));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t_getstaticpropertyvalue(arg0, arg1));
+        }
       }
       break;
     case 0x4b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isuserdefined", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isUserDefined", 0, 1);
         return (t_isuserdefined());
       }
       break;
@@ -1200,211 +1211,278 @@ Variant c_reflectionobject::o_invoke(MethodIndex methodIndex, const char *s, CAr
       break;
     case 0x4d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getextension", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtension", 0, 1);
         return (t_getextension());
       }
       break;
     case 0x4e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstructor", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstructor", 0, 1);
         return (t_getconstructor());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x4f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::newinstanceargs", count, 1, 1, 1);
-        return (t_newinstanceargs(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::newInstanceArgs", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_newinstanceargs(arg0));
+        }
       }
       break;
     case 0x50:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getendline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getEndLine", 0, 1);
         return (t_getendline());
       }
       break;
     case 0x52:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::isinstance", count, 1, 1, 1);
-        return (t_isinstance(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::isInstance", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_isinstance(arg0));
+        }
       }
       break;
     case 0x51:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::hasmethod", count, 1, 1, 1);
-        return (t_hasmethod(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasMethod", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_hasmethod(arg0));
+        }
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::__construct", count, 1, 1, 2);
-        return (t___construct(params[0]), null);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t___construct(arg0), null);
+        }
       }
       break;
     case 0x53:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isfinal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isFinal", 0, 1);
         return (t_isfinal());
       }
       break;
     case 0x54:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getmodifiers", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getModifiers", 0, 1);
         return (t_getmodifiers());
       }
       break;
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionobject::export", count, 2, 2, 1);
-        return (ti_export(o_getClassName(), params[0], params[1]));
+        if (count != 2) return throw_wrong_arguments("ReflectionObject::export", count, 2, 2, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (ti_export(o_getClassName(), arg0, arg1));
+        }
       }
       break;
     case 0x56:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getproperties", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getProperties", 0, 1);
         return (t_getproperties());
       }
       break;
     case 0x57:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::hasconstant", count, 1, 1, 1);
-        return (t_hasconstant(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasConstant", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_hasconstant(arg0));
+        }
       }
       break;
     case 0x58:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::getmethod", count, 1, 1, 1);
-        return (t_getmethod(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::getMethod", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getmethod(arg0));
+        }
       }
       break;
     case 0x59:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getextensionname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtensionName", 0, 1);
         return (t_getextensionname());
       }
       break;
     case 0x5a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getparentclass", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getParentClass", 0, 1);
         return (t_getparentclass());
       }
       break;
     case 0x37:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getFileName", 0, 1);
         return (t_getfilename());
       }
       break;
     case 0x5b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::implementsinterface", count, 1, 1, 1);
-        return (t_implementsinterface(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::implementsInterface", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_implementsinterface(arg0));
+        }
       }
       break;
     case 0x5c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfacenames", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaceNames", 0, 1);
         return (t_getinterfacenames());
       }
       break;
     case 0x5e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::getconstant", count, 1, 1, 1);
-        return (t_getconstant(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::getConstant", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getconstant(arg0));
+        }
       }
       break;
     case 0x5d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getstartline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStartLine", 0, 1);
         return (t_getstartline());
       }
       break;
     case 0x5f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstants", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstants", 0, 1);
         return (t_getconstants());
       }
       break;
     case 0x60:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getdoccomment", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDocComment", 0, 1);
         return (t_getdoccomment());
       }
       break;
     case 0x61:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isinterface", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInterface", 0, 1);
         return (t_isinterface());
       }
       break;
     case 0x62:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::issubclassof", count, 1, 1, 1);
-        return (t_issubclassof(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::isSubclassOf", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_issubclassof(arg0));
+        }
       }
       break;
     case 0x63:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::hasproperty", count, 1, 1, 1);
-        return (t_hasproperty(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasProperty", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_hasproperty(arg0));
+        }
       }
       break;
     case 0x65:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getstaticproperties", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStaticProperties", 0, 1);
         return (t_getstaticproperties());
       }
       break;
     case 0x66:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getdefaultproperties", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDefaultProperties", 0, 1);
         return (t_getdefaultproperties());
       }
       break;
     case 0x67:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionclass::setstaticpropertyvalue", count, 2, 2, 1);
-        return (t_setstaticpropertyvalue(params[0], params[1]), null);
+        if (count != 2) return throw_wrong_arguments("ReflectionClass::setStaticPropertyValue", count, 2, 2, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t_setstaticpropertyvalue(arg0, arg1), null);
+        }
       }
       break;
     case 0x68:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isinstantiable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInstantiable", 0, 1);
         return (t_isinstantiable());
       }
       break;
     case 0x69:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfaces", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaces", 0, 1);
         return (t_getinterfaces());
       }
       break;
     case 0x6b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isabstract", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isAbstract", 0, 1);
         return (t_isabstract());
       }
       break;
     case 0x6c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getName", 0, 1);
         return (t_getname());
       }
       break;
     case 0x6e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::getproperty", count, 1, 1, 1);
-        return (t_getproperty(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::getProperty", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getproperty(arg0));
+        }
       }
       break;
     case 0x6d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isinternal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInternal", 0, 1);
         return (t_isinternal());
       }
       break;
@@ -1739,27 +1817,27 @@ Variant c_reflectionobject::o_invoke_few_args(MethodIndex methodIndex, const cha
   switch (methodIndex.m_callIndex) {
     case 0x48:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("reflectionclass::getmethods", 1, 1);
+        if (count > 1) return throw_toomany_arguments("ReflectionClass::getMethods", 1, 1);
         if (count <= 0) return (t_getmethods());
         return (t_getmethods(a0));
       }
       break;
     case 0x49:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isiterateable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isIterateable", 0, 1);
         return (t_isiterateable());
       }
       break;
     case 0x4a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count < 1 || count > 2) return throw_wrong_arguments("reflectionclass::getstaticpropertyvalue", count, 1, 2, 1);
+        if (count < 1 || count > 2) return throw_wrong_arguments("ReflectionClass::getStaticPropertyValue", count, 1, 2, 1);
         if (count <= 1) return (t_getstaticpropertyvalue(a0));
         return (t_getstaticpropertyvalue(a0, a1));
       }
       break;
     case 0x4b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isuserdefined", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isUserDefined", 0, 1);
         return (t_isuserdefined());
       }
       break;
@@ -1778,211 +1856,211 @@ Variant c_reflectionobject::o_invoke_few_args(MethodIndex methodIndex, const cha
       break;
     case 0x4d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getextension", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtension", 0, 1);
         return (t_getextension());
       }
       break;
     case 0x4e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstructor", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstructor", 0, 1);
         return (t_getconstructor());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x4f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::newinstanceargs", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::newInstanceArgs", count, 1, 1, 1);
         return (t_newinstanceargs(a0));
       }
       break;
     case 0x50:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getendline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getEndLine", 0, 1);
         return (t_getendline());
       }
       break;
     case 0x52:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::isinstance", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::isInstance", count, 1, 1, 1);
         return (t_isinstance(a0));
       }
       break;
     case 0x51:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::hasmethod", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasMethod", count, 1, 1, 1);
         return (t_hasmethod(a0));
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::__construct", count, 1, 1, 2);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
         return (t___construct(a0), null);
       }
       break;
     case 0x53:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isfinal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isFinal", 0, 1);
         return (t_isfinal());
       }
       break;
     case 0x54:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getmodifiers", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getModifiers", 0, 1);
         return (t_getmodifiers());
       }
       break;
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionobject::export", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionObject::export", count, 2, 2, 1);
         return (ti_export(o_getClassName(), a0, a1));
       }
       break;
     case 0x56:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getproperties", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getProperties", 0, 1);
         return (t_getproperties());
       }
       break;
     case 0x57:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::hasconstant", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasConstant", count, 1, 1, 1);
         return (t_hasconstant(a0));
       }
       break;
     case 0x58:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::getmethod", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::getMethod", count, 1, 1, 1);
         return (t_getmethod(a0));
       }
       break;
     case 0x59:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getextensionname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtensionName", 0, 1);
         return (t_getextensionname());
       }
       break;
     case 0x5a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getparentclass", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getParentClass", 0, 1);
         return (t_getparentclass());
       }
       break;
     case 0x37:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getFileName", 0, 1);
         return (t_getfilename());
       }
       break;
     case 0x5b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::implementsinterface", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::implementsInterface", count, 1, 1, 1);
         return (t_implementsinterface(a0));
       }
       break;
     case 0x5c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfacenames", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaceNames", 0, 1);
         return (t_getinterfacenames());
       }
       break;
     case 0x5e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::getconstant", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::getConstant", count, 1, 1, 1);
         return (t_getconstant(a0));
       }
       break;
     case 0x5d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getstartline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStartLine", 0, 1);
         return (t_getstartline());
       }
       break;
     case 0x5f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstants", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstants", 0, 1);
         return (t_getconstants());
       }
       break;
     case 0x60:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getdoccomment", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDocComment", 0, 1);
         return (t_getdoccomment());
       }
       break;
     case 0x61:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isinterface", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInterface", 0, 1);
         return (t_isinterface());
       }
       break;
     case 0x62:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::issubclassof", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::isSubclassOf", count, 1, 1, 1);
         return (t_issubclassof(a0));
       }
       break;
     case 0x63:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::hasproperty", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasProperty", count, 1, 1, 1);
         return (t_hasproperty(a0));
       }
       break;
     case 0x65:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getstaticproperties", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStaticProperties", 0, 1);
         return (t_getstaticproperties());
       }
       break;
     case 0x66:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getdefaultproperties", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDefaultProperties", 0, 1);
         return (t_getdefaultproperties());
       }
       break;
     case 0x67:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionclass::setstaticpropertyvalue", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionClass::setStaticPropertyValue", count, 2, 2, 1);
         return (t_setstaticpropertyvalue(a0, a1), null);
       }
       break;
     case 0x68:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isinstantiable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInstantiable", 0, 1);
         return (t_isinstantiable());
       }
       break;
     case 0x69:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfaces", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaces", 0, 1);
         return (t_getinterfaces());
       }
       break;
     case 0x6b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isabstract", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isAbstract", 0, 1);
         return (t_isabstract());
       }
       break;
     case 0x6c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getName", 0, 1);
         return (t_getname());
       }
       break;
     case 0x6e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::getproperty", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::getProperty", count, 1, 1, 1);
         return (t_getproperty(a0));
       }
       break;
     case 0x6d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isinternal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInternal", 0, 1);
         return (t_isinternal());
       }
       break;
@@ -2247,8 +2325,14 @@ Variant c_reflectionobject::os_invoke(const char *c, MethodIndex methodIndex, co
   switch (methodIndex.m_callIndex) {
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionobject::export", count, 2, 2, 1);
-        return (ti_export(c, params[0], params[1]));
+        if (count != 2) return throw_wrong_arguments("ReflectionObject::export", count, 2, 2, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (ti_export(c, arg0, arg1));
+        }
       }
       break;
     default:
@@ -2285,7 +2369,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("reflectionclass::getmethods", 1, 1);
+        if (count > 1) return throw_toomany_arguments("ReflectionClass::getMethods", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2303,7 +2387,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isiterateable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isIterateable", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2319,7 +2403,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count < 1 || count > 2) return throw_wrong_arguments("reflectionclass::getstaticpropertyvalue", count, 1, 2, 1);
+        if (count < 1 || count > 2) return throw_wrong_arguments("ReflectionClass::getStaticPropertyValue", count, 1, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2340,7 +2424,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isuserdefined", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isUserDefined", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2369,7 +2453,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getextension", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtension", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2383,7 +2467,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstructor", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstructor", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2397,7 +2481,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2412,7 +2496,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::newinstanceargs", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::newInstanceArgs", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2429,7 +2513,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getendline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getEndLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2444,7 +2528,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::isinstance", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::isInstance", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2462,7 +2546,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::hasmethod", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasMethod", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2480,7 +2564,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::__construct", count, 1, 1, 2);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2497,7 +2581,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isfinal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isFinal", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2511,7 +2595,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getmodifiers", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getModifiers", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2527,7 +2611,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("reflectionobject::export", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionObject::export", count, 2, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2547,7 +2631,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getproperties", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getProperties", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2562,7 +2646,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::hasconstant", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasConstant", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2580,7 +2664,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::getmethod", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::getMethod", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2597,7 +2681,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getextensionname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtensionName", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2611,7 +2695,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getparentclass", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getParentClass", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2625,7 +2709,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getFileName", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2640,7 +2724,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::implementsinterface", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::implementsInterface", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2657,7 +2741,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfacenames", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaceNames", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2672,7 +2756,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::getconstant", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::getConstant", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2689,7 +2773,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getstartline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStartLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2703,7 +2787,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstants", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstants", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2717,7 +2801,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getdoccomment", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDocComment", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2731,7 +2815,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isinterface", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInterface", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2746,7 +2830,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::issubclassof", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::isSubclassOf", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2764,7 +2848,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::hasproperty", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasProperty", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2781,7 +2865,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getstaticproperties", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStaticProperties", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2795,7 +2879,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getdefaultproperties", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDefaultProperties", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2811,7 +2895,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("reflectionclass::setstaticpropertyvalue", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionClass::setStaticPropertyValue", count, 2, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2831,7 +2915,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isinstantiable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInstantiable", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2845,7 +2929,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfaces", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaces", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2859,7 +2943,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isabstract", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isAbstract", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2873,7 +2957,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getName", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2888,7 +2972,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::getproperty", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::getProperty", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2905,7 +2989,7 @@ Variant c_reflectionobject::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isinternal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInternal", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3564,7 +3648,7 @@ Variant c_reflectionobject::os_invoke_from_eval(const char *c, const char *s, Ev
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("reflectionobject::export", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionObject::export", count, 2, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -3750,57 +3834,63 @@ Variant c_reflectionexception::o_invoke(MethodIndex methodIndex, const char *s,
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
-        if (count <= 0) return (t___construct(), null);
-        if (count == 1) return (t___construct(params[0]), null);
-        return (t___construct(params[0], params[1]), null);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t___construct(), null);
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -3885,19 +3975,19 @@ Variant c_reflectionexception::o_invoke_few_args(MethodIndex methodIndex, const
   switch (methodIndex.m_callIndex) {
     case 0x19:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         return (t_getmessage());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         if (count <= 0) return (t___construct(), null);
         if (count == 1) return (t___construct(a0), null);
         return (t___construct(a0, a1), null);
@@ -3905,37 +3995,37 @@ Variant c_reflectionexception::o_invoke_few_args(MethodIndex methodIndex, const
       break;
     case 0x1b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         return (t_getcode());
       }
       break;
     case 0x1c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         return (t_getline());
       }
       break;
     case 0x1d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         return (t___init__(), null);
       }
       break;
     case 0x1e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         return (t_getfile());
       }
       break;
     case 0x1f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         return (t_gettraceasstring());
       }
       break;
     case 0x20:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         return (t_gettrace());
       }
       break;
@@ -4025,7 +4115,7 @@ Variant c_reflectionexception::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getmessage", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getMessage", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4039,7 +4129,7 @@ Variant c_reflectionexception::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4055,7 +4145,7 @@ Variant c_reflectionexception::o_invoke_from_eval(const char *s, Eval::VariableE
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 2) return throw_toomany_arguments("exception::__construct", 2, 2);
+        if (count > 2) return throw_toomany_arguments("Exception::__construct", 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -4077,7 +4167,7 @@ Variant c_reflectionexception::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getcode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getCode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4091,7 +4181,7 @@ Variant c_reflectionexception::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4105,7 +4195,7 @@ Variant c_reflectionexception::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::__init__", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::__init__", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4119,7 +4209,7 @@ Variant c_reflectionexception::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::getfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4133,7 +4223,7 @@ Variant c_reflectionexception::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettraceasstring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTraceAsString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4147,7 +4237,7 @@ Variant c_reflectionexception::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("exception::gettrace", 0, 1);
+        if (count > 0) return throw_toomany_arguments("Exception::getTrace", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4616,27 +4706,38 @@ Variant c_reflectionclass::o_invoke(MethodIndex methodIndex, const char *s, CArr
   switch (methodIndex.m_callIndex) {
     case 0x48:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("reflectionclass::getmethods", 1, 1);
-        if (count <= 0) return (t_getmethods());
-        return (t_getmethods(params[0]));
+        if (count > 1) return throw_toomany_arguments("ReflectionClass::getMethods", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_getmethods());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getmethods(arg0));
+        }
       }
       break;
     case 0x49:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isiterateable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isIterateable", 0, 1);
         return (t_isiterateable());
       }
       break;
     case 0x4a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count < 1 || count > 2) return throw_wrong_arguments("reflectionclass::getstaticpropertyvalue", count, 1, 2, 1);
-        if (count <= 1) return (t_getstaticpropertyvalue(params[0]));
-        return (t_getstaticpropertyvalue(params[0], params[1]));
+        if (count < 1 || count > 2) return throw_wrong_arguments("ReflectionClass::getStaticPropertyValue", count, 1, 2, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          if (count <= 1) return (t_getstaticpropertyvalue(arg0));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t_getstaticpropertyvalue(arg0, arg1));
+        }
       }
       break;
     case 0x4b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isuserdefined", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isUserDefined", 0, 1);
         return (t_isuserdefined());
       }
       break;
@@ -4648,223 +4749,301 @@ Variant c_reflectionclass::o_invoke(MethodIndex methodIndex, const char *s, CArr
       break;
     case 0x4d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getextension", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtension", 0, 1);
         return (t_getextension());
       }
       break;
     case 0x4e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstructor", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstructor", 0, 1);
         return (t_getconstructor());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x4f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::newinstanceargs", count, 1, 1, 1);
-        return (t_newinstanceargs(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::newInstanceArgs", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_newinstanceargs(arg0));
+        }
       }
       break;
     case 0x50:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getendline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getEndLine", 0, 1);
         return (t_getendline());
       }
       break;
     case 0x52:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::isinstance", count, 1, 1, 1);
-        return (t_isinstance(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::isInstance", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_isinstance(arg0));
+        }
       }
       break;
     case 0x51:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::hasmethod", count, 1, 1, 1);
-        return (t_hasmethod(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasMethod", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_hasmethod(arg0));
+        }
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::__construct", count, 1, 1, 2);
-        return (t___construct(params[0]), null);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t___construct(arg0), null);
+        }
       }
       break;
     case 0x53:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isfinal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isFinal", 0, 1);
         return (t_isfinal());
       }
       break;
     case 0x54:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getmodifiers", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getModifiers", 0, 1);
         return (t_getmodifiers());
       }
       break;
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionclass::export", count, 2, 2, 1);
-        return (ti_export(o_getClassName(), params[0], params[1]));
+        if (count != 2) return throw_wrong_arguments("ReflectionClass::export", count, 2, 2, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (ti_export(o_getClassName(), arg0, arg1));
+        }
       }
       break;
     case 0x56:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getproperties", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getProperties", 0, 1);
         return (t_getproperties());
       }
       break;
     case 0x57:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::hasconstant", count, 1, 1, 1);
-        return (t_hasconstant(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasConstant", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_hasconstant(arg0));
+        }
       }
       break;
     case 0x58:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::getmethod", count, 1, 1, 1);
-        return (t_getmethod(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::getMethod", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getmethod(arg0));
+        }
       }
       break;
     case 0x59:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getextensionname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtensionName", 0, 1);
         return (t_getextensionname());
       }
       break;
     case 0x5a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getparentclass", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getParentClass", 0, 1);
         return (t_getparentclass());
       }
       break;
     case 0x37:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getFileName", 0, 1);
         return (t_getfilename());
       }
       break;
     case 0x5b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::implementsinterface", count, 1, 1, 1);
-        return (t_implementsinterface(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::implementsInterface", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_implementsinterface(arg0));
+        }
       }
       break;
     case 0x5c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfacenames", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaceNames", 0, 1);
         return (t_getinterfacenames());
       }
       break;
     case 0x5e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::getconstant", count, 1, 1, 1);
-        return (t_getconstant(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::getConstant", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getconstant(arg0));
+        }
       }
       break;
     case 0x5d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getstartline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStartLine", 0, 1);
         return (t_getstartline());
       }
       break;
     case 0x5f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstants", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstants", 0, 1);
         return (t_getconstants());
       }
       break;
     case 0x60:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getdoccomment", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDocComment", 0, 1);
         return (t_getdoccomment());
       }
       break;
     case 0x61:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isinterface", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInterface", 0, 1);
         return (t_isinterface());
       }
       break;
     case 0x62:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::issubclassof", count, 1, 1, 1);
-        return (t_issubclassof(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::isSubclassOf", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_issubclassof(arg0));
+        }
       }
       break;
     case 0x63:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::hasproperty", count, 1, 1, 1);
-        return (t_hasproperty(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasProperty", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_hasproperty(arg0));
+        }
       }
       break;
     case 0x65:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getstaticproperties", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStaticProperties", 0, 1);
         return (t_getstaticproperties());
       }
       break;
     case 0x64:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionclass::test", count, 2, 2, 1);
-        return (t_test(params[0], params[1]));
+        if (count != 2) return throw_wrong_arguments("ReflectionClass::test", count, 2, 2, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t_test(arg0, arg1));
+        }
       }
       break;
     case 0x66:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getdefaultproperties", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDefaultProperties", 0, 1);
         return (t_getdefaultproperties());
       }
       break;
     case 0x67:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionclass::setstaticpropertyvalue", count, 2, 2, 1);
-        return (t_setstaticpropertyvalue(params[0], params[1]), null);
+        if (count != 2) return throw_wrong_arguments("ReflectionClass::setStaticPropertyValue", count, 2, 2, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t_setstaticpropertyvalue(arg0, arg1), null);
+        }
       }
       break;
     case 0x68:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isinstantiable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInstantiable", 0, 1);
         return (t_isinstantiable());
       }
       break;
     case 0x69:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfaces", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaces", 0, 1);
         return (t_getinterfaces());
       }
       break;
     case 0x6a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::fetch", count, 1, 1, 1);
-        return (t_fetch(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::fetch", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_fetch(arg0));
+        }
       }
       break;
     case 0x6b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isabstract", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isAbstract", 0, 1);
         return (t_isabstract());
       }
       break;
     case 0x6c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getName", 0, 1);
         return (t_getname());
       }
       break;
     case 0x6e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::getproperty", count, 1, 1, 1);
-        return (t_getproperty(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::getProperty", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getproperty(arg0));
+        }
       }
       break;
     case 0x6d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isinternal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInternal", 0, 1);
         return (t_isinternal());
       }
       break;
@@ -5220,27 +5399,27 @@ Variant c_reflectionclass::o_invoke_few_args(MethodIndex methodIndex, const char
   switch (methodIndex.m_callIndex) {
     case 0x48:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("reflectionclass::getmethods", 1, 1);
+        if (count > 1) return throw_toomany_arguments("ReflectionClass::getMethods", 1, 1);
         if (count <= 0) return (t_getmethods());
         return (t_getmethods(a0));
       }
       break;
     case 0x49:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isiterateable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isIterateable", 0, 1);
         return (t_isiterateable());
       }
       break;
     case 0x4a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count < 1 || count > 2) return throw_wrong_arguments("reflectionclass::getstaticpropertyvalue", count, 1, 2, 1);
+        if (count < 1 || count > 2) return throw_wrong_arguments("ReflectionClass::getStaticPropertyValue", count, 1, 2, 1);
         if (count <= 1) return (t_getstaticpropertyvalue(a0));
         return (t_getstaticpropertyvalue(a0, a1));
       }
       break;
     case 0x4b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isuserdefined", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isUserDefined", 0, 1);
         return (t_isuserdefined());
       }
       break;
@@ -5259,223 +5438,223 @@ Variant c_reflectionclass::o_invoke_few_args(MethodIndex methodIndex, const char
       break;
     case 0x4d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getextension", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtension", 0, 1);
         return (t_getextension());
       }
       break;
     case 0x4e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstructor", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstructor", 0, 1);
         return (t_getconstructor());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x4f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::newinstanceargs", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::newInstanceArgs", count, 1, 1, 1);
         return (t_newinstanceargs(a0));
       }
       break;
     case 0x50:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getendline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getEndLine", 0, 1);
         return (t_getendline());
       }
       break;
     case 0x52:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::isinstance", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::isInstance", count, 1, 1, 1);
         return (t_isinstance(a0));
       }
       break;
     case 0x51:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::hasmethod", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasMethod", count, 1, 1, 1);
         return (t_hasmethod(a0));
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::__construct", count, 1, 1, 2);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
         return (t___construct(a0), null);
       }
       break;
     case 0x53:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isfinal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isFinal", 0, 1);
         return (t_isfinal());
       }
       break;
     case 0x54:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getmodifiers", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getModifiers", 0, 1);
         return (t_getmodifiers());
       }
       break;
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionclass::export", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionClass::export", count, 2, 2, 1);
         return (ti_export(o_getClassName(), a0, a1));
       }
       break;
     case 0x56:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getproperties", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getProperties", 0, 1);
         return (t_getproperties());
       }
       break;
     case 0x57:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::hasconstant", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasConstant", count, 1, 1, 1);
         return (t_hasconstant(a0));
       }
       break;
     case 0x58:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::getmethod", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::getMethod", count, 1, 1, 1);
         return (t_getmethod(a0));
       }
       break;
     case 0x59:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getextensionname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtensionName", 0, 1);
         return (t_getextensionname());
       }
       break;
     case 0x5a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getparentclass", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getParentClass", 0, 1);
         return (t_getparentclass());
       }
       break;
     case 0x37:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getFileName", 0, 1);
         return (t_getfilename());
       }
       break;
     case 0x5b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::implementsinterface", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::implementsInterface", count, 1, 1, 1);
         return (t_implementsinterface(a0));
       }
       break;
     case 0x5c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfacenames", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaceNames", 0, 1);
         return (t_getinterfacenames());
       }
       break;
     case 0x5e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::getconstant", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::getConstant", count, 1, 1, 1);
         return (t_getconstant(a0));
       }
       break;
     case 0x5d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getstartline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStartLine", 0, 1);
         return (t_getstartline());
       }
       break;
     case 0x5f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstants", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstants", 0, 1);
         return (t_getconstants());
       }
       break;
     case 0x60:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getdoccomment", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDocComment", 0, 1);
         return (t_getdoccomment());
       }
       break;
     case 0x61:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isinterface", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInterface", 0, 1);
         return (t_isinterface());
       }
       break;
     case 0x62:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::issubclassof", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::isSubclassOf", count, 1, 1, 1);
         return (t_issubclassof(a0));
       }
       break;
     case 0x63:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::hasproperty", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasProperty", count, 1, 1, 1);
         return (t_hasproperty(a0));
       }
       break;
     case 0x65:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getstaticproperties", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStaticProperties", 0, 1);
         return (t_getstaticproperties());
       }
       break;
     case 0x64:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionclass::test", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionClass::test", count, 2, 2, 1);
         return (t_test(a0, a1));
       }
       break;
     case 0x66:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getdefaultproperties", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDefaultProperties", 0, 1);
         return (t_getdefaultproperties());
       }
       break;
     case 0x67:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionclass::setstaticpropertyvalue", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionClass::setStaticPropertyValue", count, 2, 2, 1);
         return (t_setstaticpropertyvalue(a0, a1), null);
       }
       break;
     case 0x68:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isinstantiable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInstantiable", 0, 1);
         return (t_isinstantiable());
       }
       break;
     case 0x69:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfaces", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaces", 0, 1);
         return (t_getinterfaces());
       }
       break;
     case 0x6a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::fetch", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::fetch", count, 1, 1, 1);
         return (t_fetch(a0));
       }
       break;
     case 0x6b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isabstract", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isAbstract", 0, 1);
         return (t_isabstract());
       }
       break;
     case 0x6c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getName", 0, 1);
         return (t_getname());
       }
       break;
     case 0x6e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionclass::getproperty", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::getProperty", count, 1, 1, 1);
         return (t_getproperty(a0));
       }
       break;
     case 0x6d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isinternal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInternal", 0, 1);
         return (t_isinternal());
       }
       break;
@@ -5750,8 +5929,14 @@ Variant c_reflectionclass::os_invoke(const char *c, MethodIndex methodIndex, con
   switch (methodIndex.m_callIndex) {
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionclass::export", count, 2, 2, 1);
-        return (ti_export(c, params[0], params[1]));
+        if (count != 2) return throw_wrong_arguments("ReflectionClass::export", count, 2, 2, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (ti_export(c, arg0, arg1));
+        }
       }
       break;
     default:
@@ -5788,7 +5973,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("reflectionclass::getmethods", 1, 1);
+        if (count > 1) return throw_toomany_arguments("ReflectionClass::getMethods", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -5806,7 +5991,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isiterateable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isIterateable", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5822,7 +6007,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count < 1 || count > 2) return throw_wrong_arguments("reflectionclass::getstaticpropertyvalue", count, 1, 2, 1);
+        if (count < 1 || count > 2) return throw_wrong_arguments("ReflectionClass::getStaticPropertyValue", count, 1, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -5843,7 +6028,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isuserdefined", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isUserDefined", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5872,7 +6057,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getextension", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtension", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5886,7 +6071,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstructor", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstructor", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5900,7 +6085,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5915,7 +6100,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::newinstanceargs", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::newInstanceArgs", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -5932,7 +6117,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getendline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getEndLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5947,7 +6132,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::isinstance", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::isInstance", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -5965,7 +6150,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::hasmethod", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasMethod", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -5983,7 +6168,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::__construct", count, 1, 1, 2);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::__construct", count, 1, 1, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6000,7 +6185,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isfinal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isFinal", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6014,7 +6199,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getmodifiers", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getModifiers", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6030,7 +6215,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("reflectionclass::export", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionClass::export", count, 2, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6050,7 +6235,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getproperties", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getProperties", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6065,7 +6250,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::hasconstant", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasConstant", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6083,7 +6268,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::getmethod", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::getMethod", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6100,7 +6285,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getextensionname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getExtensionName", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6114,7 +6299,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getparentclass", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getParentClass", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6128,7 +6313,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getFileName", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6143,7 +6328,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::implementsinterface", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::implementsInterface", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6160,7 +6345,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfacenames", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaceNames", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6175,7 +6360,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::getconstant", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::getConstant", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6192,7 +6377,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getstartline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStartLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6206,7 +6391,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getconstants", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getConstants", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6220,7 +6405,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getdoccomment", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDocComment", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6234,7 +6419,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isinterface", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInterface", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6249,7 +6434,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::issubclassof", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::isSubclassOf", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6267,7 +6452,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::hasproperty", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::hasProperty", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6284,7 +6469,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getstaticproperties", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getStaticProperties", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6300,7 +6485,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("reflectionclass::test", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionClass::test", count, 2, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6320,7 +6505,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getdefaultproperties", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getDefaultProperties", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6336,7 +6521,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("reflectionclass::setstaticpropertyvalue", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionClass::setStaticPropertyValue", count, 2, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6356,7 +6541,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isinstantiable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInstantiable", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6370,7 +6555,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getinterfaces", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getInterfaces", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6385,7 +6570,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::fetch", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::fetch", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6402,7 +6587,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isabstract", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isAbstract", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6416,7 +6601,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::getName", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -6431,7 +6616,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionclass::getproperty", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionClass::getProperty", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -6448,7 +6633,7 @@ Variant c_reflectionclass::o_invoke_from_eval(const char *s, Eval::VariableEnvir
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionclass::isinternal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionClass::isInternal", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -7145,7 +7330,7 @@ Variant c_reflectionclass::os_invoke_from_eval(const char *c, const char *s, Eva
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("reflectionclass::export", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionClass::export", count, 2, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -8203,67 +8388,78 @@ Variant c_reflectionextension::o_invoke(MethodIndex methodIndex, const char *s,
   switch (methodIndex.m_callIndex) {
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionextension::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionextension::__construct", count, 1, 1, 2);
-        return (t___construct(params[0]), null);
+        if (count != 1) return throw_wrong_arguments("ReflectionExtension::__construct", count, 1, 1, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t___construct(arg0), null);
+        }
       }
       break;
     case 0x6f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getfunctions", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getFunctions", 0, 1);
         return (t_getfunctions());
       }
       break;
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionextension::export", count, 2, 2, 1);
-        return (ti_export(o_getClassName(), params[0], params[1]));
+        if (count != 2) return throw_wrong_arguments("ReflectionExtension::export", count, 2, 2, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (ti_export(o_getClassName(), arg0, arg1));
+        }
       }
       break;
     case 0x70:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionextension::info", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::info", 0, 1);
         return (t_info());
       }
       break;
     case 0x71:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getinientries", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getINIEntries", 0, 1);
         return (t_getinientries());
       }
       break;
     case 0x5f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getconstants", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getConstants", 0, 1);
         return (t_getconstants());
       }
       break;
     case 0x72:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getclassnames", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getClassNames", 0, 1);
         return (t_getclassnames());
       }
       break;
     case 0x73:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getversion", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getVersion", 0, 1);
         return (t_getversion());
       }
       break;
     case 0x6c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getName", 0, 1);
         return (t_getname());
       }
       break;
     case 0x74:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getclasses", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getClasses", 0, 1);
         return (t_getclasses());
       }
       break;
@@ -8359,67 +8555,67 @@ Variant c_reflectionextension::o_invoke_few_args(MethodIndex methodIndex, const
   switch (methodIndex.m_callIndex) {
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionextension::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionextension::__construct", count, 1, 1, 2);
+        if (count != 1) return throw_wrong_arguments("ReflectionExtension::__construct", count, 1, 1, 2);
         return (t___construct(a0), null);
       }
       break;
     case 0x6f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getfunctions", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getFunctions", 0, 1);
         return (t_getfunctions());
       }
       break;
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionextension::export", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionExtension::export", count, 2, 2, 1);
         return (ti_export(o_getClassName(), a0, a1));
       }
       break;
     case 0x70:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionextension::info", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::info", 0, 1);
         return (t_info());
       }
       break;
     case 0x71:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getinientries", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getINIEntries", 0, 1);
         return (t_getinientries());
       }
       break;
     case 0x5f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getconstants", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getConstants", 0, 1);
         return (t_getconstants());
       }
       break;
     case 0x72:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getclassnames", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getClassNames", 0, 1);
         return (t_getclassnames());
       }
       break;
     case 0x73:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getversion", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getVersion", 0, 1);
         return (t_getversion());
       }
       break;
     case 0x6c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getName", 0, 1);
         return (t_getname());
       }
       break;
     case 0x74:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getclasses", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getClasses", 0, 1);
         return (t_getclasses());
       }
       break;
@@ -8505,8 +8701,14 @@ Variant c_reflectionextension::os_invoke(const char *c, MethodIndex methodIndex,
   switch (methodIndex.m_callIndex) {
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionextension::export", count, 2, 2, 1);
-        return (ti_export(c, params[0], params[1]));
+        if (count != 2) return throw_wrong_arguments("ReflectionExtension::export", count, 2, 2, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (ti_export(c, arg0, arg1));
+        }
       }
       break;
     default:
@@ -8542,7 +8744,7 @@ Variant c_reflectionextension::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionextension::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -8557,7 +8759,7 @@ Variant c_reflectionextension::o_invoke_from_eval(const char *s, Eval::VariableE
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionextension::__construct", count, 1, 1, 2);
+        if (count != 1) return throw_wrong_arguments("ReflectionExtension::__construct", count, 1, 1, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -8574,7 +8776,7 @@ Variant c_reflectionextension::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getfunctions", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getFunctions", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -8590,7 +8792,7 @@ Variant c_reflectionextension::o_invoke_from_eval(const char *s, Eval::VariableE
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("reflectionextension::export", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionExtension::export", count, 2, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -8610,7 +8812,7 @@ Variant c_reflectionextension::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionextension::info", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::info", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -8624,7 +8826,7 @@ Variant c_reflectionextension::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getinientries", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getINIEntries", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -8638,7 +8840,7 @@ Variant c_reflectionextension::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getconstants", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getConstants", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -8652,7 +8854,7 @@ Variant c_reflectionextension::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getclassnames", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getClassNames", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -8666,7 +8868,7 @@ Variant c_reflectionextension::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getversion", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getVersion", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -8680,7 +8882,7 @@ Variant c_reflectionextension::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getName", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -8694,7 +8896,7 @@ Variant c_reflectionextension::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionextension::getclasses", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionExtension::getClasses", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -8888,7 +9090,7 @@ Variant c_reflectionextension::os_invoke_from_eval(const char *c, const char *s,
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("reflectionextension::export", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionExtension::export", count, 2, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -9297,170 +9499,194 @@ Variant c_reflectionmethod::o_invoke(MethodIndex methodIndex, const char *s, CAr
   switch (methodIndex.m_callIndex) {
     case 0x75:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofrequiredparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
         return (t_getnumberofrequiredparameters());
       }
       break;
     case 0x7d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isprivate", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isPrivate", 0, 1);
         return (t_isprivate());
       }
       break;
     case 0x4b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isuserdefined", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
         return (t_isuserdefined());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x76:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
         return (t_getnumberofparameters());
       }
       break;
     case 0x7e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isprotected", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isProtected", 0, 1);
         return (t_isprotected());
       }
       break;
     case 0x7f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isstatic", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isStatic", 0, 1);
         return (t_isstatic());
       }
       break;
     case 0x80:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::getdeclaringclass", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getDeclaringClass", 0, 1);
         return (t_getdeclaringclass());
       }
       break;
     case 0x81:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isconstructor", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isConstructor", 0, 1);
         return (t_isconstructor());
       }
       break;
     case 0x50:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getendline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
         return (t_getendline());
       }
       break;
     case 0x77:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstaticvariables", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
         return (t_getstaticvariables());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionmethod::__construct", count, 2, 2, 2);
-        return (t___construct(params[0], params[1]), null);
+        if (count != 2) return throw_wrong_arguments("ReflectionMethod::__construct", count, 2, 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0x78:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
         return (t_getparameters());
       }
       break;
     case 0x53:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isfinal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isFinal", 0, 1);
         return (t_isfinal());
       }
       break;
     case 0x79:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionmethod::invokeargs", count, 2, 2, 1);
-        return (t_invokeargs(params[0], params[1]));
+        if (count != 2) return throw_wrong_arguments("ReflectionMethod::invokeArgs", count, 2, 2, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t_invokeargs(arg0, arg1));
+        }
       }
       break;
     case 0x7a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::returnsreference", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
         return (t_returnsreference());
       }
       break;
     case 0x54:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::getmodifiers", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getModifiers", 0, 1);
         return (t_getmodifiers());
       }
       break;
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 3) return throw_wrong_arguments("reflectionmethod::export", count, 3, 3, 1);
-        return (ti_export(o_getClassName(), params[0], params[1], params[2]));
+        if (count != 3) return throw_wrong_arguments("ReflectionMethod::export", count, 3, 3, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (ti_export(o_getClassName(), arg0, arg1, arg2));
+        }
       }
       break;
     case 0x7b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count < 1) return throw_missing_arguments("reflectionmethod::invoke", count+1, 1);
-        if (count <= 1) return (t_invoke(count, params[0]));
-        return (t_invoke(count,params[0], params.slice(1, count - 1, false)));
+        if (count < 1) return throw_missing_arguments("ReflectionMethod::invoke", count+1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          if (count <= 1) return (t_invoke(count, arg0));
+          return (t_invoke(count,arg0, params.slice(1, count - 1, false)));
+        }
       }
       break;
     case 0x82:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::ispublic", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isPublic", 0, 1);
         return (t_ispublic());
       }
       break;
     case 0x37:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
         return (t_getfilename());
       }
       break;
     case 0x83:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isdestructor", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isDestructor", 0, 1);
         return (t_isdestructor());
       }
       break;
     case 0x5d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstartline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
         return (t_getstartline());
       }
       break;
     case 0x60:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getdoccomment", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
         return (t_getdoccomment());
       }
       break;
     case 0x7c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::getclosure", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getClosure", 0, 1);
         return (t_getclosure());
       }
       break;
     case 0x6b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isabstract", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isAbstract", 0, 1);
         return (t_isabstract());
       }
       break;
     case 0x6c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
         return (t_getname());
       }
       break;
     case 0x6d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isinternal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
         return (t_isinternal());
       }
       break;
@@ -9670,115 +9896,115 @@ Variant c_reflectionmethod::o_invoke_few_args(MethodIndex methodIndex, const cha
   switch (methodIndex.m_callIndex) {
     case 0x75:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofrequiredparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
         return (t_getnumberofrequiredparameters());
       }
       break;
     case 0x7d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isprivate", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isPrivate", 0, 1);
         return (t_isprivate());
       }
       break;
     case 0x4b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isuserdefined", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
         return (t_isuserdefined());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x76:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
         return (t_getnumberofparameters());
       }
       break;
     case 0x7e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isprotected", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isProtected", 0, 1);
         return (t_isprotected());
       }
       break;
     case 0x7f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isstatic", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isStatic", 0, 1);
         return (t_isstatic());
       }
       break;
     case 0x80:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::getdeclaringclass", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getDeclaringClass", 0, 1);
         return (t_getdeclaringclass());
       }
       break;
     case 0x81:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isconstructor", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isConstructor", 0, 1);
         return (t_isconstructor());
       }
       break;
     case 0x50:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getendline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
         return (t_getendline());
       }
       break;
     case 0x77:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstaticvariables", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
         return (t_getstaticvariables());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionmethod::__construct", count, 2, 2, 2);
+        if (count != 2) return throw_wrong_arguments("ReflectionMethod::__construct", count, 2, 2, 2);
         return (t___construct(a0, a1), null);
       }
       break;
     case 0x78:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
         return (t_getparameters());
       }
       break;
     case 0x53:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isfinal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isFinal", 0, 1);
         return (t_isfinal());
       }
       break;
     case 0x79:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionmethod::invokeargs", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionMethod::invokeArgs", count, 2, 2, 1);
         return (t_invokeargs(a0, a1));
       }
       break;
     case 0x7a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::returnsreference", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
         return (t_returnsreference());
       }
       break;
     case 0x54:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::getmodifiers", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getModifiers", 0, 1);
         return (t_getmodifiers());
       }
       break;
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 3) return throw_wrong_arguments("reflectionmethod::export", count, 3, 3, 1);
+        if (count != 3) return throw_wrong_arguments("ReflectionMethod::export", count, 3, 3, 1);
         return (ti_export(o_getClassName(), a0, a1, a2));
       }
       break;
     case 0x7b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count < 1) return throw_missing_arguments("reflectionmethod::invoke", count+1, 1);
+        if (count < 1) return throw_missing_arguments("ReflectionMethod::invoke", count+1, 1);
         if (count <= 1) return (t_invoke(count, a0));
         Array params;
         if (count >= 2) params.append(a1);
@@ -9791,55 +10017,55 @@ Variant c_reflectionmethod::o_invoke_few_args(MethodIndex methodIndex, const cha
       break;
     case 0x82:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::ispublic", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isPublic", 0, 1);
         return (t_ispublic());
       }
       break;
     case 0x37:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
         return (t_getfilename());
       }
       break;
     case 0x83:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isdestructor", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isDestructor", 0, 1);
         return (t_isdestructor());
       }
       break;
     case 0x5d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstartline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
         return (t_getstartline());
       }
       break;
     case 0x60:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getdoccomment", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
         return (t_getdoccomment());
       }
       break;
     case 0x7c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::getclosure", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getClosure", 0, 1);
         return (t_getclosure());
       }
       break;
     case 0x6b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isabstract", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isAbstract", 0, 1);
         return (t_isabstract());
       }
       break;
     case 0x6c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
         return (t_getname());
       }
       break;
     case 0x6d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isinternal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
         return (t_isinternal());
       }
       break;
@@ -10032,8 +10258,15 @@ Variant c_reflectionmethod::os_invoke(const char *c, MethodIndex methodIndex, co
   switch (methodIndex.m_callIndex) {
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 3) return throw_wrong_arguments("reflectionmethod::export", count, 3, 3, 1);
-        return (ti_export(c, params[0], params[1], params[2]));
+        if (count != 3) return throw_wrong_arguments("ReflectionMethod::export", count, 3, 3, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (ti_export(c, arg0, arg1, arg2));
+        }
       }
       break;
     default:
@@ -10070,7 +10303,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofrequiredparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10084,7 +10317,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isprivate", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isPrivate", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10098,7 +10331,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isuserdefined", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10112,7 +10345,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10126,7 +10359,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10140,7 +10373,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isprotected", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isProtected", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10154,7 +10387,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isstatic", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isStatic", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10168,7 +10401,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::getdeclaringclass", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getDeclaringClass", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10182,7 +10415,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isconstructor", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isConstructor", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10196,7 +10429,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getendline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10210,7 +10443,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstaticvariables", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10226,7 +10459,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("reflectionmethod::__construct", count, 2, 2, 2);
+        if (count != 2) return throw_wrong_arguments("ReflectionMethod::__construct", count, 2, 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -10246,7 +10479,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10260,7 +10493,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isfinal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isFinal", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10276,7 +10509,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("reflectionmethod::invokeargs", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionMethod::invokeArgs", count, 2, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -10296,7 +10529,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::returnsreference", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10310,7 +10543,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::getmodifiers", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getModifiers", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10327,7 +10560,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a2;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 3) return throw_wrong_arguments("reflectionmethod::export", count, 3, 3, 1);
+        if (count != 3) return throw_wrong_arguments("ReflectionMethod::export", count, 3, 3, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -10351,7 +10584,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count < 1) return throw_missing_arguments("reflectionmethod::invoke", count+1, 1);
+        if (count < 1) return throw_missing_arguments("ReflectionMethod::invoke", count+1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -10370,7 +10603,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::ispublic", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isPublic", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10384,7 +10617,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10398,7 +10631,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isdestructor", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isDestructor", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10412,7 +10645,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstartline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10426,7 +10659,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getdoccomment", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10440,7 +10673,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::getclosure", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::getClosure", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10454,7 +10687,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionmethod::isabstract", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionMethod::isAbstract", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10468,7 +10701,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10482,7 +10715,7 @@ Variant c_reflectionmethod::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isinternal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -10935,7 +11168,7 @@ Variant c_reflectionmethod::os_invoke_from_eval(const char *c, const char *s, Ev
         Variant a2;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 3) return throw_wrong_arguments("reflectionmethod::export", count, 3, 3, 1);
+        if (count != 3) return throw_wrong_arguments("ReflectionMethod::export", count, 3, 3, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -11435,92 +11668,116 @@ Variant c_reflectionproperty::o_invoke(MethodIndex methodIndex, const char *s, C
   switch (methodIndex.m_callIndex) {
     case 0x7d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::isprivate", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isPrivate", 0, 1);
         return (t_isprivate());
       }
       break;
     case 0x8c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("reflectionproperty::getvalue", 1, 1);
-        if (count <= 0) return (t_getvalue());
-        return (t_getvalue(params[0]));
+        if (count > 1) return throw_toomany_arguments("ReflectionProperty::getValue", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_getvalue());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getvalue(arg0));
+        }
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x7e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::isprotected", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isProtected", 0, 1);
         return (t_isprotected());
       }
       break;
     case 0x7f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::isstatic", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isStatic", 0, 1);
         return (t_isstatic());
       }
       break;
     case 0x80:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::getdeclaringclass", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getDeclaringClass", 0, 1);
         return (t_getdeclaringclass());
       }
       break;
     case 0x8d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::isdefault", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isDefault", 0, 1);
         return (t_isdefault());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionproperty::__construct", count, 2, 2, 2);
-        return (t___construct(params[0], params[1]), null);
+        if (count != 2) return throw_wrong_arguments("ReflectionProperty::__construct", count, 2, 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0x54:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::getmodifiers", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getModifiers", 0, 1);
         return (t_getmodifiers());
       }
       break;
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 3) return throw_wrong_arguments("reflectionproperty::export", count, 3, 3, 1);
-        return (ti_export(o_getClassName(), params[0], params[1], params[2]));
+        if (count != 3) return throw_wrong_arguments("ReflectionProperty::export", count, 3, 3, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (ti_export(o_getClassName(), arg0, arg1, arg2));
+        }
       }
       break;
     case 0x82:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::ispublic", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isPublic", 0, 1);
         return (t_ispublic());
       }
       break;
     case 0x8e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::setaccessible", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::setAccessible", 0, 1);
         return (t_setaccessible(), null);
       }
       break;
     case 0x60:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::getdoccomment", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getDocComment", 0, 1);
         return (t_getdoccomment());
       }
       break;
     case 0x8f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionproperty::setvalue", count, 2, 2, 1);
-        return (t_setvalue(params[0], params[1]));
+        if (count != 2) return throw_wrong_arguments("ReflectionProperty::setValue", count, 2, 2, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t_setvalue(arg0, arg1));
+        }
       }
       break;
     case 0x6c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getName", 0, 1);
         return (t_getname());
       }
       break;
@@ -11654,92 +11911,92 @@ Variant c_reflectionproperty::o_invoke_few_args(MethodIndex methodIndex, const c
   switch (methodIndex.m_callIndex) {
     case 0x7d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::isprivate", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isPrivate", 0, 1);
         return (t_isprivate());
       }
       break;
     case 0x8c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("reflectionproperty::getvalue", 1, 1);
+        if (count > 1) return throw_toomany_arguments("ReflectionProperty::getValue", 1, 1);
         if (count <= 0) return (t_getvalue());
         return (t_getvalue(a0));
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x7e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::isprotected", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isProtected", 0, 1);
         return (t_isprotected());
       }
       break;
     case 0x7f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::isstatic", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isStatic", 0, 1);
         return (t_isstatic());
       }
       break;
     case 0x80:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::getdeclaringclass", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getDeclaringClass", 0, 1);
         return (t_getdeclaringclass());
       }
       break;
     case 0x8d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::isdefault", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isDefault", 0, 1);
         return (t_isdefault());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionproperty::__construct", count, 2, 2, 2);
+        if (count != 2) return throw_wrong_arguments("ReflectionProperty::__construct", count, 2, 2, 2);
         return (t___construct(a0, a1), null);
       }
       break;
     case 0x54:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::getmodifiers", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getModifiers", 0, 1);
         return (t_getmodifiers());
       }
       break;
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 3) return throw_wrong_arguments("reflectionproperty::export", count, 3, 3, 1);
+        if (count != 3) return throw_wrong_arguments("ReflectionProperty::export", count, 3, 3, 1);
         return (ti_export(o_getClassName(), a0, a1, a2));
       }
       break;
     case 0x82:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::ispublic", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isPublic", 0, 1);
         return (t_ispublic());
       }
       break;
     case 0x8e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::setaccessible", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::setAccessible", 0, 1);
         return (t_setaccessible(), null);
       }
       break;
     case 0x60:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::getdoccomment", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getDocComment", 0, 1);
         return (t_getdoccomment());
       }
       break;
     case 0x8f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionproperty::setvalue", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionProperty::setValue", count, 2, 2, 1);
         return (t_setvalue(a0, a1));
       }
       break;
     case 0x6c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getName", 0, 1);
         return (t_getname());
       }
       break;
@@ -11850,8 +12107,15 @@ Variant c_reflectionproperty::os_invoke(const char *c, MethodIndex methodIndex,
   switch (methodIndex.m_callIndex) {
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 3) return throw_wrong_arguments("reflectionproperty::export", count, 3, 3, 1);
-        return (ti_export(c, params[0], params[1], params[2]));
+        if (count != 3) return throw_wrong_arguments("ReflectionProperty::export", count, 3, 3, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (ti_export(c, arg0, arg1, arg2));
+        }
       }
       break;
     default:
@@ -11888,7 +12152,7 @@ Variant c_reflectionproperty::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::isprivate", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isPrivate", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -11903,7 +12167,7 @@ Variant c_reflectionproperty::o_invoke_from_eval(const char *s, Eval::VariableEn
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("reflectionproperty::getvalue", 1, 1);
+        if (count > 1) return throw_toomany_arguments("ReflectionProperty::getValue", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -11921,7 +12185,7 @@ Variant c_reflectionproperty::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -11935,7 +12199,7 @@ Variant c_reflectionproperty::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::isprotected", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isProtected", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -11949,7 +12213,7 @@ Variant c_reflectionproperty::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::isstatic", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isStatic", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -11963,7 +12227,7 @@ Variant c_reflectionproperty::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::getdeclaringclass", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getDeclaringClass", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -11977,7 +12241,7 @@ Variant c_reflectionproperty::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::isdefault", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isDefault", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -11993,7 +12257,7 @@ Variant c_reflectionproperty::o_invoke_from_eval(const char *s, Eval::VariableEn
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("reflectionproperty::__construct", count, 2, 2, 2);
+        if (count != 2) return throw_wrong_arguments("ReflectionProperty::__construct", count, 2, 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -12013,7 +12277,7 @@ Variant c_reflectionproperty::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::getmodifiers", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getModifiers", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -12030,7 +12294,7 @@ Variant c_reflectionproperty::o_invoke_from_eval(const char *s, Eval::VariableEn
         Variant a2;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 3) return throw_wrong_arguments("reflectionproperty::export", count, 3, 3, 1);
+        if (count != 3) return throw_wrong_arguments("ReflectionProperty::export", count, 3, 3, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -12053,7 +12317,7 @@ Variant c_reflectionproperty::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::ispublic", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::isPublic", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -12067,7 +12331,7 @@ Variant c_reflectionproperty::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::setaccessible", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::setAccessible", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -12081,7 +12345,7 @@ Variant c_reflectionproperty::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::getdoccomment", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getDocComment", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -12097,7 +12361,7 @@ Variant c_reflectionproperty::o_invoke_from_eval(const char *s, Eval::VariableEn
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("reflectionproperty::setvalue", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionProperty::setValue", count, 2, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -12117,7 +12381,7 @@ Variant c_reflectionproperty::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionproperty::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionProperty::getName", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -12389,7 +12653,7 @@ Variant c_reflectionproperty::os_invoke_from_eval(const char *c, const char *s,
         Variant a2;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 3) return throw_wrong_arguments("reflectionproperty::export", count, 3, 3, 1);
+        if (count != 3) return throw_wrong_arguments("ReflectionProperty::export", count, 3, 3, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -12792,68 +13056,84 @@ Variant c_reflectionfunction::o_invoke(MethodIndex methodIndex, const char *s, C
   switch (methodIndex.m_callIndex) {
     case 0x75:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofrequiredparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
         return (t_getnumberofrequiredparameters());
       }
       break;
     case 0x4b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isuserdefined", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
         return (t_isuserdefined());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunction::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunction::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x76:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
         return (t_getnumberofparameters());
       }
       break;
     case 0x50:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getendline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
         return (t_getendline());
       }
       break;
     case 0x77:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstaticvariables", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
         return (t_getstaticvariables());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionfunction::__construct", count, 1, 1, 2);
-        return (t___construct(params[0]), null);
+        if (count != 1) return throw_wrong_arguments("ReflectionFunction::__construct", count, 1, 1, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t___construct(arg0), null);
+        }
       }
       break;
     case 0x78:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
         return (t_getparameters());
       }
       break;
     case 0x79:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionfunction::invokeargs", count, 1, 1, 1);
-        return (t_invokeargs(params[0]));
+        if (count != 1) return throw_wrong_arguments("ReflectionFunction::invokeArgs", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_invokeargs(arg0));
+        }
       }
       break;
     case 0x7a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::returnsreference", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
         return (t_returnsreference());
       }
       break;
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionfunction::export", count, 2, 2, 1);
-        return (ti_export(o_getClassName(), params[0], params[1]));
+        if (count != 2) return throw_wrong_arguments("ReflectionFunction::export", count, 2, 2, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (ti_export(o_getClassName(), arg0, arg1));
+        }
       }
       break;
     case 0x7b:
@@ -12864,37 +13144,37 @@ Variant c_reflectionfunction::o_invoke(MethodIndex methodIndex, const char *s, C
       break;
     case 0x37:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
         return (t_getfilename());
       }
       break;
     case 0x5d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstartline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
         return (t_getstartline());
       }
       break;
     case 0x60:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getdoccomment", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
         return (t_getdoccomment());
       }
       break;
     case 0x7c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getclosure", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getClosure", 0, 1);
         return (t_getclosure());
       }
       break;
     case 0x6c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
         return (t_getname());
       }
       break;
     case 0x6d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isinternal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
         return (t_isinternal());
       }
       break;
@@ -13035,67 +13315,67 @@ Variant c_reflectionfunction::o_invoke_few_args(MethodIndex methodIndex, const c
   switch (methodIndex.m_callIndex) {
     case 0x75:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofrequiredparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
         return (t_getnumberofrequiredparameters());
       }
       break;
     case 0x4b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isuserdefined", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
         return (t_isuserdefined());
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunction::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunction::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x76:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
         return (t_getnumberofparameters());
       }
       break;
     case 0x50:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getendline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
         return (t_getendline());
       }
       break;
     case 0x77:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstaticvariables", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
         return (t_getstaticvariables());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionfunction::__construct", count, 1, 1, 2);
+        if (count != 1) return throw_wrong_arguments("ReflectionFunction::__construct", count, 1, 1, 2);
         return (t___construct(a0), null);
       }
       break;
     case 0x78:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
         return (t_getparameters());
       }
       break;
     case 0x79:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("reflectionfunction::invokeargs", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionFunction::invokeArgs", count, 1, 1, 1);
         return (t_invokeargs(a0));
       }
       break;
     case 0x7a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::returnsreference", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
         return (t_returnsreference());
       }
       break;
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionfunction::export", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionFunction::export", count, 2, 2, 1);
         return (ti_export(o_getClassName(), a0, a1));
       }
       break;
@@ -13114,37 +13394,37 @@ Variant c_reflectionfunction::o_invoke_few_args(MethodIndex methodIndex, const c
       break;
     case 0x37:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
         return (t_getfilename());
       }
       break;
     case 0x5d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstartline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
         return (t_getstartline());
       }
       break;
     case 0x60:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getdoccomment", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
         return (t_getdoccomment());
       }
       break;
     case 0x7c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getclosure", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getClosure", 0, 1);
         return (t_getclosure());
       }
       break;
     case 0x6c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
         return (t_getname());
       }
       break;
     case 0x6d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isinternal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
         return (t_isinternal());
       }
       break;
@@ -13277,8 +13557,14 @@ Variant c_reflectionfunction::os_invoke(const char *c, MethodIndex methodIndex,
   switch (methodIndex.m_callIndex) {
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionfunction::export", count, 2, 2, 1);
-        return (ti_export(c, params[0], params[1]));
+        if (count != 2) return throw_wrong_arguments("ReflectionFunction::export", count, 2, 2, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (ti_export(c, arg0, arg1));
+        }
       }
       break;
     default:
@@ -13314,7 +13600,7 @@ Variant c_reflectionfunction::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofrequiredparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfRequiredParameters", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -13328,7 +13614,7 @@ Variant c_reflectionfunction::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isuserdefined", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isUserDefined", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -13342,7 +13628,7 @@ Variant c_reflectionfunction::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunction::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunction::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -13356,7 +13642,7 @@ Variant c_reflectionfunction::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getnumberofparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getNumberOfParameters", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -13370,7 +13656,7 @@ Variant c_reflectionfunction::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getendline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getEndLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -13384,7 +13670,7 @@ Variant c_reflectionfunction::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstaticvariables", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStaticVariables", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -13399,7 +13685,7 @@ Variant c_reflectionfunction::o_invoke_from_eval(const char *s, Eval::VariableEn
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionfunction::__construct", count, 1, 1, 2);
+        if (count != 1) return throw_wrong_arguments("ReflectionFunction::__construct", count, 1, 1, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -13416,7 +13702,7 @@ Variant c_reflectionfunction::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getparameters", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getParameters", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -13431,7 +13717,7 @@ Variant c_reflectionfunction::o_invoke_from_eval(const char *s, Eval::VariableEn
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("reflectionfunction::invokeargs", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("ReflectionFunction::invokeArgs", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -13448,7 +13734,7 @@ Variant c_reflectionfunction::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::returnsreference", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::returnsReference", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -13464,7 +13750,7 @@ Variant c_reflectionfunction::o_invoke_from_eval(const char *s, Eval::VariableEn
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("reflectionfunction::export", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionFunction::export", count, 2, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -13499,7 +13785,7 @@ Variant c_reflectionfunction::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getFileName", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -13513,7 +13799,7 @@ Variant c_reflectionfunction::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getstartline", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getStartLine", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -13527,7 +13813,7 @@ Variant c_reflectionfunction::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getdoccomment", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getDocComment", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -13541,7 +13827,7 @@ Variant c_reflectionfunction::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getclosure", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getClosure", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -13555,7 +13841,7 @@ Variant c_reflectionfunction::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::getName", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -13569,7 +13855,7 @@ Variant c_reflectionfunction::o_invoke_from_eval(const char *s, Eval::VariableEn
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionfunctionabstract::isinternal", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionFunctionAbstract::isInternal", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -13864,7 +14150,7 @@ Variant c_reflectionfunction::os_invoke_from_eval(const char *c, const char *s,
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("reflectionfunction::export", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("ReflectionFunction::export", count, 2, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -14197,79 +14483,92 @@ Variant c_reflectionparameter::o_invoke(MethodIndex methodIndex, const char *s,
   switch (methodIndex.m_callIndex) {
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x80:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::getdeclaringclass", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getDeclaringClass", 0, 1);
         return (t_getdeclaringclass());
       }
       break;
     case 0x84:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::isdefaultvalueavailable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isDefaultValueAvailable", 0, 1);
         return (t_isdefaultvalueavailable());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionparameter::__construct", count, 2, 2, 2);
-        return (t___construct(params[0], params[1]), null);
+        if (count != 2) return throw_wrong_arguments("ReflectionParameter::__construct", count, 2, 2, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1), null);
+        }
       }
       break;
     case 0x85:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::getclass", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getClass", 0, 1);
         return (t_getclass());
       }
       break;
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 3) return throw_wrong_arguments("reflectionparameter::export", count, 3, 3, 1);
-        return (ti_export(o_getClassName(), params[0], params[1], params[2]));
+        if (count != 3) return throw_wrong_arguments("ReflectionParameter::export", count, 3, 3, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (ti_export(o_getClassName(), arg0, arg1, arg2));
+        }
       }
       break;
     case 0x86:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::allowsnull", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::allowsNull", 0, 1);
         return (t_allowsnull());
       }
       break;
     case 0x87:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::getposition", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getPosition", 0, 1);
         return (t_getposition());
       }
       break;
     case 0x88:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::isarray", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isArray", 0, 1);
         return (t_isarray());
       }
       break;
     case 0x89:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::isoptional", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isOptional", 0, 1);
         return (t_isoptional());
       }
       break;
     case 0x8a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::getdefaultvalue", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getDefaultValue", 0, 1);
         return (t_getdefaultvalue());
       }
       break;
     case 0x6c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getName", 0, 1);
         return (t_getname());
       }
       break;
     case 0x8b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::ispassedbyreference", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isPassedByReference", 0, 1);
         return (t_ispassedbyreference());
       }
       break;
@@ -14379,79 +14678,79 @@ Variant c_reflectionparameter::o_invoke_few_args(MethodIndex methodIndex, const
   switch (methodIndex.m_callIndex) {
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x80:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::getdeclaringclass", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getDeclaringClass", 0, 1);
         return (t_getdeclaringclass());
       }
       break;
     case 0x84:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::isdefaultvalueavailable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isDefaultValueAvailable", 0, 1);
         return (t_isdefaultvalueavailable());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("reflectionparameter::__construct", count, 2, 2, 2);
+        if (count != 2) return throw_wrong_arguments("ReflectionParameter::__construct", count, 2, 2, 2);
         return (t___construct(a0, a1), null);
       }
       break;
     case 0x85:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::getclass", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getClass", 0, 1);
         return (t_getclass());
       }
       break;
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 3) return throw_wrong_arguments("reflectionparameter::export", count, 3, 3, 1);
+        if (count != 3) return throw_wrong_arguments("ReflectionParameter::export", count, 3, 3, 1);
         return (ti_export(o_getClassName(), a0, a1, a2));
       }
       break;
     case 0x86:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::allowsnull", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::allowsNull", 0, 1);
         return (t_allowsnull());
       }
       break;
     case 0x87:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::getposition", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getPosition", 0, 1);
         return (t_getposition());
       }
       break;
     case 0x88:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::isarray", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isArray", 0, 1);
         return (t_isarray());
       }
       break;
     case 0x89:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::isoptional", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isOptional", 0, 1);
         return (t_isoptional());
       }
       break;
     case 0x8a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::getdefaultvalue", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getDefaultValue", 0, 1);
         return (t_getdefaultvalue());
       }
       break;
     case 0x6c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getName", 0, 1);
         return (t_getname());
       }
       break;
     case 0x8b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::ispassedbyreference", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isPassedByReference", 0, 1);
         return (t_ispassedbyreference());
       }
       break;
@@ -14549,8 +14848,15 @@ Variant c_reflectionparameter::os_invoke(const char *c, MethodIndex methodIndex,
   switch (methodIndex.m_callIndex) {
     case 0x55:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 3) return throw_wrong_arguments("reflectionparameter::export", count, 3, 3, 1);
-        return (ti_export(c, params[0], params[1], params[2]));
+        if (count != 3) return throw_wrong_arguments("ReflectionParameter::export", count, 3, 3, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (ti_export(c, arg0, arg1, arg2));
+        }
       }
       break;
     default:
@@ -14587,7 +14893,7 @@ Variant c_reflectionparameter::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -14601,7 +14907,7 @@ Variant c_reflectionparameter::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::getdeclaringclass", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getDeclaringClass", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -14615,7 +14921,7 @@ Variant c_reflectionparameter::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::isdefaultvalueavailable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isDefaultValueAvailable", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -14631,7 +14937,7 @@ Variant c_reflectionparameter::o_invoke_from_eval(const char *s, Eval::VariableE
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("reflectionparameter::__construct", count, 2, 2, 2);
+        if (count != 2) return throw_wrong_arguments("ReflectionParameter::__construct", count, 2, 2, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -14651,7 +14957,7 @@ Variant c_reflectionparameter::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::getclass", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getClass", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -14668,7 +14974,7 @@ Variant c_reflectionparameter::o_invoke_from_eval(const char *s, Eval::VariableE
         Variant a2;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 3) return throw_wrong_arguments("reflectionparameter::export", count, 3, 3, 1);
+        if (count != 3) return throw_wrong_arguments("ReflectionParameter::export", count, 3, 3, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -14691,7 +14997,7 @@ Variant c_reflectionparameter::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::allowsnull", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::allowsNull", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -14705,7 +15011,7 @@ Variant c_reflectionparameter::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::getposition", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getPosition", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -14719,7 +15025,7 @@ Variant c_reflectionparameter::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::isarray", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isArray", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -14733,7 +15039,7 @@ Variant c_reflectionparameter::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::isoptional", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isOptional", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -14747,7 +15053,7 @@ Variant c_reflectionparameter::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::getdefaultvalue", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getDefaultValue", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -14761,7 +15067,7 @@ Variant c_reflectionparameter::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::getname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::getName", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -14775,7 +15081,7 @@ Variant c_reflectionparameter::o_invoke_from_eval(const char *s, Eval::VariableE
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("reflectionparameter::ispassedbyreference", 0, 1);
+        if (count > 0) return throw_toomany_arguments("ReflectionParameter::isPassedByReference", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -15006,7 +15312,7 @@ Variant c_reflectionparameter::os_invoke_from_eval(const char *c, const char *s,
         Variant a2;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 3) return throw_wrong_arguments("reflectionparameter::export", count, 3, 3, 1);
+        if (count != 3) return throw_wrong_arguments("ReflectionParameter::export", count, 3, 3, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
diff --git a/src/system/gen/php/classes/splfile.cpp b/src/system/gen/php/classes/splfile.cpp
index 7801845e33..d905c42471 100644
--- a/src/system/gen/php/classes/splfile.cpp
+++ b/src/system/gen/php/classes/splfile.cpp
@@ -248,354 +248,457 @@ Variant c_splfileobject::o_invoke(MethodIndex methodIndex, const char *s, CArrRe
   switch (methodIndex.m_callIndex) {
     case 0x27:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getperms", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
         return (t_getperms());
       }
       break;
     case 0x28:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::iswritable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
         return (t_iswritable());
       }
       break;
     case 0x92:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splfileobject::fscanf", count, 1, 1, 1);
-        return (t_fscanf(params[0]));
+        if (count != 1) return throw_wrong_arguments("SplFileObject::fscanf", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_fscanf(arg0));
+        }
       }
       break;
     case 0x29:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getbasename", 1, 1);
-        if (count <= 0) return (t_getbasename());
-        return (t_getbasename(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_getbasename());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getbasename(arg0));
+        }
       }
       break;
     case 0x2a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpathname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
         return (t_getpathname());
       }
       break;
     case 0x1:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::next", 0, 1);
         return (t_next());
       }
       break;
     case 0x93:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("splfileobject::fseek", count, 2, 2, 1);
-        return (t_fseek(params[0], params[1]));
+        if (count != 2) return throw_wrong_arguments("SplFileObject::fseek", count, 2, 2, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t_fseek(arg0, arg1));
+        }
       }
       break;
     case 0x2b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getgroup", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
         return (t_getgroup());
       }
       break;
     case 0x2:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::key", 0, 1);
         return (t_key());
       }
       break;
     case 0x94:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splfileobject::fgetss", count, 1, 1, 1);
-        return (t_fgetss(params[0]));
+        if (count != 1) return throw_wrong_arguments("SplFileObject::fgetss", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_fgetss(arg0));
+        }
       }
       break;
     case 0x2c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setfileclass", 1, 1);
-        if (count <= 0) return (t_setfileclass());
-        return (t_setfileclass(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_setfileclass());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_setfileclass(arg0));
+        }
       }
       break;
     case 0x95:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 3) return throw_toomany_arguments("splfileobject::fgetcsv", 3, 1);
-        if (count <= 0) return (t_fgetcsv());
-        if (count == 1) return (t_fgetcsv(params[0]));
-        if (count == 2) return (t_fgetcsv(params[0], params[1]));
-        return (t_fgetcsv(params[0], params[1], params[2]));
+        if (count > 3) return throw_toomany_arguments("SplFileObject::fgetcsv", 3, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_fgetcsv());
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t_fgetcsv(arg0));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          if (count == 2) return (t_fgetcsv(arg0, arg1));
+          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t_fgetcsv(arg0, arg1, arg2));
+        }
       }
       break;
     case 0x2d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setinfoclass", 1, 1);
-        if (count <= 0) return (t_setinfoclass());
-        return (t_setinfoclass(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_setinfoclass());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_setinfoclass(arg0));
+        }
       }
       break;
     case 0x3:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::valid", 0, 1);
         return (t_valid());
       }
       break;
     case 0x96:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 3) return throw_toomany_arguments("splfileobject::setcsvcontrol", 3, 1);
-        if (count <= 0) return (t_setcsvcontrol());
-        if (count == 1) return (t_setcsvcontrol(params[0]));
-        if (count == 2) return (t_setcsvcontrol(params[0], params[1]));
-        return (t_setcsvcontrol(params[0], params[1], params[2]));
+        if (count > 3) return throw_toomany_arguments("SplFileObject::setCsvControl", 3, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_setcsvcontrol());
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t_setcsvcontrol(arg0));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          if (count == 2) return (t_setcsvcontrol(arg0, arg1));
+          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t_setcsvcontrol(arg0, arg1, arg2));
+        }
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x2e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getlinktarget", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
         return (t_getlinktarget());
       }
       break;
     case 0x97:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::getcsvcontrol", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::getCsvControl", 0, 1);
         return (t_getcsvcontrol());
       }
       break;
     case 0x2f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isreadable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
         return (t_isreadable());
       }
       break;
     case 0x30:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getrealpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
         return (t_getrealpath());
       }
       break;
     case 0x11:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splfileobject::setflags", count, 1, 1, 1);
-        return (t_setflags(params[0]));
+        if (count != 1) return throw_wrong_arguments("SplFileObject::setFlags", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_setflags(arg0));
+        }
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count < 1 || count > 4) return throw_wrong_arguments("splfileobject::__construct", count, 1, 4, 2);
-        if (count <= 1) return (t___construct(params[0]), null);
-        if (count == 2) return (t___construct(params[0], params[1]), null);
-        if (count == 3) return (t___construct(params[0], params[1], params[2]), null);
-        return (t___construct(params[0], params[1], params[2], params[3]), null);
+        if (count < 1 || count > 4) return throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          if (count <= 1) return (t___construct(arg0), null);
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          if (count == 2) return (t___construct(arg0, arg1), null);
+          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
+          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t___construct(arg0, arg1, arg2, arg3), null);
+        }
       }
       break;
     case 0x31:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getpathinfo", 1, 1);
-        if (count <= 0) return (t_getpathinfo());
-        return (t_getpathinfo(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_getpathinfo());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getpathinfo(arg0));
+        }
       }
       break;
     case 0x98:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splfileobject::setmaxlinelen", count, 1, 1, 1);
-        return (t_setmaxlinelen(params[0]));
+        if (count != 1) return throw_wrong_arguments("SplFileObject::setMaxLineLen", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_setmaxlinelen(arg0));
+        }
       }
       break;
     case 0x99:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::getmaxlinelen", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::getMaxLineLen", 0, 1);
         return (t_getmaxlinelen());
       }
       break;
     case 0x32:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getctime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
         return (t_getctime());
       }
       break;
     case 0x33:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
         return (t_getpath());
       }
       break;
     case 0x9a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splfileobject::ftruncate", count, 1, 1, 1);
-        return (t_ftruncate(params[0]));
+        if (count != 1) return throw_wrong_arguments("SplFileObject::ftruncate", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_ftruncate(arg0));
+        }
       }
       break;
     case 0x34:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getinode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
         return (t_getinode());
       }
       break;
     case 0x9c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::fflush", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::fflush", 0, 1);
         return (t_fflush());
       }
       break;
     case 0x9b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::eof", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::eof", 0, 1);
         return (t_eof());
       }
       break;
     case 0x35:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::islink", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
         return (t_islink());
       }
       break;
     case 0x36:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getsize", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
         return (t_getsize());
       }
       break;
     case 0x38:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
         return (t_isfile());
       }
       break;
     case 0x37:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
         return (t_getfilename());
       }
       break;
     case 0x9d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::fgetc", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::fgetc", 0, 1);
         return (t_fgetc());
       }
       break;
     case 0x9e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::fpassthru", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::fpassthru", 0, 1);
         return (t_fpassthru());
       }
       break;
     case 0x39:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getowner", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
         return (t_getowner());
       }
       break;
     case 0x46:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::haschildren", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::hasChildren", 0, 1);
         return (t_haschildren());
       }
       break;
     case 0x9f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::fgets", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::fgets", 0, 1);
         return (t_fgets());
       }
       break;
     case 0x15:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splfileobject::seek", count, 1, 1, 1);
-        return (t_seek(params[0]));
+        if (count != 1) return throw_wrong_arguments("SplFileObject::seek", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_seek(arg0));
+        }
       }
       break;
     case 0xa0:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("splfileobject::flock", count, 2, 2, 1);
-        return (t_flock(params[0], ref(const_cast<Array&>(params).lvalAt(1))));
+        if (count != 2) return throw_wrong_arguments("SplFileObject::flock", count, 2, 2, 1);
+        const_cast<Array&>(params).escalate(true);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
+          return (t_flock(arg0, ref(arg1)));
+        }
       }
       break;
     case 0x3a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getmtime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
         return (t_getmtime());
       }
       break;
     case 0x3b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isdir", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
         return (t_isdir());
       }
       break;
     case 0x16:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::getflags", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::getFlags", 0, 1);
         return (t_getflags());
       }
       break;
     case 0x3c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getfileinfo", 1, 1);
-        if (count <= 0) return (t_getfileinfo());
-        return (t_getfileinfo(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_getfileinfo());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getfileinfo(arg0));
+        }
       }
       break;
     case 0x47:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::getchildren", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::getChildren", 0, 1);
         return (t_getchildren());
       }
       break;
     case 0x7:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::current", 0, 1);
         return (t_current());
       }
       break;
     case 0xa2:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("splfileobject::fwrite", count, 2, 2, 1);
-        return (t_fwrite(params[0], params[1]));
+        if (count != 2) return throw_wrong_arguments("SplFileObject::fwrite", count, 2, 2, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t_fwrite(arg0, arg1));
+        }
       }
       break;
     case 0xa1:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::ftell", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::ftell", 0, 1);
         return (t_ftell());
       }
       break;
     case 0x3e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isexecutable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
         return (t_isexecutable());
       }
       break;
     case 0x3d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getatime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
         return (t_getatime());
       }
       break;
     case 0x3f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 3) return throw_toomany_arguments("splfileinfo::openfile", 3, 1);
-        if (count <= 0) return (t_openfile());
-        if (count == 1) return (t_openfile(params[0]));
-        if (count == 2) return (t_openfile(params[0], params[1]));
-        return (t_openfile(params[0], params[1], params[2]));
+        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_openfile());
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t_openfile(arg0));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          if (count == 2) return (t_openfile(arg0, arg1));
+          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t_openfile(arg0, arg1, arg2));
+        }
       }
       break;
     case 0xa3:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::fstat", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::fstat", 0, 1);
         return (t_fstat());
       }
       break;
     case 0x9:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::rewind", 0, 1);
         return (t_rewind());
       }
       break;
     case 0x41:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::gettype", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
         return (t_gettype());
       }
       break;
@@ -1058,75 +1161,75 @@ Variant c_splfileobject::o_invoke_few_args(MethodIndex methodIndex, const char *
   switch (methodIndex.m_callIndex) {
     case 0x27:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getperms", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
         return (t_getperms());
       }
       break;
     case 0x28:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::iswritable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
         return (t_iswritable());
       }
       break;
     case 0x92:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splfileobject::fscanf", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("SplFileObject::fscanf", count, 1, 1, 1);
         return (t_fscanf(a0));
       }
       break;
     case 0x29:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getbasename", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
         if (count <= 0) return (t_getbasename());
         return (t_getbasename(a0));
       }
       break;
     case 0x2a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpathname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
         return (t_getpathname());
       }
       break;
     case 0x1:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::next", 0, 1);
         return (t_next());
       }
       break;
     case 0x93:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("splfileobject::fseek", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("SplFileObject::fseek", count, 2, 2, 1);
         return (t_fseek(a0, a1));
       }
       break;
     case 0x2b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getgroup", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
         return (t_getgroup());
       }
       break;
     case 0x2:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::key", 0, 1);
         return (t_key());
       }
       break;
     case 0x94:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splfileobject::fgetss", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("SplFileObject::fgetss", count, 1, 1, 1);
         return (t_fgetss(a0));
       }
       break;
     case 0x2c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setfileclass", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
         if (count <= 0) return (t_setfileclass());
         return (t_setfileclass(a0));
       }
       break;
     case 0x95:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 3) return throw_toomany_arguments("splfileobject::fgetcsv", 3, 1);
+        if (count > 3) return throw_toomany_arguments("SplFileObject::fgetcsv", 3, 1);
         if (count <= 0) return (t_fgetcsv());
         if (count == 1) return (t_fgetcsv(a0));
         if (count == 2) return (t_fgetcsv(a0, a1));
@@ -1135,20 +1238,20 @@ Variant c_splfileobject::o_invoke_few_args(MethodIndex methodIndex, const char *
       break;
     case 0x2d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setinfoclass", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
         if (count <= 0) return (t_setinfoclass());
         return (t_setinfoclass(a0));
       }
       break;
     case 0x3:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::valid", 0, 1);
         return (t_valid());
       }
       break;
     case 0x96:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 3) return throw_toomany_arguments("splfileobject::setcsvcontrol", 3, 1);
+        if (count > 3) return throw_toomany_arguments("SplFileObject::setCsvControl", 3, 1);
         if (count <= 0) return (t_setcsvcontrol());
         if (count == 1) return (t_setcsvcontrol(a0));
         if (count == 2) return (t_setcsvcontrol(a0, a1));
@@ -1157,43 +1260,43 @@ Variant c_splfileobject::o_invoke_few_args(MethodIndex methodIndex, const char *
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x2e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getlinktarget", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
         return (t_getlinktarget());
       }
       break;
     case 0x97:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::getcsvcontrol", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::getCsvControl", 0, 1);
         return (t_getcsvcontrol());
       }
       break;
     case 0x2f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isreadable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
         return (t_isreadable());
       }
       break;
     case 0x30:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getrealpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
         return (t_getrealpath());
       }
       break;
     case 0x11:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splfileobject::setflags", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("SplFileObject::setFlags", count, 1, 1, 1);
         return (t_setflags(a0));
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count < 1 || count > 4) return throw_wrong_arguments("splfileobject::__construct", count, 1, 4, 2);
+        if (count < 1 || count > 4) return throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
         if (count <= 1) return (t___construct(a0), null);
         if (count == 2) return (t___construct(a0, a1), null);
         if (count == 3) return (t___construct(a0, a1, a2), null);
@@ -1202,189 +1305,189 @@ Variant c_splfileobject::o_invoke_few_args(MethodIndex methodIndex, const char *
       break;
     case 0x31:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getpathinfo", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
         if (count <= 0) return (t_getpathinfo());
         return (t_getpathinfo(a0));
       }
       break;
     case 0x98:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splfileobject::setmaxlinelen", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("SplFileObject::setMaxLineLen", count, 1, 1, 1);
         return (t_setmaxlinelen(a0));
       }
       break;
     case 0x99:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::getmaxlinelen", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::getMaxLineLen", 0, 1);
         return (t_getmaxlinelen());
       }
       break;
     case 0x32:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getctime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
         return (t_getctime());
       }
       break;
     case 0x33:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
         return (t_getpath());
       }
       break;
     case 0x9a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splfileobject::ftruncate", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("SplFileObject::ftruncate", count, 1, 1, 1);
         return (t_ftruncate(a0));
       }
       break;
     case 0x34:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getinode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
         return (t_getinode());
       }
       break;
     case 0x9c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::fflush", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::fflush", 0, 1);
         return (t_fflush());
       }
       break;
     case 0x9b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::eof", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::eof", 0, 1);
         return (t_eof());
       }
       break;
     case 0x35:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::islink", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
         return (t_islink());
       }
       break;
     case 0x36:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getsize", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
         return (t_getsize());
       }
       break;
     case 0x38:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
         return (t_isfile());
       }
       break;
     case 0x37:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
         return (t_getfilename());
       }
       break;
     case 0x9d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::fgetc", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::fgetc", 0, 1);
         return (t_fgetc());
       }
       break;
     case 0x9e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::fpassthru", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::fpassthru", 0, 1);
         return (t_fpassthru());
       }
       break;
     case 0x39:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getowner", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
         return (t_getowner());
       }
       break;
     case 0x46:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::haschildren", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::hasChildren", 0, 1);
         return (t_haschildren());
       }
       break;
     case 0x9f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::fgets", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::fgets", 0, 1);
         return (t_fgets());
       }
       break;
     case 0x15:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splfileobject::seek", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("SplFileObject::seek", count, 1, 1, 1);
         return (t_seek(a0));
       }
       break;
     case 0xa0:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("splfileobject::flock", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("SplFileObject::flock", count, 2, 2, 1);
         return (t_flock(a0, ref(a1)));
       }
       break;
     case 0x3a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getmtime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
         return (t_getmtime());
       }
       break;
     case 0x3b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isdir", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
         return (t_isdir());
       }
       break;
     case 0x16:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::getflags", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::getFlags", 0, 1);
         return (t_getflags());
       }
       break;
     case 0x3c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getfileinfo", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
         if (count <= 0) return (t_getfileinfo());
         return (t_getfileinfo(a0));
       }
       break;
     case 0x47:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::getchildren", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::getChildren", 0, 1);
         return (t_getchildren());
       }
       break;
     case 0x7:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::current", 0, 1);
         return (t_current());
       }
       break;
     case 0xa2:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 2) return throw_wrong_arguments("splfileobject::fwrite", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("SplFileObject::fwrite", count, 2, 2, 1);
         return (t_fwrite(a0, a1));
       }
       break;
     case 0xa1:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::ftell", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::ftell", 0, 1);
         return (t_ftell());
       }
       break;
     case 0x3e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isexecutable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
         return (t_isexecutable());
       }
       break;
     case 0x3d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getatime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
         return (t_getatime());
       }
       break;
     case 0x3f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 3) return throw_toomany_arguments("splfileinfo::openfile", 3, 1);
+        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
         if (count <= 0) return (t_openfile());
         if (count == 1) return (t_openfile(a0));
         if (count == 2) return (t_openfile(a0, a1));
@@ -1393,19 +1496,19 @@ Variant c_splfileobject::o_invoke_few_args(MethodIndex methodIndex, const char *
       break;
     case 0xa3:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::fstat", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::fstat", 0, 1);
         return (t_fstat());
       }
       break;
     case 0x9:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileobject::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::rewind", 0, 1);
         return (t_rewind());
       }
       break;
     case 0x41:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::gettype", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
         return (t_gettype());
       }
       break;
@@ -1776,7 +1879,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getperms", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1790,7 +1893,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::iswritable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1805,7 +1908,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("splfileobject::fscanf", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("SplFileObject::fscanf", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -1823,7 +1926,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getbasename", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -1841,7 +1944,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpathname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1855,7 +1958,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileobject::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::next", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1871,7 +1974,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("splfileobject::fseek", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("SplFileObject::fseek", count, 2, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -1891,7 +1994,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getgroup", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1905,7 +2008,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileobject::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::key", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -1920,7 +2023,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("splfileobject::fgetss", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("SplFileObject::fgetss", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -1938,7 +2041,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setfileclass", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -1959,7 +2062,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a2;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 3) return throw_toomany_arguments("splfileobject::fgetcsv", 3, 1);
+        if (count > 3) return throw_toomany_arguments("SplFileObject::fgetcsv", 3, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -1986,7 +2089,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setinfoclass", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2004,7 +2107,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileobject::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::valid", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2021,7 +2124,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a2;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 3) return throw_toomany_arguments("splfileobject::setcsvcontrol", 3, 1);
+        if (count > 3) return throw_toomany_arguments("SplFileObject::setCsvControl", 3, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2047,7 +2150,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2061,7 +2164,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getlinktarget", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2075,7 +2178,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileobject::getcsvcontrol", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::getCsvControl", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2089,7 +2192,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isreadable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2103,7 +2206,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getrealpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2118,7 +2221,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("splfileobject::setflags", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("SplFileObject::setFlags", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2139,7 +2242,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a3;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count < 1 || count > 4) return throw_wrong_arguments("splfileobject::__construct", count, 1, 4, 2);
+        if (count < 1 || count > 4) return throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2169,7 +2272,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getpathinfo", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2188,7 +2291,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("splfileobject::setmaxlinelen", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("SplFileObject::setMaxLineLen", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2205,7 +2308,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileobject::getmaxlinelen", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::getMaxLineLen", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2219,7 +2322,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getctime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2233,7 +2336,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2248,7 +2351,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("splfileobject::ftruncate", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("SplFileObject::ftruncate", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2265,7 +2368,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getinode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2279,7 +2382,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileobject::fflush", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::fflush", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2293,7 +2396,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileobject::eof", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::eof", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2307,7 +2410,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::islink", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2321,7 +2424,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getsize", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2335,7 +2438,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2349,7 +2452,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2363,7 +2466,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileobject::fgetc", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::fgetc", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2377,7 +2480,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileobject::fpassthru", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::fpassthru", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2391,7 +2494,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getowner", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2405,7 +2508,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileobject::haschildren", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::hasChildren", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2419,7 +2522,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileobject::fgets", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::fgets", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2434,7 +2537,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("splfileobject::seek", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("SplFileObject::seek", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2453,7 +2556,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("splfileobject::flock", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("SplFileObject::flock", count, 2, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2473,7 +2576,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getmtime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2487,7 +2590,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isdir", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2501,7 +2604,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileobject::getflags", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::getFlags", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2516,7 +2619,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getfileinfo", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2534,7 +2637,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileobject::getchildren", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::getChildren", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2548,7 +2651,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileobject::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::current", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2564,7 +2667,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a1;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 2) return throw_wrong_arguments("splfileobject::fwrite", count, 2, 2, 1);
+        if (count != 2) return throw_wrong_arguments("SplFileObject::fwrite", count, 2, 2, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2584,7 +2687,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileobject::ftell", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::ftell", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2598,7 +2701,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isexecutable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2612,7 +2715,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getatime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2629,7 +2732,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
         Variant a2;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 3) return throw_toomany_arguments("splfileinfo::openfile", 3, 1);
+        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -2655,7 +2758,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileobject::fstat", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::fstat", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2669,7 +2772,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileobject::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileObject::rewind", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -2683,7 +2786,7 @@ Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnviron
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::gettype", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -3939,177 +4042,214 @@ Variant c_splfileinfo::o_invoke(MethodIndex methodIndex, const char *s, CArrRef
   switch (methodIndex.m_callIndex) {
     case 0x27:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getperms", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
         return (t_getperms());
       }
       break;
     case 0x28:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::iswritable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
         return (t_iswritable());
       }
       break;
     case 0x29:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getbasename", 1, 1);
-        if (count <= 0) return (t_getbasename());
-        return (t_getbasename(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_getbasename());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getbasename(arg0));
+        }
       }
       break;
     case 0x2a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpathname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
         return (t_getpathname());
       }
       break;
     case 0x2b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getgroup", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
         return (t_getgroup());
       }
       break;
     case 0x2c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setfileclass", 1, 1);
-        if (count <= 0) return (t_setfileclass());
-        return (t_setfileclass(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_setfileclass());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_setfileclass(arg0));
+        }
       }
       break;
     case 0x2d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setinfoclass", 1, 1);
-        if (count <= 0) return (t_setinfoclass());
-        return (t_setinfoclass(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_setinfoclass());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_setinfoclass(arg0));
+        }
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x2e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getlinktarget", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
         return (t_getlinktarget());
       }
       break;
     case 0x2f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isreadable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
         return (t_isreadable());
       }
       break;
     case 0x30:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getrealpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
         return (t_getrealpath());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splfileinfo::__construct", count, 1, 1, 2);
-        return (t___construct(params[0]), null);
+        if (count != 1) return throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t___construct(arg0), null);
+        }
       }
       break;
     case 0x31:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getpathinfo", 1, 1);
-        if (count <= 0) return (t_getpathinfo());
-        return (t_getpathinfo(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_getpathinfo());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getpathinfo(arg0));
+        }
       }
       break;
     case 0x32:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getctime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
         return (t_getctime());
       }
       break;
     case 0x33:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
         return (t_getpath());
       }
       break;
     case 0x34:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getinode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
         return (t_getinode());
       }
       break;
     case 0x35:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::islink", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
         return (t_islink());
       }
       break;
     case 0x36:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getsize", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
         return (t_getsize());
       }
       break;
     case 0x38:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
         return (t_isfile());
       }
       break;
     case 0x37:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
         return (t_getfilename());
       }
       break;
     case 0x39:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getowner", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
         return (t_getowner());
       }
       break;
     case 0x3a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getmtime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
         return (t_getmtime());
       }
       break;
     case 0x3b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isdir", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
         return (t_isdir());
       }
       break;
     case 0x3c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getfileinfo", 1, 1);
-        if (count <= 0) return (t_getfileinfo());
-        return (t_getfileinfo(params[0]));
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_getfileinfo());
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_getfileinfo(arg0));
+        }
       }
       break;
     case 0x3e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isexecutable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
         return (t_isexecutable());
       }
       break;
     case 0x3d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getatime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
         return (t_getatime());
       }
       break;
     case 0x3f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 3) return throw_toomany_arguments("splfileinfo::openfile", 3, 1);
-        if (count <= 0) return (t_openfile());
-        if (count == 1) return (t_openfile(params[0]));
-        if (count == 2) return (t_openfile(params[0], params[1]));
-        return (t_openfile(params[0], params[1], params[2]));
+        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          if (count <= 0) return (t_openfile());
+          CVarRef arg0((ad->getValue(pos)));
+          if (count == 1) return (t_openfile(arg0));
+          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          if (count == 2) return (t_openfile(arg0, arg1));
+          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
+          return (t_openfile(arg0, arg1, arg2));
+        }
       }
       break;
     case 0x41:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::gettype", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
         return (t_gettype());
       }
       break;
@@ -4337,168 +4477,168 @@ Variant c_splfileinfo::o_invoke_few_args(MethodIndex methodIndex, const char *s,
   switch (methodIndex.m_callIndex) {
     case 0x27:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getperms", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
         return (t_getperms());
       }
       break;
     case 0x28:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::iswritable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
         return (t_iswritable());
       }
       break;
     case 0x29:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getbasename", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
         if (count <= 0) return (t_getbasename());
         return (t_getbasename(a0));
       }
       break;
     case 0x2a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpathname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
         return (t_getpathname());
       }
       break;
     case 0x2b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getgroup", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
         return (t_getgroup());
       }
       break;
     case 0x2c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setfileclass", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
         if (count <= 0) return (t_setfileclass());
         return (t_setfileclass(a0));
       }
       break;
     case 0x2d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setinfoclass", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
         if (count <= 0) return (t_setinfoclass());
         return (t_setinfoclass(a0));
       }
       break;
     case 0x1a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
         return (t___tostring());
       }
       break;
     case 0x2e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getlinktarget", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
         return (t_getlinktarget());
       }
       break;
     case 0x2f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isreadable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
         return (t_isreadable());
       }
       break;
     case 0x30:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getrealpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
         return (t_getrealpath());
       }
       break;
     case 0x6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splfileinfo::__construct", count, 1, 1, 2);
+        if (count != 1) return throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
         return (t___construct(a0), null);
       }
       break;
     case 0x31:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getpathinfo", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
         if (count <= 0) return (t_getpathinfo());
         return (t_getpathinfo(a0));
       }
       break;
     case 0x32:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getctime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
         return (t_getctime());
       }
       break;
     case 0x33:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
         return (t_getpath());
       }
       break;
     case 0x34:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getinode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
         return (t_getinode());
       }
       break;
     case 0x35:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::islink", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
         return (t_islink());
       }
       break;
     case 0x36:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getsize", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
         return (t_getsize());
       }
       break;
     case 0x38:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
         return (t_isfile());
       }
       break;
     case 0x37:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
         return (t_getfilename());
       }
       break;
     case 0x39:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getowner", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
         return (t_getowner());
       }
       break;
     case 0x3a:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getmtime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
         return (t_getmtime());
       }
       break;
     case 0x3b:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isdir", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
         return (t_isdir());
       }
       break;
     case 0x3c:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getfileinfo", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
         if (count <= 0) return (t_getfileinfo());
         return (t_getfileinfo(a0));
       }
       break;
     case 0x3e:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isexecutable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
         return (t_isexecutable());
       }
       break;
     case 0x3d:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getatime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
         return (t_getatime());
       }
       break;
     case 0x3f:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 3) return throw_toomany_arguments("splfileinfo::openfile", 3, 1);
+        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
         if (count <= 0) return (t_openfile());
         if (count == 1) return (t_openfile(a0));
         if (count == 2) return (t_openfile(a0, a1));
@@ -4507,7 +4647,7 @@ Variant c_splfileinfo::o_invoke_few_args(MethodIndex methodIndex, const char *s,
       break;
     case 0x41:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splfileinfo::gettype", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
         return (t_gettype());
       }
       break;
@@ -4709,7 +4849,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getperms", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4723,7 +4863,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::iswritable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4738,7 +4878,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getbasename", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -4756,7 +4896,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpathname", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4770,7 +4910,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getgroup", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4785,7 +4925,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setfileclass", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -4804,7 +4944,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::setinfoclass", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -4822,7 +4962,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::__tostring", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4836,7 +4976,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getlinktarget", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4850,7 +4990,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isreadable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4864,7 +5004,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getrealpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4879,7 +5019,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("splfileinfo::__construct", count, 1, 1, 2);
+        if (count != 1) return throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -4897,7 +5037,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getpathinfo", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -4915,7 +5055,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getctime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4929,7 +5069,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getpath", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4943,7 +5083,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getinode", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4957,7 +5097,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::islink", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4971,7 +5111,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getsize", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4985,7 +5125,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isfile", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -4999,7 +5139,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getfilename", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5013,7 +5153,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getowner", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5027,7 +5167,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getmtime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5041,7 +5181,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isdir", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5056,7 +5196,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 1) return throw_toomany_arguments("splfileinfo::getfileinfo", 1, 1);
+        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -5074,7 +5214,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::isexecutable", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5088,7 +5228,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::getatime", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -5105,7 +5245,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
         Variant a2;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 3) return throw_toomany_arguments("splfileinfo::openfile", 3, 1);
+        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -5131,7 +5271,7 @@ Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironme
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splfileinfo::gettype", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
diff --git a/src/system/gen/php/classes/splobjectstorage.cpp b/src/system/gen/php/classes/splobjectstorage.cpp
index 1c0a216390..4da537b169 100644
--- a/src/system/gen/php/classes/splobjectstorage.cpp
+++ b/src/system/gen/php/classes/splobjectstorage.cpp
@@ -234,55 +234,70 @@ Variant c_splobjectstorage::o_invoke(MethodIndex methodIndex, const char *s, CAr
   switch (methodIndex.m_callIndex) {
     case 0x1:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splobjectstorage::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplObjectStorage::next", 0, 1);
         return (t_next(), null);
       }
       break;
     case 0xa5:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splobjectstorage::detach", count, 1, 1, 1);
-        return (t_detach(params[0]), null);
+        if (count != 1) return throw_wrong_arguments("SplObjectStorage::detach", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_detach(arg0), null);
+        }
       }
       break;
     case 0xa4:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splobjectstorage::attach", count, 1, 1, 1);
-        return (t_attach(params[0]), null);
+        if (count != 1) return throw_wrong_arguments("SplObjectStorage::attach", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_attach(arg0), null);
+        }
       }
       break;
     case 0xf:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splobjectstorage::count", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplObjectStorage::count", 0, 1);
         return (t_count());
       }
       break;
     case 0x2:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splobjectstorage::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplObjectStorage::key", 0, 1);
         return (t_key());
       }
       break;
     case 0x3:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splobjectstorage::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplObjectStorage::valid", 0, 1);
         return (t_valid());
       }
       break;
     case 0xa6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splobjectstorage::contains", count, 1, 1, 1);
-        return (t_contains(params[0]));
+        if (count != 1) return throw_wrong_arguments("SplObjectStorage::contains", count, 1, 1, 1);
+        {
+          ArrayData *ad(params.get());
+          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
+          CVarRef arg0((ad->getValue(pos)));
+          return (t_contains(arg0));
+        }
       }
       break;
     case 0x7:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splobjectstorage::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplObjectStorage::current", 0, 1);
         return (t_current());
       }
       break;
     case 0x9:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splobjectstorage::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplObjectStorage::rewind", 0, 1);
         return (t_rewind(), null);
       }
       break;
@@ -372,55 +387,55 @@ Variant c_splobjectstorage::o_invoke_few_args(MethodIndex methodIndex, const cha
   switch (methodIndex.m_callIndex) {
     case 0x1:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splobjectstorage::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplObjectStorage::next", 0, 1);
         return (t_next(), null);
       }
       break;
     case 0xa5:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splobjectstorage::detach", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("SplObjectStorage::detach", count, 1, 1, 1);
         return (t_detach(a0), null);
       }
       break;
     case 0xa4:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splobjectstorage::attach", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("SplObjectStorage::attach", count, 1, 1, 1);
         return (t_attach(a0), null);
       }
       break;
     case 0xf:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splobjectstorage::count", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplObjectStorage::count", 0, 1);
         return (t_count());
       }
       break;
     case 0x2:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splobjectstorage::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplObjectStorage::key", 0, 1);
         return (t_key());
       }
       break;
     case 0x3:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splobjectstorage::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplObjectStorage::valid", 0, 1);
         return (t_valid());
       }
       break;
     case 0xa6:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count != 1) return throw_wrong_arguments("splobjectstorage::contains", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("SplObjectStorage::contains", count, 1, 1, 1);
         return (t_contains(a0));
       }
       break;
     case 0x7:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splobjectstorage::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplObjectStorage::current", 0, 1);
         return (t_current());
       }
       break;
     case 0x9:
       if (methodIndex.m_overloadIndex == 0x1) { 
-        if (count > 0) return throw_toomany_arguments("splobjectstorage::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplObjectStorage::rewind", 0, 1);
         return (t_rewind(), null);
       }
       break;
@@ -506,7 +521,7 @@ Variant c_splobjectstorage::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splobjectstorage::next", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplObjectStorage::next", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -521,7 +536,7 @@ Variant c_splobjectstorage::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("splobjectstorage::detach", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("SplObjectStorage::detach", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -539,7 +554,7 @@ Variant c_splobjectstorage::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("splobjectstorage::attach", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("SplObjectStorage::attach", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -556,7 +571,7 @@ Variant c_splobjectstorage::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splobjectstorage::count", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplObjectStorage::count", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -570,7 +585,7 @@ Variant c_splobjectstorage::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splobjectstorage::key", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplObjectStorage::key", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -584,7 +599,7 @@ Variant c_splobjectstorage::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splobjectstorage::valid", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplObjectStorage::valid", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -599,7 +614,7 @@ Variant c_splobjectstorage::o_invoke_from_eval(const char *s, Eval::VariableEnvi
         Variant a0;
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count != 1) return throw_wrong_arguments("splobjectstorage::contains", count, 1, 1, 1);
+        if (count != 1) return throw_wrong_arguments("SplObjectStorage::contains", count, 1, 1, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
           if (it == params.end()) break;
@@ -616,7 +631,7 @@ Variant c_splobjectstorage::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splobjectstorage::current", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplObjectStorage::current", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);
@@ -630,7 +645,7 @@ Variant c_splobjectstorage::o_invoke_from_eval(const char *s, Eval::VariableEnvi
       if (methodIndex.m_overloadIndex == 0x1) { 
         const std::vector<Eval::ExpressionPtr> &params = caller->params();
         int count __attribute__((__unused__)) = params.size();
-        if (count > 0) return throw_toomany_arguments("splobjectstorage::rewind", 0, 1);
+        if (count > 0) return throw_toomany_arguments("SplObjectStorage::rewind", 0, 1);
         std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
         do {
         } while(false);

