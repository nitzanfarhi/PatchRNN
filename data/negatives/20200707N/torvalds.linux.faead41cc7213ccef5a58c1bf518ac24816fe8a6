commit faead41cc7213ccef5a58c1bf518ac24816fe8a6
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Sep 22 10:31:41 2016 +0200

    iwlwifi: pcie: mark command queue lock with separate lockdep class
    
    Emmanuel reports that when CMD_WANT_ASYNC_CALLBACK is used by mvm,
    the callback will be called with the command queue lock held, and
    mvm will try to stop all (other) TX queues, which acquires their
    locks - this caused a false lockdep recursive locking report.
    
    Suppress this report by marking the command queue lock with a new,
    separate, lock class so lockdep can tell the difference between
    the two types of queues.
    
    Fixes: 156f92f2b471 ("iwlwifi: block the queues when we send ADD_STA for uAPSD")
    Reported-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Luca Coelho <luciano.coelho@intel.com>

diff --git a/drivers/net/wireless/intel/iwlwifi/pcie/tx.c b/drivers/net/wireless/intel/iwlwifi/pcie/tx.c
index e9a278b60dfd..5f840f16f40b 100644
--- a/drivers/net/wireless/intel/iwlwifi/pcie/tx.c
+++ b/drivers/net/wireless/intel/iwlwifi/pcie/tx.c
@@ -592,6 +592,7 @@ static int iwl_pcie_txq_alloc(struct iwl_trans *trans,
 static int iwl_pcie_txq_init(struct iwl_trans *trans, struct iwl_txq *txq,
 			      int slots_num, u32 txq_id)
 {
+	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
 	int ret;
 
 	txq->need_update = false;
@@ -606,6 +607,13 @@ static int iwl_pcie_txq_init(struct iwl_trans *trans, struct iwl_txq *txq,
 		return ret;
 
 	spin_lock_init(&txq->lock);
+
+	if (txq_id == trans_pcie->cmd_queue) {
+		static struct lock_class_key iwl_pcie_cmd_queue_lock_class;
+
+		lockdep_set_class(&txq->lock, &iwl_pcie_cmd_queue_lock_class);
+	}
+
 	__skb_queue_head_init(&txq->overflow_q);
 
 	/*

