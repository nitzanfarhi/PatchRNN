commit 2c92b058fd04d60045ad9f5ecf0f5c59f684afc3
Author: Eduardo Silva <edsiper@gmail.com>
Date:   Fri Jul 30 12:36:37 2010 -0400

    New Plugin registration macro: MONKEY_PLUGIN()

diff --git a/plugins/cheetah/cmd.c b/plugins/cheetah/cmd.c
index abd8f486..71214346 100644
--- a/plugins/cheetah/cmd.c
+++ b/plugins/cheetah/cmd.c
@@ -127,7 +127,7 @@ void mk_cheetah_cmd_plugins_print_stage(struct plugin *list, const char *stage,
     printf("%s[%s]%s", ANSI_BOLD ANSI_YELLOW, stage, ANSI_RESET);
   
     while (p) {
-        if (*p->hooks & stage_bw) {
+       if (p->hooks & stage_bw) {
             printf("\n  [%s] %s v%s on \"%s\"",
                    p->shortname, p->name, p->version, p->path);
         }
@@ -146,7 +146,7 @@ void mk_cheetah_cmd_plugins_print_core(struct plugin *list)
     printf("\n%s[CORE PROCESS CONTEXT]%s", ANSI_BOLD ANSI_BLUE, ANSI_RESET);
 
     while (p) {
-        if (*p->hooks & MK_PLUGIN_CORE_PRCTX) {
+        if (p->hooks & MK_PLUGIN_CORE_PRCTX) {
             printf("\n  [%s] %s v%s on \"%s\"",
                    p->shortname, p->name, p->version, p->path);
         }
@@ -158,7 +158,7 @@ void mk_cheetah_cmd_plugins_print_core(struct plugin *list)
     printf("\n%s[CORE THREAD CONTEXT]%s", ANSI_BOLD ANSI_BLUE, ANSI_RESET);
 
     while (p) {
-        if (*p->hooks & MK_PLUGIN_CORE_THCTX) {
+        if (p->hooks & MK_PLUGIN_CORE_THCTX) {
             printf("\n  [%s] %s v%s on \"%s\"",
                    p->shortname, p->name, p->version, p->path);
         }
@@ -177,7 +177,7 @@ void mk_cheetah_cmd_plugins_print_network(struct plugin *list)
     printf("%s[NETWORK I/O]%s", ANSI_BOLD ANSI_RED, ANSI_RESET);
 
     while (p) {
-        if (*p->hooks & MK_PLUGIN_NETWORK_IO) {
+        if (p->hooks & MK_PLUGIN_NETWORK_IO) {
             printf("\n  [%s] %s v%s on \"%s\"",
                    p->shortname, p->name, p->version, p->path);
         }
@@ -188,7 +188,7 @@ void mk_cheetah_cmd_plugins_print_network(struct plugin *list)
     printf("\n\n%s[NETWORK IP]%s", ANSI_BOLD ANSI_RED, ANSI_RESET);
 
     while (p) {
-        if (*p->hooks & MK_PLUGIN_NETWORK_IP) {
+        if (p->hooks & MK_PLUGIN_NETWORK_IP) {
             printf("\n  [%s] %s v%s on \"%s\"",
                    p->shortname, p->name, p->version, p->path);
         }
diff --git a/plugins/logger/logger.c b/plugins/logger/logger.c
index d1fa4c30..279ccf98 100644
--- a/plugins/logger/logger.c
+++ b/plugins/logger/logger.c
@@ -21,10 +21,11 @@
 
 #define _GNU_SOURCE
 
-#include <unistd.h>
+/* System Headers */
 #include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
+#include <unistd.h>
 #include <sys/ioctl.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -32,23 +33,12 @@
 #include <pthread.h>
 #include <unistd.h>
 
-#include "http.h"
-#include "plugin.h"
-#include "utils.h"
+/* Monkey Plugin Interface */
+#include "MKPlugin.h"
+
+/* Local Headers */
 #include "logger.h"
 #include "pointers.h"
-#include "http_status.h"
-#include "epoll.h"
-
-/* Plugin data for register */
-mk_plugin_data_t _shortname = "logger";
-mk_plugin_data_t _name = "Logger";
-mk_plugin_data_t _version = "0.11.0";
-mk_plugin_hook_t _hooks = MK_PLUGIN_CORE_PRCTX | 
-                          MK_PLUGIN_CORE_THCTX | MK_PLUGIN_STAGE_40;
-
-/* Thread key data */
-mk_plugin_key_t _mkp_data;
 
 char *mk_logger_match_by_fd(int fd)
 {
@@ -222,7 +212,10 @@ int mk_logger_read_config(char *path)
 int _mkp_init(void **api, char *confdir)
 {
     mk_api = *api;
-    
+
+    printf("\nconfdir: '%s'", confdir);
+    fflush(stdout);
+
     /* Specific thread key */
     pthread_key_create(&cache_content_length, NULL);
     pthread_key_create(&cache_status, NULL);
@@ -509,6 +502,12 @@ int _mkp_stage_40(struct client_request *cr, struct request *sr)
         mk_api->iov_send(target->fd_error[1], iov, MK_IOV_SEND_TO_PIPE);
     }
 
-
     return 0;
 }
+
+
+MONKEY_PLUGIN("logger", /* shortname */
+              "Logger", /* name */
+              "0.12.0", /* version */
+              /* hooks */
+              MK_PLUGIN_CORE_PRCTX | MK_PLUGIN_CORE_THCTX | MK_PLUGIN_STAGE_40);
diff --git a/src/include/MKPlugin.h b/src/include/MKPlugin.h
index 7cff808d..fe6497a4 100644
--- a/src/include/MKPlugin.h
+++ b/src/include/MKPlugin.h
@@ -20,10 +20,11 @@
  */
 
 #ifndef MONKEY_PLUGIN_H
-#define MONKEY_PLUGIN
+#define MONKEY_PLUGIN_H
 
 /* Monkey Headers */
 #include "plugin.h"
+#include "http.h"
 
 /* Registration variables */
 mk_plugin_data_t _shortname;
@@ -33,5 +34,10 @@ mk_plugin_hook_t _hooks;
 
 /* global vars */
 struct plugin_api *mk_api;
+mk_plugin_key_t _mkp_data;
+
+
+#define MONKEY_PLUGIN(a, b, c, d)                   \
+    struct plugin_info _plugin_info = {a, b, c, d}
 
 #endif
diff --git a/src/include/plugin.h b/src/include/plugin.h
index ea12b079..41cc17f2 100644
--- a/src/include/plugin.h
+++ b/src/include/plugin.h
@@ -107,9 +107,10 @@ struct plugin
     char *version;
     char *path;
     void *handler;
-    int *hooks;
+    int hooks;
 
     /* Mandatory calls */
+    int (*register_plugin)();
     int (*init) (void *, char *);
     int  (*exit) ();
 
@@ -262,9 +263,10 @@ typedef pthread_key_t mk_plugin_key_t;
 /* Plugin events thread key */
 pthread_key_t mk_plugin_event_k;
 
-struct plugin_event {
+struct plugin_event 
+{
     int socket;
-
+    
     struct plugin *handler;
     struct client_request *cr;
     struct request *sr;
@@ -272,6 +274,13 @@ struct plugin_event {
     struct plugin_event *next;
 };
 
+struct plugin_info {
+    const char *shortname;
+    const char *name;
+    const char *version;
+    unsigned int hooks;
+};
+
 void mk_plugin_init();
 int mk_plugin_stage_run(mk_plugin_hook_t stage,
                         unsigned int socket,
diff --git a/src/plugin.c b/src/plugin.c
index 357080da..beed0f7d 100644
--- a/src/plugin.c
+++ b/src/plugin.c
@@ -54,6 +54,7 @@ void *mk_plugin_load(char *path)
         fprintf(stderr, "Error during dlopen(): %s\n", dlerror());
         exit(1);
     }
+
     return handle;
 }
 
@@ -96,23 +97,23 @@ void mk_plugin_register_stagemap_add(struct plugin_stagem **stm, struct plugin *
 void mk_plugin_register_stagemap(struct plugin *p)
 {
     /* Plugin to stages */
-    if (*p->hooks & MK_PLUGIN_STAGE_10) {
+    if (p->hooks & MK_PLUGIN_STAGE_10) {
         mk_plugin_register_stagemap_add(&plg_stagemap->stage_10, p);
     }
 
-    if (*p->hooks & MK_PLUGIN_STAGE_20) {
+    if (p->hooks & MK_PLUGIN_STAGE_20) {
         mk_plugin_register_stagemap_add(&plg_stagemap->stage_20, p);
     }
 
-    if (*p->hooks & MK_PLUGIN_STAGE_30) {
+    if (p->hooks & MK_PLUGIN_STAGE_30) {
         mk_plugin_register_stagemap_add(&plg_stagemap->stage_30, p);
     }
 
-    if (*p->hooks & MK_PLUGIN_STAGE_40) {
+    if (p->hooks & MK_PLUGIN_STAGE_40) {
         mk_plugin_register_stagemap_add(&plg_stagemap->stage_40, p);
     }
 
-    if (*p->hooks & MK_PLUGIN_STAGE_50) {
+    if (p->hooks & MK_PLUGIN_STAGE_50) {
         mk_plugin_register_stagemap_add(&plg_stagemap->stage_50, p);
     }
 }
@@ -120,14 +121,23 @@ void mk_plugin_register_stagemap(struct plugin *p)
 struct plugin *mk_plugin_alloc(void *handler, char *path)
 {
     struct plugin *p;
+    struct plugin_info *info;
 
     p = mk_mem_malloc_z(sizeof(struct plugin));
-    p->shortname = mk_plugin_load_symbol(handler, "_shortname");
-    p->name = mk_plugin_load_symbol(handler, "_name");
-    p->version = mk_plugin_load_symbol(handler, "_version");
+    info = (struct plugin_info *) mk_plugin_load_symbol(handler, "_plugin_info");
+
+    if (!info) {
+        printf("\nPlugin Error: '%s'\nis not registering properly\n\n", path);
+        exit(1);
+    }
+
+    p->shortname = (char *) (*info).shortname;
+    p->name = (char *) (*info).name;
+    p->version = (char *) (*info).version;
+    p->hooks = (unsigned int) (*info).hooks;
+
     p->path = mk_string_dup(path);
     p->handler = handler;
-    p->hooks = (mk_plugin_hook_t *) mk_plugin_load_symbol(handler, "_hooks");
 
     /* Mandatory functions */
     p->init = (int (*)()) mk_plugin_load_symbol(handler, "_mkp_init");
@@ -233,7 +243,7 @@ struct plugin *mk_plugin_register(struct plugin *p)
         return NULL;
     }
 
-    if (!p->init || !p->exit) {
+    if (!p->register_plugin || p->init || !p->exit) {
 #ifdef TRACE
         MK_TRACE("Plugin must define hooks 'init' and 'exit'");
 #endif        
@@ -242,7 +252,7 @@ struct plugin *mk_plugin_register(struct plugin *p)
     }
 
     /* NETWORK_IO Plugin */
-    if (*p->hooks & MK_PLUGIN_NETWORK_IO) {
+    if (p->hooks & MK_PLUGIN_NETWORK_IO) {
         /* Validate mandatory calls */
         if (!p->net_io.accept || !p->net_io.read || !p->net_io.write ||
             !p->net_io.writev || !p->net_io.close || !p->net_io.connect ||
@@ -281,7 +291,7 @@ create socket : %p\nbind : %p\nserver : %p",
     }
 
     /* NETWORK_IP Plugin */
-    if (*p->hooks & MK_PLUGIN_NETWORK_IP) {
+    if (p->hooks & MK_PLUGIN_NETWORK_IP) {
         /* Validate mandatory calls */
         if (!p->net_ip.addr || !p->net_ip.maxlen) {
 #ifdef TRACE
@@ -498,6 +508,7 @@ void mk_plugin_init()
 #ifdef TRACE
             MK_TRACE("Load Plugin '%s@%s'", p->shortname, p->path);
 #endif
+            
             /* Init plugin */
             ret = p->init(&api, plugin_confdir);
             if (ret < 0) {

