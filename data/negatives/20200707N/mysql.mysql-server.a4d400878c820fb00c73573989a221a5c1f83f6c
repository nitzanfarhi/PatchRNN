commit a4d400878c820fb00c73573989a221a5c1f83f6c
Author: marko <>
Date:   Wed Aug 15 12:29:46 2007 +0000

    Replace mysql_byte with uchar and remove the #define mysql_byte from
    ha_innodb.cc.  This cleanup was made possible as of r1550:
    
    Merge changes from MySQL AB:
    
    ChangeSet@2007-05-10 12:59:39+03:00, monty@mysql.com
      WL#3817: Simplify string / memory area types and make things more consistent
      (first part)
    
      The following type conversions was done:
    
      - Changed byte to uchar
    ...

diff --git a/handler/ha_innodb.cc b/handler/ha_innodb.cc
index 10d0b9e6a25..76fb9670f9e 100644
--- a/handler/ha_innodb.cc
+++ b/handler/ha_innodb.cc
@@ -62,12 +62,6 @@ static bool innodb_inited = 0;
 */
 static handlerton *innodb_hton_ptr;
 
-/* Store MySQL definition of 'byte': in Linux it is char while InnoDB
-uses unsigned char; the header univ.i which we include next defines
-'byte' as a macro which expands to 'unsigned char' */
-
-typedef uchar mysql_byte;
-
 #define INSIDE_HA_INNOBASE_CC
 
 /* Include necessary InnoDB headers */
@@ -148,7 +142,7 @@ static HASH	innobase_open_tables;
 bool nw_panic = FALSE;
 #endif
 
-static mysql_byte* innobase_get_key(INNOBASE_SHARE *share, size_t *length,
+static uchar* innobase_get_key(INNOBASE_SHARE *share, size_t *length,
 	my_bool not_used __attribute__((unused)));
 static INNOBASE_SHARE *get_share(const char *table_name);
 static void free_share(INNOBASE_SHARE *share);
@@ -2422,7 +2416,7 @@ ha_innobase::open(
 	upd_and_key_val_buff_len =
 				table->s->reclength + table->s->max_key_length
 							+ MAX_REF_PARTS * 3;
-	if (!(mysql_byte*) my_multi_malloc(MYF(MY_WME),
+	if (!(uchar*) my_multi_malloc(MYF(MY_WME),
 			&upd_buff, upd_and_key_val_buff_len,
 			&key_val_buff, upd_and_key_val_buff_len,
 			NullS)) {
@@ -2856,8 +2850,8 @@ inline
 uint
 innobase_read_from_2_little_endian(
 /*===============================*/
-			/* out: value */
-	const mysql_byte*	buf)	/* in: from where to read */
+				/* out: value */
+	const uchar*	buf)	/* in: from where to read */
 {
 	return (uint) ((ulint)(buf[0]) + 256 * ((ulint)(buf[1])));
 }
@@ -2873,7 +2867,7 @@ ha_innobase::store_key_val_for_row(
 	char*		buff,	/* in/out: buffer for the key value (in MySQL
 				format) */
 	uint		buff_len,/* in: buffer length */
-	const mysql_byte* record)/* in: row in MySQL format */
+	const uchar*	record)/* in: row in MySQL format */
 {
 	KEY*		key_info	= table->key_info + keynr;
 	KEY_PART_INFO*	key_part	= key_info->key_part;
@@ -3070,7 +3064,7 @@ ha_innobase::store_key_val_for_row(
 			CHARSET_INFO*		cs;
 			ulint			true_len;
 			ulint			key_len;
-			const mysql_byte*	src_start;
+			const uchar*		src_start;
 			int			error=0;
 			enum_field_types	real_type;
 
@@ -3443,8 +3437,8 @@ handle. */
 int
 ha_innobase::write_row(
 /*===================*/
-				/* out: error code */
-	mysql_byte*	record)	/* in: a row in MySQL format */
+			/* out: error code */
+	uchar*	record)	/* in: a row in MySQL format */
 {
 	int		error = 0;
 	ibool		auto_inc_used= FALSE;
@@ -3648,16 +3642,16 @@ calc_row_difference(
 /*================*/
 					/* out: error number or 0 */
 	upd_t*		uvect,		/* in/out: update vector */
-	mysql_byte*	old_row,	/* in: old row in MySQL format */
-	mysql_byte*	new_row,	/* in: new row in MySQL format */
+	uchar*		old_row,	/* in: old row in MySQL format */
+	uchar*		new_row,	/* in: new row in MySQL format */
 	struct st_table* table,		/* in: table in MySQL data
 					dictionary */
-	mysql_byte*	upd_buff,	/* in: buffer to use */
+	uchar*		upd_buff,	/* in: buffer to use */
 	ulint		buff_len,	/* in: buffer length */
 	row_prebuilt_t*	prebuilt,	/* in: InnoDB prebuilt struct */
 	THD*		thd)		/* in: user thread */
 {
-	mysql_byte*	original_upd_buff = upd_buff;
+	uchar*		original_upd_buff = upd_buff;
 	Field*		field;
 	enum_field_types field_mysql_type;
 	uint		n_fields;
@@ -3801,8 +3795,8 @@ int
 ha_innobase::update_row(
 /*====================*/
 					/* out: error number or 0 */
-	const mysql_byte*	old_row,/* in: old row in MySQL format */
-	mysql_byte*		new_row)/* in: new row in MySQL format */
+	const uchar*	old_row,	/* in: old row in MySQL format */
+	uchar*		new_row)	/* in: new row in MySQL format */
 {
 	upd_t*		uvect;
 	int		error = 0;
@@ -3824,7 +3818,7 @@ ha_innobase::update_row(
 	/* Build an update vector from the modified fields in the rows
 	(uses upd_buff of the handle) */
 
-	calc_row_difference(uvect, (mysql_byte*) old_row, new_row, table,
+	calc_row_difference(uvect, (uchar*) old_row, new_row, table,
 			upd_buff, (ulint)upd_and_key_val_buff_len,
 			prebuilt, user_thd);
 
@@ -3881,8 +3875,8 @@ Deletes a row given as the parameter. */
 int
 ha_innobase::delete_row(
 /*====================*/
-					/* out: error number or 0 */
-	const mysql_byte* record)	/* in: a row in MySQL format */
+				/* out: error number or 0 */
+	const uchar*	record)	/* in: a row in MySQL format */
 {
 	int		error = 0;
 	trx_t*		trx = thd_to_trx(user_thd);
@@ -4122,9 +4116,9 @@ ha_innobase::index_read(
 /*====================*/
 					/* out: 0, HA_ERR_KEY_NOT_FOUND,
 					or error number */
-	mysql_byte*		buf,	/* in/out: buffer for the returned
+	uchar*		buf,		/* in/out: buffer for the returned
 					row */
-	const mysql_byte*	key_ptr,/* in: key value; if this is NULL
+	const uchar*	key_ptr,	/* in: key value; if this is NULL
 					we position the cursor at the
 					start or end of index; this can
 					also contain an InnoDB row id, in
@@ -4221,13 +4215,13 @@ row with the current key value or prefix. */
 int
 ha_innobase::index_read_last(
 /*=========================*/
-				   /* out: 0, HA_ERR_KEY_NOT_FOUND, or an
-				   error code */
-	mysql_byte*	  buf,	   /* out: fetched row */
-	const mysql_byte* key_ptr, /* in: key value, or a prefix of a full
-				   key value */
-	uint		  key_len) /* in: length of the key val or prefix
-				   in bytes */
+				/* out: 0, HA_ERR_KEY_NOT_FOUND, or an
+				error code */
+	uchar*		buf,	/* out: fetched row */
+	const uchar*	key_ptr,/* in: key value, or a prefix of a full
+				key value */
+	uint		key_len)/* in: length of the key val or prefix
+				in bytes */
 {
 	return(index_read(buf, key_ptr, key_len, HA_READ_PREFIX_LAST));
 }
@@ -4323,10 +4317,10 @@ int
 ha_innobase::index_read_idx(
 /*========================*/
 					/* out: error number or 0 */
-	mysql_byte*	buf,		/* in/out: buffer for the returned
+	uchar*		buf,		/* in/out: buffer for the returned
 					row */
 	uint		keynr,		/* in: use this index */
-	const mysql_byte* key,		/* in: key value; if this is NULL
+	const uchar*	key,		/* in: key value; if this is NULL
 					we position the cursor at the
 					start or end of index */
 	uint		key_len,	/* in: key value length */
@@ -4349,7 +4343,7 @@ ha_innobase::general_fetch(
 /*=======================*/
 				/* out: 0, HA_ERR_END_OF_FILE, or error
 				number */
-	mysql_byte*	buf,	/* in/out: buffer for next row in MySQL
+	uchar*	buf,		/* in/out: buffer for next row in MySQL
 				format */
 	uint	direction,	/* in: ROW_SEL_NEXT or ROW_SEL_PREV */
 	uint	match_mode)	/* in: 0, ROW_SEL_EXACT, or
@@ -4396,7 +4390,7 @@ ha_innobase::index_next(
 /*====================*/
 				/* out: 0, HA_ERR_END_OF_FILE, or error
 				number */
-	mysql_byte*	buf)	/* in/out: buffer for next row in MySQL
+	uchar*		buf)	/* in/out: buffer for next row in MySQL
 				format */
 {
 	ha_statistic_increment(&SSV::ha_read_next_count);
@@ -4412,8 +4406,8 @@ ha_innobase::index_next_same(
 /*=========================*/
 				/* out: 0, HA_ERR_END_OF_FILE, or error
 				number */
-	mysql_byte*	buf,	/* in/out: buffer for the row */
-	const mysql_byte* key,	/* in: key value */
+	uchar*		buf,	/* in/out: buffer for the row */
+	const uchar*	key,	/* in: key value */
 	uint		keylen)	/* in: key value length */
 {
 	ha_statistic_increment(&SSV::ha_read_next_count);
@@ -4428,10 +4422,8 @@ positioned using index_read. */
 int
 ha_innobase::index_prev(
 /*====================*/
-				/* out: 0, HA_ERR_END_OF_FILE, or error
-				number */
-	mysql_byte*	buf)	/* in/out: buffer for previous row in MySQL
-				format */
+			/* out: 0, HA_ERR_END_OF_FILE, or error number */
+	uchar*	buf)	/* in/out: buffer for previous row in MySQL format */
 {
 	ha_statistic_increment(&SSV::ha_read_prev_count);
 
@@ -4445,9 +4437,8 @@ corresponding row to buf. */
 int
 ha_innobase::index_first(
 /*=====================*/
-				/* out: 0, HA_ERR_END_OF_FILE,
-				or error code */
-	mysql_byte*	buf)	/* in/out: buffer for the row */
+			/* out: 0, HA_ERR_END_OF_FILE, or error code */
+	uchar*	buf)	/* in/out: buffer for the row */
 {
 	int	error;
 
@@ -4472,8 +4463,8 @@ corresponding row to buf. */
 int
 ha_innobase::index_last(
 /*====================*/
-				/* out: 0, HA_ERR_END_OF_FILE, or error code */
-	mysql_byte*	buf)	/* in/out: buffer for the row */
+			/* out: 0, HA_ERR_END_OF_FILE, or error code */
+	uchar*	buf)	/* in/out: buffer for the row */
 {
 	int	error;
 
@@ -4542,7 +4533,7 @@ int
 ha_innobase::rnd_next(
 /*==================*/
 			/* out: 0, HA_ERR_END_OF_FILE, or error number */
-	mysql_byte* buf)/* in/out: returns the row in this buffer,
+	uchar*	buf)	/* in/out: returns the row in this buffer,
 			in MySQL format */
 {
 	int	error;
@@ -4569,14 +4560,12 @@ Fetches a row from the table based on a row reference. */
 int
 ha_innobase::rnd_pos(
 /*=================*/
-				/* out: 0, HA_ERR_KEY_NOT_FOUND,
-				or error code */
-	mysql_byte*	buf,	/* in/out: buffer for the row */
-	mysql_byte*	pos)	/* in: primary key value of the row in the
-				MySQL format, or the row id if the clustered
-				index was internally generated by InnoDB;
-				the length of data in pos has to be
-				ref_length */
+			/* out: 0, HA_ERR_KEY_NOT_FOUND, or error code */
+	uchar*	buf,	/* in/out: buffer for the row */
+	uchar*	pos)	/* in: primary key value of the row in the
+			MySQL format, or the row id if the clustered
+			index was internally generated by InnoDB; the
+			length of data in pos has to be ref_length */
 {
 	int		error;
 	uint		keynr	= active_index;
@@ -4629,7 +4618,7 @@ was positioned the last time. */
 void
 ha_innobase::position(
 /*==================*/
-	const mysql_byte*	record)	/* in: row in MySQL format */
+	const uchar*	record)	/* in: row in MySQL format */
 {
 	uint		len;
 
@@ -5489,7 +5478,7 @@ ha_innobase::records_in_range(
 {
 	KEY*		key;
 	dict_index_t*	index;
-	mysql_byte*	key_val_buff2	= (mysql_byte*) my_malloc(
+	uchar*		key_val_buff2	= (uchar*) my_malloc(
 						  table->s->reclength
 					+ table->s->max_key_length + 100,
 								MYF(MY_FAE));
@@ -5531,7 +5520,7 @@ ha_innobase::records_in_range(
 				(ulint)upd_and_key_val_buff_len,
 				index,
 				(byte*) (min_key ? min_key->key :
-					 (const mysql_byte*) 0),
+					 (const uchar*) 0),
 				(ulint) (min_key ? min_key->length : 0),
 				prebuilt->trx);
 
@@ -5539,7 +5528,7 @@ ha_innobase::records_in_range(
 				range_end, (byte*) key_val_buff2,
 				buff2_len, index,
 				(byte*) (max_key ? max_key->key :
-					 (const mysql_byte*) 0),
+					 (const uchar*) 0),
 				(ulint) (max_key ? max_key->length : 0),
 				prebuilt->trx);
 
@@ -6939,12 +6928,12 @@ bool innobase_show_status(handlerton *hton, THD* thd,
  locking.
 ****************************************************************************/
 
-static mysql_byte* innobase_get_key(INNOBASE_SHARE* share, size_t *length,
+static uchar* innobase_get_key(INNOBASE_SHARE* share, size_t *length,
 	my_bool not_used __attribute__((unused)))
 {
 	*length=share->table_name_length;
 
-	return (mysql_byte*) share->table_name;
+	return (uchar*) share->table_name;
 }
 
 static INNOBASE_SHARE* get_share(const char* table_name)
@@ -6954,7 +6943,7 @@ static INNOBASE_SHARE* get_share(const char* table_name)
 	uint length=(uint) strlen(table_name);
 
 	if (!(share=(INNOBASE_SHARE*) hash_search(&innobase_open_tables,
-				(mysql_byte*) table_name,
+				(uchar*) table_name,
 				length))) {
 
 		share = (INNOBASE_SHARE *) my_malloc(sizeof(*share)+length+1,
@@ -6965,7 +6954,7 @@ static INNOBASE_SHARE* get_share(const char* table_name)
 		strmov(share->table_name,table_name);
 
 		if (my_hash_insert(&innobase_open_tables,
-				(mysql_byte*) share)) {
+				(uchar*) share)) {
 			pthread_mutex_unlock(&innobase_share_mutex);
 			my_free(share,0);
 
@@ -6987,7 +6976,7 @@ static void free_share(INNOBASE_SHARE* share)
 	pthread_mutex_lock(&innobase_share_mutex);
 
 	if (!--share->use_count) {
-		hash_delete(&innobase_open_tables, (mysql_byte*) share);
+		hash_delete(&innobase_open_tables, (uchar*) share);
 		thr_lock_delete(&share->lock);
 		pthread_mutex_destroy(&share->mutex);
 		my_free(share, MYF(0));
@@ -7488,9 +7477,9 @@ ha_innobase::cmp_ref(
 /*=================*/
 				/* out: < 0 if ref1 < ref2, 0 if equal, else
 				> 0 */
-	const mysql_byte* ref1,	/* in: an (internal) primary key value in the
+	const uchar*	ref1,	/* in: an (internal) primary key value in the
 				MySQL key value format */
-	const mysql_byte* ref2)	/* in: an (internal) primary key value in the
+	const uchar*	ref2)	/* in: an (internal) primary key value in the
 				MySQL key value format */
 {
 	enum_field_types mysql_type;

