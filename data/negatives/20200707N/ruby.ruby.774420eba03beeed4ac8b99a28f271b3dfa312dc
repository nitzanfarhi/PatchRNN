commit 774420eba03beeed4ac8b99a28f271b3dfa312dc
Author: normal <normal@b2dd03c8-39d4-4d8f-98ff-823fe69b080e>
Date:   Mon May 8 01:59:17 2017 +0000

    reduce rb_mutex_t size from 80 bytes to 72 bytes on 64-bit
    
    We can use existing RVALUE flags to avoid adding a 4-byte
    integer to store a boolean flag.  This integer cost us 8 bytes
    due to default (lack of) struct packing on x86-64
    
    * thread_sync.c (MUTEX_ALLOW_TRAP): define as FL_USER1
      (struct rb_mutex_struct): remove allow_trap
      (rb_mutex_lock): adjust for flag check
      (rb_mutex_allow_trap): adjust for flag set/unset
    
    git-svn-id: svn+ssh://ci.ruby-lang.org/ruby/trunk@58608 b2dd03c8-39d4-4d8f-98ff-823fe69b080e

diff --git a/thread_sync.c b/thread_sync.c
index 6f7919867c..bfd625d001 100644
--- a/thread_sync.c
+++ b/thread_sync.c
@@ -12,11 +12,12 @@ struct mutex_waiter {
     struct list_node node;
 };
 
+#define MUTEX_ALLOW_TRAP FL_USER1
+
 typedef struct rb_mutex_struct {
     struct rb_thread_struct volatile *th;
     struct rb_mutex_struct *next_mutex;
     struct list_head waitq; /* protected by GVL */
-    int allow_trap;
 } rb_mutex_t;
 
 #if defined(HAVE_WORKING_FORK)
@@ -206,7 +207,8 @@ rb_mutex_lock(VALUE self)
     GetMutexPtr(self, mutex);
 
     /* When running trap handler */
-    if (!mutex->allow_trap && th->interrupt_mask & TRAP_INTERRUPT_MASK) {
+    if (!FL_TEST_RAW(self, MUTEX_ALLOW_TRAP) &&
+		th->interrupt_mask & TRAP_INTERRUPT_MASK) {
 	rb_raise(rb_eThreadError, "can't be called from trap context");
     }
 
@@ -478,10 +480,12 @@ rb_mutex_synchronize_m(VALUE self, VALUE args)
 
 void rb_mutex_allow_trap(VALUE self, int val)
 {
-    rb_mutex_t *m;
-    GetMutexPtr(self, m);
+    Check_TypedStruct(self, &mutex_data_type);
 
-    m->allow_trap = val;
+    if (val)
+	FL_SET_RAW(self, MUTEX_ALLOW_TRAP);
+    else
+	FL_UNSET_RAW(self, MUTEX_ALLOW_TRAP);
 }
 
 /* Queue */

