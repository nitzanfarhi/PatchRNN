commit 5dffff5a4746075a4609366440c2c67983eec106
Author: Tom Musta <tommusta@gmail.com>
Date:   Wed Feb 12 15:22:55 2014 -0600

    target-ppc: Altivec 2.07: Add Support for Dual Altivec Instructions
    
    Some Alitvec instructions introduced in Power ISA Version 2.07 use bit 31
    (aka the "Rc" bit) as an opcode bit.  However, QEMU for PowerPC uses
    bits 0-5 and 21-30 for opcodes and not bit 31.
    
    This patch introduces macros that will handle this situation by injecting
    an auxiliary handler which decodes bit 31 in invokes one of two standard
    handlers.  Since the instructions are not, in general, from the same version
    of the ISA, two sets of PPC_*/PPC2_* instruction tags are supported.
    
    Signed-off-by: Tom Musta <tommusta@gmail.com>
    Signed-off-by: Alexander Graf <agraf@suse.de>

diff --git a/target-ppc/translate.c b/target-ppc/translate.c
index 85dad7fa0c..ffcee7ff96 100644
--- a/target-ppc/translate.c
+++ b/target-ppc/translate.c
@@ -6904,6 +6904,26 @@ static void glue(gen_, name)(DisasContext *ctx)                         \
     tcg_temp_free_ptr(rd);                                              \
 }
 
+/*
+ * Support for Altivec instruction pairs that use bit 31 (Rc) as
+ * an opcode bit.  In general, these pairs come from different
+ * versions of the ISA, so we must also support a pair of flags for
+ * each instruction.
+ */
+#define GEN_VXFORM_DUAL(name0, flg0, flg2_0, name1, flg1, flg2_1)          \
+static void glue(gen_, name0##_##name1)(DisasContext *ctx)             \
+{                                                                      \
+    if ((Rc(ctx->opcode) == 0) &&                                      \
+        ((ctx->insns_flags & flg0) || (ctx->insns_flags2 & flg2_0))) { \
+        gen_##name0(ctx);                                              \
+    } else if ((Rc(ctx->opcode) == 1) &&                               \
+        ((ctx->insns_flags & flg1) || (ctx->insns_flags2 & flg2_1))) { \
+        gen_##name1(ctx);                                              \
+    } else {                                                           \
+        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_INVAL);            \
+    }                                                                  \
+}
+
 GEN_VXFORM(vaddubm, 0, 0);
 GEN_VXFORM(vadduhm, 0, 1);
 GEN_VXFORM(vadduwm, 0, 2);
@@ -10260,6 +10280,10 @@ GEN_VX_LOGICAL(vnor, tcg_gen_nor_i64, 2, 20),
 #undef GEN_VXFORM
 #define GEN_VXFORM(name, opc2, opc3)                                    \
 GEN_HANDLER(name, 0x04, opc2, opc3, 0x00000000, PPC_ALTIVEC)
+#undef GEN_VXFORM_DUAL
+#define GEN_VXFORM_DUAL(name0, name1, opc2, opc3, type0, type1) \
+GEN_HANDLER_E(name0##_##name1, 0x4, opc2, opc3, 0x00000000, type0, type1)
+
 GEN_VXFORM(vaddubm, 0, 0),
 GEN_VXFORM(vadduhm, 0, 1),
 GEN_VXFORM(vadduwm, 0, 2),

