commit e4bc6522d53b7b8eb02cfac35fd18275fd86269d
Author: Li Wang <wangli@kylinos.com.cn>
Date:   Tue Oct 30 19:52:40 2012 +0800

    eCryptfs: Avoid unnecessary disk read and data decryption during writing
    
    ecryptfs_write_begin grabs a page from page cache for writing.
    If the page contains invalid data, or data older than the
    counterpart on the disk, eCryptfs will read out the
    corresponing data from the disk into the page, decrypt them,
    then perform writing. However, for this page, if the length
    of the data to be written into is equal to page size,
    that means the whole page of data will be overwritten,
    in which case, it does not matter whatever the data were before,
    it is beneficial to perform writing directly rather than bothering
    to read and decrypt first.
    
    With this optimization, according to our test on a machine with
    Intel Core 2 Duo processor, iozone 'write' operation on an existing
    file with write size being multiple of page size will enjoy a steady
    3x speedup.
    
    Signed-off-by: Li Wang <wangli@kylinos.com.cn>
    Signed-off-by: Yunchuan Wen <wenyunchuan@kylinos.com.cn>
    Signed-off-by: Tyler Hicks <tyhicks@canonical.com>

diff --git a/fs/ecryptfs/mmap.c b/fs/ecryptfs/mmap.c
index bd1d57f98f74..564a1fa34b99 100644
--- a/fs/ecryptfs/mmap.c
+++ b/fs/ecryptfs/mmap.c
@@ -338,7 +338,8 @@ static int ecryptfs_write_begin(struct file *file,
 			if (prev_page_end_size
 			    >= i_size_read(page->mapping->host)) {
 				zero_user(page, 0, PAGE_CACHE_SIZE);
-			} else {
+				SetPageUptodate(page);
+			} else if (len < PAGE_CACHE_SIZE) {
 				rc = ecryptfs_decrypt_page(page);
 				if (rc) {
 					printk(KERN_ERR "%s: Error decrypting "
@@ -348,8 +349,8 @@ static int ecryptfs_write_begin(struct file *file,
 					ClearPageUptodate(page);
 					goto out;
 				}
+				SetPageUptodate(page);
 			}
-			SetPageUptodate(page);
 		}
 	}
 	/* If creating a page or more of holes, zero them out via truncate.
@@ -499,6 +500,13 @@ static int ecryptfs_write_end(struct file *file,
 		}
 		goto out;
 	}
+	if (!PageUptodate(page)) {
+		if (copied < PAGE_CACHE_SIZE) {
+			rc = 0;
+			goto out;
+		}
+		SetPageUptodate(page);
+	}
 	/* Fills in zeros if 'to' goes beyond inode size */
 	rc = fill_zeros_to_end_of_page(page, to);
 	if (rc) {

