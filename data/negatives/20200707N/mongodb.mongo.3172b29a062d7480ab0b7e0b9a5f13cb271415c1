commit 3172b29a062d7480ab0b7e0b9a5f13cb271415c1
Author: matt dannenberg <matt.dannenberg@10gen.com>
Date:   Thu Feb 20 08:02:26 2014 -0500

    SERVER-12650 locking to protect the fallback oplogreader

diff --git a/src/mongo/db/repl/bgsync.cpp b/src/mongo/db/repl/bgsync.cpp
index 24948e9fa9..1e76adb16b 100644
--- a/src/mongo/db/repl/bgsync.cpp
+++ b/src/mongo/db/repl/bgsync.cpp
@@ -152,7 +152,10 @@ namespace replset {
         // It also sets the supportsUpdater flag so we know which method to use.
         // If this function fails, we ignore that situation because it will be taken care of
         // the first time markOplog() is called in the loop below.
-        connectOplogNotifier();
+        {
+            boost::unique_lock<boost::mutex> oplogLockSSF(theReplSet->syncSourceFeedback.oplock);
+            connectOplogNotifier();
+        }
         theReplSet->syncSourceFeedback.go();
 
         while (!inShutdown()) {
@@ -208,7 +211,9 @@ namespace replset {
             theReplSet->syncSourceFeedback.updateSelfInMap(theReplSet->lastOpTimeWritten);
         }
         else {
+            boost::unique_lock<boost::mutex> oplogLockSSF(theReplSet->syncSourceFeedback.oplock);
             if (!hasCursor()) {
+                oplogLockSSF.unlock();
                 sleepmillis(500);
                 return;
             }
@@ -563,6 +568,8 @@ namespace replset {
                 boost::unique_lock<boost::mutex> lock(_mutex);
                 _currentSyncTarget = target;
             }
+
+            boost::unique_lock<boost::mutex> oplogLockSSF(theReplSet->syncSourceFeedback.oplock);
             theReplSet->syncSourceFeedback.connect(target);
 
             return;
diff --git a/src/mongo/db/repl/sync_source_feedback.h b/src/mongo/db/repl/sync_source_feedback.h
index e16f988874..8238952e0b 100644
--- a/src/mongo/db/repl/sync_source_feedback.h
+++ b/src/mongo/db/repl/sync_source_feedback.h
@@ -132,6 +132,15 @@ namespace mongo {
             _oplogReader->tailingQueryGTE(ns, t, fields);
         }
 
+        /** 
+        * this mutex protects the _conn field of _oplogReader in that we cannot mix the functions
+        * which check _conn for null (commonConnect() and connect() do this) with the function that
+        * sets the pointer to null (resetConnection()). All other uses of the _oplogReader's _conn
+        * do not need the mutex locked, due to the threading logic that prevents _connect()
+        * from being called concurrently.
+        */
+        boost::mutex oplock;
+
     private:
         /**
          * Authenticates _connection using the server's cluster-membership credentials.

