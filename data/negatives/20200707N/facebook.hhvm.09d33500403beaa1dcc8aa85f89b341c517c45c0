commit 09d33500403beaa1dcc8aa85f89b341c517c45c0
Author: Rick Lavoie <rlavoie@fb.com>
Date:   Mon Mar 13 16:15:11 2017 -0700

    Fix broken HHBBC local base tracking
    
    Summary:
    setLocalForBase() in HHBBC (which is responsible for updating the type of a
    local being used as a base in a member instruction sequence) drops all the known
    information about locals if the local isn't definitely known. However, it tests
    for this using !env.state.base.local. This worked back when env.state.base.local
    was a pointer, but its now an integer. So, what its doing now is dropping all
    the known information about locals if the base is the first local. Do the proper
    check against NoLocalId instead.
    
    This exposed another bug where we weren't widening Hack array types properly, meaning HHBBC could get into an infinite loop building ever larger specialized types.
    
    Reviewed By: markw65
    
    Differential Revision: D4696131
    
    fbshipit-source-id: 49d6616d2a6b741cfcc7b80e91c92c3529da3bae

diff --git a/hphp/hhbbc/interp-minstr.cpp b/hphp/hhbbc/interp-minstr.cpp
index 52f728b8c4..77b66fca6a 100644
--- a/hphp/hhbbc/interp-minstr.cpp
+++ b/hphp/hhbbc/interp-minstr.cpp
@@ -389,7 +389,7 @@ void miThrow(ISS& env) {
 void setLocalForBase(ISS& env, Type ty) {
   assert(mustBeInFrame(env.state.base) ||
          env.state.base.loc == BaseLoc::LocalArrChain);
-  if (!env.state.base.local) return loseNonRefLocalTypes(env);
+  if (env.state.base.local == NoLocalId) return loseNonRefLocalTypes(env);
   setLoc(env, env.state.base.local, ty);
   FTRACE(4, "      ${} := {}\n",
     env.state.base.locName ? env.state.base.locName->data() : "$<unnamed>",
@@ -1489,7 +1489,11 @@ void in(ISS& env, const bc::BaseNC& op) {
   topC(env, op.arg1);
   readUnknownLocals(env);
   mayUseVV(env);
-  env.state.base = Base{TInitCell, BaseLoc::Frame};
+  env.state.base = Base { TInitCell,
+                          BaseLoc::Frame,
+                          TBottom,
+                          SString{},
+                          NoLocalId };
 }
 
 void in(ISS& env, const bc::BaseNL& op) {
@@ -1497,7 +1501,11 @@ void in(ISS& env, const bc::BaseNL& op) {
   locAsCell(env, op.loc1);
   readUnknownLocals(env);
   mayUseVV(env);
-  env.state.base = Base{TInitCell, BaseLoc::Frame};
+  env.state.base = Base { TInitCell,
+                          BaseLoc::Frame,
+                          TBottom,
+                          SString{},
+                          NoLocalId };
 }
 
 void in(ISS& env, const bc::BaseGC& op) {
diff --git a/hphp/hhbbc/type-system.cpp b/hphp/hhbbc/type-system.cpp
index a4dac70966..2805dbf97b 100644
--- a/hphp/hhbbc/type-system.cpp
+++ b/hphp/hhbbc/type-system.cpp
@@ -2300,16 +2300,17 @@ Type promote_emptyish(Type a, Type b) {
 Type widening_union(const Type& a, const Type& b) {
   if (a == b) return a;
 
+  auto const u = union_of(a, b);
+
   // Currently the only types in our typesystem that have infinitely
   // growing chains of union_of are specialized arrays.
-  if (!is_specialized_array(a) || !is_specialized_array(b)) {
-    return union_of(a, b);
+  if (!is_specialized_array_like(a) || !is_specialized_array_like(b)) {
+    return u;
   }
 
   // This (throwing away the data) is overly conservative, but works
   // for now.
-  auto const newBits = combine_arr_bits(a.m_bits, b.m_bits);
-  return Type { newBits };
+  return is_specialized_array_like(u) ? Type { u.m_bits } : u;
 }
 
 Type stack_flav(Type a) {
@@ -2801,6 +2802,8 @@ std::pair<Type,bool> array_like_set(Type arr,
                        union_of(inVal, val)), validKey };
   };
 
+  arr.m_bits = bits;
+
   switch (arr.m_dataTag) {
   case DataTag::Str:
   case DataTag::Obj:
@@ -2811,7 +2814,6 @@ std::pair<Type,bool> array_like_set(Type arr,
     not_reached();
 
   case DataTag::None:
-    arr.m_bits = bits;
     return { std::move(arr), false };
 
   case DataTag::ArrLikeVal:
@@ -2859,6 +2861,7 @@ std::pair<Type,bool> array_like_set(Type arr,
     if (maybeEmpty) {
       return emptyHelper(arr.m_data.mapn->key, arr.m_data.mapn->val);
     } else {
+      arr.m_bits = bits;
       auto const inRange = arr_mapn_set(arr, key, val);
       return { std::move(arr), inRange };
     }
@@ -2941,7 +2944,6 @@ std::pair<Type,Type> array_like_newelem(Type arr, const Type& val) {
 
   case DataTag::ArrLikePacked:
     if (maybeEmpty) {
-      auto ty = packed_values(*arr.m_data.packed);
       return emptyHelper(TInt, packed_values(*arr.m_data.packed));
     } else {
       arr.m_bits = bits;
@@ -2967,6 +2969,7 @@ std::pair<Type,Type> array_like_newelem(Type arr, const Type& val) {
       auto mkv = map_key_values(*arr.m_data.map);
       return emptyHelper(mkv.first, mkv.second);
     } else {
+      arr.m_bits = bits;
       auto const idx = arr_map_newelem(arr, val);
       return { std::move(arr), idx };
     }

