commit a621aaed690b9439141c555941b6af53873f6ff1
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Thu Jan 12 18:43:35 2006 +0000

    [MMC+MFD] Convert mmc to mutexes
    
    convert mfd and mmc to mutexes
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/mfd/ucb1x00-core.c b/drivers/mfd/ucb1x00-core.c
index b42e0fbab59b..aff83f966803 100644
--- a/drivers/mfd/ucb1x00-core.c
+++ b/drivers/mfd/ucb1x00-core.c
@@ -24,13 +24,14 @@
 #include <linux/errno.h>
 #include <linux/interrupt.h>
 #include <linux/device.h>
+#include <linux/mutex.h>
 
 #include <asm/dma.h>
 #include <asm/hardware.h>
 
 #include "ucb1x00.h"
 
-static DECLARE_MUTEX(ucb1x00_sem);
+static DEFINE_MUTEX(ucb1x00_mutex);
 static LIST_HEAD(ucb1x00_drivers);
 static LIST_HEAD(ucb1x00_devices);
 
@@ -521,12 +522,12 @@ static int ucb1x00_probe(struct mcp *mcp)
 		goto err_irq;
 
 	INIT_LIST_HEAD(&ucb->devs);
-	down(&ucb1x00_sem);
+	mutex_lock(&ucb1x00_mutex);
 	list_add(&ucb->node, &ucb1x00_devices);
 	list_for_each_entry(drv, &ucb1x00_drivers, node) {
 		ucb1x00_add_dev(ucb, drv);
 	}
-	up(&ucb1x00_sem);
+	mutex_unlock(&ucb1x00_mutex);
 	goto out;
 
  err_irq:
@@ -544,13 +545,13 @@ static void ucb1x00_remove(struct mcp *mcp)
 	struct ucb1x00 *ucb = mcp_get_drvdata(mcp);
 	struct list_head *l, *n;
 
-	down(&ucb1x00_sem);
+	mutex_lock(&ucb1x00_mutex);
 	list_del(&ucb->node);
 	list_for_each_safe(l, n, &ucb->devs) {
 		struct ucb1x00_dev *dev = list_entry(l, struct ucb1x00_dev, dev_node);
 		ucb1x00_remove_dev(dev);
 	}
-	up(&ucb1x00_sem);
+	mutex_unlock(&ucb1x00_mutex);
 
 	free_irq(ucb->irq, ucb);
 	class_device_unregister(&ucb->cdev);
@@ -561,12 +562,12 @@ int ucb1x00_register_driver(struct ucb1x00_driver *drv)
 	struct ucb1x00 *ucb;
 
 	INIT_LIST_HEAD(&drv->devs);
-	down(&ucb1x00_sem);
+	mutex_lock(&ucb1x00_mutex);
 	list_add(&drv->node, &ucb1x00_drivers);
 	list_for_each_entry(ucb, &ucb1x00_devices, node) {
 		ucb1x00_add_dev(ucb, drv);
 	}
-	up(&ucb1x00_sem);
+	mutex_unlock(&ucb1x00_mutex);
 	return 0;
 }
 
@@ -574,13 +575,13 @@ void ucb1x00_unregister_driver(struct ucb1x00_driver *drv)
 {
 	struct list_head *n, *l;
 
-	down(&ucb1x00_sem);
+	mutex_lock(&ucb1x00_mutex);
 	list_del(&drv->node);
 	list_for_each_safe(l, n, &drv->devs) {
 		struct ucb1x00_dev *dev = list_entry(l, struct ucb1x00_dev, drv_node);
 		ucb1x00_remove_dev(dev);
 	}
-	up(&ucb1x00_sem);
+	mutex_unlock(&ucb1x00_mutex);
 }
 
 static int ucb1x00_suspend(struct mcp *mcp, pm_message_t state)
@@ -588,12 +589,12 @@ static int ucb1x00_suspend(struct mcp *mcp, pm_message_t state)
 	struct ucb1x00 *ucb = mcp_get_drvdata(mcp);
 	struct ucb1x00_dev *dev;
 
-	down(&ucb1x00_sem);
+	mutex_lock(&ucb1x00_mutex);
 	list_for_each_entry(dev, &ucb->devs, dev_node) {
 		if (dev->drv->suspend)
 			dev->drv->suspend(dev, state);
 	}
-	up(&ucb1x00_sem);
+	mutex_unlock(&ucb1x00_mutex);
 	return 0;
 }
 
@@ -602,12 +603,12 @@ static int ucb1x00_resume(struct mcp *mcp)
 	struct ucb1x00 *ucb = mcp_get_drvdata(mcp);
 	struct ucb1x00_dev *dev;
 
-	down(&ucb1x00_sem);
+	mutex_lock(&ucb1x00_mutex);
 	list_for_each_entry(dev, &ucb->devs, dev_node) {
 		if (dev->drv->resume)
 			dev->drv->resume(dev);
 	}
-	up(&ucb1x00_sem);
+	mutex_unlock(&ucb1x00_mutex);
 	return 0;
 }
 
diff --git a/drivers/mmc/mmc_block.c b/drivers/mmc/mmc_block.c
index f2c42b13945d..9b7c37e0e574 100644
--- a/drivers/mmc/mmc_block.c
+++ b/drivers/mmc/mmc_block.c
@@ -28,6 +28,7 @@
 #include <linux/kdev_t.h>
 #include <linux/blkdev.h>
 #include <linux/devfs_fs_kernel.h>
+#include <linux/mutex.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/protocol.h>
@@ -57,33 +58,33 @@ struct mmc_blk_data {
 	unsigned int	read_only;
 };
 
-static DECLARE_MUTEX(open_lock);
+static DEFINE_MUTEX(open_lock);
 
 static struct mmc_blk_data *mmc_blk_get(struct gendisk *disk)
 {
 	struct mmc_blk_data *md;
 
-	down(&open_lock);
+	mutex_lock(&open_lock);
 	md = disk->private_data;
 	if (md && md->usage == 0)
 		md = NULL;
 	if (md)
 		md->usage++;
-	up(&open_lock);
+	mutex_unlock(&open_lock);
 
 	return md;
 }
 
 static void mmc_blk_put(struct mmc_blk_data *md)
 {
-	down(&open_lock);
+	mutex_lock(&open_lock);
 	md->usage--;
 	if (md->usage == 0) {
 		put_disk(md->disk);
 		mmc_cleanup_queue(&md->queue);
 		kfree(md);
 	}
-	up(&open_lock);
+	mutex_unlock(&open_lock);
 }
 
 static int mmc_blk_open(struct inode *inode, struct file *filp)

