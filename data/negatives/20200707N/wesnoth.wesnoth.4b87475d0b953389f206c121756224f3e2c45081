commit 4b87475d0b953389f206c121756224f3e2c45081
Author: JaMiT <jt_coding@zoho.com>
Date:   Sat Aug 24 01:59:22 2013 -0500

    Add the function utils::might_contain_variables().
    
    This function does a quick, but imprecise, check to see if a string
    might change after variable interpolation. If this function returns
    false, it is safe to assume the string will not change.
    
    I thought I saw another function that does this, but I cannot find it.
    
    The usecase I have in mind is where a string will persist for a while,
    perhaps for an entire scenario, where optimizations could be made if
    the string was constant, and where variables would be uncommon (with
    "uncommon" relative to the size of the optimizations). For example,
    event names seem to fit.

diff --git a/src/formula_string_utils.hpp b/src/formula_string_utils.hpp
index be0fa03804..19f9e471a7 100644
--- a/src/formula_string_utils.hpp
+++ b/src/formula_string_utils.hpp
@@ -22,6 +22,19 @@ class variable_set;
 
 namespace utils {
 
+/**
+ * Determines if a string might contain variables to interpolate.
+ * This can allow one to skip future interpolations (plural -- if there is only
+ * one interpolation, the savings are not worth this check). In this spirit,
+ * precision is sacrificed in the name of efficiency; the check is quick and
+ * allows false positives, but there are no false negatives. (A false negative
+ * would lead to incorrect behavior, whereas a false positive leads to merely
+ * inefficient behavior.) In practice, false positives should be uncommon enough
+ * to not worry about.
+ */
+inline bool might_contain_variables(const std::string &str)
+{ return str.find('$') != std::string::npos; }
+
 /**
  * Function which will interpolate variables, starting with '$' in the string
  * 'str' with the equivalent symbols in the given symbol table. If 'symbols'

