commit a699d65ec4ff82245d2c4fdfb8ed1d64776d756e
Author: Trond Myklebust <trond.myklebust@primarydata.com>
Date:   Mon Feb 10 16:28:52 2014 -0500

    SUNRPC: Don't create a gss auth cache unless rpc.gssd is running
    
    An infinite loop is caused when nfs4_establish_lease() fails
    with -EACCES. This causes nfs4_handle_reclaim_lease_error()
    to sleep a bit and resets the NFS4CLNT_LEASE_EXPIRED bit.
    This in turn causes nfs4_state_manager() to try and
    reestablished the lease, again, again, again...
    
    The problem is a valid RPCSEC_GSS client is being created when
    rpc.gssd is not running.
    
    Link: http://lkml.kernel.org/r/1392066375-16502-1-git-send-email-steved@redhat.com
    Fixes: 0ea9de0ea6a4 (sunrpc: turn warn_gssd() log message into a dprintk())
    Reported-by: Steve Dickson <steved@redhat.com>
    Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

diff --git a/net/sunrpc/auth_gss/auth_gss.c b/net/sunrpc/auth_gss/auth_gss.c
index 6c0513a7f992..44a61e8fda6f 100644
--- a/net/sunrpc/auth_gss/auth_gss.c
+++ b/net/sunrpc/auth_gss/auth_gss.c
@@ -991,6 +991,8 @@ gss_create_new(struct rpc_auth_create_args *args, struct rpc_clnt *clnt)
 	gss_auth->service = gss_pseudoflavor_to_service(gss_auth->mech, flavor);
 	if (gss_auth->service == 0)
 		goto err_put_mech;
+	if (!gssd_running(gss_auth->net))
+		goto err_put_mech;
 	auth = &gss_auth->rpc_auth;
 	auth->au_cslack = GSS_CRED_SLACK >> 2;
 	auth->au_rslack = GSS_VERF_SLACK >> 2;

