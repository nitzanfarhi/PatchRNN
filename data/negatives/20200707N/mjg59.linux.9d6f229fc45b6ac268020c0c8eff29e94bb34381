commit 9d6f229fc45b6ac268020c0c8eff29e94bb34381
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Feb 9 23:24:35 2007 +0900

    [NET] BRIDGE: Fix whitespace errors.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_device.c b/net/bridge/br_device.c
index f8dbcee80eba..905a39c33a16 100644
--- a/net/bridge/br_device.c
+++ b/net/bridge/br_device.c
@@ -40,7 +40,7 @@ int br_dev_xmit(struct sk_buff *skb, struct net_device *dev)
 	skb->mac.raw = skb->data;
 	skb_pull(skb, ETH_HLEN);
 
-	if (dest[0] & 1) 
+	if (dest[0] & 1)
 		br_flood_deliver(br, skb, 0);
 	else if ((dst = __br_fdb_get(br, dest)) != NULL)
 		br_deliver(dst->dst, skb);
@@ -178,12 +178,12 @@ void br_dev_setup(struct net_device *dev)
 	dev->change_mtu = br_change_mtu;
 	dev->destructor = free_netdev;
 	SET_MODULE_OWNER(dev);
- 	SET_ETHTOOL_OPS(dev, &br_ethtool_ops);
+	SET_ETHTOOL_OPS(dev, &br_ethtool_ops);
 	dev->stop = br_dev_stop;
 	dev->tx_queue_len = 0;
 	dev->set_mac_address = br_set_mac_address;
 	dev->priv_flags = IFF_EBRIDGE;
 
- 	dev->features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |
- 			NETIF_F_TSO | NETIF_F_NO_CSUM | NETIF_F_GSO_ROBUST;
+	dev->features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |
+			NETIF_F_TSO | NETIF_F_NO_CSUM | NETIF_F_GSO_ROBUST;
 }
diff --git a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c
index 8ca448db7a0d..def2e403f932 100644
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@ -52,7 +52,7 @@ static __inline__ unsigned long hold_time(const struct net_bridge *br)
 static __inline__ int has_expired(const struct net_bridge *br,
 				  const struct net_bridge_fdb_entry *fdb)
 {
-	return !fdb->is_static 
+	return !fdb->is_static
 		&& time_before_eq(fdb->ageing_timer + hold_time(br), jiffies);
 }
 
@@ -71,7 +71,7 @@ void br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr)
 {
 	struct net_bridge *br = p->br;
 	int i;
-	
+
 	spin_lock_bh(&br->hash_lock);
 
 	/* Search all chains since old address/hash is unknown */
@@ -85,7 +85,7 @@ void br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr)
 				/* maybe another port has same hw addr? */
 				struct net_bridge_port *op;
 				list_for_each_entry(op, &br->port_list, list) {
-					if (op != p && 
+					if (op != p &&
 					    !compare_ether_addr(op->dev->dev_addr,
 								f->addr.addr)) {
 						f->dst = op;
@@ -118,8 +118,8 @@ void br_fdb_cleanup(unsigned long _data)
 		struct hlist_node *h, *n;
 
 		hlist_for_each_entry_safe(f, h, n, &br->hash[i], hlist) {
-			if (!f->is_static && 
-			    time_before_eq(f->ageing_timer + delay, jiffies)) 
+			if (!f->is_static &&
+			    time_before_eq(f->ageing_timer + delay, jiffies))
 				fdb_delete(f);
 		}
 	}
@@ -138,11 +138,11 @@ void br_fdb_delete_by_port(struct net_bridge *br,
 	spin_lock_bh(&br->hash_lock);
 	for (i = 0; i < BR_HASH_SIZE; i++) {
 		struct hlist_node *h, *g;
-		
+
 		hlist_for_each_safe(h, g, &br->hash[i]) {
 			struct net_bridge_fdb_entry *f
 				= hlist_entry(h, struct net_bridge_fdb_entry, hlist);
-			if (f->dst != p) 
+			if (f->dst != p)
 				continue;
 
 			if (f->is_static && !do_all)
@@ -155,7 +155,7 @@ void br_fdb_delete_by_port(struct net_bridge *br,
 			if (f->is_local) {
 				struct net_bridge_port *op;
 				list_for_each_entry(op, &br->port_list, list) {
-					if (op != p && 
+					if (op != p &&
 					    !compare_ether_addr(op->dev->dev_addr,
 								f->addr.addr)) {
 						f->dst = op;
@@ -190,14 +190,14 @@ struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,
 }
 
 /* Interface used by ATM hook that keeps a ref count */
-struct net_bridge_fdb_entry *br_fdb_get(struct net_bridge *br, 
+struct net_bridge_fdb_entry *br_fdb_get(struct net_bridge *br,
 					unsigned char *addr)
 {
 	struct net_bridge_fdb_entry *fdb;
 
 	rcu_read_lock();
 	fdb = __br_fdb_get(br, addr);
-	if (fdb) 
+	if (fdb)
 		atomic_inc(&fdb->use_count);
 	rcu_read_unlock();
 	return fdb;
@@ -218,7 +218,7 @@ void br_fdb_put(struct net_bridge_fdb_entry *ent)
 }
 
 /*
- * Fill buffer with forwarding table records in 
+ * Fill buffer with forwarding table records in
  * the API format.
  */
 int br_fdb_fillbuf(struct net_bridge *br, void *buf,
@@ -237,7 +237,7 @@ int br_fdb_fillbuf(struct net_bridge *br, void *buf,
 			if (num >= maxnum)
 				goto out;
 
-			if (has_expired(br, f)) 
+			if (has_expired(br, f))
 				continue;
 
 			if (skip) {
@@ -277,7 +277,7 @@ static inline struct net_bridge_fdb_entry *fdb_find(struct hlist_head *head,
 
 static struct net_bridge_fdb_entry *fdb_create(struct hlist_head *head,
 					       struct net_bridge_port *source,
-					       const unsigned char *addr, 
+					       const unsigned char *addr,
 					       int is_local)
 {
 	struct net_bridge_fdb_entry *fdb;
@@ -307,17 +307,17 @@ static int fdb_insert(struct net_bridge *br, struct net_bridge_port *source,
 
 	fdb = fdb_find(head, addr);
 	if (fdb) {
-		/* it is okay to have multiple ports with same 
+		/* it is okay to have multiple ports with same
 		 * address, just use the first one.
 		 */
-		if (fdb->is_local) 
+		if (fdb->is_local)
 			return 0;
 
 		printk(KERN_WARNING "%s adding interface with same address "
 		       "as a received packet\n",
 		       source->dev->name);
 		fdb_delete(fdb);
- 	}
+	}
 
 	if (!fdb_create(head, source, addr, 1))
 		return -ENOMEM;
@@ -350,7 +350,7 @@ void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
 	if (likely(fdb)) {
 		/* attempt to update an entry for a local interface */
 		if (unlikely(fdb->is_local)) {
-			if (net_ratelimit()) 
+			if (net_ratelimit())
 				printk(KERN_WARNING "%s: received packet with "
 				       " own address as source address\n",
 				       source->dev->name);
diff --git a/net/bridge/br_forward.c b/net/bridge/br_forward.c
index 191b861e5e53..3e45c1a1aa96 100644
--- a/net/bridge/br_forward.c
+++ b/net/bridge/br_forward.c
@@ -21,7 +21,7 @@
 #include "br_private.h"
 
 /* Don't forward packets to originating port or forwarding diasabled */
-static inline int should_deliver(const struct net_bridge_port *p, 
+static inline int should_deliver(const struct net_bridge_port *p,
 				 const struct sk_buff *skb)
 {
 	return (skb->dev != p->dev && p->state == BR_STATE_FORWARDING);
@@ -101,7 +101,7 @@ void br_forward(const struct net_bridge_port *to, struct sk_buff *skb)
 
 /* called under bridge lock */
 static void br_flood(struct net_bridge *br, struct sk_buff *skb, int clone,
-	void (*__packet_hook)(const struct net_bridge_port *p, 
+	void (*__packet_hook)(const struct net_bridge_port *p,
 			      struct sk_buff *skb))
 {
 	struct net_bridge_port *p;
diff --git a/net/bridge/br_if.c b/net/bridge/br_if.c
index 2b7c2c7dad48..f35c1a378d0f 100644
--- a/net/bridge/br_if.c
+++ b/net/bridge/br_if.c
@@ -47,7 +47,7 @@ static int port_cost(struct net_device *dev)
 	set_fs(KERNEL_DS);
 	err = dev_ethtool(&ifr);
 	set_fs(old_fs);
-	
+
 	if (!err) {
 		switch(ecmd.speed) {
 		case SPEED_100:
@@ -191,7 +191,7 @@ static void del_br(struct net_bridge *br)
 	del_timer_sync(&br->gc_timer);
 
 	br_sysfs_delbr(br->dev);
- 	unregister_netdevice(br->dev);
+	unregister_netdevice(br->dev);
 }
 
 static struct net_device *new_bridge_dev(const char *name)
@@ -201,7 +201,7 @@ static struct net_device *new_bridge_dev(const char *name)
 
 	dev = alloc_netdev(sizeof(struct net_bridge), name,
 			   br_dev_setup);
-	
+
 	if (!dev)
 		return NULL;
 
@@ -258,12 +258,12 @@ static int find_portno(struct net_bridge *br)
 }
 
 /* called with RTNL but without bridge lock */
-static struct net_bridge_port *new_nbp(struct net_bridge *br, 
+static struct net_bridge_port *new_nbp(struct net_bridge *br,
 				       struct net_device *dev)
 {
 	int index;
 	struct net_bridge_port *p;
-	
+
 	index = find_portno(br);
 	if (index < 0)
 		return ERR_PTR(index);
@@ -276,7 +276,7 @@ static struct net_bridge_port *new_nbp(struct net_bridge *br,
 	dev_hold(dev);
 	p->dev = dev;
 	p->path_cost = port_cost(dev);
- 	p->priority = 0x8000 >> BR_PORT_BITS;
+	p->priority = 0x8000 >> BR_PORT_BITS;
 	p->port_no = index;
 	br_init_port(p);
 	p->state = BR_STATE_DISABLED;
@@ -298,7 +298,7 @@ int br_add_bridge(const char *name)
 	int ret;
 
 	dev = new_bridge_dev(name);
-	if (!dev) 
+	if (!dev)
 		return -ENOMEM;
 
 	rtnl_lock();
@@ -329,7 +329,7 @@ int br_del_bridge(const char *name)
 
 	rtnl_lock();
 	dev = __dev_get_by_name(name);
-	if (dev == NULL) 
+	if (dev == NULL)
 		ret =  -ENXIO; 	/* Could not find device */
 
 	else if (!(dev->priv_flags & IFF_EBRIDGE)) {
@@ -340,9 +340,9 @@ int br_del_bridge(const char *name)
 	else if (dev->flags & IFF_UP) {
 		/* Not shutdown yet. */
 		ret = -EBUSY;
-	} 
+	}
 
-	else 
+	else
 		del_br(netdev_priv(dev));
 
 	rtnl_unlock();
@@ -428,7 +428,7 @@ int br_add_if(struct net_bridge *br, struct net_device *dev)
 	if (err)
 		goto err0;
 
- 	err = br_fdb_insert(br, p, dev->dev_addr);
+	err = br_fdb_insert(br, p, dev->dev_addr);
 	if (err)
 		goto err1;
 
@@ -464,8 +464,8 @@ err0:
 int br_del_if(struct net_bridge *br, struct net_device *dev)
 {
 	struct net_bridge_port *p = dev->br_port;
-	
-	if (!p || p->br != br) 
+
+	if (!p || p->br != br)
 		return -EINVAL;
 
 	del_nbp(p);
diff --git a/net/bridge/br_input.c b/net/bridge/br_input.c
index bfa4d8c333f7..35b94f9a1ac5 100644
--- a/net/bridge/br_input.c
+++ b/net/bridge/br_input.c
@@ -119,7 +119,7 @@ static inline int is_link_local(const unsigned char *dest)
  * Called via br_handle_frame_hook.
  * Return 0 if *pskb should be processed furthur
  *	  1 if *pskb is handled
- * note: already called with rcu_read_lock (preempt_disabled) 
+ * note: already called with rcu_read_lock (preempt_disabled)
  */
 int br_handle_frame(struct net_bridge_port *p, struct sk_buff **pskb)
 {
@@ -137,7 +137,7 @@ int br_handle_frame(struct net_bridge_port *p, struct sk_buff **pskb)
 
 	if (p->state == BR_STATE_FORWARDING || p->state == BR_STATE_LEARNING) {
 		if (br_should_route_hook) {
-			if (br_should_route_hook(pskb)) 
+			if (br_should_route_hook(pskb))
 				return 0;
 			skb = *pskb;
 			dest = eth_hdr(skb)->h_dest;
diff --git a/net/bridge/br_ioctl.c b/net/bridge/br_ioctl.c
index 4c61a7e0a86e..3ab153d3c508 100644
--- a/net/bridge/br_ioctl.c
+++ b/net/bridge/br_ioctl.c
@@ -28,7 +28,7 @@ static int get_bridge_ifindices(int *indices, int num)
 	int i = 0;
 
 	for (dev = dev_base; dev && i < num; dev = dev->next) {
-		if (dev->priv_flags & IFF_EBRIDGE) 
+		if (dev->priv_flags & IFF_EBRIDGE)
 			indices[i++] = dev->ifindex;
 	}
 
@@ -53,7 +53,7 @@ static void get_port_ifindices(struct net_bridge *br, int *ifindices, int num)
  *            (limited to a page for sanity)
  * offset  -- number of records to skip
  */
-static int get_fdb_entries(struct net_bridge *br, void __user *userbuf, 
+static int get_fdb_entries(struct net_bridge *br, void __user *userbuf,
 			   unsigned long maxnum, unsigned long offset)
 {
 	int num;
@@ -69,7 +69,7 @@ static int get_fdb_entries(struct net_bridge *br, void __user *userbuf,
 	buf = kmalloc(size, GFP_USER);
 	if (!buf)
 		return -ENOMEM;
-	
+
 	num = br_fdb_fillbuf(br, buf, maxnum, offset);
 	if (num > 0) {
 		if (copy_to_user(userbuf, buf, num*sizeof(struct __fdb_entry)))
@@ -91,7 +91,7 @@ static int add_del_if(struct net_bridge *br, int ifindex, int isadd)
 	dev = dev_get_by_index(ifindex);
 	if (dev == NULL)
 		return -EINVAL;
-	
+
 	if (isadd)
 		ret = br_add_if(br, dev);
 	else
@@ -110,7 +110,7 @@ static int old_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	struct net_bridge *br = netdev_priv(dev);
 	unsigned long args[4];
-	
+
 	if (copy_from_user(args, rq->ifr_data, sizeof(args)))
 		return -EFAULT;
 
@@ -143,7 +143,7 @@ static int old_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 		b.tcn_timer_value = br_timer_value(&br->tcn_timer);
 		b.topology_change_timer_value = br_timer_value(&br->topology_change_timer);
 		b.gc_timer_value = br_timer_value(&br->gc_timer);
-	        rcu_read_unlock();
+		rcu_read_unlock();
 
 		if (copy_to_user((void __user *)args[1], &b, sizeof(b)))
 			return -EFAULT;
@@ -275,7 +275,7 @@ static int old_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 			return -ERANGE;
 
 		spin_lock_bh(&br->lock);
-		if ((p = br_get_port(br, args[1])) == NULL) 
+		if ((p = br_get_port(br, args[1])) == NULL)
 			ret = -EINVAL;
 		else
 			br_stp_set_port_priority(p, args[2]);
@@ -301,7 +301,7 @@ static int old_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	}
 
 	case BRCTL_GET_FDB_ENTRIES:
-		return get_fdb_entries(br, (void __user *)args[1], 
+		return get_fdb_entries(br, (void __user *)args[1],
 				       args[2], args[3]);
 	}
 
@@ -368,7 +368,7 @@ int br_ioctl_deviceless_stub(unsigned int cmd, void __user *uarg)
 	case SIOCGIFBR:
 	case SIOCSIFBR:
 		return old_deviceless(uarg);
-		
+
 	case SIOCBRADDBR:
 	case SIOCBRDELBR:
 	{
diff --git a/net/bridge/br_netfilter.c b/net/bridge/br_netfilter.c
index a25fa8cb5284..a0744e653f09 100644
--- a/net/bridge/br_netfilter.c
+++ b/net/bridge/br_netfilter.c
@@ -68,7 +68,7 @@ static __be16 inline vlan_proto(const struct sk_buff *skb)
 
 #define IS_VLAN_IP(skb) \
 	(skb->protocol == htons(ETH_P_8021Q) && \
- 	 vlan_proto(skb) == htons(ETH_P_IP) && 	\
+	 vlan_proto(skb) == htons(ETH_P_IP) && 	\
 	 brnf_filter_vlan_tagged)
 
 #define IS_VLAN_IPV6(skb) \
@@ -124,7 +124,7 @@ static inline struct nf_bridge_info *nf_bridge_alloc(struct sk_buff *skb)
 
 static inline void nf_bridge_save_header(struct sk_buff *skb)
 {
-        int header_size = ETH_HLEN;
+	int header_size = ETH_HLEN;
 
 	if (skb->protocol == htons(ETH_P_8021Q))
 		header_size += VLAN_HLEN;
@@ -139,7 +139,7 @@ static inline void nf_bridge_save_header(struct sk_buff *skb)
 int nf_bridge_copy_header(struct sk_buff *skb)
 {
 	int err;
-        int header_size = ETH_HLEN;
+	int header_size = ETH_HLEN;
 
 	if (skb->protocol == htons(ETH_P_8021Q))
 		header_size += VLAN_HLEN;
@@ -836,10 +836,10 @@ static unsigned int ip_sabotage_in(unsigned int hook, struct sk_buff **pskb,
  * For br_nf_post_routing, we need (prio = NF_BR_PRI_LAST), because
  * ip_refrag() can return NF_STOLEN. */
 static struct nf_hook_ops br_nf_ops[] = {
-	{ .hook = br_nf_pre_routing, 
-	  .owner = THIS_MODULE, 
-	  .pf = PF_BRIDGE, 
-	  .hooknum = NF_BR_PRE_ROUTING, 
+	{ .hook = br_nf_pre_routing,
+	  .owner = THIS_MODULE,
+	  .pf = PF_BRIDGE,
+	  .hooknum = NF_BR_PRE_ROUTING,
 	  .priority = NF_BR_PRI_BRNF, },
 	{ .hook = br_nf_local_in,
 	  .owner = THIS_MODULE,
diff --git a/net/bridge/br_notify.c b/net/bridge/br_notify.c
index 20278494e4da..8cd3e4229070 100644
--- a/net/bridge/br_notify.c
+++ b/net/bridge/br_notify.c
@@ -26,7 +26,7 @@ struct notifier_block br_device_notifier = {
 
 /*
  * Handle changes in state of network devices enslaved to a bridge.
- * 
+ *
  * Note: don't care about up/down if bridge itself is down, because
  *     port state is checked when bridge is brought up.
  */
@@ -60,11 +60,11 @@ static int br_device_event(struct notifier_block *unused, unsigned long event, v
 		break;
 
 	case NETDEV_FEAT_CHANGE:
-		if (br->dev->flags & IFF_UP) 
+		if (br->dev->flags & IFF_UP)
 			br_features_recompute(br);
 
 		/* could do recursive feature change notification
-		 * but who would care?? 
+		 * but who would care??
 		 */
 		break;
 
@@ -74,7 +74,7 @@ static int br_device_event(struct notifier_block *unused, unsigned long event, v
 		break;
 
 	case NETDEV_UP:
-		if (netif_carrier_ok(dev) && (br->dev->flags & IFF_UP)) 
+		if (netif_carrier_ok(dev) && (br->dev->flags & IFF_UP))
 			br_stp_enable_port(p);
 		break;
 
@@ -82,7 +82,7 @@ static int br_device_event(struct notifier_block *unused, unsigned long event, v
 		spin_unlock_bh(&br->lock);
 		br_del_if(br, dev);
 		goto done;
-	} 
+	}
 	spin_unlock_bh(&br->lock);
 
  done:
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 3a534e94c7f3..6a0540e0591e 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -149,7 +149,7 @@ extern struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,
 extern struct net_bridge_fdb_entry *br_fdb_get(struct net_bridge *br,
 					       unsigned char *addr);
 extern void br_fdb_put(struct net_bridge_fdb_entry *ent);
-extern int br_fdb_fillbuf(struct net_bridge *br, void *buf, 
+extern int br_fdb_fillbuf(struct net_bridge *br, void *buf,
 			  unsigned long count, unsigned long off);
 extern int br_fdb_insert(struct net_bridge *br,
 			 struct net_bridge_port *source,
@@ -203,7 +203,7 @@ extern void br_netfilter_fini(void);
 /* br_stp.c */
 extern void br_log_state(const struct net_bridge_port *p);
 extern struct net_bridge_port *br_get_port(struct net_bridge *br,
-				    	   u16 port_no);
+					   u16 port_no);
 extern void br_init_port(struct net_bridge_port *p);
 extern void br_become_designated_port(struct net_bridge_port *p);
 
diff --git a/net/bridge/br_stp.c b/net/bridge/br_stp.c
index 04ca0639a95a..f9ff4d57b0d7 100644
--- a/net/bridge/br_stp.c
+++ b/net/bridge/br_stp.c
@@ -24,17 +24,17 @@
 #define MESSAGE_AGE_INCR	((HZ < 256) ? 1 : (HZ/256))
 
 static const char *br_port_state_names[] = {
-	[BR_STATE_DISABLED] = "disabled", 
+	[BR_STATE_DISABLED] = "disabled",
 	[BR_STATE_LISTENING] = "listening",
-	[BR_STATE_LEARNING] = "learning", 
-	[BR_STATE_FORWARDING] = "forwarding", 
+	[BR_STATE_LEARNING] = "learning",
+	[BR_STATE_FORWARDING] = "forwarding",
 	[BR_STATE_BLOCKING] = "blocking",
 };
 
 void br_log_state(const struct net_bridge_port *p)
 {
 	pr_info("%s: port %d(%s) entering %s state\n",
-		p->br->dev->name, p->port_no, p->dev->name, 
+		p->br->dev->name, p->port_no, p->dev->name,
 		br_port_state_names[p->state]);
 
 }
@@ -53,7 +53,7 @@ struct net_bridge_port *br_get_port(struct net_bridge *br, u16 port_no)
 }
 
 /* called under bridge lock */
-static int br_should_become_root_port(const struct net_bridge_port *p, 
+static int br_should_become_root_port(const struct net_bridge_port *p,
 				      u16 root_port)
 {
 	struct net_bridge *br;
@@ -184,7 +184,7 @@ void br_transmit_config(struct net_bridge_port *p)
 }
 
 /* called under bridge lock */
-static inline void br_record_config_information(struct net_bridge_port *p, 
+static inline void br_record_config_information(struct net_bridge_port *p,
 						const struct br_config_bpdu *bpdu)
 {
 	p->designated_root = bpdu->root;
@@ -192,12 +192,12 @@ static inline void br_record_config_information(struct net_bridge_port *p,
 	p->designated_bridge = bpdu->bridge_id;
 	p->designated_port = bpdu->port_id;
 
-	mod_timer(&p->message_age_timer, jiffies 
+	mod_timer(&p->message_age_timer, jiffies
 		  + (p->br->max_age - bpdu->message_age));
 }
 
 /* called under bridge lock */
-static inline void br_record_config_timeout_values(struct net_bridge *br, 
+static inline void br_record_config_timeout_values(struct net_bridge *br,
 					    const struct br_config_bpdu *bpdu)
 {
 	br->max_age = bpdu->max_age;
@@ -415,7 +415,7 @@ void br_received_config_bpdu(struct net_bridge_port *p, struct br_config_bpdu *b
 {
 	struct net_bridge *br;
 	int was_root;
- 
+
 	br = p->br;
 	was_root = br_is_root_bridge(br);
 
@@ -430,7 +430,7 @@ void br_received_config_bpdu(struct net_bridge_port *p, struct br_config_bpdu *b
 				del_timer(&br->topology_change_timer);
 				br_transmit_tcn(br);
 
-				mod_timer(&br->tcn_timer, 
+				mod_timer(&br->tcn_timer,
 					  jiffies + br->bridge_hello_time);
 			}
 		}
@@ -441,8 +441,8 @@ void br_received_config_bpdu(struct net_bridge_port *p, struct br_config_bpdu *b
 			if (bpdu->topology_change_ack)
 				br_topology_change_acknowledged(br);
 		}
-	} else if (br_is_designated_port(p)) {		
-		br_reply(p);		
+	} else if (br_is_designated_port(p)) {
+		br_reply(p);
 	}
 }
 
diff --git a/net/bridge/br_stp_bpdu.c b/net/bridge/br_stp_bpdu.c
index 068d8afbf0a7..b9fb0dc4ab12 100644
--- a/net/bridge/br_stp_bpdu.c
+++ b/net/bridge/br_stp_bpdu.c
@@ -29,7 +29,7 @@
 #define LLC_RESERVE sizeof(struct llc_pdu_un)
 
 static void br_send_bpdu(struct net_bridge_port *p,
- 			 const unsigned char *data, int length)
+			 const unsigned char *data, int length)
 {
 	struct sk_buff *skb;
 
diff --git a/net/bridge/br_stp_if.c b/net/bridge/br_stp_if.c
index d294224592db..58d13f2bd121 100644
--- a/net/bridge/br_stp_if.c
+++ b/net/bridge/br_stp_if.c
@@ -28,7 +28,7 @@
  */
 static inline port_id br_make_port_id(__u8 priority, __u16 port_no)
 {
-	return ((u16)priority << BR_PORT_BITS) 
+	return ((u16)priority << BR_PORT_BITS)
 		| (port_no & ((1<<BR_PORT_BITS)-1));
 }
 
@@ -50,7 +50,7 @@ void br_stp_enable_bridge(struct net_bridge *br)
 	spin_lock_bh(&br->lock);
 	mod_timer(&br->hello_timer, jiffies + br->hello_time);
 	mod_timer(&br->gc_timer, jiffies + HZ/10);
-	
+
 	br_config_bpdu_generation(br);
 
 	list_for_each_entry(p, &br->port_list, list) {
diff --git a/net/bridge/br_stp_timer.c b/net/bridge/br_stp_timer.c
index d0fcde82c6fc..030aa798fea7 100644
--- a/net/bridge/br_stp_timer.c
+++ b/net/bridge/br_stp_timer.c
@@ -27,7 +27,7 @@ static int br_is_designated_for_some_port(const struct net_bridge *br)
 
 	list_for_each_entry(p, &br->port_list, list) {
 		if (p->state != BR_STATE_DISABLED &&
-		    !memcmp(&p->designated_bridge, &br->bridge_id, 8)) 
+		    !memcmp(&p->designated_bridge, &br->bridge_id, 8))
 			return 1;
 	}
 
@@ -37,7 +37,7 @@ static int br_is_designated_for_some_port(const struct net_bridge *br)
 static void br_hello_timer_expired(unsigned long arg)
 {
 	struct net_bridge *br = (struct net_bridge *)arg;
-	
+
 	pr_debug("%s: hello timer expired\n", br->dev->name);
 	spin_lock(&br->lock);
 	if (br->dev->flags & IFF_UP) {
@@ -58,11 +58,11 @@ static void br_message_age_timer_expired(unsigned long arg)
 	if (p->state == BR_STATE_DISABLED)
 		return;
 
-	
+
 	pr_info("%s: neighbor %.2x%.2x.%.2x:%.2x:%.2x:%.2x:%.2x:%.2x lost on port %d(%s)\n",
-		br->dev->name, 
-		id->prio[0], id->prio[1], 
-		id->addr[0], id->addr[1], id->addr[2], 
+		br->dev->name,
+		id->prio[0], id->prio[1],
+		id->addr[0], id->addr[1], id->addr[2],
 		id->addr[3], id->addr[4], id->addr[5],
 		p->port_no, p->dev->name);
 
@@ -114,7 +114,7 @@ static void br_tcn_timer_expired(unsigned long arg)
 	spin_lock(&br->lock);
 	if (br->dev->flags & IFF_UP) {
 		br_transmit_tcn(br);
-	
+
 		mod_timer(&br->tcn_timer,jiffies + br->bridge_hello_time);
 	}
 	spin_unlock(&br->lock);
@@ -135,7 +135,7 @@ static void br_hold_timer_expired(unsigned long arg)
 {
 	struct net_bridge_port *p = (struct net_bridge_port *) arg;
 
-	pr_debug("%s: %d(%s) hold timer expired\n", 
+	pr_debug("%s: %d(%s) hold timer expired\n",
 		 p->br->dev->name,  p->port_no, p->dev->name);
 
 	spin_lock(&p->br->lock);
@@ -166,10 +166,10 @@ void br_stp_port_timer_init(struct net_bridge_port *p)
 
 	setup_timer(&p->forward_delay_timer, br_forward_delay_timer_expired,
 		      (unsigned long) p);
-		      
+
 	setup_timer(&p->hold_timer, br_hold_timer_expired,
 		      (unsigned long) p);
-}	
+}
 
 /* Report ticks left (in USER_HZ) used for API */
 unsigned long br_timer_value(const struct timer_list *timer)
diff --git a/net/bridge/br_sysfs_br.c b/net/bridge/br_sysfs_br.c
index ce10464716a7..01a22ad0cc75 100644
--- a/net/bridge/br_sysfs_br.c
+++ b/net/bridge/br_sysfs_br.c
@@ -353,19 +353,19 @@ static ssize_t brforward_read(struct kobject *kobj, char *buf,
 	if (off % sizeof(struct __fdb_entry) != 0)
 		return -EINVAL;
 
-	n =  br_fdb_fillbuf(br, buf, 
+	n =  br_fdb_fillbuf(br, buf,
 			    count / sizeof(struct __fdb_entry),
 			    off / sizeof(struct __fdb_entry));
 
 	if (n > 0)
 		n *= sizeof(struct __fdb_entry);
-	
+
 	return n;
 }
 
 static struct bin_attribute bridge_forward = {
 	.attr = { .name = SYSFS_BRIDGE_FDB,
-		  .mode = S_IRUGO, 
+		  .mode = S_IRUGO,
 		  .owner = THIS_MODULE, },
 	.read = brforward_read,
 };
@@ -401,7 +401,7 @@ int br_sysfs_addbr(struct net_device *dev)
 		goto out2;
 	}
 
-	
+
 	kobject_set_name(&br->ifobj, SYSFS_BRIDGE_PORT_SUBDIR);
 	br->ifobj.ktype = NULL;
 	br->ifobj.kset = NULL;
diff --git a/net/bridge/netfilter/ebt_802_3.c b/net/bridge/netfilter/ebt_802_3.c
index 9abbc09ccdc3..41a78072cd0e 100644
--- a/net/bridge/netfilter/ebt_802_3.c
+++ b/net/bridge/netfilter/ebt_802_3.c
@@ -5,7 +5,7 @@
  * Chris Vitale csv@bluetail.com
  *
  * May 2003
- * 
+ *
  */
 
 #include <linux/netfilter_bridge/ebtables.h>
@@ -20,7 +20,7 @@ static int ebt_filter_802_3(const struct sk_buff *skb, const struct net_device *
 	__be16 type = hdr->llc.ui.ctrl & IS_UI ? hdr->llc.ui.type : hdr->llc.ni.type;
 
 	if (info->bitmask & EBT_802_3_SAP) {
-		if (FWINV(info->sap != hdr->llc.ui.ssap, EBT_802_3_SAP)) 
+		if (FWINV(info->sap != hdr->llc.ui.ssap, EBT_802_3_SAP))
 				return EBT_NOMATCH;
 		if (FWINV(info->sap != hdr->llc.ui.dsap, EBT_802_3_SAP))
 				return EBT_NOMATCH;
@@ -29,7 +29,7 @@ static int ebt_filter_802_3(const struct sk_buff *skb, const struct net_device *
 	if (info->bitmask & EBT_802_3_TYPE) {
 		if (!(hdr->llc.ui.dsap == CHECK_TYPE && hdr->llc.ui.ssap == CHECK_TYPE))
 			return EBT_NOMATCH;
-		if (FWINV(info->type != type, EBT_802_3_TYPE)) 
+		if (FWINV(info->type != type, EBT_802_3_TYPE))
 			return EBT_NOMATCH;
 	}
 
diff --git a/net/bridge/netfilter/ebt_among.c b/net/bridge/netfilter/ebt_among.c
index ce97c4285f9a..392d877040d3 100644
--- a/net/bridge/netfilter/ebt_among.c
+++ b/net/bridge/netfilter/ebt_among.c
@@ -18,7 +18,7 @@ static int ebt_mac_wormhash_contains(const struct ebt_mac_wormhash *wh,
 				     const char *mac, __be32 ip)
 {
 	/* You may be puzzled as to how this code works.
-	 * Some tricks were used, refer to 
+	 * Some tricks were used, refer to
 	 * 	include/linux/netfilter_bridge/ebt_among.h
 	 * as there you can find a solution of this mystery.
 	 */
@@ -207,8 +207,8 @@ static int ebt_among_check(const char *tablename, unsigned int hookmask,
 }
 
 static struct ebt_match filter_among = {
-	.name		= EBT_AMONG_MATCH, 
-	.match		= ebt_filter_among, 
+	.name		= EBT_AMONG_MATCH,
+	.match		= ebt_filter_among,
 	.check		= ebt_among_check,
 	.me		= THIS_MODULE,
 };
diff --git a/net/bridge/netfilter/ebt_arpreply.c b/net/bridge/netfilter/ebt_arpreply.c
index 0aa7b9910a86..ffe468a632e7 100644
--- a/net/bridge/netfilter/ebt_arpreply.c
+++ b/net/bridge/netfilter/ebt_arpreply.c
@@ -51,7 +51,7 @@ static int ebt_target_reply(struct sk_buff **pskb, unsigned int hooknr,
 		return EBT_DROP;
 
 	arp_send(ARPOP_REPLY, ETH_P_ARP, *siptr, (struct net_device *)in,
-	         *diptr, shp, info->mac, shp);
+		 *diptr, shp, info->mac, shp);
 
 	return info->target;
 }
diff --git a/net/bridge/netfilter/ebt_ip.c b/net/bridge/netfilter/ebt_ip.c
index 6afa4d017d4a..69f7f0ab9c76 100644
--- a/net/bridge/netfilter/ebt_ip.c
+++ b/net/bridge/netfilter/ebt_ip.c
@@ -61,15 +61,15 @@ static int ebt_filter_ip(const struct sk_buff *skb, const struct net_device *in,
 		if (info->bitmask & EBT_IP_DPORT) {
 			u32 dst = ntohs(pptr->dst);
 			if (FWINV(dst < info->dport[0] ||
-			          dst > info->dport[1],
-			          EBT_IP_DPORT))
+				  dst > info->dport[1],
+				  EBT_IP_DPORT))
 			return EBT_NOMATCH;
 		}
 		if (info->bitmask & EBT_IP_SPORT) {
 			u32 src = ntohs(pptr->src);
 			if (FWINV(src < info->sport[0] ||
-			          src > info->sport[1],
-			          EBT_IP_SPORT))
+				  src > info->sport[1],
+				  EBT_IP_SPORT))
 			return EBT_NOMATCH;
 		}
 	}
diff --git a/net/bridge/netfilter/ebt_log.c b/net/bridge/netfilter/ebt_log.c
index 985df82e427b..f9a5ae9d5b6d 100644
--- a/net/bridge/netfilter/ebt_log.c
+++ b/net/bridge/netfilter/ebt_log.c
@@ -169,10 +169,10 @@ static void ebt_log(const struct sk_buff *skb, unsigned int hooknr,
 
 	if (info->bitmask & EBT_LOG_NFLOG)
 		nf_log_packet(PF_BRIDGE, hooknr, skb, in, out, &li,
-		              "%s", info->prefix);
+			      "%s", info->prefix);
 	else
 		ebt_log_packet(PF_BRIDGE, hooknr, skb, in, out, &li,
-		               info->prefix);
+			       info->prefix);
 }
 
 static struct ebt_watcher log =
@@ -199,7 +199,7 @@ static int __init ebt_log_init(void)
 	if (nf_log_register(PF_BRIDGE, &ebt_log_logger) < 0) {
 		printk(KERN_WARNING "ebt_log: not logging via system console "
 		       "since somebody else already registered for PF_INET\n");
-		/* we cannot make module load fail here, since otherwise 
+		/* we cannot make module load fail here, since otherwise
 		 * ebtables userspace would abort */
 	}
 
diff --git a/net/bridge/netfilter/ebt_mark_m.c b/net/bridge/netfilter/ebt_mark_m.c
index 025869ee0b68..6b0d2169af74 100644
--- a/net/bridge/netfilter/ebt_mark_m.c
+++ b/net/bridge/netfilter/ebt_mark_m.c
@@ -26,7 +26,7 @@ static int ebt_filter_mark(const struct sk_buff *skb,
 static int ebt_mark_check(const char *tablename, unsigned int hookmask,
    const struct ebt_entry *e, void *data, unsigned int datalen)
 {
-        struct ebt_mark_m_info *info = (struct ebt_mark_m_info *) data;
+	struct ebt_mark_m_info *info = (struct ebt_mark_m_info *) data;
 
 	if (datalen != EBT_ALIGN(sizeof(struct ebt_mark_m_info)))
 		return -EINVAL;
diff --git a/net/bridge/netfilter/ebt_stp.c b/net/bridge/netfilter/ebt_stp.c
index a0bed82145ed..31b77367319c 100644
--- a/net/bridge/netfilter/ebt_stp.c
+++ b/net/bridge/netfilter/ebt_stp.c
@@ -62,7 +62,7 @@ static int ebt_filter_config(struct ebt_stp_info *info,
 		verdict = 0;
 		for (i = 0; i < 6; i++)
 			verdict |= (stpc->root[2+i] ^ c->root_addr[i]) &
-			           c->root_addrmsk[i];
+				   c->root_addrmsk[i];
 		if (FWINV(verdict != 0, EBT_STP_ROOTADDR))
 			return EBT_NOMATCH;
 	}
@@ -82,7 +82,7 @@ static int ebt_filter_config(struct ebt_stp_info *info,
 		verdict = 0;
 		for (i = 0; i < 6; i++)
 			verdict |= (stpc->sender[2+i] ^ c->sender_addr[i]) &
-			           c->sender_addrmsk[i];
+				   c->sender_addrmsk[i];
 		if (FWINV(verdict != 0, EBT_STP_SENDERADDR))
 			return EBT_NOMATCH;
 	}
diff --git a/net/bridge/netfilter/ebt_ulog.c b/net/bridge/netfilter/ebt_ulog.c
index c1af68b5a29c..2e4cb24e191a 100644
--- a/net/bridge/netfilter/ebt_ulog.c
+++ b/net/bridge/netfilter/ebt_ulog.c
@@ -10,8 +10,8 @@
  * Based on ipt_ULOG.c, which is
  * (C) 2000-2002 by Harald Welte <laforge@netfilter.org>
  *
- * This module accepts two parameters: 
- * 
+ * This module accepts two parameters:
+ *
  * nlbufsiz:
  *   The parameter specifies how big the buffer for each netlink multicast
  * group is. e.g. If you say nlbufsiz=8192, up to eight kb of packets will
@@ -43,17 +43,17 @@
 #include "../br_private.h"
 
 #define PRINTR(format, args...) do { if (net_ratelimit()) \
-                                printk(format , ## args); } while (0)
+				printk(format , ## args); } while (0)
 
 static unsigned int nlbufsiz = NLMSG_GOODSIZE;
 module_param(nlbufsiz, uint, 0600);
 MODULE_PARM_DESC(nlbufsiz, "netlink buffer size (number of bytes) "
-                           "(defaults to 4096)");
+			   "(defaults to 4096)");
 
 static unsigned int flushtimeout = 10;
 module_param(flushtimeout, uint, 0600);
 MODULE_PARM_DESC(flushtimeout, "buffer flush timeout (hundredths ofa second) "
-                               "(defaults to 10)");
+			       "(defaults to 10)");
 
 typedef struct {
 	unsigned int qlen;		/* number of nlmsgs' in the skb */
@@ -157,7 +157,7 @@ static void ebt_ulog_packet(unsigned int hooknr, const struct sk_buff *skb,
 	}
 
 	nlh = NLMSG_PUT(ub->skb, 0, ub->qlen, 0,
-	                size - NLMSG_ALIGN(sizeof(*nlh)));
+			size - NLMSG_ALIGN(sizeof(*nlh)));
 	ub->qlen++;
 
 	pm = NLMSG_DATA(nlh);
@@ -302,7 +302,7 @@ static int __init ebt_ulog_init(void)
 	}
 
 	ebtulognl = netlink_kernel_create(NETLINK_NFLOG, EBT_ULOG_MAXNLGROUPS,
-	                                  NULL, THIS_MODULE);
+					  NULL, THIS_MODULE);
 	if (!ebtulognl)
 		ret = -ENOMEM;
 	else if ((ret = ebt_register_watcher(&ulog)))
@@ -344,4 +344,4 @@ module_exit(ebt_ulog_fini);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Bart De Schuymer <bdschuym@pandora.be>");
 MODULE_DESCRIPTION("ebtables userspace logging module for bridged Ethernet"
-                   " frames");
+		   " frames");
diff --git a/net/bridge/netfilter/ebt_vlan.c b/net/bridge/netfilter/ebt_vlan.c
index 7ee377622964..a43c697d3d73 100644
--- a/net/bridge/netfilter/ebt_vlan.c
+++ b/net/bridge/netfilter/ebt_vlan.c
@@ -128,9 +128,9 @@ ebt_check_vlan(const char *tablename,
 
 	/* Reserved VLAN ID (VID) values
 	 * -----------------------------
-	 * 0 - The null VLAN ID. 
+	 * 0 - The null VLAN ID.
 	 * 1 - The default Port VID (PVID)
-	 * 0x0FFF - Reserved for implementation use. 
+	 * 0x0FFF - Reserved for implementation use.
 	 * if_vlan.h: VLAN_GROUP_ARRAY_LEN 4096. */
 	if (GET_BITMASK(EBT_VLAN_ID)) {
 		if (!!info->id) { /* if id!=0 => check vid range */
@@ -141,7 +141,7 @@ ebt_check_vlan(const char *tablename,
 				return -EINVAL;
 			}
 			/* Note: This is valid VLAN-tagged frame point.
-			 * Any value of user_priority are acceptable, 
+			 * Any value of user_priority are acceptable,
 			 * but should be ignored according to 802.1Q Std.
 			 * So we just drop the prio flag. */
 			info->bitmask &= ~EBT_VLAN_PRIO;
diff --git a/net/bridge/netfilter/ebtable_filter.c b/net/bridge/netfilter/ebtable_filter.c
index 127135ead2d5..81d84145c417 100644
--- a/net/bridge/netfilter/ebtable_filter.c
+++ b/net/bridge/netfilter/ebtable_filter.c
@@ -51,10 +51,10 @@ static int check(const struct ebt_table_info *info, unsigned int valid_hooks)
 }
 
 static struct ebt_table frame_filter =
-{ 
+{
 	.name		= "filter",
 	.table		= &initial_table,
-	.valid_hooks	= FILTER_VALID_HOOKS, 
+	.valid_hooks	= FILTER_VALID_HOOKS,
 	.lock		= RW_LOCK_UNLOCKED,
 	.check		= check,
 	.me		= THIS_MODULE,
diff --git a/net/bridge/netfilter/ebtables.c b/net/bridge/netfilter/ebtables.c
index 6c84ccb8c9d7..5818d70b8e8d 100644
--- a/net/bridge/netfilter/ebtables.c
+++ b/net/bridge/netfilter/ebtables.c
@@ -33,10 +33,10 @@
 #include "../br_private.h"
 
 #define BUGPRINT(format, args...) printk("kernel msg: ebtables bug: please "\
-                                         "report to author: "format, ## args)
+					 "report to author: "format, ## args)
 /* #define BUGPRINT(format, args...) */
 #define MEMPRINT(format, args...) printk("kernel msg: ebtables "\
-                                         ": out of memory: "format, ## args)
+					 ": out of memory: "format, ## args)
 /* #define MEMPRINT(format, args...) */
 
 
@@ -482,7 +482,7 @@ ebt_check_entry_size_and_hooks(struct ebt_entry *e,
 		   as it said it has */
 		if (*n != *cnt) {
 			BUGPRINT("nentries does not equal the nr of entries "
-		                 "in the chain\n");
+				 "in the chain\n");
 			return -EINVAL;
 		}
 		if (((struct ebt_entries *)e)->policy != EBT_DROP &&
@@ -809,7 +809,7 @@ static int translate_table(char *name, struct ebt_table_info *newinfo)
 	i = 0; /* holds the expected nr. of entries for the chain */
 	j = 0; /* holds the up to now counted entries for the chain */
 	k = 0; /* holds the total nr. of entries, should equal
-	          newinfo->nentries afterwards */
+		  newinfo->nentries afterwards */
 	udc_cnt = 0; /* will hold the nr. of user defined chains (udc) */
 	ret = EBT_ENTRY_ITERATE(newinfo->entries, newinfo->entries_size,
 	   ebt_check_entry_size_and_hooks, newinfo,
@@ -820,7 +820,7 @@ static int translate_table(char *name, struct ebt_table_info *newinfo)
 
 	if (i != j) {
 		BUGPRINT("nentries does not equal the nr of entries in the "
-		         "(last) chain\n");
+			 "(last) chain\n");
 		return -EINVAL;
 	}
 	if (k != newinfo->nentries) {
@@ -835,7 +835,7 @@ static int translate_table(char *name, struct ebt_table_info *newinfo)
 		   if an error occurs */
 		newinfo->chainstack =
 			vmalloc((highest_possible_processor_id()+1)
-				   	* sizeof(*(newinfo->chainstack)));
+					* sizeof(*(newinfo->chainstack)));
 		if (!newinfo->chainstack)
 			return -ENOMEM;
 		for_each_possible_cpu(i) {
@@ -948,7 +948,7 @@ static int do_replace(void __user *user, unsigned int len)
 	if (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))
 		return -ENOMEM;
 
-	countersize = COUNTER_OFFSET(tmp.nentries) * 
+	countersize = COUNTER_OFFSET(tmp.nentries) *
 					(highest_possible_processor_id()+1);
 	newinfo = vmalloc(sizeof(*newinfo) + countersize);
 	if (!newinfo)
@@ -1350,7 +1350,7 @@ static inline int ebt_make_names(struct ebt_entry *e, char *base, char __user *u
 
 	hlp = ubase + (((char *)e + e->target_offset) - base);
 	t = (struct ebt_entry_target *)(((char *)e) + e->target_offset);
-	
+
 	ret = EBT_MATCH_ITERATE(e, ebt_make_matchname, base, ubase);
 	if (ret != 0)
 		return ret;

