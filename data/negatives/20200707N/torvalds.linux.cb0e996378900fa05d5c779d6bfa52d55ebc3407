commit cb0e996378900fa05d5c779d6bfa52d55ebc3407
Author: John Stultz <johnstul@us.ibm.com>
Date:   Wed Mar 3 19:57:24 2010 -0800

    blackfin: Convert blackfin to use read/update_persistent_clock
    
    This patch converts the blackfin architecture to use the generic
    read_persistent_clock and update_persistent_clock interfaces, reducing
    the amount of arch specific code we have to maintain, and allowing for
    further cleanups in the future.
    
    I have not built or tested this patch, so help from arch maintainers
    would be appreciated.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Mike Frysinger <vapier@gentoo.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    LKML-Reference: <1267675049-12337-10-git-send-email-johnstul@us.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/blackfin/kernel/time-ts.c b/arch/blackfin/kernel/time-ts.c
index 17c38c5b5b22..08dd3e83c187 100644
--- a/arch/blackfin/kernel/time-ts.c
+++ b/arch/blackfin/kernel/time-ts.c
@@ -348,9 +348,15 @@ static int __init bfin_clockevent_init(void)
 	return 0;
 }
 
-void __init time_init(void)
+void read_persistent_clock(struct timespec *ts)
 {
 	time_t secs_since_1970 = (365 * 37 + 9) * 24 * 60 * 60;	/* 1 Jan 2007 */
+	ts->tv_sec = secs_since_1970;
+	ts->tv_nsec = 0;
+}
+
+void __init time_init(void)
+{
 
 #ifdef CONFIG_RTC_DRV_BFIN
 	/* [#2663] hack to filter junk RTC values that would cause
@@ -363,11 +369,6 @@ void __init time_init(void)
 	}
 #endif
 
-	/* Initialize xtime. From now on, xtime is updated with timer interrupts */
-	xtime.tv_sec = secs_since_1970;
-	xtime.tv_nsec = 0;
-	set_normalized_timespec(&wall_to_monotonic, -xtime.tv_sec, -xtime.tv_nsec);
-
 	bfin_cs_cycles_init();
 	bfin_cs_gptimer0_init();
 	bfin_clockevent_init();
diff --git a/arch/blackfin/kernel/time.c b/arch/blackfin/kernel/time.c
index 13c1ee3e6408..c9113619029f 100644
--- a/arch/blackfin/kernel/time.c
+++ b/arch/blackfin/kernel/time.c
@@ -112,11 +112,6 @@ u32 arch_gettimeoffset(void)
 }
 #endif
 
-static inline int set_rtc_mmss(unsigned long nowtime)
-{
-	return 0;
-}
-
 /*
  * timer_interrupt() needs to keep up the real-time clock,
  * as well as call the "do_timer()" routine every clocktick
@@ -126,29 +121,8 @@ __attribute__((l1_text))
 #endif
 irqreturn_t timer_interrupt(int irq, void *dummy)
 {
-	/* last time the cmos clock got updated */
-	static long last_rtc_update;
-
 	write_seqlock(&xtime_lock);
 	do_timer(1);
-
-	/*
-	 * If we have an externally synchronized Linux clock, then update
-	 * CMOS clock accordingly every ~11 minutes. Set_rtc_mmss() has to be
-	 * called as close as possible to 500 ms before the new second starts.
-	 */
-	if (ntp_synced() &&
-	    xtime.tv_sec > last_rtc_update + 660 &&
-	    (xtime.tv_nsec / NSEC_PER_USEC) >=
-	    500000 - ((unsigned)TICK_SIZE) / 2
-	    && (xtime.tv_nsec / NSEC_PER_USEC) <=
-	    500000 + ((unsigned)TICK_SIZE) / 2) {
-		if (set_rtc_mmss(xtime.tv_sec) == 0)
-			last_rtc_update = xtime.tv_sec;
-		else
-			/* Do it again in 60s. */
-			last_rtc_update = xtime.tv_sec - 600;
-	}
 	write_sequnlock(&xtime_lock);
 
 #ifdef CONFIG_IPIPE
@@ -161,10 +135,15 @@ irqreturn_t timer_interrupt(int irq, void *dummy)
 	return IRQ_HANDLED;
 }
 
-void __init time_init(void)
+void read_persistent_clock(struct timespec *ts)
 {
 	time_t secs_since_1970 = (365 * 37 + 9) * 24 * 60 * 60;	/* 1 Jan 2007 */
+	ts->tv_sec = secs_since_1970;
+	ts->tv_nsec = 0;
+}
 
+void __init time_init(void)
+{
 #ifdef CONFIG_RTC_DRV_BFIN
 	/* [#2663] hack to filter junk RTC values that would cause
 	 * userspace to have to deal with time values greater than
@@ -176,11 +155,5 @@ void __init time_init(void)
 	}
 #endif
 
-	/* Initialize xtime. From now on, xtime is updated with timer interrupts */
-	xtime.tv_sec = secs_since_1970;
-	xtime.tv_nsec = 0;
-
-	wall_to_monotonic.tv_sec = -xtime.tv_sec;
-
 	time_sched_init(timer_interrupt);
 }

