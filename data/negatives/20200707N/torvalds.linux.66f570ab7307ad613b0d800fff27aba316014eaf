commit 66f570ab7307ad613b0d800fff27aba316014eaf
Author: Jeff Layton <jlayton@redhat.com>
Date:   Sat Sep 17 18:17:33 2016 -0400

    nfs: use safe, interruptible sleeps when waiting to retry LOCK
    
    We actually want to use TASK_INTERRUPTIBLE sleeps when we're in the
    process of polling for a NFSv4 lock. If there is a signal pending when
    the task wakes up, then we'll be returning an error anyway. So, we might
    as well wake up immediately for non-fatal signals as well. That allows
    us to return to userland more quickly in that case, but won't change the
    error that userland sees.
    
    Also, there is no need to use the *_unsafe sleep variants here, as no
    vfs-layer locks should be held at this point.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>

diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index a84612e5979e..0aac0fbf0b58 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -5537,7 +5537,7 @@ int nfs4_proc_delegreturn(struct inode *inode, struct rpc_cred *cred, const nfs4
 static unsigned long
 nfs4_set_lock_task_retry(unsigned long timeout)
 {
-	freezable_schedule_timeout_killable_unsafe(timeout);
+	freezable_schedule_timeout_interruptible(timeout);
 	timeout <<= 1;
 	if (timeout > NFS4_LOCK_MAXTIMEOUT)
 		return NFS4_LOCK_MAXTIMEOUT;

