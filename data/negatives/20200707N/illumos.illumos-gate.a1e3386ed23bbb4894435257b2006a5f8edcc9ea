commit a1e3386ed23bbb4894435257b2006a5f8edcc9ea
Author: hiremath <none@none>
Date:   Thu Mar 15 10:59:48 2007 -0700

    6488370 "ls -lL /dev/ibd1" fails, printing "/dev/ibd1: No such file or directory"
    6507117 ibdm sends  a false notification that IOC is unreachable
    6507210 ibt_get_paths(AVAIL) needs better sorting mechanism while returning PathRec
    6527494 base_lid returned should be valid even when PortState is IBT_PORT_ARM

diff --git a/usr/src/uts/common/io/ib/ibnex/ibnex.c b/usr/src/uts/common/io/ib/ibnex/ibnex.c
index 24633d3693..f659f574a3 100644
--- a/usr/src/uts/common/io/ib/ibnex/ibnex.c
+++ b/usr/src/uts/common/io/ib/ibnex/ibnex.c
@@ -19,7 +19,7 @@
  * CDDL HEADER END
  */
 /*
- * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
+ * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
 
@@ -1184,8 +1184,6 @@ ibnex_bus_config(dev_info_t *parent, uint_t flag,
 					ret = IBNEX_SUCCESS;
 				else
 					ret = IBNEX_FAILURE;
-				/* Allows enumeration under PHCI */
-				flag |= NDI_MDI_FALLBACK;
 			} else {
 				/*
 				 * if not IOC or PORT device then always
@@ -1217,6 +1215,11 @@ ibnex_bus_config(dev_info_t *parent, uint_t flag,
 				mutex_exit(&ibnex.ibnex_mutex);
 			}
 		}
+
+		if (strncmp(cname, IBNEX_IBPORT_CNAME, 6) == 0) {
+			/* Allows enumeration under PHCI */
+			flag |= NDI_MDI_FALLBACK;
+		}
 		kmem_free(device_name, len);
 		break;
 
diff --git a/usr/src/uts/common/io/ib/ibtl/ibtl_hca.c b/usr/src/uts/common/io/ib/ibtl/ibtl_hca.c
index 06e61bd664..96395c34c8 100644
--- a/usr/src/uts/common/io/ib/ibtl/ibtl_hca.c
+++ b/usr/src/uts/common/io/ib/ibtl/ibtl_hca.c
@@ -2,9 +2,8 @@
  * CDDL HEADER START
  *
  * The contents of this file are subject to the terms of the
- * Common Development and Distribution License, Version 1.0 only
- * (the "License").  You may not use this file except in compliance
- * with the License.
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
  *
  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
  * or http://www.opensolaris.org/os/licensing.
@@ -20,7 +19,7 @@
  * CDDL HEADER END
  */
 /*
- * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
+ * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
 
@@ -464,6 +463,8 @@ ibtl_get_port_state(ibtl_hca_devinfo_t *hca_devp, uint8_t port,
 		return (IBT_HCA_PORT_INVALID);
 	}
 	portinfop = hca_devp->hd_portinfop + port - 1;
+	if (portinfop->p_linkstate != IBT_PORT_ACTIVE)
+		ibtl_reinit_hca_portinfo(hca_devp, port);
 
 	if (sgid_p)
 		*sgid_p = portinfop->p_sgid_tbl[0];
@@ -966,7 +967,8 @@ ibtl_reinit_hca_portinfo(ibtl_hca_devinfo_t *hca_devp, uint8_t port)
 					    "ibtl_reinit_hca_portinfo(%p, %d): "
 					    "PORT UP", hca_devp, port);
 			} else {
-				p1->p_base_lid = 0;
+				if (p1->p_linkstate != IBT_PORT_ARM)
+					p1->p_base_lid = 0;
 				if (p1->p_linkstate != old_linkstate)
 					IBTF_DPRINTF_L2(ibtf_hca,
 					    "ibtl_reinit_hca_portinfo(%p, %d): "
@@ -1084,7 +1086,8 @@ ibtl_init_hca_portinfo(ibtl_hca_devinfo_t *hca_devp)
 				    sn_pfx, p1->p_sgid_tbl[0].gid_prefix);
 			}
 		} else {
-			p1->p_base_lid = 0;
+			if (p1->p_linkstate != IBT_PORT_ARM)
+				p1->p_base_lid = 0;
 		}
 		p1++;
 	}
diff --git a/usr/src/uts/common/io/ib/mgt/ibcm/ibcm_path.c b/usr/src/uts/common/io/ib/mgt/ibcm/ibcm_path.c
index 93a4576bbe..6288996535 100644
--- a/usr/src/uts/common/io/ib/mgt/ibcm/ibcm_path.c
+++ b/usr/src/uts/common/io/ib/mgt/ibcm/ibcm_path.c
@@ -19,7 +19,7 @@
  * CDDL HEADER END
  */
 /*
- * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
+ * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
 
@@ -1712,13 +1712,12 @@ ibcm_get_multi_pathrec(ibcm_path_tqargs_t *p_arg, ibtl_cm_port_list_t *sl,
 			    pr_resp[i].SGID.gid_guid, pr_resp[i].DGID.gid_guid);
 		}
 
-		if (p_arg->flags & IBT_PATH_APM) {
+		if (p_arg->flags & (IBT_PATH_APM | IBT_PATH_AVAIL)) {
 			sa_path_record_t *p_resp = NULL, *a_resp = NULL;
+			sa_path_record_t *p_tmp = NULL, *a_tmp = NULL;
 			int		p_found = 0, a_found = 0;
 			ib_gid_t	p_sg, a_sg, p_dg, a_dg;
-			int		s_spec;
-
-			s_spec = p_arg->attr.pa_sgid.gid_guid != 0 ? 1 : 0;
+			int		p_tmp_found = 0, a_tmp_found = 0;
 
 			p_sg = gid_s_ptr[0];
 			if (sgid_cnt > 1)
@@ -1756,8 +1755,8 @@ ibcm_get_multi_pathrec(ibcm_path_tqargs_t *p_arg, ibtl_cm_port_list_t *sl,
 					IBTF_DPRINTF_L3(cmlog,
 					    "ibcm_get_multi_pathrec: "
 					    "Pri DGID Match.. ");
-					if ((s_spec == 0) || (p_sg.gid_guid ==
-					    pr_resp->SGID.gid_guid)) {
+					if (p_sg.gid_guid ==
+					    pr_resp->SGID.gid_guid) {
 						p_found = 1;
 						p_resp = pr_resp;
 						IBTF_DPRINTF_L3(cmlog,
@@ -1768,6 +1767,14 @@ ibcm_get_multi_pathrec(ibcm_path_tqargs_t *p_arg, ibtl_cm_port_list_t *sl,
 							break;
 						else
 							continue;
+					} else if ((!p_tmp_found) &&
+					    (a_sg.gid_guid ==
+					    pr_resp->SGID.gid_guid)) {
+						p_tmp_found = 1;
+						p_tmp = pr_resp;
+						IBTF_DPRINTF_L3(cmlog,
+						    "ibcm_get_multi_pathrec: "
+						    "Tmp Pri Path Found");
 					}
 					IBTF_DPRINTF_L3(cmlog,
 					    "ibcm_get_multi_pathrec:"
@@ -1779,8 +1786,8 @@ ibcm_get_multi_pathrec(ibcm_path_tqargs_t *p_arg, ibtl_cm_port_list_t *sl,
 					IBTF_DPRINTF_L3(cmlog,
 					    "ibcm_get_multi_pathrec:"
 					    "Alt DGID Match.. ");
-					if ((s_spec == 0) || (a_sg.gid_guid ==
-					    pr_resp->SGID.gid_guid)) {
+					if (a_sg.gid_guid ==
+					    pr_resp->SGID.gid_guid) {
 						a_found = 1;
 						a_resp = pr_resp;
 
@@ -1792,6 +1799,15 @@ ibcm_get_multi_pathrec(ibcm_path_tqargs_t *p_arg, ibtl_cm_port_list_t *sl,
 							break;
 						else
 							continue;
+					} else if ((!a_tmp_found) &&
+					    (p_sg.gid_guid ==
+					    pr_resp->SGID.gid_guid)) {
+						a_tmp_found = 1;
+						a_tmp = pr_resp;
+
+						IBTF_DPRINTF_L3(cmlog,
+						    "ibcm_get_multi_pathrec:"
+						    "Tmp Alt Path Found ");
 					}
 					IBTF_DPRINTF_L3(cmlog,
 					    "ibcm_get_multi_pathrec:"
@@ -1799,42 +1815,87 @@ ibcm_get_multi_pathrec(ibcm_path_tqargs_t *p_arg, ibtl_cm_port_list_t *sl,
 				}
 			}
 
-			if ((p_found == 0) && (a_found == 0)) {
-				IBTF_DPRINTF_L2(cmlog, "ibcm_get_multi_pathrec:"
+			if ((p_found == 0) && (a_found == 0) &&
+			    (p_tmp_found == 0) && (a_tmp_found == 0)) {
+				IBTF_DPRINTF_L3(cmlog, "ibcm_get_multi_pathrec:"
 				    " Path to desired node points NOT "
 				    "Available.");
 				retval = IBT_PATH_RECORDS_NOT_FOUND;
-				goto get_multi_pathrec_end;
+				goto get_mpr_end;
 			}
 
-			if ((p_resp == NULL) && (a_resp != NULL)) {
-				p_resp = a_resp;
-				a_resp = NULL;
+			if (p_resp == NULL) {
+				if (a_resp != NULL) {
+					p_resp = a_resp;
+					a_resp = NULL;
+				} else if (p_tmp != NULL) {
+					p_resp = p_tmp;
+					p_tmp = NULL;
+				} else if (a_tmp != NULL) {
+					p_resp = a_tmp;
+					a_tmp = NULL;
+				}
+			}
+			if (a_resp == NULL) {
+				if (a_tmp != NULL) {
+					a_resp = a_tmp;
+					a_tmp = NULL;
+				} else if (p_tmp != NULL) {
+					a_resp = p_tmp;
+					p_tmp = NULL;
+				}
 			}
 
 			/* Fill in Primary Path */
 			retval = ibcm_update_pri(p_resp, sl, dinfo,
 			    &paths[found]);
 			if (retval != IBT_SUCCESS)
-				goto get_multi_pathrec_end;
+				goto get_mpr_end;
 
-			/* Fill in Alternate Path */
-			if (a_resp != NULL) {
-				/* a_resp will point to AltPathInfo buffer. */
-				retval = ibcm_update_cep_info(a_resp, sl,
-				    NULL, &paths[found].pi_alt_cep_path);
-				if (retval != IBT_SUCCESS)
-					goto get_multi_pathrec_end;
+			if (p_arg->flags & IBT_PATH_APM) {
+				/* Fill in Alternate Path */
+				if (a_resp != NULL) {
+					/*
+					 * a_resp will point to AltPathInfo
+					 * buffer.
+					 */
+					retval = ibcm_update_cep_info(a_resp,
+					    sl, NULL,
+					    &paths[found].pi_alt_cep_path);
+					if (retval != IBT_SUCCESS)
+						goto get_mpr_end;
 
-				/* Update some leftovers */
-				paths[found].pi_alt_pkt_lt =
-				    a_resp->PacketLifeTime;
-			} else {
-				IBTF_DPRINTF_L3(cmlog, "ibcm_get_multi_pathrec:"
-				    " Alternate Path NOT Available.");
-				retval = IBT_INSUFF_DATA;
+					/* Update some leftovers */
+					paths[found].pi_alt_pkt_lt =
+					    a_resp->PacketLifeTime;
+				} else {
+					IBTF_DPRINTF_L3(cmlog,
+					    "ibcm_get_multi_pathrec:"
+					    " Alternate Path NOT Available.");
+					retval = IBT_INSUFF_DATA;
+				}
+				found++;
+			} else if (p_arg->flags & IBT_PATH_AVAIL) {
+				found++;
+
+				if (found < *num_path) {
+
+					/* Fill in second Path */
+					if (a_resp != NULL) {
+						retval = ibcm_update_pri(a_resp,
+						    sl, dinfo, &paths[found]);
+						if (retval != IBT_SUCCESS)
+							goto get_mpr_end;
+						else
+							found++;
+					} else {
+						IBTF_DPRINTF_L3(cmlog,
+						    "ibcm_get_multi_pathrec: "
+						    "SecondPath NOT Available");
+						retval = IBT_INSUFF_DATA;
+					}
+				}
 			}
-			found++;
 		} else {	/* If NOT APM */
 			boolean_t	check_pkey = B_FALSE;
 
@@ -1878,7 +1939,7 @@ ibcm_get_multi_pathrec(ibcm_path_tqargs_t *p_arg, ibtl_cm_port_list_t *sl,
 					break;
 			}
 		}
-get_multi_pathrec_end:
+get_mpr_end:
 		kmem_free(results_p, length);
 	}
 	kmem_free(mpr_req, template_len);
@@ -2335,7 +2396,7 @@ ibcm_saa_service_rec(ibcm_path_tqargs_t *p_arg, ibtl_cm_port_list_t *sl,
 
 		for (i = 0; i < num_req; i++, svcrec_resp++) {
 			ibt_status_t	ret;
-			boolean_t	local_node_check_done = B_FALSE;
+			boolean_t	is_this_on_local_node = B_FALSE;
 
 			/* Limited P_Key is NOT supported as of now!. */
 			if ((svcrec_resp->ServiceP_Key & 0x8000) == 0) {
@@ -2347,20 +2408,20 @@ ibcm_saa_service_rec(ibcm_path_tqargs_t *p_arg, ibtl_cm_port_list_t *sl,
 
 			p_gid = svcrec_resp->ServiceGID;
 
-			IBTF_DPRINTF_L3(cmlog, "ibcm_saa_service_rec: "
-			    "Let DGID(%llX:%llX) be Primary",
-			    p_gid.gid_prefix, p_gid.gid_guid);
-
 			/* Let's avoid LoopBack Nodes. */
-			if (p_gid.gid_guid == sl->p_sgid.gid_guid) {
-				local_node_check_done = B_TRUE;
+			for (j = 0; j < sl->p_count; j++) {
+				if (p_gid.gid_guid == sl[j].p_sgid.gid_guid) {
+					is_this_on_local_node = B_TRUE;
 
-				IBTF_DPRINTF_L3(cmlog, "ibcm_saa_service_rec: "
-				    "Lets Avoid Local Node, "
-				    "search for remote node.");
+					IBTF_DPRINTF_L3(cmlog,
+					    "ibcm_saa_service_rec: ServiceGID "
+					    "%llX:%llX is on Local Node, "
+					    "search for remote.",
+					    p_gid.gid_prefix, p_gid.gid_guid);
+				}
 			}
 
-			if (local_node_check_done == B_TRUE) {
+			if (is_this_on_local_node == B_TRUE) {
 				if ((i + 1) < num_req) {
 					p_gid.gid_prefix = 0;
 					p_gid.gid_guid = 0;
@@ -2513,6 +2574,9 @@ ibcm_saa_service_rec(ibcm_path_tqargs_t *p_arg, ibtl_cm_port_list_t *sl,
 			retval = IBT_INSUFF_DATA;
 	} else if (p_arg->flags & IBT_PATH_MULTI_SVC_DEST) {
 		for (i = 0; i < num_req; i++, svcrec_resp++) {
+			ib_gid_t	p_gid;
+			boolean_t	is_this_on_local_node = B_FALSE;
+
 			/* Limited P_Key is NOT supported as of now!. */
 			if ((svcrec_resp->ServiceP_Key & 0x8000) == 0) {
 				IBTF_DPRINTF_L3(cmlog, "ibcm_saa_service_rec: "
@@ -2520,6 +2584,29 @@ ibcm_saa_service_rec(ibcm_path_tqargs_t *p_arg, ibtl_cm_port_list_t *sl,
 				    svcrec_resp->ServiceP_Key);
 				continue;
 			}
+
+			p_gid = svcrec_resp->ServiceGID;
+
+			/* Let's avoid LoopBack Nodes. */
+			for (j = 0; j < sl->p_count; j++) {
+				if (p_gid.gid_guid == sl[j].p_sgid.gid_guid) {
+					is_this_on_local_node = B_TRUE;
+					IBTF_DPRINTF_L3(cmlog,
+					    "ibcm_saa_service_rec: ServiceGID "
+					    "%llX:%llX is on Local Node, "
+					    "search for remote.",
+					    p_gid.gid_prefix, p_gid.gid_guid);
+				}
+			}
+
+			if (is_this_on_local_node == B_TRUE)
+				if ((i + 1) < num_req)
+					continue;
+
+			IBTF_DPRINTF_L4(cmlog, "ibcm_saa_service_rec: "
+			    "Found ServiceGID = %llX:%llX",
+			    p_gid.gid_prefix, p_gid.gid_guid);
+
 			ibcm_fill_svcinfo(svcrec_resp,
 			    &dinfo->dest[rec_found]);
 			rec_found++;
diff --git a/usr/src/uts/common/io/ib/mgt/ibdm/ibdm.c b/usr/src/uts/common/io/ib/mgt/ibdm/ibdm.c
index 723a781618..0ad613b7e0 100644
--- a/usr/src/uts/common/io/ib/mgt/ibdm/ibdm.c
+++ b/usr/src/uts/common/io/ib/mgt/ibdm/ibdm.c
@@ -19,7 +19,7 @@
  * CDDL HEADER END
  */
 /*
- * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
+ * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
 
@@ -546,6 +546,7 @@ ibdm_event_hdlr(void *clnt_hdl,
 		hca_list->hl_nports_active--;
 		port_sa_hdl = port->pa_sa_hdl;
 		(void) ibdm_fini_port(port);
+		port->pa_state = IBT_PORT_DOWN;
 		mutex_exit(&ibdm.ibdm_hl_mutex);
 		ibdm_reset_all_dgids(port_sa_hdl);
 		break;
@@ -1692,7 +1693,7 @@ ibdm_get_reachable_ports(ibdm_port_attr_t *portinfo, ibdm_hca_list_t *hca)
 		precp = &result[ii];
 		if ((gid_info = ibdm_check_dgid(precp->DGID.gid_guid,
 		    precp->DGID.gid_prefix)) != NULL) {
-			IBTF_DPRINTF_L2("ibdm", "\tget_reachable_ports: "
+			IBTF_DPRINTF_L5("ibdm", "\tget_reachable_ports: "
 			    "Already exists nrecs %d, ii %d", nrecs, ii);
 			ibdm_addto_glhcalist(gid_info, hca);
 			continue;
@@ -3118,8 +3119,8 @@ ibdm_verify_mad_status(ib_mad_hdr_t *hdr)
 	else if ((b2h16(hdr->Status) & 0x1f) == MAD_STATUS_REDIRECT_REQUIRED)
 		ret = IBDM_SUCCESS;
 	else {
-		IBTF_DPRINTF_L4("ibdm",
-		    "\tverify_mad_status: Stauts : 0x%x", b2h16(hdr->Status));
+		IBTF_DPRINTF_L2("ibdm",
+		    "\tverify_mad_status: Status : 0x%x", b2h16(hdr->Status));
 		ret = IBDM_FAILURE;
 	}
 	return (ret);
@@ -3431,7 +3432,7 @@ ibdm_pkt_timeout_hdlr(void *arg)
 static int
 ibdm_retry_command(ibdm_timeout_cb_args_t *cb_args)
 {
-	int			ret, rval = IBDM_SUCCESS;
+	int			ret;
 	ibmf_msg_t		*msg;
 	ib_mad_hdr_t		*hdr;
 	ibdm_dp_gidinfo_t	*gid_info = cb_args->cb_gid_info;
@@ -3546,18 +3547,17 @@ ibdm_retry_command(ibdm_timeout_cb_args_t *cb_args)
 	    "timeout %x", cb_args->cb_req_type, cb_args->cb_ioc_num,
 	    cb_args->cb_srvents_start, *timeout_id);
 
-	if ((rval = ibmf_msg_transport(gid_info->gl_ibmf_hdl,
+	if (ibmf_msg_transport(gid_info->gl_ibmf_hdl,
 	    gid_info->gl_qp_hdl, msg, NULL, ibdm_ibmf_send_cb,
-	    cb_args, 0)) != IBMF_SUCCESS) {
+	    cb_args, 0) != IBMF_SUCCESS) {
 		IBTF_DPRINTF_L2("ibdm", "\tretry_command: send failed: %p "
 		    "rtype 0x%x iocidx 0x%x srvidx %d", cb_args->cb_gid_info,
 		    cb_args->cb_req_type, cb_args->cb_ioc_num,
 		    cb_args->cb_srvents_start);
 		ibdm_ibmf_send_cb(gid_info->gl_ibmf_hdl, msg, cb_args);
-		rval = IBDM_FAILURE;
 	}
 	mutex_enter(&gid_info->gl_mutex);
-	return (rval);
+	return (IBDM_SUCCESS);
 }
 
 
@@ -3647,7 +3647,7 @@ ibdm_probe_ioc(ib_guid_t nodeguid, ib_guid_t ioc_guid, int reprobe_flag)
 	ibdm_gid_t		*temp_gid;
 	sa_portinfo_record_t	*pi;
 
-	IBTF_DPRINTF_L4("ibdm", "\tprobe_ioc(%x, %x, %x): Begin",
+	IBTF_DPRINTF_L4("ibdm", "\tprobe_ioc(%llx, %llx, %x): Begin",
 	    nodeguid, ioc_guid, reprobe_flag);
 
 	/* Rescan the GID list for any removed GIDs for reprobe */
@@ -3812,11 +3812,7 @@ ibdm_probe_ioc(ib_guid_t nodeguid, ib_guid_t ioc_guid, int reprobe_flag)
 			ibdm_probe_gid(node_gid);
 
 			mutex_enter(&ibdm.ibdm_hl_mutex);
-		} else {
-			IBTF_DPRINTF_L2("ibdm", "\tibdm_probe_ioc "
-			    "Invalid state!");
 		}
-
 	}
 	mutex_exit(&ibdm.ibdm_hl_mutex);
 	IBTF_DPRINTF_L4("ibdm", "\tprobe_ioc : End\n");
@@ -5921,7 +5917,7 @@ ibdm_addto_glhcalist(ibdm_dp_gidinfo_t *gid_info,
 		if (head->hl_hca_guid == hca->hl_hca_guid) {
 			mutex_exit(&gid_info->gl_mutex);
 			IBTF_DPRINTF_L4(ibdm_string,
-			    "\taddto_glhcalist : gid %x hca %x dup",
+			    "\taddto_glhcalist : gid %p hca %p dup",
 			    gid_info, hca);
 			return;
 		}
@@ -6002,7 +5998,7 @@ ibdm_reset_all_dgids(ibmf_saa_handle_t port_sa_hdl)
 				 * going down. This is ensured by
 				 * setting gl_disconnected to 1.
 				 */
-				if (gid_info->gl_nodeguid != 0)
+				if (gid_info->gl_nodeguid == 0)
 					gid_info->gl_disconnected = 1;
 				else
 					ibdm_reset_gidinfo(gid_info);
@@ -6041,6 +6037,7 @@ ibdm_reset_gidinfo(ibdm_dp_gidinfo_t *gidinfo)
 	int	ret, ii, nrecords;
 	sa_path_record_t	*path;
 	uint8_t	npaths = 1;
+	ibdm_pkey_tbl_t		*pkey_tbl;
 
 	IBTF_DPRINTF_L4(ibdm_string, "\treset_gidinfo(%p)", gidinfo);
 
@@ -6107,16 +6104,32 @@ ibdm_reset_gidinfo(ibdm_dp_gidinfo_t *gidinfo)
 		gidinfo->gl_dgid_lo	= path->DGID.gid_guid;
 		gidinfo->gl_sgid_hi	= path->SGID.gid_prefix;
 		gidinfo->gl_sgid_lo	= path->SGID.gid_guid;
-		gidinfo->gl_p_key		= path->P_Key;
-		gidinfo->gl_sa_hdl		= port->pa_sa_hdl;
+		gidinfo->gl_p_key	= path->P_Key;
+		gidinfo->gl_sa_hdl	= port->pa_sa_hdl;
 		gidinfo->gl_ibmf_hdl	= port->pa_ibmf_hdl;
-		gidinfo->gl_slid		= path->SLID;
-		gidinfo->gl_dlid		= path->DLID;
-
+		gidinfo->gl_slid	= path->SLID;
+		gidinfo->gl_dlid	= path->DLID;
 		/* Reset redirect info, next MAD will set if redirected */
 		gidinfo->gl_redirected = 0;
 
-		gid_reinited = 1;
+		gidinfo->gl_qp_hdl = IBMF_QP_HANDLE_DEFAULT;
+		for (ii = 0; ii < port->pa_npkeys; ii++) {
+			if (port->pa_pkey_tbl == NULL)
+				break;
+
+			pkey_tbl = &port->pa_pkey_tbl[ii];
+			if ((gidinfo->gl_p_key == pkey_tbl->pt_pkey) &&
+			    (pkey_tbl->pt_qp_hdl != NULL)) {
+				gidinfo->gl_qp_hdl = pkey_tbl->pt_qp_hdl;
+				break;
+			}
+		}
+
+		if (gidinfo->gl_qp_hdl == NULL)
+			IBTF_DPRINTF_L2(ibdm_string,
+			    "\treset_gid_info: No matching Pkey");
+		else
+			gid_reinited = 1;
 
 		kmem_free(path, path_len);
 		kmem_free(pi, pi_len);

