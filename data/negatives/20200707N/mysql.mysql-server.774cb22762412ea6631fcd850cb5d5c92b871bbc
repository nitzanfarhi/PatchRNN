commit 774cb22762412ea6631fcd850cb5d5c92b871bbc
Author: Amitabh Das <amitabh.das@oracle.com>
Date:   Thu Mar 22 08:25:03 2018 +0530

    Bug#26486160 : mysql server upgrade to 8.0.3 with 1 million tables fails
    
    When mysql-5.7 data directory contains a large number of tables, in-place
    upgrade to 8.0 takes a large amount of memory.
    
    The large amount of memory consumption is due to usage of THD::mem_root and
    THD::main_mem_root for space allocation in
    
    - prepare_create_field() for table migration
    - dd::create_dd_user_table() for table migration
    - migrate_routine_to_dd()
    - migrate_event_to_dd()
    - add_sdi_info()
    
    Fix:
    
    - Allocate m_query_tables_list in THD::Transaction_state on heap rather than
      thd->main_mem_root.
    - Add fetch_global_component_names() and fetch_global_component_ids() APIs to
      DD Client to replace usage of fetch_global_components() in add_sdi_info().
    - Reduce scope of Auto_releaser in add_sdi_info() to each Tablespace and to
      each Table.
    - Swap out THD::mem_root while adding SDI information and migrating tables,
      events and routines.
    - Add trans_commit_stmt() and trans_commit() after each call of
      dd::sdi::store().
    - Register InnoDB engine in the Transaction context when calling
      Handler::sdi_set() so that trans_commit_stmt() can release InnoDB locks on
      the tables.
    
    Change-Id: Ib96259a5c991d48c90df6ea0735f6fbce4aabb23

diff --git a/sql/dd/cache/dictionary_client.h b/sql/dd/cache/dictionary_client.h
index 14b918f1767..0e4e0e74d19 100644
--- a/sql/dd/cache/dictionary_client.h
+++ b/sql/dd/cache/dictionary_client.h
@@ -855,6 +855,34 @@ class Dictionary_client {
                                     std::vector<String_type> *names) const
       MY_ATTRIBUTE((warn_unused_result));
 
+  /**
+    Fetch all global component ids of the given type.
+
+    @tparam        T              Type of components to get.
+    @param   [out] ids            An std::vector containing all component ids.
+
+    @return      true   Failure (error is reported).
+    @return      false  Success.
+  */
+
+  template <typename T>
+  bool fetch_global_component_ids(std::vector<Object_id> *ids) const
+      MY_ATTRIBUTE((warn_unused_result));
+
+  /**
+    Fetch all global component names of the given type.
+
+    @tparam        T              Type of components to get.
+    @param   [out] names          An std::vector containing all component names.
+
+    @return      true   Failure (error is reported).
+    @return      false  Success.
+  */
+
+  template <typename T>
+  bool fetch_global_component_names(std::vector<String_type> *names) const
+      MY_ATTRIBUTE((warn_unused_result));
+
   /**
     Fetch all components in the schema.
 
diff --git a/sql/dd/impl/cache/dictionary_client.cc b/sql/dd/impl/cache/dictionary_client.cc
index 19a492fd617..c83db5d9a74 100644
--- a/sql/dd/impl/cache/dictionary_client.cc
+++ b/sql/dd/impl/cache/dictionary_client.cc
@@ -1877,6 +1877,80 @@ bool Dictionary_client::check_foreign_key_exists(
   return false;
 }
 
+template <typename T>
+bool fetch_raw_record(THD *thd,
+                      std::function<bool(Raw_record *)> const &processor) {
+  Transaction_ro trx(thd, ISO_READ_COMMITTED);
+
+  trx.otx.register_tables<T>();
+  Raw_table *table = trx.otx.get_table<T>();
+  DBUG_ASSERT(table);
+
+  if (trx.otx.open_tables()) {
+    DBUG_ASSERT(thd->is_system_thread() || thd->killed || thd->is_error());
+    return true;
+  }
+
+  std::unique_ptr<Raw_record_set> rs;
+  if (table->open_record_set(nullptr, rs)) {
+    DBUG_ASSERT(thd->is_system_thread() || thd->killed || thd->is_error());
+    return true;
+  }
+
+  Raw_record *r = rs->current_record();
+  String_type s;
+  while (r) {
+    if (processor(r) || rs->next(r)) {
+      DBUG_ASSERT(thd->is_system_thread() || thd->killed || thd->is_error());
+      return true;
+    }
+  }
+
+  return false;
+}
+
+// Fetch the ids of all the components.
+template <typename T>
+bool Dictionary_client::fetch_global_component_ids(
+    std::vector<Object_id> *ids) const {
+  DBUG_ASSERT(ids);
+
+  auto processor = [&](Raw_record *r) -> bool {
+    ids->push_back(r->read_int(0));
+    return false;
+  };
+
+  if (fetch_raw_record<T>(m_thd, processor)) {
+    ids->clear();
+    DBUG_ASSERT(m_thd->is_system_thread() || m_thd->killed ||
+                m_thd->is_error());
+    return true;
+  }
+
+  return false;
+}
+
+// Fetch the names of all the components.
+template <typename T>
+bool Dictionary_client::fetch_global_component_names(
+    std::vector<String_type> *names) const {
+  DBUG_ASSERT(names);
+
+  auto processor = [&](Raw_record *r) -> bool {
+    names->push_back(r->read_str(T::DD_table::FIELD_NAME));
+    return false;
+  };
+
+  if (fetch_raw_record<T>(m_thd, processor)) {
+    names->clear();
+    DBUG_ASSERT(m_thd->is_system_thread() || m_thd->killed ||
+                m_thd->is_error());
+    return true;
+  }
+
+  return false;
+}
+
 // Fetch the names of all the components in the schema.
 template <typename T>
 bool Dictionary_client::fetch_schema_component_names(
@@ -2757,6 +2831,12 @@ template bool Dictionary_client::fetch_schema_component_names<Abstract_table>(
 template bool Dictionary_client::fetch_schema_component_names<Event>(
     const Schema *, std::vector<String_type> *) const;
 
+template bool Dictionary_client::fetch_global_component_ids<Table>(
+    std::vector<Object_id> *) const;
+
+template bool Dictionary_client::fetch_global_component_names<Tablespace>(
+    std::vector<String_type> *) const;
+
 template bool Dictionary_client::fetch_referencing_views_object_id<View_table>(
     const char *schema, const char *tbl_or_sf_name,
     std::vector<Object_id> *view_ids) const;
diff --git a/sql/dd/impl/sdi.cc b/sql/dd/impl/sdi.cc
index 875eb4f06a7..40e023382aa 100644
--- a/sql/dd/impl/sdi.cc
+++ b/sql/dd/impl/sdi.cc
@@ -545,7 +545,7 @@ namespace sdi {
 
 bool store(THD *thd, const Table *tp) {
   const Table &t = ptr_as_cref(tp);
-  const handlerton &hton = ptr_as_cref(resolve_hton(thd, t));
+  handlerton *hton = resolve_hton(thd, t);
 
   return with_schema(thd, t.schema_id(), [&](const Schema &s) {
     dd::Sdi_type sdi = serialize(thd, t, s.name());
@@ -558,8 +558,8 @@ bool store(THD *thd, const Table *tp) {
       return true;
     });
     return checked_return(
-        hton.sdi_set ? sdi_tablespace::store_tbl_sdi(thd, hton, sdi, t, s)
-                     : sdi_file::store_tbl_sdi(sdi, t, s));
+        hton->sdi_set ? sdi_tablespace::store_tbl_sdi(thd, hton, sdi, t, s)
+                      : sdi_file::store_tbl_sdi(sdi, t, s));
   });
 }
 
@@ -572,7 +572,7 @@ bool store(THD *thd, const Tablespace *ts) {
   if (sdi.empty()) {
     return checked_return(true);
   }
-  return checked_return(sdi_tablespace::store_tsp_sdi(*hton, sdi, *ts));
+  return checked_return(sdi_tablespace::store_tsp_sdi(hton, sdi, *ts));
 }
 
 bool drop(THD *thd, const Table *tp) {
diff --git a/sql/dd/impl/sdi_tablespace.cc b/sql/dd/impl/sdi_tablespace.cc
index 90c78d5d55a..03ba9b4612d 100644
--- a/sql/dd/impl/sdi_tablespace.cc
+++ b/sql/dd/impl/sdi_tablespace.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License, version 2.0,
@@ -163,7 +163,7 @@ dd::sdi_key_t get_sdi_key(const dd::Tablespace &tablespace) {
 
 namespace dd {
 namespace sdi_tablespace {
-bool store_tbl_sdi(THD *thd, const handlerton &hton, const dd::Sdi_type &sdi,
+bool store_tbl_sdi(THD *thd, handlerton *hton, const dd::Sdi_type &sdi,
                    const dd::Table &table,
                    const dd::Schema &schema MY_ATTRIBUTE((unused))) {
   const dd::sdi_key_t key = get_sdi_key(table);
@@ -172,7 +172,7 @@ bool store_tbl_sdi(THD *thd, const handlerton &hton, const dd::Sdi_type &sdi,
     DBUG_PRINT("ddsdi", ("store_sdi_with_schema[](Schema" ENTITY_FMT
                          ", Table" ENTITY_FMT ")",
                          ENTITY_VAL(schema), ENTITY_VAL(table)));
-    if (hton.sdi_set(tblspc, &table, &key, sdi.c_str(), sdi.size())) {
+    if (hton->sdi_set(hton, tblspc, &table, &key, sdi.c_str(), sdi.size())) {
       return checked_return(true);
     }
 
@@ -182,12 +182,12 @@ bool store_tbl_sdi(THD *thd, const handlerton &hton, const dd::Sdi_type &sdi,
   return apply_to_tablespaces(thd, table, store_sdi);
 }
 
-bool store_tsp_sdi(const handlerton &hton, const Sdi_type &sdi,
+bool store_tsp_sdi(handlerton *hton, const Sdi_type &sdi,
                    const Tablespace &tblspc) {
   dd::sdi_key_t key = get_sdi_key(tblspc);
 
   DBUG_PRINT("ddsdi", ("store_tsp_sdi(" ENTITY_FMT ")", ENTITY_VAL(tblspc)));
-  if (hton.sdi_set(tblspc, nullptr, &key, sdi.c_str(), sdi.size())) {
+  if (hton->sdi_set(hton, tblspc, nullptr, &key, sdi.c_str(), sdi.size())) {
     return checked_return(true);
   }
   return false;
diff --git a/sql/dd/impl/sdi_tablespace.h b/sql/dd/impl/sdi_tablespace.h
index 3cd4e44ab79..69e83c8ef3e 100644
--- a/sql/dd/impl/sdi_tablespace.h
+++ b/sql/dd/impl/sdi_tablespace.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License, version 2.0,
@@ -61,7 +61,7 @@ namespace sdi_tablespace {
   @param table
   @param schema
  */
-bool store_tbl_sdi(THD *thd, const handlerton &hton, const Sdi_type &sdi,
+bool store_tbl_sdi(THD *thd, handlerton *hton, const Sdi_type &sdi,
                    const Table &table, const dd::Schema &schema);
 
 /**
@@ -71,7 +71,7 @@ bool store_tbl_sdi(THD *thd, const handlerton &hton, const Sdi_type &sdi,
   @param sdi
   @param tablespace
  */
-bool store_tsp_sdi(const handlerton &hton, const Sdi_type &sdi,
+bool store_tsp_sdi(handlerton *hton, const Sdi_type &sdi,
                    const Tablespace &tablespace);
 
 /**
diff --git a/sql/dd/upgrade/event.cc b/sql/dd/upgrade/event.cc
index 280d532c017..ba60c62a4e0 100644
--- a/sql/dd/upgrade/event.cc
+++ b/sql/dd/upgrade/event.cc
@@ -551,12 +551,12 @@ bool migrate_events_to_dd(THD *thd) {
   uint flags = MYSQL_LOCK_IGNORE_TIMEOUT;
   DML_prelocking_strategy prelocking_strategy;
   MEM_ROOT records_mem_root;
+  Thd_mem_root_guard root_guard(thd, &records_mem_root);
 
   tables.init_one_table("mysql", 5, "event", 5, "event", TL_READ);
 
   table_list = &tables;
   if (open_and_lock_tables(thd, table_list, flags, &prelocking_strategy)) {
-    close_thread_tables(thd);
     LogErr(ERROR_LEVEL, ER_EVENT_CANT_OPEN_TABLE_MYSQL_EVENT);
     return true;
   }
@@ -593,10 +593,6 @@ bool migrate_events_to_dd(THD *thd) {
     goto err;
   }
 
-  init_sql_alloc(PSI_NOT_INSTRUMENTED, &records_mem_root, MEM_ROOT_BLOCK_SIZE,
-                 0);
-  thd->mem_root = &records_mem_root;
-
   if (migrate_event_to_dd(thd, event_table)) goto err;
 
   // Read the next row in 'event' table via index.
@@ -610,12 +606,10 @@ bool migrate_events_to_dd(THD *thd) {
   }
 
   my_tz_free();
-  free_root(&records_mem_root, MYF(0));
   return false;
 
 err:
   my_tz_free();
-  free_root(&records_mem_root, MYF(0));
   return true;
 }
 
diff --git a/sql/dd/upgrade/global.cc b/sql/dd/upgrade/global.cc
index c6d0a9c11b1..78cc2e89eb2 100644
--- a/sql/dd/upgrade/global.cc
+++ b/sql/dd/upgrade/global.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License, version 2.0,
@@ -40,14 +40,20 @@ namespace upgrade_57 {
 const char *TRN_EXT = ".TRN";
 const char *TRG_EXT = ".TRG";
 
-System_table_close_guard::System_table_close_guard(THD *thd, TABLE *table) {
+Thd_mem_root_guard::Thd_mem_root_guard(THD *thd, MEM_ROOT *mem_root) {
   m_thd = thd;
-  m_table = table;
-  m_mem_root = m_thd->mem_root;
+  m_thd_prev_mem_root = m_thd->mem_root;
+  m_thd->mem_root = mem_root;
 }
 
+Thd_mem_root_guard::~Thd_mem_root_guard() {
+  m_thd->mem_root = m_thd_prev_mem_root;
+}
+
+System_table_close_guard::System_table_close_guard(THD *thd, TABLE *table)
+    : m_thd(thd), m_table(table) {}
+
 System_table_close_guard::~System_table_close_guard() {
-  m_thd->mem_root = m_mem_root;
   if (m_table->file->inited) (void)m_table->file->ha_index_end();
   close_thread_tables(m_thd);
 }
diff --git a/sql/dd/upgrade/global.h b/sql/dd/upgrade/global.h
index ce9dc8f8e44..cc0a66c052d 100644
--- a/sql/dd/upgrade/global.h
+++ b/sql/dd/upgrade/global.h
@@ -54,6 +54,19 @@ const String_type index_stats_backup = "innodb_index_stats_backup57";
 const String_type table_stats = "innodb_table_stats";
 const String_type table_stats_backup = "innodb_table_stats_backup57";
 
+/**
+  THD::mem_root is only switched with the given mem_root and switched back
+  on destruction. This does not free any mem_root.
+ */
+class Thd_mem_root_guard {
+  THD *m_thd;
+  MEM_ROOT *m_thd_prev_mem_root;
+
+ public:
+  Thd_mem_root_guard(THD *thd, MEM_ROOT *mem_root);
+  ~Thd_mem_root_guard();
+};
+
 /**
    RAII for handling open and close of event and proc tables.
 */
@@ -61,7 +74,6 @@ const String_type table_stats_backup = "innodb_table_stats_backup57";
 class System_table_close_guard {
   THD *m_thd;
   TABLE *m_table;
-  MEM_ROOT *m_mem_root;
 
  public:
   System_table_close_guard(THD *thd, TABLE *table);
diff --git a/sql/dd/upgrade/routine.cc b/sql/dd/upgrade/routine.cc
index 19d3abdd967..54c3ade6d3c 100644
--- a/sql/dd/upgrade/routine.cc
+++ b/sql/dd/upgrade/routine.cc
@@ -442,12 +442,12 @@ bool migrate_routines_to_dd(THD *thd) {
   uint flags = MYSQL_LOCK_IGNORE_TIMEOUT;
   DML_prelocking_strategy prelocking_strategy;
   MEM_ROOT records_mem_root;
+  Thd_mem_root_guard root_guard(thd, &records_mem_root);
 
   tables.init_one_table("mysql", 5, "proc", 4, "proc", TL_READ);
 
   table_list = &tables;
   if (open_and_lock_tables(thd, table_list, flags, &prelocking_strategy)) {
-    close_thread_tables(thd);
     LogErr(ERROR_LEVEL, ER_CANT_OPEN_TABLE_MYSQL_PROC);
     return true;
   }
@@ -473,35 +473,25 @@ bool migrate_routines_to_dd(THD *thd) {
   // Read first record from mysql.proc table. Return if table is empty.
   if ((error = proc_table->file->ha_index_first(proc_table->record[0]))) {
     if (error == HA_ERR_END_OF_FILE) return false;
-
     LogErr(ERROR_LEVEL, ER_CANT_READ_TABLE_MYSQL_PROC);
     return true;
   }
 
-  init_sql_alloc(PSI_NOT_INSTRUMENTED, &records_mem_root, MEM_ROOT_BLOCK_SIZE,
-                 0);
-  thd->mem_root = &records_mem_root;
-
   // Migrate first record read to dd routines table.
-  if (migrate_routine_to_dd(thd, proc_table)) goto err;
+  if (migrate_routine_to_dd(thd, proc_table)) return true;
 
   // Read one record from mysql.proc table and
   // migrate it until all records are finished
   while (!(error = proc_table->file->ha_index_next(proc_table->record[0]))) {
-    if (migrate_routine_to_dd(thd, proc_table)) goto err;
+    if (migrate_routine_to_dd(thd, proc_table)) return true;
   }
 
   if (error != HA_ERR_END_OF_FILE) {
     LogErr(ERROR_LEVEL, ER_CANT_READ_TABLE_MYSQL_PROC);
-    goto err;
+    return true;
   }
 
-  free_root(&records_mem_root, MYF(0));
   return false;
-
-err:
-  free_root(&records_mem_root, MYF(0));
-  return true;
 }
 
 }  // namespace upgrade_57
diff --git a/sql/dd/upgrade/schema.cc b/sql/dd/upgrade/schema.cc
index 998cb635f15..b19110f0c1a 100644
--- a/sql/dd/upgrade/schema.cc
+++ b/sql/dd/upgrade/schema.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License, version 2.0,
@@ -40,11 +40,12 @@
 #include "mysql/psi/mysql_file.h"  // mysql_file_open
 #include "mysql_com.h"
 #include "mysqld_error.h"
-#include "sql/dd/dd_schema.h"  // Schema_MDL_locker
-#include "sql/log.h"           // LogErr()
-#include "sql/mysqld.h"        // key_file_dbopt
-#include "sql/sql_class.h"     // THD
-#include "sql/sql_table.h"     // build_tablename
+#include "sql/dd/cache/dictionary_client.h"  // Auto_releaser
+#include "sql/dd/dd_schema.h"                // Schema_MDL_locker
+#include "sql/log.h"                         // LogErr()
+#include "sql/mysqld.h"                      // key_file_dbopt
+#include "sql/sql_class.h"                   // THD
+#include "sql/sql_table.h"                   // build_tablename
 #include "sql/system_variables.h"
 #include "sql/thd_raii.h"
 #include "sql/transaction.h"  // trans_commit
@@ -134,6 +135,7 @@ bool migrate_schema_to_dd(THD *thd, const char *dbname) {
   char schema_name[NAME_LEN + 1];
   LEX_STRING dbopt_file_name;
   const CHARSET_INFO *schema_charset = thd->variables.collation_server;
+  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
 
   // Construct the schema name from its canonical format.
   filename_to_tablename(dbname, schema_name, sizeof(schema_name));
diff --git a/sql/dd/upgrade/table.cc b/sql/dd/upgrade/table.cc
index 2220a39ab6a..f09f0c656b9 100644
--- a/sql/dd/upgrade/table.cc
+++ b/sql/dd/upgrade/table.cc
@@ -548,7 +548,6 @@ class Upgrade_MDL_guard {
 class Table_upgrade_guard {
   THD *m_thd;
   TABLE *m_table;
-  MEM_ROOT *m_mem_root;
   sql_mode_t m_sql_mode;
   handler *m_handler;
   bool m_is_table_open;
@@ -556,18 +555,13 @@ class Table_upgrade_guard {
   Item *m_free_list_saved;
 
  public:
-  void update_mem_root(MEM_ROOT *mem_root) { m_mem_root = mem_root; }
-
   void update_handler(handler *handler) { m_handler = handler; }
 
   void update_lex(LEX *lex) { m_lex_saved = lex; }
 
-  void set_is_table_open(bool param) { m_is_table_open = param; }
-
-  Table_upgrade_guard(THD *thd, TABLE *table, MEM_ROOT *mem_root)
+  Table_upgrade_guard(THD *thd, TABLE *table)
       : m_thd(thd),
         m_table(table),
-        m_mem_root(mem_root),
         m_handler(nullptr),
         m_is_table_open(false),
         m_lex_saved(nullptr) {
@@ -622,12 +616,6 @@ class Table_upgrade_guard {
     free_table_share(m_table->s);
 
     destroy(m_handler);
-    /*
-      Make a copy of mem_root as TABLE object is allocated within its
-      own mem_root and free_root() updates its argument.
-    */
-    MEM_ROOT m_root = std::move(*m_mem_root);
-    free_root(&m_root, MYF(0));
   }
 };
 
@@ -726,6 +714,7 @@ static bool create_unlinked_view(THD *thd, TABLE_LIST *view_ref) {
   thd->lex->query_tables = NULL;
   thd->lex->sroutines_list.save_and_clear(&saved_sroutines_list);
 
+  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
   const dd::Schema *schema = nullptr;
   if (thd->dd_client()->acquire(view_ref->db, &schema)) return true;
   DBUG_ASSERT(schema != nullptr);  // Should be impossible during upgrade.
@@ -800,8 +789,7 @@ static void create_alter_view_stmt(THD *thd, TABLE_LIST *view_ref, String *str,
 */
 static bool fix_view_cols_and_deps(THD *thd, TABLE_LIST *view_ref,
                                    const String_type &db_name,
-                                   const String_type &view_name,
-                                   MEM_ROOT *mem_root) {
+                                   const String_type &view_name) {
   bool error = false;
 
   const CHARSET_INFO *client_cs = thd->variables.character_set_client;
@@ -822,9 +810,6 @@ static bool fix_view_cols_and_deps(THD *thd, TABLE_LIST *view_ref,
   thd->variables.collation_connection = m_connection_cl;
   thd->update_charset();
 
-  MEM_ROOT *m_mem_root = thd->mem_root;
-  thd->mem_root = mem_root;
-
   // Switch off modes which can prevent normal parsing of VIEW.
   Sql_mode_parse_guard parse_guard(thd);
 
@@ -874,7 +859,6 @@ static bool fix_view_cols_and_deps(THD *thd, TABLE_LIST *view_ref,
   thd->variables.character_set_client = client_cs;
   thd->variables.collation_connection = cs;
   thd->update_charset();
-  thd->mem_root = m_mem_root;
 
   return error;
 }
@@ -984,8 +968,7 @@ static bool migrate_view_to_dd(THD *thd, const FRM_context &frm_context,
 
   // View is already created, we are recreating it now.
   if (is_fix_view_cols_and_deps) {
-    if (fix_view_cols_and_deps(thd, &table_list, db_name, view_name,
-                               mem_root)) {
+    if (fix_view_cols_and_deps(thd, &table_list, db_name, view_name)) {
       LogErr(ERROR_LEVEL, ER_DD_VIEW_CANT_CREATE, db_name.c_str(),
              view_name.c_str());
       return true;
@@ -1045,9 +1028,8 @@ static bool add_triggers_to_table(THD *thd, TABLE *table,
   List<::Trigger> m_triggers;
   if (Trigger_loader::trg_file_exists(schema_name.c_str(),
                                       table_name.c_str())) {
-    if (Trigger_loader::load_triggers(thd, &table->mem_root,
-                                      schema_name.c_str(), table_name.c_str(),
-                                      &m_triggers)) {
+    if (Trigger_loader::load_triggers(thd, thd->mem_root, schema_name.c_str(),
+                                      table_name.c_str(), &m_triggers)) {
       LogErr(WARNING_LEVEL, ER_DD_TRG_FILE_UNREADABLE, table_name.c_str());
       return true;
     }
@@ -1368,7 +1350,7 @@ static bool migrate_table_to_dd(THD *thd, const String_type &schema_name,
   int error = 0;
   FRM_context frm_context;
   TABLE_SHARE share;
-  TABLE *table = nullptr;
+  TABLE table;
   Field **ptr, *field;
   handler *file = nullptr;
 
@@ -1405,46 +1387,32 @@ static bool migrate_table_to_dd(THD *thd, const String_type &schema_name,
     return true;
   }
 
-  {
-    // Initialize TABLE mem_root
-    MEM_ROOT mem_root;
-    init_sql_alloc(key_memory_TABLE, &mem_root, TABLE_ALLOC_BLOCK_SIZE, 0);
-
-    // Make a new TABLE object
-    if (!(table = new (&mem_root) TABLE())) {
-      free_table_share(&share);
-      LogErr(ERROR_LEVEL, ER_CANT_ALLOC_TABLE_OBJECT);
-      return true;
-    }
-
-    // Fix pointers in TABLE, TABLE_SHARE
-    table->s = &share;
-    table->in_use = thd;
-    table->mem_root = std::move(mem_root);
-  }
+  // Fix pointers in TABLE, TABLE_SHARE
+  table.s = &share;
+  table.in_use = thd;
 
   // Object to handle cleanup.
   LEX lex;
-  Table_upgrade_guard table_guard(thd, table, &table->mem_root);
+  Table_upgrade_guard table_guard(thd, &table);
 
   // Dont upgrade tables, we are fixing dependency for views.
   if (!share.is_view && is_fix_view_cols_and_deps) return false;
 
   if (share.is_view)
     return (migrate_view_to_dd(thd, frm_context, schema_name, table_name,
-                               &table->mem_root, is_fix_view_cols_and_deps));
+                               thd->mem_root, is_fix_view_cols_and_deps));
 
   // Get the handler
   if (!(file = get_new_handler(&share, share.partition_info_str_len != 0,
-                               &table->mem_root, share.db_type()))) {
+                               thd->mem_root, share.db_type()))) {
     LogErr(ERROR_LEVEL, ER_CANT_CREATE_HANDLER_OBJECT_FOR_TABLE,
            schema_name.c_str(), table_name.c_str());
     return true;
   }
-  table->file = file;
+  table.file = file;
   table_guard.update_handler(file);
 
-  if (table->file->set_ha_share_ref(&share.ha_share)) {
+  if (table.file->set_ha_share_ref(&share.ha_share)) {
     LogErr(ERROR_LEVEL, ER_CANT_SET_HANDLER_REFERENCE_FOR_TABLE,
            table_name.c_str(), schema_name.c_str());
     return true;
@@ -1455,12 +1423,12 @@ static bool migrate_table_to_dd(THD *thd, const String_type &schema_name,
     These steps are necessary for correct handling of
     default values by Create_field constructor.
   */
-  table->s->db_low_byte_first = table->file->low_byte_first();
-  table->use_all_columns();
-  table->record[0] = table->record[1] = share.default_values;
-  table->null_row = 0;
-  table->field = share.field;
-  table->key_info = share.key_info;
+  table.s->db_low_byte_first = table.file->low_byte_first();
+  table.use_all_columns();
+  table.record[0] = table.record[1] = share.default_values;
+  table.null_row = 0;
+  table.field = share.field;
+  table.key_info = share.key_info;
 
   /*
     Storage engine finds the auto_increment column
@@ -1470,20 +1438,20 @@ static bool migrate_table_to_dd(THD *thd, const String_type &schema_name,
     not set auto_increment value for the table.
   */
   if (share.found_next_number_field)
-    table->found_next_number_field =
-        table->field[(uint)(share.found_next_number_field - share.field)];
+    table.found_next_number_field =
+        table.field[(uint)(share.found_next_number_field - share.field)];
 
   // Set table_name variable and table in fields
   const char *alias = "";
   for (ptr = share.field; (field = *ptr); ptr++) {
-    field->table = table;
+    field->table = &table;
     field->table_name = &alias;
   }
 
   // Check presence of old data types
   bool avoid_temporal_upgrade_saved = avoid_temporal_upgrade;
   avoid_temporal_upgrade = false;
-  error = check_table_for_old_types(table);
+  error = check_table_for_old_types(&table);
   avoid_temporal_upgrade = avoid_temporal_upgrade_saved;
 
   if (error) {
@@ -1512,7 +1480,7 @@ static bool migrate_table_to_dd(THD *thd, const String_type &schema_name,
     */
     if (key_info->algorithm != HA_KEY_ALG_SE_SPECIFIC &&
         !(key_info->flags & HA_FULLTEXT) && !(key_info->flags & HA_SPATIAL) &&
-        table->file->is_index_algorithm_supported(key_info->algorithm))
+        table.file->is_index_algorithm_supported(key_info->algorithm))
       key_info->is_algorithm_explicit = true;
   }
 
@@ -1521,18 +1489,10 @@ static bool migrate_table_to_dd(THD *thd, const String_type &schema_name,
   Alter_info alter_info(thd->mem_root);
   Alter_table_ctx alter_ctx;
 
-  /*
-    Replace thd->mem_root as prepare_fields_and_keys() and
-    mysql_prepare_create_table() allocates memory in thd->mem_root.
-  */
-  MEM_ROOT *mem_root_backup = thd->mem_root;
-  thd->mem_root = &table->mem_root;
-
-  fill_create_info_for_upgrade(&create_info, table);
+  fill_create_info_for_upgrade(&create_info, &table);
 
-  if (prepare_fields_and_keys(thd, nullptr, table, &create_info, &alter_info,
+  if (prepare_fields_and_keys(thd, nullptr, &table, &create_info, &alter_info,
                               &alter_ctx, create_info.used_fields)) {
-    thd->mem_root = mem_root_backup;
     return true;
   }
 
@@ -1550,13 +1510,9 @@ static bool migrate_table_to_dd(THD *thd, const String_type &schema_name,
           &fk_key_count, alter_ctx.fk_info, alter_ctx.fk_count,
           alter_ctx.fk_max_generated_name_number, 0,
           false /* No FKs here. */)) {
-    thd->mem_root = mem_root_backup;
     return true;
   }
 
-  // Restore thd mem_root
-  thd->mem_root = mem_root_backup;
-
   int select_field_pos = alter_info.create_list.elements;
   create_info.null_bits = 0;
   Create_field *sql_field;
@@ -1564,7 +1520,7 @@ static bool migrate_table_to_dd(THD *thd, const String_type &schema_name,
 
   for (int field_no = 0; (sql_field = it_create++); field_no++) {
     if (prepare_create_field(thd, &create_info, &alter_info.create_list,
-                             &select_field_pos, table->file, sql_field,
+                             &select_field_pos, table.file, sql_field,
                              field_no))
       return true;
   }
@@ -1576,7 +1532,7 @@ static bool migrate_table_to_dd(THD *thd, const String_type &schema_name,
   lex_start(thd);
   table_guard.update_lex(lex_saved);
 
-  if (fill_partition_info_for_upgrade(thd, &share, &frm_context, table))
+  if (fill_partition_info_for_upgrade(thd, &share, &frm_context, &table))
     return true;
 
   // Add name of all tablespaces used by partitions to the hash set.
@@ -1632,7 +1588,7 @@ static bool migrate_table_to_dd(THD *thd, const String_type &schema_name,
   */
   Bootstrap_error_handler bootstrap_error_handler;
   bootstrap_error_handler.set_log_error(false);
-  if (fix_generated_columns_for_upgrade(thd, table, alter_info.create_list)) {
+  if (fix_generated_columns_for_upgrade(thd, &table, alter_info.create_list)) {
     LogErr(ERROR_LEVEL, ER_CANT_UPGRADE_GENERATED_COLUMNS_TO_DD,
            schema_name.c_str(), table_name.c_str());
     return true;
@@ -1673,7 +1629,7 @@ static bool migrate_table_to_dd(THD *thd, const String_type &schema_name,
   std::unique_ptr<dd::Table> table_def = dd::create_dd_user_table(
       thd, *sch_obj, to_table_name, &create_info, alter_info.create_list,
       key_info_buffer, key_count, Alter_info::ENABLE, fk_key_info_buffer,
-      fk_number, table->file);
+      fk_number, table.file);
 
   if (!table_def || thd->dd_client()->store(table_def.get())) {
     LogErr(ERROR_LEVEL, ER_DD_ERROR_CREATING_ENTRY, schema_name.c_str(),
@@ -1690,7 +1646,7 @@ static bool migrate_table_to_dd(THD *thd, const String_type &schema_name,
     return true;
   }
 
-  if (set_se_data_for_user_tables(thd, schema_name, to_table_name, table,
+  if (set_se_data_for_user_tables(thd, schema_name, to_table_name, &table,
                                   is_innodb_stats_table)) {
     LogErr(ERROR_LEVEL, ER_DD_CANT_FIX_SE_DATA, schema_name.c_str(),
            table_name.c_str());
@@ -1702,11 +1658,7 @@ static bool migrate_table_to_dd(THD *thd, const String_type &schema_name,
     return true;
   }
 
-  MEM_ROOT *thd_mem_root = thd->mem_root;
-  thd->mem_root = &table->mem_root;
-  error = add_triggers_to_table(thd, table, schema_name, table_name);
-  thd->mem_root = thd_mem_root;
-
+  error = add_triggers_to_table(thd, &table, schema_name, table_name);
   return error;
 }
 
@@ -1730,6 +1682,8 @@ bool migrate_all_frm_to_dd(THD *thd, const char *dbname,
   MY_DIR *a;
   String_type path;
   bool error = false;
+  MEM_ROOT root(PSI_NOT_INSTRUMENTED, 65536);
+  Thd_mem_root_guard root_guard(thd, &root);
 
   path.assign(mysql_real_data_home);
   path += dbname;
@@ -1796,6 +1750,7 @@ bool migrate_all_frm_to_dd(THD *thd, const char *dbname,
         will fail and error log will report error false positives.
      */
       thd->clear_error();
+      root.ClearForReuse();
     }
   }
   my_dirend(a);
diff --git a/sql/dd/upgrade/upgrade.cc b/sql/dd/upgrade/upgrade.cc
index 36f4905fce7..69b29d49653 100644
--- a/sql/dd/upgrade/upgrade.cc
+++ b/sql/dd/upgrade/upgrade.cc
@@ -54,6 +54,7 @@
 #include "sql/dd/info_schema/metadata.h"     // dd::info_schema::install_IS...
 #include "sql/dd/sdi_file.h"                 // dd::sdi_file::EXT
 #include "sql/dd/types/object_table.h"
+#include "sql/dd/types/table.h"  // dd::Table
 #include "sql/dd/types/tablespace.h"
 #include "sql/dd/upgrade/event.h"
 #include "sql/dd/upgrade/global.h"
@@ -469,26 +470,28 @@ bool add_sdi_info(THD *thd) {
   // Fetch list of tablespaces. We will ignore error in storing SDI info
   // as upgrade can only roll forward in this stage. Use Error handler to avoid
   // any error calls in dd::sdi::store()
-  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
-  std::vector<const dd::Tablespace *> tablespaces;
+  std::vector<dd::String_type> tablespace_names;
   Dummy_error_handler error_handler;
+  MEM_ROOT mem_root(PSI_NOT_INSTRUMENTED, MEM_ROOT_BLOCK_SIZE);
+  Thd_mem_root_guard root_guard(thd, &mem_root);
 
-  if (thd->dd_client()->fetch_global_components(&tablespaces)) {
+  if (thd->dd_client()->fetch_global_component_names<dd::Tablespace>(
+          &tablespace_names)) {
     LogErr(ERROR_LEVEL, ER_DD_UPGRADE_FAILED_TO_FETCH_TABLESPACES);
     return (true);
   }
 
   // Add sdi info
   thd->push_internal_handler(&error_handler);
-  for (const dd::Tablespace *tsc : tablespaces) {
+  for (dd::String_type &tsc : tablespace_names) {
+    dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
     Disable_autocommit_guard autocommit_guard(thd);
     dd::Tablespace *ts = nullptr;
 
-    if (thd->dd_client()->acquire_for_modification<dd::Tablespace>(tsc->name(),
-                                                                   &ts)) {
+    if (thd->dd_client()->acquire_for_modification<dd::Tablespace>(tsc, &ts)) {
       // In case of error, we will continue with upgrade.
       LogErr(ERROR_LEVEL, ER_DD_UPGRADE_FAILED_TO_ACQUIRE_TABLESPACE,
-             ts->name().c_str());
+             tsc.c_str());
       continue;
     }
 
@@ -522,20 +525,34 @@ bool add_sdi_info(THD *thd) {
       trans_commit_stmt(thd);
       trans_commit(thd);
     }
+    mem_root.ClearForReuse();
   }
   thd->pop_internal_handler();
 
   // Fetch list of tables from dictionary
-  std::vector<const dd::Table *> tables;
-  if (thd->dd_client()->fetch_global_components(&tables)) {
+  std::vector<dd::Object_id> table_ids;
+  if (thd->dd_client()->fetch_global_component_ids<dd::Table>(&table_ids)) {
     LogErr(ERROR_LEVEL, ER_DD_UPGRADE_FAILED_TO_FETCH_TABLES);
     return (true);
   }
 
   // Add sdi info
   thd->push_internal_handler(&error_handler);
-  for (const dd::Table *tab : tables) {
-    (void)dd::sdi::store(thd, tab);
+  for (dd::Object_id &table_id : table_ids) {
+    dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
+    const dd::Table *table = nullptr;
+    if (thd->dd_client()->acquire(table_id, &table) || !table) {
+      mem_root.ClearForReuse();
+      continue;
+    }
+
+    if (dd::sdi::store(thd, table)) {
+      LogErr(ERROR_LEVEL, ER_BAD_TABLE_ERROR, table->name().c_str());
+      trans_rollback_stmt(thd);
+    }
+    trans_commit_stmt(thd);
+    trans_commit(thd);
+    mem_root.ClearForReuse();
   }
   thd->pop_internal_handler();
 
@@ -1099,7 +1116,6 @@ bool fill_dd_and_finalize(THD *thd) {
 
   // Upgrade schema and tables, create view without resolving dependency
   for (it = db_name.begin(); it != db_name.end(); it++) {
-    dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());
     bool exists = false;
     dd::schema_exists(thd, it->c_str(), &exists);
 
diff --git a/sql/handler.h b/sql/handler.h
index cf848caceb6..cf4961bf740 100644
--- a/sql/handler.h
+++ b/sql/handler.h
@@ -1364,6 +1364,7 @@ typedef bool (*sdi_get_t)(const dd::Tablespace &tablespace,
 
 /**
   Insert/Update SDI for a given SDI key.
+  @param[in]  hton        handlerton object
   @param[in]  tablespace  tablespace object
   @param[in]  sdi_key     SDI key to uniquely identify SDI obj
   @param[in]  sdi         SDI to write into the tablespace
@@ -1372,7 +1373,7 @@ typedef bool (*sdi_get_t)(const dd::Tablespace &tablespace,
   @retval     true        failure, my_error() should be called
                           by SE
 */
-typedef bool (*sdi_set_t)(const dd::Tablespace &tablespace,
+typedef bool (*sdi_set_t)(handlerton *hton, const dd::Tablespace &tablespace,
                           const dd::Table *table, const dd::sdi_key_t *sdi_key,
                           const void *sdi, uint64 sdi_len);
 
diff --git a/sql/ndb_dummy_ts.h b/sql/ndb_dummy_ts.h
index b128e98d606..26247f6ae8e 100644
--- a/sql/ndb_dummy_ts.h
+++ b/sql/ndb_dummy_ts.h
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License, version 2.0,
@@ -101,6 +101,7 @@ namespace ndb_dummy_ts {
 
 
   /** Insert/Update SDI in tablespace
+    @param[in]	hton		handlerton object
     @param[in]	tablespace	tablespace object
     @param[in]	table		table object
     @param[in]	sdi_key		SDI key to uniquely identify the tablespace
@@ -111,8 +112,8 @@ namespace ndb_dummy_ts {
     @retval		true		failure
   */
   static
-  bool sdi_set(const dd::Tablespace&, const dd::Table*, const dd::sdi_key_t*,
-               const void*, uint64)
+  bool sdi_set(handlerton *hton, const dd::Tablespace&, const dd::Table*,
+               const dd::sdi_key_t*, const void*, uint64)
   {
     return false; // Success
   }
diff --git a/sql/sql_class.cc b/sql/sql_class.cc
index 348e8b9dee9..13ab695841c 100644
--- a/sql/sql_class.cc
+++ b/sql/sql_class.cc
@@ -141,7 +141,7 @@ THD::Attachable_trx::Attachable_trx(THD *thd, Attachable_trx *prev_trx)
     : m_thd(thd),
       m_reset_lex(RESET_LEX),
       m_prev_attachable_trx(prev_trx),
-      m_trx_state(&thd->main_mem_root) {
+      m_trx_state() {
   init();
 }
 
@@ -150,7 +150,7 @@ THD::Attachable_trx::Attachable_trx(THD *thd, Attachable_trx *prev_trx,
     : m_thd(thd),
       m_reset_lex(reset_lex),
       m_prev_attachable_trx(prev_trx),
-      m_trx_state(&thd->main_mem_root) {
+      m_trx_state() {
   init();
 }
 
@@ -2704,10 +2704,12 @@ void add_order_to_list(THD *thd, ORDER *order) {
   thd->lex->select_lex->add_order_to_list(order);
 }
 
-THD::Transaction_state::Transaction_state(MEM_ROOT *root)
-    : m_query_tables_list(new (root) Query_tables_list),
+THD::Transaction_state::Transaction_state()
+    : m_query_tables_list(new Query_tables_list()),
       m_ha_data(PSI_NOT_INSTRUMENTED, m_ha_data.initial_capacity) {}
 
+THD::Transaction_state::~Transaction_state() { delete m_query_tables_list; }
+
 void THD::change_item_tree(Item **place, Item *new_value) {
   /* TODO: check for OOM condition here */
   if (!stmt_arena->is_conventional()) {
diff --git a/sql/sql_class.h b/sql/sql_class.h
index 5bf81744767..d4ae7eac69c 100644
--- a/sql/sql_class.h
+++ b/sql/sql_class.h
@@ -1518,7 +1518,8 @@ class THD : public MDL_context_owner,
 
   /** An utility struct for @c Attachable_trx */
   struct Transaction_state {
-    Transaction_state(MEM_ROOT *root);
+    Transaction_state();
+    ~Transaction_state();
     void backup(THD *thd);
     void restore(THD *thd);
 
diff --git a/storage/innobase/dict/dict0sdi.cc b/storage/innobase/dict/dict0sdi.cc
index f6b2b1b5785..87a43f6d9e2 100644
--- a/storage/innobase/dict/dict0sdi.cc
+++ b/storage/innobase/dict/dict0sdi.cc
@@ -285,6 +285,7 @@ bool dict_sdi_get(const dd::Tablespace &tablespace,
 }
 
 /** Insert/Update SDI in tablespace
+@param[in]	hton		handlerton object
 @param[in]	tablespace	tablespace object
 @param[in]	table		table object
 @param[in]	sdi_key		SDI key to uniquely identify the tablespace
@@ -293,9 +294,9 @@ object
 @param[in]	sdi_len		SDI length
 @retval		false		success
 @retval		true		failure */
-bool dict_sdi_set(const dd::Tablespace &tablespace, const dd::Table *table,
-                  const dd::sdi_key_t *sdi_key, const void *sdi,
-                  uint64 sdi_len) {
+bool dict_sdi_set(handlerton *hton, const dd::Tablespace &tablespace,
+                  const dd::Table *table, const dd::sdi_key_t *sdi_key,
+                  const void *sdi, uint64 sdi_len) {
   const char *operation = "set";
 
   DBUG_EXECUTE_IF("ib_sdi", ib::info(ER_IB_MSG_215)
@@ -360,6 +361,8 @@ bool dict_sdi_set(const dd::Tablespace &tablespace, const dd::Table *table,
   trx_t *trx = check_trx_exists(current_thd);
   trx_start_if_not_started(trx, true);
 
+  innobase_register_trx(hton, current_thd, trx);
+
   ib_sdi_key_t ib_sdi_key;
   ib_sdi_key.sdi_key = sdi_key;
 
diff --git a/storage/innobase/include/dict0sdi.h b/storage/innobase/include/dict0sdi.h
index 9176ec33c67..fd0aff0291a 100644
--- a/storage/innobase/include/dict0sdi.h
+++ b/storage/innobase/include/dict0sdi.h
@@ -1,6 +1,6 @@
 /*****************************************************************************
 
-Copyright (c) 2017, Oracle and/or its affiliates. All Rights Reserved.
+Copyright (c) 2017, 2018, Oracle and/or its affiliates. All Rights Reserved.
 
 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License, version 2.0, as published by the
@@ -126,6 +126,7 @@ bool dict_sdi_get(const dd::Tablespace &tablespace,
                   const dd::sdi_key_t *sdi_key, void *sdi, uint64 *sdi_len);
 
 /** Insert/Update SDI in tablespace.
+@param[in]	hton            handlerton object
 @param[in]	tablespace	tablespace object
 @param[in]	table		table object
 @param[in]	sdi_key		SDI key to uniquely identify the tablespace
@@ -134,9 +135,9 @@ object
 @param[in]	sdi_len		SDI length
 @retval		false		success
 @retval		true		failure */
-bool dict_sdi_set(const dd::Tablespace &tablespace, const dd::Table *table,
-                  const dd::sdi_key_t *sdi_key, const void *sdi,
-                  uint64 sdi_len);
+bool dict_sdi_set(handlerton *hton, const dd::Tablespace &tablespace,
+                  const dd::Table *table, const dd::sdi_key_t *sdi_key,
+                  const void *sdi, uint64 sdi_len);
 
 /** Delete SDI from tablespace.
 @param[in]	tablespace	tablespace object

