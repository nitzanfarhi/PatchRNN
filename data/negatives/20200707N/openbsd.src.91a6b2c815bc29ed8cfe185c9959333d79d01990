commit 91a6b2c815bc29ed8cfe185c9959333d79d01990
Author: miod <miod@openbsd.org>
Date:   Wed Oct 9 21:28:33 2013 +0000

    Quick'n'dirty code to match trivial on-disk boot paths as the boot device.
    Needs more work in order to cover all cases, but enough to get internal
    disks on the first controller on models 4600 and 530 to get matched.
    
    This makes the aviion port finally self-hosting on aforementioned models,
    finally! Next step: bsd.rd...

diff --git a/sys/arch/aviion/aviion/autoconf.c b/sys/arch/aviion/aviion/autoconf.c
index 2b3aa3c0011..373112379eb 100644
--- a/sys/arch/aviion/aviion/autoconf.c
+++ b/sys/arch/aviion/aviion/autoconf.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: autoconf.c,v 1.14 2013/09/24 20:14:33 miod Exp $	*/
+/*	$OpenBSD: autoconf.c,v 1.15 2013/10/09 21:28:33 miod Exp $	*/
 /*
  * Copyright (c) 1998 Steve Murphree, Jr.
  * Copyright (c) 1996 Nivas Madhur
@@ -55,6 +55,9 @@
 
 #include <dev/cons.h>
 
+#include "sd.h"
+#include "st.h"
+
 /*
  * The following several variables are related to
  * the configuration process, and are used in initializing
@@ -67,14 +70,23 @@ int cold = 1;   /* 1 if still booting */
 
 struct device *bootdv;	/* set by device drivers (if found) */
 
-u_int bootdevtype;
+uint32_t bootdevtype;
 
+/* cied */
 #define	BT_CIEN		0x6369656e
+/* cimd */
+/* cird */
+/* cisc */
 #define	BT_DGEN		0x6467656e
+#define	BT_DGSC		0x64677363
+/* hada */
 #define	BT_HKEN		0x686b656e
 #define	BT_INEN		0x696e656e
 #define	BT_INSC		0x696e7363
 #define	BT_NCSC		0x6e637363
+/* nvrd */
+/* pefn */
+/* vitr */
 
 /*
  * called at boot time, configure all devices on the system.
@@ -138,6 +150,7 @@ void
 cmdline_parse(void)
 {
 	char *p;
+	
 
 	/*
 	 * If the boot commandline has been manually entered, it
@@ -180,30 +193,39 @@ cmdline_parse(void)
 	 * and partition numbers for us already, and we do not care about
 	 * our own filename...
 	 *
-	 * Actually we rely upon the fact that all device strings are
-	 * exactly 4 characters long, and appears at the beginning of the
-	 * commandline, so we can simply use its numerical value, as a
-	 * word, to tell device types apart.
+	 * However, in the sd() or st() cases, we need to figure out the
+	 * SCSI controller name (if not the default one) and address, if
+	 * provided.
 	 */
-	bcopy(bootargs, &bootdevtype, sizeof(int));
+	if (memcmp(bootargs, "sd", 2) == 0 ||
+	    memcmp(bootargs, "st", 2) == 0) {
+		bcopy(platform->default_boot, &bootdevtype, sizeof(uint32_t));
+		/* search for a controller specification */
+	} else
+		bcopy(bootargs, &bootdevtype, sizeof(int));
 }
 
 void
 device_register(struct device *dev, void *aux)
 {
 	struct confargs *ca = (struct confargs *)aux;
+	struct cfdriver *cf = dev->dv_cfdata->cf_driver;
 
 	if (bootdv != NULL)
 		return;
-
+/* SCSI -> match bootunit/bootpart as id:lun iff controller matches */
 	switch (bootdevtype) {
+
+	/*
+	 * Network devices
+	 */
+
 	case BT_INEN:
 		/*
 		 * Internal LANCE Ethernet is le at syscon only, and we do not
 		 * care about controller and unit numbers.
 		 */
-		if (strcmp("le", dev->dv_cfdata->cf_driver->cd_name) == 0 &&
-		    strcmp("syscon",
+		if (strcmp("le", cf->cd_name) == 0 && strcmp("syscon",
 		      dev->dv_parent->dv_cfdata->cf_driver->cd_name) == 0)
 			bootdv = dev;
 		break;
@@ -212,8 +234,7 @@ device_register(struct device *dev, void *aux)
 		 * Internal ILACC Ethernet is le at syscon only, and need to
 		 * match the controller address.
 		 */
-		if (strcmp("le", dev->dv_cfdata->cf_driver->cd_name) == 0 &&
-		    strcmp("syscon",
+		if (strcmp("le", cf->cd_name) == 0 && strcmp("syscon",
 		      dev->dv_parent->dv_cfdata->cf_driver->cd_name) == 0) {
 			switch (cpuid) {
 #ifdef AV530
@@ -230,6 +251,44 @@ device_register(struct device *dev, void *aux)
 			}
 		}
 		break;
+
+	/*
+	 * SCSI controllers
+	 */
+
+	case BT_NCSC:
+		/*
+		 * Internal 53C700 controller is oosiop at syscon only, and
+		 * needs to match the controller address, as well as SCSI
+		 * unit and lun numbers.
+		 */
+	    {
+		struct scsi_attach_args *sa = aux;
+		struct device *grandp;
+
+		if (memcmp(cf->cd_name, bootargs, 2) != 0 ||
+		    (strcmp("sd", cf->cd_name) != 0 &&
+		     strcmp("st", cf->cd_name) != 0) ||
+		    sa->sa_sc_link->target != bootunit ||
+		    sa->sa_sc_link->lun != bootpart)
+			break;
+
+		grandp = dev->dv_parent->dv_parent;
+		if (strcmp("oosiop",
+		    grandp->dv_cfdata->cf_driver->cd_name) == 0) {
+			bootdv = dev;	/* XXX second controller */
+		}
+	    }
+		break;
+
+	case BT_INSC:
+		/*
+		 * Internal AIC-6250 controller is oaic at syscon only, and
+		 * needs to match the controller address, as well as SCSI
+		 * unit and lun numbers.
+		 */
+		/* XXX TBD */
+		break;
 	}
 }
 
diff --git a/sys/arch/aviion/aviion/av400_machdep.c b/sys/arch/aviion/aviion/av400_machdep.c
index 4e1b2b8c819..4faa32433c0 100644
--- a/sys/arch/aviion/aviion/av400_machdep.c
+++ b/sys/arch/aviion/aviion/av400_machdep.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: av400_machdep.c,v 1.23 2013/10/07 19:11:39 miod Exp $	*/
+/*	$OpenBSD: av400_machdep.c,v 1.24 2013/10/09 21:28:33 miod Exp $	*/
 /*
  * Copyright (c) 2006, 2007, Miodrag Vallat.
  *
@@ -206,7 +206,8 @@ const struct board board_av400 = {
 	av400_exintsrc,
 	av400_get_vme_ranges,
 
-	av400_ptable
+	av400_ptable,
+	"insc"
 };
 
 /*
diff --git a/sys/arch/aviion/aviion/av530_machdep.c b/sys/arch/aviion/aviion/av530_machdep.c
index b829d7c73f3..a74636cbb5c 100644
--- a/sys/arch/aviion/aviion/av530_machdep.c
+++ b/sys/arch/aviion/aviion/av530_machdep.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: av530_machdep.c,v 1.9 2013/10/07 19:11:39 miod Exp $	*/
+/*	$OpenBSD: av530_machdep.c,v 1.10 2013/10/09 21:28:33 miod Exp $	*/
 /*
  * Copyright (c) 2006, 2007, 2010 Miodrag Vallat.
  *
@@ -95,7 +95,8 @@ const struct board board_av530 = {
 	av530_exintsrc,
 	av530_get_vme_ranges,
 
-	av530_ptable
+	av530_ptable,
+	"ncsc"
 };
 
 /*
diff --git a/sys/arch/aviion/include/board.h b/sys/arch/aviion/include/board.h
index 74b3cc7ca38..b7647a0ae26 100644
--- a/sys/arch/aviion/include/board.h
+++ b/sys/arch/aviion/include/board.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: board.h,v 1.11 2013/10/07 19:11:42 miod Exp $	*/
+/*	$OpenBSD: board.h,v 1.12 2013/10/09 21:28:33 miod Exp $	*/
 /*
  * Copyright (c) 2006, 2007, Miodrag Vallat
  *
@@ -94,6 +94,7 @@ struct board {
 	const struct vme_range *(*get_vme_ranges)(void);
 
 	const struct pmap_table *ptable;
+	const char	*default_boot;
 };
 
 #define	md_interrupt_func(f)	platform->intr(f)

