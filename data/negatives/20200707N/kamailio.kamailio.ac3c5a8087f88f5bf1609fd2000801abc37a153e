commit ac3c5a8087f88f5bf1609fd2000801abc37a153e
Author: Daniel-Constantin Mierla <miconda@gmail.com>
Date:   Sat Apr 30 19:06:21 2011 +0200

    htable: new attribute 'initval' to hash table definition
    
    - initval can set init integer value for hash table keys, meaning that
      if the key is not set, the init value is returned by $sht(htable=>key)
    - useful for hash tables holding counters - the value can default to 0,
      avoiding extra check for $null value

diff --git a/modules_k/htable/ht_api.c b/modules_k/htable/ht_api.c
index 31f8543f8..23bc59e1d 100644
--- a/modules_k/htable/ht_api.c
+++ b/modules_k/htable/ht_api.c
@@ -215,7 +215,8 @@ ht_t* ht_get_table(str *name)
 	return NULL;
 }
 
-int ht_add_table(str *name, int autoexp, str *dbtable, int size, int dbmode)
+int ht_add_table(str *name, int autoexp, str *dbtable, int size, int dbmode,
+		int itype, int_str *ival)
 {
 	unsigned int htid;
 	ht_t *ht;
@@ -254,6 +255,9 @@ int ht_add_table(str *name, int autoexp, str *dbtable, int size, int dbmode)
 	if(dbtable!=NULL && dbtable->len>0)
 		ht->dbtable = *dbtable;
 	ht->dbmode = dbmode;
+	ht->flags = itype;
+	if(ival!=NULL)
+		ht->initval = *ival;
 
 	ht->next = _ht_root;
 	_ht_root = ht;
@@ -605,6 +609,8 @@ int ht_table_spec(char *spec)
 	str in;
 	str tok;
 	param_t *pit=NULL;
+	int_str ival;
+	int itype;
 
 	if(!shm_initialized())
 	{
@@ -620,6 +626,8 @@ int ht_table_spec(char *spec)
 		return -1;
 	}
 	name = kval.key;
+	itype = PV_VAL_NONE;
+	memset(&ival, 0, sizeof(int_str));
 
 	for (pit = kval.u.params; pit; pit=pit->next)
 	{
@@ -643,10 +651,17 @@ int ht_table_spec(char *spec)
 				goto error;
 			LM_DBG("htable [%.*s] - dbmode [%u]\n", name.len, name.s,
 					dbmode);
+		} else if(pit->name.len==7 && strncmp(pit->name.s, "initval", 7)==0) {
+			if(str2sint(&tok, &ival.n)!=0)
+				goto error;
+			itype = PV_VAL_INT;
+			LM_DBG("htable [%.*s] - initval [%d]\n", name.len, name.s,
+					ival.n);
 		} else { goto error; }
 	}
 
-	return ht_add_table(&name, autoexpire, &dbtable, size, dbmode);
+	return ht_add_table(&name, autoexpire, &dbtable, size, dbmode,
+			itype, &ival);
 
 error:
 	LM_ERR("invalid htable parameter [%.*s]\n", in.len, in.s);
diff --git a/modules_k/htable/ht_api.h b/modules_k/htable/ht_api.h
index a55e6cd83..6a92f29de 100644
--- a/modules_k/htable/ht_api.h
+++ b/modules_k/htable/ht_api.h
@@ -55,6 +55,8 @@ typedef struct _ht
 	unsigned int htexpire;
 	str dbtable;
 	int dbmode;
+	int flags;
+	int_str initval;
 	unsigned int htsize;
 	ht_entry_t *entries;
 	struct _ht *next;
@@ -66,7 +68,8 @@ typedef struct _ht_pv {
 	pv_elem_t *pve;
 } ht_pv_t, *ht_pv_p;
 
-int ht_add_table(str *name, int autoexp, str *dbtable, int size, int dbmode);
+int ht_add_table(str *name, int autoexp, str *dbtable, int size, int dbmode,
+		int itype, int_str *ival);
 int ht_init_tables(void);
 int ht_destroy(void);
 int ht_set_cell(ht_t *ht, str *name, int type, int_str *val, int mode);
diff --git a/modules_k/htable/ht_var.c b/modules_k/htable/ht_var.c
index 03ca66f90..0d52254ae 100644
--- a/modules_k/htable/ht_var.c
+++ b/modules_k/htable/ht_var.c
@@ -48,7 +48,11 @@ int pv_get_ht_cell(struct sip_msg *msg,  pv_param_t *param,
 	}
 	htc = ht_cell_pkg_copy(hpv->ht, &htname, _htc_local);
 	if(htc==NULL)
+	{
+		if(hpv->ht->flags==PV_VAL_INT)
+			return pv_get_sintval(msg, param, res, hpv->ht->initval.n);
 		return pv_get_null(msg, param, res);
+	}
 	if(_htc_local!=htc)
 	{
 		ht_cell_pkg_free(_htc_local);

