commit 3ea6a81568f5902ff59ada61b073d8d4a6df5fbf
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Fri Jan 8 20:13:46 2016 +0100

    greybus: connection: refactor connection enable and disable
    
    Refactor connection enable and disable.
    
    This is a step towards removing the legacy-protocol handling from core.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/connection.c b/drivers/staging/greybus/connection.c
index 1cb33147aa00..6295d28a4be4 100644
--- a/drivers/staging/greybus/connection.c
+++ b/drivers/staging/greybus/connection.c
@@ -387,17 +387,13 @@ static int gb_connection_protocol_get_version(struct gb_connection *connection)
 	return 0;
 }
 
-int gb_connection_init(struct gb_connection *connection)
+int gb_connection_enable(struct gb_connection *connection)
 {
 	int ret;
 
-	ret = gb_connection_bind_protocol(connection);
-	if (ret)
-		return ret;
-
 	ret = gb_connection_hd_cport_enable(connection);
 	if (ret)
-		goto err_unbind_protocol;
+		return ret;
 
 	ret = gb_connection_svc_connection_create(connection);
 	if (ret)
@@ -411,26 +407,58 @@ int gb_connection_init(struct gb_connection *connection)
 	if (ret)
 		goto err_svc_destroy;
 
-	ret = gb_connection_protocol_get_version(connection);
-	if (ret)
-		goto err_disconnect;
+	return 0;
 
-	ret = connection->protocol->connection_init(connection);
-	if (ret)
-		goto err_disconnect;
+err_svc_destroy:
+	spin_lock_irq(&connection->lock);
+	connection->state = GB_CONNECTION_STATE_DISABLED;
+	spin_unlock_irq(&connection->lock);
 
-	return 0;
+	gb_connection_svc_connection_destroy(connection);
+err_hd_cport_disable:
+	gb_connection_hd_cport_disable(connection);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(gb_connection_enable);
 
-err_disconnect:
+void gb_connection_disable(struct gb_connection *connection)
+{
 	gb_connection_control_disconnected(connection);
 
 	spin_lock_irq(&connection->lock);
 	connection->state = GB_CONNECTION_STATE_DISABLED;
 	spin_unlock_irq(&connection->lock);
-err_svc_destroy:
+
 	gb_connection_svc_connection_destroy(connection);
-err_hd_cport_disable:
 	gb_connection_hd_cport_disable(connection);
+}
+EXPORT_SYMBOL_GPL(gb_connection_disable);
+
+int gb_connection_init(struct gb_connection *connection)
+{
+	int ret;
+
+	ret = gb_connection_bind_protocol(connection);
+	if (ret)
+		return ret;
+
+	ret = gb_connection_enable(connection);
+	if (ret)
+		goto err_unbind_protocol;
+
+	ret = gb_connection_protocol_get_version(connection);
+	if (ret)
+		goto err_disable;
+
+	ret = connection->protocol->connection_init(connection);
+	if (ret)
+		goto err_disable;
+
+	return 0;
+
+err_disable:
+	gb_connection_disable(connection);
 err_unbind_protocol:
 	gb_connection_unbind_protocol(connection);
 
@@ -448,17 +476,10 @@ void gb_connection_exit(struct gb_connection *connection)
 	spin_unlock_irq(&connection->lock);
 
 	gb_connection_cancel_operations(connection, -ESHUTDOWN);
-
 	connection->protocol->connection_exit(connection);
 
-	gb_connection_control_disconnected(connection);
+	gb_connection_disable(connection);
 
-	spin_lock_irq(&connection->lock);
-	connection->state = GB_CONNECTION_STATE_DISABLED;
-	spin_unlock_irq(&connection->lock);
-
-	gb_connection_svc_connection_destroy(connection);
-	gb_connection_hd_cport_disable(connection);
 	gb_connection_unbind_protocol(connection);
 }
 

