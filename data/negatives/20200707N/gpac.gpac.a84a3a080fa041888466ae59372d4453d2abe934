commit a84a3a080fa041888466ae59372d4453d2abe934
Author: Jean Le Feuvre <jeanlf@users.sourceforge.net>
Date:   Tue Oct 22 08:49:56 2013 +0000

    Fixed android and partial compilation build
    
    git-svn-id: http://svn.code.sf.net/p/gpac/code/trunk/gpac@4849 63c20433-aa62-49bd-875c-5a186b69a8fb

diff --git a/include/gpac/internal/compositor_dev.h b/include/gpac/internal/compositor_dev.h
index 270a9c265..526896e61 100644
--- a/include/gpac/internal/compositor_dev.h
+++ b/include/gpac/internal/compositor_dev.h
@@ -475,8 +475,6 @@ struct __tag_compositor
 
 	u32 offscreen_width, offscreen_height;
 
-	u32 texture_from_decoder_memory;
-
 #ifdef GPAC_USE_TINYGL
 	void *tgl_ctx;
 #endif
@@ -490,6 +488,8 @@ struct __tag_compositor
 	Fixed focus_distance;
 #endif
 	
+	Bool texture_from_decoder_memory;
+    
 	u32 networks_time;
 	u32 decoders_time;
 
diff --git a/modules/openhevc_dec/openhevc_dec.c b/modules/openhevc_dec/openhevc_dec.c
index fb9b5e418..b7788ec01 100644
--- a/modules/openhevc_dec/openhevc_dec.c
+++ b/modules/openhevc_dec/openhevc_dec.c
@@ -30,7 +30,7 @@
 #include <gpac/internal/media_dev.h>
 
 #include "openHevcWrapper.h"
-//#define OPEN_SHVC
+#define OPEN_SHVC
 
 
 #if defined(WIN32) && !defined(_WIN32_WCE) && !defined(__GNUC__)
@@ -106,7 +106,7 @@ static GF_Err HEVC_ConfigureStream(HEVCDec *ctx, GF_ESD *esd)
 			GF_HEVCParamArray *ar = gf_list_get(cfg->param_array, i);
 			for (j=0; j< gf_list_count(ar->nalus); j++) {
 				GF_AVCConfigSlot *sl = gf_list_get(ar->nalus, j);
-				libOpenHevcDecode(ctx->openHevcHandle, sl->data, sl->size, 0);
+				libOpenHevcDecode(ctx->openHevcHandle, sl->data, sl->size, 0, ctx->base_only);
 
 				if (ar->type==GF_HEVC_NALU_SEQ_PARAM) {
 					HEVCState hevc;
@@ -310,7 +310,7 @@ static GF_Err HEVC_ProcessData(GF_MediaDecoder *ifcg,
 	    openHevcFrame.pvV = (void*) pV;
 	    *outBufferLength = 0;
 
-		if ( libOpenHevcDecode(ctx->openHevcHandle, NULL, 0, 0) ) {
+		if ( libOpenHevcDecode(ctx->openHevcHandle, NULL, 0, 0, ctx->base_only) ) {
 			if (libOpenHevcGetOutputCpy(ctx->openHevcHandle, 1, &openHevcFrame)) {
 				*outBufferLength = ctx->out_size;
 			}
@@ -386,7 +386,7 @@ static GF_Err HEVC_ProcessData(GF_MediaDecoder *ifcg,
 #endif       
         
 		if (!skip && ctx->state_found) {
-			got_pic = libOpenHevcDecode(ctx->openHevcHandle, ptr, nalu_size, 0);
+			got_pic = libOpenHevcDecode(ctx->openHevcHandle, ptr, nalu_size, 0, ctx->base_only);
 			if (got_pic>0) {
 				nb_pics ++;
 				e = HEVC_flush_picture(ctx, outBuffer, outBufferLength);
diff --git a/src/compositor/compositor.c b/src/compositor/compositor.c
index 2af831604..d85eb63a8 100644
--- a/src/compositor/compositor.c
+++ b/src/compositor/compositor.c
@@ -1142,7 +1142,7 @@ void gf_sc_reload_config(GF_Compositor *compositor)
 #endif
 
 	sOpt = gf_cfg_get_key(compositor->user->config, "Compositor", "TextureFromDecoderMemory");
-	compositor->texture_from_decoder_memory = (sOpt && !strcmp(sOpt, "yes")) ? 1 : 0;
+	compositor->texture_from_decoder_memory = (sOpt && !strcmp(sOpt, "yes")) ? GF_TRUE : GF_FALSE;
 	if (!sOpt) 
 		gf_cfg_set_key(compositor->user->config, "Compositor", "TextureFromDecoderMemory", "no");
 
diff --git a/src/compositor/texturing_gl.c b/src/compositor/texturing_gl.c
index ecde9c12d..861b557d5 100644
--- a/src/compositor/texturing_gl.c
+++ b/src/compositor/texturing_gl.c
@@ -679,6 +679,46 @@ assert(txh->data );
 #endif
 
 
+#ifndef GPAC_DISABLE_3D
+static void do_tex_image_2d(GF_TextureHandler *txh, GLint tx_mode, Bool first_load, u8 *data, u32 stride, u32 w, u32 h)
+{
+    Bool needs_stride = (stride!=w*txh->tx_io->nb_comp) ? GF_TRUE : GF_FALSE; 
+#if !defined(GPAC_USE_OGL_ES)
+    if (needs_stride)
+        glPixelStorei(GL_UNPACK_ROW_LENGTH, stride);
+#else
+    u32 i;
+    if (needs_stride) {
+#endif        
+
+    if (first_load) {
+        glTexImage2D(txh->tx_io->gl_type, 0, tx_mode, w, h, 0, txh->tx_io->gl_format, txh->tx_io->gl_dtype, data);
+    } else {
+        glTexSubImage2D(txh->tx_io->gl_type, 0, 0, 0, w, h, txh->tx_io->gl_format, txh->tx_io->gl_dtype, data);
+    }
+    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
+
+#if !defined(GPAC_USE_OGL_ES)
+    if (needs_stride)
+        glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
+    return;
+#else
+    if (!needs_stride)
+        return;
+
+    //no GL_UNPACK_ROW_LENGTH on GLES, push line by line ...
+    if (first_load) {
+        glTexImage2D(txh->tx_io->gl_type, 0, tx_mode, w, h, 0, txh->tx_io->gl_format, txh->tx_io->gl_dtype, NULL);
+    }
+    for (i=0; i<h; i++) {
+        u8 *ptr = data + i*stride;
+        glTexSubImage2D(txh->tx_io->gl_type, 0, 0, 0, w, 1, txh->tx_io->gl_format, txh->tx_io->gl_dtype, ptr);
+    }
+#endif
+}
+
+#endif
+    
 Bool gf_sc_texture_push_image(GF_TextureHandler *txh, Bool generate_mipmaps, Bool for2d)
 {
 #ifndef GPAC_DISABLE_3D
@@ -777,27 +817,15 @@ Bool gf_sc_texture_push_image(GF_TextureHandler *txh, Bool generate_mipmaps, Boo
 			}
 
 			push_time = gf_sys_clock();
-			glPixelStorei(GL_UNPACK_ROW_LENGTH, txh->stride);
-			if (first_load) {
-				glTexImage2D(txh->tx_io->gl_type, 0, tx_mode, w, h, 0, txh->tx_io->gl_format, txh->tx_io->gl_dtype, pY);
-			} else {
-				glTexSubImage2D(txh->tx_io->gl_type, 0, 0, 0, w, h, txh->tx_io->gl_format, txh->tx_io->gl_dtype, pY);
-			}
+            
+            do_tex_image_2d(txh, tx_mode, first_load, pY, txh->stride, w, h);
 
-			glPixelStorei(GL_UNPACK_ROW_LENGTH, txh->stride/2);
 			glBindTexture(txh->tx_io->gl_type, txh->tx_io->u_id);
-			if (first_load) {
-				glTexImage2D(txh->tx_io->gl_type, 0, tx_mode, w/2, h/2, 0, txh->tx_io->gl_format, txh->tx_io->gl_dtype, pU);
-			} else {
-				glTexSubImage2D(txh->tx_io->gl_type, 0, 0, 0, w/2, h/2, txh->tx_io->gl_format, txh->tx_io->gl_dtype, pU);
-			}
-			glPixelStorei(GL_UNPACK_ROW_LENGTH, txh->stride/2);
-			glBindTexture(txh->tx_io->gl_type, txh->tx_io->v_id);
-			if (first_load) {
-				glTexImage2D(txh->tx_io->gl_type, 0, tx_mode, w/2, h/2, 0, txh->tx_io->gl_format, txh->tx_io->gl_dtype, pV);
-			} else {
-				glTexSubImage2D(txh->tx_io->gl_type, 0, 0, 0, w/2, h/2, txh->tx_io->gl_format, txh->tx_io->gl_dtype, pV);
-			}
+            do_tex_image_2d(txh, tx_mode, first_load, pU, txh->stride/2, w/2, h/2);
+			
+            glBindTexture(txh->tx_io->gl_type, txh->tx_io->v_id);
+            do_tex_image_2d(txh, tx_mode, first_load, pV, txh->stride/2, w/2, h/2);
+            
 			push_time = gf_sys_clock() - push_time;
 
 			if (txh->nb_frames==100) {

