commit 455046d9de60ae00c88039f4027f802c86ae2549
Author: Jean Le Feuvre <jeanlf@users.sourceforge.net>
Date:   Thu Dec 5 15:33:26 2013 +0000

    Added VTT patch on CENC: key roll and saiz/saio access
    
    git-svn-id: http://svn.code.sf.net/p/gpac/code/trunk/gpac@4932 63c20433-aa62-49bd-875c-5a186b69a8fb

diff --git a/include/gpac/internal/isomedia_dev.h b/include/gpac/internal/isomedia_dev.h
index cbc1b000f..102762fd2 100644
--- a/include/gpac/internal/isomedia_dev.h
+++ b/include/gpac/internal/isomedia_dev.h
@@ -2669,6 +2669,8 @@ GF_Err reftype_AddRefTrack(GF_TrackReferenceTypeBox *ref, u32 trackID, u16 *outR
 
 GF_XMLBox *gf_isom_get_meta_xml(GF_ISOFile *file, Bool root_meta, u32 track_num, Bool *is_binary);
 void gf_isom_cenc_set_saiz_saio(GF_SampleEncryptionBox *senc, GF_SampleTableBox *stbl, GF_TrackFragmentBox  *traf, u32 len);
+void gf_isom_cenc_merge_saiz_saio(GF_SampleEncryptionBox *senc, GF_SampleTableBox *stbl, u32 offset, u32 len);
+Bool gf_isom_cenc_has_saiz_saio(GF_SampleTableBox *stbl, GF_TrackFragmentBox *traf);
 
 #ifndef GPAC_DISABLE_ISOM_HINTING
 
diff --git a/include/gpac/ismacryp.h b/include/gpac/ismacryp.h
index 0afc336e7..78fb2dfda 100644
--- a/include/gpac/ismacryp.h
+++ b/include/gpac/ismacryp.h
@@ -59,7 +59,7 @@ enum
 
 typedef struct
 {
-	/*0: ISMACryp - 1: OMA DRM*/
+	/*0: ISMACryp - 1: OMA DRM - 2: CENC CTR - 3: CENC CBC*/
 	u32 enc_type;
 	u32 trackID;
 	unsigned char key[16];
diff --git a/include/gpac/isomedia.h b/include/gpac/isomedia.h
index c8c4bc39a..3ae82de0a 100644
--- a/include/gpac/isomedia.h
+++ b/include/gpac/isomedia.h
@@ -1931,7 +1931,7 @@ GF_Err gf_isom_track_cenc_add_sample_info(GF_ISOFile *the_file, u32 trackNumber,
 
 typedef struct 
 {
-	u32 bytes_clear_data;
+	u16 bytes_clear_data;
 	u32 bytes_encrypted_data;
 } GF_CENCSubSampleEntry;
 
@@ -1942,6 +1942,7 @@ typedef struct __cenc_sample_aux_info
 	GF_CENCSubSampleEntry *subsamples;
 } GF_CENCSampleAuxInfo;
 
+
 GF_Err gf_isom_set_cenc_protection(GF_ISOFile *the_file, u32 trackNumber, u32 desc_index, u32 scheme_type, 
 									u32 scheme_version, u32 default_IsEncrypted, u8 default_IV_size, bin128 default_KID);
 
@@ -1963,9 +1964,9 @@ void gf_isom_cenc_samp_aux_info_del(GF_CENCSampleAuxInfo *samp_aux_info);
 #endif
 
 /*boxType is type of box which contains the sample auxiliary information. Now we have two type: GF_ISOM_BOX_UUID_PSEC and GF_ISOM_BOX_TYPE_SENC*/
-GF_CENCSampleAuxInfo * gf_isom_cenc_get_sample_aux_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *container_type);
+GF_Err gf_isom_cenc_get_sample_aux_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, GF_CENCSampleAuxInfo **sai, u32 *container_type);
 
-void gf_isom_cenc_get_KID(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, bin128 *outKID);
+void gf_isom_cenc_get_default_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *default_IsEncrypted, u8 *default_IV_size, bin128 *default_KID);
 
 u32 gf_isom_get_pssh_count(GF_ISOFile *file);
 /*index is 1-based, all pointers shall not be free*/
@@ -2263,10 +2264,14 @@ GF_Err gf_isom_set_sample_rap_group(GF_ISOFile *movie, u32 track, u32 sample_num
 - currently sample group info MUST be added in order (no insertion in the tables)*/
 GF_Err gf_isom_set_sample_roll_group(GF_ISOFile *movie, u32 track, u32 sample_number, s16 roll_distance);
 
+/*set encryption group for a sample_number; buf specifies the parameters for this group: IsEncrypted, IV_size, KID*/ 
+GF_Err gf_isom_set_sample_cenc_group(GF_ISOFile *movie, u32 track, u32 sample_number, Bool isEncrypted, u8 IV_size, bin128 KeyID);
+
 GF_Err gf_isom_set_composition_offset_mode(GF_ISOFile *file, u32 track, Bool use_negative_offsets);
 
 #endif
 
+GF_Err gf_isom_get_sample_cenc_info(GF_ISOFile *movie, u32 track, u32 sample_number, u32 *IsEncrypted, u8 *IV_size, bin128 *KID);
 
 
 #endif /*GPAC_DISABLE_ISOM*/
diff --git a/modules/ismacryp/isma_ea.c b/modules/ismacryp/isma_ea.c
index f9b2f8e98..556967536 100644
--- a/modules/ismacryp/isma_ea.c
+++ b/modules/ismacryp/isma_ea.c
@@ -306,7 +306,15 @@ static GF_Err CENC_Setup(ISMAEAPriv *priv, GF_IPMPEvent *evt)
 		
 		/*now we search a key*/
 		priv->KID_count = pssh->KID_count;
+		if (priv->KIDs) {
+			gf_free(priv->KIDs);
+			priv->KIDs = NULL;
+		}
 		priv->KIDs = (bin128 *)gf_malloc(pssh->KID_count*sizeof(bin128));
+		if (priv->keys) {
+			gf_free(priv->keys);
+			priv->keys = NULL;
+		}
 		priv->keys = (bin128 *)gf_malloc(pssh->KID_count*sizeof(bin128));
 
 		memmove(priv->KIDs, pssh->KIDs, pssh->KID_count*sizeof(bin128));
@@ -392,15 +400,11 @@ static GF_Err CENC_ProcessData(ISMAEAPriv *priv, GF_IPMPEvent *evt)
 	if (sai->subsample_count) {
 		sai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(sai->subsample_count*sizeof(GF_CENCSubSampleEntry));
 		for (i = 0; i < sai->subsample_count; i++) {
-			sai->subsamples[i].bytes_clear_data = gf_bs_read_u32(sai_bs);
+			sai->subsamples[i].bytes_clear_data = gf_bs_read_u16(sai_bs);
 			sai->subsamples[i].bytes_encrypted_data = gf_bs_read_u32(sai_bs);
 		}
 	}
 
-	if (!strlen((char *)sai->IV)) {
-		e = GF_OK;
-		goto exit;
-	}
 
 	for (i = 0; i < priv->KID_count; i++) {
 		if (!strncmp((const char *)KID, (const char *)priv->KIDs[i], 16)) {
@@ -413,160 +417,30 @@ static GF_Err CENC_ProcessData(ISMAEAPriv *priv, GF_IPMPEvent *evt)
 		memmove(IV, sai->IV, 16);
 		e = gf_crypt_init(priv->crypt, priv->key, 16, IV);
 		if (e) {
-			GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot initialize AES-128 CTR (%s)\n", gf_error_to_string(e)) );
+			GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot initialize AES-128 AES-128 %s (%s)\n", priv->is_cenc ? "CTR" : "CBC", gf_error_to_string(e)) );
 			e = GF_IO_ERR;
 			goto exit;
 		}
 		priv->first_crypted_samp = GF_FALSE;
 	} else {
-		GF_BitStream *bs;
-		bs = gf_bs_new(IV, 17, GF_BITSTREAM_WRITE);
-		gf_bs_write_u8(bs, 0);	/*begin of counter*/
-		gf_bs_write_data(bs,(char *)sai->IV, 16);
-		gf_bs_del(bs);
-		gf_crypt_set_state(priv->crypt, IV, 17);
-	}
-
-	subsample_count = 0;
-	BSO = 0;
-	while (gf_bs_available(cyphertext_bs)) {
-		assert(subsample_count < sai->subsample_count);
-
-		/*read clear data and write it to pleintext bitstream*/
-		if (max_size < sai->subsamples[subsample_count].bytes_clear_data) {
-			buffer = (char*)gf_realloc(buffer, sizeof(char)*sai->subsamples[subsample_count].bytes_clear_data);
-			max_size = sai->subsamples[subsample_count].bytes_clear_data;
-		}
-		gf_bs_read_data(cyphertext_bs, buffer, sai->subsamples[subsample_count].bytes_clear_data);
-		gf_bs_write_data(pleintext_bs, buffer, sai->subsamples[subsample_count].bytes_clear_data);
-
-		/*now read encrypted data, decrypted it and write to pleintext bitstream*/
-		if (max_size < sai->subsamples[subsample_count].bytes_encrypted_data) {
-			buffer = (char*)gf_realloc(buffer, sizeof(char)*sai->subsamples[subsample_count].bytes_encrypted_data);
-			max_size = sai->subsamples[subsample_count].bytes_encrypted_data;
-		}
-		gf_bs_read_data(cyphertext_bs, buffer, sai->subsamples[subsample_count].bytes_encrypted_data);
-		gf_crypt_decrypt(priv->crypt, buffer, sai->subsamples[subsample_count].bytes_encrypted_data);
-		gf_bs_write_data(pleintext_bs, buffer, sai->subsamples[subsample_count].bytes_encrypted_data);
-
-		/*update IV for next subsample*/
-		BSO += sai->subsamples[subsample_count].bytes_encrypted_data;
-		if (gf_bs_available(cyphertext_bs)) {
-			char next_IV[17];
-			u64 prev_block_count, salt_portion, block_count_portion;
-			u32 remain;
-			GF_BitStream *bs, *tmp;
-
-			prev_block_count = BSO / 16;
-			remain = BSO % 16;
-			tmp = gf_bs_new(sai->IV, 16, GF_BITSTREAM_READ);
-			bs = gf_bs_new(next_IV, 17, GF_BITSTREAM_WRITE);
+		if (priv->is_cenc) {
+			GF_BitStream *bs;
+			bs = gf_bs_new(IV, 17, GF_BITSTREAM_WRITE);
 			gf_bs_write_u8(bs, 0);	/*begin of counter*/
-
-			salt_portion = gf_bs_read_u64(tmp);
-			block_count_portion = gf_bs_read_u64(tmp);
-			/*reset the block counter to zero without affecting the other 64 bits of the IV*/
-			if (prev_block_count > 0xFFFFFFFFFFFFFFFFULL - block_count_portion)
-				block_count_portion = prev_block_count - (0xFFFFFFFFFFFFFFFFULL - block_count_portion) - 1;
-			else
-				block_count_portion +=  prev_block_count;
-			gf_bs_write_u64(bs, salt_portion);
-			gf_bs_write_u64(bs, block_count_portion);
-
-			gf_crypt_set_state(priv->crypt, next_IV, 17);
-			/*decrypt remain bytes*/
-			if (remain) {
-				char dummy[20];
-				gf_crypt_decrypt(priv->crypt, dummy, remain);
-			}
-
+			gf_bs_write_data(bs,(char *)sai->IV, 16);
 			gf_bs_del(bs);
-			gf_bs_del(tmp);
+			gf_crypt_set_state(priv->crypt, IV, 17);
 		}
-
-		subsample_count++;
-	}
-
-	if (buffer) gf_free(buffer);
-	gf_bs_get_content(pleintext_bs, &buffer, &evt->data_size);
-	memmove(evt->data, buffer, evt->data_size);
-
-exit:
-	if (pleintext_bs) gf_bs_del(pleintext_bs);
-	if (sai_bs) gf_bs_del(sai_bs);
-	if (cyphertext_bs) gf_bs_del(cyphertext_bs);
-	if (buffer) gf_free(buffer);
-	if (sai && sai->subsamples) gf_free(sai->subsamples);
-	if (sai) gf_free(sai);
-	return e;
-}
-
-static GF_Err CBC_ProcessData(ISMAEAPriv *priv, GF_IPMPEvent *evt)
-{
-	GF_Err e;
-	GF_BitStream *pleintext_bs, *cyphertext_bs, *sai_bs;
-	char IV[17];
-	bin128 KID;
-	char *buffer;
-	u32 max_size, i, subsample_count;
-	GF_CENCSampleAuxInfo *sai;
-
-	e = GF_OK;
-	pleintext_bs = cyphertext_bs = sai_bs = NULL;
-	buffer = NULL;
-	max_size = 4096;
-
-	if (!priv->crypt) return GF_SERVICE_ERROR;
-	
-	if (!evt->is_encrypted) return GF_OK;
-
-	cyphertext_bs = gf_bs_new(evt->data, evt->data_size, GF_BITSTREAM_READ);
-	sai_bs = gf_bs_new(evt->sai, evt->saiz, GF_BITSTREAM_READ);
-	pleintext_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-	buffer = (char*)gf_malloc(sizeof(char) * max_size);
-
-	sai = (GF_CENCSampleAuxInfo *)gf_malloc(sizeof(GF_CENCSampleAuxInfo));
-	if (!sai) {
-		e = GF_IO_ERR;
-		goto exit;
-	}
-	memset(sai, 0, sizeof(GF_CENCSampleAuxInfo));
-	/*read sample auxiliary information from bitstream*/
-	gf_bs_read_data(sai_bs, (char *)KID, 16);
-	gf_bs_read_data(sai_bs, (char *)sai->IV, 16);
-	sai->subsample_count = gf_bs_read_u16(sai_bs);
-	if (sai->subsample_count) {
-		sai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(sai->subsample_count*sizeof(GF_CENCSubSampleEntry));
-		for (i = 0; i < sai->subsample_count; i++) {
-			sai->subsamples[i].bytes_clear_data = gf_bs_read_u32(sai_bs);
-			sai->subsamples[i].bytes_encrypted_data = gf_bs_read_u32(sai_bs);
-		}
-	}
-
-	if (!strlen((char *)sai->IV)) {
-		e = GF_OK;
-		goto exit;
-	}
-
-	for (i = 0; i < priv->KID_count; i++) {
-		if (!strncmp((const char *)KID, (const char *)priv->KIDs[i], 16)) {
-			memmove(priv->key, priv->keys[i], 16);
-			break;
-		}
-	}
-
-	if (priv->first_crypted_samp) {
-		memmove(IV, sai->IV, 16);
-		e = gf_crypt_init(priv->crypt, priv->key, 16, IV);
+		e = gf_crypt_set_key(priv->crypt, priv->key, 16, IV);
 		if (e) {
-			GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot initialize AES-128 CBC (%s)\n", gf_error_to_string(e)) );
+			GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot set key AES-128 %s (%s)\n", priv->is_cenc ? "CTR" : "CBC", gf_error_to_string(e)) );
 			e = GF_IO_ERR;
 			goto exit;
 		}
-		priv->first_crypted_samp = GF_FALSE;
 	}
 
 	subsample_count = 0;
+	BSO = 0;
 	while (gf_bs_available(cyphertext_bs)) {
 		assert(subsample_count < sai->subsample_count);
 
@@ -587,6 +461,43 @@ static GF_Err CBC_ProcessData(ISMAEAPriv *priv, GF_IPMPEvent *evt)
 		gf_crypt_decrypt(priv->crypt, buffer, sai->subsamples[subsample_count].bytes_encrypted_data);
 		gf_bs_write_data(pleintext_bs, buffer, sai->subsamples[subsample_count].bytes_encrypted_data);
 
+		/*update IV for next subsample*/
+		if (priv->is_cenc) {
+			BSO += sai->subsamples[subsample_count].bytes_encrypted_data;
+			if (gf_bs_available(cyphertext_bs)) {
+				char next_IV[17];
+				u64 prev_block_count, salt_portion, block_count_portion;
+				u32 remain;
+				GF_BitStream *bs, *tmp;
+
+				prev_block_count = BSO / 16;
+				remain = BSO % 16;
+				tmp = gf_bs_new((const char *)sai->IV, 16, GF_BITSTREAM_READ);
+				bs = gf_bs_new(next_IV, 17, GF_BITSTREAM_WRITE);
+				gf_bs_write_u8(bs, 0);	/*begin of counter*/
+
+				salt_portion = gf_bs_read_u64(tmp);
+				block_count_portion = gf_bs_read_u64(tmp);
+				/*reset the block counter to zero without affecting the other 64 bits of the IV*/
+				if (prev_block_count > 0xFFFFFFFFFFFFFFFFULL - block_count_portion)
+					block_count_portion = prev_block_count - (0xFFFFFFFFFFFFFFFFULL - block_count_portion) - 1;
+				else
+					block_count_portion +=  prev_block_count;
+				gf_bs_write_u64(bs, salt_portion);
+				gf_bs_write_u64(bs, block_count_portion);
+
+				gf_crypt_set_state(priv->crypt, next_IV, 17);
+				/*decrypt remain bytes*/
+				if (remain) {
+					char dummy[20];
+					gf_crypt_decrypt(priv->crypt, dummy, remain);
+				}
+
+				gf_bs_del(bs);
+				gf_bs_del(tmp);
+			}
+		}
+
 		subsample_count++;
 	}
 
@@ -627,10 +538,8 @@ static GF_Err IPMP_Process(GF_IPMPTool *plug, GF_IPMPEvent *evt)
 		}
 		break;
 	case GF_IPMP_TOOL_PROCESS_DATA:
-		if (priv->is_cenc) {
+		if (priv->is_cenc || priv->is_cbc) {
 			return CENC_ProcessData(priv, evt);
-		} else if (priv->is_cbc) {
-			return CBC_ProcessData(priv, evt);
 		} else if (priv->is_oma) {
 			if (evt->is_encrypted) {
 				evt->restart_requested = GF_TRUE;
diff --git a/modules/isom_in/read_ch.c b/modules/isom_in/read_ch.c
index d1c866f0f..a821a7fcd 100644
--- a/modules/isom_in/read_ch.c
+++ b/modules/isom_in/read_ch.c
@@ -531,25 +531,33 @@ fetch_next:
 			/*in case of CENC: we write sample auxiliary information to slh->sai; its size is in saiz*/
 			if (gf_isom_is_cenc_media(ch->owner->mov, ch->track, 1)) {
 				GF_CENCSampleAuxInfo *sai;
+				u32 Is_Encrypted;
+				u8 IV_size;
 				bin128 KID;
 
-				gf_isom_cenc_get_KID(ch->owner->mov, ch->track, ch->sample_num, &KID);
-				sai = gf_isom_cenc_get_sample_aux_info(ch->owner->mov, ch->track, ch->sample_num, NULL);
-				if (sai) {
-					GF_BitStream *bs;
-					bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-					/*write sample auxiliary information*/
-					gf_bs_write_data(bs, (char *)KID, 16);
-					gf_bs_write_data(bs, (char *)sai->IV, 16);
-					gf_bs_write_u16(bs, sai->subsample_count);
-					for (ivar = 0; ivar < sai->subsample_count; ivar++) {
-						gf_bs_write_u32(bs, sai->subsamples[ivar].bytes_clear_data);
-						gf_bs_write_u32(bs, sai->subsamples[ivar].bytes_encrypted_data);
-					}
-					gf_bs_get_content(bs, &ch->current_slh.sai, &ch->current_slh.saiz);
-					gf_bs_del(bs);
+				gf_isom_get_sample_cenc_info(ch->owner->mov, ch->track, ch->sample_num, &Is_Encrypted, &IV_size, &KID);
+				if (Is_Encrypted) {
 					ch->current_slh.cenc_encrypted = 1;
-				} else
+					sai = NULL;
+					gf_isom_cenc_get_sample_aux_info(ch->owner->mov, ch->track, ch->sample_num, &sai, NULL);
+					if (sai) {
+						GF_BitStream *bs;
+						bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
+						/*write sample auxiliary information*/
+						gf_bs_write_data(bs, (char *)KID, 16);
+						gf_bs_write_data(bs, (char *)sai->IV, 16);
+						gf_bs_write_u16(bs, sai->subsample_count);
+						for (ivar = 0; ivar < sai->subsample_count; ivar++) {
+							gf_bs_write_u16(bs, sai->subsamples[ivar].bytes_clear_data);
+							gf_bs_write_u32(bs, sai->subsamples[ivar].bytes_encrypted_data);
+						}
+						gf_bs_get_content(bs, &ch->current_slh.sai, &ch->current_slh.saiz);
+						gf_bs_del(bs);
+						gf_isom_cenc_samp_aux_info_del(sai);
+						sai = NULL;
+					}
+				}
+				else
 					ch->current_slh.cenc_encrypted = 0;
 			}
 		}
@@ -580,8 +588,8 @@ void isor_flush_data(ISOMReader *read, Bool check_buffer_level, Bool is_chunk_fl
 	if (read->in_data_flush) 
 		return;
 	//pull request from term: if no segments are pending (received but not yet parsed) ignore
-	if (!check_buffer_level && !read->has_pending_segments)
-		return;
+//	if (!check_buffer_level && !read->has_pending_segments)
+//		return;
 
 	gf_mx_p(read->segment_mutex);
 	read->in_data_flush = 1;
diff --git a/src/export.cpp b/src/export.cpp
index 769753e49..7e8c1239e 100644
--- a/src/export.cpp
+++ b/src/export.cpp
@@ -735,8 +735,10 @@
 #pragma comment (linker, EXPORT_SYMBOL(gf_isom_get_pssh_count) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_isom_get_pssh_info) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_isom_is_cenc_media) )
+#pragma comment (linker, EXPORT_SYMBOL(gf_isom_get_sample_cenc_info) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_isom_cenc_get_sample_aux_info) )
-#pragma comment (linker, EXPORT_SYMBOL(gf_isom_cenc_get_KID) )
+#pragma comment (linker, EXPORT_SYMBOL(gf_isom_cenc_samp_aux_info_del) )
+#pragma comment (linker, EXPORT_SYMBOL(gf_isom_cenc_get_default_info) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_isom_get_avc_svc_type) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_isom_avc_config_get) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_isom_svc_config_get) )
@@ -935,6 +937,7 @@
 #pragma comment (linker, EXPORT_SYMBOL(gf_isom_set_rvc_config) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_isom_set_sample_rap_group) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_isom_set_sample_roll_group) )
+#pragma comment (linker, EXPORT_SYMBOL(gf_isom_set_sample_cenc_group) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_isom_set_composition_offset_mode) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_isom_set_output_buffering) )
 
@@ -972,7 +975,7 @@
 #pragma comment (linker, EXPORT_SYMBOL(gf_isom_fragment_add_sample) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_isom_fragment_append_data) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_isom_fragment_add_sai) )
-#pragma comment (linker, EXPORT_SYMBOL(gf_isom_clone_pssh) )
+#pragma comment (linker, EXPORT_SYMBOL(gf_isom_clone_pssh) ) 
 #pragma comment (linker, EXPORT_SYMBOL(gf_isom_start_segment) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_isom_close_segment) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_isom_set_traf_base_media_decode_time) )
diff --git a/src/isomedia/box_code_base.c b/src/isomedia/box_code_base.c
index b2ddc9b80..ba1fdbb03 100644
--- a/src/isomedia/box_code_base.c
+++ b/src/isomedia/box_code_base.c
@@ -8384,6 +8384,16 @@ static void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, u32 entry_siz
 		*total_bytes = 1;
 		return ptr;
 	}
+	case GF_4CC( 's', 'e', 'i', 'g' ):
+	{
+		GF_CENCSampleEncryptionGroupEntry *ptr;
+		GF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry);
+		ptr->IsEncrypted = gf_bs_read_u32(bs);
+		ptr->IV_size = gf_bs_read_u8(bs);
+		gf_bs_read_data(bs, (char *)ptr->KID, 16);
+		*total_bytes = 21;
+		return ptr;
+	}
 	default:
 	{
 		GF_DefaultSampleGroupDescriptionEntry *ptr;
@@ -8404,6 +8414,7 @@ static void	sgpd_del_entry(u32 grouping_type, void *entry)
 	switch (grouping_type) {
 	case GF_4CC( 'r', 'o', 'l', 'l' ):
 	case GF_4CC( 'r', 'a', 'p', ' ' ):
+	case GF_4CC( 's', 'e', 'i', 'g' ):
 		gf_free(entry);
 		return;
 
@@ -8427,6 +8438,11 @@ static void	sgpd_write_entry(u32 grouping_type, void *entry, GF_BitStream *bs)
 		gf_bs_write_int(bs, ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples_known, 1);
 		gf_bs_write_int(bs, ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples, 7);
 		return;
+	case GF_4CC( 's', 'e', 'i', 'g' ):
+		gf_bs_write_u32(bs, ((GF_CENCSampleEncryptionGroupEntry *)entry)->IsEncrypted);
+		gf_bs_write_u8(bs, ((GF_CENCSampleEncryptionGroupEntry *)entry)->IV_size);
+		gf_bs_write_data(bs, (char *)((GF_CENCSampleEncryptionGroupEntry *)entry)->KID, 16);
+		return;
 	default:
 		{
 		GF_DefaultSampleGroupDescriptionEntry *ptr = (GF_DefaultSampleGroupDescriptionEntry *)entry;
@@ -8441,6 +8457,8 @@ static u32 sgpd_size_entry(u32 grouping_type, void *entry)
 		return 2;
 	case GF_4CC( 'r', 'a', 'p', ' ' ):
 		return 1;
+	case GF_4CC( 's', 'e', 'i', 'g' ):
+		return 21;
 	default:
 		return ((GF_DefaultSampleGroupDescriptionEntry *)entry)->length;
 	}
diff --git a/src/isomedia/box_code_drm.c b/src/isomedia/box_code_drm.c
index 9248a4d11..d9a104b81 100644
--- a/src/isomedia/box_code_drm.c
+++ b/src/isomedia/box_code_drm.c
@@ -1126,7 +1126,7 @@ GF_Err piff_psec_Read(GF_Box *s, GF_BitStream *bs)
 			sai->subsample_count = gf_bs_read_u16(bs);
 			sai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(sai->subsample_count*sizeof(GF_CENCSubSampleEntry));
 			for (j = 0; j < sai->subsample_count; j++) {
-				sai->subsamples[j].bytes_clear_data = gf_bs_read_u32(bs);
+				sai->subsamples[j].bytes_clear_data = gf_bs_read_u16(bs);
 				sai->subsamples[j].bytes_encrypted_data = gf_bs_read_u32(bs);
 			}
 			gf_list_add(ptr->samp_aux_info, sai);
@@ -1188,7 +1188,7 @@ GF_Err piff_psec_Write(GF_Box *s, GF_BitStream *bs)
 			gf_bs_write_data(bs, (char *)sai->IV, 16);
 			gf_bs_write_u16(bs, sai->subsample_count);
 			for (j = 0; j < sai->subsample_count; j++) {
-				gf_bs_write_u32(bs, sai->subsamples[j].bytes_clear_data);
+				gf_bs_write_u16(bs, sai->subsamples[j].bytes_clear_data);
 				gf_bs_write_u32(bs, sai->subsamples[j].bytes_encrypted_data);
 			}
 		}
@@ -1212,7 +1212,7 @@ GF_Err piff_psec_Size(GF_Box *s)
 	if (sample_count) {
 		for (i = 0; i < sample_count; i++) {
 			GF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, i);
-			ptr->size += 18 + 8*sai->subsample_count;
+			ptr->size += 18 + 6*sai->subsample_count;
 		}
 	}
 	return GF_OK;
diff --git a/src/isomedia/box_dump.c b/src/isomedia/box_dump.c
index ff3a5874b..a73f32fe8 100644
--- a/src/isomedia/box_dump.c
+++ b/src/isomedia/box_dump.c
@@ -4011,6 +4011,11 @@ GF_Err sgpd_dump(GF_Box *a, FILE * trace)
 			if (((GF_VisualRandomAccessEntry*)entry)->num_leading_samples_known) fprintf(trace, " num_leading_samples=\"%d\" />", ((GF_VisualRandomAccessEntry*)entry)->num_leading_samples);
 			fprintf(trace, "/>\n");
 			break;
+		case GF_4CC( 's', 'e', 'i', 'g' ):
+			fprintf(trace, "<CENCSampleEncryptionGroupEntry IsEncrypted=\"%d\" IV_size=\"%d\" KID=\"", ((GF_CENCSampleEncryptionGroupEntry*)entry)->IsEncrypted, ((GF_CENCSampleEncryptionGroupEntry*)entry)->IV_size);
+			DumpDataHex(trace, (char *)((GF_CENCSampleEncryptionGroupEntry*)entry)->KID, 16);
+			fprintf(trace, "\"/>\n");
+			break;
 		default:
 			fprintf(trace, "<DefaultSampleGroupDescriptionEntry size=\"%d\" data=\"", ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);
 			DumpData(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);
diff --git a/src/isomedia/drm_sample.c b/src/isomedia/drm_sample.c
index a152b7366..f48d1dc73 100644
--- a/src/isomedia/drm_sample.c
+++ b/src/isomedia/drm_sample.c
@@ -818,6 +818,51 @@ void gf_isom_cenc_set_saiz_saio(GF_SampleEncryptionBox *senc, GF_SampleTableBox
 		senc->cenc_saiz->sample_count++;
 	}
 }
+
+void gf_isom_cenc_merge_saiz_saio(GF_SampleEncryptionBox *senc, GF_SampleTableBox *stbl, u32 offset, u32 len) 
+{
+	u32  i;
+	if (!senc->cenc_saiz) {
+		senc->cenc_saiz = (GF_SampleAuxiliaryInfoSizeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SAIZ);
+		senc->cenc_saiz->aux_info_type = GF_4CC('c', 'e', 'n', 'c');
+		senc->cenc_saiz->aux_info_type_parameter = 0;
+		if (stbl) 
+			stbl_AddBox(stbl, (GF_Box *)senc->cenc_saiz);
+	}
+	if (!senc->cenc_saio) {
+		senc->cenc_saio = (GF_SampleAuxiliaryInfoOffsetBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SAIO);
+		senc->cenc_saio->aux_info_type = GF_4CC('c', 'e', 'n', 'c');
+		senc->cenc_saio->aux_info_type_parameter = 0;
+		if (stbl) 
+			stbl_AddBox(stbl, (GF_Box *)senc->cenc_saio);
+	}
+
+	if (!senc->cenc_saiz->sample_count || (senc->cenc_saiz->default_sample_info_size==len)) {
+		senc->cenc_saiz->sample_count ++;
+		senc->cenc_saiz->default_sample_info_size = len;
+	} else {
+		senc->cenc_saiz->sample_info_size = gf_realloc(senc->cenc_saiz->sample_info_size, sizeof(u8)*(senc->cenc_saiz->sample_count+1));
+
+		if (senc->cenc_saiz->default_sample_info_size) {
+			for (i=0; i<senc->cenc_saiz->sample_count; i++)
+				senc->cenc_saiz->sample_info_size[i] = senc->cenc_saiz->default_sample_info_size;
+			senc->cenc_saiz->default_sample_info_size = 0;
+		}
+		senc->cenc_saiz->sample_info_size[senc->cenc_saiz->sample_count] = len;
+		senc->cenc_saiz->sample_count++;
+	}
+
+	if (!senc->cenc_saio->entry_count) {
+		senc->cenc_saio->offsets = (u32 *)gf_malloc(sizeof(u32));
+		senc->cenc_saio->offsets[0] = offset;
+		senc->cenc_saio->entry_count ++;
+	} else {
+		senc->cenc_saio->offsets = gf_realloc(senc->cenc_saio->offsets, sizeof(u32)*(senc->cenc_saio->entry_count+1));
+		senc->cenc_saio->offsets[senc->cenc_saio->entry_count] = offset;
+		senc->cenc_saio->entry_count++;
+	}
+}
+
 GF_Err gf_isom_track_cenc_add_sample_info(GF_ISOFile *the_file, u32 trackNumber, u32 container_type, char *buf, u32 len)
 {
 	u32 i;
@@ -851,7 +896,7 @@ GF_Err gf_isom_track_cenc_add_sample_info(GF_ISOFile *the_file, u32 trackNumber,
 	if (sai->subsample_count) senc->flags = 0x00000002;
 	sai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(sai->subsample_count*sizeof(GF_CENCSubSampleEntry));
 	for (i = 0; i < sai->subsample_count; i++) {
-		sai->subsamples[i].bytes_clear_data = gf_bs_read_u32(bs);
+		sai->subsamples[i].bytes_clear_data = gf_bs_read_u16(bs);
 		sai->subsamples[i].bytes_encrypted_data = gf_bs_read_u32(bs);
 	}
 	gf_bs_del(bs);
@@ -865,7 +910,7 @@ GF_Err gf_isom_track_cenc_add_sample_info(GF_ISOFile *the_file, u32 trackNumber,
 
 
 #ifndef	GPAC_DISABLE_ISOM_FRAGMENTS
-
+GF_EXPORT
 void gf_isom_cenc_samp_aux_info_del(GF_CENCSampleAuxInfo *samp)
 {
 	//if (samp->IV) gf_free(samp->IV);
@@ -873,19 +918,111 @@ void gf_isom_cenc_samp_aux_info_del(GF_CENCSampleAuxInfo *samp)
 	gf_free(samp);
 }
 
+Bool gf_isom_cenc_has_saiz_saio(GF_SampleTableBox *stbl, GF_TrackFragmentBox *traf)
+{
+	u32 i;
+	GF_List *sai_sizes, *sai_offsets;
+	Bool has_saiz, has_saio;
+	has_saiz = has_saio = GF_FALSE;
+	
+	if (stbl) {
+		sai_sizes = stbl->sai_sizes;
+		sai_offsets = stbl->sai_offsets;
+	}
+	else if (traf) {
+		sai_sizes = traf->sai_sizes;
+		sai_offsets = traf->sai_offsets;
+	}
+	else return GF_FALSE;
+
+	for (i = 0; i < gf_list_count(sai_sizes); i++) {
+		GF_SampleAuxiliaryInfoSizeBox *saiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(sai_sizes, i);
+		if (saiz->aux_info_type == GF_4CC('c', 'e', 'n', 'c')) {
+			has_saiz = GF_TRUE;
+			break;
+		}
+	}
+
+	for (i = 0; i < gf_list_count(sai_offsets); i++) {
+		GF_SampleAuxiliaryInfoOffsetBox *saio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(sai_offsets, i);
+		if (saio->aux_info_type == GF_4CC('c', 'e', 'n', 'c')) {
+			has_saio = GF_TRUE;
+			break;
+		}			
+	}
+	
+	return (has_saiz && has_saio);
+}
+
+static GF_Err gf_isom_cenc_get_sai_by_saiz_saio(GF_MediaBox *mdia, u32 sampleNumber, GF_CENCSampleAuxInfo **sai)
+{
+	GF_BitStream *bs;
+	u32 offset, prev_sai_size, size, i, j, nb_saio;
+	u64 cur_position;
+	GF_Err e = GF_OK;
+	char *buffer;
+
+	offset = prev_sai_size = 0;
+
+	for (i = 0; i < gf_list_count(mdia->information->sampleTable->sai_offsets); i++) {
+		GF_SampleAuxiliaryInfoOffsetBox *saio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(mdia->information->sampleTable->sai_offsets, i);
+		if (saio->aux_info_type == GF_4CC('c', 'e', 'n', 'c')) {
+			if (saio->entry_count == 1)
+				offset = saio->offsets[0];
+			else
+				offset = saio->offsets[sampleNumber-1];
+			nb_saio = saio->entry_count;
+			break;
+		}			
+	}
+
+	for (i = 0; i < gf_list_count(mdia->information->sampleTable->sai_sizes); i++) {
+		GF_SampleAuxiliaryInfoSizeBox *saiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(mdia->information->sampleTable->sai_sizes, i);
+		if (saiz->aux_info_type == GF_4CC('c', 'e', 'n', 'c')) {
+			for (j = 0; j < sampleNumber-1; j++)
+				prev_sai_size += saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[j];
+			size = saiz->sample_info_size[sampleNumber-1];
+			break;
+		}
+	}
+
+	offset += (nb_saio == 1) ? prev_sai_size : 0;
+	cur_position = gf_bs_get_position(mdia->information->dataHandler->bs);
+	gf_bs_seek(mdia->information->dataHandler->bs, offset);
+	buffer = (char *)malloc(size);
+	gf_bs_read_data(mdia->information->dataHandler->bs, buffer, size);
+	gf_bs_seek(mdia->information->dataHandler->bs, cur_position);
+
+	*sai = (GF_CENCSampleAuxInfo *)gf_malloc(sizeof(GF_CENCSampleAuxInfo));
+	bs = gf_bs_new(buffer, size, GF_BITSTREAM_READ);
+	gf_bs_read_data(bs, (char *)(*sai)->IV, 16);
+	if (size > 16) {
+		(*sai)->subsample_count = gf_bs_read_u16(bs);
+		(*sai)->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(sizeof(GF_CENCSubSampleEntry)*(*sai)->subsample_count);
+		for (i = 0; i < (*sai)->subsample_count; i++) {
+			(*sai)->subsamples[i].bytes_clear_data = gf_bs_read_u16(bs);
+			(*sai)->subsamples[i].bytes_encrypted_data = gf_bs_read_u32(bs);
+		}
+	}
+	gf_bs_del(bs);
+	
+	return e;
+}
+
 GF_EXPORT
-GF_CENCSampleAuxInfo * gf_isom_cenc_get_sample_aux_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *container_type)
+GF_Err gf_isom_cenc_get_sample_aux_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, GF_CENCSampleAuxInfo **sai, u32 *container_type)
 {
-	GF_CENCSampleAuxInfo *sai;
+	GF_TrackBox *trak;
 	GF_SampleTableBox *stbl;
 	GF_Box *a_box;
 	u32 i, type;
+	GF_CENCSampleAuxInfo *a_sai;
 
-	GF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);
-	if (!trak) return NULL;
+	trak = gf_isom_get_track_from_file(the_file, trackNumber);
+	if (!trak) return GF_BAD_PARAM;
 	stbl = trak->Media->information->sampleTable;
 	if (!stbl)
-		return NULL;
+		return GF_BAD_PARAM;
 
 	type = 0;
 	for (i = 0; i < gf_list_count(stbl->other_boxes); i++) {
@@ -900,27 +1037,49 @@ GF_CENCSampleAuxInfo * gf_isom_cenc_get_sample_aux_info(GF_ISOFile *the_file, u3
 		}
 	}
 
-	sai = NULL;
+	if (container_type) *container_type = type;
+
+	if (!sai) return GF_OK; /*we need only container_type*/
+
+	if (*sai) {
+		gf_isom_cenc_samp_aux_info_del(*sai);
+		*sai = NULL;
+	}
+
+	/*get sample auxiliary information by saiz/saio rather than by parsing senc box*/
+	if (gf_isom_cenc_has_saiz_saio(stbl, NULL)) {
+		return gf_isom_cenc_get_sai_by_saiz_saio(trak->Media, sampleNumber, sai);
+	}
+
+	a_sai = NULL;
 	switch (type) {
 		case GF_ISOM_BOX_UUID_PSEC:
-			sai = (GF_CENCSampleAuxInfo *)gf_list_get(((GF_PIFFSampleEncryptionBox *)a_box)->samp_aux_info, sampleNumber-1);
+			a_sai = (GF_CENCSampleAuxInfo *)gf_list_get(((GF_PIFFSampleEncryptionBox *)a_box)->samp_aux_info, sampleNumber-1);
 			break;
 		case GF_ISOM_BOX_TYPE_SENC:
-			sai = (GF_CENCSampleAuxInfo *)gf_list_get(((GF_SampleEncryptionBox *)a_box)->samp_aux_info, sampleNumber-1);
+			a_sai = (GF_CENCSampleAuxInfo *)gf_list_get(((GF_SampleEncryptionBox *)a_box)->samp_aux_info, sampleNumber-1);
 			break;
 	}
+	if (!a_sai)
+		return GF_NOT_SUPPORTED;
 
-	if (container_type) *container_type = type;
+	(*sai) = (GF_CENCSampleAuxInfo *)gf_malloc(sizeof(GF_CENCSampleAuxInfo));
+	memmove((*sai)->IV, a_sai->IV, 16);
+	(*sai)->subsample_count = a_sai->subsample_count;
+	(*sai)->subsamples = gf_malloc(sizeof(GF_CENCSubSampleEntry)*(*sai)->subsample_count);
+	memmove((*sai)->subsamples, a_sai->subsamples, sizeof(GF_CENCSubSampleEntry)*(*sai)->subsample_count);
 
-	return sai;
+	return GF_OK;
 }
 
 GF_EXPORT
-void gf_isom_cenc_get_KID(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, bin128 *outKID) {
+void gf_isom_cenc_get_default_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *default_IsEncrypted, u8 *default_IV_size, bin128 *default_KID) {
 	GF_TrackBox *trak;
 	GF_ProtectionInfoBox *sinf;
 
-	memset(*outKID, 0, 16);
+	if (default_IsEncrypted) *default_IsEncrypted = 0;
+	if (default_IV_size) *default_IV_size = 0;
+	if (default_KID) memset(*default_KID, 0, 16);
 
 	trak = gf_isom_get_track_from_file(the_file, trackNumber);
 	if (!trak) return;
@@ -928,8 +1087,11 @@ void gf_isom_cenc_get_KID(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumbe
 	sinf = gf_isom_get_sinf_entry(trak, 1, GF_ISOM_CENC_SCHEME, NULL);
 	if (!sinf) sinf = gf_isom_get_sinf_entry(trak, 1, GF_ISOM_CBC_SCHEME, NULL);
 
-	if (sinf && sinf->info && sinf->info->tenc)
-		memmove(*outKID, sinf->info->tenc->KID, 16);
+	if (sinf && sinf->info && sinf->info->tenc) {
+		if (default_IsEncrypted) *default_IsEncrypted = sinf->info->tenc->IsEncrypted;
+		if (default_IV_size) *default_IV_size = sinf->info->tenc->IV_size;
+		if (default_KID) memmove(*default_KID, sinf->info->tenc->KID, 16);
+	}
 	
 }
 
diff --git a/src/isomedia/isom_read.c b/src/isomedia/isom_read.c
index 70409b8e5..19f41ba85 100644
--- a/src/isomedia/isom_read.c
+++ b/src/isomedia/isom_read.c
@@ -3297,6 +3297,63 @@ GF_Err gf_isom_get_pssh_info(GF_ISOFile *file, u32 pssh_index, bin128 SystemID,
 	return GF_OK;
 }
 
+GF_EXPORT
+GF_Err gf_isom_get_sample_cenc_info(GF_ISOFile *movie, u32 track, u32 sample_number, u32 *IsEncrypted, u8 *IV_size, bin128 *KID)
+{
+	GF_TrackBox *trak;
+	u32 i, count;
+
+	gf_isom_cenc_get_default_info(movie, track, sample_number, IsEncrypted, IV_size, KID);
+
+	trak = gf_isom_get_track_from_file(movie, track);
+
+	if (!trak->Media->information->sampleTable->sampleGroups) return GF_OK;
+
+	count = gf_list_count(trak->Media->information->sampleTable->sampleGroups);
+	for (i=0; i<count; i++) {
+		GF_SampleGroupBox *sg;
+		u32 j, group_desc_index;
+		GF_SampleGroupDescriptionBox *sgdesc;
+		u32 first_sample_in_entry, last_sample_in_entry;
+		first_sample_in_entry = 1;
+		group_desc_index = 0;
+		sg = gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);
+		for (j=0; j<sg->entry_count; j++) {
+			last_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;
+			if ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {
+				first_sample_in_entry = last_sample_in_entry+1;
+				continue;
+			}
+			/*we found our sample*/
+			group_desc_index = sg->sample_entries[j].group_description_index;
+			break;
+		}
+		/*no sampleGroup info associated*/
+		if (!group_desc_index) continue;
+
+		sgdesc = NULL;
+		for (j=0; j<gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription); j++) {
+			sgdesc = gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, j);
+			if (sgdesc->grouping_type==sg->grouping_type) break;
+			sgdesc = NULL;
+		}
+		/*no sampleGroup description found for this group (invalid file)*/
+		if (!sgdesc) continue;
+
+		switch (sgdesc->grouping_type) {
+		case GF_4CC( 's', 'e', 'i', 'g' ):
+			if (IsEncrypted || IV_size || KID) {
+				GF_CENCSampleEncryptionGroupEntry *entry = (GF_CENCSampleEncryptionGroupEntry *) gf_list_get(sgdesc->group_descriptions, group_desc_index - 1);
+				if (IsEncrypted) *IsEncrypted = entry->IsEncrypted;
+				if (IV_size) *IV_size = entry->IV_size;
+				if (KID) memmove(*KID, entry->KID, 16);
+				break;
+			}
+		}
+	}
+	return GF_OK;;
+}
+
 
 GF_EXPORT
 Bool gf_isom_get_last_producer_time_box(GF_ISOFile *file, u32 *refTrackID, u64 *ntp, u64 *timestamp, Bool reset_info)
diff --git a/src/isomedia/isom_write.c b/src/isomedia/isom_write.c
index 88331426c..cc6c659b9 100644
--- a/src/isomedia/isom_write.c
+++ b/src/isomedia/isom_write.c
@@ -4449,6 +4449,50 @@ GF_Err gf_isom_set_sample_roll_group(GF_ISOFile *movie, u32 track, u32 sample_nu
 	return gf_isom_set_sample_group_info(movie, track, sample_number, GF_4CC( 'r', 'o', 'l', 'l' ), &roll_distance, sg_roll_create_entry, sg_roll_compare_entry);
 }
 
+void *sg_encryption_create_entry(void *udta)
+{
+	GF_CENCSampleEncryptionGroupEntry *entry;
+	GF_BitStream *bs;
+	GF_SAFEALLOC(entry, GF_CENCSampleEncryptionGroupEntry);
+	bs = gf_bs_new((char *) udta, sizeof(GF_CENCSampleEncryptionGroupEntry), GF_BITSTREAM_READ);
+	entry->IsEncrypted = gf_bs_read_u32(bs);
+	entry->IV_size = gf_bs_read_u8(bs);
+	gf_bs_read_data(bs, (char *)entry->KID, 16);
+	gf_bs_del(bs);
+	return entry;
+}
+
+Bool sg_encryption_compare_entry(void *udta, void *entry)
+{
+	u32 isEncrypted;
+	u8 IV_size;
+	bin128 KID;
+	GF_BitStream *bs;
+	GF_CENCSampleEncryptionGroupEntry *seig = (GF_CENCSampleEncryptionGroupEntry *)entry;
+	bs = gf_bs_new((char *) udta, sizeof(GF_CENCSampleEncryptionGroupEntry), GF_BITSTREAM_READ);
+	isEncrypted = gf_bs_read_u32(bs);
+	IV_size = gf_bs_read_u8(bs);
+	gf_bs_read_data(bs, (char *)KID, 16);
+	gf_bs_del(bs);
+	if ((isEncrypted == seig->IsEncrypted) && (IV_size == seig->IV_size) && (!strncmp((const char *)KID, (const char *)seig->KID, 16))) return 1;
+	return 0;
+}
+
+/*sample encryption information group can be in stbl or traf*/
+GF_EXPORT
+GF_Err gf_isom_set_sample_cenc_group(GF_ISOFile *movie, u32 track, u32 sample_number, Bool isEncrypted, u8 IV_size, bin128 KeyID)
+{
+	char seig[21];
+	if ((IV_size!=0) && (IV_size!=4) && (IV_size!=8)) return GF_BAD_PARAM;
+
+	seig[0] = seig[1] = 0;
+	seig[2] = isEncrypted ? 1 : 0;
+	seig[3] = IV_size;
+	memcpy(seig + 5, KeyID, sizeof(bin128));
+
+	return gf_isom_set_sample_group_info(movie, track, sample_number, GF_4CC( 's', 'e', 'i', 'g' ), seig, sg_encryption_create_entry, sg_encryption_compare_entry);
+}
+
 static GF_Err gf_isom_set_ctts_v1(GF_ISOFile *file, u32 track, GF_TrackBox *trak)
 {
 	u32 i, shift;
diff --git a/src/isomedia/movie_fragments.c b/src/isomedia/movie_fragments.c
index 2cff70831..21b9cf4dc 100644
--- a/src/isomedia/movie_fragments.c
+++ b/src/isomedia/movie_fragments.c
@@ -1765,10 +1765,11 @@ GF_EXPORT
 GF_Err gf_isom_fragment_add_sai(GF_ISOFile *output, GF_ISOFile *input, u32 TrackID, u32 SampleNum)
 {
 	u32 trackNum;
+	GF_Err e = GF_OK;
 
 	trackNum = gf_isom_get_track_by_id(input, TrackID);
 	if (gf_isom_is_cenc_media(input, trackNum, 1)) {
-		GF_CENCSampleAuxInfo *sai, *new_sai;
+		GF_CENCSampleAuxInfo *sai;
 		GF_TrackFragmentBox  *traf = GetTraf(output, TrackID);
 		GF_TrackBox  *src_trak = gf_isom_get_track_from_file(input, TrackID);
 		u32 boxType;
@@ -1776,8 +1777,9 @@ GF_Err gf_isom_fragment_add_sai(GF_ISOFile *output, GF_ISOFile *input, u32 Track
 
 		if (!traf)  return GF_BAD_PARAM;
 
-		sai = gf_isom_cenc_get_sample_aux_info(input, trackNum, SampleNum, &boxType);
-		if (!sai) return GF_IO_ERR;
+		sai = NULL;
+		e = gf_isom_cenc_get_sample_aux_info(input, trackNum, SampleNum, &sai, &boxType);
+		if (e) return e;
 
 		switch (boxType) {
 		case GF_ISOM_BOX_UUID_PSEC:
@@ -1808,16 +1810,10 @@ GF_Err gf_isom_fragment_add_sai(GF_ISOFile *output, GF_ISOFile *input, u32 Track
 			return GF_NOT_SUPPORTED;
 		}
 
-		new_sai = (GF_CENCSampleAuxInfo *)gf_malloc(sizeof(GF_CENCSampleAuxInfo));
-		memmove((char *)new_sai->IV, (const char*)sai->IV, 16);
-		new_sai->subsample_count = sai->subsample_count;
+		gf_list_add(senc->samp_aux_info, sai);
 		if (sai->subsample_count) senc->flags = 0x00000002;
-		new_sai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(new_sai->subsample_count*sizeof(GF_CENCSubSampleEntry));
-		memmove(new_sai->subsamples, sai->subsamples, new_sai->subsample_count*sizeof(GF_CENCSubSampleEntry));
 
-		gf_list_add(senc->samp_aux_info, new_sai);
-
-		gf_isom_cenc_set_saiz_saio(senc, NULL, traf, 18+8*new_sai->subsample_count);
+		gf_isom_cenc_set_saiz_saio(senc, NULL, traf, 18+6*sai->subsample_count);
 
 	}
 
@@ -1825,7 +1821,6 @@ GF_Err gf_isom_fragment_add_sai(GF_ISOFile *output, GF_ISOFile *input, u32 Track
 }
 
 
-
 GF_Err gf_isom_fragment_append_data(GF_ISOFile *movie, u32 TrackID, char *data, u32 data_size, u8 PaddingBits)
 {
 	u32 count;
diff --git a/src/isomedia/track.c b/src/isomedia/track.c
index fa834253b..fe1a21dc8 100644
--- a/src/isomedia/track.c
+++ b/src/isomedia/track.c
@@ -580,64 +580,117 @@ GF_Err MergeTrack(GF_TrackBox *trak, GF_TrackFragmentBox *traf, u64 moof_offset,
 		}
 	}
 
-	/*Merge PIFF sample auxiliary encryption information*/
-	if (traf->piff_sample_encryption) {
-		GF_PIFFSampleEncryptionBox *psec = NULL;
-		for (i = 0; i < gf_list_count(trak->Media->information->sampleTable->other_boxes); i++) {
-			GF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->other_boxes, i);
-			if ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {
-				psec = (GF_PIFFSampleEncryptionBox *)a;
-				break;
+	if (gf_isom_is_cenc_media(trak->moov->mov, gf_isom_get_tracknum_from_id(trak->moov, trak->Header->trackID), 1)) {
+		/*Merge sample auxiliary encryption information*/
+		GF_SampleEncryptionBox *senc = NULL;
+		GF_List *sais;
+
+		if (traf->piff_sample_encryption) {
+			for (i = 0; i < gf_list_count(trak->Media->information->sampleTable->other_boxes); i++) {
+				GF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->other_boxes, i);
+				if ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) {
+					senc = (GF_SampleEncryptionBox *)a;
+					break;
+				}
 			}
+			if (!senc) {
+				senc = (GF_SampleEncryptionBox *)gf_isom_create_piff_psec_box(1, 0x2, 0, 0, NULL);
+				if (!trak->Media->information->sampleTable->other_boxes) trak->Media->information->sampleTable->other_boxes = gf_list_new();
+				gf_list_add(trak->Media->information->sampleTable->other_boxes, senc);
+			}
+			
+			sais = traf->piff_sample_encryption->samp_aux_info;
 		}
-		if (!psec) {
-			psec = gf_isom_create_piff_psec_box(1, 0x2, 0, 0, NULL);
-			if (!trak->Media->information->sampleTable->other_boxes) trak->Media->information->sampleTable->other_boxes = gf_list_new();
-			gf_list_add(trak->Media->information->sampleTable->other_boxes, psec);
-		}
-
-		for (i = 0; i < gf_list_count(traf->piff_sample_encryption->samp_aux_info); i++) {
-			GF_CENCSampleAuxInfo *sai, *new_sai;
-
-			sai = (GF_CENCSampleAuxInfo *)gf_list_get(traf->piff_sample_encryption->samp_aux_info, i);
-
-			new_sai = (GF_CENCSampleAuxInfo *)gf_malloc(sizeof(GF_CENCSampleAuxInfo));
-			memmove((char *)new_sai->IV, (const char*)sai->IV, 16);
-			new_sai->subsample_count = sai->subsample_count;
-			new_sai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(new_sai->subsample_count*sizeof(GF_CENCSubSampleEntry));
-			memmove(new_sai->subsamples, sai->subsamples, new_sai->subsample_count*sizeof(GF_CENCSubSampleEntry));
+		else if (traf->sample_encryption) {
+			for (i = 0; i < gf_list_count(trak->Media->information->sampleTable->other_boxes); i++) {
+				GF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->other_boxes, i);
+				if (a->type ==GF_ISOM_BOX_TYPE_SENC) {
+					senc = (GF_SampleEncryptionBox *)a;
+					break;
+				}
+			}
+			if (!senc) {
+				senc = gf_isom_create_samp_enc_box(1, 0x2);
+				if (!trak->Media->information->sampleTable->other_boxes) trak->Media->information->sampleTable->other_boxes = gf_list_new();
+				gf_list_add(trak->Media->information->sampleTable->other_boxes, senc);
+			}
 
-			gf_list_add(psec->samp_aux_info, new_sai);
+			sais = traf->sample_encryption->samp_aux_info;
 		}
-	}
 
-	if (traf->sample_encryption) {
-		GF_SampleEncryptionBox *senc = NULL;
-		for (i = 0; i < gf_list_count(trak->Media->information->sampleTable->other_boxes); i++) {
-			GF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->other_boxes, i);
-			if (a->type ==GF_ISOM_BOX_TYPE_SENC) {
-				senc = (GF_SampleEncryptionBox *)a;
-				break;
+		/*get sample auxiliary information by saiz/saio rather than by parsing senc box*/
+		if (gf_isom_cenc_has_saiz_saio(NULL, traf)) {
+			//GF_BitStream *bs;
+			u32 size, nb_saio;
+			u64 offset;
+			GF_Err e = GF_OK;
+			GF_SampleAuxiliaryInfoOffsetBox *saio;
+			GF_SampleAuxiliaryInfoSizeBox *saiz;
+			//GF_CENCSampleAuxInfo *sai;
+			//char *buffer;
+
+			offset = nb_saio = 0;
+
+			for (i = 0; i < gf_list_count(traf->sai_offsets); i++) {
+				saio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(traf->sai_offsets, i);
+				if (saio->aux_info_type == GF_4CC('c', 'e', 'n', 'c')) {
+					offset = saio->offsets[0] + moof_offset;
+					nb_saio = saio->entry_count;
+					break;
+				}			
+			}
+			for (i = 0; i < gf_list_count(traf->sai_sizes); i++) {
+				saiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(traf->sai_sizes, i);
+				if (saiz->aux_info_type == GF_4CC('c', 'e', 'n', 'c')) {
+					break;
+				}
 			}
-		}
-		if (!senc) {
-			senc = gf_isom_create_samp_enc_box(1, 0x2);
-			if (!trak->Media->information->sampleTable->other_boxes) trak->Media->information->sampleTable->other_boxes = gf_list_new();
-			gf_list_add(trak->Media->information->sampleTable->other_boxes, senc);
-		}
 
-		for (i = 0; i < gf_list_count(traf->sample_encryption->samp_aux_info); i++) {
-			GF_CENCSampleAuxInfo *sai, *new_sai;
+			for (i = 0; i < saiz->sample_count; i++) {
+				if (nb_saio != 1) 
+					offset = saio->offsets[i] + moof_offset;
+				size = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[i];
+
+				/*cur_position = gf_bs_get_position(trak->moov->mov->movieFileMap->bs);
+				gf_bs_seek(trak->moov->mov->movieFileMap->bs, offset);
+				buffer = (char *)malloc(size);
+				gf_bs_read_data(trak->moov->mov->movieFileMap->bs, buffer, size);
+				gf_bs_seek(trak->moov->mov->movieFileMap->bs, cur_position);
+
+				sai = (GF_CENCSampleAuxInfo *)gf_malloc(sizeof(GF_CENCSampleAuxInfo));
+				bs = gf_bs_new(buffer, size, GF_BITSTREAM_READ);
+				gf_bs_read_data(bs, (char *)sai->IV, 16);
+				if (size > 16) {
+					sai->subsample_count = gf_bs_read_u16(bs);
+					sai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(sizeof(GF_CENCSubSampleEntry)*sai->subsample_count);
+					for (j = 0; j < sai->subsample_count; j++) {
+						sai->subsamples[j].bytes_clear_data = gf_bs_read_u16(bs);
+						sai->subsamples[j].bytes_encrypted_data = gf_bs_read_u32(bs);
+					}
+					gf_bs_del(bs);
+				}
+				gf_list_add(senc->samp_aux_info, sai);
+				if (sai->subsample_count) senc->flags = 0x00000002;*/
+				gf_isom_cenc_merge_saiz_saio(senc, trak->Media->information->sampleTable, (u32)offset, size);
+				if (nb_saio == 1)
+					offset += size;				
+			}
+		}
+		else {
+			for (i = 0; i < gf_list_count(sais); i++) {
+				GF_CENCSampleAuxInfo *sai, *new_sai;
 
-			sai = (GF_CENCSampleAuxInfo *)gf_list_get(traf->sample_encryption->samp_aux_info, i);
+				sai = (GF_CENCSampleAuxInfo *)gf_list_get(sais, i);
 
-			new_sai = (GF_CENCSampleAuxInfo *)gf_malloc(sizeof(GF_CENCSampleAuxInfo));
-			memmove((char *)new_sai->IV, (const char*)sai->IV, 16);
-			new_sai->subsample_count = sai->subsample_count;
-			new_sai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(new_sai->subsample_count*sizeof(GF_CENCSubSampleEntry));
-			memmove(new_sai->subsamples, sai->subsamples, new_sai->subsample_count*sizeof(GF_CENCSubSampleEntry));
+				new_sai = (GF_CENCSampleAuxInfo *)gf_malloc(sizeof(GF_CENCSampleAuxInfo));
+				memmove((char *)new_sai->IV, (const char*)sai->IV, 16);
+				new_sai->subsample_count = sai->subsample_count;
+				new_sai->subsamples = (GF_CENCSubSampleEntry *)gf_malloc(new_sai->subsample_count*sizeof(GF_CENCSubSampleEntry));
+				memmove(new_sai->subsamples, sai->subsamples, new_sai->subsample_count*sizeof(GF_CENCSubSampleEntry));
 
-			gf_list_add(senc->samp_aux_info, new_sai);
+				gf_list_add(senc->samp_aux_info, new_sai);
+				if (sai->subsample_count) senc->flags = 0x00000002;
+			}
 		}
 	}
 	return GF_OK;
diff --git a/src/media_tools/filestreamer.c b/src/media_tools/filestreamer.c
index 09f125eae..d49097663 100644
--- a/src/media_tools/filestreamer.c
+++ b/src/media_tools/filestreamer.c
@@ -544,6 +544,22 @@ GF_ISOMRTPStreamer *gf_isom_streamer_new(const char *file_name, const char *ip_d
 			break;
 		}
 			break;
+		case GF_ISOM_SUBTYPE_HVC1:
+		case GF_ISOM_SUBTYPE_HEV1:
+		case GF_ISOM_SUBTYPE_HVC2:
+		case GF_ISOM_SUBTYPE_HEV2:
+		{
+			GF_HEVCConfig *hevcc = NULL;
+			hevcc = gf_isom_hevc_config_get(streamer->isom, track->track_num, 1);
+			if (hevcc) {
+				track->avc_nalu_size = hevcc->nal_unit_size;
+				gf_odf_hevc_cfg_del(hevcc);
+				streamType = GF_STREAM_VISUAL;
+				oti = GPAC_OTI_VIDEO_HEVC;
+			}
+			break;
+		}
+			break;
 		default:
 			streamType = GF_STREAM_4CC;
 			oti = TrackMediaSubType;
diff --git a/src/media_tools/ismacryp.c b/src/media_tools/ismacryp.c
index 17eed314c..05819da0a 100644
--- a/src/media_tools/ismacryp.c
+++ b/src/media_tools/ismacryp.c
@@ -170,8 +170,8 @@ void isma_ea_node_start(void *sax_cbck, const char *node_name, const char *name_
 			else if (!stricmp(att->name, "keyRoll")) {
 				if (!strncmp(att->value, "idx=", 4))
 					tkc->defaultKeyIdx = atoi(att->value+4);
-				else if (!strncmp(att->value, "roll=", 4))
-					tkc->keyRoll = atoi(att->value+4);
+				else if (!strncmp(att->value, "roll=", 5))
+					tkc->keyRoll = atoi(att->value+5);
 			}
 		}
 	}
@@ -843,493 +843,209 @@ static void cenc_resync_IV(GF_Crypt *mc, char IV[16], u64 BSO, u8 IV_size, Bool
 	gf_bs_del(tmp);
 }
 
-
-/*encrypts track - logs, progress: info callbacks, NULL for default*/
-GF_Err gf_cenc_encrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*progress)(void *cbk, u64 done, u64 total), void *cbk)
-{
-	GF_Err e;
-	char IV[16];
-	GF_ISOSample *samp;
-	GF_Crypt *mc;
-	Bool all_rap = GF_FALSE;
-	u32 i, count, di, track, nalu_size_length, max_size, size, len;
-	u64 BSO;
-	GF_ESD *esd;
-	Bool has_crypted_samp;
-	Bool is_nalu_video = GF_FALSE;
+static GF_Err gf_cenc_encrypt_sample_ctr(GF_Crypt *mc, GF_ISOSample *samp, Bool is_nalu_video, u32 nalu_size_length, char IV[16], u32 IV_size, char **sai, u32 *saiz) {
 	GF_BitStream *pleintext_bs, *cyphertext_bs, *sai_bs;
 	char *buffer;
-	/*for log*/
-	u8 digest[33];
-	char t[3];
-	char *buf;
+	u32 max_size, size;
+	u64 BSO;
+	GF_Err e = GF_OK;
+	GF_List *subsamples;
 
-	e = GF_OK;
-	nalu_size_length = 0;
 	pleintext_bs = cyphertext_bs = sai_bs = NULL;
-	mc = NULL;
-	buffer = buf = NULL;
 	max_size = 4096;
-
-	track = gf_isom_get_track_by_id(mp4, tci->trackID);
-	if (!track) {
-		GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot find TrackID %d in input file - skipping\n", tci->trackID));
-		return GF_OK;
-	}
-
-	esd = gf_isom_get_esd(mp4, track, 1);
-	if (esd && (esd->decoderConfig->streamType == GF_STREAM_OD)) {
-		gf_odf_desc_del((GF_Descriptor *) esd);
-		GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot encrypt OD tracks - skipping"));
-		return GF_NOT_SUPPORTED;
-	}
-	if (esd) {
-		if ((esd->decoderConfig->objectTypeIndication==GPAC_OTI_VIDEO_AVC) || (esd->decoderConfig->objectTypeIndication==GPAC_OTI_VIDEO_SVC)) {
-			GF_AVCConfig *avccfg = gf_isom_avc_config_get(mp4, track, 1);
-			GF_AVCConfig *svccfg = gf_isom_svc_config_get(mp4, track, 1);
-			if (avccfg)
-				nalu_size_length = avccfg->nal_unit_size;
-			else if (svccfg)
-				nalu_size_length = svccfg->nal_unit_size;
-			if (avccfg) gf_odf_avc_cfg_del(avccfg);
-			if (svccfg) gf_odf_avc_cfg_del(svccfg);
-			is_nalu_video = GF_TRUE;
-		}
-		else if ((esd->decoderConfig->objectTypeIndication==GPAC_OTI_VIDEO_HEVC)) {
-			GF_HEVCConfig *hevccfg = gf_isom_hevc_config_get(mp4, track, 1);
-			if (hevccfg)
-				nalu_size_length = hevccfg->nal_unit_size;
-			if (hevccfg) gf_odf_hevc_cfg_del(hevccfg);
-			is_nalu_video = GF_TRUE;
-		}
-		gf_odf_desc_del((GF_Descriptor*) esd);
-	}
-
-	samp = NULL;
-
-	mc = gf_crypt_open("AES-128", "CTR");
-	if (!mc) {
-		GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot open AES-128 CTR\n"));
+	BSO = 0;
+	buffer = (char*)gf_malloc(sizeof(char) * max_size);
+	memset(buffer, 0, max_size);
+	pleintext_bs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);
+	cyphertext_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
+	sai_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
+	gf_bs_write_data(sai_bs, IV, 16);
+	subsamples = gf_list_new();
+	if (!subsamples) {
 		e = GF_IO_ERR;
-		goto exit;
+		goto exit; 
 	}
+	while (gf_bs_available(pleintext_bs)) {
+		GF_CENCSubSampleEntry *entry = (GF_CENCSubSampleEntry *)gf_malloc(sizeof(GF_CENCSubSampleEntry));
 
-	/*select key*/
-	if (tci->defaultKeyIdx && (tci->defaultKeyIdx < tci->KID_count)) {
-		memcpy(tci->key, tci->keys[tci->defaultKeyIdx], 16);
-		memcpy(tci->default_KID, tci->KIDs[tci->defaultKeyIdx], 16);
-	} else {
-		memcpy(tci->key, tci->keys[0], 16);
-		memcpy(tci->default_KID, tci->KIDs[0], 16);
-	}
-
-	/*create CENC protection*/
-	e = gf_isom_set_cenc_protection(mp4, track, 1, GF_ISOM_CENC_SCHEME, 1, tci->IsEncrypted, tci->IV_size, tci->default_KID);
-	if (e) goto  exit;
-
-
-	count = gf_isom_get_sample_count(mp4, track);
-	buffer = (char*)gf_malloc(sizeof(char) * max_size);
-	BSO = 0;
-	has_crypted_samp = GF_FALSE;
-	/*Sample Encryption Box*/
-	e = gf_isom_cenc_allocate_storage(mp4, track, tci->sai_saved_box_type, 0, 0, NULL);
-	if (e) goto exit;
-	
-	if (! gf_isom_has_sync_points(mp4, track)) 
-		all_rap = GF_TRUE;
-
-	gf_isom_set_nalu_extract_mode(mp4, track, GF_ISOM_NALU_EXTRACT_INSPECT);
-	for (i = 0; i < count; i++) {
-		GF_List *subsamples;
-
-		samp = gf_isom_get_sample(mp4, track, i+1, &di);
-		if (!samp)
-		{
-			e = GF_IO_ERR;
-			goto exit;
-		}
-		sai_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-		switch (tci->sel_enc_type) {
-			case GF_CRYPT_SELENC_RAP:
-				if (!samp->IsRAP && !all_rap) {
-					char tmp[16];
-					memset(tmp, 0, 16);
-					gf_bs_write_data(sai_bs, tmp, 16);
-					gf_bs_write_u16(sai_bs, 0);
-					gf_bs_get_content(sai_bs, &buf, &len);
-					gf_bs_del(sai_bs);
-					sai_bs = NULL;
-
-					e = gf_isom_track_cenc_add_sample_info(mp4, track, tci->sai_saved_box_type, buf, len);
-					if (e) 
-						goto exit;
-					gf_free(buf);
-					buf = NULL;
-					gf_isom_sample_del(&samp);
-					continue;
-				}
-				break;
-			case GF_CRYPT_SELENC_NON_RAP:
-				if (samp->IsRAP || all_rap) {
-					char tmp[16];
-					memset(tmp, 0, 16);
-					gf_bs_write_data(sai_bs, tmp, 16);
-					gf_bs_write_u16(sai_bs, 0);
-					gf_bs_get_content(sai_bs, &buf, &len);
-					gf_bs_del(sai_bs);
-					sai_bs = NULL;
-
-					e = gf_isom_track_cenc_add_sample_info(mp4, track, tci->sai_saved_box_type, buf, len);
-					if (e) 
-						goto exit;
-					gf_free(buf);
-					buf = NULL;
-					gf_isom_sample_del(&samp);
-					continue;
-				}
-				break;
-			default:
-				break;
-		}
-
-		subsamples = gf_list_new();
-		if (!subsamples) {
-			e = GF_IO_ERR;
-			goto exit; 
-		}
-
-		/*generate initialization vector for the first sample in track ... */
-		if (!has_crypted_samp) {
-			memset(IV, 0, sizeof(char)*16);
-			if (tci->IV_size == 8) {
-				memcpy(IV, tci->first_IV, sizeof(char)*8);
-				memset(IV+8, '0', sizeof(char)*8);
-			} 
-			else if (tci->IV_size == 16) {
-				memcpy(IV, tci->first_IV, sizeof(char)*16);
+		if (is_nalu_video) {
+			u32 nal_hdr;
+			size = gf_bs_read_int(pleintext_bs, 8*nalu_size_length);
+			if (size>max_size) {
+				buffer = (char*)gf_realloc(buffer, sizeof(char)*size);
+				max_size = size;
 			}
-			else 
-				return GF_NOT_SUPPORTED;
-			e = gf_crypt_init(mc, tci->key, 16, IV);
-			if (e) {
-				GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot initialize AES-128 CTR (%s)\n", gf_error_to_string(e)) );
-				gf_crypt_close(mc);
-				mc = NULL;
-				e = GF_IO_ERR;
-				goto exit;
-			}
-			has_crypted_samp = GF_TRUE;
-		}
-		/* ... or update initialization vector for the subsequent samples*/
-		else {
-			cenc_resync_IV(mc, IV, BSO, tci->IV_size, GF_TRUE);
-		}
+			nal_hdr = gf_bs_read_u8(pleintext_bs);
 
-		gf_bs_write_data(sai_bs, IV, 16);
+			gf_bs_read_data(pleintext_bs, buffer, size-1);
+			gf_crypt_encrypt(mc, buffer, size-1);
+			BSO += size-1;
 
-		{
-			u32 j;
-			digest[0] = 0;				
-			for ( j=0; j<16; j++ ) {
-				t[2] = 0;
-				sprintf ( t, "%02X", (u8) IV[j] );
-				strcat ( (char*)digest, t );
-			}
-			GF_LOG(GF_LOG_DEBUG, GF_LOG_AUTHOR, ("[CENC] IV for sample %d \n \t\t first NALU: %s \n", i+1, digest) );
-		}
+			/*write clear data and encrypted data to bitstream*/
+			gf_bs_write_int(cyphertext_bs, size, 8*nalu_size_length);
+			gf_bs_write_u8(cyphertext_bs, nal_hdr);
+			gf_bs_write_data(cyphertext_bs, buffer, size-1);
 
-		BSO = 0;
-		memset(buffer, 0, max_size);
-		pleintext_bs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);
-		cyphertext_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-
-		while (gf_bs_available(pleintext_bs)) {
-			GF_CENCSubSampleEntry *entry = (GF_CENCSubSampleEntry *)gf_malloc(sizeof(GF_CENCSubSampleEntry));
-
-			if (is_nalu_video) {
-				u32 nal_hdr;
-				size = gf_bs_read_int(pleintext_bs, 8*nalu_size_length);
-				if (size>max_size) {
-					buffer = (char*)gf_realloc(buffer, sizeof(char)*size);
-					max_size = size;
-				}
-				nal_hdr = gf_bs_read_u8(pleintext_bs);
-
-				gf_bs_read_data(pleintext_bs, buffer, size-1);
-				gf_crypt_encrypt(mc, buffer, size-1);
-				BSO += size-1;
-
-				/*write clear data and encrypted data to bitstream*/
-				gf_bs_write_int(cyphertext_bs, size, 8*nalu_size_length);
-				gf_bs_write_u8(cyphertext_bs, nal_hdr);
-				gf_bs_write_data(cyphertext_bs, buffer, size-1);
-
-				entry->bytes_clear_data = nalu_size_length + 1;
-				entry->bytes_encrypted_data = size - 1;
-
-			} else {
-				gf_bs_read_data(pleintext_bs, buffer, samp->dataLength);
-				gf_crypt_encrypt(mc, buffer, samp->dataLength);
-				gf_bs_write_data(cyphertext_bs, buffer, samp->dataLength);
-
-				BSO += samp->dataLength;			
-				entry->bytes_clear_data = 0;
-				entry->bytes_encrypted_data = samp->dataLength;
-			}
-
-
-			gf_list_add(subsamples, entry);
+			entry->bytes_clear_data = nalu_size_length + 1;
+			entry->bytes_encrypted_data = size - 1;
 
+		} else {
+			gf_bs_read_data(pleintext_bs, buffer, samp->dataLength);
+			gf_crypt_encrypt(mc, buffer, samp->dataLength);
+			gf_bs_write_data(cyphertext_bs, buffer, samp->dataLength);
 
-			/*update IV for next sub-samples*/
-			if (gf_bs_available(pleintext_bs))
-				cenc_resync_IV(mc, IV, BSO, tci->IV_size, GF_FALSE);
-		}
-	
-		/*rewrite cypher text to CENC sample*/	
-		gf_bs_del(pleintext_bs);
-		pleintext_bs = NULL;
-		if (samp->data) {
-			gf_free(samp->data);
-			samp->data = NULL;
-			samp->dataLength = 0;
-		}
-		gf_bs_get_content(cyphertext_bs, &samp->data, &samp->dataLength);
-		gf_bs_del(cyphertext_bs);
-		cyphertext_bs = NULL;
-		gf_isom_update_sample(mp4, track, i+1, samp, 1);
-		gf_isom_sample_del(&samp);
-		samp = NULL;
-		/*write sample auxiliary info to bitstream*/
-		//sample_info_size[i] = 18 + 8*gf_list_count(subsamples);
-		gf_bs_write_u16(sai_bs, gf_list_count(subsamples));
-		while (gf_list_count(subsamples)) {
-			GF_CENCSubSampleEntry *ptr = (GF_CENCSubSampleEntry *)gf_list_get(subsamples, 0);
-			gf_list_rem(subsamples, 0);
-			gf_bs_write_u32(sai_bs, ptr->bytes_clear_data);
-			gf_bs_write_u32(sai_bs, ptr->bytes_encrypted_data);
-			gf_free(ptr);
+			BSO += samp->dataLength;			
+			entry->bytes_clear_data = 0;
+			entry->bytes_encrypted_data = samp->dataLength;
 		}
-		gf_list_del(subsamples);
-		gf_bs_get_content(sai_bs, &buf, &len);
-		gf_bs_del(sai_bs);
-		sai_bs = NULL;
-
-		e = gf_isom_track_cenc_add_sample_info(mp4, track, tci->sai_saved_box_type, buf, len);
-		if (e) 
-			goto exit;
-		gf_free(buf);
-		buf = NULL;
-
-		gf_set_progress("CENC Encrypt", i+1, count);
-
-	}
-
-exit:
-	//if (sample_info_size) gf_free(sample_info_size);
-	if (samp) gf_isom_sample_del(&samp);
-	if (mc) gf_crypt_close(mc);
-	if (buffer) gf_free(buffer);
-	if (buf) gf_free(buf);
-	if (pleintext_bs) gf_bs_del(pleintext_bs);
-	if (cyphertext_bs) gf_bs_del(cyphertext_bs);
-	if (sai_bs) gf_bs_del(sai_bs);
-	return e;
-}
 
-/*decrypts track - logs, progress: info callbacks, NULL for default*/
-GF_Err gf_cenc_decrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*progress)(void *cbk, u64 done, u64 total), void *cbk)
-{
-	GF_Err e;
-	u32 track, count, i, si, max_size, subsample_count;
-	u64 BSO;
-	GF_ISOSample *samp;
-	GF_Crypt *mc;
-	char IV[17];
-	Bool prev_sample_encrypted;
-	GF_BitStream *pleintext_bs, *cyphertext_bs;
-	GF_CENCSampleAuxInfo *sai;
-	char *buffer;
-	/*for log*/
-	u8 digest[33];
-	char t[3];
 
-	e = GF_OK;
-	pleintext_bs = cyphertext_bs = NULL;
-	mc = NULL;
-	buffer = NULL;
-	max_size = 4096;
+		gf_list_add(subsamples, entry);
 
-	track = gf_isom_get_track_by_id(mp4, tci->trackID);
-	if (!track) {
-		GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot find TrackID %d in input file - skipping\n", tci->trackID));
-		return GF_OK;
-	}
 
-	/*select key*/
-	if (tci->defaultKeyIdx && (tci->defaultKeyIdx < tci->KID_count)) {
-		memcpy(tci->key, tci->keys[tci->defaultKeyIdx], 16);
-		memcpy(tci->default_KID, tci->KIDs[tci->defaultKeyIdx], 16);
-	} else {
-		memcpy(tci->key, tci->keys[0], 16);
-		memcpy(tci->default_KID, tci->KIDs[0], 16);
+		/*update IV for next sub-samples*/
+		if (gf_bs_available(pleintext_bs))
+			cenc_resync_IV(mc, IV, BSO, IV_size, GF_FALSE);
 	}
 
-	mc = gf_crypt_open("AES-128", "CTR");
-	if (!mc) {
-		GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot open AES-128 CTR\n"));
-		e = GF_IO_ERR;
-		goto exit;
-	}
-
-	/* decrypt each sample */
-	count = gf_isom_get_sample_count(mp4, track);
-	buffer = (char*)gf_malloc(sizeof(char) * max_size);
-	prev_sample_encrypted = GF_FALSE;
-	gf_isom_set_nalu_extract_mode(mp4, track, GF_ISOM_NALU_EXTRACT_INSPECT);
-	for (i = 0; i < count; i++) {
-		memset(IV, 0, 17);
-		memset(buffer, 0, max_size);
-		BSO = 0;
-
-		samp = gf_isom_get_sample(mp4, track, i+1, &si);
-		if (!samp)
-		{
-			e = GF_IO_ERR;
-			goto exit;
-		}
-
-		sai = gf_isom_cenc_get_sample_aux_info(mp4, track, i+1, NULL);
-		if (!sai) {
-			e = GF_IO_ERR;
-			goto exit;
-		}
-
-		if (!strlen((char *)sai->IV)) {
-			gf_isom_sample_del(&samp);
-			continue;
-		}
+	if (samp->data) {
+		gf_free(samp->data);
+		samp->data = NULL;
+		samp->dataLength = 0;
+	}
+	gf_bs_get_content(cyphertext_bs, &samp->data, &samp->dataLength);
+	gf_bs_write_u16(sai_bs, gf_list_count(subsamples));
+	while (gf_list_count(subsamples)) {
+		GF_CENCSubSampleEntry *ptr = (GF_CENCSubSampleEntry *)gf_list_get(subsamples, 0);
+		gf_list_rem(subsamples, 0);
+		gf_bs_write_u16(sai_bs, ptr->bytes_clear_data);
+		gf_bs_write_u32(sai_bs, ptr->bytes_encrypted_data);
+		gf_free(ptr);
+	}
+	gf_list_del(subsamples);
+	gf_bs_get_content(sai_bs, sai, saiz);
+	cenc_resync_IV(mc, IV, BSO, IV_size, GF_TRUE);
 
-		cyphertext_bs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);
-		pleintext_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
+exit:
+	if (buffer) gf_free(buffer);
+	if (pleintext_bs) gf_bs_del(pleintext_bs);
+	if (cyphertext_bs) gf_bs_del(cyphertext_bs);
+	if (sai_bs) gf_bs_del(sai_bs);
+	return e;
+}
 
-		if (!prev_sample_encrypted) {
-			memmove(IV, sai->IV, 16);
-			e = gf_crypt_init(mc, tci->key, 16, IV);
-			if (e) {
-				GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot initialize AES-128 CTR (%s)\n", gf_error_to_string(e)) );
-				gf_crypt_close(mc);
-				mc = NULL;
-				e = GF_IO_ERR;
-				goto exit;
-			}
-			prev_sample_encrypted = GF_TRUE;
-		}
-		else {
-			GF_BitStream *bs;
-			bs = gf_bs_new(IV, 17, GF_BITSTREAM_WRITE);
-			gf_bs_write_u8(bs, 0);	/*begin of counter*/
-			gf_bs_write_data(bs, (char *)sai->IV, 16);
-			gf_bs_del(bs);
-			gf_crypt_set_state(mc, IV, 17);
-		}
+static GF_Err gf_cenc_encrypt_sample_cbc(GF_Crypt *mc, GF_ISOSample *samp, Bool is_nalu_video, u32 nalu_size_length, char IV[16], u32 IV_size, char **sai, u32 *saiz) {
+	GF_BitStream *pleintext_bs, *cyphertext_bs, *sai_bs;
+	char *buffer;
+	u32 max_size, size;
+	GF_Err e = GF_OK;
+	GF_List *subsamples;
 
-		{
-			u32 j;
-			digest[0] = 0;				
-			for ( j=0; j<16; j++ ) {
-				t[2] = 0;
-				sprintf ( t, "%02X", (u8) sai->IV[j] );
-				strcat ( (char*)digest, t );
+	pleintext_bs = cyphertext_bs = sai_bs = NULL;
+	max_size = 4096;
+	buffer = (char*)gf_malloc(sizeof(char) * max_size);
+	memset(buffer, 0, max_size);
+	pleintext_bs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);
+	cyphertext_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
+	sai_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
+	gf_bs_write_data(sai_bs, IV, 16);
+	subsamples = gf_list_new();
+	if (!subsamples) {
+		e = GF_IO_ERR;
+		goto exit; 
+	}
+	while (gf_bs_available(pleintext_bs)) {
+		u32 ret;
+		GF_CENCSubSampleEntry *entry = (GF_CENCSubSampleEntry *)gf_malloc(sizeof(GF_CENCSubSampleEntry));
+
+		if (is_nalu_video) {
+			size = gf_bs_read_int(pleintext_bs, 8*nalu_size_length);
+			if (size+1 > max_size) {
+				buffer = (char*)gf_realloc(buffer, sizeof(char)*(size+1));
+				memset(buffer, 0, sizeof(char)*(size+1));
+				max_size = size + 1;
 			}
-			GF_LOG(GF_LOG_DEBUG, GF_LOG_AUTHOR, ("[CENC] IV for sample %d \n \t\t first NALU: %s \n", i+1, digest) );
-		}
+			gf_bs_write_int(cyphertext_bs, size, 8*nalu_size_length);
 
-		subsample_count = 0;
-		while (gf_bs_available(cyphertext_bs)) {
-			assert(subsample_count < sai->subsample_count);
+			gf_bs_read_data(pleintext_bs, buffer, size);
 
-			/*read clear data and write it to pleintext bitstream*/
-			if (max_size < sai->subsamples[subsample_count].bytes_clear_data) {
-				buffer = (char*)gf_realloc(buffer, sizeof(char)*sai->subsamples[subsample_count].bytes_clear_data);
-				max_size = sai->subsamples[subsample_count].bytes_clear_data;
+			ret = size % 16;
+			if (ret) {
+				gf_bs_write_data(cyphertext_bs, buffer, ret);
 			}
-			gf_bs_read_data(cyphertext_bs, buffer, sai->subsamples[subsample_count].bytes_clear_data);
-			gf_bs_write_data(pleintext_bs, buffer, sai->subsamples[subsample_count].bytes_clear_data);
 
-			/*now read encrypted data, decrypted it and write to pleintext bitstream*/
-			if (max_size < sai->subsamples[subsample_count].bytes_encrypted_data) {
-				buffer = (char*)gf_realloc(buffer, sizeof(char)*sai->subsamples[subsample_count].bytes_encrypted_data);
-				max_size = sai->subsamples[subsample_count].bytes_encrypted_data;
+			if (size >= 16) {
+				gf_crypt_encrypt(mc, buffer+ret, size - ret);
+				gf_bs_write_data(cyphertext_bs, buffer+ret, size - ret);
 			}
-			gf_bs_read_data(cyphertext_bs, buffer, sai->subsamples[subsample_count].bytes_encrypted_data);
-			gf_crypt_decrypt(mc, buffer, sai->subsamples[subsample_count].bytes_encrypted_data);
-			gf_bs_write_data(pleintext_bs, buffer, sai->subsamples[subsample_count].bytes_encrypted_data);
 
-			/*update IV for next subsample*/
-			BSO += sai->subsamples[subsample_count].bytes_encrypted_data;
-			if (gf_bs_available(cyphertext_bs))
-				cenc_resync_IV(mc, (char *)sai->IV, BSO, tci->IV_size, GF_FALSE);
+			entry->bytes_clear_data = nalu_size_length + ret;
+			entry->bytes_encrypted_data = (size >= 16) ? size - ret : 0  ;
+		} else {
+			gf_bs_read_data(pleintext_bs, buffer, samp->dataLength);
+			ret = samp->dataLength % 16;
+			if (ret) {
+				gf_bs_write_data(cyphertext_bs, buffer, ret);
+			}
+			if (samp->dataLength >= 16) {
+				gf_crypt_encrypt(mc, buffer, samp->dataLength);
+				gf_bs_write_data(cyphertext_bs, buffer, samp->dataLength);
+			}
 
-			subsample_count++;
-		}
-		
-		gf_bs_del(cyphertext_bs);
-		cyphertext_bs = NULL;
-		if (samp->data) {
-			gf_free(samp->data);
-			samp->data = NULL;
-			samp->dataLength = 0;
+			entry->bytes_clear_data = ret;
+			entry->bytes_encrypted_data = (samp->dataLength >= 16) ? samp->dataLength - ret : 0;
 		}
-		gf_bs_get_content(pleintext_bs, &samp->data, &samp->dataLength);
-		gf_bs_del(pleintext_bs);
-		pleintext_bs = NULL;
-		gf_isom_update_sample(mp4, track, i+1, samp, 1);
-		gf_isom_sample_del(&samp);
-		samp = NULL;
 
-		gf_set_progress("CENC Decrypt", i+1, count);
+		gf_list_add(subsamples, entry);
 	}
 
-	/*remove protection info*/
-	e = gf_isom_remove_track_protection(mp4, track, 1);
-	if (e) {
-		GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Error CENC signature from trackID %d: %s\n", tci->trackID, gf_error_to_string(e)));
+	if (samp->data) {
+		gf_free(samp->data);
+		samp->data = NULL;
+		samp->dataLength = 0;
 	}
-
-	gf_isom_remove_cenc_saiz(mp4, track);
-	gf_isom_remove_cenc_saio(mp4, track);
-	gf_isom_remove_samp_enc_box(mp4, track);
+	gf_bs_get_content(cyphertext_bs, &samp->data, &samp->dataLength);
+	gf_bs_write_u16(sai_bs, gf_list_count(subsamples));
+	while (gf_list_count(subsamples)) {
+		GF_CENCSubSampleEntry *ptr = (GF_CENCSubSampleEntry *)gf_list_get(subsamples, 0);
+		gf_list_rem(subsamples, 0);
+		gf_bs_write_u16(sai_bs, ptr->bytes_clear_data);
+		gf_bs_write_u32(sai_bs, ptr->bytes_encrypted_data);
+		gf_free(ptr);
+	}
+	gf_list_del(subsamples);
+	gf_bs_get_content(sai_bs, sai, saiz);
 
 exit:
-	if (mc) gf_crypt_close(mc);
+	if (buffer) gf_free(buffer);
 	if (pleintext_bs) gf_bs_del(pleintext_bs);
 	if (cyphertext_bs) gf_bs_del(cyphertext_bs);
-	if (samp) gf_isom_sample_del(&samp);
-	if (buffer) gf_free(buffer);
+	if (sai_bs) gf_bs_del(sai_bs);
 	return e;
 }
 
-GF_Err gf_cbc_encrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*progress)(void *cbk, u64 done, u64 total), void *cbk)
+
+/*encrypts track - logs, progress: info callbacks, NULL for default*/
+GF_Err gf_cenc_encrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*progress)(void *cbk, u64 done, u64 total), void *cbk)
 {
 	GF_Err e;
 	char IV[16];
 	GF_ISOSample *samp;
 	GF_Crypt *mc;
-	u32 i, count, di, track, nalu_size_length, max_size, size, len;
+	Bool all_rap = GF_FALSE;
+	u32 i, count, di, track, len, nb_samp_encrypted, nalu_size_length, idx;
 	GF_ESD *esd;
-	Bool is_nalu_video = GF_TRUE;
 	Bool has_crypted_samp;
-	GF_BitStream *pleintext_bs, *cyphertext_bs, *sai_bs;
-	char *buffer, *buf;
+	Bool is_nalu_video = GF_FALSE;
+	char *buf;
+	GF_BitStream *bs;
 
 	e = GF_OK;
 	nalu_size_length = 0;
-	pleintext_bs = cyphertext_bs = sai_bs = NULL;
 	mc = NULL;
-	buffer = buf = NULL;
-	max_size = 4096;
+	buf = NULL;
+	bs = NULL;
+	idx = 0;
 
 	track = gf_isom_get_track_by_id(mp4, tci->trackID);
 	if (!track) {
@@ -1362,15 +1078,17 @@ GF_Err gf_cbc_encrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*prog
 			if (hevccfg) gf_odf_hevc_cfg_del(hevccfg);
 			is_nalu_video = GF_TRUE;
 		}
-
-
 		gf_odf_desc_del((GF_Descriptor*) esd);
 	}
 
+	samp = NULL;
 
-	mc = gf_crypt_open("AES-128", "CBC");
+	if (tci->enc_type == 2)
+		mc = gf_crypt_open("AES-128", "CTR");
+	else if (tci->enc_type == 3)
+		mc = gf_crypt_open("AES-128", "CBC");
 	if (!mc) {
-		GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot open AES-128 CBC\n"));
+		GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot open AES-128 %s\n", (tci->enc_type == 2) ? "CTR" : "CBC"));
 		e = GF_IO_ERR;
 		goto exit;
 	}
@@ -1379,39 +1097,46 @@ GF_Err gf_cbc_encrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*prog
 	if (tci->defaultKeyIdx && (tci->defaultKeyIdx < tci->KID_count)) {
 		memcpy(tci->key, tci->keys[tci->defaultKeyIdx], 16);
 		memcpy(tci->default_KID, tci->KIDs[tci->defaultKeyIdx], 16);
+		idx = tci->defaultKeyIdx;
 	} else {
 		memcpy(tci->key, tci->keys[0], 16);
 		memcpy(tci->default_KID, tci->KIDs[0], 16);
+		idx = 0;
 	}
 
 	/*create CENC protection*/
-	e = gf_isom_set_cenc_protection(mp4, track, 1, GF_ISOM_CBC_SCHEME, 1, tci->IsEncrypted, tci->IV_size, tci->default_KID);
+	e = gf_isom_set_cenc_protection(mp4, track, 1, (tci->enc_type == 2) ? GF_ISOM_CENC_SCHEME : GF_ISOM_CBC_SCHEME, 1, tci->IsEncrypted, tci->IV_size, tci->default_KID);
 	if (e) goto  exit;
 
 
 	count = gf_isom_get_sample_count(mp4, track);
-	buffer = (char*)gf_malloc(sizeof(char) * max_size);
+	
 	has_crypted_samp = GF_FALSE;
+	nb_samp_encrypted = 0;
 	/*Sample Encryption Box*/
 	e = gf_isom_cenc_allocate_storage(mp4, track, tci->sai_saved_box_type, 0, 0, NULL);
 	if (e) goto exit;
+	
+	if (! gf_isom_has_sync_points(mp4, track)) 
+		all_rap = GF_TRUE;
 
 	gf_isom_set_nalu_extract_mode(mp4, track, GF_ISOM_NALU_EXTRACT_INSPECT);
 	for (i = 0; i < count; i++) {
-		GF_List *subsamples;
-
 		samp = gf_isom_get_sample(mp4, track, i+1, &di);
 		if (!samp)
 		{
 			e = GF_IO_ERR;
 			goto exit;
 		}
-		sai_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
+		
 		switch (tci->sel_enc_type) {
 			case GF_CRYPT_SELENC_RAP:
-				if (!samp->IsRAP) {
-					char tmp[16];
-					memset(tmp, 0, 16);
+				if (!samp->IsRAP && !all_rap) {
+					GF_BitStream *sai_bs;
+					bin128 tmp;
+					memset(tmp, 0, sizeof(bin128) );
+
+					sai_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
 					gf_bs_write_data(sai_bs, tmp, 16);
 					gf_bs_write_u16(sai_bs, 0);
 					gf_bs_get_content(sai_bs, &buf, &len);
@@ -1423,14 +1148,21 @@ GF_Err gf_cbc_encrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*prog
 						goto exit;
 					gf_free(buf);
 					buf = NULL;
+
+					//already done: memset(tmp, 0, 16);
+					e = gf_isom_set_sample_cenc_group(mp4, track, i+1, 0, 0, tmp);
+					if (e) goto exit;
+
 					gf_isom_sample_del(&samp);
 					continue;
 				}
 				break;
 			case GF_CRYPT_SELENC_NON_RAP:
-				if (samp->IsRAP) {
-					char tmp[16];
-					memset(tmp, 0, 16);
+				if (samp->IsRAP || all_rap) {
+					GF_BitStream *sai_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
+					bin128 tmp;
+					memset(tmp, 0, sizeof(bin128));
+
 					gf_bs_write_data(sai_bs, tmp, 16);
 					gf_bs_write_u16(sai_bs, 0);
 					gf_bs_get_content(sai_bs, &buf, &len);
@@ -1438,10 +1170,15 @@ GF_Err gf_cbc_encrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*prog
 					sai_bs = NULL;
 
 					e = gf_isom_track_cenc_add_sample_info(mp4, track, tci->sai_saved_box_type, buf, len);
-					if (e) 
-						goto exit;
+					if (e) goto exit;
 					gf_free(buf);
 					buf = NULL;
+
+					//alreaduy done: memset(tmp, 0, 16);
+
+					e = gf_isom_set_sample_cenc_group(mp4, track, i+1, 0, 0, tmp);
+					if (e) goto exit;
+
 					gf_isom_sample_del(&samp);
 					continue;
 				}
@@ -1450,12 +1187,6 @@ GF_Err gf_cbc_encrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*prog
 				break;
 		}
 
-		subsamples = gf_list_new();
-		if (!subsamples) {
-			e = GF_IO_ERR;
-			goto exit; 
-		}
-
 		/*generate initialization vector for the first sample in track ... */
 		if (!has_crypted_samp) {
 			memset(IV, 0, sizeof(char)*16);
@@ -1468,9 +1199,10 @@ GF_Err gf_cbc_encrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*prog
 			}
 			else 
 				return GF_NOT_SUPPORTED;
+
 			e = gf_crypt_init(mc, tci->key, 16, IV);
 			if (e) {
-				GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot initialize AES-128 CBC (%s)\n", gf_error_to_string(e)) );
+				GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot initialize AES-128 %s (%s)\n", (tci->enc_type == 2) ? "CTR" : "CBC", gf_error_to_string(e)) );
 				gf_crypt_close(mc);
 				mc = NULL;
 				e = GF_IO_ERR;
@@ -1478,105 +1210,62 @@ GF_Err gf_cbc_encrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*prog
 			}
 			has_crypted_samp = GF_TRUE;
 		}
-
-		gf_bs_write_data(sai_bs, IV, 16);
-
-		memset(buffer, 0, max_size);
-		pleintext_bs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);
-		cyphertext_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-
-		while (gf_bs_available(pleintext_bs)) {
-			u32 ret;
-			GF_CENCSubSampleEntry *entry = (GF_CENCSubSampleEntry *)gf_malloc(sizeof(GF_CENCSubSampleEntry));
-
-			if (is_nalu_video) {
-				size = gf_bs_read_int(pleintext_bs, 8*nalu_size_length);
-				if (size+1 > max_size) {
-					buffer = (char*)gf_realloc(buffer, sizeof(char)*(size+1));
-					memset(buffer, 0, sizeof(char)*(size+1));
-					max_size = size + 1;
-				}
-				gf_bs_write_int(cyphertext_bs, size, 8*nalu_size_length);
-
-				gf_bs_read_data(pleintext_bs, buffer, size);
-
-				ret = size % 16;
-				if (ret) {
-					gf_bs_write_data(cyphertext_bs, buffer, ret);
-				}
-
-				if (size > 16) {
-					gf_crypt_encrypt(mc, buffer+ret, size - ret);
-					gf_bs_write_data(cyphertext_bs, buffer+ret, size - ret);
+		else {
+			if (tci->keyRoll) {
+				idx = (nb_samp_encrypted / tci->keyRoll) % tci->KID_count;
+				memcpy(tci->key, tci->keys[idx], 16);
+				e = gf_crypt_set_key(mc, tci->key, 16, IV);
+				if (e) {
+					GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot set key AES-128 %s (%s)\n", (tci->enc_type == 2) ? "CTR" : "CBC", gf_error_to_string(e)) );
+					gf_crypt_close(mc);
+					mc = NULL;
+					e = GF_IO_ERR;
+					goto exit;
 				}
-
-				entry->bytes_clear_data = nalu_size_length + ret;
-				entry->bytes_encrypted_data = size - ret;
-				gf_list_add(subsamples, entry);
-			} else {
-				gf_bs_read_data(pleintext_bs, buffer, samp->dataLength);
-				gf_crypt_encrypt(mc, buffer, samp->dataLength);
-				gf_bs_write_data(cyphertext_bs, buffer, samp->dataLength);
-
-				entry->bytes_clear_data = 0;
-				entry->bytes_encrypted_data = samp->dataLength;
 			}
 		}
-	
-		/*rewrite cypher text to CENC sample*/	
-		gf_bs_del(pleintext_bs);
-		pleintext_bs = NULL;
-		if (samp->data) {
-			gf_free(samp->data);
-			samp->data = NULL;
-			samp->dataLength = 0;
-		}
-		gf_bs_get_content(cyphertext_bs, &samp->data, &samp->dataLength);
-		gf_bs_del(cyphertext_bs);
-		cyphertext_bs = NULL;
+
+		/*add this sample to sample encryption group*/
+		e = gf_isom_set_sample_cenc_group(mp4, track, i+1, 1, tci->IV_size,tci->KIDs[idx]);
+		if (e) goto exit;
+
+		if (tci->enc_type == 2)
+			gf_cenc_encrypt_sample_ctr(mc, samp, is_nalu_video, nalu_size_length, IV, tci->IV_size, &buf, &len);
+		else if (tci->enc_type == 3)
+			gf_cenc_encrypt_sample_cbc(mc, samp, is_nalu_video, nalu_size_length, IV, tci->IV_size, &buf, &len);
+		
 		gf_isom_update_sample(mp4, track, i+1, samp, 1);
 		gf_isom_sample_del(&samp);
 		samp = NULL;
 
-		gf_bs_write_u16(sai_bs, gf_list_count(subsamples));
-		while (gf_list_count(subsamples)) {
-			GF_CENCSubSampleEntry *ptr = (GF_CENCSubSampleEntry *)gf_list_get(subsamples, 0);
-			gf_list_rem(subsamples, 0);
-			gf_bs_write_u32(sai_bs, ptr->bytes_clear_data);
-			gf_bs_write_u32(sai_bs, ptr->bytes_encrypted_data);
-			gf_free(ptr);
-		}
-		gf_list_del(subsamples);
-		gf_bs_get_content(sai_bs, &buf, &len);
-		gf_bs_del(sai_bs);
-		sai_bs = NULL;
-
 		e = gf_isom_track_cenc_add_sample_info(mp4, track, tci->sai_saved_box_type, buf, len);
 		if (e) 
 			goto exit;
 		gf_free(buf);
 		buf = NULL;
-		gf_set_progress("CENC-CBC Encrypt", i+1, count);
+
+		nb_samp_encrypted++;
+		gf_set_progress("CENC Encrypt", i+1, count);
+
 	}
 
 exit:
 	if (samp) gf_isom_sample_del(&samp);
 	if (mc) gf_crypt_close(mc);
-	if (buffer) gf_free(buffer);
 	if (buf) gf_free(buf);
-	if (pleintext_bs) gf_bs_del(pleintext_bs);
-	if (cyphertext_bs) gf_bs_del(cyphertext_bs);
-	if (sai_bs) gf_bs_del(sai_bs);
+	if (bs) gf_bs_del(bs);
 	return e;
 }
 
-GF_Err gf_cbc_decrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*progress)(void *cbk, u64 done, u64 total), void *cbk)
+/*decrypts track - logs, progress: info callbacks, NULL for default*/
+GF_Err gf_cenc_decrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*progress)(void *cbk, u64 done, u64 total), void *cbk)
 {
 	GF_Err e;
-	u32 track, count, i, si, max_size, subsample_count;
+	u32 track, count, i, j, si, max_size, subsample_count, nb_samp_decrypted;
+	u64 BSO;
 	GF_ISOSample *samp;
 	GF_Crypt *mc;
-	char IV[16];
+	char IV[17];
 	Bool prev_sample_encrypted;
 	GF_BitStream *pleintext_bs, *cyphertext_bs;
 	GF_CENCSampleAuxInfo *sai;
@@ -1587,6 +1276,8 @@ GF_Err gf_cbc_decrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*prog
 	mc = NULL;
 	buffer = NULL;
 	max_size = 4096;
+	nb_samp_decrypted = 0;
+	sai = NULL;
 
 	track = gf_isom_get_track_by_id(mp4, tci->trackID);
 	if (!track) {
@@ -1594,30 +1285,44 @@ GF_Err gf_cbc_decrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*prog
 		return GF_OK;
 	}
 
-	mc = gf_crypt_open("AES-128", "CBC");
+
+	if (tci->enc_type == 2)
+		mc = gf_crypt_open("AES-128", "CTR");
+	else if (tci->enc_type == 3)
+		mc = gf_crypt_open("AES-128", "CBC");
 	if (!mc) {
-		GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot open AES-128 CBC\n"));
+		GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot open AES-128 %s\n", (tci->enc_type == 2) ? "CTR" : "CBC"));
 		e = GF_IO_ERR;
 		goto exit;
 	}
 
-	/*select key*/
-	if (tci->defaultKeyIdx && (tci->defaultKeyIdx < tci->KID_count)) {
-		memcpy(tci->key, tci->keys[tci->defaultKeyIdx], 16);
-		memcpy(tci->default_KID, tci->KIDs[tci->defaultKeyIdx], 16);
-	} else {
-		memcpy(tci->key, tci->keys[0], 16);
-		memcpy(tci->default_KID, tci->KIDs[0], 16);
-	}
-
 	/* decrypt each sample */
 	count = gf_isom_get_sample_count(mp4, track);
 	buffer = (char*)gf_malloc(sizeof(char) * max_size);
 	prev_sample_encrypted = GF_FALSE;
 	gf_isom_set_nalu_extract_mode(mp4, track, GF_ISOM_NALU_EXTRACT_INSPECT);
 	for (i = 0; i < count; i++) {
-		memset(IV, 0, 16);
+		u32 Is_Encrypted;
+		u8 IV_size;
+		bin128 KID;
+
+		gf_isom_get_sample_cenc_info(mp4, track, i+1, &Is_Encrypted, &IV_size, &KID);
+		if (!Is_Encrypted)
+			continue;
+
+		/*select key*/
+		for (j = 0; j < tci->KID_count; j++) {
+			if (!strncmp((const char *)tci->KIDs[j], (const char *)KID, 16)) {
+				memcpy(tci->key, tci->keys[j], 16);
+				break;
+			}
+		}
+		if (j == tci->KID_count)
+			memcpy(tci->key, tci->keys[tci->defaultKeyIdx], 16);
+
+		memset(IV, 0, 17);
 		memset(buffer, 0, max_size);
+		BSO = 0;
 
 		samp = gf_isom_get_sample(mp4, track, i+1, &si);
 		if (!samp)
@@ -1626,17 +1331,11 @@ GF_Err gf_cbc_decrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*prog
 			goto exit;
 		}
 
-		sai = gf_isom_cenc_get_sample_aux_info(mp4, track, i+1, NULL);
-		if (!sai) {
-			e = GF_IO_ERR;
+		e = gf_isom_cenc_get_sample_aux_info(mp4, track, i+1, &sai, NULL);
+		if (e) {
 			goto exit;
 		}
 
-		if (!strlen((char *)sai->IV)) {
-			gf_isom_sample_del(&samp);
-			continue;
-		}
-
 		cyphertext_bs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);
 		pleintext_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
 
@@ -1644,7 +1343,7 @@ GF_Err gf_cbc_decrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*prog
 			memmove(IV, sai->IV, 16);
 			e = gf_crypt_init(mc, tci->key, 16, IV);
 			if (e) {
-				GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot initialize AES-128 CBC (%s)\n", gf_error_to_string(e)) );
+				GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot initialize AES-128 CTR (%s)\n", gf_error_to_string(e)) );
 				gf_crypt_close(mc);
 				mc = NULL;
 				e = GF_IO_ERR;
@@ -1652,6 +1351,24 @@ GF_Err gf_cbc_decrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*prog
 			}
 			prev_sample_encrypted = GF_TRUE;
 		}
+		else {
+			if (tci->enc_type == 2) {
+				GF_BitStream *bs;
+				bs = gf_bs_new(IV, 17, GF_BITSTREAM_WRITE);
+				gf_bs_write_u8(bs, 0);	/*begin of counter*/
+				gf_bs_write_data(bs, (char *)sai->IV, 16);
+				gf_bs_del(bs);
+				gf_crypt_set_state(mc, IV, 17);
+			}
+			e = gf_crypt_set_key(mc, tci->key, 16, IV);
+			if (e) {
+				GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC] Cannot set key AES-128 %s (%s)\n", (tci->enc_type == 2) ? "CTR" : "CBC", gf_error_to_string(e)) );
+				gf_crypt_close(mc);
+				mc = NULL;
+				e = GF_IO_ERR;
+				goto exit;
+			}
+		}
 
 		subsample_count = 0;
 		while (gf_bs_available(cyphertext_bs)) {
@@ -1666,18 +1383,26 @@ GF_Err gf_cbc_decrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*prog
 			gf_bs_write_data(pleintext_bs, buffer, sai->subsamples[subsample_count].bytes_clear_data);
 
 			/*now read encrypted data, decrypted it and write to pleintext bitstream*/
-			if (sai->subsamples[subsample_count].bytes_encrypted_data) {
-				if (max_size < sai->subsamples[subsample_count].bytes_encrypted_data) {
-					buffer = (char*)gf_realloc(buffer, sizeof(char)*sai->subsamples[subsample_count].bytes_encrypted_data);
-					max_size = sai->subsamples[subsample_count].bytes_encrypted_data;
-				}
-				gf_bs_read_data(cyphertext_bs, buffer, sai->subsamples[subsample_count].bytes_encrypted_data);
-				gf_crypt_decrypt(mc, buffer, sai->subsamples[subsample_count].bytes_encrypted_data);
-				gf_bs_write_data(pleintext_bs, buffer, sai->subsamples[subsample_count].bytes_encrypted_data);
+			if (max_size < sai->subsamples[subsample_count].bytes_encrypted_data) {
+				buffer = (char*)gf_realloc(buffer, sizeof(char)*sai->subsamples[subsample_count].bytes_encrypted_data);
+				max_size = sai->subsamples[subsample_count].bytes_encrypted_data;
+			}
+			gf_bs_read_data(cyphertext_bs, buffer, sai->subsamples[subsample_count].bytes_encrypted_data);
+			gf_crypt_decrypt(mc, buffer, sai->subsamples[subsample_count].bytes_encrypted_data);
+			gf_bs_write_data(pleintext_bs, buffer, sai->subsamples[subsample_count].bytes_encrypted_data);
+
+			/*update IV for next subsample*/
+			if (tci->enc_type == 2) {
+				BSO += sai->subsamples[subsample_count].bytes_encrypted_data;
+				if (gf_bs_available(cyphertext_bs))
+					cenc_resync_IV(mc, (char *)sai->IV, BSO, tci->IV_size, GF_FALSE);
 			}
 
 			subsample_count++;
 		}
+
+		gf_isom_cenc_samp_aux_info_del(sai);
+		sai = NULL;
 		
 		gf_bs_del(cyphertext_bs);
 		cyphertext_bs = NULL;
@@ -1692,8 +1417,9 @@ GF_Err gf_cbc_decrypt_track(GF_ISOFile *mp4, GF_TrackCryptInfo *tci, void (*prog
 		gf_isom_update_sample(mp4, track, i+1, samp, 1);
 		gf_isom_sample_del(&samp);
 		samp = NULL;
+		nb_samp_decrypted++;
 
-		gf_set_progress("CENC-CBC Decrypt", i+1, count);
+		gf_set_progress("CENC Decrypt", i+1, count);
 	}
 
 	/*remove protection info*/
@@ -1712,6 +1438,7 @@ exit:
 	if (cyphertext_bs) gf_bs_del(cyphertext_bs);
 	if (samp) gf_isom_sample_del(&samp);
 	if (buffer) gf_free(buffer);
+	if (sai) gf_isom_cenc_samp_aux_info_del(sai);
 	return e;
 }
 
@@ -1738,21 +1465,6 @@ GF_Err gf_decrypt_file(GF_ISOFile *mp4, const char *drm_file)
 		count = gf_list_count(info->tcis);
 	}
 
-	switch (info->crypt_type) {
-		case 1:
-			gf_decrypt_track = gf_ismacryp_decrypt_track;
-			break;
-		case 2:
-			gf_decrypt_track = gf_cenc_decrypt_track;
-			break;
-		case 3:
-			gf_decrypt_track = gf_cbc_decrypt_track;
-			break;
-		default:
-			GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC/ISMA] Encryption type not supported\n"));
-			return GF_NOT_SUPPORTED;;
-	}
-
 	common_idx=0;
 	if (info && info->has_common_key) {
 		for (common_idx=0; common_idx<count; common_idx++) {
@@ -1785,6 +1497,23 @@ GF_Err gf_decrypt_file(GF_ISOFile *mp4, const char *drm_file)
 			tci.trackID = trackID;
 		}
 
+		switch (info->crypt_type) {
+			case 1:
+				gf_decrypt_track = gf_ismacryp_decrypt_track;
+				break;
+			case 2:
+				tci.enc_type = 2;
+				gf_decrypt_track = gf_cenc_decrypt_track;
+				break;
+			case 3:
+				tci.enc_type = 3;
+				gf_decrypt_track = gf_cenc_decrypt_track;
+				break;
+			default:
+				GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC/ISMA] Encryption type not supported\n"));
+				return GF_NOT_SUPPORTED;;
+		}
+
 		if (gf_isom_is_ismacryp_media(mp4, i+1, 1)) {
 			e = gf_isom_get_ismacryp_info(mp4, i+1, 1, NULL, &scheme_type, NULL, &scheme_URI, &KMS_URI, NULL, NULL, NULL);
 		} else if (gf_isom_is_omadrm_media(mp4, i+1, 1)) {
@@ -1981,21 +1710,6 @@ GF_Err gf_crypt_file(GF_ISOFile *mp4, const char *drm_file)
 		if (e) return e;
 	}
 
-	switch (info->crypt_type) {
-		case 1:
-			gf_encrypt_track = gf_ismacryp_encrypt_track;
-			break;
-		case 2:
-			gf_encrypt_track = gf_cenc_encrypt_track;
-			break;
-		case 3:
-			gf_encrypt_track = gf_cbc_encrypt_track;
-			break;
-		default:
-			GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC/ISMA] Encryption type not sopported\n"));
-			return GF_NOT_SUPPORTED;;
-	}
-
 	e = GF_OK;
 	count = gf_list_count(info->tcis);
 
@@ -2019,6 +1733,23 @@ GF_Err gf_crypt_file(GF_ISOFile *mp4, const char *drm_file)
 		}
 		tci = (GF_TrackCryptInfo *)gf_list_get(info->tcis, idx);
 
+		switch (info->crypt_type) {
+		case 1:
+			gf_encrypt_track = gf_ismacryp_encrypt_track;
+			break;
+		case 2:
+			tci->enc_type = 2;
+			gf_encrypt_track = gf_cenc_encrypt_track;
+			break;
+		case 3:
+			tci->enc_type = 3;
+			gf_encrypt_track = gf_cenc_encrypt_track;
+			break;
+		default:
+			GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, ("[CENC/ISMA] Encryption type not sopported\n"));
+			return GF_NOT_SUPPORTED;;
+	}
+
 		/*default to FILE uri*/
 		if (!strlen(tci->KMS_URI)) strcpy(tci->KMS_URI, drm_file);
 
diff --git a/src/media_tools/isom_tools.c b/src/media_tools/isom_tools.c
index d876aaf5f..6c73f7d75 100644
--- a/src/media_tools/isom_tools.c
+++ b/src/media_tools/isom_tools.c
@@ -2446,7 +2446,7 @@ GF_Err gf_media_fragment_file(GF_ISOFile *input, const char *output_file, Double
 
 		/*copy PSSHs from moov to the first moof*/
 		if (!nb_done) {
-			e = gf_isom_clone_pssh(output, input, GF_FALSE);
+			e = gf_isom_clone_pssh(output, input, GF_TRUE);
 			if (e) goto err_exit;
 		}
 
@@ -2476,6 +2476,11 @@ GF_Err gf_media_fragment_file(GF_ISOFile *input, const char *output_file, Double
 				e = gf_isom_fragment_add_sai(output, input, tf->TrackID, tf->SampleNum + 1);
 				if (e) goto err_exit;
 
+				/*copy subsample information*/
+				e = gf_isom_fragment_copy_subsample(output, tf->TrackID, input, tf->OriginalTrack, tf->SampleNum + 1);
+				if (e) 
+					goto err_exit;
+
 				gf_set_progress("ISO File Fragmenting", nb_done, nb_samp);
 				nb_done++;
 
diff --git a/src/media_tools/media_import.c b/src/media_tools/media_import.c
index 11fb231de..c7e96df70 100644
--- a/src/media_tools/media_import.c
+++ b/src/media_tools/media_import.c
@@ -1899,6 +1899,7 @@ GF_Err gf_import_isomedia(GF_MediaImporter *import)
 	GF_ISOSample *samp;
 	GF_ESD *origin_esd;
 	GF_InitialObjectDescriptor *iod;
+	Bool is_cenc;
 	sampDTS = 0;
 	if (import->flags & GF_IMPORT_PROBE_ONLY) {
 		for (i=0; i<gf_isom_get_track_count(import->orig); i++) {
@@ -2046,6 +2047,17 @@ GF_Err gf_import_isomedia(GF_MediaImporter *import)
 	duration = (u64) (((Double)import->duration * gf_isom_get_media_timescale(import->orig, track_in)) / 1000);
 	gf_isom_set_nalu_extract_mode(import->orig, track_in, GF_ISOM_NALU_EXTRACT_INSPECT);
 	num_samples = gf_isom_get_sample_count(import->orig, track_in);
+	is_cenc = gf_isom_is_cenc_media(import->orig, track_in, 1);
+	if (is_cenc) {
+		u32 container_type;
+		e = gf_isom_cenc_get_sample_aux_info(import->orig, track_in, 0, NULL, &container_type);
+		if (e)
+			goto exit;
+		e = gf_isom_cenc_allocate_storage(import->dest, track, container_type, 0, 0, NULL);
+		if (e) goto exit;
+		e = gf_isom_clone_pssh(import->dest, import->orig, GF_FALSE);
+		if (e) goto exit;
+	}
 	for (i=0; i<num_samples; i++) {
 		if (import->flags & GF_IMPORT_USE_DATAREF) {
 			samp = gf_isom_get_sample_info(import->orig, track_in, i+1, &di, &offset);
@@ -2078,6 +2090,37 @@ GF_Err gf_import_isomedia(GF_MediaImporter *import)
 		if (import->flags & GF_IMPORT_DO_ABORT) break;
 		if (e)
 			goto exit;
+		if (is_cenc) {
+			GF_CENCSampleAuxInfo *sai;
+			u32 container_type, len, j, Is_Encrypted;
+			u8 IV_size;
+			bin128 KID;
+			GF_BitStream *bs;
+			char *buffer;
+
+			sai = NULL;
+			e = gf_isom_cenc_get_sample_aux_info(import->orig, track_in, i+1, &sai, &container_type);
+			if (e)
+				goto exit;
+			bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
+			gf_bs_write_data(bs, (const char *)sai->IV, 16);
+			gf_bs_write_u16(bs, sai->subsample_count);
+			for (j = 0; j < sai->subsample_count; j++) {
+				gf_bs_write_u16(bs, sai->subsamples[j].bytes_clear_data);
+				gf_bs_write_u32(bs, sai->subsamples[j].bytes_encrypted_data);
+			}
+			gf_isom_cenc_samp_aux_info_del(sai);
+			gf_bs_get_content(bs, &buffer, &len);
+			gf_bs_del(bs);
+			e = gf_isom_track_cenc_add_sample_info(import->dest, track, container_type, buffer, len);
+			gf_free(buffer);
+			if (e) goto exit;
+
+			e = gf_isom_get_sample_cenc_info(import->orig, track_in, i+1, &Is_Encrypted, &IV_size, &KID);
+			if (e) goto exit;
+			e = gf_isom_set_sample_cenc_group(import->dest, track, i+1, Is_Encrypted, IV_size, KID);
+			if (e) goto exit;
+		}
 	}
 
 	if (gf_isom_has_time_offset(import->orig, track_in)==2) {
diff --git a/src/terminal/channel.c b/src/terminal/channel.c
index 6fd4b62f8..4eb360e6d 100644
--- a/src/terminal/channel.c
+++ b/src/terminal/channel.c
@@ -1257,7 +1257,12 @@ void gf_es_receive_sl_packet(GF_ClientService *serv, GF_Channel *ch, char *paylo
 		evt.data = payload;
 		evt.data_size = payload_size;
 		evt.is_encrypted = (hdr.isma_encrypted || hdr.cenc_encrypted) ? 1 : 0;
-		evt.isma_BSO = hdr.isma_BSO;
+		if (hdr.isma_encrypted) {
+			evt.isma_BSO = hdr.isma_BSO;
+		} else if (hdr.cenc_encrypted) {
+			evt.sai = hdr.sai;
+			evt.saiz = hdr.saiz;
+		}
 		e = ch->ipmp_tool->process(ch->ipmp_tool, &evt);
 
 		/*we discard undecrypted AU*/
diff --git a/src/terminal/media_manager.c b/src/terminal/media_manager.c
index 59e95fa46..2cf054a18 100644
--- a/src/terminal/media_manager.c
+++ b/src/terminal/media_manager.c
@@ -321,7 +321,7 @@ static u32 MM_SimulationStep_Decoder(GF_Terminal *term)
 		if (e) {
 			GF_LOG(GF_LOG_WARNING, GF_LOG_CODEC, ("[ODM%d] Decoding Error %s\n", ce->dec->odm->OD->objectDescriptorID, gf_error_to_string(e) ));
 		} else {
-			GF_LOG(GF_LOG_DEBUG, GF_LOG_CODEC, ("[%s] Decode time slice %d ms out of %d ms\n", ce->dec->decio ? ce->dec->decio->module_name : "RAW", time_taken, time_left ));
+			//GF_LOG(GF_LOG_DEBUG, GF_LOG_CODEC, ("[%s] Decode time slice %d ms out of %d ms\n", ce->dec->decio ? ce->dec->decio->module_name : "RAW", time_taken, time_left ));
 		}
 #endif
 		if (ce->flags & GF_MM_CE_DISCARDED) {

