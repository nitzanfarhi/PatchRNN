commit 30f4e4582806dd8084ab7da8f0cf9b3fde955de5
Author: alor <alor>
Date:   Sun Jan 4 16:29:28 2004 +0000

    GW and DNS profiles retrived parsing DHCP packets

diff --git a/include/ec_hook.h b/include/ec_hook.h
index 739bc37d..d8923832 100644
--- a/include/ec_hook.h
+++ b/include/ec_hook.h
@@ -1,5 +1,5 @@
 
-/* $Id: ec_hook.h,v 1.15 2003/12/03 14:47:54 lordnaga Exp $ */
+/* $Id: ec_hook.h,v 1.16 2004/01/04 16:29:26 alor Exp $ */
 
 #ifndef EC_HOOK_H
 #define EC_HOOK_H
@@ -40,7 +40,8 @@ void hook_point(int point, struct packet_object *po);
    #define HOOK_PROTO_SMB_CHL       (HOOK_PROTO_BASE + 2)
    #define HOOK_PROTO_DHCP_REQUEST  (HOOK_PROTO_BASE + 3)
    #define HOOK_PROTO_DHCP_DISCOVER (HOOK_PROTO_BASE + 4)
-   #define HOOK_PROTO_DNS           (HOOK_PROTO_BASE + 5)
+   #define HOOK_PROTO_DHCP_PROFILE  (HOOK_PROTO_BASE + 5)
+   #define HOOK_PROTO_DNS           (HOOK_PROTO_BASE + 6)
 
 void hook_add(int point, void (*func)(struct packet_object *po) );
 int hook_del(int point, void (*func)(struct packet_object *po) );
diff --git a/include/ec_inet.h b/include/ec_inet.h
index 22f10f7c..b5cdf98b 100644
--- a/include/ec_inet.h
+++ b/include/ec_inet.h
@@ -1,5 +1,5 @@
 
-/* $Id: ec_inet.h,v 1.16 2003/12/01 16:33:32 lordnaga Exp $ */
+/* $Id: ec_inet.h,v 1.17 2004/01/04 16:29:26 alor Exp $ */
 
 #ifndef EC_INET_H
 #define EC_INET_H
@@ -39,6 +39,7 @@ struct ip_addr {
 extern int ip_addr_init(struct ip_addr *sa, int type, char *addr);
 extern int ip_addr_cmp(struct ip_addr *sa, struct ip_addr *sb);
 extern int ip_addr_null(struct ip_addr *sa);
+extern int ip_addr_is_zero(struct ip_addr *sa);
 
 extern char *ip_addr_ntoa(struct ip_addr *sa, char *dst);
 extern char *mac_addr_ntoa(u_char *mac, char *dst);
@@ -47,7 +48,7 @@ extern int mac_addr_aton(char *str, u_char *mac);
 extern int ip_addr_is_local(struct ip_addr *sa);
 
 /*
- * this prototype is implemented in ./os/.../
+ * this prototypes are implemented in ./os/.../
  * each OS implement its specific function
  */
 
diff --git a/src/dissectors/ec_dhcp.c b/src/dissectors/ec_dhcp.c
index 1c975624..e7cc81e4 100644
--- a/src/dissectors/ec_dhcp.c
+++ b/src/dissectors/ec_dhcp.c
@@ -17,7 +17,7 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: ec_dhcp.c,v 1.7 2003/11/18 15:30:13 alor Exp $
+    $Id: ec_dhcp.c,v 1.8 2004/01/04 16:29:28 alor Exp $
 */
 
 /*
@@ -85,6 +85,7 @@ FUNC_DECODER(dissector_dhcp);
 void dhcp_init(void);
 u_int8 * get_dhcp_option(u_int8 opt, u_int8 *ptr, u_int8 *end);
 void put_dhcp_option(u_int8 opt, u_int8 *value, u_int8 len, u_int8 **ptr);
+static void dhcp_add_profile(struct ip_addr *sa, size_t flag);
 
 /************************************************/
 
@@ -216,8 +217,10 @@ FUNC_DECODER(dissector_dhcp)
             DISSECT_MSG("%s ", ip_addr_ntoa(&client, tmp)); 
             DISSECT_MSG("%s ", ip_addr_ntoa(&netmask, tmp)); 
             DISSECT_MSG("GW %s ", ip_addr_ntoa(&router, tmp)); 
-            DISSECT_MSG("DNS %s ", ip_addr_ntoa(&dns, tmp)); 
-            
+            if (!ip_addr_is_zero(&dns)) {
+               DISSECT_MSG("DNS %s ", ip_addr_ntoa(&dns, tmp)); 
+            }
+
             /* dns domain */
             if ((opt = get_dhcp_option(DHCP_OPT_DOMAIN, options, end)) != NULL) {
                   strncpy(domain, opt + 1, MIN(*opt, sizeof(domain)) );
@@ -226,6 +229,10 @@ FUNC_DECODER(dissector_dhcp)
             } else
                DISSECT_MSG("\n");
             
+            /* add the GW and the DNS to hosts' profiles */
+            dhcp_add_profile(&router, FP_GATEWAY | FP_HOST_LOCAL);
+            dhcp_add_profile(&dns, FP_UNKNOWN);
+            
             break;
       }
    }
@@ -279,6 +286,34 @@ void put_dhcp_option(u_int8 opt, u_int8 *value, u_int8 len, u_int8 **ptr)
    *ptr = p;
 }
 
+
+/*
+ * create a fake packet object to feed the profile_parse function
+ */
+static void dhcp_add_profile(struct ip_addr *sa, size_t flag)
+{
+   struct packet_object po;
+
+   DEBUG_MSG("dhcp_add_profile");
+   
+   /* wipe the object */
+   memset(&po, 0, sizeof(struct packet_object));
+   
+   memcpy(&po.L3.src, sa, sizeof(struct ip_addr));
+
+   /* this is a ludicrious(tm) lie !
+    * in order to add the host to the profiles we pretend
+    * to have seen an icmp from it 
+    */
+   po.L4.proto = NL_TYPE_ICMP;
+   po.PASSIVE.flags = flag;
+
+   /* HOOK POINT: HOOK_PROTO_DHCP_PROFILE */
+   /* used by profile_parse and log_packet */
+   hook_point(HOOK_PROTO_DHCP_PROFILE, &po);
+}
+
+
 /* EOF */
 
 // vim:ts=3:expandtab
diff --git a/src/ec_dispatcher.c b/src/ec_dispatcher.c
index 84cff1f3..c30743ad 100644
--- a/src/ec_dispatcher.c
+++ b/src/ec_dispatcher.c
@@ -17,7 +17,7 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: ec_dispatcher.c,v 1.32 2003/12/17 15:56:36 alor Exp $
+    $Id: ec_dispatcher.c,v 1.33 2004/01/04 16:29:28 alor Exp $
 */
 
 #include <ec.h>
@@ -74,6 +74,7 @@ EC_THREAD_FUNC(top_half)
       DEBUG_MSG("top_half: profile collection disabled");
       hook_del(HOOK_PACKET_ARP, &profile_parse);
       hook_del(HOOK_PACKET_ICMP, &profile_parse);
+      hook_del(HOOK_PROTO_DHCP_PROFILE, &profile_parse);
       hook_del(HOOK_DISPATCHER, &profile_parse);
    }
    
diff --git a/src/ec_inet.c b/src/ec_inet.c
index 084a6434..c8e543fc 100644
--- a/src/ec_inet.c
+++ b/src/ec_inet.c
@@ -17,7 +17,7 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: ec_inet.c,v 1.18 2003/12/01 16:33:40 lordnaga Exp $
+    $Id: ec_inet.c,v 1.19 2004/01/04 16:29:28 alor Exp $
 */
 
 #include <ec.h>
@@ -32,6 +32,7 @@
 int ip_addr_init(struct ip_addr *sa, int type, char *addr);
 int ip_addr_cmp(struct ip_addr *sa, struct ip_addr *sb);
 int ip_addr_null(struct ip_addr *sa);
+int ip_addr_is_zero(struct ip_addr *sa);
 
 char *ip_addr_ntoa(struct ip_addr *sa, char *dst);
 char *mac_addr_ntoa(u_char *mac, char *dst);
@@ -65,6 +66,9 @@ int ip_addr_init(struct ip_addr *sa, int type, char *addr)
 };
 
 
+/*
+ * returns 0 if the ip address is IPv4 or IPv6
+ */
 int ip_addr_null(struct ip_addr *sa)
 {
    if (sa->type == AF_INET || sa->type == AF_INET6) 
@@ -77,7 +81,6 @@ int ip_addr_null(struct ip_addr *sa)
 /* 
  * compare two ip_addr structure.
  */
-
 int ip_addr_cmp(struct ip_addr *sa, struct ip_addr *sb)
 {
    /* different type are incompatible */
@@ -88,6 +91,28 @@ int ip_addr_cmp(struct ip_addr *sa, struct ip_addr *sb)
    
 }
 
+
+/*
+ * return true if an ip address is 0.0.0.0 or invalid
+ */
+int ip_addr_is_zero(struct ip_addr *sa)
+{
+   switch (sa->type) {
+      case AF_INET:
+         if (memcmp(sa->addr, "\x00\x00\x00\x00", IP_ADDR_LEN))
+            return 0;
+         break;
+      case AF_INET6:
+         if (memcmp(sa->addr, "\x00\x00\x00\x00\x00\x00\x00\x00"
+                               "\x00\x00\x00\x00\x00\x00\x00\x00", IP6_ADDR_LEN))
+            return 0;
+         break;
+   };
+  
+   return 1;
+}
+
+
 /*
  * print an ip_add structure
  */
diff --git a/src/ec_log.c b/src/ec_log.c
index 5e7af1da..b1e8fd92 100644
--- a/src/ec_log.c
+++ b/src/ec_log.c
@@ -17,7 +17,7 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: ec_log.c,v 1.28 2003/11/10 22:46:24 alor Exp $
+    $Id: ec_log.c,v 1.29 2004/01/04 16:29:28 alor Exp $
 */
 
 #include <ec.h>
@@ -140,6 +140,10 @@ int set_loglevel(int level, char *filename)
          
          /* add the hook for ICMP packets */
          hook_add(HOOK_PACKET_ICMP, &log_write_info_arp_icmp);
+         
+         /* add the hook for DHCP packets */
+         /* (fake icmp packets from DHCP discovered GW and DNS) */
+         hook_add(HOOK_PROTO_DHCP_PROFILE, &log_write_info_arp_icmp);
 
          break;
    }
diff --git a/src/ec_profiles.c b/src/ec_profiles.c
index 0d8b1eb6..6dbd0ad7 100644
--- a/src/ec_profiles.c
+++ b/src/ec_profiles.c
@@ -17,7 +17,7 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: ec_profiles.c,v 1.28 2003/11/28 22:02:40 alor Exp $
+    $Id: ec_profiles.c,v 1.29 2004/01/04 16:29:28 alor Exp $
 */
 
 #include <ec.h>
@@ -66,6 +66,9 @@ void __init profiles_init(void)
    
    /* add the hook for ICMP packets */
    hook_add(HOOK_PACKET_ICMP, &profile_parse);
+   
+   /* add the hook for DHCP packets */
+   hook_add(HOOK_PROTO_DHCP_PROFILE, &profile_parse);
          
    /* receive all the top half packets */
    hook_add(HOOK_DISPATCHER, &profile_parse);
@@ -100,6 +103,9 @@ void profile_parse(struct packet_object *po)
    /*
     * call the add function only if the packet
     * is interesting...
+    *    - ARP packets
+    *    - ICMP packets
+    *    - DNS packets that contain GW information (they use fake icmp po)
     */
    if ( po->L3.proto == htons(LL_TYPE_ARP) ||                     /* arp packets */
         po->L4.proto == NL_TYPE_ICMP                              /* icmp packets */
@@ -141,7 +147,16 @@ static int profile_add_host(struct packet_object *po)
    struct host_profile *h;
    struct host_profile *c;
    struct host_profile *last = NULL;
-
+   
+   /* 
+    * do not store profiles for hosts with ip == 0.0.0.0
+    * they are hosts requesting for a dhcp/bootp reply.
+    * they will get an ip address soon and we are interested
+    * only in the latter.
+    */
+   if (ip_addr_is_zero(&po->L3.src))
+      return 0;
+   
    /* 
     * if the type is FP_HOST_NONLOCAL 
     * search for the GW and mark it
@@ -154,12 +169,16 @@ static int profile_add_host(struct packet_object *po)
 
    PROFILE_LOCK;
 
-   /* parse the list */
+   /* search if it already exists */
    LIST_FOREACH(h, &GBL_PROFILES, next) {
-      /* search the host.
-       * it is identified by the mac and the ip address */
-      if (!memcmp(h->L2_addr, po->L2.src, MEDIA_ADDR_LEN) &&
+      /* an host is identified by the mac and the ip address */
+      /* if the mac address is null also update it since it could
+       * be captured as a DNS packet specifying the GW 
+       */
+      if ((!memcmp(h->L2_addr, po->L2.src, MEDIA_ADDR_LEN) ||
+           !memcmp(po->L2.src, "\x00\x00\x00\x00\x00\x00", MEDIA_ADDR_LEN) ) &&
           !ip_addr_cmp(&h->L3_addr, &po->L3.src) ) {
+
          update_info(h, po);
          /* the host was already in the list
           * return 0 host added */

