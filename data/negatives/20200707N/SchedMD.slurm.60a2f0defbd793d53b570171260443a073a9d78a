commit 60a2f0defbd793d53b570171260443a073a9d78a
Author: Danny Auble <da@schedmd.com>
Date:   Fri May 25 12:04:00 2018 -0600

    Make job_array_port_sched return the new job_ptr it potentially makes.
    
    This will be needed in a future commit.

diff --git a/src/slurmctld/job_mgr.c b/src/slurmctld/job_mgr.c
index 1e62f5a6f9..a109451507 100644
--- a/src/slurmctld/job_mgr.c
+++ b/src/slurmctld/job_mgr.c
@@ -17939,13 +17939,13 @@ extern void job_array_pre_sched(struct job_record *job_ptr)
 }
 
 /* If this is a job array meta-job, clean up after scheduling attempt */
-extern void job_array_post_sched(struct job_record *job_ptr)
+extern struct job_record *job_array_post_sched(struct job_record *job_ptr)
 {
-	struct job_record *new_job_ptr;
+	struct job_record *new_job_ptr = NULL;
 	char jobid_buf[32];
 
 	if (!job_ptr->array_recs || !job_ptr->array_recs->task_id_bitmap)
-		return;
+		return job_ptr;
 
 	if (job_ptr->array_recs->task_cnt <= 1) {
 		/* Preserve array_recs for min/max exit codes for job array */
@@ -17977,6 +17977,7 @@ extern void job_array_post_sched(struct job_record *job_ptr)
 					job_ptr->array_task_id)) {
 			_add_job_array_hash(job_ptr);
 		}
+		new_job_ptr = job_ptr;
 	} else {
 		new_job_ptr = job_array_split(job_ptr);
 		if (new_job_ptr) {
@@ -17989,6 +17990,8 @@ extern void job_array_post_sched(struct job_record *job_ptr)
 			      jobid2fmt(job_ptr, jobid_buf, sizeof(jobid_buf)));
 		}
 	}
+
+	return new_job_ptr;
 }
 
 /* _kill_dependent()
diff --git a/src/slurmctld/job_scheduler.c b/src/slurmctld/job_scheduler.c
index 7e69a78295..084490489d 100644
--- a/src/slurmctld/job_scheduler.c
+++ b/src/slurmctld/job_scheduler.c
@@ -421,7 +421,7 @@ extern List build_job_queue(bool clear_start, bool backfill)
 			continue;
 		if (job_ptr->array_recs->task_cnt == 1) {
 			job_ptr->array_task_id = i;
-			job_array_post_sched(job_ptr);
+			(void) job_array_post_sched(job_ptr);
 			continue;
 		}
 		job_ptr->array_task_id = i;
@@ -473,7 +473,7 @@ extern List build_job_queue(bool clear_start, bool backfill)
 			continue;
 		if (job_ptr->array_recs->task_cnt == 1) {
 			job_ptr->array_task_id = i;
-			job_array_post_sched(job_ptr);
+			(void) job_array_post_sched(job_ptr);
 			continue;
 		}
 		job_ptr->array_task_id = i;
diff --git a/src/slurmctld/node_scheduler.c b/src/slurmctld/node_scheduler.c
index 347d3cf659..2bf2c8f0ab 100644
--- a/src/slurmctld/node_scheduler.c
+++ b/src/slurmctld/node_scheduler.c
@@ -2343,7 +2343,7 @@ static void _end_null_job(struct job_record *job_ptr)
 	if (!job_ptr->step_list)
 		job_ptr->step_list = list_create(NULL);
 
-	job_array_post_sched(job_ptr);
+	(void) job_array_post_sched(job_ptr);
 	(void) bb_g_job_begin(job_ptr);
 	job_array_start(job_ptr);
 	rebuild_job_part_list(job_ptr);
@@ -2771,7 +2771,7 @@ extern int select_nodes(struct job_record *job_ptr, bool test_only,
 
 	job_end_time_reset(job_ptr);
 
-	job_array_post_sched(job_ptr);
+	(void) job_array_post_sched(job_ptr);
 	if (bb_g_job_begin(job_ptr) != SLURM_SUCCESS) {
 		/* Leave job queued, something is hosed */
 		error_code = ESLURM_INVALID_BURST_BUFFER_REQUEST;
diff --git a/src/slurmctld/slurmctld.h b/src/slurmctld/slurmctld.h
index 0e83f51f3e..39ed8e3872 100644
--- a/src/slurmctld/slurmctld.h
+++ b/src/slurmctld/slurmctld.h
@@ -1338,7 +1338,7 @@ extern int job_allocate(job_desc_msg_t * job_specs, int immediate,
 extern void job_array_pre_sched(struct job_record *job_ptr);
 
 /* If this is a job array meta-job, clean up after scheduling attempt */
-extern void job_array_post_sched(struct job_record *job_ptr);
+extern struct job_record *job_array_post_sched(struct job_record *job_ptr);
 
 /* Create an exact copy of an existing job record for a job array.
  * IN job_ptr - META job record for a job array, which is to become an

