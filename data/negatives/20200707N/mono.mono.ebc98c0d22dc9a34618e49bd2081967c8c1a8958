commit ebc98c0d22dc9a34618e49bd2081967c8c1a8958
Author: Aleksey Kliger (Î»geek) <akliger@gmail.com>
Date:   Fri Jun 29 10:19:39 2018 -0400

    [coop] mono_coop_cond_signal should switch to GC Safe thread state (#9347)
    
    * [debug] mono_pmip shouldn't assume it's called from an attached thread
    
    `mono_pmip` calls `get_method_from_ip` which needs to make a string with the
    name of a method. It used to call `mono_method_full_name` which is a `MONO_API`
    function and so tries to switch to GC Unsafe mode (which requires the thread to
    be attached).
    
    However `mono_pmip` is often used from GDB/LLDB and it might be invoked by the
    developer from a stopped thread that isn't currently attached which would assert.
    
    Instead call `mono_method_get_name_full` in `get_method_from_ip` which doesn't
    switch the thread state.
    
    * [coop] mono_coop_cond_signal and mono_coop_cond_broadcast should switch to GC Safe
    
    Under Linux/glibc `pthread_cond_signal` and `pthread_cond_broadcast` can block
    on a futex in `__cond_quiesce_and_switch_g1`, so switch the thread to GC Safe
    mode around the blocking operation.
    
    * [coop] ves_icall_System_Threading_WaitHandle_SignalAndWait_Internal shouldn't swith to GC Safe
    
    On Win32, still do the thread state change here; on other platforms
    its handled in the implementation of mono_w32handle_signal_and_wait

diff --git a/mono/metadata/threads.c b/mono/metadata/threads.c
index b5088292812..a648b63a4f8 100644
--- a/mono/metadata/threads.c
+++ b/mono/metadata/threads.c
@@ -2144,13 +2144,13 @@ ves_icall_System_Threading_WaitHandle_SignalAndWait_Internal (gpointer toSignal,
 
 	mono_thread_set_state (thread, ThreadState_WaitSleepJoin);
 	
-	MONO_ENTER_GC_SAFE;
 #ifdef HOST_WIN32
+	MONO_ENTER_GC_SAFE;
 	ret = mono_w32handle_convert_wait_ret (mono_win32_signal_object_and_wait (toSignal, toWait, ms, TRUE), 1);
+	MONO_EXIT_GC_SAFE;
 #else
 	ret = mono_w32handle_signal_and_wait (toSignal, toWait, ms, TRUE);
 #endif
-	MONO_EXIT_GC_SAFE;
 	
 	mono_thread_clr_state (thread, ThreadState_WaitSleepJoin);
 
diff --git a/mono/mini/mini-runtime.c b/mono/mini/mini-runtime.c
index e37c2c27dbe..2f16279167c 100644
--- a/mono/mini/mini-runtime.c
+++ b/mono/mini/mini-runtime.c
@@ -206,7 +206,7 @@ get_method_from_ip (void *ip)
 	}
 
 	method = jinfo_get_method (ji);
-	method_name = mono_method_full_name (method, TRUE);
+	method_name = mono_method_get_name_full (method, TRUE, FALSE, MONO_TYPE_NAME_FORMAT_IL);
 	/* FIXME: unused ? */
 	location = mono_debug_lookup_source_location (method, (guint32)((guint8*)ip - (guint8*)ji->code_start), domain);
 
diff --git a/mono/utils/mono-coop-mutex.h b/mono/utils/mono-coop-mutex.h
index 5f309d7e65a..d10f91e5e0d 100644
--- a/mono/utils/mono-coop-mutex.h
+++ b/mono/utils/mono-coop-mutex.h
@@ -109,13 +109,27 @@ mono_coop_cond_timedwait (MonoCoopCond *cond, MonoCoopMutex *mutex, guint32 time
 static inline void
 mono_coop_cond_signal (MonoCoopCond *cond)
 {
+	/*
+	 * On glibc using NTPL (ie Linux with an underlying futex), signaling a
+	 * condition variable can block in the __condvar_quiesce_and_switch_g1
+	 * operation. So switch to GC Safe mode here.
+	 */
+	MONO_ENTER_GC_SAFE;
 	mono_os_cond_signal (&cond->c);
+	MONO_EXIT_GC_SAFE;
 }
 
 static inline void
 mono_coop_cond_broadcast (MonoCoopCond *cond)
 {
+	/*
+	 * On glibc using NTPL (ie Linux with an underlying futex), signaling a
+	 * condition variable can block in the __condvar_quiesce_and_switch_g1
+	 * operation. So switch to GC Safe mode here.
+	 */
+	MONO_ENTER_GC_SAFE;
 	mono_os_cond_broadcast (&cond->c);
+	MONO_EXIT_GC_SAFE;
 }
 
 G_END_DECLS

