commit 5a686b2c9ed44254d58d139f969c7c08685d923a
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Apr 27 08:50:07 2018 -0700

    spi: omap2-mcspi: Idle hardware during suspend and resume
    
    We currently are calling mcspi suspend and resume without considering
    that mcspi might provide resources for other device driver such as
    regulators. This means resume can fail and will produce -EACCES if
    errors if anything calls mcspi functions between device_prepare()
    and device_complete().
    
    To fix the issue, let's do the following changes:
    
    1. Let's add checking for return values for pm_runtime_get calls,
       and call pm_runtime_put_noidle() on errors. Things still fail
       after this change, but at least we see something is wrong as
       we now see -EACCES errors on resume.
    
    2. Let's use noirq level for suspend and resume as other drivers
       can still call SPI related functions on suspend and resume. This
       still won't fix the -EACCES issue, but gets us to something a bit
       saner.
    
    3. Finally, let's modify suspend and resume to call to make sure
       the device is idled properly on suspend. We have device_prepare()
       call pm_runtime_get_noresume() that won't get released until in
       device_complete() when it calls pm_runtime_put(). So if SPI is
       still active on entering suspend, it will never get idled unless
       we add calls to pm_runtime_force_suspend() and resume. This also
       fixes the -EACCES errors on resume together with changes 1 and 2
       above.
    
    And since we're already rewriting suspend resume functions, let's
    arrange the order of suspend and resume functions to be like they
    usually are with suspend first.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-omap2-mcspi.c b/drivers/spi/spi-omap2-mcspi.c
index e8af5a7ccc5c..0d69cb96442c 100644
--- a/drivers/spi/spi-omap2-mcspi.c
+++ b/drivers/spi/spi-omap2-mcspi.c
@@ -255,6 +255,7 @@ static void omap2_mcspi_set_cs(struct spi_device *spi, bool enable)
 	if (spi->controller_state) {
 		int err = pm_runtime_get_sync(mcspi->dev);
 		if (err < 0) {
+			pm_runtime_put_noidle(mcspi->dev);
 			dev_err(mcspi->dev, "failed to get sync: %d\n", err);
 			return;
 		}
@@ -1051,8 +1052,11 @@ static int omap2_mcspi_setup(struct spi_device *spi)
 	}
 
 	ret = pm_runtime_get_sync(mcspi->dev);
-	if (ret < 0)
+	if (ret < 0) {
+		pm_runtime_put_noidle(mcspi->dev);
+
 		return ret;
+	}
 
 	ret = omap2_mcspi_setup_transfer(spi, NULL);
 	pm_runtime_mark_last_busy(mcspi->dev);
@@ -1270,8 +1274,11 @@ static int omap2_mcspi_master_setup(struct omap2_mcspi *mcspi)
 	int			ret = 0;
 
 	ret = pm_runtime_get_sync(mcspi->dev);
-	if (ret < 0)
+	if (ret < 0) {
+		pm_runtime_put_noidle(mcspi->dev);
+
 		return ret;
+	}
 
 	mcspi_write_reg(master, OMAP2_MCSPI_WAKEUPENABLE,
 			OMAP2_MCSPI_WAKEUPENABLE_WKEN);
@@ -1458,24 +1465,55 @@ static int omap2_mcspi_remove(struct platform_device *pdev)
 MODULE_ALIAS("platform:omap2_mcspi");
 
 #ifdef	CONFIG_SUSPEND
-static int omap2_mcspi_resume(struct device *dev)
+static int omap2_mcspi_suspend_noirq(struct device *dev)
 {
-	return pinctrl_pm_select_default_state(dev);
+	int error;
+
+	/*
+	 * Make sure device gets idled if other drivers call SPI
+	 * functions between device_prepare() and device_complete()
+	 */
+	error = pm_runtime_force_suspend(dev);
+	if (error < 0) {
+		dev_err(dev, "%s: force suspend failed: %i\n",
+			__func__, error);
+
+		return error;
+	}
+
+	return pinctrl_pm_select_sleep_state(dev);
 }
 
-static int omap2_mcspi_suspend(struct device *dev)
+static int omap2_mcspi_resume_noirq(struct device *dev)
 {
-	return pinctrl_pm_select_sleep_state(dev);
+	struct spi_master *master = dev_get_drvdata(dev);
+	struct omap2_mcspi *mcspi = spi_master_get_devdata(master);
+	int error;
+
+	error = pinctrl_pm_select_default_state(dev);
+	if (error)
+		dev_warn(mcspi->dev, "%s: failed to set pins: %i\n",
+			 __func__, error);
+
+	error = pm_runtime_force_resume(mcspi->dev);
+	if (error < 0) {
+		dev_warn(mcspi->dev, "%s: force resume failed: %i\n",
+			 __func__, error);
+
+		return error;
+	}
+
+	return 0;
 }
 
 #else
-#define omap2_mcspi_suspend	NULL
-#define	omap2_mcspi_resume	NULL
+#define omap2_mcspi_suspend_noirq	NULL
+#define omap2_mcspi_resume_noirq	NULL
 #endif
 
 static const struct dev_pm_ops omap2_mcspi_pm_ops = {
-	.resume = omap2_mcspi_resume,
-	.suspend = omap2_mcspi_suspend,
+	.suspend_noirq = omap2_mcspi_suspend_noirq,
+	.resume_noirq = omap2_mcspi_resume_noirq,
 	.runtime_resume	= omap_mcspi_runtime_resume,
 };
 

