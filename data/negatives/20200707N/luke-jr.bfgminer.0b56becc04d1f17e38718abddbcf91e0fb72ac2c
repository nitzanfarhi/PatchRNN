commit 0b56becc04d1f17e38718abddbcf91e0fb72ac2c
Author: Con Kolivas <kernel@kolivas.org>
Date:   Mon Oct 7 17:56:57 2013 +1100

    Check for continuous IO errors on USB and consider the device inactive if more than retry max.

diff --git a/usbutils.c b/usbutils.c
index ec9b088a..451f0638 100644
--- a/usbutils.c
+++ b/usbutils.c
@@ -2614,6 +2614,8 @@ out_unlock:
 	if (err && err != LIBUSB_ERROR_TIMEOUT && err != LIBUSB_TRANSFER_TIMED_OUT) {
 		applog(LOG_WARNING, "%s %i usb read error: %s", cgpu->drv->name, cgpu->device_id,
 		       libusb_error_name(err));
+		if (cgpu->usbinfo.continuous_ioerr_count > USB_RETRY_MAX)
+			err = LIBUSB_ERROR_OTHER;
 	}
 out_noerrmsg:
 	DEVRUNLOCK(cgpu, pstate);
@@ -2710,6 +2712,8 @@ int _usb_write(struct cgpu_info *cgpu, int intinfo, int epinfo, char *buf, size_
 	if (err) {
 		applog(LOG_WARNING, "%s %i usb write error: %s", cgpu->drv->name, cgpu->device_id,
 		       libusb_error_name(err));
+		if (cgpu->usbinfo.continuous_ioerr_count > USB_RETRY_MAX)
+			err = LIBUSB_ERROR_OTHER;
 	}
 out_noerrmsg:
 	DEVRUNLOCK(cgpu, pstate);

