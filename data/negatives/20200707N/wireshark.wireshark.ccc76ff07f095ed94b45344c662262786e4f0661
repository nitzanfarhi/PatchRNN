commit ccc76ff07f095ed94b45344c662262786e4f0661
Author: Balint Reczey <balint@balintreczey.hu>
Date:   Thu Feb 28 21:11:32 2013 +0000

    Fix MSVC build errors related to symbol visibility
    
    svn path=/trunk/; revision=47952

diff --git a/wiretap/buffer.c b/wiretap/buffer.c
index e6df387af1..52bd63921e 100644
--- a/wiretap/buffer.c
+++ b/wiretap/buffer.c
@@ -30,6 +30,7 @@
 #include "buffer.h"
 
 /* Initializes a buffer with a certain amount of allocated space */
+WS_DLL_PUBLIC
 void buffer_init(Buffer* buffer, gsize space)
 {
 	buffer->data = (guint8*)g_malloc(space);
@@ -39,6 +40,7 @@ void buffer_init(Buffer* buffer, gsize space)
 }
 
 /* Frees the memory used by a buffer, and the buffer struct */
+WS_DLL_PUBLIC
 void buffer_free(Buffer* buffer)
 {
 	g_free(buffer->data);
@@ -48,6 +50,7 @@ void buffer_free(Buffer* buffer)
 	so that another routine can copy directly into the buffer space. After
 	doing that, the routine will also want to run
 	buffer_increase_length(). */
+WS_DLL_PUBLIC
 void buffer_assure_space(Buffer* buffer, gsize space)
 {
 	gsize available_at_end = buffer->allocated - buffer->first_free;
@@ -85,6 +88,7 @@ void buffer_assure_space(Buffer* buffer, gsize space)
 	buffer->data = (guint8*)g_realloc(buffer->data, buffer->allocated);
 }
 
+WS_DLL_PUBLIC
 void buffer_append(Buffer* buffer, guint8 *from, gsize bytes)
 {
 	buffer_assure_space(buffer, bytes);
@@ -92,6 +96,7 @@ void buffer_append(Buffer* buffer, guint8 *from, gsize bytes)
 	buffer->first_free += bytes;
 }
 
+WS_DLL_PUBLIC
 void buffer_remove_start(Buffer* buffer, gsize bytes)
 {
 	if (buffer->start + bytes > buffer->first_free) {
diff --git a/wiretap/file_access.c b/wiretap/file_access.c
index c63f538c2f..23662a9379 100644
--- a/wiretap/file_access.c
+++ b/wiretap/file_access.c
@@ -186,6 +186,7 @@ static void init_open_routines(void) {
 	open_routines = (wtap_open_routine_t*)(void *)open_routines_arr->data;
 }
 
+WS_DLL_PUBLIC
 void wtap_register_open_routine(wtap_open_routine_t open_routine, gboolean has_magic) {
 	init_open_routines();
 
@@ -223,6 +224,7 @@ void wtap_register_open_routine(wtap_open_routine_t open_routine, gboolean has_m
    so that it can do sequential I/O to a capture file that's being
    written to as new packets arrive independently of random I/O done
    to display protocol trees for packets when they're selected. */
+WS_DLL_PUBLIC
 wtap* wtap_open_offline(const char *filename, int *err, char **err_info,
 			gboolean do_random)
 {
@@ -436,6 +438,7 @@ success:
  * reopens the random stream.
  */
 gboolean
+WS_DLL_PUBLIC
 wtap_fdreopen(wtap *wth, const char *filename, int *err)
 {
 	ws_statb64 statb;
@@ -764,6 +767,7 @@ static void init_file_types(void) {
 	dump_open_table = (const struct file_type_info*)(void *)dump_open_table_arr->data;
 }
 
+WS_DLL_PUBLIC
 int wtap_register_file_type(const struct file_type_info* fi) {
 	init_file_types();
 
@@ -774,6 +778,7 @@ int wtap_register_file_type(const struct file_type_info* fi) {
 	return wtap_num_file_types++;
 }
 
+WS_DLL_PUBLIC
 int wtap_get_num_file_types(void)
 {
 	return wtap_num_file_types;
@@ -785,6 +790,7 @@ int wtap_get_num_file_types(void)
  * there's only one type, it's that type, otherwise it's
  * WTAP_ENCAP_PER_PACKET.
  */
+WS_DLL_PUBLIC
 int
 wtap_dump_file_encap_type(const GArray *file_encaps)
 {
@@ -802,6 +808,7 @@ wtap_dump_file_encap_type(const GArray *file_encaps)
  * Return TRUE if a capture with a given GArray of WTAP_ENCAP_ types
  * can be written in a specified format, and FALSE if it can't.
  */
+WS_DLL_PUBLIC
 gboolean
 wtap_dump_can_write_encaps(int ft, const GArray *file_encaps)
 {
@@ -842,6 +849,7 @@ wtap_dump_can_write_encaps(int ft, const GArray *file_encaps)
  * to save a file of a given type with a given GArray of WTAP_ENCAP_
  * types.
  */
+WS_DLL_PUBLIC
 GArray *
 wtap_get_savable_file_types(int file_type, const GArray *file_encaps)
 {
@@ -910,6 +918,7 @@ wtap_get_savable_file_types(int file_type, const GArray *file_encaps)
 }
 
 /* Name that should be somewhat descriptive. */
+WS_DLL_PUBLIC
 const char *wtap_file_type_string(int filetype)
 {
 	if (filetype < 0 || filetype >= wtap_num_file_types) {
@@ -921,6 +930,7 @@ const char *wtap_file_type_string(int filetype)
 }
 
 /* Name to use in, say, a command-line flag specifying the type. */
+WS_DLL_PUBLIC
 const char *wtap_file_type_short_string(int filetype)
 {
 	if (filetype < 0 || filetype >= wtap_num_file_types)
@@ -930,6 +940,7 @@ const char *wtap_file_type_short_string(int filetype)
 }
 
 /* Translate a short name to a capture file type. */
+WS_DLL_PUBLIC
 int wtap_short_string_to_file_type(const char *short_name)
 {
 	int filetype;
@@ -975,6 +986,7 @@ static GSList *add_extensions(GSList *extensions, const gchar *extension,
 
    All strings in the list are allocated with g_malloc() and must be freed
    with g_free(). */
+WS_DLL_PUBLIC
 GSList *wtap_get_file_extensions_list(int filetype, gboolean include_compressed)
 {
 	gchar **extensions_set, **extensionp;
@@ -1041,6 +1053,7 @@ GSList *wtap_get_file_extensions_list(int filetype, gboolean include_compressed)
 /*
  * Free a list returned by wtap_file_extensions_list().
  */
+WS_DLL_PUBLIC
 void wtap_free_file_extensions_list(GSList *extensions)
 {
 	GSList *extension;
@@ -1054,6 +1067,7 @@ void wtap_free_file_extensions_list(GSList *extensions)
 
 /* Return the default file extension to use with the specified file type;
    that's just the extension, without any ".". */
+WS_DLL_PUBLIC
 const char *wtap_default_file_extension(int filetype)
 {
 	if (filetype < 0 || filetype >= wtap_num_file_types)
@@ -1062,6 +1076,7 @@ const char *wtap_default_file_extension(int filetype)
 		return dump_open_table[filetype].default_file_extension;
 }
 
+WS_DLL_PUBLIC
 gboolean wtap_dump_can_open(int filetype)
 {
 	if (filetype < 0 || filetype >= wtap_num_file_types
@@ -1071,6 +1086,7 @@ gboolean wtap_dump_can_open(int filetype)
 	return TRUE;
 }
 
+WS_DLL_PUBLIC
 gboolean wtap_dump_can_write_encap(int filetype, int encap)
 {
 	if (filetype < 0 || filetype >= wtap_num_file_types
@@ -1084,6 +1100,7 @@ gboolean wtap_dump_can_write_encap(int filetype, int encap)
 }
 
 #ifdef HAVE_LIBZ
+WS_DLL_PUBLIC
 gboolean wtap_dump_can_compress(int filetype)
 {
 	/*
@@ -1098,12 +1115,14 @@ gboolean wtap_dump_can_compress(int filetype)
 	return TRUE;
 }
 #else
+WS_DLL_PUBLIC
 gboolean wtap_dump_can_compress(int filetype _U_)
 {
 	return FALSE;
 }
 #endif
 
+WS_DLL_LOCAL
 gboolean wtap_dump_has_name_resolution(int filetype)
 {
 	if (filetype < 0 || filetype >= wtap_num_file_types
@@ -1122,6 +1141,7 @@ static WFILE_T wtap_dump_file_open(wtap_dumper *wdh, const char *filename);
 static WFILE_T wtap_dump_file_fdopen(wtap_dumper *wdh, int fd);
 static int wtap_dump_file_close(wtap_dumper *wdh);
 
+WS_DLL_PUBLIC
 wtap_dumper* wtap_dump_open(const char *filename, int filetype, int encap,
 				int snaplen, gboolean compressed, int *err)
 {
@@ -1171,6 +1191,7 @@ wtap_dump_init_dumper(int filetype, int encap, int snaplen, gboolean compressed,
 	return wdh;
 }
 
+WS_DLL_PUBLIC
 wtap_dumper* wtap_dump_open_ng(const char *filename, int filetype, int encap,
 				int snaplen, gboolean compressed, wtapng_section_t *shb_hdr, wtapng_iface_descriptions_t *idb_inf, int *err)
 {
@@ -1230,12 +1251,14 @@ wtap_dumper* wtap_dump_open_ng(const char *filename, int filetype, int encap,
 	return wdh;
 }
 
+WS_DLL_PUBLIC
 wtap_dumper* wtap_dump_fdopen(int fd, int filetype, int encap, int snaplen,
 				gboolean compressed, int *err)
 {
 	return wtap_dump_fdopen_ng(fd, filetype, encap, snaplen, compressed, NULL, NULL, err);
 }
 
+WS_DLL_PUBLIC
 wtap_dumper* wtap_dump_fdopen_ng(int fd, int filetype, int encap, int snaplen,
 				gboolean compressed, wtapng_section_t *shb_hdr, wtapng_iface_descriptions_t *idb_inf, int *err)
 {
@@ -1363,12 +1386,14 @@ static gboolean wtap_dump_open_finish(wtap_dumper *wdh, int filetype, gboolean c
 	return TRUE;	/* success! */
 }
 
+WS_DLL_PUBLIC
 gboolean wtap_dump(wtap_dumper *wdh, const struct wtap_pkthdr *phdr,
 		   const guint8 *pd, int *err)
 {
 	return (wdh->subtype_write)(wdh, phdr, pd, err);
 }
 
+WS_DLL_PUBLIC
 void wtap_dump_flush(wtap_dumper *wdh)
 {
 #ifdef HAVE_LIBZ
@@ -1381,6 +1406,7 @@ void wtap_dump_flush(wtap_dumper *wdh)
 	}
 }
 
+WS_DLL_PUBLIC
 gboolean wtap_dump_close(wtap_dumper *wdh, int *err)
 {
 	gboolean ret = TRUE;
@@ -1413,16 +1439,19 @@ gboolean wtap_dump_close(wtap_dumper *wdh, int *err)
 	return ret;
 }
 
+WS_DLL_PUBLIC
 gint64 wtap_get_bytes_dumped(wtap_dumper *wdh)
 {
 	return wdh->bytes_dumped;
 }
 
+WS_DLL_PUBLIC
 void wtap_set_bytes_dumped(wtap_dumper *wdh, gint64 bytes_dumped)
 {
 	wdh->bytes_dumped = bytes_dumped;
 }
 
+WS_DLL_PUBLIC
 gboolean wtap_dump_set_addrinfo_list(wtap_dumper *wdh, struct addrinfo *addrinfo_list)
 {
 	if (!wdh || wdh->file_type < 0 || wdh->file_type >= wtap_num_file_types
@@ -1467,6 +1496,7 @@ static WFILE_T wtap_dump_file_fdopen(wtap_dumper *wdh _U_, int fd)
 #endif
 
 /* internally writing raw bytes (compressed or not) */
+WS_DLL_LOCAL
 gboolean wtap_dump_file_write(wtap_dumper *wdh, const void *buf, size_t bufsize,
 		     int *err)
 {
diff --git a/wiretap/pcap-common.c b/wiretap/pcap-common.c
index 12f3423225..4d2555549c 100644
--- a/wiretap/pcap-common.c
+++ b/wiretap/pcap-common.c
@@ -592,6 +592,7 @@ static const struct {
 };
 #define NUM_PCAP_ENCAPS (sizeof pcap_to_wtap_map / sizeof pcap_to_wtap_map[0])
 
+WS_DLL_PUBLIC
 int
 wtap_pcap_encap_to_wtap_encap(int encap)
 {
@@ -604,6 +605,7 @@ wtap_pcap_encap_to_wtap_encap(int encap)
 	return WTAP_ENCAP_UNKNOWN;
 }
 
+WS_DLL_PUBLIC
 int
 wtap_wtap_encap_to_pcap_encap(int encap)
 {
@@ -660,6 +662,7 @@ wtap_wtap_encap_to_pcap_encap(int encap)
 	return -1;
 }
 
+WS_DLL_PUBLIC
 gboolean
 wtap_encap_requires_phdr(int encap) {
 	if (
diff --git a/wiretap/wtap.c b/wiretap/wtap.c
index dcc04716e5..e70e902fb5 100644
--- a/wiretap/wtap.c
+++ b/wiretap/wtap.c
@@ -47,6 +47,7 @@
  * Return the size of the file, as reported by the OS.
  * (gint64, in case that's 64 bits.)
  */
+WS_DLL_PUBLIC
 gint64
 wtap_file_size(wtap *wth, int *err)
 {
@@ -61,6 +62,7 @@ wtap_file_size(wtap *wth, int *err)
 /*
  * Do an fstat on the file.
  */
+WS_DLL_PUBLIC
 int
 wtap_fstat(wtap *wth, ws_statb64 *statb, int *err)
 {
@@ -70,36 +72,42 @@ wtap_fstat(wtap *wth, ws_statb64 *statb, int *err)
 	return 0;
 }
 
+WS_DLL_PUBLIC
 int
 wtap_file_type(wtap *wth)
 {
 	return wth->file_type;
 }
 
+WS_DLL_PUBLIC
 gboolean
 wtap_iscompressed(wtap *wth)
 {
 	return file_iscompressed((wth->fh == NULL) ? wth->random_fh : wth->fh);
 }
 
+WS_DLL_PUBLIC
 guint
 wtap_snapshot_length(wtap *wth)
 {
 	return wth->snapshot_length;
 }
 
+WS_DLL_PUBLIC
 int
 wtap_file_encap(wtap *wth)
 {
 	return wth->file_encap;
 }
 
+WS_DLL_PUBLIC
 int
 wtap_file_tsprecision(wtap *wth)
 {
 	return wth->tsprecision;
 }
 
+WS_DLL_PUBLIC
 wtapng_section_t *
 wtap_file_get_shb_info(wtap *wth)
 {
@@ -119,6 +127,7 @@ wtap_file_get_shb_info(wtap *wth)
 	return shb_hdr;
 }
 
+WS_DLL_PUBLIC
 void
 wtap_write_shb_comment(wtap *wth, gchar *comment)
 {
@@ -127,6 +136,7 @@ wtap_write_shb_comment(wtap *wth, gchar *comment)
 
 }
 
+WS_DLL_PUBLIC
 wtapng_iface_descriptions_t *
 wtap_file_get_idb_info(wtap *wth)
 {
@@ -617,12 +627,14 @@ static void wtap_init_encap_types(void) {
 	encap_table = (void*)encap_table_arr->data;
 }
 
+WS_DLL_PUBLIC
 int wtap_get_num_encap_types(void) {
 	wtap_init_encap_types();
 	return wtap_num_encap_types;
 }
 
 
+WS_DLL_PUBLIC
 int wtap_register_encap_type(const char* name, const char* short_name) {
 	struct encap_type_info e;
 	wtap_init_encap_types();
@@ -639,6 +651,7 @@ int wtap_register_encap_type(const char* name, const char* short_name) {
 
 
 /* Name that should be somewhat descriptive. */
+WS_DLL_PUBLIC
 const char *
 wtap_encap_string(int encap)
 {
@@ -651,6 +664,7 @@ wtap_encap_string(int encap)
 }
 
 /* Name to use in, say, a command-line flag specifying the type. */
+WS_DLL_PUBLIC
 const char *
 wtap_encap_short_string(int encap)
 {
@@ -663,6 +677,7 @@ wtap_encap_short_string(int encap)
 }
 
 /* Translate a short name to a capture file type. */
+WS_DLL_PUBLIC
 int
 wtap_short_string_to_encap(const char *short_name)
 {
@@ -702,6 +717,7 @@ static const char *wtap_errlist[] = {
 };
 #define	WTAP_ERRLIST_SIZE	(sizeof wtap_errlist / sizeof wtap_errlist[0])
 
+WS_DLL_PUBLIC
 const char *
 wtap_strerror(int err)
 {
@@ -729,6 +745,7 @@ wtap_strerror(int err)
 
    Instead, if the subtype has a "sequential close" function, we call it,
    to free up stuff used only by the sequential side. */
+WS_DLL_PUBLIC
 void
 wtap_sequential_close(wtap *wth)
 {
@@ -759,6 +776,7 @@ g_fast_seek_item_free(gpointer data, gpointer user_data _U_)
  * we need to rename a file that we have open or if we need to rename on
  * top of a file we have open.
  */
+WS_DLL_PUBLIC
 void
 wtap_fdclose(wtap *wth)
 {
@@ -768,6 +786,7 @@ wtap_fdclose(wtap *wth)
 		file_fdclose(wth->random_fh);
 }
 
+WS_DLL_PUBLIC
 void
 wtap_close(wtap *wth)
 {
@@ -826,22 +845,26 @@ wtap_close(wtap *wth)
 	g_free(wth);
 }
 
+WS_DLL_PUBLIC
 void
 wtap_cleareof(wtap *wth) {
 	/* Reset EOF */
 	file_clearerr(wth->fh);
 }
 
+WS_DLL_PUBLIC
 void wtap_set_cb_new_ipv4(wtap *wth, wtap_new_ipv4_callback_t add_new_ipv4) {
 	if (wth)
 		wth->add_new_ipv4 = add_new_ipv4;
 }
 
+WS_DLL_PUBLIC
 void wtap_set_cb_new_ipv6(wtap *wth, wtap_new_ipv6_callback_t add_new_ipv6) {
 	if (wth)
 		wth->add_new_ipv6 = add_new_ipv6;
 }
 
+WS_DLL_PUBLIC
 gboolean
 wtap_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)
 {
@@ -892,24 +915,28 @@ wtap_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)
  * Return an approximation of the amount of data we've read sequentially
  * from the file so far.  (gint64, in case that's 64 bits.)
  */
+WS_DLL_PUBLIC
 gint64
 wtap_read_so_far(wtap *wth)
 {
 	return file_tell_raw(wth->fh);
 }
 
+WS_DLL_PUBLIC
 struct wtap_pkthdr *
 wtap_phdr(wtap *wth)
 {
 	return &wth->phdr;
 }
 
+WS_DLL_PUBLIC
 guint8 *
 wtap_buf_ptr(wtap *wth)
 {
 	return buffer_start_ptr(wth->frame_buffer);
 }
 
+WS_DLL_PUBLIC
 gboolean
 wtap_seek_read(wtap *wth, gint64 seek_off,
 	struct wtap_pkthdr *phdr, guint8 *pd, int len,

