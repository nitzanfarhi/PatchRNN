commit ab285f2b5290d92b7ec1a6f9aad54308dadf6157
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Thu Apr 8 14:05:50 2010 +0200

    perf: Fix unsafe frame rewinding with hot regs fetching
    
    When we fetch the hot regs and rewind to the nth caller, it
    might happen that we dereference a frame pointer outside the
    kernel stack boundaries, like in this example:
    
            perf_trace_sched_switch+0xd5/0x120
            schedule+0x6b5/0x860
            retint_careful+0xd/0x21
    
    Since we directly dereference a userspace frame pointer here while
    rewinding behind retint_careful, this may end up in a crash.
    
    Fix this by simply using probe_kernel_address() when we rewind the
    frame pointer.
    
    This issue will have a much more proper fix in the next version of the
    perf_arch_fetch_caller_regs() API that will only need to rewind to the
    first caller.
    
    Reported-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Tested-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: David Miller <davem@davemloft.net>
    Cc: Archs <linux-arch@vger.kernel.org>

diff --git a/arch/x86/kernel/dumpstack.h b/arch/x86/kernel/dumpstack.h
index e39e77168a37..e1a93be4fd44 100644
--- a/arch/x86/kernel/dumpstack.h
+++ b/arch/x86/kernel/dumpstack.h
@@ -14,6 +14,8 @@
 #define get_bp(bp) asm("movq %%rbp, %0" : "=r" (bp) :)
 #endif
 
+#include <linux/uaccess.h>
+
 extern void
 show_trace_log_lvl(struct task_struct *task, struct pt_regs *regs,
 		unsigned long *stack, unsigned long bp, char *log_lvl);
@@ -42,8 +44,10 @@ static inline unsigned long rewind_frame_pointer(int n)
 	get_bp(frame);
 
 #ifdef CONFIG_FRAME_POINTER
-	while (n--)
-		frame = frame->next_frame;
+	while (n--) {
+		if (probe_kernel_address(&frame->next_frame, frame))
+			break;
+	}
 #endif
 
 	return (unsigned long)frame;

