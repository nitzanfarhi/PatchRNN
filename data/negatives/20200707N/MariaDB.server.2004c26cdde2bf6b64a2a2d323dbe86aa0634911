commit 2004c26cdde2bf6b64a2a2d323dbe86aa0634911
Author: Zardosht Kasheff <zardosht@tokutek.com>
Date:   Tue Apr 16 23:59:43 2013 -0400

    [t:3738], make dsn into a struct
    
    git-svn-id: file:///svn/toku/tokudb@32906 c7de825b-a66e-492c-adef-691d508d4ae1

diff --git a/newbrt/brt-serialize.c b/newbrt/brt-serialize.c
index a7472f06d0d..94095b238bd 100644
--- a/newbrt/brt-serialize.c
+++ b/newbrt/brt-serialize.c
@@ -531,7 +531,7 @@ rebalance_brtnode_leaf(BRTNODE node)
     for (int i = 0; i < node->n_children; i++) {
         DSN curr_dsn = BLB_MAX_DSN_APPLIED(node,i);
         MSN curr_msn = BLB_MAX_MSN_APPLIED(node,i);
-        min_dsn = (curr_dsn < min_dsn) ? curr_dsn : min_dsn;
+        min_dsn = (curr_dsn.dsn < min_dsn.dsn) ? curr_dsn : min_dsn;
         max_msn = (curr_msn.msn > max_msn.msn) ? curr_msn : max_msn;
     }
     
@@ -813,7 +813,7 @@ BASEMENTNODE toku_create_empty_bn(void) {
 
 BASEMENTNODE toku_create_empty_bn_no_buffer(void) {
     BASEMENTNODE XMALLOC(bn);
-    bn->max_dsn_applied = 0;
+    bn->max_dsn_applied.dsn = 0;
     bn->max_msn_applied.msn = 0;
     bn->buffer = NULL;
     bn->n_bytes_in_buffer = 0;
@@ -1005,7 +1005,7 @@ setup_available_brtnode_partition(BRTNODE node, int i) {
     if (node->height == 0) {
 	set_BLB(node, i, toku_create_empty_bn());
         BLB_MAX_MSN_APPLIED(node,i) = node->max_msn_applied_to_node_on_disk;
-        BLB_MAX_DSN_APPLIED(node,i) = 0;
+        BLB_MAX_DSN_APPLIED(node,i).dsn = 0;
     }
     else {
 	set_BNC(node, i, toku_create_empty_nl());
@@ -1681,7 +1681,7 @@ deserialize_brtheader (int fd, struct rbuf *rb, struct brt_header **brth) {
     h->dirty=0;
     h->panic = 0;
     h->panic_string = 0;
-    h->curr_dsn = MIN_DSN+1;
+    h->curr_dsn.dsn = MIN_DSN.dsn+1;
     toku_list_init(&h->live_brts);
     toku_list_init(&h->zombie_brts);
     toku_list_init(&h->checkpoint_before_commit_link);
diff --git a/newbrt/brt.c b/newbrt/brt.c
index 0f6d4b17849..05c8fc06c25 100644
--- a/newbrt/brt.c
+++ b/newbrt/brt.c
@@ -149,9 +149,9 @@ toku_assert_entire_node_in_memory(BRTNODE node) {
 //
 static void
 set_new_DSN_for_node(BRTNODE node, BRT t) {
-    assert(t->h->curr_dsn > MIN_DSN);
+    assert(t->h->curr_dsn.dsn > MIN_DSN.dsn);
     node->dsn = t->h->curr_dsn;
-    t->h->curr_dsn++;
+    t->h->curr_dsn.dsn++;
 }
 
 static u_int32_t
@@ -293,7 +293,7 @@ int toku_pin_brtnode_if_clean(
         ); // this one doesn't need to use the toku_pin_brtnode function because it doesn't bring anything in, so it cannot create a non-up-to-date leaf node.
     if (r==0) {
         BRTNODE node = node_v;
-        if (node->dsn == INVALID_DSN) {
+        if (node->dsn.dsn == INVALID_DSN.dsn) {
             set_new_DSN_for_node(node, brt);
         }
         maybe_apply_ancestors_messages_to_node(brt, node, ancestors, bounds);
@@ -324,7 +324,7 @@ int toku_pin_brtnode (BRT brt, BLOCKNUM blocknum, u_int32_t fullhash,
             unlockers);
     if (r==0) {
 	BRTNODE node = node_v;
-        if (node->dsn == INVALID_DSN) {
+        if (node->dsn.dsn == INVALID_DSN.dsn) {
             set_new_DSN_for_node(node, brt);
         }
 	maybe_apply_ancestors_messages_to_node(brt, node, ancestors, bounds);
@@ -358,7 +358,7 @@ void toku_pin_brtnode_holding_lock (BRT brt, BLOCKNUM blocknum, u_int32_t fullha
         );
     assert(r==0);
     BRTNODE node = node_v;
-    if (node->dsn == INVALID_DSN) {
+    if (node->dsn.dsn == INVALID_DSN.dsn) {
         set_new_DSN_for_node(node, brt);
     }
     maybe_apply_ancestors_messages_to_node(brt, node, ancestors, bounds);
@@ -1002,7 +1002,7 @@ brt_init_new_root(BRT brt, BRTNODE nodea, BRTNODE nodeb, DBT splitk, CACHEKEY *r
 	invariant(msna.msn == msnb.msn);
 	newroot->max_msn_applied_to_node_on_disk = msna;
     }
-    newroot->dsn = (nodea->dsn > nodeb->dsn) ? nodea->dsn : nodeb->dsn;
+    newroot->dsn = (nodea->dsn.dsn > nodeb->dsn.dsn) ? nodea->dsn : nodeb->dsn;
     BP_STATE(newroot,0) = PT_AVAIL;
     BP_STATE(newroot,1) = PT_AVAIL;
     newroot->dirty = 1;
@@ -2399,7 +2399,7 @@ maybe_merge_pinned_nodes (BRTNODE parent, int childnum_of_parent, struct kv_pair
 	    invariant(msn_max.msn <= parent->max_msn_applied_to_node_on_disk.msn);  // parent msn must be >= children's msn
 	}
     }
-    dsn_max = (a->dsn > b->dsn) ? a->dsn : b->dsn; 
+    dsn_max = (a->dsn.dsn > b->dsn.dsn) ? a->dsn : b->dsn; 
     if (a->height == 0) {
 	maybe_merge_pinned_leaf_nodes(parent, childnum_of_parent, a, b, parent_splitk, did_merge, did_rebalance, splitk);
     } else {
@@ -2615,7 +2615,7 @@ static void assert_leaf_up_to_date(BRTNODE node) {
     assert(node->height == 0);
     toku_assert_entire_node_in_memory(node);
     for (int i=0; i < node->n_children; i++) {
-	assert(BLB_MAX_DSN_APPLIED(node, i) >= MIN_DSN);
+	assert(BLB_MAX_DSN_APPLIED(node, i).dsn >= MIN_DSN.dsn);
     }
 }
 
@@ -3668,7 +3668,7 @@ brt_alloc_init_header(BRT t, TOKUTXN txn) {
 
     memset(&t->h->descriptor, 0, sizeof(t->h->descriptor));
 
-    t->h->curr_dsn = MIN_DSN + 1; // start at MIN_DSN + 1, as MIN_DSN is reserved for basement nodes
+    t->h->curr_dsn.dsn = MIN_DSN.dsn + 1; // start at MIN_DSN + 1, as MIN_DSN is reserved for basement nodes
 
     r = brt_init_header(t, txn);
     if (r != 0) goto died2;
@@ -5179,7 +5179,7 @@ partition_requires_msg_application(BRTNODE node, int childnum, ANCESTORS ancesto
         curr_ancestors = curr_ancestors->next
         ) 
     {
-        if (curr_ancestors->node->dsn > BLB_MAX_DSN_APPLIED(node,childnum)) {
+        if (curr_ancestors->node->dsn.dsn > BLB_MAX_DSN_APPLIED(node,childnum).dsn) {
             requires_msg_application = TRUE;
             break;
         }
@@ -5227,7 +5227,7 @@ maybe_apply_ancestors_messages_to_node (BRT t, BRTNODE node, ANCESTORS ancestors
                 curr_ancestors->childnum,
                 &curr_bounds
                 );
-            curr_bn->max_dsn_applied = (curr_ancestors->node->dsn > curr_bn->max_dsn_applied) 
+            curr_bn->max_dsn_applied = (curr_ancestors->node->dsn.dsn > curr_bn->max_dsn_applied.dsn) 
                 ? curr_ancestors->node->dsn 
                 : curr_bn->max_dsn_applied;
 	    curr_ancestors= curr_ancestors->next;
@@ -5266,7 +5266,7 @@ brt_search_basement_node(
     BRT_CURSOR brtcursor
     )
 {
-    assert(bn->max_dsn_applied >= MIN_DSN);
+    assert(bn->max_dsn_applied.dsn >= MIN_DSN.dsn);
 
     // Now we have to convert from brt_search_t to the heaviside function with a direction.  What a pain...
 
diff --git a/newbrt/brttypes.h b/newbrt/brttypes.h
index cd104fc54be..63b3ca7e655 100644
--- a/newbrt/brttypes.h
+++ b/newbrt/brttypes.h
@@ -60,10 +60,10 @@ typedef struct __toku_msn { u_int64_t msn; } MSN;
 #define MIN_MSN  ((MSN){(u_int64_t)1000*1000*1000})  // first 1B values reserved for messages created before Dr. No (for upgrade)
 #define MAX_MSN  ((MSN){UINT64_MAX})
 
-typedef int64_t DSN; // DESERIALIZATION sequence number
-#define INVALID_DSN -1
-#define MIN_DSN 0
-#define MAX_DSN INT64_MAX
+typedef struct __toku_dsn { int64_t dsn; } DSN; // DESERIALIZATION sequence number
+#define INVALID_DSN ((DSN){-1})
+#define MIN_DSN ((DSN){0})
+#define MAX_DSN ((DSN){INT64_MAX})
 
 /* At the brt layer, a FILENUM uniquely identifies an open file.
  * At the ydb layer, a DICTIONARY_ID uniquely identifies an open dictionary.

