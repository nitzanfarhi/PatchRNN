commit abb65272a190660790096628859e752172d822fd
Author: Tomi Valkeinen <tomi.valkeinen@nokia.com>
Date:   Thu Jan 20 14:44:20 2011 -0800

    memblock: fix memblock_is_region_memory()
    
    memblock_is_region_memory() uses reserved memblocks to search for the
    given region, while it should use the memory memblocks.
    
    I encountered the problem with OMAP's framebuffer ram allocation.
    Normally the ram is allocated dynamically, and this function is not
    called.  However, if we want to pass the framebuffer from the bootloader
    to the kernel (to retain the boot image), this function is used to check
    the validity of the kernel parameters for the framebuffer ram area.
    
    Signed-off-by: Tomi Valkeinen <tomi.valkeinen@nokia.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/mm/memblock.c b/mm/memblock.c
index 400dc62697d7..bdba245d8afd 100644
--- a/mm/memblock.c
+++ b/mm/memblock.c
@@ -683,13 +683,13 @@ int __init_memblock memblock_is_memory(phys_addr_t addr)
 
 int __init_memblock memblock_is_region_memory(phys_addr_t base, phys_addr_t size)
 {
-	int idx = memblock_search(&memblock.reserved, base);
+	int idx = memblock_search(&memblock.memory, base);
 
 	if (idx == -1)
 		return 0;
-	return memblock.reserved.regions[idx].base <= base &&
-		(memblock.reserved.regions[idx].base +
-		 memblock.reserved.regions[idx].size) >= (base + size);
+	return memblock.memory.regions[idx].base <= base &&
+		(memblock.memory.regions[idx].base +
+		 memblock.memory.regions[idx].size) >= (base + size);
 }
 
 int __init_memblock memblock_is_region_reserved(phys_addr_t base, phys_addr_t size)

