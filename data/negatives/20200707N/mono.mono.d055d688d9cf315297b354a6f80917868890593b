commit d055d688d9cf315297b354a6f80917868890593b
Author: Alex RÃ¸nne Petersen <alexrp@xamarin.com>
Date:   Wed Aug 12 08:20:39 2015 +0200

    [profiler] Add GC handle events with backtraces.

diff --git a/mono/profiler/decode.c b/mono/profiler/decode.c
index 9924906bd90..0df2d3cd1af 100644
--- a/mono/profiler/decode.c
+++ b/mono/profiler/decode.c
@@ -1845,6 +1845,7 @@ typedef struct {
 	uint64_t live;
 	uint64_t max_live;
 	TraceDesc traces;
+	TraceDesc destroy_traces;
 } HandleInfo;
 static HandleInfo handle_info [4];
 
@@ -1991,12 +1992,18 @@ tracked_creation (uintptr_t obj, ClassDesc *cd, uint64_t size, BackTrace *bt, ui
 }
 
 static void
-track_handle (uintptr_t obj, int htype, uint32_t handle)
+track_handle (uintptr_t obj, int htype, uint32_t handle, BackTrace *bt, uint64_t timestamp)
 {
 	int i;
 	for (i = 0; i < num_tracked_objects; ++i) {
-		if (tracked_objects [i] == obj)
-			fprintf (outfile, "Object %p referenced from handle %u\n", (void*)obj, handle);
+		if (tracked_objects [i] != obj)
+			continue;
+		fprintf (outfile, "Object %p referenced from handle %u at %.3f secs.\n", (void*)obj, handle, (timestamp - startup_time) / 1000000000.0);
+		if (bt && bt->count) {
+			int k;
+			for (k = 0; k < bt->count; ++k)
+				fprintf (outfile, "\t%s\n", bt->methods [k]->name);
+		}
 	}
 }
 
@@ -2274,31 +2281,72 @@ decode_buffer (ProfContext *ctx)
 						fprintf (outfile, "moved obj %p to %p\n", (void*)OBJ_ADDR (obj1diff), (void*)OBJ_ADDR (obj2diff));
 					}
 				}
-			} else if (subtype == TYPE_GC_HANDLE_CREATED) {
+			} else if (subtype == TYPE_GC_HANDLE_CREATED || subtype == TYPE_GC_HANDLE_CREATED_BT) {
+				int has_bt = subtype == TYPE_GC_HANDLE_CREATED_BT;
+				int num_bt = 0;
+				MethodDesc *sframes [8];
+				MethodDesc **frames = sframes;
 				int htype = decode_uleb128 (p, &p);
 				uint32_t handle = decode_uleb128 (p, &p);
 				intptr_t objdiff = decode_sleb128 (p, &p);
+				if (has_bt) {
+					num_bt = 8;
+					frames = decode_bt (sframes, &num_bt, p, &p, ptr_base);
+					if (!frames) {
+						fprintf (outfile, "Cannot load backtrace\n");
+						return 0;
+					}
+				}
 				if (htype > 3)
 					return 0;
-				handle_info [htype].created++;
-				handle_info [htype].live++;
-				add_trace_thread (thread, &handle_info [htype].traces, 1);
-				/* FIXME: we don't take into account timing here */
-				if (handle_info [htype].live > handle_info [htype].max_live)
-					handle_info [htype].max_live = handle_info [htype].live;
-				if (num_tracked_objects)
-					track_handle (OBJ_ADDR (objdiff), htype, handle);
+				if ((thread_filter && thread_filter == thread->thread_id) || (time_base >= time_from && time_base < time_to)) {
+					handle_info [htype].created++;
+					handle_info [htype].live++;
+					if (handle_info [htype].live > handle_info [htype].max_live)
+						handle_info [htype].max_live = handle_info [htype].live;
+					BackTrace *bt;
+					if (has_bt)
+						bt = add_trace_methods (frames, num_bt, &handle_info [htype].traces, 1);
+					else
+						bt = add_trace_thread (thread, &handle_info [htype].traces, 1);
+					if (num_tracked_objects)
+						track_handle (OBJ_ADDR (objdiff), htype, handle, bt, time_base);
+				}
 				if (debug)
 					fprintf (outfile, "handle (%s) %u created for object %p\n", get_handle_name (htype), handle, (void*)OBJ_ADDR (objdiff));
-			} else if (subtype == TYPE_GC_HANDLE_DESTROYED) {
+				if (frames != sframes)
+					free (frames);
+			} else if (subtype == TYPE_GC_HANDLE_DESTROYED || subtype == TYPE_GC_HANDLE_DESTROYED_BT) {
+				int has_bt = subtype == TYPE_GC_HANDLE_DESTROYED_BT;
+				int num_bt = 0;
+				MethodDesc *sframes [8];
+				MethodDesc **frames = sframes;
 				int htype = decode_uleb128 (p, &p);
 				uint32_t handle = decode_uleb128 (p, &p);
+				if (has_bt) {
+					num_bt = 8;
+					frames = decode_bt (sframes, &num_bt, p, &p, ptr_base);
+					if (!frames) {
+						fprintf (outfile, "Cannot load backtrace\n");
+						return 0;
+					}
+				}
 				if (htype > 3)
 					return 0;
-				handle_info [htype].destroyed ++;
-				handle_info [htype].live--;
+				if ((thread_filter && thread_filter == thread->thread_id) || (time_base >= time_from && time_base < time_to)) {
+					handle_info [htype].destroyed ++;
+					handle_info [htype].live--;
+					BackTrace *bt;
+					if (has_bt)
+						bt = add_trace_methods (frames, num_bt, &handle_info [htype].destroy_traces, 1);
+					else
+						bt = add_trace_thread (thread, &handle_info [htype].destroy_traces, 1);
+					/* TODO: track_handle_free () - would need to record and keep track of the associated object address... */
+				}
 				if (debug)
 					fprintf (outfile, "handle (%s) %u destroyed\n", get_handle_name (htype), handle);
+				if (frames != sframes)
+					free (frames);
 			}
 			break;
 		}
@@ -3178,6 +3226,7 @@ dump_gcs (void)
 			(unsigned long long) (handle_info [i].destroyed),
 			(unsigned long long) (handle_info [i].max_live));
 		dump_traces (&handle_info [i].traces, "created");
+		dump_traces (&handle_info [i].destroy_traces, "destroyed");
 	}
 }
 
diff --git a/mono/profiler/proflog.c b/mono/profiler/proflog.c
index 59d84d189f2..549a7cf0c90 100644
--- a/mono/profiler/proflog.c
+++ b/mono/profiler/proflog.c
@@ -198,8 +198,8 @@ typedef struct _LogBuffer LogBuffer;
  *
  * type GC format:
  * type: TYPE_GC
- * exinfo: one of TYPE_GC_EVENT, TYPE_GC_RESIZE, TYPE_GC_MOVE, TYPE_GC_HANDLE_CREATED,
- * TYPE_GC_HANDLE_DESTROYED
+ * exinfo: one of TYPE_GC_EVENT, TYPE_GC_RESIZE, TYPE_GC_MOVE, TYPE_GC_HANDLE_CREATED[_BT],
+ * TYPE_GC_HANDLE_DESTROYED[_BT]
  * [time diff: uleb128] nanoseconds since last timing
  * if exinfo == TYPE_GC_RESIZE
  *	[heap_size: uleb128] new heap size
@@ -211,15 +211,17 @@ typedef struct _LogBuffer LogBuffer;
  *	[objaddr: sleb128]+ num_objects object pointer differences from obj_base
  *	num is always an even number: the even items are the old
  *	addresses, the odd numbers are the respective new object addresses
- * if exinfo == TYPE_GC_HANDLE_CREATED
+ * if exinfo == TYPE_GC_HANDLE_CREATED[_BT]
  *	[handle_type: uleb128] GC handle type (System.Runtime.InteropServices.GCHandleType)
  *	upper bits reserved as flags
  *	[handle: uleb128] GC handle value
  *	[objaddr: sleb128] object pointer differences from obj_base
- * if exinfo == TYPE_GC_HANDLE_DESTROYED
+ * 	If exinfo == TYPE_GC_HANDLE_CREATED_BT, a backtrace follows.
+ * if exinfo == TYPE_GC_HANDLE_DESTROYED[_BT]
  *	[handle_type: uleb128] GC handle type (System.Runtime.InteropServices.GCHandleType)
  *	upper bits reserved as flags
  *	[handle: uleb128] GC handle value
+ * 	If exinfo == TYPE_GC_HANDLE_DESTROYED_BT, a backtrace follows.
  *
  * type metadata format:
  * type: TYPE_METADATA
@@ -1169,7 +1171,13 @@ gc_roots (MonoProfiler *prof, int num, void **objects, int *root_types, uintptr_
 static void
 gc_handle (MonoProfiler *prof, int op, int type, uintptr_t handle, MonoObject *obj)
 {
+	int do_bt = nocalls && InterlockedRead (&runtime_inited) && !notraces;
 	uint64_t now;
+	FrameData data;
+
+	if (do_bt)
+		collect_bt (&data);
+
 	LogBuffer *logbuffer = ensure_logbuf (
 		EVENT_SIZE /* event */ +
 		LEB128_SIZE /* time */ +
@@ -1177,21 +1185,36 @@ gc_handle (MonoProfiler *prof, int op, int type, uintptr_t handle, MonoObject *o
 		LEB128_SIZE /* handle */ +
 		(op == MONO_PROFILER_GC_HANDLE_CREATED ? (
 			LEB128_SIZE /* obj */
+		) : 0) +
+		(do_bt ? (
+			LEB128_SIZE /* flags */ +
+			LEB128_SIZE /* count */ +
+			data.count * (
+				LEB128_SIZE /* method */
+			)
 		) : 0)
 	);
+
 	now = current_time ();
 	ENTER_LOG (logbuffer, "gchandle");
+
 	if (op == MONO_PROFILER_GC_HANDLE_CREATED)
-		emit_byte (logbuffer, TYPE_GC_HANDLE_CREATED | TYPE_GC);
+		emit_byte (logbuffer, (do_bt ? TYPE_GC_HANDLE_CREATED_BT : TYPE_GC_HANDLE_CREATED) | TYPE_GC);
 	else if (op == MONO_PROFILER_GC_HANDLE_DESTROYED)
-		emit_byte (logbuffer, TYPE_GC_HANDLE_DESTROYED | TYPE_GC);
+		emit_byte (logbuffer, (do_bt ? TYPE_GC_HANDLE_DESTROYED_BT : TYPE_GC_HANDLE_DESTROYED) | TYPE_GC);
 	else
-		return;
+		g_assert_not_reached ();
+
 	emit_time (logbuffer, now);
 	emit_value (logbuffer, type);
 	emit_value (logbuffer, handle);
+
 	if (op == MONO_PROFILER_GC_HANDLE_CREATED)
 		emit_obj (logbuffer, obj);
+
+	if (do_bt)
+		emit_bt (prof, logbuffer, &data);
+
 	EXIT_LOG (logbuffer);
 	process_requests (prof);
 }
diff --git a/mono/profiler/proflog.h b/mono/profiler/proflog.h
index a2c0fb25f17..8fc22e43282 100644
--- a/mono/profiler/proflog.h
+++ b/mono/profiler/proflog.h
@@ -24,6 +24,7 @@
                    load/unload for contexts
                    load/unload/name for assemblies
                removed TYPE_LOAD_ERR flag (profiler never generated it, now removed from the format itself)
+               added TYPE_GC_HANDLE_{CREATED,DESTROYED}_BT
  */
 
 enum {
@@ -56,8 +57,10 @@ enum {
 	TYPE_GC_EVENT  = 1 << 4,
 	TYPE_GC_RESIZE = 2 << 4,
 	TYPE_GC_MOVE   = 3 << 4,
-	TYPE_GC_HANDLE_CREATED   = 4 << 4,
-	TYPE_GC_HANDLE_DESTROYED = 5 << 4,
+	TYPE_GC_HANDLE_CREATED      = 4 << 4,
+	TYPE_GC_HANDLE_DESTROYED    = 5 << 4,
+	TYPE_GC_HANDLE_CREATED_BT   = 6 << 4,
+	TYPE_GC_HANDLE_DESTROYED_BT = 7 << 4,
 	/* extended type for TYPE_METHOD */
 	TYPE_LEAVE     = 1 << 4,
 	TYPE_ENTER     = 2 << 4,

