commit d056a25900489d9d5e7c24c0b41acfd13e2bcf96
Author: Gal Hammer <ghammer@redhat.com>
Date:   Sun Jun 2 16:17:33 2013 +0300

    serial: bz#966809 Fix BSOD after resuming from hibernation.
    
    The driver didn't handle a surprise-removal of the device. In this
    bug's scenario, the device was added dynamically so it didn't exist
    when the guest was resumed.

diff --git a/vioserial/sys/Device.c b/vioserial/sys/Device.c
index 9bd9e7a..1cf21d3 100644
--- a/vioserial/sys/Device.c
+++ b/vioserial/sys/Device.c
@@ -501,6 +501,11 @@ VIOSerialInitAllQueues(
         }
     }
 
+    if (pContext->isHostMultiport && (pContext->c_ovq == NULL))
+    {
+        status = STATUS_NOT_FOUND;
+    }
+
     TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT, "<-- %s\n", __FUNCTION__);
     return status;
 }
@@ -599,7 +604,9 @@ VIOSerialEvtDeviceD0Entry(
     IN  WDF_POWER_DEVICE_STATE PreviousState
     )
 {
-    PPORTS_DEVICE	pContext = GetPortsDevice(Device);
+    NTSTATUS status = STATUS_SUCCESS;
+    PPORTS_DEVICE pContext = GetPortsDevice(Device);
+
     UNREFERENCED_PARAMETER(PreviousState);
 
     TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT, "--> %s\n", __FUNCTION__);
@@ -611,12 +618,16 @@ VIOSerialEvtDeviceD0Entry(
     }
     else
     {
-        VIOSerialInitAllQueues(Device);
-        VIOSerialRenewAllPorts(Device);
+        status = VIOSerialInitAllQueues(Device);
+        if (NT_SUCCESS(status))
+        {
+            VIOSerialRenewAllPorts(Device);
+        }
     }
 
     TraceEvents(TRACE_LEVEL_INFORMATION, DBG_INIT, "<-- %s\n", __FUNCTION__);
-    return STATUS_SUCCESS;
+
+    return status;
 }
 
 NTSTATUS
diff --git a/vioserial/sys/Port.c b/vioserial/sys/Port.c
index e52b4f0..26a23c4 100644
--- a/vioserial/sys/Port.c
+++ b/vioserial/sys/Port.c
@@ -1487,12 +1487,18 @@ NTSTATUS VIOSerialPortEvtDeviceD0Entry(
     IN WDF_POWER_DEVICE_STATE PreviousState)
 {
     PVIOSERIAL_PORT port = RawPdoSerialPortGetData(Device)->port;
+    PPORTS_DEVICE pCtx = GetPortsDevice(port->BusDevice);
     NTSTATUS status;
 
     TraceEvents(TRACE_LEVEL_INFORMATION, DBG_PNP, "--> %s\n", __FUNCTION__);
 
     PAGED_CODE();
 
+    if ((pCtx->in_vqs == NULL) || (pCtx->in_vqs[port->PortId] == NULL))
+    {
+        return STATUS_NOT_FOUND;
+    }
+
     status = VIOSerialFillQueue(GetInQueue(port), port->InBufLock);
     if (!NT_SUCCESS(status))
     {

