commit 0cd8116f172eed018907303dbff5c112690eeb91
Author: Joakim Tjernlund <joakim.tjernlund@infinera.com>
Date:   Wed Jun 6 12:13:29 2018 +0200

    mtd: cfi_cmdset_0002: Fix unlocking requests crossing a chip boudary
    
    The "sector is in requested range" test used to determine whether
    sectors should be re-locked or not is done on a variable that is reset
    everytime we cross a chip boundary, which can lead to some blocks being
    re-locked while the caller expect them to be unlocked.
    Fix the check to make sure this cannot happen.
    
    Fixes: 1648eaaa1575 ("mtd: cfi_cmdset_0002: Support Persistent Protection Bits (PPB) locking")
    Cc: stable@vger.kernel.org
    Signed-off-by: Joakim Tjernlund <joakim.tjernlund@infinera.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>

diff --git a/drivers/mtd/chips/cfi_cmdset_0002.c b/drivers/mtd/chips/cfi_cmdset_0002.c
index 87f9925d25f9..9cfc2645dd93 100644
--- a/drivers/mtd/chips/cfi_cmdset_0002.c
+++ b/drivers/mtd/chips/cfi_cmdset_0002.c
@@ -2660,7 +2660,7 @@ static int __maybe_unused cfi_ppb_unlock(struct mtd_info *mtd, loff_t ofs,
 		 * sectors shall be unlocked, so lets keep their locking
 		 * status at "unlocked" (locked=0) for the final re-locking.
 		 */
-		if ((adr < ofs) || (adr >= (ofs + len))) {
+		if ((offset < ofs) || (offset >= (ofs + len))) {
 			sect[sectors].chip = &cfi->chips[chipnum];
 			sect[sectors].adr = adr;
 			sect[sectors].locked = do_ppb_xxlock(

