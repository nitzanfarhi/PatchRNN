commit 9e09e54fdce83f24d72b2eea57972b8ab54a2293
Author: John Spray <john.spray@redhat.com>
Date:   Thu May 21 00:05:10 2015 +0100

    osdc: handle corruption in journal
    
    Previously we just *detected* it in _is_readable
    and raise a buffer::error.  Now actually catch that
    exception and pass up to outer error handling.
    
    Signed-off-by: John Spray <john.spray@redhat.com>

diff --git a/src/osdc/Journaler.cc b/src/osdc/Journaler.cc
index 5b33eedd2a..148817578b 100644
--- a/src/osdc/Journaler.cc
+++ b/src/osdc/Journaler.cc
@@ -832,7 +832,21 @@ void Journaler::_finish_read(int r, uint64_t offset, bufferlist& bl)
   ldout(cct, 10) << "_finish_read got " << offset << "~" << bl.length() << dendl;
   prefetch_buf[offset].swap(bl);
 
-  _assimilate_prefetch();
+  try {
+    _assimilate_prefetch();
+    // Check the readable-ness of the buffer: do this head because it involves
+    // decoding, and we would like to catch any decode errors here so that
+    // external is_readable() callers don't have to.
+    _is_readable();
+  } catch (const buffer::error &err) {
+    error = -EINVAL;
+    if (on_readable) {
+      C_OnFinisher *f = on_readable;
+      on_readable = 0;
+      f->complete(error);
+    }
+    return;
+  }
   _prefetch();
 }
 
@@ -966,6 +980,12 @@ bool Journaler::_is_readable()
   if (read_pos == write_pos)
     return false;
 
+  // Are we errored?  Stop here to avoid risking
+  // raising decode errors.
+  if (error != 0) {
+    return false;
+  }
+
   // Check if the retrieve bytestream has enough for an entry
   uint64_t need;
   if (journal_stream.readable(read_buf, &need)) {

