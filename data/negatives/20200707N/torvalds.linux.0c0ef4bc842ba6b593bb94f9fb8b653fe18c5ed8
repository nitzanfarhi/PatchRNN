commit 0c0ef4bc842ba6b593bb94f9fb8b653fe18c5ed8
Author: Josef Bacik <jbacik@fb.com>
Date:   Thu Feb 12 09:43:51 2015 -0500

    Btrfs: abort the transaction if we fail to update the free space cache inode
    
    Our gluster boxes were hitting a problem where they'd run out of space when
    updating the block group cache and therefore wouldn't be able to update the free
    space inode.  This is a problem because this is how we invalidate the cache and
    protect ourselves from errors further down the stack, so if this fails we have
    to abort the transaction so we make sure we don't end up with stale free space
    cache.  Thanks,
    
    Signed-off-by: Josef Bacik <jbacik@fb.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index 28ce5c8004d4..92146a5afdc1 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -3208,6 +3208,8 @@ static int cache_save_setup(struct btrfs_block_group_cache *block_group,
 		return 0;
 	}
 
+	if (trans->aborted)
+		return 0;
 again:
 	inode = lookup_free_space_inode(root, block_group, path);
 	if (IS_ERR(inode) && PTR_ERR(inode) != -ENOENT) {
@@ -3243,6 +3245,20 @@ static int cache_save_setup(struct btrfs_block_group_cache *block_group,
 	 */
 	BTRFS_I(inode)->generation = 0;
 	ret = btrfs_update_inode(trans, root, inode);
+	if (ret) {
+		/*
+		 * So theoretically we could recover from this, simply set the
+		 * super cache generation to 0 so we know to invalidate the
+		 * cache, but then we'd have to keep track of the block groups
+		 * that fail this way so we know we _have_ to reset this cache
+		 * before the next commit or risk reading stale cache.  So to
+		 * limit our exposure to horrible edge cases lets just abort the
+		 * transaction, this only happens in really bad situations
+		 * anyway.
+		 */
+		btrfs_abort_transaction(trans, root, ret);
+		goto out_put;
+	}
 	WARN_ON(ret);
 
 	if (i_size_read(inode) > 0) {

