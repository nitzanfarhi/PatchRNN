commit e7b36816566db7d3236bf367ab10b1176c7ccb54
Author: eezstreet <eezstreet@live.com>
Date:   Thu Apr 11 21:26:37 2013 -0400

    Fixed HUGE memory problems with the parser. Fixed issue #81 with this build.

diff --git a/code/cgame/cg_main.cpp b/code/cgame/cg_main.cpp
index b34802e9..76c347af 100644
--- a/code/cgame/cg_main.cpp
+++ b/code/cgame/cg_main.cpp
@@ -1826,8 +1826,10 @@ void CG_StartMusic( qboolean bForceStart ) {
 
 	// start the background music
 	s = (char *)CG_ConfigString( CS_MUSIC );
+	COM_BeginParseSession();
 	Q_strncpyz( parm1, COM_Parse( &s ), sizeof( parm1 ) );
 	Q_strncpyz( parm2, COM_Parse( &s ), sizeof( parm2 ) );
+	COM_EndParseSession();
 
 	cgi_S_StartBackgroundTrack( parm1, parm2, !bForceStart );
 }
@@ -2973,7 +2975,9 @@ void CG_LoadMenus(const char *menuFile)
 
 	while ( 1 ) 
 	{
+		COM_BeginParseSession();
 		token = COM_ParseExt( &p, qtrue );
+		COM_EndParseSession();
 		if( !token || token[0] == 0 || token[0] == '}') 
 		{
 			break;
@@ -2986,7 +2990,10 @@ void CG_LoadMenus(const char *menuFile)
 
 		if (Q_stricmp(token, "loadmenu") == 0) 
 		{
-			if (CG_Load_Menu(&p)) 
+			COM_BeginParseSession();
+			int menuLoad = CG_Load_Menu(&p);
+			COM_EndParseSession();
+			if (menuLoad) 
 			{
 				continue;
 			} 
diff --git a/code/cgame/cg_view.cpp b/code/cgame/cg_view.cpp
index bf7a66be..ff3acb02 100644
--- a/code/cgame/cg_view.cpp
+++ b/code/cgame/cg_view.cpp
@@ -1795,6 +1795,8 @@ static void CG_DrawSkyBoxPortal(void)
 
 	backuprefdef = cg.refdef;
 
+	// asdf --eez
+	COM_BeginParseSession();
 	token = COM_ParseExt(&cstr, qfalse);
 	if (!token || !token[0])
 	{
@@ -1873,6 +1875,7 @@ static void CG_DrawSkyBoxPortal(void)
 		}
 	}
 
+	COM_EndParseSession();
 /*
 	static float lastfov = cg_zoomFov;	// for transitions back from zoomed in modes
 	float fov_x;
diff --git a/code/game/NPC_stats.cpp b/code/game/NPC_stats.cpp
index ab5c342f..3f870e7d 100644
--- a/code/game/NPC_stats.cpp
+++ b/code/game/NPC_stats.cpp
@@ -852,6 +852,7 @@ void G_ParseAnimationEvtFile(int glaIndex, const char* eventsDirectory, int file
 
 
 	// read information for batches of sounds (UPPER or LOWER)
+	COM_BeginParseSession();
 	while ( 1 ) 
 	{
 		// Get base frame of sequence
@@ -872,6 +873,7 @@ void G_ParseAnimationEvtFile(int glaIndex, const char* eventsDirectory, int file
 			ParseAnimationEvtBlock(glaIndex, modelIndex, eventsPath, legsAnimEvents, animations, afileset.legsAnimEventCount, &text_p, bIsFrameSkipped); 
 		}
 	}
+	COM_EndParseSession();
 }
 
 /*
@@ -918,6 +920,7 @@ qboolean G_ParseAnimationFile(int glaIndex, const char *skeletonName, int fileIn
 
 	// Read In Each Token
 	//--------------------
+	COM_BeginParseSession();
 	while(1) 
 	{
 		token = COM_Parse( &text_p );
@@ -1018,6 +1021,7 @@ qboolean G_ParseAnimationFile(int glaIndex, const char *skeletonName, int fileIn
 		animations[animNum].initialLerp = lerp;
 */
 	}
+	COM_EndParseSession();
 
 
 
@@ -1282,7 +1286,10 @@ void NPC_PrecacheAnimationCFG( const char *NPC_type )
 	{
 		token = COM_ParseExt( &p, qtrue );
 		if ( token[0] == 0 )
+		{
+			COM_EndParseSession(  );
 			return;
+		}
 
 		if ( !Q_stricmp( token, NPC_type ) ) 
 		{
@@ -1294,11 +1301,13 @@ void NPC_PrecacheAnimationCFG( const char *NPC_type )
 
 	if ( !p ) 
 	{
+		COM_EndParseSession(  );
 		return;
 	}
 
 	if ( G_ParseLiteral( &p, "{" ) ) 
 	{
+		COM_EndParseSession(  );
 		return;
 	}
 
@@ -1309,6 +1318,7 @@ void NPC_PrecacheAnimationCFG( const char *NPC_type )
 		if ( !token[0] ) 
 		{
 			gi.Printf( S_COLOR_RED"ERROR: unexpected EOF while parsing '%s'\n", NPC_type );
+			COM_EndParseSession(  );
 			return;
 		}
 
@@ -1327,6 +1337,7 @@ void NPC_PrecacheAnimationCFG( const char *NPC_type )
 			//must copy data out of this pointer into a different part of memory because the funcs we're about to call will call COM_ParseExt
 			Q_strncpyz( filename, value, sizeof( filename ), qtrue );
 			G_ParseAnimFileSet( filename );
+			COM_EndParseSession(  );
 			return;
 		}
 
@@ -1365,6 +1376,7 @@ void NPC_PrecacheAnimationCFG( const char *NPC_type )
 			}
 		}
 	}
+	COM_EndParseSession(  );
 }
 
 extern int NPC_WeaponsForTeam( team_t team, int spawnflags, const char *NPC_type );
@@ -1608,7 +1620,10 @@ void CG_NPC_Precache ( gentity_t *spawner )
 	{
 		token = COM_ParseExt( &p, qtrue );
 		if ( token[0] == 0 )
+		{
+			COM_EndParseSession(  );
 			return;
+		}
 
 		if ( !Q_stricmp( token, spawner->NPC_type ) ) 
 		{
@@ -1620,21 +1635,26 @@ void CG_NPC_Precache ( gentity_t *spawner )
 
 	if ( !p ) 
 	{
+		COM_EndParseSession(  );
 		return;
 	}
 
 	if ( G_ParseLiteral( &p, "{" ) ) 
 	{
+		COM_EndParseSession(  );
 		return;
 	}
 
 	// parse the NPC info block
 	while ( 1 ) 
 	{
+		COM_EndParseSession();	// if still in session (or using continue;)
+		COM_BeginParseSession();
 		token = COM_ParseExt( &p, qtrue );
 		if ( !token[0] ) 
 		{
 			gi.Printf( S_COLOR_RED"ERROR: unexpected EOF while parsing '%s'\n", spawner->NPC_type );
+			COM_EndParseSession(  );
 			return;
 		}
 
@@ -1912,6 +1932,8 @@ void CG_NPC_Precache ( gentity_t *spawner )
 	NPC_PrecacheByClassName( spawner->NPC_type );
 
 	CG_RegisterNPCCustomSounds( &ci );
+
+	COM_EndParseSession(  );
 	//CG_RegisterNPCEffects( playerTeam );
 	//FIXME: Look for a "sounds" directory and precache death, pain, alert sounds
 }
@@ -2043,13 +2065,16 @@ qboolean NPC_ParseParms( const char *NPCName, gentity_t *NPC )
 	{
 		p = NPCParms;
 		COM_BeginParseSession();
-
+#ifdef _WIN32
+#pragma region(NPC Stats)
+#endif
 		// look for the right NPC
 		while ( p ) 
 		{
 			token = COM_ParseExt( &p, qtrue );
 			if ( token[0] == 0 )
 			{
+				COM_EndParseSession(  );
 				return qfalse;
 			}
 
@@ -2062,21 +2087,25 @@ qboolean NPC_ParseParms( const char *NPCName, gentity_t *NPC )
 		}
 		if ( !p ) 
 		{
+			COM_EndParseSession(  );
 			return qfalse;
 		}
 
 		if ( G_ParseLiteral( &p, "{" ) ) 
 		{
+			COM_EndParseSession(  );
 			return qfalse;
 		}
 			
 		// parse the NPC info block
 		while ( 1 ) 
 		{
+			COM_BeginParseSession();
 			token = COM_ParseExt( &p, qtrue );
 			if ( !token[0] ) 
 			{
 				gi.Printf( S_COLOR_RED"ERROR: unexpected EOF while parsing '%s'\n", NPCName );
+				COM_EndParseSession(  );
 				return qfalse;
 			}
 
@@ -2088,6 +2117,9 @@ qboolean NPC_ParseParms( const char *NPCName, gentity_t *NPC )
 			// custom color
 			if ( !Q_stricmp( token, "customRGBA" ) ) 
 			{
+
+				// eezstreet TODO: Put these into functions, damn it! They're too big!
+
 				if ( COM_ParseString( &p, &value ) ) 
 				{
 					continue;
@@ -3973,6 +4005,10 @@ qboolean NPC_ParseParms( const char *NPCName, gentity_t *NPC )
 			}
 			SkipRestOfLine( &p );
 		}
+#ifdef _WIN32
+#pragma endregion
+#endif
+		COM_EndParseSession(  );
 	}
 
 	ci->infoValid = qfalse;
diff --git a/code/game/bg_vehicleLoad.c b/code/game/bg_vehicleLoad.c
index 3d6e8cfb..26dd1c2f 100644
--- a/code/game/bg_vehicleLoad.c
+++ b/code/game/bg_vehicleLoad.c
@@ -350,6 +350,7 @@ int VEH_LoadVehWeapon( const char *vehWeaponName )
 		token = COM_ParseExt( &p, qtrue );
 		if ( token[0] == 0 )
 		{
+			COM_EndParseSession(  );
 			return qfalse;
 		}
 
@@ -362,17 +363,20 @@ int VEH_LoadVehWeapon( const char *vehWeaponName )
 	}
 	if ( !p ) 
 	{
+		COM_EndParseSession(  );
 		return qfalse;
 	}
 
 	token = COM_ParseExt( &p, qtrue );
 	if ( token[0] == 0 )
 	{//barf
+		COM_EndParseSession(  );
 		return VEH_WEAPON_NONE;
 	}
 
 	if ( Q_stricmp( token, "{" ) != 0 ) 
 	{
+		COM_EndParseSession(  );
 		return VEH_WEAPON_NONE;
 	}
 	
@@ -384,6 +388,7 @@ int VEH_LoadVehWeapon( const char *vehWeaponName )
 		if ( !token[0] ) 
 		{
 			Com_Printf( S_COLOR_RED"ERROR: unexpected EOF while parsing Vehicle Weapon '%s'\n", vehWeaponName );
+			COM_EndParseSession(  );
 			return VEH_WEAPON_NONE;
 		}
 
@@ -425,6 +430,7 @@ int VEH_LoadVehWeapon( const char *vehWeaponName )
 		trap_S_RegisterSound( "sound/vehicles/common/lockalarm3.wav" );
 #endif
 	}
+	COM_EndParseSession(  );
 	return (numVehicleWeapons++);
 }
 
@@ -1040,6 +1046,7 @@ int VEH_LoadVehicle( const char *vehicleName )
 		token = COM_ParseExt( &p, qtrue );
 		if ( token[0] == 0 )
 		{
+			COM_EndParseSession(  );
 			return VEHICLE_NONE;
 		}
 
@@ -1053,17 +1060,20 @@ int VEH_LoadVehicle( const char *vehicleName )
 
 	if ( !p )
 	{
+		COM_EndParseSession(  );
 		return VEHICLE_NONE;
 	}
 
 	token = COM_ParseExt( &p, qtrue );
 	if ( token[0] == 0 )
 	{//barf
+		COM_EndParseSession(  );
 		return VEHICLE_NONE;
 	}
 
 	if ( Q_stricmp( token, "{" ) != 0 ) 
 	{
+		COM_EndParseSession(  );
 		return VEHICLE_NONE;
 	}
 	
@@ -1076,6 +1086,7 @@ int VEH_LoadVehicle( const char *vehicleName )
 		if ( !token[0] ) 
 		{
 			Com_Printf( S_COLOR_RED"ERROR: unexpected EOF while parsing Vehicle '%s'\n", vehicleName );
+			COM_EndParseSession(  );
 			return VEHICLE_NONE;
 		}
 
@@ -1376,6 +1387,7 @@ int VEH_LoadVehicle( const char *vehicleName )
 	}
 #endif
 
+	COM_EndParseSession(  );
 	return (numVehicles++);
 }
 
diff --git a/code/game/g_client.cpp b/code/game/g_client.cpp
index 7feb78ff..a4517730 100644
--- a/code/game/g_client.cpp
+++ b/code/game/g_client.cpp
@@ -1157,27 +1157,34 @@ qboolean G_SetG2PlayerModelInfo( gentity_t *ent, const char *modelName, const ch
 			p = surfOff;
 			while ( 1 ) 
 			{
+				COM_BeginParseSession();
 				token = COM_ParseExt( &p, qtrue );
 				if ( !token[0] ) 
 				{//reached end of list
+					COM_EndParseSession();
 					break;
 				}
 				//turn off this surf
 				gi.G2API_SetSurfaceOnOff( &ent->ghoul2[ent->playerModel], token, 0x00000002/*G2SURFACEFLAG_OFF*/ );
+				COM_EndParseSession();
 			}
+
 		}
 		if ( surfOn && surfOn[0] )
 		{
 			p = surfOn;
 			while ( 1 )
 			{
+				COM_BeginParseSession();
 				token = COM_ParseExt( &p, qtrue );
 				if ( !token[0] ) 
 				{//reached end of list
+					COM_EndParseSession();
 					break;
 				}
 				//turn on this surf
 				gi.G2API_SetSurfaceOnOff( &ent->ghoul2[ent->playerModel], token, 0 );
+				COM_EndParseSession();
 			}
 		}
 		if ( ent->client->NPC_class == CLASS_IMPERIAL && ent->message )
diff --git a/code/game/g_itemLoad.cpp b/code/game/g_itemLoad.cpp
index f8ef306e..21829d88 100644
--- a/code/game/g_itemLoad.cpp
+++ b/code/game/g_itemLoad.cpp
@@ -690,6 +690,8 @@ static void IT_ParseParms(const char *buffer)
 		 
 	}
 
+	COM_EndParseSession(  );
+
 //	--bg_numItems;
 
 }
diff --git a/code/game/g_spawn.cpp b/code/game/g_spawn.cpp
index 9c0a6459..fb9798f7 100644
--- a/code/game/g_spawn.cpp
+++ b/code/game/g_spawn.cpp
@@ -1209,12 +1209,15 @@ qboolean G_ParseSpawnVars( const char **data ) {
 	numSpawnVarChars = 0;
 
 	// parse the opening brace	
+	COM_BeginParseSession();
 	com_token = COM_Parse( data );
 	if ( !*data ) {
 		// end of spawn string
+		COM_EndParseSession();
 		return qfalse;
 	}
 	if ( com_token[0] != '{' ) {
+		COM_EndParseSession();
 		G_Error( "G_ParseSpawnVars: found %s when expecting {",com_token );
 	}
 
@@ -1226,6 +1229,7 @@ qboolean G_ParseSpawnVars( const char **data ) {
 			break;
 		}
 		if ( !data ) {
+			COM_EndParseSession();
 			G_Error( "G_ParseSpawnVars: EOF without closing brace" );
 		}
 
@@ -1234,12 +1238,15 @@ qboolean G_ParseSpawnVars( const char **data ) {
 		// parse value	
 		com_token = COM_Parse( data );
 		if ( com_token[0] == '}' ) {
+			COM_EndParseSession();
 			G_Error( "G_ParseSpawnVars: closing brace without data" );
 		}
 		if ( !data ) {
+			COM_EndParseSession();
 			G_Error( "G_ParseSpawnVars: EOF without closing brace" );
 		}
 		if ( numSpawnVars == MAX_SPAWN_VARS ) {
+			COM_EndParseSession();
 			G_Error( "G_ParseSpawnVars: MAX_SPAWN_VARS" );
 		}
 		spawnVars[ numSpawnVars ][0] = G_AddSpawnVarToken( keyname );
@@ -1247,6 +1254,7 @@ qboolean G_ParseSpawnVars( const char **data ) {
 		numSpawnVars++;
 	}
 
+	COM_EndParseSession();
 	return qtrue;
 }
 
diff --git a/code/game/g_weaponLoad.cpp b/code/game/g_weaponLoad.cpp
index 75bd66a8..2bec1ebc 100644
--- a/code/game/g_weaponLoad.cpp
+++ b/code/game/g_weaponLoad.cpp
@@ -1329,6 +1329,8 @@ static void WP_ParseParms(const char *buffer)
 		 
 	}
 
+	COM_EndParseSession(  );
+
 }
 
 //--------------------------------------------
diff --git a/code/game/q_shared.cpp b/code/game/q_shared.cpp
index 19b6d503..5bffbb3f 100644
--- a/code/game/q_shared.cpp
+++ b/code/game/q_shared.cpp
@@ -267,6 +267,12 @@ void COM_BeginParseSession( void )
 
 #endif
 
+void COM_EndParseSession( void )
+{
+	// FIXME: I have no idea if I'm doing this right ( :D... )
+	parseDataCount = -1;
+}
+
 int COM_GetCurrentParseLine( int index )
 {
 	if(parseDataCount < 0)
diff --git a/code/game/q_shared.h b/code/game/q_shared.h
index 1e5eab3e..77565a43 100644
--- a/code/game/q_shared.h
+++ b/code/game/q_shared.h
@@ -1179,6 +1179,7 @@ void	 COM_BeginParseSession( bool nested = false );
 #else
 void	 COM_BeginParseSession( void );
 #endif
+void	 COM_EndParseSession( void );
 
 int		 COM_GetCurrentParseLine( void );
 char	*COM_Parse( const char **data_p );
diff --git a/code/game/wp_saberLoad.cpp b/code/game/wp_saberLoad.cpp
index d5c4356e..047529fb 100644
--- a/code/game/wp_saberLoad.cpp
+++ b/code/game/wp_saberLoad.cpp
@@ -537,6 +537,7 @@ qboolean WP_SaberParseParms( const char *SaberName, saberInfo_t *saber, qboolean
 		token = COM_ParseExt( &p, qtrue );
 		if ( token[0] == 0 )
 		{
+			COM_EndParseSession(  );
 			return qfalse;
 		}
 
@@ -549,11 +550,13 @@ qboolean WP_SaberParseParms( const char *SaberName, saberInfo_t *saber, qboolean
 	}
 	if ( !p ) 
 	{
+		COM_EndParseSession(  );
 		return qfalse;
 	}
 
 	if ( G_ParseLiteral( &p, "{" ) ) 
 	{
+		COM_EndParseSession(  );
 		return qfalse;
 	}
 		
@@ -564,6 +567,7 @@ qboolean WP_SaberParseParms( const char *SaberName, saberInfo_t *saber, qboolean
 		if ( !token[0] ) 
 		{
 			gi.Printf( S_COLOR_RED"ERROR: unexpected EOF while parsing '%s'\n", SaberName );
+			COM_EndParseSession(  );
 			return qfalse;
 		}
 
@@ -572,6 +576,10 @@ qboolean WP_SaberParseParms( const char *SaberName, saberInfo_t *saber, qboolean
 			break;
 		}
 
+#ifdef _WIN32
+#pragma region(Saber Parms)
+#endif
+
 		//saber fullName
 		if ( !Q_stricmp( token, "name" ) ) 
 		{
@@ -2421,7 +2429,10 @@ qboolean WP_SaberParseParms( const char *SaberName, saberInfo_t *saber, qboolean
 	{//precache all the sith sword sounds
 		Saber_SithSwordPrecache();
 	}
-
+#ifdef _WIN32
+#pragma endregion
+#endif
+	COM_EndParseSession(  );
 	return qtrue;
 }
 
diff --git a/code/qcommon/cm_shader.cpp b/code/qcommon/cm_shader.cpp
index 99f9cfff..ab911bc0 100644
--- a/code/qcommon/cm_shader.cpp
+++ b/code/qcommon/cm_shader.cpp
@@ -71,6 +71,7 @@ void CM_CreateShaderTextHash(void)
 	CCMShaderText		*shader;
 
 	p = shaderText;
+	COM_BeginParseSession();
 	// look for label
 	while (p) 
 	{
@@ -85,6 +86,7 @@ void CM_CreateShaderTextHash(void)
 
 		SkipBracedSection(&p);
 	}
+	COM_EndParseSession();
 }
 
 /*
@@ -370,10 +372,12 @@ void CM_ParseShader( CCMShader *shader, const char **text )
 {
 	char	*token;
 
+	COM_BeginParseSession();
 	token = COM_ParseExt( text, qtrue );
 	if ( token[0] != '{' )
 	{
 		Com_Printf( S_COLOR_YELLOW "WARNING: expecting '{', found '%s' instead in shader '%s'\n", token, shader->shader );
+		COM_EndParseSession();
 		return;
 	}
 
@@ -383,6 +387,7 @@ void CM_ParseShader( CCMShader *shader, const char **text )
 		if ( !token[0] )
 		{
 			Com_Printf( S_COLOR_YELLOW "WARNING: no concluding '}' in shader %s\n", shader->shader );
+			COM_EndParseSession();
 			return;
 		}
 
@@ -442,6 +447,7 @@ void CM_ParseShader( CCMShader *shader, const char **text )
 			vec3_t				fogColor;
 			if ( !CM_ParseVector( shader, text, 3, fogColor ) ) 
 			{
+				COM_EndParseSession();
 				return;
 			}
 
@@ -458,7 +464,7 @@ void CM_ParseShader( CCMShader *shader, const char **text )
 			continue;
 		}
 	}
-	return;
+	COM_EndParseSession();
 }
 
 /*
diff --git a/code/renderer/tr_bsp.cpp b/code/renderer/tr_bsp.cpp
index e6fac4a0..d5a8cc3f 100644
--- a/code/renderer/tr_bsp.cpp
+++ b/code/renderer/tr_bsp.cpp
@@ -1241,6 +1241,8 @@ void R_LoadEntities( lump_t *l, world_t &worldData ) {
 	world_t	*w;
 	float ambient = 1;
 
+	COM_BeginParseSession();
+
 	w = &worldData;
 	w->lightGridSize[0] = 64;
 	w->lightGridSize[1] = 64;
@@ -1253,6 +1255,7 @@ void R_LoadEntities( lump_t *l, world_t &worldData ) {
 
 	token = COM_ParseExt( &p, qtrue );
 	if (!*token || *token != '{') {
+		COM_EndParseSession();
 		return;
 	}
 
@@ -1327,6 +1330,8 @@ void R_LoadEntities( lump_t *l, world_t &worldData ) {
 	}
 	//both default to 1 so no harm if not present.
 	VectorScale( tr.sunAmbient, ambient, tr.sunAmbient);
+
+	COM_EndParseSession();
 }
 
 
diff --git a/code/renderer/tr_shader.cpp b/code/renderer/tr_shader.cpp
index 7370b03b..b5e9ac00 100644
--- a/code/renderer/tr_shader.cpp
+++ b/code/renderer/tr_shader.cpp
@@ -2348,11 +2348,14 @@ static qboolean ParseShader( const char  **text )
 	shader.needsNormal = false;
 	shader.needsTangent = false;
 #endif
+	COM_BeginParseSession();
+
 
 	token = COM_ParseExt( text, qtrue );
 	if ( token[0] != '{' )
 	{
 		VID_Printf( PRINT_WARNING, "WARNING: expecting '{', found '%s' instead in shader '%s'\n", token, shader.name );
+		COM_EndParseSession();
 		return qfalse;
 	}
 
@@ -2362,6 +2365,7 @@ static qboolean ParseShader( const char  **text )
 		if ( !token[0] )
 		{
 			VID_Printf( PRINT_WARNING, "WARNING: no concluding '}' in shader %s\n", shader.name );
+			COM_EndParseSession();
 			return qfalse;
 		}
 
@@ -2375,6 +2379,7 @@ static qboolean ParseShader( const char  **text )
 		{
 			if ( !ParseStage( &stages[s], text ) )
 			{
+				COM_EndParseSession();
 				return qfalse;
 			}
 			stages[s].active = true;
@@ -2495,6 +2500,7 @@ static qboolean ParseShader( const char  **text )
 		{
 			shader.fogParms = (fogParms_t *)Hunk_Alloc( sizeof( fogParms_t ), qtrue );
 			if ( !ParseVector( text, 3, shader.fogParms->color ) ) {
+				COM_EndParseSession();
 				return qfalse;
 			}
 
@@ -2594,6 +2600,7 @@ Ghoul2 Insert End
 		else
 		{
 			VID_Printf( PRINT_WARNING, "WARNING: unknown general shader parameter '%s' in '%s'\n", token, shader.name );
+			COM_EndParseSession();
 			return qfalse;
 		}
 	}
@@ -2602,11 +2609,13 @@ Ghoul2 Insert End
 	// ignore shaders that don't have any stages, unless it is a sky or fog
 	//
 	if ( s == 0 && !shader.sky && !(shader.contentFlags & CONTENTS_FOG ) ) {
+		COM_EndParseSession();
 		return qfalse;
 	}
 
 	shader.explicitlyDefined = true;
 
+	COM_EndParseSession();
 	return qtrue;
 }
 
@@ -3750,6 +3759,9 @@ static void SetupShaderEntryPtrs(void)
 	if ( !p ) 	
 		return;
 
+	// FIXED this nasty little bugger --eez
+	COM_BeginParseSession();
+
 	while (1) 
 	{
 		token = COM_ParseExt( &p, qtrue );
@@ -3772,6 +3784,8 @@ static void SetupShaderEntryPtrs(void)
 		}
 	}
 
+	COM_EndParseSession(  );
+
 	//VID_Printf( PRINT_DEVELOPER, "SetupShaderEntryPtrs(): Stored %d shader ptrs\n",ShaderEntryPtrs_Size() );
 }
 #endif
diff --git a/code/ui/ui_main.cpp b/code/ui/ui_main.cpp
index a125638d..560abe96 100644
--- a/code/ui/ui_main.cpp
+++ b/code/ui/ui_main.cpp
@@ -2121,6 +2121,7 @@ qboolean UI_ParseAnimationFile( const char *af_filename )
 	}
 
 	// read information for each frame
+	COM_BeginParseSession();
 	while(1) 
 	{
 		token = COM_Parse( &text_p );
@@ -2189,6 +2190,7 @@ qboolean UI_ParseAnimationFile( const char *af_filename )
 
 //		animations[animNum].initialLerp = ceil(1000.0f / fabs(fps));
 	}
+	COM_EndParseSession();
 
 	return qtrue;
 }
@@ -2315,6 +2317,7 @@ static qboolean UI_ParseColorData(char* buf, playerSpeciesInfo_t &species)
 		token = COM_ParseExt( &p, qtrue );	//looking for the shader
 		if ( token[0] == 0 )
 		{
+			COM_EndParseSession(  );
 			return species.ColorCount;
 		}
 		Q_strncpyz( species.ColorShader[species.ColorCount], token, sizeof(species.ColorShader[0]), qtrue );
@@ -2322,6 +2325,7 @@ static qboolean UI_ParseColorData(char* buf, playerSpeciesInfo_t &species)
 		token = COM_ParseExt( &p, qtrue );	//looking for action block {
 		if ( token[0] != '{' )
 		{
+			COM_EndParseSession(  );
 			return qfalse;
 		}
 
@@ -2331,6 +2335,7 @@ static qboolean UI_ParseColorData(char* buf, playerSpeciesInfo_t &species)
 		{
 			if ( token[0] == 0)
 			{	//EOF
+				COM_EndParseSession(  );
 				return qfalse;
 			}
 			assert(species.ColorCount < sizeof(species.ColorActionText)/sizeof(species.ColorActionText[0]) );
@@ -2340,6 +2345,7 @@ static qboolean UI_ParseColorData(char* buf, playerSpeciesInfo_t &species)
 		}
 		species.ColorCount++;	//next color please
 	}
+	COM_EndParseSession(  );
 	return qtrue;//never get here
 }
 
@@ -2647,24 +2653,12 @@ void _UI_Init( qboolean inGameLoad )
 		UI_LoadMenus(menuSet, qtrue);
 	}
 
-#ifdef FINAL_BUILD
-	Com_Printf("UI_LoadMenus completed\n");
-#endif
-
 	Menus_CloseAll();
 
-#ifdef FINAL_BUILD
-	Com_Printf("Menus_CloseAll completed\n");
-#endif
-
 	uiInfo.uiDC.whiteShader = ui.R_RegisterShaderNoMip( "white" );
 
 	AssetCache();
 
-#ifdef FINAL_BUILD
-	Com_Printf("AssetCache() completed\n");
-#endif
-
 	uis.debugMode = qfalse;
 	
 	// sets defaults for ui temp cvars
@@ -2689,10 +2683,6 @@ void _UI_Init( qboolean inGameLoad )
 
 	trap_S_RegisterSound("sound/interface/weapon_deselect", qfalse);
 
-#ifdef FINAL_BUILD
-	Com_Printf("_UI_Init completed\n");
-#endif
-
 }
 
 
@@ -2817,8 +2807,10 @@ Load_Menu
 qboolean Load_Menu(const char **holdBuffer) 
 {
 	const char	*token2;
-
+	
+	COM_BeginParseSession();
 	token2 = COM_ParseExt( holdBuffer, qtrue );
+	COM_EndParseSession();
 
 	if (!token2[0])
 	{
@@ -2832,7 +2824,9 @@ qboolean Load_Menu(const char **holdBuffer)
 
 	while ( 1 ) 
 	{
+		COM_BeginParseSession();
 		token2 = COM_ParseExt( holdBuffer, qtrue );
+		COM_EndParseSession();
 
 		if ((!token2) || (token2 == 0))
 		{
@@ -2895,7 +2889,9 @@ void UI_LoadMenus(const char *menuFile, qboolean reset)
 	holdBuffer = buffer;
 	while ( 1 ) 
 	{
+		COM_BeginParseSession();
 		token2 = COM_ParseExt( &holdBuffer, qtrue );
+		COM_EndParseSession();
 		if (!*token2)
 		{
 			break;
@@ -3004,7 +3000,7 @@ qboolean Asset_Parse(char **buffer)
     
 	while ( 1 ) 
 	{
-
+		COM_BeginParseSession();		// HACK
 		token = PC_ParseExt();
 
 		if (!token)
diff --git a/code/ui/ui_saber.cpp b/code/ui/ui_saber.cpp
index ad0d8291..420373d1 100644
--- a/code/ui/ui_saber.cpp
+++ b/code/ui/ui_saber.cpp
@@ -110,6 +110,7 @@ qboolean UI_SaberParseParm( const char *saberName, const char *parmname, char *s
 		token = COM_ParseExt( &p, qtrue );
 		if ( token[0] == 0 )
 		{
+			COM_EndParseSession(  );
 			return qfalse;
 		}
 
@@ -122,11 +123,13 @@ qboolean UI_SaberParseParm( const char *saberName, const char *parmname, char *s
 	}
 	if ( !p ) 
 	{
+		COM_EndParseSession(  );
 		return qfalse;
 	}
 
 	if ( UI_ParseLiteral( &p, "{" ) ) 
 	{
+		COM_EndParseSession(  );
 		return qfalse;
 	}
 		
@@ -137,6 +140,7 @@ qboolean UI_SaberParseParm( const char *saberName, const char *parmname, char *s
 		if ( !token[0] ) 
 		{
 			ui.Printf( S_COLOR_RED"ERROR: unexpected EOF while parsing '%s'\n", saberName );
+			COM_EndParseSession(  );
 			return qfalse;
 		}
 
@@ -152,6 +156,7 @@ qboolean UI_SaberParseParm( const char *saberName, const char *parmname, char *s
 				continue;
 			}
 			strcpy( saberData, value );
+			COM_EndParseSession(  );
 			return qtrue;
 		}
 
@@ -159,6 +164,7 @@ qboolean UI_SaberParseParm( const char *saberName, const char *parmname, char *s
 		continue;
 	}
 
+	COM_EndParseSession(  );
 	return qfalse;
 }
 
diff --git a/code/ui/ui_shared.cpp b/code/ui/ui_shared.cpp
index 91319da0..2b14a791 100644
--- a/code/ui/ui_shared.cpp
+++ b/code/ui/ui_shared.cpp
@@ -4953,6 +4953,7 @@ qboolean Item_Parse(itemDef_t *item)
 
 	while ( 1 ) 
 	{
+		COM_BeginParseSession();			// HACK
 		if (PC_ParseString(&token))
 		{
 			PC_ParseWarning("End of file inside menu item");
@@ -5217,6 +5218,7 @@ void Item_RunScript(itemDef_t *item, const char *s)
 		{
 			const char *command;
 			// expect command then arguments, ; ends command, NULL ends script
+			COM_BeginParseSession();			// HACK
 			if (!String_Parse(&p, &command)) 
 			{
 				return;
@@ -6161,6 +6163,7 @@ qboolean Item_EnableShowViaCvar(itemDef_t *item, int flag)
 		{
 			const char *val;
 			// expect value then ; or NULL, NULL ends list
+			COM_BeginParseSession();			// HACK HACK HACK!!
 			if (!String_Parse(&p, &val)) 
 			{
 				return (item->cvarFlags & flag) ? qfalse : qtrue;
diff --git a/codeJK2/game/NPC_stats.cpp b/codeJK2/game/NPC_stats.cpp
index e4bb67ba..78eead62 100644
--- a/codeJK2/game/NPC_stats.cpp
+++ b/codeJK2/game/NPC_stats.cpp
@@ -595,7 +595,9 @@ void NPC_PrecacheAnimationCFG( const char *NPC_type )
 	{
 		token = COM_ParseExt( &p, qtrue );
 		if ( token[0] == 0 )
+		{
 			return;
+		}
 
 		if ( !Q_stricmp( token, NPC_type ) ) 
 		{
@@ -744,7 +746,9 @@ void NPC_Precache ( gentity_t *spawner )
 	{
 		token = COM_ParseExt( &p, qtrue );
 		if ( token[0] == 0 )
+		{
 			return;
+		}
 
 		if ( !Q_stricmp( token, spawner->NPC_type ) ) 
 		{
@@ -961,6 +965,7 @@ void NPC_Precache ( gentity_t *spawner )
 
 	CG_RegisterNPCCustomSounds( &ci );
 	CG_RegisterNPCEffects( playerTeam );
+
 	//FIXME: Look for a "sounds" directory and precache death, pain, alert sounds
 }
 
diff --git a/codeJK2/game/g_itemLoad.cpp b/codeJK2/game/g_itemLoad.cpp
index f3506d91..a1256438 100644
--- a/codeJK2/game/g_itemLoad.cpp
+++ b/codeJK2/game/g_itemLoad.cpp
@@ -657,7 +657,6 @@ static void IT_ParseParms(const char *buffer)
 		}
 		 
 	}
-
 //	--bg_numItems;
 
 }

