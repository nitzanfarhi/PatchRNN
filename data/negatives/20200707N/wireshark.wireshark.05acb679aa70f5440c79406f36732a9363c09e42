commit 05acb679aa70f5440c79406f36732a9363c09e42
Author: Alexis La Goutte <alexis.lagoutte@gmail.com>
Date:   Sun Nov 16 16:28:51 2014 +0100

    mcast_stream: fix indent (use 4 spaces)
    
    Add also modelines info
    
    Change-Id: Idea65bfa25ce8a379c590074ab89a06f935c6648
    Reviewed-on: https://code.wireshark.org/review/5344
    Reviewed-by: Michael Mann <mmann78@netscape.net>

diff --git a/ui/gtk/mcast_stream.c b/ui/gtk/mcast_stream.c
index 2edafcae89..f1514bd7e6 100644
--- a/ui/gtk/mcast_stream.c
+++ b/ui/gtk/mcast_stream.c
@@ -75,7 +75,7 @@ static void    slidingwindow(mcast_stream_info_t *strinfo, packet_info *pinfo);
 /****************************************************************************/
 /* the one and only global mcaststream_tapinfo_t structure */
 static mcaststream_tapinfo_t the_tapinfo_struct =
-	{0, NULL, 0, NULL, 0, FALSE};
+    {0, NULL, 0, NULL, 0, FALSE};
 
 
 /****************************************************************************/
@@ -83,20 +83,20 @@ static mcaststream_tapinfo_t the_tapinfo_struct =
 static gint
 mcast_stream_info_cmp(gconstpointer aa, gconstpointer bb)
 {
-	const struct _mcast_stream_info* a = (const struct _mcast_stream_info *)aa;
-	const struct _mcast_stream_info* b = (const struct _mcast_stream_info *)bb;
-
-        if (a==b)
-                return 0;
-        if (a==NULL || b==NULL)
-                return 1;
-        if (ADDRESSES_EQUAL(&(a->src_addr), &(b->src_addr))
-                && (a->src_port == b->src_port)
-                && ADDRESSES_EQUAL(&(a->dest_addr), &(b->dest_addr))
-                && (a->dest_port == b->dest_port))
-                return 0;
-        else
-                return 1;
+    const struct _mcast_stream_info* a = (const struct _mcast_stream_info *)aa;
+    const struct _mcast_stream_info* b = (const struct _mcast_stream_info *)bb;
+
+    if (a==b)
+        return 0;
+    if (a==NULL || b==NULL)
+        return 1;
+    if (ADDRESSES_EQUAL(&(a->src_addr), &(b->src_addr))
+        && (a->src_port == b->src_port)
+        && ADDRESSES_EQUAL(&(a->dest_addr), &(b->dest_addr))
+        && (a->dest_port == b->dest_port))
+        return 0;
+    else
+        return 1;
 
 }
 
@@ -106,37 +106,37 @@ mcast_stream_info_cmp(gconstpointer aa, gconstpointer bb)
 void
 mcaststream_reset(mcaststream_tapinfo_t *tapinfo)
 {
-	GList* list;
-
-	/* free the data items first */
-	list = g_list_first(tapinfo->strinfo_list);
-	while (list)
-	{
-		/* XYZ I don't know how to clean this */
-		/*g_free(list->element.buff); */
-		g_free(list->data);
-		list = g_list_next(list);
-	}
-	g_list_free(tapinfo->strinfo_list);
-	tapinfo->strinfo_list = NULL;
-
-	/* XYZ and why does the line below causes a crach? */
-	/*g_free(tapinfo->allstreams->element.buff);*/
-	g_free(tapinfo->allstreams);
-	tapinfo->allstreams = NULL;
-
-	tapinfo->nstreams = 0;
-	tapinfo->npackets = 0;
-
-	++(tapinfo->launch_count);
-
-	return;
+    GList* list;
+
+    /* free the data items first */
+    list = g_list_first(tapinfo->strinfo_list);
+    while (list)
+    {
+        /* XYZ I don't know how to clean this */
+        /*g_free(list->element.buff); */
+        g_free(list->data);
+        list = g_list_next(list);
+    }
+    g_list_free(tapinfo->strinfo_list);
+    tapinfo->strinfo_list = NULL;
+
+    /* XYZ and why does the line below causes a crach? */
+    /*g_free(tapinfo->allstreams->element.buff);*/
+    g_free(tapinfo->allstreams);
+    tapinfo->allstreams = NULL;
+
+    tapinfo->nstreams = 0;
+    tapinfo->npackets = 0;
+
+    ++(tapinfo->launch_count);
+
+    return;
 }
 
 static void
 mcaststream_reset_cb(void *arg)
 {
-	mcaststream_reset((mcaststream_tapinfo_t *)arg);
+    mcaststream_reset((mcaststream_tapinfo_t *)arg);
 }
 
 /****************************************************************************/
@@ -145,10 +145,10 @@ static void
 mcaststream_draw(void *arg _U_)
 {
 /* XXX: see mcaststream_on_update in mcast_streams_dlg.c for comments
-	g_signal_emit_by_name(top_level, "signal_mcaststream_update");
+    g_signal_emit_by_name(top_level, "signal_mcaststream_update");
 */
-	mcaststream_dlg_update(the_tapinfo_struct.strinfo_list);
-	return;
+    mcaststream_dlg_update(the_tapinfo_struct.strinfo_list);
+    return;
 }
 
 
@@ -158,137 +158,137 @@ mcaststream_draw(void *arg _U_)
 static int
 mcaststream_packet(void *arg, packet_info *pinfo, epan_dissect_t *edt _U_, const void *arg2 _U_)
 {
-	mcaststream_tapinfo_t *tapinfo = (mcaststream_tapinfo_t *)arg;
-        mcast_stream_info_t tmp_strinfo;
-        mcast_stream_info_t *strinfo = NULL;
-        GList* list;
-	float deltatime;
-
-        /* gather infos on the stream this packet is part of */
-        COPY_ADDRESS(&(tmp_strinfo.src_addr), &(pinfo->src));
-        tmp_strinfo.src_port = pinfo->srcport;
-        COPY_ADDRESS(&(tmp_strinfo.dest_addr), &(pinfo->dst));
-        tmp_strinfo.dest_port = pinfo->destport;
-
-	/* first we ignore non multicast packets; we filter out only those ethernet packets
-	 * which start with the 01:00:5E multicast address (for IPv4) and 33:33 multicast
-	 * address (for IPv6).
-	 */
-	if ((pinfo->dl_dst.type != AT_ETHER) ||
-	    ((g_ascii_strncasecmp("01005E", bytes_to_ep_str((const guint8 *)pinfo->dl_dst.data, pinfo->dl_dst.len), 6) != 0) &&
-	     (g_ascii_strncasecmp("3333", bytes_to_ep_str((const guint8 *)pinfo->dl_dst.data, pinfo->dl_dst.len), 4) != 0)) )
-		return 0;
-
-	/* check whether we already have a stream with these parameters in the list */
-	list = g_list_first(tapinfo->strinfo_list);
-	while (list)
-	{
-		if (mcast_stream_info_cmp(&tmp_strinfo, (mcast_stream_info_t*)(list->data))==0)
-		{
-			strinfo = (mcast_stream_info_t*)(list->data);  /*found!*/
-			break;
-		}
-		list = g_list_next(list);
-	}
-
-	/* not in the list? then create a new entry */
-	if (!strinfo) {
-		/*printf("nov sip %s sp %d dip %s dp %d\n", g_strdup(ep_address_to_display(&(pinfo->src))),
-			pinfo->srcport, g_strdup(ep_address_to_display(&(pinfo->dst))), pinfo->destport);*/
-		tmp_strinfo.npackets = 0;
-		tmp_strinfo.apackets = 0;
-		tmp_strinfo.first_frame_num = pinfo->fd->num;
-		tmp_strinfo.start_sec = (guint32) pinfo->fd->abs_ts.secs;
-		tmp_strinfo.start_usec = pinfo->fd->abs_ts.nsecs/1000;
-		tmp_strinfo.start_rel_sec = (guint32) pinfo->rel_ts.secs;
-		tmp_strinfo.start_rel_usec = pinfo->rel_ts.nsecs/1000;
-		tmp_strinfo.vlan_id = 0;
-
-		/* reset Mcast stats */
-		tmp_strinfo.average_bw = 0;
-		tmp_strinfo.total_bytes = 0;
-
-		/* reset slidingwindow and buffer parameters */
-		tmp_strinfo.element.buff = (struct timeval *)g_malloc(buffsize * sizeof(struct timeval));
-		tmp_strinfo.element.first=0;
-		tmp_strinfo.element.last=0;
-		tmp_strinfo.element.burstsize=1;
-		tmp_strinfo.element.topburstsize=1;
-		tmp_strinfo.element.numbursts=0;
-		tmp_strinfo.element.burststatus=0;
-		tmp_strinfo.element.count=1;
-		tmp_strinfo.element.buffusage=pinfo->fd->pkt_len;
-		tmp_strinfo.element.topbuffusage=pinfo->fd->pkt_len;
-		tmp_strinfo.element.numbuffalarms=0;
-		tmp_strinfo.element.buffstatus=0;
-		tmp_strinfo.element.maxbw=0;
-
-		strinfo = (mcast_stream_info_t *)g_malloc(sizeof(mcast_stream_info_t));
-		*strinfo = tmp_strinfo;  /* memberwise copy of struct */
-		tapinfo->strinfo_list = g_list_append(tapinfo->strinfo_list, strinfo);
-		strinfo->element.buff = (struct timeval *)g_malloc(buffsize * sizeof(struct timeval));
-
-		/* set time with the first packet */
-		if (tapinfo->npackets == 0) {
-			tapinfo->allstreams = (mcast_stream_info_t *)g_malloc(sizeof(mcast_stream_info_t));
-			tapinfo->allstreams->element.buff =
-					(struct timeval *)g_malloc(buffsize * sizeof(struct timeval));
-			tapinfo->allstreams->start_rel_sec = (guint32) pinfo->rel_ts.secs;
-			tapinfo->allstreams->start_rel_usec = pinfo->rel_ts.nsecs/1000;
-			tapinfo->allstreams->total_bytes = 0;
-			tapinfo->allstreams->element.first=0;
-			tapinfo->allstreams->element.last=0;
-			tapinfo->allstreams->element.burstsize=1;
-			tapinfo->allstreams->element.topburstsize=1;
-			tapinfo->allstreams->element.numbursts=0;
-			tapinfo->allstreams->element.burststatus=0;
-			tapinfo->allstreams->element.count=1;
-			tapinfo->allstreams->element.buffusage=pinfo->fd->pkt_len;
-			tapinfo->allstreams->element.topbuffusage=pinfo->fd->pkt_len;
-			tapinfo->allstreams->element.numbuffalarms=0;
-			tapinfo->allstreams->element.buffstatus=0;
-			tapinfo->allstreams->element.maxbw=0;
-		}
-	}
-
-	/* time between first and last packet in the group */
-	strinfo->stop_rel_sec = (guint32) pinfo->rel_ts.secs;
-	strinfo->stop_rel_usec = pinfo->rel_ts.nsecs/1000;
-	deltatime = ((float)((strinfo->stop_rel_sec * 1000000 + strinfo->stop_rel_usec)
-					- (strinfo->start_rel_sec*1000000 + strinfo->start_rel_usec)))/1000000;
-
-	/* calculate average bandwidth for this stream */
-	strinfo->total_bytes = strinfo->total_bytes + pinfo->fd->pkt_len;
-	if (deltatime > 0)
-		strinfo->average_bw = (((float)(strinfo->total_bytes*8) / deltatime) / 1000000);
-
-	/* increment the packets counter for this stream and calculate average pps */
-	++(strinfo->npackets);
-	strinfo->apackets = (guint32) (strinfo->npackets / deltatime);
-
-	/* time between first and last packet in any group */
-	tapinfo->allstreams->stop_rel_sec = (guint32) pinfo->rel_ts.secs;
-	tapinfo->allstreams->stop_rel_usec = pinfo->rel_ts.nsecs/1000;
-	deltatime = ((float)((tapinfo->allstreams->stop_rel_sec * 1000000 + tapinfo->allstreams->stop_rel_usec)
-		- (tapinfo->allstreams->start_rel_sec*1000000 + tapinfo->allstreams->start_rel_usec)))/1000000;
-
-	/* increment the packets counter of all streams */
-	++(tapinfo->npackets);
-
-	/* calculate average bandwidth for all streams */
-	tapinfo->allstreams->total_bytes = tapinfo->allstreams->total_bytes + pinfo->fd->pkt_len;
-	if (deltatime > 0)
-		tapinfo->allstreams->average_bw = (((float)(tapinfo->allstreams->total_bytes *8) / deltatime) / 1000000);
-
-	/* sliding window and buffercalc for this group*/
-	slidingwindow(strinfo, pinfo);
-	buffusagecalc(strinfo, pinfo, mcast_stream_emptyspeed*1000);
-	/* sliding window and buffercalc for all groups */
-	slidingwindow(tapinfo->allstreams, pinfo);
-	buffusagecalc(tapinfo->allstreams, pinfo, mcast_stream_cumulemptyspeed*1000);
-	/* end of sliding window */
-
-	return 1;  /* refresh output */
+    mcaststream_tapinfo_t *tapinfo = (mcaststream_tapinfo_t *)arg;
+    mcast_stream_info_t tmp_strinfo;
+    mcast_stream_info_t *strinfo = NULL;
+    GList* list;
+    float deltatime;
+
+    /* gather infos on the stream this packet is part of */
+    COPY_ADDRESS(&(tmp_strinfo.src_addr), &(pinfo->src));
+    tmp_strinfo.src_port = pinfo->srcport;
+    COPY_ADDRESS(&(tmp_strinfo.dest_addr), &(pinfo->dst));
+    tmp_strinfo.dest_port = pinfo->destport;
+
+    /* first we ignore non multicast packets; we filter out only those ethernet packets
+     * which start with the 01:00:5E multicast address (for IPv4) and 33:33 multicast
+     * address (for IPv6).
+     */
+    if ((pinfo->dl_dst.type != AT_ETHER) ||
+        ((g_ascii_strncasecmp("01005E", bytes_to_ep_str((const guint8 *)pinfo->dl_dst.data, pinfo->dl_dst.len), 6) != 0) &&
+         (g_ascii_strncasecmp("3333", bytes_to_ep_str((const guint8 *)pinfo->dl_dst.data, pinfo->dl_dst.len), 4) != 0)) )
+        return 0;
+
+    /* check whether we already have a stream with these parameters in the list */
+    list = g_list_first(tapinfo->strinfo_list);
+    while (list)
+    {
+        if (mcast_stream_info_cmp(&tmp_strinfo, (mcast_stream_info_t*)(list->data))==0)
+        {
+            strinfo = (mcast_stream_info_t*)(list->data);  /*found!*/
+            break;
+        }
+        list = g_list_next(list);
+    }
+
+    /* not in the list? then create a new entry */
+    if (!strinfo) {
+        /*printf("nov sip %s sp %d dip %s dp %d\n", g_strdup(ep_address_to_display(&(pinfo->src))),
+            pinfo->srcport, g_strdup(ep_address_to_display(&(pinfo->dst))), pinfo->destport);*/
+        tmp_strinfo.npackets = 0;
+        tmp_strinfo.apackets = 0;
+        tmp_strinfo.first_frame_num = pinfo->fd->num;
+        tmp_strinfo.start_sec = (guint32) pinfo->fd->abs_ts.secs;
+        tmp_strinfo.start_usec = pinfo->fd->abs_ts.nsecs/1000;
+        tmp_strinfo.start_rel_sec = (guint32) pinfo->rel_ts.secs;
+        tmp_strinfo.start_rel_usec = pinfo->rel_ts.nsecs/1000;
+        tmp_strinfo.vlan_id = 0;
+
+        /* reset Mcast stats */
+        tmp_strinfo.average_bw = 0;
+        tmp_strinfo.total_bytes = 0;
+
+        /* reset slidingwindow and buffer parameters */
+        tmp_strinfo.element.buff = (struct timeval *)g_malloc(buffsize * sizeof(struct timeval));
+        tmp_strinfo.element.first=0;
+        tmp_strinfo.element.last=0;
+        tmp_strinfo.element.burstsize=1;
+        tmp_strinfo.element.topburstsize=1;
+        tmp_strinfo.element.numbursts=0;
+        tmp_strinfo.element.burststatus=0;
+        tmp_strinfo.element.count=1;
+        tmp_strinfo.element.buffusage=pinfo->fd->pkt_len;
+        tmp_strinfo.element.topbuffusage=pinfo->fd->pkt_len;
+        tmp_strinfo.element.numbuffalarms=0;
+        tmp_strinfo.element.buffstatus=0;
+        tmp_strinfo.element.maxbw=0;
+
+        strinfo = (mcast_stream_info_t *)g_malloc(sizeof(mcast_stream_info_t));
+        *strinfo = tmp_strinfo;  /* memberwise copy of struct */
+        tapinfo->strinfo_list = g_list_append(tapinfo->strinfo_list, strinfo);
+        strinfo->element.buff = (struct timeval *)g_malloc(buffsize * sizeof(struct timeval));
+
+        /* set time with the first packet */
+        if (tapinfo->npackets == 0) {
+            tapinfo->allstreams = (mcast_stream_info_t *)g_malloc(sizeof(mcast_stream_info_t));
+            tapinfo->allstreams->element.buff =
+                    (struct timeval *)g_malloc(buffsize * sizeof(struct timeval));
+            tapinfo->allstreams->start_rel_sec = (guint32) pinfo->rel_ts.secs;
+            tapinfo->allstreams->start_rel_usec = pinfo->rel_ts.nsecs/1000;
+            tapinfo->allstreams->total_bytes = 0;
+            tapinfo->allstreams->element.first=0;
+            tapinfo->allstreams->element.last=0;
+            tapinfo->allstreams->element.burstsize=1;
+            tapinfo->allstreams->element.topburstsize=1;
+            tapinfo->allstreams->element.numbursts=0;
+            tapinfo->allstreams->element.burststatus=0;
+            tapinfo->allstreams->element.count=1;
+            tapinfo->allstreams->element.buffusage=pinfo->fd->pkt_len;
+            tapinfo->allstreams->element.topbuffusage=pinfo->fd->pkt_len;
+            tapinfo->allstreams->element.numbuffalarms=0;
+            tapinfo->allstreams->element.buffstatus=0;
+            tapinfo->allstreams->element.maxbw=0;
+        }
+    }
+
+    /* time between first and last packet in the group */
+    strinfo->stop_rel_sec = (guint32) pinfo->rel_ts.secs;
+    strinfo->stop_rel_usec = pinfo->rel_ts.nsecs/1000;
+    deltatime = ((float)((strinfo->stop_rel_sec * 1000000 + strinfo->stop_rel_usec)
+                    - (strinfo->start_rel_sec*1000000 + strinfo->start_rel_usec)))/1000000;
+
+    /* calculate average bandwidth for this stream */
+    strinfo->total_bytes = strinfo->total_bytes + pinfo->fd->pkt_len;
+    if (deltatime > 0)
+        strinfo->average_bw = (((float)(strinfo->total_bytes*8) / deltatime) / 1000000);
+
+    /* increment the packets counter for this stream and calculate average pps */
+    ++(strinfo->npackets);
+    strinfo->apackets = (guint32) (strinfo->npackets / deltatime);
+
+    /* time between first and last packet in any group */
+    tapinfo->allstreams->stop_rel_sec = (guint32) pinfo->rel_ts.secs;
+    tapinfo->allstreams->stop_rel_usec = pinfo->rel_ts.nsecs/1000;
+    deltatime = ((float)((tapinfo->allstreams->stop_rel_sec * 1000000 + tapinfo->allstreams->stop_rel_usec)
+        - (tapinfo->allstreams->start_rel_sec*1000000 + tapinfo->allstreams->start_rel_usec)))/1000000;
+
+    /* increment the packets counter of all streams */
+    ++(tapinfo->npackets);
+
+    /* calculate average bandwidth for all streams */
+    tapinfo->allstreams->total_bytes = tapinfo->allstreams->total_bytes + pinfo->fd->pkt_len;
+    if (deltatime > 0)
+        tapinfo->allstreams->average_bw = (((float)(tapinfo->allstreams->total_bytes *8) / deltatime) / 1000000);
+
+    /* sliding window and buffercalc for this group*/
+    slidingwindow(strinfo, pinfo);
+    buffusagecalc(strinfo, pinfo, mcast_stream_emptyspeed*1000);
+    /* sliding window and buffercalc for all groups */
+    slidingwindow(tapinfo->allstreams, pinfo);
+    buffusagecalc(tapinfo->allstreams, pinfo, mcast_stream_cumulemptyspeed*1000);
+    /* end of sliding window */
+
+    return 1;  /* refresh output */
 
 }
 
@@ -297,14 +297,14 @@ mcaststream_packet(void *arg, packet_info *pinfo, epan_dissect_t *edt _U_, const
 void
 mcaststream_scan(void)
 {
-	gboolean was_registered = the_tapinfo_struct.is_registered;
-	if (!the_tapinfo_struct.is_registered)
-		register_tap_listener_mcast_stream();
+    gboolean was_registered = the_tapinfo_struct.is_registered;
+    if (!the_tapinfo_struct.is_registered)
+        register_tap_listener_mcast_stream();
 
-	cf_retap_packets(&cfile);
+    cf_retap_packets(&cfile);
 
-	if (!was_registered)
-		remove_tap_listener_mcast_stream();
+    if (!was_registered)
+        remove_tap_listener_mcast_stream();
 }
 
 
@@ -312,7 +312,7 @@ mcaststream_scan(void)
 const mcaststream_tapinfo_t *
 mcaststream_get_info(void)
 {
-	return &the_tapinfo_struct;
+    return &the_tapinfo_struct;
 }
 
 
@@ -324,11 +324,11 @@ mcaststream_get_info(void)
 void
 remove_tap_listener_mcast_stream(void)
 {
-	if (the_tapinfo_struct.is_registered) {
-		remove_tap_listener(&the_tapinfo_struct);
+    if (the_tapinfo_struct.is_registered) {
+        remove_tap_listener(&the_tapinfo_struct);
 
-		the_tapinfo_struct.is_registered = FALSE;
-	}
+        the_tapinfo_struct.is_registered = FALSE;
+    }
 }
 
 
@@ -336,21 +336,21 @@ remove_tap_listener_mcast_stream(void)
 void
 register_tap_listener_mcast_stream(void)
 {
-	GString *error_string;
-	if (!the_tapinfo_struct.is_registered) {
-		error_string = register_tap_listener("udp", &the_tapinfo_struct,
-			NULL, 0, mcaststream_reset_cb, mcaststream_packet,
-			mcaststream_draw);
-
-		if (error_string != NULL) {
-			simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,
-				      "%s", error_string->str);
-			g_string_free(error_string, TRUE);
-			exit(1);
-		}
-
-		the_tapinfo_struct.is_registered = TRUE;
-	}
+    GString *error_string;
+    if (!the_tapinfo_struct.is_registered) {
+        error_string = register_tap_listener("udp", &the_tapinfo_struct,
+            NULL, 0, mcaststream_reset_cb, mcaststream_packet,
+            mcaststream_draw);
+
+        if (error_string != NULL) {
+            simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,
+                          "%s", error_string->str);
+            g_string_free(error_string, TRUE);
+            exit(1);
+        }
+
+        the_tapinfo_struct.is_registered = TRUE;
+    }
 }
 
 /*******************************************************************************/
@@ -360,103 +360,115 @@ register_tap_listener_mcast_stream(void)
 static guint16
 comparetimes(struct timeval *t1, struct timeval *t2, guint16 burstint_lcl)
 {
-	if(((t2->tv_sec - t1->tv_sec)*1000 + (t2->tv_usec - t1->tv_usec)/1000) > burstint_lcl){
-		return 1;
-	} else{
-		return 0;
-	}
+    if(((t2->tv_sec - t1->tv_sec)*1000 + (t2->tv_usec - t1->tv_usec)/1000) > burstint_lcl){
+        return 1;
+    } else{
+        return 0;
+    }
 }
 
 /* calculate buffer usage */
 static void
 buffusagecalc(mcast_stream_info_t *strinfo, packet_info *pinfo, double emptyspeed_lcl)
 {
-	time_t sec=0;
-	gint32 usec=0, cur, prev;
-	struct timeval *buffer;
-	double timeelapsed;
-
-	buffer = strinfo->element.buff;
-	cur = strinfo->element.last;
-	if(cur == 0){
-		cur = buffsize - 1;
-		prev = cur - 1;
-	} else if(cur == 1){
-		prev = buffsize - 1;
-		cur = 0;
-	} else{
-		cur=cur-1;
-		prev=cur-1;
-	}
-
-	sec = buffer[cur].tv_sec - buffer[prev].tv_sec;
-	usec = (gint32)buffer[cur].tv_usec - (gint32)buffer[prev].tv_usec;
-	timeelapsed = (double)usec/1000000 + (double)sec;
-
-	/* bytes added to buffer */
-	strinfo->element.buffusage+=pinfo->fd->pkt_len;
-
-	/* bytes cleared from buffer */
-	strinfo->element.buffusage-= (guint32) (timeelapsed * emptyspeed_lcl / 8);
-
-	if(strinfo->element.buffusage < 0) strinfo->element.buffusage=0;
-	if(strinfo->element.buffusage > strinfo->element.topbuffusage)
-		strinfo->element.topbuffusage = strinfo->element.buffusage;
-	/* check for buffer losses */
-	if((strinfo->element.buffusage >= mcast_stream_bufferalarm) && (strinfo->element.buffstatus == 0)){
-		strinfo->element.buffstatus = 1;
-		strinfo->element.numbuffalarms++;
-	} else if(strinfo->element.buffusage < mcast_stream_bufferalarm){
-		strinfo->element.buffstatus = 0;
-	}
-
-	return;
+    time_t sec=0;
+    gint32 usec=0, cur, prev;
+    struct timeval *buffer;
+    double timeelapsed;
+
+    buffer = strinfo->element.buff;
+    cur = strinfo->element.last;
+    if(cur == 0){
+        cur = buffsize - 1;
+        prev = cur - 1;
+    } else if(cur == 1){
+        prev = buffsize - 1;
+        cur = 0;
+    } else{
+        cur=cur-1;
+        prev=cur-1;
+    }
+
+    sec = buffer[cur].tv_sec - buffer[prev].tv_sec;
+    usec = (gint32)buffer[cur].tv_usec - (gint32)buffer[prev].tv_usec;
+    timeelapsed = (double)usec/1000000 + (double)sec;
+
+    /* bytes added to buffer */
+    strinfo->element.buffusage+=pinfo->fd->pkt_len;
+
+    /* bytes cleared from buffer */
+    strinfo->element.buffusage-= (guint32) (timeelapsed * emptyspeed_lcl / 8);
+
+    if(strinfo->element.buffusage < 0) strinfo->element.buffusage=0;
+    if(strinfo->element.buffusage > strinfo->element.topbuffusage)
+        strinfo->element.topbuffusage = strinfo->element.buffusage;
+    /* check for buffer losses */
+    if((strinfo->element.buffusage >= mcast_stream_bufferalarm) && (strinfo->element.buffstatus == 0)){
+        strinfo->element.buffstatus = 1;
+        strinfo->element.numbuffalarms++;
+    } else if(strinfo->element.buffusage < mcast_stream_bufferalarm){
+        strinfo->element.buffstatus = 0;
+    }
+
+    return;
 }
 
 /* sliding window calculation */
 static void
 slidingwindow(mcast_stream_info_t *strinfo, packet_info *pinfo)
 {
-	struct timeval *buffer;
-	gint32 diff;
-
-	buffer = strinfo->element.buff;
-
-	diff = strinfo->element.last - strinfo->element.first;
-	if(diff < 0) diff+=buffsize;
-
-	/* check if buffer is full */
-	if(diff >= (buffsize - 2)){
-		fprintf(stderr, "Warning: capture buffer full\n");
-		strinfo->element.first++;
-		if(strinfo->element.first >= buffsize) strinfo->element.first = strinfo->element.first % buffsize;
-	}
-
-	/* burst count */
-	buffer[strinfo->element.last].tv_sec = (guint32) pinfo->rel_ts.secs;
-	buffer[strinfo->element.last].tv_usec = pinfo->rel_ts.nsecs/1000;
-	while(comparetimes((struct timeval *)&(buffer[strinfo->element.first]),
-			   (struct timeval *)&(buffer[strinfo->element.last]), mcast_stream_burstint)){
-		strinfo->element.first++;
-		if(strinfo->element.first >= buffsize) strinfo->element.first = strinfo->element.first % buffsize;
-		diff--;
-	}
-	strinfo->element.burstsize = diff;
-	if(strinfo->element.burstsize > strinfo->element.topburstsize) {
-		strinfo->element.topburstsize = strinfo->element.burstsize;
-		strinfo->element.maxbw = (float)(strinfo->element.topburstsize) * 1000 / mcast_stream_burstint * pinfo->fd->pkt_len * 8 / 1000000;
-	}
-
-	strinfo->element.last++;
-	if(strinfo->element.last >= buffsize) strinfo->element.last = strinfo->element.last % buffsize;
-	/* trigger check */
-	if((strinfo->element.burstsize >= mcast_stream_trigger) && (strinfo->element.burststatus == 0)){
-		strinfo->element.burststatus = 1;
-		strinfo->element.numbursts++;
-	} else if(strinfo->element.burstsize < mcast_stream_trigger){
-		strinfo->element.burststatus = 0;
-	}
-
-	strinfo->element.count++;
+    struct timeval *buffer;
+    gint32 diff;
+
+    buffer = strinfo->element.buff;
+
+    diff = strinfo->element.last - strinfo->element.first;
+    if(diff < 0) diff+=buffsize;
+
+    /* check if buffer is full */
+    if(diff >= (buffsize - 2)){
+        fprintf(stderr, "Warning: capture buffer full\n");
+        strinfo->element.first++;
+        if(strinfo->element.first >= buffsize) strinfo->element.first = strinfo->element.first % buffsize;
+    }
+
+    /* burst count */
+    buffer[strinfo->element.last].tv_sec = (guint32) pinfo->rel_ts.secs;
+    buffer[strinfo->element.last].tv_usec = pinfo->rel_ts.nsecs/1000;
+    while(comparetimes((struct timeval *)&(buffer[strinfo->element.first]),
+                       (struct timeval *)&(buffer[strinfo->element.last]), mcast_stream_burstint)){
+        strinfo->element.first++;
+        if(strinfo->element.first >= buffsize) strinfo->element.first = strinfo->element.first % buffsize;
+        diff--;
+    }
+    strinfo->element.burstsize = diff;
+    if(strinfo->element.burstsize > strinfo->element.topburstsize) {
+        strinfo->element.topburstsize = strinfo->element.burstsize;
+        strinfo->element.maxbw = (float)(strinfo->element.topburstsize) * 1000 / mcast_stream_burstint * pinfo->fd->pkt_len * 8 / 1000000;
+    }
+
+    strinfo->element.last++;
+    if(strinfo->element.last >= buffsize) strinfo->element.last = strinfo->element.last % buffsize;
+    /* trigger check */
+    if((strinfo->element.burstsize >= mcast_stream_trigger) && (strinfo->element.burststatus == 0)){
+        strinfo->element.burststatus = 1;
+        strinfo->element.numbursts++;
+    } else if(strinfo->element.burstsize < mcast_stream_trigger){
+        strinfo->element.burststatus = 0;
+    }
+
+    strinfo->element.count++;
 }
 
+/*
+ * Editor modelines  -  http://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 4
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=4 tabstop=8 expandtab:
+ * :indentSize=4:tabSize=8:noTabs=true:
+ */
diff --git a/ui/gtk/mcast_stream.h b/ui/gtk/mcast_stream.h
index 66d8588a14..094e27d683 100644
--- a/ui/gtk/mcast_stream.h
+++ b/ui/gtk/mcast_stream.h
@@ -34,45 +34,45 @@
 
 /* typedefs for sliding window and buffer size */
 typedef struct buffer{
-	struct timeval *buff;   /* packet times */
-	gint32 first;              /* pointer to the first element */
-	gint32 last;               /* pointer to the last element */
-	gint32 burstsize;          /* current burst */
-	gint32 topburstsize;       /* maximum burst in the refresh interval*/
-	gint32 count;              /* packet counter */
-	gint32 burststatus;        /* burst status */
-	gint32 numbursts;          /* number of bursts */
-	gint32 buffusage;          /* buffer usage */
-	gint32 buffstatus;         /* buffer status */
-	gint32 numbuffalarms;      /* number of alarms triggered by buffer underruns */
-	gint32 topbuffusage;       /* top buffer usage in refresh interval */
-	float  maxbw;              /* maximum bandwidth usage */
+    struct timeval *buff;   /* packet times */
+    gint32 first;              /* pointer to the first element */
+    gint32 last;               /* pointer to the last element */
+    gint32 burstsize;          /* current burst */
+    gint32 topburstsize;       /* maximum burst in the refresh interval*/
+    gint32 count;              /* packet counter */
+    gint32 burststatus;        /* burst status */
+    gint32 numbursts;          /* number of bursts */
+    gint32 buffusage;          /* buffer usage */
+    gint32 buffstatus;         /* buffer status */
+    gint32 numbuffalarms;      /* number of alarms triggered by buffer underruns */
+    gint32 topbuffusage;       /* top buffer usage in refresh interval */
+    float  maxbw;              /* maximum bandwidth usage */
 } t_buffer;
 
 
 /* defines an mcast stream */
 typedef struct _mcast_stream_info {
-	address src_addr;
-	guint16 src_port;
-	address dest_addr;
-	guint16 dest_port;
-	guint32 npackets;
-	guint32 apackets;
-	guint32 total_bytes;
-	float   average_bw;
-
-	guint32 first_frame_num; /* frame number of first frame */
-	/* start of recording (GMT) of this stream */
-	guint32 start_sec;         /* seconds */
-	guint32 start_usec;        /* microseconds */
-	guint32 start_rel_sec;     /* start stream rel seconds */
-	guint32 start_rel_usec;    /* start stream rel microseconds */
-	guint32 stop_rel_sec;      /* stop stream rel seconds */
-	guint32 stop_rel_usec;     /* stop stream rel microseconds */
-	guint16 vlan_id;
-
-	/*for the sliding window */
-	t_buffer element;
+    address src_addr;
+    guint16 src_port;
+    address dest_addr;
+    guint16 dest_port;
+    guint32 npackets;
+    guint32 apackets;
+    guint32 total_bytes;
+    float   average_bw;
+
+    guint32 first_frame_num; /* frame number of first frame */
+    /* start of recording (GMT) of this stream */
+    guint32 start_sec;         /* seconds */
+    guint32 start_usec;        /* microseconds */
+    guint32 start_rel_sec;     /* start stream rel seconds */
+    guint32 start_rel_usec;    /* start stream rel microseconds */
+    guint32 stop_rel_sec;      /* stop stream rel seconds */
+    guint32 stop_rel_usec;     /* stop stream rel microseconds */
+    guint16 vlan_id;
+
+    /*for the sliding window */
+    t_buffer element;
 
 } mcast_stream_info_t;
 
@@ -80,13 +80,13 @@ typedef struct _mcast_stream_info {
 /* structure that holds the information about all detected streams */
 /* struct holding all information of the tap */
 typedef struct _mcaststream_tapinfo {
-	int     nstreams;       /* number of streams in the list */
-	GList*  strinfo_list;   /* list with all streams */
-	guint32 npackets;       /* total number of mcast packets of all streams */
-	mcast_stream_info_t* allstreams; /* structure holding information common for all streams */
+    int     nstreams;       /* number of streams in the list */
+    GList*  strinfo_list;   /* list with all streams */
+    guint32 npackets;       /* total number of mcast packets of all streams */
+    mcast_stream_info_t* allstreams; /* structure holding information common for all streams */
 
-	guint32 launch_count;   /* number of times the tap has been run */
-	gboolean is_registered; /* if the tap listener is currently registered or not */
+    guint32 launch_count;   /* number of times the tap has been run */
+    gboolean is_registered; /* if the tap listener is currently registered or not */
 } mcaststream_tapinfo_t;
 
 
@@ -132,3 +132,16 @@ void mcaststream_reset(mcaststream_tapinfo_t *tapinfo);
 void mcaststream_scan(void);
 
 #endif /* __MCAST_STREAM_H__ */
+
+/*
+ * Editor modelines  -  http://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 4
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=4 tabstop=8 expandtab:
+ * :indentSize=4:tabSize=8:noTabs=true:
+ */

