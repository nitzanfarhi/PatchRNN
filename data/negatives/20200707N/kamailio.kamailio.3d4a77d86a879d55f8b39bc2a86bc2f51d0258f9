commit 3d4a77d86a879d55f8b39bc2a86bc2f51d0258f9
Author: Peter Dunkley <peter.dunkley@crocodile-rcs.com>
Date:   Sat Jun 30 22:53:00 2012 +0100

    core: Added more PROTO_WS and PROTO_WSS checks

diff --git a/action.c b/action.c
index 5263f0279..5e0875ceb 100644
--- a/action.c
+++ b/action.c
@@ -446,8 +446,10 @@ int do_action(struct run_act_ctx* h, struct action* a, struct sip_msg* msg)
 									u->proto);
 							ret=E_BAD_PROTO;
 							goto error_fwd_uri;
-						}
-						dst.proto=PROTO_TLS;
+						} else if (u->proto!=PROTO_WSS)
+							dst.proto=PROTO_TLS;
+						else
+							dst.proto=PROTO_WSS;
 					}
 #endif
 				}
diff --git a/lib/kcore/statistics.c b/lib/kcore/statistics.c
index 663c06473..6028bc3fa 100644
--- a/lib/kcore/statistics.c
+++ b/lib/kcore/statistics.c
@@ -136,6 +136,8 @@ int get_socket_list_from_proto(int **ipList, int protocol) {
 		return 0;
 	}
 #endif
+	if (protocol == PROTO_WS || protocol == PROTO_WSS)
+		return 0;
 
 	/* Retrieve the list of sockets with respect to the given protocol. */
 	list=get_sock_info_list(protocol);
@@ -409,6 +411,8 @@ int get_total_bytes_waiting(void)
 	numUDPSockets  = get_socket_list_from_proto(&UDPList,  PROTO_UDP);
 	numTCPSockets  = get_socket_list_from_proto(&TCPList,  PROTO_TCP);
 	numTLSSockets  = get_socket_list_from_proto(&TLSList,  PROTO_TLS);
+	/* Deliberately not looking at PROTO_WS or PROTO_WSS here as they are
+	   just upgraded TCP/TLS connections */
 
 	/* Find out the number of bytes waiting on our interface list over all
 	 * UDP and TCP transports. */
diff --git a/main.c b/main.c
index 306e40992..ca272e1cc 100644
--- a/main.c
+++ b/main.c
@@ -976,6 +976,8 @@ static int parse_proto(unsigned char* s, long len, int* proto)
 	}
 #endif /* USE_SCTP */
 	else
+	/* Deliberately leaving out PROTO_WS and PROTO_WSS as these are just
+	   upgraded TCP/TLS connections. */
 		return -1;
 	return 0;
 }
diff --git a/msg_translator.c b/msg_translator.c
index e4f0d7497..2c38000cb 100644
--- a/msg_translator.c
+++ b/msg_translator.c
@@ -657,7 +657,11 @@ static inline int lumps_len(struct sip_msg* msg, struct lump* lumps,
 								break; \
 						case PROTO_SCTP: \
 								new_len+=4; \
-								break; \
+							break; \
+						case PROTO_WS: \
+						case PROTO_WSS: \
+							new_len+=2; \
+							break; \
 						default: \
 						LOG(L_CRIT, "BUG: lumps_len: unknown proto %d\n", \
 								msg->rcv.bind_address->proto); \
@@ -688,6 +692,10 @@ static inline int lumps_len(struct sip_msg* msg, struct lump* lumps,
 						case PROTO_SCTP: \
 								new_len+=TRANSPORT_PARAM_LEN+4; \
 								break; \
+						case PROTO_WS: \
+						case PROTO_WSS: \
+								new_len+=TRANSPORT_PARAM_LEN+2; \
+								break; \
 						default: \
 						LOG(L_CRIT, "BUG: lumps_len: unknown proto %d\n", \
 								msg->rcv.bind_address->proto); \
@@ -729,6 +737,10 @@ static inline int lumps_len(struct sip_msg* msg, struct lump* lumps,
 						case PROTO_SCTP: \
 								new_len+=4; \
 								break; \
+						case PROTO_WS: \
+						case PROTO_WSS: \
+								new_len+=2; \
+								break; \
 						default: \
 						LOG(L_CRIT, "BUG: lumps_len: unknown proto %d\n", \
 								send_sock->proto); \
@@ -761,6 +773,10 @@ static inline int lumps_len(struct sip_msg* msg, struct lump* lumps,
 						case PROTO_SCTP: \
 								new_len+=TRANSPORT_PARAM_LEN+4; \
 								break; \
+						case PROTO_WS: \
+						case PROTO_WSS: \
+								new_len+=TRANSPORT_PARAM_LEN+2; \
+								break; \
 						default: \
 						LOG(L_CRIT, "BUG: lumps_len: unknown proto %d\n", \
 								send_sock->proto); \
@@ -1051,6 +1067,14 @@ static inline void process_lumps(	struct sip_msg* msg,
 						memcpy(new_buf+offset, "sctp", 4); \
 						offset+=4; \
 						break; \
+					case PROTO_WS: \
+					case PROTO_WSS: \
+						memcpy(new_buf+offset, TRANSPORT_PARAM, \
+								TRANSPORT_PARAM_LEN); \
+						offset+=TRANSPORT_PARAM_LEN; \
+						memcpy(new_buf+offset, "ws", 2); \
+						offset+=2; \
+						break; \
 					default: \
 						LOG(L_CRIT, "BUG: process_lumps: unknown proto %d\n", \
 								msg->rcv.bind_address->proto); \
@@ -1138,6 +1162,14 @@ static inline void process_lumps(	struct sip_msg* msg,
 						memcpy(new_buf+offset, "sctp", 4); \
 						offset+=4; \
 						break; \
+					case PROTO_WS: \
+					case PROTO_WSS: \
+						memcpy(new_buf+offset, TRANSPORT_PARAM, \
+								TRANSPORT_PARAM_LEN); \
+						offset+=TRANSPORT_PARAM_LEN; \
+						memcpy(new_buf+offset, "ws", 2); \
+						offset+=2; \
+						break; \
 					default: \
 						LOG(L_CRIT, "BUG: process_lumps: unknown proto %d\n", \
 								send_sock->proto); \
@@ -1168,6 +1200,11 @@ static inline void process_lumps(	struct sip_msg* msg,
 						memcpy(new_buf+offset, "sctp", 4); \
 						offset+=4; \
 						break; \
+					case PROTO_WS: \
+					case PROTO_WSS: \
+						memcpy(new_buf+offset, "ws", 2); \
+						offset+=2; \
+						break; \
 					default: \
 						LOG(L_CRIT, "BUG: process_lumps: unknown proto %d\n", \
 								msg->rcv.bind_address->proto); \
@@ -1198,6 +1235,11 @@ static inline void process_lumps(	struct sip_msg* msg,
 						memcpy(new_buf+offset, "sctp", 4); \
 						offset+=4; \
 						break; \
+					case PROTO_WS: \
+					case PROTO_WSS: \
+						memcpy(new_buf+offset, "ws", 2); \
+						offset+=4; \
+						break; \
 					default: \
 						LOG(L_CRIT, "BUG: process_lumps: unknown proto %d\n", \
 								send_sock->proto); \
diff --git a/socket_info.c b/socket_info.c
index f8655b909..aec4f53bb 100644
--- a/socket_info.c
+++ b/socket_info.c
@@ -140,6 +140,8 @@ inline static void addr_info_list_ins_lst(struct addr_info* lst,
 /* protocol order, filled by init_proto_order() */
 enum sip_protos nxt_proto[PROTO_LAST+1]=
 { PROTO_UDP, PROTO_TCP, PROTO_TLS, PROTO_SCTP, 0 };
+/* Deliberately left PROTO_WS and PROTO_WSS out of this as they are just
+   upgraded TCP and TLS connections */
 
 
 
diff --git a/tcp_main.c b/tcp_main.c
index c5a254729..a6e30191f 100644
--- a/tcp_main.c
+++ b/tcp_main.c
@@ -1427,7 +1427,7 @@ static inline void _tcpconn_free(struct tcp_connection* c)
 #endif
 	lock_destroy(&c->write_lock);
 #ifdef USE_TLS
-	if (unlikely(c->type==PROTO_TLS)) tls_tcpconn_clean(c);
+	if (unlikely(c->type==PROTO_TLS || c->type==PROTO_WSS)) tls_tcpconn_clean(c);
 #endif
 	shm_free(c);
 }
@@ -1456,7 +1456,7 @@ void tcpconn_rm(struct tcp_connection* c)
 	TCPCONN_UNLOCK;
 	lock_destroy(&c->write_lock);
 #ifdef USE_TLS
-	if ((c->type==PROTO_TLS)&&(c->extra_data)) tls_tcpconn_clean(c);
+	if ((c->type==PROTO_TLS || c->type==PROTO_WSS)&&(c->extra_data)) tls_tcpconn_clean(c);
 #endif
 	shm_free(c);
 }
@@ -2270,7 +2270,7 @@ static int tcpconn_send_put(struct tcp_connection* c, const char* buf,
 				{
 					do_close_fd=0;
 #ifdef USE_TLS
-					if (unlikely(c->type==PROTO_TLS)) {
+					if (unlikely(c->type==PROTO_TLS || c->type==PROTO_WSS)) {
 						t_buf = buf;
 						t_len = len;
 						do {
@@ -2372,7 +2372,7 @@ static int tcpconn_send_put(struct tcp_connection* c, const char* buf,
 		}
 	
 #ifdef USE_TLS
-		if (unlikely(c->type==PROTO_TLS)) {
+		if (unlikely(c->type==PROTO_TLS || c->type==PROTO_WSS)) {
 			/* for TLS the TLS processing and the send must happen
 			   atomically w/ respect to other sends on the same connection
 			   (otherwise reordering might occur which would break TLS) =>
@@ -2958,7 +2958,7 @@ inline static void tcpconn_close_main_fd(struct tcp_connection* tcpconn)
 	
 	fd=tcpconn->s;
 #ifdef USE_TLS
-	if (tcpconn->type==PROTO_TLS)
+	if (tcpconn->type==PROTO_TLS || tcpconn->type==PROTO_WSS)
 		tls_close(tcpconn, fd);
 #endif
 #ifdef TCP_FD_CACHE
@@ -3025,7 +3025,7 @@ inline static void tcpconn_destroy(struct tcp_connection* tcpconn)
 			tcpconn_close_main_fd(tcpconn);
 			tcpconn->flags|=F_CONN_FD_CLOSED;
 			(*tcp_connections_no)--;
-			if (unlikely(tcpconn->type==PROTO_TLS))
+			if (unlikely(tcpconn->type==PROTO_TLS || tcpconn->type==PROTO_WSS))
 				(*tls_connections_no)--;
 		}
 		_tcpconn_free(tcpconn); /* destroys also the wbuf_q if still present*/
@@ -3073,7 +3073,7 @@ inline static int tcpconn_put_destroy(struct tcp_connection* tcpconn)
 		tcpconn_close_main_fd(tcpconn);
 		tcpconn->flags|=F_CONN_FD_CLOSED;
 		(*tcp_connections_no)--;
-		if (unlikely(tcpconn->type==PROTO_TLS))
+		if (unlikely(tcpconn->type==PROTO_TLS || tcpconn->type==PROTO_WSS))
 				(*tls_connections_no)--;
 	}
 	/* all the flags / ops on the tcpconn must be done prior to decrementing
@@ -4509,7 +4509,7 @@ static inline void tcpconn_destroy_all(void)
 					fd=-1;
 				}
 #ifdef USE_TLS
-				if (fd>0 && c->type==PROTO_TLS)
+				if (fd>0 && (c->type==PROTO_TLS || c->type==PROTO_WSS))
 					tls_close(c, fd);
 #endif
 				_tcpconn_rm(c);
@@ -4522,7 +4522,7 @@ static inline void tcpconn_destroy_all(void)
 					tcp_safe_close(fd);
 				}
 				(*tcp_connections_no)--;
-				if (unlikely(c->type==PROTO_TLS))
+				if (unlikely(c->type==PROTO_TLS || c->type==PROTO_WSS))
 					(*tls_connections_no)--;
 			c=next;
 		}

