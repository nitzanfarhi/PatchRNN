commit 2c0aa2a5c2dfa1293ae3a07517d0b7de149358a1
Author: James Ketrenos <jketreno@linux.intel.com>
Date:   Wed Sep 21 11:56:27 2005 -0500

    [PATCH] ieee80211: Return NETDEV_TX_BUSY when QoS buffer full
    
    tree ba6509c7cd1dd4244a2f285f2da5d632e7ffbb25
    parent 7b5f9f2ddcabdaea214527a895e6e8445cafdd80
    author James Ketrenos <jketreno@linux.intel.com> 1124447000 -0500
    committer James Ketrenos <jketreno@linux.intel.com> 1127313383 -0500
    
    Per the conversations with folks at OLS, the QoS layer in 802.11
    drivers can now result in NETDEV_TX_BUSY being returned when the queue
    a packet is targetted for is full.
    
    To implement this, ieee80211_xmit will now call the driver's
    is_queue_full to determine if the current priority queue is full.  If
    so, NETDEV_TX_BUSY is returned to the kernel and no processing is done
    on the frame.
    
    Signed-off-by: James Ketrenos <jketreno@linux.intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/net/ieee80211/ieee80211_tx.c b/net/ieee80211/ieee80211_tx.c
index 23a1f88de7cb..e9efdd42ba37 100644
--- a/net/ieee80211/ieee80211_tx.c
+++ b/net/ieee80211/ieee80211_tx.c
@@ -236,8 +236,12 @@ int ieee80211_xmit(struct sk_buff *skb, struct net_device *dev)
 	};
 	u8 dest[ETH_ALEN], src[ETH_ALEN];
 	struct ieee80211_crypt_data *crypt;
+	int priority = skb->priority;
 	int snapped = 0;
 
+	if (ieee->is_queue_full && (*ieee->is_queue_full) (dev, priority))
+		return NETDEV_TX_BUSY;
+
 	spin_lock_irqsave(&ieee->lock, flags);
 
 	/* If there is no driver handler to take the TXB, dont' bother
@@ -467,6 +471,14 @@ int ieee80211_xmit(struct sk_buff *skb, struct net_device *dev)
 			stats->tx_bytes += txb->payload_size;
 			return 0;
 		}
+
+		if (ret == NETDEV_TX_BUSY) {
+			printk(KERN_ERR "%s: NETDEV_TX_BUSY returned; "
+			       "driver should report queue full via "
+			       "ieee_device->is_queue_full.\n",
+			       ieee->dev->name);
+		}
+
 		ieee80211_txb_free(txb);
 	}
 

