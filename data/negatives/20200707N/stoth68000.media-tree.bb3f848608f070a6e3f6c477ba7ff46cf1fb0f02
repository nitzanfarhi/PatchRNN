commit bb3f848608f070a6e3f6c477ba7ff46cf1fb0f02
Author: Liad Kaufman <liad.kaufman@intel.com>
Date:   Thu Jul 17 17:14:31 2014 +0300

    mac80211: make sure TDLS teardown packet is sent on time
    
    Since the teardown packet is created while the queues are
    stopped, it isn't sent immediately, but rather is pending.
    To be sure that when we flush the queues prior to destroying
    the station we also send this packet - the tasklet handling
    pending packets is invoked to flush the packets.
    
    Signed-off-by: Liad Kaufman <liad.kaufman@intel.com>
    Reviewed-by: ArikX Nemtsov <arik@wizery.com>
    Reviewed-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/tdls.c b/net/mac80211/tdls.c
index 50d0e0660cc4..1b21050be174 100644
--- a/net/mac80211/tdls.c
+++ b/net/mac80211/tdls.c
@@ -836,6 +836,17 @@ int ieee80211_tdls_oper(struct wiphy *wiphy, struct net_device *dev,
 		ret = 0;
 		break;
 	case NL80211_TDLS_DISABLE_LINK:
+		/*
+		 * The teardown message in ieee80211_tdls_mgmt_teardown() was
+		 * created while the queues were stopped, so it might still be
+		 * pending. Before flushing the queues we need to be sure the
+		 * message is handled by the tasklet handling pending messages,
+		 * otherwise we might start destroying the station before
+		 * sending the teardown packet.
+		 * Note that this only forces the tasklet to flush pendings -
+		 * not to stop the tasklet from rescheduling itself.
+		 */
+		tasklet_kill(&local->tx_pending_tasklet);
 		/* flush a potentially queued teardown packet */
 		ieee80211_flush_queues(local, sdata);
 

