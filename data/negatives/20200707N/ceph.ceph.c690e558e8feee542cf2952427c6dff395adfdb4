commit c690e558e8feee542cf2952427c6dff395adfdb4
Author: xie xingguo <xie.xingguo@zte.com.cn>
Date:   Sat Dec 24 14:46:52 2016 +0800

    os/bluestore/BitAllocator: miscellaneous cleanups
    
    Signed-off-by: xie xingguo <xie.xingguo@zte.com.cn>

diff --git a/src/os/bluestore/BitAllocator.cc b/src/os/bluestore/BitAllocator.cc
index d7ed7de9c2..44c8aa5c32 100644
--- a/src/os/bluestore/BitAllocator.cc
+++ b/src/os/bluestore/BitAllocator.cc
@@ -11,10 +11,10 @@
  * at a time single thread can be active as well as single biggest
  * contiguous allocation that can be requested.
  *
- * Rest of the nodes are classified in to three catagories:
+ * Rest of the nodes are classified into three catagories:
  *   root note or Allocator
  *   internal nodes or BitMapAreaIN
- *   finally nodes that contains Zones called BitMapAreaLeaf
+ *   final nodes that contains Zones called BitMapAreaLeaf
  * This classification is according to their own implmentation of some
  * of the interfaces defined in BitMapArea.
  */
@@ -167,7 +167,6 @@ bmap_t BmapEntry::align_mask(int x)
 bmap_t BmapEntry::bit_mask(int bit)
 {
   return m_bit_to_mask[bit];
-//  return ((bmap_t) 0x1 << ((BmapEntry::size() - 1) - bit));
 }
 bool BmapEntry::check_bit(int bit)
 {
@@ -252,7 +251,7 @@ int BmapEntry::find_n_cont_bits(int start_offset, int64_t num_bits)
 }
 
 /*
- * Find N free bits starting search from an given offset.
+ * Find N free bits starting search from a given offset.
  *
  * Returns number of bits found, start bit and end of
  * index next to bit where our search ended + 1.
@@ -930,7 +929,7 @@ int64_t BitMapAreaIN::alloc_blocks_dis_int_work(bool wrap, int64_t num_blocks, i
 
   while ((child = (BitMapArea *) iter.next())) {
     if (!child_check_n_lock(child, 1)) {
-    hint = 0;
+      hint = 0;
       continue;
     }
 
@@ -1089,7 +1088,6 @@ void BitMapAreaLeaf::init(int64_t total_blocks, int64_t area_idx,
   alloc_assert(num_child);
   m_child_size_blocks = total_blocks / num_child;
 
-  alloc_assert(m_level == 1);
   BitMapArea **children = new BitMapArea*[num_child];
   for (int i = 0; i < num_child; i++) {
     children[i] = new BitMapZone(cct, m_child_size_blocks, i, def);
@@ -1151,7 +1149,7 @@ int64_t BitMapAreaLeaf::alloc_blocks_dis_int(int64_t num_blocks, int64_t min_all
 
   while ((child = (BitMapArea *) iter.next())) {
     if (!child_check_n_lock(child, 1, false)) {
-    hint = 0;
+      hint = 0;
       continue;
     }
 
@@ -1162,7 +1160,7 @@ int64_t BitMapAreaLeaf::alloc_blocks_dis_int(int64_t num_blocks, int64_t min_all
     if (allocated == num_blocks) {
       break;
     }
-  hint = 0;
+    hint = 0;
   }
   return allocated;
 }
@@ -1268,7 +1266,7 @@ void BitAllocator::init_check(int64_t total_blocks, int64_t zone_size_block,
   init(total_blocks, 0, def);
   if (!def && unaligned_blocks) {
     /*
-     * Mark extra padded blocks used from begning.
+     * Mark extra padded blocks used from beginning.
      */
     set_blocks_used(total_blocks - m_extra_blocks, m_extra_blocks);
   }
@@ -1353,11 +1351,7 @@ void BitAllocator::child_unlock(BitMapArea *child)
 
 bool BitAllocator::check_input_dis(int64_t num_blocks)
 {
-  if (num_blocks == 0) {
-    return false;
-  }
-
-  if (num_blocks > size()) {
+  if (num_blocks == 0 || num_blocks > size()) {
     return false;
   }
   return true;
@@ -1365,11 +1359,7 @@ bool BitAllocator::check_input_dis(int64_t num_blocks)
 
 bool BitAllocator::check_input(int64_t num_blocks)
 {
-  if (num_blocks == 0) {
-    return false;
-  }
-
-  if (num_blocks > get_zone_size(cct)) {
+  if (num_blocks == 0 || num_blocks > get_zone_size(cct)) {
     return false;
   }
   return true;

