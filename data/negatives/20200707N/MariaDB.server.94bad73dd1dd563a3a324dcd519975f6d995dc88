commit 94bad73dd1dd563a3a324dcd519975f6d995dc88
Author: Sergey Vojtovich <svoj@mariadb.org>
Date:   Thu Apr 28 21:59:23 2016 +0400

    MDEV-9988 - Insert cast to suppress -Wdynamic-class-memaccess
    
    Clang warns on this code because it is memsetting over a vtable contained in a
    struct in the best_positions array. The diagnostic text is:
    
    mariadb/sql/sql_select.cc:24462:10: error: destination for this 'memset' call is
    a pointer to class containing a dynamic class 'Duplicate_weedout_picker'; vtable
    pointer will be overwritten [-Werror,-Wdynamic-class-memaccess]
      memset(best_positions, 0, sizeof(POSITION) * (table_count + 1));
      ~~~~~~ ^
    
    Patch contributed by David Gow.

diff --git a/sql/opt_subselect.cc b/sql/opt_subselect.cc
index de57143e61d..a81b091461f 100644
--- a/sql/opt_subselect.cc
+++ b/sql/opt_subselect.cc
@@ -2243,7 +2243,8 @@ bool optimize_semijoin_nests(JOIN *join, table_map all_table_map)
             rows *= join->map2table[tableno]->table->quick_condition_rows;
           sjm->rows= MY_MIN(sjm->rows, rows);
         }
-        memcpy(sjm->positions, join->best_positions + join->const_tables, 
+        memcpy((uchar*) sjm->positions,
+               (uchar*) (join->best_positions + join->const_tables),
                sizeof(POSITION) * n_tables);
 
         /*
@@ -3347,7 +3348,7 @@ void fix_semijoin_strategies_for_picked_join_order(JOIN *join)
       SJ_MATERIALIZATION_INFO *sjm= s->emb_sj_nest->sj_mat_info;
       sjm->is_used= TRUE;
       sjm->is_sj_scan= FALSE;
-      memcpy(pos - sjm->tables + 1, sjm->positions, 
+      memcpy((uchar*) (pos - sjm->tables + 1), (uchar*) sjm->positions,
              sizeof(POSITION) * sjm->tables);
       recalculate_prefix_record_count(join, tablenr - sjm->tables + 1,
                                       tablenr);
@@ -3363,8 +3364,8 @@ void fix_semijoin_strategies_for_picked_join_order(JOIN *join)
       sjm->is_used= TRUE;
       sjm->is_sj_scan= TRUE;
       first= pos->sjmat_picker.sjm_scan_last_inner - sjm->tables + 1;
-      memcpy(join->best_positions + first, 
-             sjm->positions, sizeof(POSITION) * sjm->tables);
+      memcpy((uchar*) (join->best_positions + first),
+             (uchar*) sjm->positions, sizeof(POSITION) * sjm->tables);
       recalculate_prefix_record_count(join, first, first + sjm->tables);
       join->best_positions[first].sj_strategy= SJ_OPT_MATERIALIZE_SCAN;
       join->best_positions[first].n_sj_tables= sjm->tables;
diff --git a/sql/sql_select.cc b/sql/sql_select.cc
index f58738a4539..c2b25d812fb 100644
--- a/sql/sql_select.cc
+++ b/sql/sql_select.cc
@@ -24672,7 +24672,7 @@ void JOIN::save_query_plan(Join_plan_state *save_to)
   }
   memcpy((uchar*) save_to->best_positions, (uchar*) best_positions,
          sizeof(POSITION) * (table_count + 1));
-  memset(best_positions, 0, sizeof(POSITION) * (table_count + 1));
+  memset((uchar*) best_positions, 0, sizeof(POSITION) * (table_count + 1));
   
   /* Save SJM nests */
   List_iterator<TABLE_LIST> it(select_lex->sj_nests);

