commit 0e1147b001793593624e80b3c0a1790822b6baca
Author: Robin Dong <sanbai@taobao.com>
Date:   Wed Jul 27 21:29:33 2011 -0400

    ext4: add action of moving index in ext4_ext_rm_idx for Punch Hole
    
    The old function ext4_ext_rm_idx is used only for truncate case
    because it just remove last index in extent-index-block. When punching
    hole, it usually needed to remove "middle" index, therefore we must
    move indexes which after it forward.
    
    (I create a file with 1 depth extent tree and punch hole in the middle
    of it, the last index in index-block strangly gone, so I find out this
    bug)
    
    Signed-off-by: Robin Dong <sanbai@taobao.com>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index 4d73e11ae883..a25bbdc7d493 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -2101,8 +2101,6 @@ ext4_ext_in_cache(struct inode *inode, ext4_lblk_t block,
 /*
  * ext4_ext_rm_idx:
  * removes index from the index block.
- * It's used in truncate case only, thus all requests are for
- * last index in the block only.
  */
 static int ext4_ext_rm_idx(handle_t *handle, struct inode *inode,
 			struct ext4_ext_path *path)
@@ -2120,6 +2118,13 @@ static int ext4_ext_rm_idx(handle_t *handle, struct inode *inode,
 	err = ext4_ext_get_access(handle, inode, path);
 	if (err)
 		return err;
+
+	if (path->p_idx != EXT_LAST_INDEX(path->p_hdr)) {
+		int len = EXT_LAST_INDEX(path->p_hdr) - path->p_idx;
+		len *= sizeof(struct ext4_extent_idx);
+		memmove(path->p_idx, path->p_idx + 1, len);
+	}
+
 	le16_add_cpu(&path->p_hdr->eh_entries, -1);
 	err = ext4_ext_dirty(handle, inode, path);
 	if (err)

