commit 1123d93963cbd2546449d4d9f0c568e323cb0ac6
Author: Max Asbock <masbock@linux.vnet.ibm.com>
Date:   Mon Jun 13 10:18:32 2011 -0700

    timerfd: Fix wakeup of processes when timer is cancelled on clock change
    
    Currently processes waiting with poll on cancelable timerfd timers are
    not woken up when the timers are canceled. When the system time is set
    the clock_was_set() function calls timerfd_clock_was_set() to cancel
    and wake up processes waiting on potential cancelable timerfd
    timers. However the wake up currently has no effect because in the
    case of timerfd_read it is dependent on ctx->ticks not being
    0. timerfd_poll also requires ctx->ticks being non zero. As a
    consequence processes waiting on cancelable timers only get woken up
    when the timers expire. This patch fixes this by incrementing
    ctx->ticks before calling wake_up.
    
    Signed-off-by: Max Asbock <masbock@linux.vnet.ibm.com>
    Cc: kay.sievers@vrfy.org
    Cc: virtuoso@slind.org
    Cc: johnstul <johnstul@linux.vnet.ibm.com>
    Link: http://lkml.kernel.org/r/1307985512.4710.41.camel@w-amax.beaverton.ibm.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/fs/timerfd.c b/fs/timerfd.c
index f67acbdda5e8..dffeb3795af1 100644
--- a/fs/timerfd.c
+++ b/fs/timerfd.c
@@ -61,7 +61,9 @@ static enum hrtimer_restart timerfd_tmrproc(struct hrtimer *htmr)
 
 /*
  * Called when the clock was set to cancel the timers in the cancel
- * list.
+ * list. This will wake up processes waiting on these timers. The
+ * wake-up requires ctx->ticks to be non zero, therefore we increment
+ * it before calling wake_up_locked().
  */
 void timerfd_clock_was_set(void)
 {
@@ -76,6 +78,7 @@ void timerfd_clock_was_set(void)
 		spin_lock_irqsave(&ctx->wqh.lock, flags);
 		if (ctx->moffs.tv64 != moffs.tv64) {
 			ctx->moffs.tv64 = KTIME_MAX;
+			ctx->ticks++;
 			wake_up_locked(&ctx->wqh);
 		}
 		spin_unlock_irqrestore(&ctx->wqh.lock, flags);

