commit c2e86cc57c4f59699f9a548d152cbd7d24bc5217
Author: Peter Ruffhead <peterr.citymi@gmail.com>
Date:   Fri Jul 16 21:38:12 2010 +0100

    Added use of EGlyphCacheStrategy

diff --git a/include/graphiteng/IFace.h b/include/graphiteng/IFace.h
index 4633b3d..4f9c1da 100644
--- a/include/graphiteng/IFace.h
+++ b/include/graphiteng/IFace.h
@@ -18,16 +18,25 @@ namespace org { namespace sil { namespace graphite { namespace v2 {
 
 class GrFace;
 
+enum EGlyphCacheStrategy{ eOneCache=0, eLoadOnDemand=100/*never unloaded*/, ePreload=200 } ;        //don't change numbering
+
 class GRNG_EXPORT IFace
 {
 public:
     //virtual ~IFace() {}
     virtual const void *getTable(unsigned int name, size_t *len) const = 0;		//In standard TTF format. Must check in range. Return NULL if not.
 
-    GrFace* makeGrFace() const;		//the 'this' must stay alive all the time when the GrFace is alive. When finished with the GrFace, call IFace::destroyGrFace    
+    GrFace* makeGrFace(EGlyphCacheStrategy requestedStrategy=ePreload) const;		//the 'this' must stay alive all the time when the GrFace is alive. When finished with the GrFace, call IFace::destroyGrFace    
     static FeaturesHandle getFeatures(const GrFace* pFace, uint32 langname/*0 means clone default*/); //clones the features. if none for language, clones the default
     static FeatureRefHandle feature(const GrFace* pFace, uint8 index);
     static void destroyGrFace(GrFace *face);
+    
+    static EGlyphCacheStrategy nearestSupportedStrategy(EGlyphCacheStrategy requested);      //old implementations of graphite might not support a requested strategy 
+    static bool setGlyphCacheStrategy(const GrFace* pFace, EGlyphCacheStrategy requestedStrategy);       //glyphs already loaded are unloaded. return value indicates success. failure keeps old cache.
+    static EGlyphCacheStrategy getGlyphStrategy(const GrFace* pFace);
+    static unsigned short numGlyphs(const GrFace* pFace);
+    static unsigned long numGlyphAccesses(const GrFace* pFace);
+    static unsigned long numGlyphLoads(const GrFace* pFace);
 
 private :
 #ifdef FIND_BROKEN_VIRTUALS
diff --git a/src/GlyphFaceCache.cpp b/src/GlyphFaceCache.cpp
index d76338c..c0a99dd 100644
--- a/src/GlyphFaceCache.cpp
+++ b/src/GlyphFaceCache.cpp
@@ -53,6 +53,29 @@ using namespace org::sil::graphite::v2;
 }
 
 
+/*static*/ EGlyphCacheStrategy GlyphFaceCache::nearestSupportedStrategy(EGlyphCacheStrategy requested)
+{
+    if (requested>=ePreload) return ePreload;
+    
+    return eOneCache;
+}
+
+
+
+/*static*/ GlyphFaceCache* GlyphFaceCache::makeCache(const GlyphFaceCacheHeader& hdr, EGlyphCacheStrategy requested)
+{
+    switch (nearestSupportedStrategy(requested))
+    {
+      case ePreload:
+            return new(hdr) GlyphFaceCachePreloaded(hdr);
+            
+      default:      //eOneCache
+            return new(hdr) GlyphFaceCacheOneItem(hdr);
+    }
+}
+
+
+
 GlyphFaceCacheOneItem::GlyphFaceCacheOneItem(const GlyphFaceCacheHeader& hdr)   //always use with the above new, passing in the same GlyphFaceCacheHeader
 :   GlyphFaceCache(hdr),
     m_LoadedGlyphNo(-1)   //-1 means none loaded
@@ -69,6 +92,12 @@ GlyphFaceCacheOneItem::GlyphFaceCacheOneItem(const GlyphFaceCacheHeader& hdr)
 }
 
 
+/*virtual*/ EGlyphCacheStrategy GlyphFaceCacheOneItem::getEnum() const
+{
+    return eOneCache;
+}
+
+
 /*virtual*/ const GlyphFace *GlyphFaceCacheOneItem::glyph(unsigned short glyphid) const      //result may be changed by subsequent call with a different glyphid
 {
     incAccesses();
@@ -119,6 +148,12 @@ GlyphFaceCachePreloaded::GlyphFaceCachePreloaded(const GlyphFaceCacheHeader& hdr
 }
 
 
+/*virtual*/ EGlyphCacheStrategy GlyphFaceCachePreloaded::getEnum() const
+{
+    return ePreload;
+}
+
+
 /*virtual*/ const GlyphFace *GlyphFaceCachePreloaded::glyph(unsigned short glyphid) const      //result may be changed by subsequent call with a different glyphid
 { 
     incAccesses();
diff --git a/src/GlyphFaceCache.h b/src/GlyphFaceCache.h
index 1b68753..767ccf6 100644
--- a/src/GlyphFaceCache.h
+++ b/src/GlyphFaceCache.h
@@ -1,12 +1,12 @@
 #pragma once
 
 #include "GlyphFace.h"
+#include "graphiteng/IFace.h"
 
 namespace org { namespace sil { namespace graphite { namespace v2 {
 
 class Segment;
 class Features;
-class IFace;
 
 
 class GlyphFaceCacheHeader
@@ -37,9 +37,13 @@ friend class GlyphFace;
 class GlyphFaceCache : public GlyphFaceCacheHeader
 {
 public:
-    GlyphFaceCache(const GlyphFaceCacheHeader& hdr) : GlyphFaceCacheHeader(hdr) {}
+    static EGlyphCacheStrategy nearestSupportedStrategy(EGlyphCacheStrategy requested);
+    static GlyphFaceCache* makeCache(const GlyphFaceCacheHeader& hdr, EGlyphCacheStrategy requested);
+
+    GlyphFaceCache(const GlyphFaceCacheHeader& hdr) : GlyphFaceCacheHeader(hdr), m_nAccesses(0), m_nLoads(0) {}
     virtual ~GlyphFaceCache() {}
     
+    virtual EGlyphCacheStrategy getEnum() const = 0 ;
     virtual const GlyphFace *glyph(unsigned short glyphid) const = 0 ;      //result may be changed by subsequent call with a different glyphid
     const GlyphFace *glyphSafe(unsigned short glyphid) const { return glyphid<numGlyphs()?glyph(glyphid):NULL; }
     uint16 glyphAttr(uint16 gid, uint8 gattr) const { if (gattr>=numAttrs()) return 0; const GlyphFace*p=glyphSafe(gid); return p?p->getAttr(gattr):0; }
@@ -47,12 +51,13 @@ public:
     CLASS_NEW_DELETE
     
 protected:
-    void incAccesses() const { ++m_Accesses; }      //don't count an access as a change
-    void incLoads() const { ++m_Loads; }            //const to allow lazy loading
+    void incAccesses() const { ++m_nAccesses; }      //don't count an access as a change
+    void incLoads() const { ++m_nLoads; }            //const to allow lazy loading
     
 private:
-    mutable unsigned long m_Accesses;
-    mutable unsigned long m_Loads;
+friend class IFace;
+    mutable unsigned long m_nAccesses;
+    mutable unsigned long m_nLoads;
 };
 
 
@@ -67,6 +72,7 @@ public:
     GlyphFaceCacheOneItem(const GlyphFaceCacheHeader& hdr);   //always use with the above new, passing in the same GlyphFaceCacheHeader
     virtual ~GlyphFaceCacheOneItem();
 
+    virtual EGlyphCacheStrategy getEnum() const;
     virtual const GlyphFace *glyph(unsigned short glyphid) const;      //result may be changed by subsequent call with a different glyphid
     
 private:
@@ -91,6 +97,7 @@ public:
     GlyphFaceCachePreloaded(const GlyphFaceCacheHeader& hdr);   //always use with the above new, passing in the same GlyphFaceCacheHeader
     virtual ~GlyphFaceCachePreloaded();
 
+    virtual EGlyphCacheStrategy getEnum() const;
     virtual const GlyphFace *glyph(unsigned short glyphid) const;      //result may be changed by subsequent call with a different glyphid
     
 private:
diff --git a/src/GrFace.cpp b/src/GrFace.cpp
index 5f4a1ff..dcad83c 100644
--- a/src/GrFace.cpp
+++ b/src/GrFace.cpp
@@ -15,16 +15,25 @@ GrFace::~GrFace()
 }
 
 
-bool GrFace::readGlyphs()
+bool GrFace::setGlyphCacheStrategy(EGlyphCacheStrategy requestedStrategy) const      //glyphs already loaded are unloaded
+{
+    GlyphFaceCache* pNewCache = GlyphFaceCache::makeCache(*m_pGlyphFaceCache, requestedStrategy);
+    if (!pNewCache)
+        return false;
+    
+    delete m_pGlyphFaceCache;
+    m_pGlyphFaceCache = pNewCache;
+    return true;
+}
+
+
+bool GrFace::readGlyphs(EGlyphCacheStrategy requestedStrategy)
 {
     GlyphFaceCacheHeader hdr;
     if (!hdr.initialize(m_face)) return false;
-    
-#if 1
-    m_pGlyphFaceCache = new(hdr) GlyphFaceCachePreloaded(hdr);
-#else
-    m_pGlyphFaceCache = new(hdr) GlyphFaceCacheOneItem(hdr);
-#endif
+
+    m_pGlyphFaceCache = GlyphFaceCache::makeCache(hdr, requestedStrategy);
+
     if (!m_pGlyphFaceCache) return false;
     m_upem = TtfUtil::DesignUnits(m_pGlyphFaceCache->m_pHead);
     // m_glyphidx = new unsigned short[m_numGlyphs];        // only need this if doing occasional glyph reads
diff --git a/src/GrFace.h b/src/GrFace.h
index 9eeebf6..09199a9 100644
--- a/src/GrFace.h
+++ b/src/GrFace.h
@@ -60,7 +60,8 @@ private:
     unsigned short numGlyphs() const { return m_pGlyphFaceCache->m_nGlyphs; }
 
 public:
-    bool readGlyphs();
+    bool setGlyphCacheStrategy(EGlyphCacheStrategy requestedStrategy) const;      //glyphs already loaded are unloaded
+    bool readGlyphs(EGlyphCacheStrategy requestedStrategy);
     bool readGraphite();
     bool readFeatures() { return m_features.readFont(m_face); }
     const Silf *chooseSilf(uint32 script) const;
@@ -70,6 +71,7 @@ public:
 
     CLASS_NEW_DELETE
 private:
+    friend class IFace;
 
     const IFace *m_face;                  // Where to get tables
     uint16 m_ascent;
@@ -77,7 +79,7 @@ private:
     // unsigned short *m_glyphidx;     // index for each glyph id in the font
     // unsigned short m_readglyphs;    // how many glyphs have we in m_glyphs?
     // unsigned short m_capacity;      // how big is m_glyphs
-    GlyphFaceCache* m_pGlyphFaceCache;
+    mutable GlyphFaceCache* m_pGlyphFaceCache;      //owned - never NULL
     unsigned short m_upem;          // design units per em
     unsigned short m_numSilf;       // number of silf subtables in the silf table
     Silf *m_silfs;                   // silf subtables.
diff --git a/src/IFace.cpp b/src/IFace.cpp
index b266630..2389def 100644
--- a/src/IFace.cpp
+++ b/src/IFace.cpp
@@ -193,14 +193,14 @@ void TtfFileFace::operator delete(void * p)
 }
 #endif			//!DISABLE_FILE_FONT
 
-GrFace* IFace::makeGrFace() const		//this must stay alive all the time when the GrFace is alive. When finished with the LoadeFace, call IFace::destroyGrFace
+GrFace* IFace::makeGrFace(EGlyphCacheStrategy requestedStrategy) const		//this must stay alive all the time when the GrFace is alive. When finished with the LoadeFace, call IFace::destroyGrFace
 {
     GrFace *res = new GrFace(this);
 #ifndef DISABLE_TRACING
     XmlTraceLog::get().openElement(ElementFace);
 #endif
     bool valid = true;
-    valid &= res->readGlyphs();
+    valid &= res->readGlyphs(requestedStrategy);
     valid &= res->readGraphite();
     valid &= res->readFeatures();
 #ifndef DISABLE_TRACING
@@ -236,5 +236,41 @@ GrFace* IFace::makeGrFace() const		//this must stay alive all the time when the
 }
 
 
+/*static*/ EGlyphCacheStrategy nearestSupportedStrategy(EGlyphCacheStrategy requested)      //old implementations of graphite might not support a requested strategy 
+{
+    return GlyphFaceCache::nearestSupportedStrategy(requested);
+}
+
+
+/*static*/ bool IFace::setGlyphCacheStrategy(const GrFace* pFace, EGlyphCacheStrategy requestedStrategy)      //glyphs already loaded are unloaded
+{
+    return pFace->setGlyphCacheStrategy(requestedStrategy);
+}
+
+
+/*static*/ EGlyphCacheStrategy IFace::getGlyphStrategy(const GrFace* pFace)
+{
+    return pFace->m_pGlyphFaceCache->getEnum();
+}
+
+
+/*static*/ unsigned short IFace::numGlyphs(const GrFace* pFace)
+{
+    return pFace->m_pGlyphFaceCache->numGlyphs();
+}
+
+
+/*static*/ unsigned long IFace::numGlyphAccesses(const GrFace* pFace)
+{
+    return pFace->m_pGlyphFaceCache->m_nAccesses;
+}
+
+
+
+/*static*/ unsigned long IFace::numGlyphLoads(const GrFace* pFace)
+{
+    return pFace->m_pGlyphFaceCache->m_nLoads;
+}
+
 
 

