commit 22de3dffbcfd752140e3c547287de4d6f9e2301d
Author: glen <glen@8f940c70-5916-0410-ac46-d1fa2fa6ea29>
Date:   Sun Sep 30 02:21:07 2007 +0000

    the array_job_list struct has gone far beyond the simple list of jobs that belonged to the array
    therefore I have renamed the struct job_array
    I've also renamed all instances of pajl (pointer to array job list) to pa (pointer to array)

diff --git a/src/include/array.h b/src/include/array.h
index 041f491d1..e48b0c78e 100644
--- a/src/include/array.h
+++ b/src/include/array.h
@@ -18,11 +18,11 @@
 #endif
 
 int is_array(char *id);
-array_job_list *get_array(char *id);
-int array_save(array_job_list *pajl);
+job_array *get_array(char *id);
+int array_save(job_array *pa);
 void get_parent_id(char *job_id, char *parent_id);
-array_job_list *recover_array_struct(char *path);
-int delete_array_struct(array_job_list *pajl);
+job_array *recover_array_struct(char *path);
+int delete_array_struct(job_array *pa);
 int setup_array_struct(job *pjob);
 
 
diff --git a/src/include/job.h b/src/include/job.h
index f6221527f..408d8edfa 100644
--- a/src/include/job.h
+++ b/src/include/job.h
@@ -390,7 +390,7 @@ typedef struct {
 #define ARRAY_STRUCT_VERSION 1
 
   /* pbs_server will keep a list of these structs, with one struct per job array*/
-  struct array_job_list {
+  struct job_array {
      list_link all_arrays;
      tlist_head array_alljobs;
      
@@ -409,7 +409,7 @@ typedef struct {
   
   };
   
-  typedef struct array_job_list array_job_list;
+  typedef struct job_array job_array;
 
 #endif
 
@@ -455,7 +455,7 @@ struct job {
 	int		ji_retryok;	/* ok to retry, some reject was temp */
 	tlist_head	ji_rejectdest;	/* list of rejected destinations */
 	list_link	ji_arrayjobs;	/* links to all jobs in same array */
-	array_job_list	*ji_arrayjoblist; /* pointer to array_job_list for this array */
+	job_array	*ji_arrayjoblist; /* pointer to job_array for this array */
         int		ji_isparent;    /* set to TRUE if this is a "parent job"*/
 #endif					/* END SERVER ONLY */
 
diff --git a/src/server/array_func.c b/src/server/array_func.c
index 9e43bc3b7..8bf794232 100644
--- a/src/server/array_func.c
+++ b/src/server/array_func.c
@@ -53,52 +53,52 @@ extern char *pbs_o_host;
 int is_array(char *id)
   {
 
-  array_job_list *pajl;
+  job_array *pa;
   
   
     
-  pajl = (array_job_list*)GET_NEXT(svr_jobarrays);  
-  while (pajl != NULL)
+  pa = (job_array*)GET_NEXT(svr_jobarrays);  
+  while (pa != NULL)
     {
-    if (strcmp(pajl->ai_qs.parent_id, id) == 0)
+    if (strcmp(pa->ai_qs.parent_id, id) == 0)
       {
       return TRUE;
       }
-    pajl = (array_job_list*)GET_NEXT(pajl->all_arrays);
+    pa = (job_array*)GET_NEXT(pa->all_arrays);
     }
   
   return FALSE;
   }
   
 /* return a server's array info struct corresponding to an array id */
-array_job_list *get_array(char *id)
+job_array *get_array(char *id)
   {
-  array_job_list *pajl;
+  job_array *pa;
    
     
-  pajl = (array_job_list*)GET_NEXT(svr_jobarrays);  
-  while (pajl != NULL)
+  pa = (job_array*)GET_NEXT(svr_jobarrays);  
+  while (pa != NULL)
     {
-    if (strcmp(pajl->ai_qs.parent_id, id) == 0)
+    if (strcmp(pa->ai_qs.parent_id, id) == 0)
       {
-      return pajl;
+      return pa;
       }
-    if (pajl == GET_NEXT(pajl->all_arrays))
+    if (pa == GET_NEXT(pa->all_arrays))
       {
-      pajl = NULL;
+      pa = NULL;
       }
     else
       {
-      pajl = (array_job_list*)GET_NEXT(pajl->all_arrays);
+      pa = (job_array*)GET_NEXT(pa->all_arrays);
       }
     }
     
-  return (array_job_list*)NULL;
+  return (job_array*)NULL;
   }
   
   
 /* save a job array struct to disk returns zero if no errors*/  
-int array_save(array_job_list *pajl)
+int array_save(job_array *pa)
 
   { 
   int fds;
@@ -106,7 +106,7 @@ int array_save(array_job_list *pajl)
   char namebuf[MAXPATHLEN];
   
   strcpy(namebuf, path_arrays);
-  strcat(namebuf, pajl->ai_qs.fileprefix);
+  strcat(namebuf, pa->ai_qs.fileprefix);
   strcat(namebuf, ARRAY_FILE_SUFFIX);
   
   
@@ -118,7 +118,7 @@ int array_save(array_job_list *pajl)
     return -1;
     }
     
-  write(fds,  &(pajl->ai_qs), sizeof(pajl->ai_qs));  
+  write(fds,  &(pa->ai_qs), sizeof(pa->ai_qs));  
   close(fds);
   
   return 0;
@@ -164,45 +164,45 @@ void get_parent_id(char *job_id, char *parent_id)
 
 /* recover_array_struct reads in  an array struct saved to disk and inserts it into 
    the servers list of arrays */
-array_job_list *recover_array_struct(char *path)
+job_array *recover_array_struct(char *path)
 {
    extern tlist_head svr_jobarrays;
-   array_job_list *pajl;
+   job_array *pa;
    int fd;
    
    /* allocate the storage for the struct */
-   pajl = (array_job_list*)malloc(sizeof(array_job_list));
+   pa = (job_array*)malloc(sizeof(job_array));
    
-   if (pajl == NULL)
+   if (pa == NULL)
      {
      return NULL;
      }
     
    /* initialize the linked list nodes */  
-   CLEAR_LINK(pajl->all_arrays);
-   CLEAR_HEAD(pajl->array_alljobs);
+   CLEAR_LINK(pa->all_arrays);
+   CLEAR_HEAD(pa->array_alljobs);
 	 
    fd = open(path, O_RDONLY,0);
    
    /* read the file into the struct previously allocated. 
     * TODO - check version of struct before trying to read the whole thing
     */
-   if (read(fd, &(pajl->ai_qs), sizeof(pajl->ai_qs)) != sizeof(pajl->ai_qs))
+   if (read(fd, &(pa->ai_qs), sizeof(pa->ai_qs)) != sizeof(pa->ai_qs))
      {
      sprintf(log_buffer,"unable to read %s", path);
 
      log_err(errno,"pbsd_init",log_buffer);
 
-     free(pajl);
+     free(pa);
      return(NULL);
      }
      
    close(fd);
 	 
    /* link the struct into the servers list of job arrays */ 
-   append_link(&svr_jobarrays, &pajl->all_arrays, (void*)pajl);
+   append_link(&svr_jobarrays, &pa->all_arrays, (void*)pa);
    
-   return pajl;
+   return pa;
 
 }
 
@@ -211,16 +211,16 @@ array_job_list *recover_array_struct(char *path)
  *  of jobs that belong to the array becomes zero.
  *  returns zero if there are no errors, non-zero otherwise
  */
-int delete_array_struct(array_job_list *pajl)
+int delete_array_struct(job_array *pa)
   {
  
   char path[MAXPATHLEN + 1];
   
   /* first thing to do is take this out of the servers list of all arrays */
-  delete_link(&pajl->all_arrays);
+  delete_link(&pa->all_arrays);
   
   strcpy(path, path_arrays);
-  strcat(path, pajl->ai_qs.fileprefix);
+  strcat(path, pa->ai_qs.fileprefix);
   strcat(path, ARRAY_FILE_SUFFIX);
   
  
@@ -233,7 +233,7 @@ int delete_array_struct(array_job_list *pajl)
     }
     
   strcpy(path,path_jobs);	/* delete script file */
-  strcat(path,pajl->ai_qs.fileprefix);
+  strcat(path,pa->ai_qs.fileprefix);
   strcat(path,JOB_SCRIPT_SUFFIX);
 
   if (unlink(path) < 0)
@@ -248,34 +248,34 @@ int delete_array_struct(array_job_list *pajl)
 
     log_record(PBSEVENT_DEBUG,
       PBS_EVENTCLASS_JOB,
-      pajl->ai_qs.parent_id,
+      pa->ai_qs.parent_id,
       log_buffer);
     }
 
   /* free the memory allocated for the struct */
-  free(pajl);  
+  free(pa);  
   return 0;
   }
   
   
 int setup_array_struct(job *pjob)
   {
-  array_job_list *pajl;
+  job_array *pa;
   struct work_task *wt;
   
   /* setup a link to this job array in the servers all_arrays list */
-  pajl = (array_job_list*)malloc(sizeof(array_job_list));
+  pa = (job_array*)malloc(sizeof(job_array));
     
-  pajl->ai_qs.struct_version = ARRAY_STRUCT_VERSION;
-  pajl->ai_qs.array_size = pjob->ji_wattr[(int)JOB_ATR_job_array_size].at_val.at_long;
-  strcpy(pajl->ai_qs.parent_id, pjob->ji_qs.ji_jobid);
-  strcpy(pajl->ai_qs.fileprefix, pjob->ji_qs.ji_fileprefix);
-  strncpy(pajl->ai_qs.owner, pjob->ji_wattr[(int)JOB_ATR_job_owner].at_val.at_str, PBS_MAXUSER + PBS_MAXSERVERNAME + 2);
-  strncpy(pajl->ai_qs.submit_host, get_variable(pjob,pbs_o_host), PBS_MAXSERVERNAME);
-  pajl->ai_qs.num_cloned = 0;
-  CLEAR_LINK(pajl->all_arrays);
-  CLEAR_HEAD(pajl->array_alljobs);
-  append_link(&svr_jobarrays, &pajl->all_arrays, (void*)pajl);
+  pa->ai_qs.struct_version = ARRAY_STRUCT_VERSION;
+  pa->ai_qs.array_size = pjob->ji_wattr[(int)JOB_ATR_job_array_size].at_val.at_long;
+  strcpy(pa->ai_qs.parent_id, pjob->ji_qs.ji_jobid);
+  strcpy(pa->ai_qs.fileprefix, pjob->ji_qs.ji_fileprefix);
+  strncpy(pa->ai_qs.owner, pjob->ji_wattr[(int)JOB_ATR_job_owner].at_val.at_str, PBS_MAXUSER + PBS_MAXSERVERNAME + 2);
+  strncpy(pa->ai_qs.submit_host, get_variable(pjob,pbs_o_host), PBS_MAXSERVERNAME);
+  pa->ai_qs.num_cloned = 0;
+  CLEAR_LINK(pa->all_arrays);
+  CLEAR_HEAD(pa->array_alljobs);
+  append_link(&svr_jobarrays, &pa->all_arrays, (void*)pa);
     
   if (job_save(pjob,SAVEJOB_FULL) != 0) 
     {
diff --git a/src/server/job_func.c b/src/server/job_func.c
index c4c6707e5..fb1fdf297 100644
--- a/src/server/job_func.c
+++ b/src/server/job_func.c
@@ -158,9 +158,9 @@ void unload_sp_switch A_((job *pjob));
 #endif	/*  PBS_MOM */
 
 #ifndef PBS_MOM
-extern int array_save(array_job_list *);
-extern array_job_list *get_array(char *id);
-extern int delete_array_struct(array_job_list *pajl);
+extern int array_save(job_array *);
+extern job_array *get_array(char *id);
+extern int delete_array_struct(job_array *pa);
 #endif
 
 /* Local Private Functions */
@@ -763,7 +763,7 @@ job *job_clone(
   int 		i;
   int           slen;
   
-  array_job_list *pajl;
+  job_array *pa;
 
   if (taskid > PBS_MAXJOBARRAY)
     {
@@ -929,11 +929,11 @@ job *job_clone(
     INCR);  
 
   /* we need to link the cloned job into the array task list */
-  pajl = get_array(poldjob->ji_qs.ji_jobid);
+  pa = get_array(poldjob->ji_qs.ji_jobid);
   
   CLEAR_LINK(pnewjob->ji_arrayjobs);
-  append_link(&pajl->array_alljobs, &pnewjob->ji_arrayjobs, (void*)pnewjob);
-  pnewjob->ji_arrayjoblist = pajl;
+  append_link(&pa->array_alljobs, &pnewjob->ji_arrayjobs, (void*)pnewjob);
+  pnewjob->ji_arrayjoblist = pa;
  
 
   return pnewjob;
@@ -956,12 +956,12 @@ struct work_task *ptask)
   int newsub;
   int rc;
   char namebuf[MAXPATHLEN];
-  array_job_list *pajl;
+  job_array *pa;
   pjob = (job*)(ptask->wt_parm1);
   
-  pajl = get_array(pjob->ji_qs.ji_jobid);
+  pa = get_array(pjob->ji_qs.ji_jobid);
   
-  startindex = pajl->ai_qs.num_cloned;
+  startindex = pa->ai_qs.num_cloned;
   
   strcpy(namebuf, path_jobs);
   strcat(namebuf, pjob->ji_qs.ji_fileprefix);
@@ -999,8 +999,8 @@ struct work_task *ptask)
       job_purge(pjobclone);
       }
       
-    pajl->ai_qs.num_cloned++;
-    array_save(pajl);
+    pa->ai_qs.num_cloned++;
+    array_save(pa);
     }
   
   
@@ -1018,7 +1018,7 @@ struct work_task *ptask)
     job_purge(pjob);
     
     /* scan over all the jobs in the array and unset the hold */
-    pjob = GET_NEXT(pajl->array_alljobs);
+    pjob = GET_NEXT(pa->array_alljobs);
     while (pjob != NULL)
       {	
       pjob->ji_wattr[(int)JOB_ATR_hold].at_val.at_long &= ~HOLD_a;
diff --git a/src/server/job_recov.c b/src/server/job_recov.c
index dbe0a80eb..eb9bcd874 100644
--- a/src/server/job_recov.c
+++ b/src/server/job_recov.c
@@ -126,7 +126,7 @@ int recov_tmsock(int,job *);
 extern int job_qs_upgrade(job *,int);
 #ifndef PBS_MOM
 extern void get_parent_id(char *job_id, char *parent_id);
-extern array_job_list *get_array(char *id);
+extern job_array *get_array(char *id);
 #endif
 /* global data items */
 
@@ -390,7 +390,7 @@ job *job_recov(
   int    qs_upgrade;
 #ifndef PBS_MOM
   char   parent_id[PBS_MAXSVRJOBID + 1];
-  array_job_list *pajl;
+  job_array *pa;
 #endif
   
   qs_upgrade = FALSE;
@@ -542,14 +542,14 @@ job *job_recov(
        to the array. */
        
       get_parent_id(pj->ji_qs.ji_jobid, parent_id);
-      pajl = get_array(parent_id);
+      pa = get_array(parent_id);
       if (strcmp(parent_id, pj->ji_qs.ji_jobid) == 0)
         {
 	pj->ji_isparent = TRUE;
 	}
       else
         {
-        if (pajl == NULL)
+        if (pa == NULL)
           {
           /* couldn't find array struct, it must not have been recovered, 
              treat job as indepentent job */
@@ -558,9 +558,9 @@ job *job_recov(
         else
           {
 	   CLEAR_LINK(pj->ji_arrayjobs);
-	   append_link(&pajl->array_alljobs, &pj->ji_arrayjobs, (void*)pj);
-	   pj->ji_arrayjoblist = pajl;
-	   pajl->jobs_recovered++;
+	   append_link(&pa->array_alljobs, &pj->ji_arrayjobs, (void*)pj);
+	   pj->ji_arrayjoblist = pa;
+	   pa->jobs_recovered++;
 	  }
 	}
     }
diff --git a/src/server/pbsd_init.c b/src/server/pbsd_init.c
index 6f6f6f897..75e612926 100644
--- a/src/server/pbsd_init.c
+++ b/src/server/pbsd_init.c
@@ -206,7 +206,7 @@ extern void   set_old_nodes A_((job *));
 extern void   acct_close A_((void));
 extern struct work_task *apply_job_delete_nanny A_((struct job *,int));
 extern int     net_move A_((job *,struct batch_request *));
-extern int delete_array_struct(array_job_list *pajl);
+extern int delete_array_struct(job_array *pa);
 extern void  job_clone_wt A_((struct work_task *));
 
 /* Private functions in this file */
@@ -266,7 +266,7 @@ int pbsd_init(
   
   
   struct work_task *wt;
-  array_job_list *pajl;
+  job_array *pa;
 
   char   EMsg[1024];
 
@@ -708,14 +708,14 @@ int pbsd_init(
            continue;
 	 
 	 
-	 pajl = (array_job_list*)malloc(sizeof(array_job_list));
-	 CLEAR_LINK(pajl->all_arrays);
-	 CLEAR_HEAD(pajl->array_alljobs);
-	 pajl->jobs_recovered = 0;
+	 pa = (job_array*)malloc(sizeof(job_array));
+	 CLEAR_LINK(pa->all_arrays);
+	 CLEAR_HEAD(pa->array_alljobs);
+	 pa->jobs_recovered = 0;
 	 
 	 fd = open(pdirent->d_name, O_RDONLY,0);
 	 	 	 
-	 if (read(fd, &(pajl->ai_qs), sizeof(pajl->ai_qs)) != sizeof(pajl->ai_qs))
+	 if (read(fd, &(pa->ai_qs), sizeof(pa->ai_qs)) != sizeof(pa->ai_qs))
 	   {
 	   sprintf(log_buffer,"unable to read %s", pdirent->d_name);
 
@@ -726,7 +726,7 @@ int pbsd_init(
 	   
 	 close(fd);
 	 
-	 append_link(&svr_jobarrays, &pajl->all_arrays, (void*)pajl);
+	 append_link(&svr_jobarrays, &pa->all_arrays, (void*)pa);
 	 
 	 }
        else
@@ -930,13 +930,13 @@ int pbsd_init(
   /* look for empty arrays and delete them 
      also look for arrays that weren't fully built and setup a work task to 
      continue the cloning process*/
-  pajl = (array_job_list*)GET_NEXT(svr_jobarrays);  
-  while (pajl != NULL)
+  pa = (job_array*)GET_NEXT(svr_jobarrays);  
+  while (pa != NULL)
     {
-    if (pajl->ai_qs.num_cloned != pajl->ai_qs.array_size)
+    if (pa->ai_qs.num_cloned != pa->ai_qs.array_size)
       {
       
-      job *pjob = find_job(pajl->ai_qs.parent_id);
+      job *pjob = find_job(pa->ai_qs.parent_id);
       if (pjob == NULL)
         {
         /* TODO, we need to so something here, we can't finish cloning the array! */
@@ -950,20 +950,20 @@ int pbsd_init(
 	   we probably should delete that last job and start the cloning process off at 
 	   num_cloned */
         wt = set_task(WORK_Timed,time_now+1,job_clone_wt,(void*)pjob);
-        wt->wt_aux = pajl->ai_qs.num_cloned;
+        wt->wt_aux = pa->ai_qs.num_cloned;
         }
       
       }
-    else if (GET_NEXT(pajl->array_alljobs) == pajl->array_alljobs.ll_struct)
+    else if (GET_NEXT(pa->array_alljobs) == pa->array_alljobs.ll_struct)
       {
-      array_job_list *temp = (array_job_list*)GET_NEXT(pajl->all_arrays);
-      delete_array_struct(pajl);
-      pajl = temp;
+      job_array *temp = (job_array*)GET_NEXT(pa->all_arrays);
+      delete_array_struct(pa);
+      pa = temp;
       }
     
-    if (pajl != NULL)
+    if (pa != NULL)
       {
-      pajl = (array_job_list*)GET_NEXT(pajl->all_arrays);
+      pa = (job_array*)GET_NEXT(pa->all_arrays);
       }
       
     }
diff --git a/src/server/req_deletearray.c b/src/server/req_deletearray.c
index aa61f6d29..fc9c77164 100644
--- a/src/server/req_deletearray.c
+++ b/src/server/req_deletearray.c
@@ -27,15 +27,15 @@ extern char *msg_permlog;
 
 void req_deletearray(struct batch_request *preq)
   {
-  array_job_list *pajl;
+  job_array *pa;
   
-  pajl = get_array(preq->rq_ind.rq_delete.rq_objname);
+  pa = get_array(preq->rq_ind.rq_delete.rq_objname);
   
   /* this should be impossible since prior to calling req_deletearray we checked the objname 
    * to see if it is an array.  Unless something is confirmed as an array id it is treated as a job id, 
    * so all unknown id errors end up being handled by the req_delete() function 
    */
-  if (pajl == NULL)
+  if (pa == NULL)
     {
     log_event(
       PBSEVENT_DEBUG, 
@@ -45,7 +45,7 @@ void req_deletearray(struct batch_request *preq)
     req_reject(PBSE_INTERNAL,0,preq,NULL, "cannot locate job array");
     }
   
-  if (svr_authorize_req(preq, pajl->ai_qs.owner,pajl->ai_qs.submit_host) == -1)
+  if (svr_authorize_req(preq, pa->ai_qs.owner,pa->ai_qs.submit_host) == -1)
     {
     sprintf(log_buffer,msg_permlog, 
       preq->rq_type,

