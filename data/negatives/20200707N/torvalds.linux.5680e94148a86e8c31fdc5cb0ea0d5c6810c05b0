commit 5680e94148a86e8c31fdc5cb0ea0d5c6810c05b0
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Apr 11 10:59:09 2011 +0200

    serial/imx: read cts state only after acking cts change irq
    
    If cts changes between reading the level at the cts input (USR1_RTSS)
    and acking the irq (USR1_RTSD) the last edge doesn't generate an irq and
    uart_handle_cts_change is called with a outdated value for cts.
    
    The race was introduced by commit
    
            ceca629 ([ARM] 2971/1: i.MX uart handle rts irq)
    
    Reported-by: Arwed Springer <Arwed.Springer@de.trumpf.com>
    Tested-by: Arwed Springer <Arwed.Springer@de.trumpf.com>
    Cc: stable@kernel.org # 2.6.14+
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c
index cb36b0d4ef3c..62df72d9f0aa 100644
--- a/drivers/tty/serial/imx.c
+++ b/drivers/tty/serial/imx.c
@@ -382,12 +382,13 @@ static void imx_start_tx(struct uart_port *port)
 static irqreturn_t imx_rtsint(int irq, void *dev_id)
 {
 	struct imx_port *sport = dev_id;
-	unsigned int val = readl(sport->port.membase + USR1) & USR1_RTSS;
+	unsigned int val;
 	unsigned long flags;
 
 	spin_lock_irqsave(&sport->port.lock, flags);
 
 	writel(USR1_RTSD, sport->port.membase + USR1);
+	val = readl(sport->port.membase + USR1) & USR1_RTSS;
 	uart_handle_cts_change(&sport->port, !!val);
 	wake_up_interruptible(&sport->port.state->port.delta_msr_wait);
 

