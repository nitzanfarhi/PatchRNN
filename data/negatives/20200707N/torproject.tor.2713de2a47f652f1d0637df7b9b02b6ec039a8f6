commit 2713de2a47f652f1d0637df7b9b02b6ec039a8f6
Author: Nick Mathewson <nickm@torproject.org>
Date:   Thu Jun 30 14:36:31 2016 -0400

    Fix more naked strdup/malloc/free instances

diff --git a/src/or/config.c b/src/or/config.c
index 18ee9790f..45acd3998 100644
--- a/src/or/config.c
+++ b/src/or/config.c
@@ -2075,7 +2075,7 @@ config_parse_commandline(int argc, char **argv, int ignore_errors,
 
     if (want_arg == ARGUMENT_NECESSARY && is_last) {
       if (ignore_errors) {
-        arg = strdup("");
+        arg = tor_strdup("");
       } else {
         log_warn(LD_CONFIG,"Command-line option '%s' with no value. Failing.",
             argv[i]);
@@ -4125,11 +4125,11 @@ have_enough_mem_for_dircache(const or_options_t *options, size_t total_mem,
   if (options->DirCache) {
     if (total_mem < DIRCACHE_MIN_BANDWIDTH) {
       if (options->BridgeRelay) {
-        *msg = strdup("Running a Bridge with less than "
+        *msg = tor_strdup("Running a Bridge with less than "
                       STRINGIFY(DIRCACHE_MIN_MB_BANDWIDTH) " MB of memory is "
                       "not recommended.");
       } else {
-        *msg = strdup("Being a directory cache (default) with less than "
+        *msg = tor_strdup("Being a directory cache (default) with less than "
                       STRINGIFY(DIRCACHE_MIN_MB_BANDWIDTH) " MB of memory is "
                       "not recommended and may consume most of the available "
                       "resources, consider disabling this functionality by "
@@ -4138,7 +4138,7 @@ have_enough_mem_for_dircache(const or_options_t *options, size_t total_mem,
     }
   } else {
     if (total_mem >= DIRCACHE_MIN_BANDWIDTH) {
-      *msg = strdup("DirCache is disabled and we are configured as a "
+      *msg = tor_strdup("DirCache is disabled and we are configured as a "
                "relay. This may disqualify us from becoming a guard in the "
                "future.");
     }
diff --git a/src/test/test_dir.c b/src/test/test_dir.c
index 576b4e45d..98823c78e 100644
--- a/src/test/test_dir.c
+++ b/src/test/test_dir.c
@@ -2849,7 +2849,7 @@ test_dir_dirserv_set_routerstatus_testing(void *arg)
   (void)arg;
 
   /* Init options */
-  mock_options = malloc(sizeof(or_options_t));
+  mock_options = tor_malloc(sizeof(or_options_t));
   reset_options(mock_options, &mock_get_options_calls);
 
   MOCK(get_options, mock_get_options);
@@ -2867,10 +2867,10 @@ test_dir_dirserv_set_routerstatus_testing(void *arg)
   routerset_parse(routerset_none, ROUTERSET_NONE_STR, "No routers");
 
   /* Init routerstatuses */
-  routerstatus_t *rs_a = malloc(sizeof(routerstatus_t));
+  routerstatus_t *rs_a = tor_malloc(sizeof(routerstatus_t));
   reset_routerstatus(rs_a, ROUTER_A_ID_STR, ROUTER_A_IPV4);
 
-  routerstatus_t *rs_b = malloc(sizeof(routerstatus_t));
+  routerstatus_t *rs_b = tor_malloc(sizeof(routerstatus_t));
   reset_routerstatus(rs_b, ROUTER_B_ID_STR, ROUTER_B_IPV4);
 
   /* Sanity check that routersets correspond to routerstatuses.
@@ -3055,7 +3055,7 @@ test_dir_dirserv_set_routerstatus_testing(void *arg)
   tt_assert(rs_b->is_hs_dir == 1);
 
  done:
-  free(mock_options);
+  tor_free(mock_options);
   mock_options = NULL;
 
   UNMOCK(get_options);
@@ -3064,8 +3064,8 @@ test_dir_dirserv_set_routerstatus_testing(void *arg)
   routerset_free(routerset_a);
   routerset_free(routerset_none);
 
-  free(rs_a);
-  free(rs_b);
+  tor_free(rs_a);
+  tor_free(rs_b);
 }
 
 static void
@@ -4282,7 +4282,7 @@ test_dir_dump_unparseable_descriptors(void *data)
    * Set up options mock so we can force a tiny FIFO size and generate
    * cleanups.
    */
-  mock_options = malloc(sizeof(or_options_t));
+  mock_options = tor_malloc(sizeof(or_options_t));
   reset_options(mock_options, &mock_get_options_calls);
   mock_options->MaxUnparseableDescSizeToLog = 1536;
   MOCK(get_options, mock_get_options);
@@ -4795,7 +4795,7 @@ test_dir_dump_unparseable_descriptors(void *data)
   UNMOCK(options_get_datadir_fname2_suffix);
   UNMOCK(check_private_dir);
   UNMOCK(get_options);
-  free(mock_options);
+  tor_free(mock_options);
   mock_options = NULL;
 
   return;
@@ -5142,7 +5142,7 @@ test_dir_find_dl_schedule(void* data)
   smartlist_t client_boot_auth_only_cons, client_boot_auth_cons;
   smartlist_t client_boot_fallback_cons, bridge;
 
-  mock_options = malloc(sizeof(or_options_t));
+  mock_options = tor_malloc(sizeof(or_options_t));
   reset_options(mock_options, &mock_get_options_calls);
   MOCK(get_options, mock_get_options);
 
@@ -5251,7 +5251,7 @@ test_dir_find_dl_schedule(void* data)
   UNMOCK(networkstatus_consensus_is_bootstrapping);
   UNMOCK(networkstatus_consensus_can_use_extra_fallbacks);
   UNMOCK(get_options);
-  free(mock_options);
+  tor_free(mock_options);
   mock_options = NULL;
 }
 
diff --git a/src/test/test_dir_handle_get.c b/src/test/test_dir_handle_get.c
index 927fa8b61..328203724 100644
--- a/src/test/test_dir_handle_get.c
+++ b/src/test/test_dir_handle_get.c
@@ -467,7 +467,7 @@ static or_options_t *mock_options = NULL;
 static void
 init_mock_options(void)
 {
-  mock_options = malloc(sizeof(or_options_t));
+  mock_options = tor_malloc(sizeof(or_options_t));
   memset(mock_options, 0, sizeof(or_options_t));
   mock_options->TestingTorNetwork = 1;
 }
diff --git a/src/test/test_policy.c b/src/test/test_policy.c
index 913a2f303..14182af86 100644
--- a/src/test/test_policy.c
+++ b/src/test/test_policy.c
@@ -804,7 +804,7 @@ mock_get_interface_address6_list(int severity,
   tt_assert(template_list);
 
   SMARTLIST_FOREACH_BEGIN(template_list, tor_addr_t *, src_addr) {
-    tor_addr_t *dest_addr = malloc(sizeof(tor_addr_t));
+    tor_addr_t *dest_addr = tor_malloc(sizeof(tor_addr_t));
     memset(dest_addr, 0, sizeof(*dest_addr));
     tor_addr_copy_tight(dest_addr, src_addr);
     smartlist_add(clone_list, dest_addr);
diff --git a/src/test/test_rendcache.c b/src/test/test_rendcache.c
index c8279fcce..e210e053b 100644
--- a/src/test/test_rendcache.c
+++ b/src/test/test_rendcache.c
@@ -971,7 +971,7 @@ test_rend_cache_entry_free(void *data)
 
   // Handles non-NULL descriptor correctly
   e = tor_malloc_zero(sizeof(rend_cache_entry_t));
-  e->desc = (char *)malloc(10);
+  e->desc = tor_malloc(10);
   rend_cache_entry_free(e);
 
  /* done: */

