commit 1b9a8a4cf6381eb0905f7656bc1d9e290abc2693
Author: Stefan Eissing <icing@apache.org>
Date:   Fri Mar 11 12:59:29 2016 +0000

    mod_proxy_http2: using SUSPENDED from handler when passing request_rec to other engine
    
    git-svn-id: https://svn.apache.org/repos/asf/httpd/httpd/trunk@1734549 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/modules/http2/h2_task.c b/modules/http2/h2_task.c
index 7b1aa8df67..97b23f9281 100644
--- a/modules/http2/h2_task.c
+++ b/modules/http2/h2_task.c
@@ -86,27 +86,6 @@ static apr_status_t h2_filter_read_response(ap_filter_t* f,
     return h2_from_h1_read_response(task->output->from_h1, f, bb);
 }
 
-static apr_status_t h2_response_freeze_filter(ap_filter_t* f,
-                                              apr_bucket_brigade* bb)
-{
-    h2_task *task = f->ctx;
-    AP_DEBUG_ASSERT(task);
-    
-    if (task->frozen) {
-        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, f->r,
-                      "h2_response_freeze_filter, saving");
-        return ap_save_brigade(f, &task->output->frozen_bb, &bb, task->c->pool);
-    }
-    
-    if (APR_BRIGADE_EMPTY(bb)) {
-        return APR_SUCCESS;
-    }
-
-    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, f->r,
-                  "h2_response_freeze_filter, passing");
-    return ap_pass_brigade(f->next, bb);
-}
-
 /*******************************************************************************
  * Register various hooks
  */
@@ -141,8 +120,6 @@ void h2_task_register_hooks(void)
                               NULL, AP_FTYPE_PROTOCOL);
     ap_register_output_filter("H2_TRAILERS", h2_response_trailers_filter,
                               NULL, AP_FTYPE_PROTOCOL);
-    ap_register_output_filter("H2_RESPONSE_FREEZE", h2_response_freeze_filter,
-                              NULL, AP_FTYPE_RESOURCE);
 }
 
 /* post config init */
@@ -317,12 +294,8 @@ static int h2_task_process_conn(conn_rec* c)
 apr_status_t h2_task_freeze(h2_task *task, request_rec *r)
 {   
     if (!task->frozen) {
-        conn_rec *c = task->c;
-        
         task->frozen = 1;
-        task->output->frozen_bb = apr_brigade_create(c->pool, c->bucket_alloc);
-        ap_add_output_filter("H2_RESPONSE_FREEZE", task, r, r->connection);
-        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, 
+        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, task->c, 
                       "h2_task(%s), frozen", task->id);
     }
     return APR_SUCCESS;
diff --git a/modules/http2/h2_task_output.c b/modules/http2/h2_task_output.c
index 025c139873..3ef884ffd2 100644
--- a/modules/http2/h2_task_output.c
+++ b/modules/http2/h2_task_output.c
@@ -155,8 +155,8 @@ apr_status_t h2_task_output_write(h2_task_output *output,
     
     if (output->task->frozen) {
         h2_util_bb_log(output->c, output->task->stream_id, APLOG_TRACE2,
-                       "frozen task output write", bb);
-        return ap_save_brigade(f, &output->frozen_bb, &bb, output->c->pool);
+                       "frozen task output write, ignored", bb);
+        return APR_SUCCESS;
     }
     
     status = open_if_needed(output, f, bb, "write");
@@ -190,18 +190,11 @@ apr_status_t h2_task_output_write(h2_task_output *output,
 
 void h2_task_output_close(h2_task_output *output)
 {
-    if (output->task->frozen) {
-        return;
-    }
     open_if_needed(output, NULL, NULL, "close");
     if (output->state != H2_TASK_OUT_DONE) {
-        if (output->frozen_bb && !APR_BRIGADE_EMPTY(output->frozen_bb)) {
-            h2_mplx_out_write(output->task->mplx, output->task->stream_id, 
-                NULL, 1, output->frozen_bb, NULL, NULL);
-        }
-        output->state = H2_TASK_OUT_DONE;
         h2_mplx_out_close(output->task->mplx, output->task->stream_id, 
                           get_trailers(output));
+        output->state = H2_TASK_OUT_DONE;
     }
 }
 
diff --git a/modules/http2/h2_task_output.h b/modules/http2/h2_task_output.h
index 26326f0908..7861039e0d 100644
--- a/modules/http2/h2_task_output.h
+++ b/modules/http2/h2_task_output.h
@@ -44,7 +44,6 @@ struct h2_task_output {
 
     apr_off_t written;
     apr_bucket_brigade *bb;
-    apr_bucket_brigade *frozen_bb;
 };
 
 h2_task_output *h2_task_output_create(struct h2_task *task, conn_rec *c);
diff --git a/modules/http2/mod_proxy_http2.c b/modules/http2/mod_proxy_http2.c
index db0e33e4ef..c98db1a7bb 100644
--- a/modules/http2/mod_proxy_http2.c
+++ b/modules/http2/mod_proxy_http2.c
@@ -367,7 +367,7 @@ static apr_status_t proxy_engine_run(h2_proxy_ctx *ctx) {
     return status;
 }
 
-static apr_status_t setup_engine(h2_proxy_ctx *ctx)
+static apr_status_t push_request_somewhere(h2_proxy_ctx *ctx)
 {
     conn_rec *c = ctx->owner;
     const char *engine_type, *hostname;
@@ -386,10 +386,10 @@ static apr_status_t setup_engine(h2_proxy_ctx *ctx)
             == APR_SUCCESS && ctx->engine == NULL) {
             /* Another engine instance has taken over processing of this
              * request. */
-            ctx->r_status = APR_SUCCESS;
+            ctx->r_status = SUSPENDED;
             ctx->next = NULL;
             
-            return APR_EOF;
+            return APR_SUCCESS;
         }
     }
     
@@ -501,8 +501,14 @@ run_connect:
         goto cleanup;
     }
     
-    if (!ctx->engine && setup_engine(ctx) != APR_SUCCESS) {
-        goto cleanup;
+    /* If we are not already hosting an engine, try to push the request 
+     * to an already existing engine or host a new engine here. */
+    if (!ctx->engine) {
+        push_request_somewhere(ctx);
+        if (ctx->r_status == SUSPENDED) {
+            /* request was pushed to another engine */
+            goto cleanup;
+        }
     }
     
     /* Step Two: Make the Connection (or check that an already existing

