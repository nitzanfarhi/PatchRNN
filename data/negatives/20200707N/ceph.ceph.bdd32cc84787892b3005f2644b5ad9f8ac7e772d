commit bdd32cc84787892b3005f2644b5ad9f8ac7e772d
Author: David Zafman <dzafman@redhat.com>
Date:   Thu Aug 16 15:24:11 2018 -0700

    osd: Use colon to separate error message from other info
    
    Signed-off-by: David Zafman <dzafman@redhat.com>

diff --git a/src/osd/PGBackend.cc b/src/osd/PGBackend.cc
index bc5a6ea14d..a0b4f726f0 100644
--- a/src/osd/PGBackend.cc
+++ b/src/osd/PGBackend.cc
@@ -992,8 +992,8 @@ map<pg_shard_t, ScrubMap *>::const_iterator
 
 out:
     if (error)
-        errorstream << pgid.pgid << " shard " << l << ": soid " << obj
-		    << " " << shard_errorstream.str() << "\n";
+        errorstream << pgid.pgid << " shard " << l << " soid " << obj
+		    << " : " << shard_errorstream.str() << "\n";
     // Keep scanning other shards
   }
   dout(10) << __func__ << ": selecting osd " << auth->first
@@ -1046,7 +1046,7 @@ void PGBackend::be_compare_scrubmaps(
 	++shallow_errors;
       store->add_object_error(k->pool, object_error);
       errorstream << pgid.pgid << " soid " << *k
-		  << ": failed to pick suitable object info\n";
+		  << " : failed to pick suitable object info\n";
       continue;
     }
     object_error.set_version(auth_oi.user_version);
@@ -1084,7 +1084,7 @@ void PGBackend::be_compare_scrubmaps(
 	  fix_digest = true;
 	  // Clear the error
 	  shard_map[j->first].clear_data_digest_mismatch_info();
-	  errorstream << pgid << " : soid " << *k << " repairing object info data_digest" << "\n";
+	  errorstream << pgid << " soid " << *k << " : repairing object info data_digest" << "\n";
 	}
 	// Some errors might have already been set in be_select_auth_object()
 	if (shard_map[j->first].errors != 0) {
@@ -1096,13 +1096,13 @@ void PGBackend::be_compare_scrubmaps(
 	  // Only true if be_compare_scrub_objects() found errors and put something
 	  // in ss.
 	  if (found)
-	    errorstream << pgid << " shard " << j->first << ": soid " << *k
-		      << " " << ss.str() << "\n";
+	    errorstream << pgid << " shard " << j->first << " soid " << *k
+		      << " : " << ss.str() << "\n";
 	} else if (found) {
 	  // Track possible shard to use as authoritative, if needed
 	  // There are errors, without identifying the shard
 	  object_errors.insert(j->first);
-	  errorstream << pgid << " : soid " << *k << " " << ss.str() << "\n";
+	  errorstream << pgid << " soid " << *k << " : " << ss.str() << "\n";
 	} else {
 	  // XXX: The auth shard might get here that we don't know
 	  // that it has the "correct" data.
@@ -1114,8 +1114,7 @@ void PGBackend::be_compare_scrubmaps(
         shard_map[j->first].primary = (j->first == get_parent()->whoami_shard());
 	// Can't have any other errors if there is no information available
 	++shallow_errors;
-	errorstream << pgid << " shard " << j->first << " missing " << *k
-		    << "\n";
+	errorstream << pgid << " shard " << j->first << " " << *k << " : missing\n";
       }
       object_error.add_shard(j->first, shard_map[j->first]);
     }
@@ -1123,7 +1122,7 @@ void PGBackend::be_compare_scrubmaps(
     if (auth_list.empty()) {
       if (object_errors.empty()) {
         errorstream << pgid.pgid << " soid " << *k
-		  << ": failed to pick suitable auth object\n";
+		  << " : failed to pick suitable auth object\n";
         goto out;
       }
       // Object errors exist and nothing in auth_list
diff --git a/src/osd/PrimaryLogPG.cc b/src/osd/PrimaryLogPG.cc
index dc4a7a358c..8702a77992 100644
--- a/src/osd/PrimaryLogPG.cc
+++ b/src/osd/PrimaryLogPG.cc
@@ -14536,7 +14536,7 @@ void PrimaryLogPG::log_missing(unsigned missing,
                << " skipped " << missing << " clone(s) in cache tier" << dendl;
   } else {
     clog->info() << mode << " " << pgid << " " << head.get()
-		       << " " << missing << " missing clone(s)";
+		       << " : " << missing << " missing clone(s)";
   }
 }
 
@@ -14563,7 +14563,7 @@ unsigned PrimaryLogPG::process_clones_to(const boost::optional<hobject_t> &head,
     if (!allow_incomplete_clones) {
       next_clone.snap = **curclone;
       clog->error() << mode << " " << pgid << " " << head.get()
-			 << " expected clone " << next_clone << " " << missing
+			 << " : expected clone " << next_clone << " " << missing
                          << " missing";
       ++scrubber.shallow_errors;
       e.set_clone_missing(next_clone.snap);
@@ -14642,7 +14642,7 @@ void PrimaryLogPG::scrub_snapshot_metadata(
     if (p->second.attrs.count(OI_ATTR) == 0) {
       oi = boost::none;
       osd->clog->error() << mode << " " << info.pgid << " " << soid
-			<< " no '" << OI_ATTR << "' attr";
+			<< " : no '" << OI_ATTR << "' attr";
       ++scrubber.shallow_errors;
       soid_error.set_info_missing();
     } else {
@@ -14654,7 +14654,7 @@ void PrimaryLogPG::scrub_snapshot_metadata(
       } catch (buffer::error& e) {
 	oi = boost::none;
 	osd->clog->error() << mode << " " << info.pgid << " " << soid
-		<< " can't decode '" << OI_ATTR << "' attr " << e.what();
+		<< " : can't decode '" << OI_ATTR << "' attr " << e.what();
 	++scrubber.shallow_errors;
 	soid_error.set_info_corrupted();
         soid_error.set_info_missing(); // Not available too
@@ -14664,7 +14664,7 @@ void PrimaryLogPG::scrub_snapshot_metadata(
     if (oi) {
       if (pgbackend->be_get_ondisk_size(oi->size) != p->second.size) {
 	osd->clog->error() << mode << " " << info.pgid << " " << soid
-			   << " on disk size (" << p->second.size
+			   << " : on disk size (" << p->second.size
 			   << ") does not match object info size ("
 			   << oi->size << ") adjusted for ondisk to ("
 			   << pgbackend->be_get_ondisk_size(oi->size)
@@ -14732,10 +14732,10 @@ void PrimaryLogPG::scrub_snapshot_metadata(
       // If we couldn't read the head's snapset, just ignore clones
       if (head && !snapset) {
 	osd->clog->error() << mode << " " << info.pgid << " " << soid
-			  << " clone ignored due to missing snapset";
+			  << " : clone ignored due to missing snapset";
       } else {
 	osd->clog->error() << mode << " " << info.pgid << " " << soid
-			   << " is an unexpected clone";
+			   << " : is an unexpected clone";
       }
       ++scrubber.shallow_errors;
       soid_error.set_headless();
@@ -14767,7 +14767,7 @@ void PrimaryLogPG::scrub_snapshot_metadata(
 
       if (p->second.attrs.count(SS_ATTR) == 0) {
 	osd->clog->error() << mode << " " << info.pgid << " " << soid
-			  << " no '" << SS_ATTR << "' attr";
+			  << " : no '" << SS_ATTR << "' attr";
         ++scrubber.shallow_errors;
 	snapset = boost::none;
 	head_error.set_snapset_missing();
@@ -14782,7 +14782,7 @@ void PrimaryLogPG::scrub_snapshot_metadata(
         } catch (buffer::error& e) {
 	  snapset = boost::none;
           osd->clog->error() << mode << " " << info.pgid << " " << soid
-		<< " can't decode '" << SS_ATTR << "' attr " << e.what();
+		<< " : can't decode '" << SS_ATTR << "' attr " << e.what();
 	  ++scrubber.shallow_errors;
 	  head_error.set_snapset_corrupted();
         }
@@ -14796,7 +14796,7 @@ void PrimaryLogPG::scrub_snapshot_metadata(
 	  dout(20) << "  snapset " << snapset.get() << dendl;
 	  if (snapset->seq == 0) {
 	    osd->clog->error() << mode << " " << info.pgid << " " << soid
-			       << " snaps.seq not set";
+			       << " : snaps.seq not set";
 	    ++scrubber.shallow_errors;
 	    head_error.set_snapset_error();
           }
@@ -14812,13 +14812,13 @@ void PrimaryLogPG::scrub_snapshot_metadata(
 
       if (snapset->clone_size.count(soid.snap) == 0) {
 	osd->clog->error() << mode << " " << info.pgid << " " << soid
-			   << " is missing in clone_size";
+			   << " : is missing in clone_size";
 	++scrubber.shallow_errors;
 	soid_error.set_size_mismatch();
       } else {
         if (oi && oi->size != snapset->clone_size[soid.snap]) {
 	  osd->clog->error() << mode << " " << info.pgid << " " << soid
-			     << " size " << oi->size << " != clone_size "
+			     << " : size " << oi->size << " != clone_size "
 			     << snapset->clone_size[*curclone];
 	  ++scrubber.shallow_errors;
 	  soid_error.set_size_mismatch();
@@ -14826,7 +14826,7 @@ void PrimaryLogPG::scrub_snapshot_metadata(
 
         if (snapset->clone_overlap.count(soid.snap) == 0) {
 	  osd->clog->error() << mode << " " << info.pgid << " " << soid
-			     << " is missing in clone_overlap";
+			     << " : is missing in clone_overlap";
 	  ++scrubber.shallow_errors;
 	  soid_error.set_size_mismatch();
 	} else {
@@ -14849,7 +14849,7 @@ void PrimaryLogPG::scrub_snapshot_metadata(
 
 	  if (bad_interval_set) {
 	    osd->clog->error() << mode << " " << info.pgid << " " << soid
-			       << " bad interval_set in clone_overlap";
+			       << " : bad interval_set in clone_overlap";
 	    ++scrubber.shallow_errors;
 	    soid_error.set_size_mismatch();
 	  } else {
@@ -14897,8 +14897,8 @@ void PrimaryLogPG::scrub_snapshot_metadata(
       continue;
     } else if (obc->obs.oi.soid != p->first) {
       osd->clog->error() << info.pgid << " " << mode
-			 << " object " << p->first
-			 << " has a valid oi attr with a mismatched name, "
+			 << " " << p->first
+			 << " : object has a valid oi attr with a mismatched name, "
 			 << " obc->obs.oi.soid: " << obc->obs.oi.soid;
       continue;
     }
@@ -14980,7 +14980,7 @@ void PrimaryLogPG::_scrub_finish()
       scrub_cstat.sum.num_whiteouts != info.stats.stats.sum.num_whiteouts ||
       scrub_cstat.sum.num_bytes != info.stats.stats.sum.num_bytes) {
     osd->clog->error() << info.pgid << " " << mode
-		      << " stat mismatch, got "
+		      << " : stat mismatch, got "
 		      << scrub_cstat.sum.num_objects << "/" << info.stats.stats.sum.num_objects << " objects, "
 		      << scrub_cstat.sum.num_object_clones << "/" << info.stats.stats.sum.num_object_clones << " clones, "
 		      << scrub_cstat.sum.num_objects_dirty << "/" << info.stats.stats.sum.num_objects_dirty << " dirty, "

