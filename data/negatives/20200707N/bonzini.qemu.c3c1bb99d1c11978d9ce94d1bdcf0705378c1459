commit c3c1bb99d1c11978d9ce94d1bdcf0705378c1459
Author: Peter Crosthwaite <peter.crosthwaite@xilinx.com>
Date:   Mon Mar 16 22:35:54 2015 -0700

    exec: Respect as_tranlsate_internal length clamp
    
    address_space_translate_internal will clamp the *plen length argument
    based on the size of the memory region being queried. The iommu walker
    logic in addresss_space_translate was ignoring this by discarding the
    post fn call value of *plen. Fix by just always using *plen as the
    length argument throughout the fn, removing the len local variable.
    
    This fixes a bootloader bug when a single elf section spans multiple
    QEMU memory regions.
    
    Signed-off-by: Peter Crosthwaite <peter.crosthwaite@xilinx.com>
    Message-Id: <1426570554-15940-1-git-send-email-peter.crosthwaite@xilinx.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/exec.c b/exec.c
index e97071a3ec..8b922db612 100644
--- a/exec.c
+++ b/exec.c
@@ -380,7 +380,6 @@ MemoryRegion *address_space_translate(AddressSpace *as, hwaddr addr,
     IOMMUTLBEntry iotlb;
     MemoryRegionSection *section;
     MemoryRegion *mr;
-    hwaddr len = *plen;
 
     rcu_read_lock();
     for (;;) {
@@ -395,7 +394,7 @@ MemoryRegion *address_space_translate(AddressSpace *as, hwaddr addr,
         iotlb = mr->iommu_ops->translate(mr, addr, is_write);
         addr = ((iotlb.translated_addr & ~iotlb.addr_mask)
                 | (addr & iotlb.addr_mask));
-        len = MIN(len, (addr | iotlb.addr_mask) - addr + 1);
+        *plen = MIN(*plen, (addr | iotlb.addr_mask) - addr + 1);
         if (!(iotlb.perm & (1 << is_write))) {
             mr = &io_mem_unassigned;
             break;
@@ -406,10 +405,9 @@ MemoryRegion *address_space_translate(AddressSpace *as, hwaddr addr,
 
     if (xen_enabled() && memory_access_is_direct(mr, is_write)) {
         hwaddr page = ((addr & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE) - addr;
-        len = MIN(page, len);
+        *plen = MIN(page, *plen);
     }
 
-    *plen = len;
     *xlat = addr;
     rcu_read_unlock();
     return mr;

