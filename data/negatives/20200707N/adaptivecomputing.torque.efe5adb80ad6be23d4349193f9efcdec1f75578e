commit efe5adb80ad6be23d4349193f9efcdec1f75578e
Author: David Beer <dbeer@adaptivecomputing.com>
Date:   Wed Sep 4 17:37:10 2013 -0600

    TRQ-2192. Fix a crash when getting a bad socket index to process_request().

diff --git a/src/server/process_request.c b/src/server/process_request.c
index fcd2d3bb3..bff91438f 100644
--- a/src/server/process_request.c
+++ b/src/server/process_request.c
@@ -333,6 +333,10 @@ int process_request(
   unsigned long         conn_addr;
   int                   sfds = chan->sock;
 
+  if ((sfds < 0) ||
+      (sfds >= PBS_NET_MAX_CONNECTIONS))
+    return(PBSE_SOCKET_CLOSE);
+
   pthread_mutex_lock(svr_conn[sfds].cn_mutex);
   conn_active = svr_conn[sfds].cn_active;
   conn_socktype = svr_conn[sfds].cn_socktype;
diff --git a/src/server/test/process_request/test_process_request.c b/src/server/test/process_request/test_process_request.c
index 32783de77..253995ed3 100644
--- a/src/server/test/process_request/test_process_request.c
+++ b/src/server/test/process_request/test_process_request.c
@@ -4,9 +4,18 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include "pbs_error.h"
-START_TEST(test_one)
+
+int process_request(struct tcp_chan *chan);
+
+START_TEST(test_process_request)
   {
+  struct tcp_chan chan;
 
+  memset(&chan, 0, sizeof(chan));
+  chan.sock = -1;
+  fail_unless(process_request(&chan) == PBSE_SOCKET_CLOSE);
+  chan.sock = 66034;
+  fail_unless(process_request(&chan) == PBSE_SOCKET_CLOSE);
 
   }
 END_TEST
@@ -21,8 +30,8 @@ END_TEST
 Suite *process_request_suite(void)
   {
   Suite *s = suite_create("process_request_suite methods");
-  TCase *tc_core = tcase_create("test_one");
-  tcase_add_test(tc_core, test_one);
+  TCase *tc_core = tcase_create("test_process_request");
+  tcase_add_test(tc_core, test_process_request);
   suite_add_tcase(s, tc_core);
 
   tc_core = tcase_create("test_two");

