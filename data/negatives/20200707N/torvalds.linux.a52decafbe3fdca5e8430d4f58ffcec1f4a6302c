commit a52decafbe3fdca5e8430d4f58ffcec1f4a6302c
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Tue Mar 13 10:07:15 2007 +0900

    [SCSI] tgt: remove the code to build sense
    
    tgt notifies a LLD of the failure with sense when it hits the
    user-space daemon bugs. However, tgt doesn't know anything about SCSI
    devices that initiators talks to. So it's impossible to send proper
    sense buffer (format and contents).
    
    This patch changes tgt not to notify a LLD of the failure with bogus
    sense. Instead, tgt just re-queues the failure command to the internal
    list so that it will be freed cleanly later on when the scsi_host is
    removed.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
index c05dff95bd95..2570f48a69c7 100644
--- a/drivers/scsi/scsi_tgt_lib.c
+++ b/drivers/scsi/scsi_tgt_lib.c
@@ -459,16 +459,6 @@ static struct request *tgt_cmd_hash_lookup(struct request_queue *q, u64 tag)
 	return rq;
 }
 
-static void scsi_tgt_build_sense(unsigned char *sense_buffer, unsigned char key,
-				 unsigned char asc, unsigned char asq)
-{
-	sense_buffer[0] = 0x70;
-	sense_buffer[2] = key;
-	sense_buffer[7] = 0xa;
-	sense_buffer[12] = asc;
-	sense_buffer[13] = asq;
-}
-
 int scsi_tgt_kspace_exec(int host_no, int result, u64 tag,
 			 unsigned long uaddr, u32 len, unsigned long sense_uaddr,
 			 u32 sense_len, u8 rw)
@@ -528,12 +518,21 @@ int scsi_tgt_kspace_exec(int host_no, int result, u64 tag,
 			 * user-space daemon bugs or OOM
 			 * TODO: we can do better for OOM.
 			 */
+			struct scsi_tgt_queuedata *qdata;
+			struct list_head *head;
+			unsigned long flags;
+
 			eprintk("cmd %p ret %d uaddr %lx len %d rw %d\n",
 				cmd, err, uaddr, len, rw);
-			cmd->result = SAM_STAT_CHECK_CONDITION;
-			memset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
-			scsi_tgt_build_sense(cmd->sense_buffer,
-					     HARDWARE_ERROR, 0, 0);
+
+			qdata = shost->uspace_req_q->queuedata;
+			head = &qdata->cmd_hash[cmd_hashfn(tcmd->tag)];
+
+			spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
+			list_add(&tcmd->hash_list, head);
+			spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
+
+			goto done;
 		}
 	}
 	err = scsi_tgt_transfer_response(cmd);

