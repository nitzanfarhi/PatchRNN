commit b0a8dece55ebe792b394e0c73fa365ad24c3ec32
Author: Kevin Liu <kliu5@marvell.com>
Date:   Sat Jan 5 17:18:28 2013 +0800

    mmc: sdhci: disable interrupt before free_irq
    
    Current code missed disabling interrupts before free irq which is shared.
    
    Notice below comments for function free_irq (kernel/irq/manage.c):
    On a shared IRQ the caller must ensure the interrupt is disabled
    on the card it drives before calling this function.
    
    Original code has below issue during suspend/resume when multiple SD
    hosts share the same IRQ:
    1. Assume there are two hosts (host1 for emmc while host2 for sd) share
    the same mmc irq.
    2. When system suspend, host2 will be suspended before host1.
    So the sequence is below:
            step1: irq handler for host2 removed ->
            step2: irq handler for host1 removed and irq disabled ->
            ... system suspended ...
            ... system resumed ...
            step3: irq enabled and the irq handler for host1 restored ->
            step4: irq handler for host2 restored
    3. So there is the buggy time slot that the irq is enabled but the irq
    handler for host2 is removed. Then host2 interrupt can be triggered
    but can't be handled at that moment.
    
    Signed-off-by: Jialing Fu <jlfu@marvell.com>
    Signed-off-by: Kevin Liu <kliu5@marvell.com>
    Signed-off-by: Chris Ball <cjb@laptop.org>

diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 1b97fe2d70ab..1165376592b9 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -2487,6 +2487,7 @@ int sdhci_suspend_host(struct sdhci_host *host)
 		return ret;
 	}
 
+	sdhci_mask_irqs(host, SDHCI_INT_ALL_MASK);
 	free_irq(host->irq, host);
 
 	return ret;
@@ -3142,6 +3143,7 @@ int sdhci_add_host(struct sdhci_host *host)
 #ifdef SDHCI_USE_LEDS_CLASS
 reset:
 	sdhci_reset(host, SDHCI_RESET_ALL);
+	sdhci_mask_irqs(host, SDHCI_INT_ALL_MASK);
 	free_irq(host->irq, host);
 #endif
 untasklet:
@@ -3184,6 +3186,7 @@ void sdhci_remove_host(struct sdhci_host *host, int dead)
 	if (!dead)
 		sdhci_reset(host, SDHCI_RESET_ALL);
 
+	sdhci_mask_irqs(host, SDHCI_INT_ALL_MASK);
 	free_irq(host->irq, host);
 
 	del_timer_sync(&host->timer);

