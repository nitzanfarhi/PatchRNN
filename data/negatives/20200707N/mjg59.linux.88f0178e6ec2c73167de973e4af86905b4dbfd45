commit 88f0178e6ec2c73167de973e4af86905b4dbfd45
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Wed Dec 12 14:58:12 2007 +1100

    [POWERPC] iSeries: don't printk with HV spinlock held
    
    Printk was observed to hang during module unload due to a limited
    window of characters that may be sent to the hypervisor.  The window
    only reexpands when we receive an ack from the HV and the spinlock here
    prevents us from ever processing that ack.  This fixes it by dropping
    the lock before doing the printk, then looping back to the top to
    reacquire the lock.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/iseries/lpevents.c b/arch/powerpc/platforms/iseries/lpevents.c
index 34bdbbe3ce59..275f49449839 100644
--- a/arch/powerpc/platforms/iseries/lpevents.c
+++ b/arch/powerpc/platforms/iseries/lpevents.c
@@ -121,6 +121,7 @@ void process_hvlpevents(void)
 {
 	struct HvLpEvent * event;
 
+ restart:
 	/* If we have recursed, just return */
 	if (!spin_trylock(&hvlpevent_queue.hq_lock))
 		return;
@@ -146,8 +147,20 @@ void process_hvlpevents(void)
 			if (event->xType < HvLpEvent_Type_NumTypes &&
 					lpEventHandler[event->xType])
 				lpEventHandler[event->xType](event);
-			else
-				printk(KERN_INFO "Unexpected Lp Event type=%d\n", event->xType );
+			else {
+				u8 type = event->xType;
+
+				/*
+				 * Don't printk in the spinlock as printk
+				 * may require ack events form the HV to send
+				 * any characters there.
+				 */
+				hvlpevent_clear_valid(event);
+				spin_unlock(&hvlpevent_queue.hq_lock);
+				printk(KERN_INFO
+					"Unexpected Lp Event type=%d\n", type);
+				goto restart;
+			}
 
 			hvlpevent_clear_valid(event);
 		} else if (hvlpevent_queue.hq_overflow_pending)

