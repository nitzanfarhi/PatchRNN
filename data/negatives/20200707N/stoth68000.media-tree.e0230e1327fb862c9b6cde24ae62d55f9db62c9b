commit e0230e1327fb862c9b6cde24ae62d55f9db62c9b
Author: Yang Zhang <yang.z.zhang@Intel.com>
Date:   Thu Oct 24 09:56:39 2013 +0800

    KVM: Mapping IOMMU pages after updating memslot
    
    In kvm_iommu_map_pages(), we need to know the page size via call
    kvm_host_page_size(). And it will check whether the target slot
    is valid before return the right page size.
    Currently, we will map the iommu pages when creating a new slot.
    But we call kvm_iommu_map_pages() during preparing the new slot.
    At that time, the new slot is not visible by domain(still in preparing).
    So we cannot get the right page size from kvm_host_page_size() and
    this will break the IOMMU super page logic.
    The solution is to map the iommu pages after we insert the new slot
    into domain.
    
    Signed-off-by: Yang Zhang <yang.z.zhang@Intel.com>
    Tested-by: Patrick Lu <patrick.lu@intel.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index 0d20c320a33d..9ca014da134d 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -873,21 +873,6 @@ int __kvm_set_memory_region(struct kvm *kvm,
 			goto out_free;
 	}
 
-	/*
-	 * IOMMU mapping:  New slots need to be mapped.  Old slots need to be
-	 * un-mapped and re-mapped if their base changes.  Since base change
-	 * unmapping is handled above with slot deletion, mapping alone is
-	 * needed here.  Anything else the iommu might care about for existing
-	 * slots (size changes, userspace addr changes and read-only flag
-	 * changes) is disallowed above, so any other attribute changes getting
-	 * here can be skipped.
-	 */
-	if ((change == KVM_MR_CREATE) || (change == KVM_MR_MOVE)) {
-		r = kvm_iommu_map_pages(kvm, &new);
-		if (r)
-			goto out_slots;
-	}
-
 	/* actual memory is freed via old in kvm_free_physmem_slot below */
 	if (change == KVM_MR_DELETE) {
 		new.dirty_bitmap = NULL;
@@ -901,6 +886,20 @@ int __kvm_set_memory_region(struct kvm *kvm,
 	kvm_free_physmem_slot(&old, &new);
 	kfree(old_memslots);
 
+	/*
+	 * IOMMU mapping:  New slots need to be mapped.  Old slots need to be
+	 * un-mapped and re-mapped if their base changes.  Since base change
+	 * unmapping is handled above with slot deletion, mapping alone is
+	 * needed here.  Anything else the iommu might care about for existing
+	 * slots (size changes, userspace addr changes and read-only flag
+	 * changes) is disallowed above, so any other attribute changes getting
+	 * here can be skipped.
+	 */
+	if ((change == KVM_MR_CREATE) || (change == KVM_MR_MOVE)) {
+		r = kvm_iommu_map_pages(kvm, &new);
+		return r;
+	}
+
 	return 0;
 
 out_slots:

