commit bc525f05fe6397ce83b4f5f0a7209604d258c946
Author: macgyver <macgyver>
Date:   Wed Jul 26 08:19:28 2000 +0000

    fnmatch.c was renamed to pr_fnmatch.c, as well as importing the new fnmatch code from glibc.

diff --git a/lib/pr_fnmatch.c b/lib/pr_fnmatch.c
new file mode 100644
index 000000000..2e7d63c26
--- /dev/null
+++ b/lib/pr_fnmatch.c
@@ -0,0 +1,354 @@
+/* Copyright (C) 1991-1993, 1996-1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* This file comes from the GNU C Library and has been modified for use in
+ * ProFTPD.
+ *
+ * Changes are released under the GNU Public License, version 2.
+ * Copyright (C) 2000 MacGyver aka Habeeb J. Dihu <macgyver@tos.net>
+ */
+
+#if 0 /* Not used in ProFTPD */
+#if HAVE_CONFIG_H
+# include <config.h>
+#endif
+#endif /* Not used in ProFTPD */
+
+/* Required to tell conf.h not to include the standard ProFTPD
+ * header files
+ */
+
+#define __PROFTPD_SUPPORT_LIBRARY
+
+#include <conf.h>
+#include <libsupp.h>
+
+#if 0 /* Not used in ProFTPD */
+/* Enable GNU extensions in fnmatch.h.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE	1
+#endif
+
+#include <assert.h>
+#include <errno.h>
+#include <fnmatch.h>
+#include <ctype.h>
+
+#if HAVE_STRING_H || defined _LIBC
+# include <string.h>
+#else
+# include <strings.h>
+#endif
+
+#if defined STDC_HEADERS || defined _LIBC
+# include <stdlib.h>
+#endif
+
+/* For platform which support the ISO C amendement 1 functionality we
+   support user defined character classes.  */
+#if defined _LIBC || (defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H)
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+# include <wchar.h>
+# include <wctype.h>
+#endif
+
+/* We need some of the locale data (the collation sequence information)
+   but there is no interface to get this information in general.  Therefore
+   we support a correct implementation only in glibc.  */
+#ifdef _LIBC
+# include "../locale/localeinfo.h"
+# include "../locale/elem-hash.h"
+
+# define CONCAT(a,b) __CONCAT(a,b)
+#endif
+#endif /* Not used in ProFTPD */
+
+/* Comment out all this code if we are using the GNU C Library, and are not
+   actually compiling the library itself.  This code is part of the GNU C
+   Library, but also included in many other GNU distributions.  Compiling
+   and linking in this code is a waste when using the GNU C library
+   (especially if it is a shared library).  Rather than having every GNU
+   program understand `configure --with-gnu-libc' and omit the object files,
+   it is simpler to just do this in the source for each such file.  */
+
+/* The comment above notwithstanding, we do want to use our own version to
+ * ensure cross-platform compatibility...among other things.
+ */
+#undef _LIBC
+#undef __GNU_LIBRARY__
+
+#if defined _LIBC || !defined __GNU_LIBRARY__
+
+
+# if defined STDC_HEADERS || !defined isascii
+#  define ISASCII(c) 1
+# else
+#  define ISASCII(c) isascii(c)
+# endif
+
+# ifdef isblank
+#  define ISBLANK(c) (ISASCII (c) && isblank (c))
+# else
+#  define ISBLANK(c) ((c) == ' ' || (c) == '\t')
+# endif
+# ifdef isgraph
+#  define ISGRAPH(c) (ISASCII (c) && isgraph (c))
+# else
+#  define ISGRAPH(c) (ISASCII (c) && isprint (c) && !isspace (c))
+# endif
+
+# define ISPRINT(c) (ISASCII (c) && isprint (c))
+# define ISDIGIT(c) (ISASCII (c) && isdigit (c))
+# define ISALNUM(c) (ISASCII (c) && isalnum (c))
+# define ISALPHA(c) (ISASCII (c) && isalpha (c))
+# define ISCNTRL(c) (ISASCII (c) && iscntrl (c))
+# define ISLOWER(c) (ISASCII (c) && islower (c))
+# define ISPUNCT(c) (ISASCII (c) && ispunct (c))
+# define ISSPACE(c) (ISASCII (c) && isspace (c))
+# define ISUPPER(c) (ISASCII (c) && isupper (c))
+# define ISXDIGIT(c) (ISASCII (c) && isxdigit (c))
+
+# define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
+
+# if defined _LIBC || (defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H)
+/* The GNU C library provides support for user-defined character classes
+   and the functions from ISO C amendement 1.  */
+#  ifdef CHARCLASS_NAME_MAX
+#   define CHAR_CLASS_MAX_LENGTH CHARCLASS_NAME_MAX
+#  else
+/* This shouldn't happen but some implementation might still have this
+   problem.  Use a reasonable default value.  */
+#   define CHAR_CLASS_MAX_LENGTH 256
+#  endif
+
+#  ifdef _LIBC
+#   define IS_CHAR_CLASS(string) __wctype (string)
+#  else
+#   define IS_CHAR_CLASS(string) wctype (string)
+#  endif
+
+#  ifdef _LIBC
+#   define ISWCTYPE(WC, WT)	__iswctype (WC, WT)
+#  else
+#   define ISWCTYPE(WC, WT)	iswctype (WC, WT)
+#  endif
+
+#  if (HAVE_MBSTATE_T && HAVE_MBSRTOWCS) || _LIBC
+/* In this case we are implementing the multibyte character handling.  */
+#   define HANDLE_MULTIBYTE	1
+#  endif
+
+# else
+#  define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
+
+#  define IS_CHAR_CLASS(string)						      \
+   (STREQ (string, "alpha") || STREQ (string, "upper")			      \
+    || STREQ (string, "lower") || STREQ (string, "digit")		      \
+    || STREQ (string, "alnum") || STREQ (string, "xdigit")		      \
+    || STREQ (string, "space") || STREQ (string, "print")		      \
+    || STREQ (string, "punct") || STREQ (string, "graph")		      \
+    || STREQ (string, "cntrl") || STREQ (string, "blank"))
+# endif
+
+/* Avoid depending on library functions or files
+   whose names are inconsistent.  */
+
+# if !defined _LIBC && !defined getenv
+extern char *getenv ();
+# endif
+
+# ifndef errno
+extern int errno;
+# endif
+
+/* This function doesn't exist on most systems.  */
+
+# if !defined HAVE___STRCHRNUL && !defined _LIBC
+static char *
+__strchrnul (s, c)
+     const char *s;
+     int c;
+{
+  char *result = strchr (s, c);
+  if (result == NULL)
+    result = strchr (s, '\0');
+  return result;
+}
+# endif
+
+# if HANDLE_MULTIBYTE && !defined HAVE___STRCHRNUL && !defined _LIBC
+static wchar_t *
+__wcschrnul (s, c)
+     const wchar_t *s;
+     wint_t c;
+{
+  wchar_t *result = wcschr (s, c);
+  if (result == NULL)
+    result = wcschr (s, '\0');
+  return result;
+}
+# endif
+
+# ifndef internal_function
+/* Inside GNU libc we mark some function in a special way.  In other
+   environments simply ignore the marking.  */
+#  define internal_function
+# endif
+
+/* Note that this evaluates C many times.  */
+# ifdef _LIBC
+#  define FOLD(c) ((flags & PR_FNM_CASEFOLD) ? tolower (c) : (c))
+# else
+#  define FOLD(c) ((flags & PR_FNM_CASEFOLD) && ISUPPER (c) ? tolower (c) : (c))
+# endif
+# define CHAR	char
+# define UCHAR	unsigned char
+# define FCT	internal_fnmatch
+# define L(CS)	CS
+# ifdef _LIBC
+#  define BTOWC(C)	__btowc (C)
+# else
+#  define BTOWC(C)	btowc (C)
+# endif
+# define STRCHR(S, C)	strchr (S, C)
+# define STRCHRNUL(S, C) __strchrnul (S, C)
+# define STRCOLL(S1, S2) strcoll (S1, S2)
+# define SUFFIX MB
+# include "pr_fnmatch_loop.c"
+
+
+# if HANDLE_MULTIBYTE
+/* Note that this evaluates C many times.  */
+#  ifdef _LIBC
+#   define FOLD(c) ((flags & PR_FNM_CASEFOLD) ? towlower (c) : (c))
+#  else
+#   define FOLD(c) ((flags & PR_FNM_CASEFOLD) && ISUPPER (c) ? towlower (c) : (c))
+#  endif
+#  define CHAR	wchar_t
+#  define UCHAR	wint_t
+#  define FCT	internal_fnwmatch
+#  define L(CS)	L##CS
+#  define BTOWC(C)	(C)
+#  define STRCHR(S, C)	wcschr (S, C)
+#  define STRCHRNUL(S, C) __wcschrnul (S, C)
+#  define STRCOLL(S1, S2) wcscoll (S1, S2)
+#  define SUFFIX WC
+#  define WIDE_CHAR_VERSION 1
+
+
+#  undef IS_CHAR_CLASS
+#  ifdef _LIBC
+/* We have to convert the wide character string in a multibyte string.  But
+   we know that the character class names are ASCII strings and since the
+   internal wide character encoding is UCS4 we can use a simplified method
+   to convert the string to a multibyte character string.  */
+static wctype_t
+is_char_class (const wchar_t *wcs)
+{
+  char s[CHAR_CLASS_MAX_LENGTH + 1];
+  char *cp = s;
+
+  do
+    {
+      if (*wcs < 0x20 || *wcs >= 0x7f)
+	return 0;
+
+      *cp++ = (char) *wcs;
+    }
+  while (*wcs++ != L'\0');
+
+  return __wctype (s);
+}
+#  else
+/* Since we cannot assume anything about the internal encoding we have to
+   convert the string back to multibyte representation the hard way.  */
+static wctype_t
+is_char_class (const wchar_t *wcs)
+{
+  mbstate_t ps;
+  const wchar_t *pwc;
+  char *s;
+  size_t n;
+
+  memset (&ps, '\0', sizeof (ps));
+
+  pwc = wcs;
+  n = wcsrtombs (NULL, &pwc, 0, &ps);
+  if (n == (size_t) -1)
+    /* Something went wrong.  */
+    return 0;
+
+  s = alloca (n + 1);
+  assert (mbsinit (&ps));
+  pwc = wcs;
+  (void) wcsrtombs (s, &pwc, n + 1, &ps);
+
+  return wctype (s);
+}
+#  endif
+#  define IS_CHAR_CLASS(string) is_char_class (string)
+
+#  include "pr_fnmatch_loop.c"
+# endif
+
+int
+pr_fnmatch (pattern, string, flags)
+     const char *pattern;
+     const char *string;
+     int flags;
+{
+# if HANDLE_MULTIBYTE
+  mbstate_t ps;
+  size_t n;
+  wchar_t *wpattern;
+  wchar_t *wstring;
+
+  if (MB_CUR_MAX == 1)
+    /* This is an optimization for 8-bit character set.  */
+    return internal_fnmatch (pattern, string, flags & PR_FNM_PERIOD, flags);
+
+  /* Convert the strings into wide characters.  */
+  memset (&ps, '\0', sizeof (ps));
+  n = mbsrtowcs (NULL, &pattern, 0, &ps);
+  if (n == (size_t) -1)
+    /* Something wrong.
+       XXX Do we have to set `errno' to something which mbsrtows hasn't
+       already done?  */
+    return -1;
+  wpattern = (wchar_t *) alloca ((n + 1) * sizeof (wchar_t));
+  assert (mbsinit (&ps));
+  (void) mbsrtowcs (wpattern, &pattern, n + 1, &ps);
+
+  assert (mbsinit (&ps));
+  n = mbsrtowcs (NULL, &string, 0, &ps);
+  if (n == (size_t) -1)
+    /* Something wrong.
+       XXX Do we have to set `errno' to something which mbsrtows hasn't
+       already done?  */
+    return -1;
+  wstring = (wchar_t *) alloca ((n + 1) * sizeof (wchar_t));
+  assert (mbsinit (&ps));
+  (void) mbsrtowcs (wstring, &string, n + 1, &ps);
+
+  return internal_fnwmatch (wpattern, wstring, flags & PR_FNM_PERIOD, flags);
+# else
+  return internal_fnmatch (pattern, string, flags & PR_FNM_PERIOD, flags);
+# endif  /* mbstate_t and mbsrtowcs or _LIBC.  */
+}
+
+#endif	/* _LIBC or not __GNU_LIBRARY__.  */
diff --git a/lib/pr_fnmatch_loop.c b/lib/pr_fnmatch_loop.c
new file mode 100644
index 000000000..e9f2b617e
--- /dev/null
+++ b/lib/pr_fnmatch_loop.c
@@ -0,0 +1,978 @@
+/* Copyright (C) 1991-1993, 1996-1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* This file comes from the GNU C Library and has been modified for use in
+ * ProFTPD.
+ *
+ * Changes are released under the GNU Public License, version 2.
+ * Copyright (C) 2000 MacGyver aka Habeeb J. Dihu <macgyver@tos.net>
+ */
+
+/* Match STRING against the filename pattern PATTERN, returning zero if
+   it matches, nonzero if not.  */
+static int FCT (const CHAR *pattern, const CHAR *string,
+		int no_leading_period, int flags) internal_function;
+
+static int
+internal_function
+FCT (pattern, string, no_leading_period, flags)
+     const CHAR *pattern;
+     const CHAR *string;
+     int no_leading_period;
+     int flags;
+{
+  register const CHAR *p = pattern, *n = string;
+  register UCHAR c;
+#ifdef _LIBC
+  const UCHAR *collseq = (const UCHAR *)
+    _NL_CURRENT(LC_COLLATE, CONCAT(_NL_COLLATE_COLLSEQ,SUFFIX));
+# ifdef WIDE_CHAR_VERSION
+  const wint_t *names = (const wint_t *)
+    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_NAMES);
+  size_t size = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_HASH_SIZE);
+  size_t layers = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_HASH_LAYERS);
+# endif
+#endif
+
+  while ((c = *p++) != L('\0'))
+    {
+      c = FOLD (c);
+
+      switch (c)
+	{
+	case L('?'):
+	  if (*n == L('\0'))
+	    return PR_FNM_NOMATCH;
+	  else if (*n == L('/') && (flags & PR_FNM_FILE_NAME))
+	    return PR_FNM_NOMATCH;
+	  else if (*n == L('.') && no_leading_period
+		   && (n == string
+		       || (n[-1] == L('/') && (flags & PR_FNM_FILE_NAME))))
+	    return PR_FNM_NOMATCH;
+	  break;
+
+	case L('\\'):
+	  if (!(flags & PR_FNM_NOESCAPE))
+	    {
+	      c = *p++;
+	      if (c == L('\0'))
+		/* Trailing \ loses.  */
+		return PR_FNM_NOMATCH;
+	      c = FOLD (c);
+	    }
+	  if (FOLD ((UCHAR) *n) != c)
+	    return PR_FNM_NOMATCH;
+	  break;
+
+	case L('*'):
+	  if (*n == L('.') && no_leading_period
+	      && (n == string
+		  || (n[-1] == L('/') && (flags & PR_FNM_FILE_NAME))))
+	    return PR_FNM_NOMATCH;
+
+	  for (c = *p++; c == L('?') || c == L('*'); c = *p++)
+	    {
+	      if (*n == L('/') && (flags & PR_FNM_FILE_NAME))
+		/* A slash does not match a wildcard under PR_FNM_FILE_NAME.  */
+		return PR_FNM_NOMATCH;
+	      else if (c == L('?'))
+		{
+		  /* A ? needs to match one character.  */
+		  if (*n == L('\0'))
+		    /* There isn't another character; no match.  */
+		    return PR_FNM_NOMATCH;
+		  else
+		    /* One character of the string is consumed in matching
+		       this ? wildcard, so *??? won't match if there are
+		       less than three characters.  */
+		    ++n;
+		}
+	    }
+
+	  if (c == L('\0'))
+	    /* The wildcard(s) is/are the last element of the pattern.
+	       If the name is a file name and contains another slash
+	       this does mean it cannot match.  If the PR_FNM_LEADING_DIR
+	       flag is set and exactly one slash is following, we have
+	       a match.  */
+	    {
+	      int result = (flags & PR_FNM_FILE_NAME) == 0 ? 0 : PR_FNM_NOMATCH;
+
+	      if (flags & PR_FNM_FILE_NAME)
+		{
+		  const CHAR *slashp = STRCHR (n, L('/'));
+
+		  if (flags & PR_FNM_LEADING_DIR)
+		    {
+		      if (slashp != NULL
+			  && STRCHR (slashp + 1, L('/')) == NULL)
+			result = 0;
+		    }
+		  else
+		    {
+		      if (slashp == NULL)
+			result = 0;
+		    }
+		}
+
+	      return result;
+	    }
+	  else
+	    {
+	      const CHAR *endp;
+
+	      endp = STRCHRNUL (n, (flags & PR_FNM_FILE_NAME) ? L('/') : L('\0'));
+
+	      if (c == L('['))
+		{
+		  int flags2 = ((flags & PR_FNM_FILE_NAME)
+				? flags : (flags & ~PR_FNM_PERIOD));
+
+		  for (--p; n < endp; ++n)
+		    if (FCT (p, n, (no_leading_period
+				    && (n == string
+					|| (n[-1] == L('/')
+					    && (flags & PR_FNM_FILE_NAME)))),
+			     flags2) == 0)
+		      return 0;
+		}
+	      else if (c == L('/') && (flags & PR_FNM_FILE_NAME))
+		{
+		  while (*n != L('\0') && *n != L('/'))
+		    ++n;
+		  if (*n == L('/')
+		      && (FCT (p, n + 1, flags & PR_FNM_PERIOD, flags) == 0))
+		    return 0;
+		}
+	      else
+		{
+		  int flags2 = ((flags & PR_FNM_FILE_NAME)
+				? flags : (flags & ~PR_FNM_PERIOD));
+
+		  if (c == L('\\') && !(flags & PR_FNM_NOESCAPE))
+		    c = *p;
+		  c = FOLD (c);
+		  for (--p; n < endp; ++n)
+		    if (FOLD ((UCHAR) *n) == c
+			&& (FCT (p, n, (no_leading_period
+					&& (n == string
+					    || (n[-1] == L('/')
+						&& (flags & PR_FNM_FILE_NAME)))),
+				 flags2) == 0))
+		      return 0;
+		}
+	    }
+
+	  /* If we come here no match is possible with the wildcard.  */
+	  return PR_FNM_NOMATCH;
+
+	case L('['):
+	  {
+	    static int posixly_correct;
+	    /* Nonzero if the sense of the character class is inverted.  */
+	    register int not;
+	    CHAR cold;
+
+	    if (posixly_correct == 0)
+	      posixly_correct = getenv ("POSIXLY_CORRECT") != NULL ? 1 : -1;
+
+	    if (*n == L('\0'))
+	      return PR_FNM_NOMATCH;
+
+	    if (*n == L('.') && no_leading_period
+		&& (n == string
+		    || (n[-1] == L('/') && (flags & PR_FNM_FILE_NAME))))
+	      return PR_FNM_NOMATCH;
+
+	    if (*n == L('/') && (flags & PR_FNM_FILE_NAME))
+	      /* `/' cannot be matched.  */
+	      return PR_FNM_NOMATCH;
+
+	    not = (*p == L('!') || (posixly_correct < 0 && *p == L('^')));
+	    if (not)
+	      ++p;
+
+	    c = *p++;
+	    for (;;)
+	      {
+		UCHAR fn = FOLD ((UCHAR) *n);
+
+		if (!(flags & PR_FNM_NOESCAPE) && c == L('\\'))
+		  {
+		    if (*p == L('\0'))
+		      return PR_FNM_NOMATCH;
+		    c = FOLD ((UCHAR) *p);
+		    ++p;
+
+		    if (c == fn)
+		      goto matched;
+		  }
+		else if (c == L('[') && *p == L(':'))
+		  {
+		    /* Leave room for the null.  */
+		    CHAR str[CHAR_CLASS_MAX_LENGTH + 1];
+		    size_t c1 = 0;
+#if defined _LIBC || (defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H)
+		    wctype_t wt;
+#endif
+		    const CHAR *startp = p;
+
+		    for (;;)
+		      {
+			if (c1 == CHAR_CLASS_MAX_LENGTH)
+			  /* The name is too long and therefore the pattern
+			     is ill-formed.  */
+			  return PR_FNM_NOMATCH;
+
+			c = *++p;
+			if (c == L(':') && p[1] == L(']'))
+			  {
+			    p += 2;
+			    break;
+			  }
+			if (c < L('a') || c >= L('z'))
+			  {
+			    /* This cannot possibly be a character class name.
+			       Match it as a normal range.  */
+			    p = startp;
+			    c = L('[');
+			    goto normal_bracket;
+			  }
+			str[c1++] = c;
+		      }
+		    str[c1] = L('\0');
+
+#if defined _LIBC || (defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H)
+		    wt = IS_CHAR_CLASS (str);
+		    if (wt == 0)
+		      /* Invalid character class name.  */
+		      return PR_FNM_NOMATCH;
+
+		    /* The following code is glibc specific but does
+		       there a good job in sppeding up the code since
+		       we can avoid the btowc() call.  The
+		       IS_CHAR_CLASS call will return a bit mask for
+		       the 32-bit table.  We have to convert it to a
+		       bitmask for the __ctype_b table.  This has to
+		       be done based on the byteorder as can be seen
+		       below.  In any case we will fall back on the
+		       code using btowc() if the class is not one of
+		       the standard classes.  */
+# if defined _LIBC && ! WIDE_CHAR_VERSION
+#  if __BYTE_ORDER == __LITTLE_ENDIAN
+		    if ((wt & 0xf0ffff) == 0)
+		      {
+			wt >>= 16;
+			if ((__ctype_b[(UCHAR) *n] & wt) != 0)
+			  goto matched;
+		      }
+#  else
+		    if (wt <= 0x800)
+		      {
+			if ((__ctype_b[(UCHAR) *n] & wt) != 0)
+			  goto matched;
+		      }
+#  endif
+		    else
+# endif
+		      if (ISWCTYPE (BTOWC ((UCHAR) *n), wt))
+			goto matched;
+#else
+		    if ((STREQ (str, L("alnum")) && ISALNUM ((UCHAR) *n))
+			|| (STREQ (str, L("alpha")) && ISALPHA ((UCHAR) *n))
+			|| (STREQ (str, L("blank")) && ISBLANK ((UCHAR) *n))
+			|| (STREQ (str, L("cntrl")) && ISCNTRL ((UCHAR) *n))
+			|| (STREQ (str, L("digit")) && ISDIGIT ((UCHAR) *n))
+			|| (STREQ (str, L("graph")) && ISGRAPH ((UCHAR) *n))
+			|| (STREQ (str, L("lower")) && ISLOWER ((UCHAR) *n))
+			|| (STREQ (str, L("print")) && ISPRINT ((UCHAR) *n))
+			|| (STREQ (str, L("punct")) && ISPUNCT ((UCHAR) *n))
+			|| (STREQ (str, L("space")) && ISSPACE ((UCHAR) *n))
+			|| (STREQ (str, L("upper")) && ISUPPER ((UCHAR) *n))
+			|| (STREQ (str, L("xdigit")) && ISXDIGIT ((UCHAR) *n)))
+		      goto matched;
+#endif
+		    c = *p++;
+		  }
+#ifdef _LIBC
+		else if (c == L('[') && *p == L('='))
+		  {
+		    UCHAR str[1];
+		    uint32_t nrules =
+		      _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
+		    const CHAR *startp = p;
+
+		    c = *++p;
+		    if (c == L('\0'))
+		      {
+			p = startp;
+			c = L('[');
+			goto normal_bracket;
+		      }
+		    str[0] = c;
+
+		    c = *++p;
+		    if (c != L('=') || p[1] != L(']'))
+		      {
+			p = startp;
+			c = L('[');
+			goto normal_bracket;
+		      }
+		    p += 2;
+
+		    if (nrules == 0)
+		      {
+			if ((UCHAR) *n == str[0])
+			  goto matched;
+		      }
+		    else
+		      {
+			const int32_t *table;
+# if WIDE_CHAR_VERSION
+			const int32_t *weights;
+			const int32_t *extra;
+# else
+			const unsigned char *weights;
+			const unsigned char *extra;
+# endif
+			const int32_t *indirect;
+			int32_t idx;
+			const UCHAR *cp = (const UCHAR *) str;
+
+			/* This #include defines a local function!  */
+# if WIDE_CHAR_VERSION
+#  include <locale/weightwc.h>
+# else
+#  include <locale/weight.h>
+# endif
+
+# if WIDE_CHAR_VERSION
+			table = (const int32_t *)
+			  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEWC);
+			weights = (const int32_t *)
+			  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTWC);
+			extra = (const int32_t *)
+			  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAWC);
+			indirect = (const int32_t *)
+			  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTWC);
+# else
+			table = (const int32_t *)
+			  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);
+			weights = (const unsigned char *)
+			  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTMB);
+			extra = (const unsigned char *)
+			  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);
+			indirect = (const int32_t *)
+			  _NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);
+# endif
+
+			idx = findidx (&cp);
+			if (idx != 0)
+			  {
+			    /* We found a table entry.  Now see whether the
+			       character we are currently at has the same
+			       equivalance class value.  */
+# if !WIDE_CHAR_VERSION
+			    int len = weights[idx];
+# endif
+			    int32_t idx2;
+			    const UCHAR *np = (const UCHAR *) n;
+
+			    idx2 = findidx (&np);
+# if WIDE_CHAR_VERSION
+			    if (idx2 != 0 && weights[idx] == weights[idx2])
+			      goto matched;
+# else
+			    if (idx2 != 0 && len == weights[idx2])
+			      {
+				int cnt = 0;
+
+				while (cnt < len
+				       && (weights[idx + 1 + cnt]
+					   == weights[idx2 + 1 + cnt]))
+				  ++cnt;
+
+				if (cnt == len)
+				  goto matched;
+			      }
+# endif
+			  }
+		      }
+
+		    c = *p++;
+		  }
+#endif
+		else if (c == L('\0'))
+		  /* [ (unterminated) loses.  */
+		  return PR_FNM_NOMATCH;
+		else
+		  {
+		    int is_range = 0;
+
+#ifdef _LIBC
+		    int is_seqval = 0;
+
+		    if (c == L('[') && *p == L('.'))
+		      {
+			uint32_t nrules =
+			  _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
+			const CHAR *startp = p;
+			size_t c1 = 0;
+
+			while (1)
+			  {
+			    c = *++p;
+			    if (c == L('.') && p[1] == L(']'))
+			      {
+				p += 2;
+				break;
+			      }
+			    if (c == '\0')
+			      return PR_FNM_NOMATCH;
+			    ++c1;
+			  }
+
+			/* We have to handling the symbols differently in
+			   ranges since then the collation sequence is
+			   important.  */
+			is_range = *p == L('-') && p[1] != L('\0');
+
+			if (nrules == 0)
+			  {
+			    /* There are no names defined in the collation
+			       data.  Therefore we only accept the trivial
+			       names consisting of the character itself.  */
+			    if (c1 != 1)
+			      return PR_FNM_NOMATCH;
+
+			    if (!is_range && *n == startp[1])
+			      goto matched;
+
+			    cold = startp[1];
+			    c = *p++;
+			  }
+			else
+			  {
+			    int32_t table_size;
+			    const int32_t *symb_table;
+# ifdef WIDE_CHAR_VERSION
+			    char str[c1];
+			    int strcnt;
+# else
+#  define str (startp + 1)
+# endif
+			    const unsigned char *extra;
+			    int32_t idx;
+			    int32_t elem;
+			    int32_t second;
+			    int32_t hash;
+
+# ifdef WIDE_CHAR_VERSION
+			    /* We have to convert the name to a single-byte
+			       string.  This is possible since the names
+			       consist of ASCII characters and the internal
+			       representation is UCS4.  */
+			    for (strcnt = 0; strcnt < c1; ++strcnt)
+			      str[strcnt] = startp[1 + strcnt];
+#endif
+
+			    table_size =
+			      _NL_CURRENT_WORD (LC_COLLATE,
+						_NL_COLLATE_SYMB_HASH_SIZEMB);
+			    symb_table = (const int32_t *)
+			      _NL_CURRENT (LC_COLLATE,
+					   _NL_COLLATE_SYMB_TABLEMB);
+			    extra = (const unsigned char *)
+			      _NL_CURRENT (LC_COLLATE,
+					   _NL_COLLATE_SYMB_EXTRAMB);
+
+			    /* Locate the character in the hashing table.  */
+			    hash = elem_hash (str, c1);
+
+			    idx = 0;
+			    elem = hash % table_size;
+			    second = hash % (table_size - 2);
+			    while (symb_table[2 * elem] != 0)
+			      {
+				/* First compare the hashing value.  */
+				if (symb_table[2 * elem] == hash
+				    && c1 == extra[symb_table[2 * elem + 1]]
+				    && memcmp (str,
+					       &extra[symb_table[2 * elem + 1]
+						     + 1], c1) == 0)
+				  {
+				    /* Yep, this is the entry.  */
+				    idx = symb_table[2 * elem + 1];
+				    idx += 1 + extra[idx];
+				    break;
+				  }
+
+				/* Next entry.  */
+				elem += second;
+			      }
+
+			    if (symb_table[2 * elem] != 0)
+			      {
+				/* Compare the byte sequence but only if
+				   this is not part of a range.  */
+# ifdef WIDE_CHAR_VERSION
+				int32_t *wextra;
+
+				idx += 1 + extra[idx];
+				/* Adjust for the alignment.  */
+				idx = (idx + 3) & ~4;
+
+				wextra = (int32_t *) &extra[idx + 4];
+# endif
+
+				if (! is_range)
+				  {
+# ifdef WIDE_CHAR_VERSION
+				    for (c1 = 0; c1 < wextra[idx]; ++c1)
+				      if (n[c1] != wextra[1 + c1])
+					break;
+
+				    if (c1 == wextra[idx])
+				      goto matched;
+# else
+				    for (c1 = 0; c1 < extra[idx]; ++c1)
+				      if (n[c1] != extra[1 + c1])
+					break;
+
+				    if (c1 == extra[idx])
+				      goto matched;
+# endif
+				  }
+
+				/* Get the collation sequence value.  */
+				is_seqval = 1;
+# ifdef WIDE_CHAR_VERSION
+				cold = wextra[1 + wextra[idx]];
+# else
+				/* Adjust for the alignment.  */
+				idx += 1 + extra[idx];
+				idx = (idx + 3) & ~4;
+				cold = *((int32_t *) &extra[idx]);
+# endif
+
+				c = *p++;
+			      }
+			    else if (symb_table[2 * elem] != 0 && c1 == 1)
+			      {
+				/* No valid character.  Match it as a
+				   single byte.  */
+				if (!is_range && *n == str[0])
+				  goto matched;
+
+				cold = str[0];
+				c = *p++;
+			      }
+			    else
+			      return PR_FNM_NOMATCH;
+			  }
+		      }
+		    else
+# undef str
+#endif
+		      {
+			c = FOLD (c);
+		      normal_bracket:
+
+			/* We have to handling the symbols differently in
+			   ranges since then the collation sequence is
+			   important.  */
+			is_range = *p == L('-') && p[1] != L('\0');
+
+			if (!is_range && c == fn)
+			  goto matched;
+
+			cold = c;
+			c = *p++;
+		      }
+
+		    if (c == L('-') && *p != L(']'))
+		      {
+#if _LIBC
+			/* We have to find the collation sequence
+			   value for C.  Collation sequence is nothing
+			   we can regularly access.  The sequence
+			   value is defined by the order in which the
+			   definitions of the collation values for the
+			   various characters appear in the source
+			   file.  A strange concept, nowhere
+			   documented.  */
+			uint32_t fcollseq;
+			uint32_t lcollseq;
+			UCHAR cend = *p++;
+# ifdef WIDE_CHAR_VERSION
+			int idx;
+			size_t cnt;
+# endif
+
+# ifdef WIDE_CHAR_VERSION
+			/* Search in the `names' array for the characters.  */
+			idx = fn % size;
+			cnt = 0;
+			while (names[idx] != fn)
+			  {
+			    if (++cnt == layers)
+			      /* XXX We don't know anything about
+				 the character we are supposed to
+				 match.  This means we are failing.  */
+			      goto range_not_matched;
+
+			    idx += size;
+			  }
+			fcollseq = collseq[idx];
+
+			if (is_seqval)
+			  lcollseq = cold;
+			else
+			  {
+			    idx = cold % size;
+			    cnt = 0;
+			    while (names[idx] != cold)
+			      {
+				if (++cnt == layers)
+				  {
+				    idx = -1;
+				    break;
+				  }
+				idx += size;
+			      }
+
+			    lcollseq = idx == -1 ? 0xffffffff : collseq[idx];
+			  }
+# else
+			fcollseq = collseq[fn];
+			lcollseq = is_seqval ? cold : collseq[(UCHAR) cold];
+# endif
+
+			is_seqval = 0;
+			if (cend == L('[') && *p == L('.'))
+			  {
+			    uint32_t nrules =
+			      _NL_CURRENT_WORD (LC_COLLATE,
+						_NL_COLLATE_NRULES);
+			    const CHAR *startp = p;
+			    size_t c1 = 0;
+
+			    while (1)
+			      {
+				c = *++p;
+				if (c == L('.') && p[1] == L(']'))
+				  {
+				    p += 2;
+				    break;
+				  }
+				if (c == '\0')
+				  return PR_FNM_NOMATCH;
+				++c1;
+			      }
+
+			    if (nrules == 0)
+			      {
+				/* There are no names defined in the
+				   collation data.  Therefore we only
+				   accept the trivial names consisting
+				   of the character itself.  */
+				if (c1 != 1)
+				  return PR_FNM_NOMATCH;
+
+				cend = startp[1];
+			      }
+			    else
+			      {
+				int32_t table_size;
+				const int32_t *symb_table;
+# ifdef WIDE_CHAR_VERSION
+				char str[c1];
+				int strcnt;
+# else
+#  define str (startp + 1)
+# endif
+				const unsigned char *extra;
+				int32_t idx;
+				int32_t elem;
+				int32_t second;
+				int32_t hash;
+
+# ifdef WIDE_CHAR_VERSION
+				/* We have to convert the name to a single-byte
+				   string.  This is possible since the names
+				   consist of ASCII characters and the internal
+				   representation is UCS4.  */
+				for (strcnt = 0; strcnt < c1; ++strcnt)
+				  str[strcnt] = startp[1 + strcnt];
+#endif
+
+				table_size =
+				  _NL_CURRENT_WORD (LC_COLLATE,
+						    _NL_COLLATE_SYMB_HASH_SIZEMB);
+				symb_table = (const int32_t *)
+				  _NL_CURRENT (LC_COLLATE,
+					       _NL_COLLATE_SYMB_TABLEMB);
+				extra = (const unsigned char *)
+				  _NL_CURRENT (LC_COLLATE,
+					       _NL_COLLATE_SYMB_EXTRAMB);
+
+				/* Locate the character in the hashing
+                                   table.  */
+				hash = elem_hash (str, c1);
+
+				idx = 0;
+				elem = hash % table_size;
+				second = hash % (table_size - 2);
+				while (symb_table[2 * elem] != 0)
+				  {
+				/* First compare the hashing value.  */
+				    if (symb_table[2 * elem] == hash
+					&& (c1
+					    == extra[symb_table[2 * elem + 1]])
+					&& memcmp (str,
+						   &extra[symb_table[2 * elem + 1]
+							 + 1], c1) == 0)
+				      {
+					/* Yep, this is the entry.  */
+					idx = symb_table[2 * elem + 1];
+					idx += 1 + extra[idx];
+					break;
+				      }
+
+				    /* Next entry.  */
+				    elem += second;
+				  }
+
+				if (symb_table[2 * elem] != 0)
+				  {
+				    /* Compare the byte sequence but only if
+				       this is not part of a range.  */
+# ifdef WIDE_CHAR_VERSION
+				    int32_t *wextra;
+
+				    idx += 1 + extra[idx];
+				    /* Adjust for the alignment.  */
+				    idx = (idx + 3) & ~4;
+
+				    wextra = (int32_t *) &extra[idx + 4];
+# endif
+				    /* Get the collation sequence value.  */
+				    is_seqval = 1;
+# ifdef WIDE_CHAR_VERSION
+				    cend = wextra[1 + wextra[idx]];
+# else
+				    /* Adjust for the alignment.  */
+				    idx += 1 + extra[idx];
+				    idx = (idx + 3) & ~4;
+				    cend = *((int32_t *) &extra[idx]);
+# endif
+				  }
+				else if (symb_table[2 * elem] != 0 && c1 == 1)
+				  {
+				    cend = str[0];
+				    c = *p++;
+				  }
+				else
+				  return PR_FNM_NOMATCH;
+			      }
+# undef str
+			  }
+			else
+			  {
+			    if (!(flags & PR_FNM_NOESCAPE) && cend == L('\\'))
+			      cend = *p++;
+			    if (cend == L('\0'))
+			      return PR_FNM_NOMATCH;
+			    cend = FOLD (cend);
+			  }
+
+			/* XXX It is not entirely clear to me how to handle
+			   characters which are not mentioned in the
+			   collation specification.  */
+			if (
+# ifdef WIDE_CHAR_VERSION
+			    lcollseq == 0xffffffff ||
+# endif
+			    lcollseq <= fcollseq)
+			  {
+			    /* We have to look at the upper bound.  */
+			    uint32_t hcollseq;
+
+			    if (is_seqval)
+			      hcollseq = cend;
+			    else
+			      {
+# ifdef WIDE_CHAR_VERSION
+				idx = cend % size;
+				cnt = 0;
+				while (names[idx] != cend)
+				  {
+				    if (++cnt == layers)
+				      {
+					/* Hum, no information about the upper
+					   bound.  The matching succeeds if the
+					   lower bound is matched exactly.  */
+					if (idx == -1 && lcollseq != fcollseq)
+					  goto range_not_matched;
+
+					goto matched;
+				      }
+				  }
+				hcollseq = collseq[idx];
+# else
+				hcollseq = collseq[cend];
+# endif
+			      }
+
+			    if (lcollseq <= hcollseq && fcollseq <= hcollseq)
+			      goto matched;
+			  }
+# ifdef WIDE_CHAR_VERSION
+		      range_not_matched:
+# endif
+#else
+			/* We use a boring value comparison of the character
+			   values.  This is better than comparing using
+			   `strcoll' since the latter would have surprising
+			   and sometimes fatal consequences.  */
+			UCHAR cend = *p++;
+
+			if (!(flags & PR_FNM_NOESCAPE) && cend == L('\\'))
+			  cend = *p++;
+			if (cend == L('\0'))
+			  return PR_FNM_NOMATCH;
+
+			/* It is a range.  */
+			if (cold <= fn && fn <= c)
+			  goto matched;
+#endif
+
+			c = *p++;
+		      }
+		  }
+
+		if (c == L(']'))
+		  break;
+	      }
+
+	    if (!not)
+	      return PR_FNM_NOMATCH;
+	    break;
+
+	  matched:
+	    /* Skip the rest of the [...] that already matched.  */
+	    do
+	      {
+	      ignore_next:
+		c = *p++;
+
+		if (c == L('\0'))
+		  /* [... (unterminated) loses.  */
+		  return PR_FNM_NOMATCH;
+
+		if (!(flags & PR_FNM_NOESCAPE) && c == L('\\'))
+		  {
+		    if (*p == L('\0'))
+		      return PR_FNM_NOMATCH;
+		    /* XXX 1003.2d11 is unclear if this is right.  */
+		    ++p;
+		  }
+		else if (c == L('[') && *p == L(':'))
+		  {
+		    int c1 = 0;
+		    const CHAR *startp = p;
+
+		    while (1)
+		      {
+			c = *++p;
+			if (++c1 == CHAR_CLASS_MAX_LENGTH)
+			  return PR_FNM_NOMATCH;
+
+			if (*p == L(':') && p[1] == L(']'))
+			  break;
+
+			if (c < L('a') || c >= L('z'))
+			  {
+			    p = startp;
+			    goto ignore_next;
+			  }
+		      }
+		    p += 2;
+		    c = *p++;
+		  }
+		else if (c == L('[') && *p == L('='))
+		  {
+		    c = *++p;
+		    if (c == L('\0'))
+		      return PR_FNM_NOMATCH;
+		    c = *++p;
+		    if (c != L('=') || p[1] != L(']'))
+		      return PR_FNM_NOMATCH;
+		    p += 2;
+		    c = *p++;
+		  }
+		else if (c == L('[') && *p == L('.'))
+		  {
+		    ++p;
+		    while (1)
+		      {
+			c = *++p;
+			if (c == '\0')
+			  return PR_FNM_NOMATCH;
+
+			if (*p == L('.') && p[1] == L(']'))
+			  break;
+		      }
+		    p += 2;
+		    c = *p++;
+		  }
+	      }
+	    while (c != L(']'));
+	    if (not)
+	      return PR_FNM_NOMATCH;
+	  }
+	  break;
+
+	default:
+	  if (c != FOLD ((UCHAR) *n))
+	    return PR_FNM_NOMATCH;
+	}
+
+      ++n;
+    }
+
+  if (*n == '\0')
+    return 0;
+
+  if ((flags & PR_FNM_LEADING_DIR) && *n == L('/'))
+    /* The PR_FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
+    return 0;
+
+  return PR_FNM_NOMATCH;
+}
+
+#undef FOLD
+#undef CHAR
+#undef UCHAR
+#undef FCT
+#undef STRCHR
+#undef STRCHRNUL
+#undef STRCOLL
+#undef L
+#undef BTOWC
+#undef SUFFIX

