commit d0fae771666d16e85ae24be805864ae1a0c40e30
Author: Ole John Aske <ole.john.aske@oracle.com>
Date:   Wed Mar 4 09:57:08 2015 +0100

    Fix for Bug#20408733:
    
     ScanOperations allocate too much memory for receive buffers
    
    A scan operation, both a plain single table scan, and a
    'query scan' used by pushed join, stores the result set
    in a buffer. This maximum size of this buffer is calculated
    and preallocated before the scan operation is started.
    
    This buffer may consume considerable amount of memory, in
    some cases we have observed a 2Gb buffer footprint in a test
    executing 100 parallel scans. This was for a tiny 2-node,
    non-mt config (2 fragments), and the memory consumption will scale
    linearly with more fragments
    
    There are several root causes for this problem:
    
    1. Result rows are 'unpacked' to full NdbRecord format before they
       are stored in the buffer. If only some of the table columns are
       selected from a table, there will be lots of empty (wasted) space
       in the buffer.
    2. Due to the 'unpacked' buffer format, varchar/varbinary columns has
       to be allocated for the max size defined for the columns.
    3. The 'BatchByteSize' and 'MaxScanBatchSize' is not taken into consideration
       as a limiting factor when calculating max buffer size.
    4  As buffer size is scaled by 'BatchSize', the problem became worse
       with 7.2 where the default was raised from 64 to 256
    
    This patch refactors the NdbReceiver class to buffer result rows
    in its 'packed' format. The NdbReceiver internal 'class NdbReceiverBuffer'
    is introduced in order to better seperate NdbReceiver handling of
    buffered (packed) and non buffered result set.
    
    Buffered scan result rows are now not unpacked until they are
    made the 'current row', either by NdbReceiver::getNextRow(), or
    NdbReceiver::getRow(<row>).
    
    The NdbReceiver code which convert from the transporters 'packed'
    format, into either row format described with a NdbRecord,
    or into NdbRecAttr values, are refactored into several
    NdbReceiver::unpack<foo>() methods. The same code is then
    used to unpack either a buffered or unbuffered result row.
    
    NdbReceiver::result_bufsize() has been added to calculate the
    size of the (packed) result buffer which has to be allocated.
    This calculation now also takes the config variables
    'BatchByteSize' and 'MaxScanBatchSize' as a limiting factor
    of the required buffer size.
    
    Unpacking of NdbRecAttr data from either a NdbScanOperation or
    a NdbQueryOperation has also been streamlined: Previously the
    'dataPtr' for each RecAttr were fetched from NdbReceiver and then
    'unpacked' one by one. The new method
    NdbReceiver::get_AttrValues(NdbRecAttr* rec_attr_list) leaves this
    operation entirely to NdbRecord, and as an addition side effect
    makes the same unpack code reusable inside NdbReceiver.
    
    In addition a general cleanup of the NdbReceiver class has been
    performed, some of them are:
    
    - Removed the code for handling the old NdbRecaAttr variant of
      NdbReceiver::execKEYINFO20(). That code relied on
      NdbReceiver::m_rows[] to have been allocated and set up, and m_rows[]
      is not allocated *anywere* - So that code is efficiently defuncted.
      Checked back to 7.0, without finding aby trace of that.
    
    - Removed 'useRec' argument to NdbReceiver::init(). The same
      info can be deducted by checking if the later NdbRecord* arg to
      NdbReceiver::do_setup_ndbrecord() '!= NULL'. Furthermore,
      setting 'useRec' in ::init(), and not specifying a NdbRecord in
      ::do_setup_ndbrecord(), would set the NdbReceiver into an
      inconsistent state.
    
    - Cleaned up the 'class NdbRecord' decl itself by removing
      unused, and redundant member variables. Mainly due to the
      same info now being available from 'class NdbReceiverBuffer'.

diff --git a/storage/ndb/include/ndbapi/NdbIndexOperation.hpp b/storage/ndb/include/ndbapi/NdbIndexOperation.hpp
index a3ce8d552c5..faeb2a349c3 100644
--- a/storage/ndb/include/ndbapi/NdbIndexOperation.hpp
+++ b/storage/ndb/include/ndbapi/NdbIndexOperation.hpp
@@ -1,5 +1,5 @@
-/* Copyright (c) 2003-2007 MySQL AB
-
+/*
+   Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -181,8 +181,7 @@ private:
   // Overloaded methods from NdbCursorOperation
   int indxInit(const class NdbIndexImpl* anIndex,
 	       const class NdbTableImpl* aTable, 
-	       NdbTransaction*,
-               bool useRec);
+	       NdbTransaction*);
 
   // Private attributes
   const NdbIndexImpl* m_theIndex;
diff --git a/storage/ndb/include/ndbapi/NdbOperation.hpp b/storage/ndb/include/ndbapi/NdbOperation.hpp
index 043e77f5060..c72e16dd410 100644
--- a/storage/ndb/include/ndbapi/NdbOperation.hpp
+++ b/storage/ndb/include/ndbapi/NdbOperation.hpp
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1111,7 +1111,7 @@ protected:
 //--------------------------------------------------------------
 // Initialise after allocating operation to a transaction		      
 //--------------------------------------------------------------
-  int init(const class NdbTableImpl*, NdbTransaction* aCon, bool useRec);
+  int init(const class NdbTableImpl*, NdbTransaction* aCon);
   void initInterpreter();
 
   NdbOperation(Ndb* aNdb, Type aType = PrimaryKeyAccess);	
@@ -1626,7 +1626,7 @@ inline
 const NdbRecAttr*
 NdbOperation::getFirstRecAttr() const 
 {
-  return theReceiver.theFirstRecAttr;
+  return theReceiver.m_firstRecAttr;
 }
 
 /******************************************************************************
diff --git a/storage/ndb/include/ndbapi/NdbReceiver.hpp b/storage/ndb/include/ndbapi/NdbReceiver.hpp
index e2f0ae5053e..d461bb0d813 100644
--- a/storage/ndb/include/ndbapi/NdbReceiver.hpp
+++ b/storage/ndb/include/ndbapi/NdbReceiver.hpp
@@ -1,5 +1,5 @@
-/* Copyright (c) 2003-2007 MySQL AB
-
+/*
+   Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -26,7 +26,9 @@ class Ndb;
 class NdbImpl;
 class NdbTransaction;
 class NdbRecord;
+class NdbRecAttr;
 class NdbQueryOperationImpl;
+class NdbReceiverBuffer;
 
 class NdbReceiver
 {
@@ -57,7 +59,7 @@ public:
   };
   
   NdbReceiver(Ndb *aNdb);
-  int init(ReceiverType type, bool useRec, void* owner);
+  int init(ReceiverType type, void* owner);
   void release();
   ~NdbReceiver();
   
@@ -81,15 +83,28 @@ public:
   
   void setErrorCode(int);
 
-  /* Prepare for receiving of rows into specified buffer */
-  void prepareReceive(char *buf);
+  /**
+   * Construct a receive buffer for a batched result set.
+   * 'buffer' has to be allocated with size as calculated by
+   * result_bufsize, and pointer should be Uint32 aligned.
+   */
+  static
+  NdbReceiverBuffer* initReceiveBuffer(
+                           Uint32 *buffer,
+                           Uint32 bufSize,      // Size in Uint32 words
+                           Uint32 batchRows);
 
-  /* Prepare for reading of rows from specified buffer */
-  void prepareRead(char *buf, Uint32 rows);
+  /**
+   * Prepare for receiving of rows into specified buffer.
+   * This buffer is later navigated, and retrieved from,
+   * by either getNextRow() or setCurrentRow(). The row is
+   * then 'unpacked' into 'row_buffer' set by do_setup_ndbrecord().
+   */
+  void prepareReceive(NdbReceiverBuffer *buf);
 
 private:
   Uint32 theMagicNumber;
-  Ndb* m_ndb;
+  Ndb* const m_ndb;
   Uint32 m_id;
   Uint32 m_tcPtrI;
   ReceiverType m_type;
@@ -113,61 +128,74 @@ private:
                             Uint32& batch_size,
                             Uint32& batch_byte_size) const;
 
+  /**
+   * Calculate size of result buffer which has to be 
+   * allocated for a buffered result set, and later given to 
+   * initReceiveBuffer() as 'buffer' argument.
+   */
+  static
+  Uint32 result_bufsize(Uint32 batch_rows,
+                        Uint32 batch_bytes,
+                        Uint32 fragments,
+                        const NdbRecord *result_record,
+                        const Uint32* read_mask,
+                        const NdbRecAttr *first_rec_attr,
+                        Uint32 key_size,
+                        bool read_range_no);
   /*
     Set up buffers for receiving TRANSID_AI and KEYINFO20 signals
     during a scan using NdbRecord.
   */
-  void do_setup_ndbrecord(const NdbRecord *ndb_record, Uint32 batch_size,
-                          Uint32 key_size, Uint32 read_range_no,
-                          Uint32 rowsize, char *buf);
+  void do_setup_ndbrecord(const NdbRecord *ndb_record,
+                          char *row_buffer,
+                          bool read_range_no, bool read_key_info);
+
 
+  /**
+   * Calculate size required for an 'unpacked' result row
+   * where the current result row is stored. A buffer of this size is used
+   * as 'row_buffer' argument to do_setup_ndbrecord().
+   */
   static
   Uint32 ndbrecord_rowsize(const NdbRecord *ndb_record,
-                           const NdbRecAttr *first_rec_attr,
-                           Uint32 key_size,
-                           bool   read_range_no);
-
+                           bool  read_range_no);
 
   int execKEYINFO20(Uint32 info, const Uint32* ptr, Uint32 len);
   int execTRANSID_AI(const Uint32* ptr, Uint32 len); 
   int execTCOPCONF(Uint32 len);
   int execSCANOPCONF(Uint32 tcPtrI, Uint32 len, Uint32 rows);
 
-  /*
-    We keep different state for old NdbRecAttr based operation and for
-    new NdbRecord style operation.
-  */
-  bool m_using_ndb_record;
-
-  /* members used for NdbRecord operation. */
-  struct {
-    const NdbRecord *m_ndb_record;
-    /* Destination to receive next row into. */
-    char *m_row_recv;
-    /* Block of memory used to read all rows in a batch during scan. */
-    char *m_row_buffer;
-    /*
-      Offsets between two rows in m_row_buffer.
-      This can be different from m_ndb_record->m_row_size, as we sometimes
-      store extra information after each row (range_no and keyinfo).
-      For non-scan operations, this is set to zero.
-    */
-    Uint32 m_row_offset;
-    /*
-      m_read_range_no is true if we are storing the range_no at the end of
-      each row during scans.
-    */
-    bool m_read_range_no;
-  } m_record;
-
-  class NdbRecAttr* theFirstRecAttr;
-  class NdbRecAttr* theCurrentRecAttr;
+  /* Convert from packed transporter to NdbRecord / RecAttr format. */
+  int unpackRow(const Uint32* ptr, Uint32 len, char* row); 
 
-  /*
-    m_rows is only used in NdbRecAttr mode, but is kept during NdbRecord mode
-    operation to avoid the need for re-allocation.
-  */
-  class NdbRecAttr** m_rows;
+  /* NdbRecord describing row layout expected by API */
+  const NdbRecord *m_ndb_record;
+
+  /* The (single) current row in 'unpacked' NdbRecord format */
+  char *m_row_buffer;
+
+  /* Block of memory used to buffer all rows in a batch during scan. */
+  NdbReceiverBuffer *m_recv_buffer;
+
+  /**
+   * m_read_range_no & m_read_key_info is true if we are reading 
+   * range / keyinfo as part of scans.
+   */
+  bool m_read_range_no;
+  bool m_read_key_info;
+
+  /**
+   * Holds the list of RecAttr defined by getValue()
+   * which to retrieve data into when a row is unpacked.
+   * These RecAttr's are owner by this NdbReceiver and
+   * terminated by ::release()
+   */
+  class NdbRecAttr* m_firstRecAttr;
+  class NdbRecAttr* m_lastRecAttr; // A helper for getValue()
+
+  /* Savepoint for unprocessed RecAttr data from current row. */
+  const Uint32* m_rec_attr_data;
+  Uint32        m_rec_attr_len;
   
   /*
     When an NdbReceiver is sitting in the NdbScanOperation::m_sent_receivers
@@ -177,26 +205,10 @@ private:
   */
   Uint32 m_list_index;
   /*
-    m_current_row serves two purposes, both used during scans:
-
-    1. While rows are being received from the kernel (and the receiver is
-       sitting in the NdbScanOperation::m_sent_receivers array), it holds the
-       row index (into m_rows) for the row to receive the next KEYINFO20 data.
-       This is used to receive keyInfo during scans (for scans that request
-       keyInfo).
-
-    2. While rows are being delivered to the application (and the receiver is
-       sitting in the NdbScanOperation::m_api_receivers array), it holds the
-       next row to be delivered to the application.
-
-    For NdbRecord operation, it works similarly, but instead indexes rows in
-    the RdbRecord m_row_buffer.
+    m_current_row holds the next row / key to be delivered to 
+    the application.
   */
   Uint32 m_current_row;
-  /* m_result_rows: Total number of rows contained in this batch. */
-  Uint32 m_result_rows;
-
-  Uint32 m__UNUSED;
 
   /*
     m_expected_result_length: Total number of 32-bit words of TRANSID_AI and
@@ -206,32 +218,64 @@ private:
   Uint32 m_expected_result_length;
   Uint32 m_received_result_length;
 
-  bool hasResults() const { return m_result_rows > 0; }
-  bool nextResult() const { return m_current_row < m_result_rows; }
-  Uint32 receive_packed_recattr(NdbRecAttr**, Uint32 bmlen, 
-                                const Uint32* aDataPtr, Uint32 aLength);
-  Uint32 receive_packed_ndbrecord(Uint32 bmlen,
-                                  const Uint32* aDataPtr,
-                                  char* row);
-  /* get_row() returns the next available row during NdbRecord scans. */
-  const char *get_row();
-  /*
-    peek_row() returns the row pointer that get_row() will return on next call,
-    without advancing the internal pointer.
-    So two successive calls to peek_row() will return the same pointer, whereas
-    two successive calls to get_row would return different pointers.
-  */
-  const char *peek_row() const;
-  /* get_range_no() returns the range_no from the last returned row. */
+  /**
+   * Unpack a packed stream of field values, whose presence and nullness
+   * is indicated by a leading bitmap into a list of NdbRecAttr objects
+   * Return the number of words read from the input stream.
+   */
+  static
+  Uint32 unpackRecAttr(NdbRecAttr**, Uint32 bmlen, 
+                       const Uint32* aDataPtr, Uint32 aLength);
+
+  /**
+   * Unpack a stream of field values, whose presence and nullness
+   * is indicated by a leading bitmap, into an NdbRecord row.
+   * Return the number of words consumed.
+   */
+  static
+  Uint32 unpackNdbRecord(const NdbRecord *record, Uint32 bmlen,
+                         const Uint32* aDataPtr,
+                         char* row);
+
+  /**
+   * Handle a stream of field values, both 'READ_PACKED' and plain
+   * unpacked fields, into a list of NdbRecAttr objects.
+   * Return 0 on success, or -1 on error
+   */
+  static
+  int handle_rec_attrs(NdbRecAttr* rec_attr_list,
+                       const Uint32* aDataPtr,
+                       Uint32 aLength);
+
+  
+  /**
+   * Unpack data for the specified 'row' previously stored into
+   * the 'buffer'. Handles both the row in NdbRecord format, and
+   * the key recieved as KEYINFO, if present.
+   */
+  const char *unpackBuffer(const NdbReceiverBuffer *buffer, Uint32 row);
+
+  /**
+   * Result set is navigated either sequentialy or randomly to a 
+   * specific row. The NdbRecord contents is then unpacked into 
+   * 'm_row_buffer' and returned. KeyInfo, Range no and RecAttr
+   * values may be retrieved by specific calls below.
+   */
+  const char *getRow(const NdbReceiverBuffer* buffer, Uint32 row);
+  const char *getNextRow();
+
+  /* Fetch the NdbRecord part of current row */
+  const char *getCurrentRow() const { return m_row_buffer; }
+
+  /* get_range_no() returns the range_no for current row. */
   int get_range_no() const;
-  /* get_keyinfo20)_ returns keyinfo from KEYINFO20 signal. */
+
+  /* Fetch keyinfo from KEYINFO20 signal for current row. */
   int get_keyinfo20(Uint32 & scaninfo, Uint32 & length,
                     const char * & data_ptr) const;
-  int getScanAttrData(const char * & data, Uint32 & size, Uint32 & pos) const;
-  /** Used by NdbQueryOperationImpl, where random access to rows is needed.*/
-  void setCurrentRow(char* buffer, Uint32 row);
-  /** Used by NdbQueryOperationImpl.*/
-  Uint32 getCurrentRow() const { return m_current_row; }
+
+  /** Fetch RecAttr values for current row. */
+  int get_AttrValues(NdbRecAttr* rec_attr_list) const;
 };
 
 #ifdef NDB_NO_DROPPED_SIGNAL
@@ -250,27 +294,10 @@ NdbReceiver::checkMagicNumber() const {
   return retVal;
 }
 
-inline
-void
-NdbReceiver::prepareSend(){
-  /* Set pointers etc. to prepare for receiving the first row of the batch. */
-  theMagicNumber = 0x11223344;
-  m_current_row = 0;
-  m_result_rows = 0;
-  m_received_result_length = 0;
-  m_expected_result_length = 0;
-  if (m_using_ndb_record)
-  {
-    if (m_type==NDB_SCANRECEIVER || m_type==NDB_QUERY_OPERATION)
-      m_record.m_row_recv= m_record.m_row_buffer;
-  }
-  theCurrentRecAttr = theFirstRecAttr;
-}
-
 inline
 int
 NdbReceiver::execTCOPCONF(Uint32 len){
-  Uint32 tmp = m_received_result_length;
+  const Uint32 tmp = m_received_result_length;
   m_expected_result_length = len;
 #ifdef assert
   assert(!(tmp && !len));
@@ -278,44 +305,5 @@ NdbReceiver::execTCOPCONF(Uint32 len){
   return ((bool)len ^ (bool)tmp ? 0 : 1);
 }
 
-inline
-int
-NdbReceiver::execSCANOPCONF(Uint32 tcPtrI, Uint32 len, Uint32 rows){
-  m_tcPtrI = tcPtrI;
-  m_result_rows = rows;
-  Uint32 tmp = m_received_result_length;
-  m_expected_result_length = len;
-  return (tmp == len ? 1 : 0);
-}
-
-inline
-void
-NdbReceiver::setCurrentRow(char* buffer, Uint32 row)
-{
-  m_record.m_row_buffer = buffer;
-  m_current_row = row;
-#ifdef assert
-  assert(m_current_row < m_result_rows);
-#endif
-}
-
-inline
-const char *
-NdbReceiver::get_row()
-{
-#ifdef assert
-  assert(m_current_row < m_result_rows);
-#endif
-  return m_record.m_row_buffer + (m_current_row++ * m_record.m_row_offset);
-}
-
-inline
-const char *
-NdbReceiver::peek_row() const
-{
-  return m_record.m_row_buffer + m_current_row * m_record.m_row_offset;
-}
-
-
 #endif // DOXYGEN_SHOULD_SKIP_INTERNAL
 #endif
diff --git a/storage/ndb/include/ndbapi/NdbScanOperation.hpp b/storage/ndb/include/ndbapi/NdbScanOperation.hpp
index 3652f263f6f..bc5ccee13f2 100644
--- a/storage/ndb/include/ndbapi/NdbScanOperation.hpp
+++ b/storage/ndb/include/ndbapi/NdbScanOperation.hpp
@@ -1,5 +1,5 @@
-/* Copyright (c) 2003-2007 MySQL AB
-
+/*
+   Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -594,7 +594,8 @@ protected:
   int getFirstATTRINFOScan();
   int doSendScan(int ProcessorId);
   int finaliseScanOldApi();
-  int prepareSendScan(Uint32 TC_ConnectPtr, Uint64 TransactionId);
+  int prepareSendScan(Uint32 TC_ConnectPtr, Uint64 TransactionId,
+                      const Uint32 * readMask);
   
   int fix_receivers(Uint32 parallel);
   void reset_receivers(Uint32 parallel, Uint32 ordered);
@@ -678,8 +679,12 @@ protected:
   bool m_multi_range; // Mark if operation is part of multi-range scan
   bool m_executed; // Marker if operation should be released at close
 
-  /* Buffer for rows received during NdbRecord scans, or NULL. */
-  char *m_scan_buffer;
+  /* Buffer given to NdbReceivers for batch of rows received 
+     during NdbRecord scans, or NULL. Buffer is chunked up
+     to construct several NdbReceiverBuffer, but is allocated
+     as a single chunk from the NdbScanOperation
+  */
+  Uint32 *m_scan_buffer;
   
   /* Initialise scan operation with user provided information */
   virtual int processTableScanDefs(LockMode lock_mode, 
diff --git a/storage/ndb/include/ndbapi/NdbTransaction.hpp b/storage/ndb/include/ndbapi/NdbTransaction.hpp
index 08161abb299..bd6c7ca1e69 100644
--- a/storage/ndb/include/ndbapi/NdbTransaction.hpp
+++ b/storage/ndb/include/ndbapi/NdbTransaction.hpp
@@ -1,5 +1,5 @@
-/* Copyright (c) 2003-2007 MySQL AB
-
+/*
+   Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1035,14 +1035,12 @@ private:
 
   int		checkMagicNumber();		       // Verify correct object
   NdbOperation* getNdbOperation(const class NdbTableImpl* aTable,
-                                NdbOperation* aNextOp = 0,
-                                bool useRec= false);
+                                NdbOperation* aNextOp = 0);
 
   NdbIndexScanOperation* getNdbScanOperation(const class NdbTableImpl* aTable);
   NdbIndexOperation* getNdbIndexOperation(const class NdbIndexImpl* anIndex, 
                                           const class NdbTableImpl* aTable,
-                                          NdbOperation* aNextOp = 0,
-                                          bool useRec= false);
+                                          NdbOperation* aNextOp = 0);
   NdbIndexScanOperation* getNdbIndexScanOperation(const NdbIndexImpl* index,
 						  const NdbTableImpl* table);
   
diff --git a/storage/ndb/src/ndbapi/NdbIndexOperation.cpp b/storage/ndb/src/ndbapi/NdbIndexOperation.cpp
index 7a63b7897d6..9b1dfcaf724 100644
--- a/storage/ndb/src/ndbapi/NdbIndexOperation.cpp
+++ b/storage/ndb/src/ndbapi/NdbIndexOperation.cpp
@@ -1,5 +1,5 @@
-/* Copyright (c) 2003-2007 MySQL AB
-
+/*
+   Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -33,7 +33,7 @@ NdbIndexOperation::NdbIndexOperation(Ndb* aNdb) :
   /**
    * Change receiver type
    */
-  theReceiver.init(NdbReceiver::NDB_INDEX_OPERATION, false, this);
+  theReceiver.init(NdbReceiver::NDB_INDEX_OPERATION, this);
 }
 
 NdbIndexOperation::~NdbIndexOperation()
@@ -50,10 +50,9 @@ NdbIndexOperation::~NdbIndexOperation()
 int
 NdbIndexOperation::indxInit(const NdbIndexImpl * anIndex,
 			    const NdbTableImpl * aTable, 
-			    NdbTransaction* myConnection,
-                            bool useRec)
+			    NdbTransaction* myConnection)
 {
-  NdbOperation::init(aTable, myConnection, useRec);
+  NdbOperation::init(aTable, myConnection);
 
   switch (anIndex->m_type) {
   case(NdbDictionary::Index::UniqueHashIndex):
diff --git a/storage/ndb/src/ndbapi/NdbOperation.cpp b/storage/ndb/src/ndbapi/NdbOperation.cpp
index a155981b628..dd3839150fd 100644
--- a/storage/ndb/src/ndbapi/NdbOperation.cpp
+++ b/storage/ndb/src/ndbapi/NdbOperation.cpp
@@ -1,5 +1,5 @@
-/* Copyright (c) 2003-2007 MySQL AB
-
+/*
+   Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -72,7 +72,7 @@ NdbOperation::NdbOperation(Ndb* aNdb, NdbOperation::Type aType) :
   theLockHandle(NULL),
   m_blob_lock_upgraded(false)
 {
-  theReceiver.init(NdbReceiver::NDB_OPERATION, false, this);
+  theReceiver.init(NdbReceiver::NDB_OPERATION, this);
   theError.code = 0;
   m_customData = NULL;
 }
@@ -133,8 +133,8 @@ NdbOperation::setErrorCodeAbort(int anErrorCode) const
  *****************************************************************************/
 
 int
-NdbOperation::init(const NdbTableImpl* tab, NdbTransaction* myConnection,
-                   bool useRec){
+NdbOperation::init(const NdbTableImpl* tab, NdbTransaction* myConnection)
+{
   NdbApiSignal* tSignal;
   theStatus		= Init;
   theError.code		= 0;
@@ -189,7 +189,7 @@ NdbOperation::init(const NdbTableImpl* tab, NdbTransaction* myConnection,
   tcKeyReq->scanInfo = 0;
   theKEYINFOptr = &tcKeyReq->keyInfo[0];
   theATTRINFOptr = &tcKeyReq->attrInfo[0];
-  if (theReceiver.init(NdbReceiver::NDB_OPERATION, useRec, this))
+  if (theReceiver.init(NdbReceiver::NDB_OPERATION, this))
   {
     // theReceiver sets the error code of its owner
     return -1;
diff --git a/storage/ndb/src/ndbapi/NdbOperationExec.cpp b/storage/ndb/src/ndbapi/NdbOperationExec.cpp
index cb08fade841..cd3f3c89bb0 100644
--- a/storage/ndb/src/ndbapi/NdbOperationExec.cpp
+++ b/storage/ndb/src/ndbapi/NdbOperationExec.cpp
@@ -1,5 +1,5 @@
-/* Copyright (c) 2003-2007 MySQL AB
-
+/*
+   Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1066,7 +1066,7 @@ NdbOperation::buildSignalsNdbRecord(Uint32 aTC_ConnectPtr,
      * header + inline data
      * Disk flag set when getValues were processed.
      */
-    const NdbRecAttr *ra= theReceiver.theFirstRecAttr;
+    const NdbRecAttr *ra= theReceiver.m_firstRecAttr;
     while (ra)
     {
       res= insertATTRINFOHdr_NdbRecord(ra->attrId(), 0);
diff --git a/storage/ndb/src/ndbapi/NdbQueryOperation.cpp b/storage/ndb/src/ndbapi/NdbQueryOperation.cpp
index 2c60058a4f4..550902c5024 100644
--- a/storage/ndb/src/ndbapi/NdbQueryOperation.cpp
+++ b/storage/ndb/src/ndbapi/NdbQueryOperation.cpp
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -372,7 +372,7 @@ public:
   explicit NdbResultSet();
 
   void init(NdbQueryImpl& query,
-            Uint32 maxRows, Uint32 rowSize);
+            Uint32 maxRows, Uint32 bufferSize);
 
   void prepareReceive(NdbReceiver& receiver)
   {
@@ -380,11 +380,6 @@ public:
     receiver.prepareReceive(m_buffer);
   }
 
-  void prepareRead(NdbReceiver& receiver)
-  {
-    receiver.prepareRead(m_buffer,m_rowCount);
-  }
-
   Uint32 getRowCount() const
   { return m_rowCount; }
 
@@ -394,16 +389,11 @@ private:
   NdbResultSet& operator=(const NdbResultSet&);
 
   /** The buffers which we receive the results into */
-  char* m_buffer;
-
-  /** Used for checking if buffer overrun occurred. */
-  Uint32* m_batchOverflowCheck;
+  NdbReceiverBuffer* m_buffer;
 
   /** Array of TupleCorrelations for all rows in m_buffer */
   TupleCorrelation* m_correlations;
 
-  Uint32 m_rowSize;
-
   /** The current #rows in 'm_buffer'.*/
   Uint32 m_rowCount;
 
@@ -446,7 +436,7 @@ public:
   { return m_receiver; }
 
   const char* getCurrentRow()
-  { return m_receiver.get_row(); }
+  { return m_receiver.getCurrentRow(); }
 
   /**
    * Process an incomming tuple for this stream. Extract parent and own tuple 
@@ -678,27 +668,19 @@ void* NdbBulkAllocator::allocObjMem(Uint32 noOfObjs)
 ///////////////////////////////////////////
 NdbResultSet::NdbResultSet() :
   m_buffer(NULL),
-  m_batchOverflowCheck(NULL),
   m_correlations(NULL),
-  m_rowSize(0),
   m_rowCount(0)
 {}
 
 void
 NdbResultSet::init(NdbQueryImpl& query,
                    Uint32 maxRows,
-                   Uint32 rowSize)
+                   Uint32 bufferSize)
 {
-  m_rowSize = rowSize;
   {
-    const int bufferSize = rowSize * maxRows;
     NdbBulkAllocator& bufferAlloc = query.getRowBufferAlloc();
-    m_buffer = reinterpret_cast<char*>(bufferAlloc.allocObjMem(bufferSize));
-
-    // So that we can test for buffer overrun.
-    m_batchOverflowCheck = 
-      reinterpret_cast<Uint32*>(bufferAlloc.allocObjMem(sizeof(Uint32)));
-    *m_batchOverflowCheck = 0xacbd1234;
+    Uint32 *buffer = reinterpret_cast<Uint32*>(bufferAlloc.allocObjMem(bufferSize));
+    m_buffer = NdbReceiver::initReceiveBuffer(buffer, bufferSize, maxRows);
 
     if (query.getQueryDef().isScanQuery())
     {
@@ -747,37 +729,41 @@ NdbResultStream::~NdbResultStream()
 void
 NdbResultStream::prepare()
 {
-  const Uint32 rowSize = m_operation.getRowSize();
   NdbQueryImpl &query = m_operation.getQuery();
 
-  /* Parent / child correlation is only relevant for scan type queries
-   * Don't create a m_tupleSet with these correlation id's for lookups!
-   */
+  const Uint32 batchBufferSize = m_operation.getBatchBufferSize();
   if (isScanQuery())
   {
+    /* Parent / child correlation is only relevant for scan type queries
+     * Don't create a m_tupleSet with these correlation id's for lookups!
+     */
     m_maxRows  = m_operation.getMaxBatchRows();
     m_tupleSet = 
       new (query.getTupleSetAlloc().allocObjMem(m_maxRows)) 
       TupleSet[m_maxRows];
 
-    // Scan results may be doublebuffered
-    m_resultSets[0].init(query, m_maxRows, rowSize); 
-    m_resultSets[1].init(query, m_maxRows, rowSize);
+    // Scan results may be double buffered
+    m_resultSets[0].init(query, m_maxRows, batchBufferSize); 
+    m_resultSets[1].init(query, m_maxRows, batchBufferSize);
   }
   else
   {
     m_maxRows = 1;
-    m_resultSets[0].init(query, m_maxRows, rowSize);
+    m_resultSets[0].init(query, m_maxRows, batchBufferSize);
   }
 
-  m_receiver.init(NdbReceiver::NDB_QUERY_OPERATION, false, &m_operation);
+  /* Alloc buffer for unpacked NdbRecord row */
+  const Uint32 rowSize = m_operation.getRowSize();
+  assert((rowSize % sizeof(Uint32)) == 0);
+  char *rowBuffer = reinterpret_cast<char*>(query.getRowBufferAlloc().allocObjMem(rowSize));
+  assert(rowBuffer != NULL);
+
+  m_receiver.init(NdbReceiver::NDB_QUERY_OPERATION, &m_operation);
   m_receiver.do_setup_ndbrecord(
                           m_operation.getNdbRecord(),
-                          m_maxRows, 
-                          0 /*key_size*/, 
-                          0 /*read_range_no*/, 
-                          rowSize,
-                          m_resultSets[m_recv].m_buffer);
+                          rowBuffer,
+                          false, /*read_range_no*/
+                          false  /*read_key_info*/);
 } //NdbResultStream::prepare
 
 /** Locate, and return 'tupleNo', of first tuple with specified parentId.
@@ -864,7 +850,8 @@ NdbResultStream::firstResult()
   if ((m_currentRow=findTupleWithParentId(parentId)) != tupleNotFound)
   {
     m_iterState = Iter_started;
-    m_receiver.setCurrentRow(m_resultSets[m_read].m_buffer, m_currentRow);
+    const char *p = m_receiver.getRow(m_resultSets[m_read].m_buffer, m_currentRow);
+    assert(p != NULL);  ((void)p);
     return m_currentRow;
   }
 
@@ -880,7 +867,8 @@ NdbResultStream::nextResult()
       (m_currentRow=findNextTuple(m_currentRow)) != tupleNotFound)
   {
     m_iterState = Iter_started;
-    m_receiver.setCurrentRow(m_resultSets[m_read].m_buffer, m_currentRow);
+    const char *p = m_receiver.getRow(m_resultSets[m_read].m_buffer, m_currentRow);
+    assert(p != NULL);  ((void)p);
     return m_currentRow;
   }
   m_iterState = Iter_finished;
@@ -955,10 +943,7 @@ NdbResultStream::prepareResultSet(Uint32 remainingScans)
    */
   const bool newResults = (m_read != m_recv);
   m_read = m_recv;
-  NdbResultSet& readResult = m_resultSets[m_read];
-
-  // Set correct buffer and #rows received by this ResultSet.
-  readResult.prepareRead(m_receiver);
+  const NdbResultSet& readResult = m_resultSets[m_read];
 
   if (m_tupleSet!=NULL)
   {
@@ -1047,10 +1032,6 @@ NdbResultStream::buildResultCorrelations()
 {
   const NdbResultSet& readResult = m_resultSets[m_read];
 
-  // Buffer overrun check.
-  assert(readResult.m_batchOverflowCheck==NULL || 
-         *readResult.m_batchOverflowCheck==0xacbd1234);
-
 //if (m_tupleSet!=NULL)
   {
     /* Clear the hashmap structures */
@@ -2740,13 +2721,19 @@ NdbQueryImpl::prepareSend()
   for (Uint32 opNo = 0; opNo < getNoOfOperations(); opNo++)
   {
     const NdbQueryOperationImpl& op = getQueryOperation(opNo);
-    // Add space for m_correlations, m_buffer & m_batchOverflowCheck
-    totalBuffSize += (sizeof(TupleCorrelation) * op.getMaxBatchRows());
-    totalBuffSize += (op.getRowSize() * op.getMaxBatchRows());
-    totalBuffSize += sizeof(Uint32); // Overflow check
+
+    // Add space for batchBuffer & m_correlations
+    Uint32 opBuffSize = op.getBatchBufferSize();
+    if (getQueryDef().isScanQuery())
+    {
+      opBuffSize += (sizeof(TupleCorrelation) * op.getMaxBatchRows());
+      opBuffSize *= 2;              // Scans are double buffered
+    }
+    opBuffSize += op.getRowSize();  // Unpacked row from buffers
+    totalBuffSize += opBuffSize;
   }
+  m_rowBufferAlloc.init(m_rootFragCount * totalBuffSize);
 
-  m_rowBufferAlloc.init(2 * m_rootFragCount * totalBuffSize);
   if (getQueryDef().isScanQuery())
   {
     Uint32 totalRows = 0;
@@ -3793,7 +3780,8 @@ NdbQueryOperationImpl::NdbQueryOperationImpl(
   m_diskInUserProjection(false),
   m_parallelism(def.getQueryOperationIx() == 0
                 ? Parallelism_max : Parallelism_adaptive),
-  m_rowSize(0xffffffff)
+  m_rowSize(0xffffffff),
+  m_batchBufferSize(0xffffffff)
 { 
   if (errno == ENOMEM)
   {
@@ -4144,23 +4132,9 @@ NdbQueryOperationImpl::fetchRow(NdbResultStream& resultStream)
   m_isRowNull = false;
   if (m_firstRecAttr != NULL)
   {
-    NdbRecAttr* recAttr = m_firstRecAttr;
-    Uint32 posInRow = 0;
-    while (recAttr != NULL)
-    {
-      const char *attrData = NULL;
-      Uint32 attrSize = 0;
-      const int retVal1 = resultStream.getReceiver()
-        .getScanAttrData(attrData, attrSize, posInRow);
-      UNUSED(retVal1);
-      assert(retVal1==0);
-      assert(attrData!=NULL);
-      const bool retVal2 = recAttr
-        ->receive_data(reinterpret_cast<const Uint32*>(attrData), attrSize);
-      UNUSED(retVal2);
-      assert(retVal2);
-      recAttr = recAttr->next();
-    }
+    // Retrieve any RecAttr (getValues()) for current row
+    const int retVal = resultStream.getReceiver().get_AttrValues(m_firstRecAttr);
+    assert(retVal==0);  ((void)retVal);
   }
   if (m_ndbRecord != NULL)
   {
@@ -4173,8 +4147,7 @@ NdbQueryOperationImpl::fetchRow(NdbResultStream& resultStream)
     {
       assert(m_resultBuffer!=NULL);
       // Copy result to buffer supplied by application.
-      memcpy(m_resultBuffer, buff, 
-             resultStream.getReceiver().m_record.m_ndb_record->m_row_size);
+      memcpy(m_resultBuffer, buff, m_ndbRecord->m_row_size);
     }
   }
 } // NdbQueryOperationImpl::fetchRow
@@ -5280,11 +5253,65 @@ Uint32 NdbQueryOperationImpl::getRowSize() const
   if (m_rowSize == 0xffffffff)
   {
     m_rowSize = 
-      NdbReceiver::ndbrecord_rowsize(m_ndbRecord, m_firstRecAttr, 0, false);
+      NdbReceiver::ndbrecord_rowsize(m_ndbRecord, false);
   }
   return m_rowSize;
 }
 
+Uint32 NdbQueryOperationImpl::getBatchBufferSize() const
+{
+  // Check if batch buffer size has been computed yet.
+  if (m_batchBufferSize == 0xffffffff)
+  {
+    Uint32 batchRows = getMaxBatchRows();
+    Uint32 batchByteSize = 0;
+    Uint32 batchFrags = 1;
+
+    if (m_operationDef.isScanOperation())
+    {
+      const Ndb* const ndb = getQuery().getNdbTransaction().getNdb();
+      NdbReceiver::calculate_batch_size(* ndb->theImpl,
+                                        getQuery().getRootFragCount(),
+                                        batchRows,
+                                        batchByteSize);
+      assert(batchRows == getMaxBatchRows());
+
+      /**
+       * When LQH reads a scan batch, the size of the batch is limited 
+       * both to a maximal number of rows and a maximal number of bytes.
+       * The latter limit is interpreted such that the batch ends when the 
+       * limit has been exceeded. Consequently, the buffer must be able to
+       * hold max_no_of_bytes plus one extra row. In addition,  when the
+       * SPJ block executes a (pushed) child scan operation, it scans a 
+       * number of fragments (possibly all) in parallel, and divides the
+       * row and byte limits by the number of parallel fragments.
+       * Consequently, a child scan operation may return max_no_of_bytes,
+       * plus one extra row for each fragment.
+       */
+      if (getParentOperation() != NULL)
+      {
+        batchFrags = getQuery().getRootFragCount();
+      }
+    }
+
+    AttributeMask readMask;
+    if (m_ndbRecord != NULL)
+    {
+      m_ndbRecord->copyMask(readMask.rep.data, m_read_mask);
+    }
+
+    m_batchBufferSize = NdbReceiver::result_bufsize(
+                                                  batchRows, 
+                                                  batchByteSize,
+                                                  batchFrags,
+                                                  m_ndbRecord,
+                                                  readMask.rep.data,
+                                                  m_firstRecAttr,
+                                                  0, 0);
+  }
+  return m_batchBufferSize;
+}
+
 /** For debugging.*/
 NdbOut& operator<<(NdbOut& out, const NdbQueryOperationImpl& op){
   out << "[ this: " << &op
diff --git a/storage/ndb/src/ndbapi/NdbQueryOperationImpl.hpp b/storage/ndb/src/ndbapi/NdbQueryOperationImpl.hpp
index 00b7efc0e92..f75890ef0e4 100644
--- a/storage/ndb/src/ndbapi/NdbQueryOperationImpl.hpp
+++ b/storage/ndb/src/ndbapi/NdbQueryOperationImpl.hpp
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -723,7 +723,10 @@ public:
   Uint32 getMaxBatchRows() const
   { return m_maxBatchRows; }
 
-  /** Get size of row as required to buffer it. */  
+  /** Get size of buffer required to hold a full batch of 'packed' rows */
+  Uint32 getBatchBufferSize() const;
+
+  /** Get size of a full row. */  
   Uint32 getRowSize() const;
 
   const NdbRecord* getNdbRecord() const
@@ -787,9 +790,12 @@ private:
    */
   Uint32 m_parallelism;
   
-  /** Size of each result row (in bytes).*/
+  /** Size of each unpacked result row (in bytes).*/
   mutable Uint32 m_rowSize;
 
+  /** Size of the buffer required to hold a batch of result rows */
+  mutable Uint32 m_batchBufferSize;
+
   explicit NdbQueryOperationImpl(NdbQueryImpl& queryImpl, 
                                  const NdbQueryOperationDefImpl& def);
   ~NdbQueryOperationImpl();
diff --git a/storage/ndb/src/ndbapi/NdbReceiver.cpp b/storage/ndb/src/ndbapi/NdbReceiver.cpp
index 45695e60ebc..f499f7c285d 100644
--- a/storage/ndb/src/ndbapi/NdbReceiver.cpp
+++ b/storage/ndb/src/ndbapi/NdbReceiver.cpp
@@ -1,5 +1,5 @@
-/* Copyright (c) 2003-2007 MySQL AB
-
+/*
+   Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -20,19 +20,266 @@
 #include <signaldata/TcKeyConf.hpp>
 #include <signaldata/DictTabInfo.hpp>
 
+
+/**
+ * 'class NdbReceiveBuffer' takes care of buffering multi-row
+ * result sets received as the result of scan- or query- operations.
+ * Rows are stored in the 'raw' transporter format in the buffer,
+ * and later (only) the 'current row' is retrieved from the buffer,
+ * and unpacked into the full NdbRecord row format when navigated to.
+ */
+class NdbReceiverBuffer
+{
+public:
+
+  /**
+   * End of row and key buffer area has an 'eodMagic'
+   * as a debugging aid in detecting buffer overflows.
+   */
+  static const Uint32 eodMagic = 0xacbd1234;
+
+  explicit NdbReceiverBuffer(Uint32 bufSizeBytes,
+                             Uint32 batchRows);
+
+  void reset()
+  { m_rows = m_keys = 0; }
+
+  Uint32 getBufSizeWords() const
+  { return m_bufSizeWords; }
+
+  Uint32 getMaxRows() const
+  { return m_maxRows; }
+
+  Uint32 getRowCount() const
+  { return m_rows; }
+
+  Uint32 getKeyCount() const
+  { return m_keys; }
+
+  /**
+   * Rows are buffered in the first part of 'm_buffer'. The first
+   * 'm_maxrows+1' Uint32s in the buffer is a row_ix[] containing
+   * buffer indexes, such that:
+   *  - Row 'n' starts at m_buffer[row_ix[n]].
+   *  - Length of row 'n' is 'row_ix[n+1] - row_ix[n].
+   * row_ix[] contains one more item than 'm_maxrows'. The item
+   * past the last row is maintained such that the length of last row
+   * can be calculated.
+   */
+  Uint32 *allocRow(Uint32 noOfWords)
+  {
+    assert(verifyBuffer());
+    const Uint32 pos = rowIx(m_rows);  //First free
+    rowIx(++m_rows) = pos + noOfWords; //Next free
+#ifndef NDEBUG
+    m_buffer[pos + noOfWords] = eodMagic;
+    assert(verifyBuffer());
+#endif
+    return &m_buffer[pos];
+  }
+
+  /**
+   * Keys are allocated from the end of 'm_buffer', it grows and are
+   * indexed in *reverse order*. key_ix[] is allocated at the very end of
+   * the buffer:
+   *  - Key 'n' starts at m_buffer[key_ix[n]]
+   *  - Length of key 'n' is 'key_ix[n-1] - key_ix[n]'.
+   */
+  Uint32 *allocKey(Uint32 noOfWords)
+  {
+    assert(verifyBuffer());
+    const Uint32 prev = keyIx(m_keys-1);
+    const Uint32 pos = prev - noOfWords;
+    keyIx(m_keys) = pos;
+    m_keys++;
+#ifndef NDEBUG
+    m_buffer[pos-1] = eodMagic;
+    assert(verifyBuffer());
+#endif
+    return &m_buffer[pos];
+  }
+
+  const Uint32 *getRow(Uint32 row, Uint32& noOfWords) const
+  {
+    assert(verifyBuffer());
+    if (unlikely(row >= m_rows))
+      return NULL;
+
+    const Uint32 ix = rowIx(row);
+    noOfWords = rowIx(row+1) - ix;
+    assert(noOfWords < m_bufSizeWords);  // Sanity check
+    return m_buffer + ix;
+  }
+
+  const Uint32 *getKey(Uint32 key, Uint32& noOfWords) const
+  {
+    assert(verifyBuffer());
+    if (unlikely(key >= m_keys))
+      return NULL;
+
+    const Uint32 ix = keyIx(key);
+    noOfWords = keyIx(key-1) - ix;
+    assert(noOfWords < m_bufSizeWords);  // Sanity check
+    return m_buffer + ix;
+  }
+
+  /**
+   * We know 'bufSizeWords', the total max size of data to store 
+   * in the buffer. In addition there are some overhead required by
+   * the buffer management itself. Calculate total words required to
+   * be allocated for the NdbReceiverBuffer structure.
+   */
+  static Uint32 calculateSizeInWords(Uint32 bufSizeWords, 
+                                     Uint32 batchRows,
+                                     Uint32 keySize)
+  {
+    return  bufSizeWords +          // Words to store
+            1 +                     // 'eodMagic' in buffer
+            headerWords +           // Admin overhead
+            ((keySize > 0)          // Row + optional key indexes
+              ? (batchRows+1) * 2   // Row + key indexes
+	      : (batchRows+1));     // Row index only
+  }
+
+private:
+  static const Uint32 headerWords= 4; //4*Uint32's below
+
+  // No copying / assignment:
+  NdbReceiverBuffer(const NdbReceiverBuffer&);
+  NdbReceiverBuffer& operator=(const NdbReceiverBuffer&);
+
+  const Uint32 m_maxRows;       // Max capacity in #rows / #keys
+  const Uint32 m_bufSizeWords;  // Size of 'm_buffer'
+
+  Uint32 m_rows;                // Current #rows in m_buffer
+  Uint32 m_keys;                // Current #keys in m_buffer
+
+  Uint32 m_buffer[1];           // Variable size buffer area (m_bufSizeWords)
+
+  /**
+   * Index to row offset is first 'maxrows' items in m_buffer.
+   * We maintain a 'next free row' position for all
+   * 'm_maxrows' in the buffer. Thus, this index array has
+   * to contain 'm_maxrows+1' items, indexed from [0..m_maxrows].
+   * This allows is to calculate data length for all rows 
+   * as 'start(row+1) - start(row))
+   */
+  Uint32  rowIx(Uint32 row) const { return m_buffer[row]; }
+  Uint32& rowIx(Uint32 row)       { return m_buffer[row]; }
+
+  /**
+   * Index to key offset is last 'maxrows' items in m_buffer.
+   * We maintain a 'previous row start' position for all
+   * 'm_maxrows' in the buffer - even for 'key 0'. 
+   * Thus, this index array has to contain 'm_maxrows+1'
+   * items, indexed from [-1..maxrows-1].
+   * This allows is to calculate data length for all keys 
+   * as 'start(key-1) - start(key)).
+   */
+
+  // 'm_bufSizeWords-2' is keyIx(0), that place keyIx(-1) at 'm_bufSizeWords-1'
+  Uint32  keyIx(Uint32 key) const { return m_buffer[m_bufSizeWords-2-key]; }
+  Uint32& keyIx(Uint32 key)       { return m_buffer[m_bufSizeWords-2-key]; }
+
+  bool verifyBuffer() const
+  {
+    assert(m_rows <= m_maxRows);
+    assert(m_keys <= m_maxRows);
+    // Check rows startpos and end within buffer
+    assert(rowIx(0) == m_maxRows+1);
+    assert(rowIx(m_rows) <= m_bufSizeWords);
+
+    // Rest of rows in sequence with non-negative length
+    for (Uint32 row=0; row<m_rows; row++)
+    {
+      assert(rowIx(row) <= rowIx(row+1));
+    }
+    // Overflow protection
+    assert(m_rows == 0 ||
+           m_buffer[rowIx(m_rows)] == eodMagic);
+
+    if (m_keys > 0)
+    {
+      // Check keys startpos and end before row buffer
+      assert(keyIx(-1) == (m_bufSizeWords - (m_maxRows+1)));
+      assert(keyIx(m_keys-1) >= rowIx(m_rows));
+
+      // Rest of keys in sequence with non-negative length
+      for (Uint32 key=0; key<m_keys; key++)
+      {
+        assert(keyIx(key) <= keyIx(key-1));
+      }
+
+      // Overflow protection
+      assert(m_buffer[keyIx(m_keys-1)-1] == eodMagic);
+    }
+    return true;
+  }
+
+}; //class NdbReceiverBuffer
+
+NdbReceiverBuffer::NdbReceiverBuffer(
+			     Uint32 bufSizeBytes, // Word aligned size
+                             Uint32 batchRows)
+  : m_maxRows(batchRows), 
+    m_bufSizeWords((bufSizeBytes/sizeof(Uint32)) - headerWords), 
+    m_rows(0), 
+    m_keys(0)
+{
+  assert((bufSizeBytes/sizeof(Uint32)) > headerWords);
+
+  /**
+   * Init row and key index arrays. Row indexes maintain
+   * a 'next free row' position which for rows start imm.
+   * after the 'm_maxrows+1' indexes.
+   */ 
+  rowIx(0) = m_maxRows+1;
+
+  /**
+   * Key indexes maintain a 'prev key startpos', even for key(0).
+   * Thus, for an empty key_ix[], we set startpos for 
+   * (the non-existing) key(-1) which is imm. after the
+   * available key buffer area.
+   *
+   * NOTE: We init key_ix[] even if keyinfo not present
+   * in result set. that case it might later be overwritten
+   * by rows, which is ok as the keyinfo is then never used.
+   */
+  keyIx(-1) = m_bufSizeWords - (m_maxRows+1);
+  assert(verifyBuffer());
+}
+
+
+/**
+ * 'BEFORE' is used as the initial position before having a
+ * valid 'current' row. Beware, wraparound is assumed such
+ * that ' beforeFirstRow+1' -> 0 (first row)
+ */
+static const Uint32 beforeFirstRow = 0xFFFFFFFF;
+
+static
+const Uint8*
+pad(const Uint8* src, Uint32 align, Uint32 bitPos);
+
 NdbReceiver::NdbReceiver(Ndb *aNdb) :
   theMagicNumber(0),
   m_ndb(aNdb),
   m_id(NdbObjectIdMap::InvalidId),
   m_tcPtrI(RNIL),
   m_type(NDB_UNINITIALIZED),
-  m_owner(0),
-  m_using_ndb_record(false),
-  theFirstRecAttr(NULL),
-  theCurrentRecAttr(NULL),
-  m_rows(NULL),
-  m_current_row(0xffffffff),
-  m_result_rows(0)
+  m_owner(NULL),
+  m_ndb_record(NULL),
+  m_row_buffer(NULL),
+  m_recv_buffer(NULL),
+  m_read_range_no(false),
+  m_read_key_info(false),
+  m_firstRecAttr(NULL),
+  m_lastRecAttr(NULL),
+  m_rec_attr_data(NULL),
+  m_rec_attr_len(0),
+  m_current_row(beforeFirstRow),
+  m_expected_result_length(0),
+  m_received_result_length(0)
 {}
  
 NdbReceiver::~NdbReceiver()
@@ -41,30 +288,38 @@ NdbReceiver::~NdbReceiver()
   if (m_id != NdbObjectIdMap::InvalidId) {
     m_ndb->theImpl->theNdbObjectIdMap.unmap(m_id, this);
   }
-  delete[] m_rows;
   DBUG_VOID_RETURN;
 }
 
+//static
+NdbReceiverBuffer*
+NdbReceiver::initReceiveBuffer(Uint32 *buffer,      // Uint32 aligned buffer
+                               Uint32 bufSizeBytes, // Size, from ::result_bufsize()
+                               Uint32 batchRows)
+{
+  assert(((UintPtr)buffer % sizeof(Uint32)) == 0);   //Is Uint32 aligned
+
+  return new(buffer) NdbReceiverBuffer(bufSizeBytes, batchRows);
+}
+
 int
-NdbReceiver::init(ReceiverType type, bool useRec, void* owner)
+NdbReceiver::init(ReceiverType type, void* owner)
 {
   theMagicNumber = 0x11223344;
   m_type = type;
-  m_using_ndb_record= useRec;
   m_owner = owner;
-
-  if (useRec)
+  m_ndb_record= NULL;
+  m_row_buffer= NULL;
+  m_recv_buffer= NULL;
+  m_read_range_no= false;
+  m_read_key_info= false;
+  m_firstRecAttr = NULL;
+  m_lastRecAttr = NULL;
+  m_rec_attr_data = NULL;
+  m_rec_attr_len = 0;
+
+  if (m_id == NdbObjectIdMap::InvalidId)
   {
-    m_record.m_ndb_record= NULL;
-    m_record.m_row_recv= NULL;
-    m_record.m_row_buffer= NULL;
-    m_record.m_row_offset= 0;
-    m_record.m_read_range_no= false;
-  }
-  theFirstRecAttr = NULL;
-  theCurrentRecAttr = NULL;
-
-  if (m_id == NdbObjectIdMap::InvalidId) {
     if (m_ndb)
     {
       m_id = m_ndb->theImpl->theNdbObjectIdMap.map(this);
@@ -75,34 +330,51 @@ NdbReceiver::init(ReceiverType type, bool useRec, void* owner)
       }
     }
   }
-
   return 0;
 }
 
 void
-NdbReceiver::release(){
+NdbReceiver::do_setup_ndbrecord(const NdbRecord *ndb_record,
+                                char *row_buffer,
+                                bool read_range_no, bool read_key_info)
+{
+  m_ndb_record= ndb_record;
+  m_row_buffer= row_buffer;
+  m_recv_buffer= NULL;
+  m_read_range_no= read_range_no;
+  m_read_key_info= read_key_info;
+}
+
+void
+NdbReceiver::release()
+{
   theMagicNumber = 0;
-  NdbRecAttr* tRecAttr = theFirstRecAttr;
+  NdbRecAttr* tRecAttr = m_firstRecAttr;
   while (tRecAttr != NULL)
   {
     NdbRecAttr* tSaveRecAttr = tRecAttr;
     tRecAttr = tRecAttr->next();
     m_ndb->releaseRecAttr(tSaveRecAttr);
   }
-  m_using_ndb_record= false;
-  theFirstRecAttr = NULL;
-  theCurrentRecAttr = NULL;
+  m_firstRecAttr = NULL;
+  m_lastRecAttr = NULL;
+  m_rec_attr_data = NULL;
+  m_rec_attr_len = 0;
+  m_ndb_record= NULL;
+  m_row_buffer= NULL;
+  m_recv_buffer= NULL;
 }
   
 NdbRecAttr *
-NdbReceiver::getValue(const NdbColumnImpl* tAttrInfo, char * user_dst_ptr){
+NdbReceiver::getValue(const NdbColumnImpl* tAttrInfo, char * user_dst_ptr)
+{
   NdbRecAttr* tRecAttr = m_ndb->getRecAttr();
   if(tRecAttr && !tRecAttr->setup(tAttrInfo, user_dst_ptr)){
-    if (theFirstRecAttr == NULL)
-      theFirstRecAttr = tRecAttr;
+    if (m_firstRecAttr == NULL)
+      m_firstRecAttr = tRecAttr;
     else
-      theCurrentRecAttr->next(tRecAttr);
-    theCurrentRecAttr = tRecAttr;
+      m_lastRecAttr->next(tRecAttr);
+    m_lastRecAttr = tRecAttr;
     tRecAttr->next(NULL);
     return tRecAttr;
   }
@@ -115,42 +387,35 @@ NdbReceiver::getValue(const NdbColumnImpl* tAttrInfo, char * user_dst_ptr){
 void
 NdbReceiver::getValues(const NdbRecord* rec, char *row_ptr)
 {
-  assert(m_using_ndb_record);
+  assert(m_recv_buffer == NULL);
+  assert(rec != NULL  && row_ptr != NULL);
 
-  m_record.m_ndb_record= rec;
-  m_record.m_row_recv= row_ptr;
-  m_record.m_row_offset= rec->m_row_size;
+  m_ndb_record= rec;
+  m_row_buffer= row_ptr;
 }
 
 void
-NdbReceiver::prepareReceive(char *buf)
+NdbReceiver::prepareSend()
 {
   /* Set pointers etc. to prepare for receiving the first row of the batch. */
-  assert(theMagicNumber == 0x11223344);
+  theMagicNumber = 0x11223344;
+  m_current_row = beforeFirstRow;
   m_received_result_length = 0;
   m_expected_result_length = 0;
-  if (m_using_ndb_record)
+
+  if (m_recv_buffer != NULL)
   {
-    m_record.m_row_recv= buf;
+    m_recv_buffer->reset();
   }
-  theCurrentRecAttr = theFirstRecAttr;
 }
 
 void
-NdbReceiver::prepareRead(char *buf, Uint32 rows)
+NdbReceiver::prepareReceive(NdbReceiverBuffer *buffer)
 {
-  /* Set pointers etc. to prepare for reading the first row of the batch. */
-  assert(theMagicNumber == 0x11223344);
-  m_current_row = 0;
-  m_result_rows = rows;
-  if (m_using_ndb_record)
-  {
-    m_record.m_row_buffer = buf;
-  }
+  m_recv_buffer= buffer;
+  prepareSend();
 }
 
- #define KEY_ATTR_ID (~(Uint32)0)
-
 /*
   Compute the batch size (rows between each NEXT_TABREQ / SCAN_TABCONF) to
   use, taking into account limits in the transporter, user preference, etc.
@@ -161,10 +426,11 @@ NdbReceiver::prepareRead(char *buf, Uint32 rows)
   - It should stay strictly within the 'batch_size' (#rows) limit.
   - It is allowed to overallocate the 'batch_byte_size' (slightly)
     in order to complete the current row when it hit the limit.
+    (Upto ::packed_rowsize())
 
   The client should be prepared to receive, and buffer, upto 
   'batch_size' rows from each fragment.
-  ::ndbrecord_rowsize() might be usefull for calculating the
+  ::ndbrecord_bufsize() might be usefull for calculating the
   buffersize to allocate for this resultset.
 */
 //static
@@ -208,50 +474,175 @@ NdbReceiver::calculate_batch_size(Uint32 parallelism,
                        batch_byte_size);
 }
 
-void
-NdbReceiver::do_setup_ndbrecord(const NdbRecord *ndb_record, Uint32 batch_size,
-                                Uint32 key_size, Uint32 read_range_no,
-                                Uint32 rowsize, char *row_buffer)
-{
-  m_using_ndb_record= true;
-  m_record.m_ndb_record= ndb_record;
-  m_record.m_row_recv= row_buffer;
-  m_record.m_row_buffer= row_buffer;
-  m_record.m_row_offset= rowsize;
-  m_record.m_read_range_no= read_range_no;
-}
-
 //static
 Uint32
-NdbReceiver::ndbrecord_rowsize(const NdbRecord *ndb_record,
-                               const NdbRecAttr *first_rec_attr,
-                               Uint32 key_size,
+NdbReceiver::ndbrecord_rowsize(const NdbRecord *result_record,
                                bool read_range_no)
 {
-  Uint32 rowsize= (ndb_record) ? ndb_record->m_row_size : 0;
+  // Unpacked NdbRecords are stored in its full unprojected form
+  Uint32 rowsize= (result_record) 
+                 ? result_record->m_row_size
+                 : 0;
 
-  /* Room for range_no. */
+  // After unpack, the optional RANGE_NO is stored as an Uint32 
   if (read_range_no)
-    rowsize+= 4;
-  /*
-    If keyinfo, need room for max. key + 4 bytes of actual key length + 4
-    bytes of scan info (all from KEYINFO20 signal).
-  */
-  if (key_size)
-    rowsize+= 8 + key_size*4;
-  /*
-    Compute extra space needed to buffer getValue() results in NdbRecord
-    scans.
-  */
+    rowsize+= sizeof(Uint32);
+
+  return (rowsize+3) & 0xfffffffc;
+}
+
+/**
+ * Calculate max size (In Uint32 words) of a 'packed' result row,
+ * including optional 'keyinfo' and 'range_no'.
+ */
+static
+Uint32 packed_rowsize(const NdbRecord *result_record,
+                      const Uint32* read_mask,
+                      const NdbRecAttr *first_rec_attr,
+                      Uint32 keySizeWords,
+                      bool read_range_no)
+{
+  Uint32 nullCount = 0;
+  Uint32 bitPos = 0;
+  const Uint8 *pos = NULL;
+
+  if (likely(result_record != NULL))
+  {
+    for (Uint32 i= 0; i<result_record->noOfColumns; i++)
+    {
+      const NdbRecord::Attr *col= &result_record->columns[i];
+      const Uint32 attrId= col->attrId;
+
+      /* Skip column if result_mask says so and we don't need
+       * to read it 
+       */
+      if (BitmaskImpl::get(MAXNROFATTRIBUTESINWORDS, read_mask, attrId))
+      {
+        const Uint32 align = col->orgAttrSize;
+
+        switch(align){
+        case DictTabInfo::aBit:
+          pos = pad(pos, 0, 0);
+          bitPos += col->bitCount;
+          pos += 4 * (bitPos / 32);
+          bitPos = (bitPos % 32);
+          break;
+        default:
+          pos = pad(pos, align, bitPos);
+          bitPos = 0;
+          pos += col->maxSize;
+          break;
+        }
+
+        if (col->flags & NdbRecord::IsNullable)
+          nullCount++;
+      }
+    }
+  }
+  Uint32 sizeInWords = (Uint32)(((Uint32*)pad(pos, 0, bitPos) - (Uint32*)NULL));
+
+  // Add AttributeHeader::READ_PACKED or ::READ_ALL (Uint32) and
+  // variable size bitmask the 'packed' columns and their null bits.
+  if (sizeInWords > 0)
+  {
+    const Uint32 attrCount= result_record->columns[result_record->noOfColumns -1].attrId+1;
+    const Uint32 sigBitmaskWords= ((attrCount+nullCount+31)>>5);
+    sizeInWords += (1+sigBitmaskWords);   //AttrHeader + bitMask
+  }
+
+  // The optional RANGE_NO is transfered and stored in buffer
+  // as AttributeHeader::RANGE_NO + an Uint32 'range_no'
+  if (read_range_no)
+  {
+    sizeInWords += 2;
+  }
+
+  // KeyInfo is transfered in a seperate signal,
+  // and is stored in the packed buffer together with 'info' word
+  if (keySizeWords > 0)
+  {
+    sizeInWords+= keySizeWords+1;
+  }
+
+  /* Add extra needed to transfer RecAttrs requested by getValue() */
   const NdbRecAttr *ra= first_rec_attr;
   while (ra != NULL)
   {
-    rowsize+= sizeof(Uint32) + ra->getColumn()->getSizeInBytes();
+    // AttrHeader + max column size. Aligned to word boundary
+    sizeInWords+= 1 + ((ra->getColumn()->getSizeInBytes() + 3) / 4);
     ra= ra->next();
   }
-  /* Ensure 4-byte alignment. */
-  rowsize= (rowsize+3) & 0xfffffffc;
-  return rowsize;
+
+  return sizeInWords;
+}
+
+/**
+ * Calculate max size (In Uint32 words) of a buffer containing
+ * 'batch_rows' of packed result rows. Size also include 
+ * overhead required by the NdbReceiverBuffer itself.
+ */
+static
+Uint32 ndbrecord_bufsize(Uint32 batchRows,
+                         Uint32 batchBytes,      //Optional upper limit of batch size
+                         Uint32 fragments,       //Frags handled by this receiver (>= 1)
+                         Uint32 rowSizeWords,    //Packed size, from ::packed_rowsize() 
+                         Uint32 keySizeWords)    //In words
+{
+  /**
+   * Size of batch is either limited by max 'batchRows' fetched,
+   * or when the total 'batchBytes' limit is reached. In the
+   * later case we are allowed to over-allocate by allowing 
+   * each fragment delivering to this NdbReceiver to complete
+   * the current row / key. If KeyInfo is requested, an additional
+   *'info' word is also added for each key which comes in addition
+   *  to the 'batch_byte' limit
+   */
+  assert(batchRows > 0);
+  Uint32 batchSizeWords = batchRows * rowSizeWords;
+
+  // Result set size may be limited by 'batch_words' if specified.
+  if (batchBytes > 0)
+  {
+    const Uint32 batchWords = (batchBytes+3) / sizeof(Uint32);
+    // Batch size + over alloc last row + info word if keyinfo20
+    const Uint32 batchSizeLimit = batchWords
+                                + (rowSizeWords * fragments)
+                                + ((keySizeWords > 0) ? batchRows : 0);
+
+    if (batchSizeWords > batchSizeLimit)
+      batchSizeWords = batchSizeLimit;
+  }
+
+  return NdbReceiverBuffer::calculateSizeInWords(batchSizeWords, batchRows, keySizeWords);
+}
+
+//static
+Uint32
+NdbReceiver::result_bufsize(Uint32 batchRows,
+                            Uint32 batchBytes,
+                            Uint32 fragments,
+                            const NdbRecord *result_record,
+                            const Uint32* read_mask,
+                            const NdbRecAttr *first_rec_attr,
+                            Uint32 keySizeWords,
+                            bool read_range_no)
+{
+  const Uint32 rowSizeWords= packed_rowsize(
+                                       result_record,
+                                       read_mask,
+                                       first_rec_attr,
+                                       keySizeWords,
+                                       read_range_no);
+
+  const Uint32 bufSizeWords= ndbrecord_bufsize(
+                                          batchRows, 
+                                          batchBytes,
+                                          fragments,
+                                          rowSizeWords,
+                                          keySizeWords);
+
+  // bufsize is in word, return as bytes
+  return bufSizeWords * sizeof(Uint32);
 }
 
 /**
@@ -281,15 +672,16 @@ pad(const Uint8* src, Uint32 align, Uint32 bitPos)
   case DictTabInfo::a64Bit:
   case DictTabInfo::a128Bit:
     return (Uint8*)(((ptr + 3) & ~(UintPtr)3) + 4 * ((bitPos + 31) >> 5));
-charpad:
-  case DictTabInfo::an8Bit:
-  case DictTabInfo::a16Bit:
-    return src + 4 * ((bitPos + 31) >> 5);
+
   default:
 #ifdef VM_TRACE
     abort();
 #endif
-    goto charpad;
+    //Fall through:
+
+  case DictTabInfo::an8Bit:
+  case DictTabInfo::a16Bit:
+    return src + 4 * ((bitPos + 31) >> 5);
   }
 }
 
@@ -316,16 +708,17 @@ handle_packed_bit(const char* _src, Uint32 pos, Uint32 len, char* _dst)
 
 
 /**
- * receive_packed_recattr
- * Receive a packed stream of field values, whose presence and nullness
+ * unpackRecAttr
+ * Unpack a packed stream of field values, whose presence and nullness
  * is indicated by a leading bitmap into a list of NdbRecAttr objects
  * Return the number of words read from the input stream.
  */
+//static
 Uint32
-NdbReceiver::receive_packed_recattr(NdbRecAttr** recAttr, 
-                                    Uint32 bmlen, 
-                                    const Uint32* aDataPtr, 
-                                    Uint32 aLength)
+NdbReceiver::unpackRecAttr(NdbRecAttr** recAttr, 
+                           Uint32 bmlen, 
+                           const Uint32* aDataPtr, 
+                           Uint32 aLength)
 {
   NdbRecAttr* currRecAttr = *recAttr;
   const Uint8 *src = (Uint8*)(aDataPtr + bmlen);
@@ -418,17 +811,16 @@ static void setRecToNULL(const NdbRecord::Attr *col,
 int
 NdbReceiver::get_range_no() const
 {
-  int range_no;
-  assert(m_using_ndb_record);
-  Uint32 idx= m_current_row;
-  if (idx == 0 || !m_record.m_read_range_no)
+  Uint32 range_no;
+  assert(m_ndb_record != NULL);
+
+  if (unlikely(!m_read_range_no))
     return -1;
+
   memcpy(&range_no,
-         m_record.m_row_buffer +
-           (idx-1)*m_record.m_row_offset +
-           m_record.m_ndb_record->m_row_size,
-         4);
-  return range_no;
+         m_row_buffer + m_ndb_record->m_row_size,
+         sizeof(range_no));
+  return (int)range_no;
 }
 
 /**
@@ -480,19 +872,20 @@ handle_bitfield_ndbrecord(const NdbRecord::Attr* col,
 
 
 /**
- * receive_packed_ndbrecord
- * Receive a packed stream of field values, whose presence and nullness
+ * unpackNdbRecord
+ * Unpack a stream of field values, whose presence and nullness
  * is indicated by a leading bitmap, into an NdbRecord row.
- * Return the number of words consumed from the input stream.
+ * Return the number of words consumed.
  */
+//static
 Uint32
-NdbReceiver::receive_packed_ndbrecord(Uint32 bmlen, 
-                                      const Uint32* aDataPtr,
-                                      char* row)
+NdbReceiver::unpackNdbRecord(const NdbRecord *rec,
+                             Uint32 bmlen, 
+                             const Uint32* aDataPtr,
+                             char* row)
 {
   const Uint8 *src = (Uint8*)(aDataPtr + bmlen);
   Uint32 bitPos = 0;
-  const NdbRecord* rec= m_record.m_ndb_record;
   const Uint32 maxAttrId= rec->columns[rec->noOfColumns -1].attrId;
   const Uint32 bmSize= bmlen << 5;
 
@@ -520,7 +913,7 @@ NdbReceiver::receive_packed_ndbrecord(Uint32 bmlen,
       {
 	if (BitmaskImpl::get(bmlen, aDataPtr, ++i))
 	{
-          setRecToNULL(col, m_record.m_row_recv);
+          setRecToNULL(col, row);
 
           // Next column...
 	  continue;
@@ -575,56 +968,56 @@ NdbReceiver::receive_packed_ndbrecord(Uint32 bmlen,
   return (Uint32)(((Uint32*)pad(src, 0, bitPos)) - aDataPtr);
 }
 
-
 int
 NdbReceiver::get_keyinfo20(Uint32 & scaninfo, Uint32 & length,
                            const char * & data_ptr) const
 {
-  assert(m_using_ndb_record);
-  Uint32 idx= m_current_row;
-  if (idx == 0)
-    return -1;                                  // No rows fetched yet
-  const char *p= m_record.m_row_buffer +
-    (idx-1)*m_record.m_row_offset +
-    m_record.m_ndb_record->m_row_size;
-  if (m_record.m_read_range_no)
-    p+= 4;
-  scaninfo= uint4korr(p);
-  p+= 4;
-  length= uint4korr(p);
-  p+= 4;
-  data_ptr= p;
+  if (unlikely(!m_read_key_info))
+    return -1;
+
+  Uint32 len;
+  const Uint32 *p = m_recv_buffer->getKey(m_current_row, len);
+  if (unlikely(p == NULL))
+    return -1;
+
+  scaninfo = *p;
+  data_ptr = reinterpret_cast<const char*>(p+1);
+  length = len-1;
   return 0;
 }
 
-
-int
-NdbReceiver::getScanAttrData(const char * & data, Uint32 & size, Uint32 & pos) const
+const char* 
+NdbReceiver::unpackBuffer(const NdbReceiverBuffer *buffer, Uint32 row)
 {
-  assert(m_using_ndb_record);
-  Uint32 idx= m_current_row;
-  if (idx == 0)
-    return -1;                                  // No rows fetched yet
-  const char *row_end= m_record.m_row_buffer + idx*m_record.m_row_offset;
+  assert(buffer != NULL);
 
-  pos+= sizeof(Uint32);
-  memcpy(&size, row_end - pos, sizeof(Uint32));
-  pos+= size;
-  data= row_end - pos;
+  Uint32 aLength;
+  const Uint32 *aDataPtr = buffer->getRow(row, aLength);
+  if (likely(aDataPtr != NULL))
+  {
+    if (unpackRow(aDataPtr, aLength, m_row_buffer) == -1)
+      return NULL;
 
-  assert (pos <= m_record.m_row_offset);
-  return 0;
+    return m_row_buffer;
+  }
+
+  /* ReceiveBuffer may containt only keyinfo */
+  const Uint32 *key = buffer->getKey(row, aLength);
+  if (key != NULL)
+  {
+    assert(m_row_buffer != NULL);
+    return m_row_buffer; // Row is empty, used as non-NULL return
+  }
+  return NULL;
 }
 
-int
-NdbReceiver::execTRANSID_AI(const Uint32* aDataPtr, Uint32 aLength)
+int 
+NdbReceiver::unpackRow(const Uint32* aDataPtr, Uint32 aLength, char* row)
 {
   /*
    * NdbRecord and NdbRecAttr row result handling are merged here
    *   First any NdbRecord attributes are extracted
    *   Then any NdbRecAttr attributes are extracted
-   *   NdbRecord scans with extra NdbRecAttr getValue() attrs
-   *   are handled separately in the NdbRecord code
    * Scenarios : 
    *   NdbRecord only PK read result
    *   NdbRecAttr only PK read result
@@ -633,116 +1026,124 @@ NdbReceiver::execTRANSID_AI(const Uint32* aDataPtr, Uint32 aLength)
    *   NdbRecAttr only scan read result
    *   Mixed scan read results
    */
-  Uint32 exp= m_expected_result_length;
-  Uint32 tmp= m_received_result_length + aLength;
-  Uint32 origLength=aLength;
-  NdbRecAttr* currRecAttr = theCurrentRecAttr;
-  Uint32 save_pos= 0;
-
-  bool ndbrecord_part_done= !m_using_ndb_record;
-  const bool isScan= (m_type == NDB_SCANRECEIVER) ||
-    (m_type == NDB_QUERY_OPERATION);
-
-  /* Read words from the incoming signal train.
-   * The length passed in is enough for one row, either as an individual
-   * read op, or part of a scan.  When there are no more words, we're at
-   * the end of the row
-   */
-  while (aLength > 0)
-  {
-    AttributeHeader ah(* aDataPtr++);
-    const Uint32 attrId= ah.getAttributeId();
-    Uint32 attrSize= ah.getByteSize();
-    aLength--;
 
-    if (!ndbrecord_part_done)
+  /* If present, NdbRecord data will come first */
+  if (m_ndb_record != NULL)
+  {
+    /* Read words from the incoming signal train.
+     * The length passed in is enough for one row, either as an individual
+     * read op, or part of a scan.  When there are no more words, we're at
+     * the end of the row
+     */
+    while (aLength > 0)
     {
-      /* Special case for RANGE_NO, which is received first and is
-       * stored just after the row. */
-      if (attrId == AttributeHeader::RANGE_NO)
-      {
-        assert(m_record.m_read_range_no);
-        assert(attrSize==4);
-        assert (m_record.m_row_offset >= m_record.m_ndb_record->m_row_size+attrSize);
-        memcpy(m_record.m_row_recv+m_record.m_ndb_record->m_row_size, 
-               aDataPtr++, 4);
-        aLength--;
-        continue; // Next
-      }
+      const AttributeHeader ah(* aDataPtr++);
+      const Uint32 attrId= ah.getAttributeId();
+      const Uint32 attrSize= ah.getByteSize();
+      aLength--;
+      assert(aLength >= (attrSize/sizeof(Uint32)));
 
       /* Normal case for all NdbRecord primary key, index key, table scan
        * and index scan reads.  Extract all requested columns from packed
        * format into the row.
        */
-      if (attrId == AttributeHeader::READ_PACKED)
+      if (likely(attrId == AttributeHeader::READ_PACKED))
       {
-        assert (m_record.m_row_offset >= m_record.m_ndb_record->m_row_size);
-        Uint32 len= receive_packed_ndbrecord(attrSize >> 2, // Bitmap length
-                                             aDataPtr,
-                                             m_record.m_row_recv);
+        const Uint32 len= unpackNdbRecord(m_ndb_record,
+                                          attrSize >> 2, // Bitmap length
+                                          aDataPtr,
+                                          row);
+        assert(aLength >= len);
         aDataPtr+= len;
         aLength-= len;
-        continue;  // Next
       }
 
-      /* If we get here then we must have 'extra getValues' - columns
-       * requested outwith the normal NdbRecord + bitmask mechanism.
-       * This could be : pseudo columns, columns read via an old-Api 
-       * scan, or just some extra columns added by the user to an 
-       * NdbRecord operation.
-       * If the extra values are part of a scan then they get copied
-       * to a special area after the end of the normal row data.  
-       * When the user calls NdbScanOperation.nextResult() they will
-       * be copied into the correct NdbRecAttr objects.
-       * If the extra values are not part of a scan then they are
-       * put into their NdbRecAttr objects now.
-       */
-      if (isScan)
+      /* Special case for RANGE_NO, which is received first and is
+       * stored just after the row. */
+      else if (attrId == AttributeHeader::RANGE_NO)
       {
-        /* For scans, we save the extra information at the end of the
-         * row buffer, in reverse order.  When nextResult() is called,
-         * this data is copied into the correct NdbRecAttr objects.
-         */
-        
-        /* Save this extra getValue */
-        save_pos+= sizeof(Uint32);
-        memcpy(m_record.m_row_recv + m_record.m_row_offset - save_pos,
-               &attrSize, sizeof(Uint32));
-        if (attrSize > 0)
-        {
-          save_pos+= attrSize;
-          assert (save_pos<=m_record.m_row_offset);
-          memcpy(m_record.m_row_recv + m_record.m_row_offset - save_pos,
-                 aDataPtr, attrSize);
-        }
-
-        Uint32 sizeInWords= (attrSize+3)>>2;
-        aDataPtr+= sizeInWords;
-        aLength-= sizeInWords;
-        continue; // Next
+        assert(m_read_range_no);
+        assert(attrSize==sizeof(Uint32));
+        memcpy(row+m_ndb_record->m_row_size, aDataPtr++, sizeof(Uint32));
+        aLength--;
       }
+
       else
       {
-        /* Not a scan, so extra information is added to RecAttrs in
-         * the 'normal' way.
+        /* If we get here then we must have 'extra getValues' - columns
+         * requested outwith the normal NdbRecord + bitmask mechanism.
+         * This could be : pseudo columns, columns read via an old-Api 
+         * scan, or just some extra columns added by the user to an 
+         * NdbRecord operation.
          */
-        assert(theCurrentRecAttr != NULL);
-        assert(theCurrentRecAttr->attrId() == attrId);
-        /* Handle extra attributes requested with getValue(). */
-        /* This implies that we've finished with the NdbRecord part
-           of the read, so move onto NdbRecAttr */
-        ndbrecord_part_done=true;
-        // Fall through to RecAttr handling
+        aDataPtr--;   // Undo read of AttributeHeader
+        aLength++;
+        break;
       }
-    } // / if (!ndbrecord_part_done)
-    
-    /* If we get here then there are some attribute values to be
+    } // while (aLength > 0)
+  } // if (m_ndb_record != NULL)
+
+  /* Handle 'getValues', possible requested after NdbRecord columns. */
+  if (aLength > 0)
+  {
+    /**
+     * If we get here then there are some attribute values to be
      * read into the attached list of NdbRecAttrs.
      * This occurs for old-Api primary and unique index keyed operations
      * and for NdbRecord primary and unique index keyed operations
      * using 'extra GetValues'.
+     *
+     * If the values are part of a scan then we save
+     * the starting point of these RecAttr values.
+     * When the user calls NdbScanOperation.nextResult(), they will
+     * be copied into the correct NdbRecAttr objects by calling
+     * NdbRecord::get_AttrValues.
+     * If the extra values are not part of a scan, then they are
+     * put into their NdbRecAttr objects now.
      */
-    if (ndbrecord_part_done)
+    const bool isScan= (m_type == NDB_SCANRECEIVER) ||
+                       (m_type == NDB_QUERY_OPERATION);
+
+    if (isScan)
+    {
+      /* Save position for RecAttr values for later retrieval. */
+      m_rec_attr_data = aDataPtr;
+      m_rec_attr_len = aLength;
+      return 0;
+    }
+    else
+    {
+      /* Put values into RecAttr now */ 
+      const int ret = handle_rec_attrs(m_firstRecAttr, aDataPtr, aLength);
+      if (unlikely(ret != 0))
+        return -1;
+
+      aDataPtr += aLength;
+      aLength  = 0;
+    }
+  } // if (aLength > 0)
+
+  m_rec_attr_data = NULL;
+  m_rec_attr_len = 0;
+  return 0;
+}
+
+//static
+int
+NdbReceiver::handle_rec_attrs(NdbRecAttr* rec_attr_list,
+                              const Uint32* aDataPtr,
+                              Uint32 aLength)
+{
+  NdbRecAttr* currRecAttr = rec_attr_list;
+
+  while (aLength > 0)
+  {
+    const AttributeHeader ah(* aDataPtr++);
+    const Uint32 attrId= ah.getAttributeId();
+    const Uint32 attrSize= ah.getByteSize();
+    aLength--;
+    assert(aLength >= (attrSize/sizeof(Uint32)));
+
     {
       // We've processed the NdbRecord part of the TRANSID_AI, if
       // any.  There are signal words left, so they must be
@@ -750,23 +1151,17 @@ NdbReceiver::execTRANSID_AI(const Uint32* aDataPtr, Uint32 aLength)
       //
       if (attrId == AttributeHeader::READ_PACKED)
       {
-        assert(!m_using_ndb_record);
-        NdbRecAttr* tmp = currRecAttr;
-        Uint32 len = receive_packed_recattr(&tmp, attrSize>>2, aDataPtr, origLength);
+        const Uint32 len = unpackRecAttr(&currRecAttr, 
+                                         attrSize>>2, aDataPtr, aLength);
+        assert(aLength >= len);
         aDataPtr += len;
         aLength -= len;
-        currRecAttr = tmp;
         continue;
       }
-      /**
-       * Skip over missing attributes
-       * TODO : How can this happen?
-       */
-      while(currRecAttr && currRecAttr->attrId() != attrId){
-            currRecAttr = currRecAttr->next();
-      }
 
-      if(currRecAttr && currRecAttr->receive_data(aDataPtr, attrSize))
+      if(currRecAttr && 
+         currRecAttr->attrId() == attrId &&
+         currRecAttr->receive_data(aDataPtr, attrSize))
       {
         Uint32 add= (attrSize + 3) >> 2;
         aLength -= add;
@@ -779,11 +1174,11 @@ NdbReceiver::execTRANSID_AI(const Uint32* aDataPtr, Uint32 aLength)
           back attributes in the wrong order).
           So dump some info for debugging, and abort.
         */
-        ndbout_c("this=%p: attrId: %d currRecAttr: %p theCurrentRecAttr: %p "
-                 "attrSize: %d %d", this,
-	         attrId, currRecAttr, theCurrentRecAttr, attrSize,
+        ndbout_c("NdbReceiver::handle_rec_attrs: attrId: %d currRecAttr: %p rec_attr_list: %p "
+                 "attrSize: %d %d",
+	         attrId, currRecAttr, rec_attr_list, attrSize,
                  currRecAttr ? currRecAttr->get_size_in_bytes() : 0);
-        currRecAttr = theCurrentRecAttr;
+        currRecAttr = rec_attr_list;
         while(currRecAttr != 0){
 	  ndbout_c("%d ", currRecAttr->attrId());
 	  currRecAttr = currRecAttr->next();
@@ -791,70 +1186,110 @@ NdbReceiver::execTRANSID_AI(const Uint32* aDataPtr, Uint32 aLength)
         abort();
         return -1;
       } // if (currRecAttr...)      
-    } // /if (ndbrecord_part_done)
-  } // / while (aLength > 0)
+    }
+  } // while (aLength > 0)
 
-  theCurrentRecAttr = currRecAttr;
+  return 0;
+}
 
-  m_received_result_length = tmp;
+int
+NdbReceiver::get_AttrValues(NdbRecAttr* rec_attr_list) const
+{
+  return handle_rec_attrs(rec_attr_list, 
+                          m_rec_attr_data,
+                          m_rec_attr_len);
+}
 
-  if (m_using_ndb_record) {
-    /* Move onto next row in scan buffer */
-    m_record.m_row_recv+= m_record.m_row_offset;
+int
+NdbReceiver::execTRANSID_AI(const Uint32* aDataPtr, Uint32 aLength)
+{
+  const Uint32 exp= m_expected_result_length;
+  const Uint32 tmp= m_received_result_length + aLength;
+
+  /*
+   * Store received data unprocessed into receive buffer
+   * in its packed format.
+   * It is unpacked into NdbRecord format when
+   * we navigate to each row.
+   */
+  if (m_recv_buffer != NULL)
+  {
+    Uint32 *row_recv = m_recv_buffer->allocRow(aLength);
+    memcpy(row_recv, aDataPtr, aLength*sizeof(Uint32));
   }
+  else
+  {
+    if (unpackRow(aDataPtr, aLength, m_row_buffer) == -1)
+      return -1;
+  }
+  m_received_result_length = tmp;
   return (tmp == exp || (exp > TcKeyConf::DirtyReadBit) ? 1 : 0);
 }
 
 int
 NdbReceiver::execKEYINFO20(Uint32 info, const Uint32* aDataPtr, Uint32 aLength)
 {
-  if (m_using_ndb_record)
-  {
-    /* Copy in the keyinfo after the user row and any range_no value. */
-
-    char *keyinfo_ptr= m_record.m_row_buffer + 
-                       m_current_row++ * m_record.m_row_offset +
-                       m_record.m_ndb_record->m_row_size;
-    if (m_record.m_read_range_no)
-      keyinfo_ptr+= 4;
-
-    int4store(keyinfo_ptr, info);
-    keyinfo_ptr+= 4;
-    int4store(keyinfo_ptr, aLength);
-    keyinfo_ptr+= 4;
-    memcpy(keyinfo_ptr, aDataPtr, 4*aLength);
-
-    Uint32 tmp= m_received_result_length + aLength;
-    m_received_result_length = tmp;
-  
-    return (tmp == m_expected_result_length ? 1 : 0);
-  }
+  assert(m_read_key_info);
+  assert(m_recv_buffer != NULL);
 
-  /* The old method, using NdbRecAttr. */
-  NdbRecAttr* currRecAttr = m_rows[m_current_row++];
-  assert(currRecAttr->attrId() == KEY_ATTR_ID);
-  /*
-    This is actually reading data one word off the end of the received
-    signal (or off the end of the long signal data section 0, for a
-    long signal), due to the aLength+1. This is to ensure the correct length
-    being set for the NdbRecAttr (one extra word for the scanInfo word placed
-    at the end), overwritten immediately below.
-    But it's a bit ugly that we rely on being able to read one word over the
-    end of the signal without crashing...
-  */
-  currRecAttr->receive_data(aDataPtr, 4*(aLength + 1));
-  
-  /**
-   * Save scanInfo in the end of keyinfo
-   */
-  ((Uint32*)currRecAttr->aRef())[aLength] = info;
-  
-  Uint32 tmp = m_received_result_length + aLength;
+  Uint32 *keyinfo_ptr = m_recv_buffer->allocKey(aLength+1);
+
+  // Copy in key 'info', followed by 'data'
+  *keyinfo_ptr= info;
+  memcpy(keyinfo_ptr+1, aDataPtr, 4*aLength);
+
+  const Uint32 tmp= m_received_result_length + aLength;
   m_received_result_length = tmp;
-  
+
   return (tmp == m_expected_result_length ? 1 : 0);
 }
 
+const char*
+NdbReceiver::getRow(const NdbReceiverBuffer* buffer, Uint32 row)
+{
+  return unpackBuffer(buffer, row);
+}
+
+const char* 
+NdbReceiver::getNextRow()
+{
+  assert(m_recv_buffer != NULL);
+  const Uint32 nextRow =  m_current_row+1;
+  const char *row = unpackBuffer(m_recv_buffer, nextRow);
+  if (likely(row != NULL))
+  {
+    m_current_row = nextRow;
+  }
+  return row;
+}
+
+int
+NdbReceiver::execSCANOPCONF(Uint32 tcPtrI, Uint32 len, Uint32 rows)
+{
+  assert(m_recv_buffer != NULL);
+  assert(m_recv_buffer->getMaxRows() >= rows);
+  assert(m_recv_buffer->getBufSizeWords() >= len);
+
+  m_tcPtrI = tcPtrI;
+
+  if (unlikely(len == 0))
+  {
+    /**
+     * No TRANSID_AI will be received. (Likely an empty projection requested.)
+     * To get row count correct, we simulate specified number of 
+     * empty TRANSID_AIs being received.
+     */
+    for (Uint32 row=0; row<rows; row++)
+    {
+      execTRANSID_AI(NULL,0);
+    }
+  }
+
+  const Uint32 tmp = m_received_result_length;
+  m_expected_result_length = len;
+  return (tmp == len ? 1 : 0);
+}
+
 void
 NdbReceiver::setErrorCode(int code)
 {
diff --git a/storage/ndb/src/ndbapi/NdbScanOperation.cpp b/storage/ndb/src/ndbapi/NdbScanOperation.cpp
index 9b1f91a9980..d4c3d5a6f28 100644
--- a/storage/ndb/src/ndbapi/NdbScanOperation.cpp
+++ b/storage/ndb/src/ndbapi/NdbScanOperation.cpp
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -87,7 +87,7 @@ NdbScanOperation::init(const NdbTableImpl* tab, NdbTransaction* myConnection)
 {
   m_transConnection = myConnection;
 
-  if (NdbOperation::init(tab, myConnection, false) != 0)
+  if (NdbOperation::init(tab, myConnection) != 0)
     return -1;
 
   theNdb->theRemainingStartTransactions++; // will be checked in hupp...
@@ -130,7 +130,7 @@ NdbScanOperation::handleScanGetValuesOldApi()
   /* Handle old API-defined scan getValue(s) */
   assert(m_scanUsingOldApi);
 
-  if (theReceiver.theFirstRecAttr != NULL) 
+  if (theReceiver.m_firstRecAttr != NULL) 
   {
     /* theReceiver has a list of RecAttrs which the user
      * wants to read.  Traverse it, adding signals to the
@@ -140,7 +140,7 @@ NdbScanOperation::handleScanGetValuesOldApi()
      * Once these are added to the signal train, all other handling
      * is exactly the same as for normal NdbRecord 'extra GetValues'
      */
-    const NdbRecAttr* recAttrToRead = theReceiver.theFirstRecAttr;
+    const NdbRecAttr* recAttrToRead = theReceiver.m_firstRecAttr;
 
     while(recAttrToRead != NULL)
     {
@@ -152,7 +152,6 @@ NdbScanOperation::handleScanGetValuesOldApi()
     }
  
     theInitialReadSize= theTotalCurrAI_Len - AttrInfo::SectionSizeInfoLength;
-
   }
 
   return 0;
@@ -482,7 +481,8 @@ NdbScanOperation::scanImpl(const NdbScanOperation::ScanOptions *options,
    * signals.
    */
   if (prepareSendScan(theNdbCon->theTCConPtr, 
-                      theNdbCon->theTransactionId) == -1)
+                      theNdbCon->theTransactionId,
+                      readMask) == -1)
     /* Error code should be set */
     return -1;
   
@@ -1586,7 +1586,7 @@ NdbScanOperation::fix_receivers(Uint32 parallel){
         return -1;
       }//if
       m_receivers[i] = tScanRec;
-      tScanRec->init(NdbReceiver::NDB_SCANRECEIVER, false, this);
+      tScanRec->init(NdbReceiver::NDB_SCANRECEIVER, this);
     }
     m_allocated_receivers = parallel;
   }
@@ -1616,7 +1616,6 @@ NdbScanOperation::receiver_delivered(NdbReceiver* tRec){
     last = m_conf_receivers_count;
     m_conf_receivers[last] = tRec;
     m_conf_receivers_count = last + 1;
-    tRec->m_current_row = 0;
   }
 }
 
@@ -1766,7 +1765,6 @@ NdbScanOperation::nextResult(bool fetchAllowed, bool forceSend)
     setErrorCode(4284);
     return -1;
   }
-    
 
   return nextResult(&dummyOutRowPtr,
                     fetchAllowed,
@@ -1780,27 +1778,21 @@ NdbScanOperation::nextResult(const char ** out_row_ptr,
 {
   int res;
 
-  if ((res = nextResultNdbRecord(*out_row_ptr, fetchAllowed, forceSend)) == 0) {
+  if ((res = nextResultNdbRecord(*out_row_ptr, fetchAllowed, forceSend)) == 0)
+  {
     NdbBlob* tBlob= theBlobList;
-    NdbRecAttr *getvalue_recattr= theReceiver.theFirstRecAttr;
+    NdbRecAttr *getvalue_recattr= theReceiver.m_firstRecAttr;
     if (((UintPtr)tBlob | (UintPtr)getvalue_recattr) != 0)
     {
       const Uint32 idx= m_current_api_receiver;
       assert(idx < m_api_receivers_count);
       const NdbReceiver *receiver= m_api_receivers[idx];
-      Uint32 pos= 0;
 
       /* First take care of any getValue(). */
-      while (getvalue_recattr != NULL)
+      if (getvalue_recattr != NULL)
       {
-        const char *attr_data;
-        Uint32 attr_size;
-        if (receiver->getScanAttrData(attr_data, attr_size, pos) == -1)
+        if (receiver->get_AttrValues(getvalue_recattr) == -1)
           return -1;
-        if (!getvalue_recattr->receive_data((const Uint32 *)attr_data,
-                                            attr_size))
-          return -1;                            // purecov: deadcode
-        getvalue_recattr= getvalue_recattr->next();
       }
 
       /* Handle blobs. */
@@ -1847,16 +1839,18 @@ NdbScanOperation::nextResultNdbRecord(const char * & out_row,
                                       bool fetchAllowed, bool forceSend)
 {
   if (m_ordered)
+  {
     return ((NdbIndexScanOperation*)this)->next_result_ordered_ndbrecord
       (out_row, fetchAllowed, forceSend);
+  }
 
   /* Return a row immediately if any is available. */
   while (m_current_api_receiver < m_api_receivers_count)
   {
     NdbReceiver *tRec= m_api_receivers[m_current_api_receiver];
-    if (tRec->nextResult())
+    out_row = tRec->getNextRow();
+    if (out_row != NULL)
     {
-      out_row= tRec->get_row();
       return 0;
     }
     m_current_api_receiver++;
@@ -1953,9 +1947,8 @@ NdbScanOperation::nextResultNdbRecord(const char * & out_row,
       while (idx < last)
       {
         NdbReceiver* tRec= m_api_receivers[idx];
-        if (tRec->nextResult())
+        if ((out_row = tRec->getNextRow()) != NULL)
         {
-          out_row= tRec->get_row();
           retVal= 0;
           break;
         }
@@ -2284,7 +2277,8 @@ int NdbScanOperation::finaliseScanOldApi()
 
 /***************************************************************************
 int prepareSendScan(Uint32 aTC_ConnectPtr,
-                    Uint64 aTransactionId)
+                    Uint64 aTransactionId,
+                    const Uint32 * readMask)
 
 Return Value:   Return 0 : preparation of send was succesful.
                 Return -1: In all other case.   
@@ -2294,7 +2288,9 @@ Remark:         Puts the the final data into ATTRINFO signal(s)  after this
                 we know the how many signal to send and their sizes
 ***************************************************************************/
 int NdbScanOperation::prepareSendScan(Uint32 aTC_ConnectPtr,
-                                      Uint64 aTransactionId){
+                                      Uint64 aTransactionId,
+                                      const Uint32 * readMask)
+{
   if (theInterpretIndicator != 1 ||
       (theOperationType != OpenScanRequest &&
        theOperationType != OpenRangeScanRequest)) {
@@ -2346,13 +2342,36 @@ int NdbScanOperation::prepareSendScan(Uint32 aTC_ConnectPtr,
   /* All scans use NdbRecord internally */
   assert(theStatus == UseNdbRecord);
   
-  assert(theParallelism > 0);
-  Uint32 rowsize= NdbReceiver::ndbrecord_rowsize(m_attribute_record,
-                                                 theReceiver.theFirstRecAttr,
-                                                 key_size,
+
+  /**
+   * Calculate memory req. for the NdbReceiverBuffer and its row buffer:
+   *
+   * Scan results are stored into a buffer in a 'packed' format
+   * by the NdbReceiver. When each row is fetched (made 'current'),
+   * NdbReceiver unpack it into a row buffer as specified by the
+   * NdbRecord argument (and RecAttrs are put into their destination)
+   */
+  Uint32 bufsize= NdbReceiver::result_bufsize(batch_size,
+                                              batch_byte_size,
+                                              1,
+                                              m_attribute_record,
+                                              readMask,
+                                              theReceiver.m_firstRecAttr,
+                                              key_size,
+                                              m_read_range_no);
+  assert((bufsize % sizeof(Uint32)) == 0); //Size returned as Uint32 aligned
+
+  /* Calculate row buffer size, align it for (hopefully) improved memory access.  */
+  Uint32 full_rowsize= NdbReceiver::ndbrecord_rowsize(m_attribute_record,
                                                  m_read_range_no);
-  Uint32 bufsize= batch_size*rowsize;
-  char *buf= new char[bufsize*theParallelism];
+
+  /**
+   * Alloc total buffers for all fragments in one big chunk. 
+   * Alloced as Uint32 to fullfil alignment req for NdbReceiveBuffers.
+   */
+  assert(theParallelism > 0);
+  const Uint32 alloc_size = ((full_rowsize+bufsize)*theParallelism) / sizeof(Uint32);
+  Uint32 *buf= new Uint32[alloc_size];
   if (!buf)
   {
     setErrorCodeAbort(4000); // "Memory allocation error"
@@ -2363,10 +2382,17 @@ int NdbScanOperation::prepareSendScan(Uint32 aTC_ConnectPtr,
   
   for (Uint32 i = 0; i<theParallelism; i++)
   {
-    m_receivers[i]->do_setup_ndbrecord(m_attribute_record, batch_size,
-                                       key_size, m_read_range_no,
-                                       rowsize, buf);
-    buf+= bufsize;
+    m_receivers[i]->do_setup_ndbrecord(m_attribute_record, 
+                                       reinterpret_cast<char*>(buf),
+                                       m_read_range_no, (key_size > 0));
+    buf+= full_rowsize/sizeof(Uint32);
+
+    NdbReceiverBuffer* recbuf =
+    NdbReceiver::initReceiveBuffer(buf,
+                                   bufsize, batch_size);
+
+    m_receivers[i]->prepareReceive(recbuf);
+    buf+= bufsize/sizeof(Uint32);
   }
 
   /* Update ATTRINFO section sizes info */
@@ -2750,7 +2776,7 @@ NdbScanOperation::takeOverScanOpNdbRecord(OperationType opType,
     return NULL;
   }
 
-  NdbOperation *op= pTrans->getNdbOperation(record->table, NULL, true);
+  NdbOperation *op= pTrans->getNdbOperation(record->table, NULL);
   if (!op)
     return NULL;
 
@@ -3584,15 +3610,15 @@ int compare_ndbrecord(const NdbReceiver *r1,
 
   assert(jdir == 1 || jdir == -1);
 
-  const char *a_row= r1->peek_row();
-  const char *b_row= r2->peek_row();
+  const char *a_row= r1->getCurrentRow();
+  const char *b_row= r2->getCurrentRow();
 
   /* First compare range_no if needed. */
   if (read_range_no)
   {
-    Uint32 a_range_no= uint4korr(a_row+result_record->m_row_size);
-    Uint32 b_range_no= uint4korr(b_row+result_record->m_row_size);
-   if (a_range_no != b_range_no)
+    const Uint32 a_range_no= r1->get_range_no();
+    const Uint32 b_range_no= r2->get_range_no();
+    if (a_range_no != b_range_no)
       return (a_range_no < b_range_no ? -1 : 1);
   }
 
@@ -3662,7 +3688,7 @@ NdbIndexScanOperation::next_result_ordered_ndbrecord(const char * & out_row,
     initial call, where we need to wait for and sort all receviers.
   */
   if (m_current_api_receiver==theParallelism ||
-      !m_api_receivers[m_current_api_receiver]->nextResult())
+      !m_api_receivers[m_current_api_receiver]->getNextRow())
   {
     if (!fetchAllowed)
       return 2;                                 // No more data available now
@@ -3678,7 +3704,11 @@ NdbIndexScanOperation::next_result_ordered_ndbrecord(const char * & out_row,
     */
     current= m_current_api_receiver;
     for (int i= 0; i < count; i++)
+    {
+      const char *nextRow = m_conf_receivers[i]->getNextRow();  // Fetch first
+      assert(nextRow != NULL);  ((void)nextRow);
       ordered_insert_receiver(current--, m_conf_receivers[i]);
+    }
     m_current_api_receiver= current;
     theNdb->theImpl->incClientStat(Ndb::ScanBatchCount, count);
   }
@@ -3693,9 +3723,9 @@ NdbIndexScanOperation::next_result_ordered_ndbrecord(const char * & out_row,
   }
 
   /* Now just return the next row (if any). */
-  if (current < theParallelism && m_api_receivers[current]->nextResult())
+  if (current < theParallelism && 
+      (out_row= m_api_receivers[current]->getCurrentRow()) != NULL)
   {
-    out_row=  m_api_receivers[current]->get_row();
     return 0;
   }
   else
diff --git a/storage/ndb/src/ndbapi/NdbTransaction.cpp b/storage/ndb/src/ndbapi/NdbTransaction.cpp
index 49cc6d81354..e9c07b8db20 100644
--- a/storage/ndb/src/ndbapi/NdbTransaction.cpp
+++ b/storage/ndb/src/ndbapi/NdbTransaction.cpp
@@ -1,5 +1,5 @@
-/* Copyright (c) 2003-2007 MySQL AB
-
+/*
+   Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1475,8 +1475,7 @@ Remark:         Get an operation from NdbOperation object idlelist and
 *****************************************************************************/
 NdbOperation*
 NdbTransaction::getNdbOperation(const NdbTableImpl * tab,
-                                NdbOperation* aNextOp,
-                                bool useRec)
+                                NdbOperation* aNextOp)
 { 
   NdbOperation* tOp;
 
@@ -1510,7 +1509,7 @@ NdbTransaction::getNdbOperation(const NdbTableImpl * tab,
     }
     tOp->next(aNextOp);
   }
-  if (tOp->init(tab, this, useRec) != -1) {
+  if (tOp->init(tab, this) != -1) {
     return tOp;
   } else {
     theNdb->releaseOperation(tOp);
@@ -1784,8 +1783,7 @@ Remark:         Get an operation from NdbIndexOperation object idlelist and get
 NdbIndexOperation*
 NdbTransaction::getNdbIndexOperation(const NdbIndexImpl * anIndex, 
                                      const NdbTableImpl * aTable,
-                                     NdbOperation* aNextOp,
-                                     bool useRec)
+                                     NdbOperation* aNextOp)
 { 
   NdbIndexOperation* tOp;
   
@@ -1814,7 +1812,7 @@ NdbTransaction::getNdbIndexOperation(const NdbIndexImpl * anIndex,
     }
     tOp->next(aNextOp);
   }
-  if (tOp->indxInit(anIndex, aTable, this, useRec)!= -1) {
+  if (tOp->indxInit(anIndex, aTable, this)!= -1) {
     return tOp;
   } else {
     theNdb->releaseOperation(tOp);
@@ -2481,7 +2479,7 @@ NdbTransaction::setupRecordOp(NdbOperation::OperationType type,
   if (key_record->flags & NdbRecord::RecIsIndex)
   {
     op= getNdbIndexOperation(key_record->table->m_index,
-                             attribute_record->table, NULL, true);
+                             attribute_record->table, NULL);
   }
   else
   {
@@ -2490,7 +2488,7 @@ NdbTransaction::setupRecordOp(NdbOperation::OperationType type,
       setOperationErrorCodeAbort(4287);
       return NULL;
     }
-    op= getNdbOperation(attribute_record->table, NULL, true);
+    op= getNdbOperation(attribute_record->table, NULL);
   }
   if(!op)
     return NULL;

