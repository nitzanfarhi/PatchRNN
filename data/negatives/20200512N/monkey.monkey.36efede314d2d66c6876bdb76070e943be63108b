commit 36efede314d2d66c6876bdb76070e943be63108b
Author: Eduardo Silva <eduardo@monkey.io>
Date:   Thu Dec 25 22:53:28 2014 -0600

    Core: Plugin: new draft of plugin mechanism (wip)
    
    This patch adds a new mechanism to load plugins, at the moment it only
    do some partial replacements over the Liana plugin adding a new structure
    to define callbacks for certain I/O network operations.
    
    note: work in process.
    
    Signed-off-by: Eduardo Silva <eduardo@monkey.io>

diff --git a/include/monkey/mk_api.h b/include/monkey/mk_api.h
index 8180dd72..200b4539 100644
--- a/include/monkey/mk_api.h
+++ b/include/monkey/mk_api.h
@@ -38,12 +38,11 @@
 
 /* global vars */
 struct plugin_api *mk_api;
-struct plugin_info MK_EXPORT _plugin_info;
 
 pthread_key_t MK_EXPORT _mkp_data;
 
 #define MONKEY_PLUGIN(a, b, c, d)                   \
-    struct plugin_info MK_EXPORT _plugin_info = {a, b, c, d}
+    struct mk_plugin_info MK_EXPORT _plugin_info = {a, b, c, d}
 
 #ifdef TRACE
 #define PLUGIN_TRACE(...) \
diff --git a/include/monkey/mk_config.h b/include/monkey/mk_config.h
index 21c5ff4a..5ecf856c 100644
--- a/include/monkey/mk_config.h
+++ b/include/monkey/mk_config.h
@@ -154,13 +154,16 @@ struct server_config
 
     /* Define the plugin who provides the transport layer */
     char *transport_layer;
-    struct plugin *transport_layer_plugin;
+    struct mk_plugin *transport_layer_plugin;
 
     /* Define the default mime type when is not possible to find the proper one */
     char *default_mimetype;
 
     /* source configuration */
     struct mk_config *config;
+
+    /* FIXME: temporal map of Network Layer plugin */
+    struct mk_plugin_network *network;
 };
 
 extern struct server_config *config;
diff --git a/include/monkey/mk_plugin.h b/include/monkey/mk_plugin.h
index 4b837c1a..035bac9b 100644
--- a/include/monkey/mk_plugin.h
+++ b/include/monkey/mk_plugin.h
@@ -50,8 +50,7 @@ extern __thread struct mk_list *worker_plugin_event_list;
 #define MK_PLUGIN_STAGE_50 (64)   /* Conection ended */
 
 /* Plugin: Network type */
-#define MK_PLUGIN_NETWORK_IO (128)
-#define MK_PLUGIN_NETWORK_IP (256)
+#define MK_PLUGIN_NETWORK_LAYER (128)
 
 /* Return values */
 #define MK_PLUGIN_RET_NOT_ME -1
@@ -60,6 +59,10 @@ extern __thread struct mk_list *worker_plugin_event_list;
 #define MK_PLUGIN_RET_CLOSE_CONX 300
 #define MK_PLUGIN_HEADER_EXTRA_ROWS  18
 
+/* Plugin types */
+#define MK_PLUGIN_STATIC     0   /* built-in into core */
+#define MK_PLUGIN_DYNAMIC    1   /* shared library     */
+
 /*
  * Event return values
  * -------------------
@@ -82,70 +85,15 @@ extern __thread struct mk_list *worker_plugin_event_list;
 /* The plugin request to the caller skip event hooks */
 #define MK_PLUGIN_RET_EVENT_CONTINUE -600
 
-/* Contexts: process/thread */
-struct plugin_core
-{
-    int  (*prctx) (struct server_config *);
-    void (*thctx) ();
-};
-
 struct plugin_stage
 {
     int (*s10) (int, struct sched_connection *);
     int (*s20) (struct mk_http_session *, struct mk_http_request *);
-    int (*s30) (struct plugin *, struct mk_http_session *, struct mk_http_request *);
+    int (*s30) (struct mk_plugin *, struct mk_http_session *, struct mk_http_request *);
     int (*s40) (struct mk_http_session *, struct mk_http_request *);
     int (*s50) (int);
 };
 
-struct plugin_network_io
-{
-    int (*accept) (int);
-    int (*read) (int, void *, int);
-    int (*write) (int, const void *, size_t);
-    int (*writev) (int, struct mk_iov *);
-    int (*close) (int);
-    int (*connect) (char *, int);
-    int (*send_file) (int, int, off_t *, size_t);
-    int (*create_socket) (int, int, int);
-    int (*bind) (int, const struct sockaddr *addr, socklen_t, int);
-    int (*server) (char *port, char *addr, int);
-    int (*buffer_size) ();
-};
-
-struct plugin
-{
-    char *shortname;
-    char *name;
-    char *version;
-    char *path;
-    void *handler;
-    unsigned int hooks;
-
-    /* Mandatory calls */
-    int (*init) (void *, char *);
-    int  (*exit) ();
-
-    /* Hook functions by type */
-    struct plugin_core core;
-    struct plugin_stage stage;
-    struct plugin_network_io net_io;
-
-    /* Epoll Events */
-    int (*event_read) (int);
-    int (*event_write) (int);
-    int (*event_error) (int);
-    int (*event_close) (int);
-    int (*event_timeout) (int);
-
-    /* Each plugin has a thread key for it's global data */
-    pthread_key_t *thread_key;
-
-    /* Next! */
-    struct mk_list _head;
-};
-
-
 /* Multiple plugins can work on multiple stages, we don't want
  * Monkey be comparing each plugin looking for a specific stage,
  * so we create a Map of direct stage calls
@@ -166,9 +114,6 @@ struct plugin_stagemap
     struct plugin_stagem *stage_50;
 };
 
-/* Network map calls */
-extern struct plugin_network_io *plg_netiomap;
-
 /* API functions exported to plugins */
 struct plugin_api
 {
@@ -321,11 +266,41 @@ struct plugin_event
     struct mk_list _head;
 };
 
-struct plugin_info {
+/* Info: used to register a plugin */
+struct mk_plugin {
+    /* Identification */
     const char *shortname;
     const char *name;
     const char *version;
     unsigned int hooks;
+
+    /* Init / Exit */
+    int (*init_plugin) (struct plugin_api **, char *);
+    int (*exit_plugin) ();
+
+    /* Init Levels */
+    int  (*master_init) (struct server_config *);
+    void (*worker_init) ();
+
+    struct mk_list _head;
+};
+
+/*
+ * Network plugin: a plugin that provides a network layer, eg: plain
+ * sockets or SSL.
+ */
+struct mk_plugin_network {
+    int (*accept) (int);
+    int (*read) (int, void *, int);
+    int (*write) (int, const void *, size_t);
+    int (*writev) (int, struct mk_iov *);
+    int (*close) (int);
+    int (*connect) (char *, int);
+    int (*send_file) (int, int, off_t *, size_t);
+    int (*create_socket) (int, int, int);
+    int (*bind) (int, const struct sockaddr *addr, socklen_t, int);
+    int (*server) (char *port, char *addr, int);
+    int (*buffer_size) ();
 };
 
 void mk_plugin_init();
diff --git a/plugins/liana/liana.c b/plugins/liana/liana.c
index 78e5816f..ad0e2b3d 100644
--- a/plugins/liana/liana.c
+++ b/plugins/liana/liana.c
@@ -34,12 +34,7 @@
 
 #include <monkey/mk_api.h>
 
-MONKEY_PLUGIN("liana",         /* shortname */
-              "Liana Network", /* name */
-              VERSION,         /* version */
-              MK_PLUGIN_NETWORK_IO); /* hooks */
-
-int _mkp_init(struct plugin_api **api, char *confdir)
+int mk_liana_plugin_init(struct plugin_api **api, char *confdir)
 {
     (void) confdir;
 
@@ -47,11 +42,12 @@ int _mkp_init(struct plugin_api **api, char *confdir)
     return 0;
 }
 
-void _mkp_exit()
+int mk_liana_plugin_exit()
 {
+    return 0;
 }
 
-int _mkp_network_io_accept(int server_fd)
+int mk_liana_accept(int server_fd)
 {
     int remote_fd;
     struct sockaddr sock_addr;
@@ -67,12 +63,12 @@ int _mkp_network_io_accept(int server_fd)
     return remote_fd;
 }
 
-int _mkp_network_io_buffer_size()
+int mk_liana_buffer_size()
 {
     return -1;
 }
 
-int _mkp_network_io_read(int socket_fd, void *buf, int count)
+int mk_liana_read(int socket_fd, void *buf, int count)
 {
     ssize_t bytes_read;
 
@@ -80,7 +76,7 @@ int _mkp_network_io_read(int socket_fd, void *buf, int count)
     return bytes_read;
 }
 
-int _mkp_network_io_write(int socket_fd, const void *buf, size_t count )
+int mk_liana_write(int socket_fd, const void *buf, size_t count )
 {
     ssize_t bytes_sent = -1;
 
@@ -89,7 +85,7 @@ int _mkp_network_io_write(int socket_fd, const void *buf, size_t count )
     return bytes_sent;
 }
 
-int _mkp_network_io_writev(int socket_fd, struct mk_iov *mk_io)
+int mk_liana_writev(int socket_fd, struct mk_iov *mk_io)
 {
     ssize_t bytes_sent = -1;
 
@@ -98,13 +94,13 @@ int _mkp_network_io_writev(int socket_fd, struct mk_iov *mk_io)
     return bytes_sent;
 }
 
-int _mkp_network_io_close(int socket_fd)
+int mk_liana_close(int socket_fd)
 {
     close(socket_fd);
     return 0;
 }
 
-int _mkp_network_io_create_socket(int domain, int type, int protocol)
+int mk_liana_create_socket(int domain, int type, int protocol)
 {
     int socket_fd;
 
@@ -119,7 +115,7 @@ int _mkp_network_io_create_socket(int domain, int type, int protocol)
 }
 
 /* We need to know how to solve the problem with AF_INET and AF_INET6 */
-int _mkp_network_io_connect(char *host, int port)
+int mk_liana_connect(char *host, int port)
 {
     int ret;
     int socket_fd = -1;
@@ -141,7 +137,7 @@ int _mkp_network_io_connect(char *host, int port)
         return -1;
     }
     for(rp = res; rp != NULL; rp = rp->ai_next) {
-        socket_fd = _mkp_network_io_create_socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
+        socket_fd = mk_liana_create_socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
 
         if( socket_fd == -1) {
             mk_warn("Error creating client socket, retrying");
@@ -165,7 +161,7 @@ int _mkp_network_io_connect(char *host, int port)
     return socket_fd;
 }
 
-int _mkp_network_io_send_file(int socket_fd, int file_fd, off_t *file_offset,
+int mk_liana_send_file(int socket_fd, int file_fd, off_t *file_offset,
                               size_t file_count)
 {
     ssize_t ret = -1;
@@ -196,7 +192,7 @@ int _mkp_network_io_send_file(int socket_fd, int file_fd, off_t *file_offset,
 #endif
 }
 
-int _mkp_network_io_bind(int socket_fd, const struct sockaddr *addr, socklen_t addrlen, int backlog)
+int mk_liana_bind(int socket_fd, const struct sockaddr *addr, socklen_t addrlen, int backlog)
 {
     int ret;
 
@@ -234,7 +230,7 @@ int _mkp_network_io_bind(int socket_fd, const struct sockaddr *addr, socklen_t a
     return ret;
 }
 
-int _mkp_network_io_server(char *port, char *listen_addr, int reuse_port)
+int mk_liana_server(char *port, char *listen_addr, int reuse_port)
 {
     int socket_fd = -1;
     int ret;
@@ -253,7 +249,7 @@ int _mkp_network_io_server(char *port, char *listen_addr, int reuse_port)
     }
 
     for(rp = res; rp != NULL; rp = rp->ai_next) {
-        socket_fd = _mkp_network_io_create_socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
+        socket_fd = mk_liana_create_socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
 
         if( socket_fd == -1) {
             mk_warn("Error creating server socket, retrying");
@@ -273,7 +269,7 @@ int _mkp_network_io_server(char *port, char *listen_addr, int reuse_port)
             }
         }
 
-        ret = _mkp_network_io_bind(socket_fd, rp->ai_addr, rp->ai_addrlen, MK_SOMAXCONN);
+        ret = mk_liana_bind(socket_fd, rp->ai_addr, rp->ai_addrlen, MK_SOMAXCONN);
         if(ret == -1) {
             mk_err("Cannot listen on %s:%s\n", listen_addr, port);
             continue;
@@ -287,3 +283,34 @@ int _mkp_network_io_server(char *port, char *listen_addr, int reuse_port)
 
     return socket_fd;
 }
+
+struct mk_plugin mk_plugin_liana = {
+    /* Identification */
+    .shortname     = "Liana",
+    .name          = "Liana Network Layer",
+    .version       = VERSION,
+    .hooks         = MK_PLUGIN_NETWORK_LAYER,
+
+    /* Init / Exit */
+    .init_plugin   = mk_liana_plugin_init,
+    .exit_plugin   = mk_liana_plugin_exit,
+
+    /* Init Levels */
+    .master_init   = NULL,
+    .worker_init   = NULL
+};
+
+/* Network Layer plugin Callbacks */
+struct mk_plugin_network mk_plugin_network_liana = {
+    .accept        = mk_liana_accept,
+    .read          = mk_liana_read,
+    .write         = mk_liana_write,
+    .writev        = mk_liana_writev,
+    .close         = mk_liana_close,
+    .connect       = mk_liana_connect,
+    .send_file     = mk_liana_send_file,
+    .create_socket = mk_liana_create_socket,
+    .bind          = mk_liana_bind,
+    .server        = mk_liana_server,
+    .buffer_size   = mk_liana_buffer_size
+};
diff --git a/src/mk_plugin.c b/src/mk_plugin.c
index afde22f4..8b5121a5 100644
--- a/src/mk_plugin.c
+++ b/src/mk_plugin.c
@@ -56,7 +56,7 @@ static struct mk_list *mk_plugin_event_get_list()
     return worker_plugin_event_list;
 }
 
-void *mk_plugin_load(const char *path)
+void *mk_plugin_load_dynamic(const char *path)
 {
     void *handle;
 
@@ -127,6 +127,54 @@ static void mk_plugin_register_stagemap(struct plugin *p)
     }
 }
 
+/*
+ * Load a plugin into Monkey core, 'type' defines if it's a MK_PLUGIN_STATIC or
+ * a MK_PLUGIN_DYNAMIC. 'shortname' is mandatory and 'path' is only used when
+ * MK_PLUGIN_DYNAMIC is set and represents the absolute path of the shared
+ * library.
+ */
+struct mk_plugin *mk_plugin_load(int type, const char *shortname,
+                                 const char *path)
+{
+    char plugin_info[64];
+    void *handler;
+    struct mk_plugin *plugin;
+
+    /* Set main struct name to reference */
+    snprintf(plugin_info, sizeof(plugin_info) - 1, "mk_plugin_%s", shortname);
+
+    if (type == MK_PLUGIN_DYNAMIC) {
+        handler = mk_plugin_load_dynamic(path);
+        plugin  = mk_plugin_load_symbol(handler, plugin_info);
+
+        if (!plugin) {
+            mk_warn("Plugin '%s' is not registering properly", path);
+            return NULL;
+        }
+    }
+    else if (type == MK_PLUGIN_STATIC) {
+        /* fixme! */
+        plugin = *plugin_info;
+    }
+
+    /* Validate all callbacks are set */
+    if (!plugin->shortname || !plugin->name || !plugin->version ||
+        !plugin->hooks || !plugin->init || !plugin->exit) {
+        mk_warn("Plugin '%s' is not registering all fields properly",
+                shortname);
+        return NULL;
+    }
+
+    if (plugin->hooks & MK_PLUGIN_NETWORK_LAYER) {
+
+    }
+
+
+    /* Add Plugin to the end of the list */
+    mk_list_add(&plugin->_head, config->plugins);
+
+}
+
 struct plugin *mk_plugin_alloc(void *handler, const char *path)
 {
     struct plugin *p;
@@ -250,7 +298,7 @@ struct plugin *mk_plugin_register(struct plugin *p)
     }
 
     /* NETWORK_IO Plugin */
-    if (p->hooks & MK_PLUGIN_NETWORK_IO) {
+    if (p->hooks & MK_PLUGIN_NETWORK_LAYER) {
 #ifdef TRACE
         /* Validate mandatory calls */
         if (!p->net_io.accept || !p->net_io.read || !p->net_io.write ||
@@ -495,7 +543,9 @@ void mk_plugin_read_config()
     mk_list_foreach(head, &section->entries) {
         entry = mk_list_entry(head, struct mk_config_entry, _head);
         if (strcasecmp(entry->key, "Load") == 0) {
-            handle = mk_plugin_load(entry->val);
+            handle = mk_plugin_load(MK_PLUGIN_DYNAMIC,
+                                    NULL,
+                                    entry->val);
 
             if (!handle) {
                 mk_warn("Invalid plugin '%s'", entry->val);
diff --git a/src/mk_socket.c b/src/mk_socket.c
index fce88b41..e724a3b2 100644
--- a/src/mk_socket.c
+++ b/src/mk_socket.c
@@ -128,7 +128,7 @@ int mk_socket_set_tcp_reuseport(int sockfd)
 
 int mk_socket_close(int socket)
 {
-    return plg_netiomap->close(socket);
+    return config->network->close(socket);
 }
 
 int mk_socket_create()
@@ -147,7 +147,7 @@ int mk_socket_connect(char *host, int port)
 {
     int sockfd;
 
-    sockfd = plg_netiomap->connect(host, port);
+    sockfd = config->network->connect(host, port);
 
     return sockfd;
 }
@@ -169,7 +169,7 @@ int mk_socket_server(char *port, char *listen_addr, int reuse_port)
 {
     int socket_fd;
 
-    socket_fd = plg_netiomap->server(port, listen_addr, reuse_port);
+    socket_fd = config->network->server(port, listen_addr, reuse_port);
     if (socket_fd < 0) {
         exit(EXIT_FAILURE);
     }
@@ -180,13 +180,13 @@ int mk_socket_server(char *port, char *listen_addr, int reuse_port)
 /* NETWORK_IO plugin functions */
 int mk_socket_accept(int server_fd)
 {
-    return plg_netiomap->accept(server_fd);
+    return config->network->accept(server_fd);
 }
 
 int mk_socket_sendv(int socket_fd, struct mk_iov *mk_io)
 {
     int bytes;
-    bytes = plg_netiomap->writev(socket_fd, mk_io);
+    bytes = config->network->writev(socket_fd, mk_io);
 
     if (config->safe_event_write == MK_TRUE) {
         mk_socket_safe_event_write(socket_fd);
@@ -197,7 +197,7 @@ int mk_socket_sendv(int socket_fd, struct mk_iov *mk_io)
 int mk_socket_send(int socket_fd, const void *buf, size_t count)
 {
     int bytes;
-    bytes = plg_netiomap->write(socket_fd, buf, count);
+    bytes = config->network->write(socket_fd, buf, count);
 
     if (config->safe_event_write == MK_TRUE) {
         mk_socket_safe_event_write(socket_fd);
@@ -207,7 +207,7 @@ int mk_socket_send(int socket_fd, const void *buf, size_t count)
 
 int mk_socket_read(int socket_fd, void *buf, int count)
 {
-    return plg_netiomap->read(socket_fd, (void *)buf, count);
+    return config->network->read(socket_fd, (void *)buf, count);
 }
 
 int mk_socket_send_file(int socket_fd, int file_fd, off_t *file_offset,
@@ -215,8 +215,8 @@ int mk_socket_send_file(int socket_fd, int file_fd, off_t *file_offset,
 {
     int bytes;
 
-    bytes = plg_netiomap->send_file(socket_fd, file_fd,
-                                    file_offset, file_count);
+    bytes = config->network->send_file(socket_fd, file_fd,
+                                       file_offset, file_count);
 
     if (config->safe_event_write == MK_TRUE) {
         mk_socket_safe_event_write(socket_fd);

