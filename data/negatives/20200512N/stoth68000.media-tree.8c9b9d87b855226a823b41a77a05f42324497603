commit 8c9b9d87b855226a823b41a77a05f42324497603
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Dec 18 15:09:29 2016 +0100

    x86/tsc: Limit the adjust value further
    
    Adjust value 0x80000000 and other values larger than that render the TSC
    deadline timer disfunctional.
    
    We have not yet any information about this from Intel, but experimentation
    clearly proves that this is a 32/64 bit and sign extension issue.
    
    If adjust values larger than that are actually required, which might be the
    case for physical CPU hotplug, then we need to disable the deadline timer
    on the affected package/CPUs and use the local APIC timer instead.
    
    That requires some surgery in the APIC setup code, so we just limit the
    ADJUST register value into the known to work range for now and revisit this
    when Intel comes forth with proper information.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Roland Scheidegger <rscheidegger_lists@hispeed.ch>
    Cc: Bruce Schlobohm <bruce.schlobohm@intel.com>
    Cc: Kevin Stanton <kevin.b.stanton@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Borislav Petkov <bp@alien8.de>

diff --git a/arch/x86/kernel/tsc_sync.c b/arch/x86/kernel/tsc_sync.c
index 1d8508fd15f7..d0db011051a5 100644
--- a/arch/x86/kernel/tsc_sync.c
+++ b/arch/x86/kernel/tsc_sync.c
@@ -73,9 +73,11 @@ static void tsc_sanitize_first_cpu(struct tsc_adjust *cur, s64 bootval,
 	 * the TSC is in sync with the already running cpus.
 	 *
 	 * But we always force positive ADJUST values. Otherwise the TSC
-	 * deadline timer creates an interrupt storm. Sigh!
+	 * deadline timer creates an interrupt storm. We also have to
+	 * prevent values > 0x7FFFFFFF as those wreckage the timer as well.
 	 */
-	if ((bootcpu && bootval != 0) || (!bootcpu && bootval < 0)) {
+	if ((bootcpu && bootval != 0) || (!bootcpu && bootval < 0) ||
+	    (bootval > 0x7FFFFFFF)) {
 		pr_warn(FW_BUG "TSC ADJUST: CPU%u: %lld force to 0\n", cpu,
 			bootval);
 		wrmsrl(MSR_IA32_TSC_ADJUST, 0);
@@ -448,13 +450,22 @@ void check_tsc_sync_target(void)
 	 * that the warp is not longer detectable when the observed warp
 	 * value is used. In the worst case the adjustment needs to go
 	 * through a 3rd run for fine tuning.
-	 *
-	 * But we must make sure that the value doesn't become negative
-	 * otherwise TSC deadline timer will create an interrupt storm.
 	 */
 	cur->adjusted += cur_max_warp;
+
+	/*
+	 * TSC deadline timer stops working or creates an interrupt storm
+	 * with adjust values < 0 and > x07ffffff.
+	 *
+	 * To allow adjust values > 0x7FFFFFFF we need to disable the
+	 * deadline timer and use the local APIC timer, but that requires
+	 * more intrusive changes and we do not have any useful information
+	 * from Intel about the underlying HW wreckage yet.
+	 */
 	if (cur->adjusted < 0)
 		cur->adjusted = 0;
+	if (cur->adjusted > 0x7FFFFFFF)
+		cur->adjusted = 0x7FFFFFFF;
 
 	pr_warn("TSC ADJUST compensate: CPU%u observed %lld warp. Adjust: %lld\n",
 		cpu, cur_max_warp, cur->adjusted);

