commit 7206b00164a1c3ca533e01db285955617e1019f8
Author: Sarah Sharp <sarah.a.sharp@linux.intel.com>
Date:   Mon Apr 27 19:54:49 2009 -0700

    USB: Add route string to struct usb_device.
    
    This patch adds a hex route string to each USB device.  The route string is used
    by the USB 3.0 host controller to send packets through the device tree.  USB 3.0
    hubs use this string to route packets to the correct port.  This is fundamental
    bus change from USB 2.0, where all packets were broadcast across the bus.
    
    Devices (including hubs) under a root port receive the route string 0x0.  Every
    four bits in the route string represent a port on a hub.  This length works
    because USB 3.0 hubs are limited to 15 ports, and USB 2.0 hubs (with potentially
    more ports) will never see packets with a route string.  A port number of 0
    means the packet is destined for that hub.
    
    For example, a peripheral device might have a route string of 0x00097.
    This means the device is connected to port 9 of the hub at depth 1.
    The hub at depth 1 is connected to port 7 of a hub at depth 0.
    The hub at depth 0 is connected to a root port.
    
    Signed-off-by: Sarah Sharp <sarah.a.sharp@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 020b58528d90..f026991d0bdf 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -375,18 +375,24 @@ struct usb_device *usb_alloc_dev(struct usb_device *parent,
 	 */
 	if (unlikely(!parent)) {
 		dev->devpath[0] = '0';
+		dev->route = 0;
 
 		dev->dev.parent = bus->controller;
 		dev_set_name(&dev->dev, "usb%d", bus->busnum);
 		root_hub = 1;
 	} else {
 		/* match any labeling on the hubs; it's one-based */
-		if (parent->devpath[0] == '0')
+		if (parent->devpath[0] == '0') {
 			snprintf(dev->devpath, sizeof dev->devpath,
 				"%d", port1);
-		else
+			/* Root ports are not counted in route string */
+			dev->route = 0;
+		} else {
 			snprintf(dev->devpath, sizeof dev->devpath,
 				"%s.%d", parent->devpath, port1);
+			dev->route = parent->route +
+				(port1 << ((parent->level - 1)*4));
+		}
 
 		dev->dev.parent = &parent->dev;
 		dev_set_name(&dev->dev, "%d-%s", bus->busnum, dev->devpath);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index fb1f2a32ae05..2b380a16c62f 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -362,6 +362,7 @@ struct usb_tt;
  * struct usb_device - kernel's representation of a USB device
  * @devnum: device number; address on a USB bus
  * @devpath: device ID string for use in messages (e.g., /port/...)
+ * @route: tree topology hex string for use with xHCI
  * @state: device state: configured, not attached, etc.
  * @speed: device speed: high/full/low (or error)
  * @tt: Transaction Translator info; used with low/full speed dev, highspeed hub
@@ -427,6 +428,7 @@ struct usb_tt;
 struct usb_device {
 	int		devnum;
 	char		devpath [16];
+	u32		route;
 	enum usb_device_state	state;
 	enum usb_device_speed	speed;
 

