commit a7b2e833f0c0adc00cd6790a4ee03647f7a26d7b
Author: eric <eric@openbsd.org>
Date:   Tue Aug 21 13:13:17 2012 +0000

    Re-enable loop detection, but in mta and mda this time.
    
    ok gilles@

diff --git a/usr.sbin/smtpd/mda.c b/usr.sbin/smtpd/mda.c
index 126db565253..3a553cd0b07 100644
--- a/usr.sbin/smtpd/mda.c
+++ b/usr.sbin/smtpd/mda.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: mda.c,v 1.69 2012/08/19 14:16:58 chl Exp $	*/
+/*	$OpenBSD: mda.c,v 1.70 2012/08/21 13:13:17 eric Exp $	*/
 
 /*
  * Copyright (c) 2008 Gilles Chehade <gilles@openbsd.org>
@@ -24,6 +24,7 @@
 #include <sys/param.h>
 #include <sys/socket.h>
 
+#include <ctype.h>
 #include <err.h>
 #include <event.h>
 #include <imsg.h>
@@ -45,6 +46,7 @@ static void mda_shutdown(void);
 static void mda_sig_handler(int, short, void *);
 static void mda_store(struct mda_session *);
 static void mda_store_event(int, short, void *);
+static int mda_check_loop(FILE *, struct envelope *);
 static struct mda_session *mda_lookup(uint32_t);
 
 uint32_t mda_id;
@@ -58,6 +60,7 @@ mda_imsg(struct imsgev *iev, struct imsg *imsg)
 	struct delivery_mda	*d_mda;
 	struct mailaddr		*maddr;
 	struct envelope		*ep;
+	FILE			*fp;
 	uint16_t		 msg;
 
 	log_imsg(PROC_MDA, iev->proc, imsg);
@@ -65,16 +68,29 @@ mda_imsg(struct imsgev *iev, struct imsg *imsg)
 	if (iev->proc == PROC_QUEUE) {
 		switch (imsg->hdr.type) {
 		case IMSG_MDA_SESS_NEW:
+			ep = (struct envelope *)imsg->data;
+			fp = fdopen(imsg->fd, "r");
+			if (fp == NULL)
+				fatalx("mda: fdopen");
+
+			if (mda_check_loop(fp, ep)) {
+				log_debug("mda: loop detected");
+				envelope_set_errormsg(ep, "646 loop detected");
+				imsg_compose_event(env->sc_ievs[PROC_QUEUE],
+				    IMSG_QUEUE_DELIVERY_LOOP, 0, 0, -1, ep,
+				    sizeof *ep);
+				fclose(fp);
+				return;
+			}
+
 			/* make new session based on provided args */
 			s = calloc(1, sizeof *s);
 			if (s == NULL)
 				fatal(NULL);
 			msgbuf_init(&s->w);
-			s->msg = *(struct envelope *)imsg->data;
+			s->msg = *ep;
 			s->id = mda_id++;
-			s->datafp = fdopen(imsg->fd, "r");
-			if (s->datafp == NULL)
-				fatalx("mda: fdopen");
+			s->datafp = fp;
 			LIST_INSERT_HEAD(&env->mda_sessions, s, entry);
 
 			/* request parent to fork a helper process */
@@ -149,7 +165,6 @@ mda_imsg(struct imsgev *iev, struct imsg *imsg)
 			output[0] = '\0';
 			if (imsg->fd != -1) {
 				char *ln, *buf;
-				FILE *fp;
 				size_t len;
 
 				buf = NULL;
@@ -409,3 +424,54 @@ mda_lookup(uint32_t id)
 
 	return s;
 }
+
+static int
+mda_check_loop(FILE *fp, struct envelope *ep)
+{
+	char		*buf, *lbuf;
+	size_t		 len;
+	struct mailaddr	 maddr, dest;
+	int		 ret = 0;
+
+	lbuf = NULL;
+	while ((buf = fgetln(fp, &len))) {
+		if (buf[len - 1] == '\n')
+			buf[len - 1] = '\0';
+		else {
+			/* EOF without EOL, copy and add the NUL */
+			if ((lbuf = malloc(len + 1)) == NULL)
+				err(1, NULL);
+			memcpy(lbuf, buf, len);
+			lbuf[len] = '\0';
+			buf = lbuf;
+		}
+
+		if (strchr(buf, ':') == NULL && !isspace((int)*buf))
+			break;
+
+		if (strncasecmp("Delivered-To: ", buf, 14) == 0) {
+
+			bzero(&maddr, sizeof maddr);
+			if (! email_to_mailaddr(&maddr, buf + 14))
+				continue;
+
+			dest = (ep->type == D_BOUNCE) ? ep->sender : ep->dest;
+
+			if (strcasecmp(maddr.user, dest.user) == 0 &&
+			    strcasecmp(maddr.domain, dest.domain) == 0) {
+				ret = 1;
+				break;
+			}
+		}
+		if (lbuf) {
+			free(lbuf);
+			lbuf = NULL;
+		}
+	}
+	if (lbuf)
+		free(lbuf);
+
+	fseek(fp, SEEK_SET, 0);
+
+	return (ret);
+}
diff --git a/usr.sbin/smtpd/mta.c b/usr.sbin/smtpd/mta.c
index a28b572fbc4..46ab4dea573 100644
--- a/usr.sbin/smtpd/mta.c
+++ b/usr.sbin/smtpd/mta.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: mta.c,v 1.134 2012/08/18 15:45:12 eric Exp $	*/
+/*	$OpenBSD: mta.c,v 1.135 2012/08/21 13:13:17 eric Exp $	*/
 
 /*
  * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@openbsd.org>
@@ -303,6 +303,8 @@ mta_response_delivery(const char *r)
 		return IMSG_QUEUE_DELIVERY_OK;
 	case '5':
 	case '6':
+		if (r[1] == '4' && r[2] == '6')
+			return IMSG_QUEUE_DELIVERY_LOOP;
 		return IMSG_QUEUE_DELIVERY_PERMFAIL;
 	default:
 		return IMSG_QUEUE_DELIVERY_TEMPFAIL;
diff --git a/usr.sbin/smtpd/mta_session.c b/usr.sbin/smtpd/mta_session.c
index 7e8e20e89ed..b5887e9dea5 100644
--- a/usr.sbin/smtpd/mta_session.c
+++ b/usr.sbin/smtpd/mta_session.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: mta_session.c,v 1.10 2012/08/18 20:52:36 eric Exp $	*/
+/*	$OpenBSD: mta_session.c,v 1.11 2012/08/21 13:13:17 eric Exp $	*/
 
 /*
  * Copyright (c) 2008 Pierre-Yves Ritschard <pyr@openbsd.org>
@@ -102,6 +102,7 @@ struct mta_session {
 	struct envelope		*currevp;
 	struct iobuf		 iobuf;
 	struct io		 io;
+	int			 is_reading; /* XXX remove this later */
 	int			 ext;
 	struct ssl		*ssl;
 };
@@ -114,6 +115,7 @@ static void mta_send(struct mta_session *, char *, ...);
 static ssize_t mta_queue_data(struct mta_session *);
 static void mta_response(struct mta_session *, char *);
 static const char * mta_strstate(int);
+static int mta_check_loop(FILE *);
 
 static struct tree sessions = SPLAY_INITIALIZER(&sessions);
 
@@ -157,7 +159,7 @@ mta_session(struct mta_route *route)
 void
 mta_session_imsg(struct imsgev *iev, struct imsg *imsg)
 {
-	uint64_t		 batch_id;
+	uint64_t		 id;
 	struct mta_session	*s;
 	struct mta_host		*host;
 	struct secret		*secret;
@@ -168,14 +170,23 @@ mta_session_imsg(struct imsgev *iev, struct imsg *imsg)
 	switch(imsg->hdr.type) {
 
 	case IMSG_QUEUE_MESSAGE_FD:
-		batch_id = *(uint64_t*)(imsg->data);
+		id = *(uint64_t*)(imsg->data);
 		if (imsg->fd == -1)
 			fatalx("mta: cannot obtain msgfd");
-		s = tree_xget(&sessions, batch_id);
+		s = tree_xget(&sessions, id);
 		s->datafp = fdopen(imsg->fd, "r");
 		if (s->datafp == NULL)
 			fatal("mta: fdopen");
-		mta_enter_state(s, MTA_SMTP_MAIL);
+
+		if (mta_check_loop(s->datafp)) {
+			log_debug("mta: loop detected");
+			fclose(s->datafp);
+			s->datafp = NULL;
+			mta_status(s, 0, "646 Loop detected");
+			mta_enter_state(s, MTA_SMTP_READY);
+		} else {
+			mta_enter_state(s, MTA_SMTP_MAIL);
+		}
 		return;
 
 	case IMSG_LKA_SECRET:
@@ -392,6 +403,7 @@ mta_enter_state(struct mta_session *s, int newstate)
 
 	case MTA_SMTP_BANNER:
 		/* just wait for banner */
+		s->is_reading = 1;
 		io_set_read(&s->io);
 		break;
 
@@ -455,7 +467,6 @@ mta_enter_state(struct mta_session *s, int newstate)
 			    s->task->sender.user, s->task->sender.domain);
 		else
 			mta_send(s, "MAIL FROM: <>");
-		io_set_write(&s->io);
 		break;
 
 	case MTA_SMTP_RCPT:
@@ -557,6 +568,7 @@ mta_response(struct mta_session *s, char *line)
 		ssl = ssl_mta_init(s->ssl);
 		if (ssl == NULL)
 			fatal("mta: ssl_mta_init");
+		s->is_reading = 0;
 		io_set_write(&s->io);
 		io_start_tls(&s->io, ssl);
 		break;
@@ -636,6 +648,7 @@ mta_io(struct io *io, int evt)
 	switch (evt) {
 
 	case IO_CONNECTED:
+		s->is_reading = 0;
 		io_set_timeout(io, 300000);
 		io_set_write(io);
 		host = TAILQ_FIRST(&s->hosts);
@@ -692,16 +705,16 @@ mta_io(struct io *io, int evt)
 		mta_response(s, line);
 
 		iobuf_normalize(&s->iobuf);
-		if (iobuf_queued(&s->iobuf))
-			io_set_write(io);
 		break;
 
 	case IO_LOWAT:
 		if (s->state == MTA_SMTP_BODY)
 			mta_enter_state(s, MTA_SMTP_BODY);
 
-		if (iobuf_queued(&s->iobuf) == 0)
+		if (iobuf_queued(&s->iobuf) == 0) {
+			s->is_reading = 1;
 			io_set_read(io);
+		}
 		break;
 
 	case IO_TIMEOUT:
@@ -757,6 +770,11 @@ mta_send(struct mta_session *s, char *fmt, ...)
 	iobuf_fqueue(&s->iobuf, "%s\r\n", p);
 
 	free(p);
+
+	if (s->is_reading) {
+		s->is_reading = 0;
+		io_set_write(&s->io);
+	}
 }
 
 /*
@@ -791,6 +809,11 @@ mta_queue_data(struct mta_session *s)
 		s->datafp = NULL;
 	}
 
+	if (s->is_reading) {
+		s->is_reading = 0;
+		io_set_write(&s->io);
+	}
+
 	return (iobuf_queued(&s->iobuf) - q);
 }
 
@@ -872,3 +895,46 @@ mta_strstate(int state)
 		return "MTA_???";
 	}
 }
+
+static int
+mta_check_loop(FILE *fp)
+{
+	char	*buf, *lbuf;
+	size_t	 len;
+	uint32_t rcvcount = 0;
+	int	 ret = 0;
+
+	lbuf = NULL;
+	while ((buf = fgetln(fp, &len))) {
+		if (buf[len - 1] == '\n')
+			buf[len - 1] = '\0';
+		else {
+			/* EOF without EOL, copy and add the NUL */
+			if ((lbuf = malloc(len + 1)) == NULL)
+				err(1, NULL);
+			memcpy(lbuf, buf, len);
+			lbuf[len] = '\0';
+			buf = lbuf;
+		}
+
+		if (strchr(buf, ':') == NULL && !isspace((int)*buf))
+			break;
+
+		if (strncasecmp("Received: ", buf, 10) == 0) {
+			rcvcount++;
+			if (rcvcount == MAX_HOPS_COUNT) {
+				ret = 1;
+				break;
+			}
+		}
+		if (lbuf) {
+			free(lbuf);
+			lbuf  = NULL;
+		}
+	}
+	if (lbuf)
+		free(lbuf);
+
+	fseek(fp, SEEK_SET, 0);
+	return ret;
+}
diff --git a/usr.sbin/smtpd/queue.c b/usr.sbin/smtpd/queue.c
index e6fa7c480f0..9c6b803ebba 100644
--- a/usr.sbin/smtpd/queue.c
+++ b/usr.sbin/smtpd/queue.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: queue.c,v 1.127 2012/08/18 20:52:36 eric Exp $	*/
+/*	$OpenBSD: queue.c,v 1.128 2012/08/21 13:13:17 eric Exp $	*/
 
 /*
  * Copyright (c) 2008 Gilles Chehade <gilles@openbsd.org>
@@ -226,6 +226,15 @@ queue_imsg(struct imsgev *iev, struct imsg *imsg)
 			    IMSG_QUEUE_DELIVERY_PERMFAIL, 0, 0, -1, &e->id,
 			    sizeof e->id);
 			return;
+
+		case IMSG_QUEUE_DELIVERY_LOOP:
+			e = imsg->data;
+			queue_bounce(e);
+			queue_envelope_delete(e);
+			imsg_compose_event(env->sc_ievs[PROC_SCHEDULER],
+			    IMSG_QUEUE_DELIVERY_LOOP, 0, 0, -1, &e->id,
+			    sizeof e->id);
+			return;
 		}
 	}
 
diff --git a/usr.sbin/smtpd/scheduler.c b/usr.sbin/smtpd/scheduler.c
index 5a23bdac977..2a4d7928203 100644
--- a/usr.sbin/smtpd/scheduler.c
+++ b/usr.sbin/smtpd/scheduler.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: scheduler.c,v 1.14 2012/08/20 09:34:53 chl Exp $	*/
+/*	$OpenBSD: scheduler.c,v 1.15 2012/08/21 13:13:17 eric Exp $	*/
 
 /*
  * Copyright (c) 2008 Gilles Chehade <gilles@openbsd.org>
@@ -121,6 +121,14 @@ scheduler_imsg(struct imsgev *iev, struct imsg *imsg)
 		scheduler_reset_events();
 		return;
 
+	case IMSG_QUEUE_DELIVERY_LOOP:
+		id = *(uint64_t *)(imsg->data);
+		log_trace(TRACE_SCHEDULER,
+		    "scheduler: deleting evp:%016" PRIx64 " (loop)", id);
+		backend->delete(id);
+		scheduler_reset_events();
+		return;
+
 	case IMSG_QUEUE_PAUSE_MDA:
 		log_trace(TRACE_SCHEDULER, "scheduler: pausing mda");
 		env->sc_flags |= SMTPD_MDA_PAUSED;
diff --git a/usr.sbin/smtpd/smtpd.c b/usr.sbin/smtpd/smtpd.c
index 8b7ba9dc418..cc623047e5a 100644
--- a/usr.sbin/smtpd/smtpd.c
+++ b/usr.sbin/smtpd/smtpd.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: smtpd.c,v 1.160 2012/08/19 14:16:58 chl Exp $	*/
+/*	$OpenBSD: smtpd.c,v 1.161 2012/08/21 13:13:17 eric Exp $	*/
 
 /*
  * Copyright (c) 2008 Gilles Chehade <gilles@openbsd.org>
@@ -1247,6 +1247,7 @@ imsg_to_str(int type)
 	CASE(IMSG_QUEUE_DELIVERY_OK);
 	CASE(IMSG_QUEUE_DELIVERY_TEMPFAIL);
 	CASE(IMSG_QUEUE_DELIVERY_PERMFAIL);
+	CASE(IMSG_QUEUE_DELIVERY_LOOP);
 
 	CASE(IMSG_QUEUE_MESSAGE_FD);
 	CASE(IMSG_QUEUE_MESSAGE_FILE);
diff --git a/usr.sbin/smtpd/smtpd.h b/usr.sbin/smtpd/smtpd.h
index 9232322ed1b..a30c5269b1f 100644
--- a/usr.sbin/smtpd/smtpd.h
+++ b/usr.sbin/smtpd/smtpd.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: smtpd.h,v 1.327 2012/08/20 21:14:17 gilles Exp $	*/
+/*	$OpenBSD: smtpd.h,v 1.328 2012/08/21 13:13:17 eric Exp $	*/
 
 /*
  * Copyright (c) 2008 Gilles Chehade <gilles@openbsd.org>
@@ -149,6 +149,7 @@ enum imsg_type {
 	IMSG_QUEUE_DELIVERY_OK,
 	IMSG_QUEUE_DELIVERY_TEMPFAIL,
 	IMSG_QUEUE_DELIVERY_PERMFAIL,
+	IMSG_QUEUE_DELIVERY_LOOP,
 	IMSG_QUEUE_MESSAGE_FD,
 	IMSG_QUEUE_MESSAGE_FILE,
 	IMSG_QUEUE_REMOVE,

