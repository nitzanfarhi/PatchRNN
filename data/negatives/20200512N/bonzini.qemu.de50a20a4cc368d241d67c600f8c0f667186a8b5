commit de50a20a4cc368d241d67c600f8c0f667186a8b5
Author: Fam Zheng <famz@redhat.com>
Date:   Wed Mar 25 15:27:26 2015 +0800

    block: Switch to host monotonic clock for IO throttling
    
    Currently, throttle timers won't make any progress when VCPU is not
    running, which would stall the request queue in utils, qtest, vm
    suspending, and live migration, without special handling.
    
    Block jobs are confusingly inconsistent between with and without
    throttling: if user sets a bps limit, stops the vm, then start a block
    job, the block job will not make any progress; in contrary, if user
    unsets the bps limit, or if it's not set, the block job will run
    normally.
    
    After this patch, with the host clock, even if the VCPUs are stopped,
    the throttle queues will be processed.
    
    This patch also enables potential to add throttle to bdrv_drain_all.
    Currently all requests are drained immediately. In other words whenever
    it is called, IO throttling goes ineffective (examples: system reset,
    migration and many block job operations.). This is a loophole that guest
    could exploit. If we use the host clock, we can later just trust the
    nested poll. This could be done on top.
    
    Note that for qemu-iotests case 093, which uses qtest, we still keep vm
    clock so the script can control the clock stepping in order to be
    deterministic.
    
    Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
    Reviewed-by: Alberto Garcia <berto@igalia.com>
    Signed-off-by: Fam Zheng <famz@redhat.com>
    Message-id: 1427268446-6426-1-git-send-email-famz@redhat.com
    Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
    Signed-off-by: Kevin Wolf <kwolf@redhat.com>

diff --git a/block.c b/block.c
index d7781eebff..670d7e4fc2 100644
--- a/block.c
+++ b/block.c
@@ -30,6 +30,7 @@
 #include "qapi/qmp/qjson.h"
 #include "sysemu/block-backend.h"
 #include "sysemu/sysemu.h"
+#include "sysemu/qtest.h"
 #include "qemu/notify.h"
 #include "block/coroutine.h"
 #include "block/qapi.h"
@@ -181,10 +182,16 @@ static void bdrv_throttle_write_timer_cb(void *opaque)
 /* should be called before bdrv_set_io_limits if a limit is set */
 void bdrv_io_limits_enable(BlockDriverState *bs)
 {
+    int clock_type = QEMU_CLOCK_REALTIME;
+
+    if (qtest_enabled()) {
+        /* For testing block IO throttling only */
+        clock_type = QEMU_CLOCK_VIRTUAL;
+    }
     assert(!bs->io_limits_enabled);
     throttle_init(&bs->throttle_state,
                   bdrv_get_aio_context(bs),
-                  QEMU_CLOCK_VIRTUAL,
+                  clock_type,
                   bdrv_throttle_read_timer_cb,
                   bdrv_throttle_write_timer_cb,
                   bs);

