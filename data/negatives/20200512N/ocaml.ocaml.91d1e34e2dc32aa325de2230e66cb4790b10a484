commit 91d1e34e2dc32aa325de2230e66cb4790b10a484
Author: Gabriel Scherer <gabriel.scherer@gmail.com>
Date:   Sat Aug 22 06:04:20 2015 +0000

    Document backtrace infrastructure, make types more explicit
    
    From: Frédéric Bour <frederic.bour@lakaban.net>
    
    git-svn-id: http://caml.inria.fr/svn/ocaml/trunk@16366 f963ae5c-01c2-4b8c-9fe0-0dff7051ff02

diff --git a/asmrun/backtrace_prim.c b/asmrun/backtrace_prim.c
index f0813424d..a9973a52e 100644
--- a/asmrun/backtrace_prim.c
+++ b/asmrun/backtrace_prim.c
@@ -33,14 +33,14 @@
    In particular, we do not need to use [caml_modify] when setting
    an array element with such a value.
 */
-value caml_raw_backtrace_slot_of_code(code_t pc)
+value caml_val_raw_backtrace_slot(backtrace_slot pc)
 {
   return Val_long((uintnat)pc>>1);
 }
 
-code_t caml_raw_backtrace_slot_code(value v)
+backtrace_slot caml_raw_backtrace_slot_val(value v)
 {
-  return ((code_t)(Long_val(v)<<1));
+  return ((backtrace_slot)(Long_val(v)<<1));
 }
 
 /* returns the next frame descriptor (or NULL if none is available),
@@ -99,7 +99,7 @@ void caml_stash_backtrace(value exn, uintnat pc, char * sp, char * trapsp)
   }
   if (caml_backtrace_buffer == NULL) {
     Assert(caml_backtrace_pos == 0);
-    caml_backtrace_buffer = malloc(BACKTRACE_BUFFER_SIZE * sizeof(code_t));
+    caml_backtrace_buffer = malloc(BACKTRACE_BUFFER_SIZE * sizeof(backtrace_slot));
     if (caml_backtrace_buffer == NULL) return;
   }
 
@@ -109,7 +109,7 @@ void caml_stash_backtrace(value exn, uintnat pc, char * sp, char * trapsp)
     if (descr == NULL) return;
     /* store its descriptor in the backtrace buffer */
     if (caml_backtrace_pos >= BACKTRACE_BUFFER_SIZE) return;
-    caml_backtrace_buffer[caml_backtrace_pos++] = (code_t) descr;
+    caml_backtrace_buffer[caml_backtrace_pos++] = (backtrace_slot) descr;
 
     /* Stop when we reach the current exception handler */
 #ifndef Stack_grows_upwards
@@ -170,7 +170,7 @@ CAMLprim value caml_get_current_callstack(value max_frames_value) {
     for (trace_pos = 0; trace_pos < trace_size; trace_pos++) {
       frame_descr * descr = caml_next_frame_descriptor(&pc, &sp);
       Assert(descr != NULL);
-      Field(trace, trace_pos) = caml_raw_backtrace_slot_of_code((code_t) descr);
+      Field(trace, trace_pos) = caml_val_raw_backtrace_slot((backtrace_slot) descr);
     }
   }
 
@@ -179,7 +179,7 @@ CAMLprim value caml_get_current_callstack(value max_frames_value) {
 
 /* Extract location information for the given frame descriptor */
 
-void caml_extract_location_info(code_t slot, /*out*/ struct caml_loc_info * li)
+void caml_extract_location_info(backtrace_slot slot, /*out*/ struct caml_loc_info * li)
 {
   uintnat infoptr;
   uint32_t info1, info2;
@@ -217,12 +217,12 @@ void caml_extract_location_info(code_t slot, /*out*/ struct caml_loc_info * li)
   li->loc_endchr = ((info2 & 0xF) << 6) | (info1 >> 26);
 }
 
-CAMLprim value caml_add_debug_info(code_t start, value size, value events)
+CAMLprim value caml_add_debug_info(backtrace_slot start, value size, value events)
 {
   return Val_unit;
 }
 
-CAMLprim value caml_remove_debug_info(code_t start)
+CAMLprim value caml_remove_debug_info(backtrace_slot start)
 {
   return Val_unit;
 }
diff --git a/byterun/backtrace.c b/byterun/backtrace.c
index 263d0a6d9..3d26c5fa4 100644
--- a/byterun/backtrace.c
+++ b/byterun/backtrace.c
@@ -28,7 +28,7 @@ struct ext_table caml_debug_info;
 
 CAMLexport int caml_backtrace_active = 0;
 CAMLexport int caml_backtrace_pos = 0;
-CAMLexport code_t * caml_backtrace_buffer = NULL;
+CAMLexport backtrace_slot * caml_backtrace_buffer = NULL;
 CAMLexport value caml_backtrace_last_exn = Val_unit;
 
 /* Start or stop the backtrace machinery */
@@ -127,11 +127,13 @@ CAMLprim value caml_get_exception_raw_backtrace(value unit)
      if the finalizer raises then catches an exception).  We choose to ignore
      any such finalizer backtraces and return the original one. */
 
-  if (caml_backtrace_buffer == NULL || caml_backtrace_pos == 0) {
+  if (!caml_backtrace_active ||
+      caml_backtrace_buffer == NULL ||
+      caml_backtrace_pos == 0) {
     res = caml_alloc(0, 0);
   }
   else {
-    code_t saved_caml_backtrace_buffer[BACKTRACE_BUFFER_SIZE];
+    backtrace_slot saved_caml_backtrace_buffer[BACKTRACE_BUFFER_SIZE];
     int saved_caml_backtrace_pos;
     intnat i;
 
@@ -142,11 +144,11 @@ CAMLprim value caml_get_exception_raw_backtrace(value unit)
     }
 
     memcpy(saved_caml_backtrace_buffer, caml_backtrace_buffer,
-           saved_caml_backtrace_pos * sizeof(code_t));
+           saved_caml_backtrace_pos * sizeof(backtrace_slot));
 
     res = caml_alloc(saved_caml_backtrace_pos, 0);
     for (i = 0; i < saved_caml_backtrace_pos; i++) {
-      Store_field(res, i, caml_raw_backtrace_slot_of_code(saved_caml_backtrace_buffer[i]));
+      Store_field(res, i, caml_val_raw_backtrace_slot(saved_caml_backtrace_buffer[i]));
     }
   }
 
@@ -164,7 +166,7 @@ CAMLprim value caml_convert_raw_backtrace_slot(value backtrace_slot)
   if (!caml_debug_info_available())
     caml_failwith("No debug information available");
 
-  caml_extract_location_info(caml_raw_backtrace_slot_code(backtrace_slot), &li);
+  caml_extract_location_info(caml_raw_backtrace_slot_val(backtrace_slot), &li);
 
   if (li.loc_valid) {
     fname = caml_copy_string(li.loc_filename);
diff --git a/byterun/backtrace_prim.c b/byterun/backtrace_prim.c
index 516c39ec3..1410ce0c4 100644
--- a/byterun/backtrace_prim.c
+++ b/byterun/backtrace_prim.c
@@ -250,14 +250,14 @@ void caml_stash_backtrace(value exn, code_t pc, value * sp, int reraise)
    In particular, we do not need to use [caml_modify] when setting
    an array element with such a value.
 */
-value caml_raw_backtrace_slot_of_code(code_t pc)
+value caml_val_raw_backtrace_slot(backtrace_slot pc)
 {
   return Val_long ((uintnat)pc >> 1);
 }
 
-code_t caml_raw_backtrace_slot_code(value v)
+backtrace_slot caml_raw_backtrace_slot_val(value v)
 {
-  return ((code_t)(Long_val(v) << 1));
+  return ((backtrace_slot)(Long_val(v) << 1));
 }
 
 /* returns the next frame pointer (or NULL if none is available);
@@ -318,7 +318,7 @@ CAMLprim value caml_get_current_callstack(value max_frames_value)
     for (trace_pos = 0; trace_pos < trace_size; trace_pos++) {
       code_t p = caml_next_frame_pointer(&sp, &trsp);
       Assert(p != NULL);
-      Field(trace, trace_pos) = caml_raw_backtrace_slot_of_code(p);
+      Field(trace, trace_pos) = caml_val_raw_backtrace_slot(p);
     }
   }
 
@@ -431,8 +431,9 @@ static struct ev_info *event_for_location(code_t pc)
 
 /* Extract location information for the given PC */
 
-void caml_extract_location_info(code_t pc, /*out*/ struct caml_loc_info * li)
+void caml_extract_location_info(backtrace_slot slot, /*out*/ struct caml_loc_info * li)
 {
+  code_t pc = slot;
   struct ev_info *event = event_for_location(pc);
   li->loc_is_raise = caml_is_instruction(*pc, RAISE) ||
     caml_is_instruction(*pc, RERAISE);
diff --git a/byterun/caml/backtrace.h b/byterun/caml/backtrace.h
index f1c709222..0066f071d 100644
--- a/byterun/caml/backtrace.h
+++ b/byterun/caml/backtrace.h
@@ -17,17 +17,93 @@
 #include "mlvalues.h"
 #include "exec.h"
 
+/* Non zero iff backtraces are recorded.
+ * This value shouldn't be set directly, one should use instead
+ * [caml_record_backtrace] instead.
+ *
+ * It has two kind of users:
+ * - high-level functions reading it to determine whether a backtrace might be
+ *   available;
+ * - low-level runtime routines, to determine whether a backtrace should be generated
+ *   when using "raise".
+ */
 CAMLextern int caml_backtrace_active;
+
+/* Backtrace generation is split in multiple steps.
+ * The lowest-level one, done by [backtrace_prim.c] just fills the
+ * [caml_backtrace_buffer] variable each time a frame is unwinded.
+ * At that point, we don't know whether the backtrace will be useful or not so
+ * this code should be as fast as possible.
+ *
+ * If the backtrace happens to be useful, later passes will read [caml_backtrace_buffer]
+ * and turn it into a [raw_backtrace] and then a [backtrace].
+ * This is done in [backtrace.c] and [stdlib/printexc.ml].
+ *
+ * The following type, [backtrace_slot] represents values stored in the
+ * lowest-level buffer.
+ * In bytecode, it is the same as a [code_t], in native code it as a [frame_descr *].
+ * The difference doesn't matter for code outside [backtrace_prim.c], so it is
+ * just exposed has a [backtrace_slot].
+ */
+typedef void * backtrace_slot;
+
+/* The [caml_backtrace_buffer] and [caml_backtrace_last_exn]
+ * variables are valid only if caml_backtrace_active is non-null.
+ *
+ * They are part of the state specific to each thread, and threading libraries
+ * are responsible for copying them on context switch.
+ * See [otherlibs/systhreads/st_stubs.c] and [otherlibs/threads/scheduler.c].
+ */
+
+/* [caml_backtrace_buffer] is filled by runtime when unwinding stack.
+ * It is an array ranging from [0] to [caml_backtrace_pos - 1].
+ * [caml_backtrace_pos] is always zero if [!caml_backtrace_active].
+ *
+ * Its maximum size is determined by [BACKTRACE_BUFFER_SIZE] from
+ * [backtrace_prim.h] but this shouldn't affect users.
+ */
+CAMLextern backtrace_slot * caml_backtrace_buffer;
 CAMLextern int caml_backtrace_pos;
-CAMLextern code_t * caml_backtrace_buffer;
+
+/* [caml_backtrace_last_exn] stores the last exception value that was raised,
+ * iff [caml_backtrace_active].
+ * It is tested for equality to determine whether a raise is a re-raise of the
+ * same exception.
+ *
+ * FIXME: this shouldn't matter anymore. Since OCaml 4.02, non-parameterized
+ * exceptions are constant, so physical equality is no longer appropriate.
+ * raise and re-raise are distinguished by:
+ * - passing reraise = 1 to [caml_stash_backtrace] (see below) in the bytecode
+ *   interpreter;
+ * - directly resetting [caml_backtrace_pos] to 0 in native runtimes for raise.
+ */
 CAMLextern value caml_backtrace_last_exn;
-CAMLextern char * caml_cds_file;
 
+/* [caml_record_backtrace] toggle backtrace recording on and off.
+ * This function can be called at runtime by user-code, or during
+ * initialization if backtrace were requested.
+ * It is then called before initializating the GC, so it shouldn't allocate
+ * memory.
+ */
 CAMLprim value caml_record_backtrace(value vflag);
+
 #ifndef NATIVE_CODE
+/* Path to the file containing debug information, if any, or NULL. */
+CAMLextern char * caml_cds_file;
+/* Primitive called _only_ by runtime to record unwinded frames to backtrace.
+ * A similar primitive exists for native code, but with a different prototype. */
 extern void caml_stash_backtrace(value exn, code_t pc, value * sp, int reraise);
 #endif
+
+/* Default (C-level) printer for backtraces.
+ * It is called if an exception causes a termination of the program or of a thread.
+ *
+ * [Printexc] provide a higher-level printer mimicking its output but making
+ * use of registered custom exception printers, which replaces this printer
+ * when program terminates and [Printexc] was initialized.
+ */
 CAMLextern void caml_print_exception_backtrace(void);
+
 CAMLexport void caml_init_debug_info();
 
 #endif /* CAML_BACKTRACE_H */
diff --git a/byterun/caml/backtrace_prim.h b/byterun/caml/backtrace_prim.h
index 1e106ce2d..e5a93ca15 100644
--- a/byterun/caml/backtrace_prim.h
+++ b/byterun/caml/backtrace_prim.h
@@ -14,6 +14,19 @@
 #ifndef CAML_BACKTRACE_PRIM_H
 #define CAML_BACKTRACE_PRIM_H
 
+#include "backtrace.h"
+
+/* Backtrace generation is split in the two files [backtrace.c] and [backtrace_prim.c].
+ *
+ * [backtrace_prim.c] contains all backend-specific code, and has two different
+ * implementations in [byterun/backtrace_prim.c] and [asmrun/backtrace_prim.c].
+ *
+ * [backtrace.c] has a unique implementation, and rely on [backtrace_prim.c] interface
+ * to expose a uniform higher level API.
+ *
+ * This file, [backtrace_prim.h] documents the interface expected by [backtrace.c].
+ */
+
 /* Extract location information for the given raw_backtrace_slot */
 
 struct caml_loc_info {
@@ -25,12 +38,16 @@ struct caml_loc_info {
   int loc_endchr;
 };
 
+/* Check availability of debug information before extracting a trace.
+ * Relevant for bytecode, always true for native code. */
 int caml_debug_info_available(void);
-void caml_extract_location_info(code_t pc, /*out*/ struct caml_loc_info * li);
 
-/* Accessing raw_backtrace_slot values */
-value caml_raw_backtrace_slot_of_code(code_t pc);
-code_t caml_raw_backtrace_slot_code(value slot);
+/* Extract locations from backtrace_slot */
+void caml_extract_location_info(backtrace_slot pc, /*out*/ struct caml_loc_info * li);
+
+/* Expose a [backtrace_slot] as an OCaml value. */
+value caml_val_raw_backtrace_slot(backtrace_slot pc);
+backtrace_slot caml_raw_backtrace_slot_val(value slot);
 
 #define BACKTRACE_BUFFER_SIZE 1024
 
diff --git a/otherlibs/systhreads/st_stubs.c b/otherlibs/systhreads/st_stubs.c
index 02ff512c7..6ee4bbc19 100644
--- a/otherlibs/systhreads/st_stubs.c
+++ b/otherlibs/systhreads/st_stubs.c
@@ -80,7 +80,7 @@ struct caml_thread_struct {
   struct longjmp_buffer * external_raise; /* Saved external_raise */
 #endif
   int backtrace_pos;            /* Saved backtrace_pos */
-  code_t * backtrace_buffer;    /* Saved backtrace_buffer */
+  backtrace_slot * backtrace_buffer;    /* Saved backtrace_buffer */
   value backtrace_last_exn;     /* Saved backtrace_last_exn (root) */
 };
 
diff --git a/otherlibs/threads/scheduler.c b/otherlibs/threads/scheduler.c
index 585a89030..315b8d5c2 100644
--- a/otherlibs/threads/scheduler.c
+++ b/otherlibs/threads/scheduler.c
@@ -80,7 +80,7 @@ struct caml_thread_struct {
   value * sp;
   value * trapsp;
   value backtrace_pos;          /* The backtrace info for this thread */
-  code_t * backtrace_buffer;
+  backtrace_slot * backtrace_buffer;
   value backtrace_last_exn;
   value status;                 /* RUNNABLE, KILLED. etc (see below) */
   value fd;     /* File descriptor on which we're doing read or write */

