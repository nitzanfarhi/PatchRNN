commit 111ff8a61dd320445f1d5167559cf65bfc2c26ca
Author: itojun <itojun>
Date:   Tue Jun 11 17:08:37 2002 +0000

    whitespace cleanup

diff --git a/addrtoname.c b/addrtoname.c
index cb754434..186823cd 100644
--- a/addrtoname.c
+++ b/addrtoname.c
@@ -23,7 +23,7 @@
  */
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/addrtoname.c,v 1.88 2002-06-02 00:07:36 guy Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/addrtoname.c,v 1.89 2002-06-11 17:08:37 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -299,7 +299,7 @@ lookup_emem(const u_char *ep)
 }
 
 /*
- * Find the hash node that corresponds to the bytestring 'bs' 
+ * Find the hash node that corresponds to the bytestring 'bs'
  * with length 'nlen'
  */
 
@@ -458,7 +458,7 @@ linkaddr_string(const u_char *ep, const unsigned int len)
 
 	if (len == 6)	/* XXX not totally correct... */
 		return etheraddr_string(ep);
-	
+
 	tp = lookup_bytestring(ep, len);
 	if (tp->e_name)
 		return (tp->e_name);
diff --git a/ieee802_11.h b/ieee802_11.h
index ac5a6f43..42b35b1e 100644
--- a/ieee802_11.h
+++ b/ieee802_11.h
@@ -1,4 +1,4 @@
-/* @(#) $Header: /tcpdump/master/tcpdump/ieee802_11.h,v 1.3 2001-06-14 09:50:01 guy Exp $ (LBL) */
+/* @(#) $Header: /tcpdump/master/tcpdump/ieee802_11.h,v 1.4 2002-06-11 17:08:38 itojun Exp $ (LBL) */
 /*
  * Copyright (c) 2001
  *	Fortress Technologies
@@ -28,15 +28,15 @@
 #define T_DATA 0x2 /* data */
 #define T_RESV 0x3  /* reserved */
 
-#define ST_ASSOC_REQUEST   	0x0 
-#define ST_ASSOC_RESPONSE 	0x1 
-#define ST_REASSOC_REQUEST   	0x2 
-#define ST_REASSOC_RESPONSE  	0x3 
-#define ST_PROBE_REQUEST   	0x4 
-#define ST_PROBE_RESPONSE   	0x5 
+#define ST_ASSOC_REQUEST   	0x0
+#define ST_ASSOC_RESPONSE 	0x1
+#define ST_REASSOC_REQUEST   	0x2
+#define ST_REASSOC_RESPONSE  	0x3
+#define ST_PROBE_REQUEST   	0x4
+#define ST_PROBE_RESPONSE   	0x5
 /* RESERVED 			0x6  */
 /* RESERVED 			0x7  */
-#define ST_BEACON   		0x8 
+#define ST_BEACON   		0x8
 #define ST_ATIM			0x9
 #define ST_DISASSOC		0xA
 #define ST_AUTH			0xB
@@ -46,7 +46,7 @@
 /* RESERVED 			0xF  */
 
 
-#define CTRL_PS_POLL	0xA 
+#define CTRL_PS_POLL	0xA
 #define CTRL_RTS	0xB
 #define CTRL_CTS	0xC
 #define CTRL_ACK	0xD
@@ -153,7 +153,7 @@ struct tim_t {
 /* reserved 		15 */
 /* reserved 		16 */
 
-#define E_CHALLENGE 	16	
+#define E_CHALLENGE 	16
 /* reserved 		17 */
 /* reserved 		18 */
 /* reserved 		19 */
diff --git a/interface.h b/interface.h
index 4e76a470..a3c5d08b 100644
--- a/interface.h
+++ b/interface.h
@@ -18,7 +18,7 @@
  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
  *
- * @(#) $Header: /tcpdump/master/tcpdump/interface.h,v 1.185 2002-05-31 09:29:07 guy Exp $ (LBL)
+ * @(#) $Header: /tcpdump/master/tcpdump/interface.h,v 1.186 2002-06-11 17:08:38 itojun Exp $ (LBL)
  */
 
 #ifndef tcpdump_interface_h
@@ -189,11 +189,11 @@ extern const char *dnnum_string(u_short);
 
 #include <pcap.h>
 
-extern void ascii_print_with_offset(const u_char *, u_int, u_int);    
-extern void ascii_print(const u_char *, u_int);    
-extern void hex_print_with_offset(const u_char *, u_int, u_int);    
-extern void telnet_print(const u_char *, u_int);    
-extern void hex_print(const u_char *, u_int);    
+extern void ascii_print_with_offset(const u_char *, u_int, u_int);
+extern void ascii_print(const u_char *, u_int);
+extern void hex_print_with_offset(const u_char *, u_int, u_int);
+extern void telnet_print(const u_char *, u_int);
+extern void hex_print(const u_char *, u_int);
 extern int ether_encap_print(u_short, const u_char *, u_int, u_int, u_short *);
 extern int llc_print(const u_char *, u_int, u_int, const u_char *,
 	const u_char *, u_short *);
diff --git a/ipsec_doi.h b/ipsec_doi.h
index ea4567ec..e1b4d862 100644
--- a/ipsec_doi.h
+++ b/ipsec_doi.h
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -13,7 +13,7 @@
  * 3. Neither the name of the project nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -26,7 +26,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
-/* YIPS @(#)$Id: ipsec_doi.h,v 1.4 2000-10-04 03:00:29 itojun Exp $ */
+/* YIPS @(#)$Id: ipsec_doi.h,v 1.5 2002-06-11 17:08:39 itojun Exp $ */
 
 /* refer to RFC 2407 */
 
diff --git a/ipx.h b/ipx.h
index 1d6c0549..87aa31d3 100644
--- a/ipx.h
+++ b/ipx.h
@@ -1,7 +1,7 @@
 /*
- * IPX protocol formats 
+ * IPX protocol formats
  *
- * @(#) $Header: /tcpdump/master/tcpdump/ipx.h,v 1.5 2002-03-05 11:35:45 guy Exp $
+ * @(#) $Header: /tcpdump/master/tcpdump/ipx.h,v 1.6 2002-06-11 17:08:39 itojun Exp $
  */
 
 /* well-known sockets */
diff --git a/isakmp.h b/isakmp.h
index 70bc5efe..cddf5888 100644
--- a/isakmp.h
+++ b/isakmp.h
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -13,7 +13,7 @@
  * 3. Neither the name of the project nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -26,7 +26,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
-/* YIPS @(#)$Id: isakmp.h,v 1.7 2000-10-03 05:16:38 itojun Exp $ */
+/* YIPS @(#)$Id: isakmp.h,v 1.8 2002-06-11 17:08:39 itojun Exp $ */
 
 /* refer to RFC 2408 */
 
diff --git a/lane.h b/lane.h
index 1a390d30..796cdc49 100644
--- a/lane.h
+++ b/lane.h
@@ -1,6 +1,6 @@
 /*
- * Marko Kiiskila carnil@cs.tut.fi 
- * 
+ * Marko Kiiskila carnil@cs.tut.fi
+ *
  * Tampere University of Technology - Telecommunications Laboratory
  *
  * Permission to use, copy, modify and distribute this
@@ -12,15 +12,15 @@
  * documentation, and that the use of this software is
  * acknowledged in any publications resulting from using
  * the software.
- * 
+ *
  * TUT ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
  * CONDITION AND DISCLAIMS ANY LIABILITY OF ANY KIND FOR
  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS
  * SOFTWARE.
- * 
+ *
  */
 
-/* $Id: lane.h,v 1.3 2000-10-03 02:54:56 itojun Exp $ */
+/* $Id: lane.h,v 1.4 2002-06-11 17:08:39 itojun Exp $ */
 
 #ifndef ETHER_ADDR_LEN
 #define ETHER_ADDR_LEN 6
diff --git a/nameser.h b/nameser.h
index 162b4d2b..60e1dcbb 100644
--- a/nameser.h
+++ b/nameser.h
@@ -1,4 +1,4 @@
-/* @(#) $Header: /tcpdump/master/tcpdump/nameser.h,v 1.9 2001-06-27 05:40:16 guy Exp $ (LBL) */
+/* @(#) $Header: /tcpdump/master/tcpdump/nameser.h,v 1.10 2002-06-11 17:08:40 itojun Exp $ (LBL) */
 /*
  * Copyright (c) 1983, 1989, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -34,14 +34,14 @@
  *      @(#)nameser.h	8.2 (Berkeley) 2/16/94
  * -
  * Portions Copyright (c) 1993 by Digital Equipment Corporation.
- * 
+ *
  * Permission to use, copy, modify, and distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
  * copyright notice and this permission notice appear in all copies, and that
  * the name of Digital Equipment Corporation not be used in advertising or
  * publicity pertaining to distribution of the document or software without
  * specific, written prior permission.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL
  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES
  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT
@@ -231,7 +231,7 @@ typedef struct {
  */
 #define INDIR_MASK	0xc0	/* 11.... */
 #define EDNS0_MASK	0x40	/* 01.... */
-#  define EDNS0_ELT_BITLABEL 0x01 
+#  define EDNS0_ELT_BITLABEL 0x01
 
 /*
  * Structure for passing resource records around.
diff --git a/oakley.h b/oakley.h
index 27178e0a..d1f49c8c 100644
--- a/oakley.h
+++ b/oakley.h
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -13,7 +13,7 @@
  * 3. Neither the name of the project nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -26,7 +26,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
-/* YIPS @(#)$Id: oakley.h,v 1.1 1999-10-30 05:11:10 itojun Exp $ */
+/* YIPS @(#)$Id: oakley.h,v 1.2 2002-06-11 17:08:40 itojun Exp $ */
 
 /* refer to RFC 2409 */
 
diff --git a/ospf6.h b/ospf6.h
index 92eae766..ba166ddc 100644
--- a/ospf6.h
+++ b/ospf6.h
@@ -1,4 +1,4 @@
-/* @(#) $Header: /tcpdump/master/tcpdump/ospf6.h,v 1.3 2000-12-17 23:07:50 guy Exp $ (LBL) */
+/* @(#) $Header: /tcpdump/master/tcpdump/ospf6.h,v 1.4 2002-06-11 17:08:40 itojun Exp $ (LBL) */
 /*
  * Copyright (c) 1991, 1993, 1994, 1995, 1996, 1997
  *	The Regents of the University of California.  All rights reserved.
@@ -153,7 +153,7 @@ struct lsa {
 	/* AS external links advertisements */
 	struct {
 	    u_int32_t asla_metric;
-	    struct lsa_prefix asla_prefix[1]; 
+	    struct lsa_prefix asla_prefix[1];
 	    /* some optional fields follow */
 	} un_asla;
 
diff --git a/print-802_11.c b/print-802_11.c
index f563fa15..592736fb 100644
--- a/print-802_11.c
+++ b/print-802_11.c
@@ -22,7 +22,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-802_11.c,v 1.7 2002-05-13 08:30:19 guy Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-802_11.c,v 1.8 2002-06-11 17:08:41 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -817,7 +817,7 @@ ieee802_11_if_print(u_char *user, const struct pcap_pkthdr *h, const u_char *p)
 
 	case T_DATA:
 		/* There may be a problem w/ AP not having this bit set */
- 		if (FC_WEP(fc)) {
+		if (FC_WEP(fc)) {
 			if (!wep_print(p,length)) {
 				printf("[|802.11]");
 				goto out;
diff --git a/print-ah.c b/print-ah.c
index 6450295b..554e0621 100644
--- a/print-ah.c
+++ b/print-ah.c
@@ -23,7 +23,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-ah.c,v 1.15 2001-09-17 21:57:54 fenner Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-ah.c,v 1.16 2002-06-11 17:08:41 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -67,7 +67,7 @@ ah_print(register const u_char *bp, register const u_char *bp2)
 	if (bp + sizeof(struct ah) + sumlen > ep)
 		fputs("[truncated]", stdout);
 	fputs("): ", stdout);
-	
+
 	return sizeof(struct ah) + sumlen;
  trunc:
 	fputs("[|AH]", stdout);
diff --git a/print-arcnet.c b/print-arcnet.c
index 5fa1497e..1a95d535 100644
--- a/print-arcnet.c
+++ b/print-arcnet.c
@@ -17,12 +17,12 @@
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- * 
+ *
  * From: NetBSD: print-arcnet.c,v 1.2 2000/04/24 13:02:28 itojun Exp
  */
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-arcnet.c,v 1.7 2002-06-01 23:50:30 guy Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-arcnet.c,v 1.8 2002-06-11 17:08:41 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
diff --git a/print-ascii.c b/print-ascii.c
index 14616aae..405621b4 100644
--- a/print-ascii.c
+++ b/print-ascii.c
@@ -42,7 +42,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-     "@(#) $Header: /tcpdump/master/tcpdump/print-ascii.c,v 1.7 2002-04-24 06:55:55 guy Exp $";
+     "@(#) $Header: /tcpdump/master/tcpdump/print-ascii.c,v 1.8 2002-06-11 17:08:42 itojun Exp $";
 #endif
 #include <stdio.h>
 #include <sys/types.h>
@@ -56,7 +56,7 @@ static const char rcsid[] =
 #define HEXDUMP_HEXSTUFF_PER_SHORT 5 /* 4 hex digits and a space */
 #define HEXDUMP_HEXSTUFF_PER_LINE \
 		(HEXDUMP_HEXSTUFF_PER_SHORT * HEXDUMP_SHORTS_PER_LINE)
-     
+
 void
 ascii_print_with_offset(register const u_char *cp, register u_int length,
 			register u_int oset)
@@ -131,7 +131,7 @@ ascii_print(register const u_char *cp, register u_int length)
 {
 	ascii_print_with_offset(cp, length, 0);
 }
-	
+
 /*
  * telnet_print() wants this.  It is essentially default_print_unaligned()
  */
diff --git a/print-beep.c b/print-beep.c
index dd9cadcf..e33945cc 100644
--- a/print-beep.c
+++ b/print-beep.c
@@ -1,8 +1,8 @@
 /*
  * Copyright (C) 2000, Richard Sharpe
  *
- * This software may be distributed either under the terms of the 
- * BSD-style licence that accompanies tcpdump or under the GNU GPL 
+ * This software may be distributed either under the terms of the
+ * BSD-style licence that accompanies tcpdump or under the GNU GPL
  * version 2 or later.
  *
  * print-beep.c
@@ -11,7 +11,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-  "@(#) $Header: /tcpdump/master/tcpdump/print-beep.c,v 1.1 2001-12-10 08:21:24 guy Exp $";
+  "@(#) $Header: /tcpdump/master/tcpdump/print-beep.c,v 1.2 2002-06-11 17:08:42 itojun Exp $";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -34,7 +34,7 @@ static const char rcsid[] =
 
 /* Check for a string but not go beyond length
  * Return TRUE on match, FALSE otherwise
- * 
+ *
  * Looks at the first few chars up to tl1 ...
  */
 
@@ -68,6 +68,6 @@ beep_print(const u_char *bp, u_int length)
 		printf(" BEEP SEQ");
 	else if (l_strnstart("END", 4, bp, length))
 		printf(" BEEP END");
-	else 
+	else
 		printf(" BEEP (payload or undecoded)");
 }
diff --git a/print-bgp.c b/print-bgp.c
index 04fab003..14eb508d 100644
--- a/print-bgp.c
+++ b/print-bgp.c
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 1999 WIDE Project.
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -13,7 +13,7 @@
  * 3. Neither the name of the project nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -33,7 +33,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-     "@(#) $Header: /tcpdump/master/tcpdump/print-bgp.c,v 1.29 2002-05-24 17:49:29 hannes Exp $";
+     "@(#) $Header: /tcpdump/master/tcpdump/print-bgp.c,v 1.30 2002-06-11 17:08:43 itojun Exp $";
 #endif
 
 #include <sys/param.h>
@@ -654,14 +654,14 @@ bgp_update_print(const u_char *dat, int length)
 	         */
 #ifdef INET6
 		printf(" (Withdrawn routes: %d bytes)", len);
-#else	
+#else
 		char buf[MAXHOSTNAMELEN + 100];
 
 		TCHECK2(p[2], len);
- 		i = 2;
+		i = 2;
 
 		printf(" (Withdrawn routes:");
-			
+
 		while(i < 2 + len) {
 			i += decode_prefix4(&p[i], buf, sizeof(buf));
 			printf(" %s", buf);
@@ -707,7 +707,7 @@ bgp_update_print(const u_char *dat, int length)
 			newline = 1;
 
 			/* ( */
-			printf(")");	
+			printf(")");
 
 			i += aoff + alen;
 		}
@@ -791,8 +791,8 @@ bgp_print(const u_char *dat, int length)
 	const u_char *ep;
 	const u_char *start;
 	const u_char marker[] = {
-		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
-		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
+		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
 	};
 	struct bgp bgp;
 	u_int16_t hlen;
diff --git a/print-bootp.c b/print-bootp.c
index ac18ac08..c2fab5e9 100644
--- a/print-bootp.c
+++ b/print-bootp.c
@@ -22,7 +22,7 @@
  */
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-bootp.c,v 1.62 2002-06-01 23:50:30 guy Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-bootp.c,v 1.63 2002-06-11 17:08:43 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -580,7 +580,7 @@ rfc1048_print(register const u_char *bp)
 				size--;
 				if (type == 0) {
 					putchar('"');
-					(void)fn_printn(bp, size, NULL);  
+					(void)fn_printn(bp, size, NULL);
 					putchar('"');
 					break;
 				} else {
diff --git a/print-cdp.c b/print-cdp.c
index 6a41973d..c291989d 100644
--- a/print-cdp.c
+++ b/print-cdp.c
@@ -26,7 +26,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-cdp.c,v 1.13 2002-04-26 09:51:34 guy Exp $";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-cdp.c,v 1.14 2002-06-11 17:08:44 itojun Exp $";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -130,7 +130,7 @@ cdp_print(const u_char *p, u_int length, u_int caplen,
 			printf(" Duplex: %s", p[i + 4] ? "full": "half");
 			break;
 /* http://www.cisco.com/univercd/cc/td/doc/product/voice/ata/atarn/186rn21m.htm
- * plus more details from other sources 
+ * plus more details from other sources
  */
 		case 0x0e:		/* incomplete doc. */
 			printf(" ATA-186 VoIP VLAN request, app %d, vlan %d",
@@ -140,7 +140,7 @@ cdp_print(const u_char *p, u_int length, u_int caplen,
 			printf(" ATA-186 VoIP VLAN assignment" );
 			break;
 		case 0x10:		/* incomplete doc. */
-			printf(" power consumption: %1.2fW", 
+			printf(" power consumption: %1.2fW",
 				cdp_get_number(p+i+4, len-4)/1000.0 );
 			break;
 		case 0x11:		/* guess - not documented */
@@ -242,7 +242,7 @@ cdp_print_addr(const u_char * p, int l)
 			 * protocol = LLC+SNAP header with the IPv6
 			 * Ethertype, address length = 16
 			 */
-			p += 10; 
+			p += 10;
 			if (p + al > endp)
 				goto trunc;
 
diff --git a/print-cip.c b/print-cip.c
index 28102325..1fc931ad 100644
--- a/print-cip.c
+++ b/print-cip.c
@@ -1,6 +1,6 @@
 /*
- * Marko Kiiskila carnil@cs.tut.fi 
- * 
+ * Marko Kiiskila carnil@cs.tut.fi
+ *
  * Tampere University of Technology - Telecommunications Laboratory
  *
  * Permission to use, copy, modify and distribute this
@@ -12,17 +12,17 @@
  * documentation, and that the use of this software is
  * acknowledged in any publications resulting from using
  * the software.
- * 
+ *
  * TUT ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
  * CONDITION AND DISCLAIMS ANY LIABILITY OF ANY KIND FOR
  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS
  * SOFTWARE.
- * 
+ *
  */
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-cip.c,v 1.16 2001-09-23 21:52:38 guy Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-cip.c,v 1.17 2002-06-11 17:08:44 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -47,7 +47,7 @@ static const char rcsid[] =
 #include "ethertype.h"
 #include "ether.h"
 
-#define RFC1483LLC_LEN	8 
+#define RFC1483LLC_LEN	8
 
 static unsigned char rfcllc[] = {
 	0xaa,	/* DSAP: non-ISO */
diff --git a/print-dhcp6.c b/print-dhcp6.c
index 2a570ff1..066759ae 100644
--- a/print-dhcp6.c
+++ b/print-dhcp6.c
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 1998 and 1999 WIDE Project.
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -13,7 +13,7 @@
  * 3. Neither the name of the project nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -32,7 +32,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-dhcp6.c,v 1.17 2002-06-01 23:50:30 guy Exp $";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-dhcp6.c,v 1.18 2002-06-11 17:08:44 itojun Exp $";
 #endif
 
 #ifdef HAVE_CONFIG_H
diff --git a/print-esp.c b/print-esp.c
index 95724508..606a26da 100644
--- a/print-esp.c
+++ b/print-esp.c
@@ -23,7 +23,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-esp.c,v 1.24 2002-04-07 02:16:03 guy Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-esp.c,v 1.25 2002-06-11 17:08:45 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -198,7 +198,7 @@ esp_print(register const u_char *bp, register const u_char *bp2,
 #ifdef HAVE_LIBCRYPTO
 	u_char *p;
 #endif
-	
+
 	esp = (struct esp *)bp;
 	spi = (u_int32_t)ntohl(esp->esp_spi);
 	secret = NULL;
diff --git a/print-ether.c b/print-ether.c
index 3f3b3a59..8ac9487b 100644
--- a/print-ether.c
+++ b/print-ether.c
@@ -20,7 +20,7 @@
  */
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-ether.c,v 1.69 2002-06-01 23:50:31 guy Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-ether.c,v 1.70 2002-06-11 17:08:45 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -239,8 +239,8 @@ ether_encap_print(u_short ethertype, const u_char *p,
 	case ETHERTYPE_PPPOED:
 	case ETHERTYPE_PPPOES:
 		pppoe_print(p, length);
- 		return (1);
- 
+		return (1);
+
 	case ETHERTYPE_PPP:
 		printf("ppp");
 		if (length) {
diff --git a/print-gre.c b/print-gre.c
index aa05dc58..29b17857 100644
--- a/print-gre.c
+++ b/print-gre.c
@@ -24,7 +24,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-gre.c,v 1.14 2002-06-01 23:50:31 guy Exp $";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-gre.c,v 1.15 2002-06-11 17:08:46 itojun Exp $";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -108,7 +108,7 @@ gre_print(const u_char *bp, u_int length)
 			printf("R%x", (flags & GRE_RECUR_MASK) >> GRE_RECUR_SHIFT);
 		ver = flags & GRE_VER_MASK;
 		printf("v%u", ver);
-		
+
 		if (flags & GRE_MBZ_MASK)
 			printf("!%x", flags & GRE_MBZ_MASK);
 		fputs("] ", stdout);
@@ -143,7 +143,7 @@ gre_print(const u_char *bp, u_int length)
 				printf("PL:%u ", EXTRACT_16BITS(cp));
 			printf("ID:%04x ", EXTRACT_16BITS(cp+2));
 		}
-		else 
+		else
 			printf("K:%08x ", EXTRACT_32BITS(cp));
 		cp += 4;	/* skip key */
 	}
@@ -166,7 +166,7 @@ gre_print(const u_char *bp, u_int length)
 	length -= cp - bp;
 	if (ether_encap_print(proto, cp, length, length,
 	    &extracted_ethertype) == 0)
- 		printf("gre-proto-0x%04X", proto);
+		printf("gre-proto-0x%04X", proto);
 	return;
 
 trunc:
diff --git a/print-hsrp.c b/print-hsrp.c
index ccb6866b..0d3e4287 100644
--- a/print-hsrp.c
+++ b/print-hsrp.c
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 2001 Julian Cowley
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -13,7 +13,7 @@
  * 3. Neither the name of the project nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -31,7 +31,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-hsrp.c,v 1.3 2002-05-07 18:31:49 fenner Exp $";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-hsrp.c,v 1.4 2002-06-11 17:08:47 itojun Exp $";
 #endif
 
 #ifdef HAVE_CONFIG_H
diff --git a/print-icmp.c b/print-icmp.c
index 681c735f..ed3689f7 100644
--- a/print-icmp.c
+++ b/print-icmp.c
@@ -21,7 +21,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-icmp.c,v 1.64 2002-06-01 23:50:32 guy Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-icmp.c,v 1.65 2002-06-11 17:08:48 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -68,7 +68,7 @@ struct icmp {
 
 		/* ICMP_UNREACH_NEEDFRAG -- Path MTU Discovery (RFC1191) */
 		struct ih_pmtu {
-			u_int16_t ipm_void;    
+			u_int16_t ipm_void;
 			u_int16_t ipm_nextmtu;
 		} ih_pmtu;
 	} icmp_hun;
@@ -282,16 +282,16 @@ icmp_print(const u_char *bp, u_int plen, const u_char *bp2)
 
 	TCHECK(dp->icmp_code);
 	switch (dp->icmp_type) {
-	
+
 	case ICMP_ECHO:
 		TCHECK(dp->icmp_seq);
-		(void)snprintf(buf, sizeof(buf), "echo request seq %u", 
+		(void)snprintf(buf, sizeof(buf), "echo request seq %u",
 			(unsigned)ntohs(dp->icmp_seq));
 		break;
 
 	case ICMP_ECHOREPLY:
 		TCHECK(dp->icmp_seq);
-		(void)snprintf(buf, sizeof(buf), "echo reply seq %u", 
+		(void)snprintf(buf, sizeof(buf), "echo reply seq %u",
 			(unsigned)ntohs(dp->icmp_seq));
 		break;
 
@@ -490,13 +490,13 @@ icmp_print(const u_char *bp, u_int plen, const u_char *bp2)
 				printf(" (wrong icmp csum)");
 		}
 	}
- 	if (vflag > 1 && !ICMP_INFOTYPE(dp->icmp_type)) {
- 		bp += 8;
- 		(void)printf(" for ");
- 		ip = (struct ip *)bp;
- 		snaplen = snapend - bp;
- 		ip_print(bp, ntohs(ip->ip_len));
- 	}
+	if (vflag > 1 && !ICMP_INFOTYPE(dp->icmp_type)) {
+		bp += 8;
+		(void)printf(" for ");
+		ip = (struct ip *)bp;
+		snaplen = snapend - bp;
+		ip_print(bp, ntohs(ip->ip_len));
+	}
 	return;
 trunc:
 	fputs("[|icmp]", stdout);
diff --git a/print-icmp6.c b/print-icmp6.c
index 71323c7d..0b13305a 100644
--- a/print-icmp6.c
+++ b/print-icmp6.c
@@ -21,7 +21,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-icmp6.c,v 1.60 2002-05-30 22:01:34 itojun Exp $";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-icmp6.c,v 1.61 2002-06-11 17:08:48 itojun Exp $";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -567,7 +567,7 @@ icmp6_opt_print(const u_char *bp, int resid)
 			    (u_int32_t)ntohl(opa->nd_opt_adv_interval));
 			/*(*/
 			printf(")");
-			break;                
+			break;
 		case ND_OPT_HOMEAGENT_INFO:
 			oph = (struct nd_opt_homeagent_info *)op;
 			TCHECK(oph->nd_opt_hai_lifetime);
@@ -575,7 +575,7 @@ icmp6_opt_print(const u_char *bp, int resid)
 			printf(" pref=%d", ntohs(oph->nd_opt_hai_preference));
 			printf(", lifetime=%u", ntohs(oph->nd_opt_hai_lifetime));
 			printf(")");
-			break;                
+			break;
 		case ND_OPT_ROUTE_INFO:
 			opri = (struct nd_opt_route_info *)op;
 			TCHECK(opri->nd_opt_rti_lifetime);
diff --git a/print-igmp.c b/print-igmp.c
index d8403e90..1e10d0b7 100644
--- a/print-igmp.c
+++ b/print-igmp.c
@@ -21,7 +21,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-igmp.c,v 1.6 2002-06-02 18:24:41 guy Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-igmp.c,v 1.7 2002-06-11 17:08:49 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -109,7 +109,7 @@ static struct tok igmpv3report2str[] = {
 	{ 0,	NULL }
 };
 
-static void 
+static void
 print_mtrace(register const u_char *bp, register u_int len)
 {
     register const struct tr_query *tr = (const struct tr_query *)(bp + 8);
@@ -122,7 +122,7 @@ print_mtrace(register const u_char *bp, register u_int len)
         printf(" with-ttl %d", TR_GETTTL(ntohl(tr->tr_rttlqid)));
 }
 
-static void 
+static void
 print_mresp(register const u_char *bp, register u_int len)
 {
     register const struct tr_query *tr = (const struct tr_query *)(bp + 8);
@@ -135,7 +135,7 @@ print_mresp(register const u_char *bp, register u_int len)
         printf(" with-ttl %d", TR_GETTTL(ntohl(tr->tr_rttlqid)));
 }
 
-static void 
+static void
 print_igmpv3_report(register const u_char *bp, register u_int len)
 {
     u_int group, nsrcs, ngroups;
@@ -143,15 +143,15 @@ print_igmpv3_report(register const u_char *bp, register u_int len)
 
     /* Minimum len is 16, and should be a multiple of 4 */
     if (len < 16 || len & 0x03) {
-    	(void)printf(" [invalid len %d]", len);
-    	return;
+	(void)printf(" [invalid len %d]", len);
+	return;
     }
     TCHECK2(bp[6], 2);
     ngroups = EXTRACT_16BITS(&bp[6]);
-    (void)printf(", %d group record(s)", ngroups); 
+    (void)printf(", %d group record(s)", ngroups);
     if (vflag > 0) {
 	/* Print the group records */
-    	group = 8;
+	group = 8;
         for (i=0; i<ngroups; i++) {
 	    if (len < group+8) {
 		(void)printf(" [invalid number of groups]");
@@ -200,8 +200,8 @@ print_igmpv3_query(register const u_char *bp, register u_int len)
     (void)printf(" v3");
     /* Minimum len is 12, and should be a multiple of 4 */
     if (len < 12 || len & 0x03) {
-    	(void)printf(" [invalid len %d]", len);
-    	return;
+	(void)printf(" [invalid len %d]", len);
+	return;
     }
     mrc = bp[1];
     if (mrc < 128) {
@@ -261,7 +261,7 @@ igmp_print(register const u_char *bp, register u_int len)
 		    (void)printf(" [max resp time %d]", bp[1]);
 	    } else
 		(void)printf(" v1");
-       	    if (EXTRACT_32BITS(&bp[4]))
+	    if (EXTRACT_32BITS(&bp[4]))
                 (void)printf(" [gaddr %s]", ipaddr_string(&bp[4]));
             if (len != 8)
                 (void)printf(" [len %d]", len);
diff --git a/print-ip.c b/print-ip.c
index c24f5d52..cf6a5d1e 100644
--- a/print-ip.c
+++ b/print-ip.c
@@ -21,7 +21,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-ip.c,v 1.104 2002-05-29 09:47:04 guy Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-ip.c,v 1.105 2002-06-11 17:08:49 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -109,7 +109,7 @@ ip_printts(register const u_char *cp, u_int length)
 	case 3:			/* IPOPT_TS_PRESPEC */
 		printf("PRESPEC");
 		break;
-	default:	
+	default:
 		printf("[bad ts type %d]", cp[3]&0xF);
 		goto done;
 	}
@@ -225,12 +225,12 @@ in_cksum(const u_short *addr, register u_int len, int csum)
 	u_short answer;
 	int sum = csum;
 
- 	/*
+	/*
 	 *  Our algorithm is simple, using a 32 bit accumulator (sum),
 	 *  we add sequential 16 bit words to it, and at the end, fold
 	 *  back all the carry bits from the top 16 bits into the lower
 	 *  16 bits.
- 	 */
+	 */
 	while (nleft > 1)  {
 		sum += *w++;
 		nleft -= 2;
@@ -367,7 +367,7 @@ again:
 		    }
 
 		case IPPROTO_SCTP:
-  			sctp_print(cp, (const u_char *)ip, len);
+			sctp_print(cp, (const u_char *)ip, len);
 			break;
 
 		case IPPROTO_TCP:
@@ -470,9 +470,9 @@ again:
 		}
 	}
 
- 	/* Ultra quiet now means that all this stuff should be suppressed */
- 	/* res 3-Nov-98 */
- 	if (qflag > 1) return;
+	/* Ultra quiet now means that all this stuff should be suppressed */
+	/* res 3-Nov-98 */
+	if (qflag > 1) return;
 
 
 	/*
diff --git a/print-ip6.c b/print-ip6.c
index d1593995..41cbf928 100644
--- a/print-ip6.c
+++ b/print-ip6.c
@@ -21,7 +21,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-ip6.c,v 1.21 2001-11-16 02:17:36 itojun Exp $";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-ip6.c,v 1.22 2002-06-11 17:08:50 itojun Exp $";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -60,7 +60,7 @@ ip6_print(register const u_char *bp, register u_int length)
 	int nh;
 	int fragmented = 0;
 	u_int flow;
-	
+
 	ip6 = (const struct ip6_hdr *)bp;
 
 #ifdef LBL_ALIGN
@@ -195,7 +195,7 @@ ip6_print(register const u_char *bp, register u_int length)
 	}
 
  end:
-	
+
 	flow = ntohl(ip6->ip6_flow);
 #if 0
 	/* rfc1883 */
diff --git a/print-ip6opts.c b/print-ip6opts.c
index 07124068..47c818f5 100644
--- a/print-ip6opts.c
+++ b/print-ip6opts.c
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 1998 WIDE Project.
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -13,7 +13,7 @@
  * 3. Neither the name of the project nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -33,7 +33,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-     "@(#) $Header: /tcpdump/master/tcpdump/print-ip6opts.c,v 1.10 2002-03-28 10:02:35 guy Exp $";
+     "@(#) $Header: /tcpdump/master/tcpdump/print-ip6opts.c,v 1.11 2002-06-11 17:08:50 itojun Exp $";
 #endif
 
 #ifdef INET6
diff --git a/print-isakmp.c b/print-isakmp.c
index bb741ff4..b438ee72 100644
--- a/print-isakmp.c
+++ b/print-isakmp.c
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -13,7 +13,7 @@
  * 3. Neither the name of the project nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -30,7 +30,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-isakmp.c,v 1.30 2002-06-01 23:50:32 guy Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-isakmp.c,v 1.31 2002-06-11 17:08:50 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
diff --git a/print-isoclns.c b/print-isoclns.c
index 055c3ce6..6ff06da1 100644
--- a/print-isoclns.c
+++ b/print-isoclns.c
@@ -26,7 +26,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-isoclns.c,v 1.50 2002-05-31 23:23:35 hannes Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-isoclns.c,v 1.51 2002-06-11 17:08:51 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -52,7 +52,7 @@ static const char rcsid[] =
 #define	NLPID_ESIS	130	/* 0x82 */
 #define	NLPID_ISIS	131	/* 0x83 */
 #define NLPID_IP6       0x8e
-#define NLPID_IP        0xcc  
+#define NLPID_IP        0xcc
 #define	NLPID_NULLNS	0
 
 /*
@@ -79,13 +79,13 @@ static const char rcsid[] =
 
 static struct tok isis_pdu_values[] = {
     { L1_LAN_IIH,       "L1 Lan IIH"},
-    { L2_LAN_IIH,       "L2 Lan IIH"},           
-    { PTP_IIH,          "p2p IIH"},           
-    { L1_LSP,           "L1 LSP"},           
-    { L2_LSP,           "L2 LSP"},          
-    { L1_CSNP,          "L1 CSNP"},   
+    { L2_LAN_IIH,       "L2 Lan IIH"},
+    { PTP_IIH,          "p2p IIH"},
+    { L1_LSP,           "L1 LSP"},
+    { L2_LSP,           "L2 LSP"},
+    { L1_CSNP,          "L1 CSNP"},
     { L2_CSNP,          "L2 CSNP"},
-    { L1_PSNP,          "L1 PSNP"},   
+    { L1_PSNP,          "L1 PSNP"},
     { L2_PSNP,          "L2 PSNP"},
     { 0, NULL}
 };
@@ -125,7 +125,7 @@ static struct tok isis_pdu_values[] = {
 #define TLV_HOSTNAME            137
 #define TLV_SHARED_RISK_GROUP   138
 #define TLV_NORTEL_PRIVATE1     176
-#define TLV_NORTEL_PRIVATE2     177   
+#define TLV_NORTEL_PRIVATE2     177
 #define TLV_RESTART_SIGNALING   211
 #define TLV_MT_IS_REACH         222
 #define TLV_MT_SUPPORTED        229
@@ -137,41 +137,41 @@ static struct tok isis_pdu_values[] = {
 
 static struct tok isis_tlv_values[] = {
     { TLV_AREA_ADDR,	     "Area address(es)"},
-    { TLV_IS_REACH,          "IS Reachability"},           
-    { TLV_ESNEIGH,           "ES Neighbor(s)"},           
-    { TLV_PART_DIS,          "Partition DIS"},           
-    { TLV_PREFIX_NEIGH,      "Prefix Neighbors"},          
-    { TLV_ISNEIGH,           "IS Neighbor(s)"},   
+    { TLV_IS_REACH,          "IS Reachability"},
+    { TLV_ESNEIGH,           "ES Neighbor(s)"},
+    { TLV_PART_DIS,          "Partition DIS"},
+    { TLV_PREFIX_NEIGH,      "Prefix Neighbors"},
+    { TLV_ISNEIGH,           "IS Neighbor(s)"},
     { TLV_ISNEIGH_VARLEN,    "IS Neighbor(s) (variable length)"},
-    { TLV_PADDING,           "Padding"},            
-    { TLV_LSP,               "LSP entries"},            
-    { TLV_AUTH,              "Authentication"},               
-    { TLV_CHECKSUM,          "Checksum"}, 
-    { TLV_LSP_BUFFERSIZE,    "LSP Buffersize"},    
-    { TLV_EXT_IS_REACH,      "Extended IS Reachability"}, 
+    { TLV_PADDING,           "Padding"},
+    { TLV_LSP,               "LSP entries"},
+    { TLV_AUTH,              "Authentication"},
+    { TLV_CHECKSUM,          "Checksum"},
+    { TLV_LSP_BUFFERSIZE,    "LSP Buffersize"},
+    { TLV_EXT_IS_REACH,      "Extended IS Reachability"},
     { TLV_IS_ALIAS_ID,       "IS Alias ID"},
-    { TLV_DECNET_PHASE4,     "DECnet Phase IV"},     
-    { TLV_LUCENT_PRIVATE,    "Lucent Proprietary"},     
-    { TLV_IP_REACH,          "IPv4 Internal reachability"}, 
-    { TLV_PROTOCOLS,         "Protocols supported"}, 
-    { TLV_IP_REACH_EXT,      "IPv4 External reachability"}, 
-    { TLV_IDRP_INFO,         "Inter-Domain Information Type"}, 
-    { TLV_IPADDR,            "IPv4 Interface address(es)"},            
-    { TLV_IPAUTH,            "IPv4 authentication (deprecated)"},            
-    { TLV_TE_ROUTER_ID,      "Traffic Engineering Router ID"}, 
-    { TLV_EXT_IP_REACH,      "Extended IPv4 reachability"}, 
-    { TLV_HOSTNAME,          "Hostname"}, 
-    { TLV_SHARED_RISK_GROUP, "Shared Risk Link Group"},  
-    { TLV_NORTEL_PRIVATE1,   "Nortel Proprietary"},   
-    { TLV_NORTEL_PRIVATE2,   "Nortel Proprietary"},   
-    { TLV_RESTART_SIGNALING, "Restart Signaling"}, 
-    { TLV_MT_IS_REACH,       "Multi Topology IS Reachability"}, 
-    { TLV_MT_SUPPORTED,      "Multi Topology"}, 
-    { TLV_IP6ADDR,           "IPv6 Interface address(es)"},           
-    { TLV_MT_IP_REACH,       "Multi-Topology IPv4 reachability"}, 
-    { TLV_IP6_REACH,         "IPv6 reachability"}, 
-    { TLV_MT_IP6_REACH,      "Multi-Topology IP6 reachability"},      
-    { TLV_PTP_ADJ,           "Point-to-point Adjacency State"}, 
+    { TLV_DECNET_PHASE4,     "DECnet Phase IV"},
+    { TLV_LUCENT_PRIVATE,    "Lucent Proprietary"},
+    { TLV_IP_REACH,          "IPv4 Internal reachability"},
+    { TLV_PROTOCOLS,         "Protocols supported"},
+    { TLV_IP_REACH_EXT,      "IPv4 External reachability"},
+    { TLV_IDRP_INFO,         "Inter-Domain Information Type"},
+    { TLV_IPADDR,            "IPv4 Interface address(es)"},
+    { TLV_IPAUTH,            "IPv4 authentication (deprecated)"},
+    { TLV_TE_ROUTER_ID,      "Traffic Engineering Router ID"},
+    { TLV_EXT_IP_REACH,      "Extended IPv4 reachability"},
+    { TLV_HOSTNAME,          "Hostname"},
+    { TLV_SHARED_RISK_GROUP, "Shared Risk Link Group"},
+    { TLV_NORTEL_PRIVATE1,   "Nortel Proprietary"},
+    { TLV_NORTEL_PRIVATE2,   "Nortel Proprietary"},
+    { TLV_RESTART_SIGNALING, "Restart Signaling"},
+    { TLV_MT_IS_REACH,       "Multi Topology IS Reachability"},
+    { TLV_MT_SUPPORTED,      "Multi Topology"},
+    { TLV_IP6ADDR,           "IPv6 Interface address(es)"},
+    { TLV_MT_IP_REACH,       "Multi-Topology IPv4 reachability"},
+    { TLV_IP6_REACH,         "IPv6 reachability"},
+    { TLV_MT_IP6_REACH,      "Multi-Topology IP6 reachability"},
+    { TLV_PTP_ADJ,           "Point-to-point Adjacency State"},
     { 0, NULL }
 };
 
@@ -213,7 +213,7 @@ static struct tok isis_subtlv_idrp_values[] = {
     { 0, NULL}
 };
 
-#define ISIS_8BIT_MASK(x)                  ((x)&0xff) 
+#define ISIS_8BIT_MASK(x)                  ((x)&0xff)
 
 #define ISIS_MASK_LSP_OL_BIT(x)            ((x)&0x4)
 #define ISIS_MASK_LSP_ISTYPE_BITS(x)       ((x)&0x3)
@@ -340,7 +340,7 @@ struct isis_tlv_ptp_adj {
     u_char adjacency_state;
     u_char extd_local_circuit_id[4];
     u_char neighbor_sysid[SYSTEM_ID_LEN];
-    u_char neighbor_extd_local_circuit_id[4]; 
+    u_char neighbor_extd_local_circuit_id[4];
 };
 
 static int osi_cksum(const u_char *, u_int);
@@ -431,7 +431,7 @@ struct isis_tlv_lsp {
     u_char sequence_number[4];
     u_char checksum[2];
 };
-    
+
 #define ISIS_COMMON_HEADER_SIZE (sizeof(struct isis_common_header))
 #define ISIS_IIH_LAN_HEADER_SIZE (sizeof(struct isis_iih_lan_header))
 #define ISIS_IIH_PTP_HEADER_SIZE (sizeof(struct isis_iih_ptp_header))
@@ -444,7 +444,7 @@ void isoclns_print(const u_char *p, u_int length, u_int caplen,
 {
 	u_char pdu_type;
 	const struct isis_common_header *header;
-	
+
 	header = (const struct isis_common_header *)p;
 	pdu_type = header->pdu_type & PDU_TYPE_MASK;
 
@@ -772,7 +772,7 @@ static int
 isis_print_unknown_data(const u_char *cp,const char *lf,int len)
 {
         int i;
-	
+
 	printf("%s0x0000: ",lf);
 	for(i=0;i<len;i++) {
 	    if (!TTEST2(*(cp+i), 1))
@@ -862,11 +862,11 @@ isis_print_tlv_ip_reach (const u_char *cp, int length)
 		 * 34 indicates no match -> must be a discontiguous netmask
 		 * lets dump the mask, otherwise print the prefix_len
 		 */
-		if (prefix_len == 34) 
+		if (prefix_len == 34)
 			printf("\n\t\t\tIPv4 prefix: %s mask %s",
 			       ipaddr_string((tlv_ip_reach->prefix)),
 			       ipaddr_string((tlv_ip_reach->mask)));
-		else 
+		else
 			printf("\n\t\t\tIPv4 prefix: %s/%u",
 			       ipaddr_string((tlv_ip_reach->prefix)),
 			       prefix_len);
@@ -930,7 +930,7 @@ isis_print_ip_reach_subtlv (const u_char *tptr,int subt,int subl,const char *lf)
                                        subl))
                 return(0);
             break;
-        }	
+        }
         return(1);
 
 trunctlv:
@@ -975,16 +975,16 @@ isis_print_is_reach_subtlv (const u_char *tptr,int subt,int subl,const char *lf)
             if (!TTEST2(*tptr,4))
                 goto trunctlv;
             j = EXTRACT_32BITS(tptr);
-            memcpy (&bw, &j, 4);            
+            memcpy (&bw, &j, 4);
             printf("%sMaximum link bandwidth : %.3f Mbps",
                    lf,
                    bw*8/1000000 );
-            break;                            
+            break;
         case SUBTLV_EXT_IS_REACH_RESERVABLE_BW :
             if (!TTEST2(*tptr,4))
                 goto trunctlv;
             j = EXTRACT_32BITS(tptr);
-            memcpy (&bw, &j, 4); 
+            memcpy (&bw, &j, 4);
             printf("%sReservable link bandwidth: %.3f Mbps",
                    lf,
                    bw*8/1000000  );
@@ -995,27 +995,27 @@ isis_print_is_reach_subtlv (const u_char *tptr,int subt,int subl,const char *lf)
                 if (!TTEST2(*(tptr+i*4),4))
                     goto trunctlv;
                 j = EXTRACT_32BITS(tptr);
-                memcpy (&bw, &j, 4); 	
+                memcpy (&bw, &j, 4);
                 printf("%s  priority level %d: %.3f Mbps",
                        lf,
                        i,
                        bw*8/1000000 );
             }
-            break;      
+            break;
         case SUBTLV_EXT_IS_REACH_TE_METRIC:
             if (!TTEST2(*tptr,3))
                 goto trunctlv;
             printf("%sTraffic Engineering Metric: %d",
                    lf,
                    EXTRACT_24BITS(tptr));
-            break;                            
+            break;
         case SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR:
             if (!TTEST2(*tptr,4))
                 goto trunctlv;
             printf("%sIPv4 interface address: %s",
                    lf,
                    ipaddr_string(tptr));
-            break;	
+            break;
         case SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR:
             if (!TTEST2(*tptr,4))
                 goto trunctlv;
@@ -1064,7 +1064,7 @@ isis_print_is_reach_subtlv (const u_char *tptr,int subt,int subl,const char *lf)
                 if (!TTEST2(*(tptr+(i*4)+4),4))
                     goto trunctlv;
                 j = EXTRACT_32BITS(tptr);
-                memcpy (&bw, &j, 4); 	
+                memcpy (&bw, &j, 4);
                 printf("%s    priority level %d: %.3f Mbps",
                        lf,
                        i,
@@ -1094,7 +1094,7 @@ isis_print_is_reach_subtlv (const u_char *tptr,int subt,int subl,const char *lf)
                    lf,
                    subt,
                    subl);
-            break;                                 
+            break;
         default:
             printf("%sunknown subTLV, type %d, length %d",
                    lf,
@@ -1104,7 +1104,7 @@ isis_print_is_reach_subtlv (const u_char *tptr,int subt,int subl,const char *lf)
                                        subl))
                 return(0);
             break;
-        }	
+        }
         return(1);
 
 trunctlv:
@@ -1144,15 +1144,15 @@ static int isis_print (const u_char *p, u_int length)
     packet_len=length;
     optr = p; /* initialize the _o_riginal pointer to the packet start -
                need it for parsing the checksum TLV */
-    header = (const struct isis_common_header *)p; 
+    header = (const struct isis_common_header *)p;
     TCHECK(*header);
-    pptr = p+(ISIS_COMMON_HEADER_SIZE);    
+    pptr = p+(ISIS_COMMON_HEADER_SIZE);
     header_iih_lan = (const struct isis_iih_lan_header *)pptr;
     header_iih_ptp = (const struct isis_iih_ptp_header *)pptr;
     header_lsp = (const struct isis_lsp_header *)pptr;
     header_csnp = (const struct isis_csnp_header *)pptr;
     header_psnp = (const struct isis_psnp_header *)pptr;
-    
+
     /*
      * Sanity checking of the header.
      */
@@ -1171,7 +1171,7 @@ static int isis_print (const u_char *p, u_int length)
 	       header->id_length);
 	return (0);
     }
-    
+
     if (header->pkt_version != ISIS_VERSION) {
 	printf(", version %d packet not supported", header->pkt_version);
 	return (0);
@@ -1194,7 +1194,7 @@ static int isis_print (const u_char *p, u_int length)
     case 0:
         id_length = 6;	 /* silly shit again */
 	break;
-    case 1:              /* 1-8 are valid sys-ID lenghts */               
+    case 1:              /* 1-8 are valid sys-ID lenghts */
     case 2:
     case 3:
     case 4:
@@ -1207,7 +1207,7 @@ static int isis_print (const u_char *p, u_int length)
         id_length = 0;   /* entirely useless */
 	break;
     default:
-	printf(", bad packet -- illegal sys-ID length (%u)", id_length);      
+	printf(", bad packet -- illegal sys-ID length (%u)", id_length);
 	return (0);
 	break;
     }
@@ -1219,7 +1219,7 @@ static int isis_print (const u_char *p, u_int length)
 	   header->id_length,
            max_area,
            header->max_area);
-           
+
     pdu_type=header->pdu_type;
 
     /* first lets see if we know the PDU name*/
@@ -1227,10 +1227,10 @@ static int isis_print (const u_char *p, u_int length)
            tok2str(isis_pdu_values,
                    "unknown PDU, type %d",
                    pdu_type));
-     
+
     switch (pdu_type) {
 
-    case L1_LAN_IIH:    
+    case L1_LAN_IIH:
     case L2_LAN_IIH:
 	if (header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE)) {
 	    printf(", bogus fixed header length %u should be %lu",
@@ -1255,7 +1255,7 @@ static int isis_print (const u_char *p, u_int length)
 	printf("\n\t\t  lan-id:    %s, Priority: %u, PDU length: %u",
                isis_print_nodeid(header_iih_lan->lan_id),
                (header_iih_lan->priority) & PRIORITY_MASK,
-               pdu_len);            
+               pdu_len);
 
 	packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE);
 	pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE);
@@ -1267,13 +1267,13 @@ static int isis_print (const u_char *p, u_int length)
 		   header->fixed_len, (unsigned long)ISIS_IIH_PTP_HEADER_SIZE);
 	    return (0);
 	}
-	
+
 	pdu_len=EXTRACT_16BITS(header_iih_ptp->pdu_len);
 	if (packet_len>pdu_len) {
 	  packet_len=pdu_len; /* do TLV decoding as long as it makes sense */
 	  length=pdu_len;
 	}
-	
+
 	TCHECK(*header_iih_ptp);
 	printf("\n\t\t  source-id: %s, holding time: %us, circuit-id: 0x%02x, %s, PDU length: %u",
                isis_print_sysid(header_iih_ptp->source_id,SYSTEM_ID_LEN),
@@ -1295,7 +1295,7 @@ static int isis_print (const u_char *p, u_int length)
 		   header->fixed_len, (unsigned long)ISIS_LSP_HEADER_SIZE);
 	    return (0);
 	}
-	
+
 	pdu_len=EXTRACT_16BITS(header_lsp->pdu_len);
 	if (packet_len>pdu_len) {
 	  packet_len=pdu_len; /* do TLV decoding as long as it makes sense */
@@ -1314,7 +1314,7 @@ static int isis_print (const u_char *p, u_int length)
                EXTRACT_16BITS(header_lsp->checksum),
                (osi_cksum(optr+12, length-12)) ? "incorrect" : "correct",
                pdu_len);
-	      
+
 	printf(", %s", ISIS_MASK_LSP_OL_BIT(header_lsp->typeblock) ? "Overload bit set, " : "");
 
 	if (ISIS_MASK_LSP_ATT_BITS(header_lsp->typeblock)) {
@@ -1338,7 +1338,7 @@ static int isis_print (const u_char *p, u_int length)
 		   header->fixed_len, (unsigned long)ISIS_CSNP_HEADER_SIZE);
 	    return (0);
 	}
-	
+
 	pdu_len=EXTRACT_16BITS(header_csnp->pdu_len);
 	if (packet_len>pdu_len) {
 	  packet_len=pdu_len; /* do TLV decoding as long as it makes sense */
@@ -1348,9 +1348,9 @@ static int isis_print (const u_char *p, u_int length)
 	TCHECK(*header_csnp);
 	printf("\n\t\t  source-id:    %s, PDU length: %u",
                isis_print_nodeid(header_csnp->source_id),
-               pdu_len);		
+               pdu_len);
 	printf("\n\t\t  start lsp-id: %s",
-               isis_print_lspid(header_csnp->start_lsp_id));	
+               isis_print_lspid(header_csnp->start_lsp_id));
 	printf("\n\t\t  end lsp-id:   %s",
                isis_print_lspid(header_csnp->end_lsp_id));
 
@@ -1374,22 +1374,22 @@ static int isis_print (const u_char *p, u_int length)
 
 	TCHECK(*header_psnp);
 	printf("\n\t\t  source-id:    %s",
-               isis_print_nodeid(header_psnp->source_id)); 
- 
+               isis_print_nodeid(header_psnp->source_id));
+
 	packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE);
 	pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE);
 	break;
 
     default:
 	if(!isis_print_unknown_data(pptr,"\n\t\t  ",length))
-	    return(0);	
+	    return(0);
 	return (0);
     }
 
     /*
      * Now print the TLV's.
      */
-    
+
     while (packet_len >= 2) {
         if (pptr == snapend) {
 	    return (1);
@@ -1408,7 +1408,7 @@ static int isis_print (const u_char *p, u_int length)
 	if (len > packet_len) {
 	    break;
 	}
-        
+
         /* first lets see if we know the TLVs name*/
 	printf("\n\t\t    %s TLV #%u, length: %u",
                tok2str(isis_tlv_values,
@@ -1478,7 +1478,7 @@ static int isis_print (const u_char *p, u_int length)
                 tptr+=2;
                 if (!TTEST2(*tptr, NODE_ID_LEN))
 		    goto trunctlv;
-            	printf("\n\t\t\t  IS Neighbor: %s", isis_print_nodeid(tptr));
+	printf("\n\t\t\t  IS Neighbor: %s", isis_print_nodeid(tptr));
                 tptr+=(NODE_ID_LEN);
                 if (!TTEST2(*tptr, 3))
                     goto trunctlv;
@@ -1489,19 +1489,19 @@ static int isis_print (const u_char *p, u_int length)
                 tslen=*(tptr++);
                 printf(", %ssub-TLVs present",tslen ? "" : "no ");
                 if (tslen) {
-                    printf(" (%u)",tslen);                    
+                    printf(" (%u)",tslen);
                     while (tslen>0) {
                         if (!TTEST2(*tptr,2))
                             goto trunctlv;
-                    	subt=*(tptr++);
-                    	subl=*(tptr++);
+	subt=*(tptr++);
+	subl=*(tptr++);
 			if(!isis_print_is_reach_subtlv(tptr,subt,subl,"\n\t\t\t  "))
 			    return(0);
 			tptr+=subl;
 			tslen-=(subl+2);
                         tmp-=(subl+2);
                     }
-                }	
+                }
                 tmp-=(SYSTEM_ID_LEN+7);
             }
             break;
@@ -1510,7 +1510,7 @@ static int isis_print (const u_char *p, u_int length)
             while (tmp>0) {
                 if (!TTEST2(*tptr, NODE_ID_LEN))
                     goto trunctlv;
-            	printf("\n\t\t\tIS Neighbor: %s", isis_print_nodeid(tptr));
+	printf("\n\t\t\tIS Neighbor: %s", isis_print_nodeid(tptr));
                 tptr+=(NODE_ID_LEN);
 
                 if (!TTEST2(*tptr, 3))
@@ -1523,19 +1523,19 @@ static int isis_print (const u_char *p, u_int length)
                 tslen=*(tptr++); /* read out subTLV length */
                 printf(", %ssub-TLVs present",tslen ? "" : "no ");
                 if (tslen) {
-                    printf(" (%u)",tslen);                    
+                    printf(" (%u)",tslen);
                     while (tslen>0) {
                         if (!TTEST2(*tptr,2))
                             goto trunctlv;
-                    	subt=*(tptr++);
-                    	subl=*(tptr++);
+	subt=*(tptr++);
+	subl=*(tptr++);
 			if(!isis_print_is_reach_subtlv(tptr,subt,subl,"\n\t\t\t  "))
 			    return(0);
 			tptr+=subl;
 			tslen-=(subl+2);
                         tmp-=(subl+2);
                     }
-                }	
+                }
                 tmp-=(SYSTEM_ID_LEN+5);
             }
             break;
@@ -1607,7 +1607,7 @@ static int isis_print (const u_char *p, u_int length)
 		    return (1);
 		memcpy(prefix,tptr,byte_length);
                 tptr+=byte_length;
-		printf("\n\t\t\tIPv4 prefix: %s/%d", 
+		printf("\n\t\t\tIPv4 prefix: %s/%d",
 		       ipaddr_string(prefix),
 		       bit_length);
 
@@ -1627,13 +1627,13 @@ static int isis_print (const u_char *p, u_int length)
 		      return (1);
                     tslen=*(tptr++);
                     tmp--;
-		    printf(" (%u)",tslen);   /* print out subTLV length */	    
+		    printf(" (%u)",tslen);   /* print out subTLV length */
 
                     while (tslen>0) {
                         if (!TTEST2(*tptr,2))
                             goto trunctlv;
-                    	subt=*(tptr++);
-                    	subl=*(tptr++);
+	subt=*(tptr++);
+	subl=*(tptr++);
 			if(!isis_print_ip_reach_subtlv(tptr,subt,subl,"\n\t\t\t  "))
 			    return(0);
 			tptr+=subl;
@@ -1663,7 +1663,7 @@ static int isis_print (const u_char *p, u_int length)
 		    return (1);
 		memcpy(prefix,tptr,byte_length);
                 tptr+=byte_length;
-		printf("\n\t\t\tIPv4 prefix: %s/%d", 
+		printf("\n\t\t\tIPv4 prefix: %s/%d",
 		       ipaddr_string(prefix),
 		       bit_length);
 
@@ -1683,13 +1683,13 @@ static int isis_print (const u_char *p, u_int length)
 		      return (1);
                     tslen=*(tptr++);
                     tmp--;
-		    printf(" (%u)",tslen);   /* print out subTLV length */	    
+		    printf(" (%u)",tslen);   /* print out subTLV length */
 
                     while (tslen>0) {
                         if (!TTEST2(*tptr,2))
                             goto trunctlv;
-                    	subt=*(tptr++);
-                    	subl=*(tptr++);
+	subt=*(tptr++);
+	subl=*(tptr++);
 			if(!isis_print_ip_reach_subtlv(tptr,subt,subl,"\n\t\t\t  "))
 			    return(0);
 			tptr+=subl;
@@ -1737,16 +1737,16 @@ static int isis_print (const u_char *p, u_int length)
                        the aggregate bytecount of the subTLVs for this prefix
                      */
 		    if (!TTEST2(*tptr, 1))
-		      return (1);		      
+		      return (1);
                     tslen=*(tptr++);
                     tmp--;
-		    printf(" (%u)",tslen);   /* print out subTLV length */	    
+		    printf(" (%u)",tslen);   /* print out subTLV length */
 
                     while (tslen>0) {
                         if (!TTEST2(*tptr,2))
                             goto trunctlv;
-                    	subt=*(tptr++);
-                    	subl=*(tptr++);
+	subt=*(tptr++);
+	subl=*(tptr++);
 			if(!isis_print_ip_reach_subtlv(tptr,subt,subl,"\n\t\t\t  "))
 			    return(0);
 			tptr+=subl;
@@ -1803,7 +1803,7 @@ static int isis_print (const u_char *p, u_int length)
 	    case SUBTLV_AUTH_PRIVATE:
 	    default:
 		if(!isis_print_unknown_data(tptr+1,"\n\t\t\t    ",len-1))
-		    return(0);	
+		    return(0);
 		break;
 	    }
 	    break;
@@ -1904,19 +1904,19 @@ static int isis_print (const u_char *p, u_int length)
 	      goto trunctlv;
 	    printf("\n\t\t\tIPv4 neighbor address: %s", ipaddr_string(tptr));
 	    tptr+=4;
-	    len-=4;	    
+	    len-=4;
 
 	    while (tmp>0) {
 	      if (!TTEST2(*tptr, 4))
-		goto trunctlv;      
+		goto trunctlv;
 	      printf("\n\t\t\tLink-ID: 0x%08x", EXTRACT_32BITS(tptr));
 	      tptr+=4;
-	      len-=4;	
+	      len-=4;
 	    }
 	    break;
 
-	case TLV_LSP:    
-	    tlv_lsp = (const struct isis_tlv_lsp *)tptr; 
+	case TLV_LSP:
+	    tlv_lsp = (const struct isis_tlv_lsp *)tptr;
 	    while(tmp>0) {
 		printf("\n\t\t\tlsp-id: %s",
                        isis_print_nodeid(tlv_lsp->lsp_id));
@@ -1940,14 +1940,14 @@ static int isis_print (const u_char *p, u_int length)
 	case TLV_CHECKSUM:
 	    if (!TTEST2(*tptr, 2))
 		goto trunctlv;
-	    printf("\n\t\t\tchecksum: 0x%04x (%s)", 
+	    printf("\n\t\t\tchecksum: 0x%04x (%s)",
 		   EXTRACT_16BITS(tptr),
                    (osi_cksum(optr, length)) ? "incorrect" : "correct");
 	    break;
 
 	case TLV_MT_SUPPORTED:
 	    while (tmp>1) {
-		/* length can only be a multiple of 2, otherwise there is 
+		/* length can only be a multiple of 2, otherwise there is
 		   something broken -> so decode down until length is 1 */
 		if (tmp!=1) {
 		    if (!TTEST2(*tptr, 2))
@@ -1972,7 +1972,7 @@ static int isis_print (const u_char *p, u_int length)
 
 	case TLV_RESTART_SIGNALING:
             if (!TTEST2(*tptr, 3))
-                goto trunctlv;    
+                goto trunctlv;
 	    rr = ISIS_MASK_TLV_RESTART_RR(*tptr);
 	    ra = ISIS_MASK_TLV_RESTART_RA(*tptr);
 	    tptr++;
@@ -1987,7 +1987,7 @@ static int isis_print (const u_char *p, u_int length)
             printf("\n\t\t\tInter-Domain Information Type: %s",
                    tok2str(isis_subtlv_idrp_values,
                            "Unknown (0x%02x)",
-                           *tptr));            
+                           *tptr));
             switch (*tptr++) {
             case SUBTLV_IDRP_ASN:
                 if (!TTEST2(*tptr, 2)) /* fetch AS number */
@@ -2005,7 +2005,7 @@ static int isis_print (const u_char *p, u_int length)
 
         case TLV_LSP_BUFFERSIZE:
             if (!TTEST2(*tptr, 2))
-                goto trunctlv;            
+                goto trunctlv;
                 printf("LSP Buffersize: %u",EXTRACT_16BITS(tptr));
             break;
 
@@ -2026,14 +2026,14 @@ static int isis_print (const u_char *p, u_int length)
             isis_print_metric_block((const struct isis_metric_block *)tptr);
             tptr+=sizeof(struct isis_metric_block);
             tmp-=sizeof(struct isis_metric_block);
-            
+
             while(tmp>0) {
                 if (!TTEST2(*tptr, 1))
                     goto trunctlv;
                 prefix_len=*tptr++; /* read out prefix length in semioctets*/
                 tmp--;
                 if (!TTEST2(*tptr, prefix_len/2))
-                    goto trunctlv;                
+                    goto trunctlv;
                 printf("\n\t\t\tAddress: %s/%u",
                        print_nsap(tptr,prefix_len/2),
                        prefix_len*4);
diff --git a/print-l2tp.c b/print-l2tp.c
index 67a3059a..0cfaa938 100644
--- a/print-l2tp.c
+++ b/print-l2tp.c
@@ -23,7 +23,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-l2tp.c,v 1.11 2002-05-25 09:41:07 guy Exp $";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-l2tp.c,v 1.12 2002-06-11 17:08:51 itojun Exp $";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -146,27 +146,27 @@ static struct tok l2tp_avp2str[] = {
 	{ L2TP_AVP_MAXIMUM_BPS,		"MAXIMUM_BPS" },
 	{ L2TP_AVP_BEARER_TYPE,		"BEARER_TYPE" },
 	{ L2TP_AVP_FRAMING_TYPE,	"FRAMING_TYPE" },
-	{ L2TP_AVP_PACKET_PROC_DELAY,	"PACKET_PROC_DELAY" },	
+	{ L2TP_AVP_PACKET_PROC_DELAY,	"PACKET_PROC_DELAY" },
 	{ L2TP_AVP_CALLED_NUMBER,	"CALLED_NUMBER" },
 	{ L2TP_AVP_CALLING_NUMBER,	"CALLING_NUMBER" },
 	{ L2TP_AVP_SUB_ADDRESS,		"SUB_ADDRESS" },
 	{ L2TP_AVP_TX_CONN_SPEED,	"TX_CONN_SPEED" },
 	{ L2TP_AVP_PHY_CHANNEL_ID,	"PHY_CHANNEL_ID" },
 	{ L2TP_AVP_INI_RECV_LCP,	"INI_RECV_LCP" },
-	{ L2TP_AVP_LAST_SENT_LCP,	"LAST_SENT_LCP" },	
-	{ L2TP_AVP_LAST_RECV_LCP,	"LAST_RECV_LCP" },	
-	{ L2TP_AVP_PROXY_AUTH_TYPE,	"PROXY_AUTH_TYPE" }, 	
+	{ L2TP_AVP_LAST_SENT_LCP,	"LAST_SENT_LCP" },
+	{ L2TP_AVP_LAST_RECV_LCP,	"LAST_RECV_LCP" },
+	{ L2TP_AVP_PROXY_AUTH_TYPE,	"PROXY_AUTH_TYPE" },
 	{ L2TP_AVP_PROXY_AUTH_NAME,	"PROXY_AUTH_NAME" },
-	{ L2TP_AVP_PROXY_AUTH_CHAL,	"PROXY_AUTH_CHAL" },	
+	{ L2TP_AVP_PROXY_AUTH_CHAL,	"PROXY_AUTH_CHAL" },
 	{ L2TP_AVP_PROXY_AUTH_ID,	"PROXY_AUTH_ID" },
 	{ L2TP_AVP_PROXY_AUTH_RESP,	"PROXY_AUTH_RESP" },
 	{ L2TP_AVP_CALL_ERRORS,		"CALL_ERRORS" },
-	{ L2TP_AVP_ACCM,		"ACCM" },		
-	{ L2TP_AVP_RANDOM_VECTOR,	"RANDOM_VECTOR" },	
+	{ L2TP_AVP_ACCM,		"ACCM" },
+	{ L2TP_AVP_RANDOM_VECTOR,	"RANDOM_VECTOR" },
 	{ L2TP_AVP_PRIVATE_GRP_ID,	"PRIVATE_GRP_ID" },
-	{ L2TP_AVP_RX_CONN_SPEED,	"RX_CONN_SPEED" }, 	
-	{ L2TP_AVP_SEQ_REQUIRED,	"SEQ_REQUIRED" }, 	
-	{ L2TP_AVP_PPP_DISCON_CC,	"PPP_DISCON_CC" },	
+	{ L2TP_AVP_RX_CONN_SPEED,	"RX_CONN_SPEED" },
+	{ L2TP_AVP_SEQ_REQUIRED,	"SEQ_REQUIRED" },
+	{ L2TP_AVP_PPP_DISCON_CC,	"PPP_DISCON_CC" },
 	{ 0,				NULL }
 };
 
@@ -243,7 +243,7 @@ static char *l2tp_error_code_general[] = {
 /******************************/
 /* generic print out routines */
 /******************************/
-static void 
+static void
 print_string(const u_char *dat, u_int length)
 {
 	int i;
@@ -252,7 +252,7 @@ print_string(const u_char *dat, u_int length)
 	}
 }
 
-static void 
+static void
 print_octets(const u_char *dat, u_int length)
 {
 	int i;
@@ -289,7 +289,7 @@ static void
 l2tp_result_code_print(const u_char *dat, u_int length)
 {
 	u_int16_t *ptr = (u_int16_t *)dat;
-	
+
 	printf("%u", EXTRACT_16BITS(ptr)); ptr++;	/* Result Code */
 	if (length > 2) {				/* Error Code (opt) */
 	        printf("/%u", EXTRACT_16BITS(ptr)); ptr++;
@@ -341,7 +341,7 @@ l2tp_q931_cc_print(const u_char *dat, u_int length)
 	if (length > 3) {
 		printf(" ");
 		print_string(dat+3, length-3);
-	} 
+	}
 }
 
 static void
@@ -381,7 +381,7 @@ l2tp_proxy_auth_type_print(const u_char *dat)
 {
 	u_int16_t *ptr = (u_int16_t *)dat;
 
-	printf("%s", tok2str(l2tp_authentype2str, 
+	printf("%s", tok2str(l2tp_authentype2str,
 			     "AuthType-#%u", EXTRACT_16BITS(ptr)));
 }
 
@@ -398,7 +398,7 @@ l2tp_call_errors_print(const u_char *dat)
 {
 	u_int16_t *ptr = (u_int16_t *)dat;
 	u_int16_t val_h, val_l;
-	
+
 	ptr++;		/* skip "Reserved" */
 
 	val_h = EXTRACT_16BITS(ptr); ptr++;
@@ -437,7 +437,7 @@ l2tp_accm_print(const u_char *dat)
 	val_h = EXTRACT_16BITS(ptr); ptr++;
 	val_l = EXTRACT_16BITS(ptr); ptr++;
 	printf("send=%08x ", (val_h<<16) + val_l);
-	
+
 	val_h = EXTRACT_16BITS(ptr); ptr++;
 	val_l = EXTRACT_16BITS(ptr); ptr++;
 	printf("recv=%08x ", (val_h<<16) + val_l);
@@ -447,10 +447,10 @@ static void
 l2tp_ppp_discon_cc_print(const u_char *dat, u_int length)
 {
 	u_int16_t *ptr = (u_int16_t *)dat;
-	
+
 	printf("%04x, ", EXTRACT_16BITS(ptr)); ptr++;	/* Disconnect Code */
 	printf("%04x ",  EXTRACT_16BITS(ptr)); ptr++;	/* Control Protocol Number */
-	printf("%s", tok2str(l2tp_cc_direction2str, 
+	printf("%s", tok2str(l2tp_cc_direction2str,
 			     "Direction-#%u", *((u_char *)ptr++)));
 
 	if (length > 5) {
@@ -476,7 +476,7 @@ l2tp_avp_print(const u_char *dat, int length)
 	TCHECK(*ptr);	/* Flags & Length */
 	len = EXTRACT_16BITS(ptr) & L2TP_AVP_HDR_LEN_MASK;
 
-	/* If it is not long enough to decode the entire AVP, we'll 
+	/* If it is not long enough to decode the entire AVP, we'll
 	   abandon. */
 	TCHECK2(*ptr, len);
 	/* After this point, no need to worry about truncation */
@@ -498,7 +498,7 @@ l2tp_avp_print(const u_char *dat, int length)
 		print_octets((u_char *)ptr, len-6);
 		printf(")");
 	} else {
-		/* IETF-defined Attributes */ 
+		/* IETF-defined Attributes */
 		ptr++;
 		attr_type = EXTRACT_16BITS(ptr); ptr++;
 		printf("%s", tok2str(l2tp_avp2str, "AVP-#%u", attr_type));
@@ -537,7 +537,7 @@ l2tp_avp_print(const u_char *dat, int length)
 			case L2TP_AVP_CALLED_NUMBER:
 			case L2TP_AVP_SUB_ADDRESS:
 			case L2TP_AVP_PROXY_AUTH_NAME:
-			case L2TP_AVP_PRIVATE_GRP_ID:	
+			case L2TP_AVP_PRIVATE_GRP_ID:
 				print_string((u_char *)ptr, len-6);
 				break;
 			case L2TP_AVP_CHALLENGE:
@@ -651,7 +651,7 @@ l2tp_print(const u_char *dat, u_int length)
 
 	ptr++;
 	cnt += 2;
-	
+
 	if (flag_l) {
 		TCHECK(*ptr);	/* Length */
 		l2tp_len = EXTRACT_16BITS(ptr); ptr++;
@@ -699,4 +699,4 @@ l2tp_print(const u_char *dat, u_int length)
 
  trunc:
 	printf("%s", tstr);
-}	
+}
diff --git a/print-lane.c b/print-lane.c
index 2836f788..329e1d57 100644
--- a/print-lane.c
+++ b/print-lane.c
@@ -1,6 +1,6 @@
 /*
- * Marko Kiiskila carnil@cs.tut.fi 
- * 
+ * Marko Kiiskila carnil@cs.tut.fi
+ *
  * Tampere University of Technology - Telecommunications Laboratory
  *
  * Permission to use, copy, modify and distribute this
@@ -12,17 +12,17 @@
  * documentation, and that the use of this software is
  * acknowledged in any publications resulting from using
  * the software.
- * 
+ *
  * TUT ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
  * CONDITION AND DISCLAIMS ANY LIABILITY OF ANY KIND FOR
  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS
  * SOFTWARE.
- * 
+ *
  */
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-lane.c,v 1.12 2001-07-05 18:54:15 guy Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-lane.c,v 1.13 2002-06-11 17:08:51 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
diff --git a/print-lcp.c b/print-lcp.c
index 06346025..a40b7b54 100644
--- a/print-lcp.c
+++ b/print-lcp.c
@@ -21,7 +21,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-"@(#) $Header: /tcpdump/master/tcpdump/Attic/print-lcp.c,v 1.9 2000-10-06 04:23:12 guy Exp $ (LBL)";
+"@(#) $Header: /tcpdump/master/tcpdump/Attic/print-lcp.c,v 1.10 2002-06-11 17:08:52 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -43,7 +43,7 @@ static const char rcsid[] =
 #include "ppp.h"
 
 /* Codes */
-enum { 
+enum {
   LCP_CONFREQ = 1,
   LCP_CONFACK = 2,
   LCP_CONFNAK = 3,
@@ -122,18 +122,18 @@ lcp_print(register const u_char *bp, u_int length)
   const u_char *lcp_data;
 
   lcp_data = bp+4;
-	
+
   if (snapend < lcp_data) {
     printf(" [LCP|]");
     return;
   }
-  
+
   lcp_code  = bp[0];
   lcp_id    = bp[1];
   lcp_length = EXTRACT_16BITS(bp+2);
 
   printf("LCP %s id=0x%x", tok2str(lcpcode2str, "LCP-#%d", lcp_code), lcp_id);
-  
+
   switch (lcp_code) {
   case LCP_CONFREQ:
   case LCP_CONFACK:
@@ -159,7 +159,7 @@ lcp_print(register const u_char *bp, u_int length)
 	    if (snapend < p+2) return;
 	    printf("%s",tok2str(lcpauth2str, "AUTH-%#x", ntohs(*(u_short*)p)));
 	    if (lcpopt_length < 4) printf(" len=%d!",lcpopt_length);
-	    if (lcpopt_length >= 5 && p < snapend) 
+	    if (lcpopt_length >= 5 && p < snapend)
 	      printf(" %s",tok2str(lcpchap2str, "%#x", p[0]));
 	    break;
 	  case LCP_QUALPROTO:
@@ -211,6 +211,6 @@ lcp_print(register const u_char *bp, u_int length)
   default:
     break;
   }
-  
+
   return;
 }
diff --git a/print-mobile.c b/print-mobile.c
index e767beb3..ec72f8bf 100644
--- a/print-mobile.c
+++ b/print-mobile.c
@@ -42,7 +42,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-     "@(#) $Header: /tcpdump/master/tcpdump/print-mobile.c,v 1.8 2002-06-01 23:50:32 guy Exp $";
+     "@(#) $Header: /tcpdump/master/tcpdump/print-mobile.c,v 1.9 2002-06-11 17:08:52 itojun Exp $";
 #endif
 
 #include <sys/param.h>
@@ -94,7 +94,7 @@ mobile_print(const u_char *bp, u_int length)
 		osp=1;
 		cp +=4 ;
 	}
-	
+
 	if (osp)  {
 		fputs("[S] ",stdout);
 		if (vflag)
diff --git a/print-nfs.c b/print-nfs.c
index 1c9dfb85..cc2441b0 100644
--- a/print-nfs.c
+++ b/print-nfs.c
@@ -21,7 +21,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-nfs.c,v 1.93 2002-06-01 23:50:32 guy Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-nfs.c,v 1.94 2002-06-11 17:08:52 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -168,7 +168,7 @@ static struct tok type2str[] = {
  *
  * Assume that a system that has INT64_FORMAT defined, has a 64-bit
  * integer datatype and can print it.
- */ 
+ */
 
 #define UNSIGNED 0
 #define SIGNED   1
@@ -783,7 +783,7 @@ nfs_printfh(register const u_int32_t *dp, const u_int len)
 	}
 
 	if(fsid.Fsid_dev.Minor == 257 && uflag)
-		/* Print the undecoded handle */ 
+		/* Print the undecoded handle */
 		(void)printf("%s", fsid.Opaque_Handle);
 	else
 		(void)printf("%ld", (long) ino);
@@ -884,7 +884,7 @@ xid_map_find(const struct rpc_msg *rp, const u_char *bp, u_int32_t *proc,
 	int cmp;
 
 	/* Start searching from where we last left off */
-	i = xid_map_hint; 
+	i = xid_map_hint;
 	do {
 		xmep = &xid_map[i];
 		cmp = 1;
diff --git a/print-ospf6.c b/print-ospf6.c
index b7fe99f4..ec18eace 100644
--- a/print-ospf6.c
+++ b/print-ospf6.c
@@ -23,7 +23,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-ospf6.c,v 1.7 2001-05-09 01:08:03 fenner Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-ospf6.c,v 1.8 2002-06-11 17:08:53 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -241,7 +241,7 @@ ospf6_print_lsaprefix(register const struct lsa_prefix *lsapp)
 	}
 	memset(&prefix, 0, sizeof(prefix));
 	memcpy(&prefix, lsapp->lsa_p_prefix, k * 4);
-	printf(" %s/%d", ip6addr_string(&prefix), 
+	printf(" %s/%d", ip6addr_string(&prefix),
 		lsapp->lsa_p_len);
 	if (lsapp->lsa_p_opt)
 		printf("(opt=%x)", lsapp->lsa_p_opt);
@@ -379,7 +379,7 @@ ospf6_print_lsa(register const struct lsa *lsap)
 
 			if ((flags32 & ASLA_FLAG_ROUTETAG) != 0) {
 				TCHECK(*(u_int32_t *)ls_opt);
-				printf(" tag %s", 
+				printf(" tag %s",
 				       ipaddr_string((u_int32_t *)ls_opt));
 
 				ls_opt += sizeof(u_int32_t);
diff --git a/print-pim.c b/print-pim.c
index fa9307c7..d6c7fe52 100644
--- a/print-pim.c
+++ b/print-pim.c
@@ -21,7 +21,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-pim.c,v 1.30 2002-05-07 18:28:38 fenner Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-pim.c,v 1.31 2002-06-11 17:08:53 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -586,7 +586,7 @@ pimv2_print(register const u_char *bp, register u_int len)
 
 			case 18:	/* Old DR-Priority */
 				if (olen == 4)
-					(void)printf(" (OLD-DR-Priority: %d)", 
+					(void)printf(" (OLD-DR-Priority: %d)",
 							EXTRACT_32BITS(&bp[4]));
 				else
 					goto unknown;
diff --git a/print-ppp.c b/print-ppp.c
index 59789853..03892a67 100644
--- a/print-ppp.c
+++ b/print-ppp.c
@@ -31,7 +31,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-ppp.c,v 1.66 2002-05-29 10:32:02 guy Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-ppp.c,v 1.67 2002-06-11 17:08:54 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -99,7 +99,7 @@ static const char *cpcodes[] = {
 	"Conf-Rej",	/* (4) */
 	"Term-Req",	/* (5) */
 	"Term-Ack",	/* (6) */
- 	"Code-Rej",	/* (7) */
+	"Code-Rej",	/* (7) */
 	"Prot-Rej",	/* (8) */
 	"Echo-Req",	/* (9) */
 	"Echo-Rep",	/* (10) */
diff --git a/print-pptp.c b/print-pptp.c
index 685c1c0d..4e81f132 100644
--- a/print-pptp.c
+++ b/print-pptp.c
@@ -23,8 +23,8 @@
 
 
 #ifndef lint
-static const char rcsid[] = 
-     "@(#) $Header: /tcpdump/master/tcpdump/print-pptp.c,v 1.3 2001-10-31 08:54:31 guy Exp $";
+static const char rcsid[] =
+     "@(#) $Header: /tcpdump/master/tcpdump/print-pptp.c,v 1.4 2002-06-11 17:08:54 itojun Exp $";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -55,7 +55,7 @@ static char tstr[] = " [|pptp]";
 
 #define PPTP_CTRL_MSG_TYPE_SCCRQ	1
 #define PPTP_CTRL_MSG_TYPE_SCCRP	2
-#define PPTP_CTRL_MSG_TYPE_StopCCRQ	3 
+#define PPTP_CTRL_MSG_TYPE_StopCCRQ	3
 #define PPTP_CTRL_MSG_TYPE_StopCCRP	4
 #define PPTP_CTRL_MSG_TYPE_ECHORQ	5
 #define PPTP_CTRL_MSG_TYPE_ECHORP	6
@@ -185,8 +185,8 @@ struct pptp_msg_icrq {
 	u_int16_t call_ser;
 	u_int32_t bearer_type;
 	u_int32_t phy_chan_id;
-	u_int16_t dialed_no_len;		
-	u_int16_t dialing_no_len;		
+	u_int16_t dialed_no_len;
+	u_int16_t dialing_no_len;
 	u_char dialed_no[64];		/* DNIS */
 	u_char dialing_no[64];		/* CLID */
 	u_char subaddr[64];
@@ -245,7 +245,7 @@ struct pptp_msg_sli {
 
 /* attributes that appear more than once in above messages:
 
-   Number of         
+   Number of
    occurence    attributes
   --------------------------------------
       2         u_int32_t bearer_cap;
@@ -272,7 +272,7 @@ struct pptp_msg_sli {
       2         u_char subaddr[64];
       2         u_char vendor[64];
 
-  so I will prepare print out functions for these attributes (except for 
+  so I will prepare print out functions for these attributes (except for
   reserved*).
 */
 
@@ -308,7 +308,7 @@ pptp_bearer_type_print(const u_int32_t *bearer_type)
 	case 2:
 		printf("D");	/* Digital */
 		break;
-	case 3: 
+	case 3:
 		printf("Any");
 		break;
 	default:
@@ -707,7 +707,7 @@ pptp_echorq_print(const u_char *dat)
 
 	TCHECK(ptr->id);
 	pptp_id_print(&ptr->id);
-	
+
 	return;
 
 trunc:
@@ -726,7 +726,7 @@ pptp_echorp_print(const u_char *dat)
 	TCHECK(ptr->err_code);
 	pptp_err_code_print(&ptr->err_code);
 	TCHECK(ptr->reserved1);
-	
+
 	return;
 
 trunc:
@@ -832,7 +832,7 @@ static void
 pptp_icrp_print(const u_char *dat)
 {
 	struct pptp_msg_icrp *ptr = (struct pptp_msg_icrp *)dat;
-	
+
 	TCHECK(ptr->call_id);
 	pptp_call_id_print(&ptr->call_id);
 	TCHECK(ptr->peer_call_id);
@@ -927,10 +927,10 @@ pptp_wen_print(const u_char *dat)
 	TCHECK(ptr->framing_err);
 	printf(" FRAMING_ERR(%lu)", (unsigned long)ntohl(ptr->framing_err));
 	TCHECK(ptr->hardware_overrun);
-	printf(" HARDWARE_OVERRUN(%lu)", 
+	printf(" HARDWARE_OVERRUN(%lu)",
 	       (unsigned long)ntohl(ptr->hardware_overrun));
 	TCHECK(ptr->buffer_overrun);
-	printf(" BUFFER_OVERRUN(%lu)", 
+	printf(" BUFFER_OVERRUN(%lu)",
 	       (unsigned long)ntohl(ptr->buffer_overrun));
 	TCHECK(ptr->timeout_err);
 	printf(" TIMEOUT_ERR(%lu)", (unsigned long)ntohl(ptr->timeout_err));
@@ -1003,7 +1003,7 @@ pptp_print(const u_char *dat, u_int length)
 	TCHECK(hdr->ctrl_msg_type);
 	ctrl_msg_type = ntohs(hdr->ctrl_msg_type);
 	if (ctrl_msg_type < PPTP_MAX_MSGTYPE_INDEX) {
-		printf(" CTRL_MSGTYPE=%s", 
+		printf(" CTRL_MSGTYPE=%s",
 		       pptp_message_type_string[ctrl_msg_type]);
 	} else {
 		printf(" UNKNOWN_CTRL_MSGTYPE(%u)", ctrl_msg_type);
@@ -1067,4 +1067,4 @@ pptp_print(const u_char *dat, u_int length)
 
 trunc:
 	printf("%s", tstr);
-}	
+}
diff --git a/print-radius.c b/print-radius.c
index a9b815f1..ff7b8b6a 100644
--- a/print-radius.c
+++ b/print-radius.c
@@ -1,10 +1,10 @@
 /*
  * Copyright (C) 2000 Alfredo Andres Omella.  All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
- *  
+ *
  *   1. Redistributions of source code must retain the above copyright
  *      notice, this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright
@@ -14,7 +14,7 @@
  *   3. The names of the authors may not be used to endorse or promote
  *      products derived from this software without specific prior
  *      written permission.
- *  
+ *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
@@ -39,12 +39,12 @@
  *
  * Alfredo Andres Omella (aandres@s21sec.com) v0.1 2000/09/15
  *
- * TODO: Among other things to print ok MacIntosh and Vendor values 
+ * TODO: Among other things to print ok MacIntosh and Vendor values
  */
 
 #ifndef lint
 static const char rcsid[] =
-    "$Id: print-radius.c,v 1.11 2002-04-20 09:40:42 guy Exp $";
+    "$Id: print-radius.c,v 1.12 2002-06-11 17:08:55 itojun Exp $";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -149,20 +149,20 @@ struct radius_attr { u_int8_t type; /* Attribute type   */
                    };
 
 
-/* Service-Type Attribute standard values */                 
+/* Service-Type Attribute standard values */
 static const char *serv_type[]={ NULL,
                                 "Login",
-                                "Framed",  
+                                "Framed",
                                 "Callback Login",
                                 "Callback Framed",
                                 "Outbound",
                                 "Administrative",
-                                "NAS Prompt",                            
+                                "NAS Prompt",
                                 "Authenticate Only",
                                 "Callback NAS Prompt",
                                 "Call Check",
                                 "Callback Administrative",
-                               };                               
+                               };
 
 /* Framed-Protocol Attribute standard values */
 static const char *frm_proto[]={ NULL,
@@ -172,14 +172,14 @@ static const char *frm_proto[]={ NULL,
                                  "Gandalf proprietary",
                                  "Xylogics IPX/SLIP",
                                  "X.75 Synchronous",
-                               };                               
+                               };
 
 /* Framed-Routing Attribute standard values */
 static const char *frm_routing[]={ "None",
                                    "Send",
                                    "Listen",
                                    "Send&Listen",
-                                 };                               
+                                 };
 
 /* Framed-Compression Attribute standard values */
 static const char *frm_comp[]={ "None",
@@ -227,7 +227,7 @@ static const char *nas_port_type[]={ "Async",
                                      "Cable",
                                      "Wireless - Other",
                                      "Wireless - IEEE 802.11",
-                                   };         
+                                   };
 
 /* Acct-Status-Type Accounting Attribute standard values */
 static const char *acct_status[]={ NULL,
@@ -292,7 +292,7 @@ static const char *tunnel_type[]={ NULL,
                                    "DVS",
                                    "IP-in-IP Tunneling",
                                  };
-                                   
+
 /* Tunnel-Medium-Type Attribute standard values */
 static const char *tunnel_medium[]={ NULL,
                                      "IPv4",
@@ -323,8 +323,8 @@ static const char *arap_zone[]={ NULL,
 static const char *prompt[]={ "No Echo",
                               "Echo",
                             };
-                            
-                                                               
+
+
 struct attrtype { char *name;            /* Attribute name                 */
                   const char **subtypes; /* Standard Values (if any)       */
                   u_char siz_subtypes;   /* Size of total standard values  */
@@ -338,23 +338,23 @@ struct attrtype { char *name;            /* Attribute name                 */
      { "CHAP-Pass",      NULL, 0, 0, NULL               },
      { "NAS_ipaddr",     NULL, 0, 0, print_attr_address },
      { "NAS_port",       NULL, 0, 0, print_attr_num     },
-     { "Service_type",   serv_type, TAM_SIZE(serv_type)-1, 1, print_attr_num },                 
+     { "Service_type",   serv_type, TAM_SIZE(serv_type)-1, 1, print_attr_num },
      { "Framed_proto",   frm_proto, TAM_SIZE(frm_proto)-1, 1, print_attr_num },
      { "Framed_ipaddr",  NULL, 0, 0, print_attr_address },
      { "Framed_ipnet",   NULL, 0, 0, print_attr_address },
-     { "Framed_routing", frm_routing, TAM_SIZE(frm_routing), 0, 
-                                                              print_attr_num }, 
+     { "Framed_routing", frm_routing, TAM_SIZE(frm_routing), 0,
+                                                              print_attr_num },
      { "Filter_id",      NULL, 0, 0, print_attr_string  },
      { "Framed_mtu",     NULL, 0, 0, print_attr_num     },
      { "Framed_compress",  frm_comp, TAM_SIZE(frm_comp),   0, print_attr_num },
      { "Login_iphost",   NULL, 0, 0, print_attr_address },
      { "Login_service",  login_serv, TAM_SIZE(login_serv), 0, print_attr_num },
-     { "Login_TCP_port", NULL, 0, 0, print_attr_num     },                 
-/*17*/ { "Unassigned", NULL, 0, 0, NULL },                 
+     { "Login_TCP_port", NULL, 0, 0, print_attr_num     },
+/*17*/ { "Unassigned", NULL, 0, 0, NULL },
      { "Reply",           NULL, 0, 0, print_attr_string },
      { "Callback-number", NULL, 0, 0, print_attr_string },
      { "Callback-id",     NULL, 0, 0, print_attr_string },
-/*21*/ { "Unassigned", NULL, 0, 0, NULL },   
+/*21*/ { "Unassigned", NULL, 0, 0, NULL },
      { "Framed_route",      NULL, 0, 0, print_attr_string },
      { "Framed_ipx_net",    NULL, 0, 0, print_attr_num    },
      { "State",             NULL, 0, 0, print_attr_string },
@@ -364,7 +364,7 @@ struct attrtype { char *name;            /* Attribute name                 */
      { "Idle_timeout",      NULL, 0, 0, print_attr_num    },
      { "Term_action", term_action, TAM_SIZE(term_action), 0, print_attr_num },
      { "Called_station",    NULL, 0, 0, print_attr_string },
-     { "Calling_station",   NULL, 0, 0, print_attr_string },   
+     { "Calling_station",   NULL, 0, 0, print_attr_string },
      { "NAS_id",            NULL, 0, 0, print_attr_string },
      { "Proxy_state",       NULL, 0, 0, print_attr_string },
      { "Login_LAT_service", NULL, 0, 0, print_attr_string },
@@ -393,13 +393,13 @@ struct attrtype { char *name;            /* Attribute name                 */
 /*57*/ { "Unassigned", NULL, 0, 0, NULL },
 /*58*/ { "Unassigned", NULL, 0, 0, NULL },
 /*59*/ { "Unassigned", NULL, 0, 0, NULL },
-     { "CHAP_challenge", NULL, 0, 0, print_attr_string },  
-     { "NAS_port_type",  nas_port_type, TAM_SIZE(nas_port_type), 0, 
+     { "CHAP_challenge", NULL, 0, 0, print_attr_string },
+     { "NAS_port_type",  nas_port_type, TAM_SIZE(nas_port_type), 0,
                                                               print_attr_num },
      { "Port_limit",     NULL, 0, 0, print_attr_num },
 /*63*/ { "Login_LAT_port", NULL, 0, 0, print_attr_string },
      { "Tunnel_type", tunnel_type, TAM_SIZE(tunnel_type)-1, 1, print_attr_num },
-     { "Tunnel_medium", tunnel_medium, TAM_SIZE(tunnel_medium)-1, 1, 
+     { "Tunnel_medium", tunnel_medium, TAM_SIZE(tunnel_medium)-1, 1,
                                                              print_attr_num },
      { "Tunnel_client_end",   NULL, 0, 0, print_attr_string },
      { "Tunnel_server_end",   NULL, 0, 0, print_attr_string },
@@ -407,7 +407,7 @@ struct attrtype { char *name;            /* Attribute name                 */
      { "Tunnel_pass",  NULL, 0, 0, print_attr_string  },
      { "ARAP_pass",    NULL, 0, 0, print_attr_strange },
      { "ARAP_feature", NULL, 0, 0, print_attr_strange },
-/*72*/ { "ARAP_zone_acces", arap_zone, TAM_SIZE(arap_zone)-1, 1, 
+/*72*/ { "ARAP_zone_acces", arap_zone, TAM_SIZE(arap_zone)-1, 1,
                                                              print_attr_num },
      { "ARAP_security",      NULL, 0, 0, print_attr_string },
      { "ARAP_security_data", NULL, 0, 0, print_attr_string },
@@ -430,7 +430,7 @@ struct attrtype { char *name;            /* Attribute name                 */
      { "Tunnel_server_auth_id", NULL, 0, 0, print_attr_string },
 /*92*/ { "Unassigned",  NULL, 0, 0, NULL },
 /*93*/ { "Unassigned",  NULL, 0, 0, NULL }
-  };                    
+  };
 
 
 /*****************************/
@@ -444,9 +444,9 @@ static void
 print_attr_string(register u_char *data, u_int length, u_short attr_code )
 {
    register u_int i;
-   
+
    TCHECK2(data[0],length);
-   
+
    printf("{");
    switch(attr_code)
    {
@@ -477,12 +477,12 @@ print_attr_string(register u_char *data, u_int length, u_short attr_code )
        printf("%c",(*data < 32 || *data > 128) ? '.' : *data );
 
    printf("}");
-   
+
    return;
-   
+
    trunc:
       printf("|radius");
-}  
+}
 
 
 /******************************/
@@ -497,7 +497,7 @@ print_attr_num(register u_char *data, u_int length, u_short attr_code )
 {
    u_int8_t tag;
    u_int32_t timeout;
-   
+
    if (length != 4)
    {
        printf("{length %u != 4}", length);
@@ -506,12 +506,12 @@ print_attr_num(register u_char *data, u_int length, u_short attr_code )
 
    TCHECK2(data[0],4);
                           /* This attribute has standard values */
-   if (attr_type[attr_code].siz_subtypes) 
+   if (attr_type[attr_code].siz_subtypes)
    {
       static const char **table;
       u_int32_t data_value;
       table = attr_type[attr_code].subtypes;
-      
+
       if ( (attr_code == TUNNEL_TYPE) || (attr_code == TUNNEL_MEDIUM) )
       {
          if (!*data)
@@ -529,7 +529,7 @@ print_attr_num(register u_char *data, u_int length, u_short attr_code )
             attr_type[attr_code].first_subtype) )
          printf("{%s}",table[data_value]);
       else
-         printf("{#%d}",data_value);          
+         printf("{#%d}",data_value);
    }
    else
    {
@@ -539,7 +539,7 @@ print_attr_num(register u_char *data, u_int length, u_short attr_code )
              if (EXTRACT_32BITS( data) == 0xFFFFFFFE )
                 printf("{NAS_select}");
              else
-                printf("{%d}",EXTRACT_32BITS( data) );          
+                printf("{%d}",EXTRACT_32BITS( data) );
           break;
 
         case SESSION_TIMEOUT:
@@ -553,27 +553,27 @@ print_attr_num(register u_char *data, u_int length, u_short attr_code )
              else
              {
                 if ( timeout < 3600 )
-                   printf( "{%02d:%02d min}", 
+                   printf( "{%02d:%02d min}",
                           timeout / 60, timeout % 60);
                 else
                    printf( "{%02d:%02d:%02d hours}",
-                          timeout / 3600, (timeout % 3600) / 60, 
+                          timeout / 3600, (timeout % 3600) / 60,
                           timeout % 60);
              }
           break;
 
         case FRM_ATALK_LINK:
-             if (EXTRACT_32BITS(data) )          
+             if (EXTRACT_32BITS(data) )
                 printf("{%d}",EXTRACT_32BITS(data) );
              else
                 printf("{Unnumbered}" );
           break;
-             
+
         case FRM_ATALK_NETWORK:
-             if (EXTRACT_32BITS(data) )          
+             if (EXTRACT_32BITS(data) )
                 printf("{%d}",EXTRACT_32BITS(data) );
              else
-                printf("{NAS_assign}" );          
+                printf("{NAS_assign}" );
           break;
 
         case TUNNEL_PREFERENCE:
@@ -588,13 +588,13 @@ print_attr_num(register u_char *data, u_int length, u_short attr_code )
         default:
              printf("{%d}",EXTRACT_32BITS( data) );
           break;
-      
+
       } /* switch */
-   
+
    } /* if-else */
 
    return;
-   
+
    trunc:
      printf("|radius}");
 }
@@ -617,7 +617,7 @@ print_attr_address(register u_char *data, u_int length, u_short attr_code )
    }
 
    TCHECK2(data[0],4);
-   
+
    switch(attr_code)
    {
       case FRM_IPADDR:
@@ -630,14 +630,14 @@ print_attr_address(register u_char *data, u_int length, u_short attr_code )
               else
                  printf("{%s}",ipaddr_string(data));
       break;
-      
+
       default:
           printf("{%s}",ipaddr_string(data) );
       break;
    }
-   
+
    return;
-   
+
    trunc:
      printf("{|radius}");
 }
@@ -663,19 +663,19 @@ static void print_attr_time(register u_char *data, u_int length, u_short attr_co
    }
 
    TCHECK2(data[0],4);
-   
+
    attr_time = EXTRACT_32BITS(data);
    strlcpy(string, ctime(&attr_time), sizeof(string));
    /* Get rid of the newline */
    string[24] = '\0';
    printf("{%.24s}", string);
    return;
-   
+
    trunc:
      printf("{|radius}");
 }
 
-           
+
 /***********************************/
 /* Print an attribute of 'strange' */
 /* data format pointed by 'data'   */
@@ -686,7 +686,7 @@ static void print_attr_time(register u_char *data, u_int length, u_short attr_co
 static void print_attr_strange(register u_char *data, u_int length, u_short attr_code)
 {
    u_short len_data;
-   
+
    switch(attr_code)
    {
       case ARAP_PASS:
@@ -705,7 +705,7 @@ static void print_attr_strange(register u_char *data, u_int length, u_short attr
            PRINT_HEX(len_data, data);
            printf("]}");
         break;
-        
+
       case ARAP_FEATURES:
            if (length != 14)
            {
@@ -749,7 +749,7 @@ static void print_attr_strange(register u_char *data, u_int length, u_short attr
            printf("}");
         break;
    }
-   
+
    trunc:
      printf("|radius}");
 }
@@ -760,20 +760,20 @@ static void
 radius_attr_print(register const u_char *attr, u_int length)
 {
    register const struct radius_attr *rad_attr = (struct radius_attr *)attr;
-   
+
    if (length < 3)
    {
       printf(" [|radius]");
       return;
    }
- 
+
    printf(" Attr[ ");
    while (length > 0)
    {
      if (rad_attr->len == 0)
      {
-     	printf("(zero-length attribute)");
-     	return;
+	printf("(zero-length attribute)");
+	return;
      }
      if ( rad_attr->len <= length )
      {
@@ -786,7 +786,7 @@ radius_attr_print(register const u_char *attr, u_int length)
            if (rad_attr->len > 2)
            {
                if ( attr_type[rad_attr->type].print_func )
-                  (*attr_type[rad_attr->type].print_func)( 
+                  (*attr_type[rad_attr->type].print_func)(
 		                           ((u_char *)(rad_attr+1)),
                                            rad_attr->len - 2, rad_attr->type);
            }
@@ -800,7 +800,7 @@ radius_attr_print(register const u_char *attr, u_int length)
      length-=(rad_attr->len);
      rad_attr = (struct radius_attr *)( ((char *)(rad_attr))+rad_attr->len);
    }
-   
+
    printf(" ]");
 }
 
@@ -811,7 +811,7 @@ radius_print(const u_char *dat, u_int length)
    register const struct radius_hdr *rad;
    register int i;
    int len;
-   
+
    i = min(length, snapend - dat);
 
    if (i < MIN_RADIUS_LEN)
@@ -831,10 +831,10 @@ radius_print(const u_char *dat, u_int length)
 
    if (len < i)
 	  i = len;
-   
+
    i -= MIN_RADIUS_LEN;
 
-   switch (rad->code) 
+   switch (rad->code)
    {
      case RADCMD_ACCESS_REQ:
          printf(" rad-access-req %d", length);
@@ -877,7 +877,7 @@ radius_print(const u_char *dat, u_int length)
          break;
    }
    printf(" [id %d]", rad->id);
- 
+
    if (i)
-      radius_attr_print( dat + MIN_RADIUS_LEN, i);  
+      radius_attr_print( dat + MIN_RADIUS_LEN, i);
 }
diff --git a/print-rt6.c b/print-rt6.c
index 8b249788..aff7df09 100644
--- a/print-rt6.c
+++ b/print-rt6.c
@@ -21,7 +21,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-rt6.c,v 1.18 2001-06-15 22:17:34 fenner Exp $";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-rt6.c,v 1.19 2002-06-11 17:08:55 itojun Exp $";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -88,7 +88,7 @@ rt6_print(register const u_char *bp, register const u_char *bp2)
 		for (i = 0; i < len; i++) {
 			if ((u_char *)(addr + 1) > ep)
 				goto trunc;
-		
+
 			printf(", [%d]%s", i, ip6addr_string(addr));
 			addr++;
 		}
diff --git a/print-rx.c b/print-rx.c
index 6018325e..ae00c583 100644
--- a/print-rx.c
+++ b/print-rx.c
@@ -5,7 +5,7 @@
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
- *  
+ *
  *   1. Redistributions of source code must retain the above copyright
  *      notice, this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright
@@ -15,7 +15,7 @@
  *   3. The names of the authors may not be used to endorse or promote
  *      products derived from this software without specific prior
  *      written permission.
- *  
+ *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
@@ -34,7 +34,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-rx.c,v 1.29 2002-04-30 06:45:08 guy Exp $";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-rx.c,v 1.30 2002-06-11 17:08:55 itojun Exp $";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -497,8 +497,8 @@ rx_print(register const u_char *bp, int length, int sport, int dport,
 	 * as well.
 	 */
 
- 	if (rxh->type == RX_PACKET_TYPE_ACK)
- 	    ack_print(bp, length);
+	if (rxh->type == RX_PACKET_TYPE_ACK)
+	    ack_print(bp, length);
 	else if (rxh->type == RX_PACKET_TYPE_DATA &&
 	    EXTRACT_32BITS(&rxh->seq) == 1 &&
 	    rxh->flags & RX_CLIENT_INITIATED) {
@@ -535,7 +535,7 @@ rx_print(register const u_char *bp, int length, int sport, int dport,
 			default:
 				;
 		}
-	
+
 	/*
 	 * If it's a reply (client-init is _not_ set, but seq is one)
 	 * then look it up in the cache.  If we find it, call the reply
@@ -607,7 +607,7 @@ rx_cache_insert(const u_char *bp, const struct ip *ip, int dport,
 
 	if (++rx_cache_next >= RX_CACHE_SIZE)
 		rx_cache_next = 0;
-	
+
 	rxent->callnum = rxh->callNumber;
 	rxent->client = ip->ip_src;
 	rxent->server = ip->ip_dst;
@@ -639,7 +639,7 @@ rx_cache_find(const struct rx_header *rxh, const struct ip *ip, int sport,
 		rxent = &rx_cache[i];
 		if (rxent->callnum == rxh->callNumber &&
 		    rxent->client.s_addr == clip &&
-		    rxent->server.s_addr == sip && 
+		    rxent->server.s_addr == sip &&
 		    rxent->serviceId == rxh->serviceId &&
 		    rxent->dport == sport) {
 
@@ -712,18 +712,18 @@ rx_cache_find(const struct rx_header *rxh, const struct ip *ip, int sport,
 			TCHECK2(bp[0], (sizeof(int32_t)*6)); \
 			mask = EXTRACT_32BITS(bp); bp += sizeof(int32_t); \
 			if (mask) printf (" StoreStatus"); \
-  		        if (mask & 1) { printf(" date"); DATEOUT(); } \
+		        if (mask & 1) { printf(" date"); DATEOUT(); } \
 			else bp += sizeof(int32_t); \
 			i = EXTRACT_32BITS(bp); bp += sizeof(int32_t); \
-  		        if (mask & 2) printf(" owner %lu", i);  \
+		        if (mask & 2) printf(" owner %lu", i);  \
 			i = EXTRACT_32BITS(bp); bp += sizeof(int32_t); \
-  		        if (mask & 4) printf(" group %lu", i); \
+		        if (mask & 4) printf(" group %lu", i); \
 			i = EXTRACT_32BITS(bp); bp += sizeof(int32_t); \
-  		        if (mask & 8) printf(" mode %lo", i & 07777); \
+		        if (mask & 8) printf(" mode %lo", i & 07777); \
 			i = EXTRACT_32BITS(bp); bp += sizeof(int32_t); \
-  		        if (mask & 16) printf(" segsize %lu", i); \
+		        if (mask & 16) printf(" segsize %lu", i); \
 			/* undocumented in 3.3 docu */ \
-  		        if (mask & 1024) printf(" fsync");  \
+		        if (mask & 1024) printf(" fsync");  \
 		}
 
 #define UBIK_VERSIONOUT() {int32_t epoch; int32_t counter; \
@@ -783,7 +783,7 @@ ack_print(register const u_char *bp, int length)
 	if (vflag <= 1)
 	        return;
 
- 	if (length <= sizeof(struct rx_header))
+	if (length <= sizeof(struct rx_header))
 		return;
 
 	bp += sizeof(struct rx_header);
@@ -836,7 +836,7 @@ ack_print(register const u_char *bp, int length)
 	    putchar(*bp == RX_ACK_TYPE_NACK? '-' : '*');
 	    bp += 1;
 	}
-	
+
 	return;
 
 trunc:
@@ -1055,12 +1055,12 @@ fs_reply_print(register const u_char *bp, int length, int32_t opcode)
 	} else if (rxh->type == RX_PACKET_TYPE_ABORT) {
 		int i;
 
- 		/*
- 		 * Otherwise, just print out the return code
- 		 */
-		TCHECK2(bp[0], sizeof(int32_t)); 
-		i = (int) EXTRACT_32BITS(bp); 
-		bp += sizeof(int32_t); 
+		/*
+		 * Otherwise, just print out the return code
+		 */
+		TCHECK2(bp[0], sizeof(int32_t));
+		i = (int) EXTRACT_32BITS(bp);
+		bp += sizeof(int32_t);
 
 		printf(" error %s", tok2str(afs_fs_errors, "#%d", i));
 	} else {
@@ -1080,7 +1080,7 @@ trunc:
  * <positive> <negative>
  * <uid1> <aclbits1>
  * ....
- * 
+ *
  * "positive" and "negative" are integers which contain the number of
  * positive and negative ACL's in the string.  The uid/aclbits pair are
  * ASCII strings containing the UID/PTS record and and a ascii number
@@ -1099,7 +1099,7 @@ acl_print(u_char *s, int maxsize, u_char *end)
 
 	if (sscanf((char *) s, "%d %d\n%n", &pos, &neg, &n) != 2)
 		goto finish;
-	
+
 	s += n;
 
 	if (s > end)
@@ -1258,7 +1258,7 @@ cb_reply_print(register const u_char *bp, int length, int32_t opcode)
 	 * Print out the afs call we're invoking.  The table used here was
 	 * gleaned from fsint/afscbint.xg
 	 */
-	
+
 	printf(" cb reply %s", tok2str(cb_req, "op#%d", opcode));
 
 	bp += sizeof(struct rx_header);
@@ -1808,7 +1808,7 @@ vldb_reply_print(register const u_char *bp, int length, int32_t opcode)
 		default:
 			;
 		}
-			
+
 	else {
 		/*
 		 * Otherwise, just print out the return code
@@ -1934,7 +1934,7 @@ kauth_reply_print(register const u_char *bp, int length, int32_t opcode)
 	 * Print out the afs call we're invoking.  The table used here was
 	 * gleaned from kauth/kauth.rg
 	 */
-	
+
 	printf(" kauth");
 
 	if (is_ubik(opcode)) {
@@ -2023,7 +2023,7 @@ vol_reply_print(register const u_char *bp, int length, int32_t opcode)
 	 * Print out the afs call we're invoking.  The table used here was
 	 * gleaned from volser/volint.xg
 	 */
-	
+
 	printf(" vol reply %s", tok2str(vol_req, "op#%d", opcode));
 
 	bp += sizeof(struct rx_header);
@@ -2158,7 +2158,7 @@ bos_reply_print(register const u_char *bp, int length, int32_t opcode)
 	 * Print out the afs call we're invoking.  The table used here was
 	 * gleaned from volser/volint.xg
 	 */
-	
+
 	printf(" bos reply %s", tok2str(bos_req, "op#%d", opcode));
 
 	bp += sizeof(struct rx_header);
@@ -2333,7 +2333,7 @@ ubik_reply_print(register const u_char *bp, int length, int32_t opcode)
 	/*
 	 * If it was a data packet, print out the arguments to the Ubik calls
 	 */
-	
+
 	if (rxh->type == RX_PACKET_TYPE_DATA)
 		switch (opcode) {
 		case 10000:		/* Beacon */
@@ -2346,7 +2346,7 @@ ubik_reply_print(register const u_char *bp, int length, int32_t opcode)
 		default:
 			;
 		}
-	
+
 	/*
 	 * Otherwise, print out "yes" it it was a beacon packet (because
 	 * that's how yes votes are returned, go figure), otherwise
@@ -2406,11 +2406,11 @@ rx_ack_print(register const u_char *bp, int length)
 		printf(" bufspace %d maxskew %d",
 		       (int) EXTRACT_16BITS(&rxa->bufferSpace),
 		       (int) EXTRACT_16BITS(&rxa->maxSkew));
-	
+
 	printf(" first %d serial %d reason %s",
 	       EXTRACT_32BITS(&rxa->firstPacket), EXTRACT_32BITS(&rxa->serial),
 	       tok2str(rx_ack_reasons, "#%d", (int) rxa->reason));
-	
+
 	/*
 	 * Okay, now we print out the ack array.  The way _this_ works
 	 * is that we start at "first", and step through the ack array.
@@ -2423,7 +2423,7 @@ rx_ack_print(register const u_char *bp, int length)
 	 * yield the start of the ack array (because RX_MAXACKS is 255
 	 * and the structure will likely get padded to a 2 or 4 byte
 	 * boundary).  However, this is the way it's implemented inside
-	 * of AFS - the start of the extra fields are at 
+	 * of AFS - the start of the extra fields are at
 	 * sizeof(struct rx_ackPacket) - RX_MAXACKS + nAcks, which _isn't_
 	 * the exact start of the ack array.  Sigh.  That's why we aren't
 	 * using bp, but instead use rxa->acks[].  But nAcks gets added
@@ -2492,7 +2492,7 @@ rx_ack_print(register const u_char *bp, int length)
 				 */
 			} else if (last == i - 1 && start != last)
 				printf("-%d", rxa->firstPacket + i - 1);
-		
+
 		/*
 		 * So, what's going on here?  We ran off the end of the
 		 * ack list, and if we got a range we need to finish it up.
@@ -2510,7 +2510,7 @@ rx_ack_print(register const u_char *bp, int length)
 		/*
 		 * Same as above, just without comments
 		 */
-		
+
 		for (i = 0, start = last = -2; i < rxa->nAcks; i++)
 			if (rxa->acks[i] == RX_ACK_TYPE_NACK) {
 				if (last == -2) {
@@ -2524,7 +2524,7 @@ rx_ack_print(register const u_char *bp, int length)
 				last = i;
 			} else if (last == i - 1 && start != last)
 				printf("-%d", rxa->firstPacket + i - 1);
-		
+
 		if (last == i - 1 && start != last)
 			printf("-%d", rxa->firstPacket + i - 1);
 
diff --git a/print-sctp.c b/print-sctp.c
index 43a71c5d..8767ec2a 100644
--- a/print-sctp.c
+++ b/print-sctp.c
@@ -35,7 +35,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-"@(#) $Header: /tcpdump/master/tcpdump/print-sctp.c,v 1.8 2002-04-25 04:45:59 guy Exp $ (NETLAB/PEL)";
+"@(#) $Header: /tcpdump/master/tcpdump/print-sctp.c,v 1.9 2002-06-11 17:08:56 itojun Exp $ (NETLAB/PEL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -67,7 +67,7 @@ static const char rcsid[] =
 void sctp_print(const u_char *bp,        /* beginning of sctp packet */
 		const u_char *bp2,       /* beginning of enclosing */
 		u_int sctpPacketLength)  /* ip packet */
-{ 
+{
   const struct sctpHeader *sctpPktHdr;
   const struct ip *ip;
 #ifdef INET6
@@ -82,7 +82,7 @@ void sctp_print(const u_char *bp,        /* beginning of sctp packet */
 
   sctpPktHdr = (const struct sctpHeader*) bp;
   endPacketPtr = (const u_char*)sctpPktHdr+sctpPacketLength;
-  
+
   if( (u_long) endPacketPtr > (u_long) snapend)
     endPacketPtr = (const void *) snapend;
   ip = (struct ip *)bp2;
@@ -94,24 +94,24 @@ void sctp_print(const u_char *bp,        /* beginning of sctp packet */
 #endif /*INET6*/
   cp = (const u_char *)(sctpPktHdr + 1);
   if (cp > snapend)
-    { 
+    {
       printf("[|sctp]");
-      return; 
-    } 
+      return;
+    }
 
-  if (sctpPacketLength < sizeof(struct sctpHeader)) 
+  if (sctpPacketLength < sizeof(struct sctpHeader))
     {
-      (void)printf("truncated-sctp - %ld bytes missing!", 
+      (void)printf("truncated-sctp - %ld bytes missing!",
 		   (long)sctpPacketLength-sizeof(struct sctpHeader));
       return;
     }
-  
+
   /*    sctpPacketLength -= sizeof(struct sctpHeader);  packet length  */
   /*  			      is now only as long as the payload  */
 
   sourcePort = ntohs(sctpPktHdr->source);
   destPort = ntohs(sctpPktHdr->destination);
-  
+
 #ifdef INET6
   if (ip6) {
     if (ip6->ip6_nxt == IPPROTO_SCTP) {
@@ -142,23 +142,23 @@ void sctp_print(const u_char *bp,        /* beginning of sctp packet */
 
   if (vflag < 2)
 	return;
-  
+
   /* cycle through all chunks, printing information on each one */
-  for (chunkCount = 0, 
+  for (chunkCount = 0,
 	 chunkDescPtr = (const struct sctpChunkDesc *)
 	    ((const u_char*) sctpPktHdr + sizeof(struct sctpHeader));
        chunkDescPtr != NULL &&
 	 ( (const void *)
 	    ((const u_char *) chunkDescPtr + sizeof(struct sctpChunkDesc))
 	   <= endPacketPtr);
-       
+
        chunkDescPtr = (const struct sctpChunkDesc *) nextChunk, chunkCount++)
     {
       u_short align;
       const u_char *chunkEnd;
-      
+
       chunkEnd = ((const u_char*)chunkDescPtr + ntohs(chunkDescPtr->chunkLength));
-      
+
       align=ntohs(chunkDescPtr->chunkLength) % 4;
       if (align != 0)
 	align = 4 - align;
@@ -171,33 +171,33 @@ void sctp_print(const u_char *bp,        /* beginning of sctp packet */
 	case SCTP_DATA :
 	  {
 	    const struct sctpDataPart *dataHdrPtr;
-	    
+
 	    printf("[DATA] ");
-	    
-	    if ((chunkDescPtr->chunkFlg & SCTP_DATA_UNORDERED) 
+
+	    if ((chunkDescPtr->chunkFlg & SCTP_DATA_UNORDERED)
 		== SCTP_DATA_UNORDERED)
 	      printf("(U)");
 
-	    if ((chunkDescPtr->chunkFlg & SCTP_DATA_FIRST_FRAG) 
+	    if ((chunkDescPtr->chunkFlg & SCTP_DATA_FIRST_FRAG)
 		== SCTP_DATA_FIRST_FRAG)
 	      printf("(B)");
-	    
-	    if ((chunkDescPtr->chunkFlg & SCTP_DATA_LAST_FRAG) 
+
+	    if ((chunkDescPtr->chunkFlg & SCTP_DATA_LAST_FRAG)
 		== SCTP_DATA_LAST_FRAG)
 	      printf("(E)");
 
-	    if( ((chunkDescPtr->chunkFlg & SCTP_DATA_UNORDERED) 
-		 == SCTP_DATA_UNORDERED) 
+	    if( ((chunkDescPtr->chunkFlg & SCTP_DATA_UNORDERED)
+		 == SCTP_DATA_UNORDERED)
 		||
-		((chunkDescPtr->chunkFlg & SCTP_DATA_FIRST_FRAG) 
+		((chunkDescPtr->chunkFlg & SCTP_DATA_FIRST_FRAG)
 		 == SCTP_DATA_FIRST_FRAG)
 		||
-		((chunkDescPtr->chunkFlg & SCTP_DATA_LAST_FRAG) 
+		((chunkDescPtr->chunkFlg & SCTP_DATA_LAST_FRAG)
 		 == SCTP_DATA_LAST_FRAG) )
 	      printf(" ");
 
 	    dataHdrPtr=(const struct sctpDataPart*)(chunkDescPtr+1);
-			     
+
 	    printf("[TSN: %u] ", (u_int32_t)ntohl(dataHdrPtr->TSN));
 	    printf("[SID: %u] ", ntohs(dataHdrPtr->streamId));
 	    printf("[SSEQ %u] ", ntohs(dataHdrPtr->sequence));
@@ -207,7 +207,7 @@ void sctp_print(const u_char *bp,        /* beginning of sctp packet */
 	    if (vflag)		/* if verbose output is specified */
 	      {		           /* at the command line */
 		const u_char *payloadPtr;
-		
+
 		printf("[Payload");
 
 		if (!xflag && !qflag) {
@@ -243,7 +243,7 @@ void sctp_print(const u_char *bp,        /* beginning of sctp packet */
 	case SCTP_INITIATION_ACK :
 	  {
 	    const struct sctpInitiation *init;
-	    
+
 	    printf("[INIT ACK] ");
 	    init=(const struct sctpInitiation*)(chunkDescPtr+1);
 	    printf("[init tag: %u] ", (u_int32_t)ntohl(init->initTag));
@@ -251,7 +251,7 @@ void sctp_print(const u_char *bp,        /* beginning of sctp packet */
 	    printf("[OS: %u] ", ntohs(init->NumPreopenStreams));
 	    printf("[MIS: %u] ", ntohs(init->MaxInboundStreams));
 	    printf("[init TSN: %u] ", (u_int32_t)ntohl(init->initialTSN));
-	    
+
 #if(0) /* ALC you can add code for optional params here */
 	    if( (init+1) < chunkEnd )
 	      printf(" @@@@@ UNFINISHED @@@@@@%s\n",
@@ -262,7 +262,7 @@ void sctp_print(const u_char *bp,        /* beginning of sctp packet */
 	case SCTP_SELECTIVE_ACK:
 	  {
 	    const struct sctpSelectiveAck *sack;
-	    const struct sctpSelectiveFrag *frag; 
+	    const struct sctpSelectiveFrag *frag;
 	    int fragNo, tsnNo;
 	    const u_long *dupTSN;
 
@@ -272,22 +272,22 @@ void sctp_print(const u_char *bp,        /* beginning of sctp packet */
 	    printf("[a_rwnd %u] ", (u_int32_t)ntohl(sack->updatedRwnd));
 	    printf("[#gap acks %u] ", ntohs(sack->numberOfdesc));
 	    printf("[#dup tsns %u] ", ntohs(sack->numDupTsns));
-	    
-	    
+
+
 	    /* print gaps */
 	    for (frag = ( (const struct sctpSelectiveFrag *)
 			  ((const struct sctpSelectiveAck *) sack+1)),
 		   fragNo=0;
 		 (const void *)frag < nextChunk && fragNo < ntohs(sack->numberOfdesc);
 		 frag++, fragNo++)
-	      printf("\n\t\t[gap ack block #%d: start = %u, end = %u] ", 
+	      printf("\n\t\t[gap ack block #%d: start = %u, end = %u] ",
 		     fragNo+1,
 		     (u_int32_t)(ntohl(sack->highestConseqTSN) + ntohs(frag->fragmentStart)),
 		     (u_int32_t)(ntohl(sack->highestConseqTSN) + ntohs(frag->fragmentEnd)));
-	    
+
 
 	    /* print duplicate TSNs */
-	    for (dupTSN = (const u_long*)frag, tsnNo=0; 
+	    for (dupTSN = (const u_long*)frag, tsnNo=0;
 		 (const void *) dupTSN < nextChunk && tsnNo<ntohs(sack->numDupTsns);
 		 dupTSN++, tsnNo++)
 	      printf("\n\t\t[dup TSN #%u: %u] ", tsnNo+1,
@@ -302,7 +302,7 @@ void sctp_print(const u_char *bp,        /* beginning of sctp packet */
 	    hb=(const struct sctpHBsender*)chunkDescPtr;
 
 	    printf("[HB REQ] ");
-	    
+
 	    break;
 	  }
 	case SCTP_HEARTBEAT_ACK :
@@ -329,7 +329,7 @@ void sctp_print(const u_char *bp,        /* beginning of sctp packet */
 	case SCTP_ECN_ECHO :
 	  printf("[ECN ECHO] ");
 	  break;
-	case SCTP_ECN_CWR : 
+	case SCTP_ECN_CWR :
 	  printf("[ECN CWR] ");
 	  break;
 	case SCTP_SHUTDOWN_COMPLETE :
diff --git a/print-snmp.c b/print-snmp.c
index a82cbf92..c7a5edf1 100644
--- a/print-snmp.c
+++ b/print-snmp.c
@@ -58,7 +58,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-snmp.c,v 1.52 2002-05-07 18:27:40 fenner Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-snmp.c,v 1.53 2002-06-11 17:08:56 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -559,7 +559,7 @@ asn1_parse(register const u_char *p, u_int len, struct be *elem)
 			        elem->type = BE_UNS64;
 				high = 0, low = 0;
 				for (i = elem->asnlen; i-- > 0; p++) {
-				        high = (high << 8) | 
+				        high = (high << 8) |
 					    ((low & 0xFF000000) >> 24);
 					low = (low << 8) | *p;
 				}
@@ -685,7 +685,7 @@ asn1_print(struct be *elem)
 			o = (o << ASN_SHIFT7) + (*p & ~ASN_BIT8);
 			if (*p & ASN_LONGLEN)
 			        continue;
-			
+
 			/*
 			 * first subitem encodes two items with 1st*OIDMUX+2nd
 			 * (see X.690:1997 clause 8.19 for the details)
@@ -725,7 +725,7 @@ asn1_print(struct be *elem)
 		        break;
 		}
 		d = elem->data.uns64.high * 4294967296.0;	/* 2^32 */
-		if (elem->data.uns64.high <= 0x1fffff) { 
+		if (elem->data.uns64.high <= 0x1fffff) {
 		        d += elem->data.uns64.low;
 #if 0 /*is looks illegal, but what is the intention?*/
 			printf("%.f", d);
@@ -876,7 +876,7 @@ static void smi_decode_oid(struct be *elem, unsigned int *oid,
 	        o = (o << ASN_SHIFT7) + (*p & ~ASN_BIT8);
 		if (*p & ASN_LONGLEN)
 		    continue;
-	    
+
 		/*
 		 * first subitem encodes two items with 1st*OIDMUX+2nd
 		 * (see X.690:1997 clause 8.19 for the details)
@@ -914,7 +914,7 @@ static int smi_check_a_range(SmiType *smiType, SmiRange *smiRange,
 			     struct be *elem)
 {
     int ok = 1;
-    
+
     switch (smiType->basetype) {
     case SMI_BASETYPE_OBJECTIDENTIFIER:
     case SMI_BASETYPE_OCTETSTRING:
@@ -931,12 +931,12 @@ static int smi_check_a_range(SmiType *smiType, SmiRange *smiRange,
 	ok = (elem->data.integer >= smiRange->minValue.value.integer32
 	      && elem->data.integer <= smiRange->maxValue.value.integer32);
 	break;
-	    
+
     case SMI_BASETYPE_UNSIGNED32:
 	ok = (elem->data.uns >= smiRange->minValue.value.unsigned32
 	      && elem->data.uns <= smiRange->maxValue.value.unsigned32);
 	break;
-	
+
     case SMI_BASETYPE_UNSIGNED64:
 	/* XXX */
 	break;
@@ -1066,7 +1066,7 @@ static void smi_print_value(SmiNode *smiNode, u_char pduid, struct be *elem)
 	/* apply display hints (integer, octetstring) */
 
 	/* convert instance identifier to index type values */
-	
+
 	switch (elem->type) {
 	case BE_OID:
 	        if (smiType->basetype == SMI_BASETYPE_BITS) {
@@ -1083,7 +1083,7 @@ static void smi_print_value(SmiNode *smiNode, u_char pduid, struct be *elem)
 				}
 				fputs(smiNode->name, stdout);
 				if (smiNode->oidlen < oidlen) {
-				        for (i = smiNode->oidlen; 
+				        for (i = smiNode->oidlen;
 					     i < oidlen; i++) {
 					        printf(".%u", oid[i]);
 					}
@@ -1434,7 +1434,7 @@ pdu_print(const u_char *np, u_int length, int version)
 	np = (u_char *)pdu.data.raw;
 
 	if (version == SNMP_VERSION_1 &&
-	    (pdu.id == GETBULKREQ || pdu.id == INFORMREQ || 
+	    (pdu.id == GETBULKREQ || pdu.id == INFORMREQ ||
 	     pdu.id == V2TRAP || pdu.id == REPORT)) {
 	        printf("[v2 PDU in v1 message]");
 		return;
@@ -1586,7 +1586,7 @@ usm_print(const u_char *np, u_int length)
 		asn1_print(&elem);
 		return;
 	}
-	if (vflag) 
+	if (vflag)
 	        printf("B=%d ", elem.data.integer);
 	length -= count;
 	np += count;
@@ -1599,7 +1599,7 @@ usm_print(const u_char *np, u_int length)
 		asn1_print(&elem);
 		return;
 	}
-	if (vflag) 
+	if (vflag)
 	        printf("T=%d ", elem.data.integer);
 	length -= count;
 	np += count;
@@ -1706,7 +1706,7 @@ v3msg_print(const u_char *np, u_int length)
 		return;
 	}
 	flags = elem.data.str[0];
-	if (flags != 0x00 && flags != 0x01 && flags != 0x03 
+	if (flags != 0x00 && flags != 0x01 && flags != 0x03
 	    && flags != 0x04 && flags != 0x05 && flags != 0x07) {
 		printf("[msgFlags=0x%02X]", flags);
 		return;
diff --git a/print-stp.c b/print-stp.c
index fbaa15b3..7a478e1c 100644
--- a/print-stp.c
+++ b/print-stp.c
@@ -11,7 +11,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-stp.c,v 1.7 2002-05-29 09:59:12 guy Exp $";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-stp.c,v 1.8 2002-06-11 17:08:57 itojun Exp $";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -82,7 +82,7 @@ stp_print(const u_char *p, u_int length)
 		printf("unknown version");
 		return;
 	}
-		
+
 	switch (p[6])
 	{
 	case 0:
diff --git a/print-telnet.c b/print-telnet.c
index 5af97c2c..308e9248 100644
--- a/print-telnet.c
+++ b/print-telnet.c
@@ -37,11 +37,11 @@
  */
 /*
  *      @(#)Copyright (c) 1994, Simon J. Gerraty.
- *      
+ *
  *      This is free software.  It comes with NO WARRANTY.
- *      Permission to use, modify and distribute this source code 
+ *      Permission to use, modify and distribute this source code
  *      is granted subject to the following conditions.
- *      1/ that the above copyright notice and this notice 
+ *      1/ that the above copyright notice and this notice
  *      are preserved in all copies.
  */
 
@@ -51,7 +51,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-     "@(#) $Header: /tcpdump/master/tcpdump/print-telnet.c,v 1.18 2001-09-10 06:40:08 fenner Exp $";
+     "@(#) $Header: /tcpdump/master/tcpdump/print-telnet.c,v 1.19 2002-06-11 17:08:57 itojun Exp $";
 #endif
 
 #include <sys/param.h>
@@ -237,7 +237,7 @@ telnet_print(const u_char *sp, u_int length)
 	int l;
 
 	osp = sp;
-	
+
 	while (length > 0 && *sp == IAC) {
 		l = telnet_parse(sp, length, 0);
 		if (l < 0)
diff --git a/print-token.c b/print-token.c
index 1690b3c9..033bf650 100644
--- a/print-token.c
+++ b/print-token.c
@@ -25,7 +25,7 @@
  */
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-token.c,v 1.15 2002-05-29 10:06:27 guy Exp $";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-token.c,v 1.16 2002-06-11 17:08:57 itojun Exp $";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -145,13 +145,13 @@ token_print(const u_char *p, u_int length, u_int caplen)
 		if (vflag) {
 			printf("%s ", broadcast_indicator[BROADCAST(trp)]);
 			printf("%s", direction[DIRECTION(trp)]);
-     
+
 			for (seg = 0; seg < SEGMENT_COUNT(trp); seg++)
 				printf(" [%d:%d]", RING_NUMBER(trp, seg),
 				    BRIDGE_NUMBER(trp, seg));
 		} else {
 			printf("rt = %x", ntohs(trp->token_rcf));
- 
+
 			for (seg = 0; seg < SEGMENT_COUNT(trp); seg++)
 				printf(":%x", ntohs(trp->token_rseg[seg]));
 		}
diff --git a/print-udp.c b/print-udp.c
index 7a40b660..c27989f6 100644
--- a/print-udp.c
+++ b/print-udp.c
@@ -21,7 +21,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/print-udp.c,v 1.103 2001-12-03 02:06:10 itojun Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/print-udp.c,v 1.104 2002-06-11 17:08:58 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -620,23 +620,23 @@ udp_print(register const u_char *bp, u_int length,
 		else if (ISPORT(L2TP_PORT))
 			l2tp_print((const u_char *)(up + 1), length);
 #ifdef TCPDUMP_DO_SMB
- 		else if (ISPORT(NETBIOS_NS_PORT))
+		else if (ISPORT(NETBIOS_NS_PORT))
 			nbt_udp137_print((const u_char *)(up + 1), length);
- 		else if (ISPORT(NETBIOS_DGRAM_PORT))
- 			nbt_udp138_print((const u_char *)(up + 1), length);
+		else if (ISPORT(NETBIOS_DGRAM_PORT))
+			nbt_udp138_print((const u_char *)(up + 1), length);
 #endif
 		else if (dport == 3456)
 			vat_print((const void *)(up + 1), length, up);
 		else if (ISPORT(ZEPHYR_SRV_PORT) || ISPORT(ZEPHYR_CLT_PORT))
 			zephyr_print((const void *)(up + 1), length);
- 		/*
- 		 * Since there are 10 possible ports to check, I think
- 		 * a <> test would be more efficient
- 		 */
- 		else if ((sport >= RX_PORT_LOW && sport <= RX_PORT_HIGH) ||
- 			 (dport >= RX_PORT_LOW && dport <= RX_PORT_HIGH))
- 			rx_print((const void *)(up + 1), length, sport, dport,
- 				 (u_char *) ip);
+		/*
+		 * Since there are 10 possible ports to check, I think
+		 * a <> test would be more efficient
+		 */
+		else if ((sport >= RX_PORT_LOW && sport <= RX_PORT_HIGH) ||
+			 (dport >= RX_PORT_LOW && dport <= RX_PORT_HIGH))
+			rx_print((const void *)(up + 1), length, sport, dport,
+				 (u_char *) ip);
 #ifdef INET6
 		else if (ISPORT(RIPNG_PORT))
 			ripng_print((const u_char *)(up + 1), length);
@@ -654,11 +654,11 @@ udp_print(register const u_char *bp, u_int length,
 			cisco_autorp_print((const void *)(up + 1), length);
 		else if (ISPORT(RADIUS_PORT) ||
 			 ISPORT(RADIUS_NEW_PORT) ||
-			 ISPORT(RADIUS_ACCOUNTING_PORT) || 
+			 ISPORT(RADIUS_ACCOUNTING_PORT) ||
 			 ISPORT(RADIUS_NEW_ACCOUNTING_PORT) )
 			radius_print((const u_char *)(up+1), length);
 		else if (dport == HSRP_PORT)
- 			hsrp_print((const u_char *)(up + 1), length);
+			hsrp_print((const u_char *)(up + 1), length);
 		else if (ISPORT(LWRES_PORT))
 			lwres_print((const u_char *)(up + 1), length);
 		else
diff --git a/rx.h b/rx.h
index 8a3e7a89..29da644b 100644
--- a/rx.h
+++ b/rx.h
@@ -5,7 +5,7 @@
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
- *  
+ *
  *   1. Redistributions of source code must retain the above copyright
  *      notice, this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright
@@ -15,7 +15,7 @@
  *   3. The names of the authors may not be used to endorse or promote
  *      products derived from this software without specific prior
  *      written permission.
- *  
+ *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
@@ -23,7 +23,7 @@
 /*
  * Rx protocol format
  *
- * $Id: rx.h,v 1.5 2001-10-22 04:23:37 itojun Exp $
+ * $Id: rx.h,v 1.6 2002-06-11 17:08:59 itojun Exp $
  */
 
 #define FS_RX_PORT	7000
diff --git a/sctpConstants.h b/sctpConstants.h
index decab1d8..17f43e8b 100644
--- a/sctpConstants.h
+++ b/sctpConstants.h
@@ -1,4 +1,4 @@
-/* @(#) $Header: /tcpdump/master/tcpdump/sctpConstants.h,v 1.2 2001-06-28 10:17:22 guy Exp $ (LBL) */
+/* @(#) $Header: /tcpdump/master/tcpdump/sctpConstants.h,v 1.3 2002-06-11 17:08:59 itojun Exp $ (LBL) */
 
 /* SCTP reference Implementation Copyright (C) 1999 Cisco And Motorola
  *
@@ -31,14 +31,14 @@
  *
  * This file is part of the SCTP reference Implementation
  *
- * 
+ *
  * Please send any bug reports or fixes you make to one of the following email
  * addresses:
- * 
+ *
  * rstewar1@email.mot.com
  * kmorneau@cisco.com
  * qxie1@email.mot.com
- * 
+ *
  * Any bugs reported given to us we will try to fix... any fixes shared will
  * be incorperated into the next SCTP release.
  */
@@ -58,7 +58,7 @@
    */
 /*#define USE_MD5 1*/
 
-/* the SCTP protocol signature 
+/* the SCTP protocol signature
  * this includes the version number
  * encoded in the last 4 bits of the
  * signature.
@@ -82,7 +82,7 @@
 /* default max I can burst out after a fast retransmit */
 #define SCTP_DEF_MAX_BURST 4
 
-/* Packet transmit states in the sent 
+/* Packet transmit states in the sent
  * field in the SCTP_transmitOnQueue struct
  */
 #define SCTP_DATAGRAM_UNSENT 		0
@@ -106,8 +106,8 @@
 #define SCTP_DATA		0x00
 #define SCTP_INITIATION		0x01
 #define SCTP_INITIATION_ACK	0x02
-#define SCTP_SELECTIVE_ACK	0x03 
-#define SCTP_HEARTBEAT_REQUEST	0x04	
+#define SCTP_SELECTIVE_ACK	0x03
+#define SCTP_HEARTBEAT_REQUEST	0x04
 #define SCTP_HEARTBEAT_ACK	0x05
 #define SCTP_ABORT_ASSOCIATION	0x06
 #define SCTP_SHUTDOWN		0x07
@@ -239,7 +239,7 @@
 #define SCTP_STARTING_MAPARRAY 10000
 
 /* Here we define the timer types used
- * by the implementation has 
+ * by the implementation has
  * arguments in the set/get timer type calls.
  */
 #define SCTP_TIMER_INIT 	0
@@ -248,7 +248,7 @@
 #define SCTP_TIMER_SHUTDOWN	3
 #define SCTP_TIMER_HEARTBEAT	4
 #define SCTP_TIMER_PMTU		5
-/* number of timer types in the base SCTP 
+/* number of timer types in the base SCTP
  * structure used in the set/get and has
  * the base default.
  */
@@ -352,7 +352,7 @@
 
 /* Events that SCTP will look for, these
  * are or'd together to declare what SCTP
- * wants. Each select mask/poll list should be 
+ * wants. Each select mask/poll list should be
  * set for the fd, if the bit is on.
  */
 #define SCTP_EVENT_READ		0x000001
@@ -361,7 +361,7 @@
 
 /* The following constant is a value for this
  * particular implemenation. It is quite arbitrary and
- * is used to limit how much data will be queued up to 
+ * is used to limit how much data will be queued up to
  * a sender, waiting for cwnd to be larger than flightSize.
  * All implementations will need this protection is some
  * way due to buffer size constraints.
@@ -371,9 +371,9 @@
 
 
 
-/* This constant (SCTP_MAX_READBUFFER) define 
+/* This constant (SCTP_MAX_READBUFFER) define
  * how big the read/write buffer is
- * when we enter the fd event notification 
+ * when we enter the fd event notification
  * the buffer is put on the stack, so the bigger
  * it is the more stack you chew up, however it
  * has got to be big enough to handle the bigest
@@ -392,7 +392,7 @@
 #define SCTP_MIN_RWND	1500
 
 #define SCTP_WINDOW_MIN	1500	/* smallest rwnd can be */
-#define SCTP_WINDOW_MAX 1048576	/* biggest I can grow rwnd to 
+#define SCTP_WINDOW_MAX 1048576	/* biggest I can grow rwnd to
 				 * My playing around suggests a
 				 * value greater than 64k does not
 				 * do much, I guess via the kernel
@@ -411,7 +411,7 @@
 					 * size to. This governs what is the
 					 * largest size we will use, of course
 					 * PMTU will raise this up to
-					 * the largest interface MTU or the 
+					 * the largest interface MTU or the
 					 * ceiling below if there is no
 					 * SIOCGIFMTU.
 					 */
@@ -542,7 +542,7 @@
 {							\
     (ts)->tv_sec  = (tv)->tv_sec;			\
     (ts)->tv_nsec = (tv)->tv_usec * 1000;		\
-}    
+}
 #endif
 
 /* pegs */
diff --git a/sctpHeader.h b/sctpHeader.h
index e6b14c4f..69a0ac82 100644
--- a/sctpHeader.h
+++ b/sctpHeader.h
@@ -1,4 +1,4 @@
-/* @(#) $Header: /tcpdump/master/tcpdump/sctpHeader.h,v 1.3 2001-08-01 03:34:00 guy Exp $ (LBL) */
+/* @(#) $Header: /tcpdump/master/tcpdump/sctpHeader.h,v 1.4 2002-06-11 17:08:59 itojun Exp $ (LBL) */
 
 /* SCTP reference Implementation Copyright (C) 1999 Cisco And Motorola
  *
@@ -31,14 +31,14 @@
  *
  * This file is part of the SCTP reference Implementation
  *
- * 
+ *
  * Please send any bug reports or fixes you make to one of the following email
  * addresses:
- * 
+ *
  * rstewar1@email.mot.com
  * kmorneau@cisco.com
  * qxie1@email.mot.com
- * 
+ *
  * Any bugs reported given to us we will try to fix... any fixes shared will
  * be incorperated into the next SCTP release.
  */
@@ -57,7 +57,7 @@ extern "C" {
 
 #ifdef TRU64
  #define _64BITS 1
-#endif 
+#endif
 
 struct sctpHeader{
   u_short source;
@@ -149,7 +149,7 @@ struct cookieMessage{
   u_short locScope;			/* V6 local scope flag */
   u_short siteScope;			/* V6 site scope flag */
   /* at the end is tacked on the INIT chunk sent in
-   * its entirety and of course our 
+   * its entirety and of course our
    * signature.
    */
 };
@@ -171,10 +171,10 @@ struct sctpSendableInit{
 };
 
 
-/* Selective Acknowledgement 
+/* Selective Acknowledgement
  * has the following structure with
  * a optional ammount of trailing int's
- * on the last part (based on the numberOfDesc 
+ * on the last part (based on the numberOfDesc
  * field).
  */
 
@@ -197,7 +197,7 @@ struct sctpUnifiedSack{
 };
 
 /* for both RTT request/response the
- * following is sent 
+ * following is sent
  */
 
 struct sctpHBrequest {
@@ -220,10 +220,10 @@ struct sctpHBsender{
   char addrFmt[SCTP_ADDRMAX];
   unsigned short userreq;
 };
-  
 
 
-/* for the abort and shutdown ACK 
+
+/* for the abort and shutdown ACK
  * we must carry the init tag in the common header. Just the
  * common header is all that is needed with a chunk descriptor.
  */
@@ -308,13 +308,13 @@ struct sctpUnifiedDatagram{
 struct sctpECN_echo{
   struct sctpChunkDesc uh;
   u_int Lowest_TSN;
-};    
+};
 
 
 struct sctpCWR{
   struct sctpChunkDesc uh;
   u_int TSN_reduced_at;
-};    
+};
 
 #ifdef	__cplusplus
 }
diff --git a/sll.h b/sll.h
index 541bbc53..8b342dc4 100644
--- a/sll.h
+++ b/sll.h
@@ -4,7 +4,7 @@
  *
  * This code is derived from the Stanford/CMU enet packet filter,
  * (net/enet.c) distributed as part of 4.3BSD, and code contributed
- * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence 
+ * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence
  * Berkeley Laboratory.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -35,7 +35,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#) $Header: /tcpdump/master/tcpdump/sll.h,v 1.4 2000-12-23 07:52:11 guy Exp $ (LBL)
+ * @(#) $Header: /tcpdump/master/tcpdump/sll.h,v 1.5 2002-06-11 17:09:00 itojun Exp $ (LBL)
  */
 
 /*
diff --git a/smb.h b/smb.h
index 89bff00c..eb25d14a 100644
--- a/smb.h
+++ b/smb.h
@@ -1,5 +1,5 @@
-/* @(#) $Header: /tcpdump/master/tcpdump/smb.h,v 1.7 2002-01-17 04:38:29 guy Exp $ (LBL) */
-/* 
+/* @(#) $Header: /tcpdump/master/tcpdump/smb.h,v 1.8 2002-06-11 17:09:00 itojun Exp $ (LBL) */
+/*
  * Copyright (C) Andrew Tridgell 1995-1999
  *
  * This software may be distributed either under the terms of the
diff --git a/tcpdump.c b/tcpdump.c
index 294f74b8..6becb9b3 100644
--- a/tcpdump.c
+++ b/tcpdump.c
@@ -30,7 +30,7 @@ static const char copyright[] =
     "@(#) Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000\n\
 The Regents of the University of California.  All rights reserved.\n";
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/tcpdump.c,v 1.176 2002-05-16 10:25:58 guy Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/tcpdump.c,v 1.177 2002-06-11 17:09:00 itojun Exp $ (LBL)";
 #endif
 
 /*
@@ -219,7 +219,7 @@ main(int argc, char **argv)
 #ifdef LIBSMI
 	smiInit("tcpdump");
 #endif
-	
+
 	opterr = 0;
 	while (
 	    (op = getopt(argc, argv, "aAc:C:deE:fF:i:lm:nNOpqr:Rs:StT:uvw:xXY")) != -1)
@@ -233,7 +233,7 @@ main(int argc, char **argv)
                        ++xflag;
                        ++Xflag;
                        ++Aflag;
-                       break; 
+                       break;
 
 		case 'c':
 			cnt = atoi(optarg);
@@ -243,7 +243,7 @@ main(int argc, char **argv)
 
 		case 'C':
 			Cflag = atoi(optarg) * 1000000;
-			if (Cflag < 0) 
+			if (Cflag < 0)
 				error("invalid file size %s", optarg);
 			break;
 
@@ -301,7 +301,7 @@ main(int argc, char **argv)
 				      program_name, optarg);
 			(void)fprintf(stderr, "(no libsmi support)\n");
 #endif
-			
+
 		case 'O':
 			Oflag = 0;
 			break;
@@ -364,7 +364,7 @@ main(int argc, char **argv)
 		case 'u':
 			++uflag;
 			break;
-			
+
 		case 'v':
 			++vflag;
 			break;
@@ -378,7 +378,7 @@ main(int argc, char **argv)
 			break;
 
 		case 'X':
-    		        ++xflag;
+		        ++xflag;
 			++Xflag;
 			break;
 
@@ -574,7 +574,7 @@ dump_and_trunc(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)
 	char *name;
 
 	info = (struct dump_info *)user;
-	
+
 	/*
 	 * XXX - this won't prevent capture files from getting
 	 * larger than Cflag - the last packet written to the
diff --git a/telnet.h b/telnet.h
index d712a7ee..345c7846 100644
--- a/telnet.h
+++ b/telnet.h
@@ -1,4 +1,4 @@
-/* @(#) $Header: /tcpdump/master/tcpdump/telnet.h,v 1.3 2001-09-17 21:58:06 fenner Exp $ (LBL) */
+/* @(#) $Header: /tcpdump/master/tcpdump/telnet.h,v 1.4 2002-06-11 17:09:01 itojun Exp $ (LBL) */
 
 /*	$NetBSD: telnet.h,v 1.9 2001/06/11 01:50:50 wiz Exp $	*/
 
@@ -220,12 +220,12 @@ const char *telopts[NTELOPTS+1] = {
  * list of names if SLC_NAMES is not defined.
  */
 #define	SLC_NAMELIST	"0", "SYNCH", "BRK", "IP", "AO", "AYT", "EOR",	\
- 			"ABORT", "EOF", "SUSP", "EC", "EL", "EW", "RP",	\
- 			"LNEXT", "XON", "XOFF", "FORW1", "FORW2",	\
- 			"MCL", "MCR", "MCWL", "MCWR", "MCBOL",		\
- 			"MCEOL", "INSRT", "OVER", "ECR", "EWR",		\
- 			"EBOL", "EEOL",					\
- 			0,
+			"ABORT", "EOF", "SUSP", "EC", "EL", "EW", "RP",	\
+			"LNEXT", "XON", "XOFF", "FORW1", "FORW2",	\
+			"MCL", "MCR", "MCWL", "MCWR", "MCBOL",		\
+			"MCEOL", "INSRT", "OVER", "ECR", "EWR",		\
+			"EBOL", "EEOL",					\
+			0,
 
 #ifdef	SLC_NAMES
 const char *slc_names[] = {
diff --git a/util.c b/util.c
index fb849c6f..c45277e8 100644
--- a/util.c
+++ b/util.c
@@ -21,7 +21,7 @@
 
 #ifndef lint
 static const char rcsid[] =
-    "@(#) $Header: /tcpdump/master/tcpdump/util.c,v 1.72 2001-10-08 16:12:13 fenner Exp $ (LBL)";
+    "@(#) $Header: /tcpdump/master/tcpdump/util.c,v 1.73 2002-06-11 17:09:01 itojun Exp $ (LBL)";
 #endif
 
 #ifdef HAVE_CONFIG_H
@@ -145,7 +145,7 @@ ts_print(register const struct timeval *tvp)
 		} else {
 			int d_usec = tvp->tv_usec - b_usec;
 			int d_sec = tvp->tv_sec - b_sec;
-			
+
 			while (d_usec < 0) {
 				d_usec += 1000000;
 				d_sec--;

