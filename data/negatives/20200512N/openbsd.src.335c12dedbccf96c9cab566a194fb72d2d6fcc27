commit 335c12dedbccf96c9cab566a194fb72d2d6fcc27
Author: mickey <mickey@openbsd.org>
Date:   Thu Jan 19 17:54:47 2006 +0000

    redo (w/ proper changes everywhere ;):
    take interp[MAXPATHLEN] off the stack.  from mickey, ok otto
    while here, switch above from malloc to pool, remove stupid casts
    tedu@ miod@ ok

diff --git a/sys/compat/freebsd/freebsd_exec.c b/sys/compat/freebsd/freebsd_exec.c
index f8f496577a6..6c545c299ca 100644
--- a/sys/compat/freebsd/freebsd_exec.c
+++ b/sys/compat/freebsd/freebsd_exec.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: freebsd_exec.c,v 1.16 2004/04/15 00:22:42 tedu Exp $	*/
+/*	$OpenBSD: freebsd_exec.c,v 1.17 2006/01/19 17:54:50 mickey Exp $	*/
 /*	$NetBSD: freebsd_exec.c,v 1.2 1996/05/18 16:02:08 christos Exp $	*/
 
 /*
@@ -174,7 +174,7 @@ freebsd_elf_probe(p, epp, itp, pos, os)
 		if (brand == NULL || strcmp(brand, "FreeBSD") != 0)
 			return (EINVAL);
 	}
-	if (itp[0]) {
+	if (itp) {
 		if ((error = emul_find(p, NULL, freebsd_emul_path, itp, &bp, 0)))
 			return (error);
 		if ((error = copystr(bp, itp, MAXPATHLEN, &len)))
diff --git a/sys/compat/linux/linux_exec.c b/sys/compat/linux/linux_exec.c
index b96be60a26b..ae096b470a5 100644
--- a/sys/compat/linux/linux_exec.c
+++ b/sys/compat/linux/linux_exec.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: linux_exec.c,v 1.24 2005/12/30 19:46:55 miod Exp $	*/
+/*	$OpenBSD: linux_exec.c,v 1.25 2006/01/19 17:54:52 mickey Exp $	*/
 /*	$NetBSD: linux_exec.c,v 1.13 1996/04/05 00:01:10 christos Exp $	*/
 
 /*-
@@ -485,7 +485,7 @@ linux_elf_probe(p, epp, itp, pos, os)
 	brand = elf32_check_brand(eh);
 	if (brand && strcmp(brand, "Linux"))
 		return (EINVAL);
-	if (itp[0]) {
+	if (itp) {
 		if ((error = emul_find(p, NULL, linux_emul_path, itp, &bp, 0)))
 			return (error);
 		if ((error = copystr(bp, itp, MAXPATHLEN, &len)))
diff --git a/sys/compat/netbsd/netbsd_exec.c b/sys/compat/netbsd/netbsd_exec.c
index d6c7f9e2910..65df435fbe3 100644
--- a/sys/compat/netbsd/netbsd_exec.c
+++ b/sys/compat/netbsd/netbsd_exec.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: netbsd_exec.c,v 1.11 2004/04/15 00:22:42 tedu Exp $	 */
+/*	$OpenBSD: netbsd_exec.c,v 1.12 2006/01/19 17:54:54 mickey Exp $	 */
 /*	$NetBSD: svr4_exec.c,v 1.16 1995/10/14 20:24:20 christos Exp $	 */
 
 /*
@@ -94,7 +94,7 @@ netbsd_elf64_probe(p, epp, itp, pos, os)
 	if (elf64_os_pt_note(p, epp, eh, "NetBSD\0", 7, 4))
 		return (EINVAL);
 
-	if (itp[0]) {
+	if (itp) {
 		if ((error = emul_find(p, NULL, netbsd_emul_path, itp, &bp, 0)))
 			return (error);
 		if ((error = copystr(bp, itp, MAXPATHLEN, &len)))
diff --git a/sys/compat/svr4/svr4_exec.c b/sys/compat/svr4/svr4_exec.c
index fdfe8756bc1..0f06a6ce105 100644
--- a/sys/compat/svr4/svr4_exec.c
+++ b/sys/compat/svr4/svr4_exec.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: svr4_exec.c,v 1.14 2002/03/14 01:26:51 millert Exp $	 */
+/*	$OpenBSD: svr4_exec.c,v 1.15 2006/01/19 17:54:56 mickey Exp $	 */
 /*	$NetBSD: svr4_exec.c,v 1.16 1995/10/14 20:24:20 christos Exp $	 */
 
 /*
@@ -126,7 +126,7 @@ svr4_elf_probe(p, epp, itp, pos, os)
 	int error;
 	size_t len;
 
-	if (itp[0]) {
+	if (itp) {
 		if ((error = emul_find(p, NULL, svr4_emul_path, itp, &bp, 0)))
 			return (error);
 		if ((error = copystr(bp, itp, MAXPATHLEN, &len)))
diff --git a/sys/kern/exec_elf.c b/sys/kern/exec_elf.c
index 5b11805837d..bddf0d9151c 100644
--- a/sys/kern/exec_elf.c
+++ b/sys/kern/exec_elf.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: exec_elf.c,v 1.52 2006/01/07 04:18:47 aaron Exp $	*/
+/*	$OpenBSD: exec_elf.c,v 1.53 2006/01/19 17:54:47 mickey Exp $	*/
 
 /*
  * Copyright (c) 1996 Per Fogelstrom
@@ -36,6 +36,7 @@
 #include <sys/kernel.h>
 #include <sys/proc.h>
 #include <sys/malloc.h>
+#include <sys/pool.h>
 #include <sys/mount.h>
 #include <sys/namei.h>
 #include <sys/vnode.h>
@@ -393,7 +394,7 @@ ELFNAME(load_file)(struct proc *p, char *path, struct exec_package *epp,
 	}
 
 	phsize = eh.e_phnum * sizeof(Elf_Phdr);
-	ph = (Elf_Phdr *)malloc(phsize, M_TEMP, M_WAITOK);
+	ph = malloc(phsize, M_TEMP, M_WAITOK);
 
 	if ((error = ELFNAME(read_from)(p, nd.ni_vp, eh.e_phoff, (caddr_t)ph,
 	    phsize)) != 0)
@@ -514,7 +515,7 @@ bad1:
 	VOP_CLOSE(nd.ni_vp, FREAD, p->p_ucred, p);
 bad:
 	if (ph != NULL)
-		free((char *)ph, M_TEMP);
+		free(ph, M_TEMP);
 
 	*last = addr;
 	vput(nd.ni_vp);
@@ -537,7 +538,7 @@ ELFNAME2(exec,makecmds)(struct proc *p, struct exec_package *epp)
 	Elf_Phdr *ph, *pp;
 	Elf_Addr phdr = 0;
 	int error, i;
-	char interp[MAXPATHLEN];
+	char *interp = NULL;
 	u_long pos = 0, phsize;
 	u_int8_t os = OOS_NULL;
 
@@ -564,7 +565,7 @@ ELFNAME2(exec,makecmds)(struct proc *p, struct exec_package *epp)
 	 * from the file
 	 */
 	phsize = eh->e_phnum * sizeof(Elf_Phdr);
-	ph = (Elf_Phdr *)malloc(phsize, M_TEMP, M_WAITOK);
+	ph = malloc(phsize, M_TEMP, M_WAITOK);
 
 	if ((error = ELFNAME(read_from)(p, epp->ep_vp, eh->e_phoff, (caddr_t)ph,
 	    phsize)) != 0)
@@ -573,16 +574,16 @@ ELFNAME2(exec,makecmds)(struct proc *p, struct exec_package *epp)
 	epp->ep_tsize = ELFDEFNNAME(NO_ADDR);
 	epp->ep_dsize = ELFDEFNNAME(NO_ADDR);
 
-	interp[0] = '\0';
-
 	for (i = 0; i < eh->e_phnum; i++) {
 		pp = &ph[i];
 		if (pp->p_type == PT_INTERP) {
-			if (pp->p_filesz >= sizeof(interp))
+			if (pp->p_filesz >= MAXPATHLEN)
 				goto bad;
+			interp = pool_get(&namei_pool, PR_WAITOK);
 			if ((error = ELFNAME(read_from)(p, epp->ep_vp,
-			    pp->p_offset, (caddr_t)interp, pp->p_filesz)) != 0)
+			    pp->p_offset, interp, pp->p_filesz)) != 0) {
 				goto bad;
+			}
 			break;
 		}
 	}
@@ -600,7 +601,7 @@ ELFNAME2(exec,makecmds)(struct proc *p, struct exec_package *epp)
 	 *
 	 * Probe functions would normally see if the interpreter (if any)
 	 * exists. Emulation packages may possibly replace the interpreter in
-	 * interp[] with a changed path (/emul/xxx/<path>), and also
+	 * *interp with a changed path (/emul/xxx/<path>), and also
 	 * set the ep_emul field in the exec package structure.
 	 */
 	error = ENOEXEC;
@@ -716,21 +717,17 @@ native:
 	if (epp->ep_tsize == ELFDEFNNAME(NO_ADDR))
 		epp->ep_tsize = 0;
 
+	epp->ep_interp = interp;
+	epp->ep_entry = eh->e_entry;
+
 	/*
 	 * Check if we found a dynamically linked binary and arrange to load
 	 * it's interpreter when the exec file is released.
 	 */
-	if (interp[0]) {
-		char *ip;
+	if (interp) {
 		struct elf_args *ap;
 
-		ip = (char *)malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
-		ap = (struct elf_args *)
-		    malloc(sizeof(struct elf_args), M_TEMP, M_WAITOK);
-
-		bcopy(interp, ip, MAXPATHLEN);
-		epp->ep_interp = ip;
-		epp->ep_interp_pos = pos;
+		ap = malloc(sizeof(struct elf_args), M_TEMP, M_WAITOK);
 
 		ap->arg_phaddr = phdr;
 		ap->arg_phentsize = eh->e_phentsize;
@@ -739,10 +736,7 @@ native:
 		ap->arg_os = os;
 
 		epp->ep_emul_arg = ap;
-		epp->ep_entry = eh->e_entry; /* keep check_exec() happy */
-	} else {
-		epp->ep_interp = NULL;
-		epp->ep_entry = eh->e_entry;
+		epp->ep_interp_pos = pos;
 	}
 
 #if defined(COMPAT_SVR4) && defined(i386)
@@ -754,12 +748,14 @@ native:
 		    epp->ep_vp, 0, VM_PROT_READ);
 #endif
 
-	free((char *)ph, M_TEMP);
+	free(ph, M_TEMP);
 	vn_marktext(epp->ep_vp);
 	return (exec_setup_stack(p, epp));
 
 bad:
-	free((char *)ph, M_TEMP);
+	if (interp)
+		pool_put(&namei_pool, interp);
+	free(ph, M_TEMP);
 	kill_vmcmds(&epp->ep_vmcmds);
 	return (ENOEXEC);
 }
@@ -781,12 +777,12 @@ ELFNAME2(exec,fixup)(struct proc *p, struct exec_package *epp)
 		return (0);
 	}
 
-	interp = (char *)epp->ep_interp;
-	ap = (struct elf_args *)epp->ep_emul_arg;
+	interp = epp->ep_interp;
+	ap = epp->ep_emul_arg;
 
 	if ((error = ELFNAME(load_file)(p, interp, epp, ap, &pos)) != 0) {
-		free((char *)ap, M_TEMP);
-		free((char *)interp, M_TEMP);
+		free(ap, M_TEMP);
+		pool_put(&namei_pool, interp);
 		kill_vmcmds(&epp->ep_vmcmds);
 		return (error);
 	}
@@ -836,8 +832,8 @@ ELFNAME2(exec,fixup)(struct proc *p, struct exec_package *epp)
 
 		error = copyout(ai, epp->ep_emul_argp, sizeof ai);
 	}
-	free((char *)ap, M_TEMP);
-	free((char *)interp, M_TEMP);
+	free(ap, M_TEMP);
+	pool_put(&namei_pool, interp);
 	return (error);
 }
 
@@ -863,7 +859,7 @@ ELFNAME(os_pt_note)(struct proc *p, struct exec_package *epp, Elf_Ehdr *eh,
 	int error;
 
 	phsize = eh->e_phnum * sizeof(Elf_Phdr);
-	hph = (Elf_Phdr *)malloc(phsize, M_TEMP, M_WAITOK);
+	hph = malloc(phsize, M_TEMP, M_WAITOK);
 	if ((error = ELFNAME(read_from)(p, epp->ep_vp, eh->e_phoff,
 	    (caddr_t)hph, phsize)) != 0)
 		goto out1;
@@ -874,7 +870,7 @@ ELFNAME(os_pt_note)(struct proc *p, struct exec_package *epp, Elf_Ehdr *eh,
 		    ph->p_filesz < sizeof(Elf_Note) + name_size)
 			continue;
 
-		np = (Elf_Note *)malloc(ph->p_filesz, M_TEMP, M_WAITOK);
+		np = malloc(ph->p_filesz, M_TEMP, M_WAITOK);
 		if ((error = ELFNAME(read_from)(p, epp->ep_vp, ph->p_offset,
 		    (caddr_t)np, ph->p_filesz)) != 0)
 			goto out2;
diff --git a/sys/kern/kern_exec.c b/sys/kern/kern_exec.c
index 3dc66fc2a06..2fa21ab332f 100644
--- a/sys/kern/kern_exec.c
+++ b/sys/kern/kern_exec.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: kern_exec.c,v 1.98 2005/12/07 19:04:53 deraadt Exp $	*/
+/*	$OpenBSD: kern_exec.c,v 1.99 2006/01/19 17:54:47 mickey Exp $	*/
 /*	$NetBSD: kern_exec.c,v 1.75 1996/02/09 18:59:28 christos Exp $	*/
 
 /*-
@@ -675,7 +675,7 @@ bad:
 		(void) fdrelease(p, pack.ep_fd);
 	}
 	if (pack.ep_interp != NULL)
-		FREE(pack.ep_interp, M_TEMP);
+		pool_put(&namei_pool, pack.ep_interp);
 	if (pack.ep_emul_arg != NULL)
 		FREE(pack.ep_emul_arg, M_TEMP);
 	/* close and put the exec'd file */
@@ -704,7 +704,7 @@ exec_abort:
 	uvm_deallocate(&vm->vm_map, VM_MIN_ADDRESS,
 		VM_MAXUSER_ADDRESS - VM_MIN_ADDRESS);
 	if (pack.ep_interp != NULL)
-		FREE(pack.ep_interp, M_TEMP);
+		pool_put(&namei_pool, pack.ep_interp);
 	if (pack.ep_emul_arg != NULL)
 		FREE(pack.ep_emul_arg, M_TEMP);
 	pool_put(&namei_pool, nid.ni_cnd.cn_pnbuf);

