commit 7727623d8cb5d5637a8af795f385e5e5b6e7d2ec
Author: Bill Meier <wmeier@newsguy.com>
Date:   Thu Nov 21 18:46:40 2013 +0000

    Do some constification;
    Create/use value_string_ext_free();
    Display certain numbers also as hex in the
       "forced to fall back to linear search: ..." value-string warning msg
    Add editor-modelines to some files;
    Do some whitespace changes.
    
    svn path=/trunk/; revision=53484

diff --git a/epan/dissectors/packet-diameter.c b/epan/dissectors/packet-diameter.c
index e984bfbb3a..9aa08c29f9 100644
--- a/epan/dissectors/packet-diameter.c
+++ b/epan/dissectors/packet-diameter.c
@@ -103,7 +103,7 @@ static gint exported_pdu_tap = -1;
 
 /* Conversation Info */
 typedef struct _diameter_conv_info_t {
-        wmem_tree_t *pdus_tree;
+	wmem_tree_t *pdus_tree;
 } diameter_conv_info_t;
 
 typedef struct _diam_ctx_t {
@@ -120,9 +120,9 @@ typedef const char *(*diam_avp_dissector_t)(diam_ctx_t *, diam_avp_t *, tvbuff_t
 
 
 typedef struct _diam_vnd_t {
-	guint32 code;
+	guint32  code;
 	GArray *vs_avps;
-	value_string_ext *vs_avps_ext;
+	const value_string_ext *vs_avps_ext;
 	GArray *vs_cmds;
 } diam_vnd_t;
 
@@ -326,18 +326,18 @@ static const char *avpflags_str[] = {
 static void
 export_diameter_pdu(packet_info *pinfo, tvbuff_t *tvb)
 {
-  exp_pdu_data_t *exp_pdu_data;
-  guint32 tags_bit_field;
+	exp_pdu_data_t *exp_pdu_data;
+	guint32 tags_bit_field;
 
-  tags_bit_field = EXP_PDU_TAG_IP_SRC_BIT + EXP_PDU_TAG_IP_DST_BIT + EXP_PDU_TAG_SRC_PORT_BIT+
-	  EXP_PDU_TAG_DST_PORT_BIT + EXP_PDU_TAG_ORIG_FNO_BIT;
+	tags_bit_field = EXP_PDU_TAG_IP_SRC_BIT + EXP_PDU_TAG_IP_DST_BIT + EXP_PDU_TAG_SRC_PORT_BIT+
+		EXP_PDU_TAG_DST_PORT_BIT + EXP_PDU_TAG_ORIG_FNO_BIT;
 
-  exp_pdu_data = load_export_pdu_tags(pinfo, "diameter", -1, tags_bit_field);
+	exp_pdu_data = load_export_pdu_tags(pinfo, "diameter", -1, tags_bit_field);
 
-  exp_pdu_data->tvb_length = tvb_length(tvb);
-  exp_pdu_data->pdu_tvb = tvb;
+	exp_pdu_data->tvb_length = tvb_length(tvb);
+	exp_pdu_data->pdu_tvb = tvb;
 
-  tap_queue_packet(exported_pdu_tap, pinfo, exp_pdu_data);
+	tap_queue_packet(exported_pdu_tap, pinfo, exp_pdu_data);
 
 }
 
@@ -347,9 +347,9 @@ compare_avps(const void *a, const void *b)
 	const value_string *vsa = (const value_string *)a;
 	const value_string *vsb = (const value_string *)b;
 
-	if(vsa->value > vsb->value)
+	if (vsa->value > vsb->value)
 		return 1;
-	if(vsa->value < vsb->value)
+	if (vsa->value < vsb->value)
 		return -1;
 
 	return 0;
@@ -479,16 +479,20 @@ dissect_diameter_avp(diam_ctx_t *c, tvbuff_t *tvb, int offset, diam_sub_dis_t *d
 		vendor = (diam_vnd_t *)a->vendor;
 	}
 
-	if(vendor->vs_avps_ext == NULL) {
+	if (vendor->vs_avps_ext == NULL) {
 		g_array_sort(vendor->vs_avps, compare_avps);
-		vendor->vs_avps_ext = value_string_ext_new(VND_AVP_VS(vendor), VND_AVP_VS_LEN(vendor)+1,
-							   g_strdup_printf("diameter_vendor_%s",val_to_str_ext_const(vendorid, &sminmpec_values_ext, "Unknown")));
+		vendor->vs_avps_ext = value_string_ext_new(VND_AVP_VS(vendor),
+							   VND_AVP_VS_LEN(vendor)+1,
+							   g_strdup_printf("diameter_vendor_%s",
+									   val_to_str_ext_const(vendorid,
+												&sminmpec_values_ext,
+												"Unknown")));
 #if 0
 		{ /* Debug code */
-			value_string *vendor_avp_vs=VALUE_STRING_EXT_VS_P(vendor->vs_avps_ext);
+			value_string *vendor_avp_vs = VALUE_STRING_EXT_VS_P(vendor->vs_avps_ext);
 			gint i = 0;
-			while(vendor_avp_vs[i].strptr!=NULL) {
-				g_warning("%u %s",vendor_avp_vs[i].value,vendor_avp_vs[i].strptr);
+			while (vendor_avp_vs[i].strptr != NULL) {
+				g_warning("%u %s", vendor_avp_vs[i].value, vendor_avp_vs[i].strptr);
 				i++;
 			}
 		}
@@ -523,15 +527,15 @@ dissect_diameter_avp(diam_ctx_t *c, tvbuff_t *tvb, int offset, diam_sub_dis_t *d
 		proto_tree_add_item(flags_tree,hf_diameter_avp_flags_mandatory,tvb,offset,1,ENC_BIG_ENDIAN);
 		proto_tree_add_item(flags_tree,hf_diameter_avp_flags_protected,tvb,offset,1,ENC_BIG_ENDIAN);
 		pi = proto_tree_add_item(flags_tree,hf_diameter_avp_flags_reserved3,tvb,offset,1,ENC_BIG_ENDIAN);
-		if(flags_bits & 0x10) expert_add_info(c->pinfo, pi, &ei_diameter_reserved_bit_set);
+		if (flags_bits & 0x10) expert_add_info(c->pinfo, pi, &ei_diameter_reserved_bit_set);
 		pi = proto_tree_add_item(flags_tree,hf_diameter_avp_flags_reserved4,tvb,offset,1,ENC_BIG_ENDIAN);
-		if(flags_bits & 0x08) expert_add_info(c->pinfo, pi, &ei_diameter_reserved_bit_set);
+		if (flags_bits & 0x08) expert_add_info(c->pinfo, pi, &ei_diameter_reserved_bit_set);
 		pi = proto_tree_add_item(flags_tree,hf_diameter_avp_flags_reserved5,tvb,offset,1,ENC_BIG_ENDIAN);
-		if(flags_bits & 0x04) expert_add_info(c->pinfo, pi, &ei_diameter_reserved_bit_set);
+		if (flags_bits & 0x04) expert_add_info(c->pinfo, pi, &ei_diameter_reserved_bit_set);
 		proto_tree_add_item(flags_tree,hf_diameter_avp_flags_reserved6,tvb,offset,1,ENC_BIG_ENDIAN);
-		if(flags_bits & 0x02) expert_add_info(c->pinfo, pi, &ei_diameter_reserved_bit_set);
+		if (flags_bits & 0x02) expert_add_info(c->pinfo, pi, &ei_diameter_reserved_bit_set);
 		proto_tree_add_item(flags_tree,hf_diameter_avp_flags_reserved7,tvb,offset,1,ENC_BIG_ENDIAN);
-		if(flags_bits & 0x01) expert_add_info(c->pinfo, pi, &ei_diameter_reserved_bit_set);
+		if (flags_bits & 0x01) expert_add_info(c->pinfo, pi, &ei_diameter_reserved_bit_set);
 	}
 	offset += 1;
 
@@ -633,7 +637,7 @@ proto_avp(diam_ctx_t *c, diam_avp_t *a, tvbuff_t *tvb, diam_sub_dis_t *diam_sub_
 
 	if (!t->handle) {
 		t->handle = find_dissector(t->name);
-		if(!t->handle) t->handle = data_handle;
+		if (!t->handle) t->handle = data_handle;
 	}
 
 	TRY {
@@ -942,13 +946,13 @@ dissect_diameter_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, voi
 		proto_tree_add_item(pt,hf_diameter_flags_error,tvb,4,1,ENC_BIG_ENDIAN);
 		proto_tree_add_item(pt,hf_diameter_flags_T,tvb,4,1,ENC_BIG_ENDIAN);
 		proto_tree_add_item(pt,hf_diameter_flags_reserved4,tvb,4,1,ENC_BIG_ENDIAN);
-		if(flags_bits & 0x08) expert_add_info(c->pinfo, pi, &ei_diameter_reserved_bit_set);
+		if (flags_bits & 0x08) expert_add_info(c->pinfo, pi, &ei_diameter_reserved_bit_set);
 		pi = proto_tree_add_item(pt,hf_diameter_flags_reserved5,tvb,4,1,ENC_BIG_ENDIAN);
-		if(flags_bits & 0x04) expert_add_info(c->pinfo, pi, &ei_diameter_reserved_bit_set);
+		if (flags_bits & 0x04) expert_add_info(c->pinfo, pi, &ei_diameter_reserved_bit_set);
 		pi = proto_tree_add_item(pt,hf_diameter_flags_reserved6,tvb,4,1,ENC_BIG_ENDIAN);
-		if(flags_bits & 0x02) expert_add_info(c->pinfo, pi, &ei_diameter_reserved_bit_set);
+		if (flags_bits & 0x02) expert_add_info(c->pinfo, pi, &ei_diameter_reserved_bit_set);
 		pi = proto_tree_add_item(pt,hf_diameter_flags_reserved7,tvb,4,1,ENC_BIG_ENDIAN);
-		if(flags_bits & 0x01) expert_add_info(c->pinfo, pi, &ei_diameter_reserved_bit_set);
+		if (flags_bits & 0x01) expert_add_info(c->pinfo, pi, &ei_diameter_reserved_bit_set);
 	}
 
 	cmd_item = proto_tree_add_item(diam_tree,hf_diameter_code,tvb,5,3,ENC_BIG_ENDIAN);
@@ -1118,24 +1122,24 @@ dissect_diameter_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, voi
 				/* TODO: Populate result_code in tap record from AVP 268 */
 			}
 		}
-		
+
 		offset = 20;
-		
+
 		/* Dissect AVPs until the end of the packet is reached */
 		while (offset < packet_len) {
 			offset += dissect_diameter_avp(c, tvb, offset, diam_sub_dis_inf);
 		}
 	}
-	
+
 	/* Handle requests for which no answers were found and
 	 * anawers for which no requests were found in the tap listener.
 	 * In case if you don't need unpaired requests/answers use:
-	 * if(diameter_pair->processing_request || !diameter_pair->req_frame)
+	 * if (diameter_pair->processing_request || !diameter_pair->req_frame)
 	 *   return;
 	 */
 	tap_queue_packet(diameter_tap, pinfo, diameter_pair);
 
-	if(have_tap_listener(exported_pdu_tap)){
+	if (have_tap_listener(exported_pdu_tap)){
 		export_diameter_pdu(pinfo,tvb);
 	}
 
@@ -1214,7 +1218,7 @@ alnumerize(char *name)
 
 static guint
 reginfo(int *hf_ptr, const char *name, const char *abbr, const char *desc,
-	enum ftenum ft, base_display_e base, value_string_ext *vs_ext,
+	enum ftenum ft, base_display_e base, const value_string_ext *vs_ext,
 	guint32 mask)
 {
 	hf_register_info hf = { hf_ptr, {
@@ -1227,7 +1231,7 @@ reginfo(int *hf_ptr, const char *name, const char *abbr, const char *desc,
 				wmem_strdup(wmem_epan_scope(), desc),
 				HFILL }};
 
-	if(vs_ext) {
+	if (vs_ext) {
 		hf.hfinfo.strings = vs_ext;
 	}
 
@@ -1237,7 +1241,7 @@ reginfo(int *hf_ptr, const char *name, const char *abbr, const char *desc,
 
 static void
 basic_avp_reginfo(diam_avp_t *a, const char *name, enum ftenum ft,
-		  base_display_e base, value_string_ext *vs_ext)
+		  base_display_e base, const value_string_ext *vs_ext)
 {
 	hf_register_info hf[] = { { &(a->hf_value),
 				  { NULL, NULL, ft, base, NULL, 0x0,
@@ -1250,7 +1254,7 @@ basic_avp_reginfo(diam_avp_t *a, const char *name, enum ftenum ft,
 
 	hf->hfinfo.name = wmem_strdup_printf(wmem_epan_scope(), "%s",name);
 	hf->hfinfo.abbrev = alnumerize(wmem_strdup_printf(wmem_epan_scope(), "diameter.%s",name));
-	if(vs_ext) {
+	if (vs_ext) {
 		hf->hfinfo.strings = vs_ext;
 	}
 
@@ -1307,7 +1311,7 @@ build_address_avp(const avp_type_t *type _U_, guint32 code,
 	t->hf_ipv6 = -1;
 	t->hf_other = -1;
 
-	basic_avp_reginfo(a,name,FT_BYTES,BASE_NONE,NULL);
+	basic_avp_reginfo(a, name, FT_BYTES, BASE_NONE, NULL);
 
 	reginfo(&(t->hf_address_type), ep_strdup_printf("%s Address Family",name),
 		alnumerize(ep_strdup_printf("diameter.%s.addr_family",name)),
@@ -1361,7 +1365,7 @@ build_simple_avp(const avp_type_t *type, guint32 code, const diam_vnd_t *vendor,
 		 const char *name, const value_string *vs, void *data _U_)
 {
 	diam_avp_t *a;
-	value_string_ext *vs_ext = NULL;
+	const value_string_ext *vs_ext = NULL;
 	base_display_e base;
 	guint i = 0;
 
@@ -1400,7 +1404,7 @@ build_simple_avp(const avp_type_t *type, guint32 code, const diam_vnd_t *vendor,
 	a->ett = -1;
 	a->hf_value = -1;
 
-	basic_avp_reginfo(a,name,type->ft,base,vs_ext);
+	basic_avp_reginfo(a, name, type->ft, base, vs_ext);
 
 	return a;
 }
@@ -1634,7 +1638,7 @@ dictionary_load(void)
 
 		if ((e = a->enums)) {
 			wmem_array_t *arr = wmem_array_new(wmem_epan_scope(), sizeof(value_string));
-                        value_string term = {0, NULL};
+			value_string term = {0, NULL};
 
 			for (; e; e = e->next) {
 				value_string item = {e->code,e->name};
@@ -1977,3 +1981,16 @@ proto_reg_handoff_diameter(void)
 
 }
 
+
+/*
+ * Editor modelines  -  http://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 8
+ * tab-width: 8
+ * indent-tabs-mode: t
+ * End:
+ *
+ * vi: set shiftwidth=8 tabstop=8 noexpandtab:
+ * :indentSize=8:tabSize=8:noTabs=false:
+ */
diff --git a/epan/dissectors/packet-etch.c b/epan/dissectors/packet-etch.c
index 2588475ee2..382f85db1a 100644
--- a/epan/dissectors/packet-etch.c
+++ b/epan/dissectors/packet-etch.c
@@ -173,8 +173,8 @@ void proto_reg_handoff_etch(void);
  *     value_string_ext from the array for use by try_val_to_str_ext & friends.
  *  (Code based upon code in packet-diameter.c)
  */
-static GArray           *gbl_symbols_array  = NULL;
-static value_string_ext *gbl_symbols_vs_ext = NULL;
+static GArray                 *gbl_symbols_array  = NULL;
+static const value_string_ext *gbl_symbols_vs_ext = NULL;
 
 static void
 gbl_symbols_new(void)
@@ -186,7 +186,7 @@ gbl_symbols_new(void)
 static void
 gbl_symbols_free(void)
 {
-  wmem_free(wmem_epan_scope(), gbl_symbols_vs_ext);
+  value_string_ext_free(gbl_symbols_vs_ext);
   gbl_symbols_vs_ext = NULL;
 
   if (gbl_symbols_array != NULL) {
diff --git a/epan/value_string.c b/epan/value_string.c
index 28abf1e71d..9938adecec 100644
--- a/epan/value_string.c
+++ b/epan/value_string.c
@@ -38,7 +38,7 @@
 /* Tries to match val against each element in the value_string array vs.
    Returns the associated string ptr on a match.
    Formats val with fmt, and returns the resulting string, on failure. */
-const gchar*
+const gchar *
 val_to_str(const guint32 val, const value_string *vs, const char *fmt)
 {
     const gchar *ret;
@@ -55,7 +55,7 @@ val_to_str(const guint32 val, const value_string *vs, const char *fmt)
 /* Tries to match val against each element in the value_string array vs.
    Returns the associated string ptr on a match.
    Returns 'unknown_str', on failure. */
-const gchar*
+const gchar *
 val_to_str_const(const guint32 val, const value_string *vs,
         const char *unknown_str)
 {
@@ -74,7 +74,7 @@ val_to_str_const(const guint32 val, const value_string *vs,
    Returns the associated string ptr, and sets "*idx" to the index in
    that table, on a match, and returns NULL, and sets "*idx" to -1,
    on failure. */
-const gchar*
+const gchar *
 try_val_to_str_idx(const guint32 val, const value_string *vs, gint *idx)
 {
     gint i = 0;
@@ -96,7 +96,7 @@ try_val_to_str_idx(const guint32 val, const value_string *vs, gint *idx)
 }
 
 /* Like try_val_to_str_idx(), but doesn't return the index. */
-const gchar*
+const gchar *
 try_val_to_str(const guint32 val, const value_string *vs)
 {
     gint ignore_me;
@@ -105,7 +105,7 @@ try_val_to_str(const guint32 val, const value_string *vs)
 
 /* 64-BIT VALUE STRING */
 
-const gchar*
+const gchar *
 val64_to_str(const guint64 val, const val64_string *vs, const char *fmt)
 {
     const gchar *ret;
@@ -119,7 +119,7 @@ val64_to_str(const guint64 val, const val64_string *vs, const char *fmt)
     return ep_strdup_printf(fmt, val);
 }
 
-const gchar*
+const gchar *
 val64_to_str_const(const guint64 val, const val64_string *vs,
         const char *unknown_str)
 {
@@ -134,7 +134,7 @@ val64_to_str_const(const guint64 val, const val64_string *vs,
     return unknown_str;
 }
 
-const gchar*
+const gchar *
 try_val64_to_str_idx(const guint64 val, const val64_string *vs, gint *idx)
 {
     gint i = 0;
@@ -155,7 +155,7 @@ try_val64_to_str_idx(const guint64 val, const val64_string *vs, gint *idx)
     return NULL;
 }
 
-const gchar*
+const gchar *
 try_val64_to_str(const guint64 val, const val64_string *vs)
 {
     gint ignore_me;
@@ -241,8 +241,8 @@ str_to_val_idx(const gchar *val, const value_string *vs)
  * required {0, NULL} terminating entry of the array.
  * Returns a pointer to an epan-scoped'd and initialized value_string_ext
  * struct. */
-value_string_ext *
-value_string_ext_new(value_string *vs, guint vs_tot_num_entries,
+const value_string_ext *
+value_string_ext_new(const value_string *vs, guint vs_tot_num_entries,
         const gchar *vs_name)
 {
     value_string_ext *vse;
@@ -266,8 +266,14 @@ value_string_ext_new(value_string *vs, guint vs_tot_num_entries,
     return vse;
 }
 
+void
+value_string_ext_free(const value_string_ext *vse)
+{
+    wmem_free(wmem_epan_scope(), (void *)vse);
+}
+
 /* Like try_val_to_str for extended value strings */
-const gchar*
+const gchar *
 try_val_to_str_ext(const guint32 val, const value_string_ext *vse)
 {
     if (vse) {
@@ -282,8 +288,8 @@ try_val_to_str_ext(const guint32 val, const value_string_ext *vse)
 }
 
 /* Like try_val_to_str_idx for extended value strings */
-const gchar*
-try_val_to_str_idx_ext(const guint32 val, value_string_ext *vse, gint *idx)
+const gchar *
+try_val_to_str_idx_ext(const guint32 val, const value_string_ext *vse, gint *idx)
 {
     if (vse) {
         const value_string *vs = vse->_vs_match2(val, vse);
@@ -297,7 +303,7 @@ try_val_to_str_idx_ext(const guint32 val, value_string_ext *vse, gint *idx)
 }
 
 /* Like val_to_str for extended value strings */
-const gchar*
+const gchar *
 val_to_str_ext(const guint32 val, const value_string_ext *vse, const char *fmt)
 {
     const gchar *ret;
@@ -312,7 +318,7 @@ val_to_str_ext(const guint32 val, const value_string_ext *vse, const char *fmt)
 }
 
 /* Like val_to_str_const for extended value strings */
-const gchar*
+const gchar *
 val_to_str_ext_const(const guint32 val, const value_string_ext *vse,
         const char *unknown_str)
 {
@@ -442,14 +448,16 @@ _try_val_to_str_ext_init(const guint32 val, const value_string_ext *a_vse)
         /* XXX: Should check for dups ?? */
         if (type == VS_BIN_TREE) {
             if (prev_value > vs_p[i].value) {
-                g_warning("Extended value string %s forced to fall back to linear search: entry %u, value %u < previous entry, value %u",
-                        vse->_vs_name, i, vs_p[i].value, prev_value);
+                g_warning("Extended value string '%s' forced to fall back to linear search:\n"
+                          "  entry %u, value %u [%#x] < previous entry, value %u [%#x]",
+                          vse->_vs_name, i, vs_p[i].value, vs_p[i].value, prev_value, prev_value);
                 type = VS_SEARCH;
                 break;
             }
             if (first_value > vs_p[i].value) {
-                g_warning("Extended value string %s forced to fall back to linear search: entry %u, value %u < first entry, value %u",
-                        vse->_vs_name, i, vs_p[i].value, first_value);
+                g_warning("Extended value string '%s' forced to fall back to linear search:\n"
+                          "  entry %u, value %u [%#x] < first entry, value %u [%#x]",
+                          vse->_vs_name, i, vs_p[i].value, vs_p[i].value, first_value, first_value);
                 type = VS_SEARCH;
                 break;
             }
@@ -482,7 +490,7 @@ _try_val_to_str_ext_init(const guint32 val, const value_string_ext *a_vse)
  * also strings (instead of unsigned integers) */
 
 /* Like val_to_str except for string_string */
-const gchar*
+const gchar *
 str_to_str(const gchar *val, const string_string *vs, const char *fmt)
 {
     const gchar *ret;
@@ -497,7 +505,7 @@ str_to_str(const gchar *val, const string_string *vs, const char *fmt)
 }
 
 /* Like try_val_to_str_idx except for string_string */
-const gchar*
+const gchar *
 try_str_to_str_idx(const gchar *val, const string_string *vs, gint *idx)
 {
     gint i = 0;
@@ -517,7 +525,7 @@ try_str_to_str_idx(const gchar *val, const string_string *vs, gint *idx)
 }
 
 /* Like try_val_to_str except for string_string */
-const gchar*
+const gchar *
 try_str_to_str(const gchar *val, const string_string *vs)
 {
     gint ignore_me;
diff --git a/epan/value_string.h b/epan/value_string.h
index 1155a29ee5..4c16775853 100644
--- a/epan/value_string.h
+++ b/epan/value_string.h
@@ -31,47 +31,47 @@
 /* VALUE TO STRING MATCHING */
 
 typedef struct _value_string {
-  guint32      value;
-  const gchar *strptr;
+    guint32      value;
+    const gchar *strptr;
 } value_string;
 
 WS_DLL_PUBLIC
-const gchar*
+const gchar *
 val_to_str(const guint32 val, const value_string *vs, const char *fmt);
 
 WS_DLL_PUBLIC
-const gchar*
+const gchar *
 val_to_str_const(const guint32 val, const value_string *vs, const char *unknown_str);
 
 WS_DLL_PUBLIC
-const gchar*
+const gchar *
 try_val_to_str(const guint32 val, const value_string *vs);
 
 WS_DLL_PUBLIC
-const gchar*
+const gchar *
 try_val_to_str_idx(const guint32 val, const value_string *vs, gint *idx);
 
 /* 64-BIT VALUE TO STRING MATCHING */
 
 typedef struct _val64_string {
-  guint64      value;
-  const gchar *strptr;
+    guint64      value;
+    const gchar *strptr;
 } val64_string;
 
 WS_DLL_PUBLIC
-const gchar*
+const gchar *
 val64_to_str(const guint64 val, const val64_string *vs, const char *fmt);
 
 WS_DLL_PUBLIC
-const gchar*
+const gchar *
 val64_to_str_const(const guint64 val, const val64_string *vs, const char *unknown_str);
 
 WS_DLL_PUBLIC
-const gchar*
+const gchar *
 try_val64_to_str(const guint64 val, const val64_string *vs);
 
 WS_DLL_PUBLIC
-const gchar*
+const gchar *
 try_val64_to_str_idx(const guint64 val, const val64_string *vs, gint *idx);
 
 /* STRING TO VALUE MATCHING */
@@ -90,12 +90,12 @@ struct _value_string_ext;
 typedef const value_string *(*_value_string_match2_t)(const guint32, const struct _value_string_ext *);
 
 typedef struct _value_string_ext {
-  _value_string_match2_t _vs_match2;
-  guint32 _vs_first_value;    /* first value of the value_string array       */
-  guint   _vs_num_entries;    /* number of entries in the value_string array */
-                              /*  (excluding final {0, NULL})                */
-  const value_string *_vs_p;  /* the value string array address              */
-  const gchar *_vs_name;      /* vse "Name" (for error messages)             */
+    _value_string_match2_t _vs_match2;
+    guint32 _vs_first_value;    /* first value of the value_string array       */
+    guint   _vs_num_entries;    /* number of entries in the value_string array */
+    /*  (excluding final {0, NULL})                */
+    const value_string *_vs_p;  /* the value string array address              */
+    const gchar *_vs_name;      /* vse "Name" (for error messages)             */
 } value_string_ext;
 
 #define VALUE_STRING_EXT_VS_P(x) (x)->_vs_p
@@ -108,54 +108,58 @@ _try_val_to_str_ext_init(const guint32 val, const value_string_ext *vse);
 #define VALUE_STRING_EXT_INIT(x) { _try_val_to_str_ext_init, 0, array_length(x)-1, x, #x }
 
 WS_DLL_PUBLIC
-value_string_ext*
-value_string_ext_new(value_string *vs, guint vs_tot_num_entries, const gchar *vs_name);
+const value_string_ext *
+value_string_ext_new(const value_string *vs, guint vs_tot_num_entries, const gchar *vs_name);
+
+WS_DLL_PUBLIC
+void
+value_string_ext_free(const value_string_ext *vse);
 
 WS_DLL_PUBLIC
-const gchar*
+const gchar *
 val_to_str_ext(const guint32 val, const value_string_ext *vs, const char *fmt);
 
 WS_DLL_PUBLIC
-const gchar*
+const gchar *
 val_to_str_ext_const(const guint32 val, const value_string_ext *vs, const char *unknown_str);
 
 WS_DLL_PUBLIC
-const gchar*
+const gchar *
 try_val_to_str_ext(const guint32 val, const value_string_ext *vse);
 
 WS_DLL_PUBLIC
-const gchar*
-try_val_to_str_idx_ext(const guint32 val, value_string_ext *vse, gint *idx);
+const gchar *
+try_val_to_str_idx_ext(const guint32 val, const value_string_ext *vse, gint *idx);
 
 /* STRING TO STRING MATCHING */
 
 typedef struct _string_string {
-  const gchar   *value;
-  const gchar   *strptr;
+    const gchar *value;
+    const gchar *strptr;
 } string_string;
 
 WS_DLL_PUBLIC
-const gchar*
+const gchar *
 str_to_str(const gchar *val, const string_string *vs, const char *fmt);
 
 WS_DLL_PUBLIC
-const gchar*
+const gchar *
 try_str_to_str(const gchar *val, const string_string *vs);
 
 WS_DLL_PUBLIC
-const gchar*
+const gchar *
 try_str_to_str_idx(const gchar *val, const string_string *vs, gint *idx);
 
 /* RANGE TO STRING MATCHING */
 
 typedef struct _range_string {
-  guint32        value_min;
-  guint32        value_max;
-  const gchar   *strptr;
+    guint32      value_min;
+    guint32      value_max;
+    const gchar *strptr;
 } range_string;
 
 WS_DLL_PUBLIC
-const gchar*
+const gchar *
 rval_to_str(const guint32 val, const range_string *rs, const char *fmt);
 
 WS_DLL_PUBLIC
@@ -163,11 +167,11 @@ const gchar *
 rval_to_str_const(const guint32 val, const range_string *rs, const char *unknown_str);
 
 WS_DLL_PUBLIC
-const gchar*
+const gchar *
 try_rval_to_str(const guint32 val, const range_string *rs);
 
 WS_DLL_PUBLIC
-const gchar*
+const gchar *
 try_rval_to_str_idx(const guint32 val, const range_string *rs, gint *idx);
 
 /* MISC (generally do not use) */
@@ -177,7 +181,21 @@ gboolean
 value_string_ext_validate(const value_string_ext *vse);
 
 WS_DLL_LOCAL
-const gchar*
+const gchar *
 value_string_ext_match_type_str(const value_string_ext *vse);
 
 #endif /* __VALUE_STRING_H__ */
+
+
+/*
+ * Editor modelines  -  http://www.wireshark.org/tools/modelines.html
+ *
+ * Local variables:
+ * c-basic-offset: 4
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * vi: set shiftwidth=4 tabstop=8 expandtab:
+ * :indentSize=4:tabSize=8:noTabs=true:
+ */

