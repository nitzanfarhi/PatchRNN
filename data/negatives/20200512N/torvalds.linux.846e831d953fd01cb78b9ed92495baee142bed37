commit 846e831d953fd01cb78b9ed92495baee142bed37
Author: Ben Skeggs <bskeggs@redhat.com>
Date:   Thu Aug 20 14:54:10 2015 +1000

    drm/nouveau/pm: switch to device pri macros
    
    Signed-off-by: Ben Skeggs <bskeggs@redhat.com>

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
index 6803ad9ebe6f..fde6a6013c49 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c
@@ -126,6 +126,7 @@ nvkm_perfsrc_find(struct nvkm_pm *pm, struct nvkm_perfsig *sig, int si)
 static int
 nvkm_perfsrc_enable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)
 {
+	struct nvkm_device *device = pm->engine.subdev.device;
 	struct nvkm_perfdom *dom = NULL;
 	struct nvkm_perfsig *sig;
 	struct nvkm_perfsrc *src;
@@ -151,7 +152,7 @@ nvkm_perfsrc_enable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)
 			value |= ((ctr->source[i][j] >> 32) << src->shift);
 
 			/* enable the source */
-			nv_mask(pm, src->addr, mask, value);
+			nvkm_mask(device, src->addr, mask, value);
 			nv_debug(pm, "enabled source 0x%08x 0x%08x 0x%08x\n",
 				 src->addr, mask, value);
 		}
@@ -162,6 +163,7 @@ nvkm_perfsrc_enable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)
 static int
 nvkm_perfsrc_disable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)
 {
+	struct nvkm_device *device = pm->engine.subdev.device;
 	struct nvkm_perfdom *dom = NULL;
 	struct nvkm_perfsig *sig;
 	struct nvkm_perfsrc *src;
@@ -186,7 +188,7 @@ nvkm_perfsrc_disable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)
 			mask |= (src->mask << src->shift);
 
 			/* disable the source */
-			nv_mask(pm, src->addr, mask, 0);
+			nvkm_mask(device, src->addr, mask, 0);
 			nv_debug(pm, "disabled source 0x%08x 0x%08x\n",
 				 src->addr, mask);
 		}
diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
index cb3f52d2f24b..75a9e6286101 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c
@@ -128,6 +128,7 @@ static void
 gf100_perfctr_init(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 		   struct nvkm_perfctr *ctr)
 {
+	struct nvkm_device *device = pm->engine.subdev.device;
 	struct gf100_pm_cntr *cntr = (void *)ctr;
 	u32 log = ctr->logic_op;
 	u32 src = 0x00000000;
@@ -136,32 +137,34 @@ gf100_perfctr_init(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 	for (i = 0; i < 4; i++)
 		src |= ctr->signal[i] << (i * 8);
 
-	nv_wr32(pm, dom->addr + 0x09c, 0x00040002 | (dom->mode << 3));
-	nv_wr32(pm, dom->addr + 0x100, 0x00000000);
-	nv_wr32(pm, dom->addr + 0x040 + (cntr->base.slot * 0x08), src);
-	nv_wr32(pm, dom->addr + 0x044 + (cntr->base.slot * 0x08), log);
+	nvkm_wr32(device, dom->addr + 0x09c, 0x00040002 | (dom->mode << 3));
+	nvkm_wr32(device, dom->addr + 0x100, 0x00000000);
+	nvkm_wr32(device, dom->addr + 0x040 + (cntr->base.slot * 0x08), src);
+	nvkm_wr32(device, dom->addr + 0x044 + (cntr->base.slot * 0x08), log);
 }
 
 static void
 gf100_perfctr_read(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 		   struct nvkm_perfctr *ctr)
 {
+	struct nvkm_device *device = pm->engine.subdev.device;
 	struct gf100_pm_cntr *cntr = (void *)ctr;
 
 	switch (cntr->base.slot) {
-	case 0: cntr->base.ctr = nv_rd32(pm, dom->addr + 0x08c); break;
-	case 1: cntr->base.ctr = nv_rd32(pm, dom->addr + 0x088); break;
-	case 2: cntr->base.ctr = nv_rd32(pm, dom->addr + 0x080); break;
-	case 3: cntr->base.ctr = nv_rd32(pm, dom->addr + 0x090); break;
+	case 0: cntr->base.ctr = nvkm_rd32(device, dom->addr + 0x08c); break;
+	case 1: cntr->base.ctr = nvkm_rd32(device, dom->addr + 0x088); break;
+	case 2: cntr->base.ctr = nvkm_rd32(device, dom->addr + 0x080); break;
+	case 3: cntr->base.ctr = nvkm_rd32(device, dom->addr + 0x090); break;
 	}
-	dom->clk = nv_rd32(pm, dom->addr + 0x070);
+	dom->clk = nvkm_rd32(device, dom->addr + 0x070);
 }
 
 static void
 gf100_perfctr_next(struct nvkm_pm *pm, struct nvkm_perfdom *dom)
 {
-	nv_wr32(pm, dom->addr + 0x06c, dom->signal_nr - 0x40 + 0x27);
-	nv_wr32(pm, dom->addr + 0x0ec, 0x00000011);
+	struct nvkm_device *device = pm->engine.subdev.device;
+	nvkm_wr32(device, dom->addr + 0x06c, dom->signal_nr - 0x40 + 0x27);
+	nvkm_wr32(device, dom->addr + 0x0ec, 0x00000011);
 }
 
 const struct nvkm_funcdom
@@ -175,8 +178,9 @@ int
 gf100_pm_fini(struct nvkm_object *object, bool suspend)
 {
 	struct nvkm_pm *pm = (void *)object;
-	nv_mask(pm, 0x000200, 0x10000000, 0x00000000);
-	nv_mask(pm, 0x000200, 0x10000000, 0x10000000);
+	struct nvkm_device *device = pm->engine.subdev.device;
+	nvkm_mask(device, 0x000200, 0x10000000, 0x00000000);
+	nvkm_mask(device, 0x000200, 0x10000000, 0x10000000);
 	return nvkm_pm_fini(pm, suspend);
 }
 
@@ -186,6 +190,7 @@ gf100_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 	      struct nvkm_object **pobject)
 {
 	struct gf100_pm_oclass *mclass = (void *)oclass;
+	struct nvkm_device *device = (void *)parent;
 	struct nvkm_pm *pm;
 	u32 mask;
 	int ret;
@@ -202,9 +207,9 @@ gf100_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 		return ret;
 
 	/* GPC */
-	mask  = (1 << nv_rd32(pm, 0x022430)) - 1;
-	mask &= ~nv_rd32(pm, 0x022504);
-	mask &= ~nv_rd32(pm, 0x022584);
+	mask  = (1 << nvkm_rd32(device, 0x022430)) - 1;
+	mask &= ~nvkm_rd32(device, 0x022504);
+	mask &= ~nvkm_rd32(device, 0x022584);
 
 	ret = nvkm_perfdom_new(pm, "gpc", mask, 0x180000,
 			       0x1000, 0x200, mclass->doms_gpc);
@@ -212,9 +217,9 @@ gf100_pm_ctor(struct nvkm_object *parent, struct nvkm_object *engine,
 		return ret;
 
 	/* PART */
-	mask  = (1 << nv_rd32(pm, 0x022438)) - 1;
-	mask &= ~nv_rd32(pm, 0x022548);
-	mask &= ~nv_rd32(pm, 0x0225c8);
+	mask  = (1 << nvkm_rd32(device, 0x022438)) - 1;
+	mask &= ~nvkm_rd32(device, 0x022548);
+	mask &= ~nvkm_rd32(device, 0x0225c8);
 
 	ret = nvkm_perfdom_new(pm, "part", mask, 0x1a0000,
 			       0x1000, 0x200, mclass->doms_part);
diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
index a447eac24f3b..b37c024f0783 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c
@@ -27,6 +27,7 @@ static void
 nv40_perfctr_init(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 		  struct nvkm_perfctr *ctr)
 {
+	struct nvkm_device *device = pm->engine.subdev.device;
 	struct nv40_pm_cntr *cntr = (void *)ctr;
 	u32 log = ctr->logic_op;
 	u32 src = 0x00000000;
@@ -35,31 +36,33 @@ nv40_perfctr_init(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 	for (i = 0; i < 4; i++)
 		src |= ctr->signal[i] << (i * 8);
 
-	nv_wr32(pm, 0x00a7c0 + dom->addr, 0x00000001 | (dom->mode << 4));
-	nv_wr32(pm, 0x00a400 + dom->addr + (cntr->base.slot * 0x40), src);
-	nv_wr32(pm, 0x00a420 + dom->addr + (cntr->base.slot * 0x40), log);
+	nvkm_wr32(device, 0x00a7c0 + dom->addr, 0x00000001 | (dom->mode << 4));
+	nvkm_wr32(device, 0x00a400 + dom->addr + (cntr->base.slot * 0x40), src);
+	nvkm_wr32(device, 0x00a420 + dom->addr + (cntr->base.slot * 0x40), log);
 }
 
 static void
 nv40_perfctr_read(struct nvkm_pm *pm, struct nvkm_perfdom *dom,
 		  struct nvkm_perfctr *ctr)
 {
+	struct nvkm_device *device = pm->engine.subdev.device;
 	struct nv40_pm_cntr *cntr = (void *)ctr;
 
 	switch (cntr->base.slot) {
-	case 0: cntr->base.ctr = nv_rd32(pm, 0x00a700 + dom->addr); break;
-	case 1: cntr->base.ctr = nv_rd32(pm, 0x00a6c0 + dom->addr); break;
-	case 2: cntr->base.ctr = nv_rd32(pm, 0x00a680 + dom->addr); break;
-	case 3: cntr->base.ctr = nv_rd32(pm, 0x00a740 + dom->addr); break;
+	case 0: cntr->base.ctr = nvkm_rd32(device, 0x00a700 + dom->addr); break;
+	case 1: cntr->base.ctr = nvkm_rd32(device, 0x00a6c0 + dom->addr); break;
+	case 2: cntr->base.ctr = nvkm_rd32(device, 0x00a680 + dom->addr); break;
+	case 3: cntr->base.ctr = nvkm_rd32(device, 0x00a740 + dom->addr); break;
 	}
-	dom->clk = nv_rd32(pm, 0x00a600 + dom->addr);
+	dom->clk = nvkm_rd32(device, 0x00a600 + dom->addr);
 }
 
 static void
 nv40_perfctr_next(struct nvkm_pm *pm, struct nvkm_perfdom *dom)
 {
+	struct nvkm_device *device = pm->engine.subdev.device;
 	if (pm->sequence != pm->sequence) {
-		nv_wr32(pm, 0x400084, 0x00000020);
+		nvkm_wr32(device, 0x400084, 0x00000020);
 		pm->sequence = pm->sequence;
 	}
 }

