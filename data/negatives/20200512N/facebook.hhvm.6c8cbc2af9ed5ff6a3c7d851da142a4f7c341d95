commit 6c8cbc2af9ed5ff6a3c7d851da142a4f7c341d95
Author: mwilliams <mwilliams@fb.com>
Date:   Thu Oct 25 08:24:27 2012 -0700

    Make some classes/funcs persistent

diff --git a/src/compiler/analysis/class_scope.cpp b/src/compiler/analysis/class_scope.cpp
index a21f58d93e..3fec37a6c9 100644
--- a/src/compiler/analysis/class_scope.cpp
+++ b/src/compiler/analysis/class_scope.cpp
@@ -57,7 +57,8 @@ ClassScope::ClassScope(KindOf kindOf, const std::string &name,
   : BlockScope(name, docComment, stmt, BlockScope::ClassScope),
     m_parent(parent), m_bases(bases), m_attribute(0), m_redeclaring(-1),
     m_kindOf(kindOf), m_derivesFromRedeclaring(FromNormal),
-    m_traitStatus(NOT_FLATTENED), m_volatile(false), m_derivedByDynamic(false),
+    m_traitStatus(NOT_FLATTENED), m_volatile(false),
+    m_persistent(false), m_derivedByDynamic(false),
     m_sep(false), m_needsCppCtor(false), m_needsInit(true), m_knownBases(0),
     m_needsEnableDestructor(0) {
 
@@ -87,7 +88,8 @@ ClassScope::ClassScope(AnalysisResultPtr ar,
     m_parent(parent), m_bases(bases),
     m_attribute(0), m_redeclaring(-1),
     m_kindOf(KindOfObjectClass), m_derivesFromRedeclaring(FromNormal),
-    m_traitStatus(NOT_FLATTENED), m_dynamic(false), m_volatile(false),
+    m_traitStatus(NOT_FLATTENED), m_dynamic(false),
+    m_volatile(false), m_persistent(false),
     m_derivedByDynamic(false), m_sep(false), m_needsCppCtor(false),
     m_needsInit(true), m_knownBases(0), m_needsEnableDestructor(0) {
   BOOST_FOREACH(FunctionScopePtr f, methods) {
diff --git a/src/compiler/analysis/class_scope.h b/src/compiler/analysis/class_scope.h
index 171c82c18d..defdfb64aa 100644
--- a/src/compiler/analysis/class_scope.h
+++ b/src/compiler/analysis/class_scope.h
@@ -156,7 +156,9 @@ public:
 
   /* For class_exists */
   void setVolatile();
-  bool isVolatile() { return m_volatile;}
+  bool isVolatile() const { return m_volatile;}
+  bool isPersistent() const { return m_persistent; }
+  void setPersistent(bool p) { m_persistent = p; }
 
   bool needLazyStaticInitializer();
 
@@ -598,6 +600,7 @@ private:
   } m_traitStatus;
   unsigned m_dynamic:1;
   unsigned m_volatile:1; // for class_exists
+  unsigned m_persistent:1;
   unsigned m_derivedByDynamic:1;
   unsigned m_sep:1;
   unsigned m_needsCppCtor:1;
diff --git a/src/compiler/analysis/emitter.cpp b/src/compiler/analysis/emitter.cpp
index cbf512d7f5..816ea13c5e 100644
--- a/src/compiler/analysis/emitter.cpp
+++ b/src/compiler/analysis/emitter.cpp
@@ -3489,8 +3489,8 @@ bool EmitterVisitor::visitImpl(ConstructPtr node) {
         const Location* sLoc = ce->getLocation().get();
         PreClassEmitter* pce = m_ue.newPreClassEmitter(className,
                                                        PreClass::NotHoistable);
-        pce->init(sLoc->line0, sLoc->line1, m_ue.bcPos(), AttrUnique,
-                  parentName, NULL);
+        pce->init(sLoc->line0, sLoc->line1, m_ue.bcPos(),
+                  AttrUnique | AttrPersistent, parentName, NULL);
         e.DefCls(pce->id());
 
         // We're still at the closure definition site. Emit code to instantiate
@@ -4827,12 +4827,15 @@ void EmitterVisitor::emitPostponedMeths() {
     Attr attrs = buildAttrs(mod, p.m_meth->isRef());
 
     if (p.m_meth->getFunctionScope()->mayUseVV()) {
-      attrs = (Attr)(attrs | AttrMayUseVV);
+      attrs = attrs | AttrMayUseVV;
     }
 
     if (Option::WholeProgram) {
       if (!funcScope->isRedeclaring()) {
-        attrs = (Attr)(attrs | AttrUnique);
+        attrs = attrs | AttrUnique;
+        if (funcScope->isPersistent()) {
+          attrs = attrs | AttrPersistent;
+        }
       }
       if (ClassScopePtr cls = p.m_meth->getClassScope()) {
         if (p.m_meth->getName() == cls->getName() &&
@@ -4845,22 +4848,22 @@ void EmitterVisitor::emitPostponedMeths() {
             treating it as a constructor even though it looks like
             one.
           */
-          attrs = (Attr)(attrs | AttrTrait);
+          attrs = attrs | AttrTrait;
         }
         if (!p.m_meth->getFunctionScope()->hasOverride()) {
-          attrs = (Attr)(attrs | AttrNoOverride);
+          attrs = attrs | AttrNoOverride;
         }
       }
     } else if (!SystemLib::s_inited) {
       // we're building systemlib. everything is unique
-      attrs = (Attr)(attrs | AttrUnique);
+      attrs = attrs | AttrUnique | AttrPersistent;
     }
 
     // For closures, the MethodStatement didn't have real attributes; enforce
     // that the __invoke method is public here
     if (fe->isClosureBody()) {
       ASSERT(!(attrs & (AttrProtected | AttrPrivate)));
-      attrs = (Attr)(attrs | AttrPublic);
+      attrs = attrs | AttrPublic;
     }
 
     Label topOfBody(e);
@@ -5521,17 +5524,20 @@ PreClass::Hoistable EmitterVisitor::emitClass(Emitter& e, ClassScopePtr cNode,
   if (Option::WholeProgram) {
     if (!cNode->isRedeclaring() &&
         !cNode->derivesFromRedeclaring()) {
-      attr = (Attr)(attr | AttrUnique);
+      attr = attr | AttrUnique;
+      if (cNode->isPersistent()) {
+        attr = attr | AttrPersistent;
+      }
     }
     if (!cNode->getAttribute(ClassScope::NotFinal)) {
-      attr = (Attr)(attr | AttrNoOverride);
+      attr = attr | AttrNoOverride;
     }
     if (cNode->getUsedTraitNames().size()) {
-      attr = (Attr)(attr | AttrNoExpandTrait);
+      attr = attr | AttrNoExpandTrait;
     }
   } else if (!SystemLib::s_inited) {
     // we're building systemlib. everything is unique
-    attr = (Attr)(attr | AttrUnique);
+    attr = attr | AttrUnique | AttrPersistent;
   }
 
   const Location* sLoc = is->getLocation().get();
@@ -6262,7 +6268,13 @@ static Unit* emitHHBCNativeFuncUnit(const HhbcExtFuncInfo* builtinFuncs,
   */
   StringData* name = StringData::GetStaticString("86null");
   FuncEmitter* fe = ue->newFuncEmitter(name, /*top*/ true);
-  fe->init(0, 0, ue->bcPos(), AttrUnique, true, empty_string.get());
+  /*
+    Dont mark it AttrPersistent, because it would be
+    deleted, and we need to be able to find it in the
+    unit's m_mergeInfo
+  */
+  fe->init(0, 0, ue->bcPos(), AttrUnique,
+           true, empty_string.get());
   ue->emitOp(OpNull);
   ue->emitOp(OpRetC);
   fe->setMaxStackCells(1);
@@ -6279,7 +6291,7 @@ static Unit* emitHHBCNativeFuncUnit(const HhbcExtFuncInfo* builtinFuncs,
     fe->setBuiltinFunc(mi, bif, base);
     ue->emitOp(OpNativeImpl);
     fe->setMaxStackCells(kNumActRecCells + 1);
-    fe->setAttrs(Attr(fe->attrs()|AttrUnique));
+    fe->setAttrs(fe->attrs() | AttrUnique | AttrPersistent);
     fe->finish(ue->bcPos(), false);
     ue->recordFunction(fe);
   }
@@ -6462,7 +6474,7 @@ static Unit* emitHHBCNativeClassUnit(const HhbcExtClassInfo* builtinClasses,
       StringData::GetStaticString(e.ci->getParentClass().get());
     PreClassEmitter* pce = ue->newPreClassEmitter(e.name,
                                                   PreClass::AlwaysHoistable);
-    pce->init(0, 0, ue->bcPos(), AttrUnique, parentName, NULL);
+    pce->init(0, 0, ue->bcPos(), AttrUnique | AttrPersistent, parentName, NULL);
     pce->setBuiltinClassInfo(e.ci, e.info->m_InstanceCtor, e.info->m_sizeof);
     {
       ClassInfo::InterfaceVec intfVec = e.ci->getInterfacesVec();
@@ -6528,7 +6540,8 @@ static Unit* emitHHBCNativeClassUnit(const HhbcExtClassInfo* builtinClasses,
     for (unsigned i = 0; i < array_size(names); ++i) {
       PreClassEmitter* pce =
         ue->newPreClassEmitter(names[i], PreClass::AlwaysHoistable);
-      pce->init(0, 0, ue->bcPos(), AttrUnique, continuationClassName, NULL);
+      pce->init(0, 0, ue->bcPos(), AttrUnique | AttrPersistent,
+                continuationClassName, NULL);
     }
   }
 
diff --git a/src/compiler/analysis/function_scope.cpp b/src/compiler/analysis/function_scope.cpp
index 1582c96766..8961a9e204 100644
--- a/src/compiler/analysis/function_scope.cpp
+++ b/src/compiler/analysis/function_scope.cpp
@@ -56,7 +56,7 @@ FunctionScope::FunctionScope(AnalysisResultConstPtr ar, bool method,
       m_modifiers(modifiers), m_hasVoid(false),
       m_method(method), m_refReturn(reference), m_virtual(false),
       m_hasOverride(false), m_perfectVirtual(false), m_overriding(false),
-      m_volatile(false), m_pseudoMain(inPseudoMain),
+      m_volatile(false), m_persistent(false), m_pseudoMain(inPseudoMain),
       m_magicMethod(false), m_system(false), m_inlineable(false), m_sep(false),
       m_containsThis(false), m_containsBareThis(0), m_nrvoFix(true),
       m_inlineAsExpr(false), m_inlineSameContext(false),
@@ -92,6 +92,7 @@ FunctionScope::FunctionScope(FunctionScopePtr orig,
       m_virtual(orig->m_virtual), m_hasOverride(orig->m_hasOverride),
       m_perfectVirtual(orig->m_perfectVirtual),
       m_overriding(orig->m_overriding), m_volatile(orig->m_volatile),
+      m_persistent(orig->m_persistent),
       m_pseudoMain(orig->m_pseudoMain), m_magicMethod(orig->m_magicMethod),
       m_system(orig->m_system), m_inlineable(orig->m_inlineable),
       m_sep(orig->m_sep), m_containsThis(orig->m_containsThis),
@@ -196,7 +197,7 @@ FunctionScope::FunctionScope(bool method, const std::string &name,
       m_modifiers(ModifierExpressionPtr()), m_hasVoid(false),
       m_method(method), m_refReturn(reference), m_virtual(false),
       m_hasOverride(false), m_perfectVirtual(false), m_overriding(false),
-      m_volatile(false), m_pseudoMain(false),
+      m_volatile(false), m_persistent(false), m_pseudoMain(false),
       m_magicMethod(false), m_system(true), m_inlineable(false), m_sep(false),
       m_containsThis(false), m_containsBareThis(0), m_nrvoFix(true),
       m_inlineAsExpr(false), m_inlineSameContext(false),
diff --git a/src/compiler/analysis/function_scope.h b/src/compiler/analysis/function_scope.h
index 026dad3ddb..8e9b9f6c34 100644
--- a/src/compiler/analysis/function_scope.h
+++ b/src/compiler/analysis/function_scope.h
@@ -290,8 +290,10 @@ public:
   bool isLocalRedeclaring() const { return m_localRedeclaring; }
 
   /* For function_exists */
-  void setVolatile() { m_volatile = true;}
-  bool isVolatile() const { return m_volatile;}
+  void setVolatile() { m_volatile = true; }
+  bool isVolatile() const { return m_volatile; }
+  bool isPersistent() const { return m_persistent; }
+  void setPersistent(bool p) { m_persistent = p; }
 
   bool isInlined() const { return m_inlineable; }
   void disableInline() { m_inlineable = false; }
@@ -537,6 +539,7 @@ private:
   unsigned m_dynamicInvoke : 1;
   unsigned m_overriding : 1; // overriding a virtual function
   unsigned m_volatile : 1; // for function_exists
+  unsigned m_persistent : 1;
   unsigned m_pseudoMain : 1;
   unsigned m_magicMethod : 1;
   unsigned m_system : 1;
diff --git a/src/compiler/option.cpp b/src/compiler/option.cpp
index 38e2bd8590..d55f2ae4eb 100644
--- a/src/compiler/option.cpp
+++ b/src/compiler/option.cpp
@@ -248,6 +248,7 @@ bool Option::GenerateFFIStaticBinding = true;
 int Option::GCCOptimization[] = {0, 0, 0};
 
 void (*Option::m_hookHandler)(Hdf &config);
+bool (*Option::PersistenceHook)(BlockScopeRawPtr scope, FileScopeRawPtr file);
 
 ///////////////////////////////////////////////////////////////////////////////
 // load from a PHP file
diff --git a/src/compiler/option.h b/src/compiler/option.h
index d3bda4f22d..7b661b0d15 100644
--- a/src/compiler/option.h
+++ b/src/compiler/option.h
@@ -19,9 +19,12 @@
 
 #include <util/hdf.h>
 #include <util/string_bag.h>
+#include <util/base.h>
 
 namespace HPHP {
 ///////////////////////////////////////////////////////////////////////////////
+DECLARE_BOOST_TYPES(BlockScope);
+DECLARE_BOOST_TYPES(FileScope);
 
 class Option {
 public:
@@ -391,6 +394,7 @@ public:
     m_hookHandler = hookHandler;
   }
 
+  static bool (*PersistenceHook)(BlockScopeRawPtr scope, FileScopeRawPtr fs);
 private:
   /**
    * Directory that has system HPHP files for loading builtin classes, etc.
diff --git a/src/compiler/statement/class_statement.cpp b/src/compiler/statement/class_statement.cpp
index e6b464d87c..9b63c52994 100644
--- a/src/compiler/statement/class_statement.cpp
+++ b/src/compiler/statement/class_statement.cpp
@@ -98,6 +98,10 @@ void ClassStatement::onParse(AnalysisResultConstPtr ar, FileScopePtr fs) {
     return;
   }
 
+  if (Option::PersistenceHook) {
+    classScope->setPersistent(Option::PersistenceHook(classScope, fs));
+  }
+
   if (m_stmt) {
     MethodStatementPtr constructor;
 
diff --git a/src/compiler/statement/function_statement.cpp b/src/compiler/statement/function_statement.cpp
index 5c4655da8d..c93c1c5d08 100644
--- a/src/compiler/statement/function_statement.cpp
+++ b/src/compiler/statement/function_statement.cpp
@@ -74,6 +74,10 @@ void FunctionStatement::onParse(AnalysisResultConstPtr ar, FileScopePtr scope) {
     m_ignored = true;
     return;
   }
+
+  if (Option::PersistenceHook) {
+    fs->setPersistent(Option::PersistenceHook(fs, scope));
+  }
 }
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/src/compiler/statement/interface_statement.cpp b/src/compiler/statement/interface_statement.cpp
index 69a976f839..e2ad614f28 100644
--- a/src/compiler/statement/interface_statement.cpp
+++ b/src/compiler/statement/interface_statement.cpp
@@ -96,6 +96,10 @@ void InterfaceStatement::onParse(AnalysisResultConstPtr ar,
   setBlockScope(classScope);
   scope->addClass(ar, classScope);
 
+  if (Option::PersistenceHook) {
+    classScope->setPersistent(Option::PersistenceHook(classScope, scope));
+  }
+
   if (m_stmt) {
     for (int i = 0; i < m_stmt->getCount(); i++) {
       IParseHandlerPtr ph = dynamic_pointer_cast<IParseHandler>((*m_stmt)[i]);
diff --git a/src/runtime/vm/class.cpp b/src/runtime/vm/class.cpp
index 8614d80ca8..da769a5615 100644
--- a/src/runtime/vm/class.cpp
+++ b/src/runtime/vm/class.cpp
@@ -309,19 +309,24 @@ void PreClassEmitter::setBuiltinClassInfo(const ClassInfo* info,
                                           BuiltinCtorFunction ctorFunc,
                                           int sz) {
   if (info->getAttribute() & ClassInfo::IsFinal) {
-    m_attrs = (Attr)(m_attrs | AttrFinal);
+    m_attrs = m_attrs | AttrFinal;
   }
   if (info->getAttribute() & ClassInfo::IsAbstract) {
-    m_attrs = (Attr)(m_attrs | AttrAbstract);
+    m_attrs = m_attrs | AttrAbstract;
   }
-  m_attrs = (Attr)(m_attrs | AttrUnique);
+  m_attrs = m_attrs | AttrUnique;
   m_InstanceCtor = ctorFunc;
   m_builtinPropSize = sz - sizeof(ObjectData);
 }
 
 PreClass* PreClassEmitter::create(Unit& unit) const {
+  Attr attrs = m_attrs;
+  if (attrs & AttrPersistent &&
+      !RuntimeOption::RepoAuthoritative && SystemLib::s_inited) {
+    attrs = Attr(attrs & ~AttrPersistent);
+  }
   PreClass* pc = new PreClass(&unit, m_line1, m_line2, m_offset, m_name,
-                              m_attrs, m_parent, m_docComment, m_id,
+                              attrs, m_parent, m_docComment, m_id,
                               m_hoistable);
   pc->m_InstanceCtor = m_InstanceCtor;
   pc->m_builtinPropSize = m_builtinPropSize;
@@ -482,7 +487,7 @@ ClassPtr Class::newClass(PreClass* preClass, Class* parent) {
 Class::Class(PreClass* preClass, Class* parent, unsigned classVecLen)
   : m_preClass(PreClassPtr(preClass)), m_parent(ClassPtr(parent)),
     m_traitsBeginIdx(0), m_traitsEndIdx(0), m_clsInfo(NULL),
-    m_builtinPropSize(0), m_classVecLen(classVecLen), m_cachedOffset(-1),
+    m_builtinPropSize(0), m_classVecLen(classVecLen), m_cachedOffset(0),
     m_propDataCache(-1), m_propSDataCache(-1), m_InstanceCtor(NULL),
     m_nextClass(NULL) {
   setParent();
@@ -498,16 +503,16 @@ Class::Class(PreClass* preClass, Class* parent, unsigned classVecLen)
 }
 
 void Class::atomicRelease() {
-  if (m_cachedOffset != (unsigned)-1) {
+  if (m_cachedOffset != 0u) {
     /*
-      m_cachedOffset is initialied to -1, and is only set
+      m_cachedOffset is initialied to 0, and is only set
       when the Class is put on the list, so we only have to
-      remove this node if its NOT -1.
-      Since we're about to remove it, reset to -1 so we know
+      remove this node if its NOT 0.
+      Since we're about to remove it, reset to 0 so we know
       its safe to kill the node during the delayed Treadmill
       callback.
     */
-    m_cachedOffset = (unsigned)-1;
+    m_cachedOffset = 0u;
     PreClass* pcls = m_preClass.get();
     {
       Lock l(Unit::s_classesMutex);
@@ -534,6 +539,30 @@ void Class::setCached() {
   *(Class**)Transl::TargetCache::handleToPtr(m_cachedOffset) = this;
 }
 
+bool Class::verifyPersistent() const {
+  if (!(attrs() & AttrPersistent)) return false;
+  if (m_parent.get() &&
+      !Transl::TargetCache::isPersistentHandle(m_parent->m_cachedOffset)) {
+    return false;
+  }
+  for (size_t i = 0, nInterfaces = m_declInterfaces.size();
+       i < nInterfaces; ++i) {
+    Class* declInterface = m_declInterfaces[i].get();
+    if (!Transl::TargetCache::isPersistentHandle(
+          declInterface->m_cachedOffset)) {
+      return false;
+    }
+  }
+  for (size_t i = 0; i < m_usedTraits.size(); i++) {
+    Class* usedTrait = m_usedTraits[i].get();
+    if (!Transl::TargetCache::isPersistentHandle(
+          usedTrait->m_cachedOffset)) {
+      return false;
+    }
+  }
+  return true;
+}
+
 /*
  * Check whether a Class from a previous request is available to be defined.
  * The caller should check that it has the same preClass that is being defined.
@@ -1112,7 +1141,6 @@ void Class::setSpecial() {
   ASSERT(m_ctor->attrs() == AttrPublic);
 }
 
-// returns true on error
 void Class::applyTraitPrecRule(const PreClass::TraitPrecRule& rule) {
   const StringData* methName          = rule.getMethodName();
   const StringData* selectedTraitName = rule.getSelectedTraitName();
@@ -1192,7 +1220,6 @@ void Class::addTraitAlias(const StringData* traitName,
                            (newMethName, origName));
 }
 
-// returns true on error
 void Class::applyTraitAliasRule(const PreClass::TraitAliasRule& rule) {
   const StringData* traitName    = rule.getTraitName();
   const StringData* origMethName = rule.getOrigMethodName();
@@ -1231,7 +1258,6 @@ void Class::applyTraitAliasRule(const PreClass::TraitAliasRule& rule) {
   }
 }
 
-// returns true on error
 void Class::applyTraitRules() {
   for (size_t i = 0; i < m_preClass->traitPrecRules().size(); i++) {
     applyTraitPrecRule(m_preClass->traitPrecRules()[i]);
@@ -1929,7 +1955,6 @@ void Class::importTraitStaticProp(ClassPtr trait,
   }
 }
 
-// returns true in case of error, false on success
 void Class::importTraitProps(PropMap::Builder& curPropMap,
                              SPropMap::Builder& curSPropMap) {
   if (attrs() & AttrNoExpandTrait) return;
diff --git a/src/runtime/vm/class.h b/src/runtime/vm/class.h
index fcc1410aec..a71b05a9d5 100644
--- a/src/runtime/vm/class.h
+++ b/src/runtime/vm/class.h
@@ -206,6 +206,7 @@ class PreClass : public AtomicCountable {
   const TraitPrecRuleVec& traitPrecRules() const { return m_traitPrecRules; }
   const TraitAliasRuleVec& traitAliasRules() const { return m_traitAliasRules; }
   const UserAttributeMap& userAttributes() const { return m_userAttributes; }
+  bool isPersistent() const { return m_attrs & AttrPersistent; }
 
   /*
    *  Funcs, Consts, and Props all behave similarly. Define raw accessors
@@ -582,6 +583,7 @@ public:
     ASSERT(Attr(m_attrCopy) == m_preClass->attrs());
     return Attr(m_attrCopy);
   }
+  bool verifyPersistent() const;
   const Func* getCtor() const { return m_ctor; }
   const Func* getDtor() const { return m_dtor; }
   const Func* getToString() const { return m_toString; }
@@ -617,6 +619,8 @@ public:
     return m_methods.lookupDefault(methName, 0);
   }
 
+  bool isPersistent() const { return m_attrCopy & AttrPersistent; }
+
   /*
    * We have a call site for an object method, which previously
    * invoked func, but this call has a different Class (*this).  See
diff --git a/src/runtime/vm/core_types.h b/src/runtime/vm/core_types.h
index 28bddb26ca..86e71f6f3f 100644
--- a/src/runtime/vm/core_types.h
+++ b/src/runtime/vm/core_types.h
@@ -98,9 +98,12 @@ enum Attr {
   AttrNoOverride= (1 << 13),     //    X                X    //
   AttrClone     = (1 << 14),     //                     X    //
   AttrVariadicByRef = (1 << 15), //                     X    //
-  AttrMayUseVV  = (1 << 16)      //                     X    //
+  AttrMayUseVV  = (1 << 16),     //                     X    //
+  AttrPersistent= (1 << 17)      //    X                X    //
 };
 
+static inline Attr operator|(Attr a, Attr b) { return Attr((int)a | (int)b); }
+
 static inline const char * attrToVisibilityStr(Attr attr) {
   return (attr & AttrPrivate)   ? "private"   :
          (attr & AttrProtected) ? "protected" : "public";
diff --git a/src/runtime/vm/func.cpp b/src/runtime/vm/func.cpp
index 33753d6155..c486c09c0b 100644
--- a/src/runtime/vm/func.cpp
+++ b/src/runtime/vm/func.cpp
@@ -31,6 +31,7 @@
 #include "runtime/vm/translator/translator-x64.h"
 #include "runtime/vm/blob_helper.h"
 #include "runtime/vm/func_inline.h"
+#include "system/lib/systemlib.h"
 
 namespace HPHP {
 namespace VM {
@@ -161,7 +162,7 @@ Func::Func(Unit& unit, Id id, int line1, int line2,
   , m_name(name)
   , m_namedEntity(NULL)
   , m_refBitVec(NULL)
-  , m_cachedOffset(-1)
+  , m_cachedOffset(0)
   , m_maxStackCells(0)
   , m_numParams(0)
   , m_attrs(attrs)
@@ -183,7 +184,7 @@ Func::Func(Unit& unit, PreClass* preClass, int line1, int line2, Offset base,
   , m_name(name)
   , m_namedEntity(NULL)
   , m_refBitVec(NULL)
-  , m_cachedOffset(-1)
+  , m_cachedOffset(0)
   , m_maxStackCells(0)
   , m_numParams(0)
   , m_attrs(attrs)
@@ -779,6 +780,13 @@ void FuncEmitter::commit(RepoTxn& txn) const {
 }
 
 Func* FuncEmitter::create(Unit& unit, PreClass* preClass /* = NULL */) const {
+  Attr attrs = m_attrs;
+  if (attrs & AttrPersistent &&
+      (RuntimeOption::EvalJitEnableRenameFunction ||
+       (!RuntimeOption::RepoAuthoritative && SystemLib::s_inited))) {
+    attrs = Attr(attrs & ~AttrPersistent);
+  }
+
   Func* f = (m_pce == NULL)
     ? m_ue.newFunc(this, unit, m_id, m_line1, m_line2, m_base,
                    m_past, m_name, m_attrs, m_top, m_docComment,
diff --git a/src/runtime/vm/func.h b/src/runtime/vm/func.h
index a5813ae019..e52aa4b21f 100644
--- a/src/runtime/vm/func.h
+++ b/src/runtime/vm/func.h
@@ -185,6 +185,7 @@ struct Func {
   bool isDestructor() const {
     return !strcmp(m_name->data(), "__destruct");
   }
+  bool isPersistent() const { return m_attrs & AttrPersistent; }
   static bool isMagicCallMethodName(const StringData* name) {
     return name->isame(s___call) || name->isame(s___callStatic);
   }
diff --git a/src/runtime/vm/func_inline.h b/src/runtime/vm/func_inline.h
index 90f03dcff0..ec3882d5a1 100644
--- a/src/runtime/vm/func_inline.h
+++ b/src/runtime/vm/func_inline.h
@@ -21,7 +21,7 @@ namespace HPHP {
 namespace VM {
 
 inline ALWAYS_INLINE Func** getCachedFuncAddr(unsigned offset) {
-  ASSERT(offset != (unsigned)-1);
+  ASSERT(offset != 0u);
   return (Func**)Transl::TargetCache::handleToPtr(offset);
 }
 
diff --git a/src/runtime/vm/funcdict.cpp b/src/runtime/vm/funcdict.cpp
index 6c9b80e638..c05ff6a9fd 100644
--- a/src/runtime/vm/funcdict.cpp
+++ b/src/runtime/vm/funcdict.cpp
@@ -65,12 +65,9 @@ bool RenamedFuncDict::rename(const StringData* old, const StringData* n3w) {
     }
   }
 
-  const StringData* sNew =
-    n3w->isStatic() ? n3w : StringData::GetStaticString(n3w);
-
   oldNe->setCachedFunc(NULL);
   if (UNLIKELY(newNe->m_cachedFuncOffset == 0)) {
-    newNe->m_cachedFuncOffset = Transl::TargetCache::allocFixedFunction(sNew);
+    Transl::TargetCache::allocFixedFunction(newNe, false);
   }
   newNe->setCachedFunc(func);
 
diff --git a/src/runtime/vm/stats.h b/src/runtime/vm/stats.h
index c328a781ce..4ebdd32329 100644
--- a/src/runtime/vm/stats.h
+++ b/src/runtime/vm/stats.h
@@ -132,6 +132,20 @@ extern __thread uint64_t tl_tcInstrs;
   STAT(TraceletGuard_enter) \
   STAT(TraceletGuard_branch) \
   STAT(TraceletGuard_execute) \
+    STAT(UnitMerge_hoistable) \
+    STAT(UnitMerge_hoistable_persistent) \
+    STAT(UnitMerge_hoistable_persistent_cache) \
+    STAT(UnitMerge_hoistable_persistent_parent) \
+    STAT(UnitMerge_hoistable_persistent_parent_cache) \
+    STAT(UnitMerge_mergeable) \
+    STAT(UnitMerge_mergeable_unique) \
+    STAT(UnitMerge_mergeable_unique_persistent) \
+    STAT(UnitMerge_mergeable_unique_persistent_cache) \
+    STAT(UnitMerge_mergeable_define) \
+    STAT(UnitMerge_mergeable_global) \
+    STAT(UnitMerge_mergeable_class) \
+    STAT(UnitMerge_mergeable_require) \
+    STAT(UnitMerge_redo_hoistable) \
   STAT(ElemAsm_GetIHit) \
   STAT(ElemAsm_GetIMiss) \
   STAT(PropAsm_Generic) \
diff --git a/src/runtime/vm/translator/hopt/codegen.cpp b/src/runtime/vm/translator/hopt/codegen.cpp
index c65c04c22f..216ef09be9 100644
--- a/src/runtime/vm/translator/hopt/codegen.cpp
+++ b/src/runtime/vm/translator/hopt/codegen.cpp
@@ -1501,7 +1501,7 @@ Address CodeGenerator::cgLdFixedFunc(IRInstruction* inst) {
   ASSERT(actRecReg != reg::noreg);
   using namespace TargetCache;
   const StringData* name = methodName->getConstValAsStr();
-  CacheHandle ch = FixedFuncCache::alloc(name);
+  CacheHandle ch = allocFixedFunction(name);
   size_t funcCacheOff = ch + offsetof(FixedFuncCache, m_func);
   m_as.load_reg64_disp_reg64(LinearScan::rTlPtr, funcCacheOff, dstReg);
   m_as.test_reg64_reg64(dstReg, dstReg);
diff --git a/src/runtime/vm/translator/targetcache.cpp b/src/runtime/vm/translator/targetcache.cpp
index 252c04bff1..dc3926cb8b 100644
--- a/src/runtime/vm/translator/targetcache.cpp
+++ b/src/runtime/vm/translator/targetcache.cpp
@@ -19,6 +19,7 @@
 
 #include <util/trace.h>
 #include <util/base.h>
+#include <util/maphuge.h>
 #include <runtime/base/complex_types.h>
 #include <runtime/base/execution_context.h>
 #include <runtime/base/types.h>
@@ -60,14 +61,17 @@ undefinedError(const char* msg, const char* name) {
 }
 
 // Targetcache memory. See the comment in targetcache.h
-__thread DataBlock tl_targetCaches = {0, 0, 0};
+__thread void* tl_targetCaches = NULL;
+
 CT_ASSERT(kConditionFlagsOff + sizeof(ssize_t) <= 64);
 size_t s_frontier = kConditionFlagsOff + 64;
+static size_t s_persistent_frontier = 0;
+static size_t s_persistent_start = 0;
 static size_t s_next_bit;
 static size_t s_bits_to_go;
+static int s_tc_fd;
 static const size_t kPreAllocatedBytes = kConditionFlagsOff + 64;
 
-static Mutex s_mutex(false /*recursive*/, RankLeaf);
 // Mapping from names to targetcache locations. Protected by the translator
 // write lease.
 typedef hphp_hash_map<const StringData*, Handle, string_data_hash,
@@ -96,7 +100,7 @@ static Mutex s_handleMutex(false /*recursive*/, RankLeaf);
 
 inline Handle
 ptrToHandle(const void* ptr) {
-  ptrdiff_t retval = uintptr_t(ptr) - uintptr_t(tl_targetCaches.base);
+  ptrdiff_t retval = uintptr_t(ptr) - uintptr_t(tl_targetCaches);
   ASSERT(retval < RuntimeOption::EvalJitTargetCacheSize);
   return retval;
 }
@@ -190,6 +194,26 @@ bool testAndSetBit(Handle handle, uint32 mask) {
   return ret;
 }
 
+bool isPersistentHandle(Handle handle) {
+  return handle >= (unsigned)s_persistent_start;
+}
+
+static Handle allocLocked(bool persistent, int numBytes, int align) {
+  s_handleMutex.assertOwnedBySelf();
+  align = Util::roundUpToPowerOfTwo(align);
+  size_t &frontier = persistent ? s_persistent_frontier : s_frontier;
+
+  frontier += align - 1;
+  frontier &= ~(align - 1);
+  frontier += numBytes;
+
+  assert(frontier < (persistent ?
+                     RuntimeOption::EvalJitTargetCacheSize :
+                     s_persistent_start));
+
+  return frontier - numBytes;
+}
+
 // namedAlloc --
 //   Many targetcache entries (Func, Class, Constant, ...) have
 //   request-unique values. There is no reason to allocate more than
@@ -212,8 +236,7 @@ namedAlloc(PHPNameSpace where, const StringData* name,
     TRACE(2, "TargetCache: hit \"%s\", %d\n", name->data(), int(retval));
     return retval;
   }
-  void *mem = tl_targetCaches.allocAt(s_frontier, numBytes, align);
-  retval = ptrToHandle(mem);
+  retval = allocLocked(where == NSPersistent, numBytes, align);
   if (name) {
     if (!name->isStatic()) name = StringData::GetStaticString(name);
     mapInsertUnique(map, name, retval);
@@ -235,16 +258,6 @@ void
 invalidateForRename(const StringData* name) {
   ASSERT(name);
   Lock l(s_handleMutex);
-  {
-    Handle handle;
-    HandleMapIS& map = getHMap(NSFunction);
-    if (mapGet(map, name, &handle)) {
-      TRACE(1, "TargetCaches: invalidating mapping for NSFunction::%s\n",
-            name->data());
-      // OK, there's a targetcache for this name.
-      FixedFuncCache::invalidate(handle);
-    }
-  }
 
   for (HandleVector::iterator i = funcCacheEntries.begin();
        i != funcCacheEntries.end(); ++i) {
@@ -252,25 +265,56 @@ invalidateForRename(const StringData* name) {
   }
 }
 
+void initPersistentCache() {
+  Lock l(s_handleMutex);
+  if (s_tc_fd) return;
+  char tmpName[] = "/tmp/tcXXXXXX";
+  s_tc_fd = mkstemp(tmpName);
+  assert(s_tc_fd != -1);
+  unlink(tmpName);
+  s_persistent_start = RuntimeOption::EvalJitTargetCacheSize * 3 / 4;
+  s_persistent_start -= s_persistent_start & (4 * 1024 - 1);
+  ftruncate(s_tc_fd,
+            RuntimeOption::EvalJitTargetCacheSize - s_persistent_start);
+  s_persistent_frontier = s_persistent_start;
+}
+
 void threadInit() {
-  tl_targetCaches.size = RuntimeOption::EvalJitTargetCacheSize;
-  tl_targetCaches.init();
+  if (!s_tc_fd) {
+    initPersistentCache();
+  }
+
+  tl_targetCaches = mmap(NULL, RuntimeOption::EvalJitTargetCacheSize,
+                         PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);
+  assert(tl_targetCaches != MAP_FAILED);
+  hintHuge(tl_targetCaches, RuntimeOption::EvalJitTargetCacheSize);
+
+  void *shared_base = (char*)tl_targetCaches + s_persistent_start;
+  /*
+   * map the upper portion of the target cache to a shared area
+   * This is used for persistent classes and functions, so they
+   * are always defined, and always visible to all threads.
+   */
+  void *mem = mmap(shared_base,
+                   RuntimeOption::EvalJitTargetCacheSize - s_persistent_start,
+                   PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED, s_tc_fd, 0);
+  assert(mem == shared_base);
 }
 
 void threadExit() {
-  tl_targetCaches.free();
+  munmap(tl_targetCaches, RuntimeOption::EvalJitTargetCacheSize);
 }
 
 static const bool zeroViaMemset = true;
 
 void
 requestInit() {
-  ASSERT(tl_targetCaches.base);
-  TRACE(1, "TargetCache: @%p\n", tl_targetCaches.base);
+  ASSERT(tl_targetCaches);
+  TRACE(1, "TargetCache: @%p\n", tl_targetCaches);
   if (zeroViaMemset) {
     TRACE(1, "TargetCache: bzeroing %zd bytes: %p\n", s_frontier,
-          tl_targetCaches.base);
-    memset(tl_targetCaches.base, 0, s_frontier);
+          tl_targetCaches);
+    memset(tl_targetCaches, 0, s_frontier);
   }
 }
 
@@ -284,8 +328,8 @@ requestExit() {
 void
 flush() {
   TRACE(1, "TargetCache: MADV_DONTNEED %zd bytes: %p\n", s_frontier,
-        tl_targetCaches.base);
-  if (madvise(tl_targetCaches.base, s_frontier, MADV_DONTNEED) < 0) {
+        tl_targetCaches);
+  if (madvise(tl_targetCaches, s_frontier, MADV_DONTNEED) < 0) {
     not_reached();
   }
 }
@@ -519,9 +563,33 @@ BoxedGlobalCache::lookupCreate(Handle handle, StringData* name) {
   return retval;
 }
 
+static CacheHandle allocFuncOrClass(const unsigned* handlep, bool persistent) {
+  if (UNLIKELY(!*handlep)) {
+    Lock l(s_handleMutex);
+    if (!*handlep) {
+      *const_cast<unsigned*>(handlep) =
+        allocLocked(persistent, sizeof(void*), sizeof(void*));
+    }
+  }
+  return *handlep;
+}
+
+CacheHandle allocKnownClass(const Class* cls) {
+  const NamedEntity* ne = cls->preClass()->namedEntity();
+  if (ne->m_cachedClassOffset) return ne->m_cachedClassOffset;
+
+  return allocKnownClass(ne,
+                         RuntimeOption::RepoAuthoritative &&
+                         cls->verifyPersistent());
+}
+
+CacheHandle allocKnownClass(const NamedEntity* ne,
+                            bool persistent) {
+  return allocFuncOrClass(&ne->m_cachedClassOffset, persistent);
+}
+
 CacheHandle allocKnownClass(const StringData* name) {
-  ASSERT(name != NULL);
-  return namedAlloc<NSKnownClass>(name, sizeof(Class*), sizeof(Class*));
+  return allocKnownClass(Unit::GetNamedEntity(name), false);
 }
 
 CacheHandle allocClassInitProp(const StringData* name) {
@@ -534,8 +602,12 @@ CacheHandle allocClassInitSProp(const StringData* name) {
                                     sizeof(TypedValue*));
 }
 
+CacheHandle allocFixedFunction(const NamedEntity* ne, bool persistent) {
+  return allocFuncOrClass(&ne->m_cachedFuncOffset, persistent);
+}
+
 CacheHandle allocFixedFunction(const StringData* name) {
-  return namedAlloc<NSFunction>(name, sizeof(Func*), sizeof(Func*));
+  return allocFixedFunction(Unit::GetNamedEntity(name), false);
 }
 
 template<bool checkOnly>
diff --git a/src/runtime/vm/translator/targetcache.h b/src/runtime/vm/translator/targetcache.h
index ca1c49cd02..fce39751ee 100644
--- a/src/runtime/vm/translator/targetcache.h
+++ b/src/runtime/vm/translator/targetcache.h
@@ -38,7 +38,7 @@ void flush();
  * layout. So the memory is in tl_targetCaches, but we allocate it via the
  * global s_frontier. This is protected by the translator's write-lease.
  */
-extern __thread DataBlock tl_targetCaches;
+extern __thread void* tl_targetCaches;
 extern size_t s_frontier;
 
 static const int kConditionFlagsOff = 0;
@@ -55,14 +55,12 @@ static const int kDefaultNumLines = 4;
 typedef ptrdiff_t CacheHandle;
 
 enum PHPNameSpace {
-  NSFunction,
   NSCtor,
   NSFixedCall,
   NSDynFunction,
   NSStaticMethod,
   NSStaticMethodF,
   NSClass,
-  NSKnownClass,
   NSClsInitProp,
   NSClsInitSProp,
 
@@ -79,7 +77,8 @@ enum PHPNameSpace {
   NumCaseSensitive = NumNameSpaces - NumInsensitive,
   FirstCaseSensitive = NumInsensitive,
 
-  NSInvalid = -1
+  NSInvalid = -1,
+  NSPersistent = -2
 };
 
 template <bool sensitive>
@@ -99,6 +98,7 @@ bool testBit(CacheHandle handle, uint32 mask);
 bool testBit(size_t bit);
 bool testAndSetBit(CacheHandle handle, uint32 mask);
 bool testAndSetBit(size_t bit);
+bool isPersistentHandle(CacheHandle handle);
 
 CacheHandle ptrToHandle(const void*);
 
@@ -107,7 +107,7 @@ TCA fcallHelper(ActRec* ar);
 static inline void*
 handleToPtr(CacheHandle h) {
   ASSERT(h < RuntimeOption::EvalJitTargetCacheSize);
-  return tl_targetCaches.base + h;
+  return (char*)tl_targetCaches + h;
 }
 
 template<class T>
@@ -195,11 +195,6 @@ struct FixedFuncCache {
     return (FixedFuncCache*)handleToPtr(handle);
   }
 
-  static CacheHandle alloc(const StringData* name) {
-    return namedAlloc<NSFunction>(name, sizeof(FixedFuncCache),
-                                  sizeof(FixedFuncCache));
-  }
-
   static void invalidate(CacheHandle handle) {
     FixedFuncCache* thiz = cacheAtHandle(handle);
     thiz->m_func = NULL;
@@ -343,7 +338,7 @@ class GlobalCache {
 
 protected:
   static inline GlobalCache* cacheAtHandle(CacheHandle handle) {
-    return (GlobalCache*)(uintptr_t(tl_targetCaches.base) + handle);
+    return (GlobalCache*)(uintptr_t(tl_targetCaches) + handle);
   }
 
   template<bool isBoxed>
@@ -383,6 +378,8 @@ public:
  * The request-private Class* for a given class name. This is used when
  * the class name is known at translation time.
  */
+CacheHandle allocKnownClass(const Class* name);
+CacheHandle allocKnownClass(const NamedEntity* name, bool persistent);
 CacheHandle allocKnownClass(const StringData* name);
 typedef Class* (*lookupKnownClass_func_t)(Class** cache,
                                           const StringData* clsName,
@@ -393,6 +390,7 @@ Class* lookupKnownClass(Class** cache, const StringData* clsName,
 CacheHandle allocClassInitProp(const StringData* name);
 CacheHandle allocClassInitSProp(const StringData* name);
 
+CacheHandle allocFixedFunction(const NamedEntity* ne, bool persistent);
 CacheHandle allocFixedFunction(const StringData* name);
 
 /*
@@ -427,7 +425,7 @@ CacheHandle allocStatic();
 class SPropCache {
 private:
   static inline SPropCache* cacheAtHandle(CacheHandle handle) {
-    return (SPropCache*)(uintptr_t(tl_targetCaches.base) + handle);
+    return (SPropCache*)(uintptr_t(tl_targetCaches) + handle);
   }
   CacheHandle allocConstantLocked(StringData* name);
 public:
diff --git a/src/runtime/vm/translator/translator-x64.cpp b/src/runtime/vm/translator/translator-x64.cpp
index b48818a010..1328cde25a 100644
--- a/src/runtime/vm/translator/translator-x64.cpp
+++ b/src/runtime/vm/translator/translator-x64.cpp
@@ -2802,7 +2802,7 @@ void enterTCHelper(Cell* vm_sp,
                    TCA start,
                    TReqInfo* infoPtr,
                    ActRec* firstAR,
-                   uint8_t* targetCacheBase) asm ("__enterTCHelper");
+                   void* targetCacheBase) asm ("__enterTCHelper");
 
 struct DepthGuard {
   static __thread int m_depth;
@@ -2850,7 +2850,7 @@ TranslatorX64::enterTC(SrcKey sk) {
     // enterTCHelper does not preserve these registers.
     asm volatile("" : : : "rbx","r12","r13","r14","r15");
     enterTCHelper(vmsp(), vmfp(), start, &info, vmFirstAR(),
-                  tl_targetCaches.base);
+                  tl_targetCaches);
     asm volatile("" : : : "rbx","r12","r13","r14","r15");
 
     tl_regState = REGSTATE_CLEAN; // Careful: pc isn't sync'ed yet.
@@ -8320,7 +8320,7 @@ TranslatorX64::translateFPushFuncD(const Tracelet& t,
   if (funcCanChange) {
     // Look it up in a FuncCache.
     using namespace TargetCache;
-    CacheHandle ch = FixedFuncCache::alloc(name);
+    CacheHandle ch = allocFixedFunction(nep.second, false);
     size_t funcOff = AROFF(m_func) - sizeof(ActRec);
     size_t funcCacheOff = ch + offsetof(FixedFuncCache, m_func);
 
@@ -8575,37 +8575,44 @@ TranslatorX64::translateFPushCufOp(const Tracelet& t,
   if (cls) {
     setupActRecClsForStaticCall(ni, func, cls, clsOff, forward);
     TargetCache::CacheHandle ch = cls->m_cachedOffset;
-    a.          cmp_imm32_disp_reg32(0, ch, rVmTl);
-    {
-      UnlikelyIfBlock<CC_Z> ifNull(a, astubs);
-      if (false) {
-        checkClass<false>(0, NULL, NULL);
-        checkClass<true>(0, NULL, NULL);
-      }
-      EMIT_CALL(astubs, TCA(safe ? checkClass<false> : checkClass<true>),
-                IMM(ch), IMM(uintptr_t(cls->name())),
-                RPLUS(rVmSp, vstackOffset(ni, startOfActRec)));
-      recordReentrantStubCall(ni, true);
-      if (safe) {
-        astubs.  mov_reg64_reg64(rax, *flag);
+    if (!TargetCache::isPersistentHandle(ch)) {
+      a.          cmp_imm32_disp_reg32(0, ch, rVmTl);
+      {
+        UnlikelyIfBlock<CC_Z> ifNull(a, astubs);
+        if (false) {
+          checkClass<false>(0, NULL, NULL);
+          checkClass<true>(0, NULL, NULL);
+        }
+        EMIT_CALL(astubs, TCA(safe ? checkClass<false> : checkClass<true>),
+                  IMM(ch), IMM(uintptr_t(cls->name())),
+                  RPLUS(rVmSp, vstackOffset(ni, startOfActRec)));
+        recordReentrantStubCall(ni, true);
+        if (safe) {
+          astubs.  mov_reg64_reg64(rax, *flag);
+        }
       }
     }
   } else {
-    ScratchReg funcReg(m_regMap);
     TargetCache::CacheHandle ch = func->getCachedOffset();
-    a.          load_reg64_disp_reg64(rVmTl, ch, *funcReg);
-    emitVStackStore(a, ni, *funcReg, funcOff);
-    emitVStackStoreImm(a, ni, 0, clsOff, sz::qword, &m_regMap);
-    a.          test_reg64_reg64(*funcReg, *funcReg);
-    {
-      UnlikelyIfBlock<CC_Z> ifNull(a, astubs);
-      emitVStackStoreImm(astubs, ni,
-                         uintptr_t(SystemLib::GetNullFunction()), funcOff);
-      if (safe) {
-        emitImmReg(astubs, false, *flag);
-      } else {
-        EMIT_CALL(astubs, TCA(warnMissingFunc), IMM(uintptr_t(func->name())));
-        recordReentrantStubCall(ni, true);
+    if (TargetCache::isPersistentHandle(ch)) {
+      emitVStackStoreImm(a, ni, uintptr_t(func), funcOff, sz::qword);
+      emitVStackStoreImm(a, ni, 0, clsOff, sz::qword, &m_regMap);
+    } else {
+      ScratchReg funcReg(m_regMap);
+      a.          load_reg64_disp_reg64(rVmTl, ch, *funcReg);
+      emitVStackStore(a, ni, *funcReg, funcOff);
+      emitVStackStoreImm(a, ni, 0, clsOff, sz::qword, &m_regMap);
+      a.          test_reg64_reg64(*funcReg, *funcReg);
+      {
+        UnlikelyIfBlock<CC_Z> ifNull(a, astubs);
+        emitVStackStoreImm(astubs, ni,
+                           uintptr_t(SystemLib::GetNullFunction()), funcOff);
+        if (safe) {
+          emitImmReg(astubs, false, *flag);
+        } else {
+          EMIT_CALL(astubs, TCA(warnMissingFunc), IMM(uintptr_t(func->name())));
+          recordReentrantStubCall(ni, true);
+        }
       }
     }
   }
@@ -10334,7 +10341,7 @@ std::string TranslatorX64::getUsage() {
                       m_irAUsage,     100 * m_irAUsage / a.code.size,
                       m_irAstubsUsage, 100 * m_irAstubsUsage / astubs.code.size,
                       tcUsage,
-                      100 * tcUsage / TargetCache::tl_targetCaches.size);
+                      100 * tcUsage / RuntimeOption::EvalJitTargetCacheSize);
   return usage;
 }
 
diff --git a/src/runtime/vm/treadmill.cpp b/src/runtime/vm/treadmill.cpp
index 8b342edac7..dfcc33440a 100644
--- a/src/runtime/vm/treadmill.cpp
+++ b/src/runtime/vm/treadmill.cpp
@@ -70,19 +70,6 @@ static GenCount* idToCount(int threadID) {
   return s_inflightRequests + threadID;
 }
 
-static bool isUnreachable(GenCount gc) {
-  if (gc > s_gen) return false;
-  for (int i = 0; i < s_maxThreadID; ++i) {
-    if (s_inflightRequests[i] != kIdleGenCount &&
-        s_inflightRequests[i] <= gc) {
-      TRACE(1, "request %d still in flight, of gen %d\n", i,
-            int(s_inflightRequests[i]));
-      return false;
-    }
-  }
-  return true;
-}
-
 typedef std::list<WorkItem*> PendingTriggers;
 static PendingTriggers s_tq;
 
@@ -115,16 +102,27 @@ void finishRequest(int threadId) {
 
     // After finishing a request, check to see if we've allowed any triggers
     // to fire.
-    for (PendingTriggers::iterator it = s_tq.begin();
-         it != s_tq.end(); ) {
-      TRACE(2, "considering delendum %d\n", int((*it)->m_gen));
-      if (isUnreachable((*it)->m_gen)) {
+    PendingTriggers::iterator it = s_tq.begin();
+    PendingTriggers::iterator end = s_tq.end();
+    if (it != end) {
+      GenCount gen = (*it)->m_gen;
+      GenCount limit = s_gen + 1;
+      for (int i = 0; i < s_maxThreadID; ++i) {
+        if (s_inflightRequests[i] != kIdleGenCount &&
+            s_inflightRequests[i] < limit) {
+          limit = s_inflightRequests[i];
+          if (limit <= gen) break;
+        }
+      }
+      do {
+        TRACE(2, "considering delendum %d\n", int((*it)->m_gen));
+        if ((*it)->m_gen >= limit) {
+          TRACE(2, "not unreachable! %d\n", int((*it)->m_gen));
+          break;
+        }
         toFire.push_back(*it);
         it = s_tq.erase(it);
-      } else {
-        TRACE(2, "not unreachable! %d\n", int((*it)->m_gen));
-        it++;
-      }
+      } while (it != end);
     }
   }
   for (unsigned i = 0; i < toFire.size(); ++i) {
diff --git a/src/runtime/vm/unit.cpp b/src/runtime/vm/unit.cpp
index 01f43024e5..1e4d97d3de 100644
--- a/src/runtime/vm/unit.cpp
+++ b/src/runtime/vm/unit.cpp
@@ -37,6 +37,7 @@
 #include <runtime/vm/func_inline.h>
 #include <runtime/eval/runtime/file_repository.h>
 #include <runtime/vm/stats.h>
+#include <runtime/vm/treadmill.h>
 
 namespace HPHP {
 namespace VM {
@@ -78,6 +79,16 @@ Func* NamedEntity::getCachedFunc() const {
   return NULL;
 }
 
+UnitMergeInfo* UnitMergeInfo::alloc(size_t size) {
+  UnitMergeInfo* mi = (UnitMergeInfo*)malloc(
+    sizeof(UnitMergeInfo) + size * sizeof(void*));
+  mi->m_firstHoistableFunc = 0;
+  mi->m_firstHoistablePreClass = 0;
+  mi->m_firstMergeablePreClass = 0;
+  mi->m_mergeablesSize = size;
+  return mi;
+}
+
 Array Unit::getUserFunctions() {
   // Return an array of all defined functions.  This method is used
   // to support get_defined_functions().
@@ -261,11 +272,7 @@ Unit::Unit()
     : m_sn(-1), m_bc(NULL), m_bclen(0),
       m_bc_meta(NULL), m_bc_meta_len(0), m_filepath(NULL),
       m_dirpath(NULL), m_md5(),
-      m_mergeables(NULL),
-      m_firstHoistableFunc(0),
-      m_firstHoistablePreClass(0),
-      m_firstMergeablePreClass(0),
-      m_mergeablesSize(0),
+      m_mergeInfo(NULL),
       m_cacheOffset(0),
       m_repoId(-1),
       m_mergeState(UnitMergeStateUnmerged),
@@ -282,8 +289,10 @@ Unit::~Unit() {
   free(m_bc);
   free(m_bc_meta);
 
-  // Delete all Func's.
-  range_foreach(mutableFuncs(), Func::destroy);
+  if (m_mergeInfo) {
+    // Delete all Func's.
+    range_foreach(mutableFuncs(), Func::destroy);
+  }
 
   // ExecutionContext and the TC may retain references to Class'es, so
   // it is possible for Class'es to outlive their Unit.
@@ -309,7 +318,7 @@ Unit::~Unit() {
     Transl::unmergePreConsts(m_preConsts, this);
   }
 
-  free(m_mergeables);
+  free(m_mergeInfo);
 }
 
 void* Unit::operator new(size_t sz) {
@@ -452,7 +461,7 @@ Class* Unit::defClass(const PreClass* preClass,
       newClass->m_cachedOffset = top->m_cachedOffset;
     } else {
       newClass->m_cachedOffset =
-        Transl::TargetCache::allocKnownClass(preClass->name());
+        Transl::TargetCache::allocKnownClass(newClass.get());
     }
     newClass->m_nextClass = top;
     Util::compiler_membar();
@@ -522,8 +531,9 @@ void Unit::loadFunc(const Func *func) {
   ASSERT(!func->isMethod());
   const NamedEntity *ne = func->getNamedEntity();
   if (UNLIKELY(!ne->m_cachedFuncOffset)) {
-    const_cast<NamedEntity*>(ne)->m_cachedFuncOffset =
-      Transl::TargetCache::allocFixedFunction(func->name());
+    Transl::TargetCache::allocFixedFunction(ne,
+                                            func->attrs() & AttrPersistent &&
+                                            RuntimeOption::RepoAuthoritative);
   }
   const_cast<Func*>(func)->m_cachedOffset = ne->m_cachedFuncOffset;
 }
@@ -566,19 +576,19 @@ void Unit::initialMerge() {
        * the value being defined/assigned.
        */
       bool allClassesUnique = true;
-      int ix = m_firstHoistablePreClass;
-      int end = m_firstMergeablePreClass;
+      int ix = m_mergeInfo->m_firstHoistablePreClass;
+      int end = m_mergeInfo->m_firstMergeablePreClass;
       while (ix < end) {
-        PreClass* pre = (PreClass*)mergeableObj(ix++);
+        PreClass* pre = (PreClass*)m_mergeInfo->mergeableObj(ix++);
         if (allClassesUnique) {
           allClassesUnique = pre->attrs() & AttrUnique;
         }
       }
       if (isMergeOnly()) {
-        ix = m_firstMergeablePreClass;
-        end = m_mergeablesSize;
+        ix = m_mergeInfo->m_firstMergeablePreClass;
+        end = m_mergeInfo->m_mergeablesSize;
         while (ix < end) {
-          void *obj = mergeableObj(ix);
+          void *obj = m_mergeInfo->mergeableObj(ix);
           InclOpFlags flags = InclOpDefault;
           UnitMergeKind k = UnitMergeKind(uintptr_t(obj) & 7);
           switch (k) {
@@ -606,19 +616,19 @@ void Unit::initialMerge() {
                 ASSERT(efile);
                 Unit* unit = efile->unit();
                 unit->initialMerge();
-                mergeableObj(ix) = (void*)((char*)unit + (int)k);
+                m_mergeInfo->mergeableObj(ix) = (void*)((char*)unit + (int)k);
               }
               break;
             case UnitMergeKindDefine: {
               StringData* s = (StringData*)((char*)obj - (int)k);
-              TypedValue* v = (TypedValue*)mergeableData(ix + 1);
+              TypedValue* v = (TypedValue*)m_mergeInfo->mergeableData(ix + 1);
               ix += sizeof(TypedValue) / sizeof(void*);
               v->_count = TargetCache::allocConstant(s);
               break;
             }
             case UnitMergeKindGlobal: {
               StringData* s = (StringData*)((char*)obj - (int)k);
-              TypedValue* v = (TypedValue*)mergeableData(ix + 1);
+              TypedValue* v = (TypedValue*)m_mergeInfo->mergeableData(ix + 1);
               ix += sizeof(TypedValue) / sizeof(void*);
               v->_count = TargetCache::GlobalCache::alloc(s);
               break;
@@ -656,18 +666,156 @@ void Unit::merge() {
   }
 
   if (UNLIKELY(isDebuggerAttached())) {
-    mergeImpl<true>(TargetCache::handleToPtr(0));
+    mergeImpl<true>(TargetCache::handleToPtr(0), m_mergeInfo);
   } else {
-    mergeImpl<false>(TargetCache::handleToPtr(0));
+    mergeImpl<false>(TargetCache::handleToPtr(0), m_mergeInfo);
+  }
+}
+
+void* Unit::replaceUnit() const {
+  if (m_mergeState & UnitMergeStateEmpty) return NULL;
+  if (isMergeOnly() &&
+      m_mergeInfo->m_mergeablesSize == m_mergeInfo->m_firstHoistableFunc + 1) {
+    void* obj =
+      m_mergeInfo->mergeableObj(m_mergeInfo->m_firstHoistableFunc);
+    if (m_mergeInfo->m_firstMergeablePreClass ==
+        m_mergeInfo->m_firstHoistableFunc) {
+      int k = uintptr_t(obj) & 7;
+      if (k != UnitMergeKindClass) return obj;
+    } else if (m_mergeInfo->m_firstHoistablePreClass ==
+               m_mergeInfo->m_firstHoistableFunc) {
+      if (uintptr_t(obj) & 1) {
+        return (char*)obj - 1 + (int)UnitMergeKindUniqueDefinedClass;
+      }
+    }
   }
+  return const_cast<Unit*>(this);
+}
+
+size_t compactUnitMergeInfo(UnitMergeInfo* in, UnitMergeInfo* out) {
+  Func** it = in->funcHoistableBegin();
+  Func** fend = in->funcEnd();
+  Func** iout = 0;
+  unsigned ix, end, oix = 0;
+
+  if (out) {
+    if (in != out) memcpy(out, in, uintptr_t(it) - uintptr_t(in));
+    iout = out->funcHoistableBegin();
+  }
+
+  size_t delta = 0;
+  while (it != fend) {
+    Func* func = *it++;
+    if (TargetCache::isPersistentHandle(func->getCachedOffset())) {
+      delta++;
+    } else if (iout) {
+      *iout++ = func;
+    }
+  }
+
+  if (out) {
+    oix = out->m_firstHoistablePreClass -= delta;
+  }
+
+  ix = in->m_firstHoistablePreClass;
+  end = in->m_firstMergeablePreClass;
+  for (; ix < end; ++ix) {
+    void* obj = in->mergeableObj(ix);
+    ASSERT((uintptr_t(obj) & 1) == 0);
+    PreClass* pre = (PreClass*)obj;
+    Class* cls = *pre->namedEntity()->clsList();
+    ASSERT(cls && !cls->m_nextClass);
+    ASSERT(cls->preClass() == pre);
+    if (TargetCache::isPersistentHandle(cls->m_cachedOffset)) {
+      delta++;
+    } else if (out) {
+      out->mergeableObj(oix++) = (void*)(uintptr_t(cls) | 1);
+    }
+  }
+
+  if (out) {
+    out->m_firstMergeablePreClass = oix;
+  }
+
+  end = in->m_mergeablesSize;
+  while (ix < end) {
+    void* obj = in->mergeableObj(ix++);
+    UnitMergeKind k = UnitMergeKind(uintptr_t(obj) & 7);
+    switch (k) {
+      case UnitMergeKindClass: {
+        PreClass* pre = (PreClass*)obj;
+        Class* cls = *pre->namedEntity()->clsList();
+        ASSERT(cls && !cls->m_nextClass);
+        ASSERT(cls->preClass() == pre);
+        if (TargetCache::isPersistentHandle(cls->m_cachedOffset)) {
+          delta++;
+        } else if (out) {
+          out->mergeableObj(oix++) =
+            (void*)(uintptr_t(cls) | UnitMergeKindUniqueDefinedClass);
+        }
+        break;
+      }
+      case UnitMergeKindUniqueDefinedClass:
+        not_reached();
+
+      case UnitMergeKindDefine:
+      case UnitMergeKindGlobal:
+        if (out) {
+          out->mergeableObj(oix++) = obj;
+          *(TypedValue*)out->mergeableData(oix) =
+            *(TypedValue*)in->mergeableData(ix);
+          oix += sizeof(TypedValue) / sizeof(void*);
+        }
+        ix += sizeof(TypedValue) / sizeof(void*);
+        break;
+
+      case UnitMergeKindReqMod:
+      case UnitMergeKindReqSrc:
+      case UnitMergeKindReqDoc: {
+        Unit *unit = (Unit*)((char*)obj - (int)k);
+        void *rep = unit->replaceUnit();
+        if (!rep) {
+          delta++;
+        } else if (out) {
+          if (rep == unit) {
+            out->mergeableObj(oix++) = obj;
+          } else {
+            UnitMergeKind k1 = UnitMergeKind(uintptr_t(rep) & 7);
+            switch (k1) {
+              case UnitMergeKindReqMod:
+              case UnitMergeKindReqSrc:
+                break;
+              case UnitMergeKindReqDoc:
+                if (k != UnitMergeKindReqDoc) {
+                  rep = obj;
+                }
+                break;
+              default:
+                break;
+            }
+            out->mergeableObj(oix++) = rep;
+          }
+        }
+        break;
+      }
+      case UnitMergeKindDone:
+        not_reached();
+    }
+  }
+  if (out) {
+    // copy the UnitMergeKindDone marker
+    out->mergeableObj(oix) = in->mergeableObj(ix);
+    out->m_mergeablesSize = oix;
+  }
+  return delta;
 }
 
 template <bool debugger>
-void Unit::mergeImpl(void* tcbase) {
+void Unit::mergeImpl(void* tcbase, UnitMergeInfo* mi) {
   ASSERT(m_mergeState & UnitMergeStateMerged);
 
-  Func** it = funcHoistableBegin();
-  Func** fend = funcEnd();
+  Func** it = mi->funcHoistableBegin();
+  Func** fend = mi->funcEnd();
   if (it != fend) {
     if (LIKELY((m_mergeState & UnitMergeStateUniqueFuncs) != 0)) {
       do {
@@ -686,8 +834,8 @@ void Unit::mergeImpl(void* tcbase) {
   }
 
   bool redoHoistable = false;
-  int ix = m_firstHoistablePreClass;
-  int end = m_firstMergeablePreClass;
+  int ix = mi->m_firstHoistablePreClass;
+  int end = mi->m_firstMergeablePreClass;
   // iterate over all the potentially hoistable classes
   // with no fatals on failure
   if (ix < end) {
@@ -695,10 +843,25 @@ void Unit::mergeImpl(void* tcbase) {
       // The first time this unit is merged, if the classes turn out to be all
       // unique and defined, we replace the PreClass*'s with the corresponding
       // Class*'s, with the low-order bit marked.
-      PreClass* pre = (PreClass*)mergeableObj(ix);
+      PreClass* pre = (PreClass*)mi->mergeableObj(ix);
       if (LIKELY(uintptr_t(pre) & 1)) {
+        Stats::inc(Stats::UnitMerge_hoistable);
         Class* cls = (Class*)(uintptr_t(pre) & ~1);
+        if (cls->isPersistent()) {
+          Stats::inc(Stats::UnitMerge_hoistable_persistent);
+        }
+        if (Stats::enabled() &&
+            TargetCache::isPersistentHandle(cls->m_cachedOffset)) {
+          Stats::inc(Stats::UnitMerge_hoistable_persistent_cache);
+        }
         if (Class* parent = cls->parent()) {
+          if (parent->isPersistent()) {
+            Stats::inc(Stats::UnitMerge_hoistable_persistent_parent);
+          }
+          if (Stats::enabled() &&
+              TargetCache::isPersistentHandle(parent->m_cachedOffset)) {
+            Stats::inc(Stats::UnitMerge_hoistable_persistent_parent_cache);
+          }
           if (UNLIKELY(!getDataRef<Class*>(tcbase, parent->m_cachedOffset))) {
             redoHoistable = true;
             continue;
@@ -731,10 +894,11 @@ void Unit::mergeImpl(void* tcbase) {
       // because now A and D go on the maybe-hoistable list
       // B goes on the never hoistable list, and we
       // fatal trying to instantiate D before B
-      if (end == (int)m_mergeablesSize) {
-        ix = m_firstHoistablePreClass;
+      Stats::inc(Stats::UnitMerge_redo_hoistable);
+      if (end == (int)mi->m_mergeablesSize) {
+        ix = mi->m_firstHoistablePreClass;
         do {
-          void* obj = mergeableObj(ix);
+          void* obj = mi->mergeableObj(ix);
           if (UNLIKELY(uintptr_t(obj) & 1)) {
             Class* cls = (Class*)(uintptr_t(obj) & ~1);
             defClass(cls->preClass(), true);
@@ -749,22 +913,33 @@ void Unit::mergeImpl(void* tcbase) {
 
   // iterate over all but the guaranteed hoistable classes
   // fataling if we fail.
-  void* obj = mergeableObj(ix);
+  void* obj = mi->mergeableObj(ix);
   UnitMergeKind k = UnitMergeKind(uintptr_t(obj) & 7);
   do {
     switch(k) {
       case UnitMergeKindClass:
         do {
+          Stats::inc(Stats::UnitMerge_mergeable);
+          Stats::inc(Stats::UnitMerge_mergeable_class);
           defClass((PreClass*)obj, true);
-          obj = mergeableObj(++ix);
+          obj = mi->mergeableObj(++ix);
           k = UnitMergeKind(uintptr_t(obj) & 7);
         } while (!k);
         continue;
 
       case UnitMergeKindUniqueDefinedClass:
         do {
+          Stats::inc(Stats::UnitMerge_mergeable);
+          Stats::inc(Stats::UnitMerge_mergeable_unique);
           Class* other = NULL;
           Class* cls = (Class*)((char*)obj - (int)k);
+          if (cls->isPersistent()) {
+            Stats::inc(Stats::UnitMerge_mergeable_unique_persistent);
+          }
+          if (Stats::enabled() &&
+              TargetCache::isPersistentHandle(cls->m_cachedOffset)) {
+            Stats::inc(Stats::UnitMerge_mergeable_unique_persistent_cache);
+          }
           Class::Avail avail = cls->avail(other, true);
           if (UNLIKELY(avail == Class::AvailFail)) {
             raise_error("unknown class %s", other->name()->data());
@@ -772,29 +947,33 @@ void Unit::mergeImpl(void* tcbase) {
           ASSERT(avail == Class::AvailTrue);
           getDataRef<Class*>(tcbase, cls->m_cachedOffset) = cls;
           if (debugger) phpDefClassHook(cls);
-          obj = mergeableObj(++ix);
+          obj = mi->mergeableObj(++ix);
           k = UnitMergeKind(uintptr_t(obj) & 7);
         } while (k == UnitMergeKindUniqueDefinedClass);
         continue;
 
       case UnitMergeKindDefine:
         do {
+          Stats::inc(Stats::UnitMerge_mergeable);
+          Stats::inc(Stats::UnitMerge_mergeable_define);
           StringData* name = (StringData*)((char*)obj - (int)k);
-          TypedValue *v = (TypedValue*)mergeableData(ix + 1);
+          TypedValue *v = (TypedValue*)mi->mergeableData(ix + 1);
           mergeCns(getDataRef<TypedValue>(tcbase, v->_count), v, name);
           ix += 1 + sizeof(TypedValue) / sizeof(void*);
-          obj = mergeableObj(ix);
+          obj = mi->mergeableObj(ix);
           k = UnitMergeKind(uintptr_t(obj) & 7);
         } while (k == UnitMergeKindDefine);
         continue;
 
       case UnitMergeKindGlobal:
         do {
+          Stats::inc(Stats::UnitMerge_mergeable);
+          Stats::inc(Stats::UnitMerge_mergeable_global);
           StringData* name = (StringData*)((char*)obj - (int)k);
-          TypedValue *v = (TypedValue*)mergeableData(ix + 1);
+          TypedValue *v = (TypedValue*)mi->mergeableData(ix + 1);
           setGlobal(&getDataRef<char>(tcbase, v->_count), v, name);
           ix += 1 + sizeof(TypedValue) / sizeof(void*);
-          obj = mergeableObj(ix);
+          obj = mi->mergeableObj(ix);
           k = UnitMergeKind(uintptr_t(obj) & 7);
         } while (k == UnitMergeKindGlobal);
         continue;
@@ -803,12 +982,14 @@ void Unit::mergeImpl(void* tcbase) {
       case UnitMergeKindReqSrc:
       case UnitMergeKindReqDoc:
         do {
+          Stats::inc(Stats::UnitMerge_mergeable);
+          Stats::inc(Stats::UnitMerge_mergeable_require);
           Unit *unit = (Unit*)((char*)obj - (int)k);
           uchar& unitLoadedFlags =
             getDataRef<uchar>(tcbase, unit->m_cacheOffset);
           if (!(unitLoadedFlags & unit->m_cacheMask)) {
             unitLoadedFlags |= unit->m_cacheMask;
-            unit->mergeImpl<debugger>(tcbase);
+            unit->mergeImpl<debugger>(tcbase, unit->m_mergeInfo);
             if (UNLIKELY(!unit->isMergeOnly())) {
               Stats::inc(Stats::PseudoMain_Reentered);
               TypedValue ret;
@@ -821,15 +1002,18 @@ void Unit::mergeImpl(void* tcbase) {
           } else {
             Stats::inc(Stats::PseudoMain_Guarded);
           }
-          obj = mergeableObj(++ix);
+          obj = mi->mergeableObj(++ix);
           k = UnitMergeKind(uintptr_t(obj) & 7);
         } while (isMergeKindReq(k));
         continue;
       case UnitMergeKindDone:
-        ASSERT((unsigned)ix == m_mergeablesSize);
+        Stats::inc(Stats::UnitMerge_mergeable, -1);
+        ASSERT((unsigned)ix == mi->m_mergeablesSize);
         if (UNLIKELY((m_mergeState & (UnitMergeStateUniqueClasses|
                                       UnitMergeStateUniqueDefinedClasses)) ==
                      UnitMergeStateUniqueClasses)) {
+          SimpleLock lock(unitInitLock);
+          if (m_mergeState & UnitMergeStateUniqueDefinedClasses) return;
           /*
            * All the classes are known to be unique, and we just got
            * here, so all were successfully defined. We can now go
@@ -837,58 +1021,33 @@ void Unit::mergeImpl(void* tcbase) {
            * UnitMergeKindUniqueDefinedClass, and all hoistable
            * classes to their Class*'s instead of PreClass*'s.
            *
-           * This is a pure optimization: whether readers see the
-           * old value or the new does not affect correctness.
-           * Also, its idempotent - even if multiple threads do
-           * this update simultaneously (which they can -- there is
-           * a race here, since the check-and-write of m_mergeState
-           * is not atomic), they all make exactly the same change,
-           * and can deal with reading pointers that have already
-           * been marked.
+           * We can also remove any Persistent Class/Func*'s,
+           * and any requires of modules that are (now) empty
            */
-          m_mergeState |= UnitMergeStateUniqueDefinedClasses;
-
-          ix = m_firstHoistablePreClass;
-          end = m_firstMergeablePreClass;
-          for (; ix < end; ++ix) {
-            obj = mergeableObj(ix);
-            // The mark check is necessary, since the pointer may have already
-            // been marked, even though this code is "only executed once". See
-            // the note about races above.
-            if ((uintptr_t(obj) & 1) == 0) {
-              PreClass* pre = (PreClass*)obj;
-              Class* cls = *pre->namedEntity()->clsList();
-              ASSERT(cls && !cls->m_nextClass);
-              ASSERT(cls->preClass() == pre);
-              mergeableObj(ix) = (void*)(uintptr_t(cls) | 1);
-            }
+          size_t delta = compactUnitMergeInfo(mi, NULL);
+          UnitMergeInfo* newMi = mi;
+          if (delta) {
+            newMi = UnitMergeInfo::alloc(mi->m_mergeablesSize - delta);
           }
-
-          ix = m_firstMergeablePreClass;
-          end = m_mergeablesSize;
-          do {
-            obj = mergeableObj(ix);
-            k = UnitMergeKind(uintptr_t(obj) & 7);
-            switch (k) {
-              case UnitMergeKindClass: {
-                // obj's low-order bits are UnitMergeKindClass, but fortunately,
-                // UnitMergeKindClass == 0.
-                PreClass* pre = (PreClass*)obj;
-                Class* cls = *pre->namedEntity()->clsList();
-                ASSERT(cls && !cls->m_nextClass);
-                ASSERT(cls->preClass() == pre);
-                mergeableObj(ix) =
-                  (char*)cls + (int)UnitMergeKindUniqueDefinedClass;
-                break;
-              }
-              case UnitMergeKindDefine:
-              case UnitMergeKindGlobal:
-                ix += sizeof(TypedValue) / sizeof(void*);
-                break;
-              default:
-                break;
+          /*
+           * In the case where mi == newMi, there's an apparent
+           * race here. Although we have a lock, so we're the only
+           * ones modifying this, there could be any number of
+           * readers. But thats ok, because it doesnt matter
+           * whether they see the old contents or the new.
+           */
+          compactUnitMergeInfo(mi, newMi);
+          if (newMi != mi) {
+            this->m_mergeInfo = newMi;
+            Treadmill::deferredFree(mi);
+            if (isMergeOnly() &&
+                newMi->m_firstHoistableFunc == newMi->m_mergeablesSize) {
+              m_mergeState |= UnitMergeStateEmpty;
             }
-          } while (++ix < end);
+          }
+          m_mergeState |= UnitMergeStateUniqueDefinedClasses;
+          ASSERT(newMi->m_firstMergeablePreClass == newMi->m_mergeablesSize ||
+                 isMergeOnly());
         }
         return;
     }
@@ -2075,53 +2234,52 @@ Unit* UnitEmitter::create() {
     }
     ix += extra;
   }
-  u->m_mergeables = malloc((ix+1) * sizeof(void*));
-  u->m_mergeablesSize = ix;
-  u->m_firstHoistableFunc = 0;
+  UnitMergeInfo *mi = UnitMergeInfo::alloc(ix);
+  u->m_mergeInfo = mi;
   ix = 0;
   for (FeVec::const_iterator it = m_fes.begin(); it != m_fes.end(); ++it) {
     Func* func = (*it)->create(*u);
     if (func->top()) {
-      if (!u->m_firstHoistableFunc) {
-        u->m_firstHoistableFunc = ix;
+      if (!mi->m_firstHoistableFunc) {
+        mi->m_firstHoistableFunc = ix;
       }
     } else {
-      ASSERT(!u->m_firstHoistableFunc);
+      ASSERT(!mi->m_firstHoistableFunc);
     }
-    u->mergeableObj(ix++) = func;
+    mi->mergeableObj(ix++) = func;
   }
   ASSERT(u->getMain()->isPseudoMain());
-  if (!u->m_firstHoistableFunc) {
-    u->m_firstHoistableFunc =  ix;
+  if (!mi->m_firstHoistableFunc) {
+    mi->m_firstHoistableFunc =  ix;
   }
-  u->m_firstHoistablePreClass = ix;
+  mi->m_firstHoistablePreClass = ix;
   ASSERT(m_fes.size());
   for (IdVec::const_iterator it = m_hoistablePceIdVec.begin();
        it != m_hoistablePceIdVec.end(); ++it) {
-    u->mergeableObj(ix++) = u->m_preClasses[*it].get();
+    mi->mergeableObj(ix++) = u->m_preClasses[*it].get();
   }
-  u->m_firstMergeablePreClass = ix;
+  mi->m_firstMergeablePreClass = ix;
   if (u->m_mainReturn._count && !m_allClassesHoistable) {
     for (MergeableStmtVec::const_iterator it = m_mergeableStmts.begin();
          it != m_mergeableStmts.end(); ++it) {
       switch (it->first) {
         case UnitMergeKindClass:
-          u->mergeableObj(ix++) = u->m_preClasses[it->second].get();
+          mi->mergeableObj(ix++) = u->m_preClasses[it->second].get();
           break;
         case UnitMergeKindReqMod:
         case UnitMergeKindReqSrc:
         case UnitMergeKindReqDoc: {
           ASSERT(RuntimeOption::RepoAuthoritative);
           void* name = u->lookupLitstrId(it->second);
-          u->mergeableObj(ix++) = (char*)name + (int)it->first;
+          mi->mergeableObj(ix++) = (char*)name + (int)it->first;
           break;
         }
         case UnitMergeKindDefine:
         case UnitMergeKindGlobal: {
           ASSERT(RuntimeOption::RepoAuthoritative);
           void* name = u->lookupLitstrId(m_mergeableValues[it->second].first);
-          u->mergeableObj(ix++) = (char*)name + (int)it->first;
-          *(TypedValue*)u->mergeableData(ix) =
+          mi->mergeableObj(ix++) = (char*)name + (int)it->first;
+          *(TypedValue*)mi->mergeableData(ix) =
             m_mergeableValues[it->second].second;
           ix += sizeof(TypedValue) / sizeof(void*);
           ASSERT(sizeof(TypedValue) % sizeof(void*) == 0);
@@ -2133,8 +2291,8 @@ Unit* UnitEmitter::create() {
       }
     }
   }
-  ASSERT(ix == u->m_mergeablesSize);
-  u->mergeableObj(ix) = (void*)UnitMergeKindDone;
+  ASSERT(ix == mi->m_mergeablesSize);
+  mi->mergeableObj(ix) = (void*)UnitMergeKindDone;
   u->m_lineTable = createLineTable(m_sourceLocTab, m_bclen);
   for (size_t i = 0; i < m_feTab.size(); ++i) {
     ASSERT(m_feTab[i].second->past() == m_feTab[i].first);
diff --git a/src/runtime/vm/unit.h b/src/runtime/vm/unit.h
index 721f4c2d36..9906e3e099 100644
--- a/src/runtime/vm/unit.h
+++ b/src/runtime/vm/unit.h
@@ -33,6 +33,14 @@
 namespace HPHP {
 namespace VM {
 
+// Forward declarations.
+class Func;
+class FuncEmitter;
+class Repo;
+class FuncDict;
+class Unit;
+struct ActRec;
+
 enum UnitOrigin {
   UnitOriginFile = 0,
   UnitOriginEval = 1
@@ -57,7 +65,8 @@ enum UnitMergeState {
   UnitMergeStateMerged = 2,
   UnitMergeStateUniqueFuncs = 4,
   UnitMergeStateUniqueClasses = 8,
-  UnitMergeStateUniqueDefinedClasses = 16
+  UnitMergeStateUniqueDefinedClasses = 16,
+  UnitMergeStateEmpty = 32
 };
 
 inline bool ALWAYS_INLINE isMergeKindReq(UnitMergeKind k) {
@@ -65,18 +74,49 @@ inline bool ALWAYS_INLINE isMergeKindReq(UnitMergeKind k) {
     unsigned(UnitMergeKindReqDoc - UnitMergeKindReqMod);
 }
 
-typedef const uchar* PC;
+struct UnitMergeInfo {
+  typedef IterRange<Func* const*> FuncRange;
+  typedef IterRange<Func**> MutableFuncRange;
 
-// Forward declarations.
-class Func;
-class FuncEmitter;
-class Repo;
-class FuncDict;
-class Unit;
-struct ActRec;
+  unsigned m_firstHoistableFunc;
+  unsigned m_firstHoistablePreClass;
+  unsigned m_firstMergeablePreClass;
+  unsigned m_mergeablesSize;
+  void*    m_mergeables[1];
+
+  static UnitMergeInfo* alloc(size_t num);
+
+  Func** funcBegin() const {
+    return (Func**)m_mergeables;
+  }
+  Func** funcEnd() const {
+    return funcBegin() + m_firstHoistablePreClass;
+  }
+  Func** funcHoistableBegin() const {
+    return funcBegin() + m_firstHoistableFunc;
+  }
+  MutableFuncRange nonMainFuncs() const {
+    return MutableFuncRange(funcBegin() + 1, funcEnd());
+  }
+  MutableFuncRange hoistableFuncs() const {
+    return MutableFuncRange(funcHoistableBegin(), funcEnd());
+  }
+  FuncRange funcs() const {
+    return FuncRange(funcBegin(), funcEnd());
+  }
+  MutableFuncRange mutableFuncs() {
+    return MutableFuncRange(funcBegin(), funcEnd());
+  }
+  void*& mergeableObj(int ix) { return ((void**)m_mergeables)[ix]; }
+  void* mergeableData(int ix) { return (char*)m_mergeables + ix*sizeof(void*); }
+
+};
+
+typedef const uchar* PC;
 
 struct NamedEntity {
   Class* m_class;
+  unsigned m_cachedClassOffset;
   unsigned m_cachedFuncOffset;
 
   Class* const* clsList() const { return &m_class; }
@@ -263,8 +303,8 @@ struct Unit {
   friend class UnitRepoProxy;
   friend class FuncDict;
 
-  typedef IterRange<Func* const*> FuncRange;
-  typedef IterRange<Func**> MutableFuncRange;
+  typedef UnitMergeInfo::FuncRange FuncRange;
+  typedef UnitMergeInfo::MutableFuncRange MutableFuncRange;
 
   class MetaInfo {
    public:
@@ -434,6 +474,17 @@ struct Unit {
     return cls;
   }
 
+  static Class *lookupUniqueClass(const NamedEntity *ne) {
+    Class *cls = *ne->clsList();
+    if (LIKELY(cls != NULL)) {
+      if (cls->attrs() & AttrUnique && RuntimeOption::RepoAuthoritative) {
+        return cls;
+      }
+      cls = cls->getCached();
+    }
+    return cls;
+  }
+
   static Class *lookupClass(const StringData *clsName) {
     Class *cls = *GetNamedEntity(clsName)->clsList();
     if (LIKELY(cls != NULL)) cls = cls->getCached();
@@ -473,48 +524,38 @@ struct Unit {
     return &m_mainReturn;
   }
 private:
-  // Raw iterators; use with care as they override const.
-  Func** funcBegin() const {
-    return (Func**)m_mergeables;
-  }
-  Func** funcEnd() const {
-    return funcBegin() + m_firstHoistablePreClass;
-  }
-  void*& mergeableObj(int ix) { return ((void**)m_mergeables)[ix]; }
-  void* mergeableData(int ix) { return (char*)m_mergeables + ix*sizeof(void*); }
   template <bool debugger>
-  void mergeImpl(void* tcbase);
+  void mergeImpl(void* tcbase, UnitMergeInfo* mi);
 public:
   Func* getMain() const {
-    return *funcBegin();
+    return *m_mergeInfo->funcBegin();
   }
-  // Ranges for iterating over functions.
-  Func** funcHoistableBegin() const {
-    return funcBegin() + m_firstHoistableFunc;
+  Func* firstHoistable() const {
+    return *m_mergeInfo->funcHoistableBegin();
   }
   MutableFuncRange nonMainFuncs() const {
-    return MutableFuncRange(funcBegin() + 1, funcEnd());
+    return m_mergeInfo->nonMainFuncs();
   }
   MutableFuncRange hoistableFuncs() const {
-    return MutableFuncRange(funcHoistableBegin(), funcEnd());
+    return m_mergeInfo->hoistableFuncs();
   }
   Func* getLambda() const {
-    ASSERT(m_firstHoistableFunc == 1);
-    ASSERT(m_firstHoistablePreClass == 2);
-    return funcBegin()[1];
+    ASSERT(m_mergeInfo->m_firstHoistableFunc == 1);
+    ASSERT(m_mergeInfo->m_firstHoistablePreClass == 2);
+    return m_mergeInfo->funcBegin()[1];
   }
   void renameFunc(const StringData* oldName, const StringData* newName);
   void mergeFuncs() const;
   static void loadFunc(const Func *func);
   FuncRange funcs() const {
-    return FuncRange(funcBegin(), funcEnd());
+    return m_mergeInfo->funcs();
   }
   MutableFuncRange mutableFuncs() {
-    return MutableFuncRange(funcBegin(), funcEnd());
+    return m_mergeInfo->mutableFuncs();
   }
   Func* lookupFuncId(Id id) const {
-    ASSERT(id < Id(m_firstHoistablePreClass));
-    return funcBegin()[id];
+    ASSERT(id < Id(m_mergeInfo->m_firstHoistablePreClass));
+    return m_mergeInfo->funcBegin()[id];
   }
   size_t numPreClasses() const {
     return (size_t)m_preClasses.size();
@@ -551,6 +592,7 @@ public:
   }
   bool isMergeOnly() const { return m_mainReturn._count; }
   void clearMergeOnly() { m_mainReturn._count = 0; }
+  void* replaceUnit() const;
 public:
   static Mutex s_classesMutex;
 
@@ -581,11 +623,7 @@ private:
   std::vector<NamedEntityPair> m_namedInfo;
   std::vector<const ArrayData*> m_arrays;
   PreClassPtrVec m_preClasses;
-  void* m_mergeables;
-  unsigned m_firstHoistableFunc;
-  unsigned m_firstHoistablePreClass;
-  unsigned m_firstMergeablePreClass;
-  unsigned m_mergeablesSize;
+  UnitMergeInfo* m_mergeInfo;
   unsigned m_cacheOffset;
   int8 m_repoId;
   uint8 m_mergeState;
diff --git a/src/system/lib/systemlib.cpp b/src/system/lib/systemlib.cpp
index 0a72838259..2f7a7351b2 100644
--- a/src/system/lib/systemlib.cpp
+++ b/src/system/lib/systemlib.cpp
@@ -163,7 +163,7 @@ SystemLib::AllocSoapFaultObject(CVarRef code,
 
 VM::Func*
 SystemLib::GetNullFunction() {
-  VM::Func* f = *s_nativeFuncUnit->funcHoistableBegin();
+  VM::Func* f = s_nativeFuncUnit->firstHoistable();
   ASSERT(!strcmp(f->name()->data(), "86null"));
   return f;
 }

