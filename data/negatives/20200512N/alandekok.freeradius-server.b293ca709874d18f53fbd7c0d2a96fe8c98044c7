commit b293ca709874d18f53fbd7c0d2a96fe8c98044c7
Author: aland <aland>
Date:   Fri May 4 12:43:51 2007 +0000

            When adding a non-detail REQUEST to the queue, mark detail
            reading as not possible.
    
            When a thread finishes a request, AND the queues are empty,
            mark detail reading as possible.

diff --git a/src/main/threads.c b/src/main/threads.c
index bf7bd3540..335c77bcf 100644
--- a/src/main/threads.c
+++ b/src/main/threads.c
@@ -146,6 +146,7 @@ typedef struct THREAD_POOL {
 
 	int		max_queue_size;
 	int		num_queued;
+	int		can_read_detail;
 	lrad_fifo_t	*fifo[NUM_FIFOS];
 } THREAD_POOL;
 
@@ -278,9 +279,6 @@ static int request_enqueue(REQUEST *request, RAD_REQUEST_FUNP fun)
 
 	thread_pool.request_count++;
 
-	/*
-	 *	FIXME: Handle proxy replies separately?
-	 */
 	if (thread_pool.num_queued >= thread_pool.max_queue_size) {
 		pthread_mutex_unlock(&thread_pool.queue_mutex);
 		
@@ -307,6 +305,15 @@ static int request_enqueue(REQUEST *request, RAD_REQUEST_FUNP fun)
 		return 0;
 	}
 
+	/*
+	 *	We've added an entry that didn't come from the detail
+	 *	file.  Note that the child thread should signal the
+	 *	main worker thread again when the queue becomes empty.
+	 */
+	if (request->listener->type != RAD_LISTEN_DETAIL) {
+		thread_pool.can_read_detail = FALSE;
+	}
+
 	thread_pool.num_queued++;
 
 	pthread_mutex_unlock(&thread_pool.queue_mutex);
@@ -448,6 +455,8 @@ static void *request_handler_thread(void *arg)
 	 *	Loop forever, until told to exit.
 	 */
 	do {
+		int can_read_detail;
+
 		/*
 		 *	Wait to be signalled.
 		 */
@@ -494,7 +503,29 @@ static void *request_handler_thread(void *arg)
 		pthread_mutex_lock(&thread_pool.queue_mutex);
 		rad_assert(thread_pool.active_threads > 0);
 		thread_pool.active_threads--;
+
+		/*
+		 *	If we're not currently allowed to read the
+		 *	detail file, AND there are no requests queued,
+		 *	THEN signal the main worker thread that
+		 *	there's at least one waiting thread (us) who
+		 *	can accept a packet from the detail file.
+		 */
+		can_read_detail = FALSE;
+		if (!thread_pool.can_read_detail &&
+		    (thread_pool.num_queued == 0)) {
+			can_read_detail = TRUE;
+		}
+
 		pthread_mutex_unlock(&thread_pool.queue_mutex);
+
+		/*
+		 *	Do this out of the lock to be nice to everyone.
+		 */
+		if (can_read_detail) {
+			radius_signal_self(RADIUS_SIGNAL_SELF_DETAIL);
+		}
+
 	} while (self->status != THREAD_CANCELLED);
 
 	DEBUG2("Thread %d exiting...", self->thread_num);

