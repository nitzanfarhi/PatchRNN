commit b110547e586eb5825bc1d04aa9147bff83b57672
Author: Nishanth Menon <nm@ti.com>
Date:   Fri May 18 12:26:19 2012 -0500

    ARM: OMAP2+: OPP: Fix to ensure check of right oppdef after bad one
    
    Commit 9fa2df6b90786301b175e264f5fa9846aba81a65
    (ARM: OMAP2+: OPP: allow OPP enumeration to continue if device is not present)
    makes the logic:
    for (i = 0; i < opp_def_size; i++) {
            <snip>
            if (!oh || !oh->od) {
                    <snip>
                    continue;
            }
    <snip>
    opp_def++;
    }
    
    In short, the moment we hit a "Bad OPP", we end up looping the list
    comparing against the bad opp definition pointer for the rest of the
    iteration count. Instead, increment opp_def in the for loop itself
    and allow continue to be used in code without much thought so that
    we check the next set of OPP definition pointers :)
    
    Cc: Steve Sakoman <steve@sakoman.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Kevin Hilman <khilman@ti.com>

diff --git a/arch/arm/mach-omap2/opp.c b/arch/arm/mach-omap2/opp.c
index de6d46451746..d8f6dbf45d16 100644
--- a/arch/arm/mach-omap2/opp.c
+++ b/arch/arm/mach-omap2/opp.c
@@ -53,7 +53,7 @@ int __init omap_init_opp_table(struct omap_opp_def *opp_def,
 	omap_table_init = 1;
 
 	/* Lets now register with OPP library */
-	for (i = 0; i < opp_def_size; i++) {
+	for (i = 0; i < opp_def_size; i++, opp_def++) {
 		struct omap_hwmod *oh;
 		struct device *dev;
 
@@ -86,7 +86,6 @@ int __init omap_init_opp_table(struct omap_opp_def *opp_def,
 					__func__, opp_def->freq,
 					opp_def->hwmod_name, i, r);
 		}
-		opp_def++;
 	}
 
 	return 0;

