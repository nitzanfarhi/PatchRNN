commit c807cd2e26949e741871856fffc598a0638e4efa
Author: aivanov@mysql.com <>
Date:   Fri Oct 28 17:16:22 2005 +0400

    Fix BUG#10511: Wrong padding of UCS2 CHAR columns in
     ON UPDATE CASCADE

diff --git a/innobase/row/row0ins.c b/innobase/row/row0ins.c
index 5ca1ee51cbd..456bb51d424 100644
--- a/innobase/row/row0ins.c
+++ b/innobase/row/row0ins.c
@@ -522,20 +522,50 @@ row_ins_cascade_calc_update_vec(
 				    && ufield->new_val.len
 				       < dtype_get_fixed_size(type)) {
 
+                                        ulint cset;
+
 				        ufield->new_val.data =
 						mem_heap_alloc(heap,
 						  dtype_get_fixed_size(type));
 					ufield->new_val.len = 
 						dtype_get_fixed_size(type);
-					ut_a(dtype_get_pad_char(type)
-					     != ULINT_UNDEFINED);
-
-					memset(ufield->new_val.data,
-					       (byte)dtype_get_pad_char(type),
-					       dtype_get_fixed_size(type));
-					ut_memcpy(ufield->new_val.data,
-						parent_ufield->new_val.data,
-						parent_ufield->new_val.len);
+
+                                        /* Handle UCS2 strings differently.
+                                        As no new collations will be
+                                        introduced in 4.1, we hardcode the
+                                        charset-collation codes here.
+                                        In 5.0, the logic is based on
+                                        mbminlen. */
+                                        cset = dtype_get_charset_coll(
+                                          dtype_get_prtype(type));
+
+                                        if (cset == 35/*ucs2_general_ci*/
+                                            || cset == 90/*ucs2_bin*/
+                                            || (cset >= 128/*ucs2_unicode_ci*/
+                                          && cset <= 144
+                                          /*ucs2_persian_ci*/)) {
+                                          /* space=0x0020 */
+                                          ulint i;
+                                          for (i = 0;
+                                               i < ufield->new_val.len;
+                                               i += 2) {
+                                            mach_write_to_2(((byte*)
+                                              ufield->new_val.data)
+                                              + i, 0x0020);
+                                          }
+                                        } else {
+                                          ut_a(dtype_get_pad_char(type)
+                                              != ULINT_UNDEFINED);
+
+                                          memset(ufield->new_val.data,
+                                              (byte)dtype_get_pad_char(
+                                                type),
+                                              ufield->new_val.len);
+                                        }
+
+                                        memcpy(ufield->new_val.data,
+                                          parent_ufield->new_val.data,
+                                          parent_ufield->new_val.len);
 				}
 
 				ufield->extern_storage = FALSE;

