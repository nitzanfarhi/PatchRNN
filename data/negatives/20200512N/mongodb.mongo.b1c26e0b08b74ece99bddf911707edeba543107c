commit b1c26e0b08b74ece99bddf911707edeba543107c
Author: Samantha Ritter <samantha.ritter@10gen.com>
Date:   Mon Jul 6 14:11:25 2015 -0400

    SERVER-19220 NetworkInterfaceASIO sets up its own sockets

diff --git a/src/mongo/executor/network_interface_asio.cpp b/src/mongo/executor/network_interface_asio.cpp
index d1f7b4e5da..1999838b92 100644
--- a/src/mongo/executor/network_interface_asio.cpp
+++ b/src/mongo/executor/network_interface_asio.cpp
@@ -55,8 +55,20 @@ NetworkInterfaceASIO::AsyncConnection::AsyncConnection(asio::ip::tcp::socket&& s
                                                        rpc::ProtocolSet protocols)
     : _sock(std::move(sock)), _protocols(protocols) {}
 
-tcp::socket* NetworkInterfaceASIO::AsyncConnection::sock() {
-    return &_sock;
+#if defined(_MSC_VER) && _MSC_VER < 1900
+NetworkInterfaceASIO::AsyncConnection::AsyncConnection(AsyncConnection&& other)
+    : _sock(std::move(other._sock)), _protocols(other._protocols) {}
+
+NetworkInterfaceASIO::AsyncConnection& NetworkInterfaceASIO::AsyncConnection::operator=(
+    AsyncConnection&& other) {
+    _sock = std::move(other._sock);
+    _protocols = other._protocols;
+    return *this;
+}
+#endif
+
+tcp::socket& NetworkInterfaceASIO::AsyncConnection::sock() {
+    return _sock;
 }
 
 NetworkInterfaceASIO::AsyncOp::AsyncOp(const TaskExecutor::CallbackHandle& cbHandle,
@@ -102,6 +114,12 @@ NetworkInterfaceASIO::AsyncConnection* NetworkInterfaceASIO::AsyncOp::connection
     return _connection.get_ptr();
 }
 
+void NetworkInterfaceASIO::AsyncOp::setConnection(AsyncConnection&& conn) {
+    invariant(!_connection.is_initialized());
+    _connection = std::move(conn);
+    _state = OpState::kConnected;
+}
+
 std::string NetworkInterfaceASIO::AsyncOp::toString() const {
     str::stream output;
     output << "op number: " << _id;
@@ -176,7 +194,11 @@ Message* NetworkInterfaceASIO::AsyncOp::toSend() {
 }
 
 NetworkInterfaceASIO::NetworkInterfaceASIO()
-    : _io_service(), _state(State::kReady), _isExecutorRunnable(false), _numOps(0) {
+    : _io_service(),
+      _resolver(_io_service),
+      _state(State::kReady),
+      _isExecutorRunnable(false),
+      _numOps(0) {
     _connPool = stdx::make_unique<ConnectionPool>(kMessagingPortKeepOpen);
 }
 
@@ -217,7 +239,7 @@ void NetworkInterfaceASIO::_messageFromRequest(const RemoteCommandRequest& reque
 }
 
 void NetworkInterfaceASIO::_asyncSendSimpleMessage(AsyncOp* op, const asio::const_buffer& buf) {
-    asio::async_write(*(op->connection()->sock()),
+    asio::async_write(op->connection()->sock(),
                       asio::buffer(buf),
                       [this, op](std::error_code ec, std::size_t bytes) {
 
@@ -279,7 +301,7 @@ void NetworkInterfaceASIO::_recvMessageBody(AsyncOp* op) {
     invariant(bodyLength >= 0);
 
     // receive remaining data into md->data
-    asio::async_read(*(op->connection()->sock()),
+    asio::async_read(op->connection()->sock(),
                      asio::buffer(mdView.data(), bodyLength),
                      [this, op, mdView](asio::error_code ec, size_t bytes) {
 
@@ -297,7 +319,7 @@ void NetworkInterfaceASIO::_recvMessageBody(AsyncOp* op) {
 }
 
 void NetworkInterfaceASIO::_recvMessageHeader(AsyncOp* op) {
-    asio::async_read(*(op->connection()->sock()),
+    asio::async_read(op->connection()->sock(),
                      asio::buffer(reinterpret_cast<char*>(op->header()), sizeof(MSGHEADER::Value)),
                      [this, op](asio::error_code ec, size_t bytes) {
 
@@ -469,25 +491,63 @@ void NetworkInterfaceASIO::_sslHandshake(AsyncOp* op) {
     _authenticate(op);
 }
 
-void NetworkInterfaceASIO::_setupSocket(AsyncOp* op,
-                                        asio::ip::basic_resolver_iterator<tcp> endpoints) {
-    // TODO: Implement ASIO-based socket setup, SERVER-19220
+void NetworkInterfaceASIO::_setupSocket(AsyncOp* op, const tcp::resolver::iterator& endpoints) {
+    tcp::socket sock(_io_service);
+    AsyncConnection conn(std::move(sock), rpc::supports::kOpQueryOnly);
+
+    // TODO: Consider moving this call to post-auth so we only assign completed connections.
+    op->setConnection(std::move(conn));
+
+    asio::async_connect(op->connection()->sock(),
+                        std::move(endpoints),
+                        [this, op](std::error_code ec, tcp::resolver::iterator iter) {
+                            if (ec) {
+                                LOG(3) << "could not connect to host at " << iter->host_name()
+                                       << ":" << iter->endpoint().port() << ", " << ec.message();
+                                return _networkErrorCallback(op, ec);
+                            }
+
+                            if (op->canceled())
+                                return _completeOperation(op, kCanceledStatus);
+
+                            _sslHandshake(op);
+                        });
 }
 
 void NetworkInterfaceASIO::_connectASIO(AsyncOp* op) {
-    // TODO: Implement asynchronous DNS resolution, SERVER-19220
-}
+    tcp::resolver::query query(op->request().target.host(),
+                               std::to_string(op->request().target.port()));
+    // TODO: Investigate how we might hint or use shortcuts to resolve when possible.
+    _resolver.async_resolve(
+        query,
+        [this, op](std::error_code ec, asio::ip::basic_resolver_iterator<tcp> endpoints) {
+            if (ec) {
+                LOG(3) << "could not resolve address " << op->request().target.host() << ":"
+                       << std::to_string(op->request().target.port()) << ", " << ec.message();
+                return _networkErrorCallback(op, ec);
+            }
+
+            if (op->canceled())
+                return _completeOperation(op, kCanceledStatus);
 
-void NetworkInterfaceASIO::_asyncRunCommand(const TaskExecutor::CallbackHandle& cbHandle,
-                                            const RemoteCommandRequest& request,
-                                            const RemoteCommandCompletionFn& onFinish) {
-    LOG(3) << "running command " << request.cmdObj << " against database " << request.dbname
-           << " across network to " << request.target.toString();
+            _setupSocket(op, endpoints);
+        });
+}
 
+void NetworkInterfaceASIO::_asyncRunCommand(AsyncOp* op) {
+    LOG(3) << "running command " << op->request().cmdObj << " against database "
+           << op->request().dbname << " across network to " << op->request().target.toString();
     if (inShutdown()) {
         return;
     }
 
+    // _connect...() will continue the state machine.
+    _connectWithDBClientConnection(op);
+}
+
+void NetworkInterfaceASIO::startCommand(const TaskExecutor::CallbackHandle& cbHandle,
+                                        const RemoteCommandRequest& request,
+                                        const RemoteCommandCompletionFn& onFinish) {
     auto ownedOp =
         stdx::make_unique<AsyncOp>(cbHandle, request, onFinish, now(), _numOps.fetchAndAdd(1));
 
@@ -498,14 +558,7 @@ void NetworkInterfaceASIO::_asyncRunCommand(const TaskExecutor::CallbackHandle&
         _inProgress.emplace(op, std::move(ownedOp));
     }
 
-    // _connect...() will continue the state machine.
-    _connectWithDBClientConnection(op);
-}
-
-void NetworkInterfaceASIO::startCommand(const TaskExecutor::CallbackHandle& cbHandle,
-                                        const RemoteCommandRequest& request,
-                                        const RemoteCommandCompletionFn& onFinish) {
-    _asyncRunCommand(cbHandle, request, onFinish);
+    asio::post(_io_service, [this, op]() { _asyncRunCommand(op); });
 }
 
 void NetworkInterfaceASIO::cancelCommand(const TaskExecutor::CallbackHandle& cbHandle) {
diff --git a/src/mongo/executor/network_interface_asio.h b/src/mongo/executor/network_interface_asio.h
index 0ae3d4db12..6f91d7bde0 100644
--- a/src/mongo/executor/network_interface_asio.h
+++ b/src/mongo/executor/network_interface_asio.h
@@ -78,7 +78,16 @@ private:
     public:
         AsyncConnection(asio::ip::tcp::socket&& sock, rpc::ProtocolSet protocols);
 
-        asio::ip::tcp::socket* sock();
+        asio::ip::tcp::socket& sock();
+
+// Explicit move construction and assignment to support MSVC
+#if defined(_MSC_VER) && _MSC_VER < 1900
+        AsyncConnection(AsyncConnection&&);
+        AsyncConnection& operator=(AsyncConnection&&);
+#else
+        AsyncConnection(AsyncConnection&&) = default;
+        AsyncConnection& operator=(AsyncConnection&&) = default;
+#endif
 
     private:
         asio::ip::tcp::socket _sock;
@@ -106,6 +115,7 @@ private:
         AsyncConnection* connection();
 
         void connect(ConnectionPool* const pool, asio::io_service* service, Date_t now);
+        void setConnection(AsyncConnection&& conn);
         bool connected() const;
 
         void finish(const TaskExecutor::ResponseStatus& status);
@@ -151,9 +161,7 @@ private:
         const int _id;
     };
 
-    void _asyncRunCommand(const TaskExecutor::CallbackHandle& cbHandle,
-                          const RemoteCommandRequest& request,
-                          const RemoteCommandCompletionFn& onFinish);
+    void _asyncRunCommand(AsyncOp* op);
 
     void _messageFromRequest(const RemoteCommandRequest& request,
                              Message* toSend,
@@ -185,6 +193,8 @@ private:
     asio::io_service _io_service;
     stdx::thread _serviceRunner;
 
+    asio::ip::tcp::resolver _resolver;
+
     std::atomic<State> _state;
 
     stdx::mutex _inProgressMutex;

