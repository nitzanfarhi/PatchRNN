commit e7f3d22289e4307b3071cc18b1d8ecc6598c0be4
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Jan 10 14:51:42 2014 +0100

    mmc: mmci: Handle CMD irq before DATA irq
    
    In case of a read operation both MCI_CMDRESPEND and MCI_DATAEND can be
    set in the status register when entering the interrupt handler. This is
    due to that the card start sending data before the host has
    acknowledged the command response.
    
    To resolve the issue for this scenario, we must start by handling the
    CMD irq instead of the DATA irq. The reason is beacuse the completion
    of the DATA irq will not respect the current command and then causing
    it to be garbled.
    
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Johan Rudholm <jrudholm@gmail.com>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Chris Ball <chris@printf.net>

diff --git a/drivers/mmc/host/mmci.c b/drivers/mmc/host/mmci.c
index b93122636531..8324e3ec21c2 100644
--- a/drivers/mmc/host/mmci.c
+++ b/drivers/mmc/host/mmci.c
@@ -1144,16 +1144,17 @@ static irqreturn_t mmci_irq(int irq, void *dev_id)
 
 		dev_dbg(mmc_dev(host->mmc), "irq0 (data+cmd) %08x\n", status);
 
+		cmd = host->cmd;
+		if (status & (MCI_CMDCRCFAIL|MCI_CMDTIMEOUT|MCI_CMDSENT|
+			      MCI_CMDRESPEND) && cmd)
+			mmci_cmd_irq(host, cmd, status);
+
 		data = host->data;
 		if (status & (MCI_DATACRCFAIL|MCI_DATATIMEOUT|MCI_STARTBITERR|
 			      MCI_TXUNDERRUN|MCI_RXOVERRUN|MCI_DATAEND|
 			      MCI_DATABLOCKEND) && data)
 			mmci_data_irq(host, data, status);
 
-		cmd = host->cmd;
-		if (status & (MCI_CMDCRCFAIL|MCI_CMDTIMEOUT|MCI_CMDSENT|MCI_CMDRESPEND) && cmd)
-			mmci_cmd_irq(host, cmd, status);
-
 		ret = 1;
 	} while (status);
 

