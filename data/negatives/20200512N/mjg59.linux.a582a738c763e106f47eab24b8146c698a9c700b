commit a582a738c763e106f47eab24b8146c698a9c700b
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Wed Jun 15 15:08:49 2011 -0700

    compaction: checks correct fragmentation index
    
    fragmentation_index() returns -1000 when the allocation might succeed
    This doesn't match the comment and code in compaction_suitable(). I
    thought compaction_suitable should return COMPACT_PARTIAL in -1000
    case, because in this case allocation could succeed depending on
    watermarks.
    
    The impact of this is that compaction starts and compact_finished() is
    called which rechecks the watermarks and the free lists.  It should have
    the same result in that compaction should not start but is more expensive.
    
    Acked-by: Mel Gorman <mel@csn.ul.ie>
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Cc: Minchan Kim <minchan.kim@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/mm/compaction.c b/mm/compaction.c
index 94bdbe1f7caf..cf7086c6dc07 100644
--- a/mm/compaction.c
+++ b/mm/compaction.c
@@ -480,7 +480,8 @@ unsigned long compaction_suitable(struct zone *zone, int order)
 	 * fragmentation index determines if allocation failures are due to
 	 * low memory or external fragmentation
 	 *
-	 * index of -1 implies allocations might succeed dependingon watermarks
+	 * index of -1000 implies allocations might succeed depending on
+	 * watermarks
 	 * index towards 0 implies failure is due to lack of memory
 	 * index towards 1000 implies failure is due to fragmentation
 	 *
@@ -490,7 +491,8 @@ unsigned long compaction_suitable(struct zone *zone, int order)
 	if (fragindex >= 0 && fragindex <= sysctl_extfrag_threshold)
 		return COMPACT_SKIPPED;
 
-	if (fragindex == -1 && zone_watermark_ok(zone, order, watermark, 0, 0))
+	if (fragindex == -1000 && zone_watermark_ok(zone, order, watermark,
+	    0, 0))
 		return COMPACT_PARTIAL;
 
 	return COMPACT_CONTINUE;

