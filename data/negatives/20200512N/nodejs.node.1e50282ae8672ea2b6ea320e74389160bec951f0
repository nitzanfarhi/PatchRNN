commit 1e50282ae8672ea2b6ea320e74389160bec951f0
Author: Ben Noordhuis <info@bnoordhuis.nl>
Date:   Tue Jun 26 23:38:35 2012 +0200

    deps: upgrade libuv to 4d42af2

diff --git a/deps/uv/include/uv.h b/deps/uv/include/uv.h
index 69e0db2f8e..dbea113a3e 100644
--- a/deps/uv/include/uv.h
+++ b/deps/uv/include/uv.h
@@ -126,7 +126,8 @@ extern "C" {
   XX( 53, ENOTEMPTY, "directory not empty") \
   XX( 54, ENOSPC, "no space left on device") \
   XX( 55, EIO, "i/o error") \
-  XX( 56, EROFS, "read-only file system" )
+  XX( 56, EROFS, "read-only file system" ) \
+  XX( 57, ENODEV, "no such device" )
 
 
 #define UV_ERRNO_GEN(val, name, s) UV_##name = val,
diff --git a/deps/uv/src/unix/error.c b/deps/uv/src/unix/error.c
index c2651a3a9e..9fbb312eef 100644
--- a/deps/uv/src/unix/error.c
+++ b/deps/uv/src/unix/error.c
@@ -86,6 +86,7 @@ uv_err_code uv_translate_sys_error(int sys_errno) {
     case EADDRNOTAVAIL: return UV_EADDRNOTAVAIL;
     case ENOTDIR: return UV_ENOTDIR;
     case EISDIR: return UV_EISDIR;
+    case ENODEV: return UV_ENODEV;
     case ENOTCONN: return UV_ENOTCONN;
     case EEXIST: return UV_EEXIST;
     case EHOSTUNREACH: return UV_EHOSTUNREACH;
diff --git a/deps/uv/src/unix/stream.c b/deps/uv/src/unix/stream.c
index 89790eabfd..8c33ee09c5 100644
--- a/deps/uv/src/unix/stream.c
+++ b/deps/uv/src/unix/stream.c
@@ -802,62 +802,51 @@ int uv__connect(uv_connect_t* req, uv_stream_t* stream, struct sockaddr* addr,
   int sockfd;
   int r;
 
+  if (stream->type != UV_TCP)
+    return uv__set_sys_error(stream->loop, ENOTSOCK);
+
+  if (stream->connect_req)
+    return uv__set_sys_error(stream->loop, EALREADY);
+
   if (stream->fd <= 0) {
-    if ((sockfd = uv__socket(addr->sa_family, SOCK_STREAM, 0)) == -1) {
-      uv__set_sys_error(stream->loop, errno);
-      return -1;
-    }
+    sockfd = uv__socket(addr->sa_family, SOCK_STREAM, 0);
+
+    if (sockfd == -1)
+      return uv__set_sys_error(stream->loop, errno);
 
     if (uv__stream_open(stream,
                         sockfd,
                         UV_STREAM_READABLE | UV_STREAM_WRITABLE)) {
       close(sockfd);
-      return -2;
+      return -1;
     }
   }
 
-  uv__req_init(stream->loop, req, UV_CONNECT);
-  req->cb = cb;
-  req->handle = stream;
-  ngx_queue_init(&req->queue);
-
-  if (stream->connect_req) {
-    uv__set_sys_error(stream->loop, EALREADY);
-    return -1;
-  }
-
-  if (stream->type != UV_TCP) {
-    uv__set_sys_error(stream->loop, ENOTSOCK);
-    return -1;
-  }
-
-  stream->connect_req = req;
+  stream->delayed_error = 0;
 
-  do {
+  do
     r = connect(stream->fd, addr, addrlen);
-  }
   while (r == -1 && errno == EINTR);
 
-  stream->delayed_error = 0;
-
-  if (r != 0 && errno != EINPROGRESS) {
-    switch (errno) {
-      /* If we get a ECONNREFUSED wait until the next tick to report the
-       * error. Solaris wants to report immediately--other unixes want to
-       * wait.
-       *
-       * XXX: do the same for ECONNABORTED?
-       */
-      case ECONNREFUSED:
-        stream->delayed_error = errno;
-        break;
-
-      default:
-        uv__set_sys_error(stream->loop, errno);
-        return -1;
-    }
+  if (r == -1) {
+    if (errno == EINPROGRESS)
+      ; /* not an error */
+    else if (errno == ECONNREFUSED)
+    /* If we get a ECONNREFUSED wait until the next tick to report the
+     * error. Solaris wants to report immediately--other unixes want to
+     * wait.
+     */
+      stream->delayed_error = errno;
+    else
+      return uv__set_sys_error(stream->loop, errno);
   }
 
+  uv__req_init(stream->loop, req, UV_CONNECT);
+  req->cb = cb;
+  req->handle = stream;
+  ngx_queue_init(&req->queue);
+  stream->connect_req = req;
+
   uv__io_start(stream->loop, &stream->write_watcher);
 
   if (stream->delayed_error)
diff --git a/deps/uv/src/unix/sunos.c b/deps/uv/src/unix/sunos.c
index 261d69d47b..b95a89b456 100644
--- a/deps/uv/src/unix/sunos.c
+++ b/deps/uv/src/unix/sunos.c
@@ -332,14 +332,6 @@ uv_err_t uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
   lookup_instance = 0;
   while ((ksp = kstat_lookup(kc, (char *)"cpu_info", lookup_instance, NULL))) {
     if (kstat_read(kc, ksp, NULL) == -1) {
-      /*
-       * It is deeply annoying, but some kstats can return errors
-       * under otherwise routine conditions.  (ACPI is one
-       * offender; there are surely others.)  To prevent these
-       * fouled kstats from completely ruining our day, we assign
-       * an "error" member to the return value that consists of
-       * the strerror().
-       */
       cpu_info->speed = 0;
       cpu_info->model = NULL;
     } else {
diff --git a/deps/uv/src/win/error.c b/deps/uv/src/win/error.c
index e95f39a10e..d7c4d53334 100644
--- a/deps/uv/src/win/error.c
+++ b/deps/uv/src/win/error.c
@@ -86,6 +86,7 @@ uv_err_code uv_translate_sys_error(int sys_errno) {
     case ERROR_MOD_NOT_FOUND:               return UV_ENOENT;
     case ERROR_PATH_NOT_FOUND:              return UV_ENOENT;
     case ERROR_ACCESS_DENIED:               return UV_EPERM;
+    case ERROR_PRIVILEGE_NOT_HELD:          return UV_EPERM;
     case ERROR_NOACCESS:                    return UV_EACCES;
     case WSAEACCES:                         return UV_EACCES;
     case ERROR_ADDRESS_ALREADY_ASSOCIATED:  return UV_EADDRINUSE;
diff --git a/deps/uv/test/test-fs.c b/deps/uv/test/test-fs.c
index 36b68f3033..4b6d847f45 100644
--- a/deps/uv/test/test-fs.c
+++ b/deps/uv/test/test-fs.c
@@ -1224,10 +1224,10 @@ TEST_IMPL(fs_symlink) {
        * We just pass the test and bail out early if we get ENOTSUP.
        */
       return 0;
-    } else if (uv_last_error(loop).sys_errno_ == ERROR_PRIVILEGE_NOT_HELD) {
+    } else if (uv_last_error(loop).code == UV_EPERM) {
       /*
        * Creating a symlink is only allowed when running elevated.
-       * We pass the test and bail out early if we get ERROR_PRIVILEGE_NOT_HELD.
+       * We pass the test and bail out early if we get UV_EPERM.
        */
       return 0;
     }

