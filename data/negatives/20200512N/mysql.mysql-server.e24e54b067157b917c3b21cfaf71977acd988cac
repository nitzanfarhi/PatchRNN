commit e24e54b067157b917c3b21cfaf71977acd988cac
Author: Ritheesh Vedire <ritheesh.vedire@oracle.com>
Date:   Wed Nov 7 20:52:57 2012 +0530

    Bug#14832472: Make mysqldump work with GTIDs
    
    Problem
    ========
    When a backup is taken using mysqldump on a server
    with gtid enabled, the dump file does not contain
    any gtid information.  This eventually results in
    replicating the transactions since history when the
    backup is used to bring up a slave.
    
    Solution
    ==========
    Fixed by adding SET @@GLOBAL.SET_GTID_PURGED=<value
    of gtid_executed on the server> in the dump file.
    For this, --set-gtid-purged has three possible values.
    i) If --set-gtid-purged=OFF, output doesn't contain gtid info.
    ii)If --set-gtid-purged=ON, and server has GTID_MODE!=ON, an
       error is generated.
    iii)If --set-gtid-purged=AUTO, and server has GTID_MODE!=ON, this
       option does nothing. However, if GTIDs are enabled, the output
       contains GTID_PURGED info.

diff --git a/client/client_priv.h b/client/client_priv.h
index 441a9fedb96..24678211718 100644
--- a/client/client_priv.h
+++ b/client/client_priv.h
@@ -49,7 +49,7 @@ enum options_client
   OPT_PROMPT, OPT_IGN_LINES,OPT_TRANSACTION,OPT_MYSQL_PROTOCOL,
   OPT_SHARED_MEMORY_BASE_NAME, OPT_FRM, OPT_SKIP_OPTIMIZATION,
   OPT_COMPATIBLE, OPT_RECONNECT, OPT_DELIMITER, OPT_SECURE_AUTH,
-  OPT_OPEN_FILES_LIMIT, OPT_SET_CHARSET, OPT_SERVER_ARG,
+  OPT_OPEN_FILES_LIMIT, OPT_SET_CHARSET, OPT_SET_GTID_PURGED, OPT_SERVER_ARG,
   OPT_STOP_POSITION, OPT_START_DATETIME, OPT_STOP_DATETIME,
   OPT_SIGINT_IGNORE, OPT_HEXBLOB, OPT_ORDER_BY_PRIMARY, OPT_COUNT,
   OPT_TRIGGERS,
diff --git a/client/mysqldump.c b/client/mysqldump.c
index f3455812eec..2834863bbcb 100644
--- a/client/mysqldump.c
+++ b/client/mysqldump.c
@@ -149,6 +149,17 @@ static DYNAMIC_STRING extended_row;
 FILE *md_result_file= 0;
 FILE *stderror_file=0;
 
+const char *set_gtid_purged_mode_names[]=
+{"OFF", "AUTO", "ON", NullS};
+static TYPELIB set_gtid_purged_mode_typelib=
+               {array_elements(set_gtid_purged_mode_names) -1, "",
+                set_gtid_purged_mode_names, NULL};
+static enum enum_set_gtid_purged_mode {
+  SET_GTID_PURGED_OFF= 0,
+  SET_GTID_PURGED_AUTO =1,
+  SET_GTID_PURGED_ON=2
+} opt_set_gtid_purged_mode= SET_GTID_PURGED_AUTO;
+
 #ifdef HAVE_SMEM
 static char *shared_memory_base_name=0;
 #endif
@@ -464,6 +475,15 @@ static struct my_option my_long_options[] =
    "Add 'SET NAMES default_character_set' to the output.",
    &opt_set_charset, &opt_set_charset, 0, GET_BOOL, NO_ARG, 1,
    0, 0, 0, 0, 0},
+  {"set-gtid-purged", OPT_SET_GTID_PURGED,
+    "Add 'SET @@GLOBAL.GTID_PURGED' to the output. Possible values for "
+    "this option are ON, OFF and AUTO. If ON is used and GTIDs "
+    "are not enabled on the server, an error is generated. If OFF is "
+    "used, this option does nothing. If AUTO is used and GTIDs are enabled "
+    "on the server, 'SET @@GLOBAL.GTID_PURGED' is added to the output. "
+    "If GTIDs are disabled, AUTO does nothing. Default is AUTO.",
+    0, 0, 0, GET_STR, OPT_ARG,
+    0, 0, 0, 0, 0, 0},
 #ifdef HAVE_SMEM
   {"shared-memory-base-name", OPT_SHARED_MEMORY_BASE_NAME,
    "Base name of shared memory.", &shared_memory_base_name, &shared_memory_base_name,
@@ -903,6 +923,13 @@ get_one_option(int optid, const struct my_option *opt __attribute__((unused)),
     opt_protocol= find_type_or_exit(argument, &sql_protocol_typelib,
                                     opt->name);
     break;
+  case (int) OPT_SET_GTID_PURGED:
+    {
+      opt_set_gtid_purged_mode= find_type_or_exit(argument,
+                                                  &set_gtid_purged_mode_typelib,
+                                                  opt->name)-1;
+      break;
+    }
   }
   return 0;
 }
@@ -5260,6 +5287,153 @@ static int replace(DYNAMIC_STRING *ds_str,
 }
 
 
+/**
+  This function sets the session binlog in the dump file.
+  When --set-gtid-purged is used, this function is called to
+  disable the session binlog and at the end of the dump, to restore
+  the session binlog.
+
+  @note: md_result_file should have been opened, before
+         this function is called.
+
+  @param[in]      flag          If FALSE, disable binlog.
+                                If TRUE and binlog disabled previously,
+                                restore the session binlog.
+*/
+
+static void set_session_binlog(my_bool flag)
+{
+  static my_bool is_binlog_disabled= FALSE;
+
+  if (!flag && !is_binlog_disabled)
+  {
+    fprintf(md_result_file,
+            "SET @MYSQLDUMP_TEMP_LOG_BIN = @@SESSION.SQL_LOG_BIN;\n");
+    fprintf(md_result_file, "SET @@SESSION.SQL_LOG_BIN= 0;\n");
+    is_binlog_disabled= 1;
+  }
+  else if (flag && is_binlog_disabled)
+  {
+    fprintf(md_result_file,
+            "SET @@SESSION.SQL_LOG_BIN = @MYSQLDUMP_TEMP_LOG_BIN;\n");
+    is_binlog_disabled= 0;
+  }
+}
+
+
+/**
+  This function gets the GTID_EXECUTED sets from the
+  server and assigns those sets to GTID_PURGED in the
+  dump file.
+
+  @param[in]  mysql_con     connection to the server
+
+  @retval     FALSE         succesfully printed GTID_PURGED sets
+                             in the dump file.
+  @retval     TRUE          failed.
+
+*/
+
+static my_bool add_set_gtid_purged(MYSQL *mysql_con)
+{
+  MYSQL_RES  *gtid_purged_res;
+  MYSQL_ROW  gtid_set;
+  ulong     num_sets, idx;
+
+  /* query to get the GTID_EXECUTED */
+  if (mysql_query_with_error_report(mysql_con, &gtid_purged_res,
+                  "SELECT @@GLOBAL.GTID_EXECUTED"))
+    return TRUE;
+
+  /* Proceed only if gtid_purged_res is non empty */
+  if ((num_sets= mysql_num_rows(gtid_purged_res)) > 0)
+  {
+    if (opt_comments)
+      fprintf(md_result_file,
+          "\n--\n--GTID state at the beginning of the backup \n--\n\n");
+
+    fprintf(md_result_file,"SET @@GLOBAL.GTID_PURGED='");
+
+    /* formatting is not required, even for multiple gtid sets */
+    for (idx= 0; idx< num_sets-1; idx++)
+    {
+      gtid_set= mysql_fetch_row(gtid_purged_res);
+      fprintf(md_result_file,"%s,", (char*)gtid_set[0]);
+    }
+    /* for the last set */
+    gtid_set= mysql_fetch_row(gtid_purged_res);
+    /* close the SET expression */
+    fprintf(md_result_file,"%s';\n", (char*)gtid_set[0]);
+  }
+
+  return FALSE;  /*success */
+}
+
+
+/**
+  This function processes the opt_set_gtid_purged option.
+  This function also calls set_session_binlog() function before
+  setting the SET @@GLOBAL.GTID_PURGED in the output.
+
+  @param[in]          mysql_con     the connection to the server
+
+  @retval             FALSE         successful according to the value
+                                    of opt_set_gtid_purged.
+  @retval             TRUE          fail.
+*/
+
+static my_bool process_set_gtid_purged(MYSQL* mysql_con)
+{
+  MYSQL_RES  *gtid_mode_res;
+  MYSQL_ROW  gtid_mode_row;
+  char       *gtid_mode_val= 0;
+
+  if (opt_set_gtid_purged_mode == SET_GTID_PURGED_OFF)
+    return FALSE;  /* nothing to be done */
+
+
+  /* check if gtid_mode is ON or OFF */
+  if (mysql_query_with_error_report(mysql_con, &gtid_mode_res,
+                                    "SELECT @@GTID_MODE"))
+    return TRUE;
+
+  gtid_mode_row = mysql_fetch_row(gtid_mode_res);
+  gtid_mode_val = (char*)gtid_mode_row[0];
+
+  if (gtid_mode_val && strcmp(gtid_mode_val, "OFF"))
+  {
+    /*
+       For any gtid_mode !=OFF and irrespective of --set-gtid-purged
+       being AUTO or ON,  add GTID_PURGED in the output.
+    */
+    if (opt_databases || !opt_alldbs || !opt_dump_triggers
+        || !opt_routines || !opt_events)
+    {
+      fprintf(stderr,"Warning: A partial dump from a server that has GTIDs will "
+                     "by default include the GTIDs of all transactions, even "
+                     "those that changed suppressed parts of the database. If "
+                     "you don't want to restore GTIDs, pass "
+                     "--set-gtid-purged=OFF. To make a complete dump, pass "
+                     "--all-databases --triggers --routines --events. \n");
+    }
+
+    set_session_binlog(FALSE);
+    if (add_set_gtid_purged(mysql_con))
+      return TRUE;
+  }
+  else /* gtid_mode is off */
+  {
+    if (opt_set_gtid_purged_mode == SET_GTID_PURGED_ON)
+    {
+      fprintf(stderr, "Error: Server has GTIDs disabled.\n");
+      return TRUE;
+    }
+  }
+
+  return FALSE;
+}
+
+
 /*
   Getting VIEW structure
 
@@ -5589,6 +5763,13 @@ int main(int argc, char **argv)
   /* Add 'STOP SLAVE to beginning of dump */
   if (opt_slave_apply && add_stop_slave())
     goto err;
+
+
+  /* Process opt_set_gtid_purged and add SET @@GLOBAL.GTID_PURGED if required. */
+  if (process_set_gtid_purged(mysql))
+    goto err;
+
+
   if (opt_master_data && do_show_master_status(mysql))
     goto err;
   if (opt_slave_data && do_show_slave_status(mysql))
@@ -5624,6 +5805,12 @@ int main(int argc, char **argv)
   if (opt_slave_data && do_start_slave_sql(mysql))
     goto err;
 
+  /*
+    if --set-gtid-purged, restore binlog at the end of the session
+    if required.
+  */
+  set_session_binlog(TRUE);
+
   /* add 'START SLAVE' to end of dump */
   if (opt_slave_apply && add_slave_statements())
     goto err;

