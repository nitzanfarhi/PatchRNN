commit 7d8ec1155b155976b092f439682b05162cba392e
Author: Gonzalo Paniagua Javier <gonzalo.mono@gmail.com>
Date:   Wed Mar 16 01:47:43 2011 -0400

    [io-layer] Handle process waits when SHM is disabled.
    
            When SHM is disabled, handle SIGCHLD and either fill the info for the
            process handle or just wait for the process to avoid zombies.
            Fixes bug #668867.

diff --git a/mono/io-layer/handles.c b/mono/io-layer/handles.c
index 97be0c71b9c..ee9fc4581a6 100644
--- a/mono/io-layer/handles.c
+++ b/mono/io-layer/handles.c
@@ -276,6 +276,8 @@ static void shared_init (void)
 		/* This allocates a 4mb array, so do it only if SHM is enabled */
 		_wapi_fileshare_layout = _wapi_shm_attach (WAPI_SHM_FILESHARE);
 		g_assert (_wapi_fileshare_layout != NULL);
+	} else {
+		_wapi_process_noshm_wait_setup ();
 	}
 	
 #if !defined (DISABLE_SHARED_HANDLES)
diff --git a/mono/io-layer/process-private.h b/mono/io-layer/process-private.h
index bb1c69ae31d..4691dee5a7b 100644
--- a/mono/io-layer/process-private.h
+++ b/mono/io-layer/process-private.h
@@ -42,5 +42,6 @@ struct _WapiHandle_process
 
 extern void _wapi_process_reap (void);
 extern void _wapi_process_signal_self (void);
+extern void _wapi_process_noshm_wait_setup (void);
 
 #endif /* _WAPI_PROCESS_PRIVATE_H_ */
diff --git a/mono/io-layer/processes.c b/mono/io-layer/processes.c
index d0501a7dbe0..20a9a62f126 100644
--- a/mono/io-layer/processes.c
+++ b/mono/io-layer/processes.c
@@ -365,7 +365,40 @@ void _wapi_process_signal_self ()
 		process_set_termination_details (current_process, 0);
 	}
 }
+
+#ifndef HAVE_SIGACTION
+void
+_wapi_process_noshm_wait_setup (void)
+{
+}
+#else
+static void
+sigchld_signal (int dummy, siginfo_t *info, void *context)
+{
+	struct _WapiHandle_process *process_handle;
+	gpointer p;
+	int status;
+
+	p = (gpointer) info->si_pid;
+	/* If the handle exists, wait for it using process_wait, which will fill in the data.
+	 * If the handle does not exist, call waitpid() to avoid leaving a zombie */
+	if (_wapi_lookup_handle (p, WAPI_HANDLE_PROCESS, (gpointer *)&process_handle) != FALSE)
+		process_wait (p, 0);
+	else
+		waitpid (info->si_pid, &status, WNOHANG);
+}
+
+void
+_wapi_process_noshm_wait_setup (void)
+{
+	struct sigaction sa;
 	
+	sa.sa_sigaction = sigchld_signal;
+	sa.sa_flags = SA_NOCLDSTOP | SA_SIGINFO;
+	sigaction (SIGCHLD, &sa, NULL);
+}
+#endif /* HAVE_SIGACTION */
+
 static void process_set_defaults (struct _WapiHandle_process *process_handle)
 {
 	/* These seem to be the defaults on w2k */

