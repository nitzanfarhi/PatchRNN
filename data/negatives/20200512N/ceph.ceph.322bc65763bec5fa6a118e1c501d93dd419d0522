commit 322bc65763bec5fa6a118e1c501d93dd419d0522
Author: xie xingguo <xie.xingguo@zte.com.cn>
Date:   Tue Mar 29 14:50:59 2016 +0800

    osd: fix failure report handling during ms_handle_connect()
    
    On connecting to a new monitor, we will resend everything
    including the osd failure reports previously sent.
    To realize this, we call requeue_failures() to transfer inflight
    failure reports from failure_pending to failure_queue first, and
    then call send_failures() to do the real delivery job.
    
    The problem here is that the send_failures() never sends a
    failure report again if it successfully detects that the doomed osd
    is already in the failure_pending set, which is necessary as we don't
    want to report monitor of the same osd failure twice in normal case.
    
    This pr solves the above problem by erasing the record from failure_pending
    set simultaneously during the requeue_failures() process. So the
    succeeding call to send_failures() can resend the failure reports correctly.
    
    Signed-off-by: xie xingguo <xie.xingguo@zte.com.cn>

diff --git a/src/osd/OSD.cc b/src/osd/OSD.cc
index ccd89831a6..324bf7fbf6 100644
--- a/src/osd/OSD.cc
+++ b/src/osd/OSD.cc
@@ -4964,9 +4964,9 @@ void OSD::requeue_failures()
   unsigned old_pending = failure_pending.size();
   for (map<int,pair<utime_t,entity_inst_t> >::iterator p =
 	 failure_pending.begin();
-       p != failure_pending.end();
-       ++p) {
+       p != failure_pending.end(); ) {
     failure_queue[p->first] = p->second.first;
+    failure_pending.erase(p++);
   }
   dout(10) << __func__ << " " << old_queue << " + " << old_pending << " -> "
 	   << failure_queue.size() << dendl;

