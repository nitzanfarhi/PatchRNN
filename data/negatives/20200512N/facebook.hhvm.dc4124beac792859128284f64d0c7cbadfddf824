commit dc4124beac792859128284f64d0c7cbadfddf824
Author: Mark Williams <mwilliams@fb.com>
Date:   Thu Oct 15 09:15:56 2015 -0700

    Bypass warnings/notices earlier
    
    Summary: We originally wrote this code to bypass warnings and notices as early
    as possible; snprintf is actually quite expensive, and for code that
    raises a lot of notices, but has them disabled (or has a large
    NoticeFrequency) it can have a significant perf impact.
    
    This was all refactored a year ago so that all the checks are
    centralized in raise_message. In addition to losing the early exit, it
    also broke raise_warning_unsampled, because it called into
    raise_message which promptly sampled it.
    
    Reviewed By: @alexmalyshev
    
    Differential Revision: D2526899
    
    fb-gh-sync-id: af05e225a24e9de792edeaada314243aacbea4ab

diff --git a/hphp/runtime/base/runtime-error.cpp b/hphp/runtime/base/runtime-error.cpp
index 0bfbe27244..ee75e4b469 100644
--- a/hphp/runtime/base/runtime-error.cpp
+++ b/hphp/runtime/base/runtime-error.cpp
@@ -40,7 +40,10 @@ namespace HPHP {
  */
 
 void raise_error(const std::string &msg) {
-  raise_message(ErrorMode::ERROR, false, msg);
+  g_context->handleError(msg, static_cast<int>(ErrorMode::ERROR), false,
+                         ExecutionContext::ErrorThrowMode::Always,
+                         "\nFatal error: ",
+                         false);
   always_assert(0);
 }
 
@@ -53,14 +56,8 @@ void raise_error(const char *fmt, ...) {
   raise_error(msg);
 }
 
-/*
- * This does not call raise_message because the mode of the error differs
- * depending on the runtime option unlike the regular raise_error.
- */
 void raise_error_without_first_frame(const std::string &msg) {
   g_context->handleError(msg, static_cast<int>(ErrorMode::ERROR), false,
-                         RuntimeOption::CallUserHandlerOnFatals ?
-                         ExecutionContext::ErrorThrowMode::IfUnhandled :
                          ExecutionContext::ErrorThrowMode::Always,
                          "\nFatal error: ",
                          true);
@@ -68,11 +65,19 @@ void raise_error_without_first_frame(const std::string &msg) {
 }
 
 void raise_recoverable_error(const std::string &msg) {
-  raise_message(ErrorMode::RECOVERABLE_ERROR, false, msg);
+  g_context->handleError(
+    msg, static_cast<int>(ErrorMode::RECOVERABLE_ERROR), true,
+    ExecutionContext::ErrorThrowMode::IfUnhandled,
+    "\nCatchable Fatal error: ",
+    false);
 }
 
 void raise_recoverable_error_without_first_frame(const std::string &msg) {
-  raise_message(ErrorMode::RECOVERABLE_ERROR, true, msg);
+  g_context->handleError(
+    msg, static_cast<int>(ErrorMode::RECOVERABLE_ERROR), true,
+    ExecutionContext::ErrorThrowMode::IfUnhandled,
+    "\nCatchable Fatal error: ",
+    true);
 }
 
 void raise_typehint_error(const std::string& msg) {
@@ -113,42 +118,111 @@ void raise_recoverable_error(const char *fmt, ...) {
 
 static int64_t g_notice_counter = 0;
 
+static bool notice_freq_check(ErrorMode mode) {
+  if (RuntimeOption::NoticeFrequency <= 0 ||
+      g_notice_counter++ % RuntimeOption::NoticeFrequency != 0) {
+    return false;
+  }
+  return g_context->errorNeedsHandling(
+    static_cast<int>(mode), true, ExecutionContext::ErrorThrowMode::Never);
+}
+
+#define HANDLE_ERROR(userHandle, throwMode, str, skip)                  \
+  g_context->handleError(msg, static_cast<int>(mode), userHandle,       \
+                         ExecutionContext::ErrorThrowMode::throwMode,   \
+                         str,                                           \
+                         skip);
+
+static void raise_notice_helper(ErrorMode mode, bool skipTop,
+                                const std::string& msg) {
+  switch (mode) {
+    case ErrorMode::STRICT:
+      HANDLE_ERROR(true, Never, "\nStrict Warning: ", skipTop);
+      break;
+    case ErrorMode::NOTICE:
+      HANDLE_ERROR(true, Never, "\nNotice: ", skipTop);
+      break;
+    case ErrorMode::PHP_DEPRECATED:
+      HANDLE_ERROR(true, Never, "\nDeprecated: ", skipTop);
+      break;
+    default:
+      always_assert(!"Unhandled type of error");
+  }
+}
+
 void raise_strict_warning(const std::string &msg) {
-  raise_message(ErrorMode::STRICT, false, msg);
+  if (notice_freq_check(ErrorMode::STRICT)) {
+    raise_notice_helper(ErrorMode::STRICT, false, msg);
+  }
 }
 
 void raise_strict_warning_without_first_frame(const std::string &msg) {
-  raise_message(ErrorMode::STRICT, true, msg);
+  if (notice_freq_check(ErrorMode::STRICT)) {
+    raise_notice_helper(ErrorMode::STRICT, true, msg);
+  }
 }
 
 void raise_strict_warning(const char *fmt, ...) {
+  if (!notice_freq_check(ErrorMode::STRICT)) return;
+
   std::string msg;
   va_list ap;
   va_start(ap, fmt);
   string_vsnprintf(msg, fmt, ap);
   va_end(ap);
-  raise_strict_warning(msg);
+  raise_notice_helper(ErrorMode::STRICT, false, msg);
 }
 
 static int64_t g_warning_counter = 0;
 
+bool warning_freq_check() {
+  if (RuntimeOption::WarningFrequency <= 0 ||
+      g_warning_counter++ % RuntimeOption::WarningFrequency != 0) {
+    return false;
+  }
+  return g_context->errorNeedsHandling(
+    static_cast<int>(ErrorMode::WARNING), true,
+    ExecutionContext::ErrorThrowMode::Never);
+}
+
+void raise_warning_helper(bool skipTop, const std::string& msg) {
+  auto mode = ErrorMode::WARNING;
+  HANDLE_ERROR(true, Never, "\nWarning: ", skipTop);
+}
+
 void raise_warning(const std::string &msg) {
-  raise_message(ErrorMode::WARNING, false, msg);
+  if (warning_freq_check()) {
+    raise_warning_helper(false, msg);
+  }
 }
 
 void raise_warning_without_first_frame(const std::string &msg) {
-  raise_message(ErrorMode::WARNING, true, msg);
+  if (warning_freq_check()) {
+    raise_warning_helper(true, msg);
+  }
 }
 
 void raise_warning(const char *fmt, ...) {
+  if (!warning_freq_check()) return;
   std::string msg;
   va_list ap;
   va_start(ap, fmt);
   string_vsnprintf(msg, fmt, ap);
   va_end(ap);
-  raise_warning(msg);
+  raise_warning_helper(false, msg);
+}
+
+static void raise_hack_strict_helper(
+  HackStrictOption option, const char *ini_setting, const std::string& msg) {
+  if (option == HackStrictOption::WARN) {
+    raise_warning_helper(
+      false, std::string("(hhvm.hack.") + ini_setting + "=warn) " + msg);
+  } else if (option == HackStrictOption::ON) {
+    raise_error(std::string("(hhvm.hack.") + ini_setting + "=error) " + msg);
+  }
 }
 
+
 /**
  * For use with the HackStrictOption settings. This will warn, error, or do
  * nothing depending on what the user chose for the option. The second param
@@ -156,21 +230,25 @@ void raise_warning(const char *fmt, ...) {
  */
 void raise_hack_strict(HackStrictOption option, const char *ini_setting,
                        const std::string& msg) {
-  if (option == HackStrictOption::WARN) {
-    raise_warning(std::string("(hhvm.hack.") + ini_setting + "=warn) " + msg);
-  } else if (option == HackStrictOption::ON) {
-    raise_error(std::string("(hhvm.hack.") + ini_setting + "=error) " + msg);
+  if (option == HackStrictOption::WARN ?
+      !warning_freq_check() : (option != HackStrictOption::ON)) {
+    return;
   }
+  raise_hack_strict_helper(option, ini_setting, msg);
 }
 
 void raise_hack_strict(HackStrictOption option, const char *ini_setting,
                        const char *fmt, ...) {
+  if (option == HackStrictOption::WARN ?
+      !warning_freq_check() : (option != HackStrictOption::ON)) {
+    return;
+  }
   std::string msg;
   va_list ap;
   va_start(ap, fmt);
   string_vsnprintf(msg, fmt, ap);
   va_end(ap);
-  raise_hack_strict(option, ini_setting, msg);
+  raise_hack_strict_helper(option, ini_setting, msg);
 }
 
 /**
@@ -187,7 +265,11 @@ void raise_warning_unsampled(const std::string &msg) {
       RuntimeOption::RaiseDebuggingFrequency != 0) {
     return;
   }
-  raise_message(ErrorMode::WARNING, false, msg);
+  if (g_context->errorNeedsHandling(
+        static_cast<int>(ErrorMode::WARNING), true,
+        ExecutionContext::ErrorThrowMode::Never)) {
+    raise_warning_helper(false, msg);
+  }
 }
 
 void raise_warning_unsampled(const char *fmt, ...) {
@@ -200,37 +282,47 @@ void raise_warning_unsampled(const char *fmt, ...) {
 }
 
 void raise_notice(const std::string &msg) {
-  raise_message(ErrorMode::NOTICE, false, msg);
+  if (notice_freq_check(ErrorMode::NOTICE)) {
+    raise_notice_helper(ErrorMode::NOTICE, false, msg);
+  }
 }
 
 void raise_notice_without_first_frame(const std::string &msg) {
-  raise_message(ErrorMode::NOTICE, true, msg);
+  if (notice_freq_check(ErrorMode::NOTICE)) {
+    raise_notice_helper(ErrorMode::NOTICE, true, msg);
+  }
 }
 
 void raise_notice(const char *fmt, ...) {
+  if (!notice_freq_check(ErrorMode::NOTICE)) return;
   std::string msg;
   va_list ap;
   va_start(ap, fmt);
   string_vsnprintf(msg, fmt, ap);
   va_end(ap);
-  raise_notice(msg);
+  raise_notice_helper(ErrorMode::NOTICE, false, msg);
 }
 
 void raise_deprecated(const std::string &msg) {
-  raise_message(ErrorMode::PHP_DEPRECATED, false, msg);
+  if (notice_freq_check(ErrorMode::PHP_DEPRECATED)) {
+    raise_notice_helper(ErrorMode::PHP_DEPRECATED, false, msg);
+  }
 }
 
 void raise_deprecated_without_first_frame(const std::string &msg) {
-  raise_message(ErrorMode::PHP_DEPRECATED, true, msg);
+  if (notice_freq_check(ErrorMode::PHP_DEPRECATED)) {
+    raise_notice_helper(ErrorMode::PHP_DEPRECATED, true, msg);
+  }
 }
 
 void raise_deprecated(const char *fmt, ...) {
+  if (!notice_freq_check(ErrorMode::PHP_DEPRECATED)) return;
   std::string msg;
   va_list ap;
   va_start(ap, fmt);
   string_vsnprintf(msg, fmt, ap);
   va_end(ap);
-  raise_message(ErrorMode::PHP_DEPRECATED, false, msg);
+  raise_notice_helper(ErrorMode::PHP_DEPRECATED, false, msg);
 }
 
 void raise_param_type_warning(
@@ -238,6 +330,11 @@ void raise_param_type_warning(
     int param_num,
     DataType expected_type,
     DataType actual_type) {
+
+  // its ok to do this before munging, because it only looks at the
+  // end of the string
+  auto is_constructor = is_constructor_name(func_name);
+  if (!is_constructor && !warning_freq_check()) return;
   // slice off fg1_
   if (strncmp(func_name, "fg1_", 4) == 0) {
     func_name += 4;
@@ -268,11 +365,11 @@ void raise_param_type_warning(
     getDataTypeString(expected_type).data(),
     getDataTypeString(actual_type).data());
 
-  if (is_constructor_name(func_name)) {
+  if (is_constructor) {
     SystemLib::throwExceptionObject(msg);
   }
 
-  raise_warning(msg);
+  raise_warning_helper(false, msg);
 }
 
 void raise_message(ErrorMode mode,
@@ -294,47 +391,40 @@ void raise_message(ErrorMode mode,
   raise_message(mode, false, msg);
 }
 
-#define HANDLE_ERROR(userHandle, mode, str, skip)                       \
-  g_context->handleError(msg, errnum, userHandle,                       \
-                         ExecutionContext::ErrorThrowMode::mode,        \
-                         str,                                           \
-                         skip);
-
 void raise_message(ErrorMode mode,
                    bool skipTop,
                    const std::string &msg) {
-  int errnum = static_cast<int>(mode);
   if (mode == ErrorMode::ERROR) {
     HANDLE_ERROR(false, Always, "\nFatal error: ", skipTop);
-  } else if (mode == ErrorMode::RECOVERABLE_ERROR) {
+    not_reached();
+  }
+
+  if (mode == ErrorMode::RECOVERABLE_ERROR) {
     HANDLE_ERROR(true, IfUnhandled, "\nCatchable fatal error: ", skipTop);
-  } else if (!g_context->errorNeedsHandling(errnum, true,
-                              ExecutionContext::ErrorThrowMode::Never)) {
     return;
-  } else if (mode == ErrorMode::WARNING) {
+  }
+
+  if (!g_context->errorNeedsHandling(static_cast<int>(mode), true,
+                                     ExecutionContext::ErrorThrowMode::Never)) {
+    return;
+  }
+
+  if (mode == ErrorMode::WARNING) {
     if (RuntimeOption::WarningFrequency <= 0 ||
         (g_warning_counter++) % RuntimeOption::WarningFrequency != 0) {
       return;
     }
     HANDLE_ERROR(true, Never, "\nWarning: ", skipTop);
-  } else if (RuntimeOption::NoticeFrequency <= 0 ||
-             (g_notice_counter++) % RuntimeOption::NoticeFrequency != 0) {
     return;
-  } else {
-    switch (mode) {
-      case ErrorMode::STRICT:
-        HANDLE_ERROR(true, Never, "\nStrict Warning: ", skipTop);
-        break;
-      case ErrorMode::NOTICE:
-        HANDLE_ERROR(true, Never, "\nNotice: ", skipTop);
-        break;
-      case ErrorMode::PHP_DEPRECATED:
-        HANDLE_ERROR(true, Never, "\nDeprecated: ", skipTop);
-        break;
-      default:
-        always_assert(!"Unhandled type of error");
-    }
   }
+
+  if (RuntimeOption::NoticeFrequency <= 0 ||
+      (g_notice_counter++) % RuntimeOption::NoticeFrequency != 0) {
+    return;
+  }
+
+  raise_notice_helper(mode, skipTop, msg);
 }
+
 ///////////////////////////////////////////////////////////////////////////////
 }

