commit 52ee28d249571616c80df7562bd4412ac253899a
Author: Liu Bo <bo.li.liu@oracle.com>
Date:   Thu Jul 11 17:51:15 2013 +0800

    Btrfs: make free space caching faster with many non-inline extent references
    
    So to cache free space, we iterate every extent item to gather free space info.
    
    When we have say 10,000 non-inline extent refs(such as BTRFS_EXTENT_DATA_REF),
    it takes quite a long time, and since inline extent refs and non-inline ones have
    same objectid in their keys, we can just re-search the tree with the next address
    to skip non-inline references.
    
    (This is found by dedup feature because dedup extents can end up with many
    non-inline extent refs.)
    
    Signed-off-by: Liu Bo <bo.li.liu@oracle.com>
    Signed-off-by: Josef Bacik <jbacik@fusionio.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index 7bea4d2f85dc..99aa9b77e948 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -420,6 +420,7 @@ static noinline void caching_thread(struct btrfs_work *work)
 	/* need to make sure the commit_root doesn't disappear */
 	down_read(&fs_info->extent_commit_sem);
 
+next:
 	ret = btrfs_search_slot(NULL, extent_root, &key, path, 0, 0);
 	if (ret < 0)
 		goto err;
@@ -459,6 +460,16 @@ static noinline void caching_thread(struct btrfs_work *work)
 			continue;
 		}
 
+		if (key.objectid < last) {
+			key.objectid = last;
+			key.offset = 0;
+			key.type = BTRFS_EXTENT_ITEM_KEY;
+
+			caching_ctl->progress = last;
+			btrfs_release_path(path);
+			goto next;
+		}
+
 		if (key.objectid < block_group->key.objectid) {
 			path->slots[0]++;
 			continue;

