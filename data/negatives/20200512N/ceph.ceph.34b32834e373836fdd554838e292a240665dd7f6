commit 34b32834e373836fdd554838e292a240665dd7f6
Author: Jason Dillaman <dillaman@redhat.com>
Date:   Wed Dec 2 14:28:18 2015 -0500

    common: lockdep now tracks lock ordering when backtraces disabled
    
    Signed-off-by: Jason Dillaman <dillaman@redhat.com>

diff --git a/src/common/lockdep.cc b/src/common/lockdep.cc
index 79fd56c61b..c39dbf0e33 100644
--- a/src/common/lockdep.cc
+++ b/src/common/lockdep.cc
@@ -53,7 +53,8 @@ static map<int, std::string> lock_names;
 static map<int, int> lock_refs;
 static list<int> free_ids;
 static ceph::unordered_map<pthread_t, map<int,BackTrace*> > held;
-static BackTrace *follows[MAX_LOCKS][MAX_LOCKS];       // follows[a][b] means b taken after a
+static bool follows[MAX_LOCKS][MAX_LOCKS]; // follows[a][b] means b taken after a
+static BackTrace *follows_bt[MAX_LOCKS][MAX_LOCKS];
 
 static bool lockdep_force_backtrace()
 {
@@ -88,9 +89,12 @@ void lockdep_unregister_ceph_context(CephContext *cct)
 
     // blow away all of our state, too, in case it starts up again.
     held.clear();
-    for (unsigned i = 0; i < MAX_LOCKS; ++i)
-      for (unsigned j = 0; j < MAX_LOCKS; ++j)
-	follows[i][j] = NULL;
+    for (unsigned i = 0; i < MAX_LOCKS; ++i) {
+      for (unsigned j = 0; j < MAX_LOCKS; ++j) {
+        follows[i][j] = false;
+        follows_bt[i][j] = NULL;
+      }
+    }
     lock_names.clear();
     lock_ids.clear();
     lock_refs.clear();
@@ -162,11 +166,13 @@ void lockdep_unregister(int id)
   if (--refs == 0) {
     // reset dependency ordering
     for (int i=0; i<MAX_LOCKS; ++i) {
-      delete follows[id][i];
-      follows[id][i] = NULL;
+      delete follows_bt[id][i];
+      follows_bt[id][i] = NULL;
+      follows[id][i] = false;
 
-      delete follows[i][id];
-      follows[i][id] = NULL;
+      delete follows_bt[i][id];
+      follows_bt[i][id] = NULL;
+      follows[i][id] = false;
     }
 
     lockdep_dout(10) << "unregistered '" << p->second << "' from " << id
@@ -191,7 +197,9 @@ static bool does_follow(int a, int b)
     *_dout << "------------------------------------" << "\n";
     *_dout << "existing dependency " << lock_names[a] << " (" << a << ") -> "
            << lock_names[b] << " (" << b << ") at:\n";
-    follows[a][b]->print(*_dout);
+    if (follows_bt[a][b]) {
+      follows_bt[a][b]->print(*_dout);
+    }
     *_dout << dendl;
     return true;
   }
@@ -201,7 +209,9 @@ static bool does_follow(int a, int b)
 	does_follow(i, b)) {
       lockdep_dout(0) << "existing intermediate dependency " << lock_names[a]
           << " (" << a << ") -> " << lock_names[i] << " (" << i << ") at:\n";
-      follows[a][i]->print(*_dout);
+      if (follows_bt[a][i]) {
+        follows_bt[a][i]->print(*_dout);
+      }
       *_dout << dendl;
       return true;
     }
@@ -271,7 +281,8 @@ int lockdep_will_lock(const char *name, int id, bool force_backtrace)
         if (force_backtrace || lockdep_force_backtrace()) {
           bt = new BackTrace(BACKTRACE_SKIP);
         }
-	follows[p->first][id] = bt;
+        follows[p->first][id] = true;
+        follows_bt[p->first][id] = bt;
 	lockdep_dout(10) << lock_names[p->first] << " -> " << name << " at" << dendl;
 	//bt->print(*_dout);
       }

