commit cd6b328cd0c79bba866ffb60ff447b84cfaacf3b
Author: Bruno Faccini <bruno.faccini@intel.com>
Date:   Tue Jul 23 00:07:09 2013 +0800

    staging/lustre/mdc: Keep resend FLocks
    
    FLocks requests (particulary F_UNLCKs) can't be trashed
    upon comm problems with Server/MDS nor upon kill/exit,
    thus we need to keep retry/send.
    
    Intel-bug-id: https://jira.hpdd.intel.com/browse/LU-2665
    Lustre-change: http://review.whamcloud.com/6415
    Signed-off-by: Bruno Faccini <bruno.faccini@intel.com>
    Reviewed-by: Bobi Jam <bobijam@gmail.com>
    Reviewed-by: Oleg Drokin <oleg.drokin@intel.com>
    Signed-off-by: Peng Tao <tao.peng@emc.com>
    Signed-off-by: Andreas Dilger <andreas.dilger@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/lustre/lustre/mdc/mdc_locks.c b/drivers/staging/lustre/lustre/mdc/mdc_locks.c
index ab88a46c1a27..803c390e1c35 100644
--- a/drivers/staging/lustre/lustre/mdc/mdc_locks.c
+++ b/drivers/staging/lustre/lustre/mdc/mdc_locks.c
@@ -823,7 +823,13 @@ int mdc_enqueue(struct obd_export *exp, struct ldlm_enqueue_info *einfo,
 		/* For flock requests we immediatelly return without further
 		   delay and let caller deal with the rest, since rest of
 		   this function metadata processing makes no sense for flock
-		   requests anyway */
+		   requests anyway. But in case of problem during comms with
+		   Server (ETIMEDOUT) or any signal/kill attempt (EINTR), we
+		   can not rely on caller and this mainly for F_UNLCKs
+		   (explicits or automatically generated by Kernel to clean
+		   current FLocks upon exit) that can't be trashed */
+		if ((rc == -EINTR) || (rc == -ETIMEDOUT))
+			goto resend;
 		RETURN(rc);
 	}
 

