commit 6cdaca481f6c415025c2687c109674919aa61934
Author: Joel Fernandes <joelf@ti.com>
Date:   Thu Sep 26 16:55:46 2013 -0500

    ARM: edma: Fix clearing of unused list for DT DMA resources
    
    HWMOD removal for MMC is breaking edma_start as the events are being manually
    triggered due to unused channel list not being clear.
    
    The above issue is fixed by reading the "dmas" property from the DT node if it
    exists and clearing the bits in the unused channel list if the dma controller
    used by any device is EDMA. For this purpose we use the of_* helpers to parse
    the arguments in the dmas phandle list.
    
    Also introduced is a minor clean up of a checkpatch error in old code.
    
    Reviewed-by: Sekhar Nori <nsekhar@ti.com>
    Reported-by: Balaji T K <balajitk@ti.com>
    Cc: Sekhar Nori <nsekhar@ti.com>
    Cc: Tony Lindgren <tony@atomide.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Nishanth Menon <nm@ti.com>
    Cc: Pantel Antoniou <panto@antoniou-consulting.com>
    Cc: Jason Kridner <jkridner@beagleboard.org>
    Cc: Koen Kooi <koen@dominion.thruhere.net>
    Signed-off-by: Joel Fernandes <joelf@ti.com>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/arm/common/edma.c b/arch/arm/common/edma.c
index 117f955a2a06..8e1a0245907f 100644
--- a/arch/arm/common/edma.c
+++ b/arch/arm/common/edma.c
@@ -269,6 +269,11 @@ static const struct edmacc_param dummy_paramset = {
 	.ccnt = 1,
 };
 
+static const struct of_device_id edma_of_ids[] = {
+	{ .compatible = "ti,edma3", },
+	{}
+};
+
 /*****************************************************************************/
 
 static void map_dmach_queue(unsigned ctlr, unsigned ch_no,
@@ -560,14 +565,38 @@ static int reserve_contiguous_slots(int ctlr, unsigned int id,
 static int prepare_unused_channel_list(struct device *dev, void *data)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	int i, ctlr;
+	int i, count, ctlr;
+	struct of_phandle_args  dma_spec;
 
+	if (dev->of_node) {
+		count = of_property_count_strings(dev->of_node, "dma-names");
+		if (count < 0)
+			return 0;
+		for (i = 0; i < count; i++) {
+			if (of_parse_phandle_with_args(dev->of_node, "dmas",
+						       "#dma-cells", i,
+						       &dma_spec))
+				continue;
+
+			if (!of_match_node(edma_of_ids, dma_spec.np)) {
+				of_node_put(dma_spec.np);
+				continue;
+			}
+
+			clear_bit(EDMA_CHAN_SLOT(dma_spec.args[0]),
+				  edma_cc[0]->edma_unused);
+			of_node_put(dma_spec.np);
+		}
+		return 0;
+	}
+
+	/* For non-OF case */
 	for (i = 0; i < pdev->num_resources; i++) {
 		if ((pdev->resource[i].flags & IORESOURCE_DMA) &&
 				(int)pdev->resource[i].start >= 0) {
 			ctlr = EDMA_CTLR(pdev->resource[i].start);
 			clear_bit(EDMA_CHAN_SLOT(pdev->resource[i].start),
-					edma_cc[ctlr]->edma_unused);
+				  edma_cc[ctlr]->edma_unused);
 		}
 	}
 
@@ -1762,11 +1791,6 @@ static int edma_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static const struct of_device_id edma_of_ids[] = {
-	{ .compatible = "ti,edma3", },
-	{}
-};
-
 static struct platform_driver edma_driver = {
 	.driver = {
 		.name	= "edma",

