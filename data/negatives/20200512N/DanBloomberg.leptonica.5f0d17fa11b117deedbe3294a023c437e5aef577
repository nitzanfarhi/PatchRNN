commit 5f0d17fa11b117deedbe3294a023c437e5aef577
Author: Dan Bloomberg <dan.bloomberg@gmail.com>
Date:   Mon Apr 17 17:28:32 2017 -0700

    Fixed bmpio for both 16 bpp and 2 bpp
    * for 16 bpp, properly reads and writes, without a colormap
    * for 2 bpp, converts to 8 bpp, saving the colormap if it exists.
    * added two colormap depth converters
    * added 4th mode for converting 16 bpp --> 8 bpp

diff --git a/src/allheaders.h b/src/allheaders.h
index fe6d5e2..0bb3fdb 100644
--- a/src/allheaders.h
+++ b/src/allheaders.h
@@ -189,7 +189,7 @@ LEPT_DLL extern l_int32 pixaSaveFont ( const char *indir, const char *outdir, l_
 LEPT_DLL extern PIX * pixReadStreamBmp ( FILE *fp );
 LEPT_DLL extern PIX * pixReadMemBmp ( const l_uint8 *cdata, size_t size );
 LEPT_DLL extern l_int32 pixWriteStreamBmp ( FILE *fp, PIX *pix );
-LEPT_DLL extern l_int32 pixWriteMemBmp ( l_uint8 **pfdata, size_t *pfsize, PIX *pix );
+LEPT_DLL extern l_int32 pixWriteMemBmp ( l_uint8 **pfdata, size_t *pfsize, PIX *pixs );
 LEPT_DLL extern PIXA * l_bootnum_gen1 ( void );
 LEPT_DLL extern PIXA * l_bootnum_gen2 ( void );
 LEPT_DLL extern PIXA * l_bootnum_gen3 ( void );
@@ -480,6 +480,8 @@ LEPT_DLL extern l_int32 pixcmapGetDistanceToColor ( PIXCMAP *cmap, l_int32 index
 LEPT_DLL extern l_int32 pixcmapGetRangeValues ( PIXCMAP *cmap, l_int32 select, l_int32 *pminval, l_int32 *pmaxval, l_int32 *pminindex, l_int32 *pmaxindex );
 LEPT_DLL extern PIXCMAP * pixcmapGrayToColor ( l_uint32 color );
 LEPT_DLL extern PIXCMAP * pixcmapColorToGray ( PIXCMAP *cmaps, l_float32 rwt, l_float32 gwt, l_float32 bwt );
+LEPT_DLL extern PIXCMAP * pixcmapConvertTo4 ( PIXCMAP *cmaps );
+LEPT_DLL extern PIXCMAP * pixcmapConvertTo8 ( PIXCMAP *cmaps );
 LEPT_DLL extern PIXCMAP * pixcmapRead ( const char *filename );
 LEPT_DLL extern PIXCMAP * pixcmapReadStream ( FILE *fp );
 LEPT_DLL extern PIXCMAP * pixcmapReadMem ( const l_uint8 *data, size_t size );
diff --git a/src/bmpio.c b/src/bmpio.c
index f4c9c74..025a88d 100644
--- a/src/bmpio.c
+++ b/src/bmpio.c
@@ -112,7 +112,7 @@ PIX      *pix;
  * \brief   pixReadMemBmp()
  *
  * \param[in]    cdata    bmp data
- * \param[in]    size     number of bytes of bmp datanumber of bytes in data
+ * \param[in]    size     number of bytes of bmp-formatted data
  * \return  pix, or NULL on error
  */
 PIX *
@@ -234,7 +234,7 @@ PIXCMAP   *cmap;
     }
     pixSetColormap(pix, cmap);
 
-        /* Acquire the image data */
+        /* Acquire the image data.  Image origin for bmp is at lower right. */
     fdata = (l_uint8 *)cdata + offset;  /* start of the bmp image data */
     pixdata = pixGetData(pix);
     if (depth != 24) {  /* typ. 1 or 8 bpp */
@@ -363,16 +363,18 @@ size_t    size, nbytes;
  *
  * \param[out]   pfdata   data of bmp formatted image
  * \param[out]   pfsize    size of returned data
- * \param[in]    pix      1, 4, 8, 32 bpp
+ * \param[in]    pixs      1, 2, 4, 8, 16, 32 bpp
  * \return  0 if OK, 1 on error
  *
  * <pre>
  * Notes:
- *      (1) 2 bpp bmp files are not valid in the spec.  We can
- *          write and read them, but nobody else can.
- *      (2) The transparency component in an rgb pix is ignored.
+ *      (1) 2 bpp bmp files are not valid in the spec, and are
+ *          written as 8 bpp.
+ *      (2) pix with depth <= 8 bpp are written with a colormap.
+ *          16 bpp gray and 32 bpp rgb pix are written without a colormap.
+ *      (3) The transparency component in an rgb pix is ignored.
  *          All 32 bpp pix have the bmp alpha component set to 255 (opaque).
- *      (3) The bmp colormap entries, RGBA_QUAD, are the same as
+ *      (4) The bmp colormap entries, RGBA_QUAD, are the same as
  *          the ones used for colormaps in leptonica.  This allows
  *          a simple memcpy for bmp output.
  * </pre>
@@ -380,7 +382,7 @@ size_t    size, nbytes;
 l_int32
 pixWriteMemBmp(l_uint8  **pfdata,
                size_t    *pfsize,
-               PIX       *pix)
+               PIX       *pixs)
 {
 l_uint8     pel[4];
 l_uint8    *cta;          /* address of the bmp color table array */
@@ -395,6 +397,7 @@ l_uint32   *line, *pword;
 size_t      fsize;
 BMP_FH     *bmpfh;
 BMP_IH     *bmpih;
+PIX        *pix;
 PIXCMAP    *cmap;
 RGBA_QUAD  *pquad;
 
@@ -406,39 +409,48 @@ RGBA_QUAD  *pquad;
         return ERROR_INT("&fdata not defined", procName, 1 );
     if (!pfsize)
         return ERROR_INT("&fsize not defined", procName, 1 );
-    if (!pix)
-        return ERROR_INT("pix not defined", procName, 1);
-
-    pixGetDimensions(pix, &w, &h, &d);
-    if (d == 2)
-        L_WARNING("writing 2 bpp bmp file; nobody else can read\n", procName);
+    if (!pixs)
+        return ERROR_INT("pixs not defined", procName, 1);
+
+    pixGetDimensions(pixs, &w, &h, &d);
+    if (d == 2) {
+        L_WARNING("2 bpp files can't be read; converting to 8 bpp\n", procName);
+        pix = pixConvert2To8(pixs, 0, 85, 170, 255, 1);
+        d = 8;
+    } else {
+        pix = pixCopy(NULL, pixs);
+    }
     fdepth = (d == 32) ? 24 : d;
-    xres = (l_int32)(39.37 * (l_float32)pixGetXRes(pix) + 0.5);  /* to ppm */
-    yres = (l_int32)(39.37 * (l_float32)pixGetYRes(pix) + 0.5);  /* to ppm */
+
+        /* Resolution is given in pixels/meter */
+    xres = (l_int32)(39.37 * (l_float32)pixGetXRes(pix) + 0.5);
+    yres = (l_int32)(39.37 * (l_float32)pixGetYRes(pix) + 0.5);
 
     pixWpl = pixGetWpl(pix);
     pixBpl = 4 * pixWpl;
     fWpl = (w * fdepth + 31) / 32;
     fBpl = 4 * fWpl;
     fimagebytes = h * fBpl;
-    if (fimagebytes > 4LL * L_MAX_ALLOWED_PIXELS)
+    if (fimagebytes > 4LL * L_MAX_ALLOWED_PIXELS) {
+        pixDestroy(&pix);
         return ERROR_INT("image data is too large", procName, 1);
+    }
 
-        /* If not rgb, the bmp data is required to have a colormap */
+        /* If not rgb or 16 bpp, the bmp data is required to have a colormap */
     heapcm = 0;
-    if (d == 32) {   /* 24 bpp rgb; no colormap */
+    if (d == 32 || d == 16) {   /* 24 bpp rgb or 16 bpp: no colormap */
         ncolors = 0;
         cmaplen = 0;
     } else if ((cmap = pixGetColormap(pix))) {   /* existing colormap */
         ncolors = pixcmapGetCount(cmap);
         cmaplen = ncolors * sizeof(RGBA_QUAD);
         cta = (l_uint8 *)cmap->array;
-    } else {   /* no existing colormap; make a binary or gray one */
+    } else {   /* no existing colormap; d <= 8; make a binary or gray one */
         if (d == 1) {
             cmaplen  = sizeof(bwmap);
             ncolors = 2;
             cta = (l_uint8 *)bwmap;
-        } else {   /* d != 32; output grayscale version */
+        } else {   /* d = 2,4,8; use a grayscale output colormap */
             ncolors = 1 << fdepth;
             cmaplen = ncolors * sizeof(RGBA_QUAD);
             heapcm = 1;
@@ -505,7 +517,7 @@ RGBA_QUAD  *pquad;
         /* An endian byte swap is also required */
     pixEndianByteSwap(pix);
 
-        /* Transfer the data */
+        /* Transfer the image data.  Image origin for bmp is at lower right. */
     fmdata = fdata + offbytes;
     if (fdepth != 24) {   /* typ 1 or 8 bpp */
         data = (l_uint8 *)pixGetData(pix) + pixBpl * (h - 1);
@@ -544,10 +556,7 @@ RGBA_QUAD  *pquad;
         }
     }
 
-        /* Restore pix to the original state */
-    pixEndianByteSwap(pix);
-    if (d == 1 && cmap && ((l_uint8 *)(cmap->array))[0] == 0x0)
-        pixInvert(pix, pix);
+    pixDestroy(&pix);
     return 0;
 }
 
diff --git a/src/colormap.c b/src/colormap.c
index 1ef1f82..f08cfd6 100644
--- a/src/colormap.c
+++ b/src/colormap.c
@@ -68,6 +68,8 @@
  *      Colormap conversion
  *           PIXCMAP    *pixcmapGrayToColor()
  *           PIXCMAP    *pixcmapColorToGray()
+ *           PIXCMAP    *pixcmapConvertTo4()
+ *           PIXCMAP    *pixcmapConvertTo8()
  *
  *      Colormap I/O
  *           l_int32     pixcmapRead()
@@ -1506,6 +1508,78 @@ PIXCMAP   *cmapd;
 }
 
 
+/*!
+ * \brief   pixcmapConvertTo4()
+ *
+ * \param[in]    cmaps   colormap for 2 bpp pix
+ * \return  cmapd   (4 bpp)
+ *
+ * <pre>
+ * Notes:
+ *      (1) This converts a 2 bpp colormap to 4 bpp.  The colors
+ *          are the same; the output colormap entry array has size 16.
+ * </pre>
+ */
+PIXCMAP *
+pixcmapConvertTo4(PIXCMAP  *cmaps)
+{
+l_int32   i, n, rval, gval, bval;
+PIXCMAP  *cmapd;
+
+    PROCNAME("pixcmapConvertTo4");
+
+    if (!cmaps)
+        return (PIXCMAP *)ERROR_PTR("cmaps not defined", procName, NULL);
+    if (pixcmapGetDepth(cmaps) != 2)
+        return (PIXCMAP *)ERROR_PTR("cmaps not for 2 bpp pix", procName, NULL);
+
+    cmapd = pixcmapCreate(4);
+    n = pixcmapGetCount(cmaps);
+    for (i = 0; i < n; i++) {
+        pixcmapGetColor(cmaps, i, &rval, &gval, &bval);
+        pixcmapAddColor(cmapd, rval, gval, bval);
+    }
+    return cmapd;
+}
+
+
+/*!
+ * \brief   pixcmapConvertTo8()
+ *
+ * \param[in]    cmaps   colormap for 2 bpp or 4 bpp pix
+ * \return  cmapd   (8 bpp)
+ *
+ * <pre>
+ * Notes:
+ *      (1) This converts a 2 bpp or 4 bpp colormap to 8 bpp.  The colors
+ *          are the same; the output colormap entry array has size 256.
+ * </pre>
+ */
+PIXCMAP *
+pixcmapConvertTo8(PIXCMAP  *cmaps)
+{
+l_int32   i, n, depth, rval, gval, bval;
+PIXCMAP  *cmapd;
+
+    PROCNAME("pixcmapConvertTo8");
+
+    if (!cmaps)
+        return (PIXCMAP *)ERROR_PTR("cmaps not defined", procName, NULL);
+    depth = pixcmapGetDepth(cmaps);
+    if (depth == 8) return pixcmapCopy(cmaps);
+    if (depth != 2 && depth != 4)
+        return (PIXCMAP *)ERROR_PTR("cmaps not 2 or 4 bpp", procName, NULL);
+
+    cmapd = pixcmapCreate(8);
+    n = pixcmapGetCount(cmaps);
+    for (i = 0; i < n; i++) {
+        pixcmapGetColor(cmaps, i, &rval, &gval, &bval);
+        pixcmapAddColor(cmapd, rval, gval, bval);
+    }
+    return cmapd;
+}
+
+   
 /*-------------------------------------------------------------*
  *                         Colormap I/O                        *
  *-------------------------------------------------------------*/
diff --git a/src/pix.h b/src/pix.h
index 466243f..e029b4a 100644
--- a/src/pix.h
+++ b/src/pix.h
@@ -819,10 +819,11 @@ enum {
 enum {
     L_LS_BYTE = 1,              /*!< use LSB                               */
     L_MS_BYTE = 2,              /*!< use MSB                               */
-    L_CLIP_TO_FF = 3,           /*!< use max(val, 255)                     */
-    L_LS_TWO_BYTES = 4,         /*!< use two LSB                           */
-    L_MS_TWO_BYTES = 5,         /*!< use two MSB                           */
-    L_CLIP_TO_FFFF = 6          /*!< use max(val, 65535)                   */
+    L_AUTO_BYTE = 3,            /*!< use LSB if max(val) < 256; else MSB   */
+    L_CLIP_TO_FF = 4,           /*!< use max(val, 255)                     */
+    L_LS_TWO_BYTES = 5,         /*!< use two LSB                           */
+    L_MS_TWO_BYTES = 6,         /*!< use two MSB                           */
+    L_CLIP_TO_FFFF = 7          /*!< use max(val, 65535)                   */
 };
 
 
diff --git a/src/pixconv.c b/src/pixconv.c
index 72d4ca6..9e36554 100644
--- a/src/pixconv.c
+++ b/src/pixconv.c
@@ -1616,13 +1616,15 @@ PIX     *pixg, *pixd;
  * \brief   pixConvert16To8()
  *
  * \param[in]    pixs 16 bpp
- * \param[in]    type L_LS_BYTE, L_MS_BYTE, L_CLIP_TO_FF
+ * \param[in]    type L_LS_BYTE, L_MS_BYTE, L_AUTO_BYTE, L_CLIP_TO_FF
  * \return  pixd 8 bpp, or NULL on error
  *
  * <pre>
  * Notes:
- *      (1) For each dest pixel, use either the LSB, the MSB, or the
- *          min(val, 255) for each 16-bit src pixel.
+ *      (1) With L_AUTO_BYTE, if the max pixel value is greater than 255,
+ *          use the MSB; otherwise, use the LSB.
+ *      (2) With L_CLIP_TO_FF, use min(pixel-value, 0xff) for each
+ *          16-bit src pixel.
  * </pre>
  */
 PIX *
@@ -1630,7 +1632,7 @@ pixConvert16To8(PIX     *pixs,
                 l_int32  type)
 {
 l_uint16   dword;
-l_int32    w, h, wpls, wpld, i, j;
+l_int32    w, h, wpls, wpld, i, j, val, use_lsb;
 l_uint32   sword, first, second;
 l_uint32  *datas, *datad, *lines, *lined;
 PIX       *pixd;
@@ -1641,7 +1643,8 @@ PIX       *pixd;
         return (PIX *)ERROR_PTR("pixs not defined", procName, NULL);
     if (pixGetDepth(pixs) != 16)
         return (PIX *)ERROR_PTR("pixs not 16 bpp", procName, NULL);
-    if (type != L_LS_BYTE && type != L_MS_BYTE && type != L_CLIP_TO_FF)
+    if (type != L_LS_BYTE && type != L_MS_BYTE &&
+        type != L_AUTO_BYTE && type != L_CLIP_TO_FF)
         return (PIX *)ERROR_PTR("invalid type", procName, NULL);
 
     pixGetDimensions(pixs, &w, &h, NULL);
@@ -1654,6 +1657,22 @@ PIX       *pixd;
     wpld = pixGetWpl(pixd);
     datad = pixGetData(pixd);
 
+    if (type == L_AUTO_BYTE) {
+        use_lsb = TRUE;
+        for (i = 0; i < h; i++) {
+            lines = datas + i * wpls;
+            for (j = 0; j < wpls; j++) {
+                 val = GET_DATA_TWO_BYTES(lines, j);
+                 if (val > 255) {
+                     use_lsb = FALSE;
+                     break;
+                 }
+            }
+            if (!use_lsb) break;
+        }
+        type = (use_lsb) ? L_LS_BYTE : L_MS_BYTE;
+    }
+        
         /* Convert 2 pixels at a time */
     for (i = 0; i < h; i++) {
         lines = datas + i * wpls;
@@ -2282,7 +2301,7 @@ PIXCMAP  *cmap;
  *          as pixs.  It is always returned.
  *      (3) A simple unpacking might use val0 = 0 and val1 = 255, or v.v.
  *      (4) To have a colormap associated with the 8 bpp pixd,
- *          usepixConvert1To8Cmap().
+ *          use pixConvert1To8Cmap().
  * </pre>
  */
 PIX *
@@ -2383,8 +2402,7 @@ pixConvert2To8(PIX     *pixs,
                l_uint8  val3,
                l_int32  cmapflag)
 {
-l_int32    w, h, i, j, nbytes, wpls, wpld, dibit, ncolor;
-l_int32    rval, gval, bval, byte;
+l_int32    w, h, i, j, nbytes, wpls, wpld, dibit, byte;
 l_uint8    val[4];
 l_uint32   index;
 l_uint32  *tab, *datas, *datad, *lines, *lined;
@@ -2413,14 +2431,10 @@ PIXCMAP   *cmaps, *cmapd;
     wpld = pixGetWpl(pixd);
 
     if (cmapflag == TRUE) {  /* pixd will have a colormap */
-        cmapd = pixcmapCreate(8);  /* 8 bpp standard cmap */
         if (cmaps) {  /* use the existing colormap from pixs */
-            ncolor = pixcmapGetCount(cmaps);
-            for (i = 0; i < ncolor; i++) {
-                pixcmapGetColor(cmaps, i, &rval, &gval, &bval);
-                pixcmapAddColor(cmapd, rval, gval, bval);
-            }
+            cmapd = pixcmapConvertTo8(cmaps);
         } else {  /* make a colormap from the input values */
+            cmapd = pixcmapCreate(8);
             pixcmapAddColor(cmapd, val0, val0, val0);
             pixcmapAddColor(cmapd, val1, val1, val1);
             pixcmapAddColor(cmapd, val2, val2, val2);
@@ -2495,8 +2509,7 @@ PIX *
 pixConvert4To8(PIX     *pixs,
                l_int32  cmapflag)
 {
-l_int32    w, h, i, j, wpls, wpld, ncolor;
-l_int32    rval, gval, bval, byte, qbit;
+l_int32    w, h, i, j, wpls, wpld, byte, qbit;
 l_uint32  *datas, *datad, *lines, *lined;
 PIX       *pixd;
 PIXCMAP   *cmaps, *cmapd;
@@ -2523,14 +2536,10 @@ PIXCMAP   *cmaps, *cmapd;
     wpld = pixGetWpl(pixd);
 
     if (cmapflag == TRUE) {  /* pixd will have a colormap */
-        cmapd = pixcmapCreate(8);
         if (cmaps) {  /* use the existing colormap from pixs */
-            ncolor = pixcmapGetCount(cmaps);
-            for (i = 0; i < ncolor; i++) {
-                pixcmapGetColor(cmaps, i, &rval, &gval, &bval);
-                pixcmapAddColor(cmapd, rval, gval, bval);
-            }
+            cmapd = pixcmapConvertTo8(cmaps);
         } else {  /* make a colormap with a linear trc */
+            cmapd = pixcmapCreate(8);
             for (i = 0; i < 16; i++)
                 pixcmapAddColor(cmapd, 17 * i, 17 * i, 17 * i);
         }

