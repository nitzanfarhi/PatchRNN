commit 359e181fca4f04c2ca17d1fe3edd4e3039935d41
Author: stephentu <stephentu@fb.com>
Date:   Wed Jun 15 11:51:03 2011 -0700

    Revert "[Perf] Improve code generated for runtime type-casting"
    
    This reverts commit d8a62fb55dbf82fea08d5c17682f2096fdbc65fd.

diff --git a/src/compiler/analysis/constant_table.cpp b/src/compiler/analysis/constant_table.cpp
index 5999288ac2..8a349c1683 100644
--- a/src/compiler/analysis/constant_table.cpp
+++ b/src/compiler/analysis/constant_table.cpp
@@ -339,6 +339,7 @@ bool ConstantTable::outputCPP(CodeGenerator &cg, AnalysisResultPtr ar,
     cg_printf(isString ? "(" : " = ");
     if (value) {
       ExpressionPtr exp = dynamic_pointer_cast<Expression>(value);
+      ASSERT(!exp->getExpectedType());
       if (isString && exp->isScalar()) {
         ScalarExpressionPtr scalarExp =
           dynamic_pointer_cast<ScalarExpression>(exp);
diff --git a/src/compiler/analysis/type.cpp b/src/compiler/analysis/type.cpp
index c7e7363af3..67516eeb20 100644
--- a/src/compiler/analysis/type.cpp
+++ b/src/compiler/analysis/type.cpp
@@ -169,21 +169,6 @@ TypePtr Type::Intersection(AnalysisResultConstPtr ar,
   return res;
 }
 
-bool Type::IsMappedToVariant(TypePtr t) {
-  switch (t->m_kindOf) {
-  case KindOfBoolean:
-  case KindOfInt32  :
-  case KindOfInt64  :
-  case KindOfDouble :
-  case KindOfString :
-  case KindOfArray  :
-  case KindOfObject :
-    return false;
-  default: break;
-  }
-  return true;
-}
-
 bool Type::IsCastNeeded(AnalysisResultConstPtr ar, TypePtr from, TypePtr to) {
   if (SameType(from, to)) return false;
   if (!from->m_kindOf) return true;
@@ -335,68 +320,6 @@ bool Type::IsExactType(KindOf kindOf) {
   return kindOf && !(kindOf & (kindOf-1));
 }
 
-bool Type::HasFastCastMethod(TypePtr t) {
-  switch (t->getKindOf()) {
-  case Type::KindOfBoolean:
-  case Type::KindOfInt32:
-  case Type::KindOfInt64:
-  case Type::KindOfDouble:
-  case Type::KindOfString:
-  case Type::KindOfArray:
-  case Type::KindOfObject:
-    return true;
-  default: break;
-  }
-  return false;
-}
-
-string Type::GetFastCastMethod(
-    TypePtr dst, bool allowRef, bool forConst, bool forVal) {
-  const char *prefix0 = allowRef ?            "to"  : "as";
-  const char *prefix1 = forConst && !forVal ? "C"   : "";
-  const char *prefix2 = forVal   ?            "Val" : "Ref";
-  const char *type;
-
-  switch (dst->getKindOf()) {
-  case Type::KindOfBoolean:
-  case Type::KindOfInt32:
-  case Type::KindOfInt64:
-  case Type::KindOfDouble:
-    prefix0 = "to";
-    prefix1 = "";
-    prefix2 = "Val";
-    break;
-  default: break;
-  }
-
-  switch (dst->getKindOf()) {
-  case Type::KindOfBoolean:
-    type = "Boolean";
-    break;
-  case Type::KindOfInt32:
-  case Type::KindOfInt64:
-    type = "Int64";
-    break;
-  case Type::KindOfDouble:
-    type = "Double";
-    break;
-  case Type::KindOfString:
-    type = "Str";
-    break;
-  case Type::KindOfArray:
-    type = "Arr";
-    break;
-  case Type::KindOfObject:
-    type = "Obj";
-    break;
-  default:
-    ASSERT(false);
-    break;
-  }
-
-  return string(prefix0) + string(prefix1) + string(type) + string(prefix2);
-}
-
 /* This new IsLegalCast returns true in a few cases where the old version
  * (which was basically a hardcoded truth table) returned false; it seems
  * like "true" is in fact the right thing to return. The cases that appear
@@ -584,22 +507,6 @@ void Type::outputCPPDecl(CodeGenerator &cg, AnalysisResultConstPtr ar,
   }
 }
 
-void Type::outputCPPFastObjectCast(CodeGenerator &cg,
-    AnalysisResultConstPtr ar,
-    BlockScopeRawPtr scope,
-    bool isConst,
-    bool isVal) {
-  ASSERT(isSpecificObject());
-  ClassScopePtr cls(getClass(ar, scope));
-  ASSERT(cls);
-  const string &cppClsName = cls->getId(cg);
-  cg_printf("(%s%s%s%s)",
-            isConst ? "const " : "",
-            Option::SmartPtrPrefix,
-            cppClsName.c_str(),
-            isVal ? "" : "&");
-}
-
 void Type::outputCPPCast(CodeGenerator &cg, AnalysisResultConstPtr ar,
                          BlockScopeRawPtr scope) {
   switch (m_kindOf) {
diff --git a/src/compiler/analysis/type.h b/src/compiler/analysis/type.h
index cea821e8e8..e1f4f4aa8f 100644
--- a/src/compiler/analysis/type.h
+++ b/src/compiler/analysis/type.h
@@ -120,12 +120,6 @@ public:
   static TypePtr Intersection(AnalysisResultConstPtr ar,
                               TypePtr from, TypePtr to);
 
-  /**
-   * Whether or not this type is mapped to type Variant
-   * in the runtime
-   */
-  static bool IsMappedToVariant(TypePtr t);
-
   /**
    * Whether or not a cast is needed during code generation.
    */
@@ -164,15 +158,6 @@ public:
    */
   static bool IsExactType(KindOf kindOf);
 
-  static bool HasFastCastMethod(TypePtr t);
-
-  /**
-   *  Returns the name of the method used to fast cast from
-   *  variant to dst
-   */
-  static std::string GetFastCastMethod(
-      TypePtr dst, bool allowRef, bool forConst, bool forVal);
-
 private:
   Type(KindOf kindOf, const std::string &name);
 
@@ -213,13 +198,6 @@ public:
   /**
    * Generate type conversion in C++.
    */
-
-  void outputCPPFastObjectCast(CodeGenerator &cg,
-      AnalysisResultConstPtr ar,
-      BlockScopeRawPtr scope,
-      bool isConst,
-      bool isVal);
-
   void outputCPPCast(CodeGenerator &cg, AnalysisResultConstPtr ar,
                      BlockScopeRawPtr scope);
 
diff --git a/src/compiler/construct.cpp b/src/compiler/construct.cpp
index ca8c96eaa9..2eab5aa030 100644
--- a/src/compiler/construct.cpp
+++ b/src/compiler/construct.cpp
@@ -157,15 +157,6 @@ void Construct::printSource(CodeGenerator &cg) {
 }
 
 void Construct::dumpNode(int spc, AnalysisResultConstPtr ar) {
-  dumpNode(spc);
-}
-
-void Construct::dumpNode(int spc) const {
-  // evil, but helpful!
-  const_cast<Construct*>(this)->dumpNode(spc);
-}
-
-void Construct::dumpNode(int spc) {
   int nkid = getKidCount();
   const char *name = 0;
   int type = 0;
@@ -278,13 +269,9 @@ void Construct::dumpNode(int spc) {
       type_info = e->getActualType()->toString();
       if (e->getExpectedType()) {
         type_info += ":" + e->getExpectedType()->toString();
-      } else {
-        type_info += ":";
       }
       if (e->getImplementedType()) {
         type_info += ";" + e->getImplementedType()->toString();
-      } else {
-        type_info += ";";
       }
       type_info = "{" + type_info + "} ";
     }
@@ -375,8 +362,7 @@ void Construct::dumpNode(int spc) {
   }
   if (objstr != "") objstr = " (" + objstr + ")";
 
-  std::cout << type_info << nkid << scontext << sef
-    << localtered << refstr << objstr;
+  std::cout << type_info << nkid << scontext << sef << localtered << refstr << objstr;
   if (m_loc) {
     std::cout << " " << m_loc->file << ":" <<
       m_loc->line1 << "@" << m_loc->char1;
diff --git a/src/compiler/construct.h b/src/compiler/construct.h
index 098c63d30c..c010ba7cb4 100644
--- a/src/compiler/construct.h
+++ b/src/compiler/construct.h
@@ -194,21 +194,17 @@ public:
    */
   virtual int getKidCount() const = 0;
 
-  // helpers for GDB
-  void dump(int spc, AnalysisResultPtr ar) {
+  void dump(int spc, AnalysisResultPtr ar) { 
     AnalysisResultConstPtr arp(ar);
     dump(spc, arp);
   }
-  void dumpNode(int spc, AnalysisResultPtr ar) {
+  void dumpNode(int spc, AnalysisResultPtr ar) { 
     AnalysisResultConstPtr arp(ar);
     dumpNode(spc, arp);
   }
-  void dumpNode(int spc);
-  void dumpNode(int spc) const;
 
   void dump(int spc, AnalysisResultConstPtr ar);
   void dumpNode(int spc, AnalysisResultConstPtr ar);
-
   static void dump(int spc, AnalysisResultConstPtr ar, bool functionOnly,
                    const AstWalkerStateVec &start,
                    ConstructPtr endBefore, ConstructPtr endAfter);
@@ -258,7 +254,7 @@ private:
       unsigned referenced_valid : 1; // whether or not the above flag is valid
       unsigned needed : 1;
       unsigned needed_valid : 1; // whether or not the above flag is valid
-      unsigned chainRoot : 1; // whether this denotes the begining of a
+      unsigned chainRoot : 1; // whether this denotes the begining of a 
                               // CSE chain
     } m_flags;
   };
diff --git a/src/compiler/expression/array_element_expression.cpp b/src/compiler/expression/array_element_expression.cpp
index 23cbbc98e6..b05fcfd602 100644
--- a/src/compiler/expression/array_element_expression.cpp
+++ b/src/compiler/expression/array_element_expression.cpp
@@ -191,18 +191,6 @@ void ArrayElementExpression::analyzeProgram(AnalysisResultPtr ar) {
       }
       FunctionScopePtr scope = getFunctionScope();
       if (scope) scope->setNeedsCheckMem();
-    } else {
-      TypePtr at(m_variable->getActualType());
-      TypePtr et(m_variable->getExpectedType());
-      if (et &&
-          (et->is(Type::KindOfSequence) ||
-           et->is(Type::KindOfAutoSequence)) &&
-          at && at->isExactType()) {
-        // since Sequence maps to Variant in the runtime,
-        // using Sequence for the expected type will
-        // never allow the necessary casts to be generated.
-        m_variable->setExpectedType(at);
-      }
     }
   }
 }
@@ -437,7 +425,7 @@ void ArrayElementExpression::outputCPPImpl(CodeGenerator &cg,
       cg_printf(")");
     }
   } else {
-    TypePtr type = m_variable->getType();
+    TypePtr type = m_variable->getActualType();
     if (hasContext(UnsetContext)) {
       cg_printf("unsetLval(");
       m_variable->outputCPP(cg, ar);
@@ -453,7 +441,18 @@ void ArrayElementExpression::outputCPPImpl(CodeGenerator &cg,
         m_variable->outputCPP(cg, ar);
         cg_printf(")");
       } else {
+        TypePtr act;
+        if (!m_variable->hasCPPTemp() && m_variable->getImplementedType() &&
+            type->is(Type::KindOfArray) &&
+            !Type::SameType(m_variable->getImplementedType(), type)) {
+          act = type;
+          type = m_variable->getImplementedType();
+          m_variable->setActualType(m_variable->getImplementedType());
+        }
         m_variable->outputCPP(cg, ar);
+        if (act) {
+          m_variable->setActualType(act);
+        }
       }
     }
     if (m_offset) {
@@ -469,17 +468,17 @@ void ArrayElementExpression::outputCPPImpl(CodeGenerator &cg,
       TypePtr t;
       bool hasCseStore = isRealChainRoot && GetCseTempInfo(
           ar,
-          static_pointer_cast<Expression>(shared_from_this()),
+          static_pointer_cast<Expression>(shared_from_this()), 
           t);
 
       if (hasContext(UnsetContext)) {
         // do nothing
       } else if (hasContext(InvokeArgument) && cg.callInfoTop() != -1) {
-        ASSERT(!isRealChainRoot); // TODO: handle this case
+        ASSERT(!isRealChainRoot); // TODO: handle this case 
         cg_printf(".argvalAt(cit%d->isRef(%d), ", cg.callInfoTop(), m_argNum);
       } else if (m_context & (LValue|RefValue|DeepReference)) {
         // if we see an array access element in LValue context, the
-        // type inference pass will never infer its type to be a string
+        // type inference pass will never infer its type to be a string 
         ASSERT(!isStringType);
         if (isRealChainRoot && !isArrayType) {
           // chain roots for non array types (variants) should call
@@ -490,7 +489,7 @@ void ArrayElementExpression::outputCPPImpl(CodeGenerator &cg,
         }
         lvalAt = true;
       } else {
-        byRef =
+        byRef = 
           ((m_context & AccessContext) || isRealChainRoot) && !isStringType;
         arrRef = byRef && isArrayType;
         cg_printf(".rval%s%s(",
@@ -515,7 +514,7 @@ void ArrayElementExpression::outputCPPImpl(CodeGenerator &cg,
           }
         } else if (lvalAt) {
           if (hasCseStore && !isArrayType) {
-            cg_printf(", %s%s",
+            cg_printf(", %s%s", 
                 Option::CseTempStoragePrefix, m_cppCseTemp.c_str());
           }
           if (hasContext(AccessContext)) {
diff --git a/src/compiler/expression/binary_op_expression.cpp b/src/compiler/expression/binary_op_expression.cpp
index d8991f091a..0d97dc9967 100644
--- a/src/compiler/expression/binary_op_expression.cpp
+++ b/src/compiler/expression/binary_op_expression.cpp
@@ -320,40 +320,7 @@ ExpressionPtr BinaryOpExpression::simplifyArithmetic(
   return ExpressionPtr();
 }
 
-void BinaryOpExpression::optimizeTypes(AnalysisResultConstPtr ar) {
-  switch (m_op) {
-  case '<':
-  case T_IS_SMALLER_OR_EQUAL:
-  case '>':
-  case T_IS_GREATER_OR_EQUAL:
-  case T_IS_IDENTICAL:
-  case T_IS_NOT_IDENTICAL:
-  case T_IS_EQUAL:
-  case T_IS_NOT_EQUAL:
-    {
-      // not needed for correctness, but will allow us to
-      // generate better code, since we can use the more
-      // specific runtime function
-
-      TypePtr a1(m_exp1->getActualType());
-      TypePtr i1(m_exp1->getImplementedType());
-      if (a1 && i1 &&
-          Type::IsMappedToVariant(i1) && Type::HasFastCastMethod(a1)) {
-        m_exp1->setExpectedType(a1);
-      }
-      TypePtr a2(m_exp2->getActualType());
-      TypePtr i2(m_exp2->getImplementedType());
-      if (a2 && i2 &&
-          Type::IsMappedToVariant(i2) && Type::HasFastCastMethod(a2)) {
-        m_exp2->setExpectedType(a2);
-      }
-    }
-  default: break;
-  }
-}
-
 ExpressionPtr BinaryOpExpression::postOptimize(AnalysisResultConstPtr ar) {
-  optimizeTypes(ar);
   ExpressionPtr optExp = simplifyArithmetic(ar);
   if (!optExp) {
     if (isShortCircuitOperator()) optExp = simplifyLogical(ar);
@@ -702,10 +669,6 @@ TypePtr BinaryOpExpression::inferTypes(AnalysisResultPtr ar, TypePtr type,
       TypePtr lhs = m_exp1->inferAndCheck(ar, Type::Any, true);
       if (lhs) {
         if (lhs->mustBe(Type::KindOfArray)) {
-          TypePtr a2(m_exp2->getActualType());
-          if (a2 && a2->is(Type::KindOfArray)) {
-            m_exp2->setExpectedType(a2);
-          }
           rt = Type::Array;
           break;
         }
@@ -713,17 +676,7 @@ TypePtr BinaryOpExpression::inferTypes(AnalysisResultPtr ar, TypePtr type,
           if (!rhs->mustBe(lhs->getKindOf())) {
             rhs = Type::combinedArithmeticType(lhs, rhs);
             if (!rhs) rhs = Type::Numeric;
-            m_exp1->inferAndCheck(ar, rhs, true);
-          }
-          TypePtr a1(m_exp1->getCPPType());
-          TypePtr a2(m_exp2->getActualType());
-          if (a1 && a1->mustBe(Type::KindOfNumeric) &&
-              a2 && a2->mustBe(Type::KindOfNumeric)) {
-            // both LHS and RHS are numeric.
-            // Set the expected type of RHS to be
-            // the stronger type
-            TypePtr t = a1->getKindOf() > a2->getKindOf() ? a1 : a2;
-            m_exp2->setExpectedType(t);
+            lhs = m_exp1->inferAndCheck(ar, rhs, true);
           }
           rt = Type::Numeric;
           break;
@@ -765,24 +718,16 @@ TypePtr BinaryOpExpression::inferTypes(AnalysisResultPtr ar, TypePtr type,
 
       TypePtr combined = Type::combinedArithmeticType(act1, act2);
       if (combined && combined->isSubsetOf(rt)) {
-        if (act1) m_exp1->setExpectedType(act1);
-        if (act2) m_exp2->setExpectedType(act2);
         rt = combined;
       } else if (m_op == '+') {
         bool a1 = act1 && act1->is(Type::KindOfArray);
         bool a2 = act2 && act2->is(Type::KindOfArray);
         if (a1 || a2) {
-          m_implementedType.reset();
-          if (!a1) {
+          if (!a1 || !a2) {
             m_implementedType = Type::Variant;
-          } else if (!a2) {
-            m_exp1->setExpectedType(Type::Array);
-            // in this case, the implemented type will
-            // actually be Type::Array (since Array::operator+
-            // returns an Array)
           } else {
-            m_exp1->setExpectedType(Type::Array);
-            m_exp2->setExpectedType(Type::Array);
+            m_exp1->setExpectedType(TypePtr());
+            m_exp2->setExpectedType(TypePtr());
           }
           rt = Type::Array;
         }
@@ -795,6 +740,9 @@ TypePtr BinaryOpExpression::inferTypes(AnalysisResultPtr ar, TypePtr type,
     break;
   }
 
+  m_exp1->fixExpectedType(ar);
+  m_exp2->fixExpectedType(ar);
+
   return rt;
 }
 
@@ -950,10 +898,18 @@ static void outputStringExpr(CodeGenerator &cg, AnalysisResultPtr ar,
     return;
   }
 
-  TypePtr et(exp->getExpectedType());
-  exp->setExpectedType(Type::String);
+  bool close = false;
+  if ((exp->hasContext(Expression::LValue) &&
+       (!exp->getActualType()->is(Type::KindOfString) ||
+        (exp->getImplementedType() &&
+         !exp->getImplementedType()->is(Type::KindOfString))))
+      ||
+      !exp->getType()->is(Type::KindOfString)) {
+    cg_printf("toString(");
+    close = true;
+  }
   exp->outputCPP(cg, ar);
-  exp->setExpectedType(et);
+  if (close) cg_printf(")");
 }
 
 static void outputStringBufExprs(ExpressionPtrVec &ev,
diff --git a/src/compiler/expression/binary_op_expression.h b/src/compiler/expression/binary_op_expression.h
index 845cf68357..d6f1234087 100644
--- a/src/compiler/expression/binary_op_expression.h
+++ b/src/compiler/expression/binary_op_expression.h
@@ -62,7 +62,6 @@ public:
   bool isAssignmentOp() const { return m_assign; }
 
 private:
-  void optimizeTypes(AnalysisResultConstPtr ar);
   ExpressionPtr simplifyLogical(AnalysisResultConstPtr ar);
   ExpressionPtr simplifyArithmetic(AnalysisResultConstPtr ar);
   bool isOpEqual();
diff --git a/src/compiler/expression/expression.cpp b/src/compiler/expression/expression.cpp
index b66edcd71e..4733b8c2a0 100644
--- a/src/compiler/expression/expression.cpp
+++ b/src/compiler/expression/expression.cpp
@@ -307,6 +307,13 @@ string Expression::originalClassName(CodeGenerator &cg, bool withComma) {
   return withComma ? "" : "null_string";
 }
 
+void Expression::fixExpectedType(AnalysisResultConstPtr ar) {
+  if (m_expectedType && m_actualType &&
+      !Type::IsCastNeeded(ar, m_actualType, m_expectedType)) {
+    m_expectedType.reset();
+  }
+}
+
 TypePtr Expression::inferAndCheck(AnalysisResultPtr ar, TypePtr type,
                                   bool coerce) {
   TypePtr actualType = inferTypes(ar, type, coerce);
@@ -336,12 +343,12 @@ TypePtr Expression::checkTypesImpl(AnalysisResultConstPtr ar,
 void Expression::setTypes(AnalysisResultConstPtr ar, TypePtr actualType,
                           TypePtr expectedType) {
   m_actualType = actualType;
-  if (!expectedType->is(Type::KindOfAny) &&
+  if (!Type::SameType(expectedType, actualType) &&
+      !expectedType->is(Type::KindOfAny) &&
       !expectedType->is(Type::KindOfSome)) {
-    // store the expected type if it is not Any nor Some,
-    // regardless of the actual type
     m_expectedType = expectedType;
   } else {
+    // Clear expected type since expectedType == actualType
     m_expectedType.reset();
   }
 
@@ -429,6 +436,8 @@ bool Expression::CheckNeeded(ExpressionPtr variable, ExpressionPtr value) {
 bool Expression::CheckVarNR(ExpressionPtr value,
                             TypePtr expectedType /* = TypePtr */) {
   if (!expectedType) expectedType = value->getExpectedType();
+  ASSERT(!value->getExpectedType() ||
+         Type::SameType(expectedType, value->getExpectedType()));
   return (!value->hasContext(Expression::RefValue) &&
           expectedType && expectedType->is(Type::KindOfVariant) &&
           (value->getCPPType()->is(Type::KindOfArray) ||
@@ -473,23 +482,15 @@ TypePtr Expression::inferAssignmentTypes(AnalysisResultPtr ar, TypePtr type,
   if (!coerce && type->is(Type::KindOfAny)) {
     ret = vt;
   } else {
-    TypePtr it = variable->getCPPType();
+    TypePtr it = variable->is(KindOfObjectPropertyExpression) ?
+      Type::Variant :
+      variable->getImplementedType();
+    if (!it) it = vt;
     if (!Type::SameType(it, ret)) {
       m_implementedType = it;
     }
   }
 
-  if (value) {
-    TypePtr vat(value->getActualType());
-    TypePtr vet(value->getExpectedType());
-    TypePtr vit(value->getImplementedType());
-    if (vat && !vet && vit &&
-        Type::IsMappedToVariant(vit) &&
-        Type::HasFastCastMethod(vat)) {
-      value->setExpectedType(vat);
-    }
-  }
-
   return ret;
 }
 
@@ -672,7 +673,7 @@ bool Expression::outputCPPArithArg(CodeGenerator &cg, AnalysisResultPtr ar,
       (at->is(Type::KindOfString) ||
        at->is(Type::KindOfObject) ||
        (at->is(Type::KindOfArray) && !arrayOk)) &&
-      (!hasCPPTemp() || getCPPType()->isExactType())) {
+      (!hasCPPTemp() || getType()->isExactType())) {
     if (!hasCPPTemp() && !getCPPType()->isExactType()) {
       TypePtr et = getExpectedType();
       setExpectedType(TypePtr());
@@ -712,29 +713,16 @@ std::string Expression::genCPPTemp(CodeGenerator &cg, AnalysisResultPtr ar) {
 void Expression::preOutputStash(CodeGenerator &cg, AnalysisResultPtr ar,
                                 int state) {
   if (hasCPPTemp() || isScalar()) return;
-  bool fastCast = needsFastCastTemp(ar);
-  if (!isLocalExprAltered() && !hasEffect() && !fastCast) return;
+  if (!isLocalExprAltered() && !hasEffect()) return;
 
   bool killCast = false;
 
-  TypePtr srcType, dstType, dstType0;
+  TypePtr srcType, dstType;
   bool needsCast = getTypeCastPtrs(ar, srcType, dstType);
 
   bool isLvalue = (m_context & LValue);
   bool isTemp = isTemporary();
-
-  bool isReferenced = false;
-
-  if (fastCast) {
-    isTemp = true;
-    killCast = true;
-    dstType0 = dstType;
-    dstType = Type::Variant;
-    SimpleVariablePtr p(
-      dynamic_pointer_cast<SimpleVariable>(
-        shared_from_this()));
-    isReferenced = p ? p->couldBeAliased() : !isTemporary();
-  } else if (needsCast) {
+  if (needsCast) {
     isTemp = true;
   } else {
     killCast = true;
@@ -781,7 +769,7 @@ void Expression::preOutputStash(CodeGenerator &cg, AnalysisResultPtr ar,
       dstType->outputCPPDecl(cg, ar, getScope());
     }
     std::string t = genCPPTemp(cg, ar);
-    const char *ref =
+    const char *ref = 
       ((isLvalue || constRef) && !(state & ForceTemp)) ? "&" : "";
     /*
       Note that double parens are necessary:
@@ -847,42 +835,7 @@ void Expression::preOutputStash(CodeGenerator &cg, AnalysisResultPtr ar,
       cg_printf("&>(%s);\n", t.c_str());
       t += "_lv";
     }
-    if (fastCast) {
-      ASSERT(dstType0);
-      ASSERT(srcType == m_implementedType);
-      dstType = dstType0;
 
-      if (constRef) cg_printf("const ");
-      dstType->outputCPPDecl(cg, ar, getScope());
-      cg_printf(" %s%s_vv = ",
-                dstType->isPrimitive() ? "" : "&",
-                t.c_str());
-
-      int closeParen = 0;
-      if (!Type::SameType(m_actualType, dstType)) {
-        dstType->outputCPPCast(cg, ar, getScope());
-        cg_printf("(");
-        closeParen++;
-      }
-
-      if (m_actualType->isSpecificObject()) {
-        cg_printf("(");
-        closeParen++;
-        m_actualType->outputCPPFastObjectCast(
-            cg, ar, getScope(), constRef, false);
-        cg_printf("(");
-        closeParen++;
-      }
-
-      const string& method = Type::GetFastCastMethod(
-          m_actualType, isReferenced, constRef, false);
-      cg_printf("%s.%s()", t.c_str(), method.c_str());
-
-      for (int i = 0; i < closeParen; i++) cg_printf(")");
-      cg_printf(";\n");
-
-      t += "_vv";
-    }
     m_cppTemp = t;
   } else {
     if (outputCPPUnneeded(cg, ar)) {
@@ -900,19 +853,20 @@ bool Expression::preOutputCPP(CodeGenerator &cg, AnalysisResultPtr ar,
 
   bool stashAll = state & StashAll;
   state &= ~StashAll;
-  bool doStash = (state & FixOrder) != 0 || needsFastCastTemp(ar);
-  bool ret = doStash;
+  bool ret = (state & FixOrder) != 0;
   int kidState = (state & ~(StashKidVars|StashVars|FixOrder));
   if (state & StashKidVars) kidState |= StashVars;
   int lastEffect = -1, i;
   int n = getKidCount();
   if (hasEffect()) {
     int j;
+    ExpressionPtr lastExpr;
     for (i = j = 0; i < n; i++) {
       ExpressionPtr k = getNthExpr(i);
       if (k && !k->isScalar()) {
         if (k->hasEffect()) {
           lastEffect = i;
+          lastExpr = k;
           if (!j && k->isTemporary()) {
             j++;
           }
@@ -962,7 +916,7 @@ bool Expression::preOutputCPP(CodeGenerator &cg, AnalysisResultPtr ar,
     }
   }
 
-  if (doStash) {
+  if (state & FixOrder) {
     if (cg.inExpression()) {
       preOutputStash(cg, ar, state);
     }
@@ -1025,7 +979,7 @@ bool Expression::preOutputOffsetLHS(CodeGenerator &cg,
       }
     }
   }
-
+  
   // check to see if this elem has a CSE substitution
   // or is a chain root. in this case, we need to force a temp
   // since we will be taking a reference out, if we need to
@@ -1083,7 +1037,7 @@ bool Expression::preOutputOffsetLHS(CodeGenerator &cg,
   return true;
 }
 
-void Expression::collectCPPTemps(ExpressionPtrVec &collection) {
+void Expression::collectCPPTemps(ExpressionPtrVec &collection) { 
   if (isChainRoot()) {
     collection.push_back(static_pointer_cast<Expression>(shared_from_this()));
   } else {
@@ -1112,7 +1066,7 @@ bool Expression::hasChainRoots() {
 
 bool Expression::GetCseTempInfo(
     AnalysisResultPtr ar,
-    ExpressionPtr p,
+    ExpressionPtr p, 
     TypePtr &t) {
   ASSERT(p);
   switch (p->getKindOf()) {
@@ -1143,7 +1097,7 @@ bool Expression::GetCseTempInfo(
 
 ExpressionPtr Expression::getNextCanonCsePtr() const {
 
-  bool dAccessCtx =
+  bool dAccessCtx = 
     hasContext(AccessContext);
   bool dLval =
     hasContext(LValue);
@@ -1159,7 +1113,7 @@ ExpressionPtr Expression::getNextCanonCsePtr() const {
           shared_from_this()));
     dGlobals = a->isSuperGlobal() || a->isDynamicGlobal();
   }
-
+  
   // see rules below - no hope to find CSE candidate
   if (dExistCtx || dUnsetCtx || dGlobals || (!dAccessCtx && dLval)) {
     return ExpressionPtr();
@@ -1172,14 +1126,14 @@ ExpressionPtr Expression::getNextCanonCsePtr() const {
   for (; p; p = p->getCanonLVal()) {
     // check if p is a suitable candidate for CSE of
     // downstream. the rules are:
-    // A) rvals can always be CSE-ed regardless of access context,
+    // A) rvals can always be CSE-ed regardless of access context, 
     //    except for unset context, which it never can be CSE-ed for
     // B) lvals can only be CSE-ed if in AccessContext
     // C) rvals and lvals cannot be CSE-ed for each other
     // D) for now, ExistContext is not optimized
     // E) no CSE for $GLOBALS[...]
     // F) node types need to match
-
+    
     bool pLval = p->hasContext(LValue);
     KindOf pKindOf = p->getKindOf();
 
@@ -1216,13 +1170,13 @@ ExpressionPtr Expression::getCanonCsePtr() const {
   return ExpressionPtr();
 }
 
-bool Expression::preOutputCPPTemp(CodeGenerator &cg, AnalysisResultPtr ar,
+bool Expression::preOutputCPPTemp(CodeGenerator &cg, AnalysisResultPtr ar, 
     bool emitTemps) {
   ExpressionPtrVec temps;
   collectCPPTemps(temps);
   if (temps.empty()) return false;
   if (emitTemps) {
-    for (ExpressionPtrVec::iterator it(temps.begin());
+    for (ExpressionPtrVec::iterator it(temps.begin()); 
         it != temps.end();
         ++it) {
       ExpressionPtr p(*it);
@@ -1235,20 +1189,20 @@ bool Expression::preOutputCPPTemp(CodeGenerator &cg, AnalysisResultPtr ar,
       bool isString = t && t->is(Type::KindOfString);
       const char *s = isString ? "String" : "Variant";
       if (!isString) {
-        cg_printf("%s%s *%s%s;\n",
+        cg_printf("%s%s *%s%s;\n", 
                   useConst ? "const " : "",
                   s,
                   Option::CseTempVariablePrefix,
                   p->m_cppCseTemp.c_str());
         if (needsStorage) {
-          cg_printf("%s %s%s;\n",
-                    s,
+          cg_printf("%s %s%s;\n", 
+                    s, 
                     Option::CseTempStoragePrefix,
                     p->m_cppCseTemp.c_str());
         }
       } else {
-        cg_printf("%s %s%s;\n",
-                  s,
+        cg_printf("%s %s%s;\n", 
+                  s, 
                   Option::CseTempVariablePrefix,
                   p->m_cppCseTemp.c_str());
       }
@@ -1275,34 +1229,22 @@ bool Expression::getTypeCastPtrs(
   dstType = m_expectedType;
   if (m_implementedType && srcType &&
       !Type::SameType(m_implementedType, srcType)) {
+    if (dstType) {
+      if (!hasContext(LValue) &&
+          Type::IsCastNeeded(ar, m_implementedType, srcType) &&
+          !Type::IsCastNeeded(ar, m_implementedType, dstType) &&
+          !Type::SameType(m_implementedType, dstType) &&
+          !dstType->is(Type::KindOfAny) && !dstType->is(Type::KindOfSome)) {
+        dstType.reset();
+      }
+    }
     srcType = m_implementedType;
+    if (!dstType) dstType = m_actualType;
   }
   return dstType && srcType && ((m_context & LValue) == 0) &&
       Type::IsCastNeeded(ar, srcType, dstType);
 }
 
-bool Expression::needsFastCastTemp(AnalysisResultPtr ar) {
-  if (is(KindOfSimpleVariable)) return false;
-  if (!canUseFastCast(ar))      return false;
-  ASSERT(m_actualType);
-  return !m_actualType->isPrimitive();
-}
-
-bool Expression::canUseFastCast(AnalysisResultPtr ar) {
-  TypePtr srcType, dstType;
-  getTypeCastPtrs(ar, srcType, dstType);
-  // if the impl type is Variant and the actual type is known
-  // with a fast cast method, and we have a dst type that
-  // is not Variant (in CPP), then we have something to benefit
-  // from doing a fast cast and should emit one.
-  return m_implementedType &&
-         Type::IsMappedToVariant(m_implementedType) &&
-         m_actualType &&
-         Type::HasFastCastMethod(m_actualType) &&
-         dstType &&
-         !Type::IsMappedToVariant(dstType);
-}
-
 void Expression::outputCPPInternal(CodeGenerator &cg, AnalysisResultPtr ar) {
   if (hasError(Expression::BadPassByRef)) {
     cg_printf("throw_fatal(\"bad pass by reference\")");
@@ -1311,51 +1253,11 @@ void Expression::outputCPPInternal(CodeGenerator &cg, AnalysisResultPtr ar) {
   int closeParen = 0;
   TypePtr srcType, dstType;
   bool needsCast = getTypeCastPtrs(ar, srcType, dstType);
-
-  bool useFastCast = false;
-  bool isReferenced = true;
-  bool isLval = (m_context & LValue);
-  bool useVal = false;
-
-  if (canUseFastCast(ar)) {
-    useFastCast = true;
-    SimpleVariablePtr p(
-      dynamic_pointer_cast<SimpleVariable>(
-        shared_from_this()));
-    isReferenced = p ? p->couldBeAliased() : !isTemporary();
-    useVal = !p;
-  }
-
   if (needsCast) {
     ASSERT(dstType);
-    if (!useFastCast ||
-        !Type::SameType(m_actualType, dstType) ||
-        m_actualType->isSpecificObject()) {
-      if (useFastCast && m_actualType->isSpecificObject()) {
-        if (!Type::SameType(m_actualType, dstType)) {
-          dstType->outputCPPCast(cg, ar, getScope());
-          cg_printf("(");
-          closeParen++;
-        }
-
-        // specific object is special, since we do not have
-        // a fast cast method into a specific object on Variant,
-        // we must emit an additional (but also fast) cast.
-        // In the end, the cast will look like (for example):
-        //
-        //    (const X&)(v_var.asCObjRef())
-
-        cg_printf("(");
-        closeParen++;
-        m_actualType->outputCPPFastObjectCast(cg, ar, getScope(), !isLval, useVal);
-        cg_printf("(");
-        closeParen++;
-      } else {
-        dstType->outputCPPCast(cg, ar, getScope());
-        cg_printf("(");
-        closeParen++;
-      }
-    }
+    dstType->outputCPPCast(cg, ar, getScope());
+    cg_printf("(");
+    closeParen++;
   } else {
     if (hasContext(RefValue) && !hasContext(NoRefWrapper) &&
         isRefable()) {
@@ -1364,14 +1266,12 @@ void Expression::outputCPPInternal(CodeGenerator &cg, AnalysisResultPtr ar) {
       } else {
         cg_printf("ref(");
       }
-      useFastCast = false; // cannot ref() or strongBind() a non-variant
       closeParen++;
     }
     if (is(Expression::KindOfArrayElementExpression)) {
       if (((m_context & LValue) || ((m_context & RefValue) &&
                                     !(m_context & InvokeArgument))) &&
           !(m_context & NoLValueWrapper)) {
-        isLval = true;
         cg_printf("lval(");
         closeParen++;
       }
@@ -1383,16 +1283,16 @@ void Expression::outputCPPInternal(CodeGenerator &cg, AnalysisResultPtr ar) {
     TypePtr t;
     GetCseTempInfo(
         ar,
-        static_pointer_cast<Expression>(shared_from_this()),
+        static_pointer_cast<Expression>(shared_from_this()), 
         t);
     if (!t || !t->is(Type::KindOfString)) needsDeref = true;
     if (isChainRoot()) {
       if (!needsDeref) {
-        cg_printf("(%s%s = (",
+        cg_printf("(%s%s = (", 
             Option::CseTempVariablePrefix, m_cppCseTemp.c_str());
         closeParen += 2;
       } else {
-        cg_printf("(*(%s%s = &(",
+        cg_printf("(*(%s%s = &(", 
             Option::CseTempVariablePrefix, m_cppCseTemp.c_str());
         closeParen += 3;
       }
@@ -1401,20 +1301,13 @@ void Expression::outputCPPInternal(CodeGenerator &cg, AnalysisResultPtr ar) {
 
   if (hasCPPCseTemp() && !isChainRoot()) {
     if (needsDeref) cg_printf("(*");
-    cg_printf("%s%s",
+    cg_printf("%s%s", 
         Option::CseTempVariablePrefix, m_cppCseTemp.c_str());
     if (needsDeref) cg_printf(")");
   } else {
     outputCPPImpl(cg, ar);
   }
 
-  if (useFastCast) {
-    ASSERT(srcType == m_implementedType);
-    const string& method = Type::GetFastCastMethod(
-        m_actualType, isReferenced, !isLval, useVal);
-    cg_printf(".%s()", method.c_str());
-  }
-
   for (int i = 0; i < closeParen; i++) {
     cg_printf(")");
   }
diff --git a/src/compiler/expression/expression.h b/src/compiler/expression/expression.h
index a8cbb3af93..dbb0b35b3f 100644
--- a/src/compiler/expression/expression.h
+++ b/src/compiler/expression/expression.h
@@ -227,9 +227,9 @@ public:
   }
   ExpressionPtr getNextCanonCsePtr() const;
   ExpressionPtr getCanonCsePtr() const;
-  bool needsCSE() const {
+  bool needsCSE() const { 
     ExpressionPtr p(getCanonCsePtr());
-    return p && p->hasCPPCseTemp();
+    return p && p->hasCPPCseTemp(); 
   }
 
   /**
@@ -361,6 +361,7 @@ public:
   static bool GetCseTempInfo(
       AnalysisResultPtr ar, ExpressionPtr p, TypePtr &t);
 
+  void fixExpectedType(AnalysisResultConstPtr ar);
   bool outputCPPArithArg(CodeGenerator &cg, AnalysisResultPtr ar, bool arrayOk);
   bool isUnused() const { return m_unused; }
   void setUnused(bool u) { m_unused = u; }
@@ -399,15 +400,11 @@ protected:
  private:
   static ExprClass Classes[];
   void outputCPPInternal(CodeGenerator &cg, AnalysisResultPtr ar);
-
   /**
    * Returns true if a type cast is needed, and sets src/dst type
    */
   bool getTypeCastPtrs(
-      AnalysisResultPtr ar, TypePtr &srcType, TypePtr &dstType);
-
-  bool needsFastCastTemp(AnalysisResultPtr ar);
-  bool canUseFastCast(AnalysisResultPtr ar);
+      AnalysisResultPtr ar, TypePtr &srcType, TypePtr &dstType); 
 
   BlockScopeRawPtr m_originalScope;
   bool m_originalScopeSet;
diff --git a/src/compiler/expression/new_object_expression.cpp b/src/compiler/expression/new_object_expression.cpp
index 31353a4e6b..9bd8f21cba 100644
--- a/src/compiler/expression/new_object_expression.cpp
+++ b/src/compiler/expression/new_object_expression.cpp
@@ -78,11 +78,6 @@ void NewObjectExpression::analyzeProgram(AnalysisResultPtr ar) {
     if (m_params) {
       markRefParams(func, "", canInvokeFewArgs());
     }
-
-    TypePtr at(getActualType());
-    if (at && at->isSpecificObject() && !getExpectedType()) {
-      setExpectedType(at);
-    }
   }
 }
 
diff --git a/src/compiler/expression/object_method_expression.cpp b/src/compiler/expression/object_method_expression.cpp
index f7b85951c8..62853266a0 100644
--- a/src/compiler/expression/object_method_expression.cpp
+++ b/src/compiler/expression/object_method_expression.cpp
@@ -80,18 +80,6 @@ void ObjectMethodExpression::analyzeProgram(AnalysisResultPtr ar) {
 
     markRefParams(func, m_name, canInvokeFewArgs());
   }
-
-  // This is OK because AnalyzeFinal is guaranteed to run for a CPP
-  // target, regardless of opts (and we only need the following
-  // for CPP targets)
-  if (ar->getPhase() == AnalysisResult::AnalyzeFinal) {
-    // necessary because we set the expected type of m_object to
-    // Type::Some during type inference.
-    TypePtr act(m_object->getActualType());
-    if (!m_object->isThis() && act && act->is(Type::KindOfObject)) {
-      m_object->setExpectedType(act);
-    }
-  }
 }
 
 ConstructPtr ObjectMethodExpression::getNthKid(int n) const {
diff --git a/src/compiler/expression/scalar_expression.cpp b/src/compiler/expression/scalar_expression.cpp
index b1e2774370..9048272ec2 100644
--- a/src/compiler/expression/scalar_expression.cpp
+++ b/src/compiler/expression/scalar_expression.cpp
@@ -171,9 +171,8 @@ bool ScalarExpression::canonCompare(ExpressionPtr e) const {
 }
 
 ExpressionPtr ScalarExpression::postOptimize(AnalysisResultConstPtr ar) {
-  if (!m_expectedType || Type::SameType(m_actualType, m_expectedType)) {
+  if (!m_expectedType)
     return ExpressionPtr();
-  }
 
   Variant orig = getVariant();
   Variant cast;
@@ -186,11 +185,10 @@ ExpressionPtr ScalarExpression::postOptimize(AnalysisResultConstPtr ar) {
   case Type::KindOfString:  match = true; cast = orig.toString();  break;
   }
 
-  if (!match || same(orig, cast)) {
+  if (!match || same(orig, cast))
     // no changes need to be made
     return ExpressionPtr();
-  }
-
+  
   ExpressionPtr p = makeScalarExpression(ar, cast);
   p->setActualType(m_expectedType);
   return p;
diff --git a/src/compiler/expression/unary_op_expression.cpp b/src/compiler/expression/unary_op_expression.cpp
index e0b8f2d115..70c01c0c78 100644
--- a/src/compiler/expression/unary_op_expression.cpp
+++ b/src/compiler/expression/unary_op_expression.cpp
@@ -471,42 +471,14 @@ TypePtr UnaryOpExpression::inferTypes(AnalysisResultPtr ar, TypePtr type,
         rt = expType;
       }
       break;
-    case T_ISSET:
-    case T_EMPTY:
-      if (m_exp->is(Expression::KindOfExpressionList)) {
-        ExpressionListPtr exps =
-          dynamic_pointer_cast<ExpressionList>(m_exp);
-        if (exps->getListKind() == ExpressionList::ListKindParam) {
-          for (int i = 0; i < exps->getCount(); i++) {
-            SetExpTypeForExistsContext((*exps)[i], m_op == T_EMPTY);
-          }
-        }
-      } else {
-        SetExpTypeForExistsContext(m_exp, m_op == T_EMPTY);
-      }
-      break;
     default:
       break;
     }
   }
 
-  return rt;
-}
+  if (m_exp) m_exp->fixExpectedType(ar);
 
-void UnaryOpExpression::SetExpTypeForExistsContext(ExpressionPtr e,
-    bool allowPrimitives) {
-  if (!e) return;
-  TypePtr at(e->getActualType());
-  TypePtr it(e->getImplementedType());
-  if (at && it &&
-      Type::IsMappedToVariant(it) &&
-      ((allowPrimitives && Type::HasFastCastMethod(at)) ||
-       (!allowPrimitives &&
-        (at->is(Type::KindOfObject) ||
-         at->is(Type::KindOfArray) ||
-         at->is(Type::KindOfString))))) {
-    e->setExpectedType(at);
-  }
+  return rt;
 }
 
 ExpressionPtr UnaryOpExpression::unneededHelper() {
diff --git a/src/compiler/expression/unary_op_expression.h b/src/compiler/expression/unary_op_expression.h
index 940e85a054..9961e43f1c 100644
--- a/src/compiler/expression/unary_op_expression.h
+++ b/src/compiler/expression/unary_op_expression.h
@@ -64,8 +64,6 @@ private:
   bool preCompute(CVarRef value, Variant &result);
   void setExistContext();
   bool outputCPPImplOpEqual(CodeGenerator &cg, AnalysisResultPtr ar);
-
-  static void SetExpTypeForExistsContext(ExpressionPtr e, bool allowPrimitives);
 };
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/src/runtime/base/type_variant.cpp b/src/runtime/base/type_variant.cpp
index ec18083b67..de24cb99c9 100644
--- a/src/runtime/base/type_variant.cpp
+++ b/src/runtime/base/type_variant.cpp
@@ -842,7 +842,7 @@ Variant Variant::operator+(CVarRef var) const {
   }
   int na = is(KindOfArray) + var.is(KindOfArray);
   if (na == 2) {
-    return toCArrRef() + var.toCArrRef();
+    return toArray() + var.toArray();
   } else if (na) {
     throw BadArrayMergeException();
   }
@@ -2403,9 +2403,9 @@ head:
   }
   if (self->m_type == KindOfObject) {
     Variant *ret = &(self->getArrayAccess()->___offsetget_lval(key));
-    if (!blackHole) {
-      *tmp = *ret;
-      ret = tmp;
+    if (!blackHole) { 
+      *tmp = *ret; 
+      ret = tmp; 
     }
     return *ret;
   }
diff --git a/src/runtime/base/type_variant.h b/src/runtime/base/type_variant.h
index f008137887..d6cf59af53 100644
--- a/src/runtime/base/type_variant.h
+++ b/src/runtime/base/type_variant.h
@@ -197,169 +197,41 @@ class Variant {
    * Fast accessors that can be used by generated code when type inference can
    * prove that m_type will have a certain value at a given point in time
    */
-
-///////////////////////////////////////////////////////////////////////////////
-// int64
-
-  inline ALWAYS_INLINE int64 asInt64Val() const {
-    ASSERT(m_type == KindOfInt32 || m_type == KindOfInt64);
-    return m_data.num;
-  }
-
-  inline ALWAYS_INLINE int64 toInt64Val() const {
-    ASSERT(is(KindOfInt32) || is(KindOfInt64));
-    return
-        LIKELY(m_type == KindOfInt32 || m_type == KindOfInt64) ?
-        m_data.num : m_data.pvar->m_data.num;
-  }
-
-///////////////////////////////////////////////////////////////////////////////
-// double
-
-  inline ALWAYS_INLINE double asDoubleVal() const {
-    ASSERT(m_type == KindOfDouble);
-    return m_data.dbl;
-  }
-
-  inline ALWAYS_INLINE double toDoubleVal() const {
-    ASSERT(is(KindOfDouble));
-    return
-        LIKELY(m_type == KindOfDouble) ?
-        m_data.dbl : m_data.pvar->m_data.dbl;
-  }
-
-///////////////////////////////////////////////////////////////////////////////
-// boolean
-
-  inline ALWAYS_INLINE bool asBooleanVal() const {
-    ASSERT(m_type == KindOfBoolean);
-    return m_data.num;
-  }
-
-  inline ALWAYS_INLINE bool toBooleanVal() const {
-    ASSERT(is(KindOfBoolean));
-    return
-        LIKELY(m_type == KindOfBoolean) ?
-        m_data.num : m_data.pvar->m_data.num;
-  }
-
-///////////////////////////////////////////////////////////////////////////////
-// string
-
-  inline ALWAYS_INLINE const String & asCStrRef() const {
+  const String & asCStrRef() const {
     ASSERT(m_type == KindOfString || m_type == KindOfStaticString);
     return *(const String*)(this);
   }
 
-  inline ALWAYS_INLINE const String & toCStrRef() const {
-    ASSERT(is(KindOfString) || is(KindOfStaticString));
-    return *(const String*)(
-        LIKELY(m_type == KindOfString || m_type == KindOfStaticString) ?
-        this : this->m_data.pvar);
-  }
-
-  inline ALWAYS_INLINE String & asStrRef() {
+  String & asStrRef() {
     ASSERT(m_type == KindOfString || m_type == KindOfStaticString);
     return *(String*)(this);
   }
 
-  inline ALWAYS_INLINE String & toStrRef() {
-    ASSERT(is(KindOfString) || is(KindOfStaticString));
-    return *(String*)(
-        LIKELY(m_type == KindOfString || m_type == KindOfStaticString) ?
-        this : this->m_data.pvar);
-  }
-
-  inline ALWAYS_INLINE String asStrVal() const {
-    ASSERT(m_type == KindOfString || m_type == KindOfStaticString);
-    return String(this->m_data.pstr);
-  }
-
-  inline ALWAYS_INLINE String toStrVal() const {
-    ASSERT(is(KindOfString) || is(KindOfStaticString));
-    return String(
-        LIKELY(m_type == KindOfString || m_type == KindOfStaticString) ?
-        this->m_data.pstr : this->m_data.pvar->m_data.pstr);
-  }
-
-///////////////////////////////////////////////////////////////////////////////
-// array
-
-  inline ALWAYS_INLINE const Array & asCArrRef() const {
+  const Array & asCArrRef() const {
     ASSERT(m_type == KindOfArray);
     return *(const Array*)(this);
   }
 
-  inline ALWAYS_INLINE const Array & toCArrRef() const {
+  const Array & toCArrRef() const {
     ASSERT(is(KindOfArray));
-    return *(const Array*)(
-        LIKELY(m_type == KindOfArray) ?
-        this : this->m_data.pvar);
+    return *(Array*)(LIKELY(m_type == KindOfArray) ? this : this->m_data.pvar);
   }
 
-  inline ALWAYS_INLINE Array & asArrRef() {
+  Array & asArrRef() {
     ASSERT(m_type == KindOfArray);
     return *(Array*)(this);
   }
 
-  inline ALWAYS_INLINE Array & toArrRef() {
-    ASSERT(is(KindOfArray));
-    return *(Array*)(
-        LIKELY(m_type == KindOfArray) ?
-        this : this->m_data.pvar);
-  }
-
-  inline ALWAYS_INLINE Array asArrVal() const {
-    ASSERT(m_type == KindOfArray);
-    return Array(this->m_data.parr);
-  }
-
-  inline ALWAYS_INLINE Array toArrVal() const {
-    ASSERT(is(KindOfArray));
-    return Array(
-        LIKELY(m_type == KindOfArray) ?
-        this->m_data.parr : this->m_data.pvar->m_data.parr);
-  }
-
-///////////////////////////////////////////////////////////////////////////////
-// object
-
-  inline ALWAYS_INLINE const Object & asCObjRef() const {
+  const Object & asCObjRef() const {
     ASSERT(m_type == KindOfObject);
     return *(const Object*)(this);
   }
 
-  inline ALWAYS_INLINE const Object & toCObjRef() const {
-    ASSERT(is(KindOfObject));
-    return *(const Object*)(
-        LIKELY(m_type == KindOfObject) ?
-        this : this->m_data.pvar);
-  }
-
-  inline ALWAYS_INLINE Object & asObjRef() {
+  Object & asObjRef() {
     ASSERT(m_type == KindOfObject);
     return *(Object*)(this);
   }
 
-  inline ALWAYS_INLINE Object & toObjRef() {
-    ASSERT(is(KindOfObject));
-    return *(Object*)(
-        LIKELY(m_type == KindOfObject) ?
-        this : this->m_data.pvar);
-  }
-
-  inline ALWAYS_INLINE Object asObjVal() const {
-    ASSERT(m_type == KindOfObject);
-    return Object(this->m_data.pobj);
-  }
-
-  inline ALWAYS_INLINE Object toObjVal() const {
-    ASSERT(is(KindOfObject));
-    return Object(
-        LIKELY(m_type == KindOfObject) ?
-        this->m_data.pobj : this->m_data.pvar->m_data.pobj);
-  }
-
   ObjectData *objectForCall() const {
     if (m_type == KindOfObject) return m_data.pobj;
     if (m_type == KindOfVariant) {

