commit 0810b51170570ed21cae56b8131db6a5e3efa584
Author: Robert Schedel <r.schedel@yahoo.de>
Date:   Tue Jun 23 11:26:48 2009 +0200

    HID: Support new variants of Samsung USB IR receiver (0419:0001)
    
    This patch extends the existing Samsung IrDA (0419:0001) quirk file with newly
    reported variants:
    
    * New device variants with 203 byte and 135 byte report descriptors were
      reported to be recognized incorrectly. This patch adds an autodetection for
      those two, using report descriptor size to enable new quirks.
    
    * Any other unknown 0419:0001 variants will now be treated without any quirk
      flags (i.e. IGNORE_HIDINPUT/HIDDEV_FORCE will not be set by default anymore).
    
    More details:
    
    1. Descriptor size 184 bytes ("Satelco bundled remote")
    Already supported since kernel 2.6.25 (my old patch).
    
    2. Descriptor size 203 bytes ("Optronix remote")
    This receiver mostly works with the regular HID input driver. Only when some
    keys are released, another spurious key press event is interpreted due to
    incorrect array ranges. According to HID 1.11, section 6.2.2.5, arrays should
    return a 0 value when no control is asserted, and ranges should go from 1 to
    the number of elements. The patch clips the value with a logical range from
    1..15 (instead of originally 0..18).
    
    Ticket with more information available at
    https://bugs.launchpad.net/bugs/326986
    
    3. Descriptor size 135 bytes ("Gotview remote")
    This receiver has a similar issue than the previous one, i.e. it mostly works
    with regular HID input, except some key press events get stuck on key release.
    The patch clips the array value from 1..14 (instead of originally 0..17).
    
    Ticket with more information available at
    http://bugs.archlinux.org/task/15216
    
    4. Other unknown variants (found one report with 218 bytes,
       but no further information about issues)
    
    For such unknown variants we should refrain from changing any device flags.
    Currently, HIDINPUT is suppressed and HIDDEV is enforced (because in 2.6.25 the
    quirk table did not yet allow differentiating variants and we
    did not expect variants either). Now we should be as strict as
    possible and enable it only for the first variant above.
    
    Signed-off-by: Robert Schedel <r.schedel@yahoo.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/hid/hid-samsung.c b/drivers/hid/hid-samsung.c
index 07083aa6c19a..ba91d9485ad0 100644
--- a/drivers/hid/hid-samsung.c
+++ b/drivers/hid/hid-samsung.c
@@ -25,25 +25,48 @@
 /*
  * Samsung IrDA remote controller (reports as Cypress USB Mouse).
  *
+ * There are several variants for 0419:0001:
+ *
+ * 1. 184 byte report descriptor
  * Vendor specific report #4 has a size of 48 bit,
  * and therefore is not accepted when inspecting the descriptors.
  * As a workaround we reinterpret the report as:
  *   Variable type, count 6, size 8 bit, log. maximum 255
  * The burden to reconstruct the data is moved into user space.
+ *
+ * 2. 203 byte report descriptor
+ * Report #4 has an array field with logical range 0..18 instead of 1..15.
+ *
+ * 3. 135 byte report descriptor
+ * Report #4 has an array field with logical range 0..17 instead of 1..14.
  */
 static void samsung_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 		unsigned int rsize)
 {
-	if (rsize >= 182 && rdesc[175] == 0x25 && rdesc[176] == 0x40 &&
+	if (rsize == 184 && rdesc[175] == 0x25 && rdesc[176] == 0x40 &&
 			rdesc[177] == 0x75 && rdesc[178] == 0x30 &&
 			rdesc[179] == 0x95 && rdesc[180] == 0x01 &&
 			rdesc[182] == 0x40) {
-		dev_info(&hdev->dev, "fixing up Samsung IrDA report "
-				"descriptor\n");
+		dev_info(&hdev->dev, "fixing up Samsung IrDA %d byte report "
+				"descriptor\n", 184);
 		rdesc[176] = 0xff;
 		rdesc[178] = 0x08;
 		rdesc[180] = 0x06;
 		rdesc[182] = 0x42;
+	} else
+	if (rsize == 203 && rdesc[192] == 0x15 && rdesc[193] == 0x0 &&
+			rdesc[194] == 0x25 && rdesc[195] == 0x12) {
+		dev_info(&hdev->dev, "fixing up Samsung IrDA %d byte report "
+				"descriptor\n", 203);
+		rdesc[193] = 0x1;
+		rdesc[195] = 0xf;
+	} else
+	if (rsize == 135 && rdesc[124] == 0x15 && rdesc[125] == 0x0 &&
+			rdesc[126] == 0x25 && rdesc[127] == 0x11) {
+		dev_info(&hdev->dev, "fixing up Samsung IrDA %d byte report "
+				"descriptor\n", 135);
+		rdesc[125] = 0x1;
+		rdesc[127] = 0xe;
 	}
 }
 
@@ -51,6 +74,7 @@ static int samsung_probe(struct hid_device *hdev,
 		const struct hid_device_id *id)
 {
 	int ret;
+	unsigned int cmask = HID_CONNECT_DEFAULT;
 
 	ret = hid_parse(hdev);
 	if (ret) {
@@ -58,8 +82,13 @@ static int samsung_probe(struct hid_device *hdev,
 		goto err_free;
 	}
 
-	ret = hid_hw_start(hdev, (HID_CONNECT_DEFAULT & ~HID_CONNECT_HIDINPUT) |
-			HID_CONNECT_HIDDEV_FORCE);
+	if (hdev->rsize == 184) {
+		/* disable hidinput, force hiddev */
+		cmask = (cmask & ~HID_CONNECT_HIDINPUT) |
+			HID_CONNECT_HIDDEV_FORCE;
+	}
+
+	ret = hid_hw_start(hdev, cmask);
 	if (ret) {
 		dev_err(&hdev->dev, "hw start failed\n");
 		goto err_free;

