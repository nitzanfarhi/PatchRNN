commit 7120dc028920834b6eff505a3673497ef5f43f72
Author: Frederik Deweerdt <fdeweerdt@fastly.com>
Date:   Thu Aug 25 13:07:42 2016 -0700

    http/1 chunk error handling
    
    - Have `encode_data_header_and_consume_window` update the write buffer
    size. This fixes a bug in the previous code where the `RST_STREAM` frame
    would actually overwrite the DATA because the size update was done
    outside of the function.
    - Remove `is_eos`, since `send_state` has all the information we need.
    This fixes a bug where we wouldn't send a `RST_STREAM` in pull mode.

diff --git a/lib/http2/stream.c b/lib/http2/stream.c
index 4465ff80..1ddf3dd1 100644
--- a/lib/http2/stream.c
+++ b/lib/http2/stream.c
@@ -112,16 +112,22 @@ static size_t calc_max_payload_size(h2o_http2_conn_t *conn, h2o_http2_stream_t *
     return sz_min(sz_min(conn_max, stream_max), conn->peer_settings.max_frame_size);
 }
 
-static void encode_data_header_and_consume_window(h2o_http2_conn_t *conn, h2o_http2_stream_t *stream, uint8_t *header,
-                                                  size_t length, h2o_send_state_t send_state, int is_eos)
+static void encode_data_header_and_consume_window(h2o_http2_conn_t *conn, h2o_http2_stream_t *stream, h2o_buffer_t **outbuf,
+                                                  size_t length, h2o_send_state_t send_state)
 {
-    assert(header != NULL);
-    header = h2o_http2_encode_frame_header(header, length, H2O_HTTP2_FRAME_TYPE_DATA, is_eos ? H2O_HTTP2_FRAME_FLAG_END_STREAM : 0,
-                                            stream->stream_id);
-    h2o_http2_window_consume_window(&conn->_write.window, length);
-    h2o_http2_window_consume_window(&stream->output_window, length);
-    if (is_eos && send_state == H2O_SEND_STATE_ERROR) {
-        h2o_http2_encode_rst_stream_frame(&conn->_write.buf, stream->stream_id, -H2O_HTTP2_ERROR_PROTOCOL);
+    assert(outbuf != NULL);
+    /* send a DATA frame if there's data or the END_STREAM flag to send */
+    if (length || send_state == H2O_SEND_STATE_FINAL) {
+        h2o_http2_encode_frame_header((void *)((*outbuf)->bytes + (*outbuf)->size), length,
+                                      H2O_HTTP2_FRAME_TYPE_DATA, send_state == H2O_SEND_STATE_FINAL ? H2O_HTTP2_FRAME_FLAG_END_STREAM : 0,
+                                      stream->stream_id);
+        h2o_http2_window_consume_window(&conn->_write.window, length);
+        h2o_http2_window_consume_window(&stream->output_window, length);
+        (*outbuf)->size += length + H2O_HTTP2_FRAME_HEADER_SIZE;
+    }
+    /* send a RST_STREAM if there's an error */
+    if (send_state == H2O_SEND_STATE_ERROR) {
+        h2o_http2_encode_rst_stream_frame(outbuf, stream->stream_id, -H2O_HTTP2_ERROR_PROTOCOL);
     }
 }
 
@@ -140,10 +146,7 @@ static h2o_send_state_t send_data_pull(h2o_http2_conn_t *conn, h2o_http2_stream_
     cbuf.len = max_payload_size;
     send_state = h2o_pull(&stream->req, stream->_pull_cb, &cbuf);
     /* write the header */
-    encode_data_header_and_consume_window(conn, stream, (void *)(conn->_write.buf->bytes + conn->_write.buf->size), cbuf.len,
-                                          send_state, send_state == H2O_SEND_STATE_FINAL);
-    /* adjust the write buf size */
-    conn->_write.buf->size += H2O_HTTP2_FRAME_HEADER_SIZE + cbuf.len;
+    encode_data_header_and_consume_window(conn, stream, &conn->_write.buf, cbuf.len, send_state);
 
 Exit:
     return send_state;
@@ -190,10 +193,10 @@ static h2o_iovec_t *send_data_push(h2o_http2_conn_t *conn, h2o_http2_stream_t *s
     /* commit the DATA frame if we have actually emitted payload */
     if (dst.len != max_payload_size || !h2o_send_state_is_in_progress(send_state)) {
         size_t payload_len = max_payload_size - dst.len;
-        encode_data_header_and_consume_window(conn, stream, (uint8_t *)conn->_write.buf->bytes + conn->_write.buf->size,
-                                              payload_len, send_state,
-                                              stream->state >= H2O_HTTP2_STREAM_STATE_SEND_BODY_IS_FINAL && bufcnt == 0);
-        conn->_write.buf->size += H2O_HTTP2_FRAME_HEADER_SIZE + payload_len;
+        if (bufcnt != 0 && send_state == H2O_SEND_STATE_FINAL) {
+            send_state = H2O_SEND_STATE_IN_PROGRESS;
+        }
+        encode_data_header_and_consume_window(conn, stream, &conn->_write.buf, payload_len, send_state);
     }
 
 Exit:

