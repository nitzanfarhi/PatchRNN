commit cde6901b7b69557a6f90f3183f76eda581af015e
Author: Shaddy Baddah <shaddy_baddah@hotmail.com>
Date:   Fri Nov 28 17:10:45 2008 +1100

    zd1211rw: use unaligned safe memcmp() in-place of compare_ether_addr()
    
    Under my 2.6.28-rc6 sparc64, when associating to an AP through my
    zd1211rw device, I was seeing kernel log messages like (not exact output):
    
      Kernel unaligned access at TPC[10129b68] zd_mac_rx+0x144/0x32c [zd1211rw]
    
    For the zd1211rw module, on RX, the 80211 packet will be located after
    the PLCP header in the skb data buffer. The PLCP header being 5 bytes
    long, the 80211 header will start unaligned from an aligned skb
    buffer.
    
    As per Documentation/unaligned-memory-access.txt, we must replace the
    not unaligned() safe compare_ether_addr() with memcmp() to protect
    architectures that require alignment.
    
    Signed-off-by: Shaddy Baddah <shaddy_baddah@hotmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/zd1211rw/zd_mac.c b/drivers/net/wireless/zd1211rw/zd_mac.c
index fe1867b25ff7..cac732f4047f 100644
--- a/drivers/net/wireless/zd1211rw/zd_mac.c
+++ b/drivers/net/wireless/zd1211rw/zd_mac.c
@@ -615,7 +615,7 @@ static int filter_ack(struct ieee80211_hw *hw, struct ieee80211_hdr *rx_hdr,
 		struct ieee80211_hdr *tx_hdr;
 
 		tx_hdr = (struct ieee80211_hdr *)skb->data;
-		if (likely(!compare_ether_addr(tx_hdr->addr2, rx_hdr->addr1)))
+		if (likely(!memcmp(tx_hdr->addr2, rx_hdr->addr1, ETH_ALEN)))
 		{
 			__skb_unlink(skb, q);
 			tx_status(hw, skb, IEEE80211_TX_STAT_ACK, stats->signal, 1);

