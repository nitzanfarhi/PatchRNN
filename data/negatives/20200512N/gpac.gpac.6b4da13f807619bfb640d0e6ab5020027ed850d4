commit 6b4da13f807619bfb640d0e6ab5020027ed850d4
Author: Jean Le Feuvre <jeanlf@users.sourceforge.net>
Date:   Tue Dec 4 19:11:29 2012 +0000

    Fixed bug in DASH client when using constant availabilityStartTime in live cases
    
    git-svn-id: http://svn.code.sf.net/p/gpac/code/trunk/gpac@4256 63c20433-aa62-49bd-875c-5a186b69a8fb

diff --git a/include/gpac/dash.h b/include/gpac/dash.h
index 2f865cf8b..02cbbcc9f 100644
--- a/include/gpac/dash.h
+++ b/include/gpac/dash.h
@@ -209,6 +209,8 @@ void gf_dash_seek(GF_DashClient *dash, Double start_range);
 Double gf_dash_get_playback_start_range(GF_DashClient *dash);
 /*when seeking, this flag is set when the seek is outside of the previously playing segment.*/
 Bool gf_dash_group_segment_switch_forced(GF_DashClient *dash, u32 idx);
+/*get video info for this group if video*/
+GF_Err gf_dash_group_get_video_info(GF_DashClient *dash, u32 idx, u32 *max_width, u32 *max_height);
 
 /*returns the start_time of the first segment in the queue (usually the one being played)*/
 Double gf_dash_group_current_segment_start_time(GF_DashClient *dash, u32 idx);
diff --git a/include/gpac/modules/service.h b/include/gpac/modules/service.h
index 388079fb0..e0b0575ac 100644
--- a/include/gpac/modules/service.h
+++ b/include/gpac/modules/service.h
@@ -94,6 +94,9 @@ typedef enum
 	GF_NET_SERVICE_INFO,
 	/*checks if there is an audio stream in the service - term->net only*/
 	GF_NET_SERVICE_HAS_AUDIO,
+
+	/*checks if there is a forced video size  - if yes, info is stored in GF_NetComPixelAR - term->net only*/
+	GF_NET_SERVICE_HAS_FORCED_VIDEO_SIZE,
 	/*instructs the service to get the migration info - term->net only*/
 	GF_NET_SERVICE_MIGRATION_INFO,
 
diff --git a/modules/mpd_in/mpd_in.c b/modules/mpd_in/mpd_in.c
index 9187bb27d..f82b8f519 100644
--- a/modules/mpd_in/mpd_in.c
+++ b/modules/mpd_in/mpd_in.c
@@ -45,6 +45,8 @@ typedef struct __mpd_module
 	Bool connection_ack_sent;
 	Bool in_seek;
     Double previous_start_range;
+	/*max width & height in all active representations*/
+	u32 width, height;
 } GF_MPD_In;
 
 typedef struct 
@@ -404,8 +406,7 @@ GF_Err mpdin_dash_io_on_dash_event(GF_DASHFileIO *dashio, GF_DASHEventType dash_
 
 		/*select input services if possible*/
 		for (i=0; i<gf_dash_get_group_count(mpdin->dash); i++) {
-			const char *mime, *init_segment;
-			
+			const char *mime, *init_segment;			
 			if (!gf_dash_is_group_selected(mpdin->dash, i))
 				continue;
 
@@ -422,7 +423,14 @@ GF_Err mpdin_dash_io_on_dash_event(GF_DASHFileIO *dashio, GF_DASHEventType dash_
 					GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[MPD_IN] Unable to connect input service to %s\n", init_segment));
 					gf_dash_group_select(mpdin->dash, i, 0);
 				} else {
+					u32 w, h;
 					group->service_connected = 1;
+					w = h = 0;
+					gf_dash_group_get_video_info(mpdin->dash, i, &w, &h);
+					if (w && h && w>mpdin->width && h>mpdin->height) {
+						mpdin->width = w;
+						mpdin->height = h;
+					}
 				}
 			}
 		}
@@ -615,6 +623,11 @@ GF_Err MPD_ServiceCommand(GF_InputService *plug, GF_NetworkCommand *com)
 		}
         return GF_NOT_SUPPORTED;
 
+	case GF_NET_SERVICE_HAS_FORCED_VIDEO_SIZE:
+		com->par.width = mpdin->width;
+		com->par.height = mpdin->height;
+        return GF_OK;
+
 	case GF_NET_SERVICE_QUALITY_SWITCH:
 		gf_dash_switch_quality(mpdin->dash, com->switch_quality.up);
         return GF_OK;
diff --git a/src/export.cpp b/src/export.cpp
index a816312f3..ddb824d92 100644
--- a/src/export.cpp
+++ b/src/export.cpp
@@ -1738,6 +1738,8 @@
 #pragma comment (linker, EXPORT_SYMBOL(gf_dash_group_segment_switch_forced) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_dash_group_current_segment_start_time) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_dash_group_get_presentation_time_offset) )
+#pragma comment (linker, EXPORT_SYMBOL(gf_dash_group_get_video_info) )
+
 
 #endif
 
diff --git a/src/media_tools/dash_client.c b/src/media_tools/dash_client.c
index 3336f9eec..9a39eeb07 100644
--- a/src/media_tools/dash_client.c
+++ b/src/media_tools/dash_client.c
@@ -30,6 +30,10 @@
 #include <gpac/internal/m3u8.h>
 #include <string.h>
 
+#ifndef _WIN32_WCE
+#include <time.h>
+#endif
+
 #ifndef GPAC_DISABLE_DASH_CLIENT
 
 /*set to 1 if you want MPD to use SegmentTemplate if possible instead of SegmentList*/
@@ -135,6 +139,8 @@ struct __dash_group
 
 	u32 prev_active_rep_index;
 
+	Bool timeline_setup;
+
 	GF_DASHGroupSelection selection;
 
 
@@ -775,6 +781,7 @@ static u32 gf_dash_purge_segment_timeline(GF_DASH_Group *group, Double min_start
 static GF_Err gf_dash_update_manifest(GF_DashClient *dash)
 {
 	GF_Err e;
+	u64 previous_availability_start_time;
 	u32 group_idx, rep_idx, i, j;
 	GF_DOMParser *mpd_parser;
 	GF_MPD_Period *period, *new_period;
@@ -825,6 +832,7 @@ static GF_Err gf_dash_update_manifest(GF_DashClient *dash)
 			purl = update_url;
 		}
 	}
+	previous_availability_start_time = dash->mpd->availabilityStartTime;
 
 	GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Updating Playlist %s...\n", purl ? purl : local_url));
 	if (purl) {
@@ -935,6 +943,11 @@ static GF_Err gf_dash_update_manifest(GF_DashClient *dash)
 				for (group_idx=0; group_idx<gf_list_count(dash->groups); group_idx++) {
 					GF_MPD_AdaptationSet *set, *new_set;
 					GF_DASH_Group *group = gf_list_get(dash->groups, group_idx);
+
+					if (previous_availability_start_time != dash->mpd->availabilityStartTime) {
+						group->timeline_setup = 0;
+					}
+
 					if (group->selection != GF_DASH_GROUP_SELECTED) continue;
 					set = group->adaptation_set;
 					new_set = gf_list_get(new_period->adaptation_sets, group_idx);
@@ -1225,6 +1238,59 @@ GF_Err gf_dash_resolve_url(GF_MPD *mpd, GF_MPD_Representation *rep, GF_DASH_Grou
 	*out_range_start = *out_range_end = 0;
 	*out_url = NULL;
 
+
+	/*todo for live - check we don't attempt to request segments before their availabilityStartTime !*/
+	if (!group->timeline_setup) {
+		u32 sec, frac;
+#ifndef _WIN32_WCE
+		time_t gtime;
+		struct tm *_t;
+#endif
+		u64 current_time;
+		gf_net_get_ntp(&sec, &frac);
+
+#ifndef _WIN32_WCE
+		gtime = sec - GF_NTP_SEC_1900_TO_1970;
+		_t = gmtime(&gtime);
+		current_time = mktime(_t);
+#else
+		current_time = sec - GF_NTP_SEC_1900_TO_1970;
+#endif
+		if (current_time < mpd->availabilityStartTime) current_time = 0;
+		else current_time -= mpd->availabilityStartTime;
+
+		if (current_time < group->period->start) current_time = 0;
+		else current_time -= group->period->start;
+
+#if 0
+		{
+			s32 diff = (s32) current_time - (s32) (mpd->media_presentation_duration/1000);
+			if (ABS(diff)>10) {
+				GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Broken UTC timing in client or server - got Media URL is not set in segment list\n"));
+					
+			}
+			current_time = mpd->media_presentation_duration/1000;
+		}
+#endif
+
+		frac = mpd->time_shift_buffer_depth/1000;
+		if (current_time < frac) current_time = 0;
+		else current_time -= frac;
+
+
+		if (segment_duration) {
+			Double nb_seg = (Double) current_time;
+			nb_seg /= group->segment_duration;
+			frac = (u32) nb_seg;
+			group->download_segment_index = frac;
+			group->nb_segments_in_rep = frac + 10;
+		} else {
+			GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Segment duration unknown - cannot estimate current startNumber\n"));
+		}
+		group->timeline_setup = 1;
+	}
+
+
 	/*resolve base URLs from document base (download location) to representation (media)*/
 	url = gf_strdup(mpd_url);
 
@@ -1882,8 +1948,14 @@ GF_Err gf_dash_setup_groups(GF_DashClient *dash)
 		for (j=0; j<gf_list_count(set->representations); j++) {
 			Double dur;
 			u32 nb_seg;
-			gf_dash_get_segment_duration(gf_list_get(set->representations, j), set, period, dash->mpd, &nb_seg, &dur);
+			GF_MPD_Representation *rep = gf_list_get(set->representations, j);
+			gf_dash_get_segment_duration(rep, set, period, dash->mpd, &nb_seg, &dur);
 			if (dur>seg_dur) seg_dur = dur;
+
+			if (rep->width>set->max_width) {
+				set->max_width = rep->width;
+				set->max_height = rep->height;
+			}
 		}
 
 		if (!seg_dur) {
@@ -2205,7 +2277,6 @@ restart_period:
 			}
 			gf_mx_p(dash->dl_mutex);
 
-			/*todo for live - check we don't attempt to request segments before their availabilityStartTime !*/
 
 			/* At this stage, there are some segments left to be downloaded */
 			e = gf_dash_resolve_url(dash->mpd, rep, group, dash->base_url, GF_DASH_RESOLVE_URL_MEDIA, group->download_segment_index, &new_base_seg_url, &start_range, &end_range, &group->current_downloaded_segment_duration);
@@ -2827,42 +2898,63 @@ void gf_dash_switch_quality(GF_DashClient *dash, Bool switch_up)
 {
 	u32 i;
 	for (i=0; i<gf_list_count(dash->groups); i++) {
-		Bool do_switch = 0;
+		u32 switch_to_rep_idx = 0;
+		u32 bandwidth, quality, k;
+		GF_MPD_Representation *rep, *active_rep;
 		GF_DASH_Group *group = gf_list_get(dash->groups, i);
 		u32 current_idx = group->active_rep_index;
 		if (group->selection != GF_DASH_GROUP_SELECTED) continue;
 
 		if (group->force_representation_idx_plus_one) current_idx = group->force_representation_idx_plus_one - 1;
-		if (switch_up) {
-			if (current_idx + 1 < gf_list_count(group->adaptation_set->representations)) {
-				group->force_representation_idx_plus_one = 1 + current_idx+1;
-				do_switch = 1;
-			}
-		} else {
-			if (current_idx) {
-				group->force_representation_idx_plus_one = 1 + current_idx - 1;
-				do_switch = 1;
+
+		active_rep = gf_list_get(group->adaptation_set->representations, current_idx);
+		if (!active_rep) continue;
+		bandwidth = switch_up ? active_rep->bandwidth : 0;
+		quality = switch_up ? active_rep->quality_ranking : 0;
+
+		for (k=0; k<gf_list_count(group->adaptation_set->representations); k++) {
+			rep = gf_list_get(group->adaptation_set->representations, k);
+			if (switch_up) {
+				if ((rep->quality_ranking>active_rep->quality_ranking) || (rep->bandwidth>active_rep->bandwidth)) {
+					if ((rep->quality_ranking < quality) || (rep->bandwidth < bandwidth)) {
+						bandwidth = rep->bandwidth;
+						quality = rep->quality_ranking;
+						switch_to_rep_idx = k+1;
+					}
+				}
+			} else {
+				if ((rep->quality_ranking < active_rep->quality_ranking) || (rep->bandwidth < active_rep->bandwidth)) {
+					if ((rep->quality_ranking > quality) || (rep->bandwidth > bandwidth)) {
+						bandwidth = rep->bandwidth;
+						quality = rep->quality_ranking;
+						switch_to_rep_idx = k+1;
+					}
+				}
 			}
 		}
-		if (do_switch) {
+		if (switch_to_rep_idx && (switch_to_rep_idx-1 != current_idx) ) {
 			gf_mx_p(dash->dl_mutex);
 			group->force_switch_bandwidth = 1;
-			/*in local playback just switch at the end of the current segment
-			for remote, we should let the user decide*/
-			while (group->nb_cached_segments>1) {
-				group->nb_cached_segments--;
-				gf_free(group->cached[group->nb_cached_segments].url);
-				group->cached[group->nb_cached_segments].url = NULL;
-				if (!group->local_files && group->cached[group->nb_cached_segments].cache) {
-					gf_delete_file( group->cached[group->nb_cached_segments].cache );
-					gf_free(group->cached[group->nb_cached_segments].cache);
-					group->cached[group->nb_cached_segments].cache = NULL;
+			group->force_representation_idx_plus_one = switch_to_rep_idx;
+
+			if (group->local_files) {
+				/*in local playback just switch at the end of the current segment
+				for remote, we should let the user decide*/
+				while (group->nb_cached_segments>1) {
+					group->nb_cached_segments--;
+					gf_free(group->cached[group->nb_cached_segments].url);
+					group->cached[group->nb_cached_segments].url = NULL;
+					if (!group->local_files && group->cached[group->nb_cached_segments].cache) {
+						gf_delete_file( group->cached[group->nb_cached_segments].cache );
+						gf_free(group->cached[group->nb_cached_segments].cache);
+						group->cached[group->nb_cached_segments].cache = NULL;
+					}
+					group->cached[group->nb_cached_segments].representation_index = 0;
+					group->cached[group->nb_cached_segments].start_range = 0;
+					group->cached[group->nb_cached_segments].end_range = 0;
+					assert(group->download_segment_index>1);
+					group->download_segment_index--;
 				}
-				group->cached[group->nb_cached_segments].representation_index = 0;
-				group->cached[group->nb_cached_segments].start_range = 0;
-				group->cached[group->nb_cached_segments].end_range = 0;
-				assert(group->download_segment_index>1);
-				group->download_segment_index--;
 			}
 			gf_mx_v(dash->dl_mutex);
 		}
@@ -3149,5 +3241,17 @@ Double gf_dash_group_current_segment_start_time(GF_DashClient *dash, u32 idx)
 	return gf_dash_get_segment_start_time(group);
 }
 
+GF_EXPORT
+GF_Err gf_dash_group_get_video_info(GF_DashClient *dash, u32 idx, u32 *max_width, u32 *max_height)
+{
+	GF_DASH_Group *group = gf_list_get(dash->groups, idx);
+	if (!group || !max_width || !max_height) return GF_BAD_PARAM;
+
+	*max_width = group->adaptation_set->max_width;
+	*max_height = group->adaptation_set->max_height;
+	return GF_OK;
+}
+
+
 #endif //GPAC_DISABLE_DASH_CLIENT
 
diff --git a/src/terminal/scene.c b/src/terminal/scene.c
index 64cfe1ff9..7d1bea099 100644
--- a/src/terminal/scene.c
+++ b/src/terminal/scene.c
@@ -1372,7 +1372,15 @@ void gf_scene_force_size(GF_Scene *scene, u32 width, u32 height)
 	gf_sg_set_scene_size_info(scene->graph, width, height, gf_sg_use_pixel_metrics(scene->graph));
 	
 	if (scene->root_od->term->root_scene == scene) {
+		GF_NetworkCommand com;
 		gf_sc_set_scene(scene->root_od->term->compositor, scene->graph);
+
+		memset(&com, 0, sizeof(GF_NetworkCommand));
+		com.base.command_type = GF_NET_SERVICE_HAS_FORCED_VIDEO_SIZE;
+		gf_term_service_command(scene->root_od->net_service, &com);
+		if (com.par.width && com.par.height) {
+			gf_sc_set_size(scene->root_od->term->compositor, com.par.width, com.par.height);
+		}
 	}
 	else if (scene->root_od->parentscene && scene->root_od->parentscene->is_dynamic_scene) {
 		gf_sg_set_scene_size_info(scene->root_od->parentscene->graph, width, height, gf_sg_use_pixel_metrics(scene->root_od->parentscene->graph));

