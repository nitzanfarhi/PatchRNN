commit 9e724af83709c443358e753cc5dd4b6ee80d4e83
Author: Bron Gondwana <brong@opera.com>
Date:   Mon Sep 20 10:55:49 2010 +1000

    Tidy up mailbox_close usage to ensure no double-close

diff --git a/imap/mboxlist.c b/imap/mboxlist.c
index e1b21a51c..5f804507b 100644
--- a/imap/mboxlist.c
+++ b/imap/mboxlist.c
@@ -1204,8 +1204,7 @@ int mboxlist_setacl(const char *name, const char *identifier,
     int myrights;
     int mode = ACL_MODE_SET;
     int isusermbox = 0, anyoneuseracl = 1;
-    struct mailbox *mailbox;
-    int mailbox_open = 0;
+    struct mailbox *mailbox = NULL;
     char *newacl = NULL;
     char *mboxent = NULL;
     struct txn *tid = NULL;
@@ -1282,7 +1281,6 @@ int mboxlist_setacl(const char *name, const char *identifier,
         r = mailbox_open_iwl(name, &mailbox);
 
 	if (!r) {
-	    mailbox_open = 1;
 	    do {
 		/* lookup the mailbox to make sure it exists and get its acl */
 		r = mboxlist_mylookup(name, &mbentry, &tid, 1);
@@ -1406,7 +1404,7 @@ int mboxlist_setacl(const char *name, const char *identifier,
 		   cyrusdb_strerror(r2));
 	}
     }
-    if (mailbox_open) mailbox_close(&mailbox);
+    if (mailbox) mailbox_close(&mailbox);
     if (mboxent) free(mboxent);
     if (newacl) free(newacl);
 
@@ -2300,38 +2298,33 @@ static int mboxlist_rmquota(const char *name,
 			    int maycreate __attribute__((unused)),
 			    void *rock)
 {
-    int r;
-    struct mailbox *mailbox;
+    int r = 0;
+    struct mailbox *mailbox = NULL;
     const char *oldroot = (const char *) rock;
 
-    assert(rock != NULL);
+    assert(oldroot != NULL);
 
     r = mailbox_open_iwl(name, &mailbox);
-    if (r) goto error_noclose;
+    if (r) goto done;
 
     if (mailbox->quotaroot) {
-	if (strlen(mailbox->quotaroot) != strlen(oldroot)
-	    || strcmp(mailbox->quotaroot, oldroot)) {
+	if (strcmp(mailbox->quotaroot, oldroot)) {
 	    /* Part of a different quota root */
-	    mailbox_close(&mailbox);
-	    return 0;
+	    goto done;
 	}
 
 	mailbox_set_quotaroot(mailbox, NULL);
-
 	r = mailbox_commit(mailbox);
-	if (r) goto error;
     }
 
-    mailbox_close(&mailbox);
-    return 0;
+ done:
+    if (mailbox) mailbox_close(&mailbox);
+    if (r) {
+	syslog(LOG_ERR, "LOSTQUOTA: unable to remove quota root %s for %s: %s",
+	       oldroot, name, error_message(r));
+    }
 
- error:
-    mailbox_close(&mailbox);
- error_noclose:
-    syslog(LOG_ERR, "LOSTQUOTA: unable to remove quota root %s for %s: %s",
-	   oldroot, name, error_message(r));
-    
+    /* not a huge tragedy if we failed, so always return success */
     return 0;
 }
 
@@ -2347,26 +2340,27 @@ static int mboxlist_changequota(const char *name,
     int r;
     struct mailbox *mailbox;
     struct change_rock *crock = (struct change_rock *) rock;
-    struct quota *newquota = crock->quota;
+    struct quota *newquota;
     struct quota q;
     struct txn **tid = crock->tid;
 
-    assert(rock != NULL);
+    assert(crock);
+    newquota = crock->quota;
+    assert(newquota);
 
     r = mailbox_open_iwl(name, &mailbox);
-    if (r) goto error_noclose;
+    if (r) goto done;
 
     if (mailbox->quotaroot) {
 	if (strlen(mailbox->quotaroot) >= strlen(newquota->root)) {
 	    /* Part of a child quota root - skip */
-	    mailbox_close(&mailbox);
-	    return 0;
+	    goto done;
 	}
 
 	/* remove usage from the old quotaroot */
 	q.root = mailbox->quotaroot;
 	r = quota_read(&q, tid, 1);
-	if (r) goto error;
+	if (r) goto done;
 	if (q.used >= mailbox->i.quota_mailbox_used) {
 	    q.used -= mailbox->i.quota_mailbox_used;
 	}
@@ -2385,18 +2379,18 @@ static int mboxlist_changequota(const char *name,
     /* update (or set) the quotaroot */
     mailbox_set_quotaroot(mailbox, newquota->root);
     r = mailbox_commit(mailbox);
-    if (r) goto error;
+    if (r) goto done;
 
     /* track this mailbox's usage */
     newquota->used += mailbox->i.quota_mailbox_used;
 
- error:
-    mailbox_close(&mailbox);
+ done:
+    if (mailbox) mailbox_close(&mailbox);
 
- error_noclose:
-    if (r)
+    if (r) {
 	syslog(LOG_ERR, "LOSTQUOTA: unable to change quota root for %s to %s: %s",
 	       name, newquota->root, error_message(r));
+    }
 
     /* Note, we're a callback, and it's not a huge tragedy if we
      * fail, so we don't ever return a failure */
diff --git a/imap/sync_client.c b/imap/sync_client.c
index e134f1d1f..1bffe283f 100644
--- a/imap/sync_client.c
+++ b/imap/sync_client.c
@@ -233,6 +233,8 @@ static int find_reserve_all(struct sync_name_list *mboxname_list,
 	    goto bail;
 	}
 
+	/* mailbox is open from here, no exiting without closing it! */
+
 	part_list = sync_reserve_partlist(reserve_guids, mailbox->part);
 
 	sync_folder_list_add(master_folders, mailbox->uniqueid, mailbox->name, 
@@ -991,19 +993,18 @@ static int mailbox_full_update(const char *mboxname)
     uint32_t recno;
     unsigned old_num_records;
     struct index_record mrecord, rrecord;
-    struct mailbox *mailbox;
+    struct mailbox *mailbox = NULL;
     int r;
-    struct dlist *kin;
-    struct dlist *ki;
-    struct dlist *kr;
-    struct dlist *ka;
-    struct dlist *kuids;
+    struct dlist *kin = NULL;
+    struct dlist *ki = NULL;
+    struct dlist *kr = NULL;
+    struct dlist *ka = NULL;
+    struct dlist *kuids = NULL;
     struct dlist *kl = NULL;
     struct dlist *kaction = NULL;
     struct dlist *kexpunge = NULL;
     modseq_t highestmodseq;
     uint32_t last_uid;
-    int mboxopen = 0;
 
     kl = dlist_atom(NULL, cmd, mboxname);
     sync_send_lookup(kl, sync_out);
@@ -1015,21 +1016,10 @@ static int mailbox_full_update(const char *mboxname)
     kl = kin->head;
 
     if (!kl) {
-	dlist_free(&kin);
-	return IMAP_MAILBOX_NONEXISTENT;
+	r = IMAP_MAILBOX_NONEXISTENT;
+	goto done;
     }
 
-    /* we'll probably be updating it! */
-    r = mailbox_open_iwl(mboxname, &mailbox);
-    if (r) goto done;
-    mboxopen = 1;
-
-    /* re-calculate our local CRC just in case it's out of sync */
-    r = mailbox_index_recalc(mailbox);
-    if (r) goto done;
-
-    old_num_records = mailbox->i.num_records;
-
     /* XXX - handle the header.  I want to do some ordering on timestamps
      * in particular here - if there's more recent data on the replica then
      * it should be copied back.  This depends on having a nice way to
@@ -1038,14 +1028,30 @@ static int mailbox_full_update(const char *mboxname)
      * doesn't really matter too much, because we'll blat the replica's
      * values anyway! */
 
-    if (!dlist_getmodseq(kl, "HIGHESTMODSEQ", &highestmodseq))
-	return IMAP_PROTOCOL_BAD_PARAMETERS;
+    if (!dlist_getmodseq(kl, "HIGHESTMODSEQ", &highestmodseq)) {
+	r = IMAP_PROTOCOL_BAD_PARAMETERS;
+	goto done;
+    }
 
-    if (!dlist_getnum(kl, "LAST_UID", &last_uid))
-	return IMAP_PROTOCOL_BAD_PARAMETERS;
+    if (!dlist_getnum(kl, "LAST_UID", &last_uid)) {
+	r = IMAP_PROTOCOL_BAD_PARAMETERS;
+	goto done;
+    }
 
-    if (!dlist_getlist(kl, "RECORD", &kr))
-	return IMAP_PROTOCOL_BAD_PARAMETERS;
+    if (!dlist_getlist(kl, "RECORD", &kr)) {
+	r = IMAP_PROTOCOL_BAD_PARAMETERS;
+	goto done;
+    }
+
+    /* we'll be updating it! */
+    r = mailbox_open_iwl(mboxname, &mailbox);
+    if (r) goto done;
+
+    /* re-calculate our local CRC just in case it's out of sync */
+    r = mailbox_index_recalc(mailbox);
+    if (r) goto done;
+
+    old_num_records = mailbox->i.num_records;
 
     if (mailbox->i.highestmodseq < highestmodseq) {
 	/* highestmodseq on replica is dirty - we must go to at least one higher! */
@@ -1148,11 +1154,11 @@ static int mailbox_full_update(const char *mboxname)
 	}
     }
 
-    /* close the mailbox before sending any expunges to avoid deadlocks */
+    /* commit and close the mailbox before sending any expunges
+     * to avoid deadlocks */
     r = mailbox_commit(mailbox);
-    mailbox_close(&mailbox);
-    mboxopen = 0;
     if (r) goto done;
+    mailbox_close(&mailbox);
 
     /* only send expunge if we have some UIDs to expunge */
     if (kuids->head) {
@@ -1161,7 +1167,8 @@ static int mailbox_full_update(const char *mboxname)
     }
 
 done:
-    if (mboxopen) mailbox_close(&mailbox);
+    if (mailbox) mailbox_close(&mailbox);
+    dlist_free(&kin);
     dlist_free(&kaction);
     dlist_free(&kexpunge);
     return r;
@@ -1256,9 +1263,9 @@ static int update_mailbox(struct sync_folder *local,
     return r;
 
 done:
+    if (mailbox) mailbox_close(&mailbox);
     dlist_free(&kupload);
     dlist_free(&kl);
-    mailbox_close(&mailbox);
     return r;
 }
 

