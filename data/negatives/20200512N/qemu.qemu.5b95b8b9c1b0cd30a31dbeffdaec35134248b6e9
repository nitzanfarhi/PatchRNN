commit 5b95b8b9c1b0cd30a31dbeffdaec35134248b6e9
Author: Alexander Graf <agraf@suse.de>
Date:   Thu Jan 17 11:54:38 2013 +0100

    PPC: KVM: Add support for EPR with KVM
    
    This patch links KVM EPR support to the existing TCG support we have now.
    
    Signed-off-by: Alexander Graf <agraf@suse.de>

diff --git a/hw/ppc.c b/hw/ppc.c
index 1fce604c73..c52e22f708 100644
--- a/hw/ppc.c
+++ b/hw/ppc.c
@@ -435,7 +435,13 @@ void ppce500_set_mpic_proxy(bool enabled)
     CPUPPCState *env;
 
     for (env = first_cpu; env != NULL; env = env->next_cpu) {
+        PowerPCCPU *cpu = ppc_env_get_cpu(env);
+        CPUState *cs = CPU(cpu);
+
         env->mpic_proxy = enabled;
+        if (kvm_enabled()) {
+            kvmppc_set_mpic_proxy(POWERPC_CPU(cs), enabled);
+        }
     }
 }
 
diff --git a/target-ppc/kvm.c b/target-ppc/kvm.c
index 19e9f25b19..2f4f06818a 100644
--- a/target-ppc/kvm.c
+++ b/target-ppc/kvm.c
@@ -846,6 +846,11 @@ int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)
         ret = 0;
         break;
 #endif
+    case KVM_EXIT_EPR:
+        dprintf("handle epr\n");
+        run->epr.epr = ldl_phys(env->mpic_iack);
+        ret = 0;
+        break;
     default:
         fprintf(stderr, "KVM: unknown exit reason %d\n", run->exit_reason);
         ret = -1;
@@ -1057,6 +1062,22 @@ void kvmppc_set_papr(PowerPCCPU *cpu)
     }
 }
 
+void kvmppc_set_mpic_proxy(PowerPCCPU *cpu, int mpic_proxy)
+{
+    CPUPPCState *env = &cpu->env;
+    CPUState *cs = CPU(cpu);
+    struct kvm_enable_cap cap = {};
+    int ret;
+
+    cap.cap = KVM_CAP_PPC_EPR;
+    cap.args[0] = mpic_proxy;
+    ret = kvm_vcpu_ioctl(cs, KVM_ENABLE_CAP, &cap);
+
+    if (ret && mpic_proxy) {
+        cpu_abort(env, "This KVM version does not support EPR\n");
+    }
+}
+
 int kvmppc_smt_threads(void)
 {
     return cap_ppc_smt ? cap_ppc_smt : 1;
diff --git a/target-ppc/kvm_ppc.h b/target-ppc/kvm_ppc.h
index 3db21fc889..c30b006674 100644
--- a/target-ppc/kvm_ppc.h
+++ b/target-ppc/kvm_ppc.h
@@ -25,6 +25,7 @@ int kvmppc_get_hasidle(CPUPPCState *env);
 int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len);
 int kvmppc_set_interrupt(PowerPCCPU *cpu, int irq, int level);
 void kvmppc_set_papr(PowerPCCPU *cpu);
+void kvmppc_set_mpic_proxy(PowerPCCPU *cpu, int mpic_proxy);
 int kvmppc_smt_threads(void);
 #ifndef CONFIG_USER_ONLY
 off_t kvmppc_alloc_rma(const char *name, MemoryRegion *sysmem);
@@ -81,6 +82,10 @@ static inline void kvmppc_set_papr(PowerPCCPU *cpu)
 {
 }
 
+static inline void kvmppc_set_mpic_proxy(PowerPCCPU *cpu, int mpic_proxy)
+{
+}
+
 static inline int kvmppc_smt_threads(void)
 {
     return 1;

