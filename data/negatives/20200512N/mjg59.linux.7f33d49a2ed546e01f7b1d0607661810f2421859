commit 7f33d49a2ed546e01f7b1d0607661810f2421859
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Jun 16 15:32:41 2009 -0700

    mm, PM/Freezer: Disable OOM killer when tasks are frozen
    
    Currently, the following scenario appears to be possible in theory:
    
    * Tasks are frozen for hibernation or suspend.
    * Free pages are almost exhausted.
    * Certain piece of code in the suspend code path attempts to allocate
      some memory using GFP_KERNEL and allocation order less than or
      equal to PAGE_ALLOC_COSTLY_ORDER.
    * __alloc_pages_internal() cannot find a free page so it invokes the
      OOM killer.
    * The OOM killer attempts to kill a task, but the task is frozen, so
      it doesn't die immediately.
    * __alloc_pages_internal() jumps to 'restart', unsuccessfully tries
      to find a free page and invokes the OOM killer.
    * No progress can be made.
    
    Although it is now hard to trigger during hibernation due to the memory
    shrinking carried out by the hibernation code, it is theoretically
    possible to trigger during suspend after the memory shrinking has been
    removed from that code path.  Moreover, since memory allocations are
    going to be used for the hibernation memory shrinking, it will be even
    more likely to happen during hibernation.
    
    To prevent it from happening, introduce the oom_killer_disabled switch
    that will cause __alloc_pages_internal() to fail in the situations in
    which the OOM killer would have been called and make the freezer set
    this switch after tasks have been successfully frozen.
    
    [akpm@linux-foundation.org: be nicer to the namespace]
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Fengguang Wu <fengguang.wu@gmail.com>
    Cc: David Rientjes <rientjes@google.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Cc: Mel Gorman <mel@csn.ul.ie>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/gfp.h b/include/linux/gfp.h
index 4efa33088a82..06b7e8cc80ac 100644
--- a/include/linux/gfp.h
+++ b/include/linux/gfp.h
@@ -243,4 +243,16 @@ void drain_zone_pages(struct zone *zone, struct per_cpu_pages *pcp);
 void drain_all_pages(void);
 void drain_local_pages(void *dummy);
 
+extern bool oom_killer_disabled;
+
+static inline void oom_killer_disable(void)
+{
+	oom_killer_disabled = true;
+}
+
+static inline void oom_killer_enable(void)
+{
+	oom_killer_disabled = false;
+}
+
 #endif /* __LINUX_GFP_H */
diff --git a/kernel/power/process.c b/kernel/power/process.c
index ca634019497a..da2072d73811 100644
--- a/kernel/power/process.c
+++ b/kernel/power/process.c
@@ -117,9 +117,12 @@ int freeze_processes(void)
 	if (error)
 		goto Exit;
 	printk("done.");
+
+	oom_killer_disable();
  Exit:
 	BUG_ON(in_atomic());
 	printk("\n");
+
 	return error;
 }
 
@@ -145,6 +148,8 @@ static void thaw_tasks(bool nosig_only)
 
 void thaw_processes(void)
 {
+	oom_killer_enable();
+
 	printk("Restarting tasks ... ");
 	thaw_tasks(true);
 	thaw_tasks(false);
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 61290ea721c8..5b09488d0f55 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -178,6 +178,8 @@ static void set_pageblock_migratetype(struct page *page, int migratetype)
 					PB_migrate, PB_migrate_end);
 }
 
+bool oom_killer_disabled __read_mostly;
+
 #ifdef CONFIG_DEBUG_VM
 static int page_outside_zone_boundaries(struct zone *zone, struct page *page)
 {
@@ -1769,6 +1771,8 @@ rebalance:
 	 */
 	if (!did_some_progress) {
 		if ((gfp_mask & __GFP_FS) && !(gfp_mask & __GFP_NORETRY)) {
+			if (oom_killer_disabled)
+				goto nopage;
 			page = __alloc_pages_may_oom(gfp_mask, order,
 					zonelist, high_zoneidx,
 					nodemask, preferred_zone,

