commit a51e91981870d013fcfcc08b0117997edbcbc7a7
Author: Dario Faggioli <raistlin@linux.it>
Date:   Thu Mar 24 14:00:18 2011 +0100

    sched: Leave sched_setscheduler() earlier if possible, do not disturb SCHED_FIFO tasks
    
    sched_setscheduler() (in sched.c) is called in order of changing the
    scheduling policy and/or the real-time priority of a task. Thus,
    if we find out that neither of those are actually being modified, it
    is possible to return earlier and save the overhead of a full
    deactivate+activate cycle of the task in question.
    
    Beside that, if we have more than one SCHED_FIFO task with the same
    priority on the same rq (which means they share the same priority queue)
    having one of them changing its position in the priority queue because of
    a sched_setscheduler (as it happens by means of the deactivate+activate)
    that does not actually change the priority violates POSIX which states,
    for SCHED_FIFO:
    
      "If a thread whose policy or priority has been modified by
       pthread_setschedprio() is a running thread or is runnable, the effect on
       its position in the thread list depends on the direction of the
       modification, as follows: a. <...> b. If the priority is unchanged, the
       thread does not change position in the thread list. c. <...>"
    
         http://pubs.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_08.html
    
     (ed: And the POSIX specification here does, briefly and somewhat unexpectedly,
          match what common sense tells us as well. )
    
    Signed-off-by: Dario Faggioli <raistlin@linux.it>
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    LKML-Reference: <1300971618.3960.82.camel@Palantir>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/sched.c b/kernel/sched.c
index f592ce6f8616..a8845516ace6 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -5011,6 +5011,17 @@ static int __sched_setscheduler(struct task_struct *p, int policy,
 		return -EINVAL;
 	}
 
+	/*
+	 * If not changing anything there's no need to proceed further:
+	 */
+	if (unlikely(policy == p->policy && (!rt_policy(policy) ||
+			param->sched_priority == p->rt_priority))) {
+
+		__task_rq_unlock(rq);
+		raw_spin_unlock_irqrestore(&p->pi_lock, flags);
+		return 0;
+	}
+
 #ifdef CONFIG_RT_GROUP_SCHED
 	if (user) {
 		/*

