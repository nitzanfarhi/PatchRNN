commit bfe2425aadc92071392cc339229270f563a22216
Author: unknown <ingo@mysql.com>
Date:   Thu May 6 15:53:01 2004 +0200

    WL#1687 - Optimize UNION DISTINCT ... UNION ALL (again).
    HEAP: Copies the key count to a backup variable and sets the key count to zero.
    That way, no HEAP function will ever try to touch any index.
    Re-enabling is done by copying back the backup variable.
    To avoid memory leak at table close, disable deletes all index trees.
    Re-enabling must be done with empty indexes and data anyway. Otherwise,
    the indexes would need to be repaired, wich HEAP is not capable of.
    MyISAM: Only the key_map is cleared and set.
    Re-enabling must be done with empty indexes and data. Otherwise, repair needs
    to be done which will enable all keys persistently.
    The former implementation disabled only non-unique keys and maked this persistent.
    The new implementation additionally can disable all keys, but only without
    making this persistent. Re-enabling all keys can be done without repair,
    if data file and indexes are empty.
    
    
    heap/heapdef.h:
      WL#1687 - Optimize UNION DISTINCT ... UNION ALL (again).
      Pulled hp_clear_keys() out of hp_clear().
    heap/hp_clear.c:
      WL#1687 - Optimize UNION DISTINCT ... UNION ALL (again).
      Pulled hp_clear_keys() out of hp_clear().
      Added the new functions for disabling and enabling keys and to ask for the key state.
    include/heap.h:
      WL#1687 - Optimize UNION DISTINCT ... UNION ALL (again).
      Added a new HP_SHARE element to save the key count while keys are disabled.
      Added declarations for the new functions.
    myisam/mi_open.c:
      WL#1687 - Optimize UNION DISTINCT ... UNION ALL (again).
      Added the new functions for disabling and enabling keys and to ask for the key state.
    myisam/myisamdef.h:
      WL#1687 - Optimize UNION DISTINCT ... UNION ALL (again).
      Added declarations for the new functions.
    sql/ha_heap.cc:
      WL#1687 - Optimize UNION DISTINCT ... UNION ALL (again).
      Pulled set_keys_for_scanning() out of open().
      Added the new functions for disabling and enabling keys and to ask for the key state.
    sql/ha_heap.h:
      WL#1687 - Optimize UNION DISTINCT ... UNION ALL (again).
      Added declarations for the new functions.
    sql/ha_myisam.cc:
      WL#1687 - Optimize UNION DISTINCT ... UNION ALL (again).
      Extended disable_indexes() for all keys and no save.
      The argument is now 'mode' as it must handle different cases.
      Extended enable_indexes() for no save.
      The new feature needs the new argument 'mode' with the same semantics as in disable_indexes().
      Added indexes_are_disabled() to ask for the key state.
      Extended the existing call to enable_indexes() by the new argument.
    sql/ha_myisam.h:
      WL#1687 - Optimize UNION DISTINCT ... UNION ALL (again).
      Modified the declarations of dis-/enable_indexes() for the new argument.
      Added the declaration of the new function to ask for the key state.
    sql/handler.h:
      WL#1687 - Optimize UNION DISTINCT ... UNION ALL (again).
      Added declarations for the operation modes for the key switching functions.
      Modified the declarations of dis-/enable_indexes() for the new argument.
      Added the declaration of the new function to ask for the key state.
    sql/sql_select.cc:
      WL#1687 - Optimize UNION DISTINCT ... UNION ALL (again).
      In create_myisam_from_heap() take notice of disabled keys
      and disable them in the new table before copying the data.
    sql/sql_table.cc:
      WL#1687 - Optimize UNION DISTINCT ... UNION ALL (again).
      Modified the calls of dis-/enable_indexes() for the new argument.

diff --git a/heap/heapdef.h b/heap/heapdef.h
index 63109badb05..083765334ab 100644
--- a/heap/heapdef.h
+++ b/heap/heapdef.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
+/* Copyright (C) 2000,2004 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -97,6 +97,7 @@ extern uint hp_rb_null_key_length(HP_KEYDEF *keydef, const byte *key);
 extern my_bool hp_if_null_in_key(HP_KEYDEF *keyinfo, const byte *record);
 extern int hp_close(register HP_INFO *info);
 extern void hp_clear(HP_SHARE *info);
+extern void hp_clear_keys(HP_SHARE *info);
 extern uint hp_rb_pack_key(HP_KEYDEF *keydef, uchar *key, const uchar *old, 
 			   uint k_len);
 #ifdef THREAD
diff --git a/heap/hp_clear.c b/heap/hp_clear.c
index e65d3a172c3..4440344f990 100644
--- a/heap/hp_clear.c
+++ b/heap/hp_clear.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
+/* Copyright (C) 2000,2004 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -29,13 +29,60 @@ void heap_clear(HP_INFO *info)
 
 void hp_clear(HP_SHARE *info)
 {
-  uint key;
   DBUG_ENTER("hp_clear");
 
   if (info->block.levels)
     VOID(hp_free_level(&info->block,info->block.levels,info->block.root,
 			(byte*) 0));
   info->block.levels=0;
+  hp_clear_keys(info);
+  info->records=info->deleted=info->data_length=0;
+  info->blength=1;
+  info->changed=0;
+  info->del_link=0;
+  DBUG_VOID_RETURN;
+}
+
+
+/*
+  Clear all keys.
+
+  SYNOPSIS
+    heap_clear_keys()
+    info      A pointer to the heap storage engine HP_INFO struct.
+
+  DESCRIPTION
+    Delete all trees of all indexes and leave them empty.
+
+  RETURN
+    void
+*/
+
+void heap_clear_keys(HP_INFO *info)
+{
+  hp_clear(info->s);
+}
+
+
+/*
+  Clear all keys.
+
+  SYNOPSIS
+    hp_clear_keys()
+    info      A pointer to the heap storage engine HP_SHARE struct.
+
+  DESCRIPTION
+    Delete all trees of all indexes and leave them empty.
+
+  RETURN
+    void
+*/
+
+void hp_clear_keys(HP_SHARE *info)
+{
+  uint key;
+  DBUG_ENTER("hp_clear_keys");
+
   for (key=0 ; key < info->keys ; key++)
   {
     HP_KEYDEF *keyinfo = info->keydef + key;
@@ -52,9 +99,95 @@ void hp_clear(HP_SHARE *info)
       block->last_allocated=0;
     }
   }
-  info->records=info->deleted=info->data_length=info->index_length=0;
-  info->blength=1;
-  info->changed=0;
-  info->del_link=0;
+  info->index_length=0;
   DBUG_VOID_RETURN;
 }
+
+
+/*
+  Disable all indexes.
+
+  SYNOPSIS
+    heap_disable_indexes()
+    info      A pointer to the heap storage engine HP_INFO struct.
+
+  DESCRIPTION
+    Disable and clear (remove contents of) all indexes.
+
+  RETURN
+    0  ok
+*/
+
+int heap_disable_indexes(HP_INFO *info)
+{
+  HP_SHARE *share= info->s;
+
+  if (share->keys)
+  {
+    hp_clear_keys(share);
+    share->currently_disabled_keys= share->keys;
+    share->keys= 0;
+  }
+  return 0;
+}
+
+
+/*
+  Enable all indexes
+
+  SYNOPSIS
+    heap_enable_indexes()
+    info      A pointer to the heap storage engine HP_INFO struct.
+
+  DESCRIPTION
+    Enable all indexes. The indexes might have been disabled
+    by heap_disable_index() before.
+    The function works only if both data and indexes are empty,
+    since the heap storage engine cannot repair the indexes.
+    To be sure, call handler::delete_all_rows() before.
+
+  RETURN
+    0  ok
+    HA_ERR_CRASHED data or index is non-empty.
+*/
+
+int heap_enable_indexes(HP_INFO *info)
+{
+  int error= 0;
+  HP_SHARE *share= info->s;
+
+  if (share->data_length || share->index_length)
+    error= HA_ERR_CRASHED;
+  else
+    if (share->currently_disabled_keys)
+    {
+      share->keys= share->currently_disabled_keys;
+      share->currently_disabled_keys= 0;
+    }
+  return error;
+}
+
+
+/*
+  Test if indexes are disabled.
+
+  SYNOPSIS
+    heap_indexes_are_disabled()
+    info      A pointer to the heap storage engine HP_INFO struct.
+
+  DESCRIPTION
+    Test if indexes are disabled.
+
+  RETURN
+    0  indexes are not disabled
+    1  all indexes are disabled
+   [2  non-unique indexes are disabled - NOT YET IMPLEMENTED]
+*/
+
+int heap_indexes_are_disabled(HP_INFO *info)
+{
+  HP_SHARE *share= info->s;
+
+  return (! share->keys && share->currently_disabled_keys);
+}
+
diff --git a/include/heap.h b/include/heap.h
index c5f2be81fb7..b536937c8c0 100644
--- a/include/heap.h
+++ b/include/heap.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 MySQL AB
+/* Copyright (C) 2000,2004 MySQL AB
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -107,6 +107,7 @@ typedef struct st_heap_share
   uint reclength;			/* Length of one record */
   uint changed;
   uint keys,max_key_length;
+  uint currently_disabled_keys;    /* saved value from "keys" when disabled */
   uint open_count;
   byte *del_link;			/* Link to next block with del. rec */
   my_string name;			/* Name of "memory-file" */
@@ -176,6 +177,10 @@ extern int heap_rprev(HP_INFO *info,byte *record);
 extern int heap_rfirst(HP_INFO *info,byte *record,int inx);
 extern int heap_rlast(HP_INFO *info,byte *record,int inx);
 extern void heap_clear(HP_INFO *info);
+extern void heap_clear_keys(HP_INFO *info);
+extern int heap_disable_indexes(HP_INFO *info);
+extern int heap_enable_indexes(HP_INFO *info);
+extern int heap_indexes_are_disabled(HP_INFO *info);
 extern void heap_update_auto_increment(HP_INFO *info, const byte *record);
 ha_rows hp_rb_records_in_range(HP_INFO *info, int inx, const byte *start_key,
 			       uint start_key_len,
diff --git a/myisam/mi_open.c b/myisam/mi_open.c
index 2c4661c4d3e..53cf87b24b4 100644
--- a/myisam/mi_open.c
+++ b/myisam/mi_open.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
+/* Copyright (C) 2000,2004 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1151,3 +1151,84 @@ int mi_open_keyfile(MYISAM_SHARE *share)
     return 1;
   return 0;
 }
+
+
+/*
+  Disable all indexes.
+
+  SYNOPSIS
+    mi_disable_indexes()
+    info        A pointer to the MyISAM storage engine MI_INFO struct.
+
+  DESCRIPTION
+    Disable all indexes.
+
+  RETURN
+    0  ok
+*/
+
+int mi_disable_indexes(MI_INFO *info)
+{
+  MYISAM_SHARE *share= info->s;
+
+  share->state.key_map= 0;
+  return 0;
+}
+
+
+/*
+  Enable all indexes
+
+  SYNOPSIS
+    mi_enable_indexes()
+    info        A pointer to the MyISAM storage engine MI_INFO struct.
+
+  DESCRIPTION
+    Enable all indexes. The indexes might have been disabled
+    by mi_disable_index() before.
+    The function works only if both data and indexes are empty,
+    otherwise a repair is required.
+    To be sure, call handler::delete_all_rows() before.
+
+  RETURN
+    0  ok
+    HA_ERR_CRASHED data or index is non-empty.
+*/
+
+int mi_enable_indexes(MI_INFO *info)
+{
+  int error= 0;
+  MYISAM_SHARE *share= info->s;
+
+  if (share->state.state.data_file_length ||
+      (share->state.state.key_file_length != share->base.keystart))
+    error= HA_ERR_CRASHED;
+  else
+    share->state.key_map= ((ulonglong) 1L << share->base.keys) - 1;
+  return error;
+}
+
+
+/*
+  Test if indexes are disabled.
+
+  SYNOPSIS
+    mi_indexes_are_disabled()
+    info        A pointer to the MyISAM storage engine MI_INFO struct.
+
+  DESCRIPTION
+    Test if indexes are disabled.
+
+  RETURN
+    0  indexes are not disabled
+    1  all indexes are disabled
+   [2  non-unique indexes are disabled - NOT YET IMPLEMENTED]
+*/
+
+int mi_indexes_are_disabled(MI_INFO *info)
+{
+  MYISAM_SHARE *share= info->s;
+
+  return (! share->state.key_map && share->base.keys);
+}
+
diff --git a/myisam/myisamdef.h b/myisam/myisamdef.h
index 0f43fe7fb61..1f100590049 100644
--- a/myisam/myisamdef.h
+++ b/myisam/myisamdef.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
+/* Copyright (C) 2000,2004 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -684,6 +684,9 @@ uint mi_uniquedef_write(File file, MI_UNIQUEDEF *keydef);
 char *mi_uniquedef_read(char *ptr, MI_UNIQUEDEF *keydef);
 uint mi_recinfo_write(File file, MI_COLUMNDEF *recinfo);
 char *mi_recinfo_read(char *ptr, MI_COLUMNDEF *recinfo);
+extern int mi_disable_indexes(MI_INFO *info);
+extern int mi_enable_indexes(MI_INFO *info);
+extern int mi_indexes_are_disabled(MI_INFO *info);
 ulong _my_calc_total_blob_length(MI_INFO *info, const byte *record);
 ha_checksum mi_checksum(MI_INFO *info, const byte *buf);
 ha_checksum mi_static_checksum(MI_INFO *info, const byte *buf);
diff --git a/sql/ha_heap.cc b/sql/ha_heap.cc
index 47978d647ec..12b922e6fc0 100644
--- a/sql/ha_heap.cc
+++ b/sql/ha_heap.cc
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
+/* Copyright (C) 2000,2004 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -47,12 +47,7 @@ int ha_heap::open(const char *name, int mode, uint test_if_locked)
   if (file)
   {
     /* Initialize variables for the opened table */
-    btree_keys.clear_all();
-    for (uint i= 0 ; i < table->keys ; i++)
-    {
-      if (table->key_info[i].algorithm == HA_KEY_ALG_BTREE)
-	btree_keys.set_bit(i);
-    }
+    set_keys_for_scanning();
   }
   return (file ? 0 : 1);
 }
@@ -62,6 +57,33 @@ int ha_heap::close(void)
   return heap_close(file);
 }
 
+
+/*
+  Compute which keys to use for scanning
+
+  SYNOPSIS
+    set_keys_for_scanning()
+    no parameter
+
+  DESCRIPTION
+    Set the bitmap btree_keys, which is used when the upper layers ask
+    which keys to use for scanning. For each btree index the
+    corresponding bit is set.
+
+  RETURN
+    void
+*/
+
+void ha_heap::set_keys_for_scanning(void)
+{
+  btree_keys.clear_all();
+  for (uint i= 0 ; i < table->keys ; i++)
+  {
+    if (table->key_info[i].algorithm == HA_KEY_ALG_BTREE)
+      btree_keys.set_bit(i);
+  }
+}
+
 int ha_heap::write_row(byte * buf)
 {
   statistic_increment(ha_write_count,&LOCK_status);
@@ -207,6 +229,114 @@ int ha_heap::external_lock(THD *thd, int lock_type)
   return 0;					// No external locking
 }
 
+
+/*
+  Disable indexes.
+
+  SYNOPSIS
+    disable_indexes()
+    mode        mode of operation:
+                HA_KEY_SWITCH_NONUNIQ      disable all non-unique keys
+                HA_KEY_SWITCH_ALL          disable all keys
+                HA_KEY_SWITCH_NONUNIQ_SAVE dis. non-uni. and make persistent
+                HA_KEY_SWITCH_ALL_SAVE     dis. all keys and make persistent
+
+  DESCRIPTION
+    Disable indexes and clear keys to use for scanning.
+
+  IMPLEMENTATION
+    HA_KEY_SWITCH_NONUNIQ       is not implemented.
+    HA_KEY_SWITCH_NONUNIQ_SAVE  is not implemented with HEAP.
+    HA_KEY_SWITCH_ALL_SAVE      is not implemented with HEAP.
+
+  RETURN
+    0  ok
+    HA_ERR_WRONG_COMMAND  mode not implemented.
+*/
+
+int ha_heap::disable_indexes(uint mode)
+{
+  int error;
+
+  if (mode == HA_KEY_SWITCH_ALL)
+  {
+    if (!(error= heap_disable_indexes(file)))
+      set_keys_for_scanning();
+  }
+  else
+  {
+    /* mode not implemented */
+    error= HA_ERR_WRONG_COMMAND;
+  }
+  return error;
+}
+
+
+/*
+  Enable indexes.
+
+  SYNOPSIS
+    enable_indexes()
+    mode        mode of operation:
+                HA_KEY_SWITCH_NONUNIQ      enable all non-unique keys
+                HA_KEY_SWITCH_ALL          enable all keys
+                HA_KEY_SWITCH_NONUNIQ_SAVE en. non-uni. and make persistent
+                HA_KEY_SWITCH_ALL_SAVE     en. all keys and make persistent
+
+  DESCRIPTION
+    Enable indexes and set keys to use for scanning.
+    The indexes might have been disabled by disable_index() before.
+    The function works only if both data and indexes are empty,
+    since the heap storage engine cannot repair the indexes.
+    To be sure, call handler::delete_all_rows() before.
+
+  IMPLEMENTATION
+    HA_KEY_SWITCH_NONUNIQ       is not implemented.
+    HA_KEY_SWITCH_NONUNIQ_SAVE  is not implemented with HEAP.
+    HA_KEY_SWITCH_ALL_SAVE      is not implemented with HEAP.
+
+  RETURN
+    0  ok
+    HA_ERR_CRASHED  data or index is non-empty. Delete all rows and retry.
+    HA_ERR_WRONG_COMMAND  mode not implemented.
+*/
+
+int ha_heap::enable_indexes(uint mode)
+{
+  int error;
+
+  if (mode == HA_KEY_SWITCH_ALL)
+  {
+    if (!(error= heap_enable_indexes(file)))
+      set_keys_for_scanning();
+  }
+  else
+  {
+    /* mode not implemented */
+    error= HA_ERR_WRONG_COMMAND;
+  }
+  return error;
+}
+
+
+/*
+  Test if indexes are disabled.
+
+  SYNOPSIS
+    indexes_are_disabled()
+    no parameters
+
+  RETURN
+    0  indexes are not disabled
+    1  all indexes are disabled
+   [2  non-unique indexes are disabled - NOT YET IMPLEMENTED]
+*/
+
+int ha_heap::indexes_are_disabled(void)
+{
+  return heap_indexes_are_disabled(file);
+}
+
 THR_LOCK_DATA **ha_heap::store_lock(THD *thd,
 				    THR_LOCK_DATA **to,
 				    enum thr_lock_type lock_type)
diff --git a/sql/ha_heap.h b/sql/ha_heap.h
index 68406202c76..2f849d2574b 100644
--- a/sql/ha_heap.h
+++ b/sql/ha_heap.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
+/* Copyright (C) 2000,2004 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -61,6 +61,7 @@ class ha_heap: public handler
 
   int open(const char *name, int mode, uint test_if_locked);
   int close(void);
+  void set_keys_for_scanning(void);
   int write_row(byte * buf);
   int update_row(const byte * old_data, byte * new_data);
   int delete_row(const byte * buf);
@@ -82,6 +83,9 @@ class ha_heap: public handler
   int extra(enum ha_extra_function operation);
   int external_lock(THD *thd, int lock_type);
   int delete_all_rows(void);
+  int disable_indexes(uint mode);
+  int enable_indexes(uint mode);
+  int indexes_are_disabled(void);
   ha_rows records_in_range(int inx, const byte *start_key,uint start_key_len,
 			   enum ha_rkey_function start_search_flag,
 			   const byte *end_key,uint end_key_len,
diff --git a/sql/ha_myisam.cc b/sql/ha_myisam.cc
index b9d6cec38aa..1b24633953d 100644
--- a/sql/ha_myisam.cc
+++ b/sql/ha_myisam.cc
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
+/* Copyright (C) 2000,2004 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -810,47 +810,146 @@ int ha_myisam::preload_keys(THD* thd, HA_CHECK_OPT *check_opt)
   }
 }
 
+
 /*
-  disable indexes, making it persistent if requested
+  Disable indexes, making it persistent if requested.
+
   SYNOPSIS
-    disable_indexes(all, save)
-    all         disable all indexes
-                if not set only non-unique indexes will be disabled
-                [all=1 is NOT IMPLEMENTED YET]
-    save        save the disabled state, so that it will persist
-                between queries/threads/reboots
-                [save=0 is NOT IMPLEMENTED YET]
+    disable_indexes()
+    mode        mode of operation:
+                HA_KEY_SWITCH_NONUNIQ      disable all non-unique keys
+                HA_KEY_SWITCH_ALL          disable all keys
+                HA_KEY_SWITCH_NONUNIQ_SAVE dis. non-uni. and make persistent
+                HA_KEY_SWITCH_ALL_SAVE     dis. all keys and make persistent
+
+  IMPLEMENTATION
+    HA_KEY_SWITCH_NONUNIQ       is not implemented.
+    HA_KEY_SWITCH_ALL_SAVE      is not implemented.
+
+  RETURN
+    0  ok
+    HA_ERR_WRONG_COMMAND  mode not implemented.
 */
-int ha_myisam::disable_indexes(bool all, bool save)
+
+int ha_myisam::disable_indexes(uint mode)
 {
-  mi_extra(file, HA_EXTRA_NO_KEYS, 0);
-  info(HA_STATUS_CONST);                        // Read new key info
-  return 0;
+  int error;
+
+  if (mode == HA_KEY_SWITCH_ALL)
+  {
+    /* call a storage engine function to switch the key map */
+    error= mi_disable_indexes(file);
+  }
+  else if (mode == HA_KEY_SWITCH_NONUNIQ_SAVE)
+  {
+    mi_extra(file, HA_EXTRA_NO_KEYS, 0);
+    info(HA_STATUS_CONST);                        // Read new key info
+    error= 0;
+  }
+  else
+  {
+    /* mode not implemented */
+    error= HA_ERR_WRONG_COMMAND;
+  }
+  return error;
 }
 
-int ha_myisam::enable_indexes()
+
+/*
+  Enable indexes, making it persistent if requested.
+
+  SYNOPSIS
+    enable_indexes()
+    mode        mode of operation:
+                HA_KEY_SWITCH_NONUNIQ      enable all non-unique keys
+                HA_KEY_SWITCH_ALL          enable all keys
+                HA_KEY_SWITCH_NONUNIQ_SAVE en. non-uni. and make persistent
+                HA_KEY_SWITCH_ALL_SAVE     en. all keys and make persistent
+
+  DESCRIPTION
+    Enable indexes, which might have been disabled by disable_index() before.
+    The modes without _SAVE work only if both data and indexes are empty,
+    since the MyISAM repair would enable them persistently.
+    To be sure in these cases, call handler::delete_all_rows() before.
+
+  IMPLEMENTATION
+    HA_KEY_SWITCH_NONUNIQ       is not implemented.
+    HA_KEY_SWITCH_ALL_SAVE      is not implemented.
+
+  RETURN
+    0  ok
+    !=0  Error, among others:
+    HA_ERR_CRASHED  data or index is non-empty. Delete all rows and retry.
+    HA_ERR_WRONG_COMMAND  mode not implemented.
+*/
+
+int ha_myisam::enable_indexes(uint mode)
 {
+  int error;
+
   if (file->s->state.key_map == set_bits(ulonglong, file->s->base.keys))
+  {
+    /* All indexes are enabled already. */
     return 0;
+  }
 
-  int error=0;
-  THD *thd=current_thd;
-  MI_CHECK param;
-  const char *save_proc_info=thd->proc_info;
-  thd->proc_info="Creating index";
-  myisamchk_init(&param);
-  param.op_name = (char*) "recreating_index";
-  param.testflag = (T_SILENT | T_REP_BY_SORT | T_QUICK |
-                    T_CREATE_MISSING_KEYS);
-  param.myf_rw&= ~MY_WAIT_IF_FULL;
-  param.sort_buffer_length=  thd->variables.myisam_sort_buff_size;
-  param.tmpdir=&mysql_tmpdir_list;
-  error=repair(thd,param,0) != HA_ADMIN_OK;
-  info(HA_STATUS_CONST);
-  thd->proc_info=save_proc_info;
+  if (mode == HA_KEY_SWITCH_ALL)
+  {
+    error= mi_enable_indexes(file);
+    /*
+       Do not try to repair on error,
+       as this could make the enabled state persistent,
+       but mode==HA_KEY_SWITCH_ALL forbids it.
+    */
+  }
+  else if (mode == HA_KEY_SWITCH_NONUNIQ_SAVE)
+  {
+    THD *thd=current_thd;
+    MI_CHECK param;
+    const char *save_proc_info=thd->proc_info;
+    thd->proc_info="Creating index";
+    myisamchk_init(&param);
+    param.op_name = (char*) "recreating_index";
+    param.testflag = (T_SILENT | T_REP_BY_SORT | T_QUICK |
+                      T_CREATE_MISSING_KEYS);
+    param.myf_rw&= ~MY_WAIT_IF_FULL;
+    param.sort_buffer_length=  thd->variables.myisam_sort_buff_size;
+    param.tmpdir=&mysql_tmpdir_list;
+    error=repair(thd,param,0) != HA_ADMIN_OK;
+    info(HA_STATUS_CONST);
+    thd->proc_info=save_proc_info;
+  }
+  else
+  {
+    /* mode not implemented */
+    error= HA_ERR_WRONG_COMMAND;
+  }
   return error;
 }
 
+
+/*
+  Test if indexes are disabled.
+
+
+  SYNOPSIS
+    indexes_are_disabled()
+      no parameters
+
+
+  RETURN
+    0  indexes are not disabled
+    1  all indexes are disabled
+   [2  non-unique indexes are disabled - NOT YET IMPLEMENTED]
+*/
+
+int ha_myisam::indexes_are_disabled(void)
+{
+  
+  return mi_indexes_are_disabled(file);
+}
+
+
 /*
   prepare for a many-rows insert operation
   e.g. - disable indexes (if they can be recreated fast) or
@@ -898,7 +997,8 @@ int ha_myisam::end_bulk_insert()
 {
   mi_end_bulk_insert(file);
   int err=mi_extra(file, HA_EXTRA_NO_CACHE, 0);
-  return err ? err : can_enable_indexes ? enable_indexes() : 0;
+  return err ? err : can_enable_indexes ?
+                     enable_indexes(HA_KEY_SWITCH_NONUNIQ_SAVE) : 0;
 }
 
 
diff --git a/sql/ha_myisam.h b/sql/ha_myisam.h
index ca318b02778..206a1c62a2f 100644
--- a/sql/ha_myisam.h
+++ b/sql/ha_myisam.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
+/* Copyright (C) 2000,2004 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -105,8 +105,9 @@ class ha_myisam: public handler
   int extra_opt(enum ha_extra_function operation, ulong cache_size);
   int external_lock(THD *thd, int lock_type);
   int delete_all_rows(void);
-  int disable_indexes(bool all, bool save);
-  int enable_indexes();
+  int disable_indexes(uint mode);
+  int enable_indexes(uint mode);
+  int indexes_are_disabled(void);
   void start_bulk_insert(ha_rows rows);
   int end_bulk_insert();
   ha_rows records_in_range(int inx,
diff --git a/sql/handler.h b/sql/handler.h
index 62ff74c436a..33d713090df 100644
--- a/sql/handler.h
+++ b/sql/handler.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
+/* Copyright (C) 2000,2004 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -91,6 +91,13 @@
 #define HA_KEY_READ_ONLY	64	/* Support HA_EXTRA_KEYREAD */
 
 
+/* operations for disable/enable indexes */
+#define HA_KEY_SWITCH_NONUNIQ      0
+#define HA_KEY_SWITCH_ALL          1
+#define HA_KEY_SWITCH_NONUNIQ_SAVE 2
+#define HA_KEY_SWITCH_ALL_SAVE     3
+
+
 /*
   Bits in index_ddl_flags(KEY *wanted_index)
   for what ddl you can do with index
@@ -371,8 +378,9 @@ class handler :public Sql_alloc
   */
   virtual int restore(THD* thd, HA_CHECK_OPT* check_opt);
   virtual int dump(THD* thd, int fd = -1) { return ER_DUMP_NOT_IMPLEMENTED; }
-  virtual int disable_indexes(bool all, bool save) { return HA_ERR_WRONG_COMMAND; }
-  virtual int enable_indexes() { return HA_ERR_WRONG_COMMAND; }
+  virtual int disable_indexes(uint mode) { return HA_ERR_WRONG_COMMAND; }
+  virtual int enable_indexes(uint mode) { return HA_ERR_WRONG_COMMAND; }
+  virtual int indexes_are_disabled(void) {return 0;}
   virtual void start_bulk_insert(ha_rows rows) {}
   virtual int end_bulk_insert() {return 0; }
   virtual int discard_or_import_tablespace(my_bool discard) {return -1;}
diff --git a/sql/sql_select.cc b/sql/sql_select.cc
index ffc52817322..f8347b9342f 100644
--- a/sql/sql_select.cc
+++ b/sql/sql_select.cc
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000-2003 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
+/* Copyright (C) 2000-2004 MySQL AB & MySQL Finland AB & TCX DataKonsult AB
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -5545,6 +5545,8 @@ bool create_myisam_from_heap(THD *thd, TABLE *table, TMP_TABLE_PARAM *param,
     goto err2;
   if (open_tmp_table(&new_table))
     goto err1;
+  if (table->file->indexes_are_disabled())
+    new_table.file->disable_indexes(HA_KEY_SWITCH_ALL);
   table->file->index_end();
   table->file->rnd_init();
   if (table->no_rows)
diff --git a/sql/sql_table.cc b/sql/sql_table.cc
index 0d0be1b7e10..fd980f90468 100644
--- a/sql/sql_table.cc
+++ b/sql/sql_table.cc
@@ -1,4 +1,4 @@
-/* Copyright (C) 2000-2003 MySQL AB
+/* Copyright (C) 2000-2004 MySQL AB
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -2556,14 +2556,14 @@ int mysql_alter_table(THD *thd,char *new_db, char *new_name,
 	VOID(pthread_mutex_lock(&LOCK_open));
 	wait_while_table_is_used(thd, table, HA_EXTRA_FORCE_REOPEN);
 	VOID(pthread_mutex_unlock(&LOCK_open));
-	error= table->file->enable_indexes();
+	error= table->file->enable_indexes(HA_KEY_SWITCH_NONUNIQ_SAVE);
 	/* COND_refresh will be signaled in close_thread_tables() */
 	break;
       case DISABLE:
 	VOID(pthread_mutex_lock(&LOCK_open));
 	wait_while_table_is_used(thd, table, HA_EXTRA_FORCE_REOPEN);
 	VOID(pthread_mutex_unlock(&LOCK_open));
-	error=table->file->disable_indexes(0, 1);
+	error=table->file->disable_indexes(HA_KEY_SWITCH_NONUNIQ_SAVE);
 	/* COND_refresh will be signaled in close_thread_tables() */
 	break;
       }

