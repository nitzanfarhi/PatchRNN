commit ff38cf9dace20854665175f403992f83312463cf
Author: Andy Fiddaman <omnios@citrus-it.net>
Date:   Sat Mar 28 15:01:48 2015 +0000

    5739 mr_sas driver - noise reduction and output fix
    Reviewed by: Hans Rosenfeld <hans.rosenfeld@nexenta.com>
    Reviewed by: Garrett D'Amore <garrett@damore.org>
    Approved by: Dan McDonald <danmcd@omniti.com>

diff --git a/usr/src/uts/common/io/mr_sas/mr_sas.c b/usr/src/uts/common/io/mr_sas/mr_sas.c
index ee43931f7d..110a89a411 100644
--- a/usr/src/uts/common/io/mr_sas/mr_sas.c
+++ b/usr/src/uts/common/io/mr_sas/mr_sas.c
@@ -45,6 +45,7 @@
  * Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2011 Bayard G. Bell. All rights reserved.
  * Copyright 2013 Nexenta Systems, Inc. All rights reserved.
+ * Copyright 2015 Citrus IT Limited. All rights reserved.
  */
 
 #include <sys/types.h>
@@ -482,9 +483,7 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 	 * check to see whether this device is in a DMA-capable slot.
 	 */
 	if (ddi_slaveonly(dip) == DDI_SUCCESS) {
-		cmn_err(CE_WARN,
-		    "mr_sas%d: Device in slave-only slot, unused",
-		    instance_no);
+		dev_err(dip, CE_WARN, "Device in slave-only slot, unused");
 		return (DDI_FAILURE);
 	}
 
@@ -493,9 +492,7 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 		/* allocate the soft state for the instance */
 		if (ddi_soft_state_zalloc(mrsas_state, instance_no)
 		    != DDI_SUCCESS) {
-			cmn_err(CE_WARN,
-			    "mr_sas%d: Failed to allocate soft state",
-			    instance_no);
+			dev_err(dip, CE_WARN, "Failed to allocate soft state");
 			return (DDI_FAILURE);
 		}
 
@@ -503,8 +500,7 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 		    (mrsas_state, instance_no);
 
 		if (instance == NULL) {
-			cmn_err(CE_WARN,
-			    "mr_sas%d: Bad soft state", instance_no);
+			dev_err(dip, CE_WARN, "Bad soft state");
 			ddi_soft_state_free(mrsas_state, instance_no);
 			return (DDI_FAILURE);
 		}
@@ -514,17 +510,14 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 		/* Setup the PCI configuration space handles */
 		if (pci_config_setup(dip, &instance->pci_handle) !=
 		    DDI_SUCCESS) {
-			cmn_err(CE_WARN,
-			    "mr_sas%d: pci config setup failed ",
-			    instance_no);
+			dev_err(dip, CE_WARN, "pci config setup failed");
 
 			ddi_soft_state_free(mrsas_state, instance_no);
 			return (DDI_FAILURE);
 		}
 
 		if (ddi_dev_nregs(dip, &nregs) != DDI_SUCCESS) {
-			cmn_err(CE_WARN,
-			    "mr_sas: failed to get registers.");
+			dev_err(dip, CE_WARN, "Failed to get registers");
 
 			pci_config_teardown(&instance->pci_handle);
 			ddi_soft_state_free(mrsas_state, instance_no);
@@ -547,10 +540,10 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 		irq = pci_config_get8(instance->pci_handle,
 		    PCI_CONF_ILINE);
 
-		con_log(CL_DLEVEL1, (CE_CONT, "mr_sas%d: "
-		    "0x%x:0x%x 0x%x:0x%x, irq:%d drv-ver:%s",
-		    instance_no, vendor_id, device_id, subsysvid,
-		    subsysid, irq, MRSAS_VERSION));
+		dev_err(dip, CE_CONT,
+		    "?0x%x:0x%x 0x%x:0x%x, irq:%d drv-ver:%s\n",
+		    vendor_id, device_id, subsysvid,
+		    subsysid, irq, MRSAS_VERSION);
 
 		/* enable bus-mastering */
 		command = pci_config_get16(instance->pci_handle,
@@ -573,8 +566,7 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 		switch (device_id) {
 		case PCI_DEVICE_ID_LSI_TBOLT:
 		case PCI_DEVICE_ID_LSI_INVADER:
-			con_log(CL_ANN, (CE_NOTE,
-			    "mr_sas: 2208 T.B. device detected"));
+			dev_err(dip, CE_CONT, "?TBOLT device detected\n");
 
 			instance->func_ptr =
 			    &mrsas_function_template_fusion;
@@ -595,16 +587,15 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 
 		case PCI_DEVICE_ID_LSI_2108VDE:
 		case PCI_DEVICE_ID_LSI_2108V:
-			con_log(CL_ANN, (CE_NOTE,
-			    "mr_sas: 2108 Liberator device detected"));
+			dev_err(dip, CE_CONT,
+			    "?2108 Liberator device detected\n");
 
 			instance->func_ptr =
 			    &mrsas_function_template_ppc;
 			break;
 
 		default:
-			cmn_err(CE_WARN,
-			    "mr_sas: Invalid device detected");
+			dev_err(dip, CE_WARN, "Invalid device detected");
 
 			pci_config_teardown(&instance->pci_handle);
 			ddi_soft_state_free(mrsas_state, instance_no);
@@ -647,8 +638,7 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 		    REGISTER_SET_IO_2108, &instance->regmap, 0,
 		    reglength, &endian_attr, &instance->regmap_handle)
 		    != DDI_SUCCESS) {
-			cmn_err(CE_WARN,
-			    "mr_sas: couldn't map control registers");
+			dev_err(dip, CE_WARN, "couldn't map control registers");
 			goto fail_attach;
 		}
 
@@ -670,13 +660,13 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 			ddi_prop_free(data);
 		}
 
-		con_log(CL_DLEVEL1, (CE_NOTE, "msi_enable = %d", msi_enable));
+		dev_err(dip, CE_CONT, "?msi_enable = %d\n", msi_enable);
 
 		if (ddi_prop_lookup_string(DDI_DEV_T_ANY, dip, 0,
 		    "mrsas-enable-fp", &data) == DDI_SUCCESS) {
 			if (strncmp(data, "no", 3) == 0) {
 				enable_fp = 0;
-				cmn_err(CE_NOTE,
+				dev_err(dip, CE_NOTE,
 				    "enable_fp = %d, Fast-Path disabled.\n",
 				    enable_fp);
 			}
@@ -684,12 +674,12 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 			ddi_prop_free(data);
 		}
 
-		con_log(CL_DLEVEL1, (CE_NOTE, "enable_fp = %d\n", enable_fp));
+		dev_err(dip, CE_CONT, "?enable_fp = %d\n", enable_fp);
 
 		/* Check for all supported interrupt types */
 		if (ddi_intr_get_supported_types(
 		    dip, &intr_types) != DDI_SUCCESS) {
-			cmn_err(CE_WARN,
+			dev_err(dip, CE_WARN,
 			    "ddi_intr_get_supported_types() failed");
 			goto fail_attach;
 		}
@@ -701,7 +691,7 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 		if (msi_enable && (intr_types & DDI_INTR_TYPE_MSIX)) {
 			if (mrsas_add_intrs(instance, DDI_INTR_TYPE_MSIX) !=
 			    DDI_SUCCESS) {
-				cmn_err(CE_WARN,
+				dev_err(dip, CE_WARN,
 				    "MSIX interrupt query failed");
 				goto fail_attach;
 			}
@@ -709,7 +699,7 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 		} else if (msi_enable && (intr_types & DDI_INTR_TYPE_MSI)) {
 			if (mrsas_add_intrs(instance, DDI_INTR_TYPE_MSI) !=
 			    DDI_SUCCESS) {
-				cmn_err(CE_WARN,
+				dev_err(dip, CE_WARN,
 				    "MSI interrupt query failed");
 				goto fail_attach;
 			}
@@ -718,13 +708,13 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 			msi_enable = 0;
 			if (mrsas_add_intrs(instance, DDI_INTR_TYPE_FIXED) !=
 			    DDI_SUCCESS) {
-				cmn_err(CE_WARN,
+				dev_err(dip, CE_WARN,
 				    "FIXED interrupt query failed");
 				goto fail_attach;
 			}
 			instance->intr_type = DDI_INTR_TYPE_FIXED;
 		} else {
-			cmn_err(CE_WARN, "Device cannot "
+			dev_err(dip, CE_WARN, "Device cannot "
 			    "suppport either FIXED or MSI/X "
 			    "interrupts");
 			goto fail_attach;
@@ -742,11 +732,11 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 			ddi_prop_free(data);
 		}
 
-		con_log(CL_DLEVEL1, (CE_WARN, "ctio_enable = %d", ctio_enable));
+		dev_err(dip, CE_CONT, "?ctio_enable = %d\n", ctio_enable);
 
 		/* setup the mfi based low level driver */
 		if (mrsas_init_adapter(instance) != DDI_SUCCESS) {
-			cmn_err(CE_WARN, "mr_sas: "
+			dev_err(dip, CE_WARN,
 			    "could not initialize the low level driver");
 
 			goto fail_attach;
@@ -804,7 +794,7 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 				    &instance->soft_intr_id, NULL, NULL,
 				    mrsas_softintr, (caddr_t)instance) !=
 				    DDI_SUCCESS) {
-					cmn_err(CE_WARN,
+					dev_err(dip, CE_WARN,
 					    "Software ISR did not register");
 
 					goto fail_attach;
@@ -821,7 +811,7 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 		tran = scsi_hba_tran_alloc(dip, SCSI_HBA_CANSLEEP);
 
 		if (tran == NULL) {
-			cmn_err(CE_WARN,
+			dev_err(dip, CE_WARN,
 			    "scsi_hba_tran_alloc failed");
 			goto fail_attach;
 		}
@@ -860,7 +850,7 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 		/* Attach this instance of the hba */
 		if (scsi_hba_attach_setup(dip, &tran_dma_attr, tran, 0)
 		    != DDI_SUCCESS) {
-			cmn_err(CE_WARN,
+			dev_err(dip, CE_WARN,
 			    "scsi_hba_attach failed");
 
 			goto fail_attach;
@@ -873,8 +863,7 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 		if (ddi_create_minor_node(dip, "devctl",
 		    S_IFCHR, INST2DEVCTL(instance_no),
 		    DDI_NT_SCSI_NEXUS, 0) == DDI_FAILURE) {
-			cmn_err(CE_WARN,
-			    "mr_sas: failed to create devctl node.");
+			dev_err(dip, CE_WARN, "failed to create devctl node.");
 
 			goto fail_attach;
 		}
@@ -885,16 +874,14 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 		if (ddi_create_minor_node(dip, "scsi", S_IFCHR,
 		    INST2SCSI(instance_no), DDI_NT_SCSI_ATTACHMENT_POINT, 0) ==
 		    DDI_FAILURE) {
-			cmn_err(CE_WARN,
-			    "mr_sas: failed to create scsi node.");
+			dev_err(dip, CE_WARN, "failed to create scsi node.");
 
 			goto fail_attach;
 		}
 
 		instance->unroll.scsictl = 1;
 
-		(void) sprintf(instance->iocnode, "%d:lsirdctl",
-		    instance_no);
+		(void) sprintf(instance->iocnode, "%d:lsirdctl", instance_no);
 
 		/*
 		 * Create a node for applications
@@ -903,8 +890,7 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 		if (ddi_create_minor_node(dip, instance->iocnode,
 		    S_IFCHR, INST2LSIRDCTL(instance_no), DDI_PSEUDO, 0) ==
 		    DDI_FAILURE) {
-			cmn_err(CE_WARN,
-			    "mr_sas: failed to create ioctl node.");
+			dev_err(dip, CE_WARN, "failed to create ioctl node.");
 
 			goto fail_attach;
 		}
@@ -914,21 +900,19 @@ mrsas_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
 		/* Create a taskq to handle dr events */
 		if ((instance->taskq = ddi_taskq_create(dip,
 		    "mrsas_dr_taskq", 1, TASKQ_DEFAULTPRI, 0)) == NULL) {
-			cmn_err(CE_WARN,
-			    "mr_sas: failed to create taskq ");
+			dev_err(dip, CE_WARN, "failed to create taskq.");
 			instance->taskq = NULL;
 			goto fail_attach;
 		}
 		instance->unroll.taskq = 1;
-		con_log(CL_ANN1, (CE_CONT, "ddi_taskq_create()	done."));
+		con_log(CL_ANN1, (CE_CONT, "ddi_taskq_create() done."));
 
 		/* enable interrupt */
 		instance->func_ptr->enable_intr(instance);
 
 		/* initiate AEN */
 		if (start_mfi_aen(instance)) {
-			cmn_err(CE_WARN,
-			    "mr_sas: failed to initiate AEN.");
+			dev_err(dip, CE_WARN, "failed to initiate AEN.");
 			goto fail_attach;
 		}
 		instance->unroll.aenPend = 1;
@@ -1001,11 +985,6 @@ fail_attach:
 	pci_config_teardown(&instance->pci_handle);
 	ddi_soft_state_free(mrsas_state, instance_no);
 
-	con_log(CL_ANN, (CE_WARN, "mr_sas: return failure from mrsas_attach"));
-
-	cmn_err(CE_WARN, "mrsas_attach() return FAILURE instance_num %d",
-	    instance_no);
-
 	return (DDI_FAILURE);
 }
 
@@ -1093,18 +1072,11 @@ mrsas_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
 	    instance_no);
 
 	if (!instance) {
-		cmn_err(CE_WARN,
-		    "mr_sas:%d could not get instance in detach",
-		    instance_no);
+		dev_err(dip, CE_WARN, "could not get instance in detach");
 
 		return (DDI_FAILURE);
 	}
 
-	con_log(CL_ANN, (CE_NOTE,
-	    "mr_sas%d: detaching device 0x%4x:0x%4x:0x%4x:0x%4x",
-	    instance_no, instance->vendor_id, instance->device_id,
-	    instance->subsysvid, instance->subsysid));
-
 	switch (cmd) {
 		case DDI_DETACH:
 			con_log(CL_ANN, (CE_NOTE,
@@ -1122,9 +1094,8 @@ mrsas_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
 
 			if (instance->unroll.tranSetup == 1) {
 				if (scsi_hba_detach(dip) != DDI_SUCCESS) {
-					cmn_err(CE_WARN,
-					    "mr_sas2%d: failed to detach",
-					    instance_no);
+					dev_err(dip, CE_WARN,
+					    "failed to detach");
 					return (DDI_FAILURE);
 				}
 				instance->unroll.tranSetup = 0;
@@ -1165,14 +1136,8 @@ mrsas_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
 static void
 mrsas_undo_resources(dev_info_t *dip, struct mrsas_instance *instance)
 {
-	int	instance_no;
-
 	con_log(CL_ANN, (CE_NOTE, "chkpnt:%s:%d", __func__, __LINE__));
 
-
-	instance_no = ddi_get_instance(dip);
-
-
 	if (instance->unroll.ioctl == 1) {
 		ddi_remove_minor_node(dip, instance->iocnode);
 		instance->unroll.ioctl = 0;
@@ -1190,8 +1155,7 @@ mrsas_undo_resources(dev_info_t *dip, struct mrsas_instance *instance)
 
 	if (instance->unroll.tranSetup == 1) {
 		if (scsi_hba_detach(dip) != DDI_SUCCESS) {
-			cmn_err(CE_WARN,
-			    "mr_sas2%d: failed to detach", instance_no);
+			dev_err(dip, CE_WARN, "failed to detach");
 			return;	 /* DDI_FAILURE */
 		}
 		instance->unroll.tranSetup = 0;
@@ -1208,7 +1172,7 @@ mrsas_undo_resources(dev_info_t *dip, struct mrsas_instance *instance)
 		if (instance->tbolt) {
 			if (abort_syncmap_cmd(instance,
 			    instance->map_update_cmd)) {
-				cmn_err(CE_WARN, "mrsas_detach: "
+				dev_err(dip, CE_WARN, "mrsas_detach: "
 				    "failed to abort previous syncmap command");
 			}
 
@@ -1219,7 +1183,7 @@ mrsas_undo_resources(dev_info_t *dip, struct mrsas_instance *instance)
 
 	if (instance->unroll.aenPend == 1) {
 		if (abort_aen_cmd(instance, instance->aen_cmd))
-			cmn_err(CE_WARN, "mrsas_detach: "
+			dev_err(dip, CE_WARN, "mrsas_detach: "
 			    "failed to abort prevous AEN command");
 
 		instance->unroll.aenPend = 0;
@@ -1584,7 +1548,7 @@ mrsas_quiesce(dev_info_t *dip)
 	if (instance->tbolt) {
 		if (abort_syncmap_cmd(instance,
 		    instance->map_update_cmd)) {
-			cmn_err(CE_WARN,
+			dev_err(dip, CE_WARN,
 			    "mrsas_detach: failed to abort "
 			    "previous syncmap command");
 			return (DDI_FAILURE);
@@ -2610,7 +2574,8 @@ mrsas_print_pending_cmds(struct mrsas_instance *instance)
 	saved_level = debug_level_g;
 	debug_level_g = CL_ANN1;
 
-	cmn_err(CE_NOTE, "mrsas_print_pending_cmds(): Called\n");
+	dev_err(instance->dip, CE_NOTE,
+	    "mrsas_print_pending_cmds(): Called");
 
 	while (flag) {
 		mutex_enter(&instance->cmd_pend_mtx);
@@ -2829,18 +2794,20 @@ mrsas_issue_pending_cmds(struct mrsas_instance *instance)
 
 			cmd->retry_count_for_ocr++;
 
-			cmn_err(CE_CONT, "cmd retry count = %d\n",
+			dev_err(instance->dip, CE_CONT,
+			    "cmd retry count = %d\n",
 			    cmd->retry_count_for_ocr);
 
 			if (cmd->retry_count_for_ocr > IO_RETRY_COUNT) {
-				cmn_err(CE_WARN, "mrsas_issue_pending_cmds(): "
+				dev_err(instance->dip,
+				    CE_WARN, "mrsas_issue_pending_cmds(): "
 				    "cmd->retry_count exceeded limit >%d\n",
 				    IO_RETRY_COUNT);
 				mrsas_print_cmd_details(instance, cmd, 0xDD);
 
-				cmn_err(CE_WARN,
+				dev_err(instance->dip, CE_WARN,
 				    "mrsas_issue_pending_cmds():"
-				    "Calling KILL Adapter\n");
+				    "Calling KILL Adapter");
 				if (instance->tbolt)
 					mrsas_tbolt_kill_adapter(instance);
 				else
@@ -2858,15 +2825,16 @@ mrsas_issue_pending_cmds(struct mrsas_instance *instance)
 				    gethrtime()));
 
 			} else {
-				cmn_err(CE_CONT,
+				dev_err(instance->dip, CE_CONT,
 				    "mrsas_issue_pending_cmds(): NO-PKT, "
-				    "cmd %p index 0x%x drv_pkt_time 0x%x ",
+				    "cmd %p index 0x%x drv_pkt_time 0x%x",
 				    (void *)cmd, cmd->index, cmd->drv_pkt_time);
 			}
 
 
 			if (cmd->sync_cmd == MRSAS_TRUE) {
-				cmn_err(CE_CONT, "mrsas_issue_pending_cmds(): "
+				dev_err(instance->dip, CE_CONT,
+				    "mrsas_issue_pending_cmds(): "
 				    "SYNC_CMD == TRUE \n");
 				instance->func_ptr->issue_cmd_in_sync_mode(
 				    instance, cmd);
@@ -2950,7 +2918,7 @@ create_mfi_frame_pool(struct mrsas_instance *instance)
 		    (uchar_t)DDI_STRUCTURE_LE_ACC);
 
 		if (cookie_cnt == -1 || cookie_cnt > 1) {
-			cmn_err(CE_WARN,
+			dev_err(instance->dip, CE_WARN,
 			    "create_mfi_frame_pool: could not alloc.");
 			retval = DDI_FAILURE;
 			goto mrsas_undo_frame_pool;
@@ -2971,8 +2939,8 @@ create_mfi_frame_pool(struct mrsas_instance *instance)
 		    tot_frame_size - SENSE_LENGTH;
 
 		if (!cmd->frame || !cmd->sense) {
-			cmn_err(CE_WARN,
-			    "mr_sas: pci_pool_alloc failed");
+			dev_err(instance->dip, CE_WARN,
+			    "pci_pool_alloc failed");
 			retval = ENOMEM;
 			goto mrsas_undo_frame_pool;
 		}
@@ -3034,8 +3002,8 @@ alloc_additional_dma_buffer(struct mrsas_instance *instance)
 
 	if (mrsas_alloc_dma_obj(instance, &instance->mfi_internal_dma_obj,
 	    (uchar_t)DDI_STRUCTURE_LE_ACC) != 1) {
-		cmn_err(CE_WARN,
-		    "mr_sas: could not alloc reply queue");
+		dev_err(instance->dip, CE_WARN,
+		    "could not alloc reply queue");
 		return (DDI_FAILURE);
 	}
 
@@ -3067,7 +3035,7 @@ alloc_additional_dma_buffer(struct mrsas_instance *instance)
 
 	if (mrsas_alloc_dma_obj(instance, &instance->mfi_evt_detail_obj,
 	    (uchar_t)DDI_STRUCTURE_LE_ACC) != 1) {
-		cmn_err(CE_WARN, "alloc_additional_dma_buffer: "
+		dev_err(instance->dip, CE_WARN, "alloc_additional_dma_buffer: "
 		    "could not allocate data transfer buffer.");
 		goto mrsas_undo_internal_buff;
 	}
@@ -3251,19 +3219,21 @@ alloc_space_for_mfi(struct mrsas_instance *instance)
 {
 	/* Allocate command pool (memory for cmd_list & individual commands) */
 	if (mrsas_alloc_cmd_pool(instance)) {
-		cmn_err(CE_WARN, "error creating cmd pool");
+		dev_err(instance->dip, CE_WARN, "error creating cmd pool");
 		return (DDI_FAILURE);
 	}
 
 	/* Allocate MFI Frame pool */
 	if (create_mfi_frame_pool(instance)) {
-		cmn_err(CE_WARN, "error creating frame DMA pool");
+		dev_err(instance->dip, CE_WARN,
+		    "error creating frame DMA pool");
 		goto mfi_undo_cmd_pool;
 	}
 
 	/* Allocate additional DMA buffer */
 	if (alloc_additional_dma_buffer(instance)) {
-		cmn_err(CE_WARN, "error creating frame DMA pool");
+		dev_err(instance->dip, CE_WARN,
+		    "error creating frame DMA pool");
 		goto mfi_undo_frame_pool;
 	}
 
@@ -3317,7 +3287,7 @@ get_ctrl_info(struct mrsas_instance *instance,
 	ci = (struct mrsas_ctrl_info *)instance->internal_buf;
 
 	if (!ci) {
-		cmn_err(CE_WARN,
+		dev_err(instance->dip, CE_WARN,
 		    "Failed to alloc mem for ctrl info");
 		mrsas_return_mfi_pkt(instance, cmd);
 		return (DDI_FAILURE);
@@ -3368,7 +3338,8 @@ get_ctrl_info(struct mrsas_instance *instance,
 		    DDI_DEV_AUTOINCR);
 		/* should get more members of ci with ddi_get when needed */
 	} else {
-		cmn_err(CE_WARN, "get_ctrl_info: Ctrl info failed");
+		dev_err(instance->dip, CE_WARN,
+		    "get_ctrl_info: Ctrl info failed");
 		ret = -1;
 	}
 
@@ -4008,7 +3979,7 @@ get_seq_num(struct mrsas_instance *instance,
 	}
 
 	if (!cmd) {
-		cmn_err(CE_WARN, "mr_sas: failed to get a cmd");
+		dev_err(instance->dip, CE_WARN, "failed to get a cmd");
 		DTRACE_PROBE2(seq_num_mfi_err, uint16_t,
 		    instance->fw_outstanding, uint16_t, instance->max_fw_cmds);
 		return (ENOMEM);
@@ -4031,7 +4002,7 @@ get_seq_num(struct mrsas_instance *instance,
 
 	if (mrsas_alloc_dma_obj(instance, &dcmd_dma_obj,
 	    (uchar_t)DDI_STRUCTURE_LE_ACC) != 1) {
-		cmn_err(CE_WARN,
+		dev_err(instance->dip, CE_WARN,
 		    "get_seq_num: could not allocate data transfer buffer.");
 		return (DDI_FAILURE);
 	}
@@ -4064,7 +4035,7 @@ get_seq_num(struct mrsas_instance *instance,
 	}
 
 	if (instance->func_ptr->issue_cmd_in_sync_mode(instance, cmd)) {
-		cmn_err(CE_WARN, "get_seq_num: "
+		dev_err(instance->dip, CE_WARN, "get_seq_num: "
 		    "failed to issue MRSAS_DCMD_CTRL_EVENT_GET_INFO");
 		ret = DDI_FAILURE;
 	} else {
@@ -4101,7 +4072,8 @@ start_mfi_aen(struct mrsas_instance *instance)
 	(void) memset(&eli, 0, sizeof (struct mrsas_evt_log_info));
 
 	if (get_seq_num(instance, &eli)) {
-		cmn_err(CE_WARN, "start_mfi_aen: failed to get seq num");
+		dev_err(instance->dip, CE_WARN,
+		    "start_mfi_aen: failed to get seq num");
 		return (-1);
 	}
 
@@ -4114,7 +4086,8 @@ start_mfi_aen(struct mrsas_instance *instance)
 	    class_locale.word);
 
 	if (ret) {
-		cmn_err(CE_WARN, "start_mfi_aen: aen registration failed");
+		dev_err(instance->dip, CE_WARN,
+		    "start_mfi_aen: aen registration failed");
 		return (-1);
 	}
 
@@ -4424,7 +4397,7 @@ mrsas_initiate_ocr_if_fw_is_faulty(struct mrsas_instance *instance)
 	fw_state = cur_abs_reg_val & MFI_STATE_MASK;
 	if (fw_state == MFI_STATE_FAULT) {
 		if (instance->disable_online_ctrl_reset == 1) {
-			cmn_err(CE_WARN,
+			dev_err(instance->dip, CE_WARN,
 			    "mrsas_initiate_ocr_if_fw_is_faulty: "
 			    "FW in Fault state, detected in ISR: "
 			    "FW doesn't support ocr ");
@@ -6622,9 +6595,9 @@ io_timeout_checker(void *arg)
 
 	/* See if this check needs to be in the beginning or last in ISR */
 	if (mrsas_initiate_ocr_if_fw_is_faulty(instance) ==  1) {
-		cmn_err(CE_WARN, "io_timeout_checker: "
+		dev_err(instance->dip, CE_WARN, "io_timeout_checker: "
 		    "FW Fault, calling reset adapter");
-		cmn_err(CE_CONT, "io_timeout_checker: "
+		dev_err(instance->dip, CE_CONT, "io_timeout_checker: "
 		    "fw_outstanding 0x%X max_fw_cmds 0x%X",
 		    instance->fw_outstanding, instance->max_fw_cmds);
 		if (instance->adapterresetinprogress == 0) {
@@ -6664,9 +6637,9 @@ io_timeout_checker(void *arg)
 			time = --cmd->drv_pkt_time;
 		}
 		if (time <= 0) {
-			cmn_err(CE_WARN, "%llx: "
+			dev_err(instance->dip, CE_WARN, "%llx: "
 			    "io_timeout_checker: TIMING OUT: pkt: %p, "
-			    "cmd %p fw_outstanding 0x%X max_fw_cmds 0x%X\n",
+			    "cmd %p fw_outstanding 0x%X max_fw_cmds 0x%X",
 			    gethrtime(), (void *)pkt, (void *)cmd,
 			    instance->fw_outstanding, instance->max_fw_cmds);
 
@@ -6678,9 +6651,9 @@ io_timeout_checker(void *arg)
 
 	if (counter) {
 		if (instance->disable_online_ctrl_reset == 1) {
-			cmn_err(CE_WARN, "mr_sas %d: %s(): OCR is NOT "
+			dev_err(instance->dip, CE_WARN, "%s(): OCR is NOT "
 			    "supported by Firmware, KILL adapter!!!",
-			    instance->instance, __func__);
+			    __func__);
 
 			if (instance->tbolt)
 				mrsas_tbolt_kill_adapter(instance);
@@ -6700,7 +6673,7 @@ io_timeout_checker(void *arg)
 					}
 				}
 			} else {
-				cmn_err(CE_WARN,
+				dev_err(instance->dip, CE_WARN,
 				    "io_timeout_checker: "
 				    "cmd %p cmd->index %d "
 				    "timed out even after 3 resets: "
@@ -6992,7 +6965,7 @@ mrsas_reset_ppc(struct mrsas_instance *instance)
 	con_log(CL_ANN, (CE_NOTE, "chkpnt:%s:%d", __func__, __LINE__));
 
 	if (instance->deadadapter == 1) {
-		cmn_err(CE_WARN, "mrsas_reset_ppc: "
+		dev_err(instance->dip, CE_WARN, "mrsas_reset_ppc: "
 		    "no more resets as HBA has been marked dead ");
 		return (DDI_FAILURE);
 	}
@@ -7019,7 +6992,8 @@ retry_reset:
 		delay(100 * drv_usectohz(MILLISEC));
 		status = RD_OB_DRWE(instance);
 		if (retry++ == 100) {
-			cmn_err(CE_WARN, "mrsas_reset_ppc: DRWE bit "
+			dev_err(instance->dip, CE_WARN,
+			    "mrsas_reset_ppc: DRWE bit "
 			    "check retry count %d", retry);
 			return (DDI_FAILURE);
 		}
@@ -7031,7 +7005,7 @@ retry_reset:
 		delay(100 * drv_usectohz(MILLISEC));
 		status = RD_OB_DRWE(instance);
 		if (retry++ == 100) {
-			cmn_err(CE_WARN, "mrsas_reset_ppc: "
+			dev_err(instance->dip, CE_WARN, "mrsas_reset_ppc: "
 			    "RESET FAILED. KILL adapter called.");
 
 			(void) mrsas_kill_adapter(instance);
@@ -7065,14 +7039,16 @@ retry_reset:
 			instance->fw_fault_count_after_ocr++;
 			if (instance->fw_fault_count_after_ocr
 			    < MAX_FW_RESET_COUNT) {
-				cmn_err(CE_WARN, "mrsas_reset_ppc: "
+				dev_err(instance->dip, CE_WARN,
+				    "mrsas_reset_ppc: "
 				    "FW is in fault after OCR count %d "
 				    "Retry Reset",
 				    instance->fw_fault_count_after_ocr);
 				goto retry_reset;
 
 			} else {
-				cmn_err(CE_WARN, "mrsas_reset_ppc: "
+				dev_err(instance->dip, CE_WARN,
+				    "mrsas_reset_ppc: "
 				    "Max Reset Count exceeded >%d"
 				    "Mark HBA as bad, KILL adapter",
 				    MAX_FW_RESET_COUNT);
diff --git a/usr/src/uts/common/io/mr_sas/mr_sas_tbolt.c b/usr/src/uts/common/io/mr_sas/mr_sas_tbolt.c
index 549c75da28..b7f3794312 100644
--- a/usr/src/uts/common/io/mr_sas/mr_sas_tbolt.c
+++ b/usr/src/uts/common/io/mr_sas/mr_sas_tbolt.c
@@ -212,8 +212,8 @@ create_mpi2_frame_pool(struct mrsas_instance *instance)
 
 	if (mrsas_alloc_dma_obj(instance, &instance->mpi2_frame_pool_dma_obj,
 	    (uchar_t)DDI_STRUCTURE_LE_ACC) != 1) {
-		cmn_err(CE_WARN,
-		    "mr_sas: could not alloc mpi2 frame pool");
+		dev_err(instance->dip, CE_WARN,
+		    "could not alloc mpi2 frame pool");
 		return (DDI_FAILURE);
 	}
 
@@ -315,8 +315,8 @@ mrsas_tbolt_alloc_additional_dma_buffer(struct mrsas_instance *instance)
 
 	if (mrsas_alloc_dma_obj(instance, &instance->mfi_internal_dma_obj,
 	    (uchar_t)DDI_STRUCTURE_LE_ACC) != 1) {
-		cmn_err(CE_WARN,
-		    "mr_sas: could not alloc reply queue");
+		dev_err(instance->dip, CE_WARN,
+		    "could not alloc reply queue");
 		return (DDI_FAILURE);
 	}
 
@@ -339,7 +339,8 @@ mrsas_tbolt_alloc_additional_dma_buffer(struct mrsas_instance *instance)
 
 	if (mrsas_alloc_dma_obj(instance, &instance->mfi_evt_detail_obj,
 	    (uchar_t)DDI_STRUCTURE_LE_ACC) != 1) {
-		cmn_err(CE_WARN, "mrsas_tbolt_alloc_additional_dma_buffer: "
+		dev_err(instance->dip, CE_WARN,
+		    "mrsas_tbolt_alloc_additional_dma_buffer: "
 		    "could not allocate data transfer buffer.");
 		goto fail_tbolt_additional_buff;
 	}
@@ -364,7 +365,7 @@ mrsas_tbolt_alloc_additional_dma_buffer(struct mrsas_instance *instance)
 
 		if (mrsas_alloc_dma_obj(instance, &instance->ld_map_obj[i],
 		    (uchar_t)DDI_STRUCTURE_LE_ACC) != 1) {
-			cmn_err(CE_WARN,
+			dev_err(instance->dip, CE_WARN,
 			    "could not allocate data transfer buffer.");
 			goto fail_tbolt_additional_buff;
 		}
@@ -460,8 +461,7 @@ alloc_req_rep_desc(struct mrsas_instance *instance)
 
 	if (mrsas_alloc_dma_obj(instance, &instance->reply_desc_dma_obj,
 	    (uchar_t)DDI_STRUCTURE_LE_ACC) != 1) {
-		cmn_err(CE_WARN,
-		    "mr_sas: could not alloc reply queue");
+		dev_err(instance->dip, CE_WARN, "could not alloc reply queue");
 		return (DDI_FAILURE);
 	}
 
@@ -523,8 +523,8 @@ alloc_req_rep_desc(struct mrsas_instance *instance)
 
 	if (mrsas_alloc_dma_obj(instance, &instance->request_desc_dma_obj,
 	    (uchar_t)DDI_STRUCTURE_LE_ACC) != 1) {
-		cmn_err(CE_WARN,
-		    "mr_sas: could not alloc request queue desc");
+		dev_err(instance->dip, CE_WARN,
+		    "could not alloc request queue desc");
 		goto fail_undo_reply_queue;
 	}
 
@@ -669,7 +669,7 @@ alloc_space_for_mpi2(struct mrsas_instance *instance)
 {
 	/* Allocate command pool (memory for cmd_list & individual commands) */
 	if (mrsas_alloc_cmd_pool_tbolt(instance)) {
-		cmn_err(CE_WARN, "Error creating cmd pool");
+		dev_err(instance->dip, CE_WARN, "Error creating cmd pool");
 		return (DDI_FAILURE);
 	}
 
@@ -696,7 +696,7 @@ alloc_space_for_mpi2(struct mrsas_instance *instance)
 	/* Allocate Request and Reply descriptors Array */
 	/* Make sure the buffer is aligned to 8 for req/rep  descriptor Pool */
 	if (alloc_req_rep_desc(instance)) {
-		cmn_err(CE_WARN,
+		dev_err(instance->dip, CE_WARN,
 		    "Error, allocating memory for descripter-pool");
 		goto mpi2_undo_cmd_pool;
 	}
@@ -706,7 +706,7 @@ alloc_space_for_mpi2(struct mrsas_instance *instance)
 
 	/* Allocate MFI Frame pool - for MPI-MFI passthru commands */
 	if (create_mfi_frame_pool(instance)) {
-		cmn_err(CE_WARN,
+		dev_err(instance->dip, CE_WARN,
 		    "Error, allocating memory for MFI frame-pool");
 		goto mpi2_undo_descripter_pool;
 	}
@@ -719,7 +719,7 @@ alloc_space_for_mpi2(struct mrsas_instance *instance)
 	 */
 
 	if (create_mpi2_frame_pool(instance)) {
-		cmn_err(CE_WARN,
+		dev_err(instance->dip, CE_WARN,
 		    "Error, allocating memory for MPI2 Message-pool");
 		goto mpi2_undo_mfi_frame_pool;
 	}
@@ -740,7 +740,7 @@ alloc_space_for_mpi2(struct mrsas_instance *instance)
 
 	/* Allocate additional dma buffer */
 	if (mrsas_tbolt_alloc_additional_dma_buffer(instance)) {
-		cmn_err(CE_WARN,
+		dev_err(instance->dip, CE_WARN,
 		    "Error, allocating tbolt additional DMA buffer");
 		goto mpi2_undo_message_pool;
 	}
@@ -782,13 +782,13 @@ mrsas_init_adapter_tbolt(struct mrsas_instance *instance)
 	}
 
 	con_log(CL_ANN, (CE_NOTE, "mrsas_init_adapter_tbolt: "
-	    " instance->max_fw_cmds 0x%X.", instance->max_fw_cmds));
+	    "instance->max_fw_cmds 0x%X.", instance->max_fw_cmds));
 
 
 	/* create a pool of commands */
 	if (alloc_space_for_mpi2(instance) != DDI_SUCCESS) {
-		cmn_err(CE_WARN,
-		    " alloc_space_for_mpi2() failed.");
+		dev_err(instance->dip, CE_WARN,
+		    "alloc_space_for_mpi2() failed.");
 
 		return (DDI_FAILURE);
 	}
@@ -796,8 +796,8 @@ mrsas_init_adapter_tbolt(struct mrsas_instance *instance)
 	/* Send ioc init message */
 	/* NOTE: the issue_init call does FMA checking already. */
 	if (mrsas_issue_init_mpi2(instance) != DDI_SUCCESS) {
-		cmn_err(CE_WARN,
-		    " mrsas_issue_init_mpi2() failed.");
+		dev_err(instance->dip, CE_WARN,
+		    "mrsas_issue_init_mpi2() failed.");
 
 		goto fail_init_fusion;
 	}
@@ -836,7 +836,7 @@ mrsas_issue_init_mpi2(struct mrsas_instance *instance)
 
 	if (mrsas_alloc_dma_obj(instance, &init2_dma_obj,
 	    (uchar_t)DDI_STRUCTURE_LE_ACC) != 1) {
-		cmn_err(CE_WARN, "mr_sas_issue_init_mpi2 "
+		dev_err(instance->dip, CE_WARN, "mr_sas_issue_init_mpi2 "
 		    "could not allocate data transfer buffer.");
 		return (DDI_FAILURE);
 	}
@@ -1016,7 +1016,7 @@ mrsas_tbolt_ioc_init(struct mrsas_instance *instance, dma_obj_t *mpi2_dma_obj)
 
 	if (mrsas_alloc_dma_obj(instance, &instance->drv_ver_dma_obj,
 	    (uchar_t)DDI_STRUCTURE_LE_ACC) != 1) {
-		cmn_err(CE_WARN,
+		dev_err(instance->dip, CE_WARN,
 		    "fusion init: Could not allocate driver version buffer.");
 		return (DDI_FAILURE);
 	}
@@ -1122,7 +1122,7 @@ mrsas_tbolt_tran_start(struct scsi_address *ap, struct scsi_pkt *pkt)
 
 	con_log(CL_DLEVEL1, (CE_NOTE, "chkpnt:%s:%d", __func__, __LINE__));
 	if (instance->deadadapter == 1) {
-		cmn_err(CE_WARN,
+		dev_err(instance->dip, CE_WARN,
 		    "mrsas_tran_start:TBOLT return TRAN_FATAL_ERROR "
 		    "for IO, as the HBA doesnt take any more IOs");
 		if (pkt) {
@@ -1164,7 +1164,7 @@ mrsas_tbolt_tran_start(struct scsi_address *ap, struct scsi_pkt *pkt)
 
 	if ((pkt->pkt_flags & FLAG_NOINTR) == 0) {
 		if (instance->fw_outstanding > instance->max_fw_cmds) {
-			cmn_err(CE_WARN,
+			dev_err(instance->dip, CE_WARN,
 			    "Command Queue Full... Returning BUSY");
 			return_raid_msg_pkt(instance, cmd);
 			return (TRAN_BUSY);
@@ -1573,7 +1573,8 @@ mrsas_tbolt_build_cmd(struct mrsas_instance *instance, struct scsi_address *ap,
 
 			if (instance->tbolt &&
 			    ((lba_count * 512) > mrsas_tbolt_max_cap_maxxfer)) {
-				cmn_err(CE_WARN, " IO SECTOR COUNT exceeds "
+				dev_err(instance->dip, CE_WARN,
+				    "IO SECTOR COUNT exceeds "
 				    "controller limit 0x%x sectors",
 				    lba_count);
 			}
@@ -1599,7 +1600,8 @@ mrsas_tbolt_build_cmd(struct mrsas_instance *instance, struct scsi_address *ap,
 			if ((MR_TargetIdToLdGet(
 			    acmd->device_id, local_map_ptr) >=
 			    MAX_LOGICAL_DRIVES) || !instance->fast_path_io) {
-				cmn_err(CE_NOTE, "Fast Path NOT Possible, "
+				dev_err(instance->dip, CE_NOTE,
+				    "Fast Path NOT Possible, "
 				    "targetId >= MAX_LOGICAL_DRIVES || "
 				    "!instance->fast_path_io");
 				fp_possible = 0;
@@ -2379,7 +2381,8 @@ tbolt_complete_cmd(struct mrsas_instance *instance,
 			pkt->pkt_reason	= CMD_TRAN_ERR;
 			break;
 		case MFI_STAT_SCSI_IO_FAILED:
-			cmn_err(CE_WARN, "tbolt_complete_cmd: scsi_io failed");
+			dev_err(instance->dip, CE_WARN,
+			    "tbolt_complete_cmd: scsi_io failed");
 			pkt->pkt_reason	= CMD_TRAN_ERR;
 			break;
 		case MFI_STAT_SCSI_DONE_WITH_ERROR:
@@ -2416,7 +2419,7 @@ tbolt_complete_cmd(struct mrsas_instance *instance,
 			}
 			break;
 		case MFI_STAT_LD_OFFLINE:
-			cmn_err(CE_WARN,
+			dev_err(instance->dip, CE_WARN,
 			    "tbolt_complete_cmd: ld offline "
 			    "CDB[0]=0x%x targetId=0x%x devhandle=0x%x",
 			    /* UNDO: */
@@ -2466,7 +2469,8 @@ tbolt_complete_cmd(struct mrsas_instance *instance,
 		case MFI_STAT_INVALID_PARAMETER:
 		case MFI_STAT_INVALID_SEQUENCE_NUMBER:
 		default:
-			cmn_err(CE_WARN, "tbolt_complete_cmd: Unknown status!");
+			dev_err(instance->dip, CE_WARN,
+			    "tbolt_complete_cmd: Unknown status!");
 			pkt->pkt_reason	= CMD_TRAN_ERR;
 
 			break;
@@ -2509,14 +2513,14 @@ tbolt_complete_cmd(struct mrsas_instance *instance,
 			    "LDMAP sync command	SMID RECEIVED 0x%X",
 			    cmd->SMID));
 			if (cmd->frame->hdr.cmd_status != 0) {
-				cmn_err(CE_WARN,
+				dev_err(instance->dip, CE_WARN,
 				    "map sync failed, status = 0x%x.",
 				    cmd->frame->hdr.cmd_status);
 			} else {
 				instance->map_id++;
-				cmn_err(CE_NOTE,
+				con_log(CL_ANN1, (CE_NOTE,
 				    "map sync received, switched map_id to %"
-				    PRIu64 " \n", instance->map_id);
+				    PRIu64, instance->map_id));
 			}
 
 			if (MR_ValidateMapInfo(
@@ -2539,7 +2543,10 @@ tbolt_complete_cmd(struct mrsas_instance *instance,
 				(void) mrsas_tbolt_sync_map_info(instance);
 			}
 
-			cmn_err(CE_NOTE, "LDMAP sync completed.");
+			con_log(CL_ANN1, (CE_NOTE,
+			    "LDMAP sync completed, ldcount=%d",
+			    instance->ld_map[instance->map_id & 1]
+			    ->raidMap.ldCount));
 			mutex_exit(&instance->sync_map_mtx);
 			break;
 		}
@@ -2767,7 +2774,7 @@ mrsas_tbolt_get_ld_map_info(struct mrsas_instance *instance)
 	cmd = get_raid_msg_pkt(instance);
 
 	if (cmd == NULL) {
-		cmn_err(CE_WARN,
+		dev_err(instance->dip, CE_WARN,
 		    "Failed to get a cmd from free-pool in get_ld_map_info()");
 		return (DDI_FAILURE);
 	}
@@ -2785,7 +2792,8 @@ mrsas_tbolt_get_ld_map_info(struct mrsas_instance *instance)
 	ci_h = instance->ld_map_phy[instance->map_id & 1];
 
 	if (!ci) {
-		cmn_err(CE_WARN, "Failed to alloc mem for ld_map_info");
+		dev_err(instance->dip, CE_WARN,
+		    "Failed to alloc mem for ld_map_info");
 		return_raid_msg_pkt(instance, cmd);
 		return (-1);
 	}
@@ -2811,7 +2819,7 @@ mrsas_tbolt_get_ld_map_info(struct mrsas_instance *instance)
 		ret = 0;
 		con_log(CL_ANN1, (CE_NOTE, "Get LD Map Info success"));
 	} else {
-		cmn_err(CE_WARN, "Get LD Map Info failed");
+		dev_err(instance->dip, CE_WARN, "Get LD Map Info failed");
 		ret = -1;
 	}
 
@@ -3103,7 +3111,7 @@ mrsas_tbolt_check_map_info(struct mrsas_instance *instance)
 	}
 
 	instance->fast_path_io = 0;
-	cmn_err(CE_WARN, "MR_ValidateMapInfo failed");
+	dev_err(instance->dip, CE_WARN, "MR_ValidateMapInfo failed");
 	con_log(CL_ANN, (CE_NOTE,
 	    "instance->fast_path_io %d", instance->fast_path_io));
 
@@ -3119,7 +3127,7 @@ mrsas_tbolt_check_map_info(struct mrsas_instance *instance)
 void
 mrsas_tbolt_kill_adapter(struct mrsas_instance *instance)
 {
-	cmn_err(CE_NOTE, "TBOLT Kill adapter called");
+	dev_err(instance->dip, CE_NOTE, "TBOLT Kill adapter called");
 
 	if (instance->deadadapter == 1)
 		return;
@@ -3168,7 +3176,7 @@ mrsas_tbolt_reset_ppc(struct mrsas_instance *instance)
 	    "mrsas_tbolt_reset_ppc entered"));
 
 	if (instance->deadadapter == 1) {
-		cmn_err(CE_WARN, "mrsas_tbolt_reset_ppc: "
+		dev_err(instance->dip, CE_WARN, "mrsas_tbolt_reset_ppc: "
 		    "no more resets as HBA has been marked dead ");
 		return (DDI_FAILURE);
 	}
@@ -3211,7 +3219,7 @@ retry_reset:
 		delay(100 * drv_usectohz(MILLISEC));
 		status = RD_TBOLT_HOST_DIAG(instance);
 		if (retry++ == 100) {
-			cmn_err(CE_WARN,
+			dev_err(instance->dip, CE_WARN,
 			    "mrsas_tbolt_reset_ppc:"
 			    "resetadapter bit is set already "
 			    "check retry count %d", retry);
@@ -3235,9 +3243,8 @@ retry_reset:
 			/* Dont call kill adapter here */
 			/* RESET BIT ADAPTER is cleared by firmare */
 			/* mrsas_tbolt_kill_adapter(instance); */
-			cmn_err(CE_WARN,
-			    "mr_sas %d: %s(): RESET FAILED; return failure!!!",
-			    instance->instance, __func__);
+			dev_err(instance->dip, CE_WARN,
+			    "%s(): RESET FAILED; return failure!!!", __func__);
 			return (DDI_FAILURE);
 		}
 	}
@@ -3254,7 +3261,7 @@ retry_reset:
 		abs_state = instance->func_ptr->read_fw_status_reg(instance);
 	}
 	if (abs_state <= MFI_STATE_FW_INIT) {
-		cmn_err(CE_WARN,
+		dev_err(instance->dip, CE_WARN,
 		    "mrsas_tbolt_reset_ppc: firmware state < MFI_STATE_FW_INIT"
 		    "state = 0x%x, RETRY RESET.", abs_state);
 		goto retry_reset;
@@ -3282,18 +3289,18 @@ retry_reset:
 			instance->fw_fault_count_after_ocr++;
 			if (instance->fw_fault_count_after_ocr
 			    < MAX_FW_RESET_COUNT) {
-				cmn_err(CE_WARN, "mrsas_tbolt_reset_ppc: "
+				dev_err(instance->dip, CE_WARN,
+				    "mrsas_tbolt_reset_ppc: "
 				    "FW is in fault after OCR count %d "
 				    "Retry Reset",
 				    instance->fw_fault_count_after_ocr);
 				goto retry_reset;
 
 			} else {
-				cmn_err(CE_WARN, "mrsas %d: %s:"
+				dev_err(instance->dip, CE_WARN, "%s:"
 				    "Max Reset Count exceeded >%d"
 				    "Mark HBA as bad, KILL adapter",
-				    instance->instance, __func__,
-				    MAX_FW_RESET_COUNT);
+				    __func__, MAX_FW_RESET_COUNT);
 
 				mrsas_tbolt_kill_adapter(instance);
 				return (DDI_FAILURE);
@@ -3311,7 +3318,7 @@ retry_reset:
 	    "Calling mrsas_issue_init_mpi2"));
 	abs_state = mrsas_issue_init_mpi2(instance);
 	if (abs_state == (uint32_t)DDI_FAILURE) {
-		cmn_err(CE_WARN, "mrsas_tbolt_reset_ppc: "
+		dev_err(instance->dip, CE_WARN, "mrsas_tbolt_reset_ppc: "
 		    "INIT failed Retrying Reset");
 		goto retry_reset;
 	}
@@ -3380,8 +3387,9 @@ mrsas_tbolt_sync_map_info(struct mrsas_instance *instance)
 	cmd = get_raid_msg_pkt(instance);
 
 	if (cmd == NULL) {
-		cmn_err(CE_WARN, "Failed to get a cmd from free-pool in "
-		    "mrsas_tbolt_sync_map_info(). ");
+		dev_err(instance->dip, CE_WARN,
+		    "Failed to get a cmd from free-pool in "
+		    "mrsas_tbolt_sync_map_info().");
 		return (DDI_FAILURE);
 	}
 
@@ -3474,7 +3482,7 @@ abort_syncmap_cmd(struct mrsas_instance *instance,
 	cmd = get_raid_msg_mfi_pkt(instance);
 
 	if (!cmd) {
-		cmn_err(CE_WARN,
+		dev_err(instance->dip, CE_WARN,
 		    "Failed to get a cmd from free-pool abort_syncmap_cmd().");
 		return (DDI_FAILURE);
 	}
@@ -3573,9 +3581,9 @@ mrsas_tbolt_config_pd(struct mrsas_instance *instance, uint16_t tgt,
 
 		if (scsi_hba_probe(sd, NULL) == SCSIPROBE_EXISTS) {
 			rval = mrsas_config_scsi_device(instance, sd, ldip);
-			con_log(CL_DLEVEL1, (CE_NOTE,
-			    "Phys. device found: tgt %d dtype %d: %s",
-			    tgt, dtype, sd->sd_inq->inq_vid));
+			dev_err(instance->dip, CE_CONT,
+			    "?Phys. device found: tgt %d dtype %d: %s\n",
+			    tgt, dtype, sd->sd_inq->inq_vid);
 		} else {
 			rval = NDI_FAILURE;
 			con_log(CL_DLEVEL1, (CE_NOTE, "Phys. device Not found "
@@ -3591,7 +3599,7 @@ mrsas_tbolt_config_pd(struct mrsas_instance *instance, uint16_t tgt,
 		kmem_free(sd, sizeof (struct scsi_device));
 	} else {
 		con_log(CL_ANN1, (CE_NOTE,
-		    "Device not supported: tgt %d lun %d dtype %d",
+		    "?Device not supported: tgt %d lun %d dtype %d",
 		    tgt, lun, dtype));
 		rval = NDI_FAILURE;
 	}

