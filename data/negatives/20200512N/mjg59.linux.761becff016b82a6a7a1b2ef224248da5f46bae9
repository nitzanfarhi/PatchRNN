commit 761becff016b82a6a7a1b2ef224248da5f46bae9
Author: Jonathan Brassow <jbrassow@redhat.com>
Date:   Thu Oct 11 13:42:19 2012 +1100

    DM RAID: Fix for "sync" directive ineffectiveness
    
    There are two table arguments that can be given to a DM RAID target
    that control whether the array is forced to (re)synchronize or skip
    initialization: "sync" and "nosync".  When "sync" is given, we set
    mddev->recovery_cp to 0 in order to cause the device to resynchronize.
    This is insufficient if there is a bitmap in use, because the array
    will simply look at the bitmap and see that there is no recovery
    necessary.
    
    The fix is to skip over the loading of the superblocks when "sync" is
    given, causing new superblocks to be written that will force the array
    to go through initialization (i.e. synchronization).
    
    Signed-off-by: Jonathan Brassow <jbrassow@redhat.com>
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/dm-raid.c b/drivers/md/dm-raid.c
index 89a06a361332..45d94a7e7f6d 100644
--- a/drivers/md/dm-raid.c
+++ b/drivers/md/dm-raid.c
@@ -1017,6 +1017,19 @@ static int analyse_superblocks(struct dm_target *ti, struct raid_set *rs)
 
 	freshest = NULL;
 	rdev_for_each_safe(rdev, tmp, mddev) {
+		/*
+		 * Skipping super_load due to DMPF_SYNC will cause
+		 * the array to undergo initialization again as
+		 * though it were new.  This is the intended effect
+		 * of the "sync" directive.
+		 *
+		 * When reshaping capability is added, we must ensure
+		 * that the "sync" directive is disallowed during the
+		 * reshape.
+		 */
+		if (rs->print_flags & DMPF_SYNC)
+			continue;
+
 		if (!rdev->meta_bdev)
 			continue;
 

