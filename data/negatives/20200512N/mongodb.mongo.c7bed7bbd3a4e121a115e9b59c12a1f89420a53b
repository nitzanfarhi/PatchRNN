commit c7bed7bbd3a4e121a115e9b59c12a1f89420a53b
Author: Antonio Juliano <ajuliano@princeton.edu>
Date:   Wed Jul 30 16:54:30 2014 -0400

    SERVER-14732 Fixed an issue where a cursor locate was being called with an empty argument
    
    Closes #728
    
    Signed-off-by: Benety Goh <benety@mongodb.com>

diff --git a/src/mongo/db/storage/heap1/heap1_btree_impl.cpp b/src/mongo/db/storage/heap1/heap1_btree_impl.cpp
index 1316934614..39b136d960 100644
--- a/src/mongo/db/storage/heap1/heap1_btree_impl.cpp
+++ b/src/mongo/db/storage/heap1/heap1_btree_impl.cpp
@@ -74,6 +74,8 @@ namespace {
 
             // Iterate through both BSONObjects, comparing individual elements one by one
             for (unsigned mask = 1; lhsIt.more(); mask <<= 1) {
+                invariant(rhsIt.more());
+
                 const BSONElement l = lhsIt.next();
                 const BSONElement r = rhsIt.next();
 
@@ -103,9 +105,7 @@ namespace {
 
             }
 
-            // There's no more data in lhs, but there's data in rhs. So, rhs is greater than lhs.
-            if (rhsIt.more())
-                return 1;
+            invariant(!rhsIt.more());
 
             // This means just look at the key, not the loc.
             if (lhs.loc.isNull() || rhs.loc.isNull())
@@ -372,6 +372,12 @@ namespace {
             }
 
             virtual bool locate(const BSONObj& keyRaw, const DiskLoc& loc) {
+                // An empty key means we should seek to the front
+                if (keyRaw.isEmpty()) {
+                    _it = _data.begin();
+                    return false;
+                }
+
                 const BSONObj key = stripFieldNames(keyRaw);
                 _it = _data.lower_bound(IndexEntry(key, loc)); // lower_bound is >= key
                 return _it != _data.end() && (_it->key == key); // intentionally not comparing loc
@@ -473,6 +479,13 @@ namespace {
             }
 
             virtual bool locate(const BSONObj& keyRaw, const DiskLoc& loc) {
+                // An empty key means we should seek to the seek to the end, 
+                // i.e. one past the lowest key in the iterator
+                if (keyRaw.isEmpty()) {
+                    _it = _data.rend();
+                    return false;
+                }
+
                 const BSONObj key = stripFieldNames(keyRaw);
                 _it = lower_bound(IndexEntry(key, loc)); // lower_bound is <= query
                 return _it != _data.rend() && (_it->key == key); // intentionally not comparing loc
diff --git a/src/mongo/db/storage/mmap_v1/btree/btree_logic_test.cpp b/src/mongo/db/storage/mmap_v1/btree/btree_logic_test.cpp
index ca6cdce9a9..ee52e8796a 100644
--- a/src/mongo/db/storage/mmap_v1/btree/btree_logic_test.cpp
+++ b/src/mongo/db/storage/mmap_v1/btree/btree_logic_test.cpp
@@ -1974,6 +1974,44 @@ namespace mongo {
         }
     };
 
+    template<class OnDiskFormat>
+    class LocateEmptyForward : public BtreeLogicTestBase<OnDiskFormat> {
+    public:
+        void run() {
+            OperationContextNoop txn;
+            this->_helper.btree.initAsEmpty(&txn);
+
+            BSONObj key1 = simpleKey('a');
+            this->insert(key1, this->_helper.dummyDiskLoc);
+            BSONObj key2 = simpleKey('b');
+            this->insert(key2, this->_helper.dummyDiskLoc);
+            BSONObj key3 = simpleKey('c');
+            this->insert(key3, this->_helper.dummyDiskLoc);
+
+            this->checkValidNumKeys(3);
+            this->locate(BSONObj(), 0, false, this->_helper.headManager.getHead(), 1);
+        }
+    };
+
+    template<class OnDiskFormat>
+    class LocateEmptyReverse : public BtreeLogicTestBase<OnDiskFormat> {
+    public:
+        void run() {
+            OperationContextNoop txn;
+            this->_helper.btree.initAsEmpty(&txn);
+
+            BSONObj key1 = simpleKey('a');
+            this->insert(key1, this->_helper.dummyDiskLoc);
+            BSONObj key2 = simpleKey('b');
+            this->insert(key2, this->_helper.dummyDiskLoc);
+            BSONObj key3 = simpleKey('c');
+            this->insert(key3, this->_helper.dummyDiskLoc);
+
+            this->checkValidNumKeys(3);
+            this->locate(BSONObj(), -1, false, DiskLoc(), -1);
+        }
+    };
+
     /* This test requires the entire server to be linked-in and it is better implemented using
        the JS framework. Disabling here and will put in jsCore.
 
@@ -2198,6 +2236,9 @@ namespace mongo {
             add< DelInternalReplacementNextNonNull<OnDiskFormat> >();
             add< DelInternalSplitPromoteLeft<OnDiskFormat> >();
             add< DelInternalSplitPromoteRight<OnDiskFormat> >();
+
+            add< LocateEmptyForward<OnDiskFormat> >();
+            add< LocateEmptyReverse<OnDiskFormat> >();
         }
     };
 

