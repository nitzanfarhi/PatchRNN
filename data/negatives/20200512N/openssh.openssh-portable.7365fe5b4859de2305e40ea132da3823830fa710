commit 7365fe5b4859de2305e40ea132da3823830fa710
Author: Damien Miller <djm@mindrot.org>
Date:   Wed Oct 14 08:25:09 2015 +1100

    upstream commit
    
    revision 1.14
    date: 2011/07/24 21:03:00;  author: miod;  state: Exp;  lines: +35 -13;
    Recent Single Unix will malloc memory if the second argument of realpath()
    is NULL, and third-party software is starting to rely upon this.
    Adapted from FreeBSD via Jona Joachim (jaj ; hcl-club , .lu), with minor
    tweaks from nicm@ and yours truly.

diff --git a/openbsd-compat/realpath.c b/openbsd-compat/realpath.c
index ba4cea93..6646330c 100644
--- a/openbsd-compat/realpath.c
+++ b/openbsd-compat/realpath.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: realpath.c,v 1.13 2005/08/08 08:05:37 espie Exp $ */
+/*	$OpenBSD: realpath.c,v 1.14 2011/07/24 21:03:00 miod Exp $ */
 /*
  * Copyright (c) 2003 Constantin S. Svintsoff <kostik@iclub.nsu.ru>
  *
@@ -51,16 +51,30 @@
  * in which case the path which caused trouble is left in (resolved).
  */
 char *
-realpath(const char *path, char resolved[PATH_MAX])
+realpath(const char *path, char *resolved)
 {
 	struct stat sb;
 	char *p, *q, *s;
 	size_t left_len, resolved_len;
 	unsigned symlinks;
-	int serrno, slen;
+	int serrno, slen, mem_allocated;
 	char left[PATH_MAX], next_token[PATH_MAX], symlink[PATH_MAX];
 
+	if (path[0] == '\0') {
+		errno = ENOENT;
+		return (NULL);
+	}
+
 	serrno = errno;
+
+	if (resolved == NULL) {
+		resolved = malloc(PATH_MAX);
+		if (resolved == NULL)
+			return (NULL);
+		mem_allocated = 1;
+	} else
+		mem_allocated = 0;
+
 	symlinks = 0;
 	if (path[0] == '/') {
 		resolved[0] = '/';
@@ -71,7 +85,10 @@ realpath(const char *path, char resolved[PATH_MAX])
 		left_len = strlcpy(left, path + 1, sizeof(left));
 	} else {
 		if (getcwd(resolved, PATH_MAX) == NULL) {
-			strlcpy(resolved, ".", PATH_MAX);
+			if (mem_allocated)
+				free(resolved);
+			else
+				strlcpy(resolved, ".", PATH_MAX);
 			return (NULL);
 		}
 		resolved_len = strlen(resolved);
@@ -79,7 +96,7 @@ realpath(const char *path, char resolved[PATH_MAX])
 	}
 	if (left_len >= sizeof(left) || resolved_len >= PATH_MAX) {
 		errno = ENAMETOOLONG;
-		return (NULL);
+		goto err;
 	}
 
 	/*
@@ -94,7 +111,7 @@ realpath(const char *path, char resolved[PATH_MAX])
 		s = p ? p : left + left_len;
 		if (s - left >= (ptrdiff_t)sizeof(next_token)) {
 			errno = ENAMETOOLONG;
-			return (NULL);
+			goto err;
 		}
 		memcpy(next_token, left, s - left);
 		next_token[s - left] = '\0';
@@ -104,7 +121,7 @@ realpath(const char *path, char resolved[PATH_MAX])
 		if (resolved[resolved_len - 1] != '/') {
 			if (resolved_len + 1 >= PATH_MAX) {
 				errno = ENAMETOOLONG;
-				return (NULL);
+				goto err;
 			}
 			resolved[resolved_len++] = '/';
 			resolved[resolved_len] = '\0';
@@ -135,23 +152,23 @@ realpath(const char *path, char resolved[PATH_MAX])
 		resolved_len = strlcat(resolved, next_token, PATH_MAX);
 		if (resolved_len >= PATH_MAX) {
 			errno = ENAMETOOLONG;
-			return (NULL);
+			goto err;
 		}
 		if (lstat(resolved, &sb) != 0) {
 			if (errno == ENOENT && p == NULL) {
 				errno = serrno;
 				return (resolved);
 			}
-			return (NULL);
+			goto err;
 		}
 		if (S_ISLNK(sb.st_mode)) {
 			if (symlinks++ > MAXSYMLINKS) {
 				errno = ELOOP;
-				return (NULL);
+				goto err;
 			}
 			slen = readlink(resolved, symlink, sizeof(symlink) - 1);
 			if (slen < 0)
-				return (NULL);
+				goto err;
 			symlink[slen] = '\0';
 			if (symlink[0] == '/') {
 				resolved[1] = 0;
@@ -174,7 +191,7 @@ realpath(const char *path, char resolved[PATH_MAX])
 					if (slen + 1 >=
 					    (ptrdiff_t)sizeof(symlink)) {
 						errno = ENAMETOOLONG;
-						return (NULL);
+						goto err;
 					}
 					symlink[slen] = '/';
 					symlink[slen + 1] = 0;
@@ -182,7 +199,7 @@ realpath(const char *path, char resolved[PATH_MAX])
 				left_len = strlcat(symlink, left, sizeof(left));
 				if (left_len >= sizeof(left)) {
 					errno = ENAMETOOLONG;
-					return (NULL);
+					goto err;
 				}
 			}
 			left_len = strlcpy(left, symlink, sizeof(left));
@@ -196,5 +213,10 @@ realpath(const char *path, char resolved[PATH_MAX])
 	if (resolved_len > 1 && resolved[resolved_len - 1] == '/')
 		resolved[resolved_len - 1] = '\0';
 	return (resolved);
+
+err:
+	if (mem_allocated)
+		free(resolved);
+	return (NULL);
 }
 #endif /* !defined(HAVE_REALPATH) || defined(BROKEN_REALPATH) */

