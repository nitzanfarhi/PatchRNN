commit b515a34676b6be77c6458dcac0f98ff5b9d1316f
Author: pancake <pancake@nopcode.org>
Date:   Mon Sep 14 12:35:38 2015 +0200

    More stdboolification

diff --git a/libr/core/anal.c b/libr/core/anal.c
index 4d800183f..68b5931c7 100644
--- a/libr/core/anal.c
+++ b/libr/core/anal.c
@@ -151,7 +151,7 @@ R_API ut64 r_core_anal_address (RCore *core, ut64 addr) {
 }
 
 /* suggest a name for the function at the address 'addr'.
- * If dump is R_TRUE, every strings associated with the function is printed */
+ * If dump is true, every strings associated with the function is printed */
 R_API char *r_core_anal_fcn_autoname(RCore *core, ut64 addr, int dump) {
 	int use_getopt = 0;
 	int use_isatty = 0;
@@ -235,7 +235,7 @@ static int core_anal_fcn(RCore *core, ut64 at, ut64 from, int reftype, int depth
 	fcn = r_anal_fcn_new ();
 	if (!fcn) {
 		eprintf ("Error: new (fcn)\n");
-		return R_FALSE;
+		return false;
 	}
 
 	hint = r_anal_hint_get (core->anal, at);
@@ -315,7 +315,7 @@ static int core_anal_fcn(RCore *core, ut64 at, ut64 from, int reftype, int depth
 			// XXX fixes overlined function ranges wtf  // fcn->addr = at;
 			/* TODO: Dupped analysis, needs more optimization */
 			fcn->depth = 256;
-			r_core_anal_bb (core, fcn, fcn->addr, R_TRUE);
+			r_core_anal_bb (core, fcn, fcn->addr, true);
 			// hack
 			if (fcn->depth == 0) {
 				eprintf ("Analysis depth reached at 0x%08"PFMT64x"\n", fcn->addr);
@@ -389,7 +389,7 @@ static int core_anal_fcn(RCore *core, ut64 at, ut64 from, int reftype, int depth
 		}
 		free (next);
 	}
-	return R_TRUE;
+	return true;
 
 error:
 	free (buf);
@@ -430,7 +430,7 @@ error:
 			}
 		}
 	}
-	return R_FALSE;
+	return false;
 }
 
 /* decode and return the RANalOp at the address addr */
@@ -765,15 +765,15 @@ R_API int r_core_anal_bb(RCore *core, RAnalFunction *fcn, ut64 at, int head) {
 	struct r_anal_bb_t *bb, *bbi;
 	RListIter *iter;
 	ut64 jump, fail;
-	int rc = R_TRUE;
+	int rc = true;
 	ut8 *buf = NULL;
 	int ret = R_ANAL_RET_NEW, buflen, bblen = 0;
 
 	--fcn->depth;
-	if (fcn->depth <= 0) return R_FALSE;
+	if (fcn->depth <= 0) return false;
 
 	bb = r_anal_bb_new ();
-	if (!bb) return R_FALSE;
+	if (!bb) return false;
 
 	if (core->anal->split) {
 		ret = r_anal_fcn_split_bb (core->anal, fcn, bb, at);
@@ -813,18 +813,18 @@ R_API int r_core_anal_bb(RCore *core, RAnalFunction *fcn, ut64 at, int head) {
 					fail = bb->fail;
 					jump = bb->jump;
 					if (fail != -1)
-						r_core_anal_bb (core, fcn, fail, R_FALSE);
+						r_core_anal_bb (core, fcn, fail, false);
 					if (jump != -1)
-						r_core_anal_bb (core, fcn, jump, R_FALSE);
+						r_core_anal_bb (core, fcn, jump, false);
 				}
 			}
 		} while (bblen != R_ANAL_RET_END);
 		free (buf);
-		return R_TRUE;
+		return true;
 	}
 	goto fin;
 error:
-	rc = R_FALSE;
+	rc = false;
 fin:
 	r_list_delete_data (fcn->bbs, bb);
 	r_anal_bb_free (bb);
@@ -855,7 +855,7 @@ R_API int r_core_anal_bb_seek(RCore *core, ut64 addr) {
 	if (bbaddr != UT64_MAX) {
 		addr = bbaddr;
 	}
-	return r_core_seek (core, addr, R_FALSE);
+	return r_core_seek (core, addr, false);
 }
 
 R_API int r_core_anal_esil_fcn(RCore *core, ut64 at, ut64 from, int reftype, int depth) {
@@ -889,7 +889,7 @@ R_API int r_core_anal_fcn(RCore *core, ut64 at, ut64 from, int reftype, int dept
 
 	if (core->io->va && !core->io->raw) {
 		if (!r_io_is_valid_offset (core->io, at, !core->anal->opt.noncode))
-			return R_FALSE;
+			return false;
 	}
 	if (r_config_get_i (core->config, "anal.a2f")) {
 		r_core_cmd0 (core, ".a2f");
@@ -916,9 +916,9 @@ R_API int r_core_anal_fcn(RCore *core, ut64 at, ut64 from, int reftype, int dept
 		return result;
 	}
 
-	if (from != UT64_MAX && at == 0) return R_FALSE;
-	if (at == UT64_MAX || depth < 0) return R_FALSE;
-	if (r_cons_singleton()->breaked) return R_FALSE;
+	if (from != UT64_MAX && at == 0) return false;
+	if (at == UT64_MAX || depth < 0) return false;
+	if (r_cons_singleton()->breaked) return false;
 
 	fcn = r_anal_get_fcn_in (core->anal, at, 0);
 	if (fcn) {
@@ -929,12 +929,12 @@ R_API int r_core_anal_fcn(RCore *core, ut64 at, ut64 from, int reftype, int dept
 		// avoid dupes
 		r_list_foreach (fcn->xrefs, iter, ref)
 			if (from == ref->addr)
-				return R_TRUE;
+				return true;
 
 		ref = r_anal_ref_new ();
 		if (!ref) {
 			eprintf ("Error: new (xref)\n");
-			return R_FALSE;
+			return false;
 		}
 		ref->addr = from;
 		ref->at = at;
@@ -946,7 +946,7 @@ R_API int r_core_anal_fcn(RCore *core, ut64 at, ut64 from, int reftype, int dept
 			free (ref);
 		}
 
-		return R_TRUE;
+		return true;
 	}
 
 	return core_anal_fcn (core, at, from, reftype, depth);
@@ -961,7 +961,7 @@ R_API int r_core_anal_fcn_clean(RCore *core, ut64 addr) {
 	if (addr == 0) {
 		r_list_purge (core->anal->fcns);
 		if (!(core->anal->fcns = r_anal_fcn_list_new ()))
-			return R_FALSE;
+			return false;
 	} else {
 		r_list_foreach_safe (core->anal->fcns, iter, iter_tmp, fcni) {
 			if (in_function (fcni, addr)) {
@@ -969,7 +969,7 @@ R_API int r_core_anal_fcn_clean(RCore *core, ut64 addr) {
 			}
 		}
 	}
-	return R_TRUE;
+	return true;
 }
 
 #define FMT_NO 0
@@ -1113,7 +1113,7 @@ R_API int r_core_anal_fcn_list(RCore *core, const char *input, int rad) {
 				(ut64)fcn->addr, (ut64)fcn->size,
 				(int)bbs, fcn->name? fcn->name: "");
 		}
-		return R_TRUE;
+		return true;
 	} else if (rad == 'j')  {
 		r_cons_printf ("[");
 	}
@@ -1281,7 +1281,7 @@ R_API int r_core_anal_fcn_list(RCore *core, const char *input, int rad) {
 	if (rad == 'j')  {
 		r_cons_printf ("]\n");
 	}
-	return R_TRUE;
+	return true;
 }
 
 static RList *recurse(RCore *core, RAnalBlock *from, RAnalBlock *dest);
@@ -1354,7 +1354,7 @@ R_API int r_core_anal_graph(RCore *core, ut64 addr, int opts) {
 
 	if (r_list_empty (core->anal->fcns)) {
 		eprintf ("No functions to diff\n");
-		return R_FALSE;
+		return false;
 	}
 
 	opts |= R_CORE_ANAL_GRAPHBODY;
@@ -1390,7 +1390,7 @@ R_API int r_core_anal_graph(RCore *core, ut64 addr, int opts) {
 	r_config_set_i (core->config, "asm.lines", reflines);
 	r_config_set_i (core->config, "asm.bytes", bytes);
 	r_config_set_i (core->config, "asm.dwarf", dwarf);
-	return R_TRUE;
+	return true;
 }
 
 static int core_anal_followptr(RCore *core, ut64 at, ut64 ptr, ut64 ref, int code, int depth) {
@@ -1402,16 +1402,16 @@ static int core_anal_followptr(RCore *core, ut64 at, ut64 ptr, ut64 ref, int cod
 			(ut64)ref, (ut64)at);
 		else r_cons_printf ("axd 0x%08"PFMT64x" 0x%08"PFMT64x"\n",
 			(ut64)ref, (ut64)at);
-		return R_TRUE;
+		return true;
 	}
 	if (depth < 1)
-		return R_FALSE;
+		return false;
 	if (core->bin && core->bin->cur && core->bin->cur->o && core->bin->cur->o->info) {
 		endian = core->bin->cur->o->info->big_endian;
 	} else endian = CPU_ENDIAN;
 	wordsize = (int)(core->anal->bits/8);
 	if ((dataptr = r_io_read_i (core->io, ptr, wordsize, endian)) == -1)
-		return R_FALSE;
+		return false;
 	return core_anal_followptr (core, at, dataptr, ref, code, depth-1);
 }
 
@@ -1440,7 +1440,7 @@ R_API int r_core_anal_search(RCore *core, ut64 from, ut64 to, ut64 ref) {
 		if (bckwrds) {
 			if (from + core->blocksize > to) {
 				at = from;
-				do_bckwrd_srch = R_FALSE;
+				do_bckwrd_srch = false;
 			} else at = to - core->blocksize;
 		} else at = from;
 		while ((!bckwrds && at < to) || bckwrds) {
@@ -1459,20 +1459,20 @@ R_API int r_core_anal_search(RCore *core, ut64 from, ut64 to, ut64 ref) {
 				if (op.type == R_ANAL_OP_TYPE_JMP || op.type == R_ANAL_OP_TYPE_CJMP ||
 					op.type == R_ANAL_OP_TYPE_CALL || op.type == R_ANAL_OP_TYPE_CCALL) {
 					if (op.jump != -1 &&
-						core_anal_followptr (core, at+i, op.jump, ref, R_TRUE, 0)) {
+						core_anal_followptr (core, at+i, op.jump, ref, true, 0)) {
 						count ++;
 					}
 				} else if (op.type == R_ANAL_OP_TYPE_UJMP || op.type == R_ANAL_OP_TYPE_UCALL ||
 					op.type == R_ANAL_OP_TYPE_UCJMP || op.type == R_ANAL_OP_TYPE_UCCALL) {
 					if (op.ptr != -1 &&
-						core_anal_followptr (core, at+i, op.ptr, ref, R_TRUE, 1)) {
+						core_anal_followptr (core, at+i, op.ptr, ref, true, 1)) {
 						count ++;
 					}
 				} else {
 					if (op.ptr != -1 &&
 						core_anal_followptr (core,
 							at+i, op.ptr, ref,
-							R_FALSE, ptrdepth)) {
+							false, ptrdepth)) {
 						count ++;
 					}
 				}
@@ -1482,7 +1482,7 @@ R_API int r_core_anal_search(RCore *core, ut64 from, ut64 to, ut64 ref) {
 				if (at > from + core->blocksize - OPSZ) {
 					at -= core->blocksize;
 				} else {
-					do_bckwrd_srch = R_FALSE;
+					do_bckwrd_srch = false;
 					at = from;
 				}
 			} else {
@@ -1697,7 +1697,7 @@ R_API int r_core_anal_all(RCore *core) {
 		if (!strncmp (fcni->name, "sym.", 4) || !strncmp (fcni->name, "main", 4))
 			fcni->type = R_ANAL_FCN_TYPE_SYM;
 	}
-	return R_TRUE;
+	return true;
 }
 
 R_API void r_core_anal_setup_enviroment (RCore *core) {
@@ -1739,7 +1739,7 @@ R_API int r_core_anal_data (RCore *core, ut64 addr, int count, int depth) {
 	count = R_MIN (count, len);
 	buf = malloc (len);
 	if (buf == NULL)
-		return R_FALSE;
+		return false;
 	memset (buf, 0xff, len);
 	r_io_read_at (core->io, addr, buf, len);
 	buf[len-1] = 0;
@@ -1780,7 +1780,7 @@ R_API int r_core_anal_data (RCore *core, ut64 addr, int count, int depth) {
 		r_anal_data_free (d);
 	}
 	free (buf);
-	return R_TRUE;
+	return true;
 }
 
 /* core analysis stats */
diff --git a/libr/core/asm.c b/libr/core/asm.c
index dc36b22ac..84ec086d4 100644
--- a/libr/core/asm.c
+++ b/libr/core/asm.c
@@ -28,7 +28,7 @@ R_API RCoreAsmHit *r_core_asm_hit_new() {
 	hit->code = NULL;
 	hit->len = 0;
 	hit->addr = -1;
-	hit->valid = R_FALSE;
+	hit->valid = false;
 	return hit;
 }
 
@@ -126,7 +126,7 @@ R_API RList *r_core_asm_strsearch(RCore *core, const char *input, ut64 from, ut6
 			}
 			if (align) {
 				if (addr % align) {
-					matches = R_FALSE;
+					matches = false;
 					eprintf ("NOT VALID %llx\n", addr);
 				}
 			}
@@ -267,7 +267,7 @@ static int handle_forward_disassemble(RCore* core, RList *hits, ut8* buf, ut64 l
 
     RAsmOp op;
     RCoreAsmHit *hit = NULL, *found_addr = NULL;
-    ut8 is_valid = R_FALSE;
+    ut8 is_valid = false;
 
 	if (end_addr < current_instr_addr)
 		return end_addr;
@@ -279,10 +279,10 @@ static int handle_forward_disassemble(RCore* core, RList *hits, ut8* buf, ut64 l
 		temp_instr_len = r_asm_disassemble (core->assembler, &op, buf+tmp_current_buf_pos, temp_instr_len);
 
 		if (temp_instr_len == 0){
-			is_valid = R_FALSE;
+			is_valid = false;
 			temp_instr_len = 1;
 		} else
-			is_valid = R_TRUE;
+			is_valid = true;
 
 		// check to see if addr exits
 		found_addr = find_addr(hits, temp_instr_addr);
@@ -325,54 +325,54 @@ static int handle_disassembly_overlap(RCore* core, RList *hits, ut8* buf, int le
 #endif
 
 static int is_addr_in_range(ut64 start, ut64 end, ut64 start_range, ut64 end_range){
-	int result = R_FALSE;
+	int result = false;
 
 	if (start == start_range) {
-		return R_TRUE;
+		return true;
 	} else if (start < end && start_range < end_range) {
 		// ez cases
 		if ( start_range <= start &&   start < end_range )
-			result = R_TRUE;
+			result = true;
 		else if (start_range < end && end < end_range )
-			result = R_TRUE;
+			result = true;
 		else if ( start <= start_range && end_range < end )
-			result = R_TRUE;
+			result = true;
 	// XXX - these cases need to be tested
 	// (long long) start_range < 0 < end_range
 	} else if (start_range > end_range) {
 		if (start < end) {
 			if (start < end_range)
-				result = R_TRUE;
+				result = true;
 			else if (end <= end_range)
-				result = R_TRUE;
+				result = true;
 			else if ( start_range <= start )
-				result = R_TRUE;
+				result = true;
 			else if ( start_range < end )
-				result = R_TRUE;
+				result = true;
 		// (long long) start < 0 < end
 		} else {
 			if (end < end_range)
-				result = R_TRUE;
+				result = true;
 			else if (end <= end_range)
-				result = R_TRUE;
+				result = true;
 			else if ( start_range <= start )
-				result = R_TRUE;
+				result = true;
 		}
 	// XXX - these cases need to be tested
 	// (long long) start < 0 < end
 	} else if (start_range < end_range) {
 		if ( start < end_range)
-			result = R_TRUE;
+			result = true;
 		else if ( start <= start_range )
-			result = R_TRUE;
+			result = true;
 		else if ( start_range < end)
-			result = R_TRUE;
+			result = true;
 	}
 	return result;
 }
 
 static int is_hit_inrange(RCoreAsmHit *hit, ut64 start_range, ut64 end_range){
-	int result = R_FALSE;
+	int result = false;
 	if (hit) {
 		result = is_addr_in_range (hit->addr,
 			hit->addr + hit->len,
@@ -433,7 +433,7 @@ R_API RList *r_core_asm_bwdisassemble (RCore *core, ut64 addr, int n, int len) {
 	at = addr-idx;
 	for ( hit_count = 0; hit_count < n; hit_count++) {
 		instrlen = r_asm_disassemble (core->assembler, &op, buf+(len-(addr-at)), addr-at);
-		add_hit_to_hits(hits, at, instrlen, R_TRUE);
+		add_hit_to_hits(hits, at, instrlen, true);
 		at += instrlen;
 	}
 	free (buf);
@@ -577,7 +577,7 @@ static RList *r_core_asm_back_disassemble (RCore *core, ut64 addr, int len, ut64
 		// disassembly invalid
 		if (current_instr_len == 0 || strstr (op.buf_asm, "invalid")) {
 			if (current_instr_len == 0) current_instr_len = 1;
-			add_hit_to_sorted_hits(hits, current_instr_addr, current_instr_len, /* is_valid */ R_FALSE);
+			add_hit_to_sorted_hits(hits, current_instr_addr, current_instr_len, /* is_valid */ false);
 			hit_count ++;
 			last_num_invalid ++;
 		// disassembly perfect
@@ -587,9 +587,9 @@ static RList *r_core_asm_back_disassemble (RCore *core, ut64 addr, int len, ut64
             // are only called in cases where a valid instruction has been found.
             // and they are lazy, since they purge the hit list
             ut32 purge_results = 0;
-			ut8 is_valid = R_TRUE;
+			ut8 is_valid = true;
 			IFDBG eprintf(" handling underlap case: current_instr_addr: 0x%"PFMT64x".\n", current_instr_addr);
-			purge_results =  prune_hits_in_addr_range(hits, current_instr_addr, current_instr_len, /* is_valid */ R_TRUE);
+			purge_results =  prune_hits_in_addr_range(hits, current_instr_addr, current_instr_len, /* is_valid */ true);
 			if (purge_results) {
 				handle_forward_disassemble(core, hits, buf, len, current_buf_pos+current_instr_len, current_instr_addr+current_instr_len, addr);
 				hit_count = r_list_length(hits);
@@ -602,8 +602,8 @@ static RList *r_core_asm_back_disassemble (RCore *core, ut64 addr, int len, ut64
 		// disassembly underlap
 		} else if (current_buf_pos + current_instr_len < next_buf_pos) {
 			ut32 purge_results = 0;
-			ut8 is_valid = R_TRUE;
-			purge_results =  prune_hits_in_addr_range(hits, current_instr_addr, current_instr_len, /* is_valid */ R_TRUE);
+			ut8 is_valid = true;
+			purge_results =  prune_hits_in_addr_range(hits, current_instr_addr, current_instr_len, /* is_valid */ true);
 			add_hit_to_sorted_hits(hits, current_instr_addr, current_instr_len, is_valid);
 
 			if (hit_count < purge_results ) hit_count = 0; // WTF??
@@ -640,13 +640,13 @@ static RList *r_core_asm_back_disassemble (RCore *core, ut64 addr, int len, ut64
 
 R_API RList *r_core_asm_back_disassemble_instr (RCore *core, ut64 addr, int len, ut32 hit_count, ut32 extra_padding){
 	// extra padding to allow for additional disassembly on border buffer cases
-	ut8 disassmble_each_addr  = R_FALSE;
+	ut8 disassmble_each_addr  = false;
 	return r_core_asm_back_disassemble (core, addr, len, hit_count, disassmble_each_addr, extra_padding);
 }
 
 R_API RList *r_core_asm_back_disassemble_byte (RCore *core, ut64 addr, int len, ut32 hit_count, ut32 extra_padding){
 	// extra padding to allow for additional disassembly on border buffer cases
-	ut8 disassmble_each_addr  = R_TRUE;
+	ut8 disassmble_each_addr  = true;
 	return r_core_asm_back_disassemble (core, addr, len, hit_count, disassmble_each_addr, extra_padding);
 }
 
diff --git a/libr/core/bin.c b/libr/core/bin.c
index 7dede4f7d..17245fc03 100644
--- a/libr/core/bin.c
+++ b/libr/core/bin.c
@@ -40,17 +40,17 @@ static ut64 rva_va (RBin *bin, ut64 paddr, ut64 vaddr) {
 R_API int r_core_bin_set_by_fd (RCore *core, ut64 bin_fd) {
 	if (r_bin_file_set_cur_by_fd (core->bin, bin_fd)) {
 		r_core_bin_set_cur (core, r_core_bin_cur(core));
-		return R_TRUE;
+		return true;
 	}
-	return R_FALSE;
+	return false;
 }
 
 R_API int r_core_bin_set_by_name (RCore *core, const char * name) {
 	if (r_bin_file_set_cur_by_name (core->bin, name)) {
 		r_core_bin_set_cur (core, r_core_bin_cur (core));
-		return R_TRUE;
+		return true;
 	}
-	return R_FALSE;
+	return false;
 }
 
 R_API int r_core_bin_set_env (RCore *r, RBinFile *binfile) {
@@ -76,26 +76,26 @@ R_API int r_core_bin_set_env (RCore *r, RBinFile *binfile) {
 		r_core_bin_info (r, R_CORE_BIN_ACC_ALL, R_CORE_BIN_SET,
 			va, NULL, NULL);
 		r_core_bin_set_cur (r, binfile);
-		return R_TRUE;
+		return true;
 	}
-	return R_FALSE;
+	return false;
 }
 
 R_API int r_core_bin_set_cur (RCore *core, RBinFile *binfile) {
-	if (!core->bin) return R_FALSE;
+	if (!core->bin) return false;
 	if (!binfile) {
 		// Find first available binfile
 		ut32 fd = r_core_file_cur_fd (core);
 		binfile = fd != (ut32) -1 ?  r_bin_file_find_by_fd (
 			core->bin, fd) : NULL;
-		if (!binfile) return R_FALSE;
+		if (!binfile) return false;
 	}
 	r_bin_file_set_cur_binfile (core->bin, binfile);
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_bin_refresh_strings(RCore *r) {
-	return r_bin_reset_strings (r->bin) ? R_TRUE: R_FALSE;
+	return r_bin_reset_strings (r->bin) ? true: false;
 }
 
 R_API RBinFile * r_core_bin_cur (RCore *core) {
@@ -114,7 +114,7 @@ static int bin_strings (RCore *r, int mode, int va) {
 	RBinFile * binfile = r_core_bin_cur (r);
 	RBinPlugin *plugin = r_bin_file_cur_plugin (binfile);
 
-	if (!binfile) return R_FALSE;
+	if (!binfile) return false;
 	minstr = r_config_get_i (r->config, "bin.minstr");
 	maxstr = r_config_get_i (r->config, "bin.maxstr");
 	rawstr = r_config_get_i (r->config, "bin.rawstr");
@@ -127,7 +127,7 @@ static int bin_strings (RCore *r, int mode, int va) {
 	if (plugin->info && plugin->name) {
 		if (!strcmp (plugin->name, "any")) {
 			if (!rawstr) {
-				return R_FALSE;
+				return false;
 
 			}
 		}
@@ -137,7 +137,7 @@ static int bin_strings (RCore *r, int mode, int va) {
 	minstr = bin->minstrlen;
 
 	if ((list = r_bin_get_strings (bin)) == NULL)
-		return R_FALSE;
+		return false;
 
 	if ((mode & R_CORE_BIN_JSON)) {
 		r_cons_printf ("[");
@@ -228,11 +228,11 @@ static int bin_strings (RCore *r, int mode, int va) {
 				string->type=='w'?"wide":"ascii", string->string);
 		}
 	}
-	return R_TRUE;
+	return true;
 }
 
 static const char* get_compile_time(Sdb *binFileSdb) {
-	Sdb *info_ns = sdb_ns(binFileSdb, "info", R_FALSE);
+	Sdb *info_ns = sdb_ns(binFileSdb, "info", false);
 	const char *timeDateStamp_string = sdb_const_get (info_ns,
 		"image_file_header.TimeDateStamp_string", 0);
 	if (timeDateStamp_string)
@@ -252,7 +252,7 @@ static int bin_info (RCore *r, int mode) {
 	if (!binfile || !info) {
 		if (mode & R_CORE_BIN_JSON)
 			r_cons_printf ("{}");
-		return R_FALSE;
+		return false;
 	}
 
 	compiled = get_compile_time (binfile->sdb);
@@ -401,7 +401,7 @@ static int bin_info (RCore *r, int mode) {
 				//ut8 *sum = &info; // XXX
 				RBinHash *h = &info->sum[i];
 				ut64 hash = r_hash_name_to_bits (h->type);
-				RHash *rh = r_hash_new (R_TRUE, hash);
+				RHash *rh = r_hash_new (true, hash);
 				len = r_hash_calculate (rh, hash, (const ut8*)
 					binfile->buf->buf+h->from, h->to);
 				//ut8 *p = binfile->buf+h->addr;
@@ -415,7 +415,7 @@ static int bin_info (RCore *r, int mode) {
 			}
 		}
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int bin_dwarf (RCore *core, int mode) {
@@ -424,7 +424,7 @@ static int bin_dwarf (RCore *core, int mode) {
 	RList *list = NULL;
 	RBinFile *binfile = r_core_bin_cur (core);
 	RBinPlugin * plugin = r_bin_file_cur_plugin (binfile);
-	if (!binfile) return R_FALSE;
+	if (!binfile) return false;
 
 	if (plugin && plugin->lines) {
 		list = plugin->lines (binfile);
@@ -440,7 +440,7 @@ static int bin_dwarf (RCore *core, int mode) {
 			free (da);
 		}
 	}
-	if (!list) return R_FALSE;
+	if (!list) return false;
 	r_cons_break (NULL, NULL);
         r_list_foreach (list, iter, row) {
 		if (r_cons_singleton()->breaked) break;
@@ -469,7 +469,7 @@ static int bin_dwarf (RCore *core, int mode) {
 	r_cons_break_end ();
 	//r_list_purge (list);
 	r_list_free (list);
-	return R_TRUE;
+	return true;
 }
 
 static int bin_pdb (RCore *core, int mode) {
@@ -479,13 +479,13 @@ static int bin_pdb (RCore *core, int mode) {
 	pdb.cb_printf = r_cons_printf;
 	if (!init_pdb_parser (&pdb, core->bin->file)) {
 		//eprintf ("initialization error of pdb parser\n");
-		return R_FALSE;
+		return false;
 	}
 
 	if (!pdb.pdb_parse (&pdb)) {
 		eprintf ("pdb was not parsed\n");
 		pdb.finish_pdb_parse (&pdb);
-		return R_FALSE;
+		return false;
 	}
 
 	if (mode == R_CORE_BIN_JSON)
@@ -495,7 +495,7 @@ static int bin_pdb (RCore *core, int mode) {
 	case R_CORE_BIN_SET:
 		mode = 's';
 		r_core_cmd0 (core, ".iP*");
-		return R_TRUE;
+		return true;
 	case R_CORE_BIN_JSON:
 		mode = 'j';
 		break;
@@ -517,13 +517,13 @@ static int bin_pdb (RCore *core, int mode) {
 		r_cons_printf ("]");
 	pdb.finish_pdb_parse (&pdb);
 
-	return R_TRUE;
+	return true;
 }
 
 static int bin_main (RCore *r, int mode, int va) {
 	RBinAddr *binmain = r_bin_get_sym (r->bin, R_BIN_SYM_MAIN);
 	ut64 main_addr = 0LL;
-	if (!binmain) return R_FALSE;
+	if (!binmain) return false;
 
 	if (va) {
 		main_addr = r_bin_a2b (r->bin, binmain->vaddr);
@@ -547,7 +547,7 @@ static int bin_main (RCore *r, int mode, int va) {
 					main_addr, binmain->paddr);
 		}
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int bin_entry (RCore *r, int mode, ut64 laddr, int va) {
@@ -627,7 +627,7 @@ static int bin_entry (RCore *r, int mode, ut64 laddr, int va) {
 		}
 		if (!mode) r_cons_printf ("\n%i entrypoints\n", i);
 	}
-	return R_TRUE;
+	return true;
 }
 
 static const char *bin_reloc_type_name (RBinReloc *reloc) {
@@ -682,7 +682,7 @@ static int bin_relocs (RCore *r, int mode, int va) {
 	va = 1; // XXX relocs always vaddr?
 
 	if ((relocs = r_bin_get_relocs (r->bin)) == NULL)
-		return R_FALSE;
+		return false;
 
 	if (mode & R_CORE_BIN_JSON) {
 		r_cons_printf ("[");
@@ -817,7 +817,7 @@ static int bin_relocs (RCore *r, int mode, int va) {
 			r_cons_printf ("\n%i relocations\n", i);
 		}
 	}
-	return R_TRUE;
+	return true;
 }
 
 #define MYDB 1
@@ -867,9 +867,9 @@ static ut64 impaddr(RBin *bin, int va, const char *name) {
 	char impname[512];
 	RList *symbols;
 	RBinSymbol *s;
-	if (!name || !*name) return R_FALSE;
+	if (!name || !*name) return false;
 	if (!(symbols = r_bin_get_symbols (bin))) {
-		return R_FALSE;
+		return false;
 	}
 	// TODO: avoid using snprintf here
 	snprintf (impname, sizeof (impname), "imp.%s", name);
@@ -982,7 +982,7 @@ static int bin_imports (RCore *r, int mode, int va, const char *name) {
 	sdb_free (mydb);
 	mydb = NULL;
 #endif
-	return R_TRUE;
+	return true;
 }
 
 static const char *getPrefixFor(const char *s) {
@@ -1279,7 +1279,7 @@ static int bin_symbols (RCore *r, int mode, ut64 laddr, int va, ut64 at, const c
 		if (!at && !mode) r_cons_printf ("\n%i symbols\n", i);
 	}
 	r_space_set (&r->anal->meta_spaces, NULL);
-	return R_TRUE;
+	return true;
 }
 
 static int bin_sections (RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, const char *chksum) {
@@ -1489,7 +1489,7 @@ static int bin_sections (RCore *r, int mode, ut64 laddr, int va, ut64 at, const
 		if (!at && !mode) r_cons_printf ("\n%i sections\n", i);
 	}
 
-	return R_TRUE;
+	return true;
 }
 
 static int bin_fields (RCore *r, int mode, int va) {
@@ -1503,7 +1503,7 @@ static int bin_fields (RCore *r, int mode, int va) {
 	ut64 baddr = r_bin_get_baddr (r->bin);
 
 	if ((fields = r_bin_get_fields (bin)) == NULL)
-		return R_FALSE;
+		return false;
 
 	if (mode & R_CORE_BIN_JSON) {
 		r_cons_printf ("[");
@@ -1545,7 +1545,7 @@ static int bin_fields (RCore *r, int mode, int va) {
 					baddr, size, size);
 		} else r_cons_printf ("\n%i fields\n", i);
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int bin_classes (RCore *r, int mode) {
@@ -1553,7 +1553,7 @@ static int bin_classes (RCore *r, int mode) {
 	RBinSymbol *sym;
 	RBinClass *c;
 	RList *cs = r_bin_get_classes (r->bin);
-	if (!cs) return R_FALSE;
+	if (!cs) return false;
 
 	// XXX: support for classes is broken and needs more love
 	if (mode & R_CORE_BIN_JSON) {
@@ -1574,7 +1574,7 @@ static int bin_classes (RCore *r, int mode) {
 		}
 	} else if (mode & R_CORE_BIN_SET) {
 		if (!r_config_get_i (r->config, "bin.classes")) {
-			return R_FALSE;
+			return false;
 		}
 		// Nothing to set.
 		r_flag_space_set (r->flags, "classes");
@@ -1627,7 +1627,7 @@ static int bin_classes (RCore *r, int mode) {
 			free (name);
 		}
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int bin_size (RCore *r, int mode) {
@@ -1639,7 +1639,7 @@ static int bin_size (RCore *r, int mode) {
 	else if ((mode & R_CORE_BIN_SET))
 		r_core_cmdf (r, "f bin_size @ %d\n", size);
 	else r_cons_printf ("%d\n", size);
-	return R_TRUE;
+	return true;
 }
 
 static int bin_libs (RCore *r, int mode) {
@@ -1649,7 +1649,7 @@ static int bin_libs (RCore *r, int mode) {
 	int i = 0;
 
 	if ((libs = r_bin_get_libs (r->bin)) == NULL)
-		return R_FALSE;
+		return false;
 
 	if (mode & R_CORE_BIN_JSON) {
 		r_cons_printf ("[");
@@ -1680,7 +1680,7 @@ static int bin_libs (RCore *r, int mode) {
 			}
 		}
 	}
-	return R_TRUE;
+	return true;
 }
 
 static void bin_mem_print (RList *mems, int perms, int depth) {
@@ -1703,23 +1703,23 @@ static void bin_mem_print (RList *mems, int perms, int depth) {
 
 static int bin_mem (RCore *r, int mode) {
 	RList *mem = NULL;
-	if (!r)	return R_FALSE;
+	if (!r)	return false;
 	if (!((mode & R_CORE_BIN_RADARE) || (mode & R_CORE_BIN_SET)))
 		r_cons_printf ("[Memory]\n\n");
 	if (!(mem = r_bin_get_mem (r->bin)))
-		return R_FALSE;
+		return false;
 	if (mode & R_CORE_BIN_JSON) {
 		r_cons_printf ("TODO\n");
-		return R_FALSE;
+		return false;
 	}
 	if (!((mode & R_CORE_BIN_RADARE) || (mode & R_CORE_BIN_SET))) {
 		bin_mem_print (mem, 7, 0);
 	}
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_bin_info (RCore *core, int action, int mode, int va, RCoreBinFilter *filter, const char *chksum) {
-	int ret = R_TRUE;
+	int ret = true;
 	const char *name = NULL;
 	ut64 at = 0, loadaddr = r_bin_get_laddr (core->bin);
 
@@ -1771,19 +1771,19 @@ R_API int r_core_bin_set_arch_bits (RCore *r, const char *name, const char * arc
 	if (!name)
 		name = (cf && cf->desc) ? cf->desc->name : NULL;
 	if (!name)
-		return R_FALSE;
+		return false;
 
 	/* Check if the arch name is a valid name */
 	if (!r_asm_is_valid (r->assembler, arch))
-		return R_FALSE;
+		return false;
 
 	/* Find a file with the requested name/arch/bits */
 	binfile = r_bin_file_find_by_arch_bits (r->bin, arch, bits, name);
 	if (!binfile)
-		return R_FALSE;
+		return false;
 
 	if (!r_bin_use_arch (r->bin, arch, bits, name))
-		return R_FALSE;
+		return false;
 
 	r_core_bin_set_cur (r, binfile);
 	return r_core_bin_set_env (r, binfile);
@@ -1802,10 +1802,10 @@ R_API int r_core_bin_raise (RCore *core, ut32 binfile_idx, ut32 binobj_idx) {
 	RBinFile *binfile = NULL;
 
 	if (binfile_idx == UT32_MAX && binobj_idx == UT32_MAX) {
-		return R_FALSE;
+		return false;
 	}
 
-	if (!r_bin_select_by_ids (bin, binfile_idx, binobj_idx)) return R_FALSE;
+	if (!r_bin_select_by_ids (bin, binfile_idx, binobj_idx)) return false;
 	binfile = r_core_bin_cur (core);
 	if (binfile) {
 		r_io_raise (core->io, binfile->fd);
@@ -1819,9 +1819,9 @@ R_API int r_core_bin_delete (RCore *core, ut32 binfile_idx, ut32 binobj_idx) {
 	RBinFile *binfile = NULL;
 
 	if (binfile_idx == UT32_MAX && binobj_idx == UT32_MAX)
-		return R_FALSE;
+		return false;
 	if (!r_bin_object_delete (bin, binfile_idx, binobj_idx))
-		return R_FALSE;
+		return false;
 	binfile = r_core_bin_cur (core);
 	if (binfile)
 		r_io_raise (core->io, binfile->fd);
@@ -1839,7 +1839,7 @@ static int r_core_bin_file_print (RCore *core, RBinFile *binfile, int mode) {
 	ut32 bin_sz = binfile ? binfile->size : 0;
 // TODO:  TODO: handle mode to print in json and r2 commands
 
-	if (!binfile) return R_FALSE;
+	if (!binfile) return false;
 
 	switch (mode) {
 	case 'j':
@@ -1867,7 +1867,7 @@ static int r_core_bin_file_print (RCore *core, RBinFile *binfile, int mode) {
 		}
 		break;
 	}
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_bin_list(RCore *core, int mode) {
@@ -1878,7 +1878,7 @@ R_API int r_core_bin_list(RCore *core, int mode) {
 	RBin *bin = core->bin;
 	const RList *binfiles = bin ? bin->binfiles: NULL;
 
-	if (!binfiles) return R_FALSE;
+	if (!binfiles) return false;
 
 	if (mode=='j') r_cons_printf("[");
 	r_list_foreach (binfiles, iter, binfile) {
diff --git a/libr/core/cmd.c b/libr/core/cmd.c
index b4bdad183..a8d9de550 100644
--- a/libr/core/cmd.c
+++ b/libr/core/cmd.c
@@ -52,11 +52,11 @@ static void cmd_debug_reg(RCore *core, const char *str);
 static int r_core_cmd_nullcallback(void *data) {
 	RCore *core = (RCore*) data;
 	if (core->cons->breaked) {
-		core->cons->breaked = R_FALSE;
+		core->cons->breaked = false;
 		return 0;
 	}
 	if (!core->cmdrepeat) return 0;
-	r_core_cmd_repeat (core, R_TRUE);
+	r_core_cmd_repeat (core, true);
 	return 1;
 }
 
@@ -301,11 +301,11 @@ static int cmd_yank(void *data, const char *input) {
 		}
 		break;
 	}
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_run_script (RCore *core, const char *file) {
-	int ret = R_FALSE;
+	int ret = false;
 	RListIter *iter;
 	RLangPlugin *p;
 	char *name;
@@ -313,7 +313,7 @@ R_API int r_core_run_script (RCore *core, const char *file) {
 	r_list_foreach (core->scriptstack, iter, name) {
 		if (!strcmp (file, name)) {
 			eprintf ("WARNING: ignored nested source: %s\n", file);
-			return R_FALSE;
+			return false;
 		}
 	}
 	r_list_push (core->scriptstack, strdup (file));
@@ -331,7 +331,7 @@ R_API int r_core_run_script (RCore *core, const char *file) {
 			sdb_query_lines (core->anal->sdb_types, out);
 			free (out);
 		}
-		ret = out? R_TRUE: R_FALSE;
+		ret = out? true: false;
 	} else {
 		p = r_lang_get_by_extension (core->lang, file);
 		if (p) {
@@ -425,7 +425,7 @@ static int cmd_stdin(void *data, const char *input) {
 	RCore *core = (RCore *)data;
 	if (input[0]=='?') {
 		r_cons_printf ("Usage: '-' '.-' '. -' do the same\n");
-		return R_FALSE;
+		return false;
 	}
 	return r_core_run_script (core, "-");
 }
@@ -559,9 +559,9 @@ static int cmd_kuery(void *data, const char *input) {
 	// TODO: add command to list all namespaces // sdb_ns_foreach ?
 	case 's':
 		if (core->http_up)
-			return R_FALSE;
+			return false;
 		if (!r_config_get_i (core->config, "scr.interactive"))
-			return R_FALSE;
+			return false;
 		if (input[1]==' ') {
 			char *n = n, *o, *p = strdup (input+2);
 			// TODO: slash split here? or inside sdb_ns ?
@@ -737,14 +737,14 @@ static int cmd_resize(void *data, const char *input) {
 		if (input[1]==' ')
 			r_file_rm (input+2);
 		else eprintf ("Usage: rm [file]   # removes a file\n");
-		return R_TRUE;
+		return true;
 	case '\0':
 		if (core->file && core->file->desc) {
 			if (oldsize != -1) {
 				r_cons_printf ("%"PFMT64d"\n", oldsize);
 			}
 		}
-		return R_TRUE;
+		return true;
 	case '+':
 	case '-':
 		delta = (st64)r_num_math (core->num, input);
@@ -755,7 +755,7 @@ static int cmd_resize(void *data, const char *input) {
 		if (newsize==0) {
 			if (input[1]=='0')
 				eprintf ("Invalid size\n");
-			return R_FALSE;
+			return false;
 		}
 		break;
 	default:
@@ -770,7 +770,7 @@ static int cmd_resize(void *data, const char *input) {
 			NULL};
 		r_core_cmd_help (core, help_msg);
 		}
-		return R_TRUE;
+		return true;
 	}
 
 	grow = (newsize > oldsize);
@@ -793,15 +793,15 @@ static int cmd_resize(void *data, const char *input) {
 			oldsize < core->offset+core->blocksize) {
 		r_core_block_read (core, 0);
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int cmd_visual(void *data, const char *input) {
 	RCore *core = (RCore*) data;
 	if (core->http_up)
-		return R_FALSE;
+		return false;
 	if (!r_config_get_i (core->config, "scr.interactive"))
-		return R_FALSE;
+		return false;
 	return r_core_visual ((RCore *)data, input);
 }
 
@@ -921,7 +921,7 @@ static int cmd_thread(void *data, const char *input) {
 
 static int cmd_pointer(void *data, const char *input) {
 	RCore *core = (RCore*) data;
-	int ret = R_TRUE;
+	int ret = true;
 	char *str, *eq;
 	while (*input==' ') input++;
 	if (!*input || *input=='?') {
@@ -1216,7 +1216,7 @@ static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon) {
 			char *line, *p = find_eoq (cmd);
 			if (!p || !*p) {
 				eprintf ("Missing \" in (%s).", cmd);
-				return R_FALSE;
+				return false;
 			}
 			*p = 0;
 			// SKIPSPACES in p+1
@@ -1240,7 +1240,7 @@ static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon) {
 				pipefd = r_cons_pipe_open (str, 1, p[2]=='>');
 			}
 			line = strdup (cmd);
-			line = r_str_replace (line, "\\\"", "\"", R_TRUE);
+			line = r_str_replace (line, "\\\"", "\"", true);
 			if (p && p[1]=='|') {
 				str = p+2;
 				while (IS_WHITESPACE (*str)) str++;
@@ -1261,7 +1261,7 @@ static int r_core_cmd_subst_i(RCore *core, char *cmd, char *colon) {
 			*p = '"';
 			cmd = p+1;
 		}
-		return R_TRUE;
+		return true;
 	case '(':
 		if (cmd[1] != '*')
 			return r_cmd_call (core->rcmd, cmd);
@@ -1387,7 +1387,7 @@ next:
 	if (ptr) {
 		int fdn = 1;
 		int pipecolor = r_config_get_i (core->config, "scr.pipecolor");
-		int use_editor = R_FALSE;
+		int use_editor = false;
 		//int scrint = r_cons_singleton()->is_interactive;
 		int ocolor = r_config_get_i (core->config, "scr.color");
 		*ptr = '\0';
@@ -1402,9 +1402,9 @@ next:
 				fdn = *fdnum - '0';
 			*fdnum = 0;
 		}
-		r_cons_set_interactive (R_FALSE);
+		r_cons_set_interactive (false);
 		if (!strcmp (str, "-")) {
-			use_editor = R_TRUE;
+			use_editor = true;
 			str = r_file_temp ("dumpedit");
 			r_config_set (core->config, "scr.color", "false");
 		}
@@ -1503,7 +1503,7 @@ next2:
 		if (ptr == cmd+1 && *cmd=='?')
 			ptr = NULL;
 	} else ptr = NULL;
-	core->tmpseek = ptr? R_TRUE: R_FALSE;
+	core->tmpseek = ptr? true: false;
 	if (ptr) {
 		ut64 tmpoff, tmpbsz, addr;
 		const char *tmpasm = NULL;
@@ -1631,7 +1631,7 @@ ignore:
                 if (isalpha ((unsigned char)ptr[1]) && addr== 0) {
                         if (!r_flag_get (core->flags, ptr+1)) {
                                 eprintf ("Invalid address (%s)\n", ptr+1);
-                                return R_FALSE;
+                                return false;
                         }
                 } else {
 			char ch = *offstr;
@@ -1690,7 +1690,7 @@ if (addr != UT64_MAX) {
 		return ret;
 	}
 
-	return cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): R_FALSE;
+	return cmd? r_cmd_call (core->rcmd, r_str_trim_head (cmd)): false;
 }
 
 static int foreach_comment(void *user, const char *k, const char *v) {
@@ -1741,7 +1741,7 @@ R_API int r_core_cmd_foreach3(RCore *core, const char *cmd, char *each) {
 			RDebugPid *p;
 			list = dbg->h->threads (dbg, dbg->pid);
 			if (list == NULL)
-				return R_FALSE;
+				return false;
 			r_list_foreach (list, iter, p) {
 				r_core_cmdf (core, "dp %d", p->pid);
 				r_cons_printf ("PID %d\n", p->pid);
@@ -1871,7 +1871,7 @@ R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {
 			}
 			r_debug_select (core->dbg, pid, pid);
 			free (ostr);
-			return R_FALSE;
+			return false;
 		}
 		break;
 	case '=':
@@ -2008,12 +2008,12 @@ R_API int r_core_cmd_foreach(RCore *core, const char *cmd, char *each) {
 
 	free (word);
 	free (ostr);
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_cmd(RCore *core, const char *cstr, int log) {
 	char *cmd, *ocmd, *ptr, *rcmd;
-	int ret = R_FALSE;
+	int ret = false;
 
 	if (core->cmdremote) {
 		if (*cstr != '=' && *cstr != 'q' && strncmp (cstr, "!=", 2)) {
@@ -2023,23 +2023,23 @@ R_API int r_core_cmd(RCore *core, const char *cstr, int log) {
 	}
 
 	if (cstr==NULL)
-		return R_FALSE;
+		return false;
 	if (*cstr == '|') {
 		// RAW COMMENT
-		return R_FALSE;
+		return false;
 	}
 	if (!strncmp (cstr, "/*", 2)) {
 		if (r_sandbox_enable (0)) {
 			eprintf ("This command is disabled in sandbox mode\n");
 			return 0;
 		}
-		core->incomment = R_TRUE;
+		core->incomment = true;
 	} else if (!strncmp (cstr, "*/", 2)) {
-		core->incomment = R_FALSE;
-		return R_FALSE;
+		core->incomment = false;
+		return false;
 	}
 	if (core->incomment)
-		return R_FALSE;
+		return false;
 	if (log && *cstr && *cstr!='.') {
 		free (core->lastcmd);
 		core->lastcmd = strdup (cstr);
@@ -2047,7 +2047,7 @@ R_API int r_core_cmd(RCore *core, const char *cstr, int log) {
 
 	ocmd = cmd = malloc (strlen (cstr)+4096);
 	if (ocmd == NULL)
-		return R_FALSE;
+		return false;
 	r_str_cpy (cmd, cstr);
 
 	if (log) r_line_hist_add (cstr);
@@ -2083,10 +2083,10 @@ R_API int r_core_cmd(RCore *core, const char *cstr, int log) {
 }
 
 R_API int r_core_cmd_lines(RCore *core, const char *lines) {
-	int r, ret = R_TRUE;
+	int r, ret = true;
 	char *nl, *data, *odata;
 
-	if (!lines || !*lines) return R_TRUE;
+	if (!lines || !*lines) return true;
 	data = odata = strdup (lines);
 	nl = strchr (odata, '\n');
 	if (nl) {
@@ -2100,7 +2100,7 @@ R_API int r_core_cmd_lines(RCore *core, const char *lines) {
 			r = r_core_cmd (core, data, 0);
 			if (r == -1) {
 				data = nl+1;
-				ret = R_FALSE;
+				ret = false;
 				break;
 			}
 			r_cons_flush ();
@@ -2124,17 +2124,17 @@ R_API int r_core_cmd_lines(RCore *core, const char *lines) {
 R_API int r_core_cmd_file(RCore *core, const char *file) {
 	char *data, *odata;
 	data = r_file_abspath (file);
-	if (!data) return R_FALSE;
+	if (!data) return false;
 	odata = r_file_slurp (data, NULL);
 	free (data);
-	if (!odata) return R_FALSE;
+	if (!odata) return false;
 	if (!r_core_cmd_lines (core, odata)) {
 		eprintf ("Failed to run script '%s'\n", file);
 		free (odata);
-		return R_FALSE;
+		return false;
 	}
 	free (odata);
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_cmd_command(RCore *core, const char *command) {
@@ -2181,7 +2181,7 @@ R_API int r_core_cmd_buffer(void *user, const char *buf) {
 	}
 	r_core_cmd (user, optr, 0);
 	free (str);
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_cmdf(void *user, const char *fmt, ...) {
diff --git a/libr/core/cmd_anal.c b/libr/core/cmd_anal.c
index 513fbd6c4..0a68ae6ae 100644
--- a/libr/core/cmd_anal.c
+++ b/libr/core/cmd_anal.c
@@ -134,7 +134,7 @@ static int var_cmd(RCore *core, const char *str) {
 					eprintf ("Can not find variable in: '%s'\n", str);
 				} else eprintf ("Unknown variable in: '%s'\n", str);
 				free (ostr);
-				return R_FALSE;
+				return false;
 			} else eprintf ("Missing argument\n");
 			break;
 		case ' ':
@@ -172,7 +172,7 @@ static int var_cmd(RCore *core, const char *str) {
 	}
 	end:
 	free (ostr);
-	return R_TRUE;
+	return true;
 }
 
 static void print_trampolines(RCore *core, ut64 a, ut64 b, size_t element_size) {
@@ -222,7 +222,7 @@ static void cmd_syscall_do(RCore *core, int num) {
 	r_cons_printf ("%d = %s (", item->num, item->name);
 	// TODO: move this to r_syscall
 	for (i=0; i<item->args; i++) {
-		ut64 arg = r_debug_arg_get (core->dbg, R_TRUE, i+1);
+		ut64 arg = r_debug_arg_get (core->dbg, true, i+1);
 		if (item->sargs==NULL)
 			r_cons_printf ("0x%08"PFMT64x"", arg);
 		else
@@ -408,7 +408,7 @@ static int anal_fcn_list_bb (RCore *core, const char *input) {
 	}
 	fcn = r_anal_get_fcn_in (core->anal, addr, 0);
 	if (!fcn)
-		return R_FALSE;
+		return false;
 	switch (mode) {
 	case 'j':
 		r_cons_printf ("[");
@@ -449,7 +449,7 @@ static int anal_fcn_list_bb (RCore *core, const char *input) {
 	if (mode=='j') {
 		r_cons_printf ("]");
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int anal_fcn_add_bb (RCore *core, const char *input) {
@@ -473,7 +473,7 @@ static int anal_fcn_add_bb (RCore *core, const char *input) {
 		if (!(diff = r_anal_diff_new ())) {
 			eprintf ("error: Cannot init RAnalDiff\n");
 			free (ptr);
-			return R_FALSE;
+			return false;
 		}
 		if (ptr2[0] == 'm')
 			diff->type = R_ANAL_DIFF_TYPE_MATCH;
@@ -512,7 +512,7 @@ static int anal_fcn_add_bb (RCore *core, const char *input) {
 	}
 	r_anal_diff_free (diff);
 	free (ptr);
-	return R_TRUE;
+	return true;
 }
 
 static int setFunctionName(RCore *core, ut64 off, const char *name) {
@@ -594,7 +594,7 @@ static int cmd_anal_fcn(RCore *core, const char *input) {
 					if (!(diff = r_anal_diff_new ())) {
 						eprintf ("error: Cannot init RAnalDiff\n");
 						free (ptr);
-						return R_FALSE;
+						return false;
 					}
 					if (ptr2[0] == 'm')
 						diff->type = R_ANAL_DIFF_TYPE_MATCH;
@@ -914,7 +914,7 @@ static int cmd_anal_fcn(RCore *core, const char *input) {
 		 }
 		 break;
 	case 'g': // "afg" - non-interactive VV
-		r_core_visual_graph (core, NULL, R_FALSE);
+		r_core_visual_graph (core, NULL, false);
 		break;
 	case '?':{ // "af?"
 		 const char* help_msg[] = {
@@ -954,7 +954,7 @@ static int cmd_anal_fcn(RCore *core, const char *input) {
 			ut64 addr = core->offset;
 			if (input[1] == 'r') {
 				input ++;
-				analyze_recursively = R_TRUE;
+				analyze_recursively = true;
 			}
 
 			// first undefine
@@ -1013,7 +1013,7 @@ static int cmd_anal_fcn(RCore *core, const char *input) {
 			flag_every_function (core);
 		}
 	}
-	return R_TRUE;
+	return true;
 }
 
 static void __anal_reg_list (RCore *core, int type, int size, char mode) {
@@ -1258,9 +1258,9 @@ void cmd_anal_reg(RCore *core, const char *str) {
 		r_debug_reg_list (core->dbg, R_REG_TYPE_GPR, bits, 3, use_color); // XXX detect which one is current usage
 		break;
 	case 'o': // "dro"
-		r_reg_arena_swap (core->dbg->reg, R_FALSE);
+		r_reg_arena_swap (core->dbg->reg, false);
 		r_debug_reg_list (core->dbg, R_REG_TYPE_GPR, bits, 0, use_color); // XXX detect which one is current usage
-		r_reg_arena_swap (core->dbg->reg, R_FALSE);
+		r_reg_arena_swap (core->dbg->reg, false);
 		break;
 	case '=': // "dr="
 		__anal_reg_list (core, type, size, 2);
@@ -1291,7 +1291,7 @@ void cmd_anal_reg(RCore *core, const char *str) {
 				//	r_reg_get_value (core->dbg->reg, r));
 				r_reg_set_value (core->dbg->reg, r,
 					r_num_math (core->num, arg+1));
-				r_debug_reg_sync (core->dbg, -1, R_TRUE);
+				r_debug_reg_sync (core->dbg, -1, true);
 				//eprintf ("0x%08"PFMT64x"\n",
 				//	r_reg_get_value (core->dbg->reg, r));
 			} else {
@@ -2279,7 +2279,7 @@ static boolt cmd_anal_refs(RCore *core, const char *input) {
 					break;
 				default:
 					free (ptr);
-					return R_FALSE;
+					return false;
 			}
 			r_anal_ref_add (core->anal, addr, at, input[0]);
 			free (ptr);
@@ -2291,7 +2291,7 @@ static boolt cmd_anal_refs(RCore *core, const char *input) {
 		break;
 	}
 
-	return R_TRUE;
+	return true;
 }
 /*
    in core/disasm we call
@@ -2468,7 +2468,7 @@ static void cmd_agraph_node (RCore *core, const char *input) {
 		//strdup cause there is double free in r_str_argv_free due to a realloc call
 		body = strdup (args[1]);
 		if (strncmp (body, "base64:", B_LEN) == 0) {
-			body = r_str_replace (body, "\\n", "", R_TRUE);
+			body = r_str_replace (body, "\\n", "", true);
 			newbody = (char *)r_base64_decode_dyn (body + B_LEN, 0);
 			free (body);
 			if (!newbody){
@@ -2879,9 +2879,9 @@ R_API int r_core_anal_refs(RCore *core, const char *input) {
 	}
 	free (ptr);
 
-	if (from == UT64_MAX && to == UT64_MAX) return R_FALSE;
-	if (from == 0 && to == 0) return R_FALSE;
-	if (to-from > r_io_size (core->io)) return R_FALSE;
+	if (from == UT64_MAX && to == UT64_MAX) return false;
+	if (from == 0 && to == 0) return false;
+	if (to-from > r_io_size (core->io)) return false;
 
 	return r_core_anal_search_xrefs (core, from, to, rad);
 }
@@ -2975,7 +2975,7 @@ static int cmd_anal_all (RCore *core, const char *input) {
 	default: r_core_cmd_help (core, help_msg_aa); break;
 	}
 
-	return R_TRUE;
+	return true;
 }
 
 static int cmd_anal(void *data, const char *input) {
@@ -3034,7 +3034,7 @@ static int cmd_anal(void *data, const char *input) {
 	case 'f':
 		if (!cmd_anal_fcn (core, input)) {
 			r_cons_break_end ();
-			return R_FALSE;
+			return false;
 		}
 		break;
 	case 'g':
@@ -3049,12 +3049,12 @@ static int cmd_anal(void *data, const char *input) {
 	case 'x':
 		if (!cmd_anal_refs (core, input+1)) {
 			r_cons_break_end ();
-			return R_FALSE;
+			return false;
 		}
 		break;
 	case 'a':
 		if (!cmd_anal_all (core, input + 1))
-			return R_FALSE;
+			return false;
 		break;
 	case 'c':
 		if (input[1]=='?') {
@@ -3070,10 +3070,10 @@ static int cmd_anal(void *data, const char *input) {
 			int li = r_config_get_i (core->config, "asm.lines");
 			int xr = r_config_get_i (core->config, "asm.xrefs");
 
-			r_config_set_i (core->config, "asm.cmtright", R_TRUE);
-			r_config_set_i (core->config, "asm.functions", R_FALSE);
-			r_config_set_i (core->config, "asm.lines", R_FALSE);
-			r_config_set_i (core->config, "asm.xrefs", R_FALSE);
+			r_config_set_i (core->config, "asm.cmtright", true);
+			r_config_set_i (core->config, "asm.functions", false);
+			r_config_set_i (core->config, "asm.lines", false);
+			r_config_set_i (core->config, "asm.xrefs", false);
 
 			r_cons_break (NULL, NULL);
 			hooks = r_core_anal_cycles (core, ccl); //analyse
diff --git a/libr/core/cmd_api.c b/libr/core/cmd_api.c
index 1a2ca10b5..e91aa3aea 100644
--- a/libr/core/cmd_api.c
+++ b/libr/core/cmd_api.c
@@ -145,16 +145,16 @@ R_API int r_cmd_set_data(RCmd *cmd, void *data) {
 R_API int r_cmd_add_long(RCmd *cmd, const char *lcmd, const char *scmd, const char *desc) {
 	RCmdLongItem *item = R_NEW (RCmdLongItem);
 	if (item == NULL)
-		return R_FALSE;
+		return false;
 	strncpy (item->cmd, lcmd, sizeof (item->cmd)-1);
 	strncpy (item->cmd_short, scmd, sizeof (item->cmd_short)-1);
 	item->cmd_len = strlen (lcmd);
 	strncpy (item->desc, desc, sizeof (item->desc)-1);
 	if (!r_list_append (cmd->lcmds, item)){
 		free (item);
-		return R_FALSE;
+		return false;
 	}
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_cmd_add(RCmd *c, const char *cmd, const char *desc, r_cmd_callback(cb)) {
@@ -169,7 +169,7 @@ R_API int r_cmd_add(RCmd *c, const char *cmd, const char *desc, r_cmd_callback(c
 	strncpy (item->cmd, cmd, sizeof (item->cmd)-1);
 	strncpy (item->desc, desc, sizeof (item->desc)-1);
 	item->callback = cb;
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_cmd_del(RCmd *cmd, const char *command) {
@@ -197,7 +197,7 @@ R_API int r_cmd_call(RCmd *cmd, const char *input) {
 		r_list_foreach (cmd->plist, iter, cp) {
 			if (cp->call (cmd->data, input)) {
 				free (nstr);
-				return R_TRUE;
+				return true;
 			}
 		}
 		if (input[0] == -1) {
@@ -288,7 +288,7 @@ R_API int r_cmd_macro_add(RCmdMacro *mac, const char *oname) {
 	} else {
 		eprintf ("Invalid macro body\n");
 		free (name);
-		return R_FALSE;
+		return false;
 	}
 
 	if (*name && name[1] && name[strlen (name)-1]==')') {
@@ -401,11 +401,11 @@ R_API int r_cmd_macro_rm(RCmdMacro *mac, const char *_name) {
 			free (m->code);
 			free (m);
 			free (name);
-			return R_TRUE;
+			return true;
 		}
 	}
 	free (name);
-	return R_FALSE;
+	return false;
 }
 
 // TODO: use mac->cb_printf which is r_cons_printf at the end
@@ -563,13 +563,13 @@ R_API int r_cmd_macro_call(RCmdMacro *mac, const char *name) {
 	str = strdup (name);
 	if (str == NULL) {
 		perror ("strdup");
-		return R_FALSE;
+		return false;
 	}
 	ptr = strchr (str, ')');
 	if (ptr == NULL) {
 		eprintf ("Missing end ')' parenthesis.\n");
 		free (str);
-		return R_FALSE;
+		return false;
 	} else *ptr='\0';
 
 	args = strchr (str, ' ');
@@ -601,7 +601,7 @@ R_API int r_cmd_macro_call(RCmdMacro *mac, const char *name) {
 					m->name, m->nargs, nargs);
 				macro_level --;
 				free (str);
-				return R_FALSE;
+				return false;
 			}
 
 			mac->brk = 0;
@@ -611,7 +611,7 @@ R_API int r_cmd_macro_call(RCmdMacro *mac, const char *name) {
 					eprintf ("Interrupted at (%s)\n", ptr);
 					if (end) *end = '\n';
 					free (str);
-					return R_FALSE;
+					return false;
 				}
 				r_cons_flush ();
 
@@ -645,7 +645,7 @@ R_API int r_cmd_macro_call(RCmdMacro *mac, const char *name) {
 				} else {
 					macro_level --;
 					free (str);
-					return R_TRUE;
+					return true;
 				}
 
 				/* Fetch next command */
@@ -655,14 +655,14 @@ R_API int r_cmd_macro_call(RCmdMacro *mac, const char *name) {
 			if (mac->brk) {
 				macro_level--;
 				free (str);
-				return R_TRUE;
+				return true;
 			}
 		}
 	}
 	eprintf ("No macro named '%s'\n", str);
 	macro_level--;
 	free (str);
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_cmd_macro_break(RCmdMacro *mac, const char *value) {
@@ -673,42 +673,3 @@ R_API int r_cmd_macro_break(RCmdMacro *mac, const char *value) {
 		mac->brk_value = &mac->_brk_value;
 	return 0;
 }
-
-#if 0
-int cmd_quit(void *data, const char *input) {
-	printf("quit\n");
-//	exit(1);
-	return 0;
-}
-
-int cmd_echo(void *data, const char *input) {
-	const char *arg = strchr(input, ' ');
-	if (arg == NULL)
-		arg = input;
-	printf("%s\n", arg+1);
-	return 0;
-}
-
-int main()
-{
-	struct r_cmd_t *cmd;
-
-	cmd = r_cmd_new();
-
-	r_cmd_add(cmd, "e", "echo message", &cmd_echo);
-	r_cmd_add(cmd, "q", "quit program", &cmd_quit);
-
-	r_cmd_add_long(cmd, "echo", "e", "echo message");
-	r_cmd_add_long(cmd, "exit", "q", "quit program");
-
-	r_cmd_call(cmd, "e hello world short");
-	r_cmd_call_long(cmd, "echo hello world long");
-	r_cmd_call_long(cmd, "exit");
-	if (!r_cmd_call(cmd, "**dummy**"))
-		eprintf ("==> Cannot call **dummy**\n");
-	else eprintf ("==> **dummy** called\n");
-	r_cmd_call(cmd, "quit");
-
-	return 0;
-}
-#endif
diff --git a/libr/core/cmd_cmp.c b/libr/core/cmd_cmp.c
index a9e1d5aa9..5fab4923f 100644
--- a/libr/core/cmd_cmp.c
+++ b/libr/core/cmd_cmp.c
@@ -44,12 +44,12 @@ R_API RCoreCmpWatcher* r_core_cmpwatch_get(RCore *core, ut64 addr) {
 
 R_API int r_core_cmpwatch_add (RCore *core, ut64 addr, int size, const char *cmd) {
 	RCoreCmpWatcher *cmpw;
-	if (size<1) return R_FALSE;
+	if (size<1) return false;
 	cmpw = r_core_cmpwatch_get (core, addr);
 	if (!cmpw) {
 		cmpw = R_NEW (RCoreCmpWatcher);
 		if (!cmpw)
-			return R_FALSE;
+			return false;
 		cmpw->addr = addr;
 	}
 	cmpw->size = size;
@@ -58,21 +58,21 @@ R_API int r_core_cmpwatch_add (RCore *core, ut64 addr, int size, const char *cmd
 	cmpw->ndata = malloc (size);
 	if (cmpw->ndata == NULL) {
 		free (cmpw);
-		return R_FALSE;
+		return false;
 	}
 	r_io_read_at (core->io, addr, cmpw->ndata, size);
 	r_list_append (core->watchers, cmpw);
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_cmpwatch_del (RCore *core, ut64 addr) {
-	int ret = R_FALSE;
+	int ret = false;
 	RCoreCmpWatcher *w;
 	RListIter *iter, *iter2;
 	r_list_foreach_safe (core->watchers, iter, iter2, w) {
 		if (w->addr == addr || addr == UT64_MAX) {
 			r_list_delete (core->watchers, iter);
-			ret = R_TRUE;
+			ret = true;
 		}
 	}
 	return ret;
@@ -102,7 +102,7 @@ R_API int r_core_cmpwatch_show (RCore *core, ut64 addr, int mode) {
 			break;
 		}
 	}
-	return R_FALSE;
+	return false;
 }
 
 R_API int r_core_cmpwatch_update (RCore *core, ut64 addr) {
@@ -113,7 +113,7 @@ R_API int r_core_cmpwatch_update (RCore *core, ut64 addr) {
 		w->odata = w->ndata;
 		w->ndata = malloc (w->size);
 		if (w->ndata == NULL)
-			return R_FALSE;
+			return false;
 		r_io_read_at (core->io, w->addr, w->ndata, w->size);
 	}
 	return !r_list_empty (core->watchers);
@@ -121,7 +121,7 @@ R_API int r_core_cmpwatch_update (RCore *core, ut64 addr) {
 
 R_API int r_core_cmpwatch_revert (RCore *core, ut64 addr) {
 	RCoreCmpWatcher *w;
-	int ret = R_FALSE;
+	int ret = false;
 	RListIter *iter;
 	r_list_foreach (core->watchers, iter, w) {
 		if (w->addr == addr || addr == UT64_MAX) {
@@ -129,7 +129,7 @@ R_API int r_core_cmpwatch_revert (RCore *core, ut64 addr) {
 				free (w->ndata);
 				w->ndata = w->odata;
 				w->odata = NULL;
-				ret = R_TRUE;
+				ret = true;
 			}
 		}
 	}
@@ -140,14 +140,14 @@ static int radare_compare_unified(RCore *core, ut64 of, ut64 od, int len) {
 	int i, min, inc = 16;
 	ut8 *f, *d;
 	if (len<1)
-		return R_FALSE;
+		return false;
 	f = malloc (len);
 	if (f == NULL)
-		return R_FALSE;
+		return false;
 	d = malloc (len);
 	if (d == NULL) {
 		free (f);
-		return R_FALSE;
+		return false;
 	}
 	r_io_read_at (core->io, of, f, len);
 	r_io_read_at (core->io, od, d, len);
@@ -168,7 +168,7 @@ static int radare_compare_unified(RCore *core, ut64 of, ut64 od, int len) {
 	}
 	if (headers)
 		B_SET (core->print->flags, R_PRINT_FLAGS_HEADER);
-	return R_TRUE;
+	return true;
 }
 
 static int radare_compare(RCore *core, const ut8 *f, const ut8 *d, int len) {
@@ -250,7 +250,7 @@ static int cmd_cmp_disasm(RCore *core, const char *input, int mode) {
 	int cols = r_config_get_i (core->config, "hex.cols") * 2;
 	ut64 off = r_num_math (core->num, input);
 	ut8 *buf = calloc (core->blocksize+32, 1);
-	if (!buf) return R_FALSE;
+	if (!buf) return false;
 	r_core_read_at (core, off, buf, core->blocksize+32);
 	switch (mode) {
 	case 'c': // columns
@@ -353,7 +353,7 @@ static int cmd_cmp(void *data, const char *input) {
 		}
 		buf = (ut8*)malloc (strlen (input+2)+1);
 		if (buf == NULL)
-			return R_FALSE;
+			return false;
 		ret = r_hex_str2bin (input+2, buf);
 		if (ret<1) eprintf ("Cannot parse hexpair\n");
 		else val = radare_compare (core, core->block, buf, ret);
@@ -367,7 +367,7 @@ static int cmd_cmp(void *data, const char *input) {
 			if (ret<1) eprintf ("Cannot read hexdump\n");
 			val = radare_compare (core, core->block, buf, ret);
 			free (buf);
-		} return R_FALSE;
+		} return false;
 		break;
 	case 'f':
 		if (input[1]!=' ') {
@@ -389,7 +389,7 @@ static int cmd_cmp(void *data, const char *input) {
 			free (buf);
 		} else {
 			fclose (fd);
-			return R_FALSE;
+			return false;
 		}
 		break;
 	case 'd':
@@ -479,17 +479,17 @@ static int cmd_cmp(void *data, const char *input) {
 			switch (input[1]) {
 			case 'o': // "cgo"
 				file2 = (char*)r_str_chop_ro (input+2);
-				r_anal_diff_setup (core->anal, R_TRUE, -1, -1);
+				r_anal_diff_setup (core->anal, true, -1, -1);
 				break;
 			case 'f': // "cgf"
 				eprintf ("TODO: agf is experimental\n");
-				r_anal_diff_setup (core->anal, R_TRUE, -1, -1);
+				r_anal_diff_setup (core->anal, true, -1, -1);
 				r_core_gdiff_fcn (core, core->offset,
 					r_num_math (core->num, input +2));
-				return R_FALSE;
+				return false;
 			case ' ':
 				file2 = (char*)r_str_chop_ro (input+2);
-				r_anal_diff_setup (core->anal, R_FALSE, -1, -1);
+				r_anal_diff_setup (core->anal, false, -1, -1);
 				break;
 			default: {
 				const char * help_message[] = {
@@ -500,18 +500,18 @@ static int cmd_cmp(void *data, const char *input) {
 				NULL
 				};
 				r_core_cmd_help(core, help_message);
-				return R_FALSE;
+				return false;
 				}
 			}
 
 			if (r_file_size (file2) <= 0) {
 				eprintf ("Cannot compare with file %s\n", file2);
-				return R_FALSE;
+				return false;
 			}
 
 			if (!(core2 = r_core_new ())) {
 				eprintf ("Cannot init diff core\n");
-				return R_FALSE;
+				return false;
 			}
 			r_core_loadlibs (core2, R_CORE_LOADLIBS_ALL, NULL);
 			core2->io->va = core->io->va;
@@ -519,11 +519,11 @@ static int cmd_cmp(void *data, const char *input) {
 			if (!r_core_file_open (core2, file2, 0, 0LL)) {
 				eprintf ("Cannot open diff file '%s'\n", file2);
 				r_core_free (core2);
-				return R_FALSE;
+				return false;
 			}
 			// TODO: must replicate on core1 too
-			r_config_set_i (core2->config, "io.va", R_TRUE);
-			r_config_set_i (core2->config, "anal.split", R_TRUE);
+			r_config_set_i (core2->config, "io.va", true);
+			r_config_set_i (core2->config, "anal.split", true);
 			r_anal_diff_setup (core->anal, diffops, -1, -1);
 			r_anal_diff_setup (core2->anal, diffops, -1, -1);
 
diff --git a/libr/core/cmd_debug.c b/libr/core/cmd_debug.c
index 400007f04..4d7d04e42 100644
--- a/libr/core/cmd_debug.c
+++ b/libr/core/cmd_debug.c
@@ -48,7 +48,7 @@ static void cmd_debug_cont_syscall (RCore *core, const char *_str) {
 	} else {
 		eprintf ("Running child until next syscall\n");
 	}
-	r_reg_arena_swap (core->dbg->reg, R_TRUE);
+	r_reg_arena_swap (core->dbg->reg, true);
 	r_debug_continue_syscalls (core->dbg, syscalls, count);
 	checkbpcallback (core);
 	free (syscalls);
@@ -150,11 +150,11 @@ static int step_until(RCore *core, ut64 addr) {
 	ut64 off = r_debug_reg_get (core->dbg, "pc");
 	if (off == 0LL) {
 		eprintf ("Cannot 'drn pc'\n");
-		return R_FALSE;
+		return false;
 	}
 	if (addr == 0LL) {
 		eprintf ("Cannot continue until address 0\n");
-		return R_FALSE;
+		return false;
 	}
 	r_cons_break (NULL, NULL);
 	do {
@@ -171,14 +171,14 @@ static int step_until(RCore *core, ut64 addr) {
 		// check breakpoint here
 	} while (off != addr);
 	r_cons_break_end();
-	return R_TRUE;
+	return true;
 }
 
 static int step_until_esil(RCore *core, const char *esilstr) {
 	if (!core || !esilstr || !core->dbg || !core->dbg->anal \
 			|| !core->dbg->anal->esil) {
 		eprintf ("Not initialized %p. Run 'aei' first.\n", core->anal->esil);
-		return R_FALSE;
+		return false;
 	}
 	r_cons_break (NULL, NULL);
 	for (;;) {
@@ -198,7 +198,7 @@ static int step_until_esil(RCore *core, const char *esilstr) {
 		}
 	}
 	r_cons_break_end();
-	return R_TRUE;
+	return true;
 }
 
 static int step_until_inst(RCore *core, const char *instr) {
@@ -210,7 +210,7 @@ static int step_until_inst(RCore *core, const char *instr) {
 	instr = r_str_chop_ro (instr);
 	if (!core || !instr|| !core->dbg) {
 		eprintf ("Wrong state\n");
-		return R_FALSE;
+		return false;
 	}
 	r_cons_break (NULL, NULL);
 	for (;;) {
@@ -239,7 +239,7 @@ static int step_until_inst(RCore *core, const char *instr) {
 		}
 	}
 	r_cons_break_end();
-	return R_TRUE;
+	return true;
 }
 
 static int step_until_flag(RCore *core, const char *instr) {
@@ -251,7 +251,7 @@ static int step_until_flag(RCore *core, const char *instr) {
 	instr = r_str_chop_ro (instr);
 	if (!core || !instr|| !core->dbg) {
 		eprintf ("Wrong state\n");
-		return R_FALSE;
+		return false;
 	}
 	r_cons_break (NULL, NULL);
 	for (;;) {
@@ -277,7 +277,7 @@ static int step_until_flag(RCore *core, const char *instr) {
 	}
 beach:
 	r_cons_break_end();
-	return R_TRUE;
+	return true;
 }
 
 /* until end of frame */
@@ -297,7 +297,7 @@ static int step_until_eof(RCore *core) {
 		// check breakpoint here
 	} while (off <= now);
 	r_cons_break_end();
-	return R_TRUE;
+	return true;
 }
 
 static int step_line(RCore *core, int times) {
@@ -307,7 +307,7 @@ static int step_line(RCore *core, int times) {
 	ut64 off = r_debug_reg_get (core->dbg, "pc");
 	if (off == 0LL) {
 		eprintf ("Cannot 'drn pc'\n");
-		return R_FALSE;
+		return false;
 	}
 	file[0] = 0;
 	file2[0] = 0;
@@ -315,11 +315,11 @@ static int step_line(RCore *core, int times) {
 		char* ptr = r_file_slurp_line (file, line, 0);
 		eprintf ("--> 0x%08"PFMT64x" %s : %d\n", off, file, line);
 		eprintf ("--> %s\n", ptr);
-		find_meta = R_FALSE;
+		find_meta = false;
 		free (ptr);
 	} else {
 		eprintf ("--> Stepping until dwarf line\n");
-		find_meta = R_TRUE;
+		find_meta = true;
 	}
 	do {
 		r_debug_step (core->dbg, 1);
@@ -332,7 +332,7 @@ static int step_line(RCore *core, int times) {
 			if (find_meta)
 				continue;
 			eprintf ("Cannot retrieve dwarf info at 0x%08"PFMT64x"\n", off);
-			return R_FALSE;
+			return false;
 		}
 	} while (!strcmp (file, file2) && line == line2);
 
@@ -341,7 +341,7 @@ static int step_line(RCore *core, int times) {
 	eprintf ("--> %s\n", tmp_ptr);
 	free (tmp_ptr);
 
-	return R_TRUE;
+	return true;
 }
 
 static void cmd_debug_pid(RCore *core, const char *input) {
@@ -372,7 +372,7 @@ static void cmd_debug_pid(RCore *core, const char *input) {
 		sig = ptr? atoi (ptr+1): 0;
 		if (pid > 0) {
 			eprintf ("Sending signal '%d' to pid '%d'\n", sig, pid);
-			r_debug_kill (core->dbg, 0, R_FALSE, sig);
+			r_debug_kill (core->dbg, 0, false, sig);
 		} else eprintf ("cmd_debug_pid: Invalid arguments (%s)\n", input);
 		break;
 	case 'n':
@@ -455,10 +455,10 @@ static void cmd_debug_backtrace (RCore *core, const char *input) {
 		ut64 oaddr = 0LL;
 		eprintf ("Trap tracing 0x%08"PFMT64x"-0x%08"PFMT64x"\n",
 			core->offset, core->offset+len);
-		r_reg_arena_swap (core->dbg->reg, R_TRUE);
-		r_bp_traptrace_reset (core->dbg->bp, R_TRUE);
+		r_reg_arena_swap (core->dbg->reg, true);
+		r_bp_traptrace_reset (core->dbg->bp, true);
 		r_bp_traptrace_add (core->dbg->bp, core->offset, core->offset+len);
-		r_bp_traptrace_enable (core->dbg->bp, R_TRUE);
+		r_bp_traptrace_enable (core->dbg->bp, true);
 		do {
 			ut8 buf[32];
 			r_debug_continue (core->dbg);
@@ -481,7 +481,7 @@ static void cmd_debug_backtrace (RCore *core, const char *input) {
 			r_core_read_at (core, addr, buf, 32); // XXX longer opcodes?
 			r_anal_op (core->anal, &analop, addr, buf, sizeof (buf));
 		} while (r_bp_traptrace_at (core->dbg->bp, addr, analop.size));
-		r_bp_traptrace_enable (core->dbg->bp, R_FALSE);
+		r_bp_traptrace_enable (core->dbg->bp, false);
 	}
 }
 
@@ -623,18 +623,18 @@ static int dump_maps(RCore *core, int perm, const char *filename) {
 	RListIter *iter;
 	r_debug_map_sync (core->dbg); // update process memory maps
 	ut64 addr = core->offset;
-	int do_dump = R_FALSE;
-	int ret = r_list_empty(core->dbg->maps)? R_FALSE: R_TRUE;
+	int do_dump = false;
+	int ret = r_list_empty(core->dbg->maps)? false: true;
 	r_list_foreach (core->dbg->maps, iter, map) {
-		do_dump = R_FALSE;
+		do_dump = false;
 		if (perm == -1) {
 			if (addr >= map->addr && addr < map->addr_end) {
-				do_dump = R_TRUE;
+				do_dump = true;
 			}
 		} else if (perm == 0) {
-			do_dump = R_TRUE;
+			do_dump = true;
 		} else if (perm == (map->perm & perm)) {
-			do_dump = R_TRUE;
+			do_dump = true;
 		}
 		if (do_dump) {
 			ut8 *buf = malloc (map->size);
@@ -795,7 +795,7 @@ static int cmd_debug_map(RCore *core, const char *input) {
 	case 'l':
 		if (input[1] != ' ') {
 			eprintf ("Usage: dml [file]\n");
-			return R_FALSE;
+			return false;
 		}
 		r_debug_map_sync (core->dbg); // update process memory maps
 		r_list_foreach (core->dbg->maps, iter, map) {
@@ -805,7 +805,7 @@ static int cmd_debug_map(RCore *core, const char *input) {
 				//TODO: use mmap here. we need a portable implementation
 				if (!buf) {
 					eprintf ("Cannot allocate 0x%08"PFMT64x" bytes\n", map->size);
-					return R_FALSE;
+					return false;
 				}
 				r_io_write_at (core->io, map->addr, (const ut8*)buf, sz);
 				if (sz != map->size)
@@ -814,11 +814,11 @@ static int cmd_debug_map(RCore *core, const char *input) {
 				eprintf ("Loaded %d bytes into the map region at 0x%08"PFMT64x"\n",
 					sz, map->addr);
 				free (buf);
-				return R_TRUE;
+				return true;
 			}
 		}
 		eprintf ("No debug region found here\n");
-		return R_FALSE;
+		return false;
 	case 'i':
 		{ // Move to a separate function
 		RCoreBinFilter filter;
@@ -846,7 +846,7 @@ static int cmd_debug_map(RCore *core, const char *input) {
 				baddr = r_bin_get_baddr (core->bin);
 				r_bin_set_baddr (core->bin, map->addr);
 				r_core_bin_info (core, R_CORE_BIN_ACC_SYMBOLS, (input[1]=='*'),
-						R_TRUE, &filter, NULL);
+						true, &filter, NULL);
 				r_bin_set_baddr (core->bin, baddr);
 				break;
 			}
@@ -866,7 +866,7 @@ static int cmd_debug_map(RCore *core, const char *input) {
 				r_debug_map_alloc(core->dbg, addr, size);
 			} else {
 				eprintf ("Usage: dm addr size\n");
-				return R_FALSE;
+				return false;
 			}
 		}
 		break;
@@ -876,7 +876,7 @@ static int cmd_debug_map(RCore *core, const char *input) {
 			if (addr >= map->addr && addr < map->addr_end) {
 				r_debug_map_dealloc(core->dbg, map);
 				r_debug_map_sync (core->dbg);
-				return R_TRUE;
+				return true;
 			}
 		}
 		eprintf ("The address doesn't match with any map.\n");
@@ -888,7 +888,7 @@ static int cmd_debug_map(RCore *core, const char *input) {
 		r_debug_map_list (core->dbg, core->offset, input[0]);
 		break;
 	}
-	return R_TRUE;
+	return true;
 }
 
 static void cmd_debug_reg(RCore *core, const char *str) {
@@ -915,7 +915,7 @@ static void cmd_debug_reg(RCore *core, const char *str) {
 			const char *p = str+1;
 			ut64 off;
 			while (IS_WHITESPACE (*p)) p++;
-			r_debug_reg_sync (core->dbg, -1, 0); //R_REG_TYPE_GPR, R_FALSE);
+			r_debug_reg_sync (core->dbg, -1, 0); //R_REG_TYPE_GPR, false);
 			off = r_debug_reg_get (core->dbg, p);
 	//		r = r_reg_get (core->dbg->reg, str+1, 0);
 	//		if (r == NULL) eprintf ("Unknown register (%s)\n", str+1);
@@ -1028,9 +1028,9 @@ free (rf);
 	case 'x':
 		switch (str[1]) {
 		case '-':
-			r_debug_reg_sync (core->dbg, R_REG_TYPE_DRX, R_FALSE);
+			r_debug_reg_sync (core->dbg, R_REG_TYPE_DRX, false);
 			r_debug_drx_unset (core->dbg, atoi (str+2));
-			r_debug_reg_sync (core->dbg, R_REG_TYPE_DRX, R_TRUE);
+			r_debug_reg_sync (core->dbg, R_REG_TYPE_DRX, true);
 			break;
 		case ' ': {
 			char *s = strdup (str+2);
@@ -1046,19 +1046,19 @@ free (rf);
 				len = (int)r_num_math (core->num, ARG(2));
 				rwx = (char)r_str_rwx (ARG(3));
 				if (len== -1) {
-					r_debug_reg_sync (core->dbg, R_REG_TYPE_DRX, R_FALSE);
+					r_debug_reg_sync (core->dbg, R_REG_TYPE_DRX, false);
 					r_debug_drx_set (core->dbg, n, 0, 0, 0, 0);
-					r_debug_reg_sync (core->dbg, R_REG_TYPE_DRX, R_TRUE);
+					r_debug_reg_sync (core->dbg, R_REG_TYPE_DRX, true);
 				} else {
-					r_debug_reg_sync (core->dbg, R_REG_TYPE_DRX, R_FALSE);
+					r_debug_reg_sync (core->dbg, R_REG_TYPE_DRX, false);
 					r_debug_drx_set (core->dbg, n, off, len, rwx, 0);
-					r_debug_reg_sync (core->dbg, R_REG_TYPE_DRX, R_TRUE);
+					r_debug_reg_sync (core->dbg, R_REG_TYPE_DRX, true);
 				}
 			} else eprintf ("|Usage: drx N [address] [length] [rwx]\n");
 			free (s);
 			} break;
 		case '\0':
-			r_debug_reg_sync (core->dbg, R_REG_TYPE_DRX, R_FALSE);
+			r_debug_reg_sync (core->dbg, R_REG_TYPE_DRX, false);
 			r_debug_drx_list (core->dbg);
 			break;
 		default: {
@@ -1127,11 +1127,11 @@ free (rf);
 				if (eq) {
 					ut64 val = r_num_math (core->num, eq);
 					r_reg_set_pack (core->dbg->reg, item, word, size, val);
-					r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, R_TRUE);
-					r_debug_reg_sync (core->dbg, R_REG_TYPE_MMX, R_TRUE);
+					r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, true);
+					r_debug_reg_sync (core->dbg, R_REG_TYPE_MMX, true);
 				} else {
-					r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, R_FALSE);
-					r_debug_reg_sync (core->dbg, R_REG_TYPE_MMX, R_FALSE);
+					r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, false);
+					r_debug_reg_sync (core->dbg, R_REG_TYPE_MMX, false);
 					ut64 res = r_reg_get_pack (core->dbg->reg, item, word, size);
 					r_cons_printf ("0x%08"PFMT64x"\n", res);
 				}
@@ -1140,13 +1140,13 @@ free (rf);
 			}
 			free (name);
 		} else {
-			r_debug_reg_sync (core->dbg, -R_REG_TYPE_MMX, R_FALSE);
+			r_debug_reg_sync (core->dbg, -R_REG_TYPE_MMX, false);
 		}
 		//r_debug_drx_list (core->dbg);
 		break;
 	case 'f': // "drf"
 		/* Note, that negative type forces sync to print the regs from the backend */
-		r_debug_reg_sync (core->dbg, -R_REG_TYPE_FPU, R_FALSE);
+		r_debug_reg_sync (core->dbg, -R_REG_TYPE_FPU, false);
 		//r_debug_drx_list (core->dbg);
 		if (str[1]=='?') {
 			eprintf ("Usage: drf [fpureg] [= value]\n");
@@ -1166,11 +1166,11 @@ free (rf);
 					long double val = 0.0f;
 					sscanf (eq, "%Lf", &val);
 					r_reg_set_double (core->dbg->reg, item, val);
-					r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, R_TRUE);
-					r_debug_reg_sync (core->dbg, R_REG_TYPE_FPU, R_TRUE);
+					r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, true);
+					r_debug_reg_sync (core->dbg, R_REG_TYPE_FPU, true);
 				} else {
-					r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, R_FALSE);
-					r_debug_reg_sync (core->dbg, R_REG_TYPE_FPU, R_FALSE);
+					r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, false);
+					r_debug_reg_sync (core->dbg, R_REG_TYPE_FPU, false);
 					long double res = r_reg_get_double (core->dbg->reg, item);
 					r_cons_printf ("%Lf\n", res);
 				}
@@ -1179,7 +1179,7 @@ free (rf);
 			}
 			free (name);
 		} else {
-			r_debug_reg_sync (core->dbg, -R_REG_TYPE_FPU, R_FALSE);
+			r_debug_reg_sync (core->dbg, -R_REG_TYPE_FPU, false);
 		}
 		break;
 	case 'p': // "drp"
@@ -1263,12 +1263,12 @@ free (rf);
 				type = r_reg_type_by_name (str+2);
 				if (size < 0)
 					size = core->dbg->bits * 8;
-				r_debug_reg_sync (core->dbg, type, R_FALSE);
+				r_debug_reg_sync (core->dbg, type, false);
 				r_debug_reg_list (core->dbg, type, size,
 					strchr (str,'*')? 1: 0, use_color);
 			} else {
 				if (type != R_REG_TYPE_LAST) {
-					r_debug_reg_sync (core->dbg, type, R_FALSE);
+					r_debug_reg_sync (core->dbg, type, false);
 					r_debug_reg_list (core->dbg, type, size,
 						strchr (str,'*')?1:0, use_color);
 				} else eprintf ("cmd_debug_reg: Unknown type\n");
@@ -1290,13 +1290,13 @@ free (rf);
 		r_debug_reg_list (core->dbg, R_REG_TYPE_GPR, bits, 3, use_color); // XXX detect which one is current usage
 		break;
 	case 'o':
-		r_reg_arena_swap (core->dbg->reg, R_FALSE);
+		r_reg_arena_swap (core->dbg->reg, false);
 		r_debug_reg_list (core->dbg, R_REG_TYPE_GPR, bits, 0, use_color); // XXX detect which one is current usage
-		r_reg_arena_swap (core->dbg->reg, R_FALSE);
+		r_reg_arena_swap (core->dbg->reg, false);
 		break;
 	case '=':
 		if (r_config_get_i (core->config, "cfg.debug")) {
-			if (r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, R_FALSE)) {
+			if (r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, false)) {
 				r_debug_reg_list (core->dbg, R_REG_TYPE_GPR, bits, 2, use_color); // XXX detect which one is current usage
 			} //else eprintf ("Cannot retrieve registers from pid %d\n", core->dbg->pid);
 		} else {
@@ -1307,7 +1307,7 @@ free (rf);
 		}
 		break;
 	case '*':
-		if (r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, R_FALSE)) {
+		if (r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, false)) {
 			r_cons_printf ("fs+regs\n");
 			r_debug_reg_list (core->dbg, R_REG_TYPE_GPR, bits, '*', use_color);
 			r_flag_space_pop (core->flags);
@@ -1395,7 +1395,7 @@ free (rf);
 		break;
 	case 'j':
 	case '\0':
-		if (r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, R_FALSE)) {
+		if (r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, false)) {
 			r_debug_reg_list (core->dbg, R_REG_TYPE_GPR, bits, str[0], use_color);
 		} else eprintf ("Cannot retrieve registers from pid %d\n", core->dbg->pid);
 		break;
@@ -1416,7 +1416,7 @@ free (rf);
 					r_cons_printf ("0x%08"PFMT64x" ->",
 							r_reg_get_value (core->dbg->reg, r));
 					r_reg_set_bvalue (core->dbg->reg, r, arg+1);
-					r_debug_reg_sync (core->dbg, -1, R_TRUE);
+					r_debug_reg_sync (core->dbg, -1, true);
 					r_cons_printf ("0x%08"PFMT64x"\n",
 							r_reg_get_value (core->dbg->reg, r));
 				} else {
@@ -1424,7 +1424,7 @@ free (rf);
 							r_reg_get_value (core->dbg->reg, r));
 					r_reg_set_value (core->dbg->reg, r,
 							r_num_math (core->num, arg+1));
-					r_debug_reg_sync (core->dbg, -1, R_TRUE);
+					r_debug_reg_sync (core->dbg, -1, true);
 					r_cons_printf ("0x%08"PFMT64x"\n",
 							r_reg_get_value (core->dbg->reg, r));
 				}
@@ -1433,7 +1433,7 @@ free (rf);
 			return;
 		} else {
 			ut64 off;
-			r_debug_reg_sync (core->dbg, -1, 0); //R_REG_TYPE_GPR, R_FALSE);
+			r_debug_reg_sync (core->dbg, -1, 0); //R_REG_TYPE_GPR, false);
 			off = r_debug_reg_get (core->dbg, str+1);
 	//		r = r_reg_get (core->dbg->reg, str+1, 0);
 	//		if (r == NULL) eprintf ("Unknown register (%s)\n", str+1);
@@ -1453,21 +1453,21 @@ static int checkbpcallback(RCore *core) {
 			r_core_cmd (core, bpi->data, 0);
 		if (cmdbp && *cmdbp)
 			r_core_cmd (core, cmdbp, 0);
-		return R_TRUE;
+		return true;
 	}
-	return R_FALSE;
+	return false;
 }
 
 static int bypassbp(RCore *core) {
 	RBreakpointItem *bpi;
 	ut64 addr;
-	r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, R_FALSE);
+	r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, false);
 	addr = r_debug_reg_get (core->dbg, "pc");
 	bpi = r_bp_get_at (core->dbg->bp, addr);
-	if (!bpi) return R_FALSE;
+	if (!bpi) return false;
 	/* XXX 2 if libr/debug/debug.c:226 is enabled */
 	r_debug_step (core->dbg, 1);
-	return R_TRUE;
+	return true;
 }
 
 static int validAddress(RCore *core, ut64 addr) {
@@ -1555,17 +1555,17 @@ static void r_core_cmd_bp(RCore *core, const char *input) {
 		case 'e':
 			for (p = input + 3; *p == ' '; p++) { /* nothing to do here */ }
 			if (*p == '*') {
-				r_bp_set_trace_all (core->dbg->bp,R_TRUE);
+				r_bp_set_trace_all (core->dbg->bp,true);
 			} else if (!r_bp_set_trace (core->dbg->bp,
-						addr, R_TRUE)) {
+						addr, true)) {
 				eprintf ("Cannot set tracepoint\n");
 			}
 			break;
 		case 'd':
 			for (p = input + 3; *p==' ';p++);
 			if (*p == '*') {
-				r_bp_set_trace_all (core->dbg->bp,R_FALSE);
-			} else if (!r_bp_set_trace (core->dbg->bp, addr, R_FALSE))
+				r_bp_set_trace_all (core->dbg->bp,false);
+			} else if (!r_bp_set_trace (core->dbg->bp, addr, false))
 				eprintf ("Cannot unset tracepoint\n");
 			break;
 		case 's':
@@ -1748,15 +1748,15 @@ static void r_core_cmd_bp(RCore *core, const char *input) {
 		break;
 	case 'e':
 		for (p = input + 2; *p == ' '; p++);
-		if (*p == '*') r_bp_enable_all (core->dbg->bp,R_TRUE);
+		if (*p == '*') r_bp_enable_all (core->dbg->bp,true);
 		else r_bp_enable (core->dbg->bp, r_num_math (core->num,
-							input + 2), R_TRUE);
+							input + 2), true);
 		break;
 	case 'd':
 		for (p = input + 2; *p == ' '; p++);
-		if (*p == '*') r_bp_enable_all (core->dbg->bp, R_FALSE);
+		if (*p == '*') r_bp_enable_all (core->dbg->bp, false);
 		r_bp_enable (core->dbg->bp, r_num_math (core->num,
-							input + 2), R_FALSE);
+							input + 2), false);
 		break;
 	case 'h':
 		switch (input[2]) {
@@ -1834,12 +1834,12 @@ static void r_core_cmd_bp(RCore *core, const char *input) {
 			break;
 		case 'e': // "dbie"
 			if ((bpi = r_bp_get_index (core->dbg->bp, addr))) {
-				bpi->enabled = R_TRUE;
+				bpi->enabled = true;
 			} else eprintf ("Cannot unset tracepoint\n");
 			break;
 		case 'd': // "dbid"
 			if ((bpi = r_bp_get_index (core->dbg->bp, addr))) {
-				bpi->enabled = R_FALSE;
+				bpi->enabled = false;
 			} else eprintf ("Cannot unset tracepoint\n");
 			break;
 		case 's': // "dbis"
@@ -1851,12 +1851,12 @@ static void r_core_cmd_bp(RCore *core, const char *input) {
 			switch (input[3]) {
 			case 'e':
 				if ((bpi = r_bp_get_index (core->dbg->bp, addr))) {
-					bpi->trace = R_TRUE;
+					bpi->trace = true;
 				} else eprintf ("Cannot unset tracepoint\n");
 				break;
 			case 'd':
 				if ((bpi = r_bp_get_index (core->dbg->bp, addr))) {
-					bpi->trace = R_FALSE;
+					bpi->trace = false;
 				} else eprintf ("Cannot unset tracepoint\n");
 				break;
 			case 's':
@@ -1932,7 +1932,7 @@ static void do_debug_trace_calls (RCore *core, ut64 from, ut64 to, ut64 final_ad
 	r_tree_add_node (tr, NULL, NULL);
 	cur = tr->root;
 
-	while (R_TRUE) {
+	while (true) {
 		ut8 buf[32];
 		ut64 addr;
 		RAnalOp aop;
@@ -1947,7 +1947,7 @@ static void do_debug_trace_calls (RCore *core, ut64 from, ut64 to, ut64 final_ad
 		else if (!r_debug_step (dbg, 1))
 			break;
 		debug_to = UT64_MAX;
-		if (!r_debug_reg_sync (dbg, R_REG_TYPE_GPR, R_FALSE))
+		if (!r_debug_reg_sync (dbg, R_REG_TYPE_GPR, false))
 			break;
 		addr = r_debug_reg_get (dbg, "pc");
 		addr_in_range = addr >= from && addr < to;
@@ -1964,7 +1964,7 @@ static void do_debug_trace_calls (RCore *core, ut64 from, ut64 to, ut64 final_ad
 			// step into
 			// get pc
 			r_debug_step (dbg, 1);
-			r_debug_reg_sync (dbg, R_REG_TYPE_GPR, R_FALSE);
+			r_debug_reg_sync (dbg, R_REG_TYPE_GPR, false);
 			called_addr = r_debug_reg_get (dbg, "pc");
 			called_in_range = called_addr >= from && called_addr < to;
 			if (!called_in_range && addr_in_range && shallow_trace)
@@ -1993,7 +1993,7 @@ static void do_debug_trace_calls (RCore *core, ut64 from, ut64 to, ut64 final_ad
 #if 0
 			// TODO: we must store ret value for each call in the graph path to do this check
 			r_debug_step (dbg, 1);
-			r_debug_reg_sync (dbg, R_REG_TYPE_GPR, R_FALSE);
+			r_debug_reg_sync (dbg, R_REG_TYPE_GPR, false);
 			addr = r_debug_reg_get (dbg, "pc");
 			// TODO: step into and check return address if correct
 			// if not correct we are hijacking the control flow (exploit!)
@@ -2047,7 +2047,7 @@ static void debug_trace_calls (RCore *core, const char *input) {
 
 	core->dbg->trace->enabled = 0;
 	r_cons_break (static_debug_stop, core->dbg);
-	r_reg_arena_swap (core->dbg->reg, R_TRUE);
+	r_reg_arena_swap (core->dbg->reg, true);
 
 	if (final_addr != UT64_MAX) {
 		int hwbp = r_config_get_i (core->config, "dbg.hwbp");
@@ -2277,7 +2277,7 @@ static int cmd_debug_continue (RCore *core, const char *input) {
 		r_core_cmd0 (core, "dcs vfork fork");
 		break;
 	case 'c':
-		r_reg_arena_swap (core->dbg->reg, R_TRUE);
+		r_reg_arena_swap (core->dbg->reg, true);
 		if (input[2] == 'u') {
 			r_debug_continue_until_optype (core->dbg, R_ANAL_OP_TYPE_UCALL, 0);
 		} else {
@@ -2286,13 +2286,13 @@ static int cmd_debug_continue (RCore *core, const char *input) {
 		checkbpcallback (core);
 		break;
 	case 'r':
-		r_reg_arena_swap (core->dbg->reg, R_TRUE);
+		r_reg_arena_swap (core->dbg->reg, true);
 		r_debug_continue_until_optype (core->dbg, R_ANAL_OP_TYPE_RET, 1);
 		checkbpcallback (core);
 		break;
 	case 'k':
 		// select pid and r_debug_continue_kill (core->dbg,
-		r_reg_arena_swap (core->dbg->reg, R_TRUE);
+		r_reg_arena_swap (core->dbg->reg, true);
 		signum = r_num_math (core->num, input+2);
 		ptr = strchr (input+3, ' ');
 		if (ptr) {
@@ -2341,7 +2341,7 @@ static int cmd_debug_continue (RCore *core, const char *input) {
 			r_cons_break (static_debug_stop, core->dbg);
 			do {
 				r_debug_step (core->dbg, 1);
-				r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, R_FALSE);
+				r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, false);
 				pc = r_debug_reg_get (core->dbg, "pc");
 				eprintf (" %d %"PFMT64x"\r", n++, pc);
 				s = r_io_section_vget (core->io, pc);
@@ -2366,7 +2366,7 @@ static int cmd_debug_continue (RCore *core, const char *input) {
 			to = r_num_math (core->num, ptr+1);
 			do {
 				r_debug_step (core->dbg, 1);
-				r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, R_FALSE);
+				r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, false);
 				pc = r_debug_reg_get (core->dbg, "pc");
 				eprintf ("Continue 0x%08"PFMT64x" > 0x%08"PFMT64x" < 0x%08"PFMT64x"\n",
 						from, pc, to);
@@ -2377,7 +2377,7 @@ static int cmd_debug_continue (RCore *core, const char *input) {
 		if (addr) {
 			eprintf ("Continue until 0x%08"PFMT64x"\n", addr);
 			bypassbp (core);
-			r_reg_arena_swap (core->dbg->reg, R_TRUE);
+			r_reg_arena_swap (core->dbg->reg, true);
 			r_bp_add_sw (core->dbg->bp, addr, 1, R_BP_PROT_EXEC);
 			r_debug_continue (core->dbg);
 			checkbpcallback (core);
@@ -2391,7 +2391,7 @@ static int cmd_debug_continue (RCore *core, const char *input) {
 		old_pid = core->dbg->pid;
 		pid = atoi (input+2);
 		bypassbp (core);
-		r_reg_arena_swap (core->dbg->reg, R_TRUE);
+		r_reg_arena_swap (core->dbg->reg, true);
 		r_debug_select (core->dbg, pid, core->dbg->tid);
 		r_debug_continue (core->dbg);
 		r_debug_select (core->dbg, old_pid, core->dbg->tid);
@@ -2402,7 +2402,7 @@ static int cmd_debug_continue (RCore *core, const char *input) {
 		break;
 	default:
 		bypassbp (core);
-		r_reg_arena_swap (core->dbg->reg, R_TRUE);
+		r_reg_arena_swap (core->dbg->reg, true);
 		r_debug_continue (core->dbg);
 		checkbpcallback (core);
 	}
@@ -2473,7 +2473,7 @@ static int cmd_debug_step (RCore *core, const char *input) {
 			step_until_esil (core, input+3);
 			break;
 		case ' ':
-			r_reg_arena_swap (core->dbg->reg, R_TRUE);
+			r_reg_arena_swap (core->dbg->reg, true);
 			step_until (core, r_num_math (core->num, input+2)); // XXX dupped by times
 			break;
 		default:
@@ -2483,12 +2483,12 @@ static int cmd_debug_step (RCore *core, const char *input) {
 		}
 		break;
 	case 'p':
-		r_reg_arena_swap (core->dbg->reg, R_TRUE);
+		r_reg_arena_swap (core->dbg->reg, true);
 		for (i=0; i<times; i++) {
 			ut8 buf[64];
 			ut64 addr;
 			RAnalOp aop;
-			r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, R_FALSE);
+			r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, false);
 			addr = r_debug_reg_get (core->dbg, "pc");
 			r_io_read_at (core->io, addr, buf, sizeof (buf));
 			r_anal_op (core->anal, &aop, addr, buf, sizeof (buf));
@@ -2508,9 +2508,9 @@ static int cmd_debug_step (RCore *core, const char *input) {
 		break;
 	case 's':
 		addr = r_debug_reg_get (core->dbg, "pc");
-		r_reg_arena_swap (core->dbg->reg, R_TRUE);
+		r_reg_arena_swap (core->dbg->reg, true);
 		for (i = 0; i < times; i++) {
-			r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, R_FALSE);
+			r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, false);
 			r_io_read_at (core->io, addr, buf, sizeof (buf));
 			r_anal_op (core->anal, &aop, addr, buf, sizeof (buf));
 			if (aop.jump != UT64_MAX && aop.fail != UT64_MAX) {
@@ -2522,7 +2522,7 @@ static int cmd_debug_step (RCore *core, const char *input) {
 		r_debug_reg_set (core->dbg, "pc", addr);
 		break;
 	case 'o':
-		r_reg_arena_swap (core->dbg->reg, R_TRUE);
+		r_reg_arena_swap (core->dbg->reg, true);
 		r_debug_step_over (core->dbg, times);
 		if (checkbpcallback (core)) {
 			eprintf ("Interrupted by a breakpoint\n");
@@ -2530,12 +2530,12 @@ static int cmd_debug_step (RCore *core, const char *input) {
 		}
 		break;
 	case 'l':
-		r_reg_arena_swap (core->dbg->reg, R_TRUE);
+		r_reg_arena_swap (core->dbg->reg, true);
 		step_line (core, times);
 		break;
 	default:
-		r_reg_arena_swap (core->dbg->reg, R_TRUE);
-		r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, R_FALSE);
+		r_reg_arena_swap (core->dbg->reg, true);
+		r_debug_reg_sync (core->dbg, R_REG_TYPE_GPR, false);
 		r_debug_step (core->dbg, times);
 		if (checkbpcallback (core)) {
 			eprintf ("Interrupted by a breakpoint\n");
diff --git a/libr/core/cmd_egg.c b/libr/core/cmd_egg.c
index 84f7dc764..10c6f76a6 100644
--- a/libr/core/cmd_egg.c
+++ b/libr/core/cmd_egg.c
@@ -14,19 +14,19 @@ static void cmd_egg_option (REgg *egg, const char *key, const char *input) {
 static int cmd_egg_compile(REgg *egg) {
 	int i;
 	RBuffer *b;
-	int ret = R_FALSE;
+	int ret = false;
 	char *p = r_egg_option_get (egg, "egg.shellcode");
 	if (p && *p) {
 		if (!r_egg_shellcode (egg, p)) {
 			free (p);
-			return R_FALSE;
+			return false;
 		}
 		free (p);
 	}
 	r_egg_compile (egg);
 	if (!r_egg_assemble (egg)) {
 		eprintf ("r_egg_assemble: invalid assembly\n");
-		return R_FALSE;
+		return false;
 	}
 	p = r_egg_option_get (egg, "egg.padding");
 	if (p && *p) {
@@ -44,7 +44,7 @@ static int cmd_egg_compile(REgg *egg) {
 				r_cons_printf ("%02x", b->buf[i]);
 			r_cons_printf ("\n");
 		}
-		ret = R_TRUE;
+		ret = true;
 	}
 	// we do not own this buffer!!
 	// r_buf_free (b);
@@ -165,6 +165,6 @@ eprintf ("TODO: list options\n");
 		}
 		break;
 	}
-	return R_TRUE;
+	return true;
 }
 
diff --git a/libr/core/cmd_eval.c b/libr/core/cmd_eval.c
index 4f71eac08..715affa2b 100644
--- a/libr/core/cmd_eval.c
+++ b/libr/core/cmd_eval.c
@@ -30,7 +30,7 @@ static int cmd_eval(void *data, const char *input) {
 			}
 			free (k);
 		}
-		return R_TRUE;
+		return true;
 	case 'x': // exit
 		return cmd_quit (data, "");
 	case 'j':
diff --git a/libr/core/cmd_hash.c b/libr/core/cmd_hash.c
index 8f02af544..bdda54b3a 100644
--- a/libr/core/cmd_hash.c
+++ b/libr/core/cmd_hash.c
@@ -40,7 +40,7 @@ static RHashHashHandlers hash_handlers[] = {
 
 static void handle_md4 (const ut8 *block, int len) {
 	int i = 0;
-	RHash *ctx = r_hash_new (R_TRUE, R_HASH_MD4);
+	RHash *ctx = r_hash_new (true, R_HASH_MD4);
 	const ut8 *c = r_hash_do_md4 (ctx, block, len);
 	for (i=0; i<R_HASH_SIZE_MD4; i++) r_cons_printf ("%02x", c[i]);
 	r_cons_newline ();
@@ -49,7 +49,7 @@ static void handle_md4 (const ut8 *block, int len) {
 
 static void handle_md5 (const ut8 *block, int len) {
 	int i = 0;
-	RHash *ctx = r_hash_new (R_TRUE, R_HASH_MD5);
+	RHash *ctx = r_hash_new (true, R_HASH_MD5);
 	const ut8 *c = r_hash_do_md5 (ctx, block, len);
 	for (i=0; i<R_HASH_SIZE_MD5; i++) r_cons_printf ("%02x", c[i]);
 	r_cons_newline ();
@@ -58,7 +58,7 @@ static void handle_md5 (const ut8 *block, int len) {
 
 static void handle_sha1 (const ut8 *block, int len) {
 	int i = 0;
-	RHash *ctx = r_hash_new (R_TRUE, R_HASH_SHA1);
+	RHash *ctx = r_hash_new (true, R_HASH_SHA1);
 	const ut8 *c = r_hash_do_sha1 (ctx, block, len);
 	for (i=0; i<R_HASH_SIZE_SHA1; i++) r_cons_printf ("%02x", c[i]);
 	r_cons_newline ();
@@ -67,7 +67,7 @@ static void handle_sha1 (const ut8 *block, int len) {
 
 static void handle_sha256 (const ut8 *block, int len) {
 	int i = 0;
-	RHash *ctx = r_hash_new (R_TRUE, R_HASH_SHA256);
+	RHash *ctx = r_hash_new (true, R_HASH_SHA256);
 	const ut8 *c = r_hash_do_sha256 (ctx, block, len);
 	for (i=0; i<R_HASH_SIZE_SHA256; i++) r_cons_printf ("%02x", c[i]);
 	r_cons_newline ();
@@ -76,7 +76,7 @@ static void handle_sha256 (const ut8 *block, int len) {
 
 static void handle_sha512 (const ut8 *block, int len) {
 	int i = 0;
-	RHash *ctx = r_hash_new (R_TRUE, R_HASH_SHA512);
+	RHash *ctx = r_hash_new (true, R_HASH_SHA512);
 	const ut8 *c = r_hash_do_sha512 (ctx, block, len);
 	for (i=0; i<R_HASH_SIZE_SHA512; i++) r_cons_printf ("%02x", c[i]);
 	r_cons_newline ();
@@ -142,7 +142,7 @@ static int cmd_hash_bang (RCore *core, const char *input) {
 	const char *lang = input+1;
 	if (r_sandbox_enable (0)) {
 		eprintf ("hashbang disabled in sandbox mode\n");
-		return R_FALSE;
+		return false;
 	}
 	if (*lang=='/') {
 		const char *ptr = lang+1;
@@ -159,7 +159,7 @@ static int cmd_hash_bang (RCore *core, const char *input) {
 		if (p && p->name) lang = p->name;
 	} else if (input[1]=='?' || input[1]=='*' || input[1]=='\0') {
 		r_lang_list (core->lang);
-		return R_TRUE;
+		return true;
 	}
 	p = strchr (input, ' ');
 	if (p) *p=0;
@@ -177,7 +177,7 @@ static int cmd_hash_bang (RCore *core, const char *input) {
 		if (!p || *p==' ')
 			eprintf ("Invalid hashbang. See '#!' for help.\n");
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int cmd_hash(void *data, const char *input) {
@@ -185,7 +185,7 @@ static int cmd_hash(void *data, const char *input) {
 	RCore *core = (RCore *)data;
 	ut32 osize = 0, len = core->blocksize;
 	const char *ptr;
-	int pos = 0, handled_cmd = R_FALSE;
+	int pos = 0, handled_cmd = false;
 
 	switch (*input) {
 	case '\t':
@@ -194,7 +194,7 @@ static int cmd_hash(void *data, const char *input) {
 	case '#':
 		if (!input[1]) {
 			algolist (1);
-			return R_TRUE;
+			return true;
 		}
 	case '!':
 		return cmd_hash_bang (core, input);
@@ -211,7 +211,7 @@ static int cmd_hash(void *data, const char *input) {
 			if (nlen != core->blocksize) {
 				eprintf ("Invalid block size\n");
 				r_core_block_size (core, osize);
-				return R_TRUE;
+				return true;
 			}
 		}
 	} else if (!ptr || !*(ptr+1)) osize = len;
@@ -220,7 +220,7 @@ static int cmd_hash(void *data, const char *input) {
 	while (osize > 0 && hash_handlers[pos].name != NULL) {
 		if (!r_str_ccmp (input, hash_handlers[pos].name, ' ')) {
 			hash_handlers[pos].handler (core->block, len);
-			handled_cmd = R_TRUE;
+			handled_cmd = true;
 			break;
 		}
 		pos++;
diff --git a/libr/core/cmd_help.c b/libr/core/cmd_help.c
index ea719a73e..dfc3275db 100644
--- a/libr/core/cmd_help.c
+++ b/libr/core/cmd_help.c
@@ -100,8 +100,7 @@ static int cmd_help(void *data, const char *input) {
 			//b64 decoding takes at most strlen(str) * 4
 			const int buflen = (strlen (input+3) * 4) + 1;
 			char* buf = calloc (buflen, sizeof(char));
-			if (!buf)
-				return R_FALSE;
+			if (!buf) return false;
 			if (input[3] == '-')
 				r_base64_decode ((ut8*)buf, input+5, strlen (input+5));
 			else r_base64_encode (buf, (const ut8*)input+4, strlen (input+4));
@@ -334,7 +333,7 @@ static int cmd_help(void *data, const char *input) {
 			NULL};
 		r_core_cmd_help (core, help_msg);
 		}
-		return R_TRUE;
+		return true;
 	case 'V':
 		if (!input[1]){
 			if (!strcmp (R2_VERSION, GIT_TAP))
@@ -453,7 +452,7 @@ static int cmd_help(void *data, const char *input) {
 			r_cons_message (input+2);
 			break;
 		case 'p': {
-			core->num->value = r_core_yank_hud_path (core, input+2, 0) == R_TRUE;
+			core->num->value = r_core_yank_hud_path (core, input+2, 0) == true;
 			} break;
 		case 'k':
 			r_cons_any_key (NULL);
diff --git a/libr/core/cmd_info.c b/libr/core/cmd_info.c
index 2d7b560fe..ee796f6a4 100644
--- a/libr/core/cmd_info.c
+++ b/libr/core/cmd_info.c
@@ -135,13 +135,13 @@ static int bin_is_executable (RBinObject *obj){
 	RListIter *it;
 	RBinSection* sec;
 	if (obj->info->arch) {
-		return R_TRUE;
+		return true;
 	}
 	r_list_foreach (obj->sections, it, sec){
 		if (R_BIN_SCN_EXECUTABLE & sec->srwx)
-			return R_TRUE;
+			return true;
 	}
-	return R_FALSE;
+	return false;
 }
 
 static void cmd_info_bin(RCore *core, int va, int mode) {
diff --git a/libr/core/cmd_magic.c b/libr/core/cmd_magic.c
index 918b545a6..083472dd6 100644
--- a/libr/core/cmd_magic.c
+++ b/libr/core/cmd_magic.c
@@ -20,7 +20,7 @@ static int r_core_magic_at(RCore *core, const char *file, ut64 addr, int depth,
 		if (addr >= core->offset && (addr+NAH) < (core->offset + core->blocksize)) {
 			delta = addr - core->offset;
 		} else {
-			r_core_seek (core, addr, R_TRUE);
+			r_core_seek (core, addr, true);
 		}
 #endif
 	}
@@ -155,5 +155,5 @@ static void r_core_magic(RCore *core, const char *file, int v) {
 	magicdepth = r_config_get_i (core->config, "magic.depth"); // TODO: do not use global var here
 	r_core_magic_at (core, file, addr, magicdepth, v);
 	if (addr != core->offset)
-		r_core_seek (core, addr, R_TRUE);
+		r_core_seek (core, addr, true);
 }
diff --git a/libr/core/cmd_meta.c b/libr/core/cmd_meta.c
index 8284c05b0..704b19cf5 100644
--- a/libr/core/cmd_meta.c
+++ b/libr/core/cmd_meta.c
@@ -95,7 +95,7 @@ static int print_addrinfo (void *user, const char *k, const char *v) {
 
 	offset = sdb_atoi (v);
 	if (!offset)
-		return R_TRUE;
+		return true;
 
 	subst = strdup (k);
 	colonpos = strchr (subst, '|');
@@ -107,7 +107,7 @@ static int print_addrinfo (void *user, const char *k, const char *v) {
 
 	free (subst);
 
-	return R_TRUE;
+	return true;
 }
 
 static int cmd_meta_add_fileline(Sdb *s, char *fileline, ut64 offset) {
@@ -132,8 +132,8 @@ static int cmd_meta_add_fileline(Sdb *s, char *fileline, ut64 offset) {
 static int cmd_meta_lineinfo(RCore *core, const char *input) {
 	int ret;
 	ut64 offset = UT64_MAX; // use this as error value
-	int remove = R_FALSE;
-	int all = R_FALSE;
+	int remove = false;
+	int all = false;
 	const char *p = input;
 	char *colon, *space, *file_line = 0;
 
@@ -144,12 +144,12 @@ static int cmd_meta_lineinfo(RCore *core, const char *input) {
 
 	if (*p == '-') {
 		p++;
-		remove = R_TRUE;
+		remove = true;
 	}
 
 	if (*p == '*') {
 		p++;
-		all = R_TRUE;
+		all = true;
 	}
 
 	if (all) {
@@ -350,7 +350,7 @@ static int cmd_meta_comment(RCore *core, const char *input) {
 			s = strdup (s+1);
 		} else {
 			eprintf ("Usage\n");
-			return R_FALSE;
+			return false;
 		}
 		p = strchr (s, ' ');
 		if (p) *p++ = 0;
@@ -363,7 +363,7 @@ static int cmd_meta_comment(RCore *core, const char *input) {
 						addr, 1, NULL);
 			} else eprintf ("Usage: CCa-[address]\n");
 			free (s);
-			return R_TRUE;
+			return true;
 		}
 		addr = r_num_math (core->num, s);
 		// Comment at
@@ -390,11 +390,11 @@ static int cmd_meta_comment(RCore *core, const char *input) {
 			}
 		} else eprintf ("Usage: CCa [address] [comment]\n");
 		free (s);
-		return R_TRUE;
+		return true;
 		}
 	}
 
-	return R_TRUE;
+	return true;
 }
 
 static int cmd_meta_hsdmf (RCore *core, const char *input) {
@@ -491,7 +491,7 @@ static int cmd_meta_hsdmf (RCore *core, const char *input) {
 					}
 			} else if (n<1) {
 				eprintf ("Invalid length %d\n", n);
-				return R_FALSE;
+				return false;
 			}
 		}
 		if (!n) n++;
@@ -505,7 +505,7 @@ static int cmd_meta_hsdmf (RCore *core, const char *input) {
 		break;
 	}
 
-	return R_TRUE;
+	return true;
 }
 
 static int cmd_meta(void *data, const char *input) {
@@ -639,5 +639,5 @@ static int cmd_meta(void *data, const char *input) {
 		 }
 		break;
 	}
-	return R_TRUE;
+	return true;
 }
diff --git a/libr/core/cmd_open.c b/libr/core/cmd_open.c
index df6b9eb76..23c37a8f1 100644
--- a/libr/core/cmd_open.c
+++ b/libr/core/cmd_open.c
@@ -211,7 +211,7 @@ static void reopen_in_debug(RCore *core) {
 		core->file->desc->referer = NULL;
 		r_core_file_reopen (core, newfile, 0, 2);
 		r_config_set_i (core->config, "asm.bits", bits);
-		r_config_set_i (core->config, "cfg.debug", R_TRUE);
+		r_config_set_i (core->config, "cfg.debug", true);
 		r_core_cmd0 (core, "sr pc");
 	}
 }
@@ -417,7 +417,7 @@ static int cmd_open(void *data, const char *input) {
 			if (!r_core_file_open (core, input+2, R_IO_READ, 0))
 				eprintf ("Cannot open file\n");
 			if (!r_core_bin_load (core, NULL, baddr))
-				r_config_set_i (core->config, "io.va", R_FALSE);
+				r_config_set_i (core->config, "io.va", false);
 		} else {
 			eprintf ("Missing argument\n");
 		}
diff --git a/libr/core/cmd_print.c b/libr/core/cmd_print.c
index 31427b688..3f4f9457b 100644
--- a/libr/core/cmd_print.c
+++ b/libr/core/cmd_print.c
@@ -115,14 +115,14 @@ static int process_input(RCore *core, const char *input, ut64* blocksize, char *
 	// asm_arch: asm_arch to interpret as if present and valid, otherwise NULL;
 	// bits: bits to use if present, otherwise -1
 
-	int result = R_FALSE;
+	int result = false;
 	char *input_one = NULL, *input_two = NULL, *input_three = NULL;
 	char *str_clone = NULL,
 		 *ptr_str_clone = NULL,
 		 *trimmed_clone = NULL;
 
 	if (input == NULL || blocksize == NULL || asm_arch == NULL || bits == NULL) {
-		return R_FALSE;
+		return false;
 	}
 
 	str_clone = strdup (input);
@@ -167,7 +167,7 @@ static int process_input(RCore *core, const char *input, ut64* blocksize, char *
 		*blocksize = r_num_is_valid_input (core->num, input_one) ? r_num_get_input_value (core->num, input_one): 0;
 		*asm_arch = r_asm_is_valid (core->assembler, input_two) ? strdup (input_two) : NULL;
 		*bits = r_num_get_input_value (core->num, input_three);
-		result = R_TRUE;
+		result = true;
 
 	} else if (input_one && input_two) {
 
@@ -185,7 +185,7 @@ static int process_input(RCore *core, const char *input, ut64* blocksize, char *
 			*asm_arch = r_asm_is_valid (core->assembler, input_two) ? strdup (input_two) : NULL;
 		}
 
-		result = R_TRUE;
+		result = true;
 	} else if (input_one) {
 		*blocksize = r_num_is_valid_input (core->num, input_one) ? r_num_get_input_value (core->num, input_one): 0;
 		if (!r_num_is_valid_input (core->num, input_one) ) {
@@ -194,7 +194,7 @@ static int process_input(RCore *core, const char *input, ut64* blocksize, char *
 				r_str_truncate_cmd (input_one);
 			*asm_arch = r_asm_is_valid (core->assembler, input_one) ? strdup (input_one) : NULL;
 		}
-		result = R_TRUE;
+		result = true;
 	}
 	return result;
 }
@@ -206,13 +206,13 @@ static int process_input_pade(RCore *core, const char *input, char** hex, char *
 	// asm_arch: asm_arch to interpret as if present and valid, otherwise NULL;
 	// bits: bits to use if present, otherwise -1
 
-	int result = R_FALSE;
+	int result = false;
 	char *input_one = NULL, *input_two = NULL, *input_three = NULL;
 	char *str_clone = NULL,
 		 *trimmed_clone = NULL;
 
 	if (input == NULL || hex == NULL || asm_arch == NULL || bits == NULL) {
-		return R_FALSE;
+		return false;
 	}
 
 	str_clone = strdup (input);
@@ -259,7 +259,7 @@ static int process_input_pade(RCore *core, const char *input, char** hex, char *
 		*hex = input_one;
 		*asm_arch = r_asm_is_valid (core->assembler, input_two) ? strdup (input_two) : NULL;
 		*bits = r_num_get_input_value (core->num, input_three);
-		result = R_TRUE;
+		result = true;
 
 	} else if (input_one && input_two) {
 		*hex = input_one;
@@ -268,10 +268,10 @@ static int process_input_pade(RCore *core, const char *input, char** hex, char *
 		}
 		*bits = r_num_is_valid_input (core->num, input_two) ? r_num_get_input_value (core->num, input_two): -1;
 		*asm_arch = r_asm_is_valid (core->assembler, input_two) ? strdup (input_two) : NULL;
-		result = R_TRUE;
+		result = true;
 	} else if (input_one) {
 		*hex = input_one;
-		result = R_TRUE;
+		result = true;
 	} else {
 		free (input_one);
 	}
@@ -601,7 +601,7 @@ static void annotated_hexdump(RCore *core, const char *str, int len) {
 	ut64 fend = UT64_MAX;
 	char *comment;
 	int i, j, low, max, here, rows;
-	boolt marks = R_FALSE, setcolor = R_TRUE, hascolor = R_FALSE;
+	boolt marks = false, setcolor = true, hascolor = false;
 	ut8 ch;
 	const char **colors = (const char **)&core->cons->pal.list;
 #if 0
@@ -675,7 +675,7 @@ static void annotated_hexdump(RCore *core, const char *str, int len) {
 		chars[0] = '\0';
 		ebytes = bytes;
 		echars = chars;
-		hascolor = R_FALSE;
+		hascolor = false;
 
 		if (usecolor) append (ebytes, core->cons->pal.offset);
 		ebytes += sprintf (ebytes, "0x%08"PFMT64x, addr);
@@ -683,7 +683,7 @@ static void annotated_hexdump(RCore *core, const char *str, int len) {
 		append (ebytes, (col==1)?" |":"  ");
 
 		for (j=0; j<nb_cols; j++) {
-			setcolor = R_TRUE;
+			setcolor = true;
 			free (note[j]);
 			note[j] = NULL;
 
@@ -692,7 +692,7 @@ static void annotated_hexdump(RCore *core, const char *str, int len) {
 			if (comment) {
 				comment = r_str_prefix (comment, ";");
 				note[j] = comment;
-				marks = R_TRUE;
+				marks = true;
 			}
 
 			// collect flags
@@ -704,22 +704,22 @@ static void annotated_hexdump(RCore *core, const char *str, int len) {
 					fend = addr + j + flag->size;
 				}
 				note[j] = r_str_prefix (strdup (flag->name), "/");
-				marks = R_TRUE;
+				marks = true;
 				color_idx++;
 				color_idx %= R_CONS_PALETTE_LIST_SIZE;
 				current_flag = flag;
 			} else {
 				// Are we past the current flag?
 				if (current_flag && addr+j > (current_flag->offset + current_flag->size)){
-					setcolor = R_FALSE;
+					setcolor = false;
 					current_flag = NULL;
 				}
 				// Turn colour off if we're at the end of the current flag
 				if (fend == UT64_MAX || fend <= addr + j)
-					setcolor = R_FALSE;
+					setcolor = false;
 			}
 			if (setcolor && !hascolor) {
-				hascolor = R_TRUE;
+				hascolor = true;
 				if (usecolor) {
 					if (current_flag && current_flag->color) {
 						char *ansicolor = r_cons_pal_parse (current_flag->color);
@@ -778,7 +778,7 @@ static void annotated_hexdump(RCore *core, const char *str, int len) {
 					append (ebytes, Color_RESET);
 					append (echars, Color_RESET);
 				}
-				hascolor = R_FALSE;
+				hascolor = false;
 			}
 
 			if (j < (nb_cols-1) && (j%2))
@@ -790,7 +790,7 @@ static void annotated_hexdump(RCore *core, const char *str, int len) {
 					append (echars, Color_RESET);
 				}
 				fend = UT64_MAX;
-				hascolor = R_FALSE;
+				hascolor = false;
 			}
 
 		}
@@ -827,7 +827,7 @@ static void annotated_hexdump(RCore *core, const char *str, int len) {
 				r_cons_strcat (out);
 				r_cons_newline ();
 			}
-			marks = R_FALSE;
+			marks = false;
 			free (out);
 		}
 		r_cons_strcat (bytes);
@@ -1125,12 +1125,12 @@ static void cmd_print_pwn(const RCore* core) {
 
 static int cmd_print_pxA(RCore *core, int len, const char *data) {
 	RConsPalette *pal = &core->cons->pal;
-	int show_offset = R_TRUE;
+	int show_offset = true;
 	int cols = r_config_get_i (core->config, "hex.cols");
 	int show_color = r_config_get_i (core->config, "scr.color");
 	int onechar = r_config_get_i (core->config, "hex.onechar");
 	int show_cursor = core->print->cur_enabled;
-	int bgcolor_in_heap = R_FALSE;
+	int bgcolor_in_heap = false;
 	char buf[2];
 	char *bgcolor, *fgcolor, *text;
 	ut64 i, c, oi;
@@ -1154,17 +1154,17 @@ static int cmd_print_pxA(RCore *core, int len, const char *data) {
 	}
 	for (oi = i = c = 0; i< len; c++) {
 		if (i && (cols != 0) && !(c % cols)) {
-			show_offset = R_TRUE;
+			show_offset = true;
 			r_cons_printf ("  %d\n", i-oi);
 			oi = i;
 		}
 		if (show_offset) {
 			r_cons_printf ("0x%08"PFMT64x"  ", core->offset+i);
-			show_offset = R_FALSE;
+			show_offset = false;
 		}
 		if (bgcolor_in_heap) {
 			free (bgcolor);
-			bgcolor_in_heap = R_FALSE;
+			bgcolor_in_heap = false;
 		}
 		bgcolor = Color_BGBLACK;
 		fgcolor = Color_WHITE;
@@ -1206,80 +1206,80 @@ static int cmd_print_pxA(RCore *core, int len, const char *data) {
 		case R_ANAL_OP_TYPE_POP:
 			text = "<-";
 			bgcolor = r_cons_swap_ground (pal->pop);
-			bgcolor_in_heap = R_TRUE;
+			bgcolor_in_heap = true;
 			fgcolor = Color_WHITE;
 			break;
 		case R_ANAL_OP_TYPE_NOP:
 			fgcolor = Color_WHITE;
 			bgcolor = r_cons_swap_ground (pal->nop);
-			bgcolor_in_heap = R_TRUE;
+			bgcolor_in_heap = true;
 			text = "..";
 			break;
 		case R_ANAL_OP_TYPE_MUL:
 			fgcolor = Color_BLACK;
 			bgcolor = r_cons_swap_ground (pal->math);
-			bgcolor_in_heap = R_TRUE;
+			bgcolor_in_heap = true;
 			text = "_*";
 			break;
 		case R_ANAL_OP_TYPE_DIV:
 			bgcolor = r_cons_swap_ground (pal->math);
-			bgcolor_in_heap = R_TRUE;
+			bgcolor_in_heap = true;
 			fgcolor = Color_BLACK;
 			text = "_/";
 			break;
 		case R_ANAL_OP_TYPE_AND:
 			bgcolor = r_cons_swap_ground (pal->bin);
-			bgcolor_in_heap = R_TRUE;
+			bgcolor_in_heap = true;
 			fgcolor = Color_BLACK;
 			text = "_&";
 			break;
 		case R_ANAL_OP_TYPE_XOR:
 			bgcolor = r_cons_swap_ground (pal->bin);
-			bgcolor_in_heap = R_TRUE;
+			bgcolor_in_heap = true;
 			fgcolor = Color_BLACK;
 			text = "_^";
 			break;
 		case R_ANAL_OP_TYPE_OR:
 			bgcolor = r_cons_swap_ground (pal->bin);
-			bgcolor_in_heap = R_TRUE;
+			bgcolor_in_heap = true;
 			fgcolor = Color_BLACK;
 			text = "_|";
 			break;
 		case R_ANAL_OP_TYPE_SHR:
 			bgcolor = r_cons_swap_ground (pal->bin);
-			bgcolor_in_heap = R_TRUE;
+			bgcolor_in_heap = true;
 			fgcolor = Color_BLACK;
 			text = ">>";
 			break;
 		case R_ANAL_OP_TYPE_SHL:
 			bgcolor = r_cons_swap_ground (pal->bin);
-			bgcolor_in_heap = R_TRUE;
+			bgcolor_in_heap = true;
 			fgcolor = Color_BLACK;
 			text = "<<";
 			break;
 		case R_ANAL_OP_TYPE_SUB:
 			bgcolor = r_cons_swap_ground (pal->math);
-			bgcolor_in_heap = R_TRUE;
+			bgcolor_in_heap = true;
 			fgcolor = Color_WHITE;
 			text = "--";
 			break;
 		case R_ANAL_OP_TYPE_ADD:
 			bgcolor = r_cons_swap_ground (pal->math);
-			bgcolor_in_heap = R_TRUE;
+			bgcolor_in_heap = true;
 			fgcolor = Color_WHITE;
 			text = "++";
 			break;
 		case R_ANAL_OP_TYPE_JMP:
 		case R_ANAL_OP_TYPE_UJMP:
 			bgcolor = r_cons_swap_ground (pal->jmp);
-			bgcolor_in_heap = R_TRUE;
+			bgcolor_in_heap = true;
 			fgcolor = Color_BLACK;
 			text = "_J";
 			break;
 		case R_ANAL_OP_TYPE_CJMP:
 		case R_ANAL_OP_TYPE_UCJMP:
 			bgcolor = r_cons_swap_ground (pal->cjmp);
-			bgcolor_in_heap = R_TRUE;
+			bgcolor_in_heap = true;
 			fgcolor = Color_BLACK;
 			text = "cJ";
 			break;
@@ -1287,20 +1287,20 @@ static int cmd_print_pxA(RCore *core, int len, const char *data) {
 		case R_ANAL_OP_TYPE_UCALL:
 		case R_ANAL_OP_TYPE_UCCALL:
 			bgcolor = r_cons_swap_ground (pal->call);
-			bgcolor_in_heap = R_TRUE;
+			bgcolor_in_heap = true;
 			fgcolor = Color_WHITE;
 			text = "_C";
 			break;
 		case R_ANAL_OP_TYPE_ACMP:
 		case R_ANAL_OP_TYPE_CMP:
 			bgcolor = r_cons_swap_ground (pal->cmp);
-			bgcolor_in_heap = R_TRUE;
+			bgcolor_in_heap = true;
 			fgcolor = Color_BLACK;
 			text = "==";
 			break;
 		case R_ANAL_OP_TYPE_RET:
 			bgcolor = r_cons_swap_ground (pal->ret);
-			bgcolor_in_heap = R_TRUE;
+			bgcolor_in_heap = true;
 			fgcolor = Color_WHITE;
 			text = "_R";
 			break;
@@ -1308,7 +1308,7 @@ static int cmd_print_pxA(RCore *core, int len, const char *data) {
 		case R_ANAL_OP_TYPE_ILL:
 		case R_ANAL_OP_TYPE_UNK:
 			bgcolor = r_cons_swap_ground (pal->invalid);
-			bgcolor_in_heap = R_TRUE;
+			bgcolor_in_heap = true;
 			fgcolor = Color_WHITE;
 			text = "XX";
 			break;
@@ -1347,7 +1347,7 @@ static int cmd_print_pxA(RCore *core, int len, const char *data) {
 	}
 	if (bgcolor_in_heap) free (bgcolor);
 
-	return R_TRUE;
+	return true;
 }
 
 static void printraw (RCore *core, int len, int mode) {
@@ -1723,7 +1723,7 @@ static int cmd_print(void *data, const char *input) {
 	{
 		ut32 new_bits = -1;
 		int segoff, old_bits, pos = 0;
-		ut8 settings_changed = R_FALSE;
+		ut8 settings_changed = false;
 		char *new_arch = NULL, *old_arch = NULL, *hex = NULL;
 		old_arch = strdup (r_config_get (core->config, "asm.arch"));
 		old_bits = r_config_get_i (core->config, "asm.bits");
@@ -1735,7 +1735,7 @@ static int cmd_print(void *data, const char *input) {
 
 			if (!process_input_pade (core, input+pos, &hex, &new_arch, &new_bits)) {
 				// XXX - print help message
-				//return R_FALSE;
+				//return false;
 			}
 		
 			if (new_arch == NULL) new_arch = strdup (old_arch);
@@ -1743,7 +1743,7 @@ static int cmd_print(void *data, const char *input) {
 			
 			if (strcmp (new_arch, old_arch) != 0 || new_bits != old_bits){
 				set_asm_configs (core, new_arch, new_bits, segoff);
-				settings_changed = R_TRUE;
+				settings_changed = true;
 			}
 		}
 		if (input[1]=='e') { // "pae"
@@ -1965,9 +1965,9 @@ static int cmd_print(void *data, const char *input) {
 		ut32 new_bits = -1;
 		ut64 use_blocksize = core->blocksize;
 		int segoff, old_bits, pos = 0;
-		ut8 settings_changed = R_FALSE, bw_disassemble = R_FALSE;
+		ut8 settings_changed = false, bw_disassemble = false;
 		char *new_arch = NULL, *old_arch = NULL;
-		ut32 pd_result = R_FALSE, processed_cmd = R_FALSE;
+		ut32 pd_result = false, processed_cmd = false;
 		old_arch = strdup (r_config_get (core->config, "asm.arch"));
 		segoff = r_config_get_i (core->config, "asm.segoff");
 		old_bits = r_config_get_i (core->config, "asm.bits");
@@ -1982,7 +1982,7 @@ static int cmd_print(void *data, const char *input) {
 
 		if (!process_input (core, input+pos, &use_blocksize, &new_arch, &new_bits)) {
 			// XXX - print help message
-			//return R_FALSE;
+			//return false;
 		}
 		if (!use_blocksize)
 			use_blocksize = core->blocksize;
@@ -1994,7 +1994,7 @@ static int cmd_print(void *data, const char *input) {
 			free (new_arch);
 			goto beach;
 		} else if (core->blocksize_max < use_blocksize && (int)use_blocksize > -core->blocksize_max) {
-			bw_disassemble = R_TRUE;
+			bw_disassemble = true;
 			use_blocksize = -use_blocksize;
 		}
 		l = use_blocksize;
@@ -2004,17 +2004,17 @@ static int cmd_print(void *data, const char *input) {
 
 		if (strcmp (new_arch, old_arch) != 0 || new_bits != old_bits){
 			set_asm_configs (core, new_arch, new_bits, segoff);
-			settings_changed = R_TRUE;
+			settings_changed = true;
 		}
 
 		switch (input[1]) {
 		case 'c': // "pdc"
 			r_core_pseudo_code (core, input+2);
 			pd_result = 0;
-			processed_cmd = R_TRUE;
+			processed_cmd = true;
 			break;
 		case 'i': // "pdi"
-			processed_cmd = R_TRUE;
+			processed_cmd = true;
 			if (*input == 'D')
 				pdi (core, 0, l, 0);
 			else
@@ -2022,7 +2022,7 @@ static int cmd_print(void *data, const char *input) {
 			pd_result = 0;
 			break;
 		case 'a': // "pda"
-			processed_cmd = R_TRUE;
+			processed_cmd = true;
 			{
 				RAsmOp asmop;
 				int ret, err = 0;
@@ -2049,11 +2049,11 @@ static int cmd_print(void *data, const char *input) {
 				r_cons_break_end ();
 				if (buf != core->block)
 					free (buf);
-				pd_result = R_TRUE;
+				pd_result = true;
 			}
 			break;
 		case 'r': // "pdr"
-			processed_cmd = R_TRUE;
+			processed_cmd = true;
 			{
 				RAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset,
 						R_ANAL_FCN_TYPE_FCN|R_ANAL_FCN_TYPE_SYM);
@@ -2088,11 +2088,11 @@ static int cmd_print(void *data, const char *input) {
 					eprintf ("Cannot find function at 0x%08"PFMT64x"\n", core->offset);
 					core->num->value = -1;
 				}
-				pd_result = R_TRUE;
+				pd_result = true;
 			}
 			break;
 		case 'b': // "pdb"
-			processed_cmd = R_TRUE;
+			processed_cmd = true;
 			{
 				RAnalBlock *b = r_anal_bb_from_offset (core->anal, core->offset);
 				if (b) {
@@ -2112,7 +2112,7 @@ static int cmd_print(void *data, const char *input) {
 			}
 			break;
 		case 'f': // "pdf"
-			processed_cmd = R_TRUE;
+			processed_cmd = true;
 			{
 			       ut32 bsz = core->blocksize;
 			       RAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset,
@@ -2139,7 +2139,7 @@ static int cmd_print(void *data, const char *input) {
 				       pd_result = 0;
 			       } else {
 				       eprintf ("Cannot find function at 0x%08"PFMT64x"\n", core->offset);
-				       processed_cmd = R_TRUE;
+				       processed_cmd = true;
 				       core->num->value = -1;
 			       }
 			       if (bsz != core->blocksize)
@@ -2148,7 +2148,7 @@ static int cmd_print(void *data, const char *input) {
 			l = 0;
 			break;
 		case 'l': //pdl
-			processed_cmd = R_TRUE;
+			processed_cmd = true;
 			{
 				RAsmOp asmop;
 				int j, ret;
@@ -2166,7 +2166,7 @@ static int cmd_print(void *data, const char *input) {
 			}
 			break;
 		case 'j': //pdj
-			processed_cmd = R_TRUE;
+			processed_cmd = true;
 			if (*input == 'D'){
 				cmd_pDj (core, input+2);
 			} else cmd_pdj (core, input+2);
@@ -2180,7 +2180,7 @@ static int cmd_print(void *data, const char *input) {
 			}
 			break;
 		case '?': // "pd?"
-			processed_cmd = R_TRUE;
+			processed_cmd = true;
 			const char* help_msg[] = {
 				"Usage:", "p[dD][ajbrfils] [sz] [arch] [bits]", " # Print Disassembly",
 				"NOTE: ", "len", "parameter can be negative",
@@ -2220,13 +2220,13 @@ static int cmd_print(void *data, const char *input) {
 						int instr_len;
 						r_core_asm_bwdis_len (core, &instr_len, &addr, l);
 						ut32 prevaddr = core->offset;
-						r_core_seek(core, prevaddr - instr_len, R_TRUE);
+						r_core_seek(core, prevaddr - instr_len, true);
 						block = realloc (block, R_MAX(instr_len, bs));
 						memcpy (block, core->block, bs);
 						r_core_read_at (core, addr+bs, block+bs, instr_len-bs); //core->blocksize);
 						core->num->value = r_core_print_disasm (core->print,
 								core, addr, block, instr_len, l, 0, 1);
-						r_core_seek(core, prevaddr, R_TRUE);
+						r_core_seek(core, prevaddr, true);
 					}
 				}
 			} else {
@@ -2455,7 +2455,7 @@ static int cmd_print(void *data, const char *input) {
 				"| e dir.magic  # defaults to "R_MAGIC_PATH"\n"
 				"| /m           # search for magic signatures\n"
 				);
-		} else r_core_magic (core, input+1, R_TRUE);
+		} else r_core_magic (core, input+1, true);
 		break;
 	case 'u': //pu
 		if (input[1]=='?') {
@@ -3151,7 +3151,7 @@ R_API void r_print_offset(RPrint *p, ut64 off, int invert, int offseg, int delta
 	if (show_color) {
 		const char *k = r_cons_singleton ()->pal.offset; // TODO etooslow. must cache
 		if (invert)
-			r_cons_invert (R_TRUE, R_TRUE);
+			r_cons_invert (true, true);
 		if (offseg) {
 			ut32 s, a;
 			a = off & 0xffff;
diff --git a/libr/core/cmd_project.c b/libr/core/cmd_project.c
index 7ebdd9ad6..bcd258318 100644
--- a/libr/core/cmd_project.c
+++ b/libr/core/cmd_project.c
@@ -7,7 +7,7 @@ static int cmd_project(void *data, const char *input) {
 	char *str = NULL;
 
 	if (!input)
-		return R_FALSE;
+		return false;
 
 	str = strdup (fileproject);
 	if (arg && *arg==' ') arg++;
@@ -180,5 +180,5 @@ static int cmd_project(void *data, const char *input) {
 		break;
 	}
 	free (str);
-	return R_TRUE;
+	return true;
 }
diff --git a/libr/core/cmd_search.c b/libr/core/cmd_search.c
index 863732137..41330f607 100644
--- a/libr/core/cmd_search.c
+++ b/libr/core/cmd_search.c
@@ -7,7 +7,7 @@ static int searchhits = 0;
 static int maplist = 0;
 static int maxhits = 0;
 static int json = 0;
-static int first_hit = R_TRUE;
+static int first_hit = true;
 static const char *cmdhit = NULL;
 static const char *searchprefix = NULL;
 static unsigned int searchcount = 0;
@@ -153,7 +153,7 @@ static int cmd_search_value_in_range(RCore *core, ut64 from, ut64 to, ut64 vmin,
 			void *v = (buf+i);
 			if (align && (from+i)%4)
 				continue;
-			match = R_FALSE;
+			match = false;
 			switch (vsize) {
 			case 1: match = (buf[i]>=vmin && buf[i]<=vmax); break;
 			case 2: v16 = *((ut16*)(v)); match = (v16>=vmin && v16<=vmax); break;
@@ -176,7 +176,7 @@ static int __prelude_cb_hit(RSearchKeyword *kw, void *user, ut64 addr) {
 	searchhits ++; //= kw->count+1;
 	r_core_anal_fcn (core, addr, -1, R_ANAL_REF_TYPE_NULL, depth);
 	preludecnt++;
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_search_prelude(RCore *core, ut64 from, ut64 to, const ut8 *buf,
@@ -255,18 +255,18 @@ static int __cb_hit(RSearchKeyword *kw, void *user, ut64 addr) {
 
 	if (!core) {
 		eprintf ("Error: Callback has an invalid RCore.\n");
-		return R_FALSE;
+		return false;
 	}
 	if (maxhits && searchhits>=maxhits) {
 		//eprintf ("Error: search.maxhits reached.\n");
-		return R_FALSE;
+		return false;
 	}
 
 	searchhits ++; ///= kw->count+1;
 	if (searchcount) {
 		if (!--searchcount) {
 			//eprintf ("\nsearch stop: search.count reached\n");
-			return R_FALSE;
+			return false;
 		}
 	}
 	if (searchshow && kw && kw->keyword_length > 0) {
@@ -330,18 +330,18 @@ static int __cb_hit(RSearchKeyword *kw, void *user, ut64 addr) {
 		}
 	}
 	if (first_hit)
-		first_hit = R_FALSE;
+		first_hit = false;
 	if (searchflags) {
 		const char *flag = sdb_fmt (0, "%s%d_%d", searchprefix, kw->kwidx, kw->count);
 		r_flag_set (core->flags, flag, addr, kw->keyword_length, 1);
 	}
 	if (!strnull (cmdhit)) {
 		ut64 here = core->offset;
-		r_core_seek (core, addr, R_TRUE);
+		r_core_seek (core, addr, true);
 		r_core_cmd (core, cmdhit, 0);
-		r_core_seek (core, here, R_TRUE);
+		r_core_seek (core, here, true);
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int c = 0;
@@ -474,7 +474,7 @@ R_API RList *r_core_get_boundaries_prot(RCore *core, int protection, const char
 				if (!mask || (s->rwx & mask)) {
 					if (!list) {
 						list = r_list_newf (free);
-						maplist = R_TRUE;
+						maplist = true;
 					}
 					map = R_NEW0 (RIOMap);
 					if (!map) {
@@ -501,9 +501,9 @@ R_API RList *r_core_get_boundaries_prot(RCore *core, int protection, const char
 		if (core->io->debug) {
 			int mask = 0;
 			int add = 0;
-			int heap = R_FALSE;
-			int stack = R_FALSE;
-			int all = R_FALSE;
+			int heap = false;
+			int stack = false;
+			int all = false;
 			RListIter *iter;
 			RDebugMap *map;
 
@@ -518,11 +518,11 @@ R_API RList *r_core_get_boundaries_prot(RCore *core, int protection, const char
 					}
 				}
 			} else {
-				if (!strcmp (mode, "dbg.maps")) all = R_TRUE;
+				if (!strcmp (mode, "dbg.maps")) all = true;
 				if (!strcmp (mode, "dbg.maps.exec")) mask = R_IO_EXEC;
 				if (!strcmp (mode, "dbg.maps.write")) mask = R_IO_WRITE;
-				if (!strcmp (mode, "dbg.heap")) heap = R_TRUE;
-				if (!strcmp (mode, "dbg.stack")) stack = R_TRUE;
+				if (!strcmp (mode, "dbg.heap")) heap = true;
+				if (!strcmp (mode, "dbg.stack")) stack = true;
 
 				r_list_foreach (core->dbg->maps, iter, map) {
 					add = (stack && strstr(map->name, "stack"))? 1: 0;
@@ -532,7 +532,7 @@ R_API RList *r_core_get_boundaries_prot(RCore *core, int protection, const char
 					if ((mask && (map->perm & mask)) || add || all) {
 						if (!list) {
 							list = r_list_newf (free);
-							maplist = R_TRUE;
+							maplist = true;
 						}
 						RIOMap *nmap = R_NEW0 (RIOMap);
 						if (!nmap) break;
@@ -613,7 +613,7 @@ static boolt is_end_gadget(const RAnalOp* aop, const ut8 crop) {
 	case R_ANAL_OP_TYPE_UJMP:
 	case R_ANAL_OP_TYPE_JMP:
 	case R_ANAL_OP_TYPE_CALL:
-		return R_TRUE;
+		return true;
 	}
 	if (crop) { //if conditional jumps, calls and returns should be used for the gadget-search too
 		switch (aop->type) {
@@ -622,10 +622,10 @@ static boolt is_end_gadget(const RAnalOp* aop, const ut8 crop) {
 		case R_ANAL_OP_TYPE_CCALL:
 		case R_ANAL_OP_TYPE_UCCALL:
 		case R_ANAL_OP_TYPE_CRET:   //i'm a condret
-			return R_TRUE;
+			return true;
 		}
 	}
-	return R_FALSE;
+	return false;
 }
 
 //TODO: follow unconditional jumps
@@ -669,7 +669,7 @@ static RList* construct_rop_gadget(RCore *core, ut64 addr, ut8 *buf, int idx,
 	}
 
 	if (r_list_contains (badstart, (void*)(intptr_t)idx)) {
-		valid = R_FALSE;
+		valid = false;
 		goto ret;
 	}
 	while (nb_instr < max_instr) {
@@ -679,7 +679,7 @@ static RList* construct_rop_gadget(RCore *core, ut64 addr, ut8 *buf, int idx,
 			goto ret;
 		if (!strncasecmp (asmop.buf_asm, "invalid", strlen ("invalid")) ||
 				!strncasecmp (asmop.buf_asm, ".byte", strlen (".byte"))) {
-			valid = R_FALSE;
+			valid = false;
 			goto ret;
 		}
 
@@ -896,7 +896,7 @@ static int r_core_search_rop(RCore *core, ut64 from, ut64 to, int opt, const cha
 			eprintf ("For rop.len = 1, use /c to search for single "
 							"instructions. See /c? for help.\n");
 		}
-		return R_FALSE;
+		return false;
 	}
 
 	if (!strcmp (arch, "mips")) // MIPS has no jump-in-the-middle
@@ -948,14 +948,14 @@ static int r_core_search_rop(RCore *core, ut64 from, ut64 to, int opt, const cha
 			r_list_free (end_list);
 			r_list_free (badstart);
 			r_list_free (list);
-			return R_FALSE;
+			return false;
 		}
 		map->fd = core->io->desc->fd;
 		map->from = from;
 		map->to = to;
 		list = r_list_newf (free);
 		r_list_append (list, map);
-		maplist = R_TRUE;
+		maplist = true;
 	}
 
 	if (json)
@@ -979,7 +979,7 @@ static int r_core_search_rop(RCore *core, ut64 from, ut64 to, int opt, const cha
 				r_list_free (end_list);
 				r_list_free (badstart);
 				r_list_free (list);
-				return R_FALSE;
+				return false;
 			}
 		}
 
@@ -1110,7 +1110,7 @@ static int r_core_search_rop(RCore *core, ut64 from, ut64 to, int opt, const cha
 	r_list_free (badstart);
 	free (gregexp);
 
-	return R_TRUE;
+	return true;
 }
 
 static int esil_addrinfo(RAnalEsil *esil) {
@@ -1176,7 +1176,7 @@ static void do_esil_search(RCore *core, struct search_parameters *param, const c
 				eprintf ("Cannot parse esil (%s)\n", input+2);
 				break;
 			}
-			hit_happens = R_FALSE;
+			hit_happens = false;
 			res = r_anal_esil_pop (core->anal->esil);
 			if (r_anal_esil_get_parm (core->anal->esil, res, &nres)) {
 				if (nres) {
@@ -1188,7 +1188,7 @@ static void do_esil_search(RCore *core, struct search_parameters *param, const c
 					kw.count++;
 					eprintf ("Hits: %d\r", kw.count);
 					kw.keyword_length = 0;
-					hit_happens = R_TRUE;
+					hit_happens = true;
 				}
 			} else {
 				eprintf ("Cannot parse esil (%s)\n", input+2);
@@ -1335,7 +1335,7 @@ static void do_asm_search(RCore *core, struct search_parameters *param, const ch
 		map->to = param->to;
 		param->boundaries = r_list_newf (free);
 		r_list_append (param->boundaries, map);
-		maplist = R_TRUE;
+		maplist = true;
 	}
 
 	if (json) r_cons_printf ("[");
@@ -1432,7 +1432,7 @@ static void do_string_search(RCore *core, struct search_parameters *param) {
 			map->to = param->to;
 			param->boundaries = r_list_newf (free);
 			r_list_append (param->boundaries, map);
-			maplist = R_TRUE;
+			maplist = true;
 		}
 		buf = (ut8 *)malloc (core->blocksize);
 		bufsz = core->blocksize;
@@ -1459,7 +1459,7 @@ static void do_string_search(RCore *core, struct search_parameters *param) {
 			if (param->bckwrds) {
 				if (param->to < param->from + bufsz) {
 					at = param->from;
-					param->do_bckwrd_srch = R_FALSE;
+					param->do_bckwrd_srch = false;
 				} else at = param->to - bufsz;
 			} else at = param->from;
 			/* bckwrds = false -> normal search -> must be at < to
@@ -1511,7 +1511,7 @@ static void do_string_search(RCore *core, struct search_parameters *param) {
 					if (at > param->from + bufsz) {
 						at -= bufsz;
 					} else {
-						param->do_bckwrd_srch = R_FALSE;
+						param->do_bckwrd_srch = false;
 						at = param->from;
 					}
 				} else {
@@ -1556,10 +1556,10 @@ static void do_string_search(RCore *core, struct search_parameters *param) {
 
 static int cmd_search(void *data, const char *input) {
 	struct search_parameters param;
-	int ret = R_TRUE;
-	int i, len, dosearch = R_FALSE;
+	_Bool dosearch = false;
+	int i, len, ret = true;
 	RCore *core = (RCore *)data;
-	int ignorecase = R_FALSE;
+	int ignorecase = false;
 	int param_offset = 2;
 	char *inp;
 	ut64 n64, __from, __to;
@@ -1568,31 +1568,31 @@ static int cmd_search(void *data, const char *input) {
 	ut8 n8;
 	if (!core || !core->io || !core->io->desc) {
 		eprintf ("Can't search if we don't have an open file.\n");
-		return R_FALSE;
+		return false;
 	}
 	if (core->in_search) {
 		eprintf ("Can't search from within a search.\n");
-		return R_FALSE;
+		return false;
 	}
-	core->in_search = R_TRUE;
+	core->in_search = true;
 
 	r_flag_space_push(core->flags, "searches");
 
 	param.from = param.to = 0;
-	param.inverse = R_FALSE;
-	param.crypto_search = R_FALSE;
-	param.bckwrds = R_FALSE;
-	param.do_bckwrd_srch = R_FALSE;
-	param.aes_search = R_FALSE;
-	param.rsa_search = R_FALSE;
-	param.use_mread = R_FALSE;
-	param.do_bckwrd_srch = R_FALSE;
+	param.inverse = false;
+	param.crypto_search = false;
+	param.bckwrds = false;
+	param.do_bckwrd_srch = false;
+	param.aes_search = false;
+	param.rsa_search = false;
+	param.use_mread = false;
+	param.do_bckwrd_srch = false;
 
 	c = 0;
-	json = R_FALSE;
-	first_hit = R_TRUE;
+	json = false;
+	first_hit = true;
 	//core->search->n_kws = 0;
-	maplist = R_FALSE;
+	maplist = false;
 	__from = r_config_get_i (core->config, "search.from");
 	__to = r_config_get_i (core->config, "search.to");
 
@@ -1609,7 +1609,7 @@ static int cmd_search(void *data, const char *input) {
 	  for all search types
 	if (__to < __from) {
 		eprintf ("Invalid search range. Check 'e search.{from|to}'\n");
-		return R_FALSE;
+		return false;
 	}
 	since the backward search will be implemented soon I'm not gonna stick
 	checks for every case in switch // jjdredd
@@ -1644,14 +1644,14 @@ static int cmd_search(void *data, const char *input) {
 		param.from = 0;
 		param.to = r_io_size (core->io);
 	}
-	core->search->bckwrds = R_FALSE;
+	core->search->bckwrds = false;
 
 	if (param.from == param.to) {
 		eprintf ("WARNING from == to?\n");
 	}
 	/* Quick & dirty check for json output */
 	if (input[0] && (input[1] == 'j') && (input[0] != ' ')) {
-		json = R_TRUE;
+		json = true;
 		param_offset++;
 	}
 
@@ -1659,7 +1659,7 @@ reread:
 	switch (*input) {
 	case '!':
 		input++;
-		param.inverse = R_TRUE;
+		param.inverse = true;
 		goto reread;
 	case 'B':
 		cmd_search_bin (core, param.from, param.to);
@@ -1669,7 +1669,7 @@ reread:
 			eprintf ("Usage: /b<command> [value] backward search, see '/?'\n");
 			goto beach;
 		}
-		core->search->bckwrds = param.bckwrds = param.do_bckwrd_srch = R_TRUE;
+		core->search->bckwrds = param.bckwrds = param.do_bckwrd_srch = true;
 		/* if backward search and __to wasn't specified
 		   search from the beginning */
 		if ((unsigned int)param.to ==  UT32_MAX){
@@ -1734,23 +1734,23 @@ reread:
 				r_search_keyword_new_hexmask (kwd, NULL));
 			r_search_begin (core->search);
 			free (kwd);
-			dosearch = R_TRUE;
+			dosearch = true;
 		} else {
-			ret = R_FALSE;
+			ret = false;
 			goto beach;
 		}
 		} break;
 	case 'C': {
-		dosearch = param.crypto_search = R_TRUE;
+		dosearch = param.crypto_search = true;
 		switch (input[1]) {
 			case 'a':
-				param.aes_search = R_TRUE;
+				param.aes_search = true;
 				break;
 			case 'r':
-				param.rsa_search = R_TRUE;
+				param.rsa_search = true;
 				break;
 			default:{
-				dosearch = param.crypto_search = R_FALSE;
+				dosearch = param.crypto_search = false;
 				const char* help_msg[] = {
 					"Usage: /C", "", "Search for crypto materials",
 					"/Ca", "" , "Search for AES keys",
@@ -1762,10 +1762,10 @@ reread:
 		} break;
 	case '/':
 		r_search_begin (core->search);
-		dosearch = R_TRUE;
+		dosearch = true;
 		break;
 	case 'm': // "/m"
-		dosearch = R_FALSE;
+		dosearch = false;
 		if (input[1]==' ' || input[1]=='\0') {
 			int ret;
 			const char *file = input[1]? input+2: NULL;
@@ -1774,7 +1774,7 @@ reread:
 			for (; addr<param.to; addr++) {
 				if (r_cons_singleton ()->breaked)
 					break;
-				ret = r_core_magic_at (core, file, addr, 99, R_FALSE);
+				ret = r_core_magic_at (core, file, addr, 99, false);
 				if (ret == -1) {
 					// something went terribly wrong.
 					break;
@@ -1824,7 +1824,7 @@ reread:
 	case 'v':
 		if (input[1]){
 			if (input[2] == 'j') {
-				json = R_TRUE;
+				json = true;
 				param_offset++;
 			}
 		}
@@ -1876,13 +1876,13 @@ reread:
 		}
 // TODO: Add support for /v4 /v8 /v2
 		r_search_begin (core->search);
-		dosearch = R_TRUE;
+		dosearch = true;
 		break;
 	case 'w': /* search wide string, includes ignorecase search functionality (/wi cmd)! */
 		if (input[1]) {
 			if (input[2]) {
-				if (input[1] == 'j' || input[2] == 'j') json = R_TRUE;
-				if (input[1] == 'i' || input[2] == 'i') ignorecase = R_TRUE;
+				if (input[1] == 'j' || input[2] == 'j') json = true;
+				if (input[1] == 'i' || input[2] == 'i') ignorecase = true;
 			}
 
 		if (input[1+json+ignorecase] == ' ') {
@@ -1909,7 +1909,7 @@ reread:
 				skw->icase = ignorecase;
 				r_search_kw_add (core->search, skw);
 				r_search_begin (core->search);
-				dosearch = R_TRUE;
+				dosearch = true;
 			} else {
 				eprintf ("Invalid keyword\n");
 				break;
@@ -1920,12 +1920,12 @@ reread:
 	case 'i':
 		if (input[param_offset-1]!= ' ') {
 			eprintf ("Missing ' ' after /i\n");
-			ret = R_FALSE;
+			ret = false;
 			goto beach;
 		}
-		ignorecase = R_TRUE;
+		ignorecase = true;
 	case 'j':
-		if (input[0] =='j') json = R_TRUE;
+		if (input[0] =='j') json = true;
 		/* pass-thru */
 	case ' ': /* search string */
 		inp = strdup (input+1+ignorecase+json);
@@ -1953,7 +1953,7 @@ reread:
 		}
 		}
 		r_search_begin (core->search);
-		dosearch = R_TRUE;
+		dosearch = true;
 		break;
 	case 'e': /* match regexp */
 		if (input[1]) {
@@ -1968,7 +1968,7 @@ reread:
 				r_config_get_i (core->config, "search.distance"));
 			r_search_kw_add (core->search, kw);
 			r_search_begin (core->search);
-			dosearch = R_TRUE;
+			dosearch = true;
 		} else eprintf ("Missing regex\n");
 		break;
 	case 'E':
@@ -1980,7 +1980,7 @@ reread:
 			r_search_kw_add (core->search,
 				r_search_keyword_new_hexmask (input+param_offset, NULL));
 			r_search_begin (core->search);
-			dosearch = R_TRUE;
+			dosearch = true;
 		} else eprintf ("Missing delta\n");
 		break;
 	case '#':
@@ -2038,7 +2038,7 @@ reread:
 				eprintf ("Searching %d bytes...\n",
 					kw->keyword_length);
 				r_search_begin (core->search);
-				dosearch = R_TRUE;
+				dosearch = true;
 			} else {
 				eprintf ("no keyword\n");
 			}
@@ -2075,7 +2075,7 @@ reread:
 			len = r_str_unescape (str);
 			ochunksize = chunksize = R_MIN (len, chunksize);
 			eprintf ("Using chunksize: %d\n", chunksize);
-			core->in_search = R_FALSE;
+			core->in_search = false;
 			for (i=0; i<len; i += chunksize) {
 				chunksize = ochunksize;
 				again:
@@ -2126,7 +2126,7 @@ reread:
 		r_search_kw_add (core->search,
 			r_search_keyword_new_hexmask ("00", NULL)); //XXX
 		r_search_begin (core->search);
-		dosearch = R_TRUE;
+		dosearch = true;
 		}
 		break;
 	default:{
@@ -2180,7 +2180,7 @@ reread:
 		do_string_search (core, &param);
 beach: 
 	core->num->value = searchhits;
-	core->in_search = R_FALSE;
+	core->in_search = false;
 	r_flag_space_pop (core->flags);
 	if (json) {
 		r_cons_newline ();
diff --git a/libr/core/cmd_section.c b/libr/core/cmd_section.c
index ff492abab..55eee916f 100644
--- a/libr/core/cmd_section.c
+++ b/libr/core/cmd_section.c
@@ -106,11 +106,11 @@ static int cmd_section(void *data, const char *input) {
 				if (!r_file_dump (file, buf, s->size, 0)) {
 					eprintf ("Cannot write '%s'\n", file);
 					free (buf);
-					return R_FALSE;
+					return false;
 				}
 				eprintf ("Dumped %d bytes into %s\n", (int)s->size, file);
 				free (buf);
-				return R_TRUE;
+				return true;
 			}
 		}
 		}
@@ -122,7 +122,7 @@ static int cmd_section(void *data, const char *input) {
 		RIOSection *s;
 		if (input[1] != ' ') {
 			eprintf ("Usage: Sl [file]\n");
-			return R_FALSE;
+			return false;
 		}
 		if (core->io->va || core->io->debug)
 			o = r_io_section_vaddr_to_maddr_try (core->io, o);
@@ -133,16 +133,16 @@ static int cmd_section(void *data, const char *input) {
 				// TODO: use mmap here. we need a portable implementation
 				if (!buf) {
 					eprintf ("Cannot allocate 0x%08"PFMT64x" bytes\n", s->size);
-					return R_FALSE;
+					return false;
 				}
 				r_io_write_at (core->io, s->vaddr, (const ut8*)buf, sz);
 				eprintf ("Loaded %d bytes into the map region at 0x%08"PFMT64x"\n", sz, s->vaddr);
 				free (buf);
-				return R_TRUE;
+				return true;
 			}
 		}
 		eprintf ("No debug region found here\n");
-		return R_FALSE;
+		return false;
 		}
 		break;
 	case '-':
@@ -232,10 +232,10 @@ static int cmd_section(void *data, const char *input) {
 		}
 		break;
 	case '\0':
-		r_io_section_list (core->io, core->offset, R_FALSE);
+		r_io_section_list (core->io, core->offset, false);
 		break;
 	case '*':
-		r_io_section_list (core->io, core->offset, R_TRUE);
+		r_io_section_list (core->io, core->offset, true);
 		break;
 	}
 	return 0;
diff --git a/libr/core/cmd_seek.c b/libr/core/cmd_seek.c
index 2aca78ca7..ca3e58391 100644
--- a/libr/core/cmd_seek.c
+++ b/libr/core/cmd_seek.c
@@ -30,7 +30,7 @@ static int cmd_seek(void *data, const char *input) {
 		if (input[0]!='/' && inputnum && isalpha (inputnum[0]) && off == 0) {
 			if (!r_flag_get (core->flags, inputnum)) {
 				eprintf ("Cannot find address for '%s'\n", inputnum);
-				return R_FALSE;
+				return false;
 			}
 		}
 #endif
@@ -232,7 +232,7 @@ static int cmd_seek(void *data, const char *input) {
 				ut64 addr = core->offset;
 				int numinstr = n * -1;
 				ret = r_core_asm_bwdis_len (core, &instr_len, &addr, numinstr);
-				r_core_seek (core, addr, R_TRUE);
+				r_core_seek (core, addr, true);
 				val += ret;
 			} else {
 				for (val=i=0; i<n; i++) {
diff --git a/libr/core/cmd_type.c b/libr/core/cmd_type.c
index ebdad104b..13a6da53a 100644
--- a/libr/core/cmd_type.c
+++ b/libr/core/cmd_type.c
@@ -276,5 +276,5 @@ static int cmd_type(void *data, const char *input) {
 		show_help (core);
 		break;
 	}
-	return R_TRUE;
+	return true;
 }
diff --git a/libr/core/cmd_write.c b/libr/core/cmd_write.c
index d1eed4e89..c323eaff6 100644
--- a/libr/core/cmd_write.c
+++ b/libr/core/cmd_write.c
@@ -344,7 +344,7 @@ static int cmd_write(void *data, const char *input) {
 		ut64 addr = 0, len = 0, b_size = 0;
 		st64 dist = 0;
 		ut8* bytes = NULL;
-		int cmd_suc = R_FALSE;
+		int cmd_suc = false;
 		char *input_shadow = NULL, *p = NULL;
 
 		switch (input[1]) {
@@ -438,18 +438,18 @@ static int cmd_write(void *data, const char *input) {
 					if (dist != 0){
 						r_core_shift_block (core, addr, b_size, dist);
 						r_core_seek (core, addr, 1);
-						cmd_suc = R_TRUE;
+						cmd_suc = true;
 					}
 				}
 				free (input_shadow);
 				break;
 			case '?':
 			default:
-				cmd_suc = R_FALSE;
+				cmd_suc = false;
 		}
 
 
-		if (cmd_suc == R_FALSE) {
+		if (cmd_suc == false) {
 			r_cons_printf ("|Usage: write extend\n"
 			"wen <num>               insert num null bytes at current offset\n"
 			"wex <hex_bytes>         insert bytes at current offset\n"
@@ -584,7 +584,7 @@ static int cmd_write(void *data, const char *input) {
 			r_core_block_read (core, 0);
 			break;
 		case 'r':
-			r_io_cache_reset (core->io, R_TRUE);
+			r_io_cache_reset (core->io, true);
 			/* Before loading the core block we have to make sure that if
 			 * the cache wrote past the original EOF these changes are no
 			 * longer displayed. */
@@ -593,7 +593,7 @@ static int cmd_write(void *data, const char *input) {
 			break;
 		case '+':
 			if (input[2]=='*') {
-				//r_io_cache_reset (core->io, R_TRUE);
+				//r_io_cache_reset (core->io, true);
 				eprintf ("TODO\n");
 			} else if (input[2]==' ') {
 				char *p = strchr (input+3, ' ');
@@ -617,7 +617,7 @@ static int cmd_write(void *data, const char *input) {
 			break;
 		case '-':
 			if (input[2]=='*') {
-				r_io_cache_reset (core->io, R_TRUE);
+				r_io_cache_reset (core->io, true);
 			} else if (input[2]==' ') {
 				char *p = strchr (input+3, ' ');
 				ut64 to, from;
@@ -658,12 +658,12 @@ static int cmd_write(void *data, const char *input) {
         }
 			break;
 		case '*':
-			r_io_cache_list (core->io, R_TRUE);
+			r_io_cache_list (core->io, true);
 			break;
 		case '\0':
 			//if (!r_config_get_i (core->config, "io.cache"))
 			//	eprintf ("[warning] e io.cache must be true\n");
-			r_io_cache_list (core->io, R_FALSE);
+			r_io_cache_list (core->io, false);
 			break;
 		}
 		break;
diff --git a/libr/core/config.c b/libr/core/config.c
index c8a63692d..565763fc4 100644
--- a/libr/core/config.c
+++ b/libr/core/config.c
@@ -75,49 +75,49 @@ static int cb_analeobjmp(void *user, void *data) {
 	RCore *core = (RCore*) user;
 	RConfigNode *node = (RConfigNode*) data;
 	core->anal->opt.eobjmp = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_analafterjmp(void *user, void *data) {
 	RCore *core = (RCore*) user;
 	RConfigNode *node = (RConfigNode*) data;
 	core->anal->opt.afterjmp = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_analsleep(void *user, void *data) {
 	RCore *core = (RCore*) user;
 	RConfigNode *node = (RConfigNode*) data;
 	core->anal->sleep = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_analmaxrefs(void *user, void *data) {
 	RCore *core = (RCore*) user;
 	RConfigNode *node = (RConfigNode*) data;
 	core->anal->maxreflines = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_analnopskip (void *user, void *data) {
 	RCore *core = (RCore*) user;
 	RConfigNode *node = (RConfigNode*) data;
 	core->anal->opt.nopskip = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_analbbsplit (void *user, void *data) {
 	RCore *core = (RCore*) user;
 	RConfigNode *node = (RConfigNode*) data;
 	core->anal->opt.bbsplit = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_analnoncode(void *user, void *data) {
 	RCore *core = (RCore*) user;
 	RConfigNode *node = (RConfigNode*) data;
-	core->anal->opt.noncode = node->i_value ? R_TRUE: R_FALSE; // obey section permissions
-	return R_TRUE;
+	core->anal->opt.noncode = node->i_value ? true: false; // obey section permissions
+	return true;
 }
 
 static int cb_analarch(void *user, void *data) {
@@ -125,7 +125,7 @@ static int cb_analarch(void *user, void *data) {
 	RConfigNode *node = (RConfigNode*) data;
 	if (*node->value == '?') {
 		r_anal_list (core->anal);
-		return R_FALSE;
+		return false;
 	} else {
 		if (*node->value) {
 			if (!r_anal_use (core->anal, node->value)) {
@@ -133,32 +133,32 @@ static int cb_analarch(void *user, void *data) {
 				if (!aa || strcmp (aa, node->value)) {
 					eprintf ("anal.arch: cannot find '%s'\n", node->value);
 				}
-				return R_FALSE;
+				return false;
 			}
-		} else return R_FALSE;
+		} else return false;
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int cb_analcpu(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	r_anal_set_cpu (core->anal, node->value);
-	return R_TRUE;
+	return true;
 }
 
 static int cb_analsplit(void *user, void *data) {
 	RCore *core = (RCore*) user;
 	RConfigNode *node = (RConfigNode*) data;
 	core->anal->split = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_analrecont(void *user, void *data) {
 	RCore *core = (RCore*) user;
 	RConfigNode *node = (RConfigNode*) data;
 	core->anal->opt.recont = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_asmarch(void *user, void *data) {
@@ -173,15 +173,15 @@ static int cb_asmarch(void *user, void *data) {
 
 	if (*node->value=='?') {
 		rasm2_list (core, NULL);
-		return R_FALSE;
+		return false;
 	}
 	r_egg_setup (core->egg, node->value, bits, 0, R_SYS_OS);
 	if (*node->value) {
 		if (!r_asm_use (core->assembler, node->value)) {
 			eprintf ("asm.arch: cannot find (%s)\n", node->value);
-			return R_FALSE;
+			return false;
 		}
-	} else return R_FALSE;
+	} else return false;
 
 	if (core->assembler && core->assembler->cur) {
 		bits = core->assembler->cur->bits;
@@ -215,21 +215,21 @@ static int cb_asmarch(void *user, void *data) {
 	//if (!strcmp (node->value, "bf"))
 	//	r_config_set (core->config, "dbg.backend", "bf");
 	__setsegoff (core->config, node->value, core->assembler->bits);
-	return R_TRUE;
+	return true;
 }
 
 static int cb_dbgbpsize(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->dbg->bpsize = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_dbgbtdepth(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->dbg->btdepth = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_asmbits(void *user, void *data) {
@@ -239,18 +239,18 @@ static int cb_asmbits(void *user, void *data) {
 	int ret;
 	if (!core) {
 		eprintf ("user can't be NULL\n");
-		return R_FALSE;
+		return false;
 	}
 
 	ret = r_asm_set_bits (core->assembler, node->i_value);
-	if (ret == R_FALSE) {
+	if (ret == false) {
 		RAsmPlugin *h = core->assembler->cur;
 		if (h) {
 			eprintf ("Cannot set bits %"PFMT64d" to '%s'\n",
 					node->i_value, h->name);
 		} else {
 			eprintf ("e asm.bits: Cannot set value, no plugins defined yet\n");
-			ret = R_TRUE;
+			ret = true;
 		}
 	}
 	if (!r_anal_set_bits (core->anal, node->i_value)) {
@@ -336,21 +336,21 @@ static int cb_asmcpu(void *user, void *data) {
 	}
 	r_asm_set_cpu (core->assembler, node->value);
 	r_config_set (core->config, "anal.cpu", node->value);
-	return R_TRUE;
+	return true;
 }
 
 static int cb_asmlineswidth(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->anal->lineswidth = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_asm_invhex(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->assembler->invhex = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_asmos(void *user, void *data) {
@@ -373,7 +373,7 @@ static int cb_asmos(void *user, void *data) {
 		__setsegoff (core->config, asmarch->value, asmbits);
 	}
 	//if (!ret) eprintf ("asm.os: Cannot setup syscall os/arch for '%s'\n", node->value);
-	return R_TRUE;
+	return true;
 }
 
 static int cb_asmparser(void *user, void *data) {
@@ -382,21 +382,21 @@ static int cb_asmparser(void *user, void *data) {
 	// XXX this is wrong? snprintf(buf, 127, "parse_%s", node->value),
 	return r_parse_use (core->parser, node->value);
 	// TODO: control error and restore old value (return false?) show errormsg?
-	//return R_TRUE;
+	//return true;
 }
 
 static int cb_binfilter(void *user, void *data) {
 	RCore *core = (RCore*) user;
 	RConfigNode *node = (RConfigNode*) data;
 	core->bin->filter = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_binforce(void *user, void *data) {
 	RCore *core = (RCore*) user;
 	RConfigNode *node = (RConfigNode*) data;
 	r_bin_force_plugin (core->bin, node->value);
-	return R_TRUE;
+	return true;
 }
 
 static int cb_asmsyntax(void *user, void *data) {
@@ -404,7 +404,7 @@ static int cb_asmsyntax(void *user, void *data) {
 	RConfigNode *node = (RConfigNode*) data;
 	if (*node->value == '?') {
 		r_cons_printf ("att\nintel\nmasm\njz\nregnum\n");
-		return R_FALSE;
+		return false;
 	} else if (!strcmp (node->value, "regnum")) {
 		r_asm_set_syntax (core->assembler, R_ASM_SYNTAX_REGNUM);
 	} else if (!strcmp (node->value, "jz")) {
@@ -415,8 +415,8 @@ static int cb_asmsyntax(void *user, void *data) {
 		r_asm_set_syntax (core->assembler, R_ASM_SYNTAX_MASM);
 	} else if (!strcmp (node->value, "att")) {
 		r_asm_set_syntax (core->assembler, R_ASM_SYNTAX_ATT);
-	} else return R_FALSE;
-	return R_TRUE;
+	} else return false;
+	return true;
 }
 
 static int cb_bigendian(void *user, void *data) {
@@ -426,34 +426,34 @@ static int cb_bigendian(void *user, void *data) {
 	core->anal->big_endian = node->i_value;
 	core->anal->reg->big_endian = node->i_value;
 	core->print->big_endian = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_cfgdatefmt(void *user, void *data) {
 	RCore *core = (RCore*) user;
 	RConfigNode *node = (RConfigNode*) data;
 	snprintf (core->print->datefmt, 32, "%s", node->value);
-	return R_TRUE;
+	return true;
 }
 
 static int cb_timezone(void *user, void *data) {
 	RCore *core = (RCore*) user;
 	RConfigNode *node = (RConfigNode*) data;
 	core->print->datezone = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_cfgdebug(void *user, void *data) {
 	int ioraw = 1;
 	RCore *core = (RCore*) user;
 	RConfigNode *node = (RConfigNode*) data;
-	if (!core) return R_FALSE;
+	if (!core) return false;
 	if (core->io) {
 		core->io->debug = node->i_value;
 	}
 	if (core->dbg && node->i_value) {
 		const char *dbgbackend = r_config_get (core->config, "dbg.backend");
-		core->bin->is_debugger = R_TRUE;
+		core->bin->is_debugger = true;
 		r_debug_use (core->dbg, dbgbackend);
 		if (!strcmp (r_config_get (core->config, "cmd.prompt"), "")) {
 			r_config_set (core->config, "cmd.prompt", ".dr*");
@@ -466,7 +466,7 @@ static int cb_cfgdebug(void *user, void *data) {
 		}
 	} else {
 		if (core->dbg) r_debug_use (core->dbg, NULL);
-		core->bin->is_debugger = R_FALSE;
+		core->bin->is_debugger = false;
 	}
 	if (core->io) {
 		if (core->dbg && core->dbg->h) {
@@ -476,7 +476,7 @@ static int cb_cfgdebug(void *user, void *data) {
 		}
 	}
 	r_config_set (core->config, "io.raw", ioraw? "true": "false");
-	return R_TRUE;
+	return true;
 }
 
 static int cb_cfgsanbox(void *user, void *data) {
@@ -491,14 +491,14 @@ static int cb_cmdrepeat(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->cmdrepeat = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_scrnull(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->cons->null = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_color(void *user, void *data) {
@@ -511,16 +511,16 @@ static int cb_color(void *user, void *data) {
 		core->print->flags &= (~R_PRINT_FLAGS_COLOR);
 	}
 	r_print_set_flags (core->print, core->print->flags);
-	return R_TRUE;
+	return true;
 }
 
 static int cb_dbgbep(void *user, void *data) {
 	RConfigNode *node = (RConfigNode*) data;
 	if (*node->value == '?') {
 		r_cons_printf ("loader\nentry\nconstructor\nmain\n");
-		return R_FALSE;
+		return false;
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int cb_dbg_btalgo(void *user, void *data) {
@@ -528,11 +528,11 @@ static int cb_dbg_btalgo(void *user, void *data) {
 	RConfigNode *node = (RConfigNode*) data;
 	if (*node->value == '?') {
 		r_cons_printf ("default\nfuzzy\nanal\n");
-		return R_FALSE;
+		return false;
 	}
 	free (core->dbg->btalgo);
 	core->dbg->btalgo = strdup (node->value);
-	return R_TRUE;
+	return true;
 }
 
 static int cb_dbg_forks(void *user, void *data) {
@@ -540,7 +540,7 @@ static int cb_dbg_forks(void *user, void *data) {
 	RConfigNode *node = (RConfigNode*) data;
 	core->dbg->trace_forks = node->i_value;
 	r_debug_attach (core->dbg, core->dbg->pid);
-	return R_TRUE;
+	return true;
 }
 
 static int cb_dbg_execs(void *user, void *data) {
@@ -548,7 +548,7 @@ static int cb_dbg_execs(void *user, void *data) {
 	RConfigNode *node = (RConfigNode*) data;
 	core->dbg->trace_execs = node->i_value;
 	r_debug_attach (core->dbg, core->dbg->pid);
-	return R_TRUE;
+	return true;
 }
 
 static int cb_dbg_clone(void *user, void *data) {
@@ -556,7 +556,7 @@ static int cb_dbg_clone(void *user, void *data) {
 	RConfigNode *node = (RConfigNode*) data;
 	core->dbg->trace_clone = node->i_value;
 	r_debug_attach (core->dbg, core->dbg->pid);
-	return R_TRUE;
+	return true;
 }
 
 static int cb_runprofile(void *user, void *data) {
@@ -566,7 +566,7 @@ static int cb_runprofile(void *user, void *data) {
 	if (!node || !*(node->value))
 		r->io->runprofile = NULL;
 	else r->io->runprofile = strdup (node->value);
-	return R_TRUE;
+	return true;
 }
 
 static int cb_dbgstatus(void *user, void *data) {
@@ -578,7 +578,7 @@ static int cb_dbgstatus(void *user, void *data) {
 				".dr* ; drd ; sr pc;pi 1;s-");
 		else r_config_set (r->config, "cmd.prompt", ".dr*");
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int cb_dbgbackend(void *user, void *data) {
@@ -588,7 +588,7 @@ static int cb_dbgbackend(void *user, void *data) {
 	if (!strcmp (node->value, "bf"))
 		r_config_set (core->config, "asm.arch", "bf");
 	r_debug_use (core->dbg, node->value);
-	return R_TRUE;
+	return true;
 }
 
 static int cb_gotolimit(void *user, void *data) {
@@ -596,11 +596,11 @@ static int cb_gotolimit(void *user, void *data) {
 	RConfigNode *node = (RConfigNode*) data;
 	if (r_sandbox_enable (0)) {
 		eprintf ("Cannot change gotolimit\n");
-		return R_FALSE;
+		return false;
 	}
 	if (core->anal->esil)
 		core->anal->esil_goto_limit = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_esildebug (void *user, void *data) {
@@ -608,41 +608,41 @@ static int cb_esildebug (void *user, void *data) {
 	RConfigNode *node = (RConfigNode*) data;
 	if (core->anal->esil)
 		core->anal->esil->debug = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_fixrows(void *user, void *data) {
 	RConfigNode *node = (RConfigNode *) data;
 	r_cons_singleton ()->fix_rows = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_fixcolumns(void *user, void *data) {
 	RConfigNode *node = (RConfigNode *) data;
 	r_cons_singleton ()->fix_columns = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_rows(void *user, void *data) {
 	RConfigNode *node = (RConfigNode *) data;
 	r_cons_singleton ()->force_rows = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_hexpairs(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->print->pairs = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int r_core_esil_cmd(RAnalEsil *esil, const char *cmd, int intr) {
 	if (cmd && *cmd) {
 		RCore *core = esil->anal->user;
 		r_core_cmdf (core, "%s %d", cmd, intr);
-		return R_TRUE;
+		return true;
 	}
-	return R_FALSE;
+	return false;
 }
 
 static int cb_cmd_esil_intr(void *user, void *data) {
@@ -652,7 +652,7 @@ static int cb_cmd_esil_intr(void *user, void *data) {
 		core->anal->esil->cmd = r_core_esil_cmd;
 		core->anal->esil->cmd_intr = node->value;
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int cb_fsview(void *user, void *data) {
@@ -661,7 +661,7 @@ static int cb_fsview(void *user, void *data) {
 	RConfigNode *node = (RConfigNode *) data;
 	if (*node->value == '?') {
 		eprintf ("Values: all|deleted|special\n");
-		return R_FALSE;
+		return false;
 	}
 	if (!strcmp (node->value, "all"))
 		type = R_FS_VIEW_ALL;
@@ -670,32 +670,32 @@ static int cb_fsview(void *user, void *data) {
 	if (!strstr (node->value, "spe"))
 		type |= R_FS_VIEW_SPECIAL;
 	r_fs_view (core->fs, type);
-	return R_TRUE;
+	return true;
 }
 
 static int cb_cmddepth(void *user, void *data) {
 	int c = R_MAX (((RConfigNode*)data)->i_value, 0);
 	((RCore *)user)->cmd_depth = c;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_hexcols(void *user, void *data) {
 	int c = R_MIN (128, R_MAX (((RConfigNode*)data)->i_value, 0));
 	((RCore *)user)->print->cols = c & ~1;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_hexstride(void *user, void *data) {
 	RConfigNode *node = (RConfigNode*) data;
 	((RCore *)user)->print->stride = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_search_kwidx(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->search->n_kws = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_ioenforce(void *user, void *data) {
@@ -705,14 +705,14 @@ static int cb_ioenforce(void *user, void *data) {
 	core->io->enforce_rwx = 0;
 	if (perm & 1) core->io->enforce_rwx |= R_IO_READ;
 	if (perm & 2) core->io->enforce_rwx |= R_IO_WRITE;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_iosectonly(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->io->sectonly = node->i_value? 1: 0;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_iobuffer(void *user, void *data) {
@@ -728,14 +728,14 @@ static int cb_iobuffer(void *user, void *data) {
 		} else r_io_buffer_load (core->io, from, (int)(to-from));
 	} else r_io_buffer_close (core->io);
 	r_core_block_read (core, 0);
-	return R_TRUE;
+	return true;
 }
 
 static int cb_iocache(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	r_io_cache_enable (core->io, node->i_value, node->i_value);
-	return R_TRUE;
+	return true;
 }
 
 static int cb_ioaslr(void *user, void *data) {
@@ -744,7 +744,7 @@ static int cb_ioaslr(void *user, void *data) {
 	if (node->i_value != core->io->aslr) {
 		core->io->aslr = node->i_value;
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int cb_iova(void *user, void *data) {
@@ -758,42 +758,42 @@ static int cb_iova(void *user, void *data) {
 		if (r_list_length (r_bin_get_sections (core->bin))>0)
 			r_core_cmd0 (core, ".ia*");
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int cb_iozeromap(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->io->zeromap = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_ioraw(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	r_io_set_raw (core->io, node->i_value);
-	return R_TRUE;
+	return true;
 }
 
 static int cb_ioff(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->io->ff = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_ioautofd(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->io->autofd = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_iovio(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->io->vio = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_pager(void *user, void *data) {
@@ -802,13 +802,13 @@ static int cb_pager(void *user, void *data) {
 
 	/* Let cons know we have a new pager. */
 	core->cons->pager = node->value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_fps(void *user, void *data) {
 	RConfigNode *node = (RConfigNode *) data;
 	r_cons_singleton ()->fps = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_rgbcolors(void *user, void *data) {
@@ -820,14 +820,14 @@ static int cb_rgbcolors(void *user, void *data) {
 	} else {
 		r_cons_singleton()->truecolor = 0;
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int cb_scrcolumns(void* user, void* data) {
 	RConfigNode *node = (RConfigNode*) data;
 	int n = atoi (node->value);
 	((RCore *)user)->cons->force_columns = n;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_scrfgets(void* user, void* data) {
@@ -836,26 +836,26 @@ static int cb_scrfgets(void* user, void* data) {
 	if (node->i_value)
 		core->cons->user_fgets = NULL;
 	else core->cons->user_fgets = (void *)r_core_fgets;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_scrhtml(void *user, void *data) {
 	RConfigNode *node = (RConfigNode *) data;
 	r_cons_singleton ()->is_html = node->i_value;
 	// TODO: control error and restore old value (return false?) show errormsg?
-	return R_TRUE;
+	return true;
 }
 
 static int cb_scrhighlight(void *user, void *data) {
 	RConfigNode *node = (RConfigNode *) data;
 	r_cons_highlight (node->value);
-	return R_TRUE;
+	return true;
 }
 
 static int cb_screcho(void *user, void *data) {
 	RConfigNode *node = (RConfigNode *) data;
 	r_cons_singleton()->echo = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_iotrap(void *user, void *data) {
@@ -864,45 +864,45 @@ static int cb_iotrap(void *user, void *data) {
 	if (core->anal && core->anal->esil) {
 		core->anal->esil->iotrap = node->i_value;
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int cb_scrint(void *user, void *data) {
 	RConfigNode *node = (RConfigNode *) data;
 	if (node->i_value && r_sandbox_enable (0)) {
-		return R_FALSE;
+		return false;
 	}
 	r_cons_singleton()->is_interactive = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_scrnkey(void *user, void *data) {
 	RConfigNode *node = (RConfigNode*) data;
 	if (!strcmp (node->value, "help") || *node->value == '?') {
 		r_cons_printf ("scr.nkey = fun, hit, flag\n");
-		return R_FALSE;
+		return false;
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int cb_scrprompt(void *user, void *data) {
 	RConfigNode *node = (RConfigNode *) data;
 	r_line_singleton()->echo = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_scrrows(void* user, void* data) {
 	RConfigNode *node = (RConfigNode*) data;
 	int n = atoi (node->value);
 	((RCore *)user)->cons->force_rows = n;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_contiguous(void *user, void *data) {
 	RCore *core = (RCore *)user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->search->contiguous = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_searchalign(void *user, void *data) {
@@ -910,7 +910,7 @@ static int cb_searchalign(void *user, void *data) {
 	RConfigNode *node = (RConfigNode *) data;
 	core->search->align = node->i_value;
 	core->print->addrmod = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_segoff(void *user, void *data) {
@@ -919,27 +919,27 @@ static int cb_segoff(void *user, void *data) {
 	if (node->i_value)
 		core->print->flags |= R_PRINT_FLAGS_SEGOFF;
 	else core->print->flags &= (((ut32)-1) & (~R_PRINT_FLAGS_SEGOFF));
-	return R_TRUE;
+	return true;
 }
 
 static int cb_stopthreads(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->dbg->stop_all_threads = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_swstep(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->dbg->swstep = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_teefile(void *user, void *data) {
 	RConfigNode *node = (RConfigNode *) data;
 	r_cons_singleton()->teefile = node->value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_anal_trace(void *user, void *data) {
@@ -951,35 +951,35 @@ static int cb_anal_trace(void *user, void *data) {
 		}
 		core->anal->trace = node->i_value;
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int cb_trace(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->dbg->trace->enabled = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_tracetag(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->dbg->trace->tag = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_truecolor(void *user, void *data) {
 	RConfigNode *node = (RConfigNode *) data;
 	if (r_cons_singleton()->truecolor)
 		r_cons_singleton()->truecolor = (node->i_value)? 2: 1;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_utf8(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->utf8 = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_zoombyte(void *user, void *data) {
@@ -992,16 +992,16 @@ static int cb_zoombyte(void *user, void *data) {
 			break;
 		default:
 			eprintf ("Invalid zoom.byte value. See pz? for help\n");
-			return R_FALSE;
+			return false;
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int cb_rawstr(void *user, void *data) {
 	RCore *core = (RCore *) user;
 	RConfigNode *node = (RConfigNode *) data;
 	core->bin->rawstr = node->i_value;
-	return R_TRUE;
+	return true;
 }
 
 static int cb_binmaxstr(void *user, void *data) {
@@ -1013,9 +1013,9 @@ static int cb_binmaxstr(void *user, void *data) {
 		core->bin->maxstrlen = v;
 	// TODO: Do not refresh if nothing changed (minstrlen ?)
 		r_core_bin_refresh_strings (core);
-		return R_TRUE;
+		return true;
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int cb_binminstr(void *user, void *data) {
@@ -1027,9 +1027,9 @@ static int cb_binminstr(void *user, void *data) {
 		core->bin->minstrlen = v;
 	// TODO: Do not refresh if nothing changed (minstrlen ?)
 		r_core_bin_refresh_strings (core);
-		return R_TRUE;
+		return true;
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int cb_searchin(void *user, void *data) {
@@ -1039,18 +1039,18 @@ static int cb_searchin(void *user, void *data) {
 							"io.sections\nio.sections.write\nio.sections.exec\n" \
 							"dbg.stack\ndbg.heap\ndbg.map\ndbg.maps\n"\
 							"dbg.maps.exec\ndbg.maps.write\nanal.fcn\nanal.bb\n");
- 		return R_FALSE;
+ 		return false;
  	}
- 	return R_TRUE;
+ 	return true;
 }
 
 static int cb_fileloadmethod(void *user, void *data) {
  	RConfigNode *node = (RConfigNode*) data;
  	if (*node->value == '?') {
  		r_cons_printf ("fail\noverwrite\nappend\n");
- 		return R_FALSE;
+ 		return false;
  	}
- 	return R_TRUE;
+ 	return true;
 }
 
 static int __dbg_swstep_getter(void *user, RConfigNode *node) {
@@ -1520,6 +1520,6 @@ R_API int r_core_config_init(RCore *core) {
 	SETI("zoom.maxsz", 512, "Zoom max size of block");
 	SETI("zoom.to", 0, "Zoom end address");
 
-	r_config_lock (cfg, R_TRUE);
-	return R_TRUE;
+	r_config_lock (cfg, true);
+	return true;
 }
diff --git a/libr/core/core.c b/libr/core/core.c
index e49dad115..b517124e1 100644
--- a/libr/core/core.c
+++ b/libr/core/core.c
@@ -68,7 +68,7 @@ R_API int r_core_bind(RCore *core, RCoreBind *bnd) {
 	bnd->cmd = (RCoreCmd)r_core_cmd0;
 	bnd->cmdstr = (RCoreCmdStr)r_core_cmd_str;
 	bnd->puts = (RCorePuts)r_cons_strcat;
-	return R_TRUE;
+	return true;
 }
 
 R_API RCore *r_core_ncast(ut64 p) {
@@ -125,7 +125,7 @@ static ut64 num_callback(RNum *userptr, const char *str, int *ok) {
 	RAnalOp op;
 	ut64 ret = 0;
 
-	if (ok) *ok = R_FALSE;
+	if (ok) *ok = false;
 	switch (*str) {
 	case '[':
 {
@@ -264,7 +264,7 @@ static ut64 num_callback(RNum *userptr, const char *str, int *ok) {
 			// NOTE: functions override flags
 			RAnalFunction *fcn = r_anal_fcn_find_name (core->anal, str);
 			if (fcn) {
-				if (ok) *ok = R_TRUE;
+				if (ok) *ok = true;
 				return fcn->addr;
 			}
 #if 0
@@ -277,7 +277,7 @@ static ut64 num_callback(RNum *userptr, const char *str, int *ok) {
 #endif
 			if ((flag = r_flag_get (core->flags, str))) {
 				ret = flag->offset;
-				if (ok) *ok = R_TRUE;
+				if (ok) *ok = true;
 			}
 		}
 		break;
@@ -590,7 +590,7 @@ static int autocomplete(RLine *line) {
 		line->completion.argc = j;
 		line->completion.argv = tmp_argv;
 	}
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_fgets(char *buf, int len) {
@@ -694,7 +694,7 @@ static char *getbitfield(void *_core, const char *name, ut64 val) {
 
 	isenum = sdb_const_get (core->anal->sdb_types, name, 0);
 	if (isenum && !strcmp (isenum, "enum")) {
-		int isFirst = R_TRUE;
+		int isFirst = true;
 		ret = r_str_concatf (ret, "0x%08"PFMT64x" : ", val);
 		for (i=0; i < 32; i++) {
 			if (!(val & (1<<i)))
@@ -702,7 +702,7 @@ static char *getbitfield(void *_core, const char *name, ut64 val) {
 			q = sdb_fmt (0, "%s.0x%x", name, (1<<i));
 			res = sdb_const_get (core->anal->sdb_types, q, 0);
 			if (isFirst) {
-				isFirst = R_FALSE;
+				isFirst = false;
 			} else {
 				ret = r_str_concat (ret, " | ");
 			}
@@ -807,11 +807,11 @@ R_API const char *r_core_anal_optype_colorfor(RCore *core, ut64 addr) {
 R_API int r_core_init(RCore *core) {
 	core->cmd_depth = R_CORE_CMD_DEPTH+1;
 	core->sdb = sdb_new (NULL, "r2kv.sdb", 0); // XXX: path must be in home?
-	core->zerosep = R_FALSE;
-	core->incomment = R_FALSE;
+	core->zerosep = false;
+	core->incomment = false;
 	core->screen_bounds = 0LL;
 	core->config = NULL;
-	core->http_up = R_FALSE;
+	core->http_up = false;
 	core->print = r_print_new ();
 	core->print->user = core;
 	core->print->get_enumname = getenumname;
@@ -830,14 +830,14 @@ R_API int r_core_init(RCore *core) {
 	core->scriptstack = r_list_new ();
 	core->scriptstack->free = (RListFree)free;
 	core->log = r_core_log_new ();
-	core->vmode = R_FALSE;
+	core->vmode = false;
 	core->section = NULL;
 	core->oobi = NULL;
 	core->oobi_len = 0;
 	core->printidx = 0;
 	core->lastcmd = NULL;
 	core->cmdqueue = NULL;
-	core->cmdrepeat = R_TRUE;
+	core->cmdrepeat = true;
 	core->yank_buf = r_buf_new();
 	core->num = r_num_new (&num_callback, core);
 	//core->num->callback = &num_callback;
@@ -870,7 +870,7 @@ R_API int r_core_init(RCore *core) {
 	if (core->block == NULL) {
 		eprintf ("Cannot allocate %d bytes\n", R_CORE_BLOCKSIZE);
 		/* XXX memory leak */
-		return R_FALSE;
+		return false;
 	}
 	core->lang = r_lang_new ();
 	core->lang->cmd_str = (char *(*)(void *, const char *))r_core_cmd_str;
@@ -926,7 +926,7 @@ R_API int r_core_init(RCore *core) {
 	core->files->free = (RListFree)r_core_file_free;
 	core->offset = 0LL;
 	r_core_cmd_init (core);
-	core->dbg = r_debug_new (R_TRUE);
+	core->dbg = r_debug_new (true);
 	r_core_bind (core, &core->dbg->corebind);
 	core->dbg->cb_printf = (PrintfCallback)r_cons_printf;
 	core->dbg->anal = core->anal; // XXX: dupped instance.. can cause lost pointerz
@@ -1011,7 +1011,7 @@ R_API RCore *r_core_free(RCore *c) {
 R_API void r_core_prompt_loop(RCore *r) {
 	int ret;
 	do {
-		if (r_core_prompt (r, R_FALSE)<1)
+		if (r_core_prompt (r, false)<1)
 			break;
 //			if (lock) r_th_lock_enter (lock);
 		if ((ret = r_core_prompt_exec (r))==-1)
@@ -1031,7 +1031,7 @@ R_API void r_core_prompt_loop(RCore *r) {
 static int prompt_flag (RCore *r, char *s, size_t maxlen) {
 	const char DOTS[] = "...";
 	const RFlagItem *f = r_flag_get_at (r->flags, r->offset);
-	if (!f) return R_FALSE;
+	if (!f) return false;
 
 	if (f->offset < r->offset) {
 		snprintf (s, maxlen, "%s + %" PFMT64u, f->name,
@@ -1043,7 +1043,7 @@ static int prompt_flag (RCore *r, char *s, size_t maxlen) {
 		s[maxlen - sizeof (DOTS) - 1] = '\0';
 		strcat (s, DOTS);
 	}
-	return R_TRUE;
+	return true;
 }
 
 static void prompt_sec(RCore *r, char *s, size_t maxlen) {
@@ -1114,7 +1114,7 @@ static void set_prompt (RCore *r) {
 		snprintf (tmp, max_tmp_size, "%04x:%04x", a, b);
 	} else {
 		char p[64], sec[32];
-		int promptset = R_FALSE;
+		int promptset = false;
 
 		sec[0] = '\0';
 		if (r_config_get_i (r->config, "scr.promptflag")) {
@@ -1148,18 +1148,18 @@ R_API int r_core_prompt(RCore *r, int sync) {
 
 	ret = r_cons_fgets (line, sizeof (line), 0, NULL);
 	if (ret == -2) return R_CORE_CMD_EXIT; // ^D
-	if (ret == -1) return R_FALSE; // FD READ ERROR
+	if (ret == -1) return false; // FD READ ERROR
 	r->num->value = rnv;
 	if (sync) {
 		return r_core_prompt_exec (r);
 	}
 	free (r->cmdqueue);
 	r->cmdqueue = strdup (line);
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_prompt_exec(RCore *r) {
-	int ret = r_core_cmd (r, r->cmdqueue, R_TRUE);
+	int ret = r_core_cmd (r, r->cmdqueue, true);
 	r_cons_flush ();
 	if (r->zerosep)
 		r_cons_zero ();
@@ -1168,20 +1168,20 @@ R_API int r_core_prompt_exec(RCore *r) {
 
 R_API int r_core_block_size(RCore *core, int bsize) {
 	ut8 *bump;
-	int ret = R_FALSE;
-	if (bsize<0) return R_FALSE;
+	int ret = false;
+	if (bsize<0) return false;
 	if (bsize == core->blocksize)
-		return R_TRUE;
+		return true;
 	if (r_sandbox_enable (0)) {
 		// TODO : restrict to filesize?
 		if (bsize > 1024*32) {
 			eprintf ("Sandbox mode restricts blocksize bigger than 32k\n");
-			return R_FALSE;
+			return false;
 		}
 	}
 	if (bsize > core->blocksize_max) {
 		eprintf ("Block size %d is too big\n", bsize);
-		return R_FALSE;
+		return false;
 	}
 	if (bsize<1) {
 		bsize = 1;
@@ -1193,9 +1193,9 @@ R_API int r_core_block_size(RCore *core, int bsize) {
 	bump = realloc (core->block, bsize+1);
 	if (bump == NULL) {
 		eprintf ("Oops. cannot allocate that much (%u)\n", bsize);
-		ret = R_FALSE;
+		ret = false;
 	} else {
-		ret = R_TRUE;
+		ret = true;
 		core->block = bump;
 		core->blocksize = bsize;
 		memset (core->block, 0xff, core->blocksize);
@@ -1209,7 +1209,7 @@ R_API int r_core_seek_align(RCore *core, ut64 align, int times) {
 	ut64 seek = core->offset;
 
 	if (!align)
-		return R_FALSE;
+		return false;
 	diff = core->offset%align;
 	if (times == 0)
 		diff = -diff;
@@ -1522,7 +1522,7 @@ reaccept:
 					ptr = (ut8 *) malloc (i+7);
 					if (!ptr) {
 						r_socket_close (c);
-						return R_FALSE;
+						return false;
 					}
 					ptr[5]='!';
 					r_socket_read_block (c, ptr+6, i);
@@ -1549,7 +1549,7 @@ reaccept:
 								if (!ptr) {
 									fclose (fd);
 									r_socket_close (c);
-									return R_FALSE;
+									return false;
 								}
 								r = fread (ptr+5, i, 1, fd);
 								ptr[5+r]='\0';
@@ -1574,7 +1574,7 @@ reaccept:
 				}
 
 				if (!ptr) ptr = (ut8 *) malloc (5); // malloc for 5 byets? c'mon!
-				if (!ptr) return R_FALSE;
+				if (!ptr) return false;
 
 				// send
 				ptr[0] = (RMT_SYSTEM | RMT_REPLY);
@@ -1617,14 +1617,14 @@ R_API int r_core_search_cb(RCore *core, ut64 from, ut64 to, RCoreSearchCallback
 			int done = cb (core, from, buf+ret, len-ret);
 			if (done<1) { /* interrupted */
 				free (buf);
-				return R_FALSE;
+				return false;
 			}
 			ret += done;
 		}
 		from += len;
 	}
 	free (buf);
-	return R_TRUE;
+	return true;
 }
 
 R_API char *r_core_editor (const RCore *core, const char *file, const char *str) {
diff --git a/libr/core/disasm.c b/libr/core/disasm.c
index 6482885a6..1a9a389aa 100644
--- a/libr/core/disasm.c
+++ b/libr/core/disasm.c
@@ -852,7 +852,7 @@ static void handle_print_show_cursor (RCore *core, RDisasmState *ds) {
 
 static int var_comparator (const RAnalVar *a, const RAnalVar *b){
 	if (a && b) return a->delta > b->delta;
-	return R_FALSE;
+	return false;
 }
 
 static void handle_show_functions (RCore *core, RDisasmState *ds) {
@@ -1677,7 +1677,7 @@ static int handle_print_middle (RCore *core, RDisasmState *ds, int ret) {
 static int handle_print_labels (RCore *core, RDisasmState *ds, RAnalFunction *f) {
 	const char *label;
 	if (!core || !ds)
-		return R_FALSE;
+		return false;
 	if (!f) {
 		f = r_anal_get_fcn_in (core->anal, ds->at, 0);
 	}
@@ -2905,7 +2905,7 @@ R_API int r_core_print_disasm_json(RCore *core, ut64 addr, ut8 *buf, int nb_byte
 				if (!r_core_asm_bwdis_len (core, &nbytes, &addr, nb_opcodes)) {
 #endif
 					r_cons_printf ("]");
-					return R_FALSE;
+					return false;
 #if BWRETRY
 				}
 #endif
@@ -3102,7 +3102,7 @@ R_API int r_core_print_disasm_json(RCore *core, ut64 addr, ut8 *buf, int nb_byte
 	}
 	r_cons_printf ("]");
 	core->offset = old_offset;
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_print_fcn_disasm(RPrint *p, RCore *core, ut64 addr, int l, int invbreak, int cbytes) {
diff --git a/libr/core/file.c b/libr/core/file.c
index d4134d4e7..e79cc46ad 100644
--- a/libr/core/file.c
+++ b/libr/core/file.c
@@ -21,7 +21,7 @@ R_API int r_core_file_reopen(RCore *core, const char *args, int perm, int loadbi
 		r_bin_file_find_by_fd (core->bin, ofile->desc->fd) : NULL;
 	RIODesc *odesc = ofile ? ofile->desc : NULL;
 	char *ofilepath = NULL, *obinfilepath = bf ? strdup (bf->file) : NULL;
-	int newpid, ret = R_FALSE;
+	int newpid, ret = false;
 	ut64 origoff = core->offset;
 	if (odesc) {
 		if (odesc->referer) {
@@ -34,7 +34,7 @@ R_API int r_core_file_reopen(RCore *core, const char *args, int perm, int loadbi
 	if (r_sandbox_enable (0)) {
 		eprintf ("Cannot reopen in sandbox\n");
 		free (obinfilepath);
-		return R_FALSE;
+		return false;
 	}
 #if 0
 	if (isdebug) {
@@ -48,7 +48,7 @@ R_API int r_core_file_reopen(RCore *core, const char *args, int perm, int loadbi
 		eprintf ("No file opened to reopen\n");
 		free (ofilepath);
 		free (obinfilepath);
-		return R_FALSE;
+		return false;
 	}
 	newpid = odesc ? odesc->fd : -1;
 
@@ -64,7 +64,7 @@ R_API int r_core_file_reopen(RCore *core, const char *args, int perm, int loadbi
 	if (!ofilepath) {
 		eprintf ("Unknown file path");
 		free (obinfilepath);
-		return R_FALSE;
+		return false;
 	}
 
 	// HACK: move last mapped address to higher place
@@ -107,7 +107,7 @@ R_API int r_core_file_reopen(RCore *core, const char *args, int perm, int loadbi
 		/*
 		if (core->bin->cur && file->desc) {
 			core->bin->cur->fd = file->desc->fd;
-			ret = R_TRUE;
+			ret = true;
 		}*/
 		// close old file
 	} else if (ofile) {
@@ -289,9 +289,9 @@ static int r_core_file_do_load_for_debug (RCore *r, ut64 baseaddr, const char *f
 	RBinFile *binfile = NULL;
 	RBinPlugin *plugin;
 	int xtr_idx = 0; // if 0, load all if xtr is used
-	int treat_as_rawstr = R_FALSE;
+	int treat_as_rawstr = false;
 
-	if (!desc) return R_FALSE;
+	if (!desc) return false;
 	if (cf && desc) {
 		int newpid = desc->fd;
 		r_debug_select (r->dbg, newpid, newpid);
@@ -311,9 +311,9 @@ static int r_core_file_do_load_for_debug (RCore *r, ut64 baseaddr, const char *f
 	if (!r_bin_load (r->bin, filenameuri, baseaddr, UT64_MAX, xtr_idx, fd, treat_as_rawstr)) {
 		eprintf ("Cannot open %s\n", filenameuri);
 		if (r_config_get_i (r->config, "bin.rawstr")) {
-			treat_as_rawstr = R_TRUE;
+			treat_as_rawstr = true;
 			if (!r_bin_load (r->bin, filenameuri, baseaddr, UT64_MAX, xtr_idx, desc->fd, treat_as_rawstr)) {
-				return R_FALSE;
+				return false;
 			}
 		}
 	}
@@ -323,7 +323,7 @@ static int r_core_file_do_load_for_debug (RCore *r, ut64 baseaddr, const char *f
 	plugin = r_bin_file_cur_plugin (binfile);
 	if ( plugin && strncmp (plugin->name, "any", 5)==0 ) {
 		// set use of raw strings
-		r_config_set_i (r->config, "io.va", R_FALSE);
+		r_config_set_i (r->config, "io.va", false);
 		//\\ r_config_set (r->config, "bin.rawstr", "true");
 		// get bin.minstr
 		r->bin->minstrlen = r_config_get_i (r->config, "bin.minstr");
@@ -340,7 +340,7 @@ static int r_core_file_do_load_for_debug (RCore *r, ut64 baseaddr, const char *f
 	}
 
 	if (r_config_get_i (r->config, "file.analyze")) r_core_cmd0 (r, "aa");
-	return R_TRUE;
+	return true;
 }
 
 static int r_core_file_do_load_for_io_plugin (RCore *r, ut64 baseaddr, ut64 loadaddr) {
@@ -350,18 +350,18 @@ static int r_core_file_do_load_for_io_plugin (RCore *r, ut64 baseaddr, ut64 load
 	int xtr_idx = 0; // if 0, load all if xtr is used
 	RBinPlugin * plugin;
 
-	if (!desc) return R_FALSE;
+	if (!desc) return false;
 	r_io_use_desc (r->io, desc);
 	if ( !r_bin_load_io (r->bin, desc, baseaddr, loadaddr, xtr_idx)) {
 		//eprintf ("Failed to load the bin with an IO Plugin.\n");
-		return R_FALSE;
+		return false;
 	}
 	binfile = r_bin_cur (r->bin);
 	r_core_bin_set_env (r, binfile);
 	plugin = r_bin_file_cur_plugin (binfile);
 	if ( plugin && strncmp (plugin->name, "any", 5)==0 ) {
 		// set use of raw strings
-		r_config_set_i (r->config, "io.va", R_FALSE);
+		r_config_set_i (r->config, "io.va", false);
 		// r_config_set (r->config, "bin.rawstr", "true");
 		// get bin.minstr
 		r->bin->minstrlen = r_config_get_i (r->config, "bin.minstr");
@@ -372,7 +372,7 @@ static int r_core_file_do_load_for_io_plugin (RCore *r, ut64 baseaddr, ut64 load
 			r_core_bin_set_arch_bits (r, binfile->file,
 				info->arch, info->bits);
 		} else {
-			r_config_set_i (r->config, "io.va", R_FALSE);
+			r_config_set_i (r->config, "io.va", false);
 		}
 	}
 
@@ -382,7 +382,7 @@ static int r_core_file_do_load_for_io_plugin (RCore *r, ut64 baseaddr, ut64 load
 
 	if (r_config_get_i (r->config, "file.analyze"))
 		r_core_cmd0 (r, "aa");
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_bin_load(RCore *r, const char *filenameuri, ut64 baddr) {
@@ -410,7 +410,7 @@ R_API int r_core_bin_load(RCore *r, const char *filenameuri, ut64 baddr) {
 
 	if (!filenameuri) {
 		eprintf ("r_core_bin_load: no file specified\n");
-		return R_FALSE;
+		return false;
 	}
 
 	r->bin->minstrlen = r_config_get_i (r->config, "bin.minstr");
@@ -437,7 +437,7 @@ R_API int r_core_bin_load(RCore *r, const char *filenameuri, ut64 baddr) {
 	if (plugin && plugin->name && !strncmp (plugin->name, "any", 3)) {
 		// set use of raw strings
 		//r_config_set (r->config, "bin.rawstr", "true");
-		r_config_set_i (r->config, "io.va", R_FALSE);
+		r_config_set_i (r->config, "io.va", false);
 		// get bin.minstr
 		r->bin->minstrlen = r_config_get_i (r->config, "bin.minstr");
 	} else if (binfile) {
@@ -455,7 +455,7 @@ R_API int r_core_bin_load(RCore *r, const char *filenameuri, ut64 baddr) {
 	if (r_config_get_i (r->config, "file.analyze")) {
 		r_core_cmd0 (r, "aa");
 	}
-	return R_TRUE;
+	return true;
 }
 
 R_API RIOMap *r_core_file_get_next_map (RCore *core, RCoreFile * fh, int mode, ut64 loadaddr) {
@@ -625,7 +625,7 @@ R_API RCoreFile *r_core_file_open (RCore *r, const char *file, int flags, ut64 l
 }
 
 R_API int r_core_files_free (const RCore *core, RCoreFile *cf) {
-	if (!core || !core->files || !cf) return R_FALSE;
+	if (!core || !core->files || !cf) return false;
 	return r_list_delete_data (core->files, cf);
 }
 
@@ -670,7 +670,7 @@ R_API int r_core_file_close(RCore *r, RCoreFile *fh) {
 	// TODO maybe using sdb to keep track of the allocated and
 	// deallocated files might be a good solutions
 	if (!r || !desc || r_list_empty (r->files))
-		return R_FALSE;
+		return false;
 
 	if (fh == r->file) r->file = NULL;
 
@@ -734,7 +734,7 @@ R_API int r_core_file_list(RCore *core, int mode) {
 			overlapped = r_io_map_overlaps (core->io, f->desc, f->map);
 		} else {
 			from = 0LL;
-			overlapped = R_FALSE;
+			overlapped = false;
 		}
 		switch (mode) {
 		case 'j':
@@ -772,7 +772,7 @@ R_API int r_core_file_bin_raise (RCore *core, ut32 binfile_idx) {
 	RBin *bin = core->bin;
 	int v = binfile_idx > 1 ? binfile_idx : 1;
 	RBinFile *bf = r_list_get_n (bin->binfiles, v);
-	int res = R_FALSE;
+	int res = false;
 	if (bf) {
 		res = r_bin_file_set_cur_binfile (bin, bf);
 		if (res) r_io_raise (core->io, bf->fd);
@@ -790,7 +790,7 @@ R_API int r_core_file_binlist(RCore *core) {
 	RBin *bin = core->bin;
 	const RList *binfiles = bin ? bin->binfiles: NULL;
 
-	if (!binfiles) return R_FALSE;
+	if (!binfiles) return false;
 
 	r_list_foreach (binfiles, iter, binfile) {
 		int fd = binfile->fd;
@@ -820,10 +820,10 @@ R_API int r_core_file_close_fd(RCore *core, int fd) {
 			if (r_list_empty (core->files))
 				core->file = NULL;
 #endif
-			return R_TRUE;
+			return true;
 		}
 	}
-	return R_FALSE;
+	return false;
 }
 
 R_API int r_core_hash_load(RCore *r, const char *file) {
@@ -839,16 +839,16 @@ R_API int r_core_hash_load(RCore *r, const char *file) {
 		file = cf->desc->name;
 	}
 	if (!file) {
-		return R_FALSE;
+		return false;
 	}
 
 	limit = r_config_get_i (r->config, "cfg.hashlimit");
 	if (r_io_desc_size (r->io, cf->desc) > limit)
-		return R_FALSE;
+		return false;
 	buf = (ut8*)r_file_slurp (file, &buf_len);
 	if (buf==NULL)
-		return R_FALSE;
-	ctx = r_hash_new (R_TRUE, R_HASH_MD5);
+		return false;
+	ctx = r_hash_new (true, R_HASH_MD5);
 	md5 = r_hash_do_md5 (ctx, buf, buf_len);
 	p = hash;
 	for (i=0; i<R_HASH_SIZE_MD5; i++) {
@@ -858,7 +858,7 @@ R_API int r_core_hash_load(RCore *r, const char *file) {
 	*p = 0;
 	r_config_set (r->config, "file.md5", hash);
 	r_hash_free (ctx);
-	ctx = r_hash_new (R_TRUE, R_HASH_SHA1);
+	ctx = r_hash_new (true, R_HASH_SHA1);
 	sha1 = r_hash_do_sha1 (ctx, buf, buf_len);
 	p = hash;
 	for (i=0; i<R_HASH_SIZE_SHA1; i++) {
@@ -869,7 +869,7 @@ R_API int r_core_hash_load(RCore *r, const char *file) {
 	r_config_set (r->config, "file.sha1", hash);
 	r_hash_free (ctx);
 	free (buf);
-	return R_TRUE;
+	return true;
 }
 
 R_API RCoreFile * r_core_file_find_by_fd (RCore *core, ut64 fd) {
@@ -913,9 +913,9 @@ R_API int r_core_file_set_by_file (RCore * core, RCoreFile *cf) {
 			r_io_use_desc (core->io, desc);
 			r_core_bin_set_by_fd (core, desc->fd);
 		}
-		return R_TRUE;
+		return true;
 	}
-	return R_FALSE;
+	return false;
 }
 
 R_API ut32 r_core_file_cur_fd (RCore *core) {
diff --git a/libr/core/gdiff.c b/libr/core/gdiff.c
index 32dd51538..4aabe2c1e 100644
--- a/libr/core/gdiff.c
+++ b/libr/core/gdiff.c
@@ -15,12 +15,10 @@ R_API int r_core_gdiff_fcn(RCore *c, ut64 addr, ut64 addr2) {
 	r_list_append (la, fa);
 	lb = r_list_new ();
 	r_list_append (lb, fb);
-
 	r_anal_diff_fcn (c->anal, la, lb);
-
 	r_list_free (la);
 	r_list_free (lb);
-	return R_FALSE;
+	return false;
 }
 
 /* Fingerprint functions and blocks, then diff.
@@ -33,7 +31,7 @@ R_API int r_core_gdiff(RCore *c, RCore *c2, int anal_all) {
 	int i;
 
 	if (!c || !c2)
-		return R_FALSE;
+		return false;
 	for (i = 0; i < 2; i++) {
 		if (anal_all>1)
 			r_core_cmd0 (cores[i], "aac");
@@ -53,7 +51,7 @@ R_API int r_core_gdiff(RCore *c, RCore *c2, int anal_all) {
 	/* Diff functions */
 	r_anal_diff_fcn (cores[0]->anal, cores[0]->anal->fcns, cores[1]->anal->fcns);
 
-	return R_TRUE;
+	return true;
 }
 
 /* copypasta from radiff2 */
diff --git a/libr/core/graph.c b/libr/core/graph.c
index a35c5ff2e..df37369d1 100644
--- a/libr/core/graph.c
+++ b/libr/core/graph.c
@@ -330,11 +330,11 @@ static int layer_sweep (const RGraph *g, const struct layer_t layers[],
 	int **cross_matrix;
 	RGraphNode *u, *v;
 	const RANode *au, *av;
-	int n_rows, j, changed = R_FALSE;
+	int n_rows, j, changed = false;
 	int len = layers[i].n_nodes;
 
 	cross_matrix = get_crossing_matrix (g, layers, maxlayer, i, from_up, &n_rows);
-	if (!cross_matrix) return R_FALSE;
+	if (!cross_matrix) return false;
 
 	for (j = 0; j < len - 1; ++j) {
 		int auidx, avidx;
@@ -350,7 +350,7 @@ static int layer_sweep (const RGraph *g, const struct layer_t layers[],
 			/* swap elements */
 			layers[i].nodes[j] = v;
 			layers[i].nodes[j + 1] = u;
-			changed = R_TRUE;
+			changed = true;
 		}
 	}
 
@@ -457,7 +457,7 @@ static int find_edge (const RGraphEdge *a, const RGraphEdge *b) {
 }
 
 static int is_reversed (const RAGraph *g, const RGraphEdge *e) {
-	return r_list_find (g->back_edges, e, (RListComparator)find_edge) ? R_TRUE : R_FALSE;
+	return r_list_find (g->back_edges, e, (RListComparator)find_edge) ? true : false;
 }
 
 /* add dummy nodes when there are edges that span multiple layers */
@@ -483,7 +483,7 @@ static void create_dummy_nodes (RAGraph *g) {
 		for (i = 1; i < diff_layer; ++i) {
 			RANode *dummy = r_agraph_add_node (g, NULL, NULL);
 			if (!dummy) return;
-			dummy->is_dummy = R_TRUE;
+			dummy->is_dummy = true;
 			dummy->layer = from->layer + i;
 			dummy->is_reversed = is_reversed (g, e);
 			dummy->w = 1;
@@ -535,17 +535,17 @@ static void minimize_crossings (const RAGraph *g) {
 	int i, cross_changed;
 
 	do {
-		cross_changed = R_FALSE;
+		cross_changed = false;
 
 		for (i = 0; i < g->n_layers; ++i)
-			cross_changed |= layer_sweep (g->graph, g->layers, g->n_layers, i, R_TRUE);
+			cross_changed |= layer_sweep (g->graph, g->layers, g->n_layers, i, true);
 	} while (cross_changed);
 
 	do {
-		cross_changed = R_FALSE;
+		cross_changed = false;
 
 		for (i = g->n_layers - 1; i >= 0; --i)
-			cross_changed |= layer_sweep (g->graph, g->layers, g->n_layers, i, R_FALSE);
+			cross_changed |= layer_sweep (g->graph, g->layers, g->n_layers, i, false);
 	} while (cross_changed);
 }
 
@@ -583,7 +583,7 @@ static int dist_nodes (const RAGraph *g, const RGraphNode *a, const RGraphNode *
 			const RGraphNode *next = g->layers[aa->layer].nodes[i + 1];
 			const RANode *anext = get_anode (next);
 			const RANode *acur = get_anode (cur);
-			int found = R_FALSE;
+			int found = false;
 
 			if (g->dists) {
 				d.from = cur;
@@ -592,7 +592,7 @@ static int dist_nodes (const RAGraph *g, const RGraphNode *a, const RGraphNode *
 				if (it) {
 					struct dist_t *old = (struct dist_t *)r_list_iter_get_data (it);
 					res += old->dist;
-					found = R_TRUE;
+					found = true;
 				}
 			}
 
@@ -757,19 +757,19 @@ static void adjust_class (const RAGraph *g, int is_left,
 	const RGraphNode *gn;
 	const RListIter *it;
 	const RANode *an;
-	int dist, v, is_first = R_TRUE;
+	int dist, v, is_first = true;
 
 	graph_foreach_anode (classes[c], it, gn, an) {
 		const RGraphNode *sibling;
 		const RANode *sibl_anode;
 
-		sibling = get_sibling (g, an, is_left, R_TRUE);
+		sibling = get_sibling (g, an, is_left, true);
 		if (!sibling) continue;
 		sibl_anode = get_anode (sibling);
 		if (sibl_anode->klass == c) continue;
 		v = adjust_class_val (g, gn, sibling, res, is_left);
 		dist = is_first ? v : R_MIN (dist, v);
-		is_first = R_FALSE;
+		is_first = false;
 	}
 
 	if (is_first) {
@@ -827,7 +827,7 @@ static int place_nodes_sel_p (int newval, int oldval, int is_first, int is_left)
 static void place_nodes (const RAGraph *g, const RGraphNode *gn, int is_left,
 						 Sdb *v_nodes, RList **classes, Sdb *res, Sdb *placed) {
 	const RList *lv = hash_get_rlist (v_nodes, gn);
-	int p = 0, v, is_first = R_TRUE;
+	int p = 0, v, is_first = true;
 	const RGraphNode *gk;
 	const RListIter *itk;
 	const RANode *ak;
@@ -836,7 +836,7 @@ static void place_nodes (const RAGraph *g, const RGraphNode *gn, int is_left,
 		const RGraphNode *sibling;
 		const RANode *sibl_anode;
 
-		sibling = get_sibling (g, ak, is_left, R_FALSE);
+		sibling = get_sibling (g, ak, is_left, false);
 		if (!sibling) continue;
 		sibl_anode = get_anode (sibling);
 		if (ak->klass == sibl_anode->klass) {
@@ -845,7 +845,7 @@ static void place_nodes (const RAGraph *g, const RGraphNode *gn, int is_left,
 
 			v = place_nodes_val (g, gk, sibling, res, is_left);
 			p = place_nodes_sel_p (v, p, is_first, is_left);
-			is_first = R_FALSE;
+			is_first = false;
 		}
 	}
 
@@ -854,7 +854,7 @@ static void place_nodes (const RAGraph *g, const RGraphNode *gn, int is_left,
 
 	graph_foreach_anode (lv, itk, gk, ak) {
 		hash_set (res, gk, p);
-		hash_set (placed, gk, R_TRUE);
+		hash_set (placed, gk, true);
 	}
 }
 
@@ -903,9 +903,9 @@ static void place_dummies (const RAGraph *g) {
 
 	vertical_nodes = compute_vertical_nodes (g);
 	if (!vertical_nodes) return;
-	xminus = compute_pos (g, R_TRUE, vertical_nodes);
+	xminus = compute_pos (g, true, vertical_nodes);
 	if (!xminus) goto xminus_err;
-	xplus = compute_pos (g, R_FALSE, vertical_nodes);
+	xplus = compute_pos (g, false, vertical_nodes);
 	if (!xplus) goto xplus_err;
 
 	nodes = r_graph_get_nodes (g->graph);
@@ -1114,8 +1114,8 @@ static void combine_sequences (const RAGraph *g, int l,
 	at = get_anode (vt);
 	atp = get_anode (vtp);
 
-	collect_changes (g, l, bm, from_up, a, t, Rm, R_TRUE);
-	collect_changes (g, l, bp, from_up, t, r, Rp, R_FALSE);
+	collect_changes (g, l, bm, from_up, a, t, Rm, true);
+	collect_changes (g, l, bp, from_up, t, r, Rp, false);
 	rm = rp = 0;
 
 	m = dist_nodes (g, vt, vtp);
@@ -1243,7 +1243,7 @@ static void original_traverse_l (const RAGraph *g, Sdb *D, Sdb *P, int from_up)
 				va = bma->pos_in_layer + 1;
 				vr = bpa->pos_in_layer;
 				place_sequence (g, i, bm, bp, from_up, va, vr);
-				hash_set (P, bm, R_TRUE);
+				hash_set (P, bm, true);
 			}
 
 			bm = bp;
@@ -1280,8 +1280,8 @@ static void place_original (RAGraph *g) {
 		}
 	}
 
-	original_traverse_l (g, D, P, R_TRUE);
-	original_traverse_l (g, D, P, R_FALSE);
+	original_traverse_l (g, D, P, true);
+	original_traverse_l (g, D, P, false);
 
 	r_list_free (g->dists);
 	g->dists = NULL;
@@ -1490,7 +1490,7 @@ static int get_bbnodes(RAGraph *g, RCore *core, RAnalFunction *fcn) {
 		free (body);
 		free (title);
 		if (!node) {
-			return R_FALSE;
+			return false;
 		}
 	}
 
@@ -1518,7 +1518,7 @@ static int get_bbnodes(RAGraph *g, RCore *core, RAnalFunction *fcn) {
 		}
 	}
 
-	return R_TRUE;
+	return true;
 }
 
 /* build the RGraph inside the RAGraph g, starting from the Call Graph
@@ -1535,7 +1535,7 @@ static int get_cgnodes(RAGraph *g, RCore *core, RAnalFunction *fcn) {
 
 	free (title);
 	if (!fcn_anode)
-		return R_FALSE;
+		return false;
 
 	fcn_anode->x = 10;
 	fcn_anode->y = 3;
@@ -1564,7 +1564,7 @@ static int get_cgnodes(RAGraph *g, RCore *core, RAnalFunction *fcn) {
 
 		node = r_agraph_add_node (g, title, body);
 		if (!node)
-			return R_FALSE;
+			return false;
 		free (title);
 		free (body);
 
@@ -1578,7 +1578,7 @@ static int get_cgnodes(RAGraph *g, RCore *core, RAnalFunction *fcn) {
 	eprintf ("Must be sdbized\n");
 #endif
 
-	return R_TRUE;
+	return true;
 }
 
 static int reload_nodes(RAGraph *g, RCore *core, RAnalFunction *fcn) {
@@ -1590,7 +1590,7 @@ static int reload_nodes(RAGraph *g, RCore *core, RAnalFunction *fcn) {
 
 static void update_seek(RConsCanvas *can, RANode *n, int force) {
 	int x, y, w, h;
-	int doscroll = R_FALSE;
+	int doscroll = false;
 
 	if (!n) return;
 
@@ -1748,7 +1748,7 @@ static void agraph_set_layout(RAGraph *g, int is_interactive) {
 	set_layout(g);
 
 	if (is_interactive)
-		set_curnode (g, find_near_of (g, NULL, R_TRUE));
+		set_curnode (g, find_near_of (g, NULL, true));
 	update_graph_sizes (g);
 	graph_foreach_anode (r_graph_get_nodes (g->graph), it, n, a) {
 		const char *k;
@@ -1807,7 +1807,7 @@ static void agraph_print_edge(const RAGraph *g, RANode *a, RANode *b, int nth) {
 	int xinc;
 	RListIter *it;
 	AEdge e, *edg = NULL;
-	int is_first = R_TRUE;
+	int is_first = true;
 	RCanvasLineStyle style;
 
 	xinc = 4 + 2 * (nth + 1);
@@ -1845,7 +1845,7 @@ static void agraph_print_edge(const RAGraph *g, RANode *a, RANode *b, int nth) {
 			x = x2;
 			y = y2;
 			style.symbol = LINE_NONE;
-			is_first = R_FALSE;
+			is_first = false;
 		}
 	}
 
@@ -1891,26 +1891,26 @@ static void agraph_print_edges(const RAGraph *g) {
 
 static void agraph_toggle_small_nodes(RAGraph *g) {
 	g->is_small_nodes = !g->is_small_nodes;
-	g->need_update_dim = R_TRUE;
-	g->need_set_layout = R_TRUE;
+	g->need_update_dim = true;
+	g->need_set_layout = true;
 }
 
 static void agraph_toggle_simple_mode(RAGraph *g) {
 	g->is_simple_mode = !g->is_simple_mode;
-	g->need_reload_nodes = R_TRUE;
+	g->need_reload_nodes = true;
 }
 
 static void agraph_toggle_callgraph(RAGraph *g) {
 	g->is_callgraph = !g->is_callgraph;
-	g->need_reload_nodes = R_TRUE;
-	g->force_update_seek = R_TRUE;
+	g->need_reload_nodes = true;
+	g->force_update_seek = true;
 }
 
 static void agraph_set_zoom (RAGraph *g, int v) {
 	g->is_small_nodes = v <= 0;
 	g->zoom = R_MAX (0, v);
-	g->need_update_dim = R_TRUE;
-	g->need_set_layout = R_TRUE;
+	g->need_update_dim = true;
+	g->need_set_layout = true;
 }
 
 /* reload all the info in the nodes, depending on the type of the graph
@@ -1931,12 +1931,12 @@ static void follow_nth(RAGraph *g, int nth) {
 
 static void agraph_follow_true(RAGraph *g) {
 	follow_nth(g, 0);
-	agraph_update_seek(g, get_anode (g->curnode), R_FALSE);
+	agraph_update_seek(g, get_anode (g->curnode), false);
 }
 
 static void agraph_follow_false(RAGraph *g) {
 	follow_nth(g, 1);
-	agraph_update_seek(g, get_anode (g->curnode), R_FALSE);
+	agraph_update_seek(g, get_anode (g->curnode), false);
 }
 
 /* go back in the history of selected nodes, if we can */
@@ -1944,7 +1944,7 @@ static void agraph_undo_node(RAGraph *g) {
 	const RGraphNode *p = history_pop (g->history);
 	if (p) {
 		set_curnode (g, p);
-		agraph_update_seek (g, p->data, R_FALSE);
+		agraph_update_seek (g, p->data, false);
 	}
 }
 
@@ -1952,16 +1952,16 @@ static void agraph_undo_node(RAGraph *g) {
  * the order given by r_graph_get_nodes */
 static void agraph_next_node(RAGraph *g) {
 	history_push (g->history, g->curnode);
-	set_curnode (g, find_near_of (g, g->curnode, R_TRUE));
-	agraph_update_seek (g, get_anode (g->curnode), R_FALSE);
+	set_curnode (g, find_near_of (g, g->curnode, true));
+	agraph_update_seek (g, get_anode (g->curnode), false);
 }
 
 /* pushes the current node in the history and makes g->curnode the prev node in
  * the order given by r_graph_get_nodes */
 static void agraph_prev_node(RAGraph *g) {
 	history_push (g->history, g->curnode);
-	set_curnode (g, find_near_of (g, g->curnode, R_FALSE));
-	agraph_update_seek (g, get_anode (g->curnode), R_FALSE);
+	set_curnode (g, find_near_of (g, g->curnode, false));
+	agraph_update_seek (g, get_anode (g->curnode), false);
 }
 
 static void agraph_update_title (RAGraph *g, RAnalFunction *fcn) {
@@ -1980,7 +1980,7 @@ static int check_changes (RAGraph *g, int is_interactive,
 		RCore *core, RAnalFunction *fcn) {
 	if (g->need_reload_nodes && core) {
 		int ret = agraph_reload_nodes (g, core, fcn);
-		if (!ret) return R_FALSE;
+		if (!ret) return false;
 	}
 	if (fcn)
 		agraph_update_title (g, fcn);
@@ -1994,12 +1994,12 @@ static int check_changes (RAGraph *g, int is_interactive,
 		if (n) update_seek(g->can, n, g->force_update_seek);
 	}
 
-	g->need_reload_nodes = R_FALSE;
-	g->need_update_dim = R_FALSE;
-	g->need_set_layout = R_FALSE;
+	g->need_reload_nodes = false;
+	g->need_update_dim = false;
+	g->need_set_layout = false;
 	g->update_seek_on = NULL;
-	g->force_update_seek = R_FALSE;
-	return R_TRUE;
+	g->force_update_seek = false;
+	return true;
 }
 
 static int agraph_print (RAGraph *g, int is_interactive,
@@ -2009,7 +2009,7 @@ static int agraph_print (RAGraph *g, int is_interactive,
 	int ret;
 
 	ret = check_changes (g, is_interactive, core, fcn);
-	if (!ret) return R_FALSE;
+	if (!ret) return false;
 
 	if (is_interactive) {
 		r_cons_clear00 ();
@@ -2037,7 +2037,7 @@ static int agraph_print (RAGraph *g, int is_interactive,
 	title_len = strlen (g->title);
 	if (is_interactive)
 		r_cons_canvas_fill (g->can, -g->can->sx + title_len, -g->can->sy,
-				w - title_len, 1, ' ', R_TRUE);
+				w - title_len, 1, ' ', true);
 
 	r_cons_canvas_print_region (g->can);
 
@@ -2051,7 +2051,7 @@ static int agraph_print (RAGraph *g, int is_interactive,
 		}
 	}
 	r_cons_flush ();
-	return R_TRUE;
+	return true;
 }
 
 static int agraph_refresh(struct agraph_refresh_data *grd) {
@@ -2067,8 +2067,8 @@ static int agraph_refresh(struct agraph_refresh_data *grd) {
 	f = r_anal_get_fcn_in (core->anal, core->offset, 0);
 	if (f && f != *fcn) {
 		*fcn = f;
-		g->need_reload_nodes = R_TRUE;
-		g->force_update_seek = R_TRUE;
+		g->need_reload_nodes = true;
+		g->force_update_seek = true;
 	}
 
 	return agraph_print (g, grd->fs, core, *fcn);
@@ -2080,12 +2080,12 @@ static void agraph_toggle_speed (RAGraph *g, RCore *core) {
 }
 
 static void agraph_init(RAGraph *g) {
-	g->is_callgraph = R_FALSE;
-	g->is_instep = R_FALSE;
-	g->is_simple_mode = R_TRUE;
-	g->is_small_nodes = R_FALSE;
-	g->need_reload_nodes = R_TRUE;
-	g->force_update_seek = R_TRUE;
+	g->is_callgraph = false;
+	g->is_instep = false;
+	g->is_simple_mode = true;
+	g->is_small_nodes = false;
+	g->need_reload_nodes = true;
+	g->force_update_seek = true;
 	g->color_box = Color_RESET;
 	g->color_box2 = Color_BLUE; // selected node
 	g->color_box3 = Color_MAGENTA;
@@ -2131,14 +2131,14 @@ static void agraph_sdb_init (const RAGraph *g) {
 }
 
 R_API Sdb *r_agraph_get_sdb (RAGraph *g) {
-	g->need_update_dim = R_TRUE;
-	g->need_set_layout = R_TRUE;
-	check_changes (g, R_FALSE, NULL, NULL);
+	g->need_update_dim = true;
+	g->need_set_layout = true;
+	check_changes (g, false, NULL, NULL);
 	return g->db;
 }
 
 R_API void r_agraph_print (RAGraph *g) {
-	agraph_print (g, R_FALSE, NULL, NULL);
+	agraph_print (g, false, NULL, NULL);
 	if (g->graph->n_nodes > 0)
 		r_cons_newline ();
 }
@@ -2158,8 +2158,8 @@ R_API RANode *r_agraph_add_node (const RAGraph *g, const char *title, const char
 	res->body = body ? strdup(body) : strdup("");
 	res->layer = -1;
 	res->pos_in_layer = -1;
-	res->is_dummy = R_FALSE;
-	res->is_reversed = R_FALSE;
+	res->is_dummy = false;
+	res->is_reversed = false;
 	res->klass = -1;
 	res->gnode = r_graph_add_node (g->graph, res);
 	sdb_num_set (g->nodes, title, (ut64)(size_t)res, 0);
@@ -2299,7 +2299,7 @@ static void visual_offset (RCore *core) {
 }
 
 R_API int r_core_visual_graph(RCore *core, RAnalFunction *_fcn, int is_interactive) {
-	int exit_graph = R_FALSE, is_error = R_FALSE;
+	int exit_graph = false, is_error = false;
 	struct agraph_refresh_data *grd;
 	int okey, key, wheel;
 	RAnalFunction *fcn;
@@ -2314,20 +2314,20 @@ R_API int r_core_visual_graph(RCore *core, RAnalFunction *_fcn, int is_interacti
 	fcn = _fcn ? _fcn : r_anal_get_fcn_in (core->anal, core->offset, 0);
 	if (!fcn) {
 		eprintf ("No function in current seek\n");
-		return R_FALSE;
+		return false;
 	}
 	w = r_cons_get_size (&h);
 	can = r_cons_canvas_new (w, h);
 	if (!can) {
 		eprintf ("Cannot create RCons.canvas context\n");
-		return R_FALSE;
+		return false;
 	}
 	can->linemode = 1;
 	can->color = r_config_get_i (core->config, "scr.color");
 
 	g = r_agraph_new (can);
 	if (!g) {
-		is_error = R_TRUE;
+		is_error = true;
 		goto err_graph_new;
 	}
 	g->movspeed = r_config_get_i (core->config, "graph.scroll");
@@ -2347,11 +2347,11 @@ R_API int r_core_visual_graph(RCore *core, RAnalFunction *_fcn, int is_interacti
 
 			free (bbtitle);
 			set_curnode (g, an->gnode);
-			agraph_update_seek (g, an, R_TRUE);
+			agraph_update_seek (g, an, true);
 		}
 	} else {
 		r_cons_newline ();
-		exit_graph = R_TRUE;
+		exit_graph = true;
 		is_error = !ret;
 	}
 
@@ -2362,14 +2362,14 @@ R_API int r_core_visual_graph(RCore *core, RAnalFunction *_fcn, int is_interacti
 		invscroll = r_config_get_i (core->config, "graph.invscroll");
 		ret = agraph_refresh (grd);
 		if (!ret) {
-			is_error = R_TRUE;
+			is_error = true;
 			break;
 		}
 
-		r_cons_show_cursor(R_FALSE);
+		r_cons_show_cursor(false);
 		wheel = r_config_get_i (core->config, "scr.wheel");
 		if (wheel)
-			r_cons_enable_mouse (R_TRUE);
+			r_cons_enable_mouse (true);
 
 		// r_core_graph_inputhandle()
 		okey = r_cons_readchar ();
@@ -2397,7 +2397,7 @@ R_API int r_core_visual_graph(RCore *core, RAnalFunction *_fcn, int is_interacti
 			break;
 		case '0':
 			agraph_set_zoom (g, ZOOM_DEFAULT);
-			agraph_update_seek (g, get_anode (g->curnode), R_TRUE);
+			agraph_update_seek (g, get_anode (g->curnode), true);
 			break;
 		case '|':
 			{ // TODO: edit
@@ -2417,7 +2417,7 @@ R_API int r_core_visual_graph(RCore *core, RAnalFunction *_fcn, int is_interacti
 			agraph_toggle_callgraph(g);
 			break;
 		case 'z':
-			g->is_instep = R_TRUE;
+			g->is_instep = true;
 			key_s = r_config_get (core->config, "key.s");
 			if (key_s && *key_s) {
 				r_core_cmd0 (core, key_s);
@@ -2427,27 +2427,27 @@ R_API int r_core_visual_graph(RCore *core, RAnalFunction *_fcn, int is_interacti
 				else
 					r_core_cmd0 (core, "aes;.dr*");
 			}
-			g->need_reload_nodes = R_TRUE;
+			g->need_reload_nodes = true;
 			break;
 		case 'Z':
 			if (okey == 27) {
 				agraph_prev_node(g);
 			} else {
 				// 'Z'
-				g->is_instep = R_TRUE;
+				g->is_instep = true;
 				if (r_config_get_i (core->config, "cfg.debug"))
 					r_core_cmd0 (core, "dso;.dr*");
 				else r_core_cmd0 (core, "aeso;.dr*");
-				g->need_reload_nodes = R_TRUE;
+				g->need_reload_nodes = true;
 			}
 			break;
 		case 'x':
 			if (r_core_visual_xrefs_x (core))
-				exit_graph = R_TRUE;
+				exit_graph = true;
 			break;
 		case 'X':
 			if (r_core_visual_xrefs_X (core))
-				exit_graph = R_TRUE;
+				exit_graph = true;
 			break;
 		case 9: // tab
 			agraph_next_node (g);
@@ -2512,11 +2512,11 @@ R_API int r_core_visual_graph(RCore *core, RAnalFunction *_fcn, int is_interacti
 			/* TODO: remove this option once the colored are "stable" */
 			int colors = r_config_get_i (core->config, "scr.color");
 			r_config_set_i (core->config, "scr.color", !colors);
-			g->need_reload_nodes = R_TRUE;
+			g->need_reload_nodes = true;
 			break;
 		}
 		case 'r':
-			agraph_set_layout (g, R_TRUE);
+			agraph_set_layout (g, true);
 			break;
 		case 'm':
 			mousemode++;
@@ -2541,14 +2541,14 @@ R_API int r_core_visual_graph(RCore *core, RAnalFunction *_fcn, int is_interacti
 			  break;
 		case 'p':
 			  agraph_toggle_small_nodes (g);
-			  agraph_update_seek (g, get_anode (g->curnode), R_TRUE);
+			  agraph_update_seek (g, get_anode (g->curnode), true);
 			  break;
 		case 'b':
 			  agraph_undo_node(g);
 			  break;
 		case '.':
-			  agraph_update_seek (g, get_anode (g->curnode), R_TRUE);
-			  g->is_instep = R_TRUE;
+			  agraph_update_seek (g, get_anode (g->curnode), true);
+			  g->is_instep = true;
 			  break;
 		case 't':
 			  agraph_follow_true (g);
@@ -2560,9 +2560,9 @@ R_API int r_core_visual_graph(RCore *core, RAnalFunction *_fcn, int is_interacti
 			  r_core_cmd0 (core, "?i highlight;e scr.highlight=`?y`");
 			  break;
 		case ':':
-			  core->vmode = R_FALSE;
+			  core->vmode = false;
 			  r_core_visual_prompt_input (core);
-			  core->vmode = R_TRUE;
+			  core->vmode = true;
 			  break;
 		case 'w':
 			  agraph_toggle_speed (g, core);
@@ -2578,7 +2578,7 @@ R_API int r_core_visual_graph(RCore *core, RAnalFunction *_fcn, int is_interacti
 				  char *cmd = r_str_newf ("s %s", n->title);
 				  r_core_cmd0 (core, cmd);
 				  free (cmd);
-				  exit_graph = R_TRUE;
+				  exit_graph = true;
 			  }
 			  break;
 		case 27: // ESC
diff --git a/libr/core/hack.c b/libr/core/hack.c
index cac34fe31..c5452c743 100644
--- a/libr/core/hack.c
+++ b/libr/core/hack.c
@@ -21,13 +21,13 @@ R_API int r_core_hack_arm(RCore *core, const char *op, RAnalOp *analop) {
 		int len = analop->size;
 		if (len%nopsize) {
 			eprintf ("Invalid nopcode size\n");
-			return R_FALSE;
+			return false;
 		}
 		r_cons_puts ("wx ");
 		do r_cons_puts (nopcode);
 		while (len -= nopsize);
 		r_cons_puts ("\n");
-		return R_TRUE;
+		return true;
 	} else
 	if (!strcmp (op, "jz")) {
 		if (bits == 16) {
@@ -92,7 +92,7 @@ R_API int r_core_hack_arm(RCore *core, const char *op, RAnalOp *analop) {
 	if (!strcmp (op, "swap-cjmp")) {
 		eprintf ("TODO: use jnz or jz\n");
 	} else eprintf ("Invalid operation\n");
-	return R_FALSE;
+	return false;
 }
 
 R_API int r_core_hack_x86(RCore *core, const char *op, RAnalOp *analop) {
@@ -103,31 +103,31 @@ R_API int r_core_hack_x86(RCore *core, const char *op, RAnalOp *analop) {
 		int len = analop->size;
 		if (len%nopsize) {
 			eprintf ("Invalid nopcode size\n");
-			return R_FALSE;
+			return false;
 		}
 		r_cons_puts ("wx ");
 		do r_cons_puts (nopcode);
 		while (len-=nopsize);
 		r_cons_puts ("\n");
-		return R_TRUE;
+		return true;
 	} else
 	if (!strcmp (op, "jz")) {
 		if (b[0] == 0x75) {
 			r_cons_puts ("wx 74\n");
-			return R_TRUE;
+			return true;
 		} else eprintf ("Current opcode is not conditional\n");
 	} else
 	if (!strcmp (op, "jnz")) {
 		if (b[0] == 0x74) {
 			r_cons_puts ("wx 75\n");
-			return R_TRUE;
+			return true;
 		} else eprintf ("Current opcode is not conditional\n");
-		return R_TRUE;
+		return true;
 	} else
 	if (!strcmp (op, "un-cjmp")) {
 		if (b[0] >= 0x70 && b[0] <= 0x7f) {
 			r_cons_puts ("wx eb\n");
-			return R_TRUE;
+			return true;
 		} else eprintf ("Current opcode is not conditional\n");
 	} else
 	if (!strcmp (op, "swap-cjmp")) {
@@ -139,13 +139,13 @@ R_API int r_core_hack_x86(RCore *core, const char *op, RAnalOp *analop) {
 		else eprintf ("Invalid opcode\n");
 		// XXX. add support for jb, jg, jl, ..
 	} else eprintf ("Invalid operation\n");
-	return R_FALSE;
+	return false;
 }
 
 // TODO: needs refactoring to make it cross-architecture
 R_API int r_core_hack(RCore *core, const char *op) {
 	int (*hack)(RCore *core, const char *op, RAnalOp *analop) = NULL;
-	int ret = R_FALSE;
+	int ret = false;
 	RAnalOp analop;
 	const char *asmarch = r_config_get (core->config, "asm.arch");
 	if (strstr (asmarch, "x86")) {
@@ -159,7 +159,7 @@ R_API int r_core_hack(RCore *core, const char *op) {
 		if (!r_anal_op (core->anal, &analop, core->offset,
 				core->block, core->blocksize)) {
 			eprintf ("anal op fail\n");
-			return R_FALSE;
+			return false;
 		}
 		ret = hack (core, op, &analop);
 	}
diff --git a/libr/core/io.c b/libr/core/io.c
index 2824984f1..481cfa71b 100644
--- a/libr/core/io.c
+++ b/libr/core/io.c
@@ -10,7 +10,7 @@ R_API int r_core_setup_debugger (RCore *r, const char *debugbackend) {
 	r_config_set_i (r->config, "cfg.debug", 1);
 	if (!p) {
 		eprintf ("Invalid debug io\n");
-		return R_FALSE;
+		return false;
 	}
 
 	pid = *p; // 1st element in debugger's struct must be int
@@ -37,7 +37,7 @@ R_API int r_core_setup_debugger (RCore *r, const char *debugbackend) {
 		r_config_set (r->config, "cmd.prompt", ".dr* ; drd ; sr pc;pi 1;s-");
 	} else r_config_set (r->config, "cmd.prompt", ".dr*");
 	r_config_set (r->config, "cmd.vprompt", ".dr*");
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_seek_base (RCore *core, const char *hex) {
@@ -61,7 +61,7 @@ R_API int r_core_seek_base (RCore *core, const char *hex) {
 		free (p);
 	}
 	if (!n) {
-		return R_FALSE;
+		return false;
 	}
 	mask = UT64_MAX << i;
 	addr = (addr & mask) | n;
@@ -81,7 +81,7 @@ R_API int r_core_dump(RCore *core, const char *file, ut64 addr, ut64 size, int a
 	}
 	if (!fd) {
 		eprintf ("Cannot open '%s' for writing\n", file);
-		return R_FALSE;
+		return false;
 	}
 	/* some io backends seems to be buggy in those cases */
 	if (bs > 4096)
@@ -90,7 +90,7 @@ R_API int r_core_dump(RCore *core, const char *file, ut64 addr, ut64 size, int a
 	if (!buf) {
 		eprintf ("Cannot alloc %d bytes\n", bs);
 		fclose (fd);
-		return R_FALSE;
+		return false;
 	}
 	r_cons_break (NULL, NULL);
 	for (i = 0; i<size; i += bs) {
@@ -108,11 +108,11 @@ R_API int r_core_dump(RCore *core, const char *file, ut64 addr, ut64 size, int a
 	r_cons_break_end ();
 	fclose (fd);
 	free (buf);
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_write_op(RCore *core, const char *arg, char op) {
-	int i, j, len, ret = R_FALSE;
+	int i, j, len, ret = false;
 	char *str;
 	ut8 *buf;
 
@@ -285,11 +285,11 @@ R_API boolt r_core_seek(RCore *core, ut64 addr, boolt rb) {
 		   XXX handle read errors correctly
 		   if (core->io->ff) {
 		   core->offset = addr;
-		   } else return R_FALSE;
+		   } else return false;
 		 */
 		//core->offset = addr;
 		if (!core->io->va)
-			return R_FALSE;
+			return false;
 		//memset (core->block, 0xff, core->blocksize);
 	} else core->offset = addr;
 	if (rb) {
@@ -311,14 +311,14 @@ R_API boolt r_core_seek(RCore *core, ut64 addr, boolt rb) {
 		r_core_seek_archbits (core, core->offset);
 		core->section = newsection;
 	}
-	return (ret==-1)? R_FALSE: R_TRUE;
+	return (ret==-1)? false: true;
 }
 
 R_API int r_core_seek_delta(RCore *core, st64 addr) {
 	ut64 tmp = core->offset;
 	int ret;
 	if (addr == 0)
-		return R_TRUE;
+		return true;
 	if (addr>0LL) {
 		/* check end of file */
 		if (0) addr = 0;
@@ -340,20 +340,20 @@ R_API int r_core_seek_delta(RCore *core, st64 addr) {
 R_API int r_core_write_at(RCore *core, ut64 addr, const ut8 *buf, int size) {
 	int ret;
 	if (!core->io || !core->file || size<1)
-		return R_FALSE;
+		return false;
 	ret = r_io_use_desc (core->io, core->file->desc);
 	if (ret != -1) {
 		ret = r_io_write_at (core->io, addr, buf, size);
 		if (addr >= core->offset && addr <= core->offset+core->blocksize)
 			r_core_block_read (core, 0);
 	}
-	return (ret==-1)? R_FALSE: R_TRUE;
+	return (ret==-1)? false: true;
 }
 
 R_API int r_core_extend_at(RCore *core, ut64 addr, int size) {
 	int ret;
 	if (!core->io || !core->file || size<1)
-		return R_FALSE;
+		return false;
 	//ret = r_io_use_fd (core->io, core->file->desc->fd);
 	ret = r_io_use_desc (core->io, core->file->desc);
 	if (ret != -1) {
@@ -361,14 +361,14 @@ R_API int r_core_extend_at(RCore *core, ut64 addr, int size) {
 		if (addr >= core->offset && addr <= core->offset+core->blocksize)
 			r_core_block_read (core, 0);
 	}
-	return (ret==-1)? R_FALSE: R_TRUE;
+	return (ret==-1)? false: true;
 }
 
 R_API int r_core_shift_block(RCore *core, ut64 addr, ut64 b_size, st64 dist) {
 	// bstart - block start, fstart file start
 	ut64 fend = 0, fstart = 0, bstart = 0, file_sz = 0;
 	ut8 * shift_buf = NULL;
-	int res = R_FALSE;
+	int res = false;
 
 	if (b_size == 0 || b_size == (ut64) -1) {
 		res = r_io_use_desc (core->io, core->file->desc);
@@ -381,7 +381,7 @@ R_API int r_core_shift_block(RCore *core, ut64 addr, ut64 b_size, st64 dist) {
 
 
 	if (!core->io || !core->file || b_size<1)
-		return R_FALSE;
+		return false;
 
 
 	// XXX handling basic cases atm
@@ -391,24 +391,24 @@ R_API int r_core_shift_block(RCore *core, ut64 addr, ut64 b_size, st64 dist) {
 	// cases
 	// addr + b_size + dist > file_end
 	//if ( (addr+b_size) + dist > file_end ) {
-	//	res = R_FALSE;
+	//	res = false;
 	//}
 	// addr + b_size + dist < file_start (should work since dist is signed)
 	//else if ( (addr+b_size) + dist < 0 ) {
-	//	res = R_FALSE;
+	//	res = false;
 	//}
 	// addr + dist < file_start
 	if ( addr + dist < fstart ) {
-		res = R_FALSE;
+		res = false;
 	}
 	// addr + dist > file_end
 	else if ( (addr) + dist > fend) {
-		res = R_FALSE;
+		res = false;
 	} else {
 		res = r_io_use_desc (core->io, core->file->desc);
 		r_io_read_at (core->io, addr, shift_buf, b_size);
 		r_io_write_at (core->io, addr+dist, shift_buf, b_size);
-		res = R_TRUE;
+		res = true;
 	}
 
 	r_core_seek (core, addr, 1);
@@ -447,7 +447,7 @@ R_API int r_core_read_at(RCore *core, ut64 addr, ut8 *buf, int size) {
 	if (!core->io || !core->file || !core->file->desc || size<1) {
 		if (size>0)
 			memset (buf, 0xff, size);
-		return R_FALSE;
+		return false;
 	}
 	r_io_use_desc (core->io, core->file->desc);
 	return r_io_read_at (core->io, addr, buf, size);
diff --git a/libr/core/libs.c b/libr/core/libs.c
index 8970f13a0..c31182deb 100644
--- a/libr/core/libs.c
+++ b/libr/core/libs.c
@@ -8,9 +8,9 @@ static int __lib_##x##_cb(RLibPlugin *pl, void *user, void *data) { \
 	struct r_##x##_plugin_t *hand = (struct r_##x##_plugin_t *)data; \
 	RCore *core = (RCore *)user; \
 	r_##x##_add (core->y, hand); \
-	return R_TRUE; \
+	return true; \
 }\
-static int __lib_##x##_dt(RLibPlugin *pl, void *p, void *u) { return R_TRUE; }
+static int __lib_##x##_dt(RLibPlugin *pl, void *p, void *u) { return true; }
 
 // XXX api consistency issues
 #define r_io_add r_io_plugin_add
@@ -47,7 +47,7 @@ R_API int r_core_loadlibs(RCore *core, int where, const char *path) {
 #if R2_LOADLIBS
 	/* TODO: all those default plugin paths should be defined in r_lib */
 	if (!r_config_get_i (core->config, "cfg.plugins")) {
-		return R_FALSE;
+		return false;
 	}
 	if (!where) where = -1;
 	if (path) r_lib_opendir (core->lib, path);
@@ -69,5 +69,5 @@ R_API int r_core_loadlibs(RCore *core, int where, const char *path) {
 		r_lib_opendir (core->lib, R2_LIBDIR"/radare2-bindings/"R2_VERSION);
 	}
 #endif
-	return R_TRUE;
+	return true;
 }
diff --git a/libr/core/p/core_anal.c b/libr/core/p/core_anal.c
index 57d0c969c..b903d2efa 100644
--- a/libr/core/p/core_anal.c
+++ b/libr/core/p/core_anal.c
@@ -1,4 +1,4 @@
-/* radare - Copyright 2014 pancake */
+/* radare - Copyright 2014-2015 pancake */
 
 #include <r_types.h>
 #include <r_core.h>
@@ -98,7 +98,7 @@ ut64 analyzeIterative (RCore *core, Sdb *db, ut64 addr) {
 		op = r_core_anal_op (core, addr + cur);
 		if (!op) {
 			eprintf ("Cannot analyze opcode at %"PFMT64d"\n", addr+cur);
-			return R_FALSE;
+			return false;
 		}
 		eprintf ("0x%08"PFMT64x"  %s\n", addr + cur, op->mnemonic);
 
@@ -203,13 +203,13 @@ static int analyzeFunction (RCore *core, ut64 addr) {
 	Sdb *db = sdb_new0 ();
 	if (!db) {
 		eprintf ("Cannot create db\n");
-		return R_FALSE;
+		return false;
 	}
 
 	addr = analyzeIterative (core, db, addr);
 	if (addr == UT64_MAX) {
 		eprintf ("Initial analysis failed\n");
-		return R_FALSE;
+		return false;
 	}
 	sdb_num_set (db, "addr", addr, 0);
 
@@ -313,7 +313,7 @@ static int analyzeFunction (RCore *core, ut64 addr) {
 		free (calls);
 	}
 	sdb_free (db);
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_anal_call(void *user, const char *input) {
@@ -329,9 +329,9 @@ static int r_cmd_anal_call(void *user, const char *input) {
 			eprintf ("Usage: a2f\n");
 			break;
 		}
-		return R_TRUE;
+		return true;
 	}
-	return R_FALSE;
+	return false;
 }
 
 // PLUGIN Definition Info
diff --git a/libr/core/p/core_java.c b/libr/core/p/core_java.c
index 616cf295a..4acb69ade 100644
--- a/libr/core/p/core_java.c
+++ b/libr/core/p/core_java.c
@@ -290,11 +290,11 @@ enum {
 };
 
 static ut8 _(r_cmd_java_obj_ref)(const char *name, const char *class_name, ut32 len) {
-	if (!name || !class_name) return R_FALSE;
-	if (strncmp (class_name, name, len)) return R_FALSE;
-	if (*(name-1) == 'L' && *(name+len) == ';') return R_TRUE;
-	if (!strncmp (class_name, name, len) && !*(name+len)) return R_TRUE;
-	return R_FALSE;
+	if (!name || !class_name) return false;
+	if (strncmp (class_name, name, len)) return false;
+	if (*(name-1) == 'L' && *(name+len) == ';') return true;
+	if (!strncmp (class_name, name, len) && !*(name+len)) return true;
+	return false;
 }
 
 static const char * r_cmd_get_next_classname_str (const char * str, const char *match_me) {
@@ -381,7 +381,7 @@ static int r_cmd_java_handle_help (RCore * core, const char * input) {
 	help_msg[3+(i*3)] = NULL;
 	r_core_cmd_help (core, help_msg);
 	free (help_msg);
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_handle_prototypes (RCore *core, const char *cmd) {
@@ -391,7 +391,7 @@ static int r_cmd_java_handle_prototypes (RCore *core, const char *cmd) {
 
 	if (!obj) {
 		eprintf ("[-] r_cmd_java: no valid java bins found.\n");
-		return R_TRUE;
+		return true;
 	}
 
 	switch (*(cmd)) {
@@ -402,7 +402,7 @@ static int r_cmd_java_handle_prototypes (RCore *core, const char *cmd) {
 	case 'a': return r_cmd_java_print_all_definitions (anal);
 	case 'j': return r_cmd_java_print_json_definitions (obj);
 	}
-	return R_FALSE;
+	return false;
 }
 
 static int r_cmd_java_handle_summary_info (RCore *core, const char *cmd) {
@@ -412,7 +412,7 @@ static int r_cmd_java_handle_summary_info (RCore *core, const char *cmd) {
 
 	if (!obj) {
 		eprintf ("[-] r_cmd_java: no valid java bins found.\n");
-		return R_TRUE;
+		return true;
 	}
 
 	r_cons_printf ("Summary for %s:\n", obj->file);
@@ -423,7 +423,7 @@ static int r_cmd_java_handle_summary_info (RCore *core, const char *cmd) {
 	r_cons_printf ("  Attributes size: 0x%"PFMT64x" count: %d:\n", obj->attrs_size, obj->attrs_count);
 	r_cons_printf ("  Interfaces size: 0x%"PFMT64x" count: %d:\n", obj->interfaces_size, obj->interfaces_count);
 
-	return R_TRUE;
+	return true;
 }
 
 static int _(r_cmd_java_check_op_idx) (const ut8 *op_bytes, ut16 idx) {
@@ -471,7 +471,7 @@ static int cpfind (RCore *core, const char *cmd) {
 
 	if (!obj) {
 		eprintf ("[-] r_cmd_java: no valid java bins found.\n");
-		return R_TRUE;
+		return true;
 	}
 	IFDBG r_cons_printf ("Function call made: %s\n", p);
 	if (p && *p) {
@@ -488,7 +488,7 @@ static int cpfind (RCore *core, const char *cmd) {
 	case 'd': find_list = cpfind_double (core, obj, r_cmd_java_consumetok (p, ' ', -1)); break;
 	default:
 		eprintf ("[-] r_cmd_java: invalid java type to search for.\n");
-		return R_TRUE;
+		return true;
 	}
 
 	r_list_foreach (find_list, iter, idx) {
@@ -496,14 +496,14 @@ static int cpfind (RCore *core, const char *cmd) {
 		r_cons_printf ("Offset: 0x%"PFMT64x" idx: %d\n", addr, *idx);
 	}
 	r_list_free (find_list);
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_reload_bin_from_buf (RCore *core, RBinJavaObj *obj, ut8* buffer, ut64 len) {
-	if (!buffer || len < 10) return R_FALSE;
+	if (!buffer || len < 10) return false;
 	int res = r_bin_java_load_bin (obj, buffer, len);
 
-	if (res == R_TRUE) {
+	if (res == true) {
 		//RBinPlugin *cp = NULL;
 		RBinPlugin *tmp;
 		RListIter *iter;
@@ -522,7 +522,7 @@ static int r_cmd_java_reload_bin_from_buf (RCore *core, RBinJavaObj *obj, ut8* b
 }
 
 static int r_cmd_java_get_cp_bytes_and_write (RCore *core, RBinJavaObj *obj, ut16 idx, ut64 addr, const ut8 * buf, const ut64 len) {
-	int res = R_FALSE;
+	int res = false;
 	RBinJavaCPTypeObj *cp_obj = r_bin_java_get_item_from_bin_cp_list (obj, idx);
 	ut64 c_file_sz = r_io_size (core->io);
 	ut32 n_sz = 0, c_sz = obj ? r_bin_java_cp_get_size (obj, idx): -1;
@@ -546,7 +546,7 @@ static int r_cmd_java_get_cp_bytes_and_write (RCore *core, RBinJavaObj *obj, ut1
 		res = r_core_write_at(core, addr, (const ut8 *)bytes, n_sz) && r_core_seek (core, addr, 1);
 	}
 
-	if (res == R_FALSE) {
+	if (res == false) {
 		eprintf ("[X] r_cmd_java_get_cp_bytes_and_write: Failed to write the bytes to the file correctly aborting.\n");
 		return res;
 	}
@@ -554,7 +554,7 @@ static int r_cmd_java_get_cp_bytes_and_write (RCore *core, RBinJavaObj *obj, ut1
 	free (bytes);
 	bytes = NULL;
 
-	if (res == R_TRUE) {
+	if (res == true) {
 		ut64 n_file_sz = 0;
 		ut8 * bin_buffer = NULL;
 		res = r_io_use_desc (core->io, core->file->desc);
@@ -563,8 +563,8 @@ static int r_cmd_java_get_cp_bytes_and_write (RCore *core, RBinJavaObj *obj, ut1
 		if (bin_buffer) {
 			memset (bin_buffer, 0, n_file_sz);
 			res = n_file_sz == r_io_read_at (core->io, obj->loadaddr,
-				bin_buffer, n_file_sz) ? R_TRUE : R_FALSE;
-			if (res == R_TRUE) {
+				bin_buffer, n_file_sz) ? true : false;
+			if (res == true) {
 				res = r_cmd_java_reload_bin_from_buf (
 					core, obj, bin_buffer, n_file_sz);
 			} else eprintf ("[X] r_cmd_java_get_cp_bytes_and_write: Failed to read the file in aborted, bin reload.\n");
@@ -576,34 +576,34 @@ static int r_cmd_java_get_cp_bytes_and_write (RCore *core, RBinJavaObj *obj, ut1
 
 static int r_cmd_java_handle_replace_cp_value_float (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr) {
 	float value = cmd && *cmd ? atof (cmd) : 0.0;
-	int res = R_FALSE;
+	int res = false;
 	res = r_cmd_java_get_cp_bytes_and_write (core, obj, idx, addr, (ut8 *) &value, 4);
 	return res;
 }
 
 static int r_cmd_java_handle_replace_cp_value_double (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr) {
 	double value = cmd && *cmd ? strtod (cmd, NULL) : 0.0;
-	int res = R_FALSE;
+	int res = false;
 	res = r_cmd_java_get_cp_bytes_and_write (core, obj, idx, addr, (ut8 *) &value, 8);
 	return res;
 }
 
 static int r_cmd_java_handle_replace_cp_value_long (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr) {
 	ut64 value = r_cmd_java_get_input_num_value (core, cmd);
-	int res = R_FALSE;
+	int res = false;
 	res = r_cmd_java_get_cp_bytes_and_write (core, obj, idx, addr, (ut8 *) &value, 8);
 	return res;
 }
 
 static int r_cmd_java_handle_replace_cp_value_int (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr) {
 	ut32 value = (ut32) r_cmd_java_get_input_num_value (core, cmd);
-	int res = R_FALSE;
+	int res = false;
 	res = r_cmd_java_get_cp_bytes_and_write (core, obj, idx, addr, (ut8 *) &value, 4);
 	return res;
 }
 
 static int r_cmd_java_handle_replace_cp_value_str (RCore *core, RBinJavaObj *obj, const char *cmd, ut16 idx, ut64 addr) {
-	int res = R_FALSE;
+	int res = false;
 	ut32 len = cmd && *cmd ? strlen (cmd) : 0;
 	if (len > 0 && cmd && *cmd == '"') {
 		cmd++;
@@ -635,7 +635,7 @@ static int r_cmd_java_handle_replace_cp_value (RCore *core, const char *cmd) {
 		eprintf ("[-] r_cmd_java: The current binary is not a Java Bin Object.\n");
 	} else if (!p || (p && !*p)) {
 		r_cmd_java_print_cmd_help (JAVA_CMDS+REPLACE_CP_VALUE_IDX);
-		return R_TRUE;
+		return true;
 	} else {
 		cp_type = r_bin_java_resolve_cp_idx_tag(obj, idx);
 		addr = r_bin_java_resolve_cp_idx_address (obj, idx);
@@ -653,11 +653,11 @@ static int r_cmd_java_handle_replace_cp_value (RCore *core, const char *cmd) {
 			core, obj, r_cmd_java_consumetok (p, ' ', -1), idx, addr);
 		default:
 			eprintf ("[-] r_cmd_java: invalid java type to search for.\n");
-			return R_FALSE;
+			return false;
 		}
-		return R_TRUE;
+		return true;
 	}
-	return R_FALSE;
+	return false;
 }
 
 static char * r_cmd_replace_name_def (const char *s_new, ut32 replace_len, const char *s_old, ut32 match_len, const char *buffer, ut32 buf_len, ut32 *res_len) {
@@ -677,13 +677,13 @@ static char * r_cmd_replace_name_def (const char *s_new, ut32 replace_len, const
 }
 
 static int r_cmd_is_object_descriptor (const char *name, ut32 name_len) {
-	int found_L = R_FALSE, found_Semi = R_FALSE;
+	int found_L = false, found_Semi = false;
 	ut32 idx = 0, L_pos = 0, Semi_pos = 0;
 	const char *p_name = name;
 
 	for (idx = 0, L_pos = 0; idx < name_len; idx++,p_name++) {
 		if (*p_name == 'L') {
-			found_L = R_TRUE;
+			found_L = true;
 			L_pos = idx;
 			break;
 		}
@@ -691,13 +691,13 @@ static int r_cmd_is_object_descriptor (const char *name, ut32 name_len) {
 
 	for (idx = 0, L_pos = 0; idx < name_len; idx++,p_name++) {
 		if (*p_name == ';') {
-			found_Semi = R_TRUE;
+			found_Semi = true;
 			Semi_pos = idx;
 			break;
 		}
 	}
 
-	return R_TRUE ? found_L == found_Semi && found_L == R_TRUE && L_pos < Semi_pos : R_FALSE;
+	return true ? found_L == found_Semi && found_L == true && L_pos < Semi_pos : false;
 }
 
 static char * r_cmd_replace_name (const char *s_new, ut32 replace_len, const char *s_old, ut32 match_len, const char *buffer, ut32 buf_len, ut32 *res_len) {
@@ -742,7 +742,7 @@ static int r_cmd_java_get_class_names_from_input (const char *input, char **clas
 	const char *p = input;
 
 	ut32 cmd_sz = input && *input ? strlen (input) : 0;
-	int res = R_FALSE;
+	int res = false;
 
 	if (!class_name || *class_name) return res;
 	else if (!new_class_name || *new_class_name) return res;
@@ -773,7 +773,7 @@ static int r_cmd_java_get_class_names_from_input (const char *input, char **clas
 				*new_class_name_len = end - p + 1;
 				*new_class_name = malloc (*new_class_name_len);
 				snprintf (*new_class_name, *new_class_name_len, "%s", p );
-				res = R_TRUE;
+				res = true;
 			}
 		}
 	}
@@ -786,17 +786,17 @@ static int r_cmd_java_handle_replace_classname_value (RCore *core, const char *c
 	ut32 class_name_len = 0, new_class_name_len = 0;
 	RAnal *anal = get_anal (core);
 	const char *p = cmd;
-	int res = R_FALSE;
+	int res = false;
 	ut16 idx = -1;
 
 	if (!core || !anal || !cmd) {
-		return R_FALSE;
+		return false;
 	}
 	IFDBG r_cons_printf ("Function call made: %s\n", p);
 	obj = (RBinJavaObj *) r_cmd_java_get_bin_obj (anal);
 	if (!obj) {
 		eprintf ("The current binary is not a Java Bin Object.\n");
-		return R_TRUE;
+		return true;
 	}
 	res = r_cmd_java_get_class_names_from_input (cmd, &class_name,
 		&class_name_len, &new_class_name, &new_class_name_len);
@@ -805,7 +805,7 @@ static int r_cmd_java_handle_replace_classname_value (RCore *core, const char *c
 		r_cmd_java_print_cmd_help (JAVA_CMDS+REPLACE_CLASS_NAME_IDX);
 		free (class_name);
 		free (new_class_name);
-		return R_TRUE;
+		return true;
 	} 
 	for (idx = 1; idx <=obj->cp_count; idx++) {
 		RBinJavaCPTypeObj* cp_obj = r_bin_java_get_item_from_bin_cp_list (obj, idx);
@@ -832,7 +832,7 @@ static int r_cmd_java_handle_replace_classname_value (RCore *core, const char *c
 				ut32 res_len = 0;
 				char * result = NULL;
 
-				if (r_cmd_is_object_descriptor (name, len) == R_TRUE) {
+				if (r_cmd_is_object_descriptor (name, len) == true) {
 					result = r_cmd_replace_name_def (new_class_name,
 						new_class_name_len-1, class_name,
 						class_name_len-1, name, len, &res_len);
@@ -845,7 +845,7 @@ static int r_cmd_java_handle_replace_classname_value (RCore *core, const char *c
 					res = r_cmd_java_get_cp_bytes_and_write (
 						core, obj, idx, addr, 
 						(const ut8*)result, res_len);
-					if  (res == R_FALSE) {
+					if  (res == false) {
 						eprintf ("ERROR: r_cmd_java: Failed to write bytes or reload the binary.\n");
 					}
 				}
@@ -858,7 +858,7 @@ static int r_cmd_java_handle_replace_classname_value (RCore *core, const char *c
 	}
 	free (class_name);
 	free (new_class_name);
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_handle_reload_bin (RCore *core, const char *cmd) {
@@ -868,14 +868,14 @@ static int r_cmd_java_handle_reload_bin (RCore *core, const char *cmd) {
 	ut64 addr = 0LL; //cur_offset = core->offset, addr = 0;
 	ut64 buf_size = 0;
 	ut8 * buf = NULL;
-	int res = R_FALSE;
+	int res = false;
 
 	if (*cmd == ' ') {
 		p = r_cmd_java_consumetok (p, ' ', -1);
 	}
 	if (!*cmd) {
 		r_cmd_java_print_cmd_help (JAVA_CMDS+RELOAD_BIN_IDX);
-		return R_TRUE;
+		return true;
 	}
 
 	addr = r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;
@@ -915,16 +915,16 @@ static int r_cmd_java_handle_find_cp_const (RCore *core, const char *cmd) {
 
 	if (!obj) {
 		eprintf ("[-] r_cmd_java: no valid java bins found.\n");
-		return R_TRUE;
+		return true;
 	}
 	if (!cmd || !*cmd) {
 		eprintf ("[-] r_cmd_java: invalid command syntax.\n");
 		r_cmd_java_print_cmd_help (JAVA_CMDS+FIND_CP_CONST_IDX);
-		return R_TRUE;
+		return true;
 	}
 	if (idx == 0) {
 		eprintf ("[-] r_cmd_java: invalid CP Obj Index Supplied.\n");
-		return R_TRUE;
+		return true;
 	}
 	find_list = r_list_new ();
 	find_list->free = free;
@@ -966,7 +966,7 @@ static int r_cmd_java_handle_find_cp_const (RCore *core, const char *cmd) {
 		}
 	}
 	r_list_free (find_list);
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_handle_field_info (RCore *core, const char *cmd) {
@@ -977,11 +977,11 @@ static int r_cmd_java_handle_field_info (RCore *core, const char *cmd) {
 
 	if (!obj) {
 		eprintf ("[-] r_cmd_java: no valid java bins found.\n");
-		return R_TRUE;
+		return true;
 	} else if (!cmd || !*cmd) {
 		eprintf ("[-] r_cmd_java: invalid command syntax.\n");
 		r_cmd_java_print_cmd_help (JAVA_CMDS+FIELD_INFO_IDX);
-		return R_TRUE;
+		return true;
 	}
 
 	if (*(cmd) == 's' || *(cmd) == 'n') {
@@ -996,7 +996,7 @@ static int r_cmd_java_handle_field_info (RCore *core, const char *cmd) {
 	IFDBG r_cons_printf ("Command is (%s)\n", cmd);
 	eprintf ("[-] r_cmd_java: invalid command syntax.\n");
 	r_cmd_java_print_cmd_help (JAVA_CMDS+FIELD_INFO_IDX);
-	return R_FALSE;
+	return false;
 }
 
 static int r_cmd_java_handle_method_info (RCore *core, const char *cmd) {
@@ -1007,11 +1007,11 @@ static int r_cmd_java_handle_method_info (RCore *core, const char *cmd) {
 
 	if (!obj) {
 		eprintf ("[-] r_cmd_java: no valid java bins found.\n");
-		return R_TRUE;
+		return true;
 	} else if (!cmd || !*cmd) {
 		eprintf ("[-] r_cmd_java: invalid command syntax.\n");
 		r_cmd_java_print_cmd_help (JAVA_CMDS+METHOD_INFO_IDX);
-		return R_FALSE;
+		return false;
 	}
 
 	if (*(cmd) == 's' || *(cmd) == 'n') {
@@ -1027,11 +1027,11 @@ static int r_cmd_java_handle_method_info (RCore *core, const char *cmd) {
 	IFDBG r_cons_printf ("Command is (%s)\n", cmd);
 	eprintf ("[-] r_cmd_java: invalid command syntax.\n");
 	r_cmd_java_print_cmd_help (JAVA_CMDS+METHOD_INFO_IDX);
-	return R_FALSE;
+	return false;
 }
 
 static int r_cmd_java_handle_calc_class_sz (RCore *core, const char *cmd) {
-	int res = R_FALSE;
+	int res = false;
 	ut64 sz = UT64_MAX;
 	ut64 addr = UT64_MAX;
 	ut64 res_size = UT64_MAX,
@@ -1060,7 +1060,7 @@ static int r_cmd_java_handle_calc_class_sz (RCore *core, const char *cmd) {
 			// to continue trying to find the class size.
 			if (res_size != UT64_MAX ||
 				r_sz < sz) {
-				res = r_sz < sz ? R_FALSE : R_TRUE;
+				res = r_sz < sz ? false : true;
 				free (buf);
 				break;
 			}else {
@@ -1075,11 +1075,11 @@ static int r_cmd_java_handle_calc_class_sz (RCore *core, const char *cmd) {
 	} else {
 		r_cmd_java_print_cmd_help (JAVA_CMDS+CALC_SZ_IDX);
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_handle_isvalid (RCore *core, const char *cmd) {
-	int res = R_FALSE;
+	int res = false;
 	ut64 res_size = UT64_MAX;
 	ut8 *buf = NULL;
 	ut32 cur_fsz =  r_io_desc_size (core->io, r_core_file_cur (core)->desc);
@@ -1107,7 +1107,7 @@ static int r_cmd_java_handle_isvalid (RCore *core, const char *cmd) {
 			// to continue trying to find the class size.
 			if (res_size != UT64_MAX ||
 				r_sz < sz) {
-				res = r_sz < sz ? R_FALSE : R_TRUE;
+				res = r_sz < sz ? false : true;
 				free (buf);
 				break;
 			}else {
@@ -1118,7 +1118,7 @@ static int r_cmd_java_handle_isvalid (RCore *core, const char *cmd) {
 		else r_cons_printf ("False\n");
 	} else
 		r_cmd_java_print_cmd_help (JAVA_CMDS+ISVALID_IDX);
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_handle_resolve_cp (RCore *core, const char *cmd) {
@@ -1128,7 +1128,7 @@ static int r_cmd_java_handle_resolve_cp (RCore *core, const char *cmd) {
 	ut16 idx = r_cmd_java_get_input_num_value (core, cmd+2);
 	IFDBG r_cons_printf ("Function call made: %s\n", cmd);
 	IFDBG r_cons_printf ("Ctype: %d (%c) RBinJavaObj points to: %p and the idx is (%s): %d\n", c_type, c_type, obj, cmd+2, idx);
-	int res = R_FALSE;
+	int res = false;
 	if (idx > 0 && obj) {
 		switch (c_type) {
 			case 't': return r_cmd_java_resolve_cp_type (obj, idx);
@@ -1145,12 +1145,12 @@ static int r_cmd_java_handle_resolve_cp (RCore *core, const char *cmd) {
 			r_cons_printf ("CP_OBJ Type %d =  %s @ 0x%"PFMT64x"\n", idx, str, addr);
 			free (str);
 		}
-		res = R_TRUE;
+		res = true;
 	} else if (obj && c_type == 'd') {
 		for (idx = 1; idx <= obj->cp_count; idx++) {
 			r_cmd_java_resolve_cp_summary (obj, idx);
 		}
-		res = R_TRUE;
+		res = true;
 	} else {
 		if (!obj) {
 			eprintf ("[-] r_cmd_java: no valid java bins found.\n");
@@ -1158,7 +1158,7 @@ static int r_cmd_java_handle_resolve_cp (RCore *core, const char *cmd) {
 			eprintf ("[-] r_cmd_java: invalid cp index given, must idx > 1.\n");
 			r_cmd_java_print_cmd_help (JAVA_CMDS+RESOLVE_CP_IDX);
 		}
-		res = R_TRUE;
+		res = true;
 	}
 	return res;
 }
@@ -1176,7 +1176,7 @@ static int r_cmd_java_get_all_access_flags_value (const char *cmd) {
 	if (!the_list) {
 		eprintf ("[-] r_cmd_java: incorrect syntax for the flags calculation.\n");
 		r_cmd_java_print_cmd_help (JAVA_CMDS+CALC_FLAGS_IDX);
-		return R_FALSE;
+		return false;
 	}
 	switch (*(cmd)) {
 		case 'f': r_cons_printf ("[=] Fields Access Flags List\n"); break;
@@ -1188,12 +1188,12 @@ static int r_cmd_java_get_all_access_flags_value (const char *cmd) {
 		r_cons_printf ("%s\n", str);
 	}
 	r_list_free (the_list);
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_handle_calc_flags (RCore *core, const char *cmd) {
 	IFDBG r_cons_printf ("Function call made: %s\n", cmd);
-	int res = R_FALSE;
+	int res = false;
 
 	switch (*(cmd)) {
 		case 'f': return r_cmd_java_print_field_access_flags_value (cmd+2);
@@ -1210,23 +1210,23 @@ static int r_cmd_java_handle_calc_flags (RCore *core, const char *cmd) {
 			case 'c': res = r_cmd_java_get_all_access_flags_value (lcmd); break;
 		}
 		// Just print them all out
-		if (res == R_FALSE) {
+		if (res == false) {
 			r_cmd_java_get_all_access_flags_value ("c");
 			r_cmd_java_get_all_access_flags_value ("m");
 			res = r_cmd_java_get_all_access_flags_value ("f");
 		}
 	}
-	if (res == R_FALSE) {
+	if (res == false) {
 		eprintf ("[-] r_cmd_java: incorrect syntax for the flags calculation.\n");
 		r_cmd_java_print_cmd_help (JAVA_CMDS+CALC_FLAGS_IDX);
-		res = R_TRUE;
+		res = true;
 	}
 	return res;
 }
 
 static int r_cmd_java_handle_flags_str (RCore *core, const char *cmd) {
 
-	int res = R_FALSE;
+	int res = false;
 	ut32 flag_value = -1;
 	const char f_type = cmd ? *cmd : 0;
 	const char *p = cmd ? cmd + 2: NULL;
@@ -1253,19 +1253,19 @@ static int r_cmd_java_handle_flags_str (RCore *core, const char *cmd) {
 		}
 		r_cons_printf ("%s\n", flags_str);
 		free (flags_str);
-		res = R_TRUE;
+		res = true;
 	}
-	if (res == R_FALSE) {
+	if (res == false) {
 		eprintf ("[-] r_cmd_java: incorrect syntax for the flags calculation.\n");
 		r_cmd_java_print_cmd_help (JAVA_CMDS+FLAGS_STR_IDX);
-		res = R_TRUE;
+		res = true;
 	}
 	return res;
 }
 
 static int r_cmd_java_handle_flags_str_at (RCore *core, const char *cmd) {
 
-	int res = R_FALSE;
+	int res = false;
 	ut64 flag_value_addr = -1;
 	ut32 flag_value = -1;
 	const char f_type = cmd ? *r_cmd_java_consumetok (cmd, ' ', -1) : 0;
@@ -1300,12 +1300,12 @@ static int r_cmd_java_handle_flags_str_at (RCore *core, const char *cmd) {
 		}
 		r_cons_printf ("%s\n", flags_str);
 		free (flags_str);
-		res = R_TRUE;
+		res = true;
 	}
-	if (res == R_FALSE) {
+	if (res == false) {
 		eprintf ("[-] r_cmd_java: incorrect syntax for the flags calculation.\n");
 		r_cmd_java_print_cmd_help (JAVA_CMDS+FLAGS_STR_IDX);
-		res = R_TRUE;
+		res = true;
 	}
 	return res;
 }
@@ -1328,12 +1328,12 @@ static int r_cmd_java_handle_set_flags (RCore * core, const char * input) {
 	ut64 addr = p && r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;
 	ut32 flag_value = -1;
 	char f_type = '?';
-	int res = R_FALSE;
+	int res = false;
 
 	p = r_cmd_java_strtok (p+1, ' ', -1);
 	if (!p || !*p) {
 		r_cmd_java_print_cmd_help (JAVA_CMDS+SET_ACC_FLAGS_IDX);
-		return R_TRUE;
+		return true;
 	}
 	f_type = p && *p ? r_cmd_java_is_valid_java_mcf (*(++p)) : 0;
 
@@ -1350,13 +1350,13 @@ static int r_cmd_java_handle_set_flags (RCore * core, const char * input) {
 
 	if (!input) {
 		eprintf ("[-] r_cmd_java: no address provided .\n");
-		res = R_TRUE;
+		res = true;
 	} else if (addr == -1) {
 		eprintf ("[-] r_cmd_java: no address provided .\n");
-		res = R_TRUE;
+		res = true;
 	} else if (!f_type && flag_value == -1) {
 		eprintf ("[-] r_cmd_java: no flag type provided .\n");
-		res = R_TRUE;
+		res = true;
 	}
 
 	if (res) {
@@ -1377,7 +1377,7 @@ static int r_cmd_java_handle_set_flags (RCore * core, const char * input) {
 		}
 		if (flag_value == -1) {
 			eprintf ("[-] r_cmd_java: in valid flag type provided .\n");
-			res = R_TRUE;
+			res = true;
 		}
 	}
 	IFDBG r_cons_printf ("Current args: (flag_value: 0x%04x addr: 0x%"PFMT64x")\n.", flag_value, addr, res);
@@ -1387,17 +1387,17 @@ static int r_cmd_java_handle_set_flags (RCore * core, const char * input) {
 	} else {
 		eprintf ("[-] r_cmd_java: invalid flag value or type provided .\n");
 		r_cmd_java_print_cmd_help (JAVA_CMDS+SET_ACC_FLAGS_IDX);
-		res = R_TRUE;
+		res = true;
 	}
 	return res;
 }
 
 static int r_cmd_java_call(void *user, const char *input) {
 	RCore *core = (RCore *) user;
-	int res = R_FALSE;
+	int res = false;
 	ut32 i = 0;
 	IFDBG r_cons_printf ("Function call made: %s\n", input);
-	if (strncmp (input, "java",4)) return R_FALSE;
+	if (strncmp (input, "java",4)) return false;
 	else if (strncmp (input, "java ",5)) {
 		return r_cmd_java_handle_help (core, input);
 	}
@@ -1415,8 +1415,8 @@ static int r_cmd_java_call(void *user, const char *input) {
 		}
 	}
 
-	if (res == R_FALSE) res = r_cmd_java_handle_help (core, input);
-	return R_TRUE;
+	if (res == false) res = r_cmd_java_handle_help (core, input);
+	return true;
 }
 
 
@@ -1435,7 +1435,7 @@ static int r_cmd_java_print_method_definitions ( RBinJavaObj *obj ) {
 
 	r_list_free(the_list);
 	r_list_free(off_list);
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_print_field_definitions ( RBinJavaObj *obj ) {
@@ -1453,7 +1453,7 @@ static int r_cmd_java_print_field_definitions ( RBinJavaObj *obj ) {
 
 	r_list_free(the_list);
 	r_list_free(off_list);
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_print_import_definitions ( RBinJavaObj *obj ) {
@@ -1464,7 +1464,7 @@ static int r_cmd_java_print_import_definitions ( RBinJavaObj *obj ) {
 		r_cons_printf("import %s;\n", str);
 	}
 	r_list_free(the_list);
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_print_all_definitions( RAnal *anal ) {
@@ -1476,7 +1476,7 @@ static int r_cmd_java_print_all_definitions( RAnal *anal ) {
 	r_list_foreach (obj_list, iter, obj) {
 		r_cmd_java_print_class_definitions (obj);
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_print_json_definitions( RBinJavaObj *obj ) {
@@ -1484,7 +1484,7 @@ static int r_cmd_java_print_json_definitions( RBinJavaObj *obj ) {
 	char *str = dso_json_obj_to_str (json_obj);
 	dso_json_obj_del (json_obj); // XXX memleak
 	r_cons_printf ("%s\n", str);
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_print_class_definitions( RBinJavaObj *obj ) {
@@ -1532,7 +1532,7 @@ static int r_cmd_java_print_class_definitions( RBinJavaObj *obj ) {
 	r_list_free (the_moffsets);
 
 	free(class_name);
-	return R_TRUE;
+	return true;
 }
 
 static RList * r_cmd_java_get_bin_obj_list(RAnal *anal) {
@@ -1566,7 +1566,7 @@ static int r_cmd_java_resolve_cp_idx (RBinJavaObj *obj, ut16 idx) {
 		r_cons_printf ("%s\n", str);
 		free (str);
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_resolve_cp_type (RBinJavaObj *obj, ut16 idx) {
@@ -1575,7 +1575,7 @@ static int r_cmd_java_resolve_cp_type (RBinJavaObj *obj, ut16 idx) {
 		r_cons_printf ("%s\n", str);
 		free (str);
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_resolve_cp_idx_b64 (RBinJavaObj *obj, ut16 idx) {
@@ -1584,7 +1584,7 @@ static int r_cmd_java_resolve_cp_idx_b64 (RBinJavaObj *obj, ut16 idx) {
 		r_cons_printf ("%s\n", str);
 		free (str);
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_resolve_cp_address (RBinJavaObj *obj, ut16 idx) {
@@ -1595,7 +1595,7 @@ static int r_cmd_java_resolve_cp_address (RBinJavaObj *obj, ut16 idx) {
 		else
 			r_cons_printf ("0x%"PFMT64x"\n", addr);
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_resolve_cp_to_key (RBinJavaObj *obj, ut16 idx) {
@@ -1604,13 +1604,13 @@ static int r_cmd_java_resolve_cp_to_key (RBinJavaObj *obj, ut16 idx) {
 		r_cons_printf ("%s\n", str);
 		free (str);
 	}
-	return R_TRUE;
+	return true;
 }
 static int r_cmd_java_resolve_cp_summary (RBinJavaObj *obj, ut16 idx) {
 	if (obj && idx){
 		r_bin_java_resolve_cp_idx_print_summary (obj, idx) ;
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_is_valid_input_num_value(RCore *core, const char *input_value){
@@ -1626,30 +1626,30 @@ static ut64 r_cmd_java_get_input_num_value(RCore *core, const char *input_value)
 static int r_cmd_java_print_class_access_flags_value( const char * flags ){
 	ut16 result = r_bin_java_calculate_class_access_value (flags);
 	r_cons_printf ("Access Value for %s = 0x%04x\n", flags, result);
-	return R_TRUE;
+	return true;
 }
 static int r_cmd_java_print_field_access_flags_value( const char * flags ){
 	ut16 result = r_bin_java_calculate_field_access_value (flags);
 	r_cons_printf ("Access Value for %s = 0x%04x\n", flags,  result);
-	return R_TRUE;
+	return true;
 }
 static int r_cmd_java_print_method_access_flags_value( const char * flags ){
 	ut16 result = r_bin_java_calculate_method_access_value (flags);
 	r_cons_printf ("Access Value for %s = 0x%04x\n", flags,  result);
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_set_acc_flags (RCore *core, ut64 addr, ut16 num_acc_flag) {
 	char cmd_buf [50];
 	//const char * fmt = "wx %04x @ 0x%"PFMT64x;
 
-	int res = R_FALSE;
+	int res = false;
 	//ut64 cur_offset = core->offset;
 	num_acc_flag = R_BIN_JAVA_USHORT (((ut8*) &num_acc_flag), 0);
 	res = r_core_write_at(core, addr, (const ut8 *)&num_acc_flag, 2);
 	//snprintf (cmd_buf, 50, fmt, num_acc_flag, addr);
 	//res = r_core_cmd0(core, cmd_buf);
-	res = R_TRUE;
+	res = true;
 	IFDBG r_cons_printf ("Executed cmd: %s == %d\n", cmd_buf, res);
 	/*if (cur_offset != core->offset) {
 		IFDBG eprintf ("Ooops, write advanced the cursor, moving it back.");
@@ -1665,7 +1665,7 @@ static int r_cmd_java_print_field_num_name (RBinJavaObj *obj) {
 		r_cons_printf ("%s\n", str);
 	}
 	r_list_free (the_list);
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_print_method_num_name (RBinJavaObj *obj) {
@@ -1676,14 +1676,14 @@ static int r_cmd_java_print_method_num_name (RBinJavaObj *obj) {
 		r_cons_printf ("%s\n", str);
 	}
 	r_list_free (the_list);
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_print_field_summary (RBinJavaObj *obj, ut16 idx) {
 	int res = r_bin_java_print_field_idx_summary (obj, idx);
-	if (res == R_FALSE) {
+	if (res == false) {
 		eprintf ("Error: Field or Method @ index (%d) not found in the RBinJavaObj.\n", idx);
-		res = R_TRUE;
+		res = true;
 	}
 	return res;
 }
@@ -1692,7 +1692,7 @@ static int UNUSED_FUNCTION(r_cmd_java_print_field_count) (RBinJavaObj *obj) {
 	ut32 res = r_bin_java_get_field_count (obj);
 	r_cons_printf ("%d\n", res);
 	r_cons_flush();
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_print_field_name (RBinJavaObj *obj, ut16 idx) {
@@ -1703,14 +1703,14 @@ static int r_cmd_java_print_field_name (RBinJavaObj *obj, ut16 idx) {
 		eprintf ("Error: Field or Method @ index (%d) not found in the RBinJavaObj.\n", idx);
 	}
 	free (res);
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_print_method_summary (RBinJavaObj *obj, ut16 idx) {
 	int res = r_bin_java_print_method_idx_summary (obj, idx);
-	if (res == R_FALSE) {
+	if (res == false) {
 		eprintf ("Error: Field or Method @ index (%d) not found in the RBinJavaObj.\n", idx);
-		res = R_TRUE;
+		res = true;
 	}
 	return res;
 }
@@ -1719,7 +1719,7 @@ static int _(r_cmd_java_print_method_count)(RBinJavaObj *obj) {
 	ut32 res = r_bin_java_get_method_count (obj);
 	r_cons_printf ("%d\n", res);
 	r_cons_flush();
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_print_method_name (RBinJavaObj *obj, ut16 idx) {
@@ -1730,7 +1730,7 @@ static int r_cmd_java_print_method_name (RBinJavaObj *obj, ut16 idx) {
 		eprintf ("Error: Field or Method @ index (%d) not found in the RBinJavaObj.\n", idx);
 	}
 	free (res);
-	return R_TRUE;
+	return true;
 }
 static char * r_cmd_java_get_descriptor (RCore *core, RBinJavaObj *bin, ut16 idx) {
 	char *class_name = NULL, *fullname = NULL, *name = NULL, *descriptor = NULL;
@@ -1779,11 +1779,11 @@ static int r_cmd_java_handle_list_code_references (RCore *core, const char *inpu
 
 	if (!core || !anal || !bin) {
 		eprintf ("Unable to access the current bin.\n");
-		return R_FALSE;
+		return false;
 	}
 	if (r_list_length (anal->fcns) == 0) {
 		eprintf ("Unable to access the current analysis, perform 'af' for function analysis.\n");
-		return R_TRUE;
+		return true;
 	}
 
 	fmt = "addr:0x%"PFMT64x" method_name:\"%s\", op:\"%s\" type:\"%s\" info:\"%s\"\n";
@@ -1875,7 +1875,7 @@ static int r_cmd_java_handle_list_code_references (RCore *core, const char *inpu
 			free (operation);
 		}
 	}
-	return R_TRUE;
+	return true;
 }
 
 static int r_cmd_java_handle_yara_code_extraction_refs (RCore *core, const char *input) {
@@ -1884,12 +1884,12 @@ static int r_cmd_java_handle_yara_code_extraction_refs (RCore *core, const char
 	const char *p = input? r_cmd_java_consumetok (input, ' ', -1): NULL, *n = NULL;
 	char *name = NULL;
 	ut64 addr = -1, count = -1;
-	int res = R_FALSE;
+	int res = false;
 
 	if (!bin) return res;
 	else if (!anal || !anal->fcns || r_list_length (anal->fcns) == 0) {
 		eprintf ("Unable to access the current analysis, perform 'af' for function analysis.\n");
-		return R_TRUE;
+		return true;
 	}
 
 	if (!p) return res;
@@ -1931,12 +1931,12 @@ static int r_cmd_java_handle_insert_method_ref (RCore *core, const char *input)
 	const char *p = input? r_cmd_java_consumetok (input, ' ', -1): NULL, *n = NULL;
 	char  *classname=NULL, *name = NULL, *descriptor = NULL;
 	ut32 cn_sz = 0, n_sz = 0, d_sz = 0;
-	int res = R_FALSE;
+	int res = false;
 
 	if (!bin) return res;
 	else if (!anal || !anal->fcns || r_list_length (anal->fcns) == 0) {
 		eprintf ("Unable to access the current analysis, perform 'af' for function analysis.\n");
-		return R_TRUE;
+		return true;
 	}
 	if (!p) return res;
 
@@ -1983,7 +1983,7 @@ static int r_cmd_java_handle_insert_method_ref (RCore *core, const char *input)
 	free (classname);
 	free (name);
 	free (descriptor);
-	res = R_TRUE;
+	res = true;
 	return res;
 }
 
@@ -1998,7 +1998,7 @@ static int r_cmd_java_handle_print_exceptions (RCore *core, const char *input) {
 	const char *p = input? r_cmd_java_consumetok (input, ' ', -1): NULL;
 	func_addr = p && *p && r_cmd_java_is_valid_input_num_value(core, p) ? r_cmd_java_get_input_num_value (core, p) : -1;
 
-	if (!bin) return R_FALSE;
+	if (!bin) return false;
 
 	r_list_foreach (bin->methods_list, methods_iter, method) {
 		ut64 start = r_bin_java_get_method_start(bin, method),
@@ -2029,7 +2029,7 @@ static int r_cmd_java_handle_print_exceptions (RCore *core, const char *input) {
 		}
 	}
 
-	return R_TRUE;
+	return true;
 }
 
 // PLUGIN Definition Info
diff --git a/libr/core/panels.c b/libr/core/panels.c
index 9de6538d4..b9bc7e73f 100644
--- a/libr/core/panels.c
+++ b/libr/core/panels.c
@@ -392,13 +392,13 @@ R_API int r_core_visual_panels(RCore *core) {
 	//can->color = 0; 
 	if (!can) {
 		eprintf ("Cannot create RCons.canvas context\n");
-		return R_FALSE;
+		return false;
 	}
 	n_panels = bbPanels (core, NULL);//&panels);
 	if (!panels) {
 		r_config_set_i (core->config, "scr.color", can->color);
 		free (can);
-		return R_FALSE;
+		return false;
 	}
 
 	if (w<140) {
@@ -421,7 +421,7 @@ repeat:
 	r_core_panels_refresh (core);
 	wheel = r_config_get_i (core->config, "scr.wheel");
 	if (wheel)
-		r_cons_enable_mouse (R_TRUE);
+		r_cons_enable_mouse (true);
 
 	// r_core_graph_inputhandle()
 	okey = r_cons_readchar ();
@@ -590,7 +590,7 @@ repeat:
 				RAnalFunction *fun = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);
 				if (fun) {
 					int ocolor = r_config_get_i (core->config, "scr.color");
-					r_core_visual_graph (core, NULL, R_TRUE);
+					r_core_visual_graph (core, NULL, true);
 					r_config_set_i (core->config, "scr.color", ocolor);
 				} else {
 					r_cons_message("Not in a function. Type 'df' to define it here");
@@ -599,9 +599,9 @@ repeat:
 				r_cons_set_raw (0);
 				r_sys_cmd ("$SHELL");
 			} else if (strstr (action, "Shell")) {
-				core->vmode = R_FALSE;
+				core->vmode = false;
 				r_core_visual_prompt_input (core);
-				core->vmode = R_TRUE;
+				core->vmode = true;
 			} else if (strstr (action, "License")) {
 				r_cons_message ("Copyright 2006-2015 - pancake - LGPL");
 			} else if (strstr (action, "Fortune")) {
@@ -662,9 +662,9 @@ repeat:
 		}
 		break;
 	case ':':
-		core->vmode = R_FALSE;
+		core->vmode = false;
 		r_core_visual_prompt_input (core);
-		core->vmode = R_TRUE;
+		core->vmode = true;
 		break;
 	case 'C':
 		can->color = !!!can->color;				//WTF
@@ -796,5 +796,5 @@ beach:
 	free (can);
 	r_config_set_i (core->config, "asm.comments", asm_comments);
 	r_config_set_i (core->config, "asm.bytes", asm_bytes);
-	return R_TRUE;
+	return true;
 }
diff --git a/libr/core/plugin.c b/libr/core/plugin.c
index 24d4dff8b..764a55633 100644
--- a/libr/core/plugin.c
+++ b/libr/core/plugin.c
@@ -1,4 +1,4 @@
-/* radare - LGPL - Copyright 2010-2014 - pancake */
+/* radare - LGPL - Copyright 2010-2015 - pancake */
 
 /* covardly copied from r_cmd */
 
@@ -14,7 +14,7 @@ R_API int r_core_plugin_deinit(RCmd *cmd) {
 	RListIter *iter;
 	RCorePlugin *plugin;
 	if (!cmd->plist)
-		return R_FALSE;
+		return false;
 	r_list_foreach (cmd->plist, iter, plugin) {
 		if (plugin && plugin->deinit) {
 			plugin->deinit (cmd, NULL);
@@ -23,15 +23,14 @@ R_API int r_core_plugin_deinit(RCmd *cmd) {
 	/* empty the list */
 	r_list_free (cmd->plist);
 	cmd->plist = NULL;
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_plugin_add(RCmd *cmd, RCorePlugin *plugin) {
-	if (plugin->init)
-		if (!plugin->init (cmd, NULL))
-			return R_FALSE;
+	if (plugin->init && !plugin->init (cmd, NULL))
+		return false;
 	r_list_append (cmd->plist, plugin);
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_plugin_init(RCmd *cmd) {
@@ -40,10 +39,10 @@ R_API int r_core_plugin_init(RCmd *cmd) {
 	for (i=0; cmd_static_plugins[i]; i++) {
 		if (!r_core_plugin_add (cmd, cmd_static_plugins[i])) {
 			eprintf ("Error loading cmd plugin\n");
-			return R_FALSE;
+			return false;
 		}
 	}
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_plugin_check(RCmd *cmd, const char *a0) {
@@ -51,22 +50,7 @@ R_API int r_core_plugin_check(RCmd *cmd, const char *a0) {
 	RCorePlugin *cp;
 	r_list_foreach (cmd->plist, iter, cp) {
 		if (cp->call (NULL, a0))
-			return R_TRUE;
+			return true;
 	}
-	return R_FALSE;
+	return false;
 }
-
-#if 0
-// TODO: must return an r_iter ator
-R_API int r_cmd_plugin_list(struct r_cmd_t *cmd) {
-	int n = 0;
-	struct list_head *pos;
-	cmd->cb_printf ("IO plugins:\n");
-	list_for_each_prev(pos, &cmd->plist) {
-		struct r_cmd_list_t *il = list_entry(pos, struct r_cmd_list_t, list);
-		cmd->cb_printf(" - %s\n", il->plugin->name);
-		n++;
-	}
-	return n;
-}
-#endif
diff --git a/libr/core/project.c b/libr/core/project.c
index c6a24f197..464066089 100644
--- a/libr/core/project.c
+++ b/libr/core/project.c
@@ -128,7 +128,7 @@ R_API int r_core_project_delete(RCore *core, const char *prjfile) {
 	path = r_core_project_file (core, prjfile);
 	if (!path) {
 		eprintf ("Invalid project name '%s'\n", prjfile);
-		return R_FALSE;
+		return false;
 	}
 	if (r_core_is_project (core, prjfile)) {
 		// rm project file
@@ -164,11 +164,11 @@ R_API int r_core_project_open(RCore *core, const char *prjfile) {
 	int ret, close_current_session = 1;
 	char *prj, *filepath;
 	if (!prjfile || !*prjfile)
-		return R_FALSE;
+		return false;
 	prj = r_core_project_file (core, prjfile);
 	if (!prj) {
 		eprintf ("Invalid project name '%s'\n", prjfile);
-		return R_FALSE;
+		return false;
 	}
 	filepath = r_core_project_info (core, prj);
 	//eprintf ("OPENING (%s) from %s\n", prj, r_config_get (core->config, "file.path"));
@@ -176,7 +176,7 @@ R_API int r_core_project_open(RCore *core, const char *prjfile) {
 	if (!filepath) {
 		eprintf ("Cannot retrieve information for project '%s'\n", prj);
 		free (prj);
-		return R_FALSE;
+		return false;
 	}
 	if (!strstr (filepath, "://")) {
 		/* check if path exists */
@@ -184,7 +184,7 @@ R_API int r_core_project_open(RCore *core, const char *prjfile) {
 			eprintf ("Cannot find file '%s'\n", filepath);
 			free (prj);
 			free (filepath);
-			return R_FALSE;
+			return false;
 		}
 	}
 	if (!strcmp (prjfile, r_config_get (core->config, "file.project"))) {
@@ -193,7 +193,7 @@ R_API int r_core_project_open(RCore *core, const char *prjfile) {
 #if 0
 		free (prj);
 		free (filepath);
-		return R_FALSE;
+		return false;
 #endif
 	}
 	if (askuser) {
@@ -217,7 +217,7 @@ R_API int r_core_project_open(RCore *core, const char *prjfile) {
 			eprintf ("Cannot open file '%s'\n", filepath);
 			free (filepath);
 			free (prj);
-			return R_FALSE;
+			return false;
 		}
 		// TODO: handle load bin info or not
 		// TODO: handle base address
@@ -272,21 +272,21 @@ R_API char *r_core_project_info(RCore *core, const char *prjfile) {
 }
 
 R_API int r_core_project_save(RCore *core, const char *file) {
-	int fd, fdold, tmp, ret = R_TRUE;
+	int fd, fdold, tmp, ret = true;
 	char *prj;
 
 	if (file == NULL || *file == '\0')
-		return R_FALSE;
+		return false;
 
 	prj = r_core_project_file (core, file);
 	if (!prj) {
 		eprintf ("Invalid project name '%s'\n", file);
-		return R_FALSE;
+		return false;
 	}
 	if (r_file_is_directory (prj)) {
 		eprintf ("Error: Target is a directory\n");
 		free (prj);
-		return R_FALSE;
+		return false;
 	}
 	r_core_project_init (core);
 	r_anal_project_save (core->anal, prj);
@@ -294,17 +294,17 @@ R_API int r_core_project_save(RCore *core, const char *file) {
 	if (fd != -1) {
 		fdold = r_cons_singleton ()->fdout;
 		r_cons_singleton ()->fdout = fd;
-		r_cons_singleton ()->is_interactive = R_FALSE;
+		r_cons_singleton ()->is_interactive = false;
 		r_str_write (fd, "# r2 rdb project file\n");
 		r_str_write (fd, "# flags\n");
 		tmp = core->flags->space_idx;
 		core->flags->space_idx = -1;
-		r_flag_list (core->flags, R_TRUE, NULL);
+		r_flag_list (core->flags, true, NULL);
 		core->flags->space_idx = tmp;
 		r_cons_flush ();
 		r_str_write (fd, "# eval\n");
 		// TODO: r_str_writef (fd, "e asm.arch=%s", r_config_get ("asm.arch"));
-		r_config_list (core->config, NULL, R_TRUE);
+		r_config_list (core->config, NULL, true);
 		r_cons_flush ();
 		r_str_write (fd, "# sections\n");
 		r_io_section_list (core->io, core->offset, 1);
@@ -329,10 +329,10 @@ R_API int r_core_project_save(RCore *core, const char *file) {
 		r_cons_flush ();
 		close (fd);
 		r_cons_singleton ()->fdout = fdold;
-		r_cons_singleton ()->is_interactive = R_TRUE;
+		r_cons_singleton ()->is_interactive = true;
 	} else {
 		eprintf ("Cannot open '%s' for writing\n", prj);
-		ret = R_FALSE;
+		ret = false;
 	}
 	free (prj);
 	return ret;
diff --git a/libr/core/pseudo.c b/libr/core/pseudo.c
index 7b16b37b8..db8e23c0e 100644
--- a/libr/core/pseudo.c
+++ b/libr/core/pseudo.c
@@ -18,7 +18,7 @@ R_API int r_core_pseudo_code (RCore *core, const char *input) {
 	if (!fcn) {
 		eprintf ("Cannot find function in 0x%08"PFMT64x"\n",
 			core->offset);
-		return R_FALSE;
+		return false;
 	}
 	r_config_set_i (core->config, "asm.pseudo", 1);
 	r_config_set_i (core->config, "asm.decode", 0);
@@ -184,5 +184,5 @@ R_API int r_core_pseudo_code (RCore *core, const char *input) {
 	r_config_set_i (core->config, "asm.comments", asmcomments);
 	r_config_set_i (core->config, "asm.functions", asmfunctions);
 	sdb_free (db);
-	return R_TRUE;
+	return true;
 }
diff --git a/libr/core/rtr.c b/libr/core/rtr.c
index 1cf35737b..4a4e2f0aa 100644
--- a/libr/core/rtr.c
+++ b/libr/core/rtr.c
@@ -43,16 +43,16 @@ static void showcursor(RCore *core, int x) {
 			// TODO: cache this
 			int wheel = r_config_get_i (core->config, "scr.wheel");
 			if (wheel)
-				r_cons_enable_mouse (R_TRUE);
+				r_cons_enable_mouse (true);
 		} else {
-			r_cons_enable_mouse (R_FALSE);
+			r_cons_enable_mouse (false);
 		}
-	} else r_cons_enable_mouse (R_FALSE);
+	} else r_cons_enable_mouse (false);
 	r_cons_flush ();
 }
 
 static int rtr_visual (RCore *core, TextLog T, const char *cmd) {
-	int autorefresh = R_FALSE;
+	int autorefresh = false;
 	if (cmd) {
 		r_cons_break (NULL, NULL);
 		for (;;) {
@@ -87,7 +87,7 @@ static int rtr_visual (RCore *core, TextLog T, const char *cmd) {
 				r_cons_break (NULL, NULL);
 				r_sys_sleep (1);
 				if (r_cons_singleton()->breaked)  {
-					autorefresh = R_FALSE;
+					autorefresh = false;
 					ch = r_cons_readchar ();
 				} else {
 					r_cons_break_end ();
@@ -131,7 +131,7 @@ TODO:
 					} else {
 						r_line_set_prompt (":> ");
 					}
-					showcursor (core, R_TRUE);
+					showcursor (core, true);
 					r_cons_fgets (buf+3, sizeof (buf)-4, 0, NULL);
 					memcpy (buf, "wx ", 3);
 					if (buf[3]) {
@@ -164,7 +164,7 @@ TODO:
 #else
 						r_line_set_prompt (":> ");
 #endif
-						showcursor (core, R_TRUE);
+						showcursor (core, true);
 						r_cons_fgets (buf, sizeof (buf), 0, NULL);
 						if (*buf) {
 							r_line_hist_add (buf);
@@ -174,17 +174,17 @@ TODO:
 								free (res);
 							}
 							r_cons_flush ();
-							ret = R_TRUE;
+							ret = true;
 						} else {
-							ret = R_FALSE;
+							ret = false;
 							//r_cons_any_key ();
 							r_cons_clear00 ();
-							showcursor (core, R_FALSE);
+							showcursor (core, false);
 						}
 					} while (ret);
 				}
 				break;
-			case '@': autorefresh = R_TRUE; break;
+			case '@': autorefresh = true; break;
 			case 'j':
 				if (cmdidx==1) {
 					free (rtrcmd (T, "so")); break;
@@ -396,28 +396,28 @@ static int r_core_rtr_http_run (RCore *core, int launch, const char *path) {
 		snprintf (buf, sizeof (buf), "%d", iport);
 		port = buf;
 	}
-	s = r_socket_new (R_FALSE);
+	s = r_socket_new (false);
 	{
 		if (host && *host) {
 			if (!strcmp (host, "::1")) {
-				s->local = R_TRUE;
+				s->local = true;
 			} else if (!strcmp (host, "localhost")) {
-				s->local = R_TRUE;
+				s->local = true;
 			} else if (!strcmp (host, "127.0.0.1")) {
-				s->local = R_TRUE;
+				s->local = true;
 			} else if (!strcmp (host, "local")) {
-				s->local = R_TRUE;
+				s->local = true;
 				r_config_set (core->config, "http.bind", "localhost");
 			} else if (host[0]=='0' || !strcmp (host, "public")) {
 				// public
 				r_config_set (core->config, "http.bind", "0.0.0.0");
 				host = "127.0.0.1";
-				s->local = R_FALSE;
+				s->local = false;
 			} else {
-				s->local = R_TRUE;
+				s->local = true;
 			}
 		} else {
-			s->local = R_TRUE;
+			s->local = true;
 		}
 	}
 	if (!r_socket_listen (s, port, NULL)) {
@@ -449,7 +449,7 @@ static int r_core_rtr_http_run (RCore *core, int launch, const char *path) {
 	eprintf ("Starting http server...\n");
 	eprintf ("open http://%s:%d/\n", host, atoi (port));
 	eprintf ("r2 -C http://%s:%d/cmd/\n", host, atoi (port));
-	core->http_up = R_TRUE;
+	core->http_up = true;
 
 	ut64 newoff, origoff = core->offset;
 	int newblksz, origblksz = core->blocksize;
@@ -503,7 +503,7 @@ static int r_core_rtr_http_run (RCore *core, int launch, const char *path) {
 			continue;
 		}
 		if (allow && *allow) {
-			int accepted = R_FALSE;
+			int accepted = false;
 			const char *allows_host;
 			char *p, *peer = r_socket_to_string (rs->s);
 			char *allows = strdup (allow);
@@ -515,7 +515,7 @@ static int r_core_rtr_http_run (RCore *core, int launch, const char *path) {
 				allows_host = r_str_word_get0 (allows, i);
 				//eprintf ("--- (%s) (%s)\n", host, peer);
 				if (!strcmp (allows_host, peer)) {
-					accepted = R_TRUE;
+					accepted = true;
 					break;
 				}
 			}
@@ -738,7 +738,7 @@ the_end:
 	r_config_set (core->config, "http.ui", httpui);
 }
 	r_cons_break_end ();
-	core->http_up = R_FALSE;
+	core->http_up = false;
 	r_socket_free (s);
 	r_config_free (newcfg);
 	r_config_set (origcfg, "scr.html", r_config_get (origcfg, "scr.html"));
@@ -749,9 +749,9 @@ the_end:
 
 static int r_core_rtr_http_thread (RThread *th) {
 	HttpThread *ht;
-	if (!th) return R_FALSE;
+	if (!th) return false;
 	ht = th->user;
-	if (!ht || !ht->core) return R_FALSE;
+	if (!ht || !ht->core) return false;
 	return r_core_rtr_http_run (ht->core, ht->launch, ht->path);
 }
 
@@ -928,7 +928,7 @@ R_API void r_core_rtr_add(RCore *core, const char *_input) {
 		return;
 	}
 
-	fd = r_socket_new (R_FALSE);
+	fd = r_socket_new (false);
 	if (!fd) {
 		eprintf ("Error: Cannot create new socket\n");
 		return;
@@ -1241,14 +1241,14 @@ R_API int r_core_rtr_cmds (RCore *core, const char *port) {
 
 	if (!port || port[0]=='?') {
 		r_cons_printf ("Usage: .:[tcp-port]    run r2 commands for clients\n");
-		return R_FALSE;
+		return false;
 	}
 
 	s = r_socket_new (0);
 	if (!r_socket_listen (s, port, NULL)) {
 		eprintf ("Error listening on port %s\n", port);
 		r_socket_free (s);
-		return R_FALSE;
+		return false;
 	}
 
 	eprintf ("Listening for commands on port %s\n", port);
diff --git a/libr/core/task.c b/libr/core/task.c
index c631f568e..e357b3328 100644
--- a/libr/core/task.c
+++ b/libr/core/task.c
@@ -111,7 +111,7 @@ R_API int r_core_task_cat (RCore *core, int id) {
 	RCoreTask *task = r_core_task_get (core, id);
 	r_cons_printf ("%s\n", task->msg->res);
 	r_core_task_del (core, id);
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_task_del (RCore *core, int id) {
@@ -120,15 +120,15 @@ R_API int r_core_task_del (RCore *core, int id) {
 	if (id == -1) {
 		r_list_free (core->tasks);
 		core->tasks = r_list_new ();
-		return R_TRUE;
+		return true;
 	}
 	r_list_foreach (core->tasks, iter, task) {
 		if (task->id == id) {
 			r_list_delete (core->tasks, iter);
-			return R_TRUE;
+			return true;
 		}
 	}
-	return R_FALSE;
+	return false;
 }
 
 R_API RCoreTask *r_core_task_get (RCore *core, int id) {
diff --git a/libr/core/visual.c b/libr/core/visual.c
index 3490af366..0ec87aaea 100644
--- a/libr/core/visual.c
+++ b/libr/core/visual.c
@@ -59,7 +59,7 @@ static void visual_repeat(RCore *core) {
 		r_cons_break (NULL, NULL);
 		r_cons_any_key (NULL);
 		eprintf ("^C  \n");
-		core->cons->breaked = R_TRUE;
+		core->cons->breaked = true;
 		r_th_wait (th);
 		r_cons_break_end ();
 	}
@@ -73,13 +73,13 @@ static void showcursor(RCore *core, int x) {
 			// TODO: cache this
 			int wheel = r_config_get_i (core->config, "scr.wheel");
 			if (wheel)
-				r_cons_enable_mouse (R_TRUE);
+				r_cons_enable_mouse (true);
 			else
-				r_cons_enable_mouse (R_FALSE);
+				r_cons_enable_mouse (false);
 		} else {
-			r_cons_enable_mouse (R_FALSE);
+			r_cons_enable_mouse (false);
 		}
-	} else r_cons_enable_mouse (R_FALSE);
+	} else r_cons_enable_mouse (false);
 	r_cons_flush ();
 }
 
@@ -99,7 +99,7 @@ R_API int r_core_visual_hud(RCore *core) {
 	char *res = NULL;
 	char *p = 0;
 
-	showcursor (core, R_TRUE);
+	showcursor (core, true);
 	if (c && *c && r_file_exists (c))
 		res = r_cons_hud_file (c);
 	if (!res && homehud)
@@ -117,7 +117,7 @@ R_API int r_core_visual_hud(RCore *core) {
 		if (p) r_core_cmd0 (core, p+1);
 		free (res);
 	}
-	showcursor (core, R_FALSE);
+	showcursor (core, false);
 	r_cons_flush ();
 	free (homehud);
 	return (int)(size_t)p;
@@ -204,9 +204,9 @@ static void r_core_visual_mark(RCore *core, ut8 ch) {
 
 static void prompt_read (const char *p, char *buf, int buflen) {
 	r_line_set_prompt (p);
-	showcursor (NULL, R_TRUE);
+	showcursor (NULL, true);
 	r_cons_fgets (buf, buflen, 0, NULL);
-	showcursor (NULL, R_FALSE);
+	showcursor (NULL, false);
 }
 
 R_API void r_core_visual_prompt_input (RCore *core) {
@@ -217,8 +217,8 @@ R_API void r_core_visual_prompt_input (RCore *core) {
 	r_cons_reset_colors();
 	r_cons_printf("\nPress <enter> to return to Visual mode.\n");
 
-	r_cons_show_cursor (R_TRUE);
-	core->vmode = R_FALSE;
+	r_cons_show_cursor (true);
+	core->vmode = false;
 	ut64 newaddr = addr;
 	if (curset) {
 		if (ocursor != -1) {
@@ -240,8 +240,8 @@ R_API void r_core_visual_prompt_input (RCore *core) {
 			r_core_block_size (core, bsze);
 		}
 	}
-	r_cons_show_cursor (R_FALSE);
-	core->vmode = R_TRUE;
+	r_cons_show_cursor (false);
+	core->vmode = true;
 }
 
 R_API int r_core_visual_prompt (RCore *core) {
@@ -252,20 +252,20 @@ R_API int r_core_visual_prompt (RCore *core) {
 #else
 	r_line_set_prompt (":> ");
 #endif
-	showcursor (core, R_TRUE);
+	showcursor (core, true);
 	r_cons_fgets (buf, sizeof (buf), 0, NULL);
 	if (!strcmp (buf, "q")) {
-		ret = R_FALSE;
+		ret = false;
 	} else if (*buf) {
 		r_line_hist_add (buf);
 		r_core_cmd (core, buf, 0);
 		r_cons_flush ();
-		ret = R_TRUE;
+		ret = true;
 	} else {
-		ret = R_FALSE;
+		ret = false;
 		//r_cons_any_key (NULL);
 		r_cons_clear00 ();
-		showcursor (core, R_FALSE);
+		showcursor (core, false);
 	}
 	return ret;
 }
@@ -388,7 +388,7 @@ static void findPair (RCore *core) {
 	if (q) {
 		cursor = (int)(size_t)(q-core->block);
 		ocursor = -1;
-		showcursor (core, R_TRUE);
+		showcursor (core, true);
 	}
 }
 
@@ -403,7 +403,7 @@ static void findNextWord (RCore *core) {
 			if (curset) {
 				cursor = i+1;
 				ocursor = -1;
-				showcursor (core, R_TRUE);
+				showcursor (core, true);
 			} else {
 				r_core_seek (core, core->offset + i + 1, 1);
 			}
@@ -438,7 +438,7 @@ static void findPrevWord (RCore *core) {
 			if (curset) {
 				cursor = i+1;
 				ocursor = -1;
-				showcursor (core, R_TRUE);
+				showcursor (core, true);
 			} else {
 				// r_core_seek (core, core->offset + i + 1, 1);
 			}
@@ -472,7 +472,7 @@ static void visual_search (RCore *core) {
 		if (len>1) {
 			ocursor = cursor+len-1;
 		} else ocursor = -1;
-		showcursor (core, R_TRUE);
+		showcursor (core, true);
 		eprintf ("FOUND IN %d\n", cursor);
 		r_cons_any_key (NULL);
 	} else {
@@ -744,7 +744,7 @@ R_API int r_core_visual_cmd(RCore *core, int ch) {
 			RAnalOp *op;
 			int wheel = r_config_get_i (core->config, "scr.wheel");
 			if (wheel)
-				r_cons_enable_mouse (R_TRUE);
+				r_cons_enable_mouse (true);
 			do {
 				op = r_core_anal_op (core, core->offset+cursor);
 				if (op) {
@@ -789,22 +789,22 @@ R_API int r_core_visual_cmd(RCore *core, int ch) {
 		if (core->file && core->file->desc && !(core->file->desc->flags & 2)) {
 			r_cons_printf ("\nFile has been opened in read-only mode. Use -w flag\n");
 			r_cons_any_key (NULL);
-			return R_TRUE;
+			return true;
 		}
 		r_cons_printf ("Enter assembler opcodes separated with ';':\n");
-		showcursor (core, R_TRUE);
+		showcursor (core, true);
 		r_cons_flush ();
-		r_cons_set_raw (R_FALSE);
+		r_cons_set_raw (false);
 		strcpy (buf, "wa ");
 		r_line_set_prompt (":> ");
 		if (r_cons_fgets (buf+3, 1000, 0, NULL) <0) buf[0]='\0';
 		if (*buf) {
 			if (curset) r_core_seek (core, core->offset + cursor, 0);
-			r_core_cmd (core, buf, R_TRUE);
+			r_core_cmd (core, buf, true);
 			if (curset) r_core_seek (core, core->offset - cursor, 1);
 		}
-		showcursor (core, R_FALSE);
-		r_cons_set_raw (R_TRUE);
+		showcursor (core, false);
+		r_cons_set_raw (true);
 		break;
 	case '=':
 		{ // TODO: edit
@@ -859,9 +859,9 @@ R_API int r_core_visual_cmd(RCore *core, int ch) {
 	case 'd':
 		{
 			int wheel = r_config_get_i (core->config, "scr.wheel");
-			if (wheel) r_cons_enable_mouse (R_FALSE);
+			if (wheel) r_cons_enable_mouse (false);
 			r_core_visual_define (core);
-			if (wheel) r_cons_enable_mouse (R_TRUE);
+			if (wheel) r_cons_enable_mouse (true);
 		}
 		break;
 	case 'D':
@@ -872,7 +872,7 @@ R_API int r_core_visual_cmd(RCore *core, int ch) {
 		int range, min, max;
 		char name[256], *n;
 		r_line_set_prompt ("flag name: ");
-		showcursor (core, R_TRUE);
+		showcursor (core, true);
 		if (r_cons_fgets (name, sizeof (name), 0, NULL) >=0 && *name) {
 			n = r_str_chop (name);
 			if (ocursor != -1) {
@@ -899,7 +899,7 @@ R_API int r_core_visual_cmd(RCore *core, int ch) {
 					core->offset + min, range, 1);
 			}
 		} }
-		showcursor (core, R_FALSE);
+		showcursor (core, false);
 		break;
 	case 'T':
 		if (r_sandbox_enable (0)) {
@@ -920,9 +920,9 @@ R_API int r_core_visual_cmd(RCore *core, int ch) {
 		if (core->file && core->file->desc &&!(core->file->desc->flags & 2)) {
 			r_cons_printf ("\nFile has been opened in read-only mode. Use -w flag\n");
 			r_cons_any_key (NULL);
-			return R_TRUE;
+			return true;
 		}
-		showcursor (core, R_TRUE);
+		showcursor (core, true);
 		r_cons_flush ();
 		r_cons_set_raw (0);
 		if (ch=='I') {
@@ -963,7 +963,7 @@ R_API int r_core_visual_cmd(RCore *core, int ch) {
 		r_core_cmd (core, buf, 1);
 		if (curset) r_core_seek (core, offset, 1);
 		r_cons_set_raw (1);
-		showcursor (core, R_FALSE);
+		showcursor (core, false);
 		break;
 	case 'R':
 		r_core_cmd0 (core, "ecr");
@@ -1040,7 +1040,7 @@ R_API int r_core_visual_cmd(RCore *core, int ch) {
 			RAnalFunction *fun = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);
 			if (fun) {
 				int ocolor = r_config_get_i (core->config, "scr.color");
-				r_core_visual_graph (core, NULL, R_TRUE);
+				r_core_visual_graph (core, NULL, true);
 				r_config_set_i (core->config, "scr.color", ocolor);
 			} else {
 				r_cons_message("Not in a function. Type 'df' to define it here");
@@ -1439,9 +1439,9 @@ R_API int r_core_visual_cmd(RCore *core, int ch) {
 		break;
 	case ';':
 		r_cons_printf ("Enter a comment: ('-' to remove, '!' to use $EDITOR)\n");
-		showcursor (core, R_TRUE);
+		showcursor (core, true);
 		r_cons_flush ();
-		r_cons_set_raw (R_FALSE);
+		r_cons_set_raw (false);
 		strcpy (buf, "\"CC ");
 		r_line_set_prompt ("comment: ");
 		i = strlen (buf);
@@ -1466,8 +1466,8 @@ R_API int r_core_visual_cmd(RCore *core, int ch) {
 			r_core_cmd (core, buf, 1);
 			if (curset) r_core_seek (core, orig, 1);
 		}
-		r_cons_set_raw (R_TRUE);
-		showcursor (core, R_FALSE);
+		r_cons_set_raw (true);
+		showcursor (core, false);
 		break;
 	case 'b':
 		{
@@ -1518,10 +1518,10 @@ R_API int r_core_visual_cmd(RCore *core, int ch) {
 	case 'q':
 	case 'Q':
 		setcursor (core, 0);
-		return R_FALSE;
+		return false;
 	}
 	r_core_block_read (core, 0);
-	return R_TRUE;
+	return true;
 }
 
 #define PIDX (R_ABS(core->printidx%NPF))
@@ -1622,7 +1622,7 @@ static void r_core_visual_refresh (RCore *core) {
 	if (!core) return;
 	w = r_cons_get_size (&h);
 	r_print_set_cursor (core->print, curset, ocursor, cursor);
-	core->cons->blankline = R_TRUE;
+	core->cons->blankline = true;
 
 	if (r_config_get_i (core->config, "scr.responsive")) {
 		if (w<110) {
@@ -1670,7 +1670,7 @@ static void r_core_visual_refresh (RCore *core) {
 	vi = r_config_get (core->config, "cmd.cprompt");
 	if (vi && *vi) {
 		// XXX: slow
-		core->cons->blankline = R_FALSE;
+		core->cons->blankline = false;
 		r_cons_clear00 ();
 		r_cons_flush ();
 		{
@@ -1714,7 +1714,7 @@ static void r_core_visual_refresh (RCore *core) {
 
 	/* this is why there's flickering */
 	r_cons_visual_flush ();
-	core->cons->blankline = R_TRUE;
+	core->cons->blankline = true;
 }
 
 R_API int r_core_visual(RCore *core, const char *input) {
@@ -1728,15 +1728,15 @@ R_API int r_core_visual(RCore *core, const char *input) {
 	}
 
 	obs = core->blocksize;
-	//r_cons_set_cup (R_TRUE);
+	//r_cons_set_cup (true);
 
-	core->vmode = R_FALSE;
+	core->vmode = false;
 	while (*input) {
 		if (!r_core_visual_cmd (core, input[0]))
 			return 0;
 		input++;
 	}
-	core->vmode = R_TRUE;
+	core->vmode = true;
 
 	// disable tee in cons
 	teefile = r_cons_singleton ()->teefile;
@@ -1776,9 +1776,9 @@ R_API int r_core_visual(RCore *core, const char *input) {
 			printfmt[2] = debugstr;
 		}
 		wheel = r_config_get_i (core->config, "scr.wheel");
-		r_cons_show_cursor (R_FALSE);
+		r_cons_show_cursor (false);
 		if (wheel)
-			r_cons_enable_mouse (R_TRUE);
+			r_cons_enable_mouse (true);
 		core->cons->event_data = core;
 		core->cons->event_resize = (RConsEvent)r_core_visual_refresh;
 		flags = core->print->flags;
@@ -1802,19 +1802,19 @@ R_API int r_core_visual(RCore *core, const char *input) {
 		if (ch==-1 || ch==4) break; // error or eof
 	} while (r_core_visual_cmd (core, ch));
 
-	r_cons_enable_mouse (R_FALSE);
+	r_cons_enable_mouse (false);
 	if (color)
 		r_cons_printf (Color_RESET);
 	r_config_set_i (core->config, "scr.color", color);
-	core->print->cur_enabled = R_FALSE;
+	core->print->cur_enabled = false;
 	if (autoblocksize)
 		r_core_block_size (core, obs);
 	r_cons_singleton ()->teefile = teefile;
-	r_cons_set_cup (R_FALSE);
+	r_cons_set_cup (false);
 	r_cons_clear00 ();
-	core->vmode = R_FALSE;
+	core->vmode = false;
 	core->cons->event_resize = NULL;
 	core->cons->event_data = NULL;
-	r_cons_show_cursor (R_TRUE);
+	r_cons_show_cursor (true);
 	return 0;
 }
diff --git a/libr/core/vmenus.c b/libr/core/vmenus.c
index 3d5ad6143..7845fae10 100644
--- a/libr/core/vmenus.c
+++ b/libr/core/vmenus.c
@@ -9,7 +9,7 @@ static char *prompt(const char *str, const char *txt) {
 	char cmd[1024];
 	char *res = NULL;
 	char *oprompt = strdup (r_cons_singleton()->line->prompt);
-	r_cons_show_cursor (R_TRUE);
+	r_cons_show_cursor (true);
 	if (txt && *txt) {
 		free (r_cons_singleton ()->line->contents);
 		r_cons_singleton ()->line->contents = strdup (txt);
@@ -159,7 +159,7 @@ R_API int r_core_visual_types(RCore *core) {
 
 		r_cons_visual_flush ();
 		ch = r_cons_readchar ();
-		if (ch==-1||ch==4) return R_FALSE;
+		if (ch==-1||ch==4) return false;
 		ch = r_cons_arrow_to_hjkl (ch); // get ESC+char, return 'hjkl' char
 		switch (ch) {
 		case 'h':
@@ -196,14 +196,14 @@ R_API int r_core_visual_types(RCore *core) {
 				  R_FREE (optword);
 				  break;
 			  }
-			if (menu<=0) return R_TRUE; menu--;
+			if (menu<=0) return true; menu--;
 			option = _option;
 			if (menu==0) {
 				// if no flagspaces, just quit
 				for (j=i=0;i<R_FLAG_SPACES_MAX;i++)
 					if (core->flags->spaces[i])
 						j = 1;
-				if (!j) return R_TRUE;
+				if (!j) return true;
 			}
 			break;
 		case 'a':
@@ -264,7 +264,7 @@ R_API int r_core_visual_types(RCore *core) {
 			r_cons_any_key (NULL);
 			break;
 		case ':':
-			r_cons_show_cursor (R_TRUE);
+			r_cons_show_cursor (true);
 			r_cons_set_raw (0);
 			cmd[0]='\0';
 			r_line_set_prompt (":> ");
@@ -273,7 +273,7 @@ R_API int r_core_visual_types(RCore *core) {
 			//line[strlen(line)-1]='\0';
 			r_core_cmd (core, cmd, 1);
 			r_cons_set_raw (1);
-			r_cons_show_cursor (R_FALSE);
+			r_cons_show_cursor (false);
 			if (cmd[0])
 				r_cons_any_key (NULL);
 			//cons_gotoxy(0,0);
@@ -281,7 +281,7 @@ R_API int r_core_visual_types(RCore *core) {
 			continue;
 		}
 	}
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_visual_trackflags(RCore *core) {
@@ -380,7 +380,7 @@ R_API int r_core_visual_trackflags(RCore *core) {
 		}
 		r_cons_visual_flush ();
 		ch = r_cons_readchar ();
-		if (ch==-1||ch==4) return R_FALSE;
+		if (ch==-1||ch==4) return false;
 		ch = r_cons_arrow_to_hjkl (ch); // get ESC+char, return 'hjkl' char
 		switch (ch) {
 		case 'C':
@@ -395,36 +395,36 @@ R_API int r_core_visual_trackflags(RCore *core) {
 		case 'h':
 		case 'b': // back
 		case 'q':
-			if (menu<=0) return R_TRUE; menu--;
+			if (menu<=0) return true; menu--;
 			option = _option;
 			if (menu==0) {
 				// if no flagspaces, just quit
 				for (j=i=0;i<R_FLAG_SPACES_MAX;i++)
 					if (core->flags->spaces[i])
 						j = 1;
-				if (!j) return R_TRUE;
+				if (!j) return true;
 			}
 			break;
 		case 'a':
 			switch (menu) {
 			case 0: // new flag space
-				r_cons_show_cursor (R_TRUE);
+				r_cons_show_cursor (true);
 				r_line_set_prompt ("add flagspace: ");
 				strcpy (cmd, "fs ");
 				if (r_cons_fgets (cmd+3, sizeof (cmd)-4, 0, NULL) > 0) {
 					r_core_cmd (core, cmd, 0);
 					r_cons_set_raw (1);
-					r_cons_show_cursor (R_FALSE);
+					r_cons_show_cursor (false);
 				}
 				break;
 			case 1: // new flag
-				r_cons_show_cursor (R_TRUE);
+				r_cons_show_cursor (true);
 				r_line_set_prompt ("add flag: ");
 				strcpy (cmd, "f ");
 				if (r_cons_fgets (cmd+2, sizeof (cmd)-3, 0, NULL) > 0) {
 					r_core_cmd (core, cmd, 0);
 					r_cons_set_raw (1);
-					r_cons_show_cursor (R_FALSE);
+					r_cons_show_cursor (false);
 				}
 				break;
 			}
@@ -456,7 +456,7 @@ R_API int r_core_visual_trackflags(RCore *core) {
 		case 'r': // "Vtr"
 			if (menu == 1) {
 				int len;
-				r_cons_show_cursor (R_TRUE);
+				r_cons_show_cursor (true);
 				r_cons_set_raw (0);
 				// TODO: use r_flag_rename or wtf?..fr doesnt uses this..
 				snprintf (cmd, sizeof (cmd), "fr %s ", fs2);
@@ -467,13 +467,13 @@ R_API int r_core_visual_trackflags(RCore *core) {
 					cmd[0]='\0';
 				r_core_cmd (core, cmd, 0);
 				r_cons_set_raw (1);
-				r_cons_show_cursor (R_FALSE);
+				r_cons_show_cursor (false);
 			}
 			break;
 		case 'R':
 			if (menu == 1) {
 				char line[1024];
-				r_cons_show_cursor (R_TRUE);
+				r_cons_show_cursor (true);
 				r_cons_set_raw (0);
 				eprintf ("Rename function '%s' as:\n", fs2);
 				r_line_set_prompt (":> ");
@@ -482,7 +482,7 @@ R_API int r_core_visual_trackflags(RCore *core) {
 				snprintf (cmd, sizeof (cmd), "afr %s %s", line, fs2);
 				r_core_cmd (core, cmd, 0);
 				r_cons_set_raw (1);
-				r_cons_show_cursor (R_FALSE);
+				r_cons_show_cursor (false);
 			}
 			break;
 		case 'P': if (--format<0) format = MAX_FORMAT; break;
@@ -495,7 +495,7 @@ R_API int r_core_visual_trackflags(RCore *core) {
 			if (menu == 1) {
 				sprintf (cmd, "s %s", fs2);
 				r_core_cmd (core, cmd, 0);
-				return R_TRUE;
+				return true;
 			}
 			r_flag_space_set (core->flags, fs);
 			menu = 1;
@@ -522,7 +522,7 @@ R_API int r_core_visual_trackflags(RCore *core) {
 			r_cons_any_key (NULL);
 			break;
 		case ':':
-			r_cons_show_cursor (R_TRUE);
+			r_cons_show_cursor (true);
 			r_cons_set_raw (0);
 			cmd[0]='\0';
 			r_line_set_prompt (":> ");
@@ -531,7 +531,7 @@ R_API int r_core_visual_trackflags(RCore *core) {
 			//line[strlen(line)-1]='\0';
 			r_core_cmd (core, cmd, 1);
 			r_cons_set_raw (1);
-			r_cons_show_cursor (R_FALSE);
+			r_cons_show_cursor (false);
 			if (cmd[0])
 				r_cons_any_key (NULL);
 			//cons_gotoxy(0,0);
@@ -539,7 +539,7 @@ R_API int r_core_visual_trackflags(RCore *core) {
 			continue;
 		}
 	}
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_visual_comments (RCore *core) {
@@ -652,11 +652,11 @@ R_API int r_core_visual_comments (RCore *core) {
 			r_core_cmd (core, cmd, 0);
 			if (p)
 				free (p);
-			return R_TRUE;
+			return true;
 		case 'q':
 			if (p)
 				free (p);
-			return R_TRUE;
+			return true;
 		case '?':
 		case 'h':
 			r_cons_clear00 ();
@@ -677,7 +677,7 @@ R_API int r_core_visual_comments (RCore *core) {
 			p = NULL;
 		}
 	}
-	return R_TRUE;
+	return true;
 }
 
 static void config_visual_hit_i(RCore *core, const char *name, int delta) {
@@ -705,13 +705,13 @@ static void config_visual_hit(RCore *core, const char *name, int editor) {
 		} else {
 			// FGETS AND SO
 			r_cons_printf ("New value (old=%s): \n", node->value);
-			r_cons_show_cursor (R_TRUE);
+			r_cons_show_cursor (true);
 			r_cons_flush ();
 			r_cons_set_raw (0);
 			r_line_set_prompt (":> ");
 			r_cons_fgets (buf, sizeof (buf)-1, 0, 0);
 			r_cons_set_raw (1);
-			r_cons_show_cursor (R_FALSE);
+			r_cons_show_cursor (false);
 			r_config_set (core->config, name, buf);
 			//node->value = r_str_dup (node->value, buf);
 		}
@@ -858,7 +858,7 @@ R_API void r_core_visual_config(RCore *core) {
 			r_cons_any_key (NULL);
 			break;
 		case ':':
-			r_cons_show_cursor (R_TRUE);
+			r_cons_show_cursor (true);
 			r_cons_set_raw(0);
 			 {
 				char *cmd = prompt (":> ", NULL);
@@ -866,7 +866,7 @@ R_API void r_core_visual_config(RCore *core) {
 				free (cmd);
 			 }
 			r_cons_set_raw (1);
-			r_cons_show_cursor (R_FALSE);
+			r_cons_show_cursor (false);
 			r_cons_any_key (NULL);
 			r_cons_clear00 ();
 			continue;
@@ -1121,12 +1121,12 @@ R_API void r_core_visual_mounts (RCore *core) {
 						file = r_fs_open (core->fs, path);
 						if (file) {
 							r_fs_read (core->fs, file, 0, file->size);
-							r_cons_show_cursor (R_TRUE);
+							r_cons_show_cursor (true);
 							r_cons_set_raw (0);
 							r_line_set_prompt ("Dump path (ej: /tmp/file): ");
 							r_cons_fgets (buf, sizeof (buf)-1, 0, 0);
 							r_cons_set_raw (1);
-							r_cons_show_cursor (R_FALSE);
+							r_cons_show_cursor (false);
 							r_file_dump (buf, file->data, file->size, 0);
 							r_fs_close (core->fs, file);
 							r_cons_printf ("Done\n");
@@ -1156,12 +1156,12 @@ R_API void r_core_visual_mounts (RCore *core) {
 				r_cons_any_key (NULL);
 				break;
 			case ':':
-				r_cons_show_cursor (R_TRUE);
+				r_cons_show_cursor (true);
 				r_cons_set_raw (0);
 				r_line_set_prompt (":> ");
 				r_cons_fgets (buf, sizeof (buf)-1, 0, 0);
 				r_cons_set_raw (1);
-				r_cons_show_cursor (R_FALSE);
+				r_cons_show_cursor (false);
 				r_core_cmd (core, buf, 1);
 				r_cons_any_key (NULL);
 				break;
@@ -1378,8 +1378,8 @@ R_API void r_core_visual_anal(RCore *core) {
 			case 0:
 				eprintf ("TODO: Add new function manually\n");
 /*
-				r_cons_show_cursor (R_TRUE);
-				r_cons_set_raw (R_FALSE);
+				r_cons_show_cursor (true);
+				r_cons_set_raw (false);
 				r_line_set_prompt ("Address: ");
 				if (!r_cons_fgets (old, sizeof (old), 0, NULL)) break;
 				old[strlen (old)-1] = 0;
@@ -1396,8 +1396,8 @@ R_API void r_core_visual_anal(RCore *core) {
 				r_flag_set (core->flags, old, addr, 0, 0);
 				//XXX sprintf(cmd, "CF %lld @ 0x%08llx", size, addr);
 				// XXX r_core_cmd0(core, cmd);
-				r_cons_set_raw (R_TRUE);
-				r_cons_show_cursor (R_FALSE);
+				r_cons_set_raw (true);
+				r_cons_show_cursor (false);
 */
 				break;
 			case 1:
@@ -1405,14 +1405,14 @@ R_API void r_core_visual_anal(RCore *core) {
 			}
 			break;
 		case 'm':
-			r_cons_show_cursor (R_TRUE);
-			r_cons_set_raw (R_FALSE);
+			r_cons_show_cursor (true);
+			r_cons_set_raw (false);
 			r_line_set_prompt ("New name: ");
 			if (!r_cons_fgets (old, sizeof (old), 0, NULL)) break;
 			//old[strlen (old)-1] = 0;
 			function_rename (core, addr, old);
-			r_cons_set_raw (R_TRUE);
-			r_cons_show_cursor (R_FALSE);
+			r_cons_set_raw (true);
+			r_cons_show_cursor (false);
 			break;
 		case 'd':
 			switch (level) {
@@ -1595,7 +1595,7 @@ R_API void r_core_visual_define (RCore *core) {
 	case 'F':
 		{
 			char cmd[128];
-			r_cons_show_cursor (R_TRUE);
+			r_cons_show_cursor (true);
 			r_core_cmd0 (core, "pf?");
 			r_cons_flush ();
 			r_line_set_prompt ("format: ");
@@ -1603,7 +1603,7 @@ R_API void r_core_visual_define (RCore *core) {
 			if (r_cons_fgets (cmd+5, sizeof (cmd)-6, 0, NULL) > 0) {
 				r_core_cmd (core, cmd, 0);
 				r_cons_set_raw (1);
-				r_cons_show_cursor (R_FALSE);
+				r_cons_show_cursor (false);
 			}
 		}
 		break;
@@ -1647,13 +1647,13 @@ R_API void r_core_visual_define (RCore *core) {
 			RFlagItem *item = r_flag_get_i (core->flags, off);
 			if (item) {
 				char cmd[128];
-				r_cons_show_cursor (R_TRUE);
+				r_cons_show_cursor (true);
 				r_cons_flush ();
 				r_line_set_prompt ("color: ");
 				if (r_cons_fgets (cmd, sizeof (cmd)-1, 0, NULL) > 0) {
 					r_flag_color (core->flags, item, cmd);
 					r_cons_set_raw (1);
-					r_cons_show_cursor (R_FALSE);
+					r_cons_show_cursor (false);
 				}
 			} else {
 				eprintf ("Sorry. No flag here\n");
@@ -1667,13 +1667,13 @@ R_API void r_core_visual_define (RCore *core) {
 			if (item) {
 				char cmd[128];
 				r_cons_printf ("Current flag size is: %d\n", item->size);
-				r_cons_show_cursor (R_TRUE);
+				r_cons_show_cursor (true);
 				r_cons_flush ();
 				r_line_set_prompt ("new size: ");
 				if (r_cons_fgets (cmd, sizeof (cmd)-1, 0, NULL) > 0) {
 					item->size = r_num_math (core->num, cmd);
 					r_cons_set_raw (1);
-					r_cons_show_cursor (R_FALSE);
+					r_cons_show_cursor (false);
 				}
 			} else {
 				eprintf ("Sorry. No flag here\n");
diff --git a/libr/core/yank.c b/libr/core/yank.c
index 280940562..799c5224a 100644
--- a/libr/core/yank.c
+++ b/libr/core/yank.c
@@ -39,7 +39,7 @@ static int perform_mapped_file_yank (RCore *core, ut64 offset, ut64 len, const c
 	RIODesc *yankfd = NULL;
 	ut64 fd = core->file ? core->file->desc->fd : -1, yank_file_sz = 0,
 		 loadaddr = 0, addr = offset;
-	int res = R_FALSE;
+	int res = false;
 
 	if (filename && *filename) {
 		ut64 load_align = r_config_get_i (core->config,
@@ -105,7 +105,7 @@ static int perform_mapped_file_yank (RCore *core, ut64 offset, ut64 len, const c
 				eprintf ("\n");
 			}*/
 			r_core_yank_set (core, R_CORE_FOREIGN_ADDR, buf, len);
-			res = R_TRUE;
+			res = true;
 		} else if (res != addr) {
 			eprintf (
 				"ERROR: Unable to yank data from file: (loadaddr (0x%"
@@ -134,9 +134,9 @@ R_API int r_core_yank_set (RCore *core, ut64 addr, const ut8 *buf, ut32 len) {
 	if (buf && len) {
 		r_buf_set_bytes (core->yank_buf, buf, len);
 		core->yank_buf->base = addr;
-		return R_TRUE;
+		return true;
 	}
-	return R_FALSE;
+	return false;
 }
 
 // Call set and then null terminate the bytes.
@@ -144,7 +144,7 @@ R_API int r_core_yank_set_str (RCore *core, ut64 addr, const char *str,
 			       ut32 len) {
 	//free (core->yank_buf);
 	int res = r_core_yank_set (core, addr, (ut8*)str, len);
-	if (res == R_TRUE)
+	if (res == true)
 		core->yank_buf->buf[len-1] = 0;
 	return res;
 }
@@ -154,7 +154,7 @@ R_API int r_core_yank(struct r_core_t *core, ut64 addr, int len) {
 	ut8 *buf = NULL;
 	if (len<0) {
 		eprintf ("r_core_yank: cannot yank negative bytes\n");
-		return R_FALSE;
+		return false;
 	}
 	if (len == 0) len = core->blocksize;
 	//free (core->yank_buf);
@@ -169,7 +169,7 @@ R_API int r_core_yank(struct r_core_t *core, ut64 addr, int len) {
 	if (curseek != addr)
 		r_core_seek (core, curseek, 1);
 	free (buf);
-	return R_TRUE;
+	return true;
 }
 
 /* Copy a zero terminated string to the clipboard. Clamp to maxlen or blocksize. */
@@ -178,14 +178,14 @@ R_API int r_core_yank_string(RCore *core, ut64 addr, int maxlen) {
 	ut8 *buf = NULL;
 	if (maxlen<0) {
 		eprintf ("r_core_yank_string: cannot yank negative bytes\n");
-		return R_FALSE;
+		return false;
 	}
 	if (addr != core->offset)
 		r_core_seek (core, addr, 1);
 	/* Ensure space and safe termination for largest possible string allowed */
 	buf = malloc (core->blocksize + 1);
 	if (!buf)
-		return R_FALSE;
+		return false;
 	buf[core->blocksize] = 0;
 	r_core_read_at (core, addr, buf, core->blocksize);
 	if (maxlen == 0) {
@@ -197,22 +197,22 @@ R_API int r_core_yank_string(RCore *core, ut64 addr, int maxlen) {
 	if (curseek != addr)
 		r_core_seek (core, curseek, 1);
 	free (buf);
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_yank_paste(RCore *core, ut64 addr, int len) {
-	if (len<0) return R_FALSE;
+	if (len<0) return false;
 	if (len == 0 || len >= core->yank_buf->length) len =
 			core->yank_buf->length;
 	r_core_write_at (core, addr, core->yank_buf->buf, len);
-	return R_TRUE;
+	return true;
 }
 
 R_API int r_core_yank_to(RCore *core, const char *_arg) {
 	ut64 len = 0;
 	ut64 pos = -1;
 	char *str, *arg;
-	int res = R_FALSE;
+	int res = false;
 
 	while (*_arg==' ') _arg++;
 	arg = strdup (_arg);
@@ -233,7 +233,7 @@ R_API int r_core_yank_to(RCore *core, const char *_arg) {
 		return res;
 	}
 
-	if (r_core_yank (core, core->offset, len) == R_TRUE)
+	if (r_core_yank (core, core->offset, len) == true)
 		res = r_core_yank_paste (core, pos, len);
 
 	free (arg);
@@ -241,7 +241,7 @@ R_API int r_core_yank_to(RCore *core, const char *_arg) {
 }
 
 R_API int r_core_yank_dump (RCore *core, ut64 pos) {
-	int res = R_FALSE, i = 0;
+	int res = false, i = 0;
 	int ybl = core->yank_buf->length;
 	if (ybl>0) {
 		if (pos<ybl) {
@@ -252,49 +252,45 @@ R_API int r_core_yank_dump (RCore *core, ut64 pos) {
 				r_cons_printf ("%02x",
 					core->yank_buf->buf[i]);
 			r_cons_newline ();
-			res = R_TRUE;
+			res = true;
 		} else eprintf ("Position exceeds buffer length.\n");
 	} else eprintf ("No buffer yanked already\n");
 	return res;
 }
 
 R_API int r_core_yank_hexdump (RCore *core, ut64 pos) {
-	int res = R_FALSE;
+	int res = false;
 	int ybl = core->yank_buf->length;
 	if (ybl>0) {
 		if (pos < ybl) {
 			r_print_hexdump (core->print, pos,
 				core->yank_buf->buf+pos,
 				ybl-pos, 16, 4);
-			res = R_TRUE;
+			res = true;
 		} else eprintf ("Position exceeds buffer length.\n");
 	} else eprintf ("No buffer yanked already\n");
 	return res;
 }
 
 R_API int r_core_yank_cat (RCore *core, ut64 pos) {
-	int res = R_FALSE;
 	int ybl = core->yank_buf->length;
 	if (ybl>0) {
 		if (pos < ybl) {
 			r_cons_memcat ((const char*)core->yank_buf->buf+pos,
 				core->yank_buf->length-pos);
 			r_cons_newline ();
-			res = R_TRUE;
+			return true;
 		} else eprintf ("Position exceeds buffer length.\n");
 	} else r_cons_newline ();
-	return res;
+	return false;
 }
 
 R_API int r_core_yank_hud_file (RCore *core, const char *input) {
 	char *buf = NULL;
+	_Bool res = false;
 	ut32 len = 0;
-	int res = R_FALSE;
-	
-	if (!input || !*input) return res;
-
+	if (!input || !*input) return false;
 	for (input++; *input==' '; input++) ;
-
 	buf = r_cons_hud_file (input);
 	len = buf ? strlen ((const char*)buf) + 1 : 0;
 	res = r_core_yank_set_str (core, R_CORE_FOREIGN_ADDR, buf, len);
@@ -305,18 +301,15 @@ R_API int r_core_yank_hud_file (RCore *core, const char *input) {
 R_API int r_core_yank_hud_path (RCore *core, const char *input, int dir) {
 	char *buf = NULL;
 	ut32 len = 0;
-	int res = R_FALSE;
 	for (input++; *input==' '; input++) ;
-
 	buf = r_cons_hud_path (input, dir);
 	len = buf ? strlen ((const char*)buf) + 1 : 0;
-	res = r_core_yank_set_str (core, R_CORE_FOREIGN_ADDR, buf, len);
-	return res;
+	return r_core_yank_set_str (core, R_CORE_FOREIGN_ADDR, buf, len);
 }
 
 R_API int r_core_yank_file_ex (RCore *core, const char *input) {
 	ut64 len = 0, adv = 0, addr = 0;
-	int res = R_FALSE;
+	int res = false;
 
 	if (!input) return res;
 
@@ -354,7 +347,7 @@ R_API int r_core_yank_file_ex (RCore *core, const char *input) {
 
 R_API int r_core_yank_file_all (RCore *core, const char *input) {
 	ut64 adv = 0;
-	if (!input) return R_FALSE;
+	if (!input) return false;
 	adv = consume_chars (input, ' ');
 	IFDBG eprintf ("Filename: %s\n", input+adv);
 	return perform_mapped_file_yank (core, 0, -1, input+adv);

