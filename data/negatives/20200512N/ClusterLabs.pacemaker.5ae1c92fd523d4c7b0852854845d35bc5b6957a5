commit 5ae1c92fd523d4c7b0852854845d35bc5b6957a5
Author: David Vossel <dvossel@redhat.com>
Date:   Wed Jun 13 17:38:09 2012 -0500

    High: crmd: cl#5068 - Fixes crm_node -R option so it works with corosync 2.0
    
    The -R option for crm_node previously worked by connecting to the
    cluster and sending out a command to all the nodes to clear
    their peer cache for a specific node.  Now that cpg is used for
    membership and communication between all the components across
    the cluster, this method would not work.  Crm_node can not connect
    to the crmd cpg to tell everyone to do something because it confuse
    the membership layer of the crmd.  To enable this functionality
    with use of corosync 2.0, a new ipc operation is created for crmd.
    This operation allows crm_node to tell the local crmd process to
    broadcast to everyone in the cgp to clear a node from their cache.

diff --git a/crmd/messages.c b/crmd/messages.c
index 0a5f8c794..5d8e823f0 100644
--- a/crmd/messages.c
+++ b/crmd/messages.c
@@ -777,6 +777,17 @@ handle_request(xmlNode * stored_msg)
         /* probably better to do this via signals on the
          * local node
          */
+
+    } else if (strcmp(op, CRM_OP_RM_NODE_CACHE) == 0) {
+        xmlNode *options = get_xpath_object("//"XML_TAG_OPTIONS, stored_msg, LOG_ERR);
+        int id = 0;
+
+        if (options) {
+           crm_element_value_int(options, XML_ATTR_ID, &id);
+        }
+        if (id) {
+            reap_crm_member(id);
+        }
     } else if (strcmp(op, CRM_OP_DEBUG_UP) == 0) {
         crm_bump_log_level();
         crm_info("Debug set to %d", get_crm_log_level());
diff --git a/include/crm/crm.h b/include/crm/crm.h
index 57f5de883..46086bc31 100644
--- a/include/crm/crm.h
+++ b/include/crm/crm.h
@@ -146,6 +146,7 @@ extern const char *crm_system_name;
 #  define CRM_OP_REPROBE		"probe_again"
 #  define CRM_OP_CLEAR_FAILCOUNT  "clear_failcount"
 #  define CRM_OP_RELAXED_SET  "one-or-more"
+#  define CRM_OP_RM_NODE_CACHE "rm_node_cache"
 
 #  define CRMD_STATE_ACTIVE	"member"
 #  define CRMD_STATE_INACTIVE	"down"
diff --git a/tools/crm_node.c b/tools/crm_node.c
index d2f70a01b..bfaee067d 100644
--- a/tools/crm_node.c
+++ b/tools/crm_node.c
@@ -486,6 +486,56 @@ node_mcp_destroy(gpointer user_data)
     exit(1);
 }
 
+static int
+crmd_remove_node_cache(int id)
+{
+    int rc = -1;
+    char *admin_uuid = NULL;
+    crm_ipc_t *conn = crm_ipc_new(CRM_SYSTEM_CRMD, 0);
+    xmlNode *cmd = NULL;
+    xmlNode *hello = NULL;
+    xmlNode *msg_data = NULL;
+
+    if (!conn) {
+        goto rm_node_cleanup;
+    }
+
+    if (!crm_ipc_connect(conn)) {
+        goto rm_node_cleanup;
+    }
+
+    crm_malloc0(admin_uuid, 11);
+    snprintf(admin_uuid, 10, "%d", getpid());
+    admin_uuid[10] = '\0';
+
+    hello = create_hello_message(admin_uuid, "crm_node", "0", "1");
+    rc = crm_ipc_send(conn, hello, NULL, 0);
+    if (rc < 0) {
+        goto rm_node_cleanup;
+    }
+
+    msg_data = create_xml_node(NULL, XML_TAG_OPTIONS);
+    crm_xml_add_int(msg_data, XML_ATTR_ID, id);
+    cmd = create_request(CRM_OP_RM_NODE_CACHE,
+        msg_data,
+        NULL,
+        CRM_SYSTEM_CRMD,
+        "crm_node",
+        admin_uuid);
+
+    rc = crm_ipc_send(conn, cmd, NULL, 0);
+
+rm_node_cleanup:
+    if (conn) {
+        crm_ipc_close(conn);
+        crm_ipc_destroy(conn);
+    }
+    free_xml(cmd);
+    free_xml(hello);
+    free(admin_uuid);
+    return rc > 0 ? 0 : rc;
+}
+
 static gboolean
 try_corosync(int command, enum cluster_type_e stack)
 {
@@ -506,6 +556,10 @@ try_corosync(int command, enum cluster_type_e stack)
         };
 
     switch (command) {
+        case 'R':
+            if (crmd_remove_node_cache(atoi(target_uname))) {
+                crm_err("Failed to connect to crmd to remove node id %s", target_uname);
+            }
         case 'e':
             /* Age makes no sense (yet) in an AIS cluster */
             fprintf(stdout, "1\n");

