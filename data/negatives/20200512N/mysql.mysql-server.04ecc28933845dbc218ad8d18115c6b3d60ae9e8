commit 04ecc28933845dbc218ad8d18115c6b3d60ae9e8
Author: Neeraj Bisht <neeraj.x.bisht@oracle.com>
Date:   Wed Mar 6 19:02:28 2013 +0530

    Bug#16272562 - WRONG RESULTS: SELECT DISTINCT ... XOR ..
    
    Problem:-
    The range optimizer used to set up incorrect ranges for queries with XOR.
    This resulted in missing rows
    
    Analysis:-
    The range optimizer set up incorrect range for query like this
    select ... where any_field XOR 'any_constant_value'
    
    Solution:
    The fix is to not use range access for the XOR operation by treating
    'a XOR b' as always true. Thus, for conditions like
    
    WHERE <something> AND (a XOR b)
    
    range access can still be used on <something>.
    
    It is possible to optimize XORs better by treating them as normal ORs and
    let condition filtering remove rows that are 'true XOR true'.
    This will be fixed by WL#5800.

diff --git a/sql/opt_range.cc b/sql/opt_range.cc
index b62fbe18ff9..a5511ed8410 100644
--- a/sql/opt_range.cc
+++ b/sql/opt_range.cc
@@ -5806,6 +5806,10 @@ static SEL_TREE *get_func_mm_tree(RANGE_OPT_PARAM *param, Item_func *cond_func,
 
   switch (cond_func->functype()) {
 
+  case Item_func::XOR_FUNC:
+    DBUG_RETURN(NULL); // Always true (don't use range access on XOR).
+    break;             // See WL#5800
+
   case Item_func::NE_FUNC:
     tree= get_ne_mm_tree(param, cond_func, field, value, value, cmp_type);
     break;

