commit ef4b4b274cf96a857dd78b49558509b55d75163a
Author: Ian Abbott <abbotti@mev.co.uk>
Date:   Fri Mar 27 15:13:06 2015 +0000

    staging: comedi: comedi_fops: extend spin-lock scope in comedi_event()
    
    `comedi_event()` is called from low-level drivers to handle comedi
    asynchronous command event flags.  As a safety check, it checks the
    subdevice's "run" flags to make sure an asynchronous command is running.
    It can also change the run flags to mark the command as no longer
    running (possibly also marking it as terminated with an error).
    Checking the runflags and modifying them involves two uses of the
    subdevice's spin-lock.  It seems better to do it with a single use of
    the spin-lock.  This also avoids possible interactions with
    `do_become_nonbusy()`.
    
    Acquire the subdevice's spin-lock at the start of `comedi_event()` and
    release it near the end, before a possible call to `kill_fasync()` (but
    after it's parameter values have been determined).
    
    Add and make use of few new inline helper functions:
    
    * `__comedi_clear_subdevice_runflags()` -- clears some run flags without
      using the spin-lock
    * `__comedi_set_subdevice_runflags()` -- sets some run flags without
      using the spin-lock
    * `__comedi_get_subdevice_runflags()` -- a spin-lockless version of
      `comedi_get_subdevice_runflags()
    * `__comedi_is_subdevice_running()` -- a spin-lockless version of
    * `comedi_is_subdevice_running()`
    
    Signed-off-by: Ian Abbott <abbotti@mev.co.uk>
    Reviewed-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index 7ae605f6bbb6..e78ddbe5a954 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -601,24 +601,41 @@ static struct attribute *comedi_dev_attrs[] = {
 };
 ATTRIBUTE_GROUPS(comedi_dev);
 
+static void __comedi_clear_subdevice_runflags(struct comedi_subdevice *s,
+					      unsigned bits)
+{
+	s->runflags &= ~bits;
+}
+
+static void __comedi_set_subdevice_runflags(struct comedi_subdevice *s,
+					    unsigned bits)
+{
+	s->runflags |= bits;
+}
+
 static void comedi_update_subdevice_runflags(struct comedi_subdevice *s,
 					     unsigned mask, unsigned bits)
 {
 	unsigned long flags;
 
 	spin_lock_irqsave(&s->spin_lock, flags);
-	s->runflags &= ~mask;
-	s->runflags |= (bits & mask);
+	__comedi_clear_subdevice_runflags(s, mask);
+	__comedi_set_subdevice_runflags(s, bits & mask);
 	spin_unlock_irqrestore(&s->spin_lock, flags);
 }
 
+static unsigned __comedi_get_subdevice_runflags(struct comedi_subdevice *s)
+{
+	return s->runflags;
+}
+
 static unsigned comedi_get_subdevice_runflags(struct comedi_subdevice *s)
 {
 	unsigned long flags;
 	unsigned runflags;
 
 	spin_lock_irqsave(&s->spin_lock, flags);
-	runflags = s->runflags;
+	runflags = __comedi_get_subdevice_runflags(s);
 	spin_unlock_irqrestore(&s->spin_lock, flags);
 	return runflags;
 }
@@ -648,6 +665,13 @@ bool comedi_is_subdevice_running(struct comedi_subdevice *s)
 }
 EXPORT_SYMBOL_GPL(comedi_is_subdevice_running);
 
+static bool __comedi_is_subdevice_running(struct comedi_subdevice *s)
+{
+	unsigned runflags = __comedi_get_subdevice_runflags(s);
+
+	return comedi_is_runflags_running(runflags);
+}
+
 static bool comedi_is_subdevice_idle(struct comedi_subdevice *s)
 {
 	unsigned runflags = comedi_get_subdevice_runflags(s);
@@ -2646,40 +2670,38 @@ static const struct file_operations comedi_fops = {
 void comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)
 {
 	struct comedi_async *async = s->async;
-	unsigned runflags = 0;
-	unsigned runflags_mask = 0;
-	unsigned int events = async->events;
+	unsigned int events;
+	int si_code = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&s->spin_lock, flags);
 
+	events = async->events;
 	async->events = 0;
-	if (!comedi_is_subdevice_running(s))
+	if (!__comedi_is_subdevice_running(s)) {
+		spin_unlock_irqrestore(&s->spin_lock, flags);
 		return;
+	}
 
 	if (events & COMEDI_CB_CANCEL_MASK)
-		runflags_mask |= COMEDI_SRF_RUNNING;
+		__comedi_clear_subdevice_runflags(s, COMEDI_SRF_RUNNING);
 
 	/*
-	 * Remember if an error event has occurred, so an error
-	 * can be returned the next time the user does a read().
+	 * Remember if an error event has occurred, so an error can be
+	 * returned the next time the user does a read() or write().
 	 */
-	if (events & COMEDI_CB_ERROR_MASK) {
-		runflags_mask |= COMEDI_SRF_ERROR;
-		runflags |= COMEDI_SRF_ERROR;
-	}
-	if (runflags_mask) {
-		/*
-		 * Changes COMEDI_SRF_ERROR and COMEDI_SRF_RUNNING together
-		 * atomically.
-		 */
-		comedi_update_subdevice_runflags(s, runflags_mask, runflags);
-	}
+	if (events & COMEDI_CB_ERROR_MASK)
+		__comedi_set_subdevice_runflags(s, COMEDI_SRF_ERROR);
 
 	if (async->cb_mask & events) {
-		int si_code;
-
 		wake_up_interruptible(&async->wait_head);
 		si_code = async->cmd.flags & CMDF_WRITE ? POLL_OUT : POLL_IN;
-		kill_fasync(&dev->async_queue, SIGIO, si_code);
 	}
+
+	spin_unlock_irqrestore(&s->spin_lock, flags);
+
+	if (si_code)
+		kill_fasync(&dev->async_queue, SIGIO, si_code);
 }
 EXPORT_SYMBOL_GPL(comedi_event);
 

