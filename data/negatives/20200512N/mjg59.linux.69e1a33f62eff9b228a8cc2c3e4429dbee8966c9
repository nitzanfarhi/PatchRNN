commit 69e1a33f62eff9b228a8cc2c3e4429dbee8966c9
Author: Andi Kleen <ak@suse.de>
Date:   Mon Sep 12 18:49:24 2005 +0200

    [PATCH] x86-64: Use ACPI PXM to parse PCI<->node assignments
    
    Since this is shared code I had to implement it for i386 too
    
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/i386/kernel/srat.c b/arch/i386/kernel/srat.c
index 7b3b27d64409..516bf5653b02 100644
--- a/arch/i386/kernel/srat.c
+++ b/arch/i386/kernel/srat.c
@@ -213,12 +213,18 @@ static __init void node_read_chunk(int nid, struct node_memory_chunk_s *memory_c
 		node_end_pfn[nid] = memory_chunk->end_pfn;
 }
 
+static u8 pxm_to_nid_map[MAX_PXM_DOMAINS];/* _PXM to logical node ID map */
+
+int pxm_to_node(int pxm)
+{
+	return pxm_to_nid_map[pxm];
+}
+
 /* Parse the ACPI Static Resource Affinity Table */
 static int __init acpi20_parse_srat(struct acpi_table_srat *sratp)
 {
 	u8 *start, *end, *p;
 	int i, j, nid;
-	u8 pxm_to_nid_map[MAX_PXM_DOMAINS];/* _PXM to logical node ID map */
 	u8 nid_to_pxm_map[MAX_NUMNODES];/* logical node ID to _PXM map */
 
 	start = (u8 *)(&(sratp->reserved) + 1);	/* skip header */
diff --git a/arch/i386/pci/acpi.c b/arch/i386/pci/acpi.c
index 42913f43feb0..2941674f35eb 100644
--- a/arch/i386/pci/acpi.c
+++ b/arch/i386/pci/acpi.c
@@ -3,16 +3,31 @@
 #include <linux/init.h>
 #include <linux/irq.h>
 #include <asm/hw_irq.h>
+#include <asm/numa.h>
 #include "pci.h"
 
 struct pci_bus * __devinit pci_acpi_scan_root(struct acpi_device *device, int domain, int busnum)
 {
+	struct pci_bus *bus;
+
 	if (domain != 0) {
 		printk(KERN_WARNING "PCI: Multiple domains not supported\n");
 		return NULL;
 	}
 
-	return pcibios_scan_root(busnum);
+	bus = pcibios_scan_root(busnum);
+#ifdef CONFIG_ACPI_NUMA
+	if (bus != NULL) {
+		int pxm = acpi_get_pxm(device->handle);
+		if (pxm >= 0) {
+			bus->sysdata = (void *)(unsigned long)pxm_to_node(pxm);
+			printk("bus %d -> pxm %d -> node %ld\n",
+				busnum, pxm, (long)(bus->sysdata));
+		}
+	}
+#endif
+	
+	return bus;
 }
 
 extern int pci_routeirq;
diff --git a/arch/x86_64/kernel/mpparse.c b/arch/x86_64/kernel/mpparse.c
index 312ecc9e5f7f..11642526c5b7 100644
--- a/arch/x86_64/kernel/mpparse.c
+++ b/arch/x86_64/kernel/mpparse.c
@@ -46,8 +46,6 @@ int acpi_found_madt;
 int apic_version [MAX_APICS];
 unsigned char mp_bus_id_to_type [MAX_MP_BUSSES] = { [0 ... MAX_MP_BUSSES-1] = -1 };
 int mp_bus_id_to_pci_bus [MAX_MP_BUSSES] = { [0 ... MAX_MP_BUSSES-1] = -1 };
-unsigned char pci_bus_to_node [256];
-EXPORT_SYMBOL(pci_bus_to_node);
 
 static int mp_current_pci_id = 0;
 /* I/O APIC entries */
diff --git a/arch/x86_64/mm/srat.c b/arch/x86_64/mm/srat.c
index 92f6ec79b232..db6b073a149f 100644
--- a/arch/x86_64/mm/srat.c
+++ b/arch/x86_64/mm/srat.c
@@ -25,6 +25,13 @@ static nodemask_t nodes_found __initdata;
 static struct node nodes[MAX_NUMNODES] __initdata;
 static __u8  pxm2node[256] = { [0 ... 255] = 0xff };
 
+int pxm_to_node(int pxm)
+{
+	if ((unsigned)pxm >= 256)
+		return 0;
+	return pxm2node[pxm];
+}
+
 static __init int setup_node(int pxm)
 {
 	unsigned node = pxm2node[pxm];
diff --git a/arch/x86_64/pci/k8-bus.c b/arch/x86_64/pci/k8-bus.c
index d80c323669e0..3acf60ded2a0 100644
--- a/arch/x86_64/pci/k8-bus.c
+++ b/arch/x86_64/pci/k8-bus.c
@@ -58,10 +58,16 @@ fill_mp_bus_to_cpumask(void)
 				for (j = SECONDARY_LDT_BUS_NUMBER(ldtbus);
 				     j <= SUBORDINATE_LDT_BUS_NUMBER(ldtbus);
 				     j++) { 
-					int node = NODE_ID(nid);
+					struct pci_bus *bus;
+					long node = NODE_ID(nid);
+					/* Algorithm a bit dumb, but
+ 					   it shouldn't matter here */
+					bus = pci_find_bus(0, j);
+					if (!bus)
+						continue;
 					if (!node_online(node))
 						node = 0;
-					pci_bus_to_node[j] = node;
+					bus->sysdata = (void *)node;
 				}		
 			}
 		}
diff --git a/include/asm-i386/numa.h b/include/asm-i386/numa.h
new file mode 100644
index 000000000000..96fcb157db1d
--- /dev/null
+++ b/include/asm-i386/numa.h
@@ -0,0 +1,3 @@
+
+int pxm_to_nid(int pxm);
+
diff --git a/include/asm-i386/topology.h b/include/asm-i386/topology.h
index 2461b731781e..0ec27c9e8e45 100644
--- a/include/asm-i386/topology.h
+++ b/include/asm-i386/topology.h
@@ -60,7 +60,7 @@ static inline int node_to_first_cpu(int node)
 	return first_cpu(mask);
 }
 
-#define pcibus_to_node(bus) mp_bus_id_to_node[(bus)->number]
+#define pcibus_to_node(bus) ((long) (bus)->sysdata)
 #define pcibus_to_cpumask(bus) node_to_cpumask(pcibus_to_node(bus))
 
 /* sched_domains SD_NODE_INIT for NUMAQ machines */
diff --git a/include/asm-x86_64/numa.h b/include/asm-x86_64/numa.h
index 3aaf70027213..bcf55c3f7f7f 100644
--- a/include/asm-x86_64/numa.h
+++ b/include/asm-x86_64/numa.h
@@ -9,6 +9,7 @@ struct node {
 };
 
 extern int compute_hash_shift(struct node *nodes, int numnodes);
+extern int pxm_to_node(int nid);
 
 #define ZONE_ALIGN (1UL << (MAX_ORDER+PAGE_SHIFT))
 
diff --git a/include/asm-x86_64/topology.h b/include/asm-x86_64/topology.h
index c1bc3fad482e..1c603cd7e4d0 100644
--- a/include/asm-x86_64/topology.h
+++ b/include/asm-x86_64/topology.h
@@ -13,7 +13,6 @@
 extern cpumask_t cpu_online_map;
 
 extern unsigned char cpu_to_node[];
-extern unsigned char pci_bus_to_node[];
 extern cpumask_t     node_to_cpumask[];
 
 #ifdef CONFIG_ACPI_NUMA
@@ -26,7 +25,7 @@ extern int __node_distance(int, int);
 #define parent_node(node)		(node)
 #define node_to_first_cpu(node) 	(__ffs(node_to_cpumask[node]))
 #define node_to_cpumask(node)		(node_to_cpumask[node])
-#define pcibus_to_node(bus)		pci_bus_to_node[(bus)->number]
+#define pcibus_to_node(bus)		((long)(bus->sysdata))	
 #define pcibus_to_cpumask(bus)		node_to_cpumask(pcibus_to_node(bus));
 
 /* sched_domains SD_NODE_INIT for x86_64 machines */

