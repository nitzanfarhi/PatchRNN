commit 608a520573951c50e9eb3e706def045098f3a2b4
Author: nelisky <nelisky.btc@gmail.com>
Date:   Sat Mar 31 13:13:53 2012 +0100

    Tweaks to make ztex work on a tp-link router with openwrt

diff --git a/cgminer.c b/cgminer.c
index 01053ab9..dab1af54 100644
--- a/cgminer.c
+++ b/cgminer.c
@@ -1528,6 +1528,8 @@ static bool submit_upstream_work(const struct work *work)
 	res = json_object_get(val, "result");
 
 	if (!QUIET) {
+#ifndef MIPSEB
+// This one segfaults on my router for some reason
 		isblock = regeneratehash(work);
 		if (isblock)
 			found_blocks++;
@@ -1535,6 +1537,7 @@ static bool submit_upstream_work(const struct work *work)
 		sprintf(hashshow, "%08lx.%08lx.%08lx%s",
 			(unsigned long)(hash32[7]), (unsigned long)(hash32[6]), (unsigned long)(hash32[5]),
 			isblock ? " BLOCK!" : "");
+#endif
 	}
 
 	/* Theoretically threads could race when modifying accepted and
diff --git a/ztex.c b/ztex.c
index ea553cbf..ea697db4 100644
--- a/ztex.c
+++ b/ztex.c
@@ -124,7 +124,12 @@ static bool ztex_checkNonce (struct libztex_device *ztex,
   unsigned char hash2[32];
   uint32_t *hash2_32 = (uint32_t *)hash2;
   int i;
-  
+
+#if defined(__BIGENDIAN__) || defined(MIPSEB)
+  hdata->nonce = swab32(hdata->nonce);
+  hdata->hash7 = swab32(hdata->hash7);
+#endif
+
   work->data[64 + 12 + 0] = (hdata->nonce >> 0) & 0xff;
   work->data[64 + 12 + 1] = (hdata->nonce >> 8) & 0xff;
   work->data[64 + 12 + 2] = (hdata->nonce >> 16) & 0xff;
@@ -135,8 +140,11 @@ static bool ztex_checkNonce (struct libztex_device *ztex,
   
   sha2(swap, 80, hash1, false);
   sha2(hash1, 32, hash2, false);
- 
+#if defined(__BIGENDIAN__) || defined(MIPSEB)
+  if (hash2_32[7] != ((hdata->hash7 + 0x5be0cd19) & 0xFFFFFFFF)) {
+#else
   if (swab32(hash2_32[7]) != ((hdata->hash7 + 0x5be0cd19) & 0xFFFFFFFF)) {
+#endif
     ztex->errorCount[ztex->freqM] += 1.0/ztex->numNonces;
     applog(LOG_DEBUG, "%s: checkNonce failed for %0.8X", ztex->repr, hdata->nonce);
     return false;
@@ -207,7 +215,7 @@ static uint64_t ztex_scanhash(struct thr_info *thr, struct work *work,
     ztex->errorWeight[ztex->freqM] = ztex->errorWeight[ztex->freqM] * 0.995 + 1.0;
  
     for (i=0; i<ztex->numNonces; i++) {
-      nonce = hdata[i].nonce;
+      nonce = swab32(hdata[i].nonce);
       if (nonce > noncecnt)
         noncecnt = nonce;
       if ((nonce >> 4) < (lastnonce[i] >> 4)) {
@@ -234,7 +242,7 @@ static uint64_t ztex_scanhash(struct thr_info *thr, struct work *work,
           if (backlog_p >= GOLDEN_BACKLOG) {
             backlog_p = 0;
           }
-#ifdef __BIG_ENDIAN__
+#if defined(__BIGENDIAN__) || defined(MIPSEB)
           nonce = swab32(nonce);
 #endif
 	  work->blk.nonce = 0xffffffff;

