commit 78deec450cfa5ddcad290c13b36dd1d187da213e
Author: Avneesh Sachdev <avneesh@opensourcerouting.org>
Date:   Tue Nov 13 22:48:56 2012 +0000

    zebra: extern/extract some functions from rt_netlink.c
    
    * zebra/{rib.h,zebra_rib.c}
    
        Add nexthop_type_to_str(), which returns a human-readable string
        corresponding to a nexthop type.
    
      * zebra/rt_netlink.[hc]
    
        - Add new header file that exposes some existing and new
          netlink-related functions from rt_netlink.c to the rest of
          zebra.
    
            addattr32
            addattr_l
            rta_addattr_l
            nl_msg_type_to_str (new)
            nl_rtproto_to_str (new)
    
        - Use nexthop_type_to_str() instead of the static array
          'nexthop_types_desc'.
    
    Signed-off-by: Avneesh Sachdev <avneesh@opensourcerouting.org>
    Signed-off-by: David Lamparter <equinox@opensourcerouting.org>

diff --git a/zebra/rib.h b/zebra/rib.h
index 4f99d714..4ecfaa0d 100644
--- a/zebra/rib.h
+++ b/zebra/rib.h
@@ -305,6 +305,7 @@ typedef struct rib_tables_iter_t_
   rib_tables_iter_state_t state;
 } rib_tables_iter_t;
 
+extern const char *nexthop_type_to_str (enum nexthop_types_t nh_type);
 extern struct nexthop *nexthop_ifindex_add (struct rib *, unsigned int);
 extern struct nexthop *nexthop_ifname_add (struct rib *, char *);
 extern struct nexthop *nexthop_blackhole_add (struct rib *);
diff --git a/zebra/rt_netlink.c b/zebra/rt_netlink.c
index ab28ad27..fa446a56 100644
--- a/zebra/rt_netlink.c
+++ b/zebra/rt_netlink.c
@@ -43,7 +43,7 @@
 #include "zebra/interface.h"
 #include "zebra/debug.h"
 
-#define NL_PKT_BUF_SIZE 4096
+#include "rt_netlink.h"
 
 /* Socket interface to kernel */
 struct nlsock
@@ -68,20 +68,6 @@ static const struct message nlmsg_str[] = {
   {0, NULL}
 };
 
-static const char *nexthop_types_desc[] =
-{
-  "none",
-  "Directly connected",
-  "Interface route",
-  "IPv4 nexthop",
-  "IPv4 nexthop with ifindex",
-  "IPv4 nexthop with ifname",
-  "IPv6 nexthop",
-  "IPv6 nexthop with ifindex",
-  "IPv6 nexthop with ifname",
-  "Null0 nexthop",
-};
-
 extern struct zebra_t zebrad;
 
 extern struct zebra_privs_t zserv_privs;
@@ -1236,7 +1222,7 @@ netlink_route_read (void)
 
 /* Utility function  comes from iproute2. 
    Authors:	Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru> */
-static int
+int
 addattr_l (struct nlmsghdr *n, int maxlen, int type, void *data, int alen)
 {
   int len;
@@ -1256,7 +1242,7 @@ addattr_l (struct nlmsghdr *n, int maxlen, int type, void *data, int alen)
   return 0;
 }
 
-static int
+int
 rta_addattr_l (struct rtattr *rta, int maxlen, int type, void *data, int alen)
 {
   int len;
@@ -1278,7 +1264,7 @@ rta_addattr_l (struct rtattr *rta, int maxlen, int type, void *data, int alen)
 
 /* Utility function comes from iproute2. 
    Authors:	Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru> */
-static int
+int
 addattr32 (struct nlmsghdr *n, int maxlen, int type, int data)
 {
   int len;
@@ -1515,7 +1501,7 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
 			 inet_ntoa (p->u.prefix4),
 #endif /* HAVE_IPV6 */
 			 
-			 p->prefixlen, nexthop_types_desc[nexthop->rtype]);
+			 p->prefixlen, nexthop_type_to_str (nexthop->rtype));
                     }
 
                   if (nexthop->rtype == NEXTHOP_TYPE_IPV4
@@ -1580,7 +1566,7 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
 #else
 			 inet_ntoa (p->u.prefix4),
 #endif /* HAVE_IPV6 */
-			 p->prefixlen, nexthop_types_desc[nexthop->type]);
+			 p->prefixlen, nexthop_type_to_str (nexthop->type));
                     }
 
                   if (nexthop->type == NEXTHOP_TYPE_IPV4
@@ -1687,7 +1673,7 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
 #else
 			 inet_ntoa (p->u.prefix4),
 #endif /* HAVE_IPV6 */
-                         p->prefixlen, nexthop_types_desc[nexthop->rtype]);
+			 p->prefixlen, nexthop_type_to_str (nexthop->rtype));
                     }
                   if (nexthop->rtype == NEXTHOP_TYPE_IPV4
                       || nexthop->rtype == NEXTHOP_TYPE_IPV4_IFINDEX)
@@ -1761,7 +1747,7 @@ netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib,
 #else
 			 inet_ntoa (p->u.prefix4),
 #endif /* HAVE_IPV6 */
-			 p->prefixlen, nexthop_types_desc[nexthop->type]);
+			 p->prefixlen, nexthop_type_to_str (nexthop->type));
                     }
                   if (nexthop->type == NEXTHOP_TYPE_IPV4
                       || nexthop->type == NEXTHOP_TYPE_IPV4_IFINDEX)
@@ -2023,3 +2009,21 @@ kernel_init (void)
       thread_add_read (zebrad.master, kernel_read, NULL, netlink.sock);
     }
 }
+
+/*
+ * nl_msg_type_to_str
+ */
+const char *
+nl_msg_type_to_str (uint16_t msg_type)
+{
+  return lookup (nlmsg_str, msg_type);
+}
+
+/*
+ * nl_rtproto_to_str
+ */
+const char *
+nl_rtproto_to_str (u_char rtproto)
+{
+  return lookup (rtproto_str, rtproto);
+}
diff --git a/zebra/rt_netlink.h b/zebra/rt_netlink.h
new file mode 100644
index 00000000..529fa517
--- /dev/null
+++ b/zebra/rt_netlink.h
@@ -0,0 +1,46 @@
+/* Header file exported by rt_netlink.c to zebra.
+ * Copyright (C) 1997, 98, 99 Kunihiro Ishiguro
+ *
+ * This file is part of GNU Zebra.
+ *
+ * GNU Zebra is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * GNU Zebra is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Zebra; see the file COPYING.  If not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+#ifndef _ZEBRA_RT_NETLINK_H
+#define _ZEBRA_RT_NETLINK_H
+
+#ifdef HAVE_NETLINK
+
+#define NL_PKT_BUF_SIZE 4096
+
+extern int
+addattr32 (struct nlmsghdr *n, int maxlen, int type, int data);
+extern int
+addattr_l (struct nlmsghdr *n, int maxlen, int type, void *data, int alen);
+
+extern int
+rta_addattr_l (struct rtattr *rta, int maxlen, int type, void *data, int alen);
+
+extern const char *
+nl_msg_type_to_str (uint16_t msg_type);
+
+extern const char *
+nl_rtproto_to_str (u_char rtproto);
+
+
+#endif /* HAVE_NETLINK */
+
+#endif /* _ZEBRA_RT_NETLINK_H */
diff --git a/zebra/zebra_rib.c b/zebra/zebra_rib.c
index 5c75b909..29977123 100644
--- a/zebra/zebra_rib.c
+++ b/zebra/zebra_rib.c
@@ -170,6 +170,31 @@ vrf_static_table (afi_t afi, safi_t safi, u_int32_t id)
   return vrf->stable[afi][safi];
 }
 
+/*
+ * nexthop_type_to_str
+ */
+const char *
+nexthop_type_to_str (enum nexthop_types_t nh_type)
+{
+  static const char *desc[] = {
+    "none",
+    "Directly connected",
+    "Interface route",
+    "IPv4 nexthop",
+    "IPv4 nexthop with ifindex",
+    "IPv4 nexthop with ifname",
+    "IPv6 nexthop",
+    "IPv6 nexthop with ifindex",
+    "IPv6 nexthop with ifname",
+    "Null0 nexthop",
+  };
+
+  if (nh_type >= ZEBRA_NUM_OF (desc))
+    return "<Invalid nh type>";
+
+  return desc[nh_type];
+}
+
 /* Add nexthop to the end of the list.  */
 static void
 nexthop_add (struct rib *rib, struct nexthop *nexthop)

