commit 26eb42489e42cb69a7d049ebec785c92b2068c68
Author: Jon Olav Hauglid <jon.hauglid@oracle.com>
Date:   Mon Aug 25 15:26:57 2014 +0200

    Bug#19498446: REFACTOR THREAD-LOCAL STORAGE IMPLEMENTATION
    
    This patch moves the thread-local storage implementation to
    a separate file, removes dead code and changes the implementation
    from macros to static inline functions.
    
    The patch also removes serveral unneeded fields from
    st_my_thread_var, reducing memory usage and reducing
    thread-local storage usage.
    
    No chages in behavior.

diff --git a/dbug/dbug.c b/dbug/dbug.c
index f31dca1348a..d79111de95f 100644
--- a/dbug/dbug.c
+++ b/dbug/dbug.c
@@ -2014,7 +2014,7 @@ static void DoPrefix(CODE_STATE *cs, uint _line_)
   cs->lineno++;
   if (cs->stack->flags & PID_ON)
   {
-    (void) fprintf(cs->stack->out_file, "%-7s: ", my_thread_name());
+    (void) fprintf(cs->stack->out_file, "T@%u: ", mysys_thread_var()->id);
   }
   if (cs->stack->flags & NUMBER_ON)
     (void) fprintf(cs->stack->out_file, "%5d: ", cs->lineno);
diff --git a/include/my_pthread.h b/include/my_pthread.h
index bc25ceeb138..0a58cc08d6b 100644
--- a/include/my_pthread.h
+++ b/include/my_pthread.h
@@ -146,15 +146,6 @@ extern int pthread_dummy(int);
 #define ETIMEDOUT 145		    /* Win32 doesn't have this */
 #endif
 
-#define pthread_key(T,V)  DWORD V
-#define pthread_key_create(A,B) ((*A=TlsAlloc())==0xFFFFFFFF)
-#define pthread_key_delete(A) TlsFree(A)
-#define my_pthread_setspecific_ptr(T,V) (!TlsSetValue((T),(V)))
-#define pthread_setspecific(A,B) (!TlsSetValue((A),(B)))
-#define pthread_getspecific(A) (TlsGetValue(A))
-#define my_pthread_getspecific(T,A) ((T) TlsGetValue(A))
-#define my_pthread_getspecific_ptr(T,V) ((T) TlsGetValue(V))
-
 #define pthread_kill(A,B) pthread_dummy((A) ? 0 : ESRCH)
 
 static inline int pthread_attr_getguardsize(pthread_attr_t *attr,
@@ -170,16 +161,12 @@ static inline int pthread_attr_getguardsize(pthread_attr_t *attr,
 
 #else /* Normal threads */
 
-#define pthread_key(T,V) pthread_key_t V
-#define my_pthread_getspecific_ptr(T,V) my_pthread_getspecific(T,(V))
-#define my_pthread_setspecific_ptr(T,V) pthread_setspecific(T,(void*) (V))
 #define pthread_handler_t EXTERNC void *
 typedef void *(* pthread_handler)(void *);
 
 #define my_pthread_once_t pthread_once_t
 #define MY_PTHREAD_ONCE_INIT PTHREAD_ONCE_INIT
 #define my_pthread_once(C,F) pthread_once(C,F)
-#define my_pthread_getspecific(A,B) ((A) pthread_getspecific(B))
 
 #endif /* defined(_WIN32) */
 
@@ -219,8 +206,6 @@ extern void my_thread_global_reinit(void);
 extern void my_thread_global_end(void);
 extern my_bool my_thread_init(void);
 extern void my_thread_end(void);
-extern const char *my_thread_name(void);
-extern my_thread_id my_thread_dbug_id(void);
 
 #ifndef DEFAULT_THREAD_STACK
 #if SIZEOF_CHARP > 4
@@ -241,45 +226,7 @@ extern my_thread_id my_thread_dbug_id(void);
 #endif /* MYSQL_SERVER */
 
 #include <mysql/psi/mysql_thread.h>
-
-/* All thread specific variables are in the following struct */
-#define THREAD_NAME_SIZE 10
-struct st_my_thread_var
-{
-  int thr_errno;
-#if defined(_WIN32)
-/*
-  thr_winerr is used for returning the original OS error-code in Windows,
-  my_osmaperr() returns EINVAL for all unknown Windows errors, hence we
-  preserve the original Windows Error code in thr_winerr.
-*/
-  int thr_winerr;
-#endif
-  mysql_cond_t suspend;
-  mysql_mutex_t mutex;
-  mysql_mutex_t * volatile current_mutex;
-  mysql_cond_t * volatile current_cond;
-  my_thread_id id;
-  int volatile abort;
-  my_bool init;
-  struct st_my_thread_var *next,**prev;
-  void *opt_info;
-  void  *stack_ends_here;
-#ifndef DBUG_OFF
-  void *dbug;
-  char name[THREAD_NAME_SIZE+1];
-#endif
-};
-
-extern struct st_my_thread_var *_my_thread_var(void) __attribute__ ((const));
-extern int set_mysys_var(struct st_my_thread_var *mysys_var);
-extern void **my_thread_var_dbug();
-#define my_thread_var (_my_thread_var())
-#define my_errno my_thread_var->thr_errno
-
-#if defined(_WIN32)
-#define my_winerr my_thread_var->thr_winerr
-#endif
+#include "my_thread_local.h"
 
 #ifdef  __cplusplus
 }
diff --git a/include/my_thread_local.h b/include/my_thread_local.h
new file mode 100644
index 00000000000..eb4a2e80cbb
--- /dev/null
+++ b/include/my_thread_local.h
@@ -0,0 +1,106 @@
+/* Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA */
+
+#ifndef MY_THREAD_LOCAL_INCLUDED
+#define MY_THREAD_LOCAL_INCLUDED
+
+C_MODE_START
+
+#ifdef _WIN32
+typedef DWORD thread_local_key_t;
+#else
+typedef pthread_key_t thread_local_key_t;
+#endif
+
+static inline int my_create_thread_local_key(thread_local_key_t *key,
+                                             void (*destructor)(void *))
+{
+#ifdef _WIN32
+  *key= TlsAlloc();
+  return (*key == TLS_OUT_OF_INDEXES);
+#else
+  return pthread_key_create(key, destructor);
+#endif
+}
+
+static inline int my_delete_thread_local_key(thread_local_key_t key)
+{
+#ifdef _WIN32
+  return !TlsFree(key);
+#else
+  return pthread_key_delete(key);
+#endif
+}
+
+static inline void* my_get_thread_local(thread_local_key_t key)
+{
+#ifdef _WIN32
+  return TlsGetValue(key);
+#else
+  return pthread_getspecific(key);
+#endif
+}
+
+static inline int my_set_thread_local(thread_local_key_t key,
+                                      void *value)
+{
+#ifdef _WIN32
+  return !TlsSetValue(key, value);
+#else
+  return pthread_setspecific(key, value);
+#endif
+}
+
+
+/* All thread specific variables are in the following struct */
+struct st_my_thread_var
+{
+  int thr_errno;
+#if defined(_WIN32)
+/*
+  thr_winerr is used for returning the original OS error-code in Windows,
+  my_osmaperr() returns EINVAL for all unknown Windows errors, hence we
+  preserve the original Windows Error code in thr_winerr.
+*/
+  int thr_winerr;
+#endif
+  mysql_cond_t suspend;
+  mysql_mutex_t mutex;
+  mysql_mutex_t * volatile current_mutex;
+  mysql_cond_t * volatile current_cond;
+  my_thread_id id;
+  int volatile abort;
+  struct st_my_thread_var *next,**prev;
+  void *opt_info;
+  void  *stack_ends_here;
+#ifndef DBUG_OFF
+  void *dbug;
+#endif
+};
+
+struct st_my_thread_var *mysys_thread_var();
+
+int set_mysys_thread_var(struct st_my_thread_var *mysys_var);
+
+#ifndef DBUG_OFF
+/* Return pointer to DBUG for holding current state */
+void **my_thread_var_dbug();
+#endif
+
+#define my_errno mysys_thread_var()->thr_errno
+
+C_MODE_END
+
+#endif // MY_THREAD_LOCAL_INCLUDED
diff --git a/mysys/lf_alloc-pin.c b/mysys/lf_alloc-pin.c
index 00ba1174bdb..85bb162e5df 100644
--- a/mysys/lf_alloc-pin.c
+++ b/mysys/lf_alloc-pin.c
@@ -323,7 +323,7 @@ static void lf_pinbox_real_free(LF_PINS *pins)
   void **addr= NULL;
   void *first= NULL, *last= NULL;
   LF_PINBOX *pinbox= pins->pinbox;
-  struct st_my_thread_var *var= my_thread_var;
+  struct st_my_thread_var *var= mysys_thread_var();
 
   npins= pinbox->pins_in_array+1;
 
diff --git a/mysys/mf_keycache.c b/mysys/mf_keycache.c
index c216f905130..5792953b7ac 100644
--- a/mysys/mf_keycache.c
+++ b/mysys/mf_keycache.c
@@ -288,7 +288,7 @@ static long keycache_thread_id;
              KEYCACHE_DBUG_PRINT(l,("|thread %ld",keycache_thread_id))
 
 #define KEYCACHE_THREAD_TRACE_BEGIN(l)                                        \
-            { struct st_my_thread_var *thread_var= my_thread_var;             \
+            { struct st_my_thread_var *thread_var= mysys_thread_var();        \
               keycache_thread_id= thread_var->id;                             \
               KEYCACHE_DBUG_PRINT(l,("[thread %ld",keycache_thread_id)) }
 
@@ -875,7 +875,7 @@ static void wait_on_queue(KEYCACHE_WQUEUE *wqueue,
                           mysql_mutex_t *mutex)
 {
   struct st_my_thread_var *last;
-  struct st_my_thread_var *thread= my_thread_var;
+  struct st_my_thread_var *thread= mysys_thread_var();
 
   /* Add to queue. */
   DBUG_ASSERT(!thread->next);
@@ -1413,7 +1413,7 @@ static void remove_reader(BLOCK_LINK *block)
 static void wait_for_readers(KEY_CACHE *keycache,
                              BLOCK_LINK *block)
 {
-  struct st_my_thread_var *thread= my_thread_var;
+  struct st_my_thread_var *thread= mysys_thread_var();
   DBUG_ASSERT(block->status & (BLOCK_READ | BLOCK_IN_USE));
   DBUG_ASSERT(!(block->status & (BLOCK_IN_FLUSH | BLOCK_CHANGED)));
   DBUG_ASSERT(block->hash_link);
@@ -1564,7 +1564,7 @@ restart:
     else
     {
       /* Wait for a free hash link */
-      struct st_my_thread_var *thread= my_thread_var;
+      struct st_my_thread_var *thread= mysys_thread_var();
       KEYCACHE_PAGE page;
       KEYCACHE_DBUG_PRINT("get_hash_link", ("waiting"));
       page.file= file;
@@ -1732,7 +1732,7 @@ restart:
         Refresh the request on the hash-link so that it cannot be reused
         for another file/pos.
       */
-      thread= my_thread_var;
+      thread= mysys_thread_var();
       thread->opt_info= (void *) hash_link;
       link_into_queue(&keycache->waiting_for_block, thread);
       do
@@ -2079,7 +2079,7 @@ restart:
             it is marked BLOCK_IN_EVICTION.
           */
 
-          struct st_my_thread_var *thread= my_thread_var;
+          struct st_my_thread_var *thread= mysys_thread_var();
           thread->opt_info= (void *) hash_link;
           link_into_queue(&keycache->waiting_for_block, thread);
           do
diff --git a/mysys/my_error.c b/mysys/my_error.c
index 896b5571552..fd6bef8288d 100644
--- a/mysys/my_error.c
+++ b/mysys/my_error.c
@@ -97,7 +97,7 @@ char *my_strerror(char *buf, size_t len, int nr)
     */
 #if defined(_WIN32)
     strerror_s(buf, len, nr);
-    if (my_winerr != 0)
+    if (mysys_thread_var()->thr_winerr != 0)
     {
       /*
         If error code is EINVAL, and Windows Error code has been set, we append
@@ -108,12 +108,12 @@ char *my_strerror(char *buf, size_t len, int nr)
         char tmp_buff[256] ;
 
         my_snprintf(tmp_buff, sizeof(tmp_buff), 
-                    " [OS Error Code : 0x%x]", my_winerr);
+                    " [OS Error Code : 0x%x]", mysys_thread_var()->thr_winerr);
 
         strcat_s(buf, len, tmp_buff);
       }
 
-      my_winerr= 0;
+      mysys_thread_var()->thr_winerr= 0;
     }
 #elif ((defined _POSIX_C_SOURCE && (_POSIX_C_SOURCE >= 200112L)) ||    \
        (defined _XOPEN_SOURCE   && (_XOPEN_SOURCE >= 600)))      &&    \
diff --git a/mysys/my_pread.c b/mysys/my_pread.c
index 9f190900da8..7c995b007a7 100644
--- a/mysys/my_pread.c
+++ b/mysys/my_pread.c
@@ -161,7 +161,7 @@ size_t my_pwrite(File Filedes, const uchar *Buffer, size_t Count,
     }
     DBUG_PRINT("error",("Write only %u bytes", (uint) writtenbytes));
 
-    if (my_thread_var->abort)
+    if (mysys_thread_var()->abort)
       MyFlags&= ~ MY_WAIT_IF_FULL;		/* End if aborted by user */
 
     if ((my_errno == ENOSPC || my_errno == EDQUOT) &&
diff --git a/mysys/my_thr_init.c b/mysys/my_thr_init.c
index 9e82e389435..61c72434154 100644
--- a/mysys/my_thr_init.c
+++ b/mysys/my_thr_init.c
@@ -22,8 +22,8 @@
 #include <m_string.h>
 #include <signal.h>
 
-pthread_key(struct st_my_thread_var*, THR_KEY_mysys);
-my_bool THR_KEY_mysys_initialized= FALSE;
+static thread_local_key_t THR_KEY_mysys;
+static my_bool THR_KEY_mysys_initialized= FALSE;
 mysql_mutex_t THR_LOCK_malloc, THR_LOCK_open,
               THR_LOCK_lock, THR_LOCK_myisam, THR_LOCK_heap,
               THR_LOCK_net, THR_LOCK_charset, THR_LOCK_threads,
@@ -89,7 +89,7 @@ void my_thread_global_reinit(void)
   mysql_cond_destroy(&THR_COND_threads);
   mysql_cond_init(key_THR_COND_threads, &THR_COND_threads);
 
-  tmp= _my_thread_var();
+  tmp= mysys_thread_var();
   DBUG_ASSERT(tmp);
 
   mysql_mutex_destroy(&tmp->mutex);
@@ -143,7 +143,7 @@ my_bool my_thread_global_init(void)
 #endif
 
   DBUG_ASSERT(! THR_KEY_mysys_initialized);
-  if ((pth_ret= pthread_key_create(&THR_KEY_mysys, NULL)) != 0)
+  if ((pth_ret= my_create_thread_local_key(&THR_KEY_mysys, NULL)) != 0)
   { /* purecov: begin inspected */
     my_message_local(ERROR_LEVEL, "Can't initialize threads: error %d",
                      pth_ret);
@@ -207,7 +207,7 @@ void my_thread_global_end(void)
   mysql_mutex_unlock(&THR_LOCK_threads);
 
   DBUG_ASSERT(THR_KEY_mysys_initialized);
-  pthread_key_delete(THR_KEY_mysys);
+  my_delete_thread_local_key(THR_KEY_mysys);
   THR_KEY_mysys_initialized= FALSE;
 #ifdef PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
   pthread_mutexattr_destroy(&my_fast_mutexattr);
@@ -250,43 +250,27 @@ static my_thread_id thread_id= 0;
    if one uses my_init() followed by mysql_server_init().
 
   RETURN
-    0  ok
-    1  Fatal error; mysys/dbug functions can't be used
+    FALSE  ok
+    TRUE   Fatal error; mysys/dbug functions can't be used
 */
 
-my_bool my_thread_init(void)
+my_bool my_thread_init()
 {
   struct st_my_thread_var *tmp;
-  my_bool error=0;
 
   if (!my_thread_global_init_done)
-    return 1; /* cannot proceed with unintialized library */
-
-#ifdef EXTRA_DEBUG_THREADS
-  my_message_local(INFORMATION_LEVEL, "my_thread_init(): thread_id: 0x%lx",
-                   (ulong) pthread_self());
-#endif  
+    return TRUE; /* cannot proceed with unintialized library */
 
-  if (_my_thread_var())
-  {
-#ifdef EXTRA_DEBUG_THREADS
-    my_message_local(WARNING_LEVEL,
-                     "my_thread_init() called more than once in thread 0x%lx",
-                     (long) pthread_self());
-#endif    
-    goto end;
-  }
+  if (mysys_thread_var())
+    return FALSE;
 
 #ifdef _MSC_VER
   install_sigabrt_handler();
 #endif
 
   if (!(tmp= (struct st_my_thread_var *) calloc(1, sizeof(*tmp))))
-  {
-    error= 1;
-    goto end;
-  }
-  set_mysys_var(tmp);
+    return TRUE;
+
   mysql_mutex_init(key_my_thread_var_mutex, &tmp->mutex, MY_MUTEX_INIT_FAST);
   mysql_cond_init(key_my_thread_var_suspend, &tmp->suspend);
 
@@ -297,14 +281,9 @@ my_bool my_thread_init(void)
   tmp->id= ++thread_id;
   ++THR_thread_count;
   mysql_mutex_unlock(&THR_LOCK_threads);
-  tmp->init= 1;
-#ifndef DBUG_OFF
-  /* Generate unique name for thread */
-  (void) my_thread_name();
-#endif
+  set_mysys_thread_var(tmp);
 
-end:
-  return error;
+  return FALSE;
 }
 
 
@@ -320,17 +299,9 @@ end:
     mysql_server_end() and then ends with a mysql_end().
 */
 
-void my_thread_end(void)
+void my_thread_end()
 {
-  struct st_my_thread_var *tmp;
-  tmp= _my_thread_var();
-
-#ifdef EXTRA_DEBUG_THREADS
-    my_message_local(INFORMATION_LEVEL, "my_thread_end(): tmp: 0x%lx  "
-                     "pthread_self: 0x%lx  thread_id: %ld",
-                     (long) tmp, (long) pthread_self(),
-                     tmp ? (long) tmp->id : 0L);
-#endif
+  struct st_my_thread_var *tmp= mysys_thread_var();
 
 #ifdef HAVE_PSI_INTERFACE
   /*
@@ -341,7 +312,7 @@ void my_thread_end(void)
   PSI_THREAD_CALL(delete_current_thread)();
 #endif
 
-  if (tmp && tmp->init)
+  if (tmp)
   {
 #if !defined(DBUG_OFF)
     /* tmp->dbug is allocated inside DBUG library */
@@ -368,56 +339,28 @@ void my_thread_end(void)
       mysql_cond_signal(&THR_COND_threads);
     mysql_mutex_unlock(&THR_LOCK_threads);
   }
-  set_mysys_var(NULL);
+  set_mysys_thread_var(NULL);
 }
 
-struct st_my_thread_var *_my_thread_var(void)
+
+struct st_my_thread_var *mysys_thread_var()
 {
   if (THR_KEY_mysys_initialized)
-    return  my_pthread_getspecific(struct st_my_thread_var*,THR_KEY_mysys);
+    return  (struct st_my_thread_var*)my_get_thread_local(THR_KEY_mysys);
   return NULL;
 }
 
-int set_mysys_var(struct st_my_thread_var *mysys_var)
+
+int set_mysys_thread_var(struct st_my_thread_var *mysys_var)
 {
   if (THR_KEY_mysys_initialized)
-    return my_pthread_setspecific_ptr(THR_KEY_mysys, mysys_var);
+    return my_set_thread_local(THR_KEY_mysys, mysys_var);
   return 0;
 }
 
-/****************************************************************************
-  Get name of current thread.
-****************************************************************************/
 
-my_thread_id my_thread_dbug_id()
-{
-  return my_thread_var->id;
-}
-
-#ifdef DBUG_OFF
-const char *my_thread_name(void)
-{
-  return "no_name";
-}
-
-#else
-
-const char *my_thread_name(void)
-{
-  char name_buff[100];
-  struct st_my_thread_var *tmp=my_thread_var;
-  if (!tmp->name[0])
-  {
-    my_thread_id id= my_thread_dbug_id();
-    sprintf(name_buff,"T@%lu", (ulong) id);
-    strmake(tmp->name,name_buff,THREAD_NAME_SIZE);
-  }
-  return tmp->name;
-}
-
-/* Return pointer to DBUG for holding current state */
-
-extern void **my_thread_var_dbug()
+#ifndef DBUG_OFF
+void **my_thread_var_dbug()
 {
   struct st_my_thread_var *tmp;
   /*
@@ -429,8 +372,8 @@ extern void **my_thread_var_dbug()
   */
   if (! THR_KEY_mysys_initialized)
     return NULL;
-  tmp= _my_thread_var();
-  return tmp && tmp->init ? &tmp->dbug : 0;
+  tmp= mysys_thread_var();
+  return tmp ? &tmp->dbug : NULL;
 }
 #endif /* DBUG_OFF */
 
diff --git a/mysys/my_winerr.c b/mysys/my_winerr.c
index cb45b87359f..41edd5f4ef6 100644
--- a/mysys/my_winerr.c
+++ b/mysys/my_winerr.c
@@ -122,9 +122,9 @@ static int get_errno_from_oserr(unsigned long oserrno)
 void my_osmaperr( unsigned long oserrno)
 {
   /*
-    set my_winerr so that we could return the Windows Error Code
+    set thr_winerr so that we could return the Windows Error Code
     when it is EINVAL.
   */
-  my_winerr= oserrno;
+  mysys_thread_var()->thr_winerr= oserrno;
   errno= get_errno_from_oserr(oserrno);
 }
diff --git a/mysys/my_write.c b/mysys/my_write.c
index 78e4d8cf45b..134da9506e0 100644
--- a/mysys/my_write.c
+++ b/mysys/my_write.c
@@ -79,7 +79,7 @@ size_t my_write(File Filedes, const uchar *Buffer, size_t Count, myf MyFlags)
     my_errno= errno;
     DBUG_PRINT("error",("Write only %ld bytes, error: %d",
 			(long) writtenbytes, my_errno));
-    if (my_thread_var->abort)
+    if (mysys_thread_var()->abort)
       MyFlags&= ~ MY_WAIT_IF_FULL;		/* End if aborted by user */
 
     if ((my_errno == ENOSPC || my_errno == EDQUOT) &&
diff --git a/mysys/thr_cond.c b/mysys/thr_cond.c
index 8f00811fa8f..4654497801d 100644
--- a/mysys/thr_cond.c
+++ b/mysys/thr_cond.c
@@ -58,7 +58,7 @@ int safe_cond_wait(native_cond_t *cond, my_mutex_t *mp,
   {
     fprintf(stderr,
 	    "safe_mutex:  Count was %d in thread 0x%x when locking mutex at %s, line %d\n",
-	    mp->count-1, my_thread_dbug_id(), file, line);
+	    mp->count-1, mysys_thread_var()->id, file, line);
     fflush(stderr);
     abort();
   }
@@ -96,7 +96,7 @@ int safe_cond_timedwait(native_cond_t *cond, my_mutex_t *mp,
   {
     fprintf(stderr,
 	    "safe_mutex:  Count was %d in thread 0x%x when locking mutex at %s, line %d (error: %d (%d))\n",
-	    mp->count-1, my_thread_dbug_id(), file, line, error, error);
+	    mp->count-1, mysys_thread_var()->id, file, line, error, error);
     fflush(stderr);
     abort();
   }
diff --git a/mysys/thr_lock.c b/mysys/thr_lock.c
index de698b7fe72..f6bbbb55455 100644
--- a/mysys/thr_lock.c
+++ b/mysys/thr_lock.c
@@ -332,9 +332,8 @@ void thr_lock_delete(THR_LOCK *lock)
 
 void thr_lock_info_init(THR_LOCK_INFO *info)
 {
-  struct st_my_thread_var *tmp= my_thread_var;
   info->thread=    pthread_self();
-  info->thread_id= tmp->id;
+  info->thread_id= mysys_thread_var()->id;
 }
 
 	/* Initialize a lock instance */
@@ -367,7 +366,7 @@ static enum enum_thr_lock_result
 wait_for_lock(struct st_lock_list *wait, THR_LOCK_DATA *data,
               my_bool in_wait_list, ulong lock_wait_timeout)
 {
-  struct st_my_thread_var *thread_var= my_thread_var;
+  struct st_my_thread_var *thread_var= mysys_thread_var();
   mysql_cond_t *cond= &thread_var->suspend;
   struct timespec wait_timeout;
   enum enum_thr_lock_result result= THR_LOCK_ABORTED;
@@ -1002,8 +1001,9 @@ thr_multi_lock(THR_LOCK_DATA **data, uint count, THR_LOCK_INFO *owner,
     }
     DEBUG_SYNC_C("thr_multi_lock_after_thr_lock");
 #ifdef MAIN
-    printf("Thread: %s  Got lock: 0x%lx  type: %d\n",my_thread_name(),
-	   (long) pos[0]->lock, pos[0]->type); fflush(stdout);
+    printf("Thread: T@%u  Got lock: 0x%lx  type: %d\n",
+           mysys_thread_var()->id, (long) pos[0]->lock, pos[0]->type);
+    fflush(stdout);
 #endif
   }
   thr_lock_merge_status(data, count);
@@ -1095,8 +1095,8 @@ void thr_multi_unlock(THR_LOCK_DATA **data,uint count)
   for (pos=data,end=data+count; pos < end ; pos++)
   {
 #ifdef MAIN
-    printf("Thread: %s  Rel lock: 0x%lx  type: %d\n",
-	   my_thread_name(), (long) pos[0]->lock, pos[0]->type);
+    printf("Thread: T@%u  Rel lock: 0x%lx  type: %d\n",
+	   mysys_thread_var()->id, (long) pos[0]->lock, pos[0]->type);
     fflush(stdout);
 #endif
     if ((*pos)->type != TL_UNLOCK)
@@ -1393,7 +1393,8 @@ static void *test_thread(void *arg)
   THR_LOCK_DATA *multi_locks[MAX_LOCK_COUNT];
   my_thread_init();
 
-  printf("Thread %s (%d) started\n",my_thread_name(),param); fflush(stdout);
+  printf("Thread T@%u (%d) started\n", mysys_thread_var()->id, param);
+  fflush(stdout);
 
 
   thr_lock_info_init(&lock_info);
@@ -1425,7 +1426,8 @@ static void *test_thread(void *arg)
     thr_multi_unlock(multi_locks,lock_counts[param]);
   }
 
-  printf("Thread %s (%d) ended\n",my_thread_name(),param); fflush(stdout);
+  printf("Thread T@%u (%d) ended\n", mysys_thread_var()->id, param);
+  fflush(stdout);
   thr_print_locks();
   mysql_mutex_lock(&LOCK_thread_count);
   thread_count--;
@@ -1445,7 +1447,7 @@ int main(int argc __attribute__((unused)),char **argv __attribute__((unused)))
   if (argc > 1 && argv[1][0] == '-' && argv[1][1] == '#')
     DBUG_PUSH(argv[1]+2);
 
-  printf("Main thread: %s\n",my_thread_name());
+  printf("Main thread: T@%u\n", mysys_thread_var()->id);
 
   if ((error= mysql_cond_init(0, &COND_thread_count)))
   {
diff --git a/mysys/thr_mutex.c b/mysys/thr_mutex.c
index d1589cc075b..a57d8d6c19a 100644
--- a/mysys/thr_mutex.c
+++ b/mysys/thr_mutex.c
@@ -72,8 +72,8 @@ int safe_mutex_lock(my_mutex_t *mp, my_bool try_lock,
     {
       fprintf(stderr,
               "safe_mutex: Trying to lock mutex at %s, line %d, when the"
-              " mutex was already locked at %s, line %d in thread %s\n",
-              file,line,mp->file, mp->line, my_thread_name());
+              " mutex was already locked at %s, line %d in thread T@%u\n",
+              file,line,mp->file, mp->line, mysys_thread_var()->id);
       fflush(stderr);
       abort();
     }
diff --git a/plugin/innodb_memcached/innodb_memcache/src/handler_api.cc b/plugin/innodb_memcached/innodb_memcache/src/handler_api.cc
index fa9c8849714..cc5f608ac1b 100644
--- a/plugin/innodb_memcached/innodb_memcache/src/handler_api.cc
+++ b/plugin/innodb_memcached/innodb_memcache/src/handler_api.cc
@@ -114,13 +114,13 @@ handler_thd_attach(
 	THD*	thd = static_cast<THD*>(my_thd);
 
 	if (original_thd) {
-		*original_thd = my_pthread_getspecific(THD*, THR_THD);
+          *original_thd = static_cast<THD*>(my_get_thread_local(THR_THD));
 		assert(thd->mysys_var);
 	}
 
-	my_pthread_setspecific_ptr(THR_THD, thd);
-	my_pthread_setspecific_ptr(THR_MALLOC, &thd->mem_root);
-	set_mysys_var(thd->mysys_var);
+	my_set_thread_local(THR_THD, thd);
+	my_set_thread_local(THR_MALLOC, &thd->mem_root);
+	set_mysys_thread_var(thd->mysys_var);
 }
 
 /**********************************************************************//**
diff --git a/plugin/semisync/semisync_master_plugin.cc b/plugin/semisync/semisync_master_plugin.cc
index 2a8d4bbca38..769ad006609 100644
--- a/plugin/semisync/semisync_master_plugin.cc
+++ b/plugin/semisync/semisync_master_plugin.cc
@@ -32,7 +32,7 @@ static ulong rpl_semi_sync_master_wait_point= WAIT_AFTER_COMMIT;
 
 static bool SEMI_SYNC_DUMP= true;
 
-pthread_key(bool *, THR_RPL_SEMI_SYNC_DUMP);
+thread_local_key_t THR_RPL_SEMI_SYNC_DUMP;
 
 static inline bool is_semi_sync_dump()
 {
@@ -40,7 +40,7 @@ static inline bool is_semi_sync_dump()
     The key is only set for semisync dump threads, so it just checks if
     the key is not NULL.
   */
-  return my_pthread_getspecific_ptr(bool *, THR_RPL_SEMI_SYNC_DUMP) != NULL;
+  return my_get_thread_local(THR_RPL_SEMI_SYNC_DUMP) != NULL;
 }
 
 C_MODE_START
@@ -120,7 +120,7 @@ int repl_semi_binlog_dump_start(Binlog_transmit_param *param,
       return -1;
     }
 
-    my_pthread_setspecific_ptr(THR_RPL_SEMI_SYNC_DUMP, &SEMI_SYNC_DUMP);
+    my_set_thread_local(THR_RPL_SEMI_SYNC_DUMP, &SEMI_SYNC_DUMP);
 
     /* One more semi-sync slave */
     repl_semisync.add_slave();
@@ -156,7 +156,7 @@ int repl_semi_binlog_dump_end(Binlog_transmit_param *param)
     ack_receiver.remove_slave(current_thd);
     /* One less semi-sync slave */
     repl_semisync.remove_slave();
-    my_pthread_setspecific_ptr(THR_RPL_SEMI_SYNC_DUMP, NULL);
+    my_set_thread_local(THR_RPL_SEMI_SYNC_DUMP, NULL);
   }
   return 0;
 }
@@ -565,7 +565,7 @@ static int semi_sync_master_plugin_init(void *p)
   init_semisync_psi_keys();
 #endif
 
-  pthread_key_create(&THR_RPL_SEMI_SYNC_DUMP, NULL);
+  my_create_thread_local_key(&THR_RPL_SEMI_SYNC_DUMP, NULL);
 
   if (repl_semisync.initObject())
     return 1;
@@ -583,7 +583,7 @@ static int semi_sync_master_plugin_init(void *p)
 static int semi_sync_master_plugin_deinit(void *p)
 {
   ack_receiver.stop();
-  pthread_key_delete(THR_RPL_SEMI_SYNC_DUMP);
+  my_delete_thread_local_key(THR_RPL_SEMI_SYNC_DUMP);
 
   if (unregister_trans_observer(&trans_observer, p))
   {
diff --git a/sql/binlog.cc b/sql/binlog.cc
index 91738bf35ee..95dc1a8b4b2 100644
--- a/sql/binlog.cc
+++ b/sql/binlog.cc
@@ -256,7 +256,7 @@ private:
       goto exit0;
     if ((error= my_pthread_set_THR_MALLOC(&thd->mem_root)))
       goto exit1;
-    if ((error= set_mysys_var(thd->mysys_var)))
+    if ((error= set_mysys_thread_var(thd->mysys_var)))
       goto exit2;
     goto exit0;
 exit2:
diff --git a/sql/ha_ndb_ddl_fk.cc b/sql/ha_ndb_ddl_fk.cc
index b03eb63e688..39c5b6e94d6 100644
--- a/sql/ha_ndb_ddl_fk.cc
+++ b/sql/ha_ndb_ddl_fk.cc
@@ -1666,7 +1666,7 @@ fk_split_name(char dst[], const char * src, bool index)
 
 struct Ndb_mem_root_guard {
   Ndb_mem_root_guard(MEM_ROOT *new_root) {
-    root_ptr= my_pthread_getspecific(MEM_ROOT**, THR_MALLOC);
+    root_ptr= my_pthread_get_THR_MALLOC();
     DBUG_ASSERT(root_ptr != 0);
     old_root= *root_ptr;
     *root_ptr= new_root;
diff --git a/sql/ha_ndbcluster.cc b/sql/ha_ndbcluster.cc
index 205c946a52b..b9da4365895 100644
--- a/sql/ha_ndbcluster.cc
+++ b/sql/ha_ndbcluster.cc
@@ -13504,8 +13504,7 @@ NDB_SHARE::create(const char* key, size_t key_length,
                                       MYF(MY_WME | MY_ZEROFILL))))
     return NULL;
 
-  MEM_ROOT **root_ptr=
-    my_pthread_getspecific_ptr(MEM_ROOT**, THR_MALLOC);
+  MEM_ROOT **root_ptr= my_pthread_get_THR_MALLOC();
   MEM_ROOT *old_root= *root_ptr;
 
   init_sql_alloc(PSI_INSTRUMENT_ME, &share->mem_root, 1024, 0);
diff --git a/sql/mysqld.cc b/sql/mysqld.cc
index fdad7c34cfa..5e573bd09d6 100644
--- a/sql/mysqld.cc
+++ b/sql/mysqld.cc
@@ -589,9 +589,9 @@ SHOW_COMP_OPTION have_statement_timeout= SHOW_OPTION_DISABLED;
 
 /* Thread specific variables */
 
-pthread_key(MEM_ROOT**,THR_MALLOC);
+thread_local_key_t THR_MALLOC;
 bool THR_MALLOC_initialized= false;
-pthread_key(THD*, THR_THD);
+thread_local_key_t THR_THD;
 bool THR_THD_initialized= false;
 mysql_mutex_t
   LOCK_status, LOCK_error_log, LOCK_uuid_generator,
@@ -1432,13 +1432,13 @@ void clean_up(bool print_message)
   if (THR_THD_initialized)
   {
     THR_THD_initialized= false;
-    (void) pthread_key_delete(THR_THD);
+    (void) my_delete_thread_local_key(THR_THD);
   }
 
   if (THR_MALLOC_initialized)
   {
     THR_MALLOC_initialized= false;
-    (void) pthread_key_delete(THR_MALLOC);
+    (void) my_delete_thread_local_key(THR_MALLOC);
   }
 
 #ifdef HAVE_MY_TIMER
@@ -3235,8 +3235,8 @@ static int init_thread_environment()
 
   DBUG_ASSERT(! THR_THD_initialized);
   DBUG_ASSERT(! THR_MALLOC_initialized);
-  if (pthread_key_create(&THR_THD,NULL) ||
-      pthread_key_create(&THR_MALLOC,NULL))
+  if (my_create_thread_local_key(&THR_THD,NULL) ||
+      my_create_thread_local_key(&THR_MALLOC,NULL))
   {
     sql_print_error("Can't create thread-keys");
     return 1;
diff --git a/sql/mysqld.h b/sql/mysqld.h
index 4dcb24ffed9..b7cbebc6146 100644
--- a/sql/mysqld.h
+++ b/sql/mysqld.h
@@ -312,23 +312,40 @@ extern LEX_CSTRING sql_statement_names[(uint) SQLCOM_END + 1];
 
 /*
   THR_MALLOC is a key which will be used to set/get MEM_ROOT** for a thread,
-  using my_pthread_setspecific_ptr()/my_thread_getspecific_ptr().
+  using my_set_thread_local()/my_get_thread_local().
 */
-extern pthread_key(MEM_ROOT**,THR_MALLOC);
+extern thread_local_key_t THR_MALLOC;
 extern bool THR_MALLOC_initialized;
 
-static inline MEM_ROOT **
-my_pthread_get_THR_MALLOC()
+static inline MEM_ROOT ** my_pthread_get_THR_MALLOC()
 {
   DBUG_ASSERT(THR_MALLOC_initialized);
-  return my_pthread_getspecific(MEM_ROOT **, THR_MALLOC);
+  return (MEM_ROOT**) my_get_thread_local(THR_MALLOC);
 }
 
-static inline int
-my_pthread_set_THR_MALLOC(MEM_ROOT ** hdl)
+static inline int my_pthread_set_THR_MALLOC(MEM_ROOT ** hdl)
 {
   DBUG_ASSERT(THR_MALLOC_initialized);
-  return my_pthread_setspecific_ptr(THR_MALLOC, hdl);
+  return my_set_thread_local(THR_MALLOC, hdl);
+}
+
+/*
+  THR_THD is a key which will be used to set/get THD* for a thread,
+  using my_set_thread_local()/my_get_thread_local().
+*/
+extern MYSQL_PLUGIN_IMPORT thread_local_key_t THR_THD;
+extern bool THR_THD_initialized;
+
+static inline THD * my_pthread_get_THR_THD()
+{
+  DBUG_ASSERT(THR_THD_initialized);
+  return (THD*)my_get_thread_local(THR_THD);
+}
+
+static inline int my_pthread_set_THR_THD(THD *thd)
+{
+  DBUG_ASSERT(THR_THD_initialized);
+  return my_set_thread_local(THR_THD, thd);
 }
 
 extern bool load_perfschema_engine;
@@ -780,23 +797,6 @@ extern int32 thread_running;
 extern char *opt_ssl_ca, *opt_ssl_capath, *opt_ssl_cert, *opt_ssl_cipher,
             *opt_ssl_key, *opt_ssl_crl, *opt_ssl_crlpath;
 
-extern MYSQL_PLUGIN_IMPORT pthread_key(THD*, THR_THD);
-extern bool THR_THD_initialized;
-
-static inline THD *
-my_pthread_get_THR_THD()
-{
-  DBUG_ASSERT(THR_THD_initialized);
-  return my_pthread_getspecific(THD *, THR_THD);
-}
-
-static inline int
-my_pthread_set_THR_THD(THD *thd)
-{
-  DBUG_ASSERT(THR_THD_initialized);
-  return my_pthread_setspecific_ptr(THR_THD, thd);
-}
-
 /**
   only options that need special treatment in get_one_option() deserve
   to be listed below
@@ -913,13 +913,7 @@ extern "C" void unireg_clear(int exit_code);
 extern "C" THD *_current_thd_noinline();
 #define _current_thd() _current_thd_noinline()
 #else
-/*
-  THR_THD is a key which will be used to set/get THD* for a thread,
-  using my_pthread_setspecific_ptr()/my_thread_getspecific_ptr().
-*/
-extern pthread_key(THD*, THR_THD);
-extern bool THR_THD_initialized;
-inline THD *_current_thd(void)
+static inline THD *_current_thd(void)
 {
   return my_pthread_get_THR_THD();
 }
diff --git a/sql/rpl_gtid_persist.cc b/sql/rpl_gtid_persist.cc
index 2512942ba8f..63c4e7350f2 100644
--- a/sql/rpl_gtid_persist.cc
+++ b/sql/rpl_gtid_persist.cc
@@ -64,7 +64,7 @@ static void deinit_thd(THD *thd)
   thd->release_resources();
   thd->restore_globals();
   delete thd;
-  my_pthread_setspecific_ptr(THR_THD,  NULL);
+  my_pthread_set_THR_THD(NULL);
   DBUG_VOID_RETURN;
 }
 
diff --git a/sql/rpl_slave.cc b/sql/rpl_slave.cc
index c24e06e0008..daeaedbcc3b 100644
--- a/sql/rpl_slave.cc
+++ b/sql/rpl_slave.cc
@@ -133,7 +133,7 @@ bool append_item_to_jobs(slave_job_item *job_item,
 
 int disconnect_slave_event_count = 0, abort_slave_event_count = 0;
 
-static pthread_key(Master_info*, RPL_MASTER_INFO);
+static thread_local_key_t RPL_MASTER_INFO;
 
 enum enum_slave_reconnect_actions
 {
@@ -371,7 +371,7 @@ int init_slave()
   */
   mysql_mutex_lock(&LOCK_active_mi);
 
-  if (pthread_key_create(&RPL_MASTER_INFO, NULL))
+  if (my_create_thread_local_key(&RPL_MASTER_INFO, NULL))
     DBUG_RETURN(1);
 
   if ((error= Rpl_info_factory::create_coordinators(opt_mi_repository_id, &active_mi,
@@ -4355,7 +4355,7 @@ pthread_handler_t handle_slave_io(void *arg)
                             llstr(mi->get_master_log_pos(), llbuff)));
 
   /* This must be called before run any binlog_relay_io hooks */
-  my_pthread_setspecific_ptr(RPL_MASTER_INFO, mi);
+  my_set_thread_local(RPL_MASTER_INFO, mi);
 
   if (RUN_HOOK(binlog_relay_io, thread_start, (thd, mi)))
   {
diff --git a/sql/rpl_table_access.cc b/sql/rpl_table_access.cc
index 389015ca82a..725aa77f70c 100644
--- a/sql/rpl_table_access.cc
+++ b/sql/rpl_table_access.cc
@@ -149,7 +149,7 @@ void System_table_access::drop_thd(THD *thd)
   DBUG_ENTER("System_table_access::drop_thd");
 
   delete thd;
-  my_pthread_setspecific_ptr(THR_THD, NULL);
+  my_pthread_set_THR_THD(NULL);
 
   DBUG_VOID_RETURN;
 }
diff --git a/sql/signal_handler.cc b/sql/signal_handler.cc
index 2cb0582d269..c6e60d49e96 100644
--- a/sql/signal_handler.cc
+++ b/sql/signal_handler.cc
@@ -133,7 +133,7 @@ extern "C" void handle_fatal_signal(int sig)
     "Hope that's ok; if not, decrease some variables in the equation.\n\n");
 
 #ifdef HAVE_STACKTRACE
-  THD *thd= my_pthread_getspecific(THD *, THR_THD);
+  THD *thd= my_pthread_get_THR_THD();
 
   if (!(test_flags & TEST_NO_STACKTRACE))
   {
diff --git a/sql/sql_class.cc b/sql/sql_class.cc
index 8c16333b4ff..e48045e6db7 100644
--- a/sql/sql_class.cc
+++ b/sql/sql_class.cc
@@ -1968,7 +1968,7 @@ bool THD::store_globals()
     have the mysys_var reference (which in fact refers to the worker
     threads local storage with key THR_KEY_mysys. 
   */
-  mysys_var=my_thread_var;
+  mysys_var= mysys_thread_var();
   DBUG_PRINT("debug", ("mysys_var: 0x%llx", (ulonglong) mysys_var));
   /*
     Let mysqld define the thread id (not mysys)
diff --git a/sql/sql_reload.cc b/sql/sql_reload.cc
index 75e5e18897a..2d1f31b85da 100644
--- a/sql/sql_reload.cc
+++ b/sql/sql_reload.cc
@@ -184,7 +184,7 @@ bool reload_acl_and_cache(THD *thd, unsigned long options,
     {
       delete tmp_thd;
       /* Remember that we don't have a THD */
-      my_pthread_setspecific_ptr(THR_THD,  0);
+      my_pthread_set_THR_THD(NULL);
       thd= 0;
     }
   }
diff --git a/storage/myisam/mi_log.c b/storage/myisam/mi_log.c
index 477d63e7919..6e5d57d7b00 100644
--- a/storage/myisam/mi_log.c
+++ b/storage/myisam/mi_log.c
@@ -24,7 +24,7 @@
 #endif
 
 #undef GETPID					/* For HPUX */
-#define GETPID() (log_type == 1 ? (long) myisam_pid : (long) my_thread_dbug_id())
+#define GETPID() (log_type == 1 ? (long) myisam_pid : (long) mysys_thread_var()->id)
 
 	/* Activate logging if flag is 1 and reset logging if flag is 0 */
 
diff --git a/storage/ndb/src/common/portlib/NdbThread.c b/storage/ndb/src/common/portlib/NdbThread.c
index 68b6a9fc8a9..ec32ee358b0 100644
--- a/storage/ndb/src/common/portlib/NdbThread.c
+++ b/storage/ndb/src/common/portlib/NdbThread.c
@@ -866,9 +866,9 @@ end:
 }
 
 #ifndef NDB_MUTEX_DEADLOCK_DETECTOR
-static pthread_key(void*, tls_keys[NDB_THREAD_TLS_MAX]);
+static thread_local_key_t tls_keys[NDB_THREAD_TLS_MAX];
 #else
-static pthread_key(void*, tls_keys[NDB_THREAD_TLS_MAX + 1]);
+static thread_local_key_t tls_keys[NDB_THREAD_TLS_MAX + 1];
 #endif
 
 struct NdbThread* NdbThread_GetNdbThread()
@@ -878,12 +878,12 @@ struct NdbThread* NdbThread_GetNdbThread()
 
 void *NdbThread_GetTlsKey(NDB_THREAD_TLS key)
 {
-  return pthread_getspecific(tls_keys[key]);
+  return my_get_thread_local(tls_keys[key]);
 }
 
 void NdbThread_SetTlsKey(NDB_THREAD_TLS key, void *value)
 {
-  pthread_setspecific(tls_keys[key], value);
+  my_set_thread_local(tls_keys[key], value);
 }
 
 int
@@ -891,11 +891,11 @@ NdbThread_Init()
 { 
   g_ndb_thread_mutex = NdbMutex_Create();
   g_ndb_thread_condition = NdbCondition_Create();
-  pthread_key_create(&(tls_keys[NDB_THREAD_TLS_JAM]), NULL);
-  pthread_key_create(&(tls_keys[NDB_THREAD_TLS_THREAD]), NULL);
-  pthread_key_create(&(tls_keys[NDB_THREAD_TLS_NDB_THREAD]), NULL);
+  my_create_thread_local_key(&(tls_keys[NDB_THREAD_TLS_JAM]), NULL);
+  my_create_thread_local_key(&(tls_keys[NDB_THREAD_TLS_THREAD]), NULL);
+  my_create_thread_local_key(&(tls_keys[NDB_THREAD_TLS_NDB_THREAD]), NULL);
 #ifdef NDB_MUTEX_DEADLOCK_DETECTOR
-  pthread_key_create(&(tls_keys[NDB_THREAD_TLS_MAX]), NULL);
+  my_create_thread_local_key(&(tls_keys[NDB_THREAD_TLS_MAX]), NULL);
 #endif
   NdbThread_CreateObject(0);
   return 0;
diff --git a/storage/perfschema/pfs.cc b/storage/perfschema/pfs.cc
index bc057e10d5a..d1ae8c4e10b 100644
--- a/storage/perfschema/pfs.cc
+++ b/storage/perfschema/pfs.cc
@@ -1298,14 +1298,14 @@ static inline int mysql_mutex_lock(...)
   @ingroup Performance_schema_implementation
 */
 
-pthread_key(PFS_thread*, THR_PFS);
+thread_local_key_t THR_PFS;
 bool THR_PFS_initialized= false;
 
 static inline PFS_thread*
 my_pthread_get_THR_PFS()
 {
   DBUG_ASSERT(THR_PFS_initialized);
-  PFS_thread *thread= my_pthread_getspecific_ptr(PFS_thread*, THR_PFS);
+  PFS_thread *thread= static_cast<PFS_thread*>(my_get_thread_local(THR_PFS));
   DBUG_ASSERT(thread == NULL || sanitize_thread(thread) != NULL);
   return thread;
 }
@@ -1314,7 +1314,7 @@ static inline void
 my_pthread_set_THR_PFS(PFS_thread *pfs)
 {
   DBUG_ASSERT(THR_PFS_initialized);
-  my_pthread_setspecific_ptr(THR_PFS, pfs);
+  my_set_thread_local(THR_PFS, pfs);
 }
 
 /**
@@ -2407,7 +2407,7 @@ void pfs_delete_current_thread_v1(void)
   if (thread != NULL)
   {
     aggregate_thread(thread, thread->m_account, thread->m_user, thread->m_host);
-    my_pthread_setspecific_ptr(THR_PFS, NULL);
+    my_set_thread_local(THR_PFS, NULL);
     destroy_thread(thread);
   }
 }
@@ -6181,7 +6181,7 @@ static PSI_memory_key pfs_memory_alloc_v1(PSI_memory_key key, size_t size)
 
   if (flag_thread_instrumentation)
   {
-    PFS_thread *pfs_thread= my_pthread_getspecific_ptr(PFS_thread*, THR_PFS);
+    PFS_thread *pfs_thread= (PFS_thread*)my_get_thread_local(THR_PFS);
     if (unlikely(pfs_thread == NULL))
       return PSI_NOT_INSTRUMENTED;
     if (! pfs_thread->m_enabled)
@@ -6222,7 +6222,7 @@ static PSI_memory_key pfs_memory_realloc_v1(PSI_memory_key key, size_t old_size,
 
   if (flag_thread_instrumentation)
   {
-    PFS_thread *pfs_thread= my_pthread_getspecific_ptr(PFS_thread*, THR_PFS);
+    PFS_thread *pfs_thread= (PFS_thread*)my_get_thread_local(THR_PFS);
     if (likely(pfs_thread != NULL))
     {
       /* Aggregate to MEMORY_SUMMARY_BY_THREAD_BY_EVENT_NAME */
@@ -6285,7 +6285,7 @@ static void pfs_memory_free_v1(PSI_memory_key key, size_t size)
 
   if (flag_thread_instrumentation)
   {
-    PFS_thread *pfs_thread= my_pthread_getspecific_ptr(PFS_thread*, THR_PFS);
+    PFS_thread *pfs_thread= (PFS_thread*)my_get_thread_local(THR_PFS);
     if (likely(pfs_thread != NULL))
     {
       /*
@@ -6342,7 +6342,7 @@ pfs_create_metadata_lock_v1(
   if (! global_metadata_class.m_enabled)
     return NULL;
 
-  PFS_thread *pfs_thread= my_pthread_getspecific_ptr(PFS_thread*, THR_PFS);
+  PFS_thread *pfs_thread= (PFS_thread*)my_get_thread_local(THR_PFS);
   if (pfs_thread == NULL)
     return NULL;
 
@@ -6394,7 +6394,7 @@ pfs_start_metadata_wait_v1(PSI_metadata_locker_state *state,
 
   if (flag_thread_instrumentation)
   {
-    PFS_thread *pfs_thread= my_pthread_getspecific_ptr(PFS_thread*, THR_PFS);
+    PFS_thread *pfs_thread= (PFS_thread*)my_get_thread_local(THR_PFS);
     if (unlikely(pfs_thread == NULL))
       return NULL;
     if (! pfs_thread->m_enabled)
diff --git a/storage/perfschema/pfs.h b/storage/perfschema/pfs.h
index 5f543d80375..ec4d412a170 100644
--- a/storage/perfschema/pfs.h
+++ b/storage/perfschema/pfs.h
@@ -33,7 +33,7 @@
 */
 extern struct PSI_bootstrap PFS_bootstrap;
 /** Performance schema Thread Local Storage key.  */
-extern pthread_key(PFS_thread*, THR_PFS);
+extern thread_local_key_t THR_PFS;
 /** True when @c THR_PFS is initialized. */
 extern bool THR_PFS_initialized;
 
diff --git a/storage/perfschema/pfs_instr.cc b/storage/perfschema/pfs_instr.cc
index cb199211aec..85a7da39c0f 100644
--- a/storage/perfschema/pfs_instr.cc
+++ b/storage/perfschema/pfs_instr.cc
@@ -886,8 +886,7 @@ void destroy_cond(PFS_cond *pfs)
 
 PFS_thread* PFS_thread::get_current_thread()
 {
-  PFS_thread *pfs= my_pthread_getspecific_ptr(PFS_thread*, THR_PFS);
-  return pfs;
+  return static_cast<PFS_thread*>(my_get_thread_local(THR_PFS));
 }
 
 void PFS_thread::reset_session_connect_attrs()
diff --git a/storage/perfschema/pfs_server.cc b/storage/perfschema/pfs_server.cc
index ab4bd7d9110..c49db18d559 100644
--- a/storage/perfschema/pfs_server.cc
+++ b/storage/perfschema/pfs_server.cc
@@ -62,7 +62,7 @@ void pre_initialize_performance_schema()
   global_table_io_stat.reset();
   global_table_lock_stat.reset();
 
-  if (pthread_key_create(&THR_PFS, destroy_pfs_thread))
+  if (my_create_thread_local_key(&THR_PFS, destroy_pfs_thread))
     return;
 
   THR_PFS_initialized= true;
@@ -273,8 +273,8 @@ void shutdown_performance_schema(void)
   */
   if (THR_PFS_initialized)
   {
-    my_pthread_setspecific_ptr(THR_PFS, NULL);
-    pthread_key_delete(THR_PFS);
+    my_set_thread_local(THR_PFS, NULL);
+    my_delete_thread_local_key(THR_PFS);
     THR_PFS_initialized= false;
   }
 }
diff --git a/unittest/gunit/dynarray-t.cc b/unittest/gunit/dynarray-t.cc
index c7492791877..a33234e365c 100644
--- a/unittest/gunit/dynarray-t.cc
+++ b/unittest/gunit/dynarray-t.cc
@@ -234,8 +234,8 @@ protected:
   virtual void SetUp()
   {
     init_sql_alloc(PSI_NOT_INSTRUMENTED, &m_mem_root, 1024, 0);
-    ASSERT_EQ(0, my_pthread_setspecific_ptr(THR_MALLOC, &m_mem_root_p));
-    MEM_ROOT *root= *my_pthread_getspecific_ptr(MEM_ROOT**, THR_MALLOC);
+    ASSERT_EQ(0, my_set_thread_local(THR_MALLOC, &m_mem_root_p));
+    MEM_ROOT *root= *static_cast<MEM_ROOT**>(my_get_thread_local(THR_MALLOC));
     ASSERT_EQ(root, m_mem_root_p);
 
     m_array_mysys.reserve(num_elements);
@@ -251,17 +251,17 @@ protected:
   static void SetUpTestCase()
   {
     generate_test_data(test_data, table_list, num_elements);
-    ASSERT_EQ(0, pthread_key_create(&THR_THD, NULL));
+    ASSERT_EQ(0, my_create_thread_local_key(&THR_THD, NULL));
     THR_THD_initialized= true;
-    ASSERT_EQ(0, pthread_key_create(&THR_MALLOC, NULL));
+    ASSERT_EQ(0, my_create_thread_local_key(&THR_MALLOC, NULL));
     THR_MALLOC_initialized= true;
   }
 
   static void TearDownTestCase()
   {
-    pthread_key_delete(THR_THD);
+    my_delete_thread_local_key(THR_THD);
     THR_THD_initialized= false;
-    pthread_key_delete(THR_MALLOC);
+    my_delete_thread_local_key(THR_MALLOC);
     THR_MALLOC_initialized= false;
   }
 
diff --git a/unittest/gunit/gunit_test_main.cc b/unittest/gunit/gunit_test_main.cc
index 4c60d42801a..fa771bd97e4 100644
--- a/unittest/gunit/gunit_test_main.cc
+++ b/unittest/gunit/gunit_test_main.cc
@@ -55,8 +55,8 @@ extern "C" my_bool get_one_option(int, const struct my_option *, char *)
 // Some globals needed for merge_small_tests.cc
 mysql_mutex_t LOCK_open;
 uint    opt_debug_sync_timeout= 0;
-pthread_key(MEM_ROOT**,THR_MALLOC);
-pthread_key(THD*, THR_THD);
+thread_local_key_t THR_MALLOC;
+thread_local_key_t THR_THD;
 bool THR_THD_initialized= false;
 bool THR_MALLOC_initialized= false;
 
diff --git a/unittest/gunit/sql_list-t.cc b/unittest/gunit/sql_list-t.cc
index 27a9016f00a..f27e89bd82e 100644
--- a/unittest/gunit/sql_list-t.cc
+++ b/unittest/gunit/sql_list-t.cc
@@ -62,8 +62,8 @@ protected:
   virtual void SetUp()
   {
     init_sql_alloc(PSI_NOT_INSTRUMENTED, &m_mem_root, 1024, 0);
-    ASSERT_EQ(0, my_pthread_setspecific_ptr(THR_MALLOC, &m_mem_root_p));
-    MEM_ROOT *root= *my_pthread_getspecific_ptr(MEM_ROOT**, THR_MALLOC);
+    ASSERT_EQ(0, my_set_thread_local(THR_MALLOC, &m_mem_root_p));
+    MEM_ROOT *root= *static_cast<MEM_ROOT**>(my_get_thread_local(THR_MALLOC));
     ASSERT_EQ(root, m_mem_root_p);
   }
 
@@ -74,17 +74,17 @@ protected:
 
   static void SetUpTestCase()
   {
-    ASSERT_EQ(0, pthread_key_create(&THR_THD, NULL));
+    ASSERT_EQ(0, my_create_thread_local_key(&THR_THD, NULL));
     THR_THD_initialized= true;
-    ASSERT_EQ(0, pthread_key_create(&THR_MALLOC, NULL));
+    ASSERT_EQ(0, my_create_thread_local_key(&THR_MALLOC, NULL));
     THR_MALLOC_initialized= true;
   }
 
   static void TearDownTestCase()
   {
-    pthread_key_delete(THR_THD);
+    my_delete_thread_local_key(THR_THD);
     THR_THD_initialized= false;
-    pthread_key_delete(THR_MALLOC);
+    my_delete_thread_local_key(THR_MALLOC);
     THR_MALLOC_initialized= false;
   }
 
diff --git a/unittest/gunit/test_utils.h b/unittest/gunit/test_utils.h
index fc4b3b2c07b..9105f9d3e68 100644
--- a/unittest/gunit/test_utils.h
+++ b/unittest/gunit/test_utils.h
@@ -21,8 +21,8 @@
 #include "sql_class.h"
 #include "set_var.h"
 
-extern pthread_key(MEM_ROOT**,THR_MALLOC);
-extern pthread_key(THD*, THR_THD);
+extern thread_local_key_t THR_MALLOC;
+extern thread_local_key_t THR_THD;
 extern bool THR_THD_initialized;
 extern bool THR_MALLOC_initialized;
 extern mysql_mutex_t LOCK_open;

