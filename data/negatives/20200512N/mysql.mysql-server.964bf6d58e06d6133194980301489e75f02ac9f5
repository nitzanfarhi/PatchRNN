commit 964bf6d58e06d6133194980301489e75f02ac9f5
Author: jonas@perch.ndb.mysql.com <>
Date:   Wed Aug 2 14:45:29 2006 +0200

    ndb -
      make Dblqh use OM_AUTO_SYNC

diff --git a/storage/ndb/include/kernel/signaldata/FsOpenReq.hpp b/storage/ndb/include/kernel/signaldata/FsOpenReq.hpp
index ad453da65b6..7365f4592ff 100644
--- a/storage/ndb/include/kernel/signaldata/FsOpenReq.hpp
+++ b/storage/ndb/include/kernel/signaldata/FsOpenReq.hpp
@@ -43,6 +43,7 @@ class FsOpenReq {
   friend class Lgman;
   friend class Tsman;
   friend class Restore;
+  friend class Dblqh;
 
   /**
    * For printing
diff --git a/storage/ndb/src/kernel/blocks/dblqh/Dblqh.hpp b/storage/ndb/src/kernel/blocks/dblqh/Dblqh.hpp
index be52e06eb81..f0d87bb8053 100644
--- a/storage/ndb/src/kernel/blocks/dblqh/Dblqh.hpp
+++ b/storage/ndb/src/kernel/blocks/dblqh/Dblqh.hpp
@@ -29,6 +29,7 @@
 #include <signaldata/LCP.hpp>
 #include <signaldata/LqhTransConf.hpp>
 #include <signaldata/LqhFrag.hpp>
+#include <signaldata/FsOpenReq.hpp>
 
 // primary key is stored in TUP
 #include "../dbtup/Dbtup.hpp"
@@ -1515,11 +1516,6 @@ public:
     /**
      *       This variable contains the last word written in the last page.
      */
-    UintR logFilePagesToDiskWithoutSynch;
-    /**
-     *       This variable keeps track of the number of pages written since
-     *       last synch on this log file.
-     */
     LogFileStatus logFileStatus;
     /**
      *       A reference to page zero in this file. 
diff --git a/storage/ndb/src/kernel/blocks/dblqh/DblqhMain.cpp b/storage/ndb/src/kernel/blocks/dblqh/DblqhMain.cpp
index 8e6333e4615..e917e78414b 100644
--- a/storage/ndb/src/kernel/blocks/dblqh/DblqhMain.cpp
+++ b/storage/ndb/src/kernel/blocks/dblqh/DblqhMain.cpp
@@ -12415,7 +12415,6 @@ void Dblqh::initFsopenconf(Signal* signal)
   ptrCheckGuard(logPartPtr, clogPartFileSize, logPartRecord);
   logFilePtr.p->currentMbyte = 0;
   logFilePtr.p->filePosition = 0;
-  logFilePtr.p->logFilePagesToDiskWithoutSynch = 0;
 }//Dblqh::initFsopenconf()
 
 /* ========================================================================= */
@@ -13062,14 +13061,16 @@ void Dblqh::initLogpage(Signal* signal)
 /* ------------------------------------------------------------------------- */
 void Dblqh::openFileRw(Signal* signal, LogFileRecordPtr olfLogFilePtr) 
 {
+  FsOpenReq* req = (FsOpenReq*)signal->getDataPtrSend();
   signal->theData[0] = cownref;
   signal->theData[1] = olfLogFilePtr.i;
   signal->theData[2] = olfLogFilePtr.p->fileName[0];
   signal->theData[3] = olfLogFilePtr.p->fileName[1];
   signal->theData[4] = olfLogFilePtr.p->fileName[2];
   signal->theData[5] = olfLogFilePtr.p->fileName[3];
-  signal->theData[6] = ZOPEN_READ_WRITE;
-  sendSignal(NDBFS_REF, GSN_FSOPENREQ, signal, 7, JBA);
+  signal->theData[6] = ZOPEN_READ_WRITE | FsOpenReq::OM_AUTOSYNC;
+  req->auto_sync_size = MAX_REDO_PAGES_WITHOUT_SYNCH * sizeof(LogPageRecord);
+  sendSignal(NDBFS_REF, GSN_FSOPENREQ, signal, FsOpenReq::SignalLength, JBA);
 }//Dblqh::openFileRw()
 
 /* ------------------------------------------------------------------------- */
@@ -13080,14 +13081,16 @@ void Dblqh::openFileRw(Signal* signal, LogFileRecordPtr olfLogFilePtr)
 void Dblqh::openLogfileInit(Signal* signal) 
 {
   logFilePtr.p->logFileStatus = LogFileRecord::OPENING_INIT;
+  FsOpenReq* req = (FsOpenReq*)signal->getDataPtrSend();
   signal->theData[0] = cownref;
   signal->theData[1] = logFilePtr.i;
   signal->theData[2] = logFilePtr.p->fileName[0];
   signal->theData[3] = logFilePtr.p->fileName[1];
   signal->theData[4] = logFilePtr.p->fileName[2];
   signal->theData[5] = logFilePtr.p->fileName[3];
-  signal->theData[6] = 0x302;
-  sendSignal(NDBFS_REF, GSN_FSOPENREQ, signal, 7, JBA);
+  signal->theData[6] = 0x302 | FsOpenReq::OM_AUTOSYNC;
+  req->auto_sync_size = MAX_REDO_PAGES_WITHOUT_SYNCH * sizeof(LogPageRecord);
+  sendSignal(NDBFS_REF, GSN_FSOPENREQ, signal, FsOpenReq::SignalLength, JBA);
 }//Dblqh::openLogfileInit()
 
 /* OPEN FOR READ/WRITE, DO CREATE AND DO TRUNCATE FILE */
@@ -13114,14 +13117,16 @@ void Dblqh::openNextLogfile(Signal* signal)
       return;
     }//if
     onlLogFilePtr.p->logFileStatus = LogFileRecord::OPENING_WRITE_LOG;
+    FsOpenReq* req = (FsOpenReq*)signal->getDataPtrSend();
     signal->theData[0] = cownref;
     signal->theData[1] = onlLogFilePtr.i;
     signal->theData[2] = onlLogFilePtr.p->fileName[0];
     signal->theData[3] = onlLogFilePtr.p->fileName[1];
     signal->theData[4] = onlLogFilePtr.p->fileName[2];
     signal->theData[5] = onlLogFilePtr.p->fileName[3];
-    signal->theData[6] = 2;
-    sendSignal(NDBFS_REF, GSN_FSOPENREQ, signal, 7, JBA);
+    signal->theData[6] = 2 | FsOpenReq::OM_AUTOSYNC;
+    req->auto_sync_size = MAX_REDO_PAGES_WITHOUT_SYNCH * sizeof(LogPageRecord);
+    sendSignal(NDBFS_REF, GSN_FSOPENREQ, signal, FsOpenReq::SignalLength, JBA);
   }//if
 }//Dblqh::openNextLogfile()
 
@@ -16138,15 +16143,8 @@ void Dblqh::completedLogPage(Signal* signal, Uint32 clpType, Uint32 place)
   signal->theData[0] = logFilePtr.p->fileRef;
   signal->theData[1] = cownref;
   signal->theData[2] = lfoPtr.i;
-  logFilePtr.p->logFilePagesToDiskWithoutSynch += twlpNoPages;
   if (twlpType == ZLAST_WRITE_IN_FILE) {
     jam();
-    logFilePtr.p->logFilePagesToDiskWithoutSynch = 0;
-    signal->theData[3] = ZLIST_OF_MEM_PAGES_SYNCH;
-  } else if (logFilePtr.p->logFilePagesToDiskWithoutSynch >
-             MAX_REDO_PAGES_WITHOUT_SYNCH) {
-    jam();
-    logFilePtr.p->logFilePagesToDiskWithoutSynch = 0;
     signal->theData[3] = ZLIST_OF_MEM_PAGES_SYNCH;
   } else {
     jam();
diff --git a/storage/ndb/src/kernel/vm/pc.hpp b/storage/ndb/src/kernel/vm/pc.hpp
index 6b9b563aa27..37684fa4ca6 100644
--- a/storage/ndb/src/kernel/vm/pc.hpp
+++ b/storage/ndb/src/kernel/vm/pc.hpp
@@ -163,17 +163,10 @@
 #define NO_OF_FRAGS_PER_CHUNK 4
 #define LOG_NO_OF_FRAGS_PER_CHUNK 2
 
-/**
-* Page Header Size for pages
-*/
-#define ZPAGE_HEADER_SIZE 32
-#define ZPAGE_FRAG_PAGE_ID_POS 4 /* POSITION OF FRAG PAGE ID WHEN USED*/
-
 /* ---------------------------------------------------------------- */
 // To avoid synching too big chunks at a time we synch after writing
 // a certain number of data/UNDO pages. (e.g. 2 MBytes).
 /* ---------------------------------------------------------------- */
-#define MAX_PAGES_WITHOUT_SYNCH 64
 #define MAX_REDO_PAGES_WITHOUT_SYNCH 32
 
 /* ------------------------------------------------------------------ */

