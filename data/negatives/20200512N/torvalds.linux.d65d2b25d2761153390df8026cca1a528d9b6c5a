commit d65d2b25d2761153390df8026cca1a528d9b6c5a
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Tue Apr 21 22:33:00 2015 +0100

    staging: vt6655: vnt_tx_packet Correct TX order of OWNED_BY_NIC
    
    The state of m_td0TD0.f1Owner should change after the buff_addr
    has been filled otherwise the device grabs the buffer too early.
    
    m_td0TD0.f1Owner is protected by memory barriers on both sides
    of change.
    
    iTDUsed is best incremented after MACvTransmit.
    
    It appears that f1Owner actually polls to do the memory transfer.
    
    A back port patch will be needed for v3.19
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Cc: <stable@vger.kernel.org> # v4.0+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c
index c81776363d8e..930bbbebc102 100644
--- a/drivers/staging/vt6655/device_main.c
+++ b/drivers/staging/vt6655/device_main.c
@@ -1206,14 +1206,6 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 	if (dma_idx == TYPE_AC0DMA)
 		head_td->pTDInfo->byFlags = TD_FLAGS_NETIF_SKB;
 
-	priv->iTDUsed[dma_idx]++;
-
-	/* Take ownership */
-	wmb();
-	head_td->m_td0TD0.f1Owner = OWNED_BY_NIC;
-
-	/* get Next */
-	wmb();
 	priv->apCurrTD[dma_idx] = head_td->next;
 
 	spin_unlock_irqrestore(&priv->lock, flags);
@@ -1234,11 +1226,18 @@ static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)
 
 	head_td->buff_addr = cpu_to_le32(head_td->pTDInfo->skb_dma);
 
+	/* Poll Transmit the adapter */
+	wmb();
+	head_td->m_td0TD0.f1Owner = OWNED_BY_NIC;
+	wmb(); /* second memory barrier */
+
 	if (head_td->pTDInfo->byFlags & TD_FLAGS_NETIF_SKB)
 		MACvTransmitAC0(priv->PortOffset);
 	else
 		MACvTransmit0(priv->PortOffset);
 
+	priv->iTDUsed[dma_idx]++;
+
 	spin_unlock_irqrestore(&priv->lock, flags);
 
 	return 0;

