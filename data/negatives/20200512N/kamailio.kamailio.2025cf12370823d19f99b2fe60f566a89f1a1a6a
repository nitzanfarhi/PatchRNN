commit 2025cf12370823d19f99b2fe60f566a89f1a1a6a
Author: Miklos Tirpak <miklos@iptel.org>
Date:   Fri Oct 19 16:58:37 2007 +0000

    ipmatch() and allow_trusted() functions are tested and the found bugs
    are corrected regarding the DB-API update.

diff --git a/modules_s/permissions/im_db.c b/modules_s/permissions/im_db.c
index 13c8c7e7c..124cb7209 100644
--- a/modules_s/permissions/im_db.c
+++ b/modules_s/permissions/im_db.c
@@ -38,8 +38,8 @@ static db_cmd_t	*cmd_load_im = NULL;
 int init_im_db(void)
 {
 	db_fld_t load_res_cols[] = {
-		{.name = "ip",		.type = DB_STR},
-		{.name = "avp_val",	.type = DB_STR},
+		{.name = "ip",		.type = DB_CSTR},
+		{.name = "avp_val",	.type = DB_CSTR},
 		{.name = "mark",	.type = DB_BITMAP},
 		{.name = "flags",	.type = DB_BITMAP},
 		{.name = NULL}
@@ -119,9 +119,9 @@ static int load_db(im_entry_t **hash)
 			avp_val = NULL;
 
 		if (rec->fld[2].flags & DB_NULL)
-			mark = rec->fld[2].v.bitmap;	/* get mark */
-		else
 			mark = (unsigned int)-1;	/* will match eveything */
+		else
+			mark = rec->fld[2].v.bitmap;	/* get mark */
 
 		/* create a new entry and insert it into the hash table */
 		if (insert_im_hash(ip, avp_val, mark, hash)) {
@@ -156,6 +156,13 @@ int reload_im_cache(void)
 	im_entry_t	**hash, **old_hash;
 	int	ret;
 
+
+	if (!IM_HASH) {
+		LOG(L_CRIT, "ERROR: reload_im_cache(): ipmatch hash table is not initialied. "
+			"Have you set the database url?\n");
+		return -1;
+	}
+
 	/* make sure that there is no other writer process */
 	writer_lock_imhash();
 
diff --git a/modules_s/permissions/ipmatch.c b/modules_s/permissions/ipmatch.c
index 4adad3e7d..bd29e7b32 100644
--- a/modules_s/permissions/ipmatch.c
+++ b/modules_s/permissions/ipmatch.c
@@ -80,6 +80,12 @@ static int ipmatch(struct ip_addr *ip, unsigned short port,
 
 	ret = 0;
 
+	if (!IM_HASH) {
+		LOG(L_CRIT, "ERROR: ipmatch(): ipmatch hash table is not initialied. "
+			"Have you set the database url?\n");
+		return 0;
+	}
+
 	/* lock hash table for reading */
 	reader_lock_imhash();
 
diff --git a/modules_s/permissions/trusted.c b/modules_s/permissions/trusted.c
index 3e781e1c8..49f2da664 100644
--- a/modules_s/permissions/trusted.c
+++ b/modules_s/permissions/trusted.c
@@ -108,20 +108,20 @@ void clean_trusted(void)
 int init_trusted_db(void)
 {
 	db_fld_t load_res_cols[] = {
-		{.name = source_col,	.type = DB_STR},
-		{.name = proto_col,	.type = DB_STR},
-		{.name = from_col,	.type = DB_STR},
+		{.name = source_col,	.type = DB_CSTR},
+		{.name = proto_col,	.type = DB_CSTR},
+		{.name = from_col,	.type = DB_CSTR},
 		{.name = NULL}
 	};
 
 	db_fld_t query_match[] = {
-		{.name = source_col,	.type = DB_STR},
+		{.name = source_col,	.type = DB_CSTR},
 		{.name = NULL}
 	};
 
 	db_fld_t query_res_cols[] = {
-		{.name = proto_col,	.type = DB_STR},
-		{.name = from_col,	.type = DB_STR},
+		{.name = proto_col,	.type = DB_CSTR},
+		{.name = from_col,	.type = DB_CSTR},
 		{.name = NULL}
 	};
 
@@ -211,7 +211,7 @@ static inline int match_proto(char *proto_string, int proto_int)
 
 /*
  * Matches from uri against patterns returned from database.  Returns 1 when
- * first pattern matches and 0 if none of the patterns match.
+ * first pattern matches and -1 if none of the patterns match.
  */
 static int match_res(struct sip_msg* msg, db_res_t* _r)
 {
@@ -239,7 +239,7 @@ static int match_res(struct sip_msg* msg, db_res_t* _r)
 			goto next;
 
 		/* check the protocol */
-		if (!match_proto(rec->fld[0].v.cstr, msg->rcv.proto))
+		if (match_proto(rec->fld[0].v.cstr, msg->rcv.proto) <= 0)
 			goto next;
 
 		/* check the from uri */

