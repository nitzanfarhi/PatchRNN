commit 457291482525a7b0ae80ed0e602723581925a027
Author: Satya B <satya.bn@sun.com>
Date:   Mon Nov 30 17:34:09 2009 +0530

    Applying InnoDB Plugin 1.0.6 snapshot, part 4. Fixes BUG#3139
    
    applied revisions: r6160
    
    Detailed revision comments:
    
    r6160 | vasil | 2009-11-11 15:33:49 +0200 (Wed, 11 Nov 2009) | 72 lines
    branches/zip: Merge r6152:6159 from branches/5.1:
    
    (r6158 was skipped as an equivallent change has already been merged from MySQL)
    
      ------------------------------------------------------------------------
      r6154 | calvin | 2009-11-11 02:51:17 +0200 (Wed, 11 Nov 2009) | 17 lines
      Changed paths:
         M /branches/5.1/include/os0file.h
         M /branches/5.1/os/os0file.c
    
      branches/5.1: fix bug#3139: Mysql crashes: 'windows error 995'
      after several selects on a large DB
    
      During stress environment, Windows AIO may fail with error code
      ERROR_OPERATION_ABORTED. InnoDB does not handle the error, rather
      crashes. The cause of the error is unknown, but likely due to
      faulty hardware or driver.
    
      This patch introduces a new error code OS_FILE_OPERATION_ABORTED,
      which maps to Windows ERROR_OPERATION_ABORTED (995). When the error
      is detected during AIO, the InnoDB will issue a synchronous retry
      (read/write).
    
      This patch has been extensively tested by MySQL support.
    
      Approved by: Marko
      rb://196
      ------------------------------------------------------------------------
      r6158 | vasil | 2009-11-11 14:52:14 +0200 (Wed, 11 Nov 2009) | 37 lines
      Changed paths:
         M /branches/5.1/handler/ha_innodb.cc
         M /branches/5.1/handler/ha_innodb.h
    
      branches/5.1:
    
      Merge a change from MySQL:
      (this has been reviewed by Calvin and Marko, and Calvin says Luis has
      incorporated Marko's suggestions)
    
        ------------------------------------------------------------
        revno: 3092.5.1
        committer: Luis Soares <luis.soares@sun.com>
        branch nick: mysql-5.1-bugteam
        timestamp: Thu 2009-09-24 15:52:52 +0100
        message:
          BUG#42829: binlogging enabled for all schemas regardless of
          binlog-db-db / binlog-ignore-db
    
          InnoDB will return an error if statement based replication is used
          along with transaction isolation level READ-COMMITTED (or weaker),
          even if the statement in question is filtered out according to the
          binlog-do-db rules set. In this case, an error should not be printed.
    
          This patch addresses this issue by extending the existing check in
          external_lock to take into account the filter rules before deciding to
          print an error. Furthermore, it also changes decide_logging_format to
          take into consideration whether the statement is filtered out from
          binlog before decision is made.
        added:
          mysql-test/suite/binlog/r/binlog_stm_do_db.result
          mysql-test/suite/binlog/t/binlog_stm_do_db-master.opt
          mysql-test/suite/binlog/t/binlog_stm_do_db.test
        modified:
          sql/sql_base.cc
          sql/sql_class.cc
          storage/innobase/handler/ha_innodb.cc
          storage/innobase/handler/ha_innodb.h
          storage/innodb_plugin/handler/ha_innodb.cc
          storage/innodb_plugin/handler/ha_innodb.h
    
      ------------------------------------------------------------------------

diff --git a/storage/innodb_plugin/include/os0file.h b/storage/innodb_plugin/include/os0file.h
index c06b28187d7..16568579f31 100644
--- a/storage/innodb_plugin/include/os0file.h
+++ b/storage/innodb_plugin/include/os0file.h
@@ -158,6 +158,7 @@ log. */
 #define	OS_FILE_SHARING_VIOLATION	76
 #define	OS_FILE_ERROR_NOT_SPECIFIED	77
 #define	OS_FILE_INSUFFICIENT_RESOURCE	78
+#define	OS_FILE_OPERATION_ABORTED	79
 /* @} */
 
 /** Types for aio operations @{ */
diff --git a/storage/innodb_plugin/os/os0file.c b/storage/innodb_plugin/os/os0file.c
index a3d0b0a10d0..37edad442db 100644
--- a/storage/innodb_plugin/os/os0file.c
+++ b/storage/innodb_plugin/os/os0file.c
@@ -323,6 +323,13 @@ os_file_get_last_error(
 				"InnoDB: The error means that there are no"
 				" sufficient system resources or quota to"
 				" complete the operation.\n");
+		} else if (err == ERROR_OPERATION_ABORTED) {
+			fprintf(stderr,
+				"InnoDB: The error means that the I/O"
+				" operation has been aborted\n"
+				"InnoDB: because of either a thread exit"
+				" or an application request.\n"
+				"InnoDB: Retry attempt is made.\n");
 		} else {
 			fprintf(stderr,
 				"InnoDB: Some operating system error numbers"
@@ -347,6 +354,8 @@ os_file_get_last_error(
 	} else if (err == ERROR_WORKING_SET_QUOTA
 		   || err == ERROR_NO_SYSTEM_RESOURCES) {
 		return(OS_FILE_INSUFFICIENT_RESOURCE);
+	} else if (err == ERROR_OPERATION_ABORTED) {
+		return(OS_FILE_OPERATION_ABORTED);
 	} else {
 		return(100 + err);
 	}
@@ -467,6 +476,10 @@ os_file_handle_error_cond_exit(
 		return(TRUE);
 	} else if (err == OS_FILE_INSUFFICIENT_RESOURCE) {
 
+		os_thread_sleep(100000);	/* 100 ms */
+		return(TRUE);
+	} else if (err == OS_FILE_OPERATION_ABORTED) {
+
 		os_thread_sleep(100000);	/* 100 ms */
 		return(TRUE);
 	} else {
@@ -3766,6 +3779,7 @@ os_aio_windows_handle(
 	ibool		ret_val;
 	BOOL		ret;
 	DWORD		len;
+	BOOL		retry		= FALSE;
 
 	if (segment == ULINT_UNDEFINED) {
 		array = os_aio_sync_array;
@@ -3819,14 +3833,52 @@ os_aio_windows_handle(
 			ut_a(TRUE == os_file_flush(slot->file));
 		}
 #endif /* UNIV_DO_FLUSH */
+	} else if (os_file_handle_error(slot->name, "Windows aio")) {
+
+		retry = TRUE;
 	} else {
-		os_file_handle_error(slot->name, "Windows aio");
 
 		ret_val = FALSE;
 	}
 
 	os_mutex_exit(array->mutex);
 
+	if (retry) {
+		/* retry failed read/write operation synchronously.
+		No need to hold array->mutex. */
+
+		switch (slot->type) {
+		case OS_FILE_WRITE:
+			ret = WriteFile(slot->file, slot->buf,
+					slot->len, &len,
+					&(slot->control));
+
+			break;
+		case OS_FILE_READ:
+			ret = ReadFile(slot->file, slot->buf,
+				       slot->len, &len,
+				       &(slot->control));
+
+			break;
+		default:
+			ut_error;
+		}
+
+		if (!ret && GetLastError() == ERROR_IO_PENDING) {
+			/* aio was queued successfully!
+			We want a synchronous i/o operation on a
+			file where we also use async i/o: in Windows
+			we must use the same wait mechanism as for
+			async i/o */
+
+			ret = GetOverlappedResult(slot->file,
+						  &(slot->control),
+						  &len, TRUE);
+		}
+
+		ret_val = ret && len == slot->len;
+	}
+
 	os_aio_array_free_slot(array, slot);
 
 	return(ret_val);

