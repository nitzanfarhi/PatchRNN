commit 4e0e87f538ce02b7716ffe91e020442df0f4f19f
Author: thib <thib@openbsd.org>
Date:   Thu Jul 8 08:15:18 2010 +0000

    better op buf handling. Instead of mallocing a new buffer for every
    encdec operation, keep a PAGE_SIZE (or not, depending if we fail during
    setup) buf around; if the crd_len is larger then the current buf, re allocate
    a new one that fits the data, and keep it around.

diff --git a/sys/arch/amd64/amd64/aesni.c b/sys/arch/amd64/amd64/aesni.c
index 821ea320f69..fa74f041c76 100644
--- a/sys/arch/amd64/amd64/aesni.c
+++ b/sys/arch/amd64/amd64/aesni.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: aesni.c,v 1.6 2010/07/05 16:53:08 thib Exp $	*/
+/*	$OpenBSD: aesni.c,v 1.7 2010/07/08 08:15:18 thib Exp $	*/
 /*-
  * Copyright (c) 2003 Jason Wright
  * Copyright (c) 2003, 2004 Theo de Raadt
@@ -54,7 +54,8 @@ struct aesni_sess {
 };
 
 struct aesni_softc {
-	uint8_t			 op_buf[16384];
+	uint8_t			*sc_buf;
+	size_t			 sc_buflen;
 	int32_t			 sc_cid;
 	LIST_HEAD(, aesni_sess)	 sc_sessions;
 } *aesni_sc;
@@ -98,6 +99,10 @@ aesni_setup(void)
 	if (aesni_sc == NULL)
 		return;
 
+	aesni_sc->sc_buf = malloc(PAGE_SIZE, M_DEVBUF, M_NOWAIT|M_ZERO);
+	if (aesni_sc->sc_buf != NULL)
+		aesni_sc->sc_buflen = PAGE_SIZE;
+
 	bzero(algs, sizeof(algs));
 	algs[CRYPTO_AES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
 	algs[CRYPTO_AES_CTR] = CRYPTO_ALG_FLAG_SUPPORTED;
@@ -297,7 +302,7 @@ aesni_swauth(struct cryptop *crp, struct cryptodesc *crd,
 	if (crp->crp_flags & CRYPTO_F_IMBUF)
 		type = CRYPTO_BUF_MBUF;
 	else
-		type= CRYPTO_BUF_IOV;
+		type = CRYPTO_BUF_IOV;
 
 	return (swcr_authcompute(crp, crd, sw, buf, type));
 }
@@ -307,7 +312,7 @@ aesni_encdec(struct cryptop *crp, struct cryptodesc *crd,
     struct aesni_sess *ses)
 {
 	uint8_t iv[EALG_MAX_BLOCK_LEN];
-	uint8_t *buf = &aesni_sc->op_buf[0];
+	uint8_t *buf = aesni_sc->sc_buf;
 	int ivlen = 0;
 	int err = 0;
 
@@ -316,18 +321,19 @@ aesni_encdec(struct cryptop *crp, struct cryptodesc *crd,
 		return (err);
 	}
 
-	if (crd->crd_len > sizeof (aesni_sc->op_buf)) {
-		printf("aesni: crd->crd_len > sizeof (aesni_sc->op_buf)\n");
-		return (EINVAL);
-	}
+	if (crd->crd_len > aesni_sc->sc_buflen) {
+		if (buf != NULL) {
+			bzero(buf, aesni_sc->sc_buflen);
+			free(buf, M_DEVBUF);
+		}
 
-	/*
-	buf = malloc(crd->crd_len, M_DEVBUF, M_NOWAIT);
-	if (buf == NULL) {
-		err = ENOMEM;
-		return (err);
+		aesni_sc->sc_buflen = 0;
+		aesni_sc->sc_buf = buf = malloc(crd->crd_len, M_DEVBUF,
+		    M_NOWAIT|M_ZERO);
+		if (buf == NULL)
+			return (ENOMEM);
+		aesni_sc->sc_buflen = crd->crd_len;
 	}
-	*/
 
 	/* CBC uses 16, CTR only 8 */
 	ivlen = (crd->crd_alg == CRYPTO_AES_CBC) ? 16 : 8;
@@ -420,13 +426,6 @@ aesni_encdec(struct cryptop *crp, struct cryptodesc *crd,
 			    crd->crd_len - ivlen, ses->ses_iv, ivlen);
 	}
 
-	/*
-	if (buf != NULL) {
-		bzero(buf, crd->crd_len);
-		free(buf, M_DEVBUF);
-	}
-	*/
-
 out:
 	bzero(buf, crd->crd_len);
 	return (err);

