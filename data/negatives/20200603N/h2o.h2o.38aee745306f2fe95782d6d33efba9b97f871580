commit 38aee745306f2fe95782d6d33efba9b97f871580
Author: Kazuho Oku <kazuhooku@gmail.com>
Date:   Thu Oct 16 16:46:20 2014 +0900

    implement connect(2) wrapper

diff --git a/include/h2o.h b/include/h2o.h
index 4e1b07c8..fd635e0d 100644
--- a/include/h2o.h
+++ b/include/h2o.h
@@ -676,6 +676,10 @@ static void h2o_linklist_unlink(h2o_linklist_t *node);
  * closes the socket
  */
 void h2o_socket_close(h2o_socket_t *sock);
+/**
+ * connects to peer
+ */
+h2o_socket_t *h2o_socket_connect(h2o_loop_t *loop, struct sockaddr *addr, socklen_t addrlen, h2o_socket_cb cb);
 /**
  * writes given data to socket
  * @param sock the socket
diff --git a/include/h2o/evloop.h b/include/h2o/evloop.h
index 5ddfdb52..237a01ea 100644
--- a/include/h2o/evloop.h
+++ b/include/h2o/evloop.h
@@ -28,6 +28,7 @@
 #define H2O_SOCKET_FLAG_IS_POLLED_FOR_READ 0x8
 #define H2O_SOCKET_FLAG_IS_POLLED_FOR_WRITE 0x10
 #define H2O_SOCKET_FLAG_IS_ACCEPT 0x20
+#define H2O_SOCKET_FLAG_IS_CONNECTING 0x40
 #define H2O_SOCKET_FLAG__EPOLL_IS_REGISTERED 0x1000
 
 typedef struct st_h2o_evloop_t h2o_evloop_t;
diff --git a/lib/socket.c b/lib/socket.c
index 2f7e7896..b66b9c3e 100644
--- a/lib/socket.c
+++ b/lib/socket.c
@@ -154,7 +154,7 @@ int decode_ssl_input(h2o_socket_t *sock)
         int rlen = SSL_read(sock->ssl->ssl, buf.base, (int)buf.len);
         if (rlen == -1) {
             if (SSL_get_error(sock->ssl->ssl, rlen) != SSL_ERROR_WANT_READ) {
-                return -1;
+                return EIO;
             }
             break;
         } else if (rlen == 0) {
diff --git a/lib/socket/evloop.c.h b/lib/socket/evloop.c.h
index 24d11045..9b57c019 100644
--- a/lib/socket/evloop.c.h
+++ b/lib/socket/evloop.c.h
@@ -177,21 +177,32 @@ static int write_core(int fd, h2o_buf_t **bufs, size_t *bufcnt)
 void write_pending(struct st_h2o_evloop_socket_t *sock)
 {
     assert(sock->super._cb.write != NULL);
+
+    if ((sock->_flags & H2O_SOCKET_FLAG_IS_CONNECTING) != 0) {
+        /* connection complete */
+        assert(sock->_wreq.cnt == 0);
+        goto Complete;
+    }
+
     assert(sock->_wreq.cnt != 0);
 
     /* write */
-    if (write_core(sock->fd, &sock->_wreq.bufs, &sock->_wreq.cnt) != 0
-        || sock->_wreq.cnt == 0) {
-        /* either completed or failed */
-        wreq_free_buffer_if_allocated(sock);
-        if (sock->_wreq.cnt != 0) {
-            /* pending data exists -> was an error */
-            sock->_wreq.cnt = 0; /* clear it ! */
-            sock->_flags |= H2O_SOCKET_FLAG_IS_WRITE_ERROR;
-        }
-        link_to_pending(sock);
-        link_to_statechanged(sock); /* might need to disable the write polling */
+    if (write_core(sock->fd, &sock->_wreq.bufs, &sock->_wreq.cnt) == 0 && sock->_wreq.cnt != 0) {
+        /* partial write */
+        return;
     }
+
+    /* either completed or failed */
+    wreq_free_buffer_if_allocated(sock);
+    if (sock->_wreq.cnt != 0) {
+        /* pending data exists -> was an error */
+        sock->_wreq.cnt = 0; /* clear it ! */
+        sock->_flags |= H2O_SOCKET_FLAG_IS_WRITE_ERROR;
+    }
+
+Complete:
+    link_to_pending(sock);
+    link_to_statechanged(sock); /* might need to disable the write polling */
 }
 
 static void read_on_ready(struct st_h2o_evloop_socket_t *sock)
@@ -317,6 +328,24 @@ h2o_socket_t *h2o_evloop_socket_accept(h2o_socket_t *_listener)
     return sock;
 }
 
+h2o_socket_t *h2o_socket_connect(h2o_loop_t *loop, struct sockaddr *addr, socklen_t addrlen, h2o_socket_cb cb)
+{
+    int fd;
+    struct st_h2o_evloop_socket_t *sock;
+
+    if ((fd = socket(addr->sa_family, SOCK_STREAM, IPPROTO_TCP)) == -1)
+        return NULL;
+    if (! (connect(fd, addr, addrlen) == 0 || errno == EINPROGRESS)) {
+        close(fd);
+        return NULL;
+    }
+
+    sock = (void*)h2o_evloop_socket_create(loop, fd, addr, addrlen, H2O_SOCKET_FLAG_IS_CONNECTING);
+    sock->super._cb.write = cb;
+    link_to_statechanged(sock);
+    return &sock->super;
+}
+
 h2o_evloop_t *create_evloop(size_t sz)
 {
     h2o_evloop_t *loop = h2o_malloc(sz);
@@ -360,7 +389,15 @@ static void run_socket(struct st_h2o_evloop_socket_t* sock)
     }
 
     if (sock->super._cb.write != NULL && sock->_wreq.cnt == 0) {
-        on_write_complete(&sock->super, (sock->_flags & H2O_SOCKET_FLAG_IS_WRITE_ERROR) != 0 ? -1 : 0);
+        int status;
+        if ((sock->_flags & H2O_SOCKET_FLAG_IS_CONNECTING) != 0) {
+            socklen_t l = sizeof(status);
+            getsockopt(sock->fd, SOL_SOCKET, SO_ERROR, &status, &l);
+            sock->_flags &= ~H2O_SOCKET_FLAG_IS_CONNECTING;
+        } else {
+            status = (sock->_flags & H2O_SOCKET_FLAG_IS_WRITE_ERROR) != 0 ? -1 : 0;
+        }
+        on_write_complete(&sock->super, status);
     }
 
     if ((sock->_flags & H2O_SOCKET_FLAG_IS_READ_READY) != 0) {
diff --git a/lib/socket/evloop/epoll.c.h b/lib/socket/evloop/epoll.c.h
index 1e7fc8b6..c9f91561 100644
--- a/lib/socket/evloop/epoll.c.h
+++ b/lib/socket/evloop/epoll.c.h
@@ -61,7 +61,7 @@ static int update_status(struct st_h2o_evloop_epoll_t *loop)
                     changed = 1;
                 }
             }
-            if (h2o_socket_is_writing(&sock->super) && sock->_wreq.cnt != 0) {
+            if (h2o_socket_is_writing(&sock->super) && (sock->_wreq.cnt != 0 || (sock->_flags & H2O_SOCKET_FLAG_IS_CONNECTING) != 0)) {
                 ev.events |= EPOLLOUT;
                 if ((sock->_flags & H2O_SOCKET_FLAG_IS_POLLED_FOR_WRITE) == 0) {
                     sock->_flags |= H2O_SOCKET_FLAG_IS_POLLED_FOR_WRITE;
diff --git a/lib/socket/evloop/kqueue.c.h b/lib/socket/evloop/kqueue.c.h
index b9994989..dfe4a233 100644
--- a/lib/socket/evloop/kqueue.c.h
+++ b/lib/socket/evloop/kqueue.c.h
@@ -72,7 +72,7 @@ static int collect_status(struct st_h2o_socket_loop_kqueue_t *loop, struct keven
                     SET_AND_UPDATE(EVFILT_READ, EV_DELETE);
                 }
             }
-            if (h2o_socket_is_writing(&sock->super) && sock->_wreq.cnt != 0) {
+            if (h2o_socket_is_writing(&sock->super) && (sock->_wreq.cnt != 0 || (sock->_flags & H2O_SOCKET_FLAG_IS_CONNECTING) != 0)) {
                 if ((sock->_flags & H2O_SOCKET_FLAG_IS_POLLED_FOR_WRITE) == 0) {
                     sock->_flags |= H2O_SOCKET_FLAG_IS_POLLED_FOR_WRITE;
                     SET_AND_UPDATE(EVFILT_WRITE, EV_ADD);
diff --git a/lib/socket/evloop/select.c.h b/lib/socket/evloop/select.c.h
index 913f1661..da1fee01 100644
--- a/lib/socket/evloop/select.c.h
+++ b/lib/socket/evloop/select.c.h
@@ -62,7 +62,7 @@ static void update_fdset(struct st_h2o_evloop_select_t *loop)
                 FD_CLR(sock->fd, &loop->readfds);
                 sock->_flags &= ~H2O_SOCKET_FLAG_IS_POLLED_FOR_READ;
             }
-            if (h2o_socket_is_writing(&sock->super) && sock->_wreq.cnt != 0) {
+            if (h2o_socket_is_writing(&sock->super) && (sock->_wreq.cnt != 0 || (sock->_flags & H2O_SOCKET_FLAG_IS_CONNECTING) != 0)) {
                 DEBUG_LOG("setting WRITE for fd: %d\n", sock->fd);
                 FD_SET(sock->fd, &loop->writefds);
                 sock->_flags |= H2O_SOCKET_FLAG_IS_POLLED_FOR_WRITE;

