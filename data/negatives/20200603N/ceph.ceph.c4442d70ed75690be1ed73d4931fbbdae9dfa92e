commit c4442d70ed75690be1ed73d4931fbbdae9dfa92e
Author: Samuel Just <sam.just@inktank.com>
Date:   Thu Oct 24 18:52:59 2013 -0700

    ReplicatedPG: reset new_obs and new_snapset in execute_ctx
    
    This way, if execute_ctx is rerun on the same OpContext, we
    won't erroneously reuse a stale snapset/object_info.
    
    Signed-off-by: Samuel Just <sam.just@inktank.com>

diff --git a/src/osd/ReplicatedPG.cc b/src/osd/ReplicatedPG.cc
index 450b377288..fc9ce53d27 100644
--- a/src/osd/ReplicatedPG.cc
+++ b/src/osd/ReplicatedPG.cc
@@ -1203,6 +1203,7 @@ void ReplicatedPG::do_cache_redirect(OpRequestRef op, ObjectContextRef obc)
 void ReplicatedPG::execute_ctx(OpContext *ctx)
 {
   dout(10) << __func__ << " " << ctx << dendl;
+  ctx->reset_obs(ctx->obc);
   OpRequestRef op = ctx->op;
   MOSDOp *m = static_cast<MOSDOp*>(op->get_req());
   ObjectContextRef obc = ctx->obc;
diff --git a/src/osd/ReplicatedPG.h b/src/osd/ReplicatedPG.h
index f36138079a..e897925f09 100644
--- a/src/osd/ReplicatedPG.h
+++ b/src/osd/ReplicatedPG.h
@@ -403,6 +403,13 @@ public:
 	snapset = &_ssc->snapset;
       }
     }
+    void reset_obs(ObjectContextRef obc) {
+      new_obs = ObjectState(obc->obs.oi, obc->obs.exists);
+      if (obc->ssc) {
+	new_snapset = obc->ssc->snapset;
+	snapset = &obc->ssc->snapset;
+      }
+    }
     ~OpContext() {
       assert(!clone_obc);
       assert(lock_to_release == NONE);

