commit a608483b137f997e3d8832cbfcf1a6ff378c8480
Author: Romain Bouqueau <romain.bouqueau.pro@gmail.com>
Date:   Tue Apr 14 23:31:43 2015 +0200

    cpp warnings for modules

diff --git a/modules/dx_hw/copy_pixels.c b/modules/dx_hw/copy_pixels.c
index 1de3da0d2..7bc5fd151 100644
--- a/modules/dx_hw/copy_pixels.c
+++ b/modules/dx_hw/copy_pixels.c
@@ -66,7 +66,7 @@ static Bool format_is_yuv(u32 in_pf)
 	case GF_PIXEL_YV12:
 	case GF_PIXEL_IYUV:
 	case GF_PIXEL_I420:
-		return 1;
+		return GF_TRUE;
 	/*not supported yet*/
 	case GF_PIXEL_YUVA:
 	default:
@@ -80,7 +80,7 @@ static Bool is_planar_yuv(u32 pf)
 	case GF_PIXEL_YV12:
 	case GF_PIXEL_I420:
 	case GF_PIXEL_IYUV:
-		return 1;
+		return GF_TRUE;
 	}
 	return GF_FALSE;
 }
diff --git a/modules/dx_hw/dx_2d.c b/modules/dx_hw/dx_2d.c
index 9c5ee4cf8..39744305b 100644
--- a/modules/dx_hw/dx_2d.c
+++ b/modules/dx_hw/dx_2d.c
@@ -47,7 +47,7 @@ static Bool pixelformat_yuv(u32 pixel_format)
 	case GF_PIXEL_IYUV:
 	case GF_PIXEL_I420:
 	case GF_PIXEL_YV12_10:
-		return 1;
+		return GF_TRUE;
 	default:
 		return GF_FALSE;
 	}
@@ -130,14 +130,14 @@ GF_Err CreateBackBuffer(GF_VideoOutput *dr, u32 Width, u32 Height, Bool use_syst
 		if (use_system_memory) {
 			if (!strcmp(opt, "Always")) use_system_memory = GF_FALSE;
 		} else {
-			if (!strcmp(opt, "Never")) use_system_memory = 1;
-			else if (!strcmp(opt, "Auto")) dd->force_video_mem_for_yuv = 1;
+			if (!strcmp(opt, "Never")) use_system_memory = GF_TRUE;
+			else if (!strcmp(opt, "Auto")) dd->force_video_mem_for_yuv = GF_TRUE;
 		}
 	}
 
 	force_reinit = GF_FALSE;
-	if (use_system_memory && !dd->systems_memory) force_reinit = 1;
-	else if (!use_system_memory && dd->systems_memory) force_reinit = 1;
+	if (use_system_memory && !dd->systems_memory) force_reinit = GF_TRUE;
+	else if (!use_system_memory && dd->systems_memory) force_reinit = GF_TRUE;
 	if (dd->pBack && !force_reinit&& !dd->fullscreen && (dd->width == Width) && (dd->height == Height) ) {
 		return GF_OK;
 	}
@@ -158,7 +158,7 @@ GF_Err CreateBackBuffer(GF_VideoOutput *dr, u32 Width, u32 Height, Bool use_syst
 			ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
 		} else {
 			ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
-			dd->systems_memory = 1;
+			dd->systems_memory = GF_TRUE;
 		}
 	}
 	if (dd->systems_memory) dr->hw_caps &= ~GF_VIDEO_HW_HAS_RGB;
@@ -445,7 +445,7 @@ static DDSurface *DD_GetSurface(GF_VideoOutput *dr, u32 width, u32 height, u32 p
 
 			SAFE_DD_RELEASE(yuvp->pSurface);
 			memset(yuvp, 0, sizeof(DDSurface));
-			yuvp->is_yuv = 1;
+			yuvp->is_yuv = GF_TRUE;
 
 			memset (&ddsd, 0, sizeof(ddsd));
 			ddsd.dwSize = sizeof(ddsd);
@@ -688,7 +688,7 @@ void DD_InitYUV(GF_VideoOutput *dr)
 			opt = gf_modules_get_option((GF_BaseInterface *)dr, "Video", "HasOverlay");
 			if (opt && !strcmp(opt, "yes"))
 				dr->hw_caps |= GF_VIDEO_HW_HAS_YUV_OVERLAY;
-			dd->yuv_init = 1;
+			dd->yuv_init = GF_TRUE;
 			num_yuv = 1;
 		}
 	}
@@ -696,7 +696,7 @@ void DD_InitYUV(GF_VideoOutput *dr)
 	/*first run on this machine, to some benchmark*/
 	if (! dd->yuv_init) {
 		char szOpt[100];
-		dd->yuv_init = 1;
+		dd->yuv_init = GF_TRUE;
 
 		dr->hw_caps |= GF_VIDEO_HW_HAS_YUV | GF_VIDEO_HW_HAS_YUV_OVERLAY;
 
@@ -728,11 +728,11 @@ void DD_InitYUV(GF_VideoOutput *dr)
 			if (dd->yuv_pool.pSurface) {
 				SAFE_DD_RELEASE(dd->yuv_pool.pSurface);
 				memset(&dd->yuv_pool, 0, sizeof(DDSurface));
-				dd->yuv_pool.is_yuv = 1;
+				dd->yuv_pool.is_yuv = GF_TRUE;
 			}
 
 			dr->yuv_pixel_format = formats[i];
-			if (DD_GetSurface(dr, w, h, dr->yuv_pixel_format, 1) == NULL)
+			if (DD_GetSurface(dr, w, h, dr->yuv_pixel_format, GF_TRUE) == NULL)
 				goto rem_fmt;
 
 			now = gf_sys_clock();
@@ -743,7 +743,7 @@ void DD_InitYUV(GF_VideoOutput *dr)
 			}
 			now = gf_sys_clock() - now;
 			if (formats[i]== GF_PIXEL_YV12)
-				force_yv12=1;
+				force_yv12 = GF_TRUE;
 
 			if (!checkPacked) {
 				if (now<min_planar) {
@@ -775,7 +775,7 @@ rem_fmt:
 		if (dd->yuv_pool.pSurface) {
 			SAFE_DD_RELEASE(dd->yuv_pool.pSurface);
 			memset(&dd->yuv_pool, 0, sizeof(DDSurface));
-			dd->yuv_pool.is_yuv = 1;
+			dd->yuv_pool.is_yuv = GF_TRUE;
 		}
 
 		if (best_planar && (min_planar <= min_packed )) {
@@ -814,7 +814,7 @@ rem_fmt:
 		gf_modules_set_option((GF_BaseInterface *)dr, "Video", "EnableOffscreenYUV", "yes");
 	}
 	if (opt && strcmp(opt, "yes")) dr->hw_caps &= ~GF_VIDEO_HW_HAS_YUV;
-	else dd->offscreen_yuv_to_rgb = 1;
+	else dd->offscreen_yuv_to_rgb = GF_TRUE;
 
 	/*get YUV overlay key*/
 	opt = gf_modules_get_option((GF_BaseInterface *)dr, "Video", "OverlayColorKey");
diff --git a/modules/dx_hw/dx_audio.c b/modules/dx_hw/dx_audio.c
index bd9f3253e..df05a104a 100644
--- a/modules/dx_hw/dx_audio.c
+++ b/modules/dx_hw/dx_audio.c
@@ -85,7 +85,7 @@ static GF_Err DS_Setup(GF_AudioOutput *dr, void *os_handle, u32 num_buffers, u32
 	/*too bad, use desktop as window*/
 	if (!ctx->hWnd) ctx->hWnd = GetDesktopWindow();
 
-	ctx->force_config = (num_buffers && total_duration) ? 1 : GF_FALSE;
+	ctx->force_config = (num_buffers && total_duration) ? GF_TRUE : GF_FALSE;
 	ctx->cfg_num_buffers = num_buffers;
 	ctx->cfg_duration = total_duration;
 	if (ctx->cfg_num_buffers <= 1) ctx->cfg_num_buffers = 2;
@@ -124,7 +124,7 @@ void DS_ReleaseBuffer(GF_AudioOutput *dr)
 	if (ctx->use_notif) {
 		for (i=0; i<ctx->num_audio_buffer; i++) CloseHandle(ctx->events[i]);
 	}
-	ctx->use_notif = 0;
+	ctx->use_notif = GF_FALSE;
 }
 
 static void DS_Shutdown(GF_AudioOutput *dr)
@@ -168,9 +168,9 @@ static GF_Err DS_ConfigureOutput(GF_AudioOutput *dr, u32 *SampleRate, u32 *NbCha
 	/*make sure we're aligned*/
 	while (ctx->buffer_size % ctx->format.nBlockAlign) ctx->buffer_size++;
 
-	ctx->use_notif = 1;
+	ctx->use_notif = GF_TRUE;
 	sOpt = gf_modules_get_option((GF_BaseInterface *)dr, "Audio", "DisableNotification");
-	if (sOpt && !stricmp(sOpt, "yes")) ctx->use_notif = 0;
+	if (sOpt && !stricmp(sOpt, "yes")) ctx->use_notif = GF_FALSE;
 
 	memset(&dsbBufferDesc, 0, sizeof(DSBUFFERDESC));
 	dsbBufferDesc.dwSize = sizeof (DSBUFFERDESC);
@@ -205,7 +205,7 @@ static GF_Err DS_ConfigureOutput(GF_AudioOutput *dr, u32 *SampleRate, u32 *NbCha
 	if (FAILED(hr)) {
 retry:
 		if (ctx->use_notif) gf_modules_set_option((GF_BaseInterface *)dr, "Audio", "DisableNotification", "yes");
-		ctx->use_notif = 0;
+		ctx->use_notif = GF_FALSE;
 		dsbBufferDesc.dwFlags = DSBCAPS_GETCURRENTPOSITION2 | DSBCAPS_GLOBALFOCUS;
 		hr = ctx->pDS->lpVtbl->CreateSoundBuffer(ctx->pDS, &dsbBufferDesc, &ctx->pOutput, NULL );
 		if (FAILED(hr)) {
@@ -242,7 +242,7 @@ retry:
 
 			pNotify->lpVtbl->Release(pNotify);
 		} else {
-			ctx->use_notif = 0;
+			ctx->use_notif = GF_FALSE;
 		}
 	}
 	if (ctx->use_notif) {
@@ -268,9 +268,9 @@ static Bool DS_RestoreBuffer(LPDIRECTSOUNDBUFFER pDSBuffer)
 		GF_LOG(GF_LOG_ERROR, GF_LOG_MMIO, ("[DirectSound] buffer lost\n"));
 		pDSBuffer->lpVtbl->Restore(pDSBuffer);
 		pDSBuffer->lpVtbl->GetStatus(pDSBuffer, &dwStatus);
-		if( dwStatus & DSBSTATUS_BUFFERLOST ) return 1;
+		if( dwStatus & DSBSTATUS_BUFFERLOST ) return GF_TRUE;
 	}
-	return 0;
+	return GF_FALSE;
 }
 
 
diff --git a/modules/dx_hw/dx_video.c b/modules/dx_hw/dx_video.c
index c976d8288..c4e8cad58 100644
--- a/modules/dx_hw/dx_video.c
+++ b/modules/dx_hw/dx_video.c
@@ -173,7 +173,7 @@ void DestroyObjectsEx(DDContext *dd, Bool only_3d)
 		memset(&dd->rgb_pool, 0, sizeof(DDSurface));
 		SAFE_DD_RELEASE(dd->yuv_pool.pSurface);
 		memset(&dd->yuv_pool, 0, sizeof(DDSurface));
-		dd->yuv_pool.is_yuv = 1;
+		dd->yuv_pool.is_yuv = GF_TRUE;
 
 		SAFE_DD_RELEASE(dd->pPrimary);
 		SAFE_DD_RELEASE(dd->pBack);
@@ -314,7 +314,7 @@ GF_Err DD_SetupOpenGL(GF_VideoOutput *dr, u32 offscreen_width, u32 offscreen_hei
 	dd->bound_hwnd = target_hwnd;
 
 	/*cleanup*/
-	DestroyObjectsEx(dd, (dd->output_3d_type==1) ? GF_FALSE : 1);
+	DestroyObjectsEx(dd, (dd->output_3d_type==1) ? GF_FALSE : GF_TRUE);
 
 	//first time we init GL: create a dummy window to select pixel format for high bpp - we must do this because
 	//- we must get a valid GL context to query the extensions for bpp > 8 (regular choosePixelFormat does not work for them)
@@ -370,7 +370,7 @@ GF_Err DD_SetupOpenGL(GF_VideoOutput *dr, u32 offscreen_width, u32 offscreen_hei
 		use_double_buffer = dd->gl_double_buffer;
 	} else {
 		sOpt = gf_modules_get_option((GF_BaseInterface *)dr, "Video", "UseGLDoubleBuffering");
-		if (!sOpt || !strcmp(sOpt, "yes")) use_double_buffer = 1;
+		if (!sOpt || !strcmp(sOpt, "yes")) use_double_buffer = GF_TRUE;
 	}
 
 	sOpt = gf_modules_get_option((GF_BaseInterface *)dr, "Video", "GLNbBitsDepth");
@@ -457,7 +457,7 @@ GF_Err DD_SetupOpenGL(GF_VideoOutput *dr, u32 offscreen_width, u32 offscreen_hei
 	if (!dd->gl_HRC) return GF_IO_ERR;
 
 	if (!dd->glext_init) {
-		dd->glext_init = 1;
+		dd->glext_init = GF_TRUE;
 		wglMakeCurrent(dd->gl_HDC, dd->gl_HRC);
 		dd_init_gl_offscreen(dr);
 	}
@@ -607,7 +607,7 @@ static GF_Err DD_SetFullScreen(GF_VideoOutput *dr, Bool bOn, u32 *outWidth, u32
 	dd->yuv_init = GF_FALSE;
 	if (dd->fullscreen) {
 		const char *sOpt = gf_modules_get_option((GF_BaseInterface *)dr, "Video", "SwitchResolution");
-		if (sOpt && !stricmp(sOpt, "yes")) dd->switch_res = 1;
+		if (sOpt && !stricmp(sOpt, "yes")) dd->switch_res = GF_TRUE;
 		/*get current or best fitting mode*/
 		if (GetDisplayMode(dd) != GF_OK) return GF_IO_ERR;
 	}
@@ -660,7 +660,7 @@ static GF_Err DD_SetFullScreen(GF_VideoOutput *dr, Bool bOn, u32 *outWidth, u32
 				dd->fs_height = dr->max_screen_height;
 				Y = 0;
 			}
-			if (!(minfo.dwFlags & MONITORINFOF_PRIMARY)) dd->on_secondary_screen = 1;
+			if (!(minfo.dwFlags & MONITORINFOF_PRIMARY)) dd->on_secondary_screen = GF_TRUE;
 		}
 #endif
 
@@ -742,10 +742,10 @@ GF_Err DD_Flush(GF_VideoOutput *dr, GF_Window *dest)
 	if (!dd->fullscreen && dd->windowless) {
 		HDC hdc;
 		/*lock backbuffer HDC*/
-		dr->LockOSContext(dr, 1);
+		dr->LockOSContext(dr, GF_TRUE);
 		/*get window hdc and copy from backbuffer to window*/
 		hdc = GetDC(dd->os_hwnd);
-		BitBlt(hdc, 0, 0, dd->width, dd->height, dd->lock_hdc, 0, 0, SRCCOPY );
+		BitBlt(hdc, 0, 0, dd->width, dd->height, dd->lock_hdc, 0, 0, SRCCOPY);
 		ReleaseDC(dd->os_hwnd, hdc);
 		/*unlock backbuffer HDC*/
 		dr->LockOSContext(dr, GF_FALSE);
@@ -800,12 +800,12 @@ GF_Err GetDisplayMode(DDContext *dd)
 {
 	if (dd->switch_res && dd->DirectDrawCreate) {
 		HRESULT hr;
-		Bool temp_dd = 0;;
+		Bool temp_dd = GF_FALSE;
 		if (!dd->pDD) {
 			LPDIRECTDRAW ddraw;
 			dd->DirectDrawCreate(NULL, &ddraw, NULL);
 			ddraw->lpVtbl->QueryInterface(ddraw, &IID_IDirectDraw7, (LPVOID *)&dd->pDD);
-			temp_dd = 1;
+			temp_dd = GF_TRUE;
 		}
 		//we start with a hugde res and downscale
 		dd->fs_width = dd->fs_height = 50000;
@@ -830,7 +830,7 @@ static void *NewDXVideoOutput()
 	memset(driv, 0, sizeof(GF_VideoOutput));
 	GF_REGISTER_MODULE_INTERFACE(driv, GF_VIDEO_OUTPUT_INTERFACE, "DirectX Video Output", "gpac distribution");
 
-	pCtx = gf_malloc(sizeof(DDContext));
+	pCtx = (DDContext*)gf_malloc(sizeof(DDContext));
 	memset(pCtx, 0, sizeof(DDContext));
 	driv->opaque = pCtx;
 	driv->Flush = DD_Flush;
diff --git a/modules/dx_hw/dx_window.c b/modules/dx_hw/dx_window.c
index 5308a0597..0681b185c 100644
--- a/modules/dx_hw/dx_window.c
+++ b/modules/dx_hw/dx_window.c
@@ -460,7 +460,7 @@ void release_mouse(DDContext *ctx, HWND hWnd, GF_VideoOutput *vout)
 
 LRESULT APIENTRY DD_WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
 {
-	Bool ret = 1;
+	Bool ret = GF_TRUE;
 	GF_Event evt;
 	DDContext *ctx;
 #ifdef _WIN64
@@ -477,7 +477,7 @@ LRESULT APIENTRY DD_WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam
 		if (wParam==SIZE_MINIMIZED) {
 			evt.type = GF_EVENT_SHOWHIDE_NOTIF;
 			evt.show.show_type = 0;
-			ctx->hidden = 1;
+			ctx->hidden = GF_TRUE;
 			vout->on_event(vout->evt_cbk_hdl, &evt);
 		} else {
 			if (ctx->hidden && wParam==SIZE_RESTORED) {
@@ -519,10 +519,10 @@ LRESULT APIENTRY DD_WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam
 		}
 		break;
 	case WM_DISPLAYCHANGE:
-		ctx->dd_lost = 1;
+		ctx->dd_lost = GF_TRUE;
 		memset(&evt, 0, sizeof(GF_Event));
 		evt.type = GF_EVENT_VIDEO_SETUP;
-		evt.setup.back_buffer = 1;
+		evt.setup.back_buffer = GF_TRUE;
 		vout->on_event(vout->evt_cbk_hdl, &evt);
 		break;
 
@@ -541,7 +541,7 @@ LRESULT APIENTRY DD_WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam
 	case WM_ACTIVATEAPP:
 #endif
 		if (hWnd==ctx->os_hwnd) {
-			ctx->has_focus = 1;
+			ctx->has_focus = GF_TRUE;
 			SetFocus(hWnd);
 		}
 		break;
@@ -549,7 +549,7 @@ LRESULT APIENTRY DD_WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam
 		if (hWnd==ctx->os_hwnd) ctx->has_focus = GF_FALSE;
 		break;
 	case WM_SETFOCUS:
-		if (hWnd==ctx->os_hwnd) ctx->has_focus = 1;
+		if (hWnd==ctx->os_hwnd) ctx->has_focus = GF_TRUE;
 		break;
 	case WM_IME_SETCONTEXT:
 		if ((hWnd==ctx->os_hwnd) && (wParam!=0) && !ctx->fullscreen) SetFocus(hWnd);
@@ -629,7 +629,7 @@ LRESULT APIENTRY DD_WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam
 		evt.mouse.button = GF_MOUSE_LEFT;
 		ret = vout->on_event(vout->evt_cbk_hdl, &evt);
 		if (!ctx->has_focus && (hWnd==ctx->os_hwnd)) {
-			ctx->has_focus = 1;
+			ctx->has_focus = GF_TRUE;
 			SetFocus(ctx->os_hwnd);
 		}
 		break;
@@ -648,7 +648,7 @@ LRESULT APIENTRY DD_WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam
 		evt.mouse.button = GF_MOUSE_RIGHT;
 		ret = vout->on_event(vout->evt_cbk_hdl, &evt);
 		if (!ctx->has_focus && (hWnd==ctx->os_hwnd)) {
-			ctx->has_focus = 1;
+			ctx->has_focus = GF_TRUE;
 			SetFocus(ctx->os_hwnd);
 		}
 		break;
@@ -668,7 +668,7 @@ LRESULT APIENTRY DD_WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam
 		DD_GetCoordinates(lParam, &evt);
 		ret = vout->on_event(vout->evt_cbk_hdl, &evt);
 		if (!ctx->has_focus && (hWnd==ctx->os_hwnd)) {
-			ctx->has_focus = 1;
+			ctx->has_focus = GF_TRUE;
 			SetFocus(ctx->os_hwnd);
 		}
 		break;
@@ -729,8 +729,8 @@ LRESULT APIENTRY DD_WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam
 	case WM_KEYDOWN:
 		w32_translate_key(wParam, lParam, &evt.key);
 		evt.type = ((msg==WM_SYSKEYDOWN) || (msg==WM_KEYDOWN)) ? GF_EVENT_KEYDOWN : GF_EVENT_KEYUP;
-		if (evt.key.key_code==GF_KEY_ALT) ctx->alt_down = (evt.type==GF_EVENT_KEYDOWN) ? 1 : GF_FALSE;
-		if (evt.key.key_code==GF_KEY_CONTROL) ctx->ctrl_down = (evt.type==GF_EVENT_KEYDOWN) ? 1 : GF_FALSE;
+		if (evt.key.key_code==GF_KEY_ALT) ctx->alt_down = (evt.type==GF_EVENT_KEYDOWN) ? GF_TRUE : GF_FALSE;
+		if (evt.key.key_code==GF_KEY_CONTROL) ctx->ctrl_down = (evt.type==GF_EVENT_KEYDOWN) ? GF_TRUE : GF_FALSE;
 		if ((ctx->os_hwnd==ctx->fs_hwnd) && ctx->alt_down && (evt.key.key_code==GF_KEY_F4)) {
 			memset(&evt, 0, sizeof(GF_Event));
 			evt.type = GF_EVENT_QUIT;
@@ -778,7 +778,7 @@ LRESULT APIENTRY DD_WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam
 
 		if ( !ctx->ctrl_down && !ctx->alt_down
 		        && evt.key.key_code != GF_KEY_CONTROL && evt.key.key_code != GF_KEY_ALT )
-			ret = 1;
+			ret = GF_TRUE;
 		break;
 
 	case WM_UNICHAR:
@@ -865,7 +865,7 @@ static void SetWindowless(GF_VideoOutput *vout, HWND hWnd)
 Bool DD_InitWindows(GF_VideoOutput *vout, DDContext *ctx)
 {
 	u32 flags;
-	Bool use_fs_wnd = 1;
+	Bool use_fs_wnd = GF_TRUE;
 #ifndef _WIN32_WCE
 	RECT rc;
 #endif
@@ -894,11 +894,11 @@ Bool DD_InitWindows(GF_VideoOutput *vout, DDContext *ctx)
 
 	flags = ctx->switch_res;
 	ctx->switch_res = GF_FALSE;
-	ctx->force_alpha = (flags & GF_TERM_WINDOW_TRANSPARENT) ? 1 : GF_FALSE;
+	ctx->force_alpha = (flags & GF_TERM_WINDOW_TRANSPARENT) ? GF_TRUE : GF_FALSE;
 
 	if (!ctx->os_hwnd) {
 		u32 styles;
-		if (flags & GF_TERM_WINDOWLESS) ctx->windowless = 1;
+		if (flags & GF_TERM_WINDOWLESS) ctx->windowless = GF_TRUE;
 
 
 #ifdef _WIN32_WCE
@@ -939,7 +939,7 @@ Bool DD_InitWindows(GF_VideoOutput *vout, DDContext *ctx)
 		ctx->off_w = rc.right - rc.left - 100;
 		ctx->off_h = rc.bottom - rc.top - 100;
 #endif
-		ctx->owns_hwnd = 1;
+		ctx->owns_hwnd = GF_TRUE;
 
 		if (ctx->windowless) SetWindowless(vout, ctx->os_hwnd);
 	}
@@ -978,7 +978,7 @@ Bool DD_InitWindows(GF_VideoOutput *vout, DDContext *ctx)
 	ctx->curs_hand = LoadCursor(hInst, MAKEINTRESOURCE(IDC_HAND_PTR));
 	ctx->curs_collide = LoadCursor(hInst, MAKEINTRESOURCE(IDC_COLLIDE));
 	ctx->cursor_type = GF_CURSOR_NORMAL;
-	return 1;
+	return GF_TRUE;
 }
 
 u32 DD_WindowThread(void *par)
@@ -1239,7 +1239,7 @@ GF_Err DD_ProcessEvent(GF_VideoOutput*dr, GF_Event *evt)
 			ctx->dd_lost = GF_FALSE;
 			DestroyObjects(ctx);
 		}
-		ctx->is_setup = 1;
+		ctx->is_setup = GF_TRUE;
 		switch (evt->setup.opengl_mode) {
 		case 0:
 #ifndef GPAC_DISABLE_3D
diff --git a/modules/ffmpeg_in/ffmpeg_decode.c b/modules/ffmpeg_in/ffmpeg_decode.c
index 6ae1b0220..4ec424c6c 100644
--- a/modules/ffmpeg_in/ffmpeg_decode.c
+++ b/modules/ffmpeg_in/ffmpeg_decode.c
@@ -204,7 +204,7 @@ static GF_Err FFDEC_AttachStream(GF_BaseDecoder *plug, GF_ESD *esd)
 		}
 
 		*codec = avcodec_find_decoder(codec_id);
-		FFDEC_LoadDSI(ffd, bs, *codec, *ctx, 1);
+		FFDEC_LoadDSI(ffd, bs, *codec, *ctx, GF_TRUE);
 		gf_bs_del(bs);
 	}
 	/*private QT DSI*/
@@ -230,7 +230,7 @@ static GF_Err FFDEC_AttachStream(GF_BaseDecoder *plug, GF_ESD *esd)
 			(*ctx)->height = gf_bs_read_u16(bs);
 		}
 		(*codec) = ffmpeg_get_codec(codec_id);
-		FFDEC_LoadDSI(ffd, bs, *codec, *ctx, 0);
+		FFDEC_LoadDSI(ffd, bs, *codec, *ctx, GF_FALSE);
 		gf_bs_del(bs);
 	}
 	/*use std MPEG-4 st/oti*/
@@ -261,7 +261,7 @@ static GF_Err FFDEC_AttachStream(GF_BaseDecoder *plug, GF_ESD *esd)
 				break;
 			case GPAC_OTI_IMAGE_JPEG:
 				codec_id = CODEC_ID_MJPEG;
-				ffd->is_image=1;
+				ffd->is_image = GF_TRUE;
 				break;
 			case 0xFF:
 				codec_id = CODEC_ID_SVQ3;
@@ -308,12 +308,12 @@ static GF_Err FFDEC_AttachStream(GF_BaseDecoder *plug, GF_ESD *esd)
 					if (dsi.height%2) dsi.height++;
 					(*ctx)->width = dsi.width;
 					(*ctx)->height = dsi.height;
-					if (!dsi.width && !dsi.height) ffd->check_short_header = 1;
+					if (!dsi.width && !dsi.height) ffd->check_short_header = GF_TRUE;
 					ffd->previous_par = (dsi.par_num<<16) | dsi.par_den;
-					ffd->no_par_update = 1;
+					ffd->no_par_update = GF_TRUE;
 #endif
 				} else if (ffd->oti==GPAC_OTI_VIDEO_AVC) {
-					ffd->check_h264_isma = 1;
+					ffd->check_h264_isma = GF_TRUE;
 				}
 
 				/*setup dsi for FFMPEG context BEFORE attaching decoder (otherwise not proper init)*/
@@ -378,7 +378,7 @@ static GF_Err FFDEC_AttachStream(GF_BaseDecoder *plug, GF_ESD *esd)
 	if (codec_id == CODEC_ID_RAWVIDEO) {
 		(*ctx)->codec_id = CODEC_ID_RAWVIDEO;
 		(*ctx)->pix_fmt = ffd->raw_pix_fmt;
-		if ((*ctx)->extradata && strstr((char *) (*ctx)->extradata, "BottomUp")) ffd->flipped = 1;
+		if ((*ctx)->extradata && strstr((char *) (*ctx)->extradata, "BottomUp")) ffd->flipped = GF_TRUE;
 	} else {
 #ifdef USE_AVCTX3
 		if (avcodec_open2((*ctx), (*codec), NULL )<0) return GF_NON_COMPLIANT_BITSTREAM;
@@ -466,12 +466,12 @@ static GF_Err FFDEC_AttachStream(GF_BaseDecoder *plug, GF_ESD *esd)
 
 	sOpt = gf_modules_get_option((GF_BaseInterface *)plug, "Systems", "Output8bit");
 	if (!sOpt) gf_modules_set_option((GF_BaseInterface *)plug, "Systems", "Output8bit", (ffd->display_bpp>8) ? "no" : "yes");
-	if (sOpt && !strcmp(sOpt, "yes")) ffd->output_as_8bit = 1;
+	if (sOpt && !strcmp(sOpt, "yes")) ffd->output_as_8bit = GF_TRUE;
 
 	if (ffd->output_as_8bit && (ffd->stride > (u32) (*ctx)->width)) {
 		ffd->stride /=2;
 		ffd->out_size /= 2;
-		ffd->conv_to_8bit = 1;
+		ffd->conv_to_8bit = GF_TRUE;
 	}
 
 	return GF_OK;
@@ -679,7 +679,7 @@ static GF_Err FFDEC_ProcessData(GF_MediaDecoder *plug,
 #ifdef FFMPEG_SWSCALE
 	struct SwsContext **cached_sws;
 #endif
-	FFDec *ffd = plug->privateStack;
+	FFDec *ffd = (FFDec*)plug->privateStack;
 #ifdef FFMPEG_SWSCALE
 	cached_sws = &(ffd->base_sws);
 #endif
@@ -888,7 +888,7 @@ redecode:
 
 	/*we have a valid frame not yet dispatched*/
 	if (ffd->had_pic) {
-		ffd->had_pic = 0;
+		ffd->had_pic = GF_FALSE;
 		gotpic = 1;
 	} else {
 		if (ffd->check_h264_isma) {
@@ -987,8 +987,8 @@ redecode:
 
 	/*we have a picture and need resize, do it*/
 	if (gotpic && ffd->needs_output_resize) {
-		ffd->needs_output_resize=0;
-		ffd->had_pic = 1;
+		ffd->needs_output_resize = GF_FALSE;
+		ffd->had_pic = GF_TRUE;
 		*outBufferLength = ffd->out_size;
 		return GF_BUFFER_TOO_SMALL;
 	}
@@ -996,7 +996,7 @@ redecode:
 	stride = frame->linesize[0];
 #ifndef NO_10bit
 	if ((ctx->pix_fmt == PIX_FMT_YUV420P10LE) && ffd->output_as_8bit && (frame->linesize[0] >= 2*w) )  {
-		ffd->conv_to_8bit = 1;
+		ffd->conv_to_8bit = GF_TRUE;
 		stride=w;
 	}
 #endif
@@ -1040,7 +1040,7 @@ redecode:
 		/*we didn't get any picture: wait for a picture before resizing output buffer, otherwise we will have no
 		video in the output buffer*/
 		if (!gotpic) {
-			ffd->needs_output_resize = 1;
+			ffd->needs_output_resize = GF_TRUE;
 			return GF_OK;
 		}
 		*outBufferLength = ffd->out_size;
@@ -1054,10 +1054,10 @@ redecode:
 			*cached_sws = NULL;
 		}
 #endif
-		ffd->had_pic = 1;
+		ffd->had_pic = GF_TRUE;
 
 		if (ffd->conv_to_8bit && ffd->direct_output) {
-			ffd->conv_buffer = gf_realloc(ffd->conv_buffer, sizeof(char)*ffd->out_size);
+			ffd->conv_buffer = (char*)gf_realloc(ffd->conv_buffer, sizeof(char)*ffd->out_size);
 		}
 
 		return GF_BUFFER_TOO_SMALL;
@@ -1069,11 +1069,11 @@ redecode:
 			ffd->previous_par = new_par;
 
 			if (!gotpic) {
-				ffd->needs_output_resize = 1;
+				ffd->needs_output_resize = GF_TRUE;
 				return GF_OK;
 			}
 			*outBufferLength = ffd->out_size;
-			ffd->had_pic = 1;
+			ffd->had_pic = GF_TRUE;
 			return GF_BUFFER_TOO_SMALL;
 		}
 	}
@@ -1104,7 +1104,7 @@ redecode:
 		dst.video_buffer = ffd->direct_output ? ffd->conv_buffer : outBuffer;
 		dst.pixel_format = GF_PIXEL_YV12;
 
-		gf_color_write_yv12_10_to_yuv(&dst, (u8 *) frame->data[0], frame->data[1], frame->data[2], frame->linesize[0], ctx->width, ctx->height, NULL, 0);
+		gf_color_write_yv12_10_to_yuv(&dst, (u8 *) frame->data[0], frame->data[1], frame->data[2], frame->linesize[0], ctx->width, ctx->height, NULL, GF_FALSE);
 		*outBufferLength = ffd->out_size;
 		return GF_OK;
 	}
@@ -1206,7 +1206,7 @@ redecode:
 
 static GF_Err FFDEC_GetOutputBuffer(GF_MediaDecoder *ifcg, u16 ES_ID, u8 **pY_or_RGB, u8 **pU, u8 **pV)
 {
-	FFDec *ffd = ifcg->privateStack;
+	FFDec *ffd = (FFDec*)ifcg->privateStack;
 	AVFrame *frame;
 
 
@@ -1234,7 +1234,7 @@ static u32 FFDEC_CanHandleStream(GF_BaseDecoder *plug, u32 StreamType, GF_ESD *e
 	GF_BitStream *bs;
 	u32 codec_id;
 	Bool check_4cc;
-	FFDec *ffd = plug->privateStack;
+	FFDec *ffd = (FFDec*)plug->privateStack;
 
 	/*media type query*/
 	if (!esd) {
@@ -1247,7 +1247,7 @@ static u32 FFDEC_CanHandleStream(GF_BaseDecoder *plug, u32 StreamType, GF_ESD *e
 	ffd->st = StreamType;
 
 	codec_id = 0;
-	check_4cc = 0;
+	check_4cc = GF_FALSE;
 
 	/*private from FFMPEG input*/
 	if (ffd->oti == GPAC_OTI_MEDIA_FFMPEG) {
@@ -1259,7 +1259,7 @@ static u32 FFDEC_CanHandleStream(GF_BaseDecoder *plug, u32 StreamType, GF_ESD *e
 	else if (ffd->oti == GPAC_OTI_MEDIA_GENERIC) {
 		bs = gf_bs_new(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, GF_BITSTREAM_READ);
 		codec_id = gf_bs_read_u32(bs);
-		check_4cc = 1;
+		check_4cc = GF_TRUE;
 		gf_bs_del(bs);
 	}
 	else if (StreamType==GF_STREAM_AUDIO) {
@@ -1284,22 +1284,22 @@ static u32 FFDEC_CanHandleStream(GF_BaseDecoder *plug, u32 StreamType, GF_ESD *e
 		/*fixme - we should use some priority rather than declare ffmpeg can't handle svc*/
 		if (esd->decoderConfig->objectTypeIndication == GPAC_OTI_VIDEO_AVC) {
 			if (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {
-				Bool is_svc = 0;
+				Bool is_svc = GF_FALSE;
 				u32 i, count;
 				GF_AVCConfig *cfg = gf_odf_avc_cfg_read(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);
 				if (!cfg) return GF_CODEC_SUPPORTED;
 
 				if (esd->has_ref_base)
-					is_svc = 1;
+					is_svc = GF_TRUE;
 
 				/*decode all NALUs*/
 				count = gf_list_count(cfg->sequenceParameterSets);
 				for (i=0; i<count; i++) {
-					GF_AVCConfigSlot *slc = gf_list_get(cfg->sequenceParameterSets, i);
+					GF_AVCConfigSlot *slc = (GF_AVCConfigSlot*)gf_list_get(cfg->sequenceParameterSets, i);
 					u8 nal_type = slc->data[0] & 0x1F;
 
 					if (nal_type==GF_AVC_NALU_SVC_SUBSEQ_PARAM) {
-						is_svc = 1;
+						is_svc = GF_TRUE;
 						break;
 					}
 				}
@@ -1379,7 +1379,7 @@ static const char *FFDEC_GetCodecName(GF_BaseDecoder *dec)
 	FFDec *ffd;
 	if (!dec)
 		return NULL;
-	ffd = dec->privateStack;
+	ffd = (FFDec*)dec->privateStack;
 	if (ffd && ffd->base_codec) {
 		sprintf(ffd->szCodec, "FFMPEG %s - version %s", ffd->base_codec->name ? ffd->base_codec->name : "unknown", LIBAVCODEC_IDENT);
 		return ffd->szCodec;
@@ -1421,11 +1421,11 @@ void *FFDEC_Load()
 
 void FFDEC_Delete(void *ifce)
 {
-	GF_BaseDecoder *dec = ifce;
+	GF_BaseDecoder *dec = (GF_BaseDecoder*)ifce;
 	FFDec *ffd;
 	if (!ifce)
 		return;
-	ffd = dec->privateStack;
+	ffd = (FFDec*)dec->privateStack;
 	dec->privateStack = NULL;
 	if (ffd) {
 		if (ffd->base_ctx && ffd->base_ctx->codec) avcodec_close(ffd->base_ctx);
diff --git a/modules/ffmpeg_in/ffmpeg_demux.c b/modules/ffmpeg_in/ffmpeg_demux.c
index b18bfd7d3..f603a250a 100644
--- a/modules/ffmpeg_in/ffmpeg_demux.c
+++ b/modules/ffmpeg_in/ffmpeg_demux.c
@@ -278,7 +278,7 @@ static Bool FFD_CanHandleURL(GF_InputService *plug, const char *url)
 			u32 i;
 			for (i = 0 ; FFD_MIME_TYPES[i]; i+=3) {
 				if (gf_service_check_mime_register(plug, FFD_MIME_TYPES[i], FFD_MIME_TYPES[i+1], FFD_MIME_TYPES[i+2], ext))
-					return 1;
+					return GF_TRUE;
 			}
 		}
 	}
@@ -305,17 +305,17 @@ static Bool FFD_CanHandleURL(GF_InputService *plug, const char *url)
 		AVCodecContext *enc = ctx->streams[i]->codec;
 		switch(enc->codec_type) {
 		case AVMEDIA_TYPE_AUDIO:
-			if (!has_audio) has_audio = 1;
+			if (!has_audio) has_audio = GF_TRUE;
 			break;
 		case AVMEDIA_TYPE_VIDEO:
-			if (!has_video) has_video= 1;
+			if (!has_video) has_video= GF_TRUE;
 			break;
 		default:
 			break;
 		}
 	}
 	if (!has_audio && !has_video) goto exit;
-	ret = 1;
+	ret = GF_TRUE;
 #if ((LIBAVFORMAT_VERSION_MAJOR == 52) && (LIBAVFORMAT_VERSION_MINOR <= 47)) || (LIBAVFORMAT_VERSION_MAJOR < 52)
 	fmt_out = guess_stream_format(NULL, url, NULL);
 #else
@@ -477,11 +477,11 @@ static void FFD_SetupObjects(FFDemux *ffd)
 
 	if ((ffd->audio_st>=0) && (ffd->service_type != 1)) {
 		od = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);
-		esd = FFD_GetESDescriptor(ffd, 1);
+		esd = FFD_GetESDescriptor(ffd, GF_TRUE);
 		od->objectDescriptorID = esd->ESID;
 		audio_esid = esd->ESID;
 		gf_list_add(od->ESDescriptors, esd);
-		gf_service_declare_media(ffd->service, (GF_Descriptor*)od, (ffd->video_st>=0) ? 1 : GF_FALSE);
+		gf_service_declare_media(ffd->service, (GF_Descriptor*)od, (ffd->video_st>=0) ? GF_TRUE : GF_FALSE);
 	}
 	if ((ffd->video_st>=0) && (ffd->service_type != 2)) {
 		od = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);
@@ -583,7 +583,7 @@ static GF_Err FFD_ConnectService(GF_InputService *plug, GF_ClientService *serv,
 	strlwr(szExt);
 	if (!strcmp(szExt, "cmp")) av_in = av_find_input_format("m4v");
 
-	is_local = (strnicmp(url, "file://", 7) && strstr(url, "://")) ? GF_FALSE : 1;
+	is_local = (strnicmp(url, "file://", 7) && strstr(url, "://")) ? GF_FALSE : GF_TRUE;
 
 	GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, ("[FFMPEG] opening file %s - local %d - av_in %08x\n", url, is_local, av_in));
 
@@ -726,10 +726,10 @@ static GF_Err FFD_ConnectService(GF_InputService *plug, GF_ClientService *serv,
 				if (pkt.pts == AV_NOPTS_VALUE) pkt.pts = pkt.dts;
 				if (pkt.stream_index==ffd->audio_st) last_aud_pts = pkt.pts;
 			}
-			if (last_aud_pts*ffd->audio_tscale.den<10*ffd->audio_tscale.num) ffd->unreliable_audio_timing = 1;
+			if (last_aud_pts*ffd->audio_tscale.den<10*ffd->audio_tscale.num) ffd->unreliable_audio_timing = GF_TRUE;
 		}
 
-		ffd->seekable = (av_seek_frame(ffd->ctx, -1, 0, AVSEEK_FLAG_BACKWARD)<0) ? GF_FALSE : 1;
+		ffd->seekable = (av_seek_frame(ffd->ctx, -1, 0, AVSEEK_FLAG_BACKWARD)<0) ? GF_FALSE : GF_TRUE;
 		if (!ffd->seekable) {
 #if FF_API_CLOSE_INPUT_FILE
 			av_close_input_file(ffd->ctx);
@@ -780,7 +780,7 @@ static GF_Descriptor *FFD_GetServiceDesc(GF_InputService *plug, u32 expect_type,
 		if (ffd->audio_st<0) return NULL;
 		od = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG);
 		od->objectDescriptorID = 1;
-		esd = FFD_GetESDescriptor(ffd, 1);
+		esd = FFD_GetESDescriptor(ffd, GF_TRUE);
 		/*if session join, setup sync*/
 		if (ffd->video_ch) esd->OCRESID = ffd->video_st+1;
 		gf_list_add(od->ESDescriptors, esd);
@@ -928,8 +928,8 @@ static GF_Err FFD_ServiceCommand(GF_InputService *plug, GF_NetworkCommand *com)
 		gf_mx_p(ffd->mx);
 		ffd->seek_time = (com->play.start_range>=0) ? com->play.start_range : 0;
 
-		if (ffd->audio_ch==com->base.on_channel) ffd->audio_run = 1;
-		else if (ffd->video_ch==com->base.on_channel) ffd->video_run = 1;
+		if (ffd->audio_ch==com->base.on_channel) ffd->audio_run = GF_TRUE;
+		else if (ffd->video_ch==com->base.on_channel) ffd->video_run = GF_TRUE;
 
 		/*play on media stream, start thread*/
 		if ((ffd->audio_ch==com->base.on_channel) || (ffd->video_ch==com->base.on_channel)) {
@@ -973,8 +973,8 @@ static Bool FFD_CanHandleURLInService(GF_InputService *plug, const char *url)
 
 	if ((url[0] != '#') && strnicmp(szURL, url, sizeof(char)*strlen(szURL))) return GF_FALSE;
 	sep = strrchr(url, '#');
-	if (sep && !stricmp(sep, "#video") && (ffd->video_st>=0)) return 1;
-	if (sep && !stricmp(sep, "#audio") && (ffd->audio_st>=0)) return 1;
+	if (sep && !stricmp(sep, "#video") && (ffd->video_st>=0)) return GF_TRUE;
+	if (sep && !stricmp(sep, "#audio") && (ffd->audio_st>=0)) return GF_TRUE;
 	return GF_FALSE;
 }
 
diff --git a/modules/ft_font/ft_font.c b/modules/ft_font/ft_font.c
index 73434c29f..d696b5277 100644
--- a/modules/ft_font/ft_font.c
+++ b/modules/ft_font/ft_font.c
@@ -154,8 +154,8 @@ static Bool ft_enum_fonts(void *cbck, char *file_name, char *file_path, GF_FileE
 			if (face->style_name) {
 				char *name = gf_strdup(face->style_name);
 				strupr(name);
-				if (strstr(name, "BOLD")) bold = 1;
-				if (strstr(name, "ITALIC")) italic = 1;
+				if (strstr(name, "BOLD")) bold = GF_TRUE;
+				if (strstr(name, "ITALIC")) italic = GF_TRUE;
 				/*if font is not regular style, append all styles blindly*/
 				if (!strstr(name, "REGULAR")) {
 					strcat(szfont, " ");
@@ -163,8 +163,8 @@ static Bool ft_enum_fonts(void *cbck, char *file_name, char *file_path, GF_FileE
 				}
 				gf_free(name);
 			} else {
-				if (face->style_flags & FT_STYLE_FLAG_BOLD) bold = 1;
-				if (face->style_flags & FT_STYLE_FLAG_ITALIC) italic = 1;
+				if (face->style_flags & FT_STYLE_FLAG_BOLD) bold = GF_TRUE;
+				if (face->style_flags & FT_STYLE_FLAG_ITALIC) italic = GF_TRUE;
 
 				if (bold) strcat(szfont, " Bold");
 				if (italic) strcat(szfont, " Italic");
@@ -199,7 +199,7 @@ static Bool ft_enum_fonts_dir(void *cbck, char *file_name, char *file_path, GF_F
 {
 	GF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, ("[FreeType] Scanning directory %s (%s)\n", file_name, file_path));
 	gf_enum_directory(file_path, GF_FALSE, ft_enum_fonts, cbck, "ttf;ttc");
-	return (gf_enum_directory(file_path, 1, ft_enum_fonts_dir, cbck, NULL)==GF_OK) ? GF_FALSE : GF_TRUE;
+	return (gf_enum_directory(file_path, GF_TRUE, ft_enum_fonts_dir, cbck, NULL)==GF_OK) ? GF_FALSE : GF_TRUE;
 }
 
 
@@ -237,7 +237,7 @@ static void ft_rescan_fonts(GF_FontReader *dr)
 	ftpriv->font_dir = NULL;
 
 	gf_enum_directory(font_dir, GF_FALSE, ft_enum_fonts, dr, "ttf;ttc");
-	gf_enum_directory(font_dir, 1, ft_enum_fonts_dir, dr, NULL);
+	gf_enum_directory(font_dir, GF_TRUE, ft_enum_fonts_dir, dr, NULL);
 
 	font_default = ftpriv->font_dir;
 	ftpriv->font_dir = font_dir;
@@ -415,7 +415,7 @@ static Bool ft_check_face(FT_Face font, const char *fontName, u32 styles)
 		styles = (styles & 0x00000007);
 
 	if (ft_style==styles)
-		return 1;
+		return GF_TRUE;
 	return GF_FALSE;
 }
 
@@ -703,7 +703,7 @@ GF_FontReader *ft_load()
 void ft_delete(GF_BaseInterface *ifce)
 {
 	GF_FontReader *dr = (GF_FontReader *) ifce;
-	FTBuilder *ftpriv = dr->udta;
+	FTBuilder *ftpriv = (FTBuilder*)dr->udta;
 
 
 	if (ftpriv->font_dir) gf_free(ftpriv->font_dir);
diff --git a/modules/gpac_js/gpac_js.c b/modules/gpac_js/gpac_js.c
index 942cd8739..dff91f4a9 100644
--- a/modules/gpac_js/gpac_js.c
+++ b/modules/gpac_js/gpac_js.c
@@ -337,7 +337,7 @@ case -13://"fullscreen"
 {
 	/*no fullscreen for iOS (always on)*/
 #ifndef GPAC_IPHONE
-	Bool res = (JSVAL_TO_BOOLEAN(*vp)==JS_TRUE) ? 1 : GF_FALSE;
+	Bool res = (JSVAL_TO_BOOLEAN(*vp)==JS_TRUE) ? GF_TRUE : GF_FALSE;
 	if (term->compositor->fullscreen != res) {
 		gf_term_set_option(term, GF_OPT_FULLSCREEN, res);
 	}
@@ -361,15 +361,15 @@ case -17: //"navigation_type"
 	gf_term_set_option(term, GF_OPT_NAVIGATION_TYPE, 0);
 	break;
 case -33: //"disable_hardware_blit"
-	term->compositor->disable_hardware_blit = JSVAL_TO_INT(*vp) ? 1 : GF_FALSE;
+	term->compositor->disable_hardware_blit = JSVAL_TO_INT(*vp) ? GF_TRUE : GF_FALSE;
 	gf_sc_set_option(term->compositor, GF_OPT_REFRESH, 0);
 	break;
 case -34: //"disable_composite_blit"
 {
-	Bool new_val = JSVAL_TO_INT(*vp) ? 1 : GF_FALSE;
+	Bool new_val = JSVAL_TO_INT(*vp) ? GF_TRUE : GF_FALSE;
 	if (new_val != term->compositor->disable_composite_blit) {
 		term->compositor->disable_composite_blit = new_val;
-		term->compositor->rebuild_offscreen_textures = 1;
+		term->compositor->rebuild_offscreen_textures = GF_TRUE;
 		gf_sc_set_option(term->compositor, GF_OPT_REFRESH, 0);
 	}
 }
@@ -381,7 +381,7 @@ case -24:  //"http_max_bitrate"
 }
 break;
 case -35: //"focus_highlight"
-	term->compositor->disable_focus_highlight = JSVAL_TO_BOOLEAN(*vp) ? GF_FALSE : 1;
+	term->compositor->disable_focus_highlight = JSVAL_TO_BOOLEAN(*vp) ? GF_FALSE : GF_TRUE;
 	break;
 }
 return JS_TRUE;
@@ -573,12 +573,12 @@ static JSBool SMJS_FUNCTION(gpac_enum_directory)
 
 	if ((argc >= 1) && JSVAL_IS_STRING(argv[0])) {
 		dir = SMJS_CHARS(c, argv[0]);
-		if (!strcmp(dir, "/")) browse_root = 1;
+		if (!strcmp(dir, "/")) browse_root = GF_TRUE;
 	}
 	if ((argc >= 2) && JSVAL_IS_STRING(argv[1])) {
 		filter = SMJS_CHARS(c, argv[1]);
 		if (!strcmp(filter, "dir")) {
-			dir_only = 1;
+			dir_only = GF_TRUE;
 			filter = NULL;
 		} else if (!strlen(filter)) {
 			SMJS_FREE(c, filter);
@@ -589,20 +589,20 @@ static JSBool SMJS_FUNCTION(gpac_enum_directory)
 		if (JSVAL_TO_BOOLEAN(argv[2])==JS_TRUE) {
 			url = gf_url_concatenate(dir, "..");
 			if (!strcmp(url, "..") || (url[0]==0)) {
-				if ((dir[1]==':') && ((dir[2]=='/') || (dir[2]=='\\')) ) browse_root = 1;
-				else if (!strcmp(dir, "/")) browse_root = 1;
+				if ((dir[1]==':') && ((dir[2]=='/') || (dir[2]=='\\')) ) browse_root = GF_TRUE;
+				else if (!strcmp(dir, "/")) browse_root = GF_TRUE;
 			}
-			if (!strcmp(url, "/")) browse_root = 1;
+			if (!strcmp(url, "/")) browse_root = GF_TRUE;
 		}
 	}
 
-	if ( (!dir || !strlen(dir) ) && (!url || !strlen(url))) browse_root = 1;
+	if ( (!dir || !strlen(dir) ) && (!url || !strlen(url))) browse_root = GF_TRUE;
 
 	if (browse_root) {
 		cbk.c = c;
 		cbk.array = JS_NewArrayObject(c, 0, 0);
-		cbk.is_dir = 1;
-		gf_enum_directory("/", 1, enum_dir_fct, &cbk, NULL);
+		cbk.is_dir = GF_TRUE;
+		gf_enum_directory("/", GF_TRUE, enum_dir_fct, &cbk, NULL);
 		SMJS_SET_RVAL( OBJECT_TO_JSVAL(cbk.array) );
 		if (url) gf_free(url);
 		SMJS_FREE(c, dir);
@@ -613,7 +613,7 @@ static JSBool SMJS_FUNCTION(gpac_enum_directory)
 	cbk.c = c;
 	cbk.array = JS_NewArrayObject(c, 0, 0);
 
-	cbk.is_dir = 1;
+	cbk.is_dir = GF_TRUE;
 
 	term = gpac_get_term(c, obj);
 	/*concatenate with service url*/
@@ -622,7 +622,7 @@ static JSBool SMJS_FUNCTION(gpac_enum_directory)
 		gf_free(url);
 		url = an_url;
 	}
-	err = gf_enum_directory(url ? url : dir, 1, enum_dir_fct, &cbk, NULL);
+	err = gf_enum_directory(url ? url : dir, GF_TRUE, enum_dir_fct, &cbk, NULL);
 
 	if (!dir_only) {
 		cbk.is_dir = GF_FALSE;
@@ -664,14 +664,14 @@ static JSBool SMJS_FUNCTION(gpac_set_size)
 		h = (u32) d;
 	}
 	if ((argc >= 3) && JSVAL_IS_BOOLEAN(argv[2]) && (JSVAL_TO_BOOLEAN(argv[2])==JS_TRUE) )
-		override_size_info = 1;
+		override_size_info = GF_TRUE;
 
 	if (w && h) {
 		GF_Event evt;
 		if (override_size_info) {
 			term->compositor->scene_width = w;
 			term->compositor->scene_height = h;
-			term->compositor->has_size_info = 1;
+			term->compositor->has_size_info = GF_TRUE;
 			return JS_TRUE;
 		}
 		if (term->user->os_window_handler) {
@@ -711,7 +711,7 @@ static JSBool SMJS_FUNCTION(gpac_set_3d)
 	if (argc && JSVAL_IS_INT(argv[0])) type_3d = JSVAL_TO_INT(argv[0]);
 	if (term->compositor->inherit_type_3d != type_3d) {
 		term->compositor->inherit_type_3d = type_3d;
-		term->compositor->root_visual_setup = 0;
+		term->compositor->root_visual_setup = GF_FALSE;
 		gf_sc_reset_graphics(term->compositor);
 	}
 	return JS_TRUE;
@@ -1179,7 +1179,7 @@ static JSBool SMJS_FUNCTION(gjs_odm_select_quality)
 	com.base.command_type = GF_NET_SERVICE_QUALITY_SWITCH;
 	com.base.on_channel = gf_list_get(odm->channels, 0);
 	if (!strcmp(ID, "auto")) {
-		com.switch_quality.set_auto = 1;
+		com.switch_quality.set_auto = GF_TRUE;
 	} else {
 		com.switch_quality.ID = ID;
 	}
@@ -1437,9 +1437,9 @@ static Bool gjs_event_filter(void *udta, GF_Event *evt, Bool consumed_by_composi
 
 	res = GF_FALSE;
 	if (JSVAL_IS_BOOLEAN(rval) ) {
-		res = (JSVAL_TO_BOOLEAN(rval)==JS_TRUE) ? 1 : GF_FALSE;
+		res = (JSVAL_TO_BOOLEAN(rval)==JS_TRUE) ? GF_TRUE : GF_FALSE;
 	} else if (JSVAL_IS_INT(rval) ) {
-		res = (JSVAL_TO_INT(rval)) ? 1 : GF_FALSE;
+		res = (JSVAL_TO_INT(rval)) ? GF_TRUE : GF_FALSE;
 	}
 
 	gf_sg_lock_javascript(gjs->c, GF_FALSE);
@@ -1480,7 +1480,7 @@ static JSBool SMJS_FUNCTION(gpac_set_focus)
 	if (JSVAL_IS_STRING(argv[0])) {
 		char *focus_type = SMJS_CHARS(c, argv[0]);
 		if (!stricmp(focus_type, "previous")) {
-			gf_sc_focus_switch_ring(term->compositor, 1, NULL, 0);
+			gf_sc_focus_switch_ring(term->compositor, GF_TRUE, NULL, 0);
 		}
 		else if (!stricmp(focus_type, "next")) {
 			gf_sc_focus_switch_ring(term->compositor, GF_FALSE, NULL, 0);
diff --git a/modules/img_in/bmp_dec.c b/modules/img_in/bmp_dec.c
index 30c5ab87c..f0a3f64ad 100644
--- a/modules/img_in/bmp_dec.c
+++ b/modules/img_in/bmp_dec.c
@@ -200,7 +200,7 @@ Bool NewBMPDec(GF_BaseDecoder *ifcd)
 	ifcd->SetCapabilities = BMP_SetCapabilities;
 	ifcd->GetName = BMP_GetCodecName;
 	((GF_MediaDecoder *)ifcd)->ProcessData = BMP_ProcessData;
-	return 1;
+	return GF_TRUE;
 }
 
 void DeleteBMPDec(GF_BaseDecoder *ifcg)
diff --git a/modules/img_in/img_in.c b/modules/img_in/img_in.c
index fa456fe5d..39ac6279c 100644
--- a/modules/img_in/img_in.c
+++ b/modules/img_in/img_in.c
@@ -136,16 +136,16 @@ static Bool IMG_CanHandleURL(GF_InputService *plug, const char *url)
 	sExt = strrchr(url, '.');
 	for (i = 0 ; IMG_MIME_TYPES[i]; i+=3) {
 		if (gf_service_check_mime_register(plug, IMG_MIME_TYPES[i], IMG_MIME_TYPES[i+1], IMG_MIME_TYPES[i+2], sExt))
-			return 1;
+			return GF_TRUE;
 	}
 	return GF_FALSE;
 }
 
 static Bool jp_is_local(const char *url)
 {
-	if (!strnicmp(url, "file://", 7)) return 1;
+	if (!strnicmp(url, "file://", 7)) return GF_TRUE;
 	if (strstr(url, "://")) return GF_FALSE;
-	return 1;
+	return GF_TRUE;
 }
 
 
@@ -278,7 +278,7 @@ static GF_Descriptor *IMG_GetServiceDesc(GF_InputService *plug, u32 expect_type,
 		gf_list_add(od->ESDescriptors, esd);
 		return (GF_Descriptor *) od;
 	}
-	read->is_inline = 1;
+	read->is_inline = GF_TRUE;
 	return NULL;
 }
 
@@ -378,7 +378,7 @@ static GF_Err IMG_ChannelGetSLP(GF_InputService *plug, LPNETCHANNEL channel, cha
 				*out_data_size = 0;
 				return GF_OK;
 			}
-			*is_new_data = 1;
+			*is_new_data = GF_TRUE;
 			gf_fseek(read->stream, 0, SEEK_SET);
 			read->data = (char*) gf_malloc(sizeof(char) * (read->data_size + read->pad_bytes));
 			read->data_size = (u32) fread(read->data, sizeof(char), read->data_size, read->stream);
@@ -401,7 +401,7 @@ static GF_Err IMG_ChannelReleaseSLP(GF_InputService *plug, LPNETCHANNEL channel)
 		if (!read->data) return GF_BAD_PARAM;
 		gf_free(read->data);
 		read->data = NULL;
-		read->done = 1;
+		read->done = GF_TRUE;
 		return GF_OK;
 	}
 	return GF_OK;
diff --git a/modules/img_in/jp2_dec.c b/modules/img_in/jp2_dec.c
index 7ec5d621f..4a1692918 100644
--- a/modules/img_in/jp2_dec.c
+++ b/modules/img_in/jp2_dec.c
@@ -457,7 +457,7 @@ Bool NewJP2Dec(GF_BaseDecoder *ifcd)
 	ifcd->SetCapabilities = JP2_SetCapabilities;
 	ifcd->GetName = JP2_GetCodecName;
 	((GF_MediaDecoder *)ifcd)->ProcessData = JP2_ProcessData;
-	return 1;
+	return GF_TRUE;
 }
 
 void DeleteJP2Dec(GF_BaseDecoder *ifcg)
diff --git a/modules/img_in/jpeg_dec.c b/modules/img_in/jpeg_dec.c
index db9b768b1..b7a7bd492 100644
--- a/modules/img_in/jpeg_dec.c
+++ b/modules/img_in/jpeg_dec.c
@@ -146,7 +146,7 @@ Bool NewJPEGDec(GF_BaseDecoder *ifcd)
 	ifcd->SetCapabilities = JPEG_SetCapabilities;
 	ifcd->GetName = JPEG_GetCodecName;
 	((GF_MediaDecoder *)ifcd)->ProcessData = JPEG_ProcessData;
-	return 1;
+	return GF_TRUE;
 }
 
 void DeleteJPEGDec(GF_BaseDecoder *ifcg)
diff --git a/modules/img_in/png_dec.c b/modules/img_in/png_dec.c
index a91e8617c..18a0bbed5 100644
--- a/modules/img_in/png_dec.c
+++ b/modules/img_in/png_dec.c
@@ -171,7 +171,7 @@ Bool NewPNGDec(GF_BaseDecoder *ifcd)
 	ifcd->SetCapabilities = PNG_SetCapabilities;
 	ifcd->GetName = PNG_GetCodecName;
 	((GF_MediaDecoder *)ifcd)->ProcessData = PNG_ProcessData;
-	return 1;
+	return GF_TRUE;
 }
 
 void DeletePNGDec(GF_BaseDecoder *ifcg)
diff --git a/modules/isom_in/isom_cache.c b/modules/isom_in/isom_cache.c
index 61893e63b..13c2dadac 100644
--- a/modules/isom_in/isom_cache.c
+++ b/modules/isom_in/isom_cache.c
@@ -139,7 +139,7 @@ static GF_Err ISOW_Write(GF_StreamingCache *mc, LPNETCHANNEL ch, char *data, u32
 		mch->time_scale = esd->slConfig->timestampResolution;
 		mch->streamType = esd->decoderConfig->streamType;
 		mch->track = gf_isom_new_track(cache->mov, com.cache_esd.esd->ESID, mtype, mch->time_scale);
-		mch->is_playing = 1;
+		mch->is_playing = GF_TRUE;
 		mch->channel = ch;
 		mch->owner = cache;
 		gf_isom_set_track_enabled(cache->mov, mch->track, 1);
@@ -151,7 +151,7 @@ static GF_Err ISOW_Write(GF_StreamingCache *mc, LPNETCHANNEL ch, char *data, u32
 			szCode[4]=0;
 			if (!stricmp(szCode, "samr") || !stricmp(szCode, "amr ") || !stricmp(szCode, "sawb")) {
 				GF_3GPConfig amrc;
-				mapped = 1;
+				mapped = GF_TRUE;
 				memset(&amrc, 0, sizeof(GF_3GPConfig));
 
 				amrc.frames_per_sample = (u32) esd->decoderConfig->decoderSpecificInfo->data[13];
@@ -164,7 +164,7 @@ static GF_Err ISOW_Write(GF_StreamingCache *mc, LPNETCHANNEL ch, char *data, u32
 				h263c.type = GF_ISOM_SUBTYPE_3GP_H263;
 				h263c.vendor = GF_4CC('G','P','A','C');
 				gf_isom_3gp_config_new(cache->mov, mch->track, &h263c, NULL, NULL, &di);
-				mapped = 1;
+				mapped = GF_TRUE;
 			}
 		}
 		if (!mapped) gf_isom_new_mpeg4_description(cache->mov, mch->track, esd, NULL, NULL, &di);
diff --git a/modules/isom_in/read.c b/modules/isom_in/read.c
index f920fd670..5a0da35d9 100644
--- a/modules/isom_in/read.c
+++ b/modules/isom_in/read.c
@@ -541,7 +541,7 @@ static GF_Descriptor *ISOR_GetServiceDesc(GF_InputService *plug, u32 expect_type
 	if (!read->mov) return NULL;
 
 	/*no matter what always read text as TTUs*/
-	gf_isom_text_set_streaming_mode(read->mov, 1);
+	gf_isom_text_set_streaming_mode(read->mov, GF_TRUE);
 
 	trackID = 0;
 	if (!sub_url) {
@@ -873,7 +873,7 @@ GF_Err ISOR_DisconnectChannel(GF_InputService *plug, LPNETCHANNEL channel)
 
 exit:
 	if (read->input->query_proxy && read->input->proxy_udta && read->input->proxy_type) {
-		send_proxy_command(read, 1, GF_FALSE, e, NULL, channel);
+		send_proxy_command(read, GF_TRUE, GF_FALSE, e, NULL, channel);
 	} else {
 		gf_service_disconnect_ack(read->service, channel, e);
 	}
@@ -1052,7 +1052,7 @@ GF_Err ISOR_ServiceCommand(GF_InputService *plug, GF_NetworkCommand *com)
 		return GF_OK;
 	}
 	if (com->command_type == GF_NET_SERVICE_PROXY_DATA_RECEIVE) {
-		isor_flush_data(read, 1, com->proxy_data.is_chunk);
+		isor_flush_data(read, GF_TRUE, com->proxy_data.is_chunk);
 		return GF_OK;
 	}
 	if (com->command_type == GF_NET_SERVICE_FLUSH_DATA) {
@@ -1080,7 +1080,7 @@ GF_Err ISOR_ServiceCommand(GF_InputService *plug, GF_NetworkCommand *com)
 			return GF_NOT_SUPPORTED;
 #endif
 
-		ch->is_pulling = 1;
+		ch->is_pulling = GF_TRUE;
 		return GF_OK;
 	case GF_NET_CHAN_INTERACTIVE:
 		return GF_OK;
@@ -1118,14 +1118,14 @@ GF_Err ISOR_ServiceCommand(GF_InputService *plug, GF_NetworkCommand *com)
 		gf_mx_p(read->segment_mutex);
 		isor_reset_reader(ch);
 		ch->speed = com->play.speed;
-		read->reset_frag_state = 1;
+		read->reset_frag_state = GF_TRUE;
 		gf_mx_v(read->segment_mutex);
 
 		ch->start = ch->end = 0;
 		if (com->play.speed>0) {
 			if (com->play.start_range>=0) {
 				ch->start = (u64) (s64) (com->play.start_range * ch->time_scale);
-				ch->start = check_round(ch, ch->start, com->play.start_range, 1);
+				ch->start = check_round(ch, ch->start, com->play.start_range, GF_TRUE);
 			}
 			if (com->play.end_range >= com->play.start_range) {
 				ch->end = (u64) (s64) (com->play.end_range*ch->time_scale);
@@ -1138,8 +1138,8 @@ GF_Err ISOR_ServiceCommand(GF_InputService *plug, GF_NetworkCommand *com)
 			if (end <= com->play.start_range)
 				ch->end = (u64) (s64) (end  * ch->time_scale);
 		}
-		ch->is_playing = 1;
-		if (com->play.dash_segment_switch) ch->wait_for_segment_switch = 1;
+		ch->is_playing = GF_TRUE;
+		if (com->play.dash_segment_switch) ch->wait_for_segment_switch = GF_TRUE;
 		GF_LOG(GF_LOG_DEBUG, GF_LOG_NETWORK, ("[IsoMedia] Starting channel playback "LLD" to "LLD" (%g to %g)\n", ch->start, ch->end, com->play.start_range, com->play.end_range));
 
 		//and check buffer level on play request
@@ -1179,7 +1179,7 @@ GF_Err ISOR_ServiceCommand(GF_InputService *plug, GF_NetworkCommand *com)
 	}
 	case GF_NET_CHAN_NALU_MODE:
 		ch->nalu_extract_mode = GF_ISOM_NALU_EXTRACT_INBAND_PS_FLAG;
-		ch->disable_seek = 1;
+		ch->disable_seek = GF_TRUE;
 		//when this is set, we work in real scalable (eg N streams reassembled by the player) so only extract the layer. This wll need refinements if we plan to support
 		//several scalable layers ...
 		if (com->nalu_mode.extract_mode==1) {
diff --git a/modules/isom_in/read_ch.c b/modules/isom_in/read_ch.c
index 210e16308..a9f95cde7 100644
--- a/modules/isom_in/read_ch.c
+++ b/modules/isom_in/read_ch.c
@@ -40,7 +40,7 @@ void isor_reset_reader(ISOMChannel *ch)
 	ch->sample_num = 0;
 	ch->speed = 1.0;
 	ch->start = ch->end = 0;
-	ch->to_init = 1;
+	ch->to_init = GF_TRUE;
 	ch->is_playing = GF_FALSE;
 	memset(&ch->current_slh, 0, sizeof(GF_SLHeader));
 }
@@ -69,7 +69,7 @@ void isor_segment_switch_or_refresh(ISOMReader *read, Bool do_refresh)
 	memset(&param, 0, sizeof(GF_NetworkCommand));
 	param.command_type = GF_NET_SERVICE_QUERY_NEXT;
 	//always check current download - this might be ignored by the dash client depending on lowLatency settings
-	param.url_query.current_download = 1;
+	param.url_query.current_download = GF_TRUE;
 
 	count = gf_list_count(read->channels);
 
@@ -85,7 +85,7 @@ void isor_segment_switch_or_refresh(ISOMReader *read, Bool do_refresh)
 
 	if (read->drop_next_segment) {
 		read->drop_next_segment = GF_FALSE;
-		param.url_query.drop_first_segment = 1;
+		param.url_query.drop_first_segment = GF_TRUE;
 	}
 
 	//if first time trying to fetch next segment, check if we have to discard it
@@ -102,12 +102,12 @@ void isor_segment_switch_or_refresh(ISOMReader *read, Bool do_refresh)
 #endif
 
 		/*close current segment*/
-		gf_isom_release_segment(read->mov, 1);
+		gf_isom_release_segment(read->mov, GF_TRUE);
 		read->seg_opened = 0;
 		GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[IsoMedia] Done playing segment - querying new one\n"));
 
 		/*drop this segment*/
-		param.url_query.drop_first_segment = 1;
+		param.url_query.drop_first_segment = GF_TRUE;
 	}
 
 next_segment:
@@ -121,8 +121,8 @@ next_segment:
 
 			//previously loaded file has been aborted, reload segment !
 			if (do_refresh && param.url_query.discontinuity_type) {
-				gf_isom_release_segment(read->mov, 1);
-				gf_isom_reset_fragment_info(read->mov, 1);
+				gf_isom_release_segment(read->mov, GF_TRUE);
+				gf_isom_reset_fragment_info(read->mov, GF_TRUE);
 				do_refresh = GF_FALSE;
 			}
 
@@ -156,7 +156,7 @@ next_segment:
 
 			if (param.url_query.discontinuity_type == 2) {
 				gf_isom_reset_fragment_info(read->mov, GF_FALSE);
-				read->clock_discontinuity = 1;
+				read->clock_discontinuity = GF_TRUE;
 			}
 			e = GF_OK;
 			if (param.url_query.next_url_init_or_switch_segment) {
@@ -189,9 +189,9 @@ next_segment:
 			}
 
 			if (e<0) {
-				gf_isom_release_segment(read->mov, 1);
+				gf_isom_release_segment(read->mov, GF_TRUE);
 				//gf_isom_reset_fragment_info(read->mov, 1);
-				read->drop_next_segment = 1;
+				read->drop_next_segment = GF_TRUE;
 				//error opening the segment, reset everything ...
 				gf_isom_reset_fragment_info(read->mov, GF_FALSE);
 				for (i=0; i<count; i++) {
@@ -215,7 +215,7 @@ next_segment:
 			}
 
 #ifndef _WIN32_WCE
-			if (gf_isom_get_last_producer_time_box(read->mov, &trackID, &ntp, &timestamp, 1)) {
+			if (gf_isom_get_last_producer_time_box(read->mov, &trackID, &ntp, &timestamp, GF_TRUE)) {
 				time_t secs;
 				struct tm t;
 
@@ -286,7 +286,7 @@ next_segment:
 		if (param.url_query.has_next) {
 			param.url_query.drop_first_segment = GF_FALSE;
 			param.url_query.dependent_representation_index++;
-			scalable_segment = 1;
+			scalable_segment = GF_TRUE;
 			GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[IsoMedia] Enhancement layer available in cache - refreshing it\n"));
 			goto next_segment;
 		}
@@ -414,7 +414,7 @@ void isor_reader_get_sample(ISOMChannel *ch)
 	}
 
 	if ((ch->owner->seg_opened==1) && ch->is_pulling) {
-		isor_segment_switch_or_refresh(ch->owner, 1);
+		isor_segment_switch_or_refresh(ch->owner, GF_TRUE);
 	}
 
 	if (ch->to_init) {
@@ -572,7 +572,7 @@ void isor_reader_get_sample(ISOMChannel *ch)
 			if (ch->owner->frag_type==1) {
 				//if segment is fully opened and no more data, this track is done, wait for next segment
 				if (!ch->wait_for_segment_switch && ch->owner->input->query_proxy && (ch->owner->seg_opened==2) ) {
-					ch->wait_for_segment_switch = 1;
+					ch->wait_for_segment_switch = GF_TRUE;
 					GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[IsoMedia] Track #%d end of segment reached - waiting for sample %d - current count %d\n", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track) ));
 				}
 				/*if sample cannot be found and file is fragmented, rewind sample*/
@@ -746,10 +746,10 @@ void isor_flush_data(ISOMReader *read, Bool check_buffer_level, Bool is_chunk_fl
 		if (check_buffer_level && !is_chunk_flush) read->has_pending_segments++;
 		return;
 	}
-	read->in_data_flush = 1;
+	read->in_data_flush = GF_TRUE;
 	count = gf_list_count(read->channels);
 
-	do_refresh = (read->seg_opened==1) ? 1 : GF_FALSE;
+	do_refresh = (read->seg_opened==1) ? GF_TRUE : GF_FALSE;
 
 	if (do_refresh) {
 		//query from terminal - do nothing if we are not done downloading the segment - otherwise we could access media data while it is reallocated by the downloader
@@ -762,7 +762,7 @@ void isor_flush_data(ISOMReader *read, Bool check_buffer_level, Bool is_chunk_fl
 	}
 	//this is a new file, check buffer level
 	else if (!is_chunk_flush && check_buffer_level) {
-		Bool buffer_full = 1;
+		Bool buffer_full = GF_TRUE;
 		for (i=0; i<count; i++) {
 			ch = (ISOMChannel *)gf_list_get(read->channels, i);
 			/*query buffer level on each channel, don't sleep if too low*/
@@ -795,7 +795,7 @@ void isor_flush_data(ISOMReader *read, Bool check_buffer_level, Bool is_chunk_fl
 
 	//if this is a request from terminal to flush pending segments, try to refresh
 	if (!check_buffer_level && !do_refresh)
-		do_refresh = 1;
+		do_refresh = GF_TRUE;
 
 	//update data
 	isor_segment_switch_or_refresh(read, do_refresh);
@@ -824,7 +824,7 @@ void isor_flush_data(ISOMReader *read, Bool check_buffer_level, Bool is_chunk_fl
 		memset(&param, 0, sizeof(GF_NetworkCommand));
 		param.command_type = GF_NET_SERVICE_QUERY_NEXT;
 		param.url_query.dependent_representation_index = 0;
-		param.url_query.drop_first_segment = 1;
+		param.url_query.drop_first_segment = GF_TRUE;
 		e = read->input->query_proxy(read->input, &param);
 
 		read->nb_force_flush = 0;
@@ -846,7 +846,7 @@ void isor_flush_data(ISOMReader *read, Bool check_buffer_level, Bool is_chunk_fl
 		}
 
 		/*close current segment*/
-		gf_isom_release_segment(read->mov, 1);
+		gf_isom_release_segment(read->mov, GF_TRUE);
 		read->seg_opened = 0;
 		GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[IsoMedia] Done playing segment \n"));
 	}
diff --git a/modules/mpd_in/mpd_in.c b/modules/mpd_in/mpd_in.c
index 56eec0f3b..42d900f90 100644
--- a/modules/mpd_in/mpd_in.c
+++ b/modules/mpd_in/mpd_in.c
@@ -123,7 +123,7 @@ static s32 gf_dash_get_group_idx_from_service(GF_MPD_In *mpdin, GF_InputService
 	s32 i;
 
 	for (i=0; (u32) i < gf_dash_get_group_count(mpdin->dash); i++) {
-		GF_MPDGroup *group = gf_dash_get_group_udta(mpdin->dash, i);
+		GF_MPDGroup *group = (GF_MPDGroup*)gf_dash_get_group_udta(mpdin->dash, i);
 		if (!group) continue;
 		if (group->segment_ifce == ifce) {
 			return i;
@@ -171,7 +171,7 @@ void mpdin_data_packet(GF_ClientService *service, LPNETCHANNEL ns, char *data, u
 			u64 pto;
 			gf_dash_group_get_presentation_time_offset(mpdin->dash, i, &pto, &group->timescale);
 			group->pto = (s64) pto;
-			group->pto_setup = 1;
+			group->pto_setup = GF_TRUE;
 
 			if (group->timescale && (group->timescale != ch->esd->slConfig->timestampResolution)) {
 				group->pto *= ch->esd->slConfig->timestampResolution;
@@ -227,8 +227,8 @@ void mpdin_data_packet(GF_ClientService *service, LPNETCHANNEL ns, char *data, u
 		}
 
 	} else if (!group->pto_setup) {
-		do_map_time = 1;
-		group->pto_setup = 1;
+		do_map_time = GF_TRUE;
+		group->pto_setup = GF_TRUE;
 	}
 
 	mpdin->fn_data_packet(service, ns, data, data_size, hdr, reception_status);
@@ -339,7 +339,7 @@ static GF_Err MPD_ClientQuery(GF_InputService *ifce, GF_NetworkCommand *param)
 			if (group_done) {
 				if (!gf_dash_get_period_switch_status(mpdin->dash) && !gf_dash_in_last_period(mpdin->dash)) {
 					GF_NetworkCommand com;
-					param->url_query.in_end_of_period = 1;
+					param->url_query.in_end_of_period = GF_TRUE;
 					memset(&com, 0, sizeof(GF_NetworkCommand));
 					com.command_type = GF_NET_BUFFER_QUERY;
 					if (gf_dash_get_period_switch_status(mpdin->dash) != 1) {
@@ -362,7 +362,7 @@ static GF_Err MPD_ClientQuery(GF_InputService *ifce, GF_NetworkCommand *param)
 				gf_dash_group_probe_current_download_segment_location(mpdin->dash, group_idx, &param->url_query.next_url, NULL, &param->url_query.next_url_init_or_switch_segment, &src_url, &is_switched);
 
 				if (param->url_query.next_url) {
-					param->url_query.current_download = 1;
+					param->url_query.current_download = GF_TRUE;
 					param->url_query.has_new_data = group->has_new_data;
 					param->url_query.discontinuity_type = is_switched ? 1 : 0;
 					if (gf_dash_group_loop_detected(mpdin->dash, group_idx))
@@ -529,7 +529,7 @@ static void mpdin_dash_segment_netio(void *cbk, GF_NETIO_Parameter *param)
 	}
 
 	if (param->msg_type == GF_NETIO_DATA_EXCHANGE) {
-		group->has_new_data = 1;
+		group->has_new_data = GF_TRUE;
 
 		if (param->reply) {
 			u32 bytes_per_sec;
@@ -538,9 +538,9 @@ static void mpdin_dash_segment_netio(void *cbk, GF_NETIO_Parameter *param)
 			GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[MPD_IN] End of chunk received for %s at UTC "LLU" ms - estimated bandwidth %d kbps - chunk start at UTC "LLU"\n", url, gf_net_get_utc(), 8*bytes_per_sec/1000, gf_dm_sess_get_utc_start(group->sess)));
 
 			if (group->mpdin->use_low_latency)
-				MPD_NotifyData(group, 1);
+				MPD_NotifyData(group, GF_TRUE);
 		} else if (group->mpdin->use_low_latency==2) {
-			MPD_NotifyData(group, 1);
+			MPD_NotifyData(group, GF_TRUE);
 		}
 
 		if (group->mpdin->allow_http_abort)
@@ -734,7 +734,7 @@ GF_Err mpdin_dash_io_on_dash_event(GF_DASHFileIO *dashio, GF_DASHEventType dash_
 					GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[MPD_IN] Unable to connect input service to %s\n", init_segment));
 					gf_dash_group_select(mpdin->dash, i, GF_FALSE);
 				} else {
-					group->service_connected = 1;
+					group->service_connected = GF_TRUE;
 				}
 				if (mpdin->closed) return GF_OK;
 			}
@@ -742,7 +742,7 @@ GF_Err mpdin_dash_io_on_dash_event(GF_DASHFileIO *dashio, GF_DASHEventType dash_
 
 		if (!mpdin->connection_ack_sent) {
 			mpdin->fn_connect_ack(mpdin->service, NULL, GF_OK);
-			mpdin->connection_ack_sent = 1;
+			mpdin->connection_ack_sent = GF_TRUE;
 		}
 
 		//we had a seek outside of the period we were setting up, during period setup !
@@ -897,11 +897,11 @@ GF_Err MPD_ConnectService(GF_InputService *plug, GF_ClientService *serv, const c
 	keep_files = GF_FALSE;
 	opt = gf_modules_get_option((GF_BaseInterface *)plug, "DASH", "KeepFiles");
 	if (!opt) gf_modules_set_option((GF_BaseInterface *)plug, "DASH", "KeepFiles", "no");
-	if (opt && !strcmp(opt, "yes")) keep_files = 1;
+	if (opt && !strcmp(opt, "yes")) keep_files = GF_TRUE;
 
 	disable_switching = GF_FALSE;
 	opt = gf_modules_get_option((GF_BaseInterface *)plug, "DASH", "DisableSwitching");
-	if (opt && !strcmp(opt, "yes")) disable_switching = 1;
+	if (opt && !strcmp(opt, "yes")) disable_switching = GF_TRUE;
 
 	first_select_mode = GF_DASH_SELECT_QUALITY_LOWEST;
 	opt = gf_modules_get_option((GF_BaseInterface *)plug, "DASH", "StartRepresentation");
@@ -927,11 +927,11 @@ GF_Err MPD_ConnectService(GF_InputService *plug, GF_ClientService *serv, const c
 #endif
 		gf_modules_set_option((GF_BaseInterface *)plug, "DASH", "UseMaxResolution", opt);
 	}
-	mpdin->use_max_res = !strcmp(opt, "yes") ? 1 : GF_FALSE;
+	mpdin->use_max_res = !strcmp(opt, "yes") ? GF_TRUE : GF_FALSE;
 
 	opt = gf_modules_get_option((GF_BaseInterface *)plug, "DASH", "ImmediateSwitching");
 	if (!opt) gf_modules_set_option((GF_BaseInterface *)plug, "DASH", "ImmediateSwitching", "no");
-	mpdin->immediate_switch = (opt && !strcmp(opt, "yes")) ? 1 : GF_FALSE;
+	mpdin->immediate_switch = (opt && !strcmp(opt, "yes")) ? GF_TRUE : GF_FALSE;
 
 	opt = gf_modules_get_option((GF_BaseInterface *)plug, "DASH", "BufferingMode");
 	if (!opt) gf_modules_set_option((GF_BaseInterface *)plug, "DASH", "BufferingMode", "minBuffer");
@@ -957,7 +957,7 @@ GF_Err MPD_ConnectService(GF_InputService *plug, GF_ClientService *serv, const c
 
 	opt = gf_modules_get_option((GF_BaseInterface *)plug, "DASH", "UseServerUTC");
 	if (!opt) gf_modules_set_option((GF_BaseInterface *)plug, "DASH", "UseServerUTC", "yes");
-	use_server_utc = (opt && !strcmp(opt, "yes")) ? 1 : GF_FALSE;
+	use_server_utc = (opt && !strcmp(opt, "yes")) ? GF_TRUE : GF_FALSE;
 
 	mpdin->in_seek = GF_FALSE;
 	mpdin->previous_start_range = 0;
@@ -1049,7 +1049,7 @@ static GF_Descriptor *MPD_GetServiceDesc(GF_InputService *plug, u32 expect_type,
 		if (mudta->service_descriptor_fetched) continue;
 
 		desc = mudta->segment_ifce->GetServiceDescriptor(mudta->segment_ifce, expect_type, sub_url);
-		if (desc) mudta->service_descriptor_fetched = 1;
+		if (desc) mudta->service_descriptor_fetched = GF_TRUE;
 		gf_odf_desc_del(desc);
 	}
 	return NULL;
@@ -1062,7 +1062,7 @@ GF_Err MPD_CloseService(GF_InputService *plug)
 	assert(mpdin);
 	GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[MPD_IN] Received Close Service (%p) request from terminal\n", mpdin->service));
 
-	mpdin->closed = 1;
+	mpdin->closed = GF_TRUE;
 
 	if (mpdin->dash)
 		gf_dash_close(mpdin->dash);
@@ -1129,7 +1129,7 @@ GF_Err MPD_ServiceCommand(GF_InputService *plug, GF_NetworkCommand *com)
 
 	case GF_NET_SERVICE_QUALITY_SWITCH:
 		if (com->switch_quality.set_auto) {
-			gf_dash_set_automatic_switching(mpdin->dash, 1);
+			gf_dash_set_automatic_switching(mpdin->dash, GF_TRUE);
 		} else if (com->base.on_channel) {
 			segment_ifce = MPD_GetInputServiceForChannel(mpdin, com->base.on_channel);
 			if (!segment_ifce) return GF_NOT_SUPPORTED;
@@ -1252,7 +1252,7 @@ GF_Err MPD_ServiceCommand(GF_InputService *plug, GF_NetworkCommand *com)
 				if (com->play.start_range < 0) com->play.start_range = 0;
 			}
 
-			group->is_timestamp_based = 1;
+			group->is_timestamp_based = GF_TRUE;
 			group->pto_setup = GF_FALSE;
 			mpdin->media_start_range = com->play.start_range;
 		} else {
@@ -1334,7 +1334,7 @@ GF_Err MPD_ServiceCommand(GF_InputService *plug, GF_NetworkCommand *com)
 	{
 		s32 idx = MPD_GetGroupIndexForChannel(mpdin, com->play.on_channel);
 		if (idx>=0) {
-			gf_dash_set_group_done(mpdin->dash, (u32) idx, 1);
+			gf_dash_set_group_done(mpdin->dash, (u32) idx, GF_TRUE);
 		}
 		mpdin->previous_start_range = -1;
 	}
@@ -1379,7 +1379,7 @@ Bool MPD_CanHandleURLInService(GF_InputService *plug, const char *url)
 	GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[MPD_IN] Received Can Handle URL In Service (%p) request from terminal for %s\n", mpdin->service, url));
 	if (!plug || !plug->priv || !mpdin->dash) return GF_FALSE;
 	if (gf_dash_get_url(mpdin->dash) && !strcmp(gf_dash_get_url(mpdin->dash) , url)) {
-		return 1;
+		return GF_TRUE;
 	} else {
 		GF_MPDGroup *mudta;
 		u32 i;
diff --git a/modules/mpegts_in/mpegts_in.c b/modules/mpegts_in/mpegts_in.c
index 2f5dbab83..f6f23eb9e 100644
--- a/modules/mpegts_in/mpegts_in.c
+++ b/modules/mpegts_in/mpegts_in.c
@@ -109,7 +109,7 @@ static Bool M2TS_CanHandleURL(GF_InputService *plug, const char *url)
 	        || !strnicmp(url, "dvb://", 6)
 #endif
 	   ) {
-		return 1;
+		return GF_TRUE;
 	}
 
 	sExt = strrchr(url, '.');
@@ -117,7 +117,7 @@ static Bool M2TS_CanHandleURL(GF_InputService *plug, const char *url)
 		int i=0;
 		for (i = 0 ; NULL != MIMES[i]; i++)
 			if (gf_service_check_mime_register(plug, MIMES[i], M2TS_EXTENSIONS, "MPEG-2 TS", sExt))
-				return 1;
+				return GF_TRUE;
 	}
 	return GF_FALSE;
 }
@@ -136,7 +136,7 @@ static Bool M2TS_CanHandleURLInService(GF_InputService *plug, const char *url)
 	if (!strnicmp(url, "pid://", 6)) {
 		u32 pid = atoi(url+6);
 		if (pid>=GF_M2TS_MAX_STREAMS) return GF_FALSE;
-		if (m2ts->ts->ess[pid]) return 1;
+		if (m2ts->ts->ess[pid]) return GF_TRUE;
 		return GF_FALSE;
 	}
 
@@ -173,7 +173,7 @@ static Bool M2TS_CanHandleURLInService(GF_InputService *plug, const char *url)
 			if (frag) frag[0] = 0;
 			if (!strlen(url) || !strcmp(url, m2ts->ts->filename)) {
 				GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, ("[DVBIn] Reusing the same input file for %s\n", url));
-				ret = 1;
+				ret = GF_TRUE;
 			}
 			if (frag) frag[0] = '#';
 		}
@@ -330,7 +330,7 @@ static void MP2TS_DeclareStream(M2TSIn *m2ts, GF_M2TS_PES *stream, char *dsi, u3
 	GF_ObjectDescriptor *od = MP2TS_GetOD(m2ts, stream, dsi, dsi_size, NULL);
 	if (!od) return;
 	/*declare but don't regenerate scene*/
-	gf_service_declare_media(m2ts->service, (GF_Descriptor*)od, 1);
+	gf_service_declare_media(m2ts->service, (GF_Descriptor*)od, GF_TRUE);
 }
 
 static void MP2TS_SetupProgram(M2TSIn *m2ts, GF_M2TS_Program *prog, Bool regenerate_scene, Bool no_declare)
@@ -352,8 +352,8 @@ static void MP2TS_SetupProgram(M2TSIn *m2ts, GF_M2TS_Program *prog, Bool regener
 
 	/*TS is a file, start regulation regardless of how the TS is access (with or without fragment URI)*/
 	if (m2ts->ts->file || m2ts->ts->dnload) {
-		m2ts->file_regulate = 1;
-		if (!m2ts->nb_playing) gf_m2ts_pause_demux(m2ts->ts, 1);
+		m2ts->file_regulate = GF_TRUE;
+		if (!m2ts->nb_playing) gf_m2ts_pause_demux(m2ts->ts, GF_TRUE);
 	}
 
 	for (i=0; i<count; i++) {
@@ -540,7 +540,7 @@ static void M2TS_FlushRequested(M2TSIn *m2ts)
 			GF_ObjectDescriptor *od = M2TS_GenerateEPG_OD(m2ts);
 			/*declare but don't regenerate scene*/
 			gf_service_declare_media(m2ts->service, (GF_Descriptor*)od, GF_FALSE);
-			m2ts->has_eit = 1;
+			m2ts->has_eit = GF_TRUE;
 		}
 	} else {
 		/*force scene regeneration only when EPG is not requested*/
@@ -582,7 +582,7 @@ static void M2TS_OnEvent(GF_M2TS_Demuxer *ts, u32 evt_type, void *param)
 		/* In case the TS has one program, wait for the PMT to send connect, in case of IOD in PMT */
 		if (gf_list_count(m2ts->ts->programs) != 1) {
 			gf_service_connect_ack(m2ts->service, NULL, GF_OK);
-			m2ts->is_connected = 1;
+			m2ts->is_connected = GF_TRUE;
 		}
 		/* Send the TS to the a user if needed. Useful to check the number of received programs*/
 		forward_m2ts_event(m2ts, evt_type, param);
@@ -596,7 +596,7 @@ static void M2TS_OnEvent(GF_M2TS_Demuxer *ts, u32 evt_type, void *param)
 	case GF_M2TS_EVT_PMT_FOUND:
 		if (gf_list_count(m2ts->ts->programs) == 1) {
 			gf_service_connect_ack(m2ts->service, NULL, GF_OK);
-			m2ts->is_connected = 1;
+			m2ts->is_connected = GF_TRUE;
 		}
 		/*do not declare if  single program was requested for playback*/
 		MP2TS_SetupProgram(m2ts, param, m2ts->request_all_pids, m2ts->request_all_pids ? 0 : 1);
@@ -613,7 +613,7 @@ static void M2TS_OnEvent(GF_M2TS_Demuxer *ts, u32 evt_type, void *param)
 
 	case GF_M2TS_EVT_SDT_FOUND:
 	case GF_M2TS_EVT_SDT_UPDATE:
-		m2ts->flush_sdt = 1;
+		m2ts->flush_sdt = GF_TRUE;
 	case GF_M2TS_EVT_SDT_REPEAT:
 		M2TS_FlushRequested(m2ts);
 		if (m2ts->flush_sdt) {
@@ -646,8 +646,8 @@ static void M2TS_OnEvent(GF_M2TS_Demuxer *ts, u32 evt_type, void *param)
 			gf_m2ts_set_pes_framing(pck->stream, GF_M2TS_PES_FRAMING_SKIP_NO_RESET);
 			MP2TS_DeclareStream(m2ts, pck->stream, pck->data, pck->data_len);
 			if (ts->file || ts->dnload) {
-				m2ts->file_regulate = 1;
-				if (!m2ts->nb_playing) gf_m2ts_pause_demux(m2ts->ts, 1);
+				m2ts->file_regulate = GF_TRUE;
+				if (!m2ts->nb_playing) gf_m2ts_pause_demux(m2ts->ts, GF_TRUE);
 
 			}
 			pck->stream->first_dts=1;
@@ -804,7 +804,7 @@ static void M2TS_OnEvent(GF_M2TS_Demuxer *ts, u32 evt_type, void *param)
 				u32 j, count2;
 				if (prog->tdt_found || !prog->last_pcr_value) /*map TDT one time, after we received a PCR*/
 					continue;
-				prog->tdt_found = 1;
+				prog->tdt_found = GF_TRUE;
 				count2 = gf_list_count(prog->streams);
 				com.map_time.timestamp = prog->last_pcr_value/300;
 				for (j=0; j<count2; j++) {
@@ -933,7 +933,7 @@ void m2ts_net_io(void *cbk, GF_NETIO_Parameter *param)
 		return;
 	default:
 		if (!m2ts->ts_setup) {
-			m2ts->ts_setup = 1;
+			m2ts->ts_setup = GF_TRUE;
 		}
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER,("[MPEGTSIn] : Error while getting data : %s\n", gf_error_to_string(e)));
 		gf_service_connect_ack(m2ts->service, NULL, e);
@@ -966,8 +966,8 @@ static GF_Err M2TS_QueryNextFile(void *udta, DASHQueryType query_type, const cha
 
 	memset(&param, 0, sizeof(GF_NetworkCommand));
 	param.command_type = (query_type == INIT_RANGE) ? GF_NET_SERVICE_QUERY_INIT_RANGE : GF_NET_SERVICE_QUERY_NEXT;
-	param.url_query.drop_first_segment = (query_type == DROP_NEXT_SEGMENT) ? 1 : GF_FALSE;
-	param.url_query.current_download = (query_type == NEXT_SEGMENT_EXCEPT_DL) ? GF_FALSE : 1;
+	param.url_query.drop_first_segment = (query_type == DROP_NEXT_SEGMENT) ? GF_TRUE : GF_FALSE;
+	param.url_query.current_download = (query_type == NEXT_SEGMENT_EXCEPT_DL) ? GF_FALSE : GF_TRUE;
 
 	//we are downloading the segment we play, don't delete it
 	if (m2ts->in_segment_download)
@@ -988,13 +988,13 @@ static GF_Err M2TS_QueryNextFile(void *udta, DASHQueryType query_type, const cha
 
 		/*the segment is being downloaded now, start monitoring refresh*/
 		if (param.url_query.current_download) {
-			m2ts->low_latency_mode = 1;
+			m2ts->low_latency_mode = GF_TRUE;
 			if (refresh_type) *refresh_type = 1;
 			if (!m2ts->in_segment_download || param.url_query.has_new_data) {
 				GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[M2TS In] progressive loading of TS segments\n"));
 			}
 			//state "in progress"
-			m2ts->in_segment_download = 1;
+			m2ts->in_segment_download = GF_TRUE;
 		} else {
 			if (refresh_type) {
 				//segment done downloading but was in progress mode: do a final refresh
@@ -1035,7 +1035,7 @@ void m2ts_flush_data(M2TSIn *m2ts, u32 flush_type)
             m2ts->has_pending_segments++;
         return;
     }
-	m2ts->in_data_flush = 1;
+	m2ts->in_data_flush = GF_TRUE;
 
 	//check buffer level when start of new segment
 	if (flush_type<=GF_M2TS_PUSH_CHUNK) {
@@ -1098,7 +1098,7 @@ static GF_Err M2TS_ConnectService(GF_InputService *plug, GF_ClientService *serv,
 
 	opt = gf_modules_get_option((GF_BaseInterface *)m2ts->owner, "HybRadio", "Activated");
 	if (opt && !strcmp(opt, "true")) {
-		m2ts->hybrid_on = 1;
+		m2ts->hybrid_on = GF_TRUE;
 	}
 
 	m2ts->ts->record_to = gf_modules_get_option((GF_BaseInterface *)m2ts->owner, "M2TS", "RecordTo");
@@ -1125,7 +1125,7 @@ static GF_Err M2TS_ConnectService(GF_InputService *plug, GF_ClientService *serv,
 			if (url) {
 				u64 start_byterange, end_byterange;
 				gf_mx_p(m2ts->mx);
-				m2ts->in_data_flush = 1;
+				m2ts->in_data_flush = GF_TRUE;
 				M2TS_QueryNextFile(m2ts, INIT_RANGE, NULL, &start_byterange, &end_byterange, NULL);
 				e = gf_m2ts_demux_file(m2ts->ts, url, start_byterange, end_byterange, 0, GF_FALSE);
 				M2TS_QueryNextFile(m2ts, DROP_NEXT_SEGMENT, NULL, NULL, NULL, NULL);
@@ -1187,7 +1187,7 @@ static GF_Descriptor *M2TS_GetServiceDesc(GF_InputService *plug, u32 expect_type
 	}
 
 	if (!frag) {
-		m2ts->request_all_pids = 1;
+		m2ts->request_all_pids = GF_TRUE;
 	} else {
 		/*we need exclusive access*/
 		gf_mx_p(m2ts->mx);
@@ -1196,7 +1196,7 @@ static GF_Descriptor *M2TS_GetServiceDesc(GF_InputService *plug, u32 expect_type
 			prog->pid = atoi(frag+4);
 			gf_list_add(m2ts->ts->requested_pids, prog);
 		} else if (!strnicmp(frag, "EPG", 3)) {
-			m2ts->epg_requested = 1;
+			m2ts->epg_requested = GF_TRUE;
 		} else {
 			u32 i, count;
 			count = gf_list_count(m2ts->ts->requested_progs);
@@ -1444,7 +1444,7 @@ static GF_Err M2TS_ServiceCommand(GF_InputService *plug, GF_NetworkCommand *com)
 				com->info.provider = sdt->provider;
 			}
 		} else {
-			m2ts->flush_sdt = 1;
+			m2ts->flush_sdt = GF_TRUE;
 		}
 		return GF_OK;
 	}
@@ -1491,7 +1491,7 @@ static GF_Err M2TS_ServiceCommand(GF_InputService *plug, GF_NetworkCommand *com)
 				m2ts->map_media_time_on_prog_id = pes->program->number;
 
 			if (com->play.dash_segment_switch)
-				ts->abort_parsing = 1;
+				ts->abort_parsing = GF_TRUE;
 
 			/*start demuxer*/
 			if (!plug->query_proxy) {
@@ -1542,7 +1542,7 @@ static GF_Err M2TS_ServiceCommand(GF_InputService *plug, GF_NetworkCommand *com)
 			if (pes->slcfg) gf_free(pes->slcfg);
 			pes->slcfg = (GF_SLConfig*)gf_malloc(sizeof(GF_SLConfig));
 			memcpy(pes->slcfg, &com->cfg.sl_config, sizeof(GF_SLConfig));
-			com->cfg.use_m2ts_sections = 1;
+			com->cfg.use_m2ts_sections = GF_TRUE;
 			pes->flags |= GF_M2TS_ES_SEND_REPEATED_SECTIONS;
 		}
 		return GF_OK;
@@ -1557,7 +1557,7 @@ static GF_Err M2TS_ServiceCommand(GF_InputService *plug, GF_NetworkCommand *com)
 			m2ts->nb_paused--;
 			if (!m2ts->nb_paused) {
 				m2ts->pcr_last = 0;
-				gf_m2ts_pause_demux(m2ts->ts, 0);
+				gf_m2ts_pause_demux(m2ts->ts, GF_FALSE);
 
 			}
 		}
@@ -1584,7 +1584,7 @@ static void M2TS_GetNetworkType(GF_InputService *plug,M2TSIn *reader)
 
 	mob_on = gf_modules_get_option((GF_BaseInterface*)plug, "Network", "MobileIPEnabled");
 	if(mob_on && !strcmp(mob_on, "yes")) {
-		reader->ts->MobileIPEnabled = 1;
+		reader->ts->MobileIPEnabled = GF_TRUE;
 		reader->ts->network_type = gf_modules_get_option((GF_BaseInterface*)plug, "Network", "MobileIP");
 	}
 
@@ -1615,7 +1615,7 @@ GF_InputService *NewM2TSReader()
 	reader->ts = gf_m2ts_demux_new();
 	reader->ts->on_event = M2TS_OnEvent;
 	reader->ts->user = reader;
-	reader->ts->demux_and_play = 1;
+	reader->ts->demux_and_play = GF_TRUE;
 	reader->ts->th = gf_th_new("MPEG-2 TS Demux");
 
 	reader->mx = gf_mx_new("MPEG2 Demux");
@@ -1656,7 +1656,7 @@ void DeleteM2TSReader(void *ifce)
 		gf_free(m2ts->network_buffer);
 	m2ts->network_buffer = NULL;
 	m2ts->network_buffer_size = 0;
-	m2ts->request_all_pids = 0;
+	m2ts->request_all_pids = GF_FALSE;
 	gf_m2ts_demux_del(m2ts->ts);
 	m2ts->ts = NULL;
 	gf_mx_del(m2ts->mx);

