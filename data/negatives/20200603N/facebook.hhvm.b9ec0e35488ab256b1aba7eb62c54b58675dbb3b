commit b9ec0e35488ab256b1aba7eb62c54b58675dbb3b
Author: mwilliams <mwilliams@fb.com>
Date:   Tue Oct 1 06:06:34 2013 -0700

    Make SrcDB more compact
    
    Add a GrowableVectorWrapper to make GrowableVector more
    compatible with vector, and use it in SrcRec.
    Use a CompactSizedPtr to hold the tca and tag for IncomingBranch.
    
    Reviewed By: @edwinsmith
    
    Differential Revision: D991310

diff --git a/hphp/runtime/vm/jit/srcdb.cpp b/hphp/runtime/vm/jit/srcdb.cpp
index 5caf076634..3ccc1f2127 100644
--- a/hphp/runtime/vm/jit/srcdb.cpp
+++ b/hphp/runtime/vm/jit/srcdb.cpp
@@ -148,7 +148,7 @@ void SrcRec::patchIncomingBranches(TCA newStart) {
 
   TRACE(1, "%zd incoming branches to rechain\n", m_incomingBranches.size());
 
-  vector<IncomingBranch>& change = m_incomingBranches;
+  auto& change = m_incomingBranches;
   for (unsigned i = 0; i < change.size(); ++i) {
     TRACE(1, "SrcRec(%p)::newTranslation rechaining @%p -> %p\n",
           this, change[i].toSmash(), newStart);
diff --git a/hphp/runtime/vm/jit/srcdb.h b/hphp/runtime/vm/jit/srcdb.h
index c646ca5176..40683e4663 100644
--- a/hphp/runtime/vm/jit/srcdb.h
+++ b/hphp/runtime/vm/jit/srcdb.h
@@ -28,6 +28,92 @@
 namespace HPHP {
 namespace Transl {
 
+/*
+ * GrowableVector --
+ *
+ * We make a large number of these, and they typically only have one entry.
+ * It's a shame to use a 24-byte std::vector for this.
+ *
+ * Only gets larger. Non-standard interface because we may realloc
+ * at push_back() time.
+ */
+template<typename T>
+struct GrowableVector {
+  uint32_t m_size;
+  T m_data[1]; // Actually variable length
+  GrowableVector() : m_size(0) { }
+  static GrowableVector* make() {
+    static_assert(boost::has_trivial_destructor<T>::value,
+                  "GrowableVector can only hold trivially destructible types");
+    auto mem = malloc(sizeof(GrowableVector));
+    return new (mem) GrowableVector;
+  }
+  size_t size() const {
+    return m_size;
+  }
+  T& operator[](const size_t idx) {
+    assert(idx < m_size);
+    return m_data[idx];
+  }
+  const T& operator[](const size_t idx) const {
+    assert(idx < m_size);
+    return m_data[idx];
+  }
+  GrowableVector* push_back(const T& datum) {
+    GrowableVector* gv;
+    // m_data always has room for at least one element due to the m_data[1]
+    // declaration, so the realloc() code first has to kick in when a second
+    // element is about to be pushed.
+    if (Util::isPowerOfTwo(m_size)) {
+      gv = (GrowableVector*)realloc(this,
+                                    offsetof(GrowableVector<T>, m_data) +
+                                    2 * m_size * sizeof(T));
+    } else {
+      gv = this;
+    }
+    gv->m_data[gv->m_size++] = datum;
+    return gv;
+  }
+};
+
+template<typename T>
+struct GrowableVectorWrapper {
+  GrowableVectorWrapper() : m_vec(nullptr) {}
+  size_t size() const {
+    return m_vec ? m_vec->size() : 0;
+  }
+  T& operator[](const size_t idx) {
+    assert(idx < size());
+    return m_vec->operator[](idx);
+  }
+  const T& operator[](const size_t idx) const {
+    assert(idx < size());
+    return m_vec->operator[](idx);
+  }
+  void push_back(const T& datum) {
+    if (!m_vec) {
+      m_vec = GrowableVector<T>::make();
+    }
+    m_vec = m_vec->push_back(datum);
+  }
+  void swap(GrowableVectorWrapper<T>& other) {
+    std::swap(m_vec, other.m_vec);
+  }
+  void clear() {
+    free(m_vec);
+    m_vec = nullptr;
+  }
+  bool empty() const {
+    return !m_vec;
+  }
+  T* begin() const { return m_vec ? &m_vec->operator[](0) : (T*)this; }
+  T* end() const {
+    return m_vec ? &m_vec->operator[](m_vec->size()) : (T*)this;
+  }
+private:
+  GrowableVector<T>* m_vec;
+};
+
 /*
  * Incoming branches between different translations are tracked using
  * this structure.
@@ -58,17 +144,19 @@ struct IncomingBranch {
     return IncomingBranch(Tag::ADDR, TCA(from));
   }
 
-  Tag type()        const { return m_type; }
-  TCA toSmash()     const { return m_toSmash; }
+  Tag type()        const { return static_cast<Tag>(m_ptr.size()); }
+  TCA toSmash()     const { return TCA(m_ptr.ptr()); }
 
 private:
-  explicit IncomingBranch(Tag type, TCA toSmash)
-    : m_type(type)
-    , m_toSmash(toSmash)
-  {}
+  explicit IncomingBranch(Tag type, TCA toSmash) {
+    m_ptr.set((uint32_t)type, toSmash);
+  }
+
+  /* needed to allow IncomingBranch to be put in a GrowableVector */
+  friend class GrowableVector<IncomingBranch>;
+  IncomingBranch() {}
 
-  Tag m_type;
-  TCA m_toSmash;
+  CompactSizedPtr<void> m_ptr;
 };
 
 /*
@@ -107,7 +195,7 @@ struct SrcRec {
   bool hasDebuggerGuard() const { return m_dbgBranchGuardSrc != nullptr; }
   const MD5& unitMd5() const { return m_unitMd5; }
 
-  const vector<TCA>& translations() const {
+  const GrowableVectorWrapper<TCA>& translations() const {
     return m_translations;
   }
 
@@ -121,11 +209,11 @@ struct SrcRec {
     m_anchorTranslation = anc;
   }
 
-  const vector<IncomingBranch>& inProgressTailJumps() const {
+  const GrowableVectorWrapper<IncomingBranch>& inProgressTailJumps() const {
     return m_inProgressTailJumps;
   }
 
-  const vector<IncomingBranch>& incomingBranches() const {
+  const GrowableVectorWrapper<IncomingBranch>& incomingBranches() const {
     return m_incomingBranches;
   }
 
@@ -153,58 +241,16 @@ private:
   // track all the fallback jumps from the "tail" translation so we
   // can rewrire them to new ones.
   TCA m_anchorTranslation;
-  vector<IncomingBranch> m_tailFallbackJumps;
-  vector<IncomingBranch> m_inProgressTailJumps;
+  GrowableVectorWrapper<IncomingBranch> m_tailFallbackJumps;
+  GrowableVectorWrapper<IncomingBranch> m_inProgressTailJumps;
 
-  vector<TCA> m_translations;
-  vector<IncomingBranch> m_incomingBranches;
+  GrowableVectorWrapper<TCA> m_translations;
+  GrowableVectorWrapper<IncomingBranch> m_incomingBranches;
   MD5 m_unitMd5;
   // The branch src for the debug guard, if this has one.
   TCA m_dbgBranchGuardSrc;
 };
 
-/*
- * GrowableVector --
- *
- * We make a large number of these, and they typically only have one entry.
- * It's a shame to use a 24-byte std::vector for this.
- *
- * Only gets larger. Non-standard interface because we may realloc
- * at push_back() time.
- */
-template<typename T>
-struct GrowableVector {
-  uint32_t m_size;
-  T m_data[1]; // Actually variable length
-  GrowableVector() : m_size(0) { }
-  size_t size() const {
-    return m_size;
-  }
-  T& operator[](const size_t idx) {
-    assert(idx < m_size);
-    return m_data[idx];
-  }
-  const T& operator[](const size_t idx) const {
-    assert(idx < m_size);
-    return m_data[idx];
-  }
-  GrowableVector* push_back(const T& datum) {
-    GrowableVector* gv;
-    // m_data always has room for at least one element due to the m_data[1]
-    // declaration, so the realloc() code first has to kick in when a second
-    // element is about to be pushed.
-    if (Util::isPowerOfTwo(m_size)) {
-      gv = (GrowableVector*)realloc(this,
-                                    offsetof(GrowableVector<T>, m_data) +
-                                    2 * m_size * sizeof(T));
-    } else {
-      gv = this;
-    }
-    gv->m_data[gv->m_size++] = datum;
-    return gv;
-  }
-};
-
 class SrcDB : boost::noncopyable {
   // SrcKeys that depend on a particular file go here.
   typedef hphp_hash_map<const Eval::PhpFile*,
diff --git a/hphp/runtime/vm/jit/trans-cfg.cpp b/hphp/runtime/vm/jit/trans-cfg.cpp
index 5a5432039e..d8d735a9b0 100644
--- a/hphp/runtime/vm/jit/trans-cfg.cpp
+++ b/hphp/runtime/vm/jit/trans-cfg.cpp
@@ -26,7 +26,7 @@ static TransIDSet findPredTrans(const SrcRec* sr,
   assert(sr);
   TransIDSet predSet;
 
-  for (auto inBr : sr->incomingBranches()) {
+  for (auto& inBr : sr->incomingBranches()) {
     TransID srcId = mapGet(jmpToTransID, inBr.toSmash(), InvalidID);
     FTRACE(5, "findPredTrans: toSmash = {}   srcId = {}\n",
            inBr.toSmash(), srcId);
diff --git a/hphp/runtime/vm/jit/translator-x64.cpp b/hphp/runtime/vm/jit/translator-x64.cpp
index c7658bc707..4d6ea6698b 100644
--- a/hphp/runtime/vm/jit/translator-x64.cpp
+++ b/hphp/runtime/vm/jit/translator-x64.cpp
@@ -414,7 +414,6 @@ TranslatorX64::createTranslation(const TranslArgs& args) {
   //   allow conditional jump fall-throughs
   TCA astart = mainCode.frontier();
   TCA stubstart = stubsCode.frontier();
-  Asm astubs { stubsCode };
   TCA req = emitServiceReq(stubsCode, JIT::REQ_RETRANSLATE, sk.offset());
   SKTRACE(1, sk, "inserting anchor translation for (%p,%d) at %p\n",
           sk.unit(), sk.offset(), req);
@@ -2173,7 +2172,7 @@ TranslatorX64::reachedTranslationLimit(SrcKey sk,
   if (srcRec.translations().size() == RuntimeOption::EvalJitMaxTranslations) {
     INC_TPC(max_trans);
     if (debug && Trace::moduleEnabled(Trace::tx64, 2)) {
-      const vector<TCA>& tns = srcRec.translations();
+      const auto& tns = srcRec.translations();
       TRACE(1, "Too many (%zd) translations: %s, BC offset %d\n",
             tns.size(), sk.unit()->filepath()->data(),
             sk.offset());

