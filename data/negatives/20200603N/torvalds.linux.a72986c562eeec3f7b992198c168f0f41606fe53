commit a72986c562eeec3f7b992198c168f0f41606fe53
Author: Mikulas Patocka <mpatocka@redhat.com>
Date:   Mon Jun 22 10:12:13 2009 +0100

    dm raid1: keep retrying alloc if mempool_alloc failed
    
    If the code can't handle allocation failures, use __GFP_NOFAIL so that
    in case of memory pressure the allocator will retry indefinitely and
    won't return NULL which would cause a crash in the function.
    
    This is still not a correct fix, it may cause a classic deadlock when
    memory manager waits for I/O being done and I/O waits for some free memory.
    I/O code shouldn't allocate any memory. But in this case it probably
    doesn't matter much in practice, people usually do not swap on RAID.
    
    Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
    Signed-off-by: Alasdair G Kergon <agk@redhat.com>

diff --git a/drivers/md/dm-region-hash.c b/drivers/md/dm-region-hash.c
index 7b899be0b087..36dbe29f2fd6 100644
--- a/drivers/md/dm-region-hash.c
+++ b/drivers/md/dm-region-hash.c
@@ -283,7 +283,7 @@ static struct dm_region *__rh_alloc(struct dm_region_hash *rh, region_t region)
 
 	nreg = mempool_alloc(rh->region_pool, GFP_ATOMIC);
 	if (unlikely(!nreg))
-		nreg = kmalloc(sizeof(*nreg), GFP_NOIO);
+		nreg = kmalloc(sizeof(*nreg), GFP_NOIO | __GFP_NOFAIL);
 
 	nreg->state = rh->log->type->in_sync(rh->log, region, 1) ?
 		      DM_RH_CLEAN : DM_RH_NOSYNC;

