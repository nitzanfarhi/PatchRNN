commit 789cbbeca4eb7141cbd748ee93772471101b507b
Author: Joe Lawrence <joe.lawrence@stratus.com>
Date:   Sun Oct 5 13:24:21 2014 -0400

    workqueue: Add quiescent state between work items
    
    Similar to the stop_machine deadlock scenario on !PREEMPT kernels
    addressed in b22ce2785d97 "workqueue: cond_resched() after processing
    each work item", kworker threads requeueing back-to-back with zero jiffy
    delay can stall RCU. The cond_resched call introduced in that fix will
    yield only iff there are other higher priority tasks to run, so force a
    quiescent RCU state between work items.
    
    Signed-off-by: Joe Lawrence <joe.lawrence@stratus.com>
    Link: https://lkml.kernel.org/r/20140926105227.01325697@jlaw-desktop.mno.stratus.com
    Link: https://lkml.kernel.org/r/20140929115445.40221d8e@jlaw-desktop.mno.stratus.com
    Fixes: b22ce2785d97 ("workqueue: cond_resched() after processing each work item")
    Cc: <stable@vger.kernel.org>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>

diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index 5dbe22aa3efd..345bec95e708 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -2043,8 +2043,10 @@ __acquires(&pool->lock)
 	 * kernels, where a requeueing work item waiting for something to
 	 * happen could deadlock with stop_machine as such work item could
 	 * indefinitely requeue itself while all other CPUs are trapped in
-	 * stop_machine.
+	 * stop_machine. At the same time, report a quiescent RCU state so
+	 * the same condition doesn't freeze RCU.
 	 */
+	rcu_note_voluntary_context_switch(current);
 	cond_resched();
 
 	spin_lock_irq(&pool->lock);

