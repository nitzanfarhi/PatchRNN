commit 0bc5013e3034b5d6a4d88800041899976e3d65d9
Author: John Esmet <esmet@tokutek.com>
Date:   Wed Apr 17 00:01:08 2013 -0400

    fixes #5423 fixes #5424 fixes #5503 fixes #5225 fsync always succeeds and returns void, no more ft panic or logger panic, no more impossible error paths
    
    
    git-svn-id: file:///svn/toku/tokudb@48076 c7de825b-a66e-492c-adef-691d508d4ae1

diff --git a/buildheader/make_tdb.cc b/buildheader/make_tdb.cc
index 9e88f0a4b2d..cb514c79150 100644
--- a/buildheader/make_tdb.cc
+++ b/buildheader/make_tdb.cc
@@ -696,21 +696,21 @@ int main (int argc, char *const argv[] __attribute__((__unused__))) {
     printf("const char *db_strerror(int) %s;\n", VISIBLE);
     printf("const char *db_version(int*,int *,int *) %s;\n", VISIBLE);
     printf("int log_compare (const DB_LSN*, const DB_LSN *) %s;\n", VISIBLE);
-    printf("int db_env_set_func_fsync (int (*)(int)) %s;\n", VISIBLE);
     printf("int toku_set_trace_file (const char *fname) %s;\n", VISIBLE);
     printf("int toku_close_trace_file (void) %s;\n", VISIBLE);
-    printf("int db_env_set_func_free (void (*)(void*)) %s;\n", VISIBLE);
-    printf("int db_env_set_func_malloc (void *(*)(size_t)) %s;\n", VISIBLE);
-    printf("int db_env_set_func_realloc (void *(*)(void*, size_t)) %s;\n", VISIBLE);
-    printf("int db_env_set_func_pwrite (ssize_t (*)(int, const void *, size_t, toku_off_t)) %s;\n", VISIBLE);
-    printf("int db_env_set_func_full_pwrite (ssize_t (*)(int, const void *, size_t, toku_off_t)) %s;\n", VISIBLE);
-    printf("int db_env_set_func_write (ssize_t (*)(int, const void *, size_t)) %s;\n", VISIBLE);
-    printf("int db_env_set_func_full_write (ssize_t (*)(int, const void *, size_t)) %s;\n", VISIBLE);
-    printf("int db_env_set_func_fdopen (FILE* (*)(int, const char *)) %s;\n", VISIBLE);
-    printf("int db_env_set_func_fopen (FILE* (*)(const char *, const char *)) %s;\n", VISIBLE);
-    printf("int db_env_set_func_open (int (*)(const char *, int, int)) %s;\n", VISIBLE);
-    printf("int db_env_set_func_fclose (int (*)(FILE*)) %s;\n", VISIBLE);
-    printf("int db_env_set_func_pread (ssize_t (*)(int, void *, size_t, off_t)) %s;\n", VISIBLE);
+    printf("void db_env_set_func_fsync (int (*)(int)) %s;\n", VISIBLE);
+    printf("void db_env_set_func_free (void (*)(void*)) %s;\n", VISIBLE);
+    printf("void db_env_set_func_malloc (void *(*)(size_t)) %s;\n", VISIBLE);
+    printf("void db_env_set_func_realloc (void *(*)(void*, size_t)) %s;\n", VISIBLE);
+    printf("void db_env_set_func_pwrite (ssize_t (*)(int, const void *, size_t, toku_off_t)) %s;\n", VISIBLE);
+    printf("void db_env_set_func_full_pwrite (ssize_t (*)(int, const void *, size_t, toku_off_t)) %s;\n", VISIBLE);
+    printf("void db_env_set_func_write (ssize_t (*)(int, const void *, size_t)) %s;\n", VISIBLE);
+    printf("void db_env_set_func_full_write (ssize_t (*)(int, const void *, size_t)) %s;\n", VISIBLE);
+    printf("void db_env_set_func_fdopen (FILE* (*)(int, const char *)) %s;\n", VISIBLE);
+    printf("void db_env_set_func_fopen (FILE* (*)(const char *, const char *)) %s;\n", VISIBLE);
+    printf("void db_env_set_func_open (int (*)(const char *, int, int)) %s;\n", VISIBLE);
+    printf("void db_env_set_func_fclose (int (*)(FILE*)) %s;\n", VISIBLE);
+    printf("void db_env_set_func_pread (ssize_t (*)(int, void *, size_t, off_t)) %s;\n", VISIBLE);
     printf("void db_env_set_func_loader_fwrite (size_t (*fwrite_fun)(const void*,size_t,size_t,FILE*)) %s;\n", VISIBLE);
     printf("void db_env_set_checkpoint_callback (void (*)(void*), void*) %s;\n", VISIBLE);
     printf("void db_env_set_checkpoint_callback2 (void (*)(void*), void*) %s;\n", VISIBLE);
diff --git a/ft/block_table.cc b/ft/block_table.cc
index c1449bea790..829f3bba6f3 100644
--- a/ft/block_table.cc
+++ b/ft/block_table.cc
@@ -365,16 +365,6 @@ toku_ft_unlock (FT ft) {
     unlock_for_blocktable(bt);
 }
 
-// This is a special debugging function used only in the brt-serialize-test.
-void
-toku_block_alloc(BLOCK_TABLE bt, uint64_t size, uint64_t *offset) {
-    lock_for_blocktable(bt);
-PRNTF("allocSomethingUnknown", 0L, (int64_t)size, 0L, bt);
-    block_allocator_alloc_block(bt->block_allocator, size, offset);
-PRNTF("allocSomethingUnknownd", 0L, (int64_t)size, (int64_t)*offset, bt);
-    unlock_for_blocktable(bt);
-}
-
 // Also used only in brt-serialize-test.
 void
 toku_block_free(BLOCK_TABLE bt, uint64_t offset) {
diff --git a/ft/block_table.h b/ft/block_table.h
index c7faa087ff8..588f9b913da 100644
--- a/ft/block_table.h
+++ b/ft/block_table.h
@@ -57,7 +57,6 @@ void toku_block_table_swap_for_redirect(BLOCK_TABLE old_bt, BLOCK_TABLE new_bt);
 //DEBUG ONLY (ftdump included), tests included
 void toku_blocknum_dump_translation(BLOCK_TABLE bt, BLOCKNUM b);
 void toku_dump_translation_table(FILE *f, BLOCK_TABLE bt);
-void toku_block_alloc(BLOCK_TABLE bt, uint64_t size, uint64_t *offset);
 void toku_block_free(BLOCK_TABLE bt, uint64_t offset);
 typedef int(*BLOCKTABLE_CALLBACK)(BLOCKNUM b, int64_t size, int64_t address, void *extra);
 enum translation_type {TRANSLATION_NONE=0,
diff --git a/ft/cachetable-internal.h b/ft/cachetable-internal.h
index bb748a9b7e7..d17b0022ba8 100644
--- a/ft/cachetable-internal.h
+++ b/ft/cachetable-internal.h
@@ -108,14 +108,14 @@ struct cachefile {
     char *fname_in_env; /* Used for logging */
 
     void *userdata;
-    int (*log_fassociate_during_checkpoint)(CACHEFILE cf, void *userdata); // When starting a checkpoint we must log all open files.
-    int (*log_suppress_rollback_during_checkpoint)(CACHEFILE cf, void *userdata); // When starting a checkpoint we must log which files need rollbacks suppressed
-    int (*close_userdata)(CACHEFILE cf, int fd, void *userdata, char **error_string, bool lsnvalid, LSN); // when closing the last reference to a cachefile, first call this function. 
-    int (*begin_checkpoint_userdata)(LSN lsn_of_checkpoint, void *userdata); // before checkpointing cachefiles call this function.
+    void (*log_fassociate_during_checkpoint)(CACHEFILE cf, void *userdata); // When starting a checkpoint we must log all open files.
+    void (*log_suppress_rollback_during_checkpoint)(CACHEFILE cf, void *userdata); // When starting a checkpoint we must log which files need rollbacks suppressed
+    int (*close_userdata)(CACHEFILE cf, int fd, void *userdata, bool lsnvalid, LSN); // when closing the last reference to a cachefile, first call this function. 
+    void (*begin_checkpoint_userdata)(LSN lsn_of_checkpoint, void *userdata); // before checkpointing cachefiles call this function.
     int (*checkpoint_userdata)(CACHEFILE cf, int fd, void *userdata); // when checkpointing a cachefile, call this function.
-    int (*end_checkpoint_userdata)(CACHEFILE cf, int fd, void *userdata); // after checkpointing cachefiles call this function.
-    int (*note_pin_by_checkpoint)(CACHEFILE cf, void *userdata); // add a reference to the userdata to prevent it from being removed from memory
-    int (*note_unpin_by_checkpoint)(CACHEFILE cf, void *userdata); // add a reference to the userdata to prevent it from being removed from memory
+    void (*end_checkpoint_userdata)(CACHEFILE cf, int fd, void *userdata); // after checkpointing cachefiles call this function.
+    void (*note_pin_by_checkpoint)(CACHEFILE cf, void *userdata); // add a reference to the userdata to prevent it from being removed from memory
+    void (*note_unpin_by_checkpoint)(CACHEFILE cf, void *userdata); // add a reference to the userdata to prevent it from being removed from memory
     BACKGROUND_JOB_MANAGER bjm;
 };
 
@@ -262,7 +262,7 @@ class pair_list {
     toku_pthread_rwlock_t m_pending_lock_expensive;
     toku_pthread_rwlock_t m_pending_lock_cheap;
     void init();
-    int destroy();
+    void destroy();
     void evict(PAIR pair);
     void put(PAIR pair);
     PAIR find_pair(CACHEFILE file, CACHEKEY key, uint32_t hash);
@@ -317,14 +317,14 @@ class checkpointer {
 public:
     void init(pair_list *_pl, TOKULOGGER _logger, evictor *_ev, cachefile_list *files);
     void destroy();
-    int set_checkpoint_period(uint32_t new_period);
+    void set_checkpoint_period(uint32_t new_period);
     uint32_t get_checkpoint_period();
     int shutdown();
     bool has_been_shutdown();
-    int begin_checkpoint();
+    void begin_checkpoint();
     void add_background_job();
     void remove_background_job();
-    int end_checkpoint(void (*testcallback_f)(void*),  void* testextra);
+    void end_checkpoint(void (*testcallback_f)(void*),  void* testextra);
     TOKULOGGER get_logger();
     // used during begin_checkpoint
     void increment_num_txns();
@@ -351,7 +351,7 @@ class checkpointer {
     void checkpoint_userdata(CACHEFILE* checkpoint_cfs);
     void log_end_checkpoint();
     void end_checkpoint_userdata(CACHEFILE* checkpoint_cfs);
-    int remove_cachefiles(CACHEFILE* checkpoint_cfs);
+    void remove_cachefiles(CACHEFILE* checkpoint_cfs);
     
     // Unit test struct needs access to private members.
     friend struct checkpointer_test;
diff --git a/ft/cachetable.cc b/ft/cachetable.cc
index 6edf0d8bae8..b616a3caf89 100644
--- a/ft/cachetable.cc
+++ b/ft/cachetable.cc
@@ -151,8 +151,8 @@ checkpoint_thread (void *checkpointer_v)
     return r;
 }
 
-int toku_set_checkpoint_period (CACHETABLE ct, uint32_t new_period) {
-    return ct->cp.set_checkpoint_period(new_period);
+void toku_set_checkpoint_period (CACHETABLE ct, uint32_t new_period) {
+    ct->cp.set_checkpoint_period(new_period);
 }
 
 uint32_t toku_get_checkpoint_period (CACHETABLE ct) {
@@ -163,9 +163,8 @@ uint32_t toku_get_checkpoint_period_unlocked (CACHETABLE ct) {
     return ct->cp.get_checkpoint_period();
 }
 
-int toku_set_cleaner_period (CACHETABLE ct, uint32_t new_period) {
+void toku_set_cleaner_period (CACHETABLE ct, uint32_t new_period) {
     ct->cl.set_period(new_period);
-    return 0;
 }
 
 uint32_t toku_get_cleaner_period (CACHETABLE ct) {
@@ -176,9 +175,8 @@ uint32_t toku_get_cleaner_period_unlocked (CACHETABLE ct) {
     return ct->cl.get_period_unlocked();
 }
 
-int toku_set_cleaner_iterations (CACHETABLE ct, uint32_t new_iterations) {
+void toku_set_cleaner_iterations (CACHETABLE ct, uint32_t new_iterations) {
     ct->cl.set_iterations(new_iterations);
-    return 0;
 }
 
 uint32_t toku_get_cleaner_iterations (CACHETABLE ct) {
@@ -192,14 +190,12 @@ uint32_t toku_get_cleaner_iterations_unlocked (CACHETABLE ct) {
 // reserve 25% as "unreservable".  The loader cannot have it.
 #define unreservable_memory(size) ((size)/4)
 
-int toku_create_cachetable(CACHETABLE *result, long size_limit, LSN UU(initial_lsn), TOKULOGGER logger) {
+void toku_cachetable_create(CACHETABLE *result, long size_limit, LSN UU(initial_lsn), TOKULOGGER logger) {
     if (size_limit == 0) {
         size_limit = 128*1024*1024;
     }
-    CACHETABLE MALLOC(ct);
-    if (ct == 0) return ENOMEM;
-    memset(ct, 0, sizeof(*ct));
 
+    CACHETABLE XCALLOC(ct);
     ct->list.init();
     ct->cf_list.init();
 
@@ -214,7 +210,6 @@ int toku_create_cachetable(CACHETABLE *result, long size_limit, LSN UU(initial_l
     ct->cl.init(1, &ct->list, ct); // by default, start with one iteration
     ct->env_dir = toku_xstrdup(".");
     *result = ct;
-    return 0;
 }
 
 // Returns a pointer to the checkpoint contained within
@@ -393,7 +388,7 @@ int toku_cachefile_set_fd (CACHEFILE cf, int fd, const char *fname_in_env) {
     if (r != 0) { 
         r=get_error_errno(); close(fd); goto cleanup; // no change for t:2444
     }
-    if (cf->close_userdata && (r = cf->close_userdata(cf, cf->fd, cf->userdata, 0, false, ZERO_LSN))) {
+    if (cf->close_userdata && (r = cf->close_userdata(cf, cf->fd, cf->userdata, false, ZERO_LSN))) {
         goto cleanup;
     }
     cf->close_userdata = NULL;
@@ -445,7 +440,7 @@ static void remove_cf_from_cachefiles_list (CACHEFILE cf) {
 
 // TODO: (Zardosht) review locking of this function carefully in code review
 int 
-toku_cachefile_close(CACHEFILE *cfp, char **error_string, bool oplsn_valid, LSN oplsn) {
+toku_cachefile_close(CACHEFILE *cfp, bool oplsn_valid, LSN oplsn) {
     int r, close_error = 0;
     CACHEFILE cf = *cfp;
     CACHETABLE ct = cf->cachetable;
@@ -463,7 +458,7 @@ toku_cachefile_close(CACHEFILE *cfp, char **error_string, bool oplsn_valid, LSN
     // Call the close userdata callback to notify the client this cachefile
     // and its underlying file are going to be closed
     if (cf->close_userdata) {
-        close_error = cf->close_userdata(cf, cf->fd, cf->userdata, error_string, oplsn_valid, oplsn);
+        close_error = cf->close_userdata(cf, cf->fd, cf->userdata, oplsn_valid, oplsn);
     }
 
     remove_cf_from_cachefiles_list(cf);
@@ -471,8 +466,7 @@ toku_cachefile_close(CACHEFILE *cfp, char **error_string, bool oplsn_valid, LSN
     cf->bjm = NULL;
 
     // fsync and close the fd. 
-    r = toku_file_fsync_without_accounting(cf->fd);
-    assert(r == 0);   
+    toku_file_fsync_without_accounting(cf->fd);
     r = close(cf->fd);
     assert(r == 0);
 
@@ -499,11 +493,10 @@ toku_cachefile_close(CACHEFILE *cfp, char **error_string, bool oplsn_valid, LSN
 // while this function is called, no other thread does work on the 
 // cachefile.
 //
-int toku_cachefile_flush (CACHEFILE cf) {
+void toku_cachefile_flush (CACHEFILE cf) {
     bjm_wait_for_jobs_to_finish(cf->bjm);
     CACHETABLE ct = cf->cachetable;
     cachetable_flush_cachefile(ct, cf);
-    return 0;
 }
 
 // This hash function comes from Jenkins:  http://burtleburtle.net/bob/c/lookup3.c
@@ -825,37 +818,23 @@ static PAIR cachetable_insert_at(CACHETABLE ct,
 //
 // Requires pair list's write lock to be held on entry
 //
-static int cachetable_put_internal(
+static void cachetable_put_internal(
     CACHEFILE cachefile, 
     CACHEKEY key, 
     uint32_t fullhash, 
-    void*value, 
+    void *value, 
     PAIR_ATTR attr,
     CACHETABLE_WRITE_CALLBACK write_callback,
     CACHETABLE_PUT_CALLBACK put_callback
     )
 {
     CACHETABLE ct = cachefile->cachetable;
-    {
-        PAIR p = ct->list.find_pair(cachefile, key, fullhash);
-        if (p != NULL) {
-            // Ideally, we would like to just assert(false) here
-            // and not return an error, but as of Dr. Noga,
-            // cachetable-test2 depends on this behavior.
-            // To replace the following with an assert(false)
-            // we need to change the behavior of cachetable-test2
-            //
-            // Semantically, these two asserts are not strictly right.  After all, when are two functions eq?
-            // In practice, the functions better be the same.
-            assert(p->flush_callback == write_callback.flush_callback);
-            assert(p->pe_callback == write_callback.pe_callback);
-            assert(p->cleaner_callback == write_callback.cleaner_callback);
-            return -1; /* Already present, don't grab lock. */
-        }
-    }
+    PAIR p = ct->list.find_pair(cachefile, key, fullhash);
+    invariant_null(p);
+
     // flushing could change the table size, but wont' change the fullhash
     cachetable_puts++;
-    PAIR p = cachetable_insert_at(
+    p = cachetable_insert_at(
         ct, 
         cachefile, 
         key, 
@@ -872,7 +851,6 @@ static int cachetable_put_internal(
     //note_hash_count(count);
     invariant_notnull(put_callback);
     put_callback(value, p);
-    return 0;
 }
 
 // Pair mutex (p->mutex) is may or may not be held on entry,
@@ -1090,10 +1068,10 @@ static void get_pairs(
     }
 }
 
-int toku_cachetable_put_with_dep_pairs(
+void toku_cachetable_put_with_dep_pairs(
     CACHEFILE cachefile, 
     CACHETABLE_GET_KEY_AND_FULLHASH get_key_and_fullhash,
-    void*value, 
+    void *value, 
     PAIR_ATTR attr,
     CACHETABLE_WRITE_CALLBACK write_callback,
     void *get_key_and_fullhash_extra,
@@ -1117,54 +1095,49 @@ int toku_cachetable_put_with_dep_pairs(
     if (ct->ev.should_client_wake_eviction_thread()) {
         ct->ev.signal_eviction_thread();
     }
-    int rval;
-    {
-        ct->list.write_list_lock();
-        get_key_and_fullhash(key, fullhash, get_key_and_fullhash_extra);
-        rval = cachetable_put_internal(
-            cachefile,
-            *key,
-            *fullhash,
-            value,
-            attr,
-            write_callback,
-            put_callback
-            );
-        PAIR dependent_pairs[num_dependent_pairs];
-        get_pairs(
-            &ct->list,
-            num_dependent_pairs,
-            dependent_cfs,
-            dependent_keys,
-            dependent_fullhash,
-            dependent_pairs
-            );
-        bool checkpoint_pending[num_dependent_pairs];
-        ct->list.write_pending_cheap_lock();
-        for (uint32_t i = 0; i < num_dependent_pairs; i++) {
-            checkpoint_pending[i] = dependent_pairs[i]->checkpoint_pending;
-            dependent_pairs[i]->checkpoint_pending = false;
-        }
-        ct->list.write_pending_cheap_unlock();
-        ct->list.write_list_unlock();
-
-        //
-        // now that we have inserted the row, let's checkpoint the 
-        // dependent nodes, if they need checkpointing
-        //
-        checkpoint_dependent_pairs(
-            ct,
-            num_dependent_pairs,
-            dependent_pairs,
-            checkpoint_pending,
-            dependent_dirty
-            );
+    ct->list.write_list_lock();
+    get_key_and_fullhash(key, fullhash, get_key_and_fullhash_extra);
+    cachetable_put_internal(
+        cachefile,
+        *key,
+        *fullhash,
+        value,
+        attr,
+        write_callback,
+        put_callback
+        );
+    PAIR dependent_pairs[num_dependent_pairs];
+    get_pairs(
+        &ct->list,
+        num_dependent_pairs,
+        dependent_cfs,
+        dependent_keys,
+        dependent_fullhash,
+        dependent_pairs
+        );
+    bool checkpoint_pending[num_dependent_pairs];
+    ct->list.write_pending_cheap_lock();
+    for (uint32_t i = 0; i < num_dependent_pairs; i++) {
+        checkpoint_pending[i] = dependent_pairs[i]->checkpoint_pending;
+        dependent_pairs[i]->checkpoint_pending = false;
     }
-    return rval;
-}
+    ct->list.write_pending_cheap_unlock();
+    ct->list.write_list_unlock();
 
+    //
+    // now that we have inserted the row, let's checkpoint the 
+    // dependent nodes, if they need checkpointing
+    //
+    checkpoint_dependent_pairs(
+        ct,
+        num_dependent_pairs,
+        dependent_pairs,
+        checkpoint_pending,
+        dependent_dirty
+        );
+}
 
-int toku_cachetable_put(CACHEFILE cachefile, CACHEKEY key, uint32_t fullhash, void*value, PAIR_ATTR attr,
+void toku_cachetable_put(CACHEFILE cachefile, CACHEKEY key, uint32_t fullhash, void*value, PAIR_ATTR attr,
                         CACHETABLE_WRITE_CALLBACK write_callback,
                         CACHETABLE_PUT_CALLBACK put_callback
                         ) {
@@ -1176,7 +1149,7 @@ int toku_cachetable_put(CACHEFILE cachefile, CACHEKEY key, uint32_t fullhash, vo
         ct->ev.signal_eviction_thread();
     }
     ct->list.write_list_lock();
-    int r = cachetable_put_internal(
+    cachetable_put_internal(
         cachefile,
         key,
         fullhash,
@@ -1186,7 +1159,6 @@ int toku_cachetable_put(CACHEFILE cachefile, CACHEKEY key, uint32_t fullhash, vo
         put_callback
         );
     ct->list.write_list_unlock();
-    return r;
 }
 
 static uint64_t get_tnow(void) {
@@ -2560,21 +2532,14 @@ toku_cachetable_minicron_shutdown(CACHETABLE ct) {
     ct->cl.destroy();
 }
 
-/* Require that it all be flushed. */
-int 
-toku_cachetable_close (CACHETABLE *ctp) {
-    int r = 0;
-    CACHETABLE ct=*ctp;
+/* Requires that it all be flushed. */
+void toku_cachetable_close (CACHETABLE *ctp) {
+    CACHETABLE ct = *ctp;
     ct->cp.destroy();
     ct->cl.destroy();
     cachetable_flush_cachefile(ct, NULL);
     ct->ev.destroy();
-    r = ct->list.destroy();
-    if (r != 0) {
-        // This means that there were still pairs in the
-        // pair list, which is bad.
-        return -1;
-    }
+    ct->list.destroy();
     ct->cf_list.destroy();
     
     toku_kibbutz_destroy(ct->client_kibbutz);
@@ -2583,7 +2548,6 @@ toku_cachetable_close (CACHETABLE *ctp) {
     toku_free(ct->env_dir);
     toku_free(ct);
     *ctp = 0;
-    return 0;
 }
 
 static PAIR test_get_pair(CACHEFILE cachefile, CACHEKEY key, uint32_t fullhash, bool have_ct_lock) {
@@ -2775,35 +2739,33 @@ int log_open_txn (const TOKUTXN &txn, const uint32_t UU(index), checkpointer * c
     invariant(r==0);
     switch (toku_txn_get_state(txn)) {
     case TOKUTXN_LIVE:{
-        r = toku_log_xstillopen(logger, NULL, 0, txn,
-                                toku_txn_get_txnid(txn),
-                                toku_txn_get_txnid(toku_logger_txn_parent(txn)),
-                                txn->roll_info.rollentry_raw_count,
-                                open_filenums,
-                                txn->force_fsync_on_commit,
-                                txn->roll_info.num_rollback_nodes,
-                                txn->roll_info.num_rollentries,
-                                txn->roll_info.spilled_rollback_head,
-                                txn->roll_info.spilled_rollback_tail,
-                                txn->roll_info.current_rollback);
-        lazy_assert_zero(r);
+        toku_log_xstillopen(logger, NULL, 0, txn,
+                            toku_txn_get_txnid(txn),
+                            toku_txn_get_txnid(toku_logger_txn_parent(txn)),
+                            txn->roll_info.rollentry_raw_count,
+                            open_filenums,
+                            txn->force_fsync_on_commit,
+                            txn->roll_info.num_rollback_nodes,
+                            txn->roll_info.num_rollentries,
+                            txn->roll_info.spilled_rollback_head,
+                            txn->roll_info.spilled_rollback_tail,
+                            txn->roll_info.current_rollback);
         goto cleanup;
     }
     case TOKUTXN_PREPARING: {
         TOKU_XA_XID xa_xid;
         toku_txn_get_prepared_xa_xid(txn, &xa_xid);
-        r = toku_log_xstillopenprepared(logger, NULL, 0, txn,
-                                        toku_txn_get_txnid(txn),
-                                        &xa_xid,
-                                        txn->roll_info.rollentry_raw_count,
-                                        open_filenums,
-                                        txn->force_fsync_on_commit,
-                                        txn->roll_info.num_rollback_nodes,
-                                        txn->roll_info.num_rollentries,
-                                        txn->roll_info.spilled_rollback_head,
-                                        txn->roll_info.spilled_rollback_tail,
-                                        txn->roll_info.current_rollback);
-        lazy_assert_zero(r);
+        toku_log_xstillopenprepared(logger, NULL, 0, txn,
+                                    toku_txn_get_txnid(txn),
+                                    &xa_xid,
+                                    txn->roll_info.rollentry_raw_count,
+                                    open_filenums,
+                                    txn->force_fsync_on_commit,
+                                    txn->roll_info.num_rollback_nodes,
+                                    txn->roll_info.num_rollentries,
+                                    txn->roll_info.spilled_rollback_head,
+                                    txn->roll_info.spilled_rollback_tail,
+                                    txn->roll_info.current_rollback);
         goto cleanup;
     }
     case TOKUTXN_RETIRED:
@@ -2823,9 +2785,8 @@ int log_open_txn (const TOKUTXN &txn, const uint32_t UU(index), checkpointer * c
 //             Use the begin_checkpoint callback to take necessary snapshots (header, btt)
 //             Mark every dirty node as "pending."  ("Pending" means that the node must be
 //                                                    written to disk before it can be modified.)
-int
-toku_cachetable_begin_checkpoint (CHECKPOINTER cp, TOKULOGGER UU(logger)) {    
-    return cp->begin_checkpoint();
+void toku_cachetable_begin_checkpoint (CHECKPOINTER cp, TOKULOGGER UU(logger)) {    
+    cp->begin_checkpoint();
 }
 
 
@@ -2843,10 +2804,9 @@ int toku_cachetable_get_checkpointing_user_data_status (void) {
 //             Use checkpoint callback to write snapshot information to disk (header, btt)
 //             Use end_checkpoint callback to fsync dictionary and log, and to free unused blocks
 // Note:       If testcallback is null (for testing purposes only), call it after writing dictionary but before writing log
-int
-toku_cachetable_end_checkpoint(CHECKPOINTER cp, TOKULOGGER UU(logger),
+void toku_cachetable_end_checkpoint(CHECKPOINTER cp, TOKULOGGER UU(logger),
                                void (*testcallback_f)(void*),  void* testextra) {
-    return cp->end_checkpoint(testcallback_f, testextra);
+    cp->end_checkpoint(testcallback_f, testextra);
 }
 
 TOKULOGGER toku_cachefile_logger (CACHEFILE cf) {
@@ -2958,14 +2918,14 @@ int toku_cachetable_get_key_state (CACHETABLE ct, CACHEKEY key, CACHEFILE cf, vo
 void
 toku_cachefile_set_userdata (CACHEFILE cf,
                              void *userdata,
-                             int (*log_fassociate_during_checkpoint)(CACHEFILE, void*),
-                             int (*log_suppress_rollback_during_checkpoint)(CACHEFILE, void*),
-                             int (*close_userdata)(CACHEFILE, int, void*, char**, bool, LSN),
+                             void (*log_fassociate_during_checkpoint)(CACHEFILE, void*),
+                             void (*log_suppress_rollback_during_checkpoint)(CACHEFILE, void*),
+                             int (*close_userdata)(CACHEFILE, int, void*, bool, LSN),
                              int (*checkpoint_userdata)(CACHEFILE, int, void*),
-                             int (*begin_checkpoint_userdata)(LSN, void*),
-                             int (*end_checkpoint_userdata)(CACHEFILE, int, void*),
-                             int (*note_pin_by_checkpoint)(CACHEFILE, void*),
-                             int (*note_unpin_by_checkpoint)(CACHEFILE, void*)) {
+                             void (*begin_checkpoint_userdata)(LSN, void*),
+                             void (*end_checkpoint_userdata)(CACHEFILE, int, void*),
+                             void (*note_pin_by_checkpoint)(CACHEFILE, void*),
+                             void (*note_unpin_by_checkpoint)(CACHEFILE, void*)) {
     cf->userdata = userdata;
     cf->log_fassociate_during_checkpoint = log_fassociate_during_checkpoint;
     cf->log_suppress_rollback_during_checkpoint = log_suppress_rollback_during_checkpoint;
@@ -2988,23 +2948,18 @@ toku_cachefile_get_cachetable(CACHEFILE cf) {
 
 //Only called by ft_end_checkpoint
 //Must have access to cf->fd (must be protected)
-int
-toku_cachefile_fsync(CACHEFILE cf) {
-    int r;
-    r = toku_file_fsync(cf->fd);
-    return r;
+void toku_cachefile_fsync(CACHEFILE cf) {
+    toku_file_fsync(cf->fd);
 }
 
 // Make it so when the cachefile closes, the underlying file is unlinked
-void 
-toku_cachefile_unlink_on_close(CACHEFILE cf) {
+void toku_cachefile_unlink_on_close(CACHEFILE cf) {
     assert(!cf->unlink_on_close);
     cf->unlink_on_close = true;
 }
 
 // is this cachefile marked as unlink on close?
-bool 
-toku_cachefile_is_unlink_on_close(CACHEFILE cf) {
+bool toku_cachefile_is_unlink_on_close(CACHEFILE cf) {
     return cf->unlink_on_close;
 }
 
@@ -3105,8 +3060,7 @@ uint32_t cleaner::get_period_unlocked(void) {
 }
 
 void cleaner::set_period(uint32_t new_period) {
-    int r = toku_minicron_change_period(&m_cleaner_cron, new_period);
-    assert_zero(r);
+    toku_minicron_change_period(&m_cleaner_cron, new_period);
 }
 
 // Effect:  runs a cleaner.
@@ -3274,18 +3228,15 @@ void pair_list::init() {
 // Frees the pair_list hash table.  It is expected to be empty by
 // the time this is called.  Returns an error if there are any
 // pairs in any of the hash table slots.
-int pair_list::destroy() {
+void pair_list::destroy() {
     // Check if any entries exist in the hash table.
     for (uint32_t i = 0; i < m_table_size; ++i) {
-        if (m_table[i]) {
-            return -1;
-        }
+        invariant_null(m_table[i]);
     }
     toku_pthread_rwlock_destroy(&m_list_lock);    
     toku_pthread_rwlock_destroy(&m_pending_lock_expensive);    
     toku_pthread_rwlock_destroy(&m_pending_lock_cheap);    
     toku_free(m_table);
-    return 0;
 }
 
 // This places the given pair inside of the pair list.
@@ -4206,8 +4157,8 @@ void checkpointer::destroy() {
 //
 // Sets how often the checkpoint thread will run.
 //
-int checkpointer::set_checkpoint_period(uint32_t new_period) {
-    return toku_minicron_change_period(&m_checkpointer_cron, new_period);
+void checkpointer::set_checkpoint_period(uint32_t new_period) {
+    toku_minicron_change_period(&m_checkpointer_cron, new_period);
 }
 
 //
@@ -4243,14 +4194,12 @@ void checkpointer::increment_num_txns() {
 // Update the user data in any cachefiles in our checkpoint list.
 //
 void checkpointer::update_cachefiles() {
-    int r = 0;
     CACHEFILE cf;
     for(cf = m_cf_list->m_head; cf; cf=cf->next) {
         assert(cf->begin_checkpoint_userdata);
         if (cf->for_checkpoint) {
-            r = cf->begin_checkpoint_userdata(m_lsn_of_checkpoint_in_progress,
+            cf->begin_checkpoint_userdata(m_lsn_of_checkpoint_in_progress,
                                               cf->userdata);
-            assert(r == 0);
         }
     }
 }
@@ -4258,9 +4207,8 @@ void checkpointer::update_cachefiles() {
 //
 // Sets up and kicks off a checkpoint.
 //
-int checkpointer::begin_checkpoint() {
+void checkpointer::begin_checkpoint() {
     // 1. Initialize the accountability counters.
-    int r = 0;
     m_checkpoint_num_files = 0;
     m_checkpoint_num_txns = 0;
     
@@ -4275,8 +4223,7 @@ int checkpointer::begin_checkpoint() {
         // Putting this check here so that this method may be called
         // by cachetable tests.
         assert(cf->note_pin_by_checkpoint);
-        r = cf->note_pin_by_checkpoint(cf, cf->userdata);
-        assert(r == 0);
+        cf->note_pin_by_checkpoint(cf, cf->userdata);
         cf->for_checkpoint = true;
         m_checkpoint_num_files++;
     }
@@ -4302,7 +4249,6 @@ int checkpointer::begin_checkpoint() {
     m_cf_list->read_unlock();
     m_list->read_list_unlock();
     m_list->write_pending_exp_unlock();
-    return r;
 }
 
 //
@@ -4324,15 +4270,13 @@ void checkpointer::log_begin_checkpoint() {
     LSN begin_lsn={ .lsn = (uint64_t) -1 }; // we'll need to store the lsn of the checkpoint begin in all the trees that are checkpointed.
     TXN_MANAGER mgr = toku_logger_get_txn_manager(m_logger);
     TXNID last_xid = toku_txn_manager_get_last_xid(mgr);
-    r = toku_log_begin_checkpoint(m_logger, &begin_lsn, 0, 0, last_xid);
-    assert(r==0);
+    toku_log_begin_checkpoint(m_logger, &begin_lsn, 0, 0, last_xid);
     m_lsn_of_checkpoint_in_progress = begin_lsn;
     
     // Log the list of open dictionaries.
     for (CACHEFILE cf = m_cf_list->m_head; cf; cf = cf->next) {
         assert(cf->log_fassociate_during_checkpoint);
-        r = cf->log_fassociate_during_checkpoint(cf, cf->userdata);
-        assert(r == 0);
+        cf->log_fassociate_during_checkpoint(cf, cf->userdata);
     }
     
     // Write open transactions to the log.
@@ -4345,8 +4289,7 @@ void checkpointer::log_begin_checkpoint() {
     // rollback logs suppressed.
     for (CACHEFILE cf = m_cf_list->m_head; cf; cf = cf->next) {
         assert(cf->log_suppress_rollback_during_checkpoint);
-        r = cf->log_suppress_rollback_during_checkpoint(cf, cf->userdata);
-        assert(r == 0);
+        cf->log_suppress_rollback_during_checkpoint(cf, cf->userdata);
     }
 }
 
@@ -4396,8 +4339,7 @@ void checkpointer::remove_background_job() {
     bjm_remove_background_job(m_checkpoint_clones_bjm);
 }
 
-int checkpointer::end_checkpoint(void (*testcallback_f)(void*),  void* testextra) {
-    int r = 0;
+void checkpointer::end_checkpoint(void (*testcallback_f)(void*),  void* testextra) {
     CACHEFILE *XMALLOC_N(m_checkpoint_num_files, checkpoint_cfs);
 
     this->fill_checkpoint_cfs(checkpoint_cfs);    
@@ -4411,9 +4353,8 @@ int checkpointer::end_checkpoint(void (*testcallback_f)(void*),  void* testextra
     this->end_checkpoint_userdata(checkpoint_cfs);
 
     //Delete list of cachefiles in the checkpoint,
-    r = this->remove_cachefiles(checkpoint_cfs);
+    this->remove_cachefiles(checkpoint_cfs);
     toku_free(checkpoint_cfs);
-    return r;
 }
 
 void checkpointer::fill_checkpoint_cfs(CACHEFILE* checkpoint_cfs) {
@@ -4464,13 +4405,12 @@ void checkpointer::checkpoint_userdata(CACHEFILE* checkpoint_cfs) {
 
 void checkpointer::log_end_checkpoint() {
     if (m_logger) {
-        int r = toku_log_end_checkpoint(m_logger, NULL,
-                                        1, // want the end_checkpoint to be fsync'd
-                                        m_lsn_of_checkpoint_in_progress, 
-                                        0,
-                                        m_checkpoint_num_files,
-                                        m_checkpoint_num_txns);
-        assert(r==0);
+        toku_log_end_checkpoint(m_logger, NULL,
+                                1, // want the end_checkpoint to be fsync'd
+                                m_lsn_of_checkpoint_in_progress, 
+                                0,
+                                m_checkpoint_num_files,
+                                m_checkpoint_num_txns);
         toku_logger_note_checkpoint(m_logger, m_lsn_of_checkpoint_in_progress);
     }
 }
@@ -4484,16 +4424,14 @@ void checkpointer::end_checkpoint_userdata(CACHEFILE* checkpoint_cfs) {
         CACHEFILE cf = checkpoint_cfs[i];
         assert(cf->for_checkpoint);
         assert(cf->end_checkpoint_userdata);
-        int r = cf->end_checkpoint_userdata(cf, cf->fd, cf->userdata);
-        assert(r==0);
+        cf->end_checkpoint_userdata(cf, cf->fd, cf->userdata);
     }
 }
 
 //
 // Deletes all the cachefiles in this checkpointers cachefile list. 
 //
-int checkpointer::remove_cachefiles(CACHEFILE* checkpoint_cfs) {
-    int r = 0;
+void checkpointer::remove_cachefiles(CACHEFILE* checkpoint_cfs) {
     // making this a while loop because note_unpin_by_checkpoint may destroy the cachefile
     for (uint32_t i = 0; i < m_checkpoint_num_files; i++) {
         CACHEFILE cf = checkpoint_cfs[i];
@@ -4503,12 +4441,8 @@ int checkpointer::remove_cachefiles(CACHEFILE* checkpoint_cfs) {
         cf->for_checkpoint = false;
         assert(cf->note_unpin_by_checkpoint);
         // Clear the bit saying theis file is in the checkpoint.
-        r = cf->note_unpin_by_checkpoint(cf, cf->userdata);
-        if (r != 0) {
-            return r;
-        }
+        cf->note_unpin_by_checkpoint(cf, cf->userdata);
     }
-    return r;
 }
 
 
diff --git a/ft/cachetable.h b/ft/cachetable.h
index 8fcd6c41c06..25a6e17a362 100644
--- a/ft/cachetable.h
+++ b/ft/cachetable.h
@@ -11,7 +11,6 @@
 #include "fttypes.h"
 #include "minicron.h"
 
-
 // Maintain a cache mapping from cachekeys to values (void*)
 // Some of the keys can be pinned.  Don't pin too many or for too long.
 // If the cachetable is too full, it will call the flush_callback() function with the key, the value, and the otherargs
@@ -27,10 +26,10 @@
 
 typedef BLOCKNUM CACHEKEY;
 
-int toku_set_cleaner_period (CACHETABLE ct, uint32_t new_period);
+void toku_set_cleaner_period (CACHETABLE ct, uint32_t new_period);
 uint32_t toku_get_cleaner_period (CACHETABLE ct);
 uint32_t toku_get_cleaner_period_unlocked (CACHETABLE ct);
-int toku_set_cleaner_iterations (CACHETABLE ct, uint32_t new_iterations);
+void toku_set_cleaner_iterations (CACHETABLE ct, uint32_t new_iterations);
 uint32_t toku_get_cleaner_iterations (CACHETABLE ct);
 uint32_t toku_get_cleaner_iterations_unlocked (CACHETABLE ct);
 
@@ -39,7 +38,7 @@ uint32_t toku_get_cleaner_iterations_unlocked (CACHETABLE ct);
 // create and initialize a cache table
 // size_limit is the upper limit on the size of the size of the values in the table
 // pass 0 if you want the default
-int toku_create_cachetable(CACHETABLE *result, long size_limit, LSN initial_lsn, TOKULOGGER);
+void toku_cachetable_create(CACHETABLE *result, long size_limit, LSN initial_lsn, TOKULOGGER);
 
 // Create a new cachetable.
 // Effects: a new cachetable is created and initialized.
@@ -62,11 +61,11 @@ int toku_cachefile_of_iname_in_env (CACHETABLE ct, const char *iname_in_env, CAC
 
 // Get the iname (within the cwd) associated with the cachefile
 // Return the filename
-char * toku_cachefile_fname_in_cwd (CACHEFILE cf);
+char *toku_cachefile_fname_in_cwd (CACHEFILE cf);
+
+void toku_cachetable_begin_checkpoint (CHECKPOINTER cp, TOKULOGGER);
 
-// TODO: #1510  Add comments on how these behave
-int toku_cachetable_begin_checkpoint (CHECKPOINTER cp, TOKULOGGER);
-int toku_cachetable_end_checkpoint(CHECKPOINTER cp, TOKULOGGER logger, 
+void toku_cachetable_end_checkpoint(CHECKPOINTER cp, TOKULOGGER logger, 
                                    void (*testcallback_f)(void*),  void * testextra);
 
 // Shuts down checkpoint thread
@@ -75,15 +74,15 @@ void toku_cachetable_minicron_shutdown(CACHETABLE ct);
 
 // Close the cachetable.
 // Effects: All of the memory objects are flushed to disk, and the cachetable is destroyed.
-int toku_cachetable_close (CACHETABLE*); /* Flushes everything to disk, and destroys the cachetable. */
+void toku_cachetable_close(CACHETABLE *ct); 
 
 // Open a file and bind the file to a new cachefile object. (For use by test programs only.)
-int toku_cachetable_openf (CACHEFILE *,CACHETABLE, const char */*fname_in_env*/, int flags, mode_t mode);
+int toku_cachetable_openf(CACHEFILE *,CACHETABLE, const char *fname_in_env, int flags, mode_t mode);
 
 // Bind a file to a new cachefile object.
-int toku_cachetable_openfd (CACHEFILE *,CACHETABLE, int /*fd*/, 
-			    const char *fname_relative_to_env); /*(used for logging)*/
-int toku_cachetable_openfd_with_filenum (CACHEFILE *,CACHETABLE, int /*fd*/, 
+int toku_cachetable_openfd(CACHEFILE *,CACHETABLE, int fd, 
+			    const char *fname_relative_to_env);
+int toku_cachetable_openfd_with_filenum (CACHEFILE *,CACHETABLE, int fd, 
 					 const char *fname_in_env,
 					 FILENUM filenum);
 
@@ -100,8 +99,7 @@ void toku_cachetable_release_reserved_memory(CACHETABLE, uint64_t);
 // cachefile operations
 
 // Does an fsync of a cachefile.
-// Handles the case where cf points to /dev/null
-int toku_cachefile_fsync(CACHEFILE cf);
+void toku_cachefile_fsync(CACHEFILE cf);
 
 enum partial_eviction_cost {
     PE_CHEAP=0, // running partial eviction is cheap, and can be done on the client thread
@@ -189,14 +187,14 @@ typedef void (*CACHETABLE_GET_KEY_AND_FULLHASH)(CACHEKEY* cachekey, uint32_t* fu
 typedef void (*CACHETABLE_REMOVE_KEY)(CACHEKEY* cachekey, bool for_checkpoint, void* extra);
 
 void toku_cachefile_set_userdata(CACHEFILE cf, void *userdata,
-    int (*log_fassociate_during_checkpoint)(CACHEFILE, void*),
-    int (*log_suppress_rollback_during_checkpoint)(CACHEFILE, void*),
-    int (*close_userdata)(CACHEFILE, int, void*, char **/*error_string*/, bool, LSN),
+    void (*log_fassociate_during_checkpoint)(CACHEFILE, void*),
+    void (*log_suppress_rollback_during_checkpoint)(CACHEFILE, void*),
+    int (*close_userdata)(CACHEFILE, int, void*, bool, LSN),
     int (*checkpoint_userdata)(CACHEFILE, int, void*),
-    int (*begin_checkpoint_userdata)(LSN, void*),
-    int (*end_checkpoint_userdata)(CACHEFILE, int, void*),
-    int (*note_pin_by_checkpoint)(CACHEFILE, void*),
-    int (*note_unpin_by_checkpoint)(CACHEFILE, void*));
+    void (*begin_checkpoint_userdata)(LSN, void*),
+    void (*end_checkpoint_userdata)(CACHEFILE, int, void*),
+    void (*note_pin_by_checkpoint)(CACHEFILE, void*),
+    void (*note_unpin_by_checkpoint)(CACHEFILE, void*));
 // Effect: Store some cachefile-specific user data.  When the last reference to a cachefile is closed, we call close_userdata().
 // Before starting a checkpoint, we call checkpoint_prepare_userdata().
 // When the cachefile needs to be checkpointed, we call checkpoint_userdata().
@@ -220,10 +218,10 @@ typedef enum {
 
 // put something into the cachetable and checkpoint dependent pairs
 // if the checkpointing is necessary
-int toku_cachetable_put_with_dep_pairs(
+void toku_cachetable_put_with_dep_pairs(
     CACHEFILE cachefile,
     CACHETABLE_GET_KEY_AND_FULLHASH get_key_and_fullhash,
-    void*value,
+    void *value,
     PAIR_ATTR attr,
     CACHETABLE_WRITE_CALLBACK write_callback,
     void *get_key_and_fullhash_extra,
@@ -241,9 +239,7 @@ int toku_cachetable_put_with_dep_pairs(
 // Effects: Lookup the key in the cachetable. If the key is not in the cachetable,
 // then insert the pair and pin it. Otherwise return an error.  Some of the key
 // value pairs may be evicted from the cachetable when the cachetable gets too big.
-// Returns: 0 if the memory object is placed into the cachetable, otherwise an
-// error number.
-int toku_cachetable_put(CACHEFILE cf, CACHEKEY key, uint32_t fullhash,
+void toku_cachetable_put(CACHEFILE cf, CACHEKEY key, uint32_t fullhash,
 			void *value, PAIR_ATTR size,
 			CACHETABLE_WRITE_CALLBACK write_callback,
                         CACHETABLE_PUT_CALLBACK put_callback
@@ -386,8 +382,6 @@ int toku_cachetable_get_and_pin_nonblocking (
     UNLOCKERS unlockers
     );
 
-#define CAN_RELEASE_LOCK_DURING_IO
-
 int toku_cachetable_maybe_get_and_pin (CACHEFILE, CACHEKEY, uint32_t /*fullhash*/, void**);
 // Effect: Maybe get and pin a memory object.
 //  This function is similar to the get_and_pin function except that it
@@ -459,13 +453,13 @@ int toku_cachefile_count_pinned (CACHEFILE, int /*printthem*/ );
 // object is freed.
 // If oplsn_valid is true then use oplsn as the LSN of the close instead of asking the logger.  oplsn_valid being true is only allowed during recovery, and requires that you are removing the last reference (otherwise the lsn wouldn't make it in.)
 // Returns: 0 if success, otherwise returns an error number.
-int toku_cachefile_close (CACHEFILE*, char **error_string, bool oplsn_valid, LSN oplsn);
+int toku_cachefile_close (CACHEFILE*, bool oplsn_valid, LSN oplsn);
 
 // Flush the cachefile.
 // Effect: Flush everything owned by the cachefile from the cachetable. All dirty
 // blocks are written.  All unpinned blocks are evicted from the cachetable.
 // Returns: 0 if success, otherwise returns an error number.
-int toku_cachefile_flush (CACHEFILE);
+void toku_cachefile_flush(CACHEFILE);
 
 // Return on success (different from pread and pwrite)
 //int cachefile_pwrite (CACHEFILE, const void *buf, size_t count, toku_off_t offset);
@@ -527,8 +521,6 @@ void toku_cachetable_verify (CACHETABLE t);
 // Not for use in production, but useful for testing.
 void toku_cachetable_print_hash_histogram (void) __attribute__((__visibility__("default")));
 
-#define TOKU_CACHETABLE_DO_EVICT_FROM_WRITER 0
-
 void toku_cachetable_maybe_flush_some(CACHETABLE ct);
 
 // for stat64
@@ -572,11 +564,10 @@ void remove_background_job_from_cf (CACHEFILE cf);
 // the cachetable must be notified.
 
 // test-only function
-extern int toku_cachetable_get_checkpointing_user_data_status(void);
+int toku_cachetable_get_checkpointing_user_data_status(void);
 
 // test-only function
-int toku_cleaner_thread_for_test (CACHETABLE ct);
-int toku_cleaner_thread (void *cleaner_v);
-
+int toku_cleaner_thread_for_test(CACHETABLE ct);
+int toku_cleaner_thread(void *cleaner_v);
 
-#endif
+#endif /* CACHETABLE_H */
diff --git a/ft/checkpoint.cc b/ft/checkpoint.cc
index 5ec8f4cd69c..62040be0a51 100644
--- a/ft/checkpoint.cc
+++ b/ft/checkpoint.cc
@@ -222,7 +222,7 @@ toku_checkpoint(CHECKPOINTER cp, TOKULOGGER logger,
                 void (*callback_f)(void*),  void * extra,
                 void (*callback2_f)(void*), void * extra2,
                 checkpoint_caller_t caller_id) {
-    int r;
+    int r = 0;
     int footprint_offset = (int) caller_id * 1000;
 
     assert(initialized);
@@ -241,7 +241,7 @@ toku_checkpoint(CHECKPOINTER cp, TOKULOGGER logger,
     
     SET_CHECKPOINT_FOOTPRINT(30);
     STATUS_VALUE(CP_TIME_LAST_CHECKPOINT_BEGIN) = time(NULL);
-    r = toku_cachetable_begin_checkpoint(cp, logger);
+    toku_cachetable_begin_checkpoint(cp, logger);
 
     toku_ft_open_close_unlock();
     multi_operation_checkpoint_unlock();
@@ -250,7 +250,7 @@ toku_checkpoint(CHECKPOINTER cp, TOKULOGGER logger,
     if (r==0) {
         if (callback_f) 
             callback_f(extra);      // callback is called with checkpoint_safe_lock still held
-        r = toku_cachetable_end_checkpoint(cp, logger, callback2_f, extra2);
+        toku_cachetable_end_checkpoint(cp, logger, callback2_f, extra2);
     }
     SET_CHECKPOINT_FOOTPRINT(50);
     if (r==0 && logger) {
diff --git a/ft/checkpoint.h b/ft/checkpoint.h
index bc70eedb259..7b8633749c4 100644
--- a/ft/checkpoint.h
+++ b/ft/checkpoint.h
@@ -8,7 +8,7 @@
 #ident "$Id$"
 
 
-int toku_set_checkpoint_period(CACHETABLE ct, uint32_t new_period);
+void toku_set_checkpoint_period(CACHETABLE ct, uint32_t new_period);
 //Effect: Change [end checkpoint (n) - begin checkpoint (n+1)] delay to
 //        new_period seconds.  0 means disable.
 
diff --git a/ft/ft-cachetable-wrappers.cc b/ft/ft-cachetable-wrappers.cc
index f9c73b184bb..0f107c687df 100644
--- a/ft/ft-cachetable-wrappers.cc
+++ b/ft/ft-cachetable-wrappers.cc
@@ -45,7 +45,7 @@ cachetable_put_empty_node_with_dep_nodes(
         dependent_dirty_bits[i] = (enum cachetable_dirty) dependent_nodes[i]->dirty;
     }
 
-    int r = toku_cachetable_put_with_dep_pairs(
+    toku_cachetable_put_with_dep_pairs(
         h->cf,
         ftnode_get_key_and_fullhash,
         new_node,
@@ -60,7 +60,6 @@ cachetable_put_empty_node_with_dep_nodes(
         name,
         fullhash,
         toku_node_save_ct_pair);
-    assert_zero(r);
     *result = new_node;
 }
 
diff --git a/ft/ft-flusher.cc b/ft/ft-flusher.cc
index 4446dcd3a0e..86418fa53b6 100644
--- a/ft/ft-flusher.cc
+++ b/ft/ft-flusher.cc
@@ -1034,7 +1034,6 @@ flush_this_child(
 // Effect: Push everything in the CHILDNUMth buffer of node down into the child.
 {
     update_flush_status(child, 0);
-    int r;
     toku_assert_entire_node_in_memory(node);
     if (fa->should_destroy_basement_nodes(fa)) {
         maybe_destroy_child_blbs(node, child, h);
@@ -1053,7 +1052,7 @@ flush_this_child(
     set_BNC(node, childnum, toku_create_empty_nl());
 
     // now we have a bnc to flush to the child
-    r = toku_bnc_flush_to_child(h, bnc, child); assert_zero(r);
+    toku_bnc_flush_to_child(h, bnc, child);
     destroy_nonleaf_childinfo(bnc);
 }
 
@@ -1136,8 +1135,7 @@ merge_leaf_nodes(FTNODE a, FTNODE b)
     b->n_children = 0;
 }
 
-static int
-balance_leaf_nodes(
+static void balance_leaf_nodes(
     FTNODE a,
     FTNODE b,
     DBT *splitk)
@@ -1151,8 +1149,6 @@ balance_leaf_nodes(
     // now split them
     // because we are not creating a new node, we can pass in no dependent nodes
     ftleaf_split(NULL, a, &a, &b, splitk, false, 0, NULL);
-
-    return 0;
 }
 
 static void
@@ -1184,8 +1180,7 @@ maybe_merge_pinned_leaf_nodes(
         // one is less than 1/4 of a node, and together they are more than 3/4 of a node.
         toku_free(parent_splitk->data); // We don't need the parent_splitk any more. If we need a splitk (if we don't merge) we'll malloc a new one.
         *did_rebalance = true;
-        int r = balance_leaf_nodes(a, b, splitk);
-        assert(r==0);
+         balance_leaf_nodes(a, b, splitk);
     } else {
         // we are merging them.
         *did_merge = true;
@@ -1478,7 +1473,6 @@ flush_some_child(
     call_flusher_thread_callback(flt_flush_before_child_pin);
 
     // get the child into memory
-    int r;
     BLOCKNUM targetchild = BP_BLOCKNUM(parent, childnum);
     toku_verify_blocknum_allocated(h->blocktable, targetchild);
     uint32_t childfullhash = compute_child_fullhash(h->cf, parent, childnum);
@@ -1557,12 +1551,11 @@ flush_some_child(
             child->dirty = 1;
         }
         // do the actual flush
-        r = toku_bnc_flush_to_child(
+        toku_bnc_flush_to_child(
             h,
             bnc,
             child
             );
-        assert_zero(r);
         destroy_nonleaf_childinfo(bnc);
     }
 
@@ -1736,7 +1729,6 @@ struct flusher_extra {
 //
 static void flush_node_fun(void *fe_v)
 {
-    int r;
     struct flusher_extra* fe = (struct flusher_extra *) fe_v;
     // The node that has been placed on the background
     // thread may not be fully in memory. Some message
@@ -1761,12 +1753,11 @@ static void flush_node_fun(void *fe_v)
         // for test purposes
         call_flusher_thread_callback(flt_flush_before_applying_inbox);
 
-        r = toku_bnc_flush_to_child(
+        toku_bnc_flush_to_child(
             fe->h,
             fe->bnc,
             fe->node
             );
-        assert_zero(r);
         destroy_nonleaf_childinfo(fe->bnc);
 
         // after the flush has completed, now check to see if the node needs flushing
diff --git a/ft/ft-internal.h b/ft/ft-internal.h
index d27b7acd995..21784e1b486 100644
--- a/ft/ft-internal.h
+++ b/ft/ft-internal.h
@@ -131,15 +131,10 @@ unsigned int toku_bnc_nbytesinbuf(NONLEAF_CHILDINFO bnc);
 int toku_bnc_n_entries(NONLEAF_CHILDINFO bnc);
 long toku_bnc_memory_size(NONLEAF_CHILDINFO bnc);
 long toku_bnc_memory_used(NONLEAF_CHILDINFO bnc);
-int toku_bnc_insert_msg(NONLEAF_CHILDINFO bnc, const void *key, ITEMLEN keylen, const void *data, ITEMLEN datalen, enum ft_msg_type type, MSN msn, XIDS xids, bool is_fresh, DESCRIPTOR desc, ft_compare_func cmp);
+void toku_bnc_insert_msg(NONLEAF_CHILDINFO bnc, const void *key, ITEMLEN keylen, const void *data, ITEMLEN datalen, enum ft_msg_type type, MSN msn, XIDS xids, bool is_fresh, DESCRIPTOR desc, ft_compare_func cmp);
 void toku_bnc_empty(NONLEAF_CHILDINFO bnc);
-int toku_bnc_flush_to_child(
-    FT h,
-    NONLEAF_CHILDINFO bnc, 
-    FTNODE child
-    );
-bool
-toku_ft_nonleaf_is_gorged(FTNODE node, uint32_t nodesize);
+void toku_bnc_flush_to_child(FT h, NONLEAF_CHILDINFO bnc, FTNODE child);
+bool toku_ft_nonleaf_is_gorged(FTNODE node, uint32_t nodesize);
 
 
 enum reactivity get_nonleaf_reactivity (FTNODE node);
@@ -463,11 +458,6 @@ struct ft {
     // A checkpoint is running.  If true, then keep this header around for checkpoint, like a transaction
     bool pinned_by_checkpoint;
 
-    // If nonzero there was a write error.  Don't write any more, because it probably only gets worse.  This is the error code.
-    int panic;
-    // A malloced string that can indicate what went wrong.
-    char *panic_string;
-
     // is this ft a blackhole? if so, all messages are dropped.
     bool blackhole;
 };
@@ -550,8 +540,7 @@ deserialize_ft_from_fd_into_rbuf(int fd,
 int
 deserialize_ft_versioned(int fd, struct rbuf *rb, FT *ft, uint32_t version);
 
-int
-read_block_from_fd_into_rbuf(
+void read_block_from_fd_into_rbuf(
     int fd, 
     BLOCKNUM blocknum,
     FT h,
@@ -582,9 +571,9 @@ unsigned int toku_serialize_ftnode_size(FTNODE node); /* How much space will it
 
 void toku_verify_or_set_counts(FTNODE);
 
-int toku_serialize_ft_size (FT_HEADER h);
-int toku_serialize_ft_to (int fd, FT_HEADER h, BLOCK_TABLE blocktable, CACHEFILE cf);
-int toku_serialize_ft_to_wbuf (
+size_t toku_serialize_ft_size (FT_HEADER h);
+void toku_serialize_ft_to (int fd, FT_HEADER h, BLOCK_TABLE blocktable, CACHEFILE cf);
+void toku_serialize_ft_to_wbuf (
     struct wbuf *wbuf, 
     FT_HEADER h, 
     DISKOFF translation_location_on_disk, 
@@ -892,8 +881,7 @@ int toku_cmd_leafval_heaviside (OMTVALUE leafentry, void *extra)
     __attribute__((__warn_unused_result__));
 
 // toku_ft_root_put_cmd() accepts non-constant cmd because this is where we set the msn
-int toku_ft_root_put_cmd(FT h, FT_MSG_S * cmd)
-    __attribute__((__warn_unused_result__));
+void toku_ft_root_put_cmd(FT h, FT_MSG_S * cmd);
 
 void *mempool_malloc_from_omt(OMT omt, struct mempool *mp, size_t size, void **maybe_free);
 // Effect: Allocate a new object of size SIZE in MP.  If MP runs out of space, allocate new a new mempool space, and copy all the items
diff --git a/ft/ft-ops.cc b/ft/ft-ops.cc
index 56587821741..4c2619de74c 100644
--- a/ft/ft-ops.cc
+++ b/ft/ft-ops.cc
@@ -329,21 +329,6 @@ uint32_t compute_child_fullhash (CACHEFILE cf, FTNODE node, int childnum) {
     return toku_cachetable_hash(cf, BP_BLOCKNUM(node, childnum));
 }
 
-// TODO: (Zardosht) look into this and possibly fix and use
-static void __attribute__((__unused__))
-ft_leaf_check_leaf_stats (FTNODE node)
-{
-    assert(node);
-    assert(false);
-    // static int count=0; count++;
-    // if (node->height>0) return;
-    // struct subtree_estimates e = calc_leaf_stats(node);
-    // assert(e.ndata == node->u.l.leaf_stats.ndata);
-    // assert(e.nkeys == node->u.l.leaf_stats.nkeys);
-    // assert(e.dsize == node->u.l.leaf_stats.dsize);
-    // assert(node->u.l.leaf_stats.exact);
-}
-
 int
 toku_bnc_n_entries(NONLEAF_CHILDINFO bnc)
 {
@@ -729,12 +714,10 @@ void toku_ftnode_flush_callback (
         if (height == 0 && !is_clone) {
             ftnode_update_disk_stats(ftnode, h, for_checkpoint);
         }
-        if (!h->panic) { // if the brt panicked, stop writing, otherwise try to write it.
-            toku_assert_entire_node_in_memory(ftnode);
-            int r = toku_serialize_ftnode_to(fd, ftnode->thisnodename, ftnode, ndd, !is_clone, h, for_checkpoint);
-            assert_zero(r);
-            ftnode->layout_version_read_from_disk = FT_LAYOUT_VERSION;
-        }
+        toku_assert_entire_node_in_memory(ftnode);
+        int r = toku_serialize_ftnode_to(fd, ftnode->thisnodename, ftnode, ndd, !is_clone, h, for_checkpoint);
+        assert_zero(r);
+        ftnode->layout_version_read_from_disk = FT_LAYOUT_VERSION;
         ft_status_update_flush_reason(ftnode, for_checkpoint);
     }
     if (!keep_me) {
@@ -1425,8 +1408,6 @@ toku_ft_bn_apply_cmd_once (
 //   idx is the location where it goes
 //   le is old leafentry
 {
-    // ft_leaf_check_leaf_stats(node);
-
     size_t newsize=0, oldsize=0, workdone_this_le=0;
     LEAFENTRY new_le=0;
     void *maybe_free = 0;
@@ -1861,8 +1842,7 @@ toku_fifo_entry_key_msn_cmp(const struct toku_fifo_entry_key_msn_cmp_extra &extr
                        extra.desc, extra.cmp);
 }
 
-int
-toku_bnc_insert_msg(NONLEAF_CHILDINFO bnc, const void *key, ITEMLEN keylen, const void *data, ITEMLEN datalen, enum ft_msg_type type, MSN msn, XIDS xids, bool is_fresh, DESCRIPTOR desc, ft_compare_func cmp)
+void toku_bnc_insert_msg(NONLEAF_CHILDINFO bnc, const void *key, ITEMLEN keylen, const void *data, ITEMLEN datalen, enum ft_msg_type type, MSN msn, XIDS xids, bool is_fresh, DESCRIPTOR desc, ft_compare_func cmp)
 // Effect: Enqueue the message represented by the parameters into the
 //   bnc's buffer, and put it in either the fresh or stale message tree,
 //   or the broadcast list.
@@ -1882,23 +1862,19 @@ toku_bnc_insert_msg(NONLEAF_CHILDINFO bnc, const void *key, ITEMLEN keylen, cons
             r = bnc->stale_message_tree.insert<struct toku_fifo_entry_key_msn_heaviside_extra, toku_fifo_entry_key_msn_heaviside>(offset, extra, nullptr);
             assert_zero(r);
         }
-    } else if (ft_msg_type_applies_all(type) || ft_msg_type_does_nothing(type)) {
+    } else {
+        invariant(ft_msg_type_applies_all(type) || ft_msg_type_does_nothing(type));
         const uint32_t idx = bnc->broadcast_list.size();
         r = bnc->broadcast_list.insert_at(offset, idx);
         assert_zero(r);
-    } else {
-        abort();
     }
-    return r;
 }
 
 // append a cmd to a nonleaf node's child buffer
 // should be static, but used by test programs
-void
-toku_ft_append_to_child_buffer(ft_compare_func compare_fun, DESCRIPTOR desc, FTNODE node, int childnum, enum ft_msg_type type, MSN msn, XIDS xids, bool is_fresh, const DBT *key, const DBT *val) {
+void toku_ft_append_to_child_buffer(ft_compare_func compare_fun, DESCRIPTOR desc, FTNODE node, int childnum, enum ft_msg_type type, MSN msn, XIDS xids, bool is_fresh, const DBT *key, const DBT *val) {
     assert(BP_STATE(node,childnum) == PT_AVAIL);
-    int r = toku_bnc_insert_msg(BNC(node, childnum), key->data, key->size, val->data, val->size, type, msn, xids, is_fresh, desc, compare_fun);
-    invariant_zero(r);
+    toku_bnc_insert_msg(BNC(node, childnum), key->data, key->size, val->data, val->size, type, msn, xids, is_fresh, desc, compare_fun);
     node->dirty = 1;
 }
 
@@ -2240,8 +2216,7 @@ ft_leaf_gc_all_les(FTNODE node,
     }
 }
 
-int
-toku_bnc_flush_to_child(
+void toku_bnc_flush_to_child(
     FT h,
     NONLEAF_CHILDINFO bnc,
     FTNODE child
@@ -2293,8 +2268,6 @@ toku_bnc_flush_to_child(
         live_root_txns.destroy();
         referenced_xids.destroy();
     }
-
-    return 0;
 }
 
 void bring_node_fully_into_memory(FTNODE node, FT h)
@@ -2477,8 +2450,7 @@ static void push_something_at_root (FT h, FTNODE *nodep, FT_MSG cmd)
     }
 }
 
-int
-toku_ft_root_put_cmd (FT ft, FT_MSG_S * cmd)
+void toku_ft_root_put_cmd(FT ft, FT_MSG_S * cmd)
 // Effect:
 //  - assign msn to cmd
 //  - push the cmd into the brt
@@ -2486,7 +2458,7 @@ toku_ft_root_put_cmd (FT ft, FT_MSG_S * cmd)
 {
     // blackhole fractal trees drop all messages, so do nothing.
     if (ft->blackhole) {
-        return 0;
+        return;
     }
 
     FTNODE node;
@@ -2567,58 +2539,47 @@ toku_ft_root_put_cmd (FT ft, FT_MSG_S * cmd)
     else {
         toku_unpin_ftnode(ft, node);  // unpin root
     }
-
-    return 0;
 }
 
 // Effect: Insert the key-val pair into brt.
-int toku_ft_insert (FT_HANDLE brt, DBT *key, DBT *val, TOKUTXN txn) {
-    return toku_ft_maybe_insert(brt, key, val, txn, false, ZERO_LSN, true, FT_INSERT);
+void toku_ft_insert (FT_HANDLE brt, DBT *key, DBT *val, TOKUTXN txn) {
+    toku_ft_maybe_insert(brt, key, val, txn, false, ZERO_LSN, true, FT_INSERT);
 }
 
-int
-toku_ft_load_recovery(TOKUTXN txn, FILENUM old_filenum, char const * new_iname, int do_fsync, int do_log, LSN *load_lsn) {
-    int r = 0;
+void toku_ft_load_recovery(TOKUTXN txn, FILENUM old_filenum, char const * new_iname, int do_fsync, int do_log, LSN *load_lsn) {
     assert(txn);
     toku_txn_force_fsync_on_commit(txn);  //If the txn commits, the commit MUST be in the log
                                           //before the (old) file is actually unlinked
     TOKULOGGER logger = toku_txn_logger(txn);
 
     BYTESTRING new_iname_bs = {.len=(uint32_t) strlen(new_iname), .data=(char*)new_iname};
-    r = toku_logger_save_rollback_load(txn, old_filenum, &new_iname_bs);
-    if (r==0 && do_log && logger) {
+    toku_logger_save_rollback_load(txn, old_filenum, &new_iname_bs);
+    if (do_log && logger) {
         TXNID xid = toku_txn_get_txnid(txn);
-        r = toku_log_load(logger, load_lsn, do_fsync, txn, xid, old_filenum, new_iname_bs);
+        toku_log_load(logger, load_lsn, do_fsync, txn, xid, old_filenum, new_iname_bs);
     }
-    return r;
 }
 
 // 2954
 // this function handles the tasks needed to be recoverable
 //  - write to rollback log
 //  - write to recovery log
-int
-toku_ft_hot_index_recovery(TOKUTXN txn, FILENUMS filenums, int do_fsync, int do_log, LSN *hot_index_lsn)
+void toku_ft_hot_index_recovery(TOKUTXN txn, FILENUMS filenums, int do_fsync, int do_log, LSN *hot_index_lsn)
 {
-    int r = 0;
     assert(txn);
     TOKULOGGER logger = toku_txn_logger(txn);
 
     // write to the rollback log
-    r = toku_logger_save_rollback_hot_index(txn, &filenums);
-    if ( r==0 && do_log && logger) {
+    toku_logger_save_rollback_hot_index(txn, &filenums);
+    if (do_log && logger) {
         TXNID xid = toku_txn_get_txnid(txn);
         // write to the recovery log
-        r = toku_log_hot_index(logger, hot_index_lsn, do_fsync, txn, xid, filenums);
+        toku_log_hot_index(logger, hot_index_lsn, do_fsync, txn, xid, filenums);
     }
-    return r;
 }
 
-// Effect: Optimize the brt.
-int
-toku_ft_optimize (FT_HANDLE brt) {
-    int r = 0;
-
+// Effect: Optimize the ft.
+void toku_ft_optimize (FT_HANDLE brt) {
     TOKULOGGER logger = toku_cachefile_logger(brt->ft->cf);
     if (logger) {
         TXNID oldest = toku_txn_manager_get_oldest_living_xid(logger->txn_manager);
@@ -2629,8 +2590,8 @@ toku_ft_optimize (FT_HANDLE brt) {
             message_xids = root_xids;
         }
         else {
-            r = xids_create_child(root_xids, &message_xids, oldest);
-            invariant(r==0);
+            int r = xids_create_child(root_xids, &message_xids, oldest);
+            invariant(r == 0);
         }
 
         DBT key;
@@ -2638,50 +2599,36 @@ toku_ft_optimize (FT_HANDLE brt) {
         toku_init_dbt(&key);
         toku_init_dbt(&val);
         FT_MSG_S ftcmd = { FT_OPTIMIZE, ZERO_MSN, message_xids, .u = { .id = {&key,&val} } };
-        r = toku_ft_root_put_cmd(brt->ft, &ftcmd);
+        toku_ft_root_put_cmd(brt->ft, &ftcmd);
         xids_destroy(&message_xids);
     }
-    return r;
 }
 
-int
-toku_ft_load(FT_HANDLE brt, TOKUTXN txn, char const * new_iname, int do_fsync, LSN *load_lsn) {
-    int r = 0;
+void toku_ft_load(FT_HANDLE brt, TOKUTXN txn, char const * new_iname, int do_fsync, LSN *load_lsn) {
     FILENUM old_filenum = toku_cachefile_filenum(brt->ft->cf);
     int do_log = 1;
-    r = toku_ft_load_recovery(txn, old_filenum, new_iname, do_fsync, do_log, load_lsn);
-    return r;
+    toku_ft_load_recovery(txn, old_filenum, new_iname, do_fsync, do_log, load_lsn);
 }
 
-// 2954
-// brt actions for logging hot index filenums
-int
-toku_ft_hot_index(FT_HANDLE brt __attribute__ ((unused)), TOKUTXN txn, FILENUMS filenums, int do_fsync, LSN *lsn) {
-    int r = 0;
+// ft actions for logging hot index filenums
+void toku_ft_hot_index(FT_HANDLE brt __attribute__ ((unused)), TOKUTXN txn, FILENUMS filenums, int do_fsync, LSN *lsn) {
     int do_log = 1;
-    r = toku_ft_hot_index_recovery(txn, filenums, do_fsync, do_log, lsn);
-    return r;
+    toku_ft_hot_index_recovery(txn, filenums, do_fsync, do_log, lsn);
 }
 
-int
+void
 toku_ft_log_put (TOKUTXN txn, FT_HANDLE brt, const DBT *key, const DBT *val) {
-    int r = 0;
     TOKULOGGER logger = toku_txn_logger(txn);
     if (logger && brt->ft->txnid_that_suppressed_recovery_logs == TXNID_NONE) {
         BYTESTRING keybs = {.len=key->size, .data=(char *) key->data};
         BYTESTRING valbs = {.len=val->size, .data=(char *) val->data};
         TXNID xid = toku_txn_get_txnid(txn);
-        // if (type == FT_INSERT)
-            r = toku_log_enq_insert(logger, (LSN*)0, 0, txn, toku_cachefile_filenum(brt->ft->cf), xid, keybs, valbs);
-        // else
-            // r = toku_log_enq_insert_no_overwrite(logger, (LSN*)0, 0, toku_cachefile_filenum(brt->ft->cf), xid, keybs, valbs);
+        toku_log_enq_insert(logger, (LSN*)0, 0, txn, toku_cachefile_filenum(brt->ft->cf), xid, keybs, valbs);
     }
-    return r;
 }
 
-int
+void
 toku_ft_log_put_multiple (TOKUTXN txn, FT_HANDLE src_ft, FT_HANDLE *brts, int num_fts, const DBT *key, const DBT *val) {
-    int r = 0;
     assert(txn);
     assert(num_fts > 0);
     TOKULOGGER logger = toku_txn_logger(txn);
@@ -2701,23 +2648,19 @@ toku_ft_log_put_multiple (TOKUTXN txn, FT_HANDLE src_ft, FT_HANDLE *brts, int nu
             BYTESTRING valbs = {.len=val->size, .data=(char *) val->data};
             TXNID xid = toku_txn_get_txnid(txn);
             FILENUM src_filenum = src_ft ? toku_cachefile_filenum(src_ft->ft->cf) : FILENUM_NONE;
-            r = toku_log_enq_insert_multiple(logger, (LSN*)0, 0, txn, src_filenum, filenums, xid, keybs, valbs);
+            toku_log_enq_insert_multiple(logger, (LSN*)0, 0, txn, src_filenum, filenums, xid, keybs, valbs);
         }
     }
-    return r;
 }
 
-int
-toku_ft_maybe_insert (FT_HANDLE ft_h, DBT *key, DBT *val, TOKUTXN txn, bool oplsn_valid, LSN oplsn, bool do_logging, enum ft_msg_type type) {
+void toku_ft_maybe_insert (FT_HANDLE ft_h, DBT *key, DBT *val, TOKUTXN txn, bool oplsn_valid, LSN oplsn, bool do_logging, enum ft_msg_type type) {
     assert(type==FT_INSERT || type==FT_INSERT_NO_OVERWRITE);
-    int r = 0;
     XIDS message_xids = xids_get_root_xids(); //By default use committed messages
     TXNID xid = toku_txn_get_txnid(txn);
     if (txn) {
         if (ft_h->ft->txnid_that_created_or_locked_when_empty != xid) {
             BYTESTRING keybs = {key->size, (char *) key->data};
-            r = toku_logger_save_rollback_cmdinsert(txn, toku_cachefile_filenum(ft_h->ft->cf), &keybs);
-            if (r!=0) return r;
+            toku_logger_save_rollback_cmdinsert(txn, toku_cachefile_filenum(ft_h->ft->cf), &keybs);
             toku_txn_maybe_note_ft(txn, ft_h->ft);
             //We have transactions, and this is not 2440.  We must send the full root-to-leaf-path
             message_xids = toku_txn_get_xids(txn);
@@ -2733,44 +2676,37 @@ toku_ft_maybe_insert (FT_HANDLE ft_h, DBT *key, DBT *val, TOKUTXN txn, bool opls
         BYTESTRING keybs = {.len=key->size, .data=(char *) key->data};
         BYTESTRING valbs = {.len=val->size, .data=(char *) val->data};
         if (type == FT_INSERT) {
-            r = toku_log_enq_insert(logger, (LSN*)0, 0, txn, toku_cachefile_filenum(ft_h->ft->cf), xid, keybs, valbs);
+            toku_log_enq_insert(logger, (LSN*)0, 0, txn, toku_cachefile_filenum(ft_h->ft->cf), xid, keybs, valbs);
         }
         else {
-            r = toku_log_enq_insert_no_overwrite(logger, (LSN*)0, 0, txn, toku_cachefile_filenum(ft_h->ft->cf), xid, keybs, valbs);
+            toku_log_enq_insert_no_overwrite(logger, (LSN*)0, 0, txn, toku_cachefile_filenum(ft_h->ft->cf), xid, keybs, valbs);
         }
-        if (r!=0) return r;
     }
 
     LSN treelsn;
     if (oplsn_valid && oplsn.lsn <= (treelsn = toku_ft_checkpoint_lsn(ft_h->ft)).lsn) {
-        r = 0;
+        // do nothing
     } else {
-        r = toku_ft_send_insert(ft_h, key, val, message_xids, type);
+        toku_ft_send_insert(ft_h, key, val, message_xids, type);
     }
-    return r;
 }
 
-static int
+static void
 ft_send_update_msg(FT_HANDLE brt, FT_MSG_S *msg, TOKUTXN txn) {
     msg->xids = (txn
                  ? toku_txn_get_xids(txn)
                  : xids_get_root_xids());
-    int r = toku_ft_root_put_cmd(brt->ft, msg);
-    return r;
+    toku_ft_root_put_cmd(brt->ft, msg);
 }
 
-int
-toku_ft_maybe_update(FT_HANDLE ft_h, const DBT *key, const DBT *update_function_extra,
+void toku_ft_maybe_update(FT_HANDLE ft_h, const DBT *key, const DBT *update_function_extra,
                       TOKUTXN txn, bool oplsn_valid, LSN oplsn,
                       bool do_logging) {
-    int r = 0;
-
     TXNID xid = toku_txn_get_txnid(txn);
     if (txn) {
         BYTESTRING keybs = { key->size, (char *) key->data };
-        r = toku_logger_save_rollback_cmdupdate(
+        toku_logger_save_rollback_cmdupdate(
             txn, toku_cachefile_filenum(ft_h->ft->cf), &keybs);
-        if (r != 0) { goto cleanup; }
         toku_txn_maybe_note_ft(txn, ft_h->ft);
     }
 
@@ -2781,37 +2717,28 @@ toku_ft_maybe_update(FT_HANDLE ft_h, const DBT *key, const DBT *update_function_
         BYTESTRING keybs = {.len=key->size, .data=(char *) key->data};
         BYTESTRING extrabs = {.len=update_function_extra->size,
                               .data = (char *) update_function_extra->data};
-        r = toku_log_enq_update(logger, NULL, 0, txn,
+        toku_log_enq_update(logger, NULL, 0, txn,
                                 toku_cachefile_filenum(ft_h->ft->cf),
                                 xid, keybs, extrabs);
-        if (r != 0) { goto cleanup; }
     }
 
     LSN treelsn;
-    if (oplsn_valid &&
-        oplsn.lsn <= (treelsn = toku_ft_checkpoint_lsn(ft_h->ft)).lsn) {
-        r = 0;
+    if (oplsn_valid && oplsn.lsn <= (treelsn = toku_ft_checkpoint_lsn(ft_h->ft)).lsn) {
+        // do nothing
     } else {
         FT_MSG_S msg = { FT_UPDATE, ZERO_MSN, NULL,
                          .u = { .id = { key, update_function_extra } } };
-        r = ft_send_update_msg(ft_h, &msg, txn);
+        ft_send_update_msg(ft_h, &msg, txn);
     }
-
-cleanup:
-    return r;
 }
 
-int
-toku_ft_maybe_update_broadcast(FT_HANDLE ft_h, const DBT *update_function_extra,
+void toku_ft_maybe_update_broadcast(FT_HANDLE ft_h, const DBT *update_function_extra,
                                 TOKUTXN txn, bool oplsn_valid, LSN oplsn,
                                 bool do_logging, bool is_resetting_op) {
-    int r = 0;
-
     TXNID xid = toku_txn_get_txnid(txn);
     uint8_t  resetting = is_resetting_op ? 1 : 0;
     if (txn) {
-        r = toku_logger_save_rollback_cmdupdatebroadcast(txn, toku_cachefile_filenum(ft_h->ft->cf), resetting);
-        if (r != 0) { goto cleanup; }
+        toku_logger_save_rollback_cmdupdatebroadcast(txn, toku_cachefile_filenum(ft_h->ft->cf), resetting);
         toku_txn_maybe_note_ft(txn, ft_h->ft);
     }
 
@@ -2821,63 +2748,52 @@ toku_ft_maybe_update_broadcast(FT_HANDLE ft_h, const DBT *update_function_extra,
         ft_h->ft->txnid_that_suppressed_recovery_logs == TXNID_NONE) {
         BYTESTRING extrabs = {.len=update_function_extra->size,
                               .data = (char *) update_function_extra->data};
-        r = toku_log_enq_updatebroadcast(logger, NULL, 0, txn,
+        toku_log_enq_updatebroadcast(logger, NULL, 0, txn,
                                          toku_cachefile_filenum(ft_h->ft->cf),
                                          xid, extrabs, resetting);
-        if (r != 0) { goto cleanup; }
     }
 
     //TODO(yoni): remove treelsn here and similar calls (no longer being used)
     LSN treelsn;
     if (oplsn_valid &&
         oplsn.lsn <= (treelsn = toku_ft_checkpoint_lsn(ft_h->ft)).lsn) {
-        r = 0;
+
     } else {
         DBT nullkey;
         const DBT *nullkeyp = toku_init_dbt(&nullkey);
         FT_MSG_S msg = { FT_UPDATE_BROADCAST_ALL, ZERO_MSN, NULL,
                          .u = { .id = { nullkeyp, update_function_extra } } };
-        r = ft_send_update_msg(ft_h, &msg, txn);
+        ft_send_update_msg(ft_h, &msg, txn);
     }
-
-cleanup:
-    return r;
 }
 
-int
-toku_ft_send_insert(FT_HANDLE brt, DBT *key, DBT *val, XIDS xids, enum ft_msg_type type) {
+void toku_ft_send_insert(FT_HANDLE brt, DBT *key, DBT *val, XIDS xids, enum ft_msg_type type) {
     FT_MSG_S ftcmd = { type, ZERO_MSN, xids, .u = { .id = { key, val } } };
-    int r = toku_ft_root_put_cmd(brt->ft, &ftcmd);
-    return r;
+    toku_ft_root_put_cmd(brt->ft, &ftcmd);
 }
 
-int
-toku_ft_send_commit_any(FT_HANDLE brt, DBT *key, XIDS xids) {
+void toku_ft_send_commit_any(FT_HANDLE brt, DBT *key, XIDS xids) {
     DBT val;
     FT_MSG_S ftcmd = { FT_COMMIT_ANY, ZERO_MSN, xids, .u = { .id = { key, toku_init_dbt(&val) } } };
-    int r = toku_ft_root_put_cmd(brt->ft, &ftcmd);
-    return r;
+    toku_ft_root_put_cmd(brt->ft, &ftcmd);
 }
 
-int toku_ft_delete(FT_HANDLE brt, DBT *key, TOKUTXN txn) {
-    return toku_ft_maybe_delete(brt, key, txn, false, ZERO_LSN, true);
+void toku_ft_delete(FT_HANDLE brt, DBT *key, TOKUTXN txn) {
+    toku_ft_maybe_delete(brt, key, txn, false, ZERO_LSN, true);
 }
 
-int
+void
 toku_ft_log_del(TOKUTXN txn, FT_HANDLE brt, const DBT *key) {
-    int r = 0;
     TOKULOGGER logger = toku_txn_logger(txn);
     if (logger && brt->ft->txnid_that_suppressed_recovery_logs == TXNID_NONE) {
         BYTESTRING keybs = {.len=key->size, .data=(char *) key->data};
         TXNID xid = toku_txn_get_txnid(txn);
-        r = toku_log_enq_delete_any(logger, (LSN*)0, 0, txn, toku_cachefile_filenum(brt->ft->cf), xid, keybs);
+        toku_log_enq_delete_any(logger, (LSN*)0, 0, txn, toku_cachefile_filenum(brt->ft->cf), xid, keybs);
     }
-    return r;
 }
 
-int
+void
 toku_ft_log_del_multiple (TOKUTXN txn, FT_HANDLE src_ft, FT_HANDLE *brts, int num_fts, const DBT *key, const DBT *val) {
-    int r = 0;
     assert(txn);
     assert(num_fts > 0);
     TOKULOGGER logger = toku_txn_logger(txn);
@@ -2897,22 +2813,18 @@ toku_ft_log_del_multiple (TOKUTXN txn, FT_HANDLE src_ft, FT_HANDLE *brts, int nu
             BYTESTRING valbs = {.len=val->size, .data=(char *) val->data};
             TXNID xid = toku_txn_get_txnid(txn);
             FILENUM src_filenum = src_ft ? toku_cachefile_filenum(src_ft->ft->cf) : FILENUM_NONE;
-            r = toku_log_enq_delete_multiple(logger, (LSN*)0, 0, txn, src_filenum, filenums, xid, keybs, valbs);
+            toku_log_enq_delete_multiple(logger, (LSN*)0, 0, txn, src_filenum, filenums, xid, keybs, valbs);
         }
     }
-    return r;
 }
 
-int
-toku_ft_maybe_delete(FT_HANDLE ft_h, DBT *key, TOKUTXN txn, bool oplsn_valid, LSN oplsn, bool do_logging) {
-    int r;
+void toku_ft_maybe_delete(FT_HANDLE ft_h, DBT *key, TOKUTXN txn, bool oplsn_valid, LSN oplsn, bool do_logging) {
     XIDS message_xids = xids_get_root_xids(); //By default use committed messages
     TXNID xid = toku_txn_get_txnid(txn);
     if (txn) {
         if (ft_h->ft->txnid_that_created_or_locked_when_empty != xid) {
             BYTESTRING keybs = {key->size, (char *) key->data};
-            r = toku_logger_save_rollback_cmddelete(txn, toku_cachefile_filenum(ft_h->ft->cf), &keybs);
-            if (r!=0) return r;
+            toku_logger_save_rollback_cmddelete(txn, toku_cachefile_filenum(ft_h->ft->cf), &keybs);
             toku_txn_maybe_note_ft(txn, ft_h->ft);
             //We have transactions, and this is not 2440.  We must send the full root-to-leaf-path
             message_xids = toku_txn_get_xids(txn);
@@ -2926,25 +2838,21 @@ toku_ft_maybe_delete(FT_HANDLE ft_h, DBT *key, TOKUTXN txn, bool oplsn_valid, LS
     if (do_logging && logger &&
         ft_h->ft->txnid_that_suppressed_recovery_logs == TXNID_NONE) {
         BYTESTRING keybs = {.len=key->size, .data=(char *) key->data};
-        r = toku_log_enq_delete_any(logger, (LSN*)0, 0, txn, toku_cachefile_filenum(ft_h->ft->cf), xid, keybs);
-        if (r!=0) return r;
+        toku_log_enq_delete_any(logger, (LSN*)0, 0, txn, toku_cachefile_filenum(ft_h->ft->cf), xid, keybs);
     }
 
     LSN treelsn;
     if (oplsn_valid && oplsn.lsn <= (treelsn = toku_ft_checkpoint_lsn(ft_h->ft)).lsn) {
-        r = 0;
+        // do nothing
     } else {
-        r = toku_ft_send_delete(ft_h, key, message_xids);
+        toku_ft_send_delete(ft_h, key, message_xids);
     }
-    return r;
 }
 
-int
-toku_ft_send_delete(FT_HANDLE brt, DBT *key, XIDS xids) {
+void toku_ft_send_delete(FT_HANDLE brt, DBT *key, XIDS xids) {
     DBT val; toku_init_dbt(&val);
     FT_MSG_S ftcmd = { FT_DELETE_ANY, ZERO_MSN, xids, .u = { .id = { key, &val } } };
-    int result = toku_ft_root_put_cmd(brt->ft, &ftcmd);
-    return result;
+    toku_ft_root_put_cmd(brt->ft, &ftcmd);
 }
 
 /* mempool support */
@@ -2966,8 +2874,7 @@ static int move_it (OMTVALUE lev, uint32_t idx, void *v) {
 }
 
 // Compress things, and grow the mempool if needed.
-// TODO 4092 should copy data to new memory, then call toku_mempool_destory() followed by toku_mempool_init()
-static int omt_compress_kvspace (OMT omt, struct mempool *memp, size_t added_size, void **maybe_free) {
+static void omt_compress_kvspace (OMT omt, struct mempool *memp, size_t added_size, void **maybe_free) {
     uint32_t total_size_needed = memp->free_offset-memp->frag_size + added_size;
     if (total_size_needed+total_size_needed/4 >= memp->size) {
         memp->size = total_size_needed+total_size_needed/4;
@@ -2984,17 +2891,15 @@ static int omt_compress_kvspace (OMT omt, struct mempool *memp, size_t added_siz
         toku_free(memp->base);
     }
     *memp = new_kvspace;
-    return 0;
 }
 
 void *
 mempool_malloc_from_omt(OMT omt, struct mempool *mp, size_t size, void **maybe_free) {
     void *v = toku_mempool_malloc(mp, size, 1);
-    if (v==0) {
-        if (0 == omt_compress_kvspace(omt, mp, size, maybe_free)) {
-            v = toku_mempool_malloc(mp, size, 1);
-            lazy_assert(v);
-        }
+    if (v == NULL) {
+        omt_compress_kvspace(omt, mp, size, maybe_free);
+        v = toku_mempool_malloc(mp, size, 1);
+        lazy_assert(v);
     }
     return v;
 }
@@ -3008,18 +2913,15 @@ int toku_open_ft_handle (const char *fname, int is_create, FT_HANDLE *ft_handle_
                    CACHETABLE cachetable, TOKUTXN txn,
                    int (*compare_fun)(DB *, const DBT*,const DBT*)) {
     FT_HANDLE brt;
-    int r;
     const int only_create = 0;
 
-    r = toku_ft_handle_create(&brt);
-    if (r != 0)
-        return r;
+    toku_ft_handle_create(&brt);
     toku_ft_handle_set_nodesize(brt, nodesize);
     toku_ft_handle_set_basementnodesize(brt, basementnodesize);
     toku_ft_handle_set_compression_method(brt, compression_method);
-    r = toku_ft_set_bt_compare(brt, compare_fun); assert_zero(r);
+    toku_ft_set_bt_compare(brt, compare_fun);
 
-    r = toku_ft_handle_open(brt, fname, is_create, only_create, cachetable, txn);
+    int r = toku_ft_handle_open(brt, fname, is_create, only_create, cachetable, txn);
     if (r != 0) {
         return r;
     }
@@ -3098,8 +3000,7 @@ verify_builtin_comparisons_consistent(FT_HANDLE t, uint32_t flags) {
 // See comments in toku_db_change_descriptor to understand invariants 
 // in the system when this function is called
 //
-int
-toku_ft_change_descriptor(
+void toku_ft_change_descriptor(
     FT_HANDLE ft_h,
     const DBT* old_descriptor,
     const DBT* new_descriptor,
@@ -3108,7 +3009,6 @@ toku_ft_change_descriptor(
     bool update_cmp_descriptor
     )
 {
-    int r = 0;
     DESCRIPTOR_S new_d;
 
     // if running with txns, save to rollback + write to recovery log
@@ -3116,18 +3016,17 @@ toku_ft_change_descriptor(
         // put information into rollback file
         BYTESTRING old_desc_bs = { old_descriptor->size, (char *) old_descriptor->data };
         BYTESTRING new_desc_bs = { new_descriptor->size, (char *) new_descriptor->data };
-        r = toku_logger_save_rollback_change_fdescriptor(
+        toku_logger_save_rollback_change_fdescriptor(
             txn,
             toku_cachefile_filenum(ft_h->ft->cf),
             &old_desc_bs
             );
-        if (r != 0) { goto cleanup; }
         toku_txn_maybe_note_ft(txn, ft_h->ft);
 
         if (do_log) {
             TOKULOGGER logger = toku_txn_logger(txn);
             TXNID xid = toku_txn_get_txnid(txn);
-            r = toku_log_change_fdescriptor(
+            toku_log_change_fdescriptor(
                 logger, NULL, 0,
                 txn,
                 toku_cachefile_filenum(ft_h->ft->cf),
@@ -3136,7 +3035,6 @@ toku_ft_change_descriptor(
                 new_desc_bs,
                 update_cmp_descriptor
                 );
-            if (r != 0) { goto cleanup; }
         }
     }
 
@@ -3144,16 +3042,11 @@ toku_ft_change_descriptor(
     new_d.dbt = *new_descriptor;
     toku_ft_update_descriptor(ft_h->ft, &new_d);
     // very infrequent operation, worth precise threadsafe count
-    if (r == 0) {
-        STATUS_INC(FT_DESCRIPTOR_SET, 1);
-    }
-    if (r!=0) goto cleanup;
+    STATUS_INC(FT_DESCRIPTOR_SET, 1);
 
     if (update_cmp_descriptor) {
         toku_ft_update_cmp_descriptor(ft_h->ft);
     }
-cleanup:
-    return r;
 }
 
 static void
@@ -3188,10 +3081,6 @@ ft_handle_open(FT_HANDLE ft_h, const char *fname_in_env, int is_create, int only
         r = verify_builtin_comparisons_consistent(ft_h, ft_h->options.flags);
         if (r!=0) { goto exit; }
     }
-    if (txn && txn->logger->is_panicked) {
-        r = EINVAL;
-        goto exit;
-    }
 
     assert(is_create || !only_create);
     FILENUM reserved_filenum;
@@ -3208,12 +3097,10 @@ ft_handle_open(FT_HANDLE ft_h, const char *fname_in_env, int is_create, int only
             mode_t mode = S_IRWXU|S_IRWXG|S_IRWXO;
             if (txn) {
                 BYTESTRING bs = { .len=(uint32_t) strlen(fname_in_env), .data = (char*)fname_in_env };
-                r = toku_logger_save_rollback_fcreate(txn, reserved_filenum, &bs); // bs is a copy of the fname relative to the environment
-                assert_zero(r);
+                toku_logger_save_rollback_fcreate(txn, reserved_filenum, &bs); // bs is a copy of the fname relative to the environment
             }
             txn_created = (bool)(txn!=NULL);
-            r = toku_logger_log_fcreate(txn, fname_in_env, reserved_filenum, mode, ft_h->options.flags, ft_h->options.nodesize, ft_h->options.basementnodesize, ft_h->options.compression_method);
-            assert_zero(r); // only possible failure is panic, which we check above
+            toku_logger_log_fcreate(txn, fname_in_env, reserved_filenum, mode, ft_h->options.flags, ft_h->options.nodesize, ft_h->options.basementnodesize, ft_h->options.compression_method);
             r = ft_create_file(ft_h, fname_in_cwd, &fd);
             assert_zero(r);
         }
@@ -3255,8 +3142,7 @@ ft_handle_open(FT_HANDLE ft_h, const char *fname_in_env, int is_create, int only
 
     if (!was_already_open) {
         if (!did_create) { //Only log the fopen that OPENs the file.  If it was already open, don't log.
-            r = toku_logger_log_fopen(txn, fname_in_env, toku_cachefile_filenum(cf), ft_h->options.flags);
-            assert_zero(r);
+            toku_logger_log_fopen(txn, fname_in_env, toku_cachefile_filenum(cf), ft_h->options.flags);
         }
     }
     int use_reserved_dict_id;
@@ -3317,13 +3203,12 @@ ft_handle_open(FT_HANDLE ft_h, const char *fname_in_env, int is_create, int only
             toku_ft_release_reflock(ft);
             if (!needed) {
                 //Close immediately.
-                char *error_string = NULL;
-                r = toku_ft_evict_from_memory(ft, &error_string, false, ZERO_LSN);
+                r = toku_ft_evict_from_memory(ft, false, ZERO_LSN);
                 lazy_assert_zero(r);
             }
         }
         else {
-            toku_cachefile_close(&cf, 0, false, ZERO_LSN);
+            toku_cachefile_close(&cf, false, ZERO_LSN);
         }
     }
     toku_ft_open_close_unlock();
@@ -3354,10 +3239,8 @@ toku_ft_handle_open(FT_HANDLE t, const char *fname_in_env, int is_create, int on
 // clone an ft handle. the cloned handle has a new dict_id but refers to the same fractal tree
 int 
 toku_ft_handle_clone(FT_HANDLE *cloned_ft_handle, FT_HANDLE ft_handle, TOKUTXN txn) {
-    int r;
     FT_HANDLE result_ft_handle; 
-    r = toku_ft_handle_create(&result_ft_handle);
-    resource_assert_zero(r);
+    toku_ft_handle_create(&result_ft_handle);
 
     // we're cloning, so the handle better have an open ft and open cf
     invariant(ft_handle->ft);
@@ -3370,7 +3253,7 @@ toku_ft_handle_clone(FT_HANDLE *cloned_ft_handle, FT_HANDLE ft_handle, TOKUTXN t
     CACHEFILE cf = ft_handle->ft->cf;
     CACHETABLE ct = toku_cachefile_get_cachetable(cf);
     const char *fname_in_env = toku_cachefile_fname_in_env(cf);
-    r = toku_ft_handle_open(result_ft_handle, fname_in_env, false, false, ct, txn); 
+    int r = toku_ft_handle_open(result_ft_handle, fname_in_env, false, false, ct, txn); 
     if (r != 0) {
         toku_ft_handle_close(result_ft_handle);
         result_ft_handle = NULL;
@@ -3466,9 +3349,8 @@ void toku_ft_handle_get_basementnodesize(FT_HANDLE ft_handle, unsigned int *base
     }
 }
 
-int toku_ft_set_bt_compare(FT_HANDLE brt, int (*bt_compare)(DB*, const DBT*, const DBT*)) {
+void toku_ft_set_bt_compare(FT_HANDLE brt, int (*bt_compare)(DB*, const DBT*, const DBT*)) {
     brt->options.compare_fun = bt_compare;
-    return 0;
 }
 
 void toku_ft_set_redirect_callback(FT_HANDLE brt, on_redirect_callback redir_cb, void* extra) {
@@ -3476,9 +3358,8 @@ void toku_ft_set_redirect_callback(FT_HANDLE brt, on_redirect_callback redir_cb,
     brt->redirect_callback_extra = extra;
 }
 
-int toku_ft_set_update(FT_HANDLE brt, ft_update_func update_fun) {
+void toku_ft_set_update(FT_HANDLE brt, ft_update_func update_fun) {
     brt->options.update_fun = update_fun;
-    return 0;
 }
 
 ft_compare_func toku_ft_get_bt_compare (FT_HANDLE brt) {
@@ -3523,10 +3404,8 @@ toku_close_ft_handle_nolsn (FT_HANDLE ft_handle, char** UU(error_string)) {
     return 0;
 }
 
-int toku_ft_handle_create(FT_HANDLE *ft_handle_ptr) {
-    FT_HANDLE MALLOC(brt);
-    if (brt == 0)
-        return ENOMEM;
+void toku_ft_handle_create(FT_HANDLE *ft_handle_ptr) {
+    FT_HANDLE XMALLOC(brt);
     memset(brt, 0, sizeof *brt);
     toku_list_init(&brt->live_ft_handle_link);
     brt->options.flags = 0;
@@ -3537,7 +3416,6 @@ int toku_ft_handle_create(FT_HANDLE *ft_handle_ptr) {
     brt->options.compare_fun = toku_builtin_compare_fun;
     brt->options.update_fun = NULL;
     *ft_handle_ptr = brt;
-    return 0;
 }
 
 /* ************* CURSORS ********************* */
@@ -3681,7 +3559,7 @@ toku_ft_cursor_set_range_lock(FT_CURSOR cursor, const DBT *left, const DBT *righ
     }
 }
 
-int toku_ft_cursor_close(FT_CURSOR cursor) {
+void toku_ft_cursor_close(FT_CURSOR cursor) {
     ft_cursor_cleanup_dbts(cursor);
     if (cursor->range_lock_left_key.data) {
         toku_free(cursor->range_lock_left_key.data);
@@ -3692,7 +3570,6 @@ int toku_ft_cursor_close(FT_CURSOR cursor) {
         toku_destroy_dbt(&cursor->range_lock_right_key);
     }
     toku_free(cursor);
-    return 0;
 }
 
 static inline void ft_cursor_set_prefetching(FT_CURSOR cursor) {
@@ -5245,7 +5122,7 @@ toku_ft_lookup (FT_HANDLE brt, DBT *k, FT_GET_CALLBACK_FUNCTION getf, void *getf
     int op = DB_SET;
     r = toku_ft_cursor_get(cursor, k, getf, getf_v, op);
 
-    rr = toku_ft_cursor_close(cursor); assert_zero(rr);
+    toku_ft_cursor_close(cursor);
 
     return r;
 }
@@ -5271,7 +5148,7 @@ toku_ft_cursor_delete(FT_CURSOR cursor, int flags, TOKUTXN txn) {
             r = toku_ft_cursor_current(cursor, DB_CURRENT, getf_nothing, NULL);
         }
         if (r == 0) {
-            r = toku_ft_delete(cursor->ft_handle, &cursor->key, txn);
+            toku_ft_delete(cursor->ft_handle, &cursor->key, txn);
         }
     }
     return r;
@@ -5394,8 +5271,7 @@ toku_ft_keyrange_internal (FT_HANDLE brt, FTNODE node,
     return r;
 }
 
-int
-toku_ft_keyrange (FT_HANDLE brt, DBT *key, uint64_t *less_p, uint64_t *equal_p, uint64_t *greater_p)
+void toku_ft_keyrange(FT_HANDLE brt, DBT *key, uint64_t *less_p, uint64_t *equal_p, uint64_t *greater_p)
 // Effect: Return an estimate  of the number of keys to the left, the number equal, and the number to the right of the key.
 //   The values are an estimate.
 //   If you perform a keyrange on two keys that are in the same in-memory and uncompressed basement,
@@ -5452,14 +5328,11 @@ toku_ft_keyrange (FT_HANDLE brt, DBT *key, uint64_t *less_p, uint64_t *equal_p,
         *equal_p   = equal;
         *greater_p = greater;
     }
-    return 0;
 }
 
-int
-toku_ft_handle_stat64 (FT_HANDLE brt, TOKUTXN UU(txn), struct ftstat64_s *s) {
+void toku_ft_handle_stat64 (FT_HANDLE brt, TOKUTXN UU(txn), struct ftstat64_s *s) {
     assert(brt->ft);
     toku_ft_stat64(brt->ft, s);
-    return 0;
 }
 
 /* ********************* debugging dump ************************ */
@@ -5596,10 +5469,6 @@ toku_ft_suppress_recovery_logs (FT_HANDLE brt, TOKUTXN txn) {
     txn->checkpoint_needed_before_commit = true;
 }
 
-int toku_ft_handle_set_panic(FT_HANDLE brt, int panic, const char *panic_string) {
-    return toku_ft_set_panic(brt->ft, panic, panic_string);
-}
-
 // Prepare to remove a dictionary from the database when this transaction is committed:
 //  - mark transaction as NEED fsync on commit
 //  - make entry in rollback log
@@ -5616,13 +5485,10 @@ int toku_ft_handle_set_panic(FT_HANDLE brt, int panic, const char *panic_string)
 //           3.) we're already holding the multi operation lock to 
 //           synchronize with begin checkpoint.
 // Contract: the iname of the ft should never be reused.
-int 
-toku_ft_unlink_on_commit(FT_HANDLE handle, TOKUTXN txn) {
-    int r;
-    CACHEFILE cf;
-
+void toku_ft_unlink_on_commit(FT_HANDLE handle, TOKUTXN txn) {
     assert(txn);
-    cf = handle->ft->cf;
+
+    CACHEFILE cf = handle->ft->cf;
     FT CAST_FROM_VOIDP(ft, toku_cachefile_get_userdata(cf));
 
     toku_txn_maybe_note_ft(txn, ft);
@@ -5631,11 +5497,9 @@ toku_ft_unlink_on_commit(FT_HANDLE handle, TOKUTXN txn) {
     toku_txn_force_fsync_on_commit(txn); 
     // make entry in rollback log
     FILENUM filenum = toku_cachefile_filenum(cf);
-    r = toku_logger_save_rollback_fdelete(txn, filenum);
-    assert_zero(r);
+    toku_logger_save_rollback_fdelete(txn, filenum);
     // make entry in recovery log
-    r = toku_logger_log_fdelete(txn, filenum);
-    return r;
+    toku_logger_log_fdelete(txn, filenum);
 }
 
 // Non-transactional version of fdelete
@@ -5644,8 +5508,7 @@ toku_ft_unlink_on_commit(FT_HANDLE handle, TOKUTXN txn) {
 //         pinned by checkpoint. see toku_remove_ft_ref() and how unlink on
 //         close works in toku_cachefile_close();
 // Requires: serialized with begin checkpoint
-void 
-toku_ft_unlink(FT_HANDLE handle) {
+void toku_ft_unlink(FT_HANDLE handle) {
     CACHEFILE cf;
     cf = handle->ft->cf;
     toku_cachefile_unlink_on_close(cf);
diff --git a/ft/ft-ops.h b/ft/ft-ops.h
index 90d20f489e5..8d4d3303ff6 100644
--- a/ft/ft-ops.h
+++ b/ft/ft-ops.h
@@ -37,10 +37,10 @@ int toku_open_ft_handle (const char *fname, int is_create, FT_HANDLE *, int node
 // - can only update cmp descriptor immidiately after opening the FIRST ft handle for this ft and before 
 //   ANY operations. to update the cmp descriptor after any operations have already happened, all handles 
 //   and transactions must close and reopen before the change, then you can update the cmp descriptor
-int toku_ft_change_descriptor(FT_HANDLE t, const DBT* old_descriptor, const DBT* new_descriptor, bool do_log, TOKUTXN txn, bool update_cmp_descriptor);
+void toku_ft_change_descriptor(FT_HANDLE t, const DBT* old_descriptor, const DBT* new_descriptor, bool do_log, TOKUTXN txn, bool update_cmp_descriptor);
 uint32_t toku_serialize_descriptor_size(const DESCRIPTOR desc);
 
-int toku_ft_handle_create(FT_HANDLE *)  __attribute__ ((warn_unused_result));
+void toku_ft_handle_create(FT_HANDLE *ft);
 void toku_ft_set_flags(FT_HANDLE, unsigned int flags);
 void toku_ft_get_flags(FT_HANDLE, unsigned int *flags);
 void toku_ft_handle_set_nodesize(FT_HANDLE, unsigned int nodesize);
@@ -51,7 +51,7 @@ void toku_ft_handle_get_basementnodesize(FT_HANDLE, unsigned int *basementnodesi
 void toku_ft_handle_set_compression_method(FT_HANDLE, enum toku_compression_method);
 void toku_ft_handle_get_compression_method(FT_HANDLE, enum toku_compression_method *);
 
-int toku_ft_set_bt_compare(FT_HANDLE, ft_compare_func)  __attribute__ ((warn_unused_result));
+void toku_ft_set_bt_compare(FT_HANDLE, ft_compare_func);
 ft_compare_func toku_ft_get_bt_compare (FT_HANDLE brt);
 
 void toku_ft_set_redirect_callback(FT_HANDLE brt, on_redirect_callback redir_cb, void* extra);
@@ -92,7 +92,7 @@ void toku_ft_set_redirect_callback(FT_HANDLE brt, on_redirect_callback redir_cb,
 // Implementation note: Acquires a write lock on the entire database.
 //  This function works by sending an BROADCAST-UPDATE message containing
 //   the key and the extra.
-int toku_ft_set_update(FT_HANDLE brt, ft_update_func update_fun) __attribute__ ((warn_unused_result));
+void toku_ft_set_update(FT_HANDLE brt, ft_update_func update_fun);
 
 int toku_ft_handle_open(FT_HANDLE, const char *fname_in_env,
 		  int is_create, int only_create, CACHETABLE ct, TOKUTXN txn)  __attribute__ ((warn_unused_result));
@@ -122,52 +122,44 @@ toku_ft_handle_open_with_dict_id(
 int toku_ft_lookup (FT_HANDLE brt, DBT *k, FT_GET_CALLBACK_FUNCTION getf, void *getf_v)  __attribute__ ((warn_unused_result));
 
 // Effect: Insert a key and data pair into a brt
-// Returns 0 if successful
-int toku_ft_insert (FT_HANDLE brt, DBT *k, DBT *v, TOKUTXN txn)  __attribute__ ((warn_unused_result));
+void toku_ft_insert (FT_HANDLE brt, DBT *k, DBT *v, TOKUTXN txn);
 
-int toku_ft_optimize (FT_HANDLE brt)  __attribute__ ((warn_unused_result));
+// Effect: Optimize the ft
+void toku_ft_optimize (FT_HANDLE brt);
 
 // Effect: Insert a key and data pair into a brt if the oplsn is newer than the brt lsn.  This function is called during recovery.
-// Returns 0 if successful
-int toku_ft_maybe_insert (FT_HANDLE brt, DBT *k, DBT *v, TOKUTXN txn, bool oplsn_valid, LSN oplsn, bool do_logging, enum ft_msg_type type)  __attribute__ ((warn_unused_result));
+void toku_ft_maybe_insert (FT_HANDLE brt, DBT *k, DBT *v, TOKUTXN txn, bool oplsn_valid, LSN oplsn, bool do_logging, enum ft_msg_type type);
 
 // Effect: Send an update message into a brt.  This function is called
 // during recovery.
-// Returns 0 if successful
-int toku_ft_maybe_update(FT_HANDLE brt, const DBT *key, const DBT *update_function_extra, TOKUTXN txn, bool oplsn_valid, LSN oplsn, bool do_logging) __attribute__ ((warn_unused_result));
+void toku_ft_maybe_update(FT_HANDLE brt, const DBT *key, const DBT *update_function_extra, TOKUTXN txn, bool oplsn_valid, LSN oplsn, bool do_logging);
 
 // Effect: Send a broadcasting update message into a brt.  This function
 // is called during recovery.
-// Returns 0 if successful
-int toku_ft_maybe_update_broadcast(FT_HANDLE brt, const DBT *update_function_extra, TOKUTXN txn, bool oplsn_valid, LSN oplsn, bool do_logging, bool is_resetting_op) __attribute__ ((warn_unused_result));
+void toku_ft_maybe_update_broadcast(FT_HANDLE brt, const DBT *update_function_extra, TOKUTXN txn, bool oplsn_valid, LSN oplsn, bool do_logging, bool is_resetting_op);
 
-int toku_ft_load_recovery(TOKUTXN txn, FILENUM old_filenum, char const * new_iname, int do_fsync, int do_log, LSN *load_lsn)  __attribute__ ((warn_unused_result));
-int toku_ft_load(FT_HANDLE brt, TOKUTXN txn, char const * new_iname, int do_fsync, LSN *get_lsn)  __attribute__ ((warn_unused_result));
-// 2954
-int toku_ft_hot_index_recovery(TOKUTXN txn, FILENUMS filenums, int do_fsync, int do_log, LSN *hot_index_lsn);
-int toku_ft_hot_index(FT_HANDLE brt, TOKUTXN txn, FILENUMS filenums, int do_fsync, LSN *lsn) __attribute__ ((warn_unused_result));
+void toku_ft_load_recovery(TOKUTXN txn, FILENUM old_filenum, char const * new_iname, int do_fsync, int do_log, LSN *load_lsn);
+void toku_ft_load(FT_HANDLE brt, TOKUTXN txn, char const * new_iname, int do_fsync, LSN *get_lsn);
+void toku_ft_hot_index_recovery(TOKUTXN txn, FILENUMS filenums, int do_fsync, int do_log, LSN *hot_index_lsn);
+void toku_ft_hot_index(FT_HANDLE brt, TOKUTXN txn, FILENUMS filenums, int do_fsync, LSN *lsn);
 
-int toku_ft_log_put_multiple (TOKUTXN txn, FT_HANDLE src_ft, FT_HANDLE *brts, int num_fts, const DBT *key, const DBT *val)  __attribute__ ((warn_unused_result));
-int toku_ft_log_put (TOKUTXN txn, FT_HANDLE brt, const DBT *key, const DBT *val)  __attribute__ ((warn_unused_result));
-int toku_ft_log_del_multiple (TOKUTXN txn, FT_HANDLE src_ft, FT_HANDLE *brts, int num_fts, const DBT *key, const DBT *val) __attribute__ ((warn_unused_result));
-int toku_ft_log_del (TOKUTXN txn, FT_HANDLE brt, const DBT *key) __attribute__ ((warn_unused_result));
+void toku_ft_log_put_multiple (TOKUTXN txn, FT_HANDLE src_ft, FT_HANDLE *brts, int num_fts, const DBT *key, const DBT *val);
+void toku_ft_log_put (TOKUTXN txn, FT_HANDLE brt, const DBT *key, const DBT *val);
+void toku_ft_log_del_multiple (TOKUTXN txn, FT_HANDLE src_ft, FT_HANDLE *brts, int num_fts, const DBT *key, const DBT *val);
+void toku_ft_log_del (TOKUTXN txn, FT_HANDLE brt, const DBT *key);
 
 // Effect: Delete a key from a brt
-// Returns 0 if successful
-int toku_ft_delete (FT_HANDLE brt, DBT *k, TOKUTXN txn)  __attribute__ ((warn_unused_result));
+void toku_ft_delete (FT_HANDLE brt, DBT *k, TOKUTXN txn);
 
 // Effect: Delete a key from a brt if the oplsn is newer than the brt lsn.  This function is called during recovery.
-// Returns 0 if successful
-int toku_ft_maybe_delete (FT_HANDLE brt, DBT *k, TOKUTXN txn, bool oplsn_valid, LSN oplsn, bool do_logging)  __attribute__ ((warn_unused_result));
+void toku_ft_maybe_delete (FT_HANDLE brt, DBT *k, TOKUTXN txn, bool oplsn_valid, LSN oplsn, bool do_logging);
 
-int toku_ft_send_insert(FT_HANDLE brt, DBT *key, DBT *val, XIDS xids, enum ft_msg_type type) __attribute__ ((warn_unused_result));
-int toku_ft_send_delete(FT_HANDLE brt, DBT *key, XIDS xids) __attribute__ ((warn_unused_result));
-int toku_ft_send_commit_any(FT_HANDLE brt, DBT *key, XIDS xids) __attribute__ ((warn_unused_result));
+void toku_ft_send_insert(FT_HANDLE brt, DBT *key, DBT *val, XIDS xids, enum ft_msg_type type);
+void toku_ft_send_delete(FT_HANDLE brt, DBT *key, XIDS xids);
+void toku_ft_send_commit_any(FT_HANDLE brt, DBT *key, XIDS xids);
 
 int toku_close_ft_handle_nolsn (FT_HANDLE, char **error_string)  __attribute__ ((warn_unused_result));
 
-int toku_ft_handle_set_panic(FT_HANDLE brt, int panic, const char *panic_string)  __attribute__ ((warn_unused_result));
-
 int toku_dump_ft (FILE *,FT_HANDLE brt)  __attribute__ ((warn_unused_result));
 
 extern int toku_ft_debug_mode;
@@ -200,7 +192,7 @@ int toku_ft_cursor_get_both_range(FT_CURSOR cursor, DBT *key, DBT *val, FT_GET_C
 int toku_ft_cursor_get_both_range_reverse(FT_CURSOR cursor, DBT *key, DBT *val, FT_GET_CALLBACK_FUNCTION getf, void *getf_v)  __attribute__ ((warn_unused_result));
 
 int toku_ft_cursor_delete(FT_CURSOR cursor, int flags, TOKUTXN)  __attribute__ ((warn_unused_result));
-int toku_ft_cursor_close (FT_CURSOR curs)  __attribute__ ((warn_unused_result));
+void toku_ft_cursor_close (FT_CURSOR curs);
 bool toku_ft_cursor_uninitialized(FT_CURSOR c)  __attribute__ ((warn_unused_result));
 
 void toku_ft_cursor_peek(FT_CURSOR cursor, const DBT **pkey, const DBT **pval);
@@ -214,8 +206,7 @@ enum ft_flags {
     TOKU_DB_VALCMP_BUILTIN_13  = (1<<3),
 };
 
-int 
-toku_ft_keyrange (FT_HANDLE brt, DBT *key, uint64_t *less,  uint64_t *equal,  uint64_t *greater) __attribute__ ((warn_unused_result));
+void toku_ft_keyrange(FT_HANDLE brt, DBT *key, uint64_t *less,  uint64_t *equal,  uint64_t *greater);
 
 struct ftstat64_s {
     uint64_t nkeys; /* estimate how many unique keys (even when flattened this may be an estimate)     */
@@ -228,8 +219,7 @@ struct ftstat64_s {
     uint64_t verify_time_sec; /* time of last verification, in seconds */
 };
 
-int 
-toku_ft_handle_stat64 (FT_HANDLE, TOKUTXN, struct ftstat64_s *stat) __attribute__ ((warn_unused_result));
+void toku_ft_handle_stat64 (FT_HANDLE, TOKUTXN, struct ftstat64_s *stat);
 
 int toku_ft_layer_init(void) __attribute__ ((warn_unused_result));
 void toku_ft_open_close_lock(void);
diff --git a/ft/ft-serialize.cc b/ft/ft-serialize.cc
index 47ee213a457..19ec7e2052e 100644
--- a/ft/ft-serialize.cc
+++ b/ft/ft-serialize.cc
@@ -149,8 +149,6 @@ deserialize_ft_versioned(int fd, struct rbuf *rb, FT *ftp, uint32_t version)
 
     XCALLOC(ft);
     ft->checkpoint_header = NULL;
-    ft->panic = 0;
-    ft->panic_string = 0;
     toku_list_init(&ft->live_ft_handles);
 
     //version MUST be in network order on disk regardless of disk order
@@ -364,10 +362,9 @@ deserialize_ft_versioned(int fd, struct rbuf *rb, FT *ftp, uint32_t version)
     return r;
 }
 
-static uint32_t
+static size_t
 serialize_ft_min_size (uint32_t version) {
-    uint32_t size = 0;
-
+    size_t size = 0;
 
     switch(version) {
     case FT_LAYOUT_VERSION_20:
@@ -418,6 +415,7 @@ serialize_ft_min_size (uint32_t version) {
     default:
         lazy_assert(false);
     }
+    
     lazy_assert(size <= BLOCK_ALLOCATOR_HEADER_RESERVE);
     return size;
 }
@@ -654,15 +652,15 @@ toku_deserialize_ft_from(int fd,
 }
 
 
-int toku_serialize_ft_size (FT_HEADER h) {
-    uint32_t size = serialize_ft_min_size(h->layout_version);
+size_t toku_serialize_ft_size (FT_HEADER h) {
+    size_t size = serialize_ft_min_size(h->layout_version);
     //There is no dynamic data.
     lazy_assert(size <= BLOCK_ALLOCATOR_HEADER_RESERVE);
     return size;
 }
 
 
-int toku_serialize_ft_to_wbuf (
+void toku_serialize_ft_to_wbuf (
     struct wbuf *wbuf, 
     FT_HEADER h, 
     DISKOFF translation_location_on_disk, 
@@ -700,59 +698,47 @@ int toku_serialize_ft_to_wbuf (
     uint32_t checksum = x1764_finish(&wbuf->checksum);
     wbuf_int(wbuf, checksum);
     lazy_assert(wbuf->ndone == wbuf->size);
-    return 0;
 }
 
-int toku_serialize_ft_to (int fd, FT_HEADER h, BLOCK_TABLE blocktable, CACHEFILE cf) {
-    int rr = 0;
+void toku_serialize_ft_to (int fd, FT_HEADER h, BLOCK_TABLE blocktable, CACHEFILE cf) {
     lazy_assert(h->type==FT_CHECKPOINT_INPROGRESS);
     struct wbuf w_translation;
     int64_t size_translation;
     int64_t address_translation;
-    {
-        //Must serialize translation first, to get address,size for header.
-        toku_serialize_translation_to_wbuf(blocktable, fd, &w_translation,
-                                                   &address_translation,
-                                                   &size_translation);
-        lazy_assert(size_translation==w_translation.size);
-    }
+
+    //Must serialize translation first, to get address,size for header.
+    toku_serialize_translation_to_wbuf(blocktable, fd, &w_translation,
+                                               &address_translation,
+                                               &size_translation);
+    lazy_assert(size_translation == w_translation.size);
+
     struct wbuf w_main;
-    unsigned int size_main = toku_serialize_ft_size(h);
-    {
-        wbuf_init(&w_main, toku_xmalloc(size_main), size_main);
-        {
-            int r=toku_serialize_ft_to_wbuf(&w_main, h, address_translation, size_translation);
-            lazy_assert_zero(r);
-        }
-        lazy_assert(w_main.ndone==size_main);
-    }
-    {
-        //Actual Write translation table
-        toku_os_full_pwrite(fd, w_translation.buf,
-                                size_translation, address_translation);
-    }
-    {
-        //Everything but the header MUST be on disk before header starts.
-        //Otherwise we will think the header is good and some blocks might not
-        //yet be on disk.
-        //If the header has a cachefile we need to do cachefile fsync (to
-        //prevent crash if we redirected to dev null)
-        //If there is no cachefile we still need to do an fsync.
-        if (cf) {
-            rr = toku_cachefile_fsync(cf);
-        }
-        else {
-            rr = toku_file_fsync(fd);
-        }
-        if (rr==0) {
-            //Alternate writing header to two locations:
-            //   Beginning (0) or BLOCK_ALLOCATOR_HEADER_RESERVE
-            toku_off_t main_offset;
-            main_offset = (h->checkpoint_count & 0x1) ? 0 : BLOCK_ALLOCATOR_HEADER_RESERVE;
-            toku_os_full_pwrite(fd, w_main.buf, w_main.ndone, main_offset);
-        }
-    }
+    size_t size_main = toku_serialize_ft_size(h);
+    wbuf_init(&w_main, toku_xmalloc(size_main), size_main);
+    toku_serialize_ft_to_wbuf(&w_main, h, address_translation, size_translation);
+    lazy_assert(w_main.ndone == size_main);
+
+    //Actual Write translation table
+    toku_os_full_pwrite(fd, w_translation.buf, size_translation, address_translation);
+
+    //Everything but the header MUST be on disk before header starts.
+    //Otherwise we will think the header is good and some blocks might not
+    //yet be on disk.
+    //If the header has a cachefile we need to do cachefile fsync (to
+    //prevent crash if we redirected to dev null)
+    //If there is no cachefile we still need to do an fsync.
+    if (cf) {
+        toku_cachefile_fsync(cf);
+    }
+    else {
+        toku_file_fsync(fd);
+    }
+
+    //Alternate writing header to two locations:
+    //   Beginning (0) or BLOCK_ALLOCATOR_HEADER_RESERVE
+    toku_off_t main_offset;
+    main_offset = (h->checkpoint_count & 0x1) ? 0 : BLOCK_ALLOCATOR_HEADER_RESERVE;
+    toku_os_full_pwrite(fd, w_main.buf, w_main.ndone, main_offset);
     toku_free(w_main.buf);
     toku_free(w_translation.buf);
-    return rr;
 }
diff --git a/ft/ft-test-helpers.cc b/ft/ft-test-helpers.cc
index 436919056a8..10b8211a731 100644
--- a/ft/ft-test-helpers.cc
+++ b/ft/ft-test-helpers.cc
@@ -208,8 +208,7 @@ int toku_testsetup_insert_to_nonleaf (FT_HANDLE brt, BLOCKNUM blocknum, enum ft_
 
     XIDS xids_0 = xids_get_root_xids();
     MSN msn = next_dummymsn();
-    r = toku_bnc_insert_msg(BNC(node, childnum), key, keylen, val, vallen, cmdtype, msn, xids_0, true, NULL, testhelper_string_key_cmp);
-    assert(r==0);
+    toku_bnc_insert_msg(BNC(node, childnum), key, keylen, val, vallen, cmdtype, msn, xids_0, true, NULL, testhelper_string_key_cmp);
     // Hack to get the test working. The problem is that this test
     // is directly queueing something in a FIFO instead of 
     // using brt APIs.
diff --git a/ft/ft.cc b/ft/ft.cc
index 61259209959..cf381f0bcf1 100644
--- a/ft/ft.cc
+++ b/ft/ft.cc
@@ -31,8 +31,6 @@ toku_reset_root_xid_that_created(FT ft, TXNID new_root_xid_that_created) {
 
 static void
 ft_destroy(FT ft) {
-    if (!ft->panic) assert(!ft->checkpoint_header);
-
     //header and checkpoint_header have same Blocktable pointer
     //cannot destroy since it is still in use by CURRENT
     assert(ft->h->type == FT_CURRENT);
@@ -51,7 +49,6 @@ static void
 ft_copy_for_checkpoint_unlocked(FT ft, LSN checkpoint_lsn) {
     assert(ft->h->type == FT_CURRENT);
     assert(ft->checkpoint_header == NULL);
-    assert(ft->panic==0);
 
     FT_HEADER XMEMDUP(ch, ft->h);
     ch->type = FT_CHECKPOINT_INPROGRESS; //Different type
@@ -93,7 +90,7 @@ toku_ft_release_reflock(FT ft) {
 //
 
 // maps to cf->log_fassociate_during_checkpoint
-static int
+static void
 ft_log_fassociate_during_checkpoint (CACHEFILE cf, void *header_v) {
     FT ft = (FT) header_v;
     char* fname_in_env = toku_cachefile_fname_in_env(cf);
@@ -102,14 +99,12 @@ ft_log_fassociate_during_checkpoint (CACHEFILE cf, void *header_v) {
     TOKULOGGER logger = toku_cachefile_logger(cf);
     FILENUM filenum = toku_cachefile_filenum(cf);
     bool unlink_on_close = toku_cachefile_is_unlink_on_close(cf);
-    int r = toku_log_fassociate(logger, NULL, 0, filenum, ft->h->flags, bs, unlink_on_close);
-    return r;
+    toku_log_fassociate(logger, NULL, 0, filenum, ft->h->flags, bs, unlink_on_close);
 }
 
 // maps to cf->log_suppress_rollback_during_checkpoint
-static int
+static void
 ft_log_suppress_rollback_during_checkpoint (CACHEFILE cf, void *header_v) {
-    int r = 0;
     FT h = (FT) header_v;
     TXNID xid = h->txnid_that_created_or_locked_when_empty;
     if (xid != TXNID_NONE) {
@@ -119,9 +114,8 @@ ft_log_suppress_rollback_during_checkpoint (CACHEFILE cf, void *header_v) {
         // We don't have access to the txn here, but the txn is
         // necessarily already marked as non-readonly.  Use NULL.
         TOKUTXN txn = NULL;
-        r = toku_log_suppress_rollback(logger, NULL, 0, txn, filenum, xid);
+        toku_log_suppress_rollback(logger, NULL, 0, txn, filenum, xid);
     }
-    return r;
 }
 
 // Maps to cf->begin_checkpoint_userdata
@@ -129,21 +123,16 @@ ft_log_suppress_rollback_during_checkpoint (CACHEFILE cf, void *header_v) {
 // Has access to fd (it is protected).
 //
 // Not reentrant for a single FT (see ft_checkpoint)
-static int
-ft_begin_checkpoint (LSN checkpoint_lsn, void *header_v) {
+static void ft_begin_checkpoint (LSN checkpoint_lsn, void *header_v) {
     FT ft = (FT) header_v;
-    int r = ft->panic;
-    if (r==0) {
-        // hold lock around copying and clearing of dirty bit
-        toku_ft_lock (ft);
-        assert(ft->h->type == FT_CURRENT);
-        assert(ft->checkpoint_header == NULL);
-        ft_copy_for_checkpoint_unlocked(ft, checkpoint_lsn);
-        ft->h->dirty = 0;             // this is only place this bit is cleared        (in currentheader)
-        toku_block_translation_note_start_checkpoint_unlocked(ft->blocktable);
-        toku_ft_unlock (ft);
-    }
-    return r;
+    // hold lock around copying and clearing of dirty bit
+    toku_ft_lock (ft);
+    assert(ft->h->type == FT_CURRENT);
+    assert(ft->checkpoint_header == NULL);
+    ft_copy_for_checkpoint_unlocked(ft, checkpoint_lsn);
+    ft->h->dirty = 0;             // this is only place this bit is cleared        (in currentheader)
+    toku_block_translation_note_start_checkpoint_unlocked(ft->blocktable);
+    toku_ft_unlock (ft);
 }
 
 // #4922: Hack to remove data corruption race condition.
@@ -180,7 +169,6 @@ ft_checkpoint (CACHEFILE cf, int fd, void *header_v) {
     FT ft = (FT) header_v;
     FT_HEADER ch = ft->checkpoint_header;
     int r = 0;
-    if (ft->panic!=0) goto handle_error;
     //printf("%s:%d allocated_limit=%lu writing queue to %lu\n", __FILE__, __LINE__,
     //             block_allocator_allocated_limit(h->block_allocator), h->unused_blocks.b*h->nodesize);
     assert(ch);
@@ -198,15 +186,11 @@ ft_checkpoint (CACHEFILE cf, int fd, void *header_v) {
         ft_hack_highest_unused_msn_for_upgrade_for_checkpoint(ft);
                                                              
         // write translation and header to disk (or at least to OS internal buffer)
-        r = toku_serialize_ft_to(fd, ch, ft->blocktable, ft->cf);
-        if (r!=0) goto handle_error;
+        toku_serialize_ft_to(fd, ch, ft->blocktable, ft->cf);
         ch->dirty = 0;                      // this is only place this bit is cleared (in checkpoint_header)
         
         // fsync the cachefile
-        r = toku_cachefile_fsync(cf);
-        if (r!=0) {
-            goto handle_error;
-        }
+        toku_cachefile_fsync(cf);
         ft->h->checkpoint_count++;        // checkpoint succeeded, next checkpoint will save to alternate header location
         ft->h->checkpoint_lsn = ch->checkpoint_lsn;  //Header updated.
     } 
@@ -215,8 +199,7 @@ ft_checkpoint (CACHEFILE cf, int fd, void *header_v) {
     }
     if (0) {
 handle_error:
-        if (ft->panic) r = ft->panic;
-        else toku_block_translation_note_failed_checkpoint(ft->blocktable);
+        toku_block_translation_note_failed_checkpoint(ft->blocktable);
     }
     return r;
 
@@ -226,75 +209,56 @@ ft_checkpoint (CACHEFILE cf, int fd, void *header_v) {
 // free unused disk space 
 // (i.e. tell BlockAllocator to liberate blocks used by previous checkpoint).
 // Must have access to fd (protected)
-static int
-ft_end_checkpoint (CACHEFILE UU(cachefile), int fd, void *header_v) {
+static void ft_end_checkpoint (CACHEFILE UU(cachefile), int fd, void *header_v) {
     FT ft = (FT) header_v;
-    int r = ft->panic;
-    if (r==0) {
-        assert(ft->h->type == FT_CURRENT);
-        toku_block_translation_note_end_checkpoint(ft->blocktable, fd);
-    }
-    if (ft->checkpoint_header) {         // could be NULL only if panic was true at begin_checkpoint
+    assert(ft->h->type == FT_CURRENT);
+    toku_block_translation_note_end_checkpoint(ft->blocktable, fd);
+    if (ft->checkpoint_header) {
         toku_free(ft->checkpoint_header);
         ft->checkpoint_header = NULL;
     }
-    return r;
 }
 
 // maps to cf->close_userdata
 // Has access to fd (it is protected).
 static int
-ft_close (CACHEFILE cachefile, int fd, void *header_v, char **malloced_error_string, bool oplsn_valid, LSN oplsn) {
+ft_close(CACHEFILE cachefile, int fd, void *header_v, bool oplsn_valid, LSN oplsn) {
     FT ft = (FT) header_v;
     assert(ft->h->type == FT_CURRENT);
     // We already have exclusive access to this field already, so skip the locking.
     // This should already never fail.
     invariant(!toku_ft_needed_unlocked(ft));
     int r = 0;
-    if (ft->panic) {
-        r = ft->panic;
-    } else {
-        assert(ft->cf == cachefile);
-        TOKULOGGER logger = toku_cachefile_logger(cachefile);
-        LSN lsn = ZERO_LSN;
-        //Get LSN
-        if (oplsn_valid) {
-            //Use recovery-specified lsn
-            lsn = oplsn;
-            //Recovery cannot reduce lsn of a header.
-            if (lsn.lsn < ft->h->checkpoint_lsn.lsn)
-                lsn = ft->h->checkpoint_lsn;
-        }
-        else {
-            //Get LSN from logger
-            lsn = ZERO_LSN; // if there is no logger, we use zero for the lsn
-            if (logger) {
-                char* fname_in_env = toku_cachefile_fname_in_env(cachefile);
-                assert(fname_in_env);
-                BYTESTRING bs = {.len=(uint32_t) strlen(fname_in_env), .data=fname_in_env};
-                r = toku_log_fclose(logger, &lsn, ft->h->dirty, bs, toku_cachefile_filenum(cachefile)); // flush the log on close (if new header is being written), otherwise it might not make it out.
-                if (r!=0) return r;
-            }
-        }
-        if (ft->h->dirty) {               // this is the only place this bit is tested (in currentheader)
-            if (logger) { //Rollback cachefile MUST NOT BE CLOSED DIRTY
-                          //It can be checkpointed only via 'checkpoint'
-                assert(logger->rollback_cachefile != cachefile);
-            }
-            int r2;
-            //assert(lsn.lsn!=0);
-            r2 = ft_begin_checkpoint(lsn, header_v);
-            if (r==0) r = r2;
-            r2 = ft_checkpoint(cachefile, fd, ft);
-            if (r==0) r = r2;
-            r2 = ft_end_checkpoint(cachefile, fd, header_v);
-            if (r==0) r = r2;
-            if (!ft->panic) assert(!ft->h->dirty);             // dirty bit should be cleared by begin_checkpoint and never set again (because we're closing the dictionary)
+    assert(ft->cf == cachefile);
+    TOKULOGGER logger = toku_cachefile_logger(cachefile);
+    LSN lsn = ZERO_LSN;
+    //Get LSN
+    if (oplsn_valid) {
+        //Use recovery-specified lsn
+        lsn = oplsn;
+        //Recovery cannot reduce lsn of a header.
+        if (lsn.lsn < ft->h->checkpoint_lsn.lsn)
+            lsn = ft->h->checkpoint_lsn;
+    }
+    else {
+        //Get LSN from logger
+        lsn = ZERO_LSN; // if there is no logger, we use zero for the lsn
+        if (logger) {
+            char* fname_in_env = toku_cachefile_fname_in_env(cachefile);
+            assert(fname_in_env);
+            BYTESTRING bs = {.len=(uint32_t) strlen(fname_in_env), .data=fname_in_env};
+            toku_log_fclose(logger, &lsn, ft->h->dirty, bs, toku_cachefile_filenum(cachefile)); // flush the log on close (if new header is being written), otherwise it might not make it out.
         }
     }
-    if (malloced_error_string) *malloced_error_string = ft->panic_string;
-    if (r == 0) {
-        r = ft->panic;
+    if (ft->h->dirty) {               // this is the only place this bit is tested (in currentheader)
+        if (logger) { //Rollback cachefile MUST NOT BE CLOSED DIRTY
+                      //It can be checkpointed only via 'checkpoint'
+            assert(logger->rollback_cachefile != cachefile);
+        }
+        ft_begin_checkpoint(lsn, header_v);
+        r = ft_checkpoint(cachefile, fd, ft);
+        ft_end_checkpoint(cachefile, fd, header_v);
+        assert(!ft->h->dirty); // dirty bit should be cleared by begin_checkpoint and never set again (because we're closing the dictionary)
     }
     toku_ft_free(ft);
     return r;
@@ -303,20 +267,14 @@ ft_close (CACHEFILE cachefile, int fd, void *header_v, char **malloced_error_str
 // maps to cf->note_pin_by_checkpoint
 //Must be protected by ydb lock.
 //Is only called by checkpoint begin, which holds it
-static int
-ft_note_pin_by_checkpoint (CACHEFILE UU(cachefile), void *header_v)
-{
-    //Set arbitrary brt (for given header) as pinned by checkpoint.
-    //Only one can be pinned (only one checkpoint at a time), but not worth verifying.
-    FT ft = (FT) header_v;
-
+static void ft_note_pin_by_checkpoint (CACHEFILE UU(cachefile), void *header_v) {
     // Note: open_close lock is held by checkpoint begin
+    FT ft = (FT) header_v;
     toku_ft_grab_reflock(ft);
     assert(!ft->pinned_by_checkpoint);
     assert(toku_ft_needed_unlocked(ft));
     ft->pinned_by_checkpoint = true;
     toku_ft_release_reflock(ft);
-    return 0;
 }
 
 static void
@@ -325,30 +283,27 @@ unpin_by_checkpoint_callback(FT ft, void *extra)
 {
     invariant(extra == NULL);
     invariant(ft->pinned_by_checkpoint);
-    ft->pinned_by_checkpoint = false; //Unpin
+    ft->pinned_by_checkpoint = false;
 }
 
 // maps to cf->note_unpin_by_checkpoint
 //Must be protected by ydb lock.
 //Called by end_checkpoint, which grabs ydb lock around note_unpin
-static int
-ft_note_unpin_by_checkpoint (CACHEFILE UU(cachefile), void *header_v)
-{
+static void ft_note_unpin_by_checkpoint (CACHEFILE UU(cachefile), void *header_v) {
     FT ft = (FT) header_v;
     toku_ft_remove_reference(ft, false, ZERO_LSN, unpin_by_checkpoint_callback, NULL);
-    return 0;
 }
 
 //
 // End of Functions that are callbacks to the cachefile
 /////////////////////////////////////////////////////////////////////////
 
-
 void toku_node_save_ct_pair(void *value_data, PAIR p) {
     FTNODE CAST_FROM_VOIDP(node, value_data);
     node->ct_pair = p;
 }
 
+// TODO: can't fail
 static int setup_initial_ft_root_node (FT ft, BLOCKNUM blocknum) {
     FTNODE XMALLOC(node);
     toku_initialize_empty_ftnode(node, blocknum, 0, 1, ft->h->layout_version, ft->h->flags);
@@ -356,15 +311,12 @@ static int setup_initial_ft_root_node (FT ft, BLOCKNUM blocknum) {
 
     uint32_t fullhash = toku_cachetable_hash(ft->cf, blocknum);
     node->fullhash = fullhash;
-    int r = toku_cachetable_put(ft->cf, blocknum, fullhash,
-                                node, make_ftnode_pair_attr(node),
-                                get_write_callbacks_for_node(ft),
-                                toku_node_save_ct_pair);
-    if (r != 0)
-        toku_free(node);
-    else
-        toku_unpin_ftnode(ft, node);
-    return r;
+    toku_cachetable_put(ft->cf, blocknum, fullhash,
+                        node, make_ftnode_pair_attr(node),
+                        get_write_callbacks_for_node(ft),
+                        toku_node_save_ct_pair);
+    toku_unpin_ftnode(ft, node);
+    return 0;
 }
 
 static int
@@ -554,16 +506,10 @@ toku_ft_has_one_reference_unlocked(FT ft) {
 
 // evict a ft from memory by closing its cachefile. any future work
 // will have to read in the ft in a new cachefile and new FT object.
-int toku_ft_evict_from_memory(FT ft, char **error_string, bool oplsn_valid, LSN oplsn) {
+int toku_ft_evict_from_memory(FT ft, bool oplsn_valid, LSN oplsn) {
     int r = 0;
     assert(ft->cf);
-    if (error_string) {
-        assert(*error_string == 0);
-    }
-    r = toku_cachefile_close(&ft->cf, error_string, oplsn_valid, oplsn);
-    if (r == 0 && error_string) {
-        assert(*error_string == 0);
-    }
+    r = toku_cachefile_close(&ft->cf, oplsn_valid, oplsn);
     return r;
 }
 
@@ -646,20 +592,16 @@ toku_ft_init(FT ft,
 // Open a brt for use by redirect.  The new brt must have the same dict_id as the old_ft passed in.  (FILENUM is assigned by the ft_handle_open() function.)
 static int
 ft_handle_open_for_redirect(FT_HANDLE *new_ftp, const char *fname_in_env, TOKUTXN txn, FT old_h) {
-    int r;
     FT_HANDLE t;
     assert(old_h->dict_id.dictid != DICTIONARY_ID_NONE.dictid);
-    r = toku_ft_handle_create(&t);
-    assert_zero(r);
-    r = toku_ft_set_bt_compare(t, old_h->compare_fun);
-    assert_zero(r);
-    r = toku_ft_set_update(t, old_h->update_fun);
-    assert_zero(r);
+    toku_ft_handle_create(&t);
+    toku_ft_set_bt_compare(t, old_h->compare_fun);
+    toku_ft_set_update(t, old_h->update_fun);
     toku_ft_handle_set_nodesize(t, old_h->h->nodesize);
     toku_ft_handle_set_basementnodesize(t, old_h->h->basementnodesize);
     toku_ft_handle_set_compression_method(t, old_h->h->compression_method);
     CACHETABLE ct = toku_cachefile_get_cachetable(old_h->cf);
-    r = toku_ft_handle_open_with_dict_id(t, fname_in_env, 0, 0, ct, txn, old_h->dict_id);
+    int r = toku_ft_handle_open_with_dict_id(t, fname_in_env, 0, 0, ct, txn, old_h->dict_id);
     assert_zero(r);
     assert(t->ft->dict_id.dictid == old_h->dict_id.dictid);
 
@@ -813,13 +755,11 @@ toku_dictionary_redirect (const char *dst_fname_in_env, FT_HANDLE old_ft_h, TOKU
 
         FILENUM old_filenum = toku_cachefile_filenum(old_ft->cf);
         FILENUM new_filenum = toku_cachefile_filenum(new_ft->cf);
-        r = toku_logger_save_rollback_dictionary_redirect(txn, old_filenum, new_filenum);
-        assert_zero(r);
+        toku_logger_save_rollback_dictionary_redirect(txn, old_filenum, new_filenum);
 
         TXNID xid = toku_txn_get_txnid(txn);
         toku_ft_suppress_rollbacks(new_ft, txn);
-        r = toku_log_suppress_rollback(txn->logger, NULL, 0, txn, new_filenum, xid);
-        assert_zero(r);
+        toku_log_suppress_rollback(txn->logger, NULL, 0, txn, new_filenum, xid);
     }
     
 cleanup:
@@ -867,17 +807,6 @@ LSN toku_ft_checkpoint_lsn(FT ft) {
     return ft->h->checkpoint_lsn;
 }
 
-int toku_ft_set_panic(FT ft, int panic, const char *panic_string) {
-    if (ft->panic == 0) {
-        ft->panic = panic;
-        if (ft->panic_string) {
-            toku_free(ft->panic_string);
-        }
-        ft->panic_string = toku_strdup(panic_string);
-    }
-    return 0;
-}
-
 void 
 toku_ft_stat64 (FT ft, struct ftstat64_s *s) {
     s->fsize = toku_cachefile_size(ft->cf);
@@ -986,11 +915,8 @@ toku_ft_remove_reference(FT ft, bool oplsn_valid, LSN oplsn, remove_ft_ref_callb
         }
         if (!needed) {
             // close header
-            char *error_string = NULL;
-            int r;
-            r = toku_ft_evict_from_memory(ft, &error_string, oplsn_valid, oplsn);
+            int r = toku_ft_evict_from_memory(ft, oplsn_valid, oplsn);
             assert_zero(r);
-            assert(error_string == NULL);
         }
     
         toku_ft_open_close_unlock();
diff --git a/ft/ft.h b/ft/ft.h
index 8cfa054abb4..1f6e926a6d8 100644
--- a/ft/ft.h
+++ b/ft/ft.h
@@ -18,7 +18,7 @@
 // unlink a ft from the filesystem with or without a txn.
 // if with a txn, then the unlink happens on commit.
 void toku_ft_unlink(FT_HANDLE handle);
-int toku_ft_unlink_on_commit(FT_HANDLE handle, TOKUTXN txn) __attribute__((__warn_unused_result__));
+void toku_ft_unlink_on_commit(FT_HANDLE handle, TOKUTXN txn);
 
 //Effect: suppresses rollback logs
 void toku_ft_suppress_rollbacks(FT h, TOKUTXN txn);
@@ -39,7 +39,7 @@ bool toku_ft_has_one_reference_unlocked(FT ft);
 
 // evict a ft from memory by closing its cachefile. any future work
 // will have to read in the ft in a new cachefile and new FT object.
-int toku_ft_evict_from_memory(FT ft, char **error_string, bool oplsn_valid, LSN oplsn)  __attribute__ ((warn_unused_result));
+int toku_ft_evict_from_memory(FT ft, bool oplsn_valid, LSN oplsn)  __attribute__ ((warn_unused_result));
 
 FT_HANDLE toku_ft_get_only_existing_ft_handle(FT h);
 
@@ -69,7 +69,6 @@ void toku_ft_remove_txn_ref(FT h);
 void toku_calculate_root_offset_pointer ( FT h, CACHEKEY* root_key, uint32_t *roothash);
 void toku_ft_set_new_root_blocknum(FT h, CACHEKEY new_root_key); 
 LSN toku_ft_checkpoint_lsn(FT h)  __attribute__ ((warn_unused_result));
-int toku_ft_set_panic(FT h, int panic, const char *panic_string) __attribute__ ((warn_unused_result));
 void toku_ft_stat64 (FT h, struct ftstat64_s *s);
 
 // unconditionally set the descriptor for an open FT. can't do this when 
diff --git a/ft/ft_node-serialize.cc b/ft/ft_node-serialize.cc
index e960ac93c5d..e469995cbff 100644
--- a/ft/ft_node-serialize.cc
+++ b/ft/ft_node-serialize.cc
@@ -1109,32 +1109,21 @@ void destroy_nonleaf_childinfo (NONLEAF_CHILDINFO nl)
     toku_free(nl);
 }
 
-int
-read_block_from_fd_into_rbuf(
+void read_block_from_fd_into_rbuf(
     int fd, 
     BLOCKNUM blocknum,
     FT h,
     struct rbuf *rb
     ) 
 {
-    if (h->panic) {
-        toku_trace("panic set, will not read block from fd into buf");
-        return h->panic;
-    }
-    toku_trace("deserial start nopanic");
-    
     // get the file offset and block size for the block
     DISKOFF offset, size;
     toku_translate_blocknum_to_offset_size(h->blocktable, blocknum, &offset, &size);
     uint8_t *XMALLOC_N(size, raw_block);
     rbuf_init(rb, raw_block, size);
-    {
-        // read the block
-        ssize_t rlen = toku_os_pread(fd, raw_block, size, offset);
-        lazy_assert((DISKOFF)rlen == size);
-    }
-    
-    return 0;
+    // read the block
+    ssize_t rlen = toku_os_pread(fd, raw_block, size, offset);
+    lazy_assert((DISKOFF)rlen == size);
 }
 
 static const int read_header_heuristic_max = 32*1024;
@@ -1144,7 +1133,6 @@ static const int read_header_heuristic_max = 32*1024;
 static void read_ftnode_header_from_fd_into_rbuf_if_small_enough (int fd, BLOCKNUM blocknum, FT h, struct rbuf *rb)
 // Effect: If the header part of the node is small enough, then read it into the rbuf.  The rbuf will be allocated to be big enough in any case.
 {
-    assert(!h->panic);
     DISKOFF offset, size;
     toku_translate_blocknum_to_offset_size(h->blocktable, blocknum, &offset, &size);
     DISKOFF read_size = MIN(read_header_heuristic_max, size);
@@ -2424,17 +2412,12 @@ deserialize_ftnode_from_fd(int fd,
                             STAT64INFO info)
 {
     struct rbuf rb = RBUF_INITIALIZER;
-    int r = 0;
-    r = read_block_from_fd_into_rbuf(fd, blocknum, bfe->h, &rb);
-    if (r != 0) {
-        goto cleanup;
-    } // if we were successful, then we are done.
+    read_block_from_fd_into_rbuf(fd, blocknum, bfe->h, &rb);
 
-    r = deserialize_ftnode_from_rbuf(ftnode, ndd, blocknum, fullhash, bfe, info, &rb, fd);
+    int r = deserialize_ftnode_from_rbuf(ftnode, ndd, blocknum, fullhash, bfe, info, &rb, fd);
     if (r != 0) {
         dump_bad_block(rb.buf,rb.size);
     }
-cleanup:
     toku_free(rb.buf);
     return r;
 }
@@ -2533,6 +2516,7 @@ serialize_rollback_log_node_to_buf(ROLLBACK_LOG_NODE log, char *buf, size_t calc
     lazy_assert(calculated_size==wb.ndone);
 }
 
+// TODO: can't fail. assert on ENOMEM for compressed_buf...
 static int
 serialize_uncompressed_block_to_memory(char * uncompressed_buf,
                                        int n_sub_blocks,
@@ -2856,9 +2840,6 @@ read_and_decompress_block_from_fd_into_rbuf(int fd, BLOCKNUM blocknum,
                                   /* out */ int *layout_version_p) {
     int r = 0;
     if (0) printf("Deserializing Block %" PRId64 "\n", blocknum.b);
-    if (h->panic) return h->panic;
-
-    toku_trace("deserial start nopanic");
 
     // get the file offset and block size for the block
     DISKOFF offset, size;
diff --git a/ft/ftdump.cc b/ft/ftdump.cc
index 5ca233e6ecb..e7c4ab60359 100644
--- a/ft/ftdump.cc
+++ b/ft/ftdump.cc
@@ -512,10 +512,9 @@ main (int argc, const char *const argv[]) {
     int f = open(n, O_RDWR + O_BINARY);  assert(f>=0);
     FT ft;
     // create a cachefile for the header
-    int r = toku_create_cachetable(&ct, 1<<25, (LSN){0}, 0);
-    assert(r == 0);
+    toku_cachetable_create(&ct, 1<<25, (LSN){0}, 0);
     CACHEFILE cf = NULL;
-    r = toku_cachetable_openfd (&cf, ct, f, n);
+    int r = toku_cachetable_openfd (&cf, ct, f, n);
     assert(r==0);
     dump_header(f, &ft, cf);
     if (interactive) {
diff --git a/ft/ftloader.cc b/ft/ftloader.cc
index f9e39eebf21..38401494975 100644
--- a/ft/ftloader.cc
+++ b/ft/ftloader.cc
@@ -2784,7 +2784,7 @@ static int write_translation_table (struct dbout *out, long long *off_of_transla
 static int
 write_header (struct dbout *out, long long translation_location_on_disk, long long translation_size_on_disk) {
     int result = 0;
-    unsigned int size = toku_serialize_ft_size (out->h->h);
+    size_t size = toku_serialize_ft_size(out->h->h);
     struct wbuf wbuf;
     char *MALLOC_N(size, buf);
     if (buf == NULL) {
diff --git a/ft/ftverify.cc b/ft/ftverify.cc
index ed01a18ca03..cd85b930d76 100644
--- a/ft/ftverify.cc
+++ b/ft/ftverify.cc
@@ -201,13 +201,7 @@ check_block(BLOCKNUM blocknum, int64_t UU(blocksize), int64_t UU(address), void
     // Let's read the block off of disk and fill a buffer with that
     // block.
     struct rbuf rb = RBUF_INITIALIZER;
-    r = read_block_from_fd_into_rbuf(fd, blocknum, ft, &rb);
-    if (r != 0) {
-        // This is impossible without setting the panic member in
-        // the ft, let's just pretend that it is not and exit.
-        printf(" Read block failed.\n");
-        failure++;
-    }
+    read_block_from_fd_into_rbuf(fd, blocknum, ft, &rb);
 
     // Allocate the node.
     FTNODE XMALLOC(node);
diff --git a/ft/le-cursor.cc b/ft/le-cursor.cc
index 9c7508a121a..405b6b47bcf 100644
--- a/ft/le-cursor.cc
+++ b/ft/le-cursor.cc
@@ -52,11 +52,9 @@ toku_le_cursor_create(LE_CURSOR *le_cursor_result, FT_HANDLE ft_handle, TOKUTXN
     return result;
 }
 
-int 
-toku_le_cursor_close(LE_CURSOR le_cursor) {
-    int result = toku_ft_cursor_close(le_cursor->ft_cursor);
+void toku_le_cursor_close(LE_CURSOR le_cursor) {
+    toku_ft_cursor_close(le_cursor->ft_cursor);
     toku_free(le_cursor);
-    return result;
 }
 
 // Move to the next leaf entry under the LE_CURSOR
diff --git a/ft/le-cursor.h b/ft/le-cursor.h
index 6df96eee824..fff15690548 100644
--- a/ft/le-cursor.h
+++ b/ft/le-cursor.h
@@ -25,9 +25,7 @@ typedef struct le_cursor *LE_CURSOR;
 int toku_le_cursor_create(LE_CURSOR *le_cursor_result, FT_HANDLE brt, TOKUTXN txn);
 
 // Close and free the LE_CURSOR
-// Success: returns 0
-// Failure: returns a non-zero error number
-int toku_le_cursor_close(LE_CURSOR le_cursor);
+void toku_le_cursor_close(LE_CURSOR le_cursor);
 
 // Move to the next leaf entry under the LE_CURSOR
 // Success: returns zero, calls the getf callback with the getf_v parameter
diff --git a/ft/log-internal.h b/ft/log-internal.h
index 6061cb3fe22..130b84d22cc 100644
--- a/ft/log-internal.h
+++ b/ft/log-internal.h
@@ -63,10 +63,8 @@ struct tokulogger {
     bool output_is_available;           // this is part of the predicate for the output condition.  It's true if no thread is modifying the output (either doing an fsync or otherwise fiddling with the output).
 
     bool is_open;
-    bool is_panicked;
     bool write_log_files;
     bool trim_log_files; // for test purposes
-    int panic_errno;
     char *directory;  // file system directory
     DIR *dir; // descriptor for directory
     int fd;
diff --git a/ft/log_upgrade.cc b/ft/log_upgrade.cc
index 0592a0a5788..a8679560d8d 100644
--- a/ft/log_upgrade.cc
+++ b/ft/log_upgrade.cc
@@ -156,6 +156,7 @@ verify_clean_shutdown_of_log_version(const char *log_dir, uint32_t version, LSN
 
 
 // Actually create a log file of the current version, making the environment be of the current version.
+// TODO: can't fail
 static int
 upgrade_log(const char *env_dir, const char *log_dir, LSN last_lsn, TXNID last_xid) { // the real deal
     int r;
@@ -169,8 +170,7 @@ upgrade_log(const char *env_dir, const char *log_dir, LSN last_lsn, TXNID last_x
     FOOTPRINT(1);
 
     { //Create temporary environment
-        r = toku_create_cachetable(&ct, 1<<25, initial_lsn, NULL);
-        assert(r == 0);
+        toku_cachetable_create(&ct, 1<<25, initial_lsn, NULL);
         toku_cachetable_set_env_dir(ct, env_dir);
         r = toku_logger_create(&logger);
         assert(r == 0);
@@ -184,10 +184,8 @@ upgrade_log(const char *env_dir, const char *log_dir, LSN last_lsn, TXNID last_x
         assert(r == 0);
     }
     { //Close cachetable and logger
-        r = toku_logger_shutdown(logger);
-        assert(r==0);
-        r = toku_cachetable_close(&ct);
-        assert(r==0);
+        toku_logger_shutdown(logger);
+        toku_cachetable_close(&ct);
         r = toku_logger_close(&logger);
         assert(r==0);
     }
diff --git a/ft/logformat.cc b/ft/logformat.cc
index 9b5e9249188..baf3601f1cf 100644
--- a/ft/logformat.cc
+++ b/ft/logformat.cc
@@ -395,7 +395,7 @@ generate_log_writer (void) {
             fprintf(hf, "static const size_t toku_log_%s_overhead = (+4+1+8", lt->name);
             DO_FIELDS(field_type, lt, fprintf(hf, "+sizeof(%s)", field_type->type));
             fprintf(hf, "+8);\n");
-                        fprintf2(cf, hf, "int toku_log_%s (TOKULOGGER logger, LSN *lsnp, int do_fsync", lt->name);
+                        fprintf2(cf, hf, "void toku_log_%s (TOKULOGGER logger, LSN *lsnp, int do_fsync", lt->name);
                         switch (lt->log_begin_action) {
                         case SHOULD_LOG_BEGIN:
                         case ASSERT_BEGIN_WAS_LOGGED: {
@@ -407,8 +407,9 @@ generate_log_writer (void) {
                         DO_FIELDS(field_type, lt, fprintf2(cf, hf, ", %s %s", field_type->type, field_type->name));
                         fprintf(hf, ");\n");
                         fprintf(cf, ") {\n");
-                        fprintf(cf, "  int r = 0;\n");
-                        fprintf(cf, "  if (logger==0) return 0;\n");
+                        fprintf(cf, "  if (logger == NULL) {\n");
+                        fprintf(cf, "     return;\n");
+                        fprintf(cf, "  }\n");
                         switch (lt->log_begin_action) {
                         case SHOULD_LOG_BEGIN: {
                             fprintf(cf, "  //txn can be NULL during tests\n");
@@ -431,7 +432,7 @@ generate_log_writer (void) {
                         fprintf(cf, "    logger->lsn.lsn++;\n");
                         fprintf(cf, "    if (lsnp) *lsnp=logger->lsn;\n");
                         fprintf(cf, "    ml_unlock(&logger->input_lock);\n");
-                        fprintf(cf, "    return 0;\n");
+                        fprintf(cf, "    return;\n");
                         fprintf(cf, "  }\n");
                         fprintf(cf, "  const unsigned int buflen= (+4 // len at the beginning\n");
                         fprintf(cf, "                              +1 // log command\n");
@@ -442,8 +443,7 @@ generate_log_writer (void) {
                         fprintf(cf, "                     );\n");
                         fprintf(cf, "  struct wbuf wbuf;\n");
                         fprintf(cf, "  ml_lock(&logger->input_lock);\n");
-                        fprintf(cf, "  r = toku_logger_make_space_in_inbuf(logger, buflen);\n");
-                        fprintf(cf, "  if (r!=0) goto panic;\n");
+                        fprintf(cf, "  toku_logger_make_space_in_inbuf(logger, buflen);\n");
                         fprintf(cf, "  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);\n");
                         fprintf(cf, "  wbuf_nocrc_int(&wbuf, buflen);\n");
                         fprintf(cf, "  wbuf_nocrc_char(&wbuf, '%c');\n", (char)(0xff&lt->command_and_flags));
@@ -459,12 +459,7 @@ generate_log_writer (void) {
                         fprintf(cf, "  wbuf_nocrc_int(&wbuf, buflen);\n");
                         fprintf(cf, "  assert(wbuf.ndone==buflen);\n");
                         fprintf(cf, "  logger->inbuf.n_in_buf += buflen;\n");
-                        fprintf(cf, "  r = toku_logger_maybe_fsync(logger, logger->lsn, do_fsync);\n");
-                        fprintf(cf, "  if (r!=0) goto panic;\n");
-                        fprintf(cf, "  return 0;\n");
-                        fprintf(cf, " panic:\n");
-                        fprintf(cf, "  toku_logger_panic(logger, r);\n");
-                        fprintf(cf, "  return r;\n");
+                        fprintf(cf, "  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync);\n");
                         fprintf(cf, "}\n\n");
                     });
 }
@@ -595,7 +590,7 @@ generate_logprint (void) {
                 fprintf(pf, "          if (len_in_file!=len || crc_in_file!=actual_murmur) return DB_BADFORMAT;\n");
                 fprintf(pf, "        };\n");
                 fprintf(pf, "        fprintf(outf, \"\\n\");\n");
-                fprintf(pf, "        return 0;;\n\n");
+                fprintf(pf, "        return 0;\n\n");
             });
     fprintf(pf, "    }\n");
     fprintf(pf, "    fprintf(outf, \"Unknown command %%d ('%%c')\", cmd, cmd);\n");
@@ -606,7 +601,7 @@ generate_logprint (void) {
 static void
 generate_rollbacks (void) {
     DO_ROLLBACKS(lt, {
-                    fprintf2(cf, hf, "int toku_logger_save_rollback_%s (TOKUTXN txn", lt->name);
+                    fprintf2(cf, hf, "void toku_logger_save_rollback_%s (TOKUTXN txn", lt->name);
                     DO_FIELDS(field_type, lt, {
                         if ( strcmp(field_type->type, "BYTESTRING") == 0 ) {
                             fprintf2(cf, hf, ", BYTESTRING *%s_ptr", field_type->name);
@@ -664,7 +659,7 @@ generate_rollbacks (void) {
                     fprintf(cf, "  toku_maybe_spill_rollbacks(txn, log);\n");
                     fprintf(cf, "  toku_rollback_log_unpin(txn, log);\n");
                     fprintf(cf, "  toku_txn_unlock(txn);\n");
-                    fprintf(cf, "  return 0;\n}\n");
+                    fprintf(cf, "}\n");
             });
 
     DO_ROLLBACKS(lt, {
diff --git a/ft/logger.cc b/ft/logger.cc
index c430223c434..c10a7a7587e 100644
--- a/ft/logger.cc
+++ b/ft/logger.cc
@@ -10,7 +10,7 @@
 static const int log_format_version=TOKU_LOG_VERSION;
 
 static int open_logfile (TOKULOGGER logger);
-static int toku_logger_write_buffer (TOKULOGGER logger, LSN *fsynced_lsn);
+static void logger_write_buffer (TOKULOGGER logger, LSN *fsynced_lsn);
 static int delete_logfile(TOKULOGGER logger, long long index, uint32_t version);
 static void grab_output(TOKULOGGER logger, LSN *fsynced_lsn);
 static void release_output(TOKULOGGER logger, LSN fsynced_lsn);
@@ -68,12 +68,11 @@ static bool is_a_logfile (const char *name, long long *number_result) {
 }
 
 
+// TODO: can't fail
 int toku_logger_create (TOKULOGGER *resultp) {
     TOKULOGGER CALLOC(result);
     if (result==0) return get_error_errno();
     result->is_open=false;
-    result->is_panicked=false;
-    result->panic_errno = 0;
     result->write_log_files = true;
     result->trim_log_files = true;
     result->directory=0;
@@ -104,8 +103,8 @@ int toku_logger_create (TOKULOGGER *resultp) {
     return 0;
 }
 
-static int fsync_logdir(TOKULOGGER logger) {
-    return toku_fsync_dirfd_without_accounting(logger->dir);
+static void fsync_logdir(TOKULOGGER logger) {
+    toku_fsync_dirfd_without_accounting(logger->dir);
 }
 
 static int open_logdir(TOKULOGGER logger, const char *directory) {
@@ -138,7 +137,6 @@ static int close_logdir(TOKULOGGER logger) {
 int
 toku_logger_open_with_last_xid(const char *directory, TOKULOGGER logger, TXNID last_xid) {
     if (logger->is_open) return EINVAL;
-    if (logger->is_panicked) return EINVAL;
 
     int r;
     TXNID last_xid_if_clean_shutdown;
@@ -181,19 +179,14 @@ bool toku_logger_rollback_is_open (TOKULOGGER logger) {
 int
 toku_logger_open_rollback(TOKULOGGER logger, CACHETABLE cachetable, bool create) {
     assert(logger->is_open);
-    assert(!logger->is_panicked);
     assert(!logger->rollback_cachefile);
     
-    int r;
     FT_HANDLE t = NULL;   // Note, there is no DB associated with this BRT.
-
-    r = toku_ft_handle_create(&t);
-    assert_zero(r);
-    r = toku_ft_handle_open(t, ROLLBACK_CACHEFILE_NAME, create, create, cachetable, NULL_TXN);
+    toku_ft_handle_create(&t);
+    int r = toku_ft_handle_open(t, ROLLBACK_CACHEFILE_NAME, create, create, cachetable, NULL_TXN);
     assert_zero(r);
     logger->rollback_cachefile = t->ft->cf;
     //Verify it is empty
-    assert(!t->ft->panic);
     //Must have no data blocks (rollback logs or otherwise).
     toku_block_verify_no_data_blocks_except_root_unlocked(t->ft->blocktable, t->ft->h->root_blocknum);
     bool is_empty;
@@ -207,24 +200,18 @@ toku_logger_open_rollback(TOKULOGGER logger, CACHETABLE cachetable, bool create)
 //            so it will always be clean (!h->dirty) when about to be closed.
 //            Rollback log can only be closed when there are no open transactions,
 //            so it will always be empty (no data blocks) when about to be closed.
+// TODO: can't fail
 int
-toku_logger_close_rollback(TOKULOGGER logger, bool recovery_failed) {
-    int r = 0;
+toku_logger_close_rollback(TOKULOGGER logger) {
     CACHEFILE cf = logger->rollback_cachefile;  // stored in logger at rollback cachefile open
-    if (!logger->is_panicked && cf) {
+    if (cf) {
         FT_HANDLE ft_to_close;
         {   //Find "brt"
             FT CAST_FROM_VOIDP(ft, toku_cachefile_get_userdata(cf));
-            if (!ft->panic && recovery_failed) {
-                r = toku_ft_set_panic(ft, EINVAL, "Recovery failed");
-                assert_zero(r);
-            }
             //Verify it is safe to close it.
-            if (!ft->panic) { //If paniced, it is safe to close.
-                assert(!ft->h->dirty);  //Must not be dirty.
-                //Must have no data blocks (rollback logs or otherwise).
-                toku_block_verify_no_data_blocks_except_root_unlocked(ft->blocktable, ft->h->root_blocknum);
-            }
+            assert(!ft->h->dirty);  //Must not be dirty.
+            //Must have no data blocks (rollback logs or otherwise).
+            toku_block_verify_no_data_blocks_except_root_unlocked(ft->blocktable, ft->h->root_blocknum);
             assert(!ft->h->dirty);
             ft_to_close = toku_ft_get_only_existing_ft_handle(ft);
             {
@@ -239,61 +226,59 @@ toku_logger_close_rollback(TOKULOGGER logger, bool recovery_failed) {
         //Set as dealt with already.
         logger->rollback_cachefile = NULL;
     }
-    return r;
+    return 0;
 }
 
 // No locks held on entry
 // No locks held on exit.
 // No locks are needed, since you cannot legally close the log concurrently with doing anything else.
+// TODO: can't fail
 int toku_logger_close(TOKULOGGER *loggerp) {
+    int r;
     TOKULOGGER logger = *loggerp;
-    if (logger->is_panicked) return EINVAL;
-    int r = 0;
-    if (!logger->is_open) goto is_closed;
+    if (!logger->is_open) {
+        goto is_closed;
+    }
     ml_lock(&logger->input_lock);
     logger->input_lock_ctr++;
     LSN fsynced_lsn;
     grab_output(logger, &fsynced_lsn);
-    r = toku_logger_write_buffer(logger, &fsynced_lsn);           if (r!=0) goto panic; //Releases the input lock
+    logger_write_buffer(logger, &fsynced_lsn);
     if (logger->fd!=-1) {
         if ( logger->write_log_files ) {
-            r = toku_file_fsync_without_accounting(logger->fd);   if (r!=0) { r=get_error_errno(); goto panic; }
+            toku_file_fsync_without_accounting(logger->fd);
         }
-        r = close(logger->fd);                                    if (r!=0) { r=get_error_errno(); goto panic; }
+        r = close(logger->fd);
+        assert(r == 0);
     }
-    r = close_logdir(logger);  if (r!=0) { r=get_error_errno(); goto panic; }
+    r = close_logdir(logger);
+    assert(r == 0);
     logger->fd=-1;
     release_output(logger, fsynced_lsn);
 
- is_closed:
+is_closed:
     toku_free(logger->inbuf.buf);
     toku_free(logger->outbuf.buf);
     // before destroying locks they must be left in the unlocked state.
     ml_destroy(&logger->input_lock);
     toku_mutex_destroy(&logger->output_condition_lock);
     toku_cond_destroy(&logger->output_condition);
-    logger->is_panicked=true; // Just in case this might help.
     toku_txn_manager_destroy(logger->txn_manager);
     if (logger->directory) toku_free(logger->directory);
     toku_logfilemgr_destroy(&logger->logfilemgr);
     toku_free(logger);
     *loggerp=0;
-    return r;
- panic:
-    toku_logger_panic(logger, r);
-    return r;
+    return 0;
 }
 
-int toku_logger_shutdown(TOKULOGGER logger) {
-    int r = 0;
+void toku_logger_shutdown(TOKULOGGER logger) {
     if (logger->is_open) {
         TXN_MANAGER mgr = logger->txn_manager;
         if (toku_txn_manager_num_live_txns(mgr) == 0) {
             TXNID last_xid = toku_txn_manager_get_last_xid(mgr);
-            r = toku_log_shutdown(logger, NULL, true, 0, last_xid);
+            toku_log_shutdown(logger, NULL, true, 0, last_xid);
         }
     }
-    return r;
 }
 
 static int close_and_open_logfile (TOKULOGGER logger, LSN *fsynced_lsn)
@@ -303,7 +288,7 @@ static int close_and_open_logfile (TOKULOGGER logger, LSN *fsynced_lsn)
 {
     int r;
     if (logger->write_log_files) {
-        r = toku_file_fsync_without_accounting(logger->fd);                 if (r!=0) return get_error_errno();
+        toku_file_fsync_without_accounting(logger->fd);
         *fsynced_lsn = logger->written_lsn;
         toku_logfilemgr_update_last_lsn(logger->logfilemgr, logger->written_lsn);          // fixes t:2294
     }
@@ -432,7 +417,7 @@ write_outbuf_to_logfile (TOKULOGGER logger, LSN *fsynced_lsn)
     }
 }
 
-int
+void
 toku_logger_make_space_in_inbuf (TOKULOGGER logger, int n_bytes_needed)
 // Entry: Holds the inlock
 // Exit:  Holds the inlock
@@ -444,7 +429,9 @@ toku_logger_make_space_in_inbuf (TOKULOGGER logger, int n_bytes_needed)
 // Arguments:  logger:         the logger (side effects)
 //             n_bytes_needed: how many bytes to make space for.
 {
-    if (logger->inbuf.n_in_buf + n_bytes_needed <= LOGGER_MIN_BUF_SIZE) return 0;
+    if (logger->inbuf.n_in_buf + n_bytes_needed <= LOGGER_MIN_BUF_SIZE) {
+        return;
+    }
     logger->input_lock_ctr++;
     ml_unlock(&logger->input_lock);
     LSN fsynced_lsn;
@@ -455,7 +442,7 @@ toku_logger_make_space_in_inbuf (TOKULOGGER logger, int n_bytes_needed)
     // Some other thread may have written the log out while we didn't have the lock.  If we have space now, then be happy.
     if (logger->inbuf.n_in_buf + n_bytes_needed <= LOGGER_MIN_BUF_SIZE) {
         release_output(logger, fsynced_lsn);
-        return 0;
+        return;
     }
     if (logger->inbuf.n_in_buf > 0) {
         // There isn't enough space, and there is something in the buffer, so write the inbuf.
@@ -473,7 +460,6 @@ toku_logger_make_space_in_inbuf (TOKULOGGER logger, int n_bytes_needed)
         logger->inbuf.buf_size = new_size;
     }
     release_output(logger, fsynced_lsn);
-    return 0;
 }
 
 int toku_logger_fsync (TOKULOGGER logger)
@@ -482,42 +468,25 @@ int toku_logger_fsync (TOKULOGGER logger)
 // Exit: Holds no locks
 // Implementation note:  Acquire the output condition lock, then the output permission, then release the output condition lock, then get the input lock.
 // Then release everything.
-// 
+//  TODO: can't fail
 {
-    int r;
-    if (logger->is_panicked) return EINVAL;
     ml_lock(&logger->input_lock);
     logger->input_lock_ctr++;
-    r = toku_logger_maybe_fsync(logger, logger->inbuf.max_lsn_in_buf, true);
-    if (r!=0) {
-        toku_logger_panic(logger, r);
-    }
-    return r;
+    toku_logger_maybe_fsync(logger, logger->inbuf.max_lsn_in_buf, true);
+    return 0;
 }
 
+// TODO: can't fail
 int
 toku_logger_fsync_if_lsn_not_fsynced (TOKULOGGER logger, LSN lsn) {
-    int r = 0;
-    if (logger->is_panicked) r = EINVAL;
-    else if (logger->write_log_files) {
+    if (logger->write_log_files) {
         ml_lock(&logger->input_lock);
         logger->input_lock_ctr++;
-        r = toku_logger_maybe_fsync(logger, lsn, true);
-        if (r!=0) {
-            toku_logger_panic(logger, r);
-        }
+        toku_logger_maybe_fsync(logger, lsn, true);
     }
-    return r;
+    return 0;
 }
 
-void toku_logger_panic (TOKULOGGER logger, int err) {
-    logger->panic_errno=err;
-    logger->is_panicked=true;
-}
-int toku_logger_panicked(TOKULOGGER logger) {
-    if (logger==0) return 0;
-    return logger->is_panicked;
-}
 int toku_logger_is_open(TOKULOGGER logger) {
     if (logger==0) return 0;
     return logger->is_open;
@@ -529,7 +498,6 @@ void toku_logger_set_cachetable (TOKULOGGER logger, CACHETABLE ct) {
 
 int toku_logger_set_lg_max(TOKULOGGER logger, uint32_t lg_max) {
     if (logger==0) return EINVAL; // no logger
-    if (logger->is_panicked) return EINVAL;
     if (logger->is_open) return EINVAL;
     if (lg_max>(1<<30)) return EINVAL; // too big
     logger->lg_max = lg_max;
@@ -537,14 +505,12 @@ int toku_logger_set_lg_max(TOKULOGGER logger, uint32_t lg_max) {
 }
 int toku_logger_get_lg_max(TOKULOGGER logger, uint32_t *lg_maxp) {
     if (logger==0) return EINVAL; // no logger
-    if (logger->is_panicked) return EINVAL;
     *lg_maxp = logger->lg_max;
     return 0;
 }
 
 int toku_logger_set_lg_bsize(TOKULOGGER logger, uint32_t bsize) {
     if (logger==0) return EINVAL; // no logger
-    if (logger->is_panicked) return EINVAL;
     if (logger->is_open) return EINVAL;
     if (bsize<=0 || bsize>(1<<30)) return EINVAL;
     logger->write_block_size = bsize;
@@ -657,21 +623,22 @@ static int open_logfile (TOKULOGGER logger)
     long long index = logger->next_log_file_number;
     if (logger->write_log_files) {
         logger->fd = open(fname, O_CREAT+O_WRONLY+O_TRUNC+O_EXCL+O_BINARY, S_IRWXU);     
-        if (logger->fd==-1) return get_error_errno();
-        int r = fsync_logdir(logger);   if (r!=0) return r; // t:2445
+        if (logger->fd==-1) {
+            return get_error_errno();
+        }
+        fsync_logdir(logger);
         logger->next_log_file_number++;
     } else {
         logger->fd = open(DEV_NULL_FILE, O_WRONLY+O_BINARY);
-        // printf("%s: %s %d\n", __FUNCTION__, DEV_NULL_FILE, logger->fd); fflush(stdout);
-        if (logger->fd==-1) return get_error_errno();
+        if (logger->fd==-1) {
+            return get_error_errno();
+        }
     }
     toku_os_full_write(logger->fd, "tokulogg", 8);
     int version_l = toku_htonl(log_format_version); //version MUST be in network byte order regardless of disk order
     toku_os_full_write(logger->fd, &version_l, 4);
     if ( logger->write_log_files ) {
-        TOKULOGFILEINFO MALLOC(lf_info);
-        if (lf_info == NULL) 
-            return ENOMEM;
+        TOKULOGFILEINFO XMALLOC(lf_info);
         lf_info->index = index;
         lf_info->maxlsn = logger->written_lsn; 
         lf_info->version = TOKU_LOG_VERSION;
@@ -739,20 +706,21 @@ void toku_logger_trim_log_files (TOKULOGGER logger, bool trim_log_files)
     logger->trim_log_files = trim_log_files;
 }
 
-int toku_logger_maybe_fsync (TOKULOGGER logger, LSN lsn, int do_fsync)
+void toku_logger_maybe_fsync(TOKULOGGER logger, LSN lsn, int do_fsync)
 // Effect: If fsync is nonzero, then make sure that the log is flushed and synced at least up to lsn.
 // Entry: Holds input lock.  The log entry has already been written to the input buffer.
 // Exit:  Holds no locks.
 // The input lock may be released and then reacquired.  Thus this function does not run atomically with respect to other threads.
 {
-    int r;
     if (do_fsync) {
         // reacquire the locks (acquire output permission first)
         logger->input_lock_ctr++;
         ml_unlock(&logger->input_lock);
         LSN  fsynced_lsn;
         bool already_done = wait_till_output_already_written_or_output_buffer_available(logger, lsn, &fsynced_lsn);
-        if (already_done) return 0;
+        if (already_done) {
+            return;
+        }
 
         // otherwise we now own the output permission, and our lsn isn't outputed.
 
@@ -767,27 +735,23 @@ int toku_logger_maybe_fsync (TOKULOGGER logger, LSN lsn, int do_fsync)
         write_outbuf_to_logfile(logger, &fsynced_lsn);
         if (fsynced_lsn.lsn < lsn.lsn) {
             // it may have gotten fsynced by the write_outbuf_to_logfile.
-            r = toku_file_fsync_without_accounting(logger->fd);
-            if (r!=0) {
-                toku_logger_panic(logger, r);
-                return r;
-            }
+            toku_file_fsync_without_accounting(logger->fd);
             assert(fsynced_lsn.lsn <= logger->written_lsn.lsn);
             fsynced_lsn = logger->written_lsn;
         }
         // the last lsn is only accessed while holding output permission or else when the log file is old.
-        if ( logger->write_log_files )
+        if (logger->write_log_files) {
             toku_logfilemgr_update_last_lsn(logger->logfilemgr, logger->written_lsn);
+        }
         release_output(logger, fsynced_lsn);
     } else {
         logger->input_lock_ctr++;
         ml_unlock(&logger->input_lock);
     }
-    return 0;
 }
 
-static int
-toku_logger_write_buffer (TOKULOGGER logger, LSN *fsynced_lsn) 
+static void
+logger_write_buffer(TOKULOGGER logger, LSN *fsynced_lsn) 
 // Entry:  Holds the input lock and permission to modify output.
 // Exit:   Holds only the permission to modify output.
 // Effect:  Write the buffers to the output.  If DO_FSYNC is true, then fsync.
@@ -798,14 +762,9 @@ toku_logger_write_buffer (TOKULOGGER logger, LSN *fsynced_lsn)
     ml_unlock(&logger->input_lock);
     write_outbuf_to_logfile(logger, fsynced_lsn);
     if (logger->write_log_files) {
-        int r = toku_file_fsync_without_accounting(logger->fd);
-        if (r!=0) {
-            toku_logger_panic(logger, r);
-            return r;
-        }
+        toku_file_fsync_without_accounting(logger->fd);
         toku_logfilemgr_update_last_lsn(logger->logfilemgr, logger->written_lsn);  // t:2294
     }
-    return 0;
 }
 
 int toku_logger_restart(TOKULOGGER logger, LSN lastlsn)
@@ -818,15 +777,11 @@ int toku_logger_restart(TOKULOGGER logger, LSN lastlsn)
     grab_output(logger, &fsynced_lsn);
     ml_lock(&logger->input_lock);
     logger->input_lock_ctr++;
-    r = toku_logger_write_buffer(logger, &fsynced_lsn); assert(r == 0);
+    logger_write_buffer(logger, &fsynced_lsn);
 
     // close the log file
     if ( logger->write_log_files) { // fsyncs don't work to /dev/null
-        r = toku_file_fsync_without_accounting(logger->fd); 
-        if ( r!=0 ) {
-            toku_logger_panic(logger, r);
-            return r;
-        }
+        toku_file_fsync_without_accounting(logger->fd); 
     }
     r = close(logger->fd);                              assert(r == 0);
     logger->fd = -1;
@@ -843,35 +798,36 @@ int toku_logger_restart(TOKULOGGER logger, LSN lastlsn)
 }
 
 // fname is the iname
-int toku_logger_log_fcreate (TOKUTXN txn, const char *fname, FILENUM filenum, uint32_t mode, uint32_t treeflags, uint32_t nodesize, uint32_t basementnodesize, enum toku_compression_method compression_method) {
-    if (txn==0) return 0;
-    if (txn->logger->is_panicked) return EINVAL;
-    BYTESTRING bs_fname = { .len = (uint32_t) strlen(fname), .data = (char *) fname };
-    // fsync log on fcreate
-    int r = toku_log_fcreate (txn->logger, (LSN*)0, 1, txn, toku_txn_get_txnid(txn), filenum, bs_fname, mode, treeflags, nodesize, basementnodesize, compression_method);
-    return r;
+void toku_logger_log_fcreate (TOKUTXN txn, const char *fname, FILENUM filenum, uint32_t mode,
+        uint32_t treeflags, uint32_t nodesize, uint32_t basementnodesize,
+        enum toku_compression_method compression_method) {
+    if (txn) {
+        BYTESTRING bs_fname = { .len = (uint32_t) strlen(fname), .data = (char *) fname };
+        // fsync log on fcreate
+        toku_log_fcreate (txn->logger, (LSN*)0, 1, txn, toku_txn_get_txnid(txn), filenum, 
+                bs_fname, mode, treeflags, nodesize, basementnodesize, compression_method);
+    }
 }
 
 
 // We only do fdelete on open ft's, so we pass the filenum here
-int toku_logger_log_fdelete (TOKUTXN txn, FILENUM filenum) {
-    if (txn==0) return 0;
-    if (txn->logger->is_panicked) return EINVAL;
-    //No fsync.
-    int r = toku_log_fdelete (txn->logger, (LSN*)0, 0, txn, toku_txn_get_txnid(txn), filenum);
-    return r;
+void toku_logger_log_fdelete (TOKUTXN txn, FILENUM filenum) {
+    if (txn) {
+        //No fsync.
+        toku_log_fdelete (txn->logger, (LSN*)0, 0, txn, toku_txn_get_txnid(txn), filenum);
+    }
 }
 
 
 
 /* fopen isn't really an action.  It's just for bookkeeping.  We need to know the filename that goes with a filenum. */
-int toku_logger_log_fopen (TOKUTXN txn, const char * fname, FILENUM filenum, uint32_t treeflags) {
-    if (txn==0) return 0;
-    if (txn->logger->is_panicked) return EINVAL;
-    BYTESTRING bs;
-    bs.len = strlen(fname);
-    bs.data = (char*)fname;
-    return toku_log_fopen (txn->logger, (LSN*)0, 0, bs, filenum, treeflags);
+void toku_logger_log_fopen (TOKUTXN txn, const char * fname, FILENUM filenum, uint32_t treeflags) {
+    if (txn) {
+        BYTESTRING bs;
+        bs.len = strlen(fname);
+        bs.data = (char*)fname;
+        toku_log_fopen (txn->logger, (LSN*)0, 0, bs, filenum, treeflags);
+    }
 }
 
 static int toku_fread_uint8_t_nocrclen (FILE *f, uint8_t *v) {
@@ -1177,15 +1133,6 @@ int toku_read_logmagic (FILE *f, uint32_t *versionp) {
     return 0;
 }
 
-TXNID toku_txn_get_root_txnid (TOKUTXN txn) {
-    if (txn==0) return 0;
-    TOKUTXN root = txn;
-    while (root->parent) {
-        root = root->parent;
-    }
-    return root->txnid64;
-}
-
 TXNID toku_txn_get_txnid (TOKUTXN txn) {
     if (txn==0) return 0;
     else return txn->txnid64;
@@ -1309,11 +1256,6 @@ void toku_logger_note_checkpoint(TOKULOGGER logger, LSN lsn) {
     logger->last_completed_checkpoint_lsn = lsn;
 }
 
-LSN
-toku_logger_get_next_lsn(TOKULOGGER logger) {
-    return logger->lsn;
-}
-
 ///////////////////////////////////////////////////////////////////////////////////
 // Engine status
 //
@@ -1336,8 +1278,6 @@ status_init(void) {
     STATUS_INIT(LOGGER_ILOCK_CTR,    UINT64,  "ilock count");
     STATUS_INIT(LOGGER_OLOCK_CTR,    UINT64,  "olock count");
     STATUS_INIT(LOGGER_SWAP_CTR,     UINT64,  "swap count");
-    STATUS_INIT(LOGGER_PANICKED,     UINT64,  "panic");
-    STATUS_INIT(LOGGER_PANIC_ERRNO,  UINT64,  "panic errno");
     logger_status.initialized = true;
 }
 #undef STATUS_INIT
@@ -1353,8 +1293,6 @@ toku_logger_get_status(TOKULOGGER logger, LOGGER_STATUS statp) {
         STATUS_VALUE(LOGGER_ILOCK_CTR)   = logger->input_lock_ctr;
         STATUS_VALUE(LOGGER_OLOCK_CTR)   = logger->output_condition_lock_ctr;
         STATUS_VALUE(LOGGER_SWAP_CTR)    = logger->swap_ctr;
-        STATUS_VALUE(LOGGER_PANICKED)    = logger->is_panicked;
-        STATUS_VALUE(LOGGER_PANIC_ERRNO) = logger->panic_errno;
     }
     *statp = logger_status;
 }
diff --git a/ft/logger.h b/ft/logger.h
index 6ddbbe62fec..e9afc8aed63 100644
--- a/ft/logger.h
+++ b/ft/logger.h
@@ -23,25 +23,20 @@ enum {
 int toku_logger_create (TOKULOGGER *resultp);
 int toku_logger_open (const char *directory, TOKULOGGER logger);
 int toku_logger_open_with_last_xid(const char *directory, TOKULOGGER logger, TXNID last_xid);
-int toku_logger_shutdown(TOKULOGGER logger);
+void toku_logger_shutdown(TOKULOGGER logger);
 int toku_logger_close(TOKULOGGER *loggerp);
 int toku_logger_open_rollback(TOKULOGGER logger, CACHETABLE cachetable, bool create);
-int toku_logger_close_rollback(TOKULOGGER logger, bool recovery_failed);
+int toku_logger_close_rollback(TOKULOGGER logger);
 bool toku_logger_rollback_is_open (TOKULOGGER); // return true iff the rollback is open.
 
 int toku_logger_fsync (TOKULOGGER logger);
 int toku_logger_fsync_if_lsn_not_fsynced(TOKULOGGER logger, LSN lsn);
-void toku_logger_panic (TOKULOGGER logger, int err);
-int toku_logger_panicked(TOKULOGGER logger);
 int toku_logger_is_open(TOKULOGGER logger);
 void toku_logger_set_cachetable (TOKULOGGER logger, CACHETABLE ct);
 int toku_logger_set_lg_max(TOKULOGGER logger, uint32_t lg_max);
 int toku_logger_get_lg_max(TOKULOGGER logger, uint32_t *lg_maxp);
 int toku_logger_set_lg_bsize(TOKULOGGER logger, uint32_t bsize);
 
-int toku_logger_lock_init(void);
-int toku_logger_lock_destroy(void);
-
 void toku_logger_write_log_files (TOKULOGGER logger, bool write_log_files);
 void toku_logger_trim_log_files(TOKULOGGER logger, bool trim_log_files);
 
@@ -58,9 +53,9 @@ int toku_logger_restart(TOKULOGGER logger, LSN lastlsn);
 // Returns: 0 if success
 int toku_logger_maybe_trim_log(TOKULOGGER logger, LSN oldest_open_lsn);
 
-int toku_logger_log_fcreate (TOKUTXN txn, const char *fname, FILENUM filenum, uint32_t mode, uint32_t flags, uint32_t nodesize, uint32_t basementnodesize, enum toku_compression_method compression_method);
-int toku_logger_log_fdelete (TOKUTXN txn, FILENUM filenum);
-int toku_logger_log_fopen (TOKUTXN txn, const char * fname, FILENUM filenum, uint32_t treeflags);
+void toku_logger_log_fcreate(TOKUTXN txn, const char *fname, FILENUM filenum, uint32_t mode, uint32_t flags, uint32_t nodesize, uint32_t basementnodesize, enum toku_compression_method compression_method);
+void toku_logger_log_fdelete(TOKUTXN txn, FILENUM filenum);
+void toku_logger_log_fopen(TOKUTXN txn, const char * fname, FILENUM filenum, uint32_t treeflags);
 
 int toku_fread_uint8_t (FILE *f, uint8_t *v, struct x1764 *mm, uint32_t *len);
 int toku_fread_uint32_t_nocrclen (FILE *f, uint32_t *v);
@@ -91,7 +86,6 @@ int toku_read_and_print_logmagic (FILE *f, uint32_t *versionp);
 int toku_read_logmagic (FILE *f, uint32_t *versionp);
 
 TXNID toku_txn_get_txnid (TOKUTXN txn);
-TXNID toku_txn_get_root_txnid (TOKUTXN txn);
 LSN toku_logger_last_lsn(TOKULOGGER logger);
 TOKULOGGER toku_txn_logger (TOKUTXN txn);
 
@@ -103,12 +97,9 @@ int toku_logger_log_archive (TOKULOGGER logger, char ***logs_p, int flags);
 TOKUTXN toku_logger_txn_parent (TOKUTXN txn);
 void toku_logger_note_checkpoint(TOKULOGGER logger, LSN lsn);
 
-LSN toku_logger_get_next_lsn(TOKULOGGER logger);
-
-int toku_logger_make_space_in_inbuf (TOKULOGGER logger, int n_bytes_needed);
+void toku_logger_make_space_in_inbuf (TOKULOGGER logger, int n_bytes_needed);
 
-int
-toku_logger_write_inbuf (TOKULOGGER logger);
+int toku_logger_write_inbuf (TOKULOGGER logger);
 // Effect: Write the buffered data (from the inbuf) to a file.  No fsync, however.
 // As a side effect, the inbuf will be made empty.
 // Return 0 on success, otherwise return an error number.
@@ -119,9 +110,7 @@ toku_logger_write_inbuf (TOKULOGGER logger);
 // Rationale:  When the buffer becomes nearly full, call this function so that more can be put in.
 // Implementation note:  Since the output lock is acquired first, we must release the input lock, and then grab both in the right order.
 
-
-int
-toku_logger_maybe_fsync (TOKULOGGER logger, LSN lsn, int do_fsync);
+void toku_logger_maybe_fsync (TOKULOGGER logger, LSN lsn, int do_fsync);
 // Effect: If fsync is nonzero, then make sure that the log is flushed and synced at least up to lsn.
 // Entry: Holds input lock.
 // Exit:  Holds no locks.
@@ -163,14 +152,11 @@ toku_logger_maybe_fsync (TOKULOGGER logger, LSN lsn, int do_fsync);
 //        fsync
 //        release the outlock
 
-
 typedef enum {
     LOGGER_NEXT_LSN = 0,
     LOGGER_ILOCK_CTR,
     LOGGER_OLOCK_CTR,
     LOGGER_SWAP_CTR,
-    LOGGER_PANICKED,
-    LOGGER_PANIC_ERRNO,
     LOGGER_STATUS_NUM_ROWS
 } logger_status_entry;
 
@@ -179,17 +165,12 @@ typedef struct {
     TOKU_ENGINE_STATUS_ROW_S status[LOGGER_STATUS_NUM_ROWS];
 } LOGGER_STATUS_S, *LOGGER_STATUS;
 
-
 void toku_logger_get_status(TOKULOGGER logger, LOGGER_STATUS s);
 
 int toku_get_version_of_logs_on_disk(const char *log_dir, bool *found_any_logs, uint32_t *version_found);
-int toku_delete_all_logs_of_version(const char *log_dir, uint32_t version_to_delete);
 
 TXN_MANAGER toku_logger_get_txn_manager(TOKULOGGER logger);
 
-
 static const TOKULOGGER NULL_logger __attribute__((__unused__)) = NULL;
 
-
-#endif
-
+#endif /* TOKU_LOGGER_H */
diff --git a/ft/minicron.cc b/ft/minicron.cc
index c94faac1181..2099ed5dc17 100644
--- a/ft/minicron.cc
+++ b/ft/minicron.cc
@@ -98,14 +98,13 @@ toku_minicron_setup(struct minicron *p, uint32_t period_in_seconds, int(*f)(void
     return toku_pthread_create(&p->thread, 0, minicron_do, p);
 }
     
-int
+void
 toku_minicron_change_period(struct minicron *p, uint32_t new_period)
 {
     toku_mutex_lock(&p->mutex);
     p->period_in_seconds = new_period;
     toku_cond_signal(&p->condvar);
     toku_mutex_unlock(&p->mutex);
-    return 0;
 }
 
 uint32_t
diff --git a/ft/minicron.h b/ft/minicron.h
index 815d8ec76c5..916fdeafbc9 100644
--- a/ft/minicron.h
+++ b/ft/minicron.h
@@ -37,7 +37,7 @@ struct minicron {
 };
 
 int toku_minicron_setup (struct minicron *s, uint32_t period_in_seconds, int(*f)(void *), void *arg);
-int toku_minicron_change_period(struct minicron *p, uint32_t new_period);
+void toku_minicron_change_period(struct minicron *p, uint32_t new_period);
 uint32_t toku_minicron_get_period(struct minicron *p);
 uint32_t toku_minicron_get_period_unlocked(struct minicron *p);
 int toku_minicron_shutdown(struct minicron *p);
diff --git a/ft/recover.cc b/ft/recover.cc
index 9a095d16efa..1497795a5b2 100644
--- a/ft/recover.cc
+++ b/ft/recover.cc
@@ -122,7 +122,7 @@ static uint32_t file_map_get_num_dictionaries(struct file_map *fmap) {
     return toku_omt_size(fmap->filenums);
 }
 
-static void file_map_close_dictionaries(struct file_map *fmap, bool recovery_succeeded, LSN oplsn) {
+static void file_map_close_dictionaries(struct file_map *fmap, LSN oplsn) {
     int r;
 
     while (1) {
@@ -136,16 +136,9 @@ static void file_map_close_dictionaries(struct file_map *fmap, bool recovery_suc
         assert(r == 0);
         struct file_map_tuple *CAST_FROM_VOIDP(tuple, v);
         assert(tuple->ft_handle);
-        if (!recovery_succeeded) {
-            // don't update the brt on close
-            r = toku_ft_handle_set_panic(tuple->ft_handle, DB_RUNRECOVERY, "recovery failed");
-            assert(r==0);
-        }
         // Logging is on again, but we must pass the right LSN into close.
         if (tuple->ft_handle) { // it's a DB, not a rollback file
             toku_ft_handle_close_recovery(tuple->ft_handle, oplsn);
-        } else {
-            assert(tuple->ft_handle==NULL);
         }
         file_map_tuple_destroy(tuple);
         toku_free(tuple);
@@ -202,7 +195,7 @@ static int recover_env_init (RECOVER_ENV renv,
                              generate_row_for_put_func generate_row_for_put,
                              generate_row_for_del_func generate_row_for_del,
                              size_t cachetable_size) {
-    int r;
+    int r = 0;
 
     // If we are passed a logger use it, otherwise create one.
     renv->destroy_logger_at_end = logger==NULL;
@@ -213,8 +206,7 @@ static int recover_env_init (RECOVER_ENV renv,
         assert(r == 0);
     }
     toku_logger_write_log_files(renv->logger, false);
-    r = toku_create_cachetable(&renv->ct, cachetable_size ? cachetable_size : 1<<25, (LSN){0}, renv->logger);
-    assert(r == 0);
+    toku_cachetable_create(&renv->ct, cachetable_size ? cachetable_size : 1<<25, (LSN){0}, renv->logger);
     toku_cachetable_set_env_dir(renv->ct, env_dir);
     if (keep_cachetable_callback) keep_cachetable_callback(env, renv->ct);
     toku_logger_set_cachetable(renv->logger, renv->ct);
@@ -233,15 +225,14 @@ static int recover_env_init (RECOVER_ENV renv,
     return r;
 }
 
-static void recover_env_cleanup (RECOVER_ENV renv, bool recovery_succeeded) {
+static void recover_env_cleanup (RECOVER_ENV renv) {
     int r;
 
     assert(toku_omt_size(renv->fmap.filenums)==0);
-    //file_map_close_dictionaries(renv, &renv->fmap, recovery_succeeded, oplsn);
     file_map_destroy(&renv->fmap);
 
     if (renv->destroy_logger_at_end) {
-        r = toku_logger_close_rollback(renv->logger, !recovery_succeeded);
+        r = toku_logger_close_rollback(renv->logger);
         assert(r==0);
         r = toku_logger_close(&renv->logger);
         assert(r == 0);
@@ -252,8 +243,7 @@ static void recover_env_cleanup (RECOVER_ENV renv, bool recovery_succeeded) {
     if (renv->keep_cachetable_callback) {
         renv->ct = NULL;
     } else {
-        r = toku_cachetable_close(&renv->ct);
-        assert(r == 0);
+        toku_cachetable_close(&renv->ct);
     }
 
     if (tokudb_recovery_trace)
@@ -267,13 +257,11 @@ static const char *recover_state(RECOVER_ENV renv) {
 // Open the file if it is not already open.  If it is already open, then do nothing.
 static int internal_recover_fopen_or_fcreate (RECOVER_ENV renv, bool must_create, int UU(mode), BYTESTRING *bs_iname, FILENUM filenum, uint32_t treeflags,
                                               TOKUTXN txn, uint32_t nodesize, uint32_t basementnodesize, enum toku_compression_method compression_method, LSN max_acceptable_lsn) {
-    int r;
+    int r = 0;
     FT_HANDLE brt = NULL;
     char *iname = fixup_fname(bs_iname);
 
-    r = toku_ft_handle_create(&brt);
-    assert(r == 0);
-
+    toku_ft_handle_create(&brt);
     toku_ft_set_flags(brt, treeflags);
 
     if (nodesize != 0) {
@@ -290,13 +278,11 @@ static int internal_recover_fopen_or_fcreate (RECOVER_ENV renv, bool must_create
 
     // set the key compare functions
     if (!(treeflags & TOKU_DB_KEYCMP_BUILTIN) && renv->bt_compare) {
-        r = toku_ft_set_bt_compare(brt, renv->bt_compare);
-        assert(r == 0);
+        toku_ft_set_bt_compare(brt, renv->bt_compare);
     }
 
     if (renv->update_function) {
-        r = toku_ft_set_update(brt, renv->update_function);
-        assert(r == 0);
+        toku_ft_set_update(brt, renv->update_function);
     }
 
     // TODO mode (FUTURE FEATURE)
@@ -432,8 +418,7 @@ static int toku_recover_fassociate (struct logtype_fassociate *l, RECOVER_ENV re
             if (rollback_file) {
                 max_acceptable_lsn = renv->ss.checkpoint_begin_lsn;
                 FT_HANDLE t;
-                r = toku_ft_handle_create(&t);
-                assert(r==0);
+                toku_ft_handle_create(&t);
                 r = toku_ft_handle_open_recovery(t, ROLLBACK_CACHEFILE_NAME, false, false, renv->ct, (TOKUTXN)NULL, l->filenum, max_acceptable_lsn);
                 renv->logger->rollback_cachefile = t->ft->cf;
             } else {
@@ -619,7 +604,7 @@ static int toku_recover_xstillopenprepared (struct logtype_xstillopenprepared *l
     }
     switch (renv->ss.ss) {
         case FORWARD_BETWEEN_CHECKPOINT_BEGIN_END: {
-            r = toku_txn_prepare_txn(txn, l->xa_xid);
+            toku_txn_prepare_txn(txn, l->xa_xid);
             break;
         }
         case FORWARD_NEWER_CHECKPOINT_END: {
@@ -710,8 +695,7 @@ static int toku_recover_xprepare (struct logtype_xprepare *l, RECOVER_ENV renv)
     assert(txn!=NULL);
 
     // Save the transaction
-    r = toku_txn_prepare_txn(txn, l->xa_xid);
-    assert(r == 0);
+    toku_txn_prepare_txn(txn, l->xa_xid);
 
     return 0;
 }
@@ -834,7 +818,7 @@ static int toku_recover_change_fdescriptor (struct logtype_change_fdescriptor *l
             l->new_descriptor.data, 
             l->new_descriptor.len
             );
-        r = toku_ft_change_descriptor(
+        toku_ft_change_descriptor(
             tuple->ft_handle, 
             &old_descriptor, 
             &new_descriptor, 
@@ -842,7 +826,6 @@ static int toku_recover_change_fdescriptor (struct logtype_change_fdescriptor *l
             txn,
             l->update_cmp_descriptor
             );
-        assert(r==0);
     }    
     return 0;
 }
@@ -889,7 +872,7 @@ static int toku_recover_fdelete (struct logtype_fdelete *l, RECOVER_ENV renv) {
     struct file_map_tuple *tuple;
     r = file_map_find(&renv->fmap, l->filenum, &tuple);
     if (r == 0) {
-        r = toku_ft_unlink_on_commit(tuple->ft_handle, txn);
+        toku_ft_unlink_on_commit(tuple->ft_handle, txn);
     }
     return 0;
 }
@@ -912,8 +895,7 @@ static int toku_recover_enq_insert (struct logtype_enq_insert *l, RECOVER_ENV re
         DBT keydbt, valdbt;
         toku_fill_dbt(&keydbt, l->key.data, l->key.len);
         toku_fill_dbt(&valdbt, l->value.data, l->value.len);
-        r = toku_ft_maybe_insert(tuple->ft_handle, &keydbt, &valdbt, txn, true, l->lsn, false, FT_INSERT);
-        assert(r == 0);
+        toku_ft_maybe_insert(tuple->ft_handle, &keydbt, &valdbt, txn, true, l->lsn, false, FT_INSERT);
         toku_txn_maybe_note_ft(txn, tuple->ft_handle->ft);
     }
     return 0;
@@ -937,8 +919,7 @@ static int toku_recover_enq_insert_no_overwrite (struct logtype_enq_insert_no_ov
         DBT keydbt, valdbt;
         toku_fill_dbt(&keydbt, l->key.data, l->key.len);
         toku_fill_dbt(&valdbt, l->value.data, l->value.len);
-        r = toku_ft_maybe_insert(tuple->ft_handle, &keydbt, &valdbt, txn, true, l->lsn, false, FT_INSERT_NO_OVERWRITE);
-        assert(r == 0);
+        toku_ft_maybe_insert(tuple->ft_handle, &keydbt, &valdbt, txn, true, l->lsn, false, FT_INSERT_NO_OVERWRITE);
     }    
     return 0;
 }
@@ -960,8 +941,7 @@ static int toku_recover_enq_delete_any (struct logtype_enq_delete_any *l, RECOVE
         //Maybe do the deletion if we found the cachefile.
         DBT keydbt;
         toku_fill_dbt(&keydbt, l->key.data, l->key.len);
-        r = toku_ft_maybe_delete(tuple->ft_handle, &keydbt, txn, true, l->lsn, false);
-        assert(r == 0);
+        toku_ft_maybe_delete(tuple->ft_handle, &keydbt, txn, true, l->lsn, false);
     }    
     return 0;
 }
@@ -1007,8 +987,7 @@ static int toku_recover_enq_insert_multiple (struct logtype_enq_insert_multiple
                 DB *db = &tuple->fake_db;
                 r = renv->generate_row_for_put(db, src_db, &dest_key, &dest_val, &src_key, &src_val);
                 assert(r==0);
-                r = toku_ft_maybe_insert(tuple->ft_handle, &dest_key, &dest_val, txn, true, l->lsn, false, FT_INSERT);
-                assert(r == 0);
+                toku_ft_maybe_insert(tuple->ft_handle, &dest_key, &dest_val, txn, true, l->lsn, false, FT_INSERT);
 
                 //flags==0 means generate_row_for_put callback changed it
                 //(and freed any memory necessary to do so) so that values are now stored
@@ -1068,8 +1047,7 @@ static int toku_recover_enq_delete_multiple (struct logtype_enq_delete_multiple
                 DB *db = &tuple->fake_db;
                 r = renv->generate_row_for_del(db, src_db, &dest_key, &src_key, &src_val);
                 assert(r==0);
-                r = toku_ft_maybe_delete(tuple->ft_handle, &dest_key, txn, true, l->lsn, false);
-                assert(r == 0);
+                toku_ft_maybe_delete(tuple->ft_handle, &dest_key, txn, true, l->lsn, false);
 
                 //flags==0 indicates the return values are stored in temporary memory that does
                 //not need to be freed.  We need to continue using DB_DBT_REALLOC however.
@@ -1102,9 +1080,7 @@ static int toku_recover_enq_update(struct logtype_enq_update *l, RECOVER_ENV ren
         DBT key, extra;
         toku_fill_dbt(&key, l->key.data, l->key.len);
         toku_fill_dbt(&extra, l->extra.data, l->extra.len);
-        r = toku_ft_maybe_update(tuple->ft_handle, &key, &extra, txn, true, l->lsn,
-                                  false);
-        assert(r == 0);
+        toku_ft_maybe_update(tuple->ft_handle, &key, &extra, txn, true, l->lsn, false);
     }
     return 0;
 }
@@ -1121,9 +1097,8 @@ static int toku_recover_enq_updatebroadcast(struct logtype_enq_updatebroadcast *
         // Maybe do the update broadcast if we found the cachefile.
         DBT extra;
         toku_fill_dbt(&extra, l->extra.data, l->extra.len);
-        r = toku_ft_maybe_update_broadcast(tuple->ft_handle, &extra, txn, true,
+        toku_ft_maybe_update_broadcast(tuple->ft_handle, &extra, txn, true,
                                             l->lsn, false, l->is_resetting_op);
-        assert(r == 0);
     }
     return 0;
 }
@@ -1169,15 +1144,13 @@ static int toku_recover_backward_shutdown (struct logtype_shutdown *UU(l), RECOV
 }
 
 static int toku_recover_load(struct logtype_load *UU(l), RECOVER_ENV UU(renv)) {
-    int r;
     TOKUTXN txn = NULL;
-    r = toku_txnid2txn(renv->logger, l->xid, &txn);
+    int r = toku_txnid2txn(renv->logger, l->xid, &txn);
     assert(r == 0);
     assert(txn!=NULL);
     char *new_iname = fixup_fname(&l->new_iname);
 
-    r = toku_ft_load_recovery(txn, l->old_filenum, new_iname, 0, 0, (LSN*)NULL);
-    assert(r==0);
+    toku_ft_load_recovery(txn, l->old_filenum, new_iname, 0, 0, (LSN*)NULL);
 
     toku_free(new_iname);
     return 0;
@@ -1190,15 +1163,13 @@ static int toku_recover_backward_load(struct logtype_load *UU(l), RECOVER_ENV UU
 
 // #2954
 static int toku_recover_hot_index(struct logtype_hot_index *UU(l), RECOVER_ENV UU(renv)) {
-    int r;
     TOKUTXN txn = NULL;
-    r = toku_txnid2txn(renv->logger, l->xid, &txn);
+    int r = toku_txnid2txn(renv->logger, l->xid, &txn);
     assert(r == 0);
     assert(txn!=NULL);
     // just make an entry in the rollback log 
     //   - set do_log = 0 -> don't write to recovery log
-    r = toku_ft_hot_index_recovery(txn, l->hot_index_filenums, 0, 0, (LSN*)NULL);
-    assert(r == 0);
+    toku_ft_hot_index_recovery(txn, l->hot_index_filenums, 0, 0, (LSN*)NULL);
     return 0;
 }
 
@@ -1499,13 +1470,12 @@ static int do_recovery(RECOVER_ENV renv, const char *env_dir, const char *log_di
         tnow = time(NULL);
         fprintf(stderr, "%.24s Tokudb recovery closing %" PRIu32 " dictionar%s\n", ctime(&tnow), n, n > 1 ? "ies" : "y");
     }
-    file_map_close_dictionaries(&renv->fmap, true, lastlsn);
+    file_map_close_dictionaries(&renv->fmap, lastlsn);
 
     {
         // write a recovery log entry
         BYTESTRING recover_comment = { static_cast<uint32_t>(strlen("recover")), (char *) "recover" };
-        r = toku_log_comment(renv->logger, NULL, true, 0, recover_comment);
-        assert(r == 0);
+        toku_log_comment(renv->logger, NULL, true, 0, recover_comment);
     }
 
     // checkpoint 
@@ -1594,7 +1564,7 @@ int tokudb_recover(DB_ENV *env,
 
         rr = do_recovery(&renv, env_dir, log_dir);
 
-        recover_env_cleanup(&renv, (bool)(rr == 0));
+        recover_env_cleanup(&renv);
     }
 
     r = toku_recover_unlock(lockfd);
diff --git a/ft/roll.cc b/ft/roll.cc
index 6a8fff46d7d..1833a382b3e 100644
--- a/ft/roll.cc
+++ b/ft/roll.cc
@@ -179,8 +179,8 @@ static int do_insertion (enum ft_msg_type type, FILENUM filenum, BYTESTRING key,
                                           ? toku_fill_dbt(&data_dbt, data->data, data->len)
                                           : toku_init_dbt(&data_dbt) } } };
 
-        r = toku_ft_root_put_cmd(h, &ftcmd);
-        if (r == 0 && reset_root_xid_that_created) {
+        toku_ft_root_put_cmd(h, &ftcmd);
+        if (reset_root_xid_that_created) {
             TXNID new_root_xid_that_created = xids_get_outermost_xid(xids);
             toku_reset_root_xid_that_created(h, new_root_xid_that_created);
         }
diff --git a/ft/rollback-apply.cc b/ft/rollback-apply.cc
index 9a3f8acc823..fe15ea3bac2 100644
--- a/ft/rollback-apply.cc
+++ b/ft/rollback-apply.cc
@@ -139,10 +139,9 @@ int toku_rollback_commit(TOKUTXN txn, LSN lsn) {
             if (txn_has_current_rollback_log(txn)) {
                 num_nodes--; //Don't count the in-progress rollback log.
             }
-            r = toku_logger_save_rollback_rollinclude(txn->parent, txn->txnid64, num_nodes,
+            toku_logger_save_rollback_rollinclude(txn->parent, txn->txnid64, num_nodes,
                                                       txn->roll_info.spilled_rollback_head, txn->roll_info.spilled_rollback_head_hash,
                                                       txn->roll_info.spilled_rollback_tail, txn->roll_info.spilled_rollback_tail_hash);
-            if (r!=0) return r;
             //Remove ownership from child.
             txn->roll_info.spilled_rollback_head      = ROLLBACK_NONE; 
             txn->roll_info.spilled_rollback_head_hash = 0; 
diff --git a/ft/rollback-ct-callbacks.cc b/ft/rollback-ct-callbacks.cc
index 984b874a79c..50b20a1e05c 100644
--- a/ft/rollback-ct-callbacks.cc
+++ b/ft/rollback-ct-callbacks.cc
@@ -27,7 +27,6 @@ rollback_log_destroy(ROLLBACK_LOG_NODE log) {
 void toku_rollback_flush_callback (CACHEFILE cachefile, int fd, BLOCKNUM logname,
                                           void *rollback_v,  void** UU(disk_data), void *extraargs, PAIR_ATTR size, PAIR_ATTR* new_size,
                                           bool write_me, bool keep_me, bool for_checkpoint, bool is_clone) {
-    int r;
     ROLLBACK_LOG_NODE log = nullptr;
     SERIALIZED_ROLLBACK_LOG_NODE serialized = nullptr;
     if (is_clone) {
@@ -40,20 +39,10 @@ void toku_rollback_flush_callback (CACHEFILE cachefile, int fd, BLOCKNUM logname
     }
     FT CAST_FROM_VOIDP(h, extraargs);
 
-    if (write_me && !h->panic) {
+    if (write_me) {
         assert(h->cf == cachefile);
-
-        r = toku_serialize_rollback_log_to(fd, log, serialized, is_clone, h, for_checkpoint);
-        if (r) {
-            if (h->panic==0) {
-                char *e = strerror(r);
-                int   l = 200 + strlen(e);
-                char s[l];
-                h->panic=r;
-                snprintf(s, l-1, "While writing data to disk, error %d (%s)", r, e);
-                h->panic_string = toku_strdup(s);
-            }
-        }
+        int r = toku_serialize_rollback_log_to(fd, log, serialized, is_clone, h, for_checkpoint);
+        assert(r == 0);
     }
     *new_size = size;
     if (!keep_me) {
diff --git a/ft/rollback.cc b/ft/rollback.cc
index 21cff04cd7d..d2ba46a4517 100644
--- a/ft/rollback.cc
+++ b/ft/rollback.cc
@@ -74,7 +74,6 @@ static void rollback_log_create (TOKUTXN txn, BLOCKNUM previous, uint32_t previo
     ROLLBACK_LOG_NODE MALLOC(log);
     assert(log);
 
-    int r;
     CACHEFILE cf = txn->logger->rollback_cachefile;
     FT CAST_FROM_VOIDP(h, toku_cachefile_get_userdata(cf));
 
@@ -94,11 +93,10 @@ static void rollback_log_create (TOKUTXN txn, BLOCKNUM previous, uint32_t previo
     log->rollentry_resident_bytecount = 0;
 
     *result = log;
-    r = toku_cachetable_put(cf, log->blocknum, log->hash,
-                          log, rollback_memory_size(log),
-                          get_write_callbacks_for_rollback_log(h),
-                          toku_rollback_node_save_ct_pair);
-    assert(r == 0);
+    toku_cachetable_put(cf, log->blocknum, log->hash,
+                       log, rollback_memory_size(log),
+                       get_write_callbacks_for_rollback_log(h),
+                       toku_rollback_node_save_ct_pair);
     txn->roll_info.current_rollback      = log->blocknum;
     txn->roll_info.current_rollback_hash = log->hash;
 }
diff --git a/ft/tests/benchmark-test.cc b/ft/tests/benchmark-test.cc
index b5f15be1c92..674bef82671 100644
--- a/ft/tests/benchmark-test.cc
+++ b/ft/tests/benchmark-test.cc
@@ -35,14 +35,14 @@ static FT_HANDLE t;
 static void setup (void) {
     int r;
     unlink(fname);
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);         assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 1, &t, nodesize, basementnodesize, compression_method, ct, NULL_TXN, toku_builtin_compare_fun); assert(r==0);
 }
 
 static void toku_shutdown (void) {
     int r;
     r = toku_close_ft_handle_nolsn(t, 0); assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
 }
 static void long_long_to_array (unsigned char *a, unsigned long long l) {
     int i;
@@ -57,8 +57,7 @@ static void insert (long long v) {
     long_long_to_array(kc, v);
     memset(vc, 0, sizeof vc);
     long_long_to_array(vc, v);
-    int r = toku_ft_insert(t, toku_fill_dbt(&kt, kc, keysize), toku_fill_dbt(&vt, vc, valsize), 0);
-    CKERR(r);
+    toku_ft_insert(t, toku_fill_dbt(&kt, kc, keysize), toku_fill_dbt(&vt, vc, valsize), 0);
     if (do_verify) toku_cachetable_verify(ct);
 }
 
diff --git a/ft/tests/bnc-insert-benchmark.cc b/ft/tests/bnc-insert-benchmark.cc
index b12c98e6d7b..b6c76e03847 100644
--- a/ft/tests/bnc-insert-benchmark.cc
+++ b/ft/tests/bnc-insert-benchmark.cc
@@ -54,11 +54,11 @@ run_test(unsigned long eltsize, unsigned long nodesize, unsigned long repeat)
     for (unsigned int i = 0; i < repeat; ++i) {
         bnc = toku_create_empty_nl();
         for (; toku_bnc_nbytesinbuf(bnc) <= nodesize; ++cur) {
-            r = toku_bnc_insert_msg(bnc,
-                                    &keys[cur % 1024], sizeof keys[cur % 1024],
-                                    vals[cur % 1024], eltsize - (sizeof keys[cur % 1024]),
-                                    FT_NONE, next_dummymsn(), xids_123, true,
-                                    NULL, long_key_cmp); assert_zero(r);
+            toku_bnc_insert_msg(bnc,
+                                &keys[cur % 1024], sizeof keys[cur % 1024],
+                                vals[cur % 1024], eltsize - (sizeof keys[cur % 1024]),
+                                FT_NONE, next_dummymsn(), xids_123, true,
+                                NULL, long_key_cmp); assert_zero(r);
         }
         nbytesinserted += toku_bnc_nbytesinbuf(bnc);
         destroy_nonleaf_childinfo(bnc);
diff --git a/ft/tests/cachetable-3969.cc b/ft/tests/cachetable-3969.cc
index cd63708b876..161698df4c9 100644
--- a/ft/tests/cachetable-3969.cc
+++ b/ft/tests/cachetable-3969.cc
@@ -23,7 +23,7 @@ run_test (void) {
     const int test_limit = 20;
     int r;
     ct = NULL;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     f1 = NULL;
@@ -53,7 +53,7 @@ run_test (void) {
     // pin 1 and 2
     r = toku_cachetable_get_and_pin(f1, make_blocknum(1), 1, &v2, &s2, def_write_callback(NULL), def_fetch, def_pf_req_callback, def_pf_callback, true, NULL);
     CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-    r = toku_cachetable_begin_checkpoint(cp, NULL);
+    toku_cachetable_begin_checkpoint(cp, NULL);
     // mark nodes as pending a checkpoint, so that get_and_pin_nonblocking on block 1 will return TOKUDB_TRY_AGAIN
     r = toku_test_cachetable_unpin(f1, make_blocknum(1), 1, CACHETABLE_DIRTY, make_pair_attr(8)); assert(r==0);
 
@@ -80,19 +80,16 @@ run_test (void) {
         );
     assert(r==TOKUDB_TRY_AGAIN);
     
-    r = toku_cachetable_end_checkpoint(
+    toku_cachetable_end_checkpoint(
         cp, 
         NULL, 
         NULL,
         NULL
         );
-    assert(r==0);
     
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
-    
-    
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-4357.cc b/ft/tests/cachetable-4357.cc
index f7c51088f5a..fc28bbd46b0 100644
--- a/ft/tests/cachetable-4357.cc
+++ b/ft/tests/cachetable-4357.cc
@@ -31,7 +31,7 @@ cachetable_test (void) {
   const int test_limit = 12;
   int r;
   CACHETABLE ct;
-  r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+  toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
   char fname1[] = __SRCFILE__ "test1.dat";
   unlink(fname1);
   r = toku_cachetable_openf(&f1, ct, fname1, O_RDWR|O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO); assert(r == 0);
@@ -61,10 +61,8 @@ cachetable_test (void) {
   assert_zero(r);
   
   toku_cachetable_verify(ct);
-  r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-  r = toku_cachetable_close(&ct); lazy_assert_zero(r);
-
-
+  r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+  toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-4365.cc b/ft/tests/cachetable-4365.cc
index fbcb4d6ec3d..3d3f811f62b 100644
--- a/ft/tests/cachetable-4365.cc
+++ b/ft/tests/cachetable-4365.cc
@@ -26,7 +26,7 @@ static void *pin_nonblocking(void *arg) {
 }
 
 static void *put_same_key(void *arg) {
-    int r = toku_cachetable_put(
+    toku_cachetable_put(
         f1, 
         make_blocknum(1),
         toku_cachetable_hash(f1,make_blocknum(1)),
@@ -35,7 +35,6 @@ static void *put_same_key(void *arg) {
         def_write_callback(NULL),
         put_callback_nop
         );
-    assert(r==0);
     return arg;
 }
 
@@ -53,7 +52,7 @@ cachetable_test (void) {
   const int test_limit = 12;
   int r;
   CACHETABLE ct;
-  r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+  toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
   char fname1[] = __SRCFILE__ "test1.dat";
   unlink(fname1);
   r = toku_cachetable_openf(&f1, ct, fname1, O_RDWR|O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO); assert(r == 0);
@@ -87,10 +86,8 @@ cachetable_test (void) {
   r = toku_test_cachetable_unpin(f1, make_blocknum(1), toku_cachetable_hash(f1, make_blocknum(1)), CACHETABLE_CLEAN, make_pair_attr(2));
   
   toku_cachetable_verify(ct);
-  r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-  r = toku_cachetable_close(&ct); lazy_assert_zero(r);
-
-
+  r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+  toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-5097.cc b/ft/tests/cachetable-5097.cc
index 06c4c8dda54..e08a6e27880 100644
--- a/ft/tests/cachetable-5097.cc
+++ b/ft/tests/cachetable-5097.cc
@@ -84,7 +84,7 @@ cachetable_test (void) {
     check_flush = false;
     dirty_flush_called = false;
     
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     evictor_test_helpers::disable_ev_thread(&ct->ev); // disable eviction thread
     
     char fname1[] = __SRCFILE__ "test1.dat";
@@ -118,7 +118,7 @@ cachetable_test (void) {
 
     usleep(2*1024*1024);
     check_flush = true;
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); 
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); 
     assert(r == 0);
     assert(dirty_flush_called);
     check_flush = false;
@@ -129,8 +129,8 @@ cachetable_test (void) {
 
 
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f2, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f2, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-all-write.cc b/ft/tests/cachetable-all-write.cc
index b17a166c133..4e155b09f26 100644
--- a/ft/tests/cachetable-all-write.cc
+++ b/ft/tests/cachetable-all-write.cc
@@ -32,7 +32,7 @@ cachetable_test (void) {
     const int test_limit = 12;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -52,8 +52,8 @@ cachetable_test (void) {
     //r = toku_test_cachetable_unpin(f1, make_blocknum(1), 1, CACHETABLE_CLEAN, 8);
 
 
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-checkpoint-pending.cc b/ft/tests/cachetable-checkpoint-pending.cc
index ac81329ae3a..daa24133208 100644
--- a/ft/tests/cachetable-checkpoint-pending.cc
+++ b/ft/tests/cachetable-checkpoint-pending.cc
@@ -105,7 +105,7 @@ static void checkpoint_pending(void) {
     if (verbose) { printf("%s:%d n=%d\n", __FUNCTION__, __LINE__, N); fflush(stdout); }
     const int test_limit = N;
     int r;
-    r = toku_create_cachetable(&ct, test_limit*sizeof(int), ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit*sizeof(int), ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     r = unlink(fname1); if (r!=0) CKERR2(get_error_errno(), ENOENT);
     r = toku_cachetable_openf(&cf, ct, fname1, O_RDWR|O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO); assert(r == 0);
@@ -119,7 +119,7 @@ static void checkpoint_pending(void) {
 	values[i] = 42;
         CACHETABLE_WRITE_CALLBACK wc = def_write_callback(NULL);
         wc.flush_callback = flush;
-        r = toku_cachetable_put(cf, key, hi, &values[i], make_pair_attr(sizeof(int)), wc, put_callback_nop);
+        toku_cachetable_put(cf, key, hi, &values[i], make_pair_attr(sizeof(int)), wc, put_callback_nop);
         assert(r == 0);
 
         r = toku_test_cachetable_unpin(cf, key, hi, CACHETABLE_DIRTY, make_pair_attr(item_size));
@@ -153,8 +153,8 @@ static void checkpoint_pending(void) {
     assert(r == 0);
     assert(n_flush == 0 && n_write_me == 0 && n_keep_me == 0);
 
-    r = toku_cachefile_close(&cf, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&cf, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-checkpoint-pinned-nodes.cc b/ft/tests/cachetable-checkpoint-pinned-nodes.cc
index 7836a9c72cd..c0aa645a2e9 100644
--- a/ft/tests/cachetable-checkpoint-pinned-nodes.cc
+++ b/ft/tests/cachetable-checkpoint-pinned-nodes.cc
@@ -68,7 +68,7 @@ cachetable_test (void) {
   const int test_limit = 20;
   int r;
   CACHETABLE ct;
-  r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+  toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
   char fname1[] = __SRCFILE__ "test1.dat";
   unlink(fname1);
   CACHEFILE f1;
@@ -91,7 +91,7 @@ cachetable_test (void) {
   // flush will be called only for v1, because v1 is dirty
   //
   CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-  r = toku_cachetable_begin_checkpoint(cp, NULL); assert(r == 0);
+  toku_cachetable_begin_checkpoint(cp, NULL);
 
 
   r = toku_test_cachetable_unpin(f1, make_blocknum(1), 1, CACHETABLE_DIRTY, make_pair_attr(8));
@@ -99,7 +99,7 @@ cachetable_test (void) {
 
   check_me = true;
   flush_called = false;
-  r = toku_cachetable_end_checkpoint(
+  toku_cachetable_end_checkpoint(
       cp, 
       NULL, 
       NULL,
@@ -110,8 +110,8 @@ cachetable_test (void) {
   check_me = false;
 
   toku_cachetable_verify(ct);
-  r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-  r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+  r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+  toku_cachetable_close(&ct);
 
 
 }
diff --git a/ft/tests/cachetable-checkpoint-prefetched-nodes.cc b/ft/tests/cachetable-checkpoint-prefetched-nodes.cc
index d0d9828f3e3..68356ad5106 100644
--- a/ft/tests/cachetable-checkpoint-prefetched-nodes.cc
+++ b/ft/tests/cachetable-checkpoint-prefetched-nodes.cc
@@ -70,7 +70,7 @@ cachetable_test (void) {
   const int test_limit = 20;
   int r;
   CACHETABLE ct;
-  r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+  toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
   char fname1[] = __SRCFILE__ "test1.dat";
   unlink(fname1);
   CACHEFILE f1;
@@ -93,12 +93,12 @@ cachetable_test (void) {
   // flush will be called only for v1, because v1 is dirty
   //
   CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-  r = toku_cachetable_begin_checkpoint(cp, NULL); assert(r == 0);
+  toku_cachetable_begin_checkpoint(cp, NULL);
 
 
   check_me = true;
   flush_called = false;
-  r = toku_cachetable_end_checkpoint(
+  toku_cachetable_end_checkpoint(
       cp, 
       NULL, 
       NULL,
@@ -111,8 +111,8 @@ cachetable_test (void) {
 
 
   toku_cachetable_verify(ct);
-  r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-  r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+  r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+  toku_cachetable_close(&ct);
 
 
 }
diff --git a/ft/tests/cachetable-checkpoint-test.cc b/ft/tests/cachetable-checkpoint-test.cc
index c0197ebf0fe..08227b527b7 100644
--- a/ft/tests/cachetable-checkpoint-test.cc
+++ b/ft/tests/cachetable-checkpoint-test.cc
@@ -60,7 +60,7 @@ static void cachetable_checkpoint_test(int n, enum cachetable_dirty dirty) {
     const int test_limit = n;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -74,8 +74,7 @@ static void cachetable_checkpoint_test(int n, enum cachetable_dirty dirty) {
         uint32_t hi = toku_cachetable_hash(f1, key);
         CACHETABLE_WRITE_CALLBACK wc = def_write_callback(NULL);
         wc.flush_callback = flush;
-        r = toku_cachetable_put(f1, key, hi, (void *)(long)i, make_pair_attr(1), wc, put_callback_nop);
-        assert(r == 0);
+        toku_cachetable_put(f1, key, hi, (void *)(long)i, make_pair_attr(1), wc, put_callback_nop);
 
         r = toku_test_cachetable_unpin(f1, key, hi, dirty, make_pair_attr(item_size));
         assert(r == 0);
@@ -132,8 +131,8 @@ static void cachetable_checkpoint_test(int n, enum cachetable_dirty dirty) {
     assert(r == 0);
     assert(n_flush == 0 && n_write_me == 0 && n_keep_me == 0);
 
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0 );
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0 );
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-checkpointer-class.cc b/ft/tests/cachetable-checkpointer-class.cc
index a7135790117..f7129d3edfa 100644
--- a/ft/tests/cachetable-checkpointer-class.cc
+++ b/ft/tests/cachetable-checkpointer-class.cc
@@ -34,8 +34,6 @@ struct checkpointer_test {
 // Description:
 //
 void checkpointer_test::test_begin_checkpoint() {
-    int r = 0;
-
     cachefile_list cfl;
     cfl.init();
 
@@ -46,8 +44,7 @@ void checkpointer_test::test_begin_checkpoint() {
     m_cp.init(&ctbl.list, NULL, &ctbl.ev, &cfl);
 
     // 1. Call checkpoint with NO cachefiles.
-    r = m_cp.begin_checkpoint();
-    if (r) { assert(!"CHECKPOINTER: Checkpoint with no cachefiles failed!\n"); }
+    m_cp.begin_checkpoint();
 
     // 2. Call checkpoint with ONE cachefile.
     //cachefile cf;
@@ -57,8 +54,7 @@ void checkpointer_test::test_begin_checkpoint() {
     m_cp.m_cf_list->m_head = &cf;
     create_dummy_functions(&cf);
 
-    r = m_cp.begin_checkpoint();
-    if (r) { assert(!"CHECKPOINTER: Checkpoint with one cachefile failed!\n"); }
+    m_cp.begin_checkpoint();
     assert(m_cp.m_checkpoint_num_files == 1);
     assert(cf.for_checkpoint == true);
 
@@ -76,8 +72,7 @@ void checkpointer_test::test_begin_checkpoint() {
         }
     }
 
-    r = m_cp.begin_checkpoint();
-    if (r) { assert(!"CHECKPOINTER: Multiple checkpoint failed!\n"); }
+    m_cp.begin_checkpoint();
     assert(m_cp.m_checkpoint_num_files == count);
     for (uint32_t i = 0; i < count; ++i) {
         assert(cfs[i].for_checkpoint == true);
@@ -171,8 +166,7 @@ void checkpointer_test::test_pending_bits() {
         m_cp.m_list->evict(pp);
     }
 
-    int r = ctbl.list.destroy();
-    assert_zero(r);
+    ctbl.list.destroy();
     m_cp.destroy();
 }
 
@@ -307,8 +301,7 @@ void checkpointer_test::test_end_checkpoint() {
         m_cp.m_list->evict(pp);
     }
     m_cp.destroy();
-    int r = ctbl.list.destroy();
-    assert_zero(r);
+    ctbl.list.destroy();
 }
 
 
diff --git a/ft/tests/cachetable-cleaner-checkpoint.cc b/ft/tests/cachetable-cleaner-checkpoint.cc
index e2b569583e3..41672e14345 100644
--- a/ft/tests/cachetable-cleaner-checkpoint.cc
+++ b/ft/tests/cachetable-cleaner-checkpoint.cc
@@ -63,7 +63,7 @@ cachetable_test (void) {
   const int test_limit = 12;
   int r;
   CACHETABLE ct;
-  r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+  toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
   char fname1[] = __SRCFILE__ "test1.dat";
   unlink(fname1);
   r = toku_cachetable_openf(&f1, ct, fname1, O_RDWR|O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO); assert(r == 0);
@@ -83,11 +83,11 @@ cachetable_test (void) {
 
   cleaner_called = false;
   CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-  r = toku_cachetable_begin_checkpoint(cp, NULL);
+  toku_cachetable_begin_checkpoint(cp, NULL);
   assert_zero(r);
   toku_cleaner_thread_for_test(ct);
   assert(cleaner_called);
-  r = toku_cachetable_end_checkpoint(
+  toku_cachetable_end_checkpoint(
       cp, 
       NULL, 
       NULL,
@@ -96,8 +96,8 @@ cachetable_test (void) {
   assert(r==0);
 
   toku_cachetable_verify(ct);
-  r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-  r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+  r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+  toku_cachetable_close(&ct);
 
 
 }
diff --git a/ft/tests/cachetable-cleaner-checkpoint2.cc b/ft/tests/cachetable-cleaner-checkpoint2.cc
index 2ae524e6985..c117c566583 100644
--- a/ft/tests/cachetable-cleaner-checkpoint2.cc
+++ b/ft/tests/cachetable-cleaner-checkpoint2.cc
@@ -63,7 +63,7 @@ cachetable_test (void) {
   const int test_limit = 12;
   int r;
   CACHETABLE ct;
-  r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+  toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
   char fname1[] = __SRCFILE__ "test1.dat";
   unlink(fname1);
   r = toku_cachetable_openf(&f1, ct, fname1, O_RDWR|O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO); assert(r == 0);
@@ -83,11 +83,11 @@ cachetable_test (void) {
 
   cleaner_called = false;
   CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-  r = toku_cachetable_begin_checkpoint(cp, NULL);
+  toku_cachetable_begin_checkpoint(cp, NULL);
   assert_zero(r);
   toku_cleaner_thread_for_test(ct);
   assert(!cleaner_called);
-  r = toku_cachetable_end_checkpoint(
+  toku_cachetable_end_checkpoint(
       cp, 
       NULL, 
       NULL,
@@ -96,8 +96,8 @@ cachetable_test (void) {
   assert(r==0);
 
   toku_cachetable_verify(ct);
-  r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-  r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+  r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+  toku_cachetable_close(&ct);
 
 
 }
diff --git a/ft/tests/cachetable-cleaner-thread-attrs-accumulate.cc b/ft/tests/cachetable-cleaner-thread-attrs-accumulate.cc
index c7a9e334175..cef6667ec29 100644
--- a/ft/tests/cachetable-cleaner-thread-attrs-accumulate.cc
+++ b/ft/tests/cachetable-cleaner-thread-attrs-accumulate.cc
@@ -59,7 +59,7 @@ run_test (void) {
     int r;
     CACHETABLE ct;
     toku_mutex_init(&attr_mutex, NULL);
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
 
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
@@ -126,8 +126,8 @@ run_test (void) {
     assert(STATUS_VALUE(CT_SIZE_CACHEPRESSURE) == (uint64_t) expect.cache_pressure_size);
 
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-cleaner-thread-empty-cachetable.cc b/ft/tests/cachetable-cleaner-thread-empty-cachetable.cc
index 08795c9274a..f7c4dbd0ff5 100644
--- a/ft/tests/cachetable-cleaner-thread-empty-cachetable.cc
+++ b/ft/tests/cachetable-cleaner-thread-empty-cachetable.cc
@@ -15,8 +15,8 @@ cachetable_test (void) {
     const int test_limit = 1000;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
-    r = toku_set_cleaner_period(ct, 1); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
+    toku_set_cleaner_period(ct, 1);
 
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
@@ -26,8 +26,8 @@ cachetable_test (void) {
     
     usleep(4000000);
     CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-    r = toku_cachetable_begin_checkpoint(cp, NULL); assert(r == 0);
-    r = toku_cachetable_end_checkpoint(
+    toku_cachetable_begin_checkpoint(cp, NULL);
+    toku_cachetable_end_checkpoint(
         cp,
         NULL,
         NULL,
@@ -36,8 +36,8 @@ cachetable_test (void) {
     assert(r==0);
 
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-cleaner-thread-everything-pinned.cc b/ft/tests/cachetable-cleaner-thread-everything-pinned.cc
index 9f1953b5ce1..446d466c59f 100644
--- a/ft/tests/cachetable-cleaner-thread-everything-pinned.cc
+++ b/ft/tests/cachetable-cleaner-thread-everything-pinned.cc
@@ -27,14 +27,14 @@ run_test (void) {
     const int test_limit = 1000;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
-    r = toku_set_cleaner_period(ct, 1); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
+    toku_set_cleaner_period(ct, 1);
 
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
     r = toku_cachetable_openf(&f1, ct, fname1, O_RDWR|O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO); assert(r == 0);
-    r = toku_set_cleaner_period(ct, 1);
+    toku_set_cleaner_period(ct, 1);
     assert(r==0);
 
     void* vs[8];
@@ -62,8 +62,8 @@ run_test (void) {
     }
 
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-cleaner-thread-nothing-needs-flushing.cc b/ft/tests/cachetable-cleaner-thread-nothing-needs-flushing.cc
index 5b271a09c20..856fac9d9d9 100644
--- a/ft/tests/cachetable-cleaner-thread-nothing-needs-flushing.cc
+++ b/ft/tests/cachetable-cleaner-thread-nothing-needs-flushing.cc
@@ -27,8 +27,8 @@ run_test (void) {
     const int test_limit = 1000;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
-    r = toku_set_cleaner_period(ct, 1); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
+    toku_set_cleaner_period(ct, 1);
 
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
@@ -60,8 +60,8 @@ run_test (void) {
     usleep(4000000);
 
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-cleaner-thread-simple.cc b/ft/tests/cachetable-cleaner-thread-simple.cc
index 046d05d8654..60e4c42b867 100644
--- a/ft/tests/cachetable-cleaner-thread-simple.cc
+++ b/ft/tests/cachetable-cleaner-thread-simple.cc
@@ -35,8 +35,8 @@ run_test (void) {
     const int test_limit = 1000;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
-    r = toku_set_cleaner_period(ct, 1); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
+    toku_set_cleaner_period(ct, 1);
     my_cleaner_callback_called = false;
 
     char fname1[] = __SRCFILE__ "test1.dat";
@@ -80,8 +80,8 @@ run_test (void) {
     assert(my_cleaner_callback_called);
 
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0 );
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0 );
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-clock-all-pinned.cc b/ft/tests/cachetable-clock-all-pinned.cc
index ed048b216fa..171505f6e9a 100644
--- a/ft/tests/cachetable-clock-all-pinned.cc
+++ b/ft/tests/cachetable-clock-all-pinned.cc
@@ -12,7 +12,7 @@ cachetable_test (void) {
     int test_limit = 6;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -20,14 +20,13 @@ cachetable_test (void) {
 
     // test that putting something too big in the cachetable works fine
     CACHETABLE_WRITE_CALLBACK wc = def_write_callback(NULL);
-    r = toku_cachetable_put(f1, make_blocknum(num_entries+1), num_entries+1, NULL, make_pair_attr(test_limit*2), wc, put_callback_nop);
-    assert(r==0);
+    toku_cachetable_put(f1, make_blocknum(num_entries+1), num_entries+1, NULL, make_pair_attr(test_limit*2), wc, put_callback_nop);
     r = toku_test_cachetable_unpin(f1, make_blocknum(num_entries+1), num_entries+1, CACHETABLE_DIRTY, make_pair_attr(test_limit*2));
     assert(r==0);
 
 
     for (int64_t i = 0; i < num_entries; i++) {
-        r = toku_cachetable_put(f1, make_blocknum(i), i, NULL, make_pair_attr(1), wc, put_callback_nop);
+        toku_cachetable_put(f1, make_blocknum(i), i, NULL, make_pair_attr(1), wc, put_callback_nop);
         assert(toku_cachefile_count_pinned(f1, 0) == (i+1));
     }
     for (int64_t i = 0; i < num_entries; i++) {
@@ -35,8 +34,8 @@ cachetable_test (void) {
     }
 
     
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0 );
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0 );
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-clock-eviction.cc b/ft/tests/cachetable-clock-eviction.cc
index 49ee874c243..730980eac46 100644
--- a/ft/tests/cachetable-clock-eviction.cc
+++ b/ft/tests/cachetable-clock-eviction.cc
@@ -58,7 +58,7 @@ cachetable_test (void) {
     num_entries = 0;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -89,7 +89,7 @@ cachetable_test (void) {
     }
     flush_may_occur = true;
     expected_flushed_key = 4;
-    r = toku_cachetable_put(f1, make_blocknum(5), 5, NULL, make_pair_attr(4), wc, put_callback_nop);
+    toku_cachetable_put(f1, make_blocknum(5), 5, NULL, make_pair_attr(4), wc, put_callback_nop);
     ct->ev.signal_eviction_thread();
     usleep(1*1024*1024);
     
@@ -100,8 +100,8 @@ cachetable_test (void) {
     usleep(1*1024*1024);
 
     check_flush = false;
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0 );
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0 );
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-clock-eviction2.cc b/ft/tests/cachetable-clock-eviction2.cc
index 902fac2848b..084b76d63ba 100644
--- a/ft/tests/cachetable-clock-eviction2.cc
+++ b/ft/tests/cachetable-clock-eviction2.cc
@@ -99,7 +99,7 @@ cachetable_test (void) {
     const int test_limit = 16;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -142,7 +142,7 @@ cachetable_test (void) {
     CACHETABLE_WRITE_CALLBACK wc = def_write_callback(NULL);
     wc.flush_callback = other_flush;
     wc.pe_callback = other_pe_callback;
-    r = toku_cachetable_put(f1, make_blocknum(5), 5, NULL, make_pair_attr(4), wc, put_callback_nop);
+    toku_cachetable_put(f1, make_blocknum(5), 5, NULL, make_pair_attr(4), wc, put_callback_nop);
     ct->ev.signal_eviction_thread();
     usleep(1*1024*1024);
     flush_may_occur = true;
@@ -152,8 +152,8 @@ cachetable_test (void) {
     assert(expected_bytes_to_free == 0);
 
 
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-clock-eviction3.cc b/ft/tests/cachetable-clock-eviction3.cc
index 6b795ebc0b4..acf8b05f5b1 100644
--- a/ft/tests/cachetable-clock-eviction3.cc
+++ b/ft/tests/cachetable-clock-eviction3.cc
@@ -115,7 +115,7 @@ cachetable_test (void) {
     const int test_limit = 20;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     evictor_test_helpers::set_hysteresis_limits(&ct->ev, test_limit, 100*test_limit);
     evictor_test_helpers::disable_ev_thread(&ct->ev);
     char fname1[] = __SRCFILE__ "test1.dat";
@@ -165,7 +165,7 @@ cachetable_test (void) {
     wc.flush_callback = other_flush;
     wc.pe_est_callback = pe_est_callback;
     wc.pe_callback = other_pe_callback;
-    r = toku_cachetable_put(f1, make_blocknum(5), 5, NULL, make_pair_attr(4), wc, put_callback_nop);
+    toku_cachetable_put(f1, make_blocknum(5), 5, NULL, make_pair_attr(4), wc, put_callback_nop);
     flush_may_occur = true;
     r = toku_test_cachetable_unpin(f1, make_blocknum(5), 5, CACHETABLE_CLEAN, make_pair_attr(8));
     ct->ev.signal_eviction_thread();
@@ -180,8 +180,8 @@ cachetable_test (void) {
     assert(expected_bytes_to_free == 3);
 
 
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-clock-eviction4.cc b/ft/tests/cachetable-clock-eviction4.cc
index 61d52d5f358..4255e7a5d54 100644
--- a/ft/tests/cachetable-clock-eviction4.cc
+++ b/ft/tests/cachetable-clock-eviction4.cc
@@ -95,7 +95,7 @@ cachetable_test (void) {
     num_entries = 0;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -128,14 +128,14 @@ cachetable_test (void) {
     }
     flush_may_occur = true;
     expected_flushed_key = 4;
-    r = toku_cachetable_put(f1, make_blocknum(5), 5, NULL, make_pair_attr(4), wc, put_callback_nop);
+    toku_cachetable_put(f1, make_blocknum(5), 5, NULL, make_pair_attr(4), wc, put_callback_nop);
     flush_may_occur = true;
     expected_flushed_key = 5;
     r = toku_test_cachetable_unpin(f1, make_blocknum(5), 5, CACHETABLE_CLEAN, make_pair_attr(4));
 
     check_flush = false;
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0 );
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0 );
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-clone-checkpoint.cc b/ft/tests/cachetable-clone-checkpoint.cc
index 8551340b01c..9828d9d1be8 100644
--- a/ft/tests/cachetable-clone-checkpoint.cc
+++ b/ft/tests/cachetable-clone-checkpoint.cc
@@ -42,13 +42,12 @@ flush (
 
 static void *run_end_checkpoint(void *arg) {
     CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-    int r = toku_cachetable_end_checkpoint(
+    toku_cachetable_end_checkpoint(
         cp, 
         NULL, 
         NULL,
         NULL
         );
-    assert_zero(r);
     return arg;
 }
 
@@ -60,7 +59,7 @@ cachetable_test (void) {
     const int test_limit = 200;
     int r;
     ct = NULL;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -77,7 +76,7 @@ cachetable_test (void) {
     r = toku_test_cachetable_unpin(f1, make_blocknum(1), 1, CACHETABLE_DIRTY, make_pair_attr(8));
     assert_zero(r);
     CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-    r = toku_cachetable_begin_checkpoint(cp, NULL);
+    toku_cachetable_begin_checkpoint(cp, NULL);
 
 
     clone_flush_started = false;
@@ -100,8 +99,8 @@ cachetable_test (void) {
     assert(clone_flush_started && clone_flush_completed);
 
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-clone-partial-fetch-pinned-node.cc b/ft/tests/cachetable-clone-partial-fetch-pinned-node.cc
index 776648e165f..50819c5f213 100644
--- a/ft/tests/cachetable-clone-partial-fetch-pinned-node.cc
+++ b/ft/tests/cachetable-clone-partial-fetch-pinned-node.cc
@@ -53,7 +53,7 @@ cachetable_test (void) {
     const int test_limit = 12;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -73,7 +73,7 @@ cachetable_test (void) {
 
     flush_completed = false;
     CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-    r = toku_cachetable_begin_checkpoint(cp, NULL); assert_zero(r);
+    toku_cachetable_begin_checkpoint(cp, NULL);
     assert_zero(r);
     r = toku_cachetable_get_and_pin(f1, make_blocknum(1), 1, &v1, &s1, wc, def_fetch, def_pf_req_callback, def_pf_callback, true, NULL);
     assert_zero(r);
@@ -91,7 +91,7 @@ cachetable_test (void) {
     assert_zero(r);
     assert(pf_called);
 
-    r = toku_cachetable_end_checkpoint(
+    toku_cachetable_end_checkpoint(
         cp, 
         NULL, 
         NULL,
@@ -101,8 +101,8 @@ cachetable_test (void) {
 
 
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 
 
 }
diff --git a/ft/tests/cachetable-clone-partial-fetch.cc b/ft/tests/cachetable-clone-partial-fetch.cc
index 1792c95767a..9899f8f55f4 100644
--- a/ft/tests/cachetable-clone-partial-fetch.cc
+++ b/ft/tests/cachetable-clone-partial-fetch.cc
@@ -58,7 +58,7 @@ cachetable_test (void) {
     const int test_limit = 12;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -78,7 +78,7 @@ cachetable_test (void) {
 
     flush_completed = false;
     CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-    r = toku_cachetable_begin_checkpoint(cp, NULL); assert_zero(r);
+    toku_cachetable_begin_checkpoint(cp, NULL);
     assert_zero(r);
     r = toku_cachetable_get_and_pin(f1, make_blocknum(1), 1, &v1, &s1, wc, def_fetch, def_pf_req_callback, def_pf_callback, true, NULL);
     assert_zero(r);
@@ -92,7 +92,7 @@ cachetable_test (void) {
     assert_zero(r);
     assert(pf_called);
 
-    r = toku_cachetable_end_checkpoint(
+    toku_cachetable_end_checkpoint(
         cp, 
         NULL, 
         NULL,
@@ -102,8 +102,8 @@ cachetable_test (void) {
 
 
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 
 
 }
diff --git a/ft/tests/cachetable-clone-pin-nonblocking.cc b/ft/tests/cachetable-clone-pin-nonblocking.cc
index 561c034593e..793516b5e5e 100644
--- a/ft/tests/cachetable-clone-pin-nonblocking.cc
+++ b/ft/tests/cachetable-clone-pin-nonblocking.cc
@@ -40,7 +40,7 @@ cachetable_test (enum cachetable_dirty dirty, bool cloneable) {
     const int test_limit = 12;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -58,7 +58,7 @@ cachetable_test (enum cachetable_dirty dirty, bool cloneable) {
 
     // test that having a pin that passes false for may_modify_value does not stall behind checkpoint
     CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-    r = toku_cachetable_begin_checkpoint(cp, NULL); assert_zero(r);
+    toku_cachetable_begin_checkpoint(cp, NULL);
     r = toku_cachetable_get_and_pin_nonblocking(f1, make_blocknum(1), 1, &v1, &s1, wc, def_fetch, def_pf_req_callback, def_pf_callback, PL_READ, NULL, NULL);
     assert(r == 0);
     r = toku_test_cachetable_unpin(f1, make_blocknum(1), 1, CACHETABLE_CLEAN, make_pair_attr(8));
@@ -73,20 +73,16 @@ cachetable_test (enum cachetable_dirty dirty, bool cloneable) {
         r = toku_test_cachetable_unpin(f1, make_blocknum(1), 1, CACHETABLE_CLEAN, make_pair_attr(8));
     }
 
-    r = toku_cachetable_end_checkpoint(
+    toku_cachetable_end_checkpoint(
         cp, 
         NULL, 
         NULL,
         NULL
         );
-    assert_zero(r);
-
 
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
-
-
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-clone-unpin-remove.cc b/ft/tests/cachetable-clone-unpin-remove.cc
index 68d5f5b82fe..7f0e1487cbc 100644
--- a/ft/tests/cachetable-clone-unpin-remove.cc
+++ b/ft/tests/cachetable-clone-unpin-remove.cc
@@ -51,7 +51,7 @@ cachetable_test (void) {
     const int test_limit = 12;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -72,7 +72,7 @@ cachetable_test (void) {
     flush_completed = false;
     evict_called = false;
     CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-    r = toku_cachetable_begin_checkpoint(cp, NULL); assert_zero(r);
+    toku_cachetable_begin_checkpoint(cp, NULL);
     assert_zero(r);
     r = toku_cachetable_get_and_pin(f1, make_blocknum(1), toku_cachetable_hash(f1, make_blocknum(1)), &v1, &s1, wc, def_fetch, def_pf_req_callback, def_pf_callback, true, NULL);
     assert_zero(r);
@@ -80,7 +80,7 @@ cachetable_test (void) {
     assert_zero(r);
 
 
-    r = toku_cachetable_end_checkpoint(
+    toku_cachetable_end_checkpoint(
         cp, 
         NULL, 
         NULL,
@@ -90,8 +90,8 @@ cachetable_test (void) {
 
 
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 
 
 }
diff --git a/ft/tests/cachetable-count-pinned-test.cc b/ft/tests/cachetable-count-pinned-test.cc
index 47edc92c6f3..291b30d378c 100644
--- a/ft/tests/cachetable-count-pinned-test.cc
+++ b/ft/tests/cachetable-count-pinned-test.cc
@@ -12,7 +12,7 @@ cachetable_count_pinned_test (int n) {
     const int test_limit = 2*n;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -23,8 +23,7 @@ cachetable_count_pinned_test (int n) {
         uint32_t hi;
         hi = toku_cachetable_hash(f1, make_blocknum(i));
         CACHETABLE_WRITE_CALLBACK wc = def_write_callback(NULL);
-        r = toku_cachetable_put(f1, make_blocknum(i), hi, (void *)(long)i, make_pair_attr(1), wc, put_callback_nop);
-        assert(r == 0);
+        toku_cachetable_put(f1, make_blocknum(i), hi, (void *)(long)i, make_pair_attr(1), wc, put_callback_nop);
         assert(toku_cachefile_count_pinned(f1, 0) == i);
 
         void *v;
@@ -48,8 +47,8 @@ cachetable_count_pinned_test (int n) {
     assert(toku_cachefile_count_pinned(f1, 1) == 0);
     toku_cachetable_verify(ct);
 
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-debug-test.cc b/ft/tests/cachetable-debug-test.cc
index a7132a99543..b8548c47a2e 100644
--- a/ft/tests/cachetable-debug-test.cc
+++ b/ft/tests/cachetable-debug-test.cc
@@ -11,7 +11,7 @@ cachetable_debug_test (int n) {
     const int test_limit = n;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -30,8 +30,7 @@ cachetable_debug_test (int n) {
         uint32_t hi;
         hi = toku_cachetable_hash(f1, make_blocknum(i));
         CACHETABLE_WRITE_CALLBACK wc = def_write_callback(NULL);
-        r = toku_cachetable_put(f1, make_blocknum(i), hi, (void *)(long)i, make_pair_attr(item_size), wc, put_callback_nop);
-        assert(r == 0);
+        toku_cachetable_put(f1, make_blocknum(i), hi, (void *)(long)i, make_pair_attr(item_size), wc, put_callback_nop);
 
         void *v; int dirty; long long pinned; long pair_size;
         r = toku_cachetable_get_key_state(ct, make_blocknum(i), f1, &v, &dirty, &pinned, &pair_size);
@@ -53,8 +52,8 @@ cachetable_debug_test (int n) {
     }
     toku_cachetable_verify(ct);
 
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-eviction-close-test.cc b/ft/tests/cachetable-eviction-close-test.cc
index 985bc552ae6..c3e1b349d92 100644
--- a/ft/tests/cachetable-eviction-close-test.cc
+++ b/ft/tests/cachetable-eviction-close-test.cc
@@ -70,7 +70,7 @@ static void cachetable_eviction_full_test (void) {
     const int test_limit = 12;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -132,8 +132,8 @@ static void cachetable_eviction_full_test (void) {
 
     // close with the eviction in progress. the close should block until
     // all of the reads and writes are complete.
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-eviction-close-test2.cc b/ft/tests/cachetable-eviction-close-test2.cc
index 72a841267b9..42bb6bb75cd 100644
--- a/ft/tests/cachetable-eviction-close-test2.cc
+++ b/ft/tests/cachetable-eviction-close-test2.cc
@@ -82,7 +82,7 @@ static void cachetable_eviction_full_test (void) {
     const int test_limit = 12;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -146,8 +146,8 @@ static void cachetable_eviction_full_test (void) {
 
     // close with the eviction in progress. the close should block until
     // all of the reads and writes are complete.
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-eviction-getandpin-test.cc b/ft/tests/cachetable-eviction-getandpin-test.cc
index 9a26b17bb80..f2d77cd7d3f 100644
--- a/ft/tests/cachetable-eviction-getandpin-test.cc
+++ b/ft/tests/cachetable-eviction-getandpin-test.cc
@@ -38,7 +38,7 @@ static void cachetable_predef_fetch_maybegetandpin_test (void) {
     const int test_limit = 12;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     evictor_test_helpers::disable_ev_thread(&ct->ev);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
@@ -119,8 +119,8 @@ static void cachetable_predef_fetch_maybegetandpin_test (void) {
     assert(r == 0);
     toku_cachetable_verify(ct);
 
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-eviction-getandpin-test2.cc b/ft/tests/cachetable-eviction-getandpin-test2.cc
index a411c522c03..4e5f5247c7d 100644
--- a/ft/tests/cachetable-eviction-getandpin-test2.cc
+++ b/ft/tests/cachetable-eviction-getandpin-test2.cc
@@ -44,7 +44,7 @@ static void cachetable_prefetch_maybegetandpin_test (void) {
     const int test_limit = 12;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     evictor_test_helpers::disable_ev_thread(&ct->ev);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
@@ -148,8 +148,8 @@ static void cachetable_prefetch_maybegetandpin_test (void) {
     assert(r == 0);
     toku_cachetable_verify(ct);
 
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-fd-test.cc b/ft/tests/cachetable-fd-test.cc
index e4a6bbcac37..ae972938271 100644
--- a/ft/tests/cachetable-fd-test.cc
+++ b/ft/tests/cachetable-fd-test.cc
@@ -12,7 +12,7 @@ cachetable_fd_test (void) {
     const int test_limit = 1;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE cf;
@@ -44,8 +44,8 @@ cachetable_fd_test (void) {
     r = toku_cachefile_of_filenum(ct, fn, &newcf);
     assert(r == ENOENT);
 
-    r = toku_cachefile_close(&cf, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&cf, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-fetch-inducing-evictor.cc b/ft/tests/cachetable-fetch-inducing-evictor.cc
index 174b2d51be0..95fe02f7b10 100644
--- a/ft/tests/cachetable-fetch-inducing-evictor.cc
+++ b/ft/tests/cachetable-fetch-inducing-evictor.cc
@@ -28,7 +28,7 @@ cachetable_test (enum pin_evictor_test_type test_type, bool nonblocking) {
     const int test_limit = 7;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     evictor_test_helpers::set_hysteresis_limits(&ct->ev, test_limit, test_limit);
     evictor_test_helpers::disable_ev_thread(&ct->ev);
     char fname1[] = __SRCFILE__ "test1.dat";
@@ -100,8 +100,8 @@ cachetable_test (enum pin_evictor_test_type test_type, bool nonblocking) {
     }
   
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-flush-during-cleaner.cc b/ft/tests/cachetable-flush-during-cleaner.cc
index 7bcbac2596f..134bf3d0e6f 100644
--- a/ft/tests/cachetable-flush-during-cleaner.cc
+++ b/ft/tests/cachetable-flush-during-cleaner.cc
@@ -25,8 +25,8 @@ cachetable_test (void) {
   const int test_limit = 400;
   int r;
   CACHETABLE ct;
-  r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
-  r = toku_set_cleaner_period(ct, 1); assert(r == 0);
+  toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
+  toku_set_cleaner_period(ct, 1);
 
   char fname1[] = __SRCFILE__ "test1.dat";
   unlink(fname1);
@@ -43,12 +43,11 @@ cachetable_test (void) {
           r = toku_cachetable_get_and_pin(f1, make_blocknum(i), i, &v1, &s1, wc, def_fetch, def_pf_req_callback, def_pf_callback, true, NULL);
           r = toku_test_cachetable_unpin(f1, make_blocknum(i), i, CACHETABLE_DIRTY, make_pair_attr(8));
       }
-      r = toku_cachefile_flush(f1);
-      assert(r == 0);
+      toku_cachefile_flush(f1);
   }
   toku_cachetable_verify(ct);
-  r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-  r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+  r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+  toku_cachetable_close(&ct);
 
 
 }
diff --git a/ft/tests/cachetable-flush-test.cc b/ft/tests/cachetable-flush-test.cc
index 20d396cf1b6..f39cd357212 100644
--- a/ft/tests/cachetable-flush-test.cc
+++ b/ft/tests/cachetable-flush-test.cc
@@ -12,7 +12,7 @@ test_cachetable_def_flush (int n) {
     const int test_limit = 2*n;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -28,13 +28,11 @@ test_cachetable_def_flush (int n) {
     for (i=0; i<n; i++) {
         uint32_t hi;
         hi = toku_cachetable_hash(f1, make_blocknum(i));
-        r = toku_cachetable_put(f1, make_blocknum(i), hi, (void *)(long)i, make_pair_attr(1), wc, put_callback_nop);
-        assert(r == 0);
+        toku_cachetable_put(f1, make_blocknum(i), hi, (void *)(long)i, make_pair_attr(1), wc, put_callback_nop);
         r = toku_test_cachetable_unpin(f1, make_blocknum(i), hi, CACHETABLE_CLEAN, make_pair_attr(1));
         assert(r == 0);
         hi = toku_cachetable_hash(f2, make_blocknum(i));
-        r = toku_cachetable_put(f2, make_blocknum(i), hi, (void *)(long)i, make_pair_attr(1), wc, put_callback_nop);
-        assert(r == 0);
+        toku_cachetable_put(f2, make_blocknum(i), hi, (void *)(long)i, make_pair_attr(1), wc, put_callback_nop);
         r = toku_test_cachetable_unpin(f2, make_blocknum(i), hi, CACHETABLE_CLEAN, make_pair_attr(1));
         assert(r == 0);
     }
@@ -57,7 +55,7 @@ test_cachetable_def_flush (int n) {
     }
 
     // def_flush 
-    r = toku_cachefile_flush(f1); assert(r == 0);
+    toku_cachefile_flush(f1);
     toku_cachefile_verify(f1);
 
     // verify keys do not exist in f1 but do exist in f2
@@ -74,9 +72,9 @@ test_cachetable_def_flush (int n) {
         assert(r == 0);
     }
 
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachefile_close(&f2, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    r = toku_cachefile_close(&f2, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-getandpin-test.cc b/ft/tests/cachetable-getandpin-test.cc
index 7f6edc4f068..305712267eb 100644
--- a/ft/tests/cachetable-getandpin-test.cc
+++ b/ft/tests/cachetable-getandpin-test.cc
@@ -49,7 +49,7 @@ cachetable_getandpin_test (int n) {
     const int test_limit = 1024*1024;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test_getandpin.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -73,8 +73,8 @@ cachetable_getandpin_test (int n) {
     }
     toku_cachetable_verify(ct);
 
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-kibbutz_and_flush_cachefile.cc b/ft/tests/cachetable-kibbutz_and_flush_cachefile.cc
index e280034ae12..91b50603df6 100644
--- a/ft/tests/cachetable-kibbutz_and_flush_cachefile.cc
+++ b/ft/tests/cachetable-kibbutz_and_flush_cachefile.cc
@@ -29,7 +29,7 @@ run_test (void) {
     const int test_limit = 12;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -43,16 +43,16 @@ run_test (void) {
     r = toku_cachetable_get_and_pin(f1, make_blocknum(1), 1, &v1, &s1, wc, def_fetch, def_pf_req_callback, def_pf_callback, true, NULL);
     foo = false;
     cachefile_kibbutz_enq(f1, kibbutz_work, f1);
-    r = toku_cachefile_flush(f1); assert(r == 0);
+    toku_cachefile_flush(f1);
     assert(foo);
     assert(f1);
     
     r = toku_cachetable_get_and_pin(f1, make_blocknum(1), 1, &v1, &s1, wc, def_fetch, def_pf_req_callback, def_pf_callback, true, NULL);
     foo = false;
     cachefile_kibbutz_enq(f1, kibbutz_work, f1);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
     assert(foo);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    toku_cachetable_close(&ct);
     
     
 }
diff --git a/ft/tests/cachetable-partial-fetch.cc b/ft/tests/cachetable-partial-fetch.cc
index fa237c9e40a..c2ccb08a64d 100644
--- a/ft/tests/cachetable-partial-fetch.cc
+++ b/ft/tests/cachetable-partial-fetch.cc
@@ -81,7 +81,7 @@ cachetable_test (void) {
     int r;
     CACHETABLE ct;
     bool doing_prefetch = false;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -128,7 +128,7 @@ cachetable_test (void) {
     r = toku_test_cachetable_unpin(f1, make_blocknum(1), 1, CACHETABLE_CLEAN, make_pair_attr(8));
 
     // close and reopen cachefile so we can do some simple prefetch tests
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
     r = toku_cachetable_openf(&f1, ct, fname1, O_RDWR|O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO); assert(r == 0);
     //
     // verify that a prefetch of the node will succeed
@@ -176,8 +176,8 @@ cachetable_test (void) {
     
     
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
     
     
 }
diff --git a/ft/tests/cachetable-pin-checkpoint.cc b/ft/tests/cachetable-pin-checkpoint.cc
index e12c96929f3..717b83edd50 100644
--- a/ft/tests/cachetable-pin-checkpoint.cc
+++ b/ft/tests/cachetable-pin-checkpoint.cc
@@ -269,16 +269,14 @@ static void *checkpoints(void *arg) {
         //
         // now run a checkpoint
         //
-        int r;
         CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-        r = toku_cachetable_begin_checkpoint(cp, NULL); assert(r == 0);    
-        r = toku_cachetable_end_checkpoint(
+        toku_cachetable_begin_checkpoint(cp, NULL);    
+        toku_cachetable_end_checkpoint(
             cp, 
             NULL, 
             NULL,
             NULL
             );
-        assert(r==0);
         assert (sum==0);
         for (int i = 0; i < NUM_ELEMENTS; i++) {
             sum += checkpointed_data[i];
@@ -290,18 +288,12 @@ static void *checkpoints(void *arg) {
     return arg;
 }
 
-static int
+static void
 test_begin_checkpoint (
     LSN UU(checkpoint_lsn), 
     void* UU(header_v)) 
 {
     memcpy(checkpointed_data, data, sizeof(int64_t)*NUM_ELEMENTS);
-    return 0;
-}
-
-static int
-dummy_int_checkpoint_userdata(CACHEFILE UU(cf), int UU(n), void* UU(extra)) {
-    return 0;
 }
 
 static void sum_vals(void) {
@@ -336,7 +328,7 @@ cachetable_test (void) {
 
     int r;
     
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     r = toku_cachetable_openf(&f1, ct, fname1, O_RDWR|O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO); assert(r == 0);
@@ -344,13 +336,13 @@ cachetable_test (void) {
     toku_cachefile_set_userdata(
         f1, 
         NULL, 
-        &dummy_log_fassociate, 
-        &dummy_log_rollback, 
-        &dummy_close_usr, 
-        dummy_int_checkpoint_userdata, 
-        test_begin_checkpoint, // called in begin_checkpoint
-        dummy_int_checkpoint_userdata,
-        &dummy_note_pin, 
+        &dummy_log_fassociate,
+        &dummy_log_rollback,
+        &dummy_close_usr,
+        &dummy_chckpnt_usr,
+        &test_begin_checkpoint,
+        &dummy_end,
+        &dummy_note_pin,
         &dummy_note_unpin
         );
     
@@ -389,8 +381,8 @@ cachetable_test (void) {
     }
 
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
     
     sum_vals();
     if (verbose) printf("num_checkpoints %d\n", num_checkpoints);
diff --git a/ft/tests/cachetable-pin-nonblocking-checkpoint-clean.cc b/ft/tests/cachetable-pin-nonblocking-checkpoint-clean.cc
index 76a15247ac9..205ea5e54db 100644
--- a/ft/tests/cachetable-pin-nonblocking-checkpoint-clean.cc
+++ b/ft/tests/cachetable-pin-nonblocking-checkpoint-clean.cc
@@ -15,7 +15,7 @@ run_test (void) {
     const int test_limit = 20;
     int r;
     ct = NULL;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     f1 = NULL;
@@ -37,7 +37,7 @@ run_test (void) {
 
     r = toku_cachetable_get_and_pin(f1, make_blocknum(1), 1, &v2, &s2, def_write_callback(NULL), def_fetch, def_pf_req_callback, def_pf_callback, true, NULL);
     CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-    r = toku_cachetable_begin_checkpoint(cp, NULL);
+    toku_cachetable_begin_checkpoint(cp, NULL);
     // mark nodes as pending a checkpoint, so that get_and_pin_nonblocking on block 1 will return TOKUDB_TRY_AGAIN
     r = toku_test_cachetable_unpin(f1, make_blocknum(1), 1, CACHETABLE_CLEAN, make_pair_attr(8)); assert(r==0);
 
@@ -58,7 +58,7 @@ run_test (void) {
     assert(r==0);
     r = toku_test_cachetable_unpin(f1, make_blocknum(1), 1, CACHETABLE_CLEAN, make_pair_attr(8)); assert(r==0);
     
-    r = toku_cachetable_end_checkpoint(
+    toku_cachetable_end_checkpoint(
         cp, 
         NULL, 
         NULL,
@@ -67,8 +67,8 @@ run_test (void) {
     assert(r==0);
     
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
     
     
 }
diff --git a/ft/tests/cachetable-prefetch-checkpoint-test.cc b/ft/tests/cachetable-prefetch-checkpoint-test.cc
index ceea32d3d52..6d5268d1654 100644
--- a/ft/tests/cachetable-prefetch-checkpoint-test.cc
+++ b/ft/tests/cachetable-prefetch-checkpoint-test.cc
@@ -68,7 +68,7 @@ static void cachetable_prefetch_checkpoint_test(int n, enum cachetable_dirty dir
     CACHETABLE ct;
     CACHETABLE_WRITE_CALLBACK wc = def_write_callback(NULL);
     wc.flush_callback = flush;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -88,8 +88,7 @@ static void cachetable_prefetch_checkpoint_test(int n, enum cachetable_dirty dir
     for (i=0; i<n; i++) {
         CACHEKEY key = make_blocknum(i);
         uint32_t hi = toku_cachetable_hash(f1, key);
-        r = toku_cachetable_put(f1, key, hi, (void *)(long)i, make_pair_attr(1), wc, put_callback_nop);
-        assert(r == 0);
+        toku_cachetable_put(f1, key, hi, (void *)(long)i, make_pair_attr(1), wc, put_callback_nop);
 
         r = toku_test_cachetable_unpin(f1, key, hi, dirty, make_pair_attr(item_size));
         assert(r == 0);
@@ -143,8 +142,8 @@ static void cachetable_prefetch_checkpoint_test(int n, enum cachetable_dirty dir
     assert(r == 0);
     assert(n_flush == 0 && n_write_me == 0 && n_keep_me == 0);
 
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-prefetch-close-leak-test.cc b/ft/tests/cachetable-prefetch-close-leak-test.cc
index 35fabf9d66b..991d098803f 100644
--- a/ft/tests/cachetable-prefetch-close-leak-test.cc
+++ b/ft/tests/cachetable-prefetch-close-leak-test.cc
@@ -54,7 +54,7 @@ static void cachetable_prefetch_close_leak_test (void) {
     const int test_limit = 1;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -70,8 +70,8 @@ static void cachetable_prefetch_close_leak_test (void) {
 
     // close with the prefetch in progress. the close should block until
     // all of the reads and writes are complete.
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-prefetch-close-test.cc b/ft/tests/cachetable-prefetch-close-test.cc
index 16d1c5e8308..5dd8f33890d 100644
--- a/ft/tests/cachetable-prefetch-close-test.cc
+++ b/ft/tests/cachetable-prefetch-close-test.cc
@@ -56,7 +56,7 @@ static void cachetable_prefetch_full_test (bool partial_fetch) {
     expect_pf = false;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -97,8 +97,8 @@ static void cachetable_prefetch_full_test (bool partial_fetch) {
 
     // close with the prefetch in progress. the close should block until
     // all of the reads and writes are complete.
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-prefetch-flowcontrol-test.cc b/ft/tests/cachetable-prefetch-flowcontrol-test.cc
index 346fd1325ed..4d83eb1551e 100644
--- a/ft/tests/cachetable-prefetch-flowcontrol-test.cc
+++ b/ft/tests/cachetable-prefetch-flowcontrol-test.cc
@@ -67,7 +67,7 @@ fetch (CACHEFILE f        __attribute__((__unused__)),
 static void cachetable_prefetch_flowcontrol_test (int cachetable_size_limit) {
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, cachetable_size_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, cachetable_size_limit, ZERO_LSN, NULL_LOGGER);
     evictor_test_helpers::set_hysteresis_limits(&ct->ev, cachetable_size_limit, cachetable_size_limit);
     evictor_test_helpers::disable_ev_thread(&ct->ev);
     char fname1[] = __SRCFILE__ "test1.dat";
@@ -103,11 +103,10 @@ static void cachetable_prefetch_flowcontrol_test (int cachetable_size_limit) {
     }
 
 
-    char *error_string;
-    r = toku_cachefile_close(&f1, &error_string, false, ZERO_LSN); assert(r == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
     if (verbose) printf("%s:%d 0x%x 0x%x\n", __FUNCTION__, __LINE__,
         evicted_keys, (1 << (2*cachetable_size_limit))-1);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-prefetch-getandpin-test.cc b/ft/tests/cachetable-prefetch-getandpin-test.cc
index 58d45094511..f48a85375c2 100644
--- a/ft/tests/cachetable-prefetch-getandpin-test.cc
+++ b/ft/tests/cachetable-prefetch-getandpin-test.cc
@@ -77,7 +77,7 @@ static void cachetable_prefetch_maybegetandpin_test (bool do_partial_fetch) {
     const int test_limit = 2;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -137,8 +137,8 @@ static void cachetable_prefetch_maybegetandpin_test (bool do_partial_fetch) {
     assert(r == 0);
     toku_cachetable_verify(ct);
 
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-prefetch-maybegetandpin-test.cc b/ft/tests/cachetable-prefetch-maybegetandpin-test.cc
index 539da656c7d..a311aabca77 100644
--- a/ft/tests/cachetable-prefetch-maybegetandpin-test.cc
+++ b/ft/tests/cachetable-prefetch-maybegetandpin-test.cc
@@ -34,7 +34,7 @@ static void cachetable_prefetch_maybegetandpin_test (void) {
     const int test_limit = 1;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -63,8 +63,8 @@ static void cachetable_prefetch_maybegetandpin_test (void) {
     assert(r == 0);
     toku_cachetable_verify(ct);
 
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-prefetch2-test.cc b/ft/tests/cachetable-prefetch2-test.cc
index c7a894abe31..7d4e21f3ec0 100644
--- a/ft/tests/cachetable-prefetch2-test.cc
+++ b/ft/tests/cachetable-prefetch2-test.cc
@@ -37,7 +37,7 @@ static void cachetable_prefetch_maybegetandpin_test (void) {
     const int test_limit = 1;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -73,8 +73,8 @@ static void cachetable_prefetch_maybegetandpin_test (void) {
     assert(r == 0);
     toku_cachetable_verify(ct);
 
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-put-checkpoint.cc b/ft/tests/cachetable-put-checkpoint.cc
index 9a59e631402..6071a8bf31a 100644
--- a/ft/tests/cachetable-put-checkpoint.cc
+++ b/ft/tests/cachetable-put-checkpoint.cc
@@ -315,7 +315,7 @@ static void merge_and_split_child(
     CACHEKEY new_key;
     uint32_t new_fullhash;
     int64_t* XMALLOC(data_val);
-    r = toku_cachetable_put_with_dep_pairs(
+    toku_cachetable_put_with_dep_pairs(
           f1,
           get_data,
           data_val,
@@ -398,16 +398,14 @@ static void *checkpoints(void *arg) {
         //
         // now run a checkpoint
         //
-        int r;
         CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-        r = toku_cachetable_begin_checkpoint(cp, NULL); assert(r == 0);    
-        r = toku_cachetable_end_checkpoint(
+        toku_cachetable_begin_checkpoint(cp, NULL);    
+        toku_cachetable_end_checkpoint(
             cp, 
             NULL, 
             NULL,
             NULL
             );
-        assert(r==0);
         assert (sum==0);
         for (int i = 0; i < NUM_ELEMENTS; i++) {
             if (checkpointed_data[i] != INT64_MAX) {
@@ -420,13 +418,12 @@ static void *checkpoints(void *arg) {
     return arg;
 }
 
-static int
+static void
 test_begin_checkpoint (
     LSN UU(checkpoint_lsn), 
     void* UU(header_v)) 
 {
     memcpy(checkpointed_data, data, sizeof(int64_t)*NUM_ELEMENTS);
-    return 0;
 }
 
 static int
@@ -470,7 +467,7 @@ cachetable_test (void) {
 
     int r;
     
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test-put-checkpoint.dat";
     unlink(fname1);
     r = toku_cachetable_openf(&f1, ct, fname1, O_RDWR|O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO); assert(r == 0);
@@ -481,9 +478,9 @@ cachetable_test (void) {
         &dummy_log_fassociate,
         &dummy_log_rollback,
         &dummy_close_usr,
-        dummy_int_checkpoint_userdata, 
-        test_begin_checkpoint, // called in begin_checkpoint
         dummy_int_checkpoint_userdata,
+        test_begin_checkpoint, // called in begin_checkpoint
+        &dummy_end, 
         &dummy_note_pin,
         &dummy_note_unpin
         );
@@ -523,8 +520,8 @@ cachetable_test (void) {
     }
 
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
     
     sum_vals();
     if (verbose) printf("num_checkpoints %d\n", num_checkpoints);
diff --git a/ft/tests/cachetable-put-test.cc b/ft/tests/cachetable-put-test.cc
index ae5dd8e7be7..0acd16f2042 100644
--- a/ft/tests/cachetable-put-test.cc
+++ b/ft/tests/cachetable-put-test.cc
@@ -11,7 +11,7 @@ cachetable_put_test (int n) {
     const int test_limit = 2*n;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -22,8 +22,7 @@ cachetable_put_test (int n) {
         uint32_t hi;
         hi = toku_cachetable_hash(f1, make_blocknum(i));
         CACHETABLE_WRITE_CALLBACK wc = def_write_callback(NULL);
-        r = toku_cachetable_put(f1, make_blocknum(i), hi, (void *)(long)i, make_pair_attr(1), wc, put_callback_nop);
-        assert(r == 0);
+        toku_cachetable_put(f1, make_blocknum(i), hi, (void *)(long)i, make_pair_attr(1), wc, put_callback_nop);
         assert(toku_cachefile_count_pinned(f1, 0) == i);
 
         void *v;
@@ -45,8 +44,8 @@ cachetable_put_test (int n) {
     assert(toku_cachefile_count_pinned(f1, 1) == 0);
     toku_cachetable_verify(ct);
 
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-scan.cc b/ft/tests/cachetable-scan.cc
index bcda0cc0660..64b9e868932 100644
--- a/ft/tests/cachetable-scan.cc
+++ b/ft/tests/cachetable-scan.cc
@@ -59,7 +59,7 @@ CACHEFILE f;
 
 static void open_file (void ) {
     int r;
-    r = toku_create_cachetable(&t, KEYLIMIT, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&t, KEYLIMIT, ZERO_LSN, NULL_LOGGER);
     r = toku_cachetable_openf(&f, t, fname, O_RDWR|O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO);   assert(r==0);
 }
 
@@ -75,7 +75,7 @@ static void writeit (void) {
 	for (j=0; j<BLOCKSIZE; j++) ((char*)buf)[j]=(char)((i+j)%256);
         CACHETABLE_WRITE_CALLBACK wc = def_write_callback(NULL);
         wc.flush_callback = f_flush;
-	r = toku_cachetable_put(f, key, fullhash, buf, make_pair_attr(BLOCKSIZE), wc, put_callback_nop);	assert(r==0);
+	toku_cachetable_put(f, key, fullhash, buf, make_pair_attr(BLOCKSIZE), wc, put_callback_nop);
 	r = toku_test_cachetable_unpin(f, key, fullhash, CACHETABLE_CLEAN, make_pair_attr(BLOCKSIZE)); assert(r==0);
     }
     gettimeofday(&end, 0);
@@ -101,8 +101,8 @@ static void readit (void) {
 	r=toku_cachetable_get_and_pin(f, key, fullhash, &block, &current_size, wc, f_fetch, def_pf_req_callback, def_pf_callback, true, 0); assert(r==0);
 	r=toku_test_cachetable_unpin(f, key, fullhash, CACHETABLE_CLEAN, make_pair_attr(BLOCKSIZE));                                      assert(r==0);
     }
-    r = toku_cachefile_close(&f, 0, false, ZERO_LSN);    assert(r == 0);
-    r = toku_cachetable_close(&t);      assert(r == 0);
+    r = toku_cachefile_close(&f, false, ZERO_LSN);    assert(r == 0);
+    toku_cachetable_close(&t);
     gettimeofday(&end, 0);
     toku_os_get_process_times(&end_usertime, &end_systime);
     double diff = toku_tdiff(&end, &start);
diff --git a/ft/tests/cachetable-simple-clone.cc b/ft/tests/cachetable-simple-clone.cc
index c3aac059117..969ddbf236b 100644
--- a/ft/tests/cachetable-simple-clone.cc
+++ b/ft/tests/cachetable-simple-clone.cc
@@ -64,7 +64,7 @@ test_clean (enum cachetable_dirty dirty, bool cloneable) {
     const int test_limit = 12;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -86,7 +86,7 @@ test_clean (enum cachetable_dirty dirty, bool cloneable) {
     // begin checkpoint, since pair is clean, we should not 
     // have the clone called
     CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-    r = toku_cachetable_begin_checkpoint(cp, NULL);
+    toku_cachetable_begin_checkpoint(cp, NULL);
     assert_zero(r);
     struct timeval tstart;
     struct timeval tend; 
@@ -130,19 +130,18 @@ test_clean (enum cachetable_dirty dirty, bool cloneable) {
         assert(tdelta_usec(&tend, &tstart) >= 2000000); 
     }
 
-    r = toku_cachetable_end_checkpoint(
+    toku_cachetable_end_checkpoint(
         cp, 
         NULL, 
         NULL,
         NULL
         );
-    assert_zero(r);
     
     check_flush = false;
     
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-simple-clone2.cc b/ft/tests/cachetable-simple-clone2.cc
index 433a53e28de..7c5da0d3d59 100644
--- a/ft/tests/cachetable-simple-clone2.cc
+++ b/ft/tests/cachetable-simple-clone2.cc
@@ -51,7 +51,7 @@ test_clean (enum cachetable_dirty dirty, bool cloneable) {
     const int test_limit = 200;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -70,28 +70,27 @@ test_clean (enum cachetable_dirty dirty, bool cloneable) {
     // begin checkpoint, since pair is clean, we should not 
     // have the clone called
     CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-    r = toku_cachetable_begin_checkpoint(cp, NULL);
+    toku_cachetable_begin_checkpoint(cp, NULL);
     assert_zero(r);
     r = toku_cachetable_get_and_pin(f1, make_blocknum(1), 1, &v1, &s1, wc, def_fetch, def_pf_req_callback, def_pf_callback, true, NULL);
     
     // at this point, there should be no more dirty writes
     r = toku_test_cachetable_unpin(f1, make_blocknum(1), 1, dirty, make_pair_attr(8));
     usleep(2*1024*1024);
-    r = toku_cachetable_end_checkpoint(
+    toku_cachetable_end_checkpoint(
         cp, 
         NULL, 
         NULL,
         NULL
     );
-    assert_zero(r);
     
     check_flush = true;
     flush_expected = (dirty == CACHETABLE_DIRTY) ? true : false;
     flush_called = false;
     
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0 );
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0 );
+    toku_cachetable_close(&ct);
     if (flush_expected) assert(flush_called);
 }
 
diff --git a/ft/tests/cachetable-simple-maybe-get-pin.cc b/ft/tests/cachetable-simple-maybe-get-pin.cc
index cd7a56ba9d9..d2b67b36868 100644
--- a/ft/tests/cachetable-simple-maybe-get-pin.cc
+++ b/ft/tests/cachetable-simple-maybe-get-pin.cc
@@ -15,7 +15,7 @@ cachetable_test (void) {
     const int test_limit = 12;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -52,26 +52,22 @@ cachetable_test (void) {
     assert(r==0);
     r = toku_test_cachetable_unpin(f1, make_blocknum(1), 1, CACHETABLE_DIRTY, make_pair_attr(8));
     CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-    r = toku_cachetable_begin_checkpoint(cp, NULL); assert(r == 0);
+    toku_cachetable_begin_checkpoint(cp, NULL);
     // now these should fail, because the node should be pending a checkpoint
     r = toku_cachetable_maybe_get_and_pin(f1, make_blocknum(1), 1, &v1);
     assert(r==-1);
     r = toku_cachetable_maybe_get_and_pin(f1, make_blocknum(1), 1, &v1);
     assert(r==-1);
-    r = toku_cachetable_end_checkpoint(
+    toku_cachetable_end_checkpoint(
         cp, 
         NULL, 
         NULL,
         NULL
         );
-    assert(r==0);
-    
-
 
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
-        
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-simple-pin-cheap.cc b/ft/tests/cachetable-simple-pin-cheap.cc
index 1ec2c6fcebf..e23e7f3f232 100644
--- a/ft/tests/cachetable-simple-pin-cheap.cc
+++ b/ft/tests/cachetable-simple-pin-cheap.cc
@@ -40,7 +40,7 @@ run_test (pair_lock_type lock_type) {
     struct unlockers unlockers = {true, unlock_dummy, NULL, NULL};
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -81,9 +81,9 @@ run_test (pair_lock_type lock_type) {
     }
     
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); 
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); 
     assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);    
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-simple-pin-dep-nodes.cc b/ft/tests/cachetable-simple-pin-dep-nodes.cc
index 7fbb5180127..b2fa44c6e1e 100644
--- a/ft/tests/cachetable-simple-pin-dep-nodes.cc
+++ b/ft/tests/cachetable-simple-pin-dep-nodes.cc
@@ -69,7 +69,7 @@ cachetable_test (bool write_first, bool write_second, bool start_checkpoint) {
     const int test_limit = 12;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -107,7 +107,7 @@ cachetable_test (bool write_first, bool write_second, bool start_checkpoint) {
         //
         // should mark the v1 and v2 as pending
         //
-        r = toku_cachetable_begin_checkpoint(cp, NULL); assert(r==0);
+        toku_cachetable_begin_checkpoint(cp, NULL);
     }
     //
     // This call should cause a flush for both
@@ -145,20 +145,17 @@ cachetable_test (bool write_first, bool write_second, bool start_checkpoint) {
     r = toku_test_cachetable_unpin(f1, make_blocknum(3), 3, CACHETABLE_CLEAN, make_pair_attr(8));
 
     if (start_checkpoint) {
-        r = toku_cachetable_end_checkpoint(
+        toku_cachetable_end_checkpoint(
             cp, 
             NULL, 
             NULL,
             NULL
             );
-        assert(r==0);
     }
 
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
-
-
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-simple-pin-nonblocking-cheap.cc b/ft/tests/cachetable-simple-pin-nonblocking-cheap.cc
index c6e2adf0055..84b8dcac5c3 100644
--- a/ft/tests/cachetable-simple-pin-nonblocking-cheap.cc
+++ b/ft/tests/cachetable-simple-pin-nonblocking-cheap.cc
@@ -79,7 +79,7 @@ run_test (void) {
     const int test_limit = 12;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -109,9 +109,9 @@ run_test (void) {
     run_case_that_should_fail(f1, PL_WRITE_EXPENSIVE, PL_WRITE_EXPENSIVE);
     
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); 
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); 
     assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);    
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-simple-pin-nonblocking.cc b/ft/tests/cachetable-simple-pin-nonblocking.cc
index 373fa6e2028..4ae5f0530fe 100644
--- a/ft/tests/cachetable-simple-pin-nonblocking.cc
+++ b/ft/tests/cachetable-simple-pin-nonblocking.cc
@@ -62,7 +62,7 @@ run_test (void) {
     const int test_limit = 12;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -109,25 +109,20 @@ run_test (void) {
     r = toku_test_cachetable_unpin(f1, make_blocknum(1), 1, CACHETABLE_DIRTY, make_pair_attr(8)); assert(r==0);
     // this should mark the PAIR as pending
     CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-    r = toku_cachetable_begin_checkpoint(cp, NULL); assert(r == 0);
+    toku_cachetable_begin_checkpoint(cp, NULL);
     r = toku_cachetable_get_and_pin_nonblocking(f1, make_blocknum(1), 1, &v1, &s1, wc, def_fetch, def_pf_req_callback, def_pf_callback, PL_WRITE_EXPENSIVE, NULL, NULL);
     assert(r==TOKUDB_TRY_AGAIN);
-    r = toku_cachetable_end_checkpoint(
+    toku_cachetable_end_checkpoint(
         cp, 
         NULL, 
         NULL,
         NULL
         );
-    assert(r==0);
-    
-    
     
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); 
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); 
     assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
-    
-    
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-simple-pin.cc b/ft/tests/cachetable-simple-pin.cc
index e1283749756..cc886c3457e 100644
--- a/ft/tests/cachetable-simple-pin.cc
+++ b/ft/tests/cachetable-simple-pin.cc
@@ -54,7 +54,7 @@ run_test (void) {
     const int test_limit = 12;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -81,7 +81,7 @@ run_test (void) {
 
     // now this should mark the pair for checkpoint
     CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-    r = toku_cachetable_begin_checkpoint(cp, NULL);
+    toku_cachetable_begin_checkpoint(cp, NULL);
 
     //
     // now we pin the pair again, and verify in flush callback that the pair is being checkpointed
@@ -94,20 +94,16 @@ run_test (void) {
 
     
     check_me = false;
-    r = toku_cachetable_end_checkpoint(
+    toku_cachetable_end_checkpoint(
         cp, 
         NULL, 
         NULL,
         NULL
         );
-    assert(r==0);
-    
     
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
-    
-    
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-simple-put-dep-nodes.cc b/ft/tests/cachetable-simple-put-dep-nodes.cc
index 4e33fc5f108..759bd746246 100644
--- a/ft/tests/cachetable-simple-put-dep-nodes.cc
+++ b/ft/tests/cachetable-simple-put-dep-nodes.cc
@@ -76,7 +76,7 @@ cachetable_test (bool write_first, bool write_second, bool start_checkpoint) {
     const int test_limit = 12;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -112,7 +112,7 @@ cachetable_test (bool write_first, bool write_second, bool start_checkpoint) {
         //
         // should mark the v1 and v2 as pending
         //
-        r = toku_cachetable_begin_checkpoint(cp, NULL); assert(r==0);
+        toku_cachetable_begin_checkpoint(cp, NULL);
     }
     //
     // This call should cause a flush for both
@@ -123,7 +123,7 @@ cachetable_test (bool write_first, bool write_second, bool start_checkpoint) {
 
     CACHEKEY put_key;
     uint32_t put_fullhash;
-    r = toku_cachetable_put_with_dep_pairs(
+    toku_cachetable_put_with_dep_pairs(
         f1,
         get_key_and_fullhash,
         &val3,
@@ -139,7 +139,6 @@ cachetable_test (bool write_first, bool write_second, bool start_checkpoint) {
         &put_fullhash,
         put_callback_nop
         );
-    assert(r == 0);
     assert(put_key.b == 3);
     assert(put_fullhash == 3);
 
@@ -154,18 +153,17 @@ cachetable_test (bool write_first, bool write_second, bool start_checkpoint) {
     r = toku_test_cachetable_unpin(f1, make_blocknum(3), 3, CACHETABLE_CLEAN, make_pair_attr(8));
 
     if (start_checkpoint) {
-        r = toku_cachetable_end_checkpoint(
+        toku_cachetable_end_checkpoint(
             cp, 
             NULL, 
             NULL,
             NULL
             );
-        assert(r==0);
     }
 
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 
 
 }
diff --git a/ft/tests/cachetable-simple-read-pin-nonblocking.cc b/ft/tests/cachetable-simple-read-pin-nonblocking.cc
index 10c61f6ea0e..a23fb237a09 100644
--- a/ft/tests/cachetable-simple-read-pin-nonblocking.cc
+++ b/ft/tests/cachetable-simple-read-pin-nonblocking.cc
@@ -67,7 +67,7 @@ run_test (void) {
     int r;
     void *ret;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     r = toku_cachetable_openf(&f1, ct, fname1, O_RDWR|O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO); assert(r == 0);
@@ -112,8 +112,8 @@ run_test (void) {
     assert_zero(r);
 
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-simple-read-pin.cc b/ft/tests/cachetable-simple-read-pin.cc
index b110e77c653..9b4c603025b 100644
--- a/ft/tests/cachetable-simple-read-pin.cc
+++ b/ft/tests/cachetable-simple-read-pin.cc
@@ -73,7 +73,7 @@ run_test (void) {
     int r;
     void *ret;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     r = toku_cachetable_openf(&f1, ct, fname1, O_RDWR|O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO); assert(r == 0);
@@ -122,8 +122,8 @@ run_test (void) {
     assert_zero(r);
 
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-simple-unpin-remove-checkpoint.cc b/ft/tests/cachetable-simple-unpin-remove-checkpoint.cc
index 82d39eb1116..50c01482f89 100644
--- a/ft/tests/cachetable-simple-unpin-remove-checkpoint.cc
+++ b/ft/tests/cachetable-simple-unpin-remove-checkpoint.cc
@@ -29,7 +29,7 @@ cachetable_test (void) {
   const int test_limit = 120;
   int r;
   CACHETABLE ct;
-  r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+  toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
   char fname1[] = __SRCFILE__ "test1.dat";
   unlink(fname1);
   CACHEFILE f1;
@@ -43,23 +43,21 @@ cachetable_test (void) {
   CACHETABLE_WRITE_CALLBACK wc = def_write_callback(NULL);
   r = toku_cachetable_get_and_pin(f1, make_blocknum(1), 1, &v1, &s1, wc, def_fetch, def_pf_req_callback, def_pf_callback, true, NULL);
   CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-  r = toku_cachetable_begin_checkpoint(cp, NULL); assert(r == 0);
+  toku_cachetable_begin_checkpoint(cp, NULL);
   r = toku_test_cachetable_unpin_and_remove(f1, make_blocknum(1), remove_key_expect_checkpoint, NULL);  
-  r = toku_cachetable_end_checkpoint(
+  toku_cachetable_end_checkpoint(
       cp, 
       NULL, 
       NULL,
       NULL
       );
-  assert(r==0);
 
   r = toku_cachetable_get_and_pin(f1, make_blocknum(1), 1, &v1, &s1, wc, def_fetch, def_pf_req_callback, def_pf_callback, true, NULL);
   r = toku_test_cachetable_unpin_and_remove(f1, make_blocknum(1), remove_key_expect_no_checkpoint, NULL);  
-
   
   toku_cachetable_verify(ct);
-  r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-  r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+  r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+  toku_cachetable_close(&ct);
 
 
 }
diff --git a/ft/tests/cachetable-simple-verify.cc b/ft/tests/cachetable-simple-verify.cc
index 2a3aad6ab61..bed3e6392f1 100644
--- a/ft/tests/cachetable-simple-verify.cc
+++ b/ft/tests/cachetable-simple-verify.cc
@@ -10,7 +10,7 @@ cachetable_test (void) {
   const int test_limit = 12;
   int r;
   CACHETABLE ct;
-  r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+  toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
   char fname1[] = __SRCFILE__ "test1.dat";
   unlink(fname1);
   CACHEFILE f1;
@@ -24,8 +24,8 @@ cachetable_test (void) {
   r = toku_cachetable_get_and_pin(f1, make_blocknum(1), 1, &v1, &s1, wc, def_fetch, def_pf_req_callback, def_pf_callback, true, NULL);
   r = toku_test_cachetable_unpin(f1, make_blocknum(1), 1, CACHETABLE_DIRTY, make_pair_attr(8));
   toku_cachetable_verify(ct);
-  r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-  r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+  r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+  toku_cachetable_close(&ct);
 
 
 }
diff --git a/ft/tests/cachetable-test.cc b/ft/tests/cachetable-test.cc
index b2ae4c6f434..860eb2e66fa 100644
--- a/ft/tests/cachetable-test.cc
+++ b/ft/tests/cachetable-test.cc
@@ -28,32 +28,12 @@ static inline void test_mutex_unlock(void) {
     toku_mutex_unlock(&test_mutex);
 }
 
-static void *my_malloc_always_fails(size_t n UU()) {
-    errno = ENOMEM;
-    return NULL;
-}
-
 // verify that cachetable creation and close works
 
 static void
 test_cachetable_create(void) {
     CACHETABLE ct = NULL;
-    int r;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r == 0);
-    r = toku_cachetable_close(&ct);
-    assert(r == 0 && ct == 0);
-}
-
-// verify that cachetable create with no memory returns ENOMEM
-static void
-test_cachetable_create_no_memory (void) {
-    toku_set_func_malloc(my_malloc_always_fails);
-    CACHETABLE ct = NULL;
-    int r;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r == ENOMEM);
-    toku_set_func_malloc(NULL);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 }
 
 static const int test_object_size = 1;
@@ -106,8 +86,7 @@ static void test_nested_pin (void) {
     void *vv,*vv2;
     char fname[] = __SRCFILE__ "test_ct.dat";
     if (verbose) printf("creating cachetable\n");
-    r = toku_create_cachetable(&t, 1, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&t, 1, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
     r = toku_cachetable_openf(&f, t, fname, O_RDWR|O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO);
     assert(r==0);
@@ -117,8 +96,7 @@ static void test_nested_pin (void) {
     uint32_t f1hash = toku_cachetable_hash(f, make_blocknum(1));
     CACHETABLE_WRITE_CALLBACK wc = def_write_callback(f2);
     wc.flush_callback = flush_n;
-    r = toku_cachetable_put(f, make_blocknum(1), f1hash, &i0, make_pair_attr(1), wc, put_callback_nop);
-    assert(r==0);
+    toku_cachetable_put(f, make_blocknum(1), f1hash, &i0, make_pair_attr(1), wc, put_callback_nop);
     r = toku_test_cachetable_unpin(f, make_blocknum(1), f1hash, CACHETABLE_CLEAN, make_pair_attr(test_object_size));
     r = toku_cachetable_get_and_pin(f, make_blocknum(1), f1hash, &vv, NULL, wc, fetch_n, def_pf_req_callback, def_pf_callback, true, f2);
     assert(r==0);
@@ -132,13 +110,11 @@ static void test_nested_pin (void) {
     r = toku_test_cachetable_unpin(f, make_blocknum(1), f1hash, CACHETABLE_CLEAN, make_pair_attr(test_object_size));
     assert(r==0);
     uint32_t f2hash = toku_cachetable_hash(f, make_blocknum(2));
-    r = toku_cachetable_put(f, make_blocknum(2), f2hash, &i1, make_pair_attr(test_object_size), wc, put_callback_nop);
-    assert(r==0); // The other one is pinned, but now the cachetable fails gracefully:  It allows the pin to happen
+    toku_cachetable_put(f, make_blocknum(2), f2hash, &i1, make_pair_attr(test_object_size), wc, put_callback_nop);
     r = toku_test_cachetable_unpin(f, make_blocknum(2), f2hash, CACHETABLE_CLEAN, make_pair_attr(test_object_size));
     assert(r==0);
-    //    toku_os_usleep(1*1000000);
-    r = toku_cachefile_close(&f, 0, false, ZERO_LSN); assert(r==0);
-    r = toku_cachetable_close(&t); assert(r==0);
+    r = toku_cachefile_close(&f, false, ZERO_LSN); assert(r==0);
+    toku_cachetable_close(&t);
 }
 
 
@@ -192,7 +168,7 @@ static void test_multi_filehandles (void) {
     unlink(fname1);
     unlink(fname2);
 
-    r = toku_create_cachetable(&t, 4, ZERO_LSN, NULL_LOGGER);          assert(r==0);
+    toku_cachetable_create(&t, 4, ZERO_LSN, NULL_LOGGER);
     r = toku_cachetable_openf(&f1, t, fname1, O_RDWR|O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO);   assert(r==0);
     r = link(fname1, fname2);                                     assert(r==0);
     r = toku_cachetable_openf(&f2, t, fname2, O_RDWR|O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO);   assert(r==0);
@@ -203,7 +179,7 @@ static void test_multi_filehandles (void) {
     
     CACHETABLE_WRITE_CALLBACK wc = def_write_callback((void*)123);
     wc.flush_callback = null_flush;
-    r = toku_cachetable_put(f1, make_blocknum(1), toku_cachetable_hash(f1, make_blocknum(1)), (void*)124, make_pair_attr(test_object_size), wc, put_callback_nop); assert(r==0);
+    toku_cachetable_put(f1, make_blocknum(1), toku_cachetable_hash(f1, make_blocknum(1)), (void*)124, make_pair_attr(test_object_size), wc, put_callback_nop);
     r = toku_test_cachetable_unpin(f1, make_blocknum(1), toku_cachetable_hash(f1, make_blocknum(1)), CACHETABLE_DIRTY, make_pair_attr(0)); assert(r==0);
     r = toku_cachetable_get_and_pin(f2, make_blocknum(1), toku_cachetable_hash(f2, make_blocknum(1)), &v, NULL, wc, add123_fetch, def_pf_req_callback, def_pf_callback, true, (void*)123); assert(r==0);
     assert((unsigned long)v==124);
@@ -216,12 +192,12 @@ static void test_multi_filehandles (void) {
     // we support only one close for a file handle
     r = toku_test_cachetable_unpin(f1, make_blocknum(1), toku_cachetable_hash(f1, make_blocknum(1)), CACHETABLE_CLEAN, make_pair_attr(0)); assert(r==0);
     r = toku_test_cachetable_unpin(f2, make_blocknum(2), toku_cachetable_hash(f2, make_blocknum(2)), CACHETABLE_CLEAN, make_pair_attr(0)); assert(r==0);
-    r = toku_cachefile_close(&f2, 0, false, ZERO_LSN); assert(r==0);
+    r = toku_cachefile_close(&f2, false, ZERO_LSN); assert(r==0);
 
     r = toku_test_cachetable_unpin(f3, make_blocknum(2), toku_cachetable_hash(f3, make_blocknum(2)), CACHETABLE_CLEAN, make_pair_attr(0)); assert(r==0);
-    r = toku_cachefile_close(&f3, 0, false, ZERO_LSN); assert(r==0);
+    r = toku_cachefile_close(&f3, false, ZERO_LSN); assert(r==0);
 
-    r = toku_cachetable_close(&t); assert(r==0);
+    toku_cachetable_close(&t);
 }
 
 #endif
@@ -262,8 +238,7 @@ static void test_dirty(void) {
     int dirty; long long pinned; long entry_size;
     int r;
 
-    r = toku_create_cachetable(&t, 4, ZERO_LSN, NULL_LOGGER);
-    assert(r == 0);
+    toku_cachetable_create(&t, 4, ZERO_LSN, NULL_LOGGER);
 
     const char *fname = __SRCFILE__ "test.dat";
     unlink(fname);
@@ -274,8 +249,7 @@ static void test_dirty(void) {
     uint32_t hkey = toku_cachetable_hash(f, key);
     CACHETABLE_WRITE_CALLBACK wc = def_write_callback(NULL);
     wc.flush_callback = test_dirty_flush;
-    r = toku_cachetable_put(f, key, hkey, value, make_pair_attr(test_object_size), wc, put_callback_nop);
-    assert(r == 0);
+    toku_cachetable_put(f, key, hkey, value, make_pair_attr(test_object_size), wc, put_callback_nop);
 
     // cachetable_print_state(t);
     r = toku_cachetable_get_key_state(t, key, f, &value, &dirty, &pinned, &entry_size);
@@ -351,10 +325,7 @@ static void test_dirty(void) {
     assert(dirty == 1);
     assert(pinned == 0);
      
-    r = toku_cachefile_close(&f, 0, false, ZERO_LSN);
-    assert(r == 0);
-    r = toku_cachetable_close(&t);
-    assert(r == 0);
+    toku_cachefile_close(&f, false, ZERO_LSN);
 }
 
 static int test_size_debug;
@@ -395,8 +366,7 @@ static void test_size_resize(void) {
     int n = 3;
     long size = 1;
 
-    r = toku_create_cachetable(&t, n*size, ZERO_LSN, NULL_LOGGER);
-    assert(r == 0);
+    toku_cachetable_create(&t, n*size, ZERO_LSN, NULL_LOGGER);
 
     const char *fname = __SRCFILE__ "test.dat";
     unlink(fname);
@@ -410,8 +380,7 @@ static void test_size_resize(void) {
 
     CACHETABLE_WRITE_CALLBACK wc = def_write_callback(NULL);
     wc.flush_callback = test_size_flush_callback;
-    r = toku_cachetable_put(f, key, hkey, value, make_pair_attr(size), wc, put_callback_nop);
-    assert(r == 0);
+    toku_cachetable_put(f, key, hkey, value, make_pair_attr(size), wc, put_callback_nop);
 
     void *entry_value; int dirty; long long pinned; long entry_size;
     r = toku_cachetable_get_key_state(t, key, f, &entry_value, &dirty, &pinned, &entry_size);
@@ -435,10 +404,7 @@ static void test_size_resize(void) {
     r = toku_test_cachetable_unpin(f, key, hkey, CACHETABLE_CLEAN, make_pair_attr(new_size));
     assert(r == 0);
 
-    r = toku_cachefile_close(&f, 0, false, ZERO_LSN);
-    assert(r == 0);
-    r = toku_cachetable_close(&t);
-    assert(r == 0);
+    toku_cachefile_close(&f, false, ZERO_LSN);
 }
 
 static int min2(int a, int b) { return a < b ? a : b; }
@@ -453,8 +419,7 @@ static void test_size_flush(void) {
 
     const int n = 8;
     long long size = 1*1024*1024;
-    r = toku_create_cachetable(&t, n*size, ZERO_LSN, NULL_LOGGER);
-    assert(r == 0);
+    toku_cachetable_create(&t, n*size, ZERO_LSN, NULL_LOGGER);
 
     const char *fname = __SRCFILE__ "test.dat";
     unlink(fname);
@@ -475,8 +440,7 @@ static void test_size_flush(void) {
 	uint32_t hkey = toku_cachetable_hash(f, key);
         CACHETABLE_WRITE_CALLBACK wc = def_write_callback(NULL);
         wc.flush_callback = test_size_flush_callback;
-        r = toku_cachetable_put(f, key, hkey, value, make_pair_attr(size), wc, put_callback_nop);
-        assert(r == 0);
+        toku_cachetable_put(f, key, hkey, value, make_pair_attr(size), wc, put_callback_nop);
 
         int n_entries, hash_size; long size_current, size_limit;
         toku_cachetable_get_state(t, &n_entries, &hash_size, &size_current, &size_limit);
@@ -506,17 +470,13 @@ static void test_size_flush(void) {
         assert(r == 0);
     }
     
-    r = toku_cachefile_close(&f, 0, false, ZERO_LSN);
-    assert(r == 0);
-    r = toku_cachetable_close(&t);
+    r = toku_cachefile_close(&f, false, ZERO_LSN);
     assert(r == 0);
+    toku_cachetable_close(&t);
 }
 
 int
 test_main (int argc, const char *argv[]) {
-    // defaults
-    int do_malloc_fail = 0;
-
     // parse args
     int i;
     for (i=1; i<argc; i++) {
@@ -529,10 +489,6 @@ test_main (int argc, const char *argv[]) {
             if (verbose > 0) verbose--;
             continue;
         }
-        if (strcmp(arg, "-malloc-fail") == 0) {
-            do_malloc_fail = 1;
-            continue;
-        }
     }
 
     test_mutex_init();
@@ -542,8 +498,6 @@ test_main (int argc, const char *argv[]) {
     test_multi_filehandles();
 #endif
     test_cachetable_create();
-    if (do_malloc_fail)
-        test_cachetable_create_no_memory();    // fails with valgrind
     for (i=0; i<1; i++) {
         test_nested_pin();
 #if !TOKU_WINDOWS
diff --git a/ft/tests/cachetable-test.h b/ft/tests/cachetable-test.h
index 1b3b585fb7f..cafeb01832a 100644
--- a/ft/tests/cachetable-test.h
+++ b/ft/tests/cachetable-test.h
@@ -9,22 +9,22 @@
 //
 // Dummy callbacks for checkpointing
 //
-static int dummy_log_fassociate(CACHEFILE UU(cf), void* UU(p))
-{ return 0; }
-static int dummy_log_rollback(CACHEFILE UU(cf), void* UU(p))
-{ return 0; }
-static int dummy_close_usr(CACHEFILE UU(cf), int UU(i), void* UU(p), char** UU(c), bool UU(b), LSN UU(lsn)) 
+static void dummy_log_fassociate(CACHEFILE UU(cf), void* UU(p))
+{ return; }
+static void dummy_log_rollback(CACHEFILE UU(cf), void* UU(p))
+{ return; }
+static int dummy_close_usr(CACHEFILE UU(cf), int UU(i), void* UU(p), bool UU(b), LSN UU(lsn)) 
 { return 0; }
 static int dummy_chckpnt_usr(CACHEFILE UU(cf), int UU(i), void* UU(p))
 { return 0; }
-static int dummy_begin(LSN UU(lsn), void* UU(p)) 
-{ return 0; }
-static int dummy_end(CACHEFILE UU(cf), int UU(i), void* UU(p)) 
-{ return 0; }
-static int dummy_note_pin(CACHEFILE UU(cf), void* UU(p)) 
-{ return 0; }
-static int dummy_note_unpin(CACHEFILE UU(cf), void* UU(p))
-{ return 0; }
+static void dummy_begin(LSN UU(lsn), void* UU(p)) 
+{ return; }
+static void dummy_end(CACHEFILE UU(cf), int UU(i), void* UU(p)) 
+{ return; }
+static void dummy_note_pin(CACHEFILE UU(cf), void* UU(p)) 
+{ return; }
+static void dummy_note_unpin(CACHEFILE UU(cf), void* UU(p))
+{ return; }
 
 //
 // Helper function to set dummy functions in given cachefile.
@@ -43,4 +43,4 @@ create_dummy_functions(CACHEFILE cf)
                                  &dummy_end,
                                  &dummy_note_pin,
                                  &dummy_note_unpin);
-};
\ No newline at end of file
+};
diff --git a/ft/tests/cachetable-unpin-and-remove-test.cc b/ft/tests/cachetable-unpin-and-remove-test.cc
index 1cba7f2b960..349591072ce 100644
--- a/ft/tests/cachetable-unpin-and-remove-test.cc
+++ b/ft/tests/cachetable-unpin-and-remove-test.cc
@@ -31,7 +31,7 @@ cachetable_unpin_and_remove_test (int n) {
     int i;
 
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, table_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, table_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -47,8 +47,7 @@ cachetable_unpin_and_remove_test (int n) {
     // put the keys into the cachetable
     for (i=0; i<n; i++) {
         uint32_t hi = toku_cachetable_hash(f1, make_blocknum(keys[i].b));
-        r = toku_cachetable_put(f1, make_blocknum(keys[i].b), hi, (void *)(long) keys[i].b, make_pair_attr(1),wc, put_callback_nop);
-        assert(r == 0);
+        toku_cachetable_put(f1, make_blocknum(keys[i].b), hi, (void *)(long) keys[i].b, make_pair_attr(1),wc, put_callback_nop);
     }
     
     // unpin and remove
@@ -75,9 +74,8 @@ cachetable_unpin_and_remove_test (int n) {
     toku_cachetable_get_state(ct, &nentries, NULL, NULL, NULL);
     assert(nentries == 0);
 
-    char *error_string;
-    r = toku_cachefile_close(&f1, &error_string, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 // test remove when the pair in being written
@@ -89,7 +87,7 @@ cachetable_put_evict_remove_test (int n) {
     int i;
 
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, table_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, table_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -102,8 +100,7 @@ cachetable_put_evict_remove_test (int n) {
 
     // put 0, 1, 2, ... should evict 0
     for (i=0; i<n; i++) {
-        r = toku_cachetable_put(f1, make_blocknum(i), hi[i], (void *)(long)i, make_pair_attr(1), wc, put_callback_nop);
-        assert(r == 0);
+        toku_cachetable_put(f1, make_blocknum(i), hi[i], (void *)(long)i, make_pair_attr(1), wc, put_callback_nop);
         r = toku_test_cachetable_unpin(f1, make_blocknum(i), hi[i], CACHETABLE_CLEAN, make_pair_attr(1));
         assert(r == 0);
     }
@@ -117,9 +114,8 @@ cachetable_put_evict_remove_test (int n) {
     r = toku_test_cachetable_unpin_and_remove(f1, make_blocknum(0), NULL, NULL);
     assert(r == 0);
 
-    char *error_string;
-    r = toku_cachefile_close(&f1, &error_string, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-unpin-remove-and-checkpoint.cc b/ft/tests/cachetable-unpin-remove-and-checkpoint.cc
index 6ba24aae430..dc6a93d86a2 100644
--- a/ft/tests/cachetable-unpin-remove-and-checkpoint.cc
+++ b/ft/tests/cachetable-unpin-remove-and-checkpoint.cc
@@ -15,13 +15,12 @@ CACHETABLE ct;
 static void *run_end_chkpt(void *arg) {
     assert(arg == NULL);
     CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-    int r = toku_cachetable_end_checkpoint(
+    toku_cachetable_end_checkpoint(
         cp, 
         NULL, 
         NULL,
         NULL
         );
-    assert(r==0);
     return arg;
 }
 
@@ -30,7 +29,7 @@ run_test (void) {
     const int test_limit = 12;
     int r;
     ct = NULL;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -53,7 +52,7 @@ run_test (void) {
 
     // now this should mark the pair for checkpoint
     CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
-    r = toku_cachetable_begin_checkpoint(cp, NULL);
+    toku_cachetable_begin_checkpoint(cp, NULL);
     r = toku_cachetable_get_and_pin(f1, make_blocknum(1), toku_cachetable_hash(f1, make_blocknum(1)), &v1, &s1, wc, def_fetch, def_pf_req_callback, def_pf_callback, true, NULL);
 
     toku_pthread_t mytid;
@@ -70,8 +69,8 @@ run_test (void) {
     assert(r==0);
     
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); lazy_assert_zero(r);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
     
     
 }
diff --git a/ft/tests/cachetable-unpin-test.cc b/ft/tests/cachetable-unpin-test.cc
index d842ebddbf9..32e8c4e0aa1 100644
--- a/ft/tests/cachetable-unpin-test.cc
+++ b/ft/tests/cachetable-unpin-test.cc
@@ -12,7 +12,7 @@ cachetable_unpin_test (int n) {
     const int test_limit = 2*n;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -23,8 +23,7 @@ cachetable_unpin_test (int n) {
         uint32_t hi;
         CACHETABLE_WRITE_CALLBACK wc = def_write_callback(NULL);
         hi = toku_cachetable_hash(f1, make_blocknum(i));
-        r = toku_cachetable_put(f1, make_blocknum(i), hi, (void *)(long)i, make_pair_attr(1), wc, put_callback_nop);
-        assert(r == 0);
+        toku_cachetable_put(f1, make_blocknum(i), hi, (void *)(long)i, make_pair_attr(1), wc, put_callback_nop);
         assert(toku_cachefile_count_pinned(f1, 0) == i);
 
         void *v;
@@ -46,8 +45,8 @@ cachetable_unpin_test (int n) {
     assert(toku_cachefile_count_pinned(f1, 1) == 0);
     toku_cachetable_verify(ct);
 
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 enum unpin_evictor_test_type {
@@ -61,7 +60,7 @@ unpin_and_evictor_test(enum unpin_evictor_test_type test_type) {
     int r;
     CACHETABLE ct;
     int test_limit = 4;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -113,8 +112,8 @@ unpin_and_evictor_test(enum unpin_evictor_test_type test_type) {
     }
 
     toku_cachetable_verify(ct);
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/cachetable-writer-thread-limit.cc b/ft/tests/cachetable-writer-thread-limit.cc
index 3cbf25e3840..278d9c5c295 100644
--- a/ft/tests/cachetable-writer-thread-limit.cc
+++ b/ft/tests/cachetable-writer-thread-limit.cc
@@ -39,7 +39,7 @@ cachetable_test (void) {
     test_limit = 6;
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, test_limit, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, test_limit, ZERO_LSN, NULL_LOGGER);
     char fname1[] = __SRCFILE__ "test1.dat";
     unlink(fname1);
     CACHEFILE f1;
@@ -48,14 +48,14 @@ cachetable_test (void) {
     for (int64_t i = 0; i < num_entries; i++) {
        CACHETABLE_WRITE_CALLBACK wc = def_write_callback(NULL);
        wc.flush_callback = flush;
-        r = toku_cachetable_put(f1, make_blocknum(i), i, NULL, make_pair_attr(1), wc, put_callback_nop);
+        toku_cachetable_put(f1, make_blocknum(i), i, NULL, make_pair_attr(1), wc, put_callback_nop);
         int curr_size = __sync_fetch_and_add(&total_size, 1);
         assert(curr_size <= test_limit + test_limit/2+1);
         r = toku_test_cachetable_unpin(f1, make_blocknum(i), i, CACHETABLE_DIRTY, make_pair_attr(4));
     }
     
-    r = toku_cachefile_close(&f1, 0, false, ZERO_LSN); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0 && ct == 0);
+    r = toku_cachefile_close(&f1, false, ZERO_LSN); assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/ft-bfe-query.cc b/ft/tests/ft-bfe-query.cc
index 77f7d59ad38..2f42622ddf1 100644
--- a/ft/tests/ft-bfe-query.cc
+++ b/ft/tests/ft-bfe-query.cc
@@ -336,7 +336,6 @@ test_prefetching(void) {
                  128*1024,
                  TOKU_DEFAULT_COMPRESSION_METHOD);
     brt->ft = brt_h;
-    brt_h->panic = 0; brt_h->panic_string = 0;
     toku_blocktable_create_new(&brt_h->blocktable);
     { int r_truncate = ftruncate(fd, 0); CKERR(r_truncate); }
     //Want to use block #20
diff --git a/ft/tests/ft-clock-test.cc b/ft/tests/ft-clock-test.cc
index 05c0ccfb412..9652725a2e9 100644
--- a/ft/tests/ft-clock-test.cc
+++ b/ft/tests/ft-clock-test.cc
@@ -263,9 +263,9 @@ test_serialize_nonleaf(void) {
     r = xids_create_child(xids_123, &xids_234, (TXNID)234);
     CKERR(r);
 
-    r = toku_bnc_insert_msg(BNC(&sn, 0), "a", 2, "aval", 5, FT_NONE, next_dummymsn(), xids_0, true, NULL, string_key_cmp); assert_zero(r);
-    r = toku_bnc_insert_msg(BNC(&sn, 0), "b", 2, "bval", 5, FT_NONE, next_dummymsn(), xids_123, false, NULL, string_key_cmp); assert_zero(r);
-    r = toku_bnc_insert_msg(BNC(&sn, 1), "x", 2, "xval", 5, FT_NONE, next_dummymsn(), xids_234, true, NULL, string_key_cmp); assert_zero(r);
+    toku_bnc_insert_msg(BNC(&sn, 0), "a", 2, "aval", 5, FT_NONE, next_dummymsn(), xids_0, true, NULL, string_key_cmp);
+    toku_bnc_insert_msg(BNC(&sn, 0), "b", 2, "bval", 5, FT_NONE, next_dummymsn(), xids_123, false, NULL, string_key_cmp);
+    toku_bnc_insert_msg(BNC(&sn, 1), "x", 2, "xval", 5, FT_NONE, next_dummymsn(), xids_234, true, NULL, string_key_cmp);
     //Cleanup:
     xids_destroy(&xids_0);
     xids_destroy(&xids_123);
@@ -281,7 +281,7 @@ test_serialize_nonleaf(void) {
                  128*1024,
                  TOKU_DEFAULT_COMPRESSION_METHOD);
     brt->ft = brt_h;
-    brt_h->panic = 0; brt_h->panic_string = 0;
+    
     toku_blocktable_create_new(&brt_h->blocktable);
     { int r_truncate = ftruncate(fd, 0); CKERR(r_truncate); }
     //Want to use block #20
@@ -369,7 +369,7 @@ test_serialize_leaf(void) {
                  128*1024,
                  TOKU_DEFAULT_COMPRESSION_METHOD);
     brt->ft = brt_h;
-    brt_h->panic = 0; brt_h->panic_string = 0;
+    
     toku_blocktable_create_new(&brt_h->blocktable);
     { int r_truncate = ftruncate(fd, 0); CKERR(r_truncate); }
     //Want to use block #20
diff --git a/ft/tests/ft-serialize-benchmark.cc b/ft/tests/ft-serialize-benchmark.cc
index f0890b04e92..3b4797eaa04 100644
--- a/ft/tests/ft-serialize-benchmark.cc
+++ b/ft/tests/ft-serialize-benchmark.cc
@@ -114,7 +114,7 @@ test_serialize_leaf(int valsize, int nelts, double entropy) {
                  128*1024,
                  TOKU_DEFAULT_COMPRESSION_METHOD);
     brt->ft = brt_h;
-    brt_h->panic = 0; brt_h->panic_string = 0;
+    
     brt_h->compare_fun = long_key_cmp;
     toku_blocktable_create_new(&brt_h->blocktable);
     { int r_truncate = ftruncate(fd, 0); CKERR(r_truncate); }
@@ -222,7 +222,7 @@ test_serialize_nonleaf(int valsize, int nelts, double entropy) {
             }
             memset(&buf[c], 0, valsize - c);
 
-            r = toku_bnc_insert_msg(bnc, &k, sizeof k, buf, valsize, FT_NONE, next_dummymsn(), xids_123, true, NULL, long_key_cmp); assert_zero(r);
+            toku_bnc_insert_msg(bnc, &k, sizeof k, buf, valsize, FT_NONE, next_dummymsn(), xids_123, true, NULL, long_key_cmp);
         }
         if (ck < 7) {
             toku_fill_dbt(&sn.childkeys[ck], toku_xmemdup(&k, sizeof k), sizeof k);
@@ -244,7 +244,7 @@ test_serialize_nonleaf(int valsize, int nelts, double entropy) {
                  128*1024,
                  TOKU_DEFAULT_COMPRESSION_METHOD);
     brt->ft = brt_h;
-    brt_h->panic = 0; brt_h->panic_string = 0;
+    
     brt_h->compare_fun = long_key_cmp;
     toku_blocktable_create_new(&brt_h->blocktable);
     { int r_truncate = ftruncate(fd, 0); CKERR(r_truncate); }
diff --git a/ft/tests/ft-serialize-sub-block-test.cc b/ft/tests/ft-serialize-sub-block-test.cc
index c840ce9a72a..18fd862392b 100644
--- a/ft/tests/ft-serialize-sub-block-test.cc
+++ b/ft/tests/ft-serialize-sub-block-test.cc
@@ -27,8 +27,7 @@ static void test_sub_block(int n) {
 
     unlink(fname);
 
-    error = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(error == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     error = toku_open_ft_handle(fname, true, &brt, nodesize, basementnodesize, compression_method, ct, null_txn, toku_builtin_compare_fun);
     assert(error == 0);
@@ -40,7 +39,7 @@ static void test_sub_block(int n) {
 	DBT key, val;
         toku_fill_dbt(&key, &k, sizeof k);
         toku_fill_dbt(&val, &v, sizeof v);
-        error = toku_ft_insert(brt, &key, &val, 0);
+        toku_ft_insert(brt, &key, &val, 0);
         assert(error == 0);
     }
 
@@ -69,14 +68,12 @@ static void test_sub_block(int n) {
     }
     assert(i == n);
 
-    error = toku_ft_cursor_close(cursor);
-    assert(error == 0);
+    toku_ft_cursor_close(cursor);
 
     error = toku_close_ft_handle_nolsn(brt, 0);
     assert(error == 0);
 
-    error = toku_cachetable_close(&ct);
-    assert(error == 0);
+    toku_cachetable_close(&ct);
 }
 
 int test_main (int argc , const char *argv[]) {
diff --git a/ft/tests/ft-serialize-test.cc b/ft/tests/ft-serialize-test.cc
index 34e55a1e2a7..64192a36302 100644
--- a/ft/tests/ft-serialize-test.cc
+++ b/ft/tests/ft-serialize-test.cc
@@ -259,7 +259,6 @@ test_serialize_leaf_check_msn(enum ftnode_verify_type bft, bool do_clone) {
                  128*1024,
                  TOKU_DEFAULT_COMPRESSION_METHOD);
     brt->ft = brt_h;
-    brt_h->panic = 0; brt_h->panic_string = 0;
     toku_blocktable_create_new(&brt_h->blocktable);
     { int r_truncate = ftruncate(fd, 0); CKERR(r_truncate); }
 
@@ -405,7 +404,6 @@ test_serialize_leaf_with_large_pivots(enum ftnode_verify_type bft, bool do_clone
                  128*1024,
                  TOKU_DEFAULT_COMPRESSION_METHOD);
     brt->ft = brt_h;
-    brt_h->panic = 0; brt_h->panic_string = 0;
     toku_blocktable_create_new(&brt_h->blocktable);
     { int r_truncate = ftruncate(fd, 0); CKERR(r_truncate); }
     //Want to use block #20
@@ -547,7 +545,7 @@ test_serialize_leaf_with_many_rows(enum ftnode_verify_type bft, bool do_clone) {
                  128*1024,
                  TOKU_DEFAULT_COMPRESSION_METHOD);
     brt->ft = brt_h;
-    brt_h->panic = 0; brt_h->panic_string = 0;
+    
     toku_blocktable_create_new(&brt_h->blocktable);
     { int r_truncate = ftruncate(fd, 0); CKERR(r_truncate); }
     //Want to use block #20
@@ -694,7 +692,7 @@ test_serialize_leaf_with_large_rows(enum ftnode_verify_type bft, bool do_clone)
                  128*1024,
                  TOKU_DEFAULT_COMPRESSION_METHOD);
     brt->ft = brt_h;
-    brt_h->panic = 0; brt_h->panic_string = 0;
+    
     toku_blocktable_create_new(&brt_h->blocktable);
     { int r_truncate = ftruncate(fd, 0); CKERR(r_truncate); }
     //Want to use block #20
@@ -856,7 +854,7 @@ test_serialize_leaf_with_empty_basement_nodes(enum ftnode_verify_type bft, bool
                  128*1024,
                  TOKU_DEFAULT_COMPRESSION_METHOD);
     brt->ft = brt_h;
-    brt_h->panic = 0; brt_h->panic_string = 0;
+    
     toku_blocktable_create_new(&brt_h->blocktable);
     { int r_truncate = ftruncate(fd, 0); CKERR(r_truncate); }
     //Want to use block #20
@@ -982,7 +980,7 @@ test_serialize_leaf_with_multiple_empty_basement_nodes(enum ftnode_verify_type b
                  128*1024,
                  TOKU_DEFAULT_COMPRESSION_METHOD);
     brt->ft = brt_h;
-    brt_h->panic = 0; brt_h->panic_string = 0;
+    
     toku_blocktable_create_new(&brt_h->blocktable);
     { int r_truncate = ftruncate(fd, 0); CKERR(r_truncate); }
     //Want to use block #20
@@ -1113,7 +1111,7 @@ test_serialize_leaf(enum ftnode_verify_type bft, bool do_clone) {
                  128*1024,
                  TOKU_DEFAULT_COMPRESSION_METHOD);
     brt->ft = brt_h;
-    brt_h->panic = 0; brt_h->panic_string = 0;
+    
     toku_blocktable_create_new(&brt_h->blocktable);
     { int r_truncate = ftruncate(fd, 0); CKERR(r_truncate); }
     //Want to use block #20
@@ -1239,9 +1237,9 @@ test_serialize_nonleaf(enum ftnode_verify_type bft, bool do_clone) {
     r = xids_create_child(xids_123, &xids_234, (TXNID)234);
     CKERR(r);
 
-    r = toku_bnc_insert_msg(BNC(&sn, 0), "a", 2, "aval", 5, FT_NONE, next_dummymsn(), xids_0, true, NULL, string_key_cmp); assert_zero(r);
-    r = toku_bnc_insert_msg(BNC(&sn, 0), "b", 2, "bval", 5, FT_NONE, next_dummymsn(), xids_123, false, NULL, string_key_cmp); assert_zero(r);
-    r = toku_bnc_insert_msg(BNC(&sn, 1), "x", 2, "xval", 5, FT_NONE, next_dummymsn(), xids_234, true, NULL, string_key_cmp); assert_zero(r);
+    toku_bnc_insert_msg(BNC(&sn, 0), "a", 2, "aval", 5, FT_NONE, next_dummymsn(), xids_0, true, NULL, string_key_cmp);
+    toku_bnc_insert_msg(BNC(&sn, 0), "b", 2, "bval", 5, FT_NONE, next_dummymsn(), xids_123, false, NULL, string_key_cmp);
+    toku_bnc_insert_msg(BNC(&sn, 1), "x", 2, "xval", 5, FT_NONE, next_dummymsn(), xids_234, true, NULL, string_key_cmp);
     //Cleanup:
     xids_destroy(&xids_0);
     xids_destroy(&xids_123);
@@ -1257,7 +1255,7 @@ test_serialize_nonleaf(enum ftnode_verify_type bft, bool do_clone) {
                  128*1024,
                  TOKU_DEFAULT_COMPRESSION_METHOD);
     brt->ft = brt_h;
-    brt_h->panic = 0; brt_h->panic_string = 0;
+    
     toku_blocktable_create_new(&brt_h->blocktable);
     { int r_truncate = ftruncate(fd, 0); CKERR(r_truncate); }
     //Want to use block #20
diff --git a/ft/tests/ft-test-cursor-2.cc b/ft/tests/ft-test-cursor-2.cc
index 086b1630a61..2ad0bd0ec73 100644
--- a/ft/tests/ft-test-cursor-2.cc
+++ b/ft/tests/ft-test-cursor-2.cc
@@ -33,8 +33,7 @@ static void test_multiple_ft_cursor_dbts(int n) {
 
     unlink(fname);
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     r = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     assert(r==0);
@@ -45,11 +44,10 @@ static void test_multiple_ft_cursor_dbts(int n) {
 	char key[10],val[10];
 	snprintf(key, sizeof key, "k%04d", i);
 	snprintf(val, sizeof val, "v%04d", i);
-	r = toku_ft_insert(brt,
-			    toku_fill_dbt(&kbt, key, 1+strlen(key)),
-			    toku_fill_dbt(&vbt, val, 1+strlen(val)),
-			    0);
-	assert(r == 0);
+	toku_ft_insert(brt,
+                       toku_fill_dbt(&kbt, key, 1+strlen(key)),
+                       toku_fill_dbt(&vbt, val, 1+strlen(val)),
+                       0);
     }
 
     for (i=0; i<n; i++) {
@@ -78,7 +76,7 @@ static void test_multiple_ft_cursor_dbts(int n) {
     }
 
     for (i=0; i<n; i++) {
-        r = toku_ft_cursor_close(cursors[i]);
+        toku_ft_cursor_close(cursors[i]);
         assert(r == 0);
 	toku_free(ptrs[i]);
     }
@@ -86,8 +84,7 @@ static void test_multiple_ft_cursor_dbts(int n) {
     r = toku_close_ft_handle_nolsn(brt, 0);
     assert(r==0);
 
-    r = toku_cachetable_close(&ct);
-    assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void test_ft_cursor(void) {
diff --git a/ft/tests/ft-test-cursor.cc b/ft/tests/ft-test-cursor.cc
index 5b0221883e8..658dd57e781 100644
--- a/ft/tests/ft-test-cursor.cc
+++ b/ft/tests/ft-test-cursor.cc
@@ -29,8 +29,7 @@ static void assert_cursor_notfound(FT_HANDLE brt, int position) {
     assert(r == DB_NOTFOUND);
     assert(pair.call_count==0);
 
-    r = toku_ft_cursor_close(cursor);
-    assert(r==0);
+    toku_ft_cursor_close(cursor);
 }
 
 static void assert_cursor_value(FT_HANDLE brt, int position, long long value) {
@@ -46,8 +45,7 @@ static void assert_cursor_value(FT_HANDLE brt, int position, long long value) {
     assert(r == 0);
     assert(pair.call_count==1);
 
-    r = toku_ft_cursor_close(cursor);
-    assert(r==0);
+    toku_ft_cursor_close(cursor);
 }
 
 static void assert_cursor_first_last(FT_HANDLE brt, long long firstv, long long lastv) {
@@ -74,8 +72,7 @@ static void assert_cursor_first_last(FT_HANDLE brt, long long firstv, long long
     }
     if (test_cursor_debug && verbose) printf("\n");
 
-    r = toku_ft_cursor_close(cursor);
-    assert(r==0);
+    toku_ft_cursor_close(cursor);
 }
 
 static void test_ft_cursor_first(int n) {
@@ -88,8 +85,7 @@ static void test_ft_cursor_first(int n) {
 
     unlink(fname);
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     r = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, test_ft_cursor_keycompare);
     assert(r==0);
@@ -103,8 +99,7 @@ static void test_ft_cursor_first(int n) {
         toku_fill_dbt(&kbt, key, strlen(key)+1);
         v = i;
         toku_fill_dbt(&vbt, &v, sizeof v);
-        r = toku_ft_insert(brt, &kbt, &vbt, 0);
-        assert(r==0);
+        toku_ft_insert(brt, &kbt, &vbt, 0);
     }
 
     if (n == 0)
@@ -115,8 +110,7 @@ static void test_ft_cursor_first(int n) {
     r = toku_close_ft_handle_nolsn(brt, 0);
     assert(r==0);
 
-    r = toku_cachetable_close(&ct);
-    assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void test_ft_cursor_last(int n) {
@@ -129,8 +123,7 @@ static void test_ft_cursor_last(int n) {
 
     unlink(fname);
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     r = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, test_ft_cursor_keycompare);
     assert(r==0);
@@ -144,7 +137,7 @@ static void test_ft_cursor_last(int n) {
         toku_fill_dbt(&kbt, key, strlen(key)+1);
         v = i;
         toku_fill_dbt(&vbt, &v, sizeof v);
-        r = toku_ft_insert(brt, &kbt, &vbt, 0);
+        toku_ft_insert(brt, &kbt, &vbt, 0);
         assert(r==0);
     }
 
@@ -156,8 +149,7 @@ static void test_ft_cursor_last(int n) {
     r = toku_close_ft_handle_nolsn(brt, 0);
     assert(r==0);
 
-    r = toku_cachetable_close(&ct);
-    assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void test_ft_cursor_first_last(int n) {
@@ -170,8 +162,7 @@ static void test_ft_cursor_first_last(int n) {
 
     unlink(fname);
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     r = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, test_ft_cursor_keycompare);
     assert(r==0);
@@ -186,8 +177,7 @@ static void test_ft_cursor_first_last(int n) {
         v = i;
         toku_fill_dbt(&vbt, &v, sizeof v);
 
-        r = toku_ft_insert(brt, &kbt, &vbt, 0);
-        assert(r==0);
+        toku_ft_insert(brt, &kbt, &vbt, 0);
     }
 
     if (n == 0) {
@@ -199,8 +189,7 @@ static void test_ft_cursor_first_last(int n) {
     r = toku_close_ft_handle_nolsn(brt, 0);
     assert(r==0);
 
-    r = toku_cachetable_close(&ct);
-    assert(r==0);
+    toku_cachetable_close(&ct);
 
 
 }
@@ -215,8 +204,7 @@ static void test_ft_cursor_rfirst(int n) {
 
     unlink(fname);
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     r = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, test_ft_cursor_keycompare);
     assert(r==0);
@@ -231,8 +219,7 @@ static void test_ft_cursor_rfirst(int n) {
         toku_fill_dbt(&kbt, key, strlen(key)+1);
         v = i;
         toku_fill_dbt(&vbt, &v, sizeof v);
-        r = toku_ft_insert(brt, &kbt, &vbt, 0);
-        assert(r==0);
+        toku_ft_insert(brt, &kbt, &vbt, 0);
     }
 
     if (n == 0)
@@ -243,8 +230,7 @@ static void test_ft_cursor_rfirst(int n) {
     r = toku_close_ft_handle_nolsn(brt, 0);
     assert(r==0);
 
-    r = toku_cachetable_close(&ct);
-    assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void assert_cursor_walk(FT_HANDLE brt, int n) {
@@ -269,8 +255,7 @@ static void assert_cursor_walk(FT_HANDLE brt, int n) {
     if (test_cursor_debug && verbose) printf("\n");
     assert(i == n);
 
-    r = toku_ft_cursor_close(cursor);
-    assert(r==0);
+    toku_ft_cursor_close(cursor);
 }
 
 static void test_ft_cursor_walk(int n) {
@@ -283,8 +268,7 @@ static void test_ft_cursor_walk(int n) {
 
     unlink(fname);
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     r = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, test_ft_cursor_keycompare);
     assert(r==0);
@@ -298,8 +282,7 @@ static void test_ft_cursor_walk(int n) {
         toku_fill_dbt(&kbt, key, strlen(key)+1);
         v = i;
         toku_fill_dbt(&vbt, &v, sizeof v);
-        r = toku_ft_insert(brt, &kbt, &vbt, 0);
-        assert(r==0);
+        toku_ft_insert(brt, &kbt, &vbt, 0);
     }
 
     /* walk the tree */
@@ -308,8 +291,7 @@ static void test_ft_cursor_walk(int n) {
     r = toku_close_ft_handle_nolsn(brt, 0);
     assert(r==0);
 
-    r = toku_cachetable_close(&ct);
-    assert(r==0);
+    toku_cachetable_close(&ct);
 
 }
 
@@ -335,8 +317,7 @@ static void assert_cursor_rwalk(FT_HANDLE brt, int n) {
     if (test_cursor_debug && verbose) printf("\n");
     assert(i == -1);
 
-    r = toku_ft_cursor_close(cursor);
-    assert(r==0);
+    toku_ft_cursor_close(cursor);
 }
 
 static void test_ft_cursor_rwalk(int n) {
@@ -349,8 +330,7 @@ static void test_ft_cursor_rwalk(int n) {
 
     unlink(fname);
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     r = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, test_ft_cursor_keycompare);
     assert(r==0);
@@ -364,8 +344,7 @@ static void test_ft_cursor_rwalk(int n) {
         toku_fill_dbt(&kbt, &k, sizeof k);
         v = i;
         toku_fill_dbt(&vbt, &v, sizeof v);
-        r = toku_ft_insert(brt, &kbt, &vbt, 0);
-        assert(r==0);
+        toku_ft_insert(brt, &kbt, &vbt, 0);
     }
 
     /* walk the tree */
@@ -374,8 +353,7 @@ static void test_ft_cursor_rwalk(int n) {
     r = toku_close_ft_handle_nolsn(brt, 0);
     assert(r==0);
 
-    r = toku_cachetable_close(&ct);
-    assert(r==0);
+    toku_cachetable_close(&ct);
 
 }
 
@@ -420,8 +398,7 @@ static void assert_cursor_walk_inorder(FT_HANDLE brt, int n) {
     if (test_cursor_debug && verbose) printf("\n");
     assert(i == n);
 
-    r = toku_ft_cursor_close(cursor);
-    assert(r==0);
+    toku_ft_cursor_close(cursor);
 }
 
 static void test_ft_cursor_rand(int n) {
@@ -434,8 +411,7 @@ static void test_ft_cursor_rand(int n) {
 
     unlink(fname);
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     r = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, test_ft_cursor_keycompare);
     assert(r==0);
@@ -459,8 +435,7 @@ static void test_ft_cursor_rand(int n) {
                 continue;
 	    }
 	    assert(pair.call_count==0);
-	    r = toku_ft_insert(brt, &kbt, &vbt, 0);
-	    assert(r==0);
+	    toku_ft_insert(brt, &kbt, &vbt, 0);
 	    break;
         }
     }
@@ -471,9 +446,7 @@ static void test_ft_cursor_rand(int n) {
     r = toku_close_ft_handle_nolsn(brt, 0);
     assert(r==0);
 
-    r = toku_cachetable_close(&ct);
-    assert(r==0);
-
+    toku_cachetable_close(&ct);
 }
 
 static void test_ft_cursor_split(int n) {
@@ -488,8 +461,7 @@ static void test_ft_cursor_split(int n) {
 
     unlink(fname);
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     r = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, test_ft_cursor_keycompare);
     assert(r==0);
@@ -503,8 +475,7 @@ static void test_ft_cursor_split(int n) {
         toku_fill_dbt(&kbt, key, strlen(key)+1);
         v = keyseqnum;
         toku_fill_dbt(&vbt, &v, sizeof v);
-        r = toku_ft_insert(brt, &kbt, &vbt, 0);
-        assert(r==0);
+        toku_ft_insert(brt, &kbt, &vbt, 0);
     }
 
     r = toku_ft_cursor(brt, &cursor, NULL, false, false);
@@ -527,8 +498,7 @@ static void test_ft_cursor_split(int n) {
         toku_fill_dbt(&kbt, key, strlen(key)+1);
         v = keyseqnum;
         toku_fill_dbt(&vbt, &v, sizeof v);
-        r = toku_ft_insert(brt, &kbt, &vbt, 0);
-        assert(r==0);
+        toku_ft_insert(brt, &kbt, &vbt, 0);
     }
 
     if (test_cursor_debug && verbose) printf("key: ");
@@ -544,14 +514,12 @@ static void test_ft_cursor_split(int n) {
     }
     if (test_cursor_debug && verbose) printf("\n");
 
-    r = toku_ft_cursor_close(cursor);
-    assert(r==0);
+    toku_ft_cursor_close(cursor);
 
     r = toku_close_ft_handle_nolsn(brt, 0);
     assert(r==0);
 
-    r = toku_cachetable_close(&ct);
-    assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void test_multiple_ft_cursors(int n) {
@@ -564,8 +532,7 @@ static void test_multiple_ft_cursors(int n) {
 
     unlink(fname);
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     r = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, test_ft_cursor_keycompare);
     assert(r==0);
@@ -577,15 +544,13 @@ static void test_multiple_ft_cursors(int n) {
     }
 
     for (i=0; i<n; i++) {
-        r = toku_ft_cursor_close(cursors[i]);
-        assert(r == 0);
+        toku_ft_cursor_close(cursors[i]);
     }
 
     r = toku_close_ft_handle_nolsn(brt, 0);
     assert(r==0);
 
-    r = toku_cachetable_close(&ct);
-    assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static int log16(int n) {
@@ -613,8 +578,7 @@ static void test_multiple_ft_cursor_walk(int n) {
     int nodesize = 1<<12;
     int h = log16(n);
     int cachesize = 2 * h * ncursors * nodesize;
-    r = toku_create_cachetable(&ct, cachesize, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, cachesize, ZERO_LSN, NULL_LOGGER);
 
     r = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, test_ft_cursor_keycompare);
     assert(r==0);
@@ -637,8 +601,7 @@ static void test_multiple_ft_cursor_walk(int n) {
 	    toku_fill_dbt(&key, &k, sizeof k);
 	    toku_fill_dbt(&val, &v, sizeof v);
 
-	    r = toku_ft_insert(brt, &key, &val, 0);
-	    assert(r == 0);
+	    toku_ft_insert(brt, &key, &val, 0);
 	}
 
         /* point cursor i / cursor_gap to the current last key i */
@@ -669,15 +632,13 @@ static void test_multiple_ft_cursor_walk(int n) {
     }
 
     for (i=0; i<ncursors; i++) {
-        r = toku_ft_cursor_close(cursors[i]);
-        assert(r == 0);
+        toku_ft_cursor_close(cursors[i]);
     }
 
     r = toku_close_ft_handle_nolsn(brt, 0);
     assert(r==0);
 
-    r = toku_cachetable_close(&ct);
-    assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void test_ft_cursor_set(int n, int cursor_op) {
@@ -690,8 +651,7 @@ static void test_ft_cursor_set(int n, int cursor_op) {
 
     unlink(fname);
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     r = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, test_ft_cursor_keycompare);
     assert(r==0);
@@ -705,8 +665,7 @@ static void test_ft_cursor_set(int n, int cursor_op) {
 	DBT key,val;
         toku_fill_dbt(&key, &k, sizeof k);
         toku_fill_dbt(&val, &v, sizeof v);
-        r = toku_ft_insert(brt, &key, &val, 0);
-        assert(r == 0);
+        toku_ft_insert(brt, &key, &val, 0);
     }
 
     r = toku_ft_cursor(brt, &cursor, NULL, false, false);
@@ -742,14 +701,12 @@ static void test_ft_cursor_set(int n, int cursor_op) {
 	assert((unsigned int)k==toku_htonl(i));
     }
 
-    r = toku_ft_cursor_close(cursor);
-    assert(r==0);
+    toku_ft_cursor_close(cursor);
 
     r = toku_close_ft_handle_nolsn(brt, 0);
     assert(r==0);
 
-    r = toku_cachetable_close(&ct);
-    assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void test_ft_cursor_set_range(int n) {
@@ -762,8 +719,7 @@ static void test_ft_cursor_set_range(int n) {
 
     unlink(fname);
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     r = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, test_ft_cursor_keycompare);
     assert(r==0);
@@ -778,8 +734,7 @@ static void test_ft_cursor_set_range(int n) {
 	DBT key, val;
         toku_fill_dbt(&key, &k, sizeof k);
         toku_fill_dbt(&val, &v, sizeof v);
-        r = toku_ft_insert(brt, &key, &val, 0);
-        assert(r == 0);
+        toku_ft_insert(brt, &key, &val, 0);
     }
 
     r = toku_ft_cursor(brt, &cursor, NULL, false, false);
@@ -806,14 +761,12 @@ static void test_ft_cursor_set_range(int n) {
         }
     }
 
-    r = toku_ft_cursor_close(cursor);
-    assert(r==0);
+    toku_ft_cursor_close(cursor);
 
     r = toku_close_ft_handle_nolsn(brt, 0);
     assert(r==0);
 
-    r = toku_cachetable_close(&ct);
-    assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void test_ft_cursor_delete(int n) {
@@ -826,8 +779,7 @@ static void test_ft_cursor_delete(int n) {
 
     unlink(fname);
 
-    error = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(error == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     error = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, test_ft_cursor_keycompare);
     assert(error == 0);
@@ -845,8 +797,7 @@ static void test_ft_cursor_delete(int n) {
         v = i;
         toku_fill_dbt(&key, &k, sizeof k);
         toku_fill_dbt(&val, &v, sizeof v);
-        error = toku_ft_insert(brt, &key, &val, 0);
-        assert(error == 0);
+        toku_ft_insert(brt, &key, &val, 0);
     }
 
     /* walk the tree and delete under the cursor */
@@ -867,14 +818,12 @@ static void test_ft_cursor_delete(int n) {
     error = toku_ft_cursor_delete(cursor, 0, null_txn);
     assert(error != 0);
 
-    error = toku_ft_cursor_close(cursor);
-    assert(error == 0);
+    toku_ft_cursor_close(cursor);
 
     error = toku_close_ft_handle_nolsn(brt, 0);
     assert(error == 0);
 
-    error = toku_cachetable_close(&ct);
-    assert(error == 0);
+    toku_cachetable_close(&ct);
 }
 
 static int test_ft_cursor_inc = 1000;
diff --git a/ft/tests/ft-test-header.cc b/ft/tests/ft-test-header.cc
index eeced70c87b..174b3cfcaf8 100644
--- a/ft/tests/ft-test-header.cc
+++ b/ft/tests/ft-test-header.cc
@@ -19,8 +19,7 @@ static void test_header (void) {
     char fname[]= __SRCFILE__ ".ft_handle";
 
     // First create dictionary
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
     r = toku_open_ft_handle(fname, 1, &t, 1024, 256, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     assert(r==0);
@@ -35,12 +34,10 @@ static void test_header (void) {
     ft->in_memory_stats          = (STAT64INFO_S) {10, 11};
     ft->h->on_disk_stats            = (STAT64INFO_S) {20, 21};
     r = toku_close_ft_handle_nolsn(t, 0);     assert(r==0);
-    r = toku_cachetable_close(&ct);
-    assert(r==0);
+    toku_cachetable_close(&ct);
 
     // Now read dictionary back into memory and examine some header fields
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 0, &t, 1024, 256, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     assert(r==0);
 
@@ -53,8 +50,7 @@ static void test_header (void) {
     assert(ft->in_memory_stats.numrows == expected_stats.numrows);
     assert(ft->h->on_disk_stats.numbytes  == expected_stats.numbytes);
     r = toku_close_ft_handle_nolsn(t, 0);     assert(r==0);
-    r = toku_cachetable_close(&ct);
-    assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/ft-test.cc b/ft/tests/ft-test.cc
index 03e77914613..20698dd3ecb 100644
--- a/ft/tests/ft-test.cc
+++ b/ft/tests/ft-test.cc
@@ -16,14 +16,13 @@ static void test_dump_empty_db (void) {
     CACHETABLE ct;
     int r;
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
     r = toku_open_ft_handle(fname, 1, &t, 1024, 256, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     assert(r==0);
     if (verbose) { r=toku_dump_ft(stdout, t); assert(r==0); }
     r = toku_close_ft_handle_nolsn(t, 0);          assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
     
 }
 
@@ -38,7 +37,7 @@ static void test_multiple_files_of_size (int size) {
     unlink(n0);
     unlink(n1);
     
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);   assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(n0, 1, &t0, size, size / 4, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun); assert(r==0);
     r = toku_open_ft_handle(n1, 1, &t1, size, size / 4, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun); assert(r==0);
     for (i=0; i<10000; i++) {
@@ -46,9 +45,9 @@ static void test_multiple_files_of_size (int size) {
 	DBT k,v;
 	snprintf(key, 100, "key%d", i);
 	snprintf(val, 100, "val%d", i);
-	r = toku_ft_insert(t0, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), null_txn); assert(r==0);
+	toku_ft_insert(t0, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), null_txn);
 	snprintf(val, 100, "Val%d", i);
-	r = toku_ft_insert(t1, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), null_txn); assert(r==0);
+	toku_ft_insert(t1, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), null_txn);
     }
     //toku_verify_ft(t0);
     //dump_ft(t0);
@@ -58,11 +57,11 @@ static void test_multiple_files_of_size (int size) {
 
     r = toku_close_ft_handle_nolsn(t0, 0); assert(r==0);
     r = toku_close_ft_handle_nolsn(t1, 0); assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
     
 
     /* Now see if the data is all there. */
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);      assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(n0, 0, &t0, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     if (verbose) printf("%s:%d r=%d\n", __SRCFILE__, __LINE__,r);
     assert(r==0);
@@ -79,7 +78,7 @@ static void test_multiple_files_of_size (int size) {
 
     r = toku_close_ft_handle_nolsn(t0, 0); assert(r==0);
     r = toku_close_ft_handle_nolsn(t1, 0); assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
     
 }
 
@@ -97,7 +96,7 @@ static void test_multiple_ft_handles_one_db_one_file (void) {
     if (verbose) printf("test_multiple_ft_handles_one_db_one_file:");
     
     unlink(fname);
-    r = toku_create_cachetable(&ct, 32, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 32, ZERO_LSN, NULL_LOGGER);
     for (i=0; i<MANYN; i++) {
 	r = toku_open_ft_handle(fname, (i==0), &trees[i], 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
 	assert(r==0);
@@ -107,8 +106,7 @@ static void test_multiple_ft_handles_one_db_one_file (void) {
 	DBT kb, vb;
 	snprintf(k, 20, "key%d", i);
 	snprintf(v, 20, "val%d", i);
-	r = toku_ft_insert(trees[i], toku_fill_dbt(&kb, k, strlen(k)+1), toku_fill_dbt(&vb, v, strlen(v)+1), null_txn);
-	assert(r==0);
+	toku_ft_insert(trees[i], toku_fill_dbt(&kb, k, strlen(k)+1), toku_fill_dbt(&vb, v, strlen(v)+1), null_txn);
     }
     for (i=0; i<MANYN; i++) {
 	char k[20],vexpect[20];
@@ -119,7 +117,7 @@ static void test_multiple_ft_handles_one_db_one_file (void) {
     for (i=0; i<MANYN; i++) {
 	r=toku_close_ft_handle_nolsn(trees[i], 0); assert(r==0);
     }
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
     
     if (verbose) printf(" ok\n");
 }
@@ -137,31 +135,30 @@ static void  test_read_what_was_written (void) {
     unlink(fname);
     
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);       assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);  assert(r==0);
     r = toku_close_ft_handle_nolsn(brt, 0); assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
 
     
 
     /* Now see if we can read an empty tree in. */
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);     assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 0, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);  assert(r==0);
 
     /* See if we can put something in it. */
     {
 	DBT k,v;
-	r = toku_ft_insert(brt, toku_fill_dbt(&k, "hello", 6), toku_fill_dbt(&v, "there", 6), null_txn);
-	assert(r==0);
+	toku_ft_insert(brt, toku_fill_dbt(&k, "hello", 6), toku_fill_dbt(&v, "there", 6), null_txn);
     }
 
     r = toku_close_ft_handle_nolsn(brt, 0); assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
 
     
 
     /* Now see if we can read it in and get the value. */
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 0, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun); assert(r==0);
 
     ft_lookup_and_check_nodup(brt, "hello", "there");
@@ -180,8 +177,7 @@ static void  test_read_what_was_written (void) {
 		int verify_result=toku_verify_ft(brt);;
 		assert(verify_result==0);
 	    }
-	    r = toku_ft_insert(brt, toku_fill_dbt(&k, key, strlen(key)+1), toku_fill_dbt(&v, val, strlen(val)+1), null_txn);
-	    assert(r==0);
+	    toku_ft_insert(brt, toku_fill_dbt(&k, key, strlen(key)+1), toku_fill_dbt(&v, val, strlen(val)+1), null_txn);
 	    if (i<600) {
 		int verify_result=toku_verify_ft(brt);
 		if (verify_result) {
@@ -220,11 +216,11 @@ static void  test_read_what_was_written (void) {
 
     r = toku_close_ft_handle_nolsn(brt, 0); assert(r==0);
     if (verbose) printf("%s:%d About to close %p\n", __SRCFILE__, __LINE__, ct);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
 
     
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 0, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun); assert(r==0);
 
     ft_lookup_and_check_nodup(brt, "hello", "there");
@@ -239,7 +235,7 @@ static void  test_read_what_was_written (void) {
     }
 
     r = toku_close_ft_handle_nolsn(brt, 0); assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
 
     
 
@@ -257,7 +253,7 @@ static void test_cursor_last_empty(void) {
     unlink(fname);
     
     //printf("%s:%d %d alloced\n", __SRCFILE__, __LINE__, toku_get_n_items_malloced()); toku_print_malloced_items();
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);       assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     //printf("%s:%d %d alloced\n", __SRCFILE__, __LINE__, toku_get_n_items_malloced()); toku_print_malloced_items();
     r = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);  assert(r==0);
     //printf("%s:%d %d alloced\n", __SRCFILE__, __LINE__, toku_get_n_items_malloced()); toku_print_malloced_items();
@@ -274,11 +270,10 @@ static void test_cursor_last_empty(void) {
 	assert(pair.call_count==0);
 	assert(r==DB_NOTFOUND);
     }
-    r = toku_ft_cursor_close(cursor);
-    assert_zero(r);
+    toku_ft_cursor_close(cursor);
     r = toku_close_ft_handle_nolsn(brt, 0);
     //printf("%s:%d %d alloced\n", __SRCFILE__, __LINE__, toku_get_n_items_malloced()); toku_print_malloced_items();
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
     //printf("%s:%d %d alloced\n", __SRCFILE__, __LINE__, toku_get_n_items_malloced()); toku_print_malloced_items();
     
 }
@@ -292,12 +287,12 @@ static void test_cursor_next (void) {
 
     unlink(fname);
     
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);       assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     //printf("%s:%d %d alloced\n", __SRCFILE__, __LINE__, toku_get_n_items_malloced()); toku_print_malloced_items();
     r = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);  assert(r==0);
     //printf("%s:%d %d alloced\n", __SRCFILE__, __LINE__, toku_get_n_items_malloced()); toku_print_malloced_items();
-    r = toku_ft_insert(brt, toku_fill_dbt(&kbt, "hello", 6), toku_fill_dbt(&vbt, "there", 6), null_txn);
-    r = toku_ft_insert(brt, toku_fill_dbt(&kbt, "byebye", 7), toku_fill_dbt(&vbt, "byenow", 7), null_txn);
+    toku_ft_insert(brt, toku_fill_dbt(&kbt, "hello", 6), toku_fill_dbt(&vbt, "there", 6), null_txn);
+    toku_ft_insert(brt, toku_fill_dbt(&kbt, "byebye", 7), toku_fill_dbt(&vbt, "byenow", 7), null_txn);
     if (verbose) printf("%s:%d calling toku_ft_cursor(...)\n", __SRCFILE__, __LINE__);
     r = toku_ft_cursor(brt, &cursor, NULL, false, false);            assert(r==0);
     toku_init_dbt(&kbt);
@@ -327,11 +322,10 @@ static void test_cursor_next (void) {
 	assert(pair.call_count==0);
     }
 
-    r = toku_ft_cursor_close(cursor);
-    assert_zero(r);
+    toku_ft_cursor_close(cursor);
     r = toku_close_ft_handle_nolsn(brt, 0);
     //printf("%s:%d %d alloced\n", __SRCFILE__, __LINE__, toku_get_n_items_malloced()); toku_print_malloced_items();
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
     //printf("%s:%d %d alloced\n", __SRCFILE__, __LINE__, toku_get_n_items_malloced()); toku_print_malloced_items();
     
 
@@ -369,7 +363,7 @@ static void test_wrongendian_compare (int wrong_p, unsigned int N) {
 	assert(wrong_compare_fun(NULL, toku_fill_dbt(&at, b, 4), toku_fill_dbt(&bt, a, 4))<0);
     }
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);       assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     //printf("%s:%d WRONG=%d\n", __SRCFILE__, __LINE__, wrong_p);
 
     if (0) { // ???? Why is this commented out?
@@ -388,8 +382,7 @@ static void test_wrongendian_compare (int wrong_p, unsigned int N) {
 	    printf("%s:%d insert: %02x%02x%02x%02x -> %02x%02x%02x%02x\n", __SRCFILE__, __LINE__,
 		   ((char*)kbt.data)[0], ((char*)kbt.data)[1], ((char*)kbt.data)[2], ((char*)kbt.data)[3],
 		   ((char*)vbt.data)[0], ((char*)vbt.data)[1], ((char*)vbt.data)[2], ((char*)vbt.data)[3]);
-	r = toku_ft_insert(brt, &kbt, &vbt, null_txn);
-	assert(r==0);
+	toku_ft_insert(brt, &kbt, &vbt, null_txn);
     }
     {
 	FT_CURSOR cursor=0;
@@ -430,8 +423,7 @@ static void test_wrongendian_compare (int wrong_p, unsigned int N) {
 	    if (0) printf("%s:%d insert: %02x%02x%02x%02x -> %02x%02x%02x%02x\n", __SRCFILE__, __LINE__,
 			  ((unsigned char*)kbt.data)[0], ((unsigned char*)kbt.data)[1], ((unsigned char*)kbt.data)[2], ((unsigned char*)kbt.data)[3],
 			  ((unsigned char*)vbt.data)[0], ((unsigned char*)vbt.data)[1], ((unsigned char*)vbt.data)[2], ((unsigned char*)vbt.data)[3]);
-	    r = toku_ft_insert(brt, &kbt, &vbt, null_txn);
-	    assert(r==0);
+	    toku_ft_insert(brt, &kbt, &vbt, null_txn);
 	    toku_cachetable_verify(ct);
 	}
 	FT_CURSOR cursor=0;
@@ -449,12 +441,11 @@ static void test_wrongendian_compare (int wrong_p, unsigned int N) {
 	    assert(pair.call_count==1);
 	    toku_cachetable_verify(ct);
 	}
-        r = toku_ft_cursor_close(cursor);
-        assert_zero(r);
+        toku_ft_cursor_close(cursor);
 	r = toku_close_ft_handle_nolsn(brt, 0);
 	assert(r==0);
     }
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
     
 }
 
@@ -469,8 +460,7 @@ static void test_large_kv(int bsize, int ksize, int vsize) {
 
     if (verbose) printf("test_large_kv: %d %d %d\n", bsize, ksize, vsize);
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
     r = toku_open_ft_handle(fname, 1, &t, bsize, bsize / 4, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     assert(r==0);
@@ -482,14 +472,13 @@ static void test_large_kv(int bsize, int ksize, int vsize) {
     toku_fill_dbt(&key, k, ksize);
     toku_fill_dbt(&val, v, vsize);
 
-    r = toku_ft_insert(t, &key, &val, 0);
-    assert(r == 0);
+    toku_ft_insert(t, &key, &val, 0);
 
     toku_free(k);
     toku_free(v);
 
     r = toku_close_ft_handle_nolsn(t, 0);        assert(r==0);
-    r = toku_cachetable_close(&ct);     assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 /*
@@ -515,8 +504,7 @@ static void test_ft_delete_empty(void) {
     int r;
     CACHETABLE ct;
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
     r = toku_open_ft_handle(fname, 1, &t, 4096, 1024, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     assert(r==0);
@@ -524,11 +512,10 @@ static void test_ft_delete_empty(void) {
     DBT key;
     int k = toku_htonl(1);
     toku_fill_dbt(&key, &k, sizeof k);
-    r = toku_ft_delete(t, &key, null_txn);
-    assert(r == 0);
+    toku_ft_delete(t, &key, null_txn);
 
     r = toku_close_ft_handle_nolsn(t, 0);        assert(r==0);
-    r = toku_cachetable_close(&ct);     assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 /*
@@ -543,8 +530,7 @@ static void test_ft_delete_present(int n) {
     CACHETABLE ct;
     int i;
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
     r = toku_open_ft_handle(fname, 1, &t, 4096, 1024, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     assert(r==0);
@@ -557,8 +543,7 @@ static void test_ft_delete_present(int n) {
         toku_fill_dbt(&key, &k, sizeof k);
 	DBT val;
         toku_fill_dbt(&val, &v, sizeof v);
-        r = toku_ft_insert(t, &key, &val, 0);
-        assert(r == 0);
+        toku_ft_insert(t, &key, &val, 0);
     }
 
     /* delete 0 .. n-1 */
@@ -566,7 +551,7 @@ static void test_ft_delete_present(int n) {
         int k = toku_htonl(i);
 	DBT key;
         toku_fill_dbt(&key, &k, sizeof k);
-        r = toku_ft_delete(t, &key, null_txn);
+        toku_ft_delete(t, &key, null_txn);
         assert(r == 0);
     }
 
@@ -594,11 +579,10 @@ static void test_ft_delete_present(int n) {
 	assert(pair.call_count==0);
     }
 
-    r = toku_ft_cursor_close(cursor);
-    assert(r == 0);
+    toku_ft_cursor_close(cursor);
 
     r = toku_close_ft_handle_nolsn(t, 0);        assert(r==0);
-    r = toku_cachetable_close(&ct);     assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void test_ft_delete_not_present(int n) {
@@ -609,8 +593,7 @@ static void test_ft_delete_not_present(int n) {
     CACHETABLE ct;
     int i;
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
     r = toku_open_ft_handle(fname, 1, &t, 4096, 1024, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     assert(r==0);
@@ -623,28 +606,27 @@ static void test_ft_delete_not_present(int n) {
         k = toku_htonl(i); v = i;
         toku_fill_dbt(&key, &k, sizeof k);
         toku_fill_dbt(&val, &v, sizeof v);
-        r = toku_ft_insert(t, &key, &val, 0);
-        assert(r == 0);
+        toku_ft_insert(t, &key, &val, 0);
     }
 
     /* delete 0 .. n-1 */
     for (i=0; i<n; i++) {
         k = toku_htonl(i);
         toku_fill_dbt(&key, &k, sizeof k);
-        r = toku_ft_delete(t, &key, null_txn);
+        toku_ft_delete(t, &key, null_txn);
         assert(r == 0);
     }
 
     /* try to delete key n+1 not in the tree */
     k = toku_htonl(n+1);
     toku_fill_dbt(&key, &k, sizeof k);
-    r = toku_ft_delete(t, &key, null_txn);
+    toku_ft_delete(t, &key, null_txn);
     /* the delete may be buffered or may be executed on a leaf node, so the
        return value depends */
     if (verbose) printf("toku_ft_delete k=%d %d\n", k, r);
 
     r = toku_close_ft_handle_nolsn(t, 0);        assert(r==0);
-    r = toku_cachetable_close(&ct);     assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void test_ft_delete_cursor_first(int n) {
@@ -655,8 +637,7 @@ static void test_ft_delete_cursor_first(int n) {
     CACHETABLE ct;
     int i;
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
     r = toku_open_ft_handle(fname, 1, &t, 4096, 1024, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     assert(r==0);
@@ -669,8 +650,7 @@ static void test_ft_delete_cursor_first(int n) {
         toku_fill_dbt(&key, &k, sizeof k);
 	DBT val;
         toku_fill_dbt(&val, &v, sizeof v);
-        r = toku_ft_insert(t, &key, &val, 0);
-        assert(r == 0);
+        toku_ft_insert(t, &key, &val, 0);
     }
 
     /* lookups 0 .. n-1 should succeed */
@@ -692,8 +672,7 @@ static void test_ft_delete_cursor_first(int n) {
 	    int k = toku_htonl(i);
 	    DBT key;
             toku_fill_dbt(&key, &k, sizeof k);
-	    r = toku_ft_delete(t, &key, null_txn);
-	    assert(r == 0);
+	    toku_ft_delete(t, &key, null_txn);
 	}
 
 	{
@@ -733,11 +712,10 @@ static void test_ft_delete_cursor_first(int n) {
 	assert(pair.call_count==1);
     }
 
-    r = toku_ft_cursor_close(cursor);
-    assert(r == 0);
+    toku_ft_cursor_close(cursor);
 
     r = toku_close_ft_handle_nolsn(t, 0);        assert(r==0);
-    r = toku_cachetable_close(&ct);     assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 /* test for bug: insert cmd in a nonleaf node, delete removes the
@@ -754,8 +732,7 @@ static void test_insert_delete_lookup(int n) {
     CACHETABLE ct;
     int i;
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
     r = toku_open_ft_handle(fname, 1, &t, 4096, 1024, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     assert(r==0);
@@ -768,8 +745,7 @@ static void test_insert_delete_lookup(int n) {
         toku_fill_dbt(&key, &k, sizeof k);
 	DBT val;
         toku_fill_dbt(&val, &v, sizeof v);
-        r = toku_ft_insert(t, &key, &val, 0);
-        assert(r == 0);
+        toku_ft_insert(t, &key, &val, 0);
     }
 
     if (n > 0) {
@@ -777,8 +753,7 @@ static void test_insert_delete_lookup(int n) {
 	    int k = toku_htonl(n-1);
 	    DBT key;
             toku_fill_dbt(&key, &k, sizeof k);
-	    r = toku_ft_delete(t, &key, null_txn);
-	    assert(r == 0);
+	    toku_ft_delete(t, &key, null_txn);
 	}
 	{
 	    int k = toku_htonl(n-1);
@@ -792,7 +767,7 @@ static void test_insert_delete_lookup(int n) {
     }
 
     r = toku_close_ft_handle_nolsn(t, 0);        assert(r==0);
-    r = toku_cachetable_close(&ct);     assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 /* insert <0,0>, <0,1>, .. <0,n>
@@ -822,7 +797,7 @@ static void test_new_ft_cursor_create_close (void) {
     int n = 8;
     FT_CURSOR cursors[n];
 
-    r = toku_ft_handle_create(&brt); assert(r == 0);
+    toku_ft_handle_create(&brt);
 
     int i;
     for (i=0; i<n; i++) {
@@ -830,7 +805,7 @@ static void test_new_ft_cursor_create_close (void) {
     }
 
     for (i=0; i<n; i++) {
-        r = toku_ft_cursor_close(cursors[i]); assert(r == 0);
+        toku_ft_cursor_close(cursors[i]);
     }
 
     r = toku_close_ft_handle_nolsn(brt, 0); assert(r == 0);
@@ -844,9 +819,9 @@ static void test_new_ft_cursor_first(int n) {
     CACHETABLE ct;
     int i;
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
-    r = toku_ft_handle_create(&t); assert(r == 0);
+    toku_ft_handle_create(&t);
     toku_ft_handle_set_nodesize(t, 4096);
     r = toku_ft_handle_open(t, fname, 1, 1, ct, null_txn); assert(r==0);
 
@@ -855,7 +830,7 @@ static void test_new_ft_cursor_first(int n) {
 
     for (i=0; i<n; i++) {
         k = toku_htonl(i); v = toku_htonl(i);
-        r = toku_ft_insert(t, toku_fill_dbt(&key, &k, sizeof k), toku_fill_dbt(&val, &v, sizeof v), 0); assert(r == 0);
+        toku_ft_insert(t, toku_fill_dbt(&key, &k, sizeof k), toku_fill_dbt(&val, &v, sizeof v), 0); assert(r == 0);
     }
 
     FT_CURSOR cursor=0;
@@ -883,9 +858,9 @@ static void test_new_ft_cursor_first(int n) {
     if (key.data) toku_free(key.data);
     if (val.data) toku_free(val.data);
 
-    r = toku_ft_cursor_close(cursor); assert(r == 0);
+    toku_ft_cursor_close(cursor);
     r = toku_close_ft_handle_nolsn(t, 0); assert(r==0);
-    r = toku_cachetable_close(&ct);assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void test_new_ft_cursor_last(int n) {
@@ -896,9 +871,9 @@ static void test_new_ft_cursor_last(int n) {
     CACHETABLE ct;
     int i;
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
-    r = toku_ft_handle_create(&t); assert(r == 0);
+    toku_ft_handle_create(&t);
     toku_ft_handle_set_nodesize(t, 4096);
     r = toku_ft_handle_open(t, fname, 1, 1, ct, null_txn); assert(r==0);
 
@@ -907,7 +882,7 @@ static void test_new_ft_cursor_last(int n) {
 
     for (i=0; i<n; i++) {
         k = toku_htonl(i); v = toku_htonl(i);
-        r = toku_ft_insert(t, toku_fill_dbt(&key, &k, sizeof k), toku_fill_dbt(&val, &v, sizeof v), 0); assert(r == 0);
+        toku_ft_insert(t, toku_fill_dbt(&key, &k, sizeof k), toku_fill_dbt(&val, &v, sizeof v), 0); assert(r == 0);
     }
 
     FT_CURSOR cursor=0;
@@ -936,9 +911,9 @@ static void test_new_ft_cursor_last(int n) {
     if (key.data) toku_free(key.data);
     if (val.data) toku_free(val.data);
 
-    r = toku_ft_cursor_close(cursor); assert(r == 0);
+    toku_ft_cursor_close(cursor);
     r = toku_close_ft_handle_nolsn(t, 0); assert(r==0);
-    r = toku_cachetable_close(&ct);assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void test_new_ft_cursor_next(int n) {
@@ -949,9 +924,9 @@ static void test_new_ft_cursor_next(int n) {
     CACHETABLE ct;
     int i;
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
-    r = toku_ft_handle_create(&t); assert(r == 0);
+    toku_ft_handle_create(&t);
     toku_ft_handle_set_nodesize(t, 4096);
     r = toku_ft_handle_open(t, fname, 1, 1, ct, null_txn); assert(r==0);
 
@@ -959,7 +934,7 @@ static void test_new_ft_cursor_next(int n) {
 	DBT key, val;
 	int k = toku_htonl(i);
 	int v = toku_htonl(i);
-        r = toku_ft_insert(t, toku_fill_dbt(&key, &k, sizeof k), toku_fill_dbt(&val, &v, sizeof v), 0); assert(r == 0);
+        toku_ft_insert(t, toku_fill_dbt(&key, &k, sizeof k), toku_fill_dbt(&val, &v, sizeof v), 0); assert(r == 0);
     }
 
     FT_CURSOR cursor=0;
@@ -979,9 +954,9 @@ static void test_new_ft_cursor_next(int n) {
     }
     assert(i == n);
 
-    r = toku_ft_cursor_close(cursor); assert(r == 0);
+    toku_ft_cursor_close(cursor);
     r = toku_close_ft_handle_nolsn(t, 0); assert(r==0);
-    r = toku_cachetable_close(&ct);assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void test_new_ft_cursor_prev(int n) {
@@ -992,9 +967,9 @@ static void test_new_ft_cursor_prev(int n) {
     CACHETABLE ct;
     int i;
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
-    r = toku_ft_handle_create(&t); assert(r == 0);
+    toku_ft_handle_create(&t);
     toku_ft_handle_set_nodesize(t, 4096);
     r = toku_ft_handle_open(t, fname, 1, 1, ct, null_txn); assert(r==0);
 
@@ -1002,7 +977,7 @@ static void test_new_ft_cursor_prev(int n) {
 	DBT key, val;
         int k = toku_htonl(i);
 	int v = toku_htonl(i);
-        r = toku_ft_insert(t, toku_fill_dbt(&key, &k, sizeof k), toku_fill_dbt(&val, &v, sizeof v), 0); assert(r == 0);
+        toku_ft_insert(t, toku_fill_dbt(&key, &k, sizeof k), toku_fill_dbt(&val, &v, sizeof v), 0); assert(r == 0);
     }
 
     FT_CURSOR cursor=0;
@@ -1022,9 +997,9 @@ static void test_new_ft_cursor_prev(int n) {
     }
     assert(i == -1);
 
-    r = toku_ft_cursor_close(cursor); assert(r == 0);
+    toku_ft_cursor_close(cursor);
     r = toku_close_ft_handle_nolsn(t, 0); assert(r==0);
-    r = toku_cachetable_close(&ct);assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void test_new_ft_cursor_current(int n) {
@@ -1035,9 +1010,9 @@ static void test_new_ft_cursor_current(int n) {
     CACHETABLE ct;
     int i;
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
-    r = toku_ft_handle_create(&t); assert(r == 0);
+    toku_ft_handle_create(&t);
     toku_ft_handle_set_nodesize(t, 4096);
     r = toku_ft_handle_open(t, fname, 1, 1, ct, null_txn); assert(r==0);
 
@@ -1045,7 +1020,7 @@ static void test_new_ft_cursor_current(int n) {
         int k = toku_htonl(i);
 	int v = toku_htonl(i);
 	DBT key, val;
-        r = toku_ft_insert(t, toku_fill_dbt(&key, &k, sizeof k), toku_fill_dbt(&val, &v, sizeof v), 0); assert(r == 0);
+        toku_ft_insert(t, toku_fill_dbt(&key, &k, sizeof k), toku_fill_dbt(&val, &v, sizeof v), 0); assert(r == 0);
     }
 
     FT_CURSOR cursor=0;
@@ -1104,9 +1079,9 @@ static void test_new_ft_cursor_current(int n) {
     }
     assert(i == n);
 
-    r = toku_ft_cursor_close(cursor); assert(r == 0);
+    toku_ft_cursor_close(cursor);
     r = toku_close_ft_handle_nolsn(t, 0); assert(r==0);
-    r = toku_cachetable_close(&ct);assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void test_new_ft_cursor_set_range(int n) {
@@ -1117,9 +1092,9 @@ static void test_new_ft_cursor_set_range(int n) {
     FT_HANDLE brt=0;
     FT_CURSOR cursor=0;
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
-    r = toku_ft_handle_create(&brt); assert(r == 0);
+    toku_ft_handle_create(&brt);
     toku_ft_handle_set_nodesize(brt, 4096);
     r = toku_ft_handle_open(brt, fname, 1, 1, ct, null_txn); assert(r==0);
 
@@ -1131,7 +1106,7 @@ static void test_new_ft_cursor_set_range(int n) {
 	DBT key, val;
         int k = toku_htonl(10*i);
         int v = 10*i;
-        r = toku_ft_insert(brt, toku_fill_dbt(&key, &k, sizeof k), toku_fill_dbt(&val, &v, sizeof v), 0); assert(r == 0);
+        toku_ft_insert(brt, toku_fill_dbt(&key, &k, sizeof k), toku_fill_dbt(&val, &v, sizeof v), 0); assert(r == 0);
     }
 
     r = toku_ft_cursor(brt, &cursor, NULL, false, false); assert(r==0);
@@ -1161,11 +1136,11 @@ static void test_new_ft_cursor_set_range(int n) {
         }
     }
 
-    r = toku_ft_cursor_close(cursor); assert(r==0);
+    toku_ft_cursor_close(cursor);
 
     r = toku_close_ft_handle_nolsn(brt, 0); assert(r==0);
 
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void test_new_ft_cursor_set(int n, int cursor_op, DB *db) {
@@ -1178,7 +1153,7 @@ static void test_new_ft_cursor_set(int n, int cursor_op, DB *db) {
 
     unlink(fname);
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     r = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, test_ft_cursor_keycompare); assert(r==0);
 
@@ -1189,7 +1164,7 @@ static void test_new_ft_cursor_set(int n, int cursor_op, DB *db) {
 	DBT key, val;
         int k = toku_htonl(10*i);
         int v = 10*i;
-        r = toku_ft_insert(brt, toku_fill_dbt(&key, &k, sizeof k), toku_fill_dbt(&val, &v, sizeof v), 0); assert(r == 0);
+        toku_ft_insert(brt, toku_fill_dbt(&key, &k, sizeof k), toku_fill_dbt(&val, &v, sizeof v), 0); assert(r == 0);
     }
 
     r = toku_ft_cursor(brt, &cursor, NULL, false, false); assert(r==0);
@@ -1222,11 +1197,11 @@ static void test_new_ft_cursor_set(int n, int cursor_op, DB *db) {
         assert(key.data == &k);
     }
 
-    r = toku_ft_cursor_close(cursor); assert(r==0);
+    toku_ft_cursor_close(cursor);
 
     r = toku_close_ft_handle_nolsn(brt, 0); assert(r==0);
 
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void test_new_ft_cursors(void) {
diff --git a/ft/tests/ft-test0.cc b/ft/tests/ft-test0.cc
index 8205cca4c90..58db9680116 100644
--- a/ft/tests/ft-test0.cc
+++ b/ft/tests/ft-test0.cc
@@ -16,8 +16,7 @@ static void test0 (void) {
     char fname[]= __SRCFILE__ ".ft_handle";
     if (verbose) printf("%s:%d test0\n", __SRCFILE__, __LINE__);
     
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     if (verbose) printf("%s:%d test0\n", __SRCFILE__, __LINE__);
     unlink(fname);
     r = toku_open_ft_handle(fname, 1, &t, 1024, 256, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
@@ -26,9 +25,7 @@ static void test0 (void) {
     //printf("%s:%d n_items_malloced=%lld\n", __SRCFILE__, __LINE__, n_items_malloced);
     r = toku_close_ft_handle_nolsn(t, 0);     assert(r==0);
     //printf("%s:%d n_items_malloced=%lld\n", __SRCFILE__, __LINE__, n_items_malloced);
-    r = toku_cachetable_close(&ct);
-    assert(r==0);
-    
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/ft-test1.cc b/ft/tests/ft-test1.cc
index d9e199be9f2..aef1d3c637f 100644
--- a/ft/tests/ft-test1.cc
+++ b/ft/tests/ft-test1.cc
@@ -16,12 +16,11 @@ static void test1 (void) {
     char fname[]= __SRCFILE__ ".ft_handle";
     DBT k,v;
     
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
     r = toku_open_ft_handle(fname, 1, &t, 1024, 256, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     assert(r==0);
-    r = toku_ft_insert(t, toku_fill_dbt(&k, "hello", 6), toku_fill_dbt(&v, "there", 6), null_txn);
+    toku_ft_insert(t, toku_fill_dbt(&k, "hello", 6), toku_fill_dbt(&v, "there", 6), null_txn);
     assert(r==0);
     {
 	struct check_pair pair = {6, "hello", 6, "there", 0};
@@ -30,7 +29,7 @@ static void test1 (void) {
 	assert(pair.call_count==1);
     }
     r = toku_close_ft_handle_nolsn(t, 0);              assert(r==0);
-    r = toku_cachetable_close(&ct);     assert(r==0);
+    toku_cachetable_close(&ct);
     
     if (verbose) printf("test1 ok\n");
 }
diff --git a/ft/tests/ft-test2.cc b/ft/tests/ft-test2.cc
index 2131c9fd205..5e5c4376bc9 100644
--- a/ft/tests/ft-test2.cc
+++ b/ft/tests/ft-test2.cc
@@ -17,7 +17,7 @@ static void test2 (int limit) {
     char fname[]= __SRCFILE__ ".ft_handle";
     if (verbose) printf("%s:%d checking\n", __SRCFILE__, __LINE__);
     
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
     r = toku_open_ft_handle(fname, 1, &t, 1024, 256, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     if (verbose) printf("%s:%d did setup\n", __SRCFILE__, __LINE__);
@@ -27,7 +27,7 @@ static void test2 (int limit) {
 	char key[100],val[100];
 	snprintf(key,100,"hello%d",i);
 	snprintf(val,100,"there%d",i);
-	r = toku_ft_insert(t, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), null_txn);
+	toku_ft_insert(t, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), null_txn);
 	assert(r==0);
 	r = toku_verify_ft(t); assert(r==0);
 	//printf("%s:%d did insert %d\n", __SRCFILE__, __LINE__, i);
@@ -35,7 +35,7 @@ static void test2 (int limit) {
     if (verbose) printf("%s:%d inserted\n", __SRCFILE__, __LINE__);
     r = toku_verify_ft(t); assert(r==0);
     r = toku_close_ft_handle_nolsn(t, 0);              assert(r==0);
-    r = toku_cachetable_close(&ct);     assert(r==0);
+    toku_cachetable_close(&ct);
     
     if (verbose) printf("test2 ok\n");
 }
diff --git a/ft/tests/ft-test3.cc b/ft/tests/ft-test3.cc
index 97e72a160cb..97efc7476e1 100644
--- a/ft/tests/ft-test3.cc
+++ b/ft/tests/ft-test3.cc
@@ -21,7 +21,7 @@ static void test3 (int nodesize, int basementnodesize, int count) {
     int i;
     CACHETABLE ct;
     
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     gettimeofday(&t0, 0);
     unlink(fname);
     r = toku_open_ft_handle(fname, 1, &t, nodesize, basementnodesize, compression_method, ct, null_txn, toku_builtin_compare_fun);
@@ -31,12 +31,11 @@ static void test3 (int nodesize, int basementnodesize, int count) {
 	DBT k,v;
 	snprintf(key,100,"hello%d",i);
 	snprintf(val,100,"there%d",i);
-	r = toku_ft_insert(t, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), null_txn);
-	assert(r==0);
+	toku_ft_insert(t, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), null_txn);
     }
     r = toku_verify_ft(t); assert(r==0);
     r = toku_close_ft_handle_nolsn(t, 0);        assert(r==0);
-    r = toku_cachetable_close(&ct);     assert(r==0);
+    toku_cachetable_close(&ct);
     
     gettimeofday(&t1, 0);
     {
diff --git a/ft/tests/ft-test4.cc b/ft/tests/ft-test4.cc
index 4d78f49347f..3ee7da9e0b0 100644
--- a/ft/tests/ft-test4.cc
+++ b/ft/tests/ft-test4.cc
@@ -21,7 +21,7 @@ static void test4 (int nodesize, int count) {
     gettimeofday(&t0, 0);
     unlink(fname);
     
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);         assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 1, &t, nodesize, nodesize / 8, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun); assert(r==0);
     for (i=0; i<count; i++) {
 	char key[100],val[100];
@@ -29,12 +29,11 @@ static void test4 (int nodesize, int count) {
 	DBT k,v;
 	snprintf(key,100,"hello%d",rv);
 	snprintf(val,100,"there%d",i);
-	r = toku_ft_insert(t, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), null_txn);
-	assert(r==0);
+	toku_ft_insert(t, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), null_txn);
     }
     r = toku_verify_ft(t); assert(r==0);
     r = toku_close_ft_handle_nolsn(t, 0);        assert(r==0);
-    r = toku_cachetable_close(&ct);     assert(r==0);
+    toku_cachetable_close(&ct);
     
     gettimeofday(&t1, 0);
     {
diff --git a/ft/tests/ft-test5.cc b/ft/tests/ft-test5.cc
index 958e8e03703..63a9ebd13aa 100644
--- a/ft/tests/ft-test5.cc
+++ b/ft/tests/ft-test5.cc
@@ -21,7 +21,7 @@ static void test5 (void) {
     MALLOC_N(limit,values);
     for (i=0; i<limit; i++) values[i]=-1;
     unlink(fname);
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);        assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 1, &t, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);   assert(r==0);
     for (i=0; i<limit/2; i++) {
 	char key[100],val[100];
@@ -32,8 +32,7 @@ static void test5 (void) {
 	snprintf(key, 100, "key%d", rk);
 	snprintf(val, 100, "val%d", rv);
 	DBT k,v;
-	r = toku_ft_insert(t, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), null_txn);
-	assert(r==0);
+	toku_ft_insert(t, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), null_txn);
     }
     if (verbose) printf("\n");
     for (i=0; i<limit/2; i++) {
@@ -54,7 +53,7 @@ static void test5 (void) {
     toku_free(values);
     r = toku_verify_ft(t);         assert(r==0);
     r = toku_close_ft_handle_nolsn(t, 0);       assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
     
 }
 
diff --git a/ft/tests/ftloader-test-merge-files-dbufio.cc b/ft/tests/ftloader-test-merge-files-dbufio.cc
index 2acf692bec2..ac4d12b6b64 100644
--- a/ft/tests/ftloader-test-merge-files-dbufio.cc
+++ b/ft/tests/ftloader-test-merge-files-dbufio.cc
@@ -313,8 +313,7 @@ static void test (const char *directory, bool is_error) {
     CACHETABLE ct;
     enum {CACHETABLE_SIZE = 64*1024};
     {
-	int r = toku_create_cachetable(&ct, CACHETABLE_SIZE, (LSN){1}, NULL);
-	assert(r==0);
+	toku_cachetable_create(&ct, CACHETABLE_SIZE, (LSN){1}, NULL);
     }
     LSN *XMALLOC(lsnp);
     {
@@ -426,8 +425,7 @@ static void test (const char *directory, bool is_error) {
     }
     toku_ft_loader_internal_destroy(bl, false);
     {
-	int r = toku_cachetable_close(&ct);
-	assert(r==0);
+	toku_cachetable_close(&ct);
     }
     for (int i=0; i<N_DEST_DBS; i++) {
 	toku_free((void*)new_fnames_in_env[i]);
diff --git a/ft/tests/ftloader-test-vm.cc b/ft/tests/ftloader-test-vm.cc
index ba3d2ac92ab..5fedfe32b7d 100644
--- a/ft/tests/ftloader-test-vm.cc
+++ b/ft/tests/ftloader-test-vm.cc
@@ -12,8 +12,7 @@
 static void test_cachetable_reservation (long size) {
     CACHETABLE ct;
     {
-        int r = toku_create_cachetable(&ct, size, ZERO_LSN, NULL);
-        assert(r==0);
+        toku_cachetable_create(&ct, size, ZERO_LSN, NULL);
     }
     {
         uint64_t r0 = toku_cachetable_reserve_memory(ct, 0.5);
@@ -38,8 +37,7 @@ static void test_cachetable_reservation (long size) {
         toku_cachetable_release_reserved_memory(ct, r2);
     }
     {
-        int r = toku_cachetable_close(&ct);
-        assert(r==0);
+        toku_cachetable_close(&ct);
     }
     
 }
diff --git a/ft/tests/ftloader-test-writer.cc b/ft/tests/ftloader-test-writer.cc
index bd4b024a46f..e29106e8aea 100644
--- a/ft/tests/ftloader-test-writer.cc
+++ b/ft/tests/ftloader-test-writer.cc
@@ -43,13 +43,12 @@ static void verify_dbfile(int n, const char *name) {
     int r;
 
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     TOKUTXN const null_txn = NULL;
     FT_HANDLE t = NULL;
-    r = toku_ft_handle_create(&t); assert(r == 0);
-    r = toku_ft_set_bt_compare(t, compare_ints);
-    assert(r==0);
+    toku_ft_handle_create(&t);
+    toku_ft_set_bt_compare(t, compare_ints);
     r = toku_ft_handle_open(t, name, 0, 0, ct, null_txn); assert(r==0);
 
     if (verbose) traceit("Verifying brt internals");
@@ -76,14 +75,14 @@ static void verify_dbfile(int n, const char *name) {
 
     assert(i == n);
 
-    r = toku_ft_cursor_close(cursor); assert(r == 0);
+    toku_ft_cursor_close(cursor);
 
     struct ftstat64_s s;
-    r = toku_ft_handle_stat64(t, NULL, &s); assert(r == 0);
+    toku_ft_handle_stat64(t, NULL, &s);
     assert(s.nkeys == (uint64_t)n && s.ndata == (uint64_t)n && s.dsize == userdata);
 
     r = toku_close_ft_handle_nolsn(t, 0); assert(r==0);
-    r = toku_cachetable_close(&ct);assert(r==0);
+    toku_cachetable_close(&ct);
     if (verbose) traceit("verify done");
 }
 
diff --git a/ft/tests/ftloader-test.cc b/ft/tests/ftloader-test.cc
index 8b959c3f9ea..48a77b566bf 100644
--- a/ft/tests/ftloader-test.cc
+++ b/ft/tests/ftloader-test.cc
@@ -249,12 +249,12 @@ static void verify_dbfile(int n, int sorted_keys[], const char *sorted_vals[], c
     int r;
 
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     TOKUTXN const null_txn = NULL;
     FT_HANDLE t = NULL;
-    r = toku_ft_handle_create(&t); assert(r == 0);
-    r = toku_ft_set_bt_compare(t, compare_ints); assert(r==0);
+    toku_ft_handle_create(&t);
+    toku_ft_set_bt_compare(t, compare_ints);
     r = toku_ft_handle_open(t, name, 0, 0, ct, null_txn); assert(r==0);
 
     FT_CURSOR cursor = NULL;
@@ -277,14 +277,14 @@ static void verify_dbfile(int n, int sorted_keys[], const char *sorted_vals[], c
     r = toku_ft_cursor_get(cursor, NULL, lookup_checkf, &pair, DB_NEXT);
     assert(r != 0);
 
-    r = toku_ft_cursor_close(cursor); assert(r == 0);
+    toku_ft_cursor_close(cursor);
 
     struct ftstat64_s s;
-    r = toku_ft_handle_stat64(t, NULL, &s); assert(r == 0);
+    toku_ft_handle_stat64(t, NULL, &s);
     assert(s.nkeys == (uint64_t) n && s.ndata == (uint64_t) n && s.dsize == userdata);
     
     r = toku_close_ft_handle_nolsn(t, 0); assert(r==0);
-    r = toku_cachetable_close(&ct);assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void test_merge_files (const char *tf_template, const char *output_name) {
diff --git a/ft/tests/is_empty.cc b/ft/tests/is_empty.cc
index 0936d149904..d41ac7c5fc9 100644
--- a/ft/tests/is_empty.cc
+++ b/ft/tests/is_empty.cc
@@ -26,7 +26,7 @@ static void test_it (int N) {
 
 
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, logger);                                               CKERR(r);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, logger);
     toku_cachetable_set_env_dir(ct, TESTDIR);
 
     toku_logger_set_cachetable(logger, ct);
@@ -58,7 +58,7 @@ static void test_it (int N) {
 	snprintf(key, sizeof(key), "key%x.%x", rands[i], i);
 	memset(val, 'v', sizeof(val));
 	val[sizeof(val)-1]=0;
-	r = toku_ft_insert(brt, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), txn);
+	toku_ft_insert(brt, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), txn);
 	r = toku_txn_commit_txn(txn, false, NULL, NULL);                                 CKERR(r);
 	toku_txn_close_txn(txn);
 
@@ -78,7 +78,7 @@ static void test_it (int N) {
 	char key[100];
 	DBT k;
 	snprintf(key, sizeof(key), "key%x.%x", rands[i], i);
-	r = toku_ft_delete(brt, toku_fill_dbt(&k, key, 1+strlen(key)), txn);
+	toku_ft_delete(brt, toku_fill_dbt(&k, key, 1+strlen(key)), txn);
 
 	if (0) {
 	bool is_empty;
@@ -109,9 +109,9 @@ static void test_it (int N) {
     r = toku_close_ft_handle_nolsn(brt, NULL);                                                                             CKERR(r);
 
     r = toku_checkpoint(cp, logger, NULL, NULL, NULL, NULL, CLIENT_CHECKPOINT);                                CKERR(r);
-    r = toku_logger_close_rollback(logger, false);                                                             CKERR(r);
+    toku_logger_close_rollback(logger);                                                             CKERR(r);
     r = toku_checkpoint(cp, logger, NULL, NULL, NULL, NULL, CLIENT_CHECKPOINT);                                CKERR(r);
-    r = toku_cachetable_close(&ct);                                                                            CKERR(r);
+    toku_cachetable_close(&ct);
     r = toku_logger_close(&logger);                                                        assert(r==0);
 
 }
diff --git a/ft/tests/keyrange.cc b/ft/tests/keyrange.cc
index 46b0a406f7b..7e277946f9d 100644
--- a/ft/tests/keyrange.cc
+++ b/ft/tests/keyrange.cc
@@ -20,13 +20,13 @@ static FT_HANDLE t;
 static void close_ft_and_ct (void) {
     int r;
     r = toku_close_ft_handle_nolsn(t, 0);          assert(r==0);
-    r = toku_cachetable_close(&ct);    assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void open_ft_and_ct (bool unlink_old) {
     int r;
     if (unlink_old) unlink(fname);
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);                                assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 1, &t, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);   assert(r==0);
 }
 
@@ -75,13 +75,12 @@ static void test_keyrange (enum memory_state ms, uint64_t limit) {
 	snprintf(key, 100, "%08llu", (unsigned long long)2*i+1);
 	snprintf(val, 100, "%08llu", (unsigned long long)2*i+1);
 	DBT k,v;
-	int r = toku_ft_insert(t, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v,val, 1+strlen(val)), null_txn);
-	assert(r == 0);
+	toku_ft_insert(t, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v,val, 1+strlen(val)), null_txn);
     }
 
     {
         struct ftstat64_s s;
-        int r = toku_ft_handle_stat64(t, null_txn, &s); assert(r == 0);
+        toku_ft_handle_stat64(t, null_txn, &s);
         
         assert(0 < s.nkeys && s.nkeys < limit);
         assert(0 < s.dsize && s.dsize < limit * (9 + 9)); // keylen = 9, vallen = 9
@@ -100,8 +99,7 @@ static void test_keyrange (enum memory_state ms, uint64_t limit) {
 	    snprintf(key, 100, "%08llu", (unsigned long long)2*i+1);
 	    DBT k;
 	    uint64_t less,equal,greater;
-	    int r = toku_ft_keyrange(t, toku_fill_dbt(&k, key, 1+strlen(key)), &less, &equal, &greater);
-	    assert(r == 0);
+	    toku_ft_keyrange(t, toku_fill_dbt(&k, key, 1+strlen(key)), &less, &equal, &greater);
 	    if (verbose > 1) 
                 printf("Pkey %llu/%llu %llu %llu %llu\n", (unsigned long long)2*i+1, (unsigned long long)2*limit, (unsigned long long)less, (unsigned long long)equal, (unsigned long long)greater);
 
@@ -163,8 +161,7 @@ static void test_keyrange (enum memory_state ms, uint64_t limit) {
 	snprintf(key, 100, "%08llu", (unsigned long long)2*i);
 	DBT k;
 	uint64_t less,equal,greater;
-	int r = toku_ft_keyrange(t, toku_fill_dbt(&k, key, 1+strlen(key)), &less, &equal, &greater);
-	assert(r == 0);
+	toku_ft_keyrange(t, toku_fill_dbt(&k, key, 1+strlen(key)), &less, &equal, &greater);
         if (verbose > 1)
             printf("Akey %llu/%llu %llu %llu %llu\n", (unsigned long long)2*i, (unsigned long long)2*limit, (unsigned long long)less, (unsigned long long)equal, (unsigned long long)greater);
 
diff --git a/ft/tests/le-cursor-provdel.cc b/ft/tests/le-cursor-provdel.cc
index 1a8372419e0..06821759ee4 100644
--- a/ft/tests/le-cursor-provdel.cc
+++ b/ft/tests/le-cursor-provdel.cc
@@ -44,8 +44,7 @@ create_populate_tree(const char *logdir, const char *fname, int n) {
     error = toku_logger_open(logdir, logger);
     assert(error == 0);
     CACHETABLE ct = NULL;
-    error = toku_create_cachetable(&ct, 0, ZERO_LSN, logger);
-    assert(error == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, logger);
     toku_logger_set_cachetable(logger, ct);
     error = toku_logger_open_rollback(logger, ct, true);
     assert(error == 0);
@@ -74,7 +73,7 @@ create_populate_tree(const char *logdir, const char *fname, int n) {
         toku_fill_dbt(&key, &k, sizeof k);
         DBT val;
         toku_fill_dbt(&val, &v, sizeof v);
-        error = toku_ft_insert(brt, &key, &val, txn);
+        toku_ft_insert(brt, &key, &val, txn);
         assert(error == 0);
     }
 
@@ -89,20 +88,18 @@ create_populate_tree(const char *logdir, const char *fname, int n) {
     error = toku_checkpoint(cp, logger, NULL, NULL, NULL, NULL, CLIENT_CHECKPOINT);
     assert(error == 0);
 
-    error = toku_logger_close_rollback(logger, false);
+    toku_logger_close_rollback(logger);
     assert(error == 0);
     
     error = toku_checkpoint(cp, logger, NULL, NULL, NULL, NULL, CLIENT_CHECKPOINT);
     assert(error == 0);
 
-    error = toku_logger_shutdown(logger);
-    CKERR(error);
+    toku_logger_shutdown(logger);
 
     error = toku_logger_close(&logger);
     assert(error == 0);
 
-    error = toku_cachetable_close(&ct);
-    assert(error == 0);
+    toku_cachetable_close(&ct);
 }
 
 // provionally delete all of the even keys
@@ -118,8 +115,7 @@ test_provdel(const char *logdir, const char *fname, int n) {
     error = toku_logger_open(logdir, logger);
     assert(error == 0);
     CACHETABLE ct = NULL;
-    error = toku_create_cachetable(&ct, 0, ZERO_LSN, logger);
-    assert(error == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, logger);
     toku_logger_set_cachetable(logger, ct);
     error = toku_logger_open_rollback(logger, ct, false);
     assert(error == 0);
@@ -145,7 +141,7 @@ test_provdel(const char *logdir, const char *fname, int n) {
         int k = toku_htonl(i);
         DBT key;
         toku_fill_dbt(&key, &k, sizeof k);
-        error = toku_ft_delete(brt, &key, txn);
+        toku_ft_delete(brt, &key, txn);
         assert(error == 0);
     }
 
@@ -180,8 +176,7 @@ test_provdel(const char *logdir, const char *fname, int n) {
     toku_destroy_dbt(&key);
     toku_destroy_dbt(&val);
 
-    error = toku_le_cursor_close(cursor);
-    assert(error == 0);
+    toku_le_cursor_close(cursor);
 
     error = toku_txn_commit_txn(cursortxn, true, NULL, NULL);
     assert(error == 0);
@@ -197,13 +192,12 @@ test_provdel(const char *logdir, const char *fname, int n) {
     error = toku_checkpoint(cp, logger, NULL, NULL, NULL, NULL, CLIENT_CHECKPOINT);
     assert(error == 0);
 
-    error = toku_logger_close_rollback(logger, false);
+    toku_logger_close_rollback(logger);
     assert(error == 0);
     error = toku_logger_close(&logger);
     assert(error == 0);
 
-    error = toku_cachetable_close(&ct);
-    assert(error == 0);
+    toku_cachetable_close(&ct);
 }
 
 static void
diff --git a/ft/tests/le-cursor-right.cc b/ft/tests/le-cursor-right.cc
index 9c4473604f2..072617cc2d6 100644
--- a/ft/tests/le-cursor-right.cc
+++ b/ft/tests/le-cursor-right.cc
@@ -48,8 +48,7 @@ create_populate_tree(const char *logdir, const char *fname, int n) {
     error = toku_logger_open(logdir, logger);
     assert(error == 0);
     CACHETABLE ct = NULL;
-    error = toku_create_cachetable(&ct, 0, ZERO_LSN, logger);
-    assert(error == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, logger);
     toku_logger_set_cachetable(logger, ct);
     error = toku_logger_open_rollback(logger, ct, true);
     assert(error == 0);
@@ -78,8 +77,7 @@ create_populate_tree(const char *logdir, const char *fname, int n) {
         toku_fill_dbt(&key, &k, sizeof k);
         DBT val;
         toku_fill_dbt(&val, &v, sizeof v);
-        error = toku_ft_insert(brt, &key, &val, txn);
-        assert(error == 0);
+        toku_ft_insert(brt, &key, &val, txn);
     }
 
     error = toku_txn_commit_txn(txn, true, NULL, NULL);
@@ -92,20 +90,18 @@ create_populate_tree(const char *logdir, const char *fname, int n) {
     CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
     error = toku_checkpoint(cp, logger, NULL, NULL, NULL, NULL, CLIENT_CHECKPOINT);
     assert(error == 0);
-    error = toku_logger_close_rollback(logger, false);
+    toku_logger_close_rollback(logger);
     assert(error == 0);
 
     error = toku_checkpoint(cp, logger, NULL, NULL, NULL, NULL, CLIENT_CHECKPOINT);
     assert(error == 0);
 
-    error = toku_logger_shutdown(logger);
-    CKERR(error);
+    toku_logger_shutdown(logger);
 
     error = toku_logger_close(&logger);
     assert(error == 0);
 
-    error = toku_cachetable_close(&ct);
-    assert(error == 0);
+    toku_cachetable_close(&ct);
 }
 
 // test toku_le_cursor_is_key_greater when the LE_CURSOR is positioned at -infinity
@@ -115,8 +111,7 @@ test_neg_infinity(const char *fname, int n) {
     int error;
 
     CACHETABLE ct = NULL;
-    error = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(error == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     FT_HANDLE brt = NULL;
     error = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, test_keycompare);
@@ -135,14 +130,12 @@ test_neg_infinity(const char *fname, int n) {
         assert(right == true);
     }
         
-    error = toku_le_cursor_close(cursor);
-    assert(error == 0);
+    toku_le_cursor_close(cursor);
 
     error = toku_close_ft_handle_nolsn(brt, 0);
     assert(error == 0);
 
-    error = toku_cachetable_close(&ct);
-    assert(error == 0);
+    toku_cachetable_close(&ct);
 }
 
 // test toku_le_cursor_is_key_greater when the LE_CURSOR is positioned at +infinity
@@ -152,8 +145,7 @@ test_pos_infinity(const char *fname, int n) {
     int error;
 
     CACHETABLE ct = NULL;
-    error = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(error == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     FT_HANDLE brt = NULL;
     error = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, test_keycompare);
@@ -196,14 +188,12 @@ test_pos_infinity(const char *fname, int n) {
         assert(right == false);
     }
 
-    error = toku_le_cursor_close(cursor);
-    assert(error == 0);
+    toku_le_cursor_close(cursor);
 
     error = toku_close_ft_handle_nolsn(brt, 0);
     assert(error == 0);
 
-    error = toku_cachetable_close(&ct);
-    assert(error == 0);
+    toku_cachetable_close(&ct);
 }
 
 // test toku_le_cursor_is_key_greater when the LE_CURSOR is positioned in between -infinity and +infinity
@@ -213,8 +203,7 @@ test_between(const char *fname, int n) {
     int error;
 
     CACHETABLE ct = NULL;
-    error = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(error == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     FT_HANDLE brt = NULL;
     error = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, test_keycompare);
@@ -268,14 +257,12 @@ test_between(const char *fname, int n) {
     toku_destroy_dbt(&key);
     toku_destroy_dbt(&val);
 
-    error = toku_le_cursor_close(cursor);
-    assert(error == 0);
+    toku_le_cursor_close(cursor);
 
     error = toku_close_ft_handle_nolsn(brt, 0);
     assert(error == 0);
 
-    error = toku_cachetable_close(&ct);
-    assert(error == 0);
+    toku_cachetable_close(&ct);
 }
 
 static void
diff --git a/ft/tests/le-cursor-walk.cc b/ft/tests/le-cursor-walk.cc
index 64e2b3a588a..f7bd94b4ef5 100644
--- a/ft/tests/le-cursor-walk.cc
+++ b/ft/tests/le-cursor-walk.cc
@@ -44,8 +44,7 @@ create_populate_tree(const char *logdir, const char *fname, int n) {
     error = toku_logger_open(logdir, logger);
     assert(error == 0);
     CACHETABLE ct = NULL;
-    error = toku_create_cachetable(&ct, 0, ZERO_LSN, logger);
-    assert(error == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, logger);
     toku_logger_set_cachetable(logger, ct);
     error = toku_logger_open_rollback(logger, ct, true);
     assert(error == 0);
@@ -74,8 +73,7 @@ create_populate_tree(const char *logdir, const char *fname, int n) {
         toku_fill_dbt(&key, &k, sizeof k);
         DBT val;
         toku_fill_dbt(&val, &v, sizeof v);
-        error = toku_ft_insert(brt, &key, &val, txn);
-        assert(error == 0);
+        toku_ft_insert(brt, &key, &val, txn);
     }
 
     error = toku_txn_commit_txn(txn, true, NULL, NULL);
@@ -88,18 +86,16 @@ create_populate_tree(const char *logdir, const char *fname, int n) {
     CHECKPOINTER cp = toku_cachetable_get_checkpointer(ct);
     error = toku_checkpoint(cp, logger, NULL, NULL, NULL, NULL, CLIENT_CHECKPOINT);
     assert(error == 0);
-    error = toku_logger_close_rollback(logger, false);
+    toku_logger_close_rollback(logger);
     assert(error == 0);
     error = toku_checkpoint(cp, logger, NULL, NULL, NULL, NULL, CLIENT_CHECKPOINT);
     assert(error == 0);
 
-    error = toku_logger_shutdown(logger);
-    CKERR(error);
+    toku_logger_shutdown(logger);
     error = toku_logger_close(&logger);
     assert(error == 0);
 
-    error = toku_cachetable_close(&ct);
-    assert(error == 0);
+    toku_cachetable_close(&ct);
 }
 
 // retrieve all of the leaf entries in the the tree and verify the key associated with each one.
@@ -110,8 +106,7 @@ walk_tree(const char *fname, int n) {
     int error;
 
     CACHETABLE ct = NULL;
-    error = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(error == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     FT_HANDLE brt = NULL;
     error = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, test_ft_cursor_keycompare);
@@ -147,14 +142,12 @@ walk_tree(const char *fname, int n) {
     toku_destroy_dbt(&key);
     toku_destroy_dbt(&val);
 
-    error = toku_le_cursor_close(cursor);
-    assert(error == 0);
+    toku_le_cursor_close(cursor);
 
     error = toku_close_ft_handle_nolsn(brt, 0);
     assert(error == 0);
 
-    error = toku_cachetable_close(&ct);
-    assert(error == 0);
+    toku_cachetable_close(&ct);
 }
 
 static void
diff --git a/ft/tests/log-test-maybe-trim.cc b/ft/tests/log-test-maybe-trim.cc
index eaa9e1868b8..1ad58d47cfe 100644
--- a/ft/tests/log-test-maybe-trim.cc
+++ b/ft/tests/log-test-maybe-trim.cc
@@ -27,11 +27,11 @@ test_main (int argc __attribute__((__unused__)),
     r = toku_logger_open(dname, logger); assert(r == 0);
     BYTESTRING hello = (BYTESTRING) { 5, (char *) "hello"};
     LSN comment_lsn;
-    r = toku_log_comment(logger, &comment_lsn, true, 0, hello);
+    toku_log_comment(logger, &comment_lsn, true, 0, hello);
     LSN begin_lsn;
-    r = toku_log_begin_checkpoint(logger, &begin_lsn, true, 0, 0); assert(r == 0);
+    toku_log_begin_checkpoint(logger, &begin_lsn, true, 0, 0);
     LSN end_lsn;
-    r = toku_log_end_checkpoint(logger, &end_lsn, true, begin_lsn, 0, 0, 0); assert(r == 0);
+    toku_log_end_checkpoint(logger, &end_lsn, true, begin_lsn, 0, 0, 0);
     r = toku_logger_maybe_trim_log(logger, begin_lsn); assert(r == 0);
     r = toku_logger_close(&logger); assert(r == 0);
 
diff --git a/ft/tests/log-test4.cc b/ft/tests/log-test4.cc
index 3da7c585660..ebc1585642a 100644
--- a/ft/tests/log-test4.cc
+++ b/ft/tests/log-test4.cc
@@ -34,7 +34,7 @@ test_main (int argc __attribute__((__unused__)),
 
     {
 	ml_lock(&logger->input_lock);
-	r = toku_logger_make_space_in_inbuf(logger, 5);                  assert(r == 0);
+	toku_logger_make_space_in_inbuf(logger, 5);
 	snprintf(logger->inbuf.buf+logger->inbuf.n_in_buf, 5, "a1234");
 	logger->inbuf.n_in_buf+=5;
 	logger->lsn.lsn++;
diff --git a/ft/tests/log-test5.cc b/ft/tests/log-test5.cc
index 26fa609d246..0821bbf95be 100644
--- a/ft/tests/log-test5.cc
+++ b/ft/tests/log-test5.cc
@@ -39,7 +39,7 @@ test_main (int argc __attribute__((__unused__)),
 	ml_lock(&logger->input_lock);
 
 	int ilen=3+random()%5;
-	r = toku_logger_make_space_in_inbuf(logger, ilen+1);                                 assert(r==0);
+	toku_logger_make_space_in_inbuf(logger, ilen+1);
 	snprintf(logger->inbuf.buf+logger->inbuf.n_in_buf, ilen+1, "a%0*d ", (int)ilen, i);
 	logger->inbuf.n_in_buf+=(ilen+1);
 	logger->lsn.lsn++;
diff --git a/ft/tests/log-test6.cc b/ft/tests/log-test6.cc
index 6ee0d99f0f5..b1358f6032c 100644
--- a/ft/tests/log-test6.cc
+++ b/ft/tests/log-test6.cc
@@ -44,7 +44,7 @@ test_main (int argc __attribute__((__unused__)),
     {
 	ml_lock(&logger->input_lock);
 	int lsize=LSIZE-12-2;
-	r = toku_logger_make_space_in_inbuf(logger, lsize);           assert(r==0);
+	toku_logger_make_space_in_inbuf(logger, lsize);
 	snprintf(logger->inbuf.buf+logger->inbuf.n_in_buf, lsize, "a%*d", lsize-1, 0);
 	logger->inbuf.n_in_buf += lsize;
 	logger->lsn.lsn++;
@@ -54,7 +54,7 @@ test_main (int argc __attribute__((__unused__)),
 
     {
 	ml_lock(&logger->input_lock);
-	r = toku_logger_make_space_in_inbuf(logger, 2);                  assert(r==0);
+	toku_logger_make_space_in_inbuf(logger, 2);
 	memcpy(logger->inbuf.buf+logger->inbuf.n_in_buf, "b1", 2);
 	logger->inbuf.n_in_buf += 2;
 	logger->lsn.lsn++;
diff --git a/ft/tests/log-test7.cc b/ft/tests/log-test7.cc
index 8e717abe3bd..fc77766fc71 100644
--- a/ft/tests/log-test7.cc
+++ b/ft/tests/log-test7.cc
@@ -41,11 +41,10 @@ static void setup_logger(int which) {
 }
 
 static void play_with_logger(int which) {
-    int r;
     {
 	ml_lock(&logger[which]->input_lock);
 	int lsize=LSIZE-12-2;
-	r = toku_logger_make_space_in_inbuf(logger[which], lsize);       assert(r==0); 
+	toku_logger_make_space_in_inbuf(logger[which], lsize);
 	snprintf(logger[which]->inbuf.buf+logger[which]->inbuf.n_in_buf, lsize, "a%*d", lsize-1, 0);
 	logger[which]->inbuf.n_in_buf += lsize;
 	logger[which]->lsn.lsn++;
@@ -55,7 +54,7 @@ static void play_with_logger(int which) {
 
     {
 	ml_lock(&logger[which]->input_lock);
-	r = toku_logger_make_space_in_inbuf(logger[which], 2);           assert(r==0);
+	toku_logger_make_space_in_inbuf(logger[which], 2);
 	memcpy(logger[which]->inbuf.buf+logger[which]->inbuf.n_in_buf, "b1", 2);
 	logger[which]->inbuf.n_in_buf += 2;
 	logger[which]->lsn.lsn++;
diff --git a/ft/tests/logcursor-bad-checksum.cc b/ft/tests/logcursor-bad-checksum.cc
index 12302dfcdc0..bcffefab0fd 100644
--- a/ft/tests/logcursor-bad-checksum.cc
+++ b/ft/tests/logcursor-bad-checksum.cc
@@ -51,8 +51,7 @@ test_main (int argc, const char *argv[]) {
     assert(r == 0);
 
     BYTESTRING bs0 = { .len = 5, .data = (char *) "hello" };
-    r = toku_log_comment(logger, &lsn, 0, 0, bs0);
-    assert(r == 0);
+    toku_log_comment(logger, &lsn, 0, 0, bs0);
 
     r = toku_logger_close(&logger);
     assert(r == 0);
diff --git a/ft/tests/logcursor-empty-logfile-2.cc b/ft/tests/logcursor-empty-logfile-2.cc
index db14cc4f1e9..0a05f975a91 100644
--- a/ft/tests/logcursor-empty-logfile-2.cc
+++ b/ft/tests/logcursor-empty-logfile-2.cc
@@ -48,8 +48,7 @@ test_main (int argc, const char *argv[]) {
         char str[32];
         sprintf(str, "hello%d", helloseq++);
         BYTESTRING bs0 = { .len = (uint32_t) strlen(str), .data = str };
-        r = toku_log_comment(logger, &lsn, 0, 0, bs0);
-        assert(r == 0);
+        toku_log_comment(logger, &lsn, 0, 0, bs0);
 
         r = toku_logger_close(&logger);
         assert(r == 0);
diff --git a/ft/tests/logcursor-empty-logfile-3.cc b/ft/tests/logcursor-empty-logfile-3.cc
index c5a03c8680b..5c7d3bda1b4 100644
--- a/ft/tests/logcursor-empty-logfile-3.cc
+++ b/ft/tests/logcursor-empty-logfile-3.cc
@@ -36,8 +36,7 @@ test_main (int argc, const char *argv[]) {
         char str[32];
         sprintf(str, "hello%d", helloseq++);
         BYTESTRING bs0 = { .len = (uint32_t) strlen(str), .data = str };
-        r = toku_log_comment(logger, &lsn, 0, 0, bs0);
-        assert(r == 0);
+        toku_log_comment(logger, &lsn, 0, 0, bs0);
 
         r = toku_logger_close(&logger);
         assert(r == 0);
@@ -78,8 +77,7 @@ test_main (int argc, const char *argv[]) {
         char str[32];
         sprintf(str, "hello%d", helloseq++);
         BYTESTRING bs0 = { .len = (uint32_t) strlen(str), .data = str };
-        r = toku_log_comment(logger, &lsn, 0, 0, bs0);
-        assert(r == 0);
+        toku_log_comment(logger, &lsn, 0, 0, bs0);
 
         r = toku_logger_close(&logger);
         assert(r == 0);
diff --git a/ft/tests/logcursor-empty-logfile.cc b/ft/tests/logcursor-empty-logfile.cc
index 283ef70e735..ac652f2a3ab 100644
--- a/ft/tests/logcursor-empty-logfile.cc
+++ b/ft/tests/logcursor-empty-logfile.cc
@@ -36,8 +36,7 @@ test_main (int argc, const char *argv[]) {
         char str[32];
         sprintf(str, "hello%d", helloseq++);
         BYTESTRING bs0 = { .len = (uint32_t) strlen(str), .data = str };
-        r = toku_log_comment(logger, &lsn, 0, 0, bs0);
-        assert(r == 0);
+        toku_log_comment(logger, &lsn, 0, 0, bs0);
 
         r = toku_logger_close(&logger);
         assert(r == 0);
@@ -66,8 +65,7 @@ test_main (int argc, const char *argv[]) {
         char str[32];
         sprintf(str, "hello%d", helloseq++);
         BYTESTRING bs0 = { .len = (uint32_t) strlen(str), .data = str };
-        r = toku_log_comment(logger, &lsn, 0, 0, bs0);
-        assert(r == 0);
+        toku_log_comment(logger, &lsn, 0, 0, bs0);
 
         r = toku_logger_close(&logger);
         assert(r == 0);
diff --git a/ft/tests/logcursor-timestamp.cc b/ft/tests/logcursor-timestamp.cc
index 0b1e0f157e3..07eaae360d7 100644
--- a/ft/tests/logcursor-timestamp.cc
+++ b/ft/tests/logcursor-timestamp.cc
@@ -40,14 +40,12 @@ test_main (int argc, const char *argv[]) {
     assert(r == 0);
 
     BYTESTRING bs0 = { .len = 5, .data = (char *) "hello" };
-    r = toku_log_comment(logger, &lsn, 0, now(), bs0);
-    assert(r == 0);
+    toku_log_comment(logger, &lsn, 0, now(), bs0);
 
     sleep(11);
 
     BYTESTRING bs1 = { .len = 5, .data = (char *) "world" };
-    r = toku_log_comment(logger, &lsn, 0, now(), bs1);
-    assert(r == 0);
+    toku_log_comment(logger, &lsn, 0, now(), bs1);
 
     r = toku_logger_close(&logger);
     assert(r == 0);
diff --git a/ft/tests/make-tree.cc b/ft/tests/make-tree.cc
index cb1cb1d4f94..ea8fc8051d8 100644
--- a/ft/tests/make-tree.cc
+++ b/ft/tests/make-tree.cc
@@ -123,8 +123,7 @@ test_make_tree(int height, int fanout, int nperleaf, int do_verify) {
 
     // create a cachetable
     CACHETABLE ct = NULL;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     // create the brt
     TOKUTXN null_txn = NULL;
@@ -154,8 +153,7 @@ test_make_tree(int height, int fanout, int nperleaf, int do_verify) {
     assert(r == 0);
 
     // shutdown the cachetable
-    r = toku_cachetable_close(&ct);
-    assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 static int
diff --git a/ft/tests/minicron-test.cc b/ft/tests/minicron-test.cc
index 7876ad68cc3..511dde61f64 100644
--- a/ft/tests/minicron-test.cc
+++ b/ft/tests/minicron-test.cc
@@ -126,7 +126,7 @@ test5 (void *v) {
     int counter = 0;
     ZERO_STRUCT(m);
     int r = toku_minicron_setup(&m, 10, run_3sec, &counter); assert(r==0);
-    r = toku_minicron_change_period(&m, 2);                  assert(r==0);
+    toku_minicron_change_period(&m, 2);
     sleep(9);
     r = toku_minicron_shutdown(&m);                     assert(r==0);
     assert(counter==2);
@@ -138,7 +138,7 @@ test6 (void *v) {
     struct minicron m;
     ZERO_STRUCT(m);
     int r = toku_minicron_setup(&m, 5, never_run, 0); assert(r==0);
-    r = toku_minicron_change_period(&m, 0);                  assert(r==0);
+    toku_minicron_change_period(&m, 0);
     sleep(7);
     r = toku_minicron_shutdown(&m);                          assert(r==0);
     return v;
diff --git a/ft/tests/msnfilter.cc b/ft/tests/msnfilter.cc
index 46c5f4ea7a0..43c9bf7ce6c 100644
--- a/ft/tests/msnfilter.cc
+++ b/ft/tests/msnfilter.cc
@@ -116,8 +116,7 @@ test_msnfilter(int do_verify) {
 
     // create a cachetable
     CACHETABLE ct = NULL;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     // create the brt
     TOKUTXN null_txn = NULL;
@@ -150,8 +149,7 @@ test_msnfilter(int do_verify) {
     assert(r == 0);
 
     // shutdown the cachetable
-    r = toku_cachetable_close(&ct);
-    assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 static int
diff --git a/ft/tests/orthopush-flush.cc b/ft/tests/orthopush-flush.cc
index 167c6911273..19a9a63aa4d 100644
--- a/ft/tests/orthopush-flush.cc
+++ b/ft/tests/orthopush-flush.cc
@@ -88,10 +88,9 @@ insert_random_message(NONLEAF_CHILDINFO bnc, FT_MSG_S **save, bool *is_fresh_out
     *save = result;
     *is_fresh_out = is_fresh;
 
-    int r = toku_bnc_insert_msg(bnc, key, keylen + (sizeof pfx), val, vallen,
-                                FT_INSERT, msn, xids, is_fresh,
-                                NULL, dummy_cmp);
-    assert_zero(r);
+    toku_bnc_insert_msg(bnc, key, keylen + (sizeof pfx), val, vallen,
+                        FT_INSERT, msn, xids, is_fresh,
+                        NULL, dummy_cmp);
 }
 
 // generate a random message with xids and a key starting with pfx, insert
@@ -224,11 +223,10 @@ insert_random_update_message(NONLEAF_CHILDINFO bnc, FT_MSG_S **save, bool is_fre
     result->u.id.val = valdbt;
     *save = result;
 
-    int r = toku_bnc_insert_msg(bnc, key, keylen + (sizeof pfx),
-                                update_extra, sizeof *update_extra,
-                                FT_UPDATE, msn, xids, is_fresh,
-                                NULL, dummy_cmp);
-    assert_zero(r);
+    toku_bnc_insert_msg(bnc, key, keylen + (sizeof pfx),
+                        update_extra, sizeof *update_extra,
+                        FT_UPDATE, msn, xids, is_fresh,
+                        NULL, dummy_cmp);
     if (msn.msn > max_msn->msn) {
         *max_msn = msn;
     }
@@ -1119,12 +1117,11 @@ test_main (int argc, const char *argv[]) {
     initialize_dummymsn();
     int r;
     CACHETABLE ct;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
     FT_HANDLE t;
     r = toku_open_ft_handle(fname, 1, &t, 128*1024, 4096, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun); assert(r==0);
-    r = toku_ft_set_update(t, orthopush_flush_update_fun); assert(r==0);
+    toku_ft_set_update(t, orthopush_flush_update_fun);
     // HACK
     t->ft->update_fun = orthopush_flush_update_fun;
 
@@ -1148,7 +1145,7 @@ test_main (int argc, const char *argv[]) {
     }
 
     r = toku_close_ft_handle_nolsn(t, 0);          assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
 
     return 0;
 }
diff --git a/ft/tests/recovery-bad-last-entry.cc b/ft/tests/recovery-bad-last-entry.cc
index 7b90c128276..b7560cb7913 100644
--- a/ft/tests/recovery-bad-last-entry.cc
+++ b/ft/tests/recovery-bad-last-entry.cc
@@ -37,15 +37,15 @@ run_test(void) {
         r = toku_logger_open(TESTDIR, logger); assert(r == 0);
         LSN beginlsn;
         // all logs must contain a valid checkpoint
-        r = toku_log_begin_checkpoint(logger, &beginlsn, true, 0, 0); assert(r == 0);
-        r = toku_log_end_checkpoint(logger, NULL, true, beginlsn, 0, 0, 0); assert(r == 0);
-        r = toku_log_comment(logger, NULL, true, 0, hello); assert(r == 0);
-        r = toku_log_comment(logger, NULL, true, 0, world); assert(r == 0);
-        r = toku_log_begin_checkpoint(logger, &beginlsn, true, 0, 0); assert(r == 0);
-        r = toku_log_end_checkpoint(logger, NULL, true, beginlsn, 0, 0, 0); assert(r == 0);
-        r = toku_log_comment(logger, NULL, true, 0, hello); assert(r == 0);
-        r = toku_log_comment(logger, NULL, true, 0, there); assert(r == 0);
-        r = toku_logger_close(&logger); assert(r == 0);
+        toku_log_begin_checkpoint(logger, &beginlsn, true, 0, 0);
+        toku_log_end_checkpoint(logger, NULL, true, beginlsn, 0, 0, 0);
+        toku_log_comment(logger, NULL, true, 0, hello);
+        toku_log_comment(logger, NULL, true, 0, world);
+        toku_log_begin_checkpoint(logger, &beginlsn, true, 0, 0);
+        toku_log_end_checkpoint(logger, NULL, true, beginlsn, 0, 0, 0);
+        toku_log_comment(logger, NULL, true, 0, hello);
+        toku_log_comment(logger, NULL, true, 0, there);
+        toku_logger_close(&logger);
 
         // redirect stderr
         int devnul = open(DEV_NULL_FILE, O_WRONLY);
diff --git a/ft/tests/recovery-cbegin-cend-hello.cc b/ft/tests/recovery-cbegin-cend-hello.cc
index 069335afe79..7f65485877e 100644
--- a/ft/tests/recovery-cbegin-cend-hello.cc
+++ b/ft/tests/recovery-cbegin-cend-hello.cc
@@ -26,8 +26,8 @@ run_test(void) {
     
     // add begin checkpoint, end checkpoint
     LSN beginlsn;
-    r = toku_log_begin_checkpoint(logger, &beginlsn, false, 0, 0); assert(r == 0);
-    r = toku_log_end_checkpoint(logger, NULL, true, beginlsn, 0, 0, 0); assert(r == 0);
+    toku_log_begin_checkpoint(logger, &beginlsn, false, 0, 0);
+    toku_log_end_checkpoint(logger, NULL, true, beginlsn, 0, 0, 0);
     r = toku_logger_close(&logger); assert(r == 0);
 
     // add hello
@@ -35,7 +35,7 @@ run_test(void) {
         r = toku_logger_create(&logger); assert(r == 0);
         r = toku_logger_open(TESTDIR, logger); assert(r == 0);
         BYTESTRING hello  = { (uint32_t) strlen("hello"), (char *) "hello" };
-        r = toku_log_comment(logger, NULL, true, 0, hello);
+        toku_log_comment(logger, NULL, true, 0, hello);
         r = toku_logger_close(&logger); assert(r == 0);
     }
 
diff --git a/ft/tests/recovery-cbegin-cend.cc b/ft/tests/recovery-cbegin-cend.cc
index 0aaa47d115d..eb686a694e7 100644
--- a/ft/tests/recovery-cbegin-cend.cc
+++ b/ft/tests/recovery-cbegin-cend.cc
@@ -22,12 +22,12 @@ run_test(void) {
     r = toku_logger_create(&logger); assert(r == 0);
     r = toku_logger_open(TESTDIR, logger); assert(r == 0);
     LSN beginlsn;
-    r = toku_log_begin_checkpoint(logger, &beginlsn, false, 0, 0); assert(r == 0);
+    toku_log_begin_checkpoint(logger, &beginlsn, false, 0, 0);
     r = toku_logger_close(&logger); assert(r == 0);
 
     r = toku_logger_create(&logger); assert(r == 0);
     r = toku_logger_open(TESTDIR, logger); assert(r == 0);
-    r = toku_log_end_checkpoint(logger, NULL, true, beginlsn, 0, 0, 0); assert(r == 0);
+    toku_log_end_checkpoint(logger, NULL, true, beginlsn, 0, 0, 0);
     r = toku_logger_close(&logger); assert(r == 0);
 
     // run recovery
diff --git a/ft/tests/recovery-cbegin.cc b/ft/tests/recovery-cbegin.cc
index dc6a9c0a488..39e5bad1a4c 100644
--- a/ft/tests/recovery-cbegin.cc
+++ b/ft/tests/recovery-cbegin.cc
@@ -22,9 +22,9 @@ run_test(void) {
     r = toku_logger_create(&logger); assert(r == 0);
     r = toku_logger_open(TESTDIR, logger); assert(r == 0);
     LSN beginlsn;
-    r = toku_log_begin_checkpoint(logger, &beginlsn, true, 0, 0); assert(r == 0);
-    r = toku_log_end_checkpoint(logger, NULL, true, beginlsn, 0, 0, 0); assert(r == 0);
-    r = toku_log_begin_checkpoint(logger, &beginlsn, true, 0, 0); assert(r == 0);
+    toku_log_begin_checkpoint(logger, &beginlsn, true, 0, 0);
+    toku_log_end_checkpoint(logger, NULL, true, beginlsn, 0, 0, 0);
+    toku_log_begin_checkpoint(logger, &beginlsn, true, 0, 0);
     r = toku_logger_close(&logger); assert(r == 0);
 
     // run recovery
diff --git a/ft/tests/recovery-cend-cbegin.cc b/ft/tests/recovery-cend-cbegin.cc
index a80ef7b9586..f78e14ded8e 100644
--- a/ft/tests/recovery-cend-cbegin.cc
+++ b/ft/tests/recovery-cend-cbegin.cc
@@ -24,10 +24,10 @@ run_test(void) {
     r = toku_logger_create(&logger); assert(r == 0);
     r = toku_logger_open(TESTDIR, logger); assert(r == 0);
     LSN firstbegin = ZERO_LSN;
-    r = toku_log_begin_checkpoint(logger, &firstbegin, true, 0, 0); assert(r == 0);
+    toku_log_begin_checkpoint(logger, &firstbegin, true, 0, 0);
     assert(firstbegin.lsn != ZERO_LSN.lsn);
-    r = toku_log_end_checkpoint(logger, NULL, false, firstbegin, 0, 0, 0); assert(r == 0);
-    r = toku_log_begin_checkpoint(logger, NULL, true, 0, 0); assert(r == 0);
+    toku_log_end_checkpoint(logger, NULL, false, firstbegin, 0, 0, 0);
+    toku_log_begin_checkpoint(logger, NULL, true, 0, 0);
     r = toku_logger_close(&logger); assert(r == 0);
 
     if (!verbose) {
diff --git a/ft/tests/recovery-datadir-is-file.cc b/ft/tests/recovery-datadir-is-file.cc
index 1d47b21258a..f60d59fc328 100644
--- a/ft/tests/recovery-datadir-is-file.cc
+++ b/ft/tests/recovery-datadir-is-file.cc
@@ -25,7 +25,7 @@ run_test(void) {
     r = toku_logger_create(&logger); assert(r == 0);
     r = toku_logger_open(TESTDIR, logger); assert(r == 0);
     BYTESTRING hello  = { (uint32_t) strlen("hello"), (char *) "hello" };
-    r = toku_log_comment(logger, NULL, true, 0, hello);
+    toku_log_comment(logger, NULL, true, 0, hello);
     r = toku_logger_close(&logger); assert(r == 0);
 
     // redirect stderr
diff --git a/ft/tests/recovery-fopen-missing-file.cc b/ft/tests/recovery-fopen-missing-file.cc
index 077a9a07957..ec5141a04e0 100644
--- a/ft/tests/recovery-fopen-missing-file.cc
+++ b/ft/tests/recovery-fopen-missing-file.cc
@@ -24,13 +24,13 @@ run_test(void) {
     r = toku_logger_create(&logger); assert(r == 0);
     r = toku_logger_open(TESTDIR, logger); assert(r == 0);
     LSN beginlsn;
-    r = toku_log_begin_checkpoint(logger, &beginlsn, true, 0, 0); assert(r == 0);
-    r = toku_log_end_checkpoint(logger, NULL, true, beginlsn, 0, 0, 0); assert(r == 0);
+    toku_log_begin_checkpoint(logger, &beginlsn, true, 0, 0);
+    toku_log_end_checkpoint(logger, NULL, true, beginlsn, 0, 0, 0);
 
     BYTESTRING iname  = { (uint32_t) strlen("missing_tokudb_file"), (char *) "missing_tokudb_file" };
     FILENUM filenum = {42};
     uint32_t treeflags = 0;
-    r = toku_log_fopen(logger, NULL, true, iname, filenum, treeflags);
+    toku_log_fopen(logger, NULL, true, iname, filenum, treeflags);
     r = toku_logger_close(&logger); assert(r == 0);
 
     // redirect stderr
diff --git a/ft/tests/recovery-hello.cc b/ft/tests/recovery-hello.cc
index 749a586d7d7..58c09c47d4b 100644
--- a/ft/tests/recovery-hello.cc
+++ b/ft/tests/recovery-hello.cc
@@ -24,13 +24,13 @@ run_test(void) {
     r = toku_logger_create(&logger); assert(r == 0);
     r = toku_logger_open(TESTDIR, logger); assert(r == 0);
     BYTESTRING hello  = { (uint32_t) strlen("hello"), (char *) "hello" };
-    r = toku_log_comment(logger, NULL, true, 0, hello); assert(r == 0);
+    toku_log_comment(logger, NULL, true, 0, hello);
     LSN beginlsn;
-    r = toku_log_begin_checkpoint(logger, &beginlsn, true, 0, 0); assert(r == 0);
-    r = toku_log_end_checkpoint(logger, NULL, true, beginlsn, 0, 0, 0); assert(r == 0);
-    r = toku_log_comment(logger, NULL, true, 0, hello); assert(r == 0);
+    toku_log_begin_checkpoint(logger, &beginlsn, true, 0, 0);
+    toku_log_end_checkpoint(logger, NULL, true, beginlsn, 0, 0, 0);
+    toku_log_comment(logger, NULL, true, 0, hello);
     BYTESTRING there  = { (uint32_t) strlen("there"), (char *) "there" };
-    r = toku_log_comment(logger, NULL, true, 0, there); assert(r == 0);
+    toku_log_comment(logger, NULL, true, 0, there);
     r = toku_logger_close(&logger); assert(r == 0);
 
     // redirect stderr
diff --git a/ft/tests/recovery-lsn-error-during-forward-scan.cc b/ft/tests/recovery-lsn-error-during-forward-scan.cc
index a73b086e967..045d7f509f6 100644
--- a/ft/tests/recovery-lsn-error-during-forward-scan.cc
+++ b/ft/tests/recovery-lsn-error-during-forward-scan.cc
@@ -43,8 +43,8 @@ run_test(void) {
     r = toku_logger_open(TESTDIR, logger); assert(r == 0);
 
     LSN beginlsn;
-    r = toku_log_begin_checkpoint(logger, &beginlsn, true, 0, 0); assert(r == 0);
-    r = toku_log_end_checkpoint(logger, NULL, true, beginlsn, 0, 0, 0); assert(r == 0);
+    toku_log_begin_checkpoint(logger, &beginlsn, true, 0, 0);
+    toku_log_end_checkpoint(logger, NULL, true, beginlsn, 0, 0, 0);
 
     r = toku_logger_close(&logger); assert(r == 0);
 
@@ -53,7 +53,7 @@ run_test(void) {
     r = toku_logger_open(TESTDIR, logger); assert(r == 0);
 
     BYTESTRING hello  = { (uint32_t) strlen("hello"), (char *) "hello" };
-    r = toku_log_comment(logger, NULL, true, 0, hello); assert(r == 0);
+    toku_log_comment(logger, NULL, true, 0, hello);
 
     r = toku_logger_close(&logger); assert(r == 0);
 
@@ -62,7 +62,7 @@ run_test(void) {
     r = toku_logger_open(TESTDIR, logger); assert(r == 0);
 
     BYTESTRING there  = { (uint32_t) strlen("there"), (char *) "there" };
-    r = toku_log_comment(logger, NULL, true, 0, there); assert(r == 0);
+    toku_log_comment(logger, NULL, true, 0, there);
 
     r = toku_logger_close(&logger); assert(r == 0);
 
diff --git a/ft/tests/recovery-no-datadir.cc b/ft/tests/recovery-no-datadir.cc
index 0e57a787337..3e413a19f8c 100644
--- a/ft/tests/recovery-no-datadir.cc
+++ b/ft/tests/recovery-no-datadir.cc
@@ -24,7 +24,7 @@ run_test(void) {
     r = toku_logger_create(&logger); assert(r == 0);
     r = toku_logger_open(TESTDIR, logger); assert(r == 0);
     BYTESTRING hello  = { (uint32_t) strlen("hello"), (char *) "hello" };
-    r = toku_log_comment(logger, NULL, true, 0, hello);
+    toku_log_comment(logger, NULL, true, 0, hello);
     r = toku_logger_close(&logger); assert(r == 0);
 
     // redirect stderr
diff --git a/ft/tests/recovery-test5123.cc b/ft/tests/recovery-test5123.cc
index 8b65f875968..c8028c4b7c4 100644
--- a/ft/tests/recovery-test5123.cc
+++ b/ft/tests/recovery-test5123.cc
@@ -21,21 +21,15 @@ static void test_5123(void) {
 
     int r;
 
-    r = toku_log_xbegin(logger, NULL, false, (TXNID) 1, TXNID_NONE);
-    CKERR(r);
-    r = toku_log_xbegin(logger, NULL, false, (TXNID) 3, TXNID_NONE);
-    CKERR(r);
-    r = toku_log_xbegin(logger, NULL, false, (TXNID) 2, TXNID_NONE);
-    CKERR(r);
+    toku_log_xbegin(logger, NULL, false, (TXNID) 1, TXNID_NONE);
+    toku_log_xbegin(logger, NULL, false, (TXNID) 3, TXNID_NONE);
+    toku_log_xbegin(logger, NULL, false, (TXNID) 2, TXNID_NONE);
 
-    r = toku_log_xcommit(logger, NULL, false, NULL, (TXNID) 2);
-    CKERR(r);
+    toku_log_xcommit(logger, NULL, false, NULL, (TXNID) 2);
 
-    r = toku_logger_close_rollback(logger, false);
-    CKERR(r);
+    toku_logger_close_rollback(logger);
 
-    r = toku_cachetable_close(&ct);
-    CKERR(r);
+    toku_cachetable_close(&ct);
     // "Crash"
     r = toku_logger_close(&logger);
     CKERR(r);
diff --git a/ft/tests/shortcut.cc b/ft/tests/shortcut.cc
index 6f39aecb3c9..687d5aca6fa 100644
--- a/ft/tests/shortcut.cc
+++ b/ft/tests/shortcut.cc
@@ -23,7 +23,7 @@ test_main (int argc __attribute__((__unused__)), const char *argv[]  __attribute
 
     unlink(fname);
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);                               assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 1, &brt, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, test_ft_cursor_keycompare);   assert(r==0);
     r = toku_ft_cursor(brt, &cursor, NULL, false, false);               assert(r==0);
 
@@ -32,7 +32,7 @@ test_main (int argc __attribute__((__unused__)), const char *argv[]  __attribute
 	char string[100];
 	snprintf(string, sizeof(string), "%04d", i);
 	DBT key,val;
-	r = toku_ft_insert(brt, toku_fill_dbt(&key, string, 5), toku_fill_dbt(&val, string, 5), 0);       assert(r==0);
+	toku_ft_insert(brt, toku_fill_dbt(&key, string, 5), toku_fill_dbt(&val, string, 5), 0);
     }
 
     {
@@ -47,7 +47,7 @@ test_main (int argc __attribute__((__unused__)), const char *argv[]  __attribute
     // This will invalidate due to the root counter bumping, but the OMT itself will still be valid.
     {
 	DBT key, val;
-	r = toku_ft_insert(brt, toku_fill_dbt(&key, "d", 2), toku_fill_dbt(&val, "w", 2), 0);   assert(r==0);
+	toku_ft_insert(brt, toku_fill_dbt(&key, "d", 2), toku_fill_dbt(&val, "w", 2), 0);
     }
 
     {
@@ -55,8 +55,8 @@ test_main (int argc __attribute__((__unused__)), const char *argv[]  __attribute
 	r = toku_ft_cursor_get(cursor, NULL, lookup_checkf, &pair, DB_NEXT);    assert(r==0); assert(pair.call_count==1);
     }
 
-    r = toku_ft_cursor_close(cursor);                                                           assert(r==0);
+    toku_ft_cursor_close(cursor);
     r = toku_close_ft_handle_nolsn(brt, 0);                                                               assert(r==0);
-    r = toku_cachetable_close(&ct);                                                              assert(r==0);
+    toku_cachetable_close(&ct);
     return 0;
 }
diff --git a/ft/tests/test-checkpoint-during-flush.cc b/ft/tests/test-checkpoint-during-flush.cc
index 14d1b1e2033..24f9a01d3eb 100644
--- a/ft/tests/test-checkpoint-during-flush.cc
+++ b/ft/tests/test-checkpoint-during-flush.cc
@@ -99,7 +99,7 @@ doit (bool after_child_pin) {
 
     toku_flusher_thread_set_callback(flusher_callback, &after_child_pin);
     
-    r = toku_create_cachetable(&ct, 500*1024*1024, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 500*1024*1024, ZERO_LSN, NULL_LOGGER);
     unlink("foo1.ft_handle");
     r = toku_open_ft_handle("foo1.ft_handle", 1, &t, NODESIZE, NODESIZE/2, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     assert(r==0);
@@ -251,7 +251,7 @@ doit (bool after_child_pin) {
 
     r = toku_close_ft_handle_nolsn(t, 0);    assert(r==0);
     r = toku_close_ft_handle_nolsn(c_ft, 0);    assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/test-checkpoint-during-merge.cc b/ft/tests/test-checkpoint-during-merge.cc
index 5e9ad242ec0..e195bad7f03 100644
--- a/ft/tests/test-checkpoint-during-merge.cc
+++ b/ft/tests/test-checkpoint-during-merge.cc
@@ -90,7 +90,7 @@ doit (int state) {
 
     toku_flusher_thread_set_callback(flusher_callback, &state);
     
-    r = toku_create_cachetable(&ct, 500*1024*1024, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 500*1024*1024, ZERO_LSN, NULL_LOGGER);
     unlink("foo2.ft_handle");
     unlink("bar2.ft_handle");
     // note the basement node size is 5 times the node size
@@ -315,7 +315,7 @@ doit (int state) {
 
     r = toku_close_ft_handle_nolsn(t, 0);    assert(r==0);
     r = toku_close_ft_handle_nolsn(c_ft, 0);    assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
     toku_free(pivots[0]);
 }
 
diff --git a/ft/tests/test-checkpoint-during-rebalance.cc b/ft/tests/test-checkpoint-during-rebalance.cc
index 24c5afb7364..e11f148c681 100644
--- a/ft/tests/test-checkpoint-during-rebalance.cc
+++ b/ft/tests/test-checkpoint-during-rebalance.cc
@@ -90,7 +90,7 @@ doit (int state) {
 
     toku_flusher_thread_set_callback(flusher_callback, &state);
     
-    r = toku_create_cachetable(&ct, 500*1024*1024, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 500*1024*1024, ZERO_LSN, NULL_LOGGER);
     unlink("foo3.ft_handle");
     unlink("bar3.ft_handle");
     // note the basement node size is 5 times the node size
@@ -311,7 +311,7 @@ doit (int state) {
 
     r = toku_close_ft_handle_nolsn(t, 0);    assert(r==0);
     r = toku_close_ft_handle_nolsn(c_ft, 0);    assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
     toku_free(pivots[0]);
 }
 
diff --git a/ft/tests/test-checkpoint-during-split.cc b/ft/tests/test-checkpoint-during-split.cc
index d1411dc052f..1c74d121f49 100644
--- a/ft/tests/test-checkpoint-during-split.cc
+++ b/ft/tests/test-checkpoint-during-split.cc
@@ -99,7 +99,7 @@ doit (bool after_split) {
 
     toku_flusher_thread_set_callback(flusher_callback, &after_split);
     
-    r = toku_create_cachetable(&ct, 500*1024*1024, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 500*1024*1024, ZERO_LSN, NULL_LOGGER);
     unlink("foo4.ft_handle");
     unlink("bar4.ft_handle");
     // note the basement node size is 5 times the node size
@@ -306,7 +306,7 @@ doit (bool after_split) {
 
     r = toku_close_ft_handle_nolsn(t, 0);    assert(r==0);
     r = toku_close_ft_handle_nolsn(c_ft, 0);    assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/test-del-inorder.cc b/ft/tests/test-del-inorder.cc
index d6e25a66ead..81b3e1f1b9c 100644
--- a/ft/tests/test-del-inorder.cc
+++ b/ft/tests/test-del-inorder.cc
@@ -29,7 +29,7 @@ doit (void) {
     XMALLOC_N(fnamelen, fname);
 
     snprintf(fname, fnamelen, "%s.ft_handle", __SRCFILE__);
-    r = toku_create_cachetable(&ct, 16*1024, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 16*1024, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
     r = toku_open_ft_handle(fname, 1, &t, NODESIZE, NODESIZE, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     assert(r==0);
@@ -50,11 +50,10 @@ doit (void) {
     assert(r==0);
     
     DBT k,v;
-    r = toku_ft_insert(t,
-			toku_fill_dbt(&k, "hello", 6),
-			toku_fill_dbt(&v, "there", 6),
-			null_txn);
-    assert(r==0);
+    toku_ft_insert(t,
+                   toku_fill_dbt(&k, "hello", 6),
+                   toku_fill_dbt(&v, "there", 6),
+                   null_txn);
 
     memset(&v, 0, sizeof(v));
     struct check_pair pair = {6, "hello", 6, "there", 0};
@@ -63,7 +62,7 @@ doit (void) {
     assert(pair.call_count == 1);
 
     r = toku_close_ft_handle_nolsn(t, 0);    assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/test-dirty-flushes-on-cleaner.cc b/ft/tests/test-dirty-flushes-on-cleaner.cc
index 5f88e7cfd4e..72b830750b2 100644
--- a/ft/tests/test-dirty-flushes-on-cleaner.cc
+++ b/ft/tests/test-dirty-flushes-on-cleaner.cc
@@ -52,7 +52,7 @@ doit (void) {
     XMALLOC_N(fnamelen, fname);
 
     snprintf(fname, fnamelen, "%s.ft_handle", __SRCFILE__);
-    r = toku_create_cachetable(&ct, 500*1024*1024, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 500*1024*1024, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
     r = toku_open_ft_handle(fname, 1, &brt, NODESIZE, NODESIZE/2, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     assert(r==0);
@@ -266,7 +266,7 @@ doit (void) {
 
 
     r = toku_close_ft_handle_nolsn(brt, 0);    assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
 
     toku_free(pivots[0]);
 }
diff --git a/ft/tests/test-dump-ft.cc b/ft/tests/test-dump-ft.cc
index 4b63e3350a7..05542b141a3 100644
--- a/ft/tests/test-dump-ft.cc
+++ b/ft/tests/test-dump-ft.cc
@@ -21,7 +21,7 @@ test_main(int argc, const char *argv[]) {
     FILE *f = fopen("test-dump-ft.out", "w");
     unlink(n);
     assert(f);
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);   assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(n, 1, &t, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun); assert(r==0);
     int i;
     for (i=0; i<10000; i++) {
@@ -29,12 +29,11 @@ test_main(int argc, const char *argv[]) {
 	DBT k,v;
 	snprintf(key, 100, "key%d", i);
 	snprintf(val, 100, "val%d", i);
-	r = toku_ft_insert(t, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), null_txn);
-	assert(r==0);
+	toku_ft_insert(t, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), null_txn);
     }
     r = toku_dump_ft(f, t); assert(r==0);
     r = toku_close_ft_handle_nolsn(t, 0); assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
     fclose(f);
     return 0;
 }
diff --git a/ft/tests/test-flushes-on-cleaner.cc b/ft/tests/test-flushes-on-cleaner.cc
index 650b80e9ab0..60966b5906d 100644
--- a/ft/tests/test-flushes-on-cleaner.cc
+++ b/ft/tests/test-flushes-on-cleaner.cc
@@ -52,7 +52,7 @@ doit (bool keep_other_bn_in_memory) {
     XMALLOC_N(fnamelen, fname);
 
     snprintf(fname, fnamelen, "%s.ft_handle", __SRCFILE__);
-    r = toku_create_cachetable(&ct, 500*1024*1024, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 500*1024*1024, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
     r = toku_open_ft_handle(fname, 1, &brt, NODESIZE, NODESIZE/2, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     assert(r==0);
@@ -295,7 +295,7 @@ doit (bool keep_other_bn_in_memory) {
 
 
     r = toku_close_ft_handle_nolsn(brt, 0);    assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
 
     toku_free(pivots[0]);
 }
diff --git a/ft/tests/test-ft-overflow.cc b/ft/tests/test-ft-overflow.cc
index a92f978660a..414fa3b3caa 100644
--- a/ft/tests/test-ft-overflow.cc
+++ b/ft/tests/test-ft-overflow.cc
@@ -21,7 +21,7 @@ test_overflow (void) {
     uint32_t nodesize = 1<<20; 
     int r;
     unlink(fname);
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);         assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 1, &t, nodesize, nodesize / 8, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun); assert(r==0);
 
     DBT k,v;
@@ -31,11 +31,10 @@ test_overflow (void) {
     int i;
     for (i=0; i<8; i++) {
 	char key[]={(char)('a'+i), 0};
-	r = toku_ft_insert(t, toku_fill_dbt(&k, key, 2), toku_fill_dbt(&v,buf,sizeof(buf)), null_txn);
-	assert(r==0);
+	toku_ft_insert(t, toku_fill_dbt(&k, key, 2), toku_fill_dbt(&v,buf,sizeof(buf)), null_txn);
     }
     r = toku_close_ft_handle_nolsn(t, 0);        assert(r==0);
-    r = toku_cachetable_close(&ct);     assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/test-ft-txns.h b/ft/tests/test-ft-txns.h
index 6f4adcb48d3..a64339ada47 100644
--- a/ft/tests/test-ft-txns.h
+++ b/ft/tests/test-ft-txns.h
@@ -28,8 +28,7 @@ test_setup(TOKULOGGER *loggerp, CACHETABLE *ctp) {
     r = toku_logger_open(TESTDIR, logger);
     CKERR(r);
 
-    r = toku_create_cachetable(ctp, 0, ZERO_LSN, logger);
-    CKERR(r);
+    toku_cachetable_create(ctp, 0, ZERO_LSN, logger);
     CACHETABLE ct = *ctp;
     toku_cachetable_set_env_dir(ct, TESTDIR);
 
@@ -68,8 +67,7 @@ static inline void test_setup_and_recover(TOKULOGGER *loggerp, CACHETABLE *ctp)
         invariant(ct==NULL);
         r = toku_logger_open(TESTDIR, logger);
         CKERR(r);
-        r = toku_create_cachetable(&ct, 0, ZERO_LSN, logger);
-        CKERR(r);
+        toku_cachetable_create(&ct, 0, ZERO_LSN, logger);
         toku_logger_set_cachetable(logger, ct);
     }
     *ctp = ct;
@@ -82,17 +80,15 @@ static inline void clean_shutdown(TOKULOGGER *loggerp, CACHETABLE *ctp) {
     r = toku_checkpoint(cp, *loggerp, NULL, NULL, NULL, NULL, SHUTDOWN_CHECKPOINT);
     CKERR(r);
 
-    r = toku_logger_close_rollback(*loggerp, false);
+    r = toku_logger_close_rollback(*loggerp);
     CKERR(r);
 
     r = toku_checkpoint(cp, *loggerp, NULL, NULL, NULL, NULL, SHUTDOWN_CHECKPOINT);
     CKERR(r);
 
-    r = toku_logger_shutdown(*loggerp);
-    CKERR(r);
+    toku_logger_shutdown(*loggerp);
 
-    r = toku_cachetable_close(ctp);
-    CKERR(r);
+    toku_cachetable_close(ctp);
 
     r = toku_logger_close(loggerp);
     CKERR(r);
@@ -100,10 +96,9 @@ static inline void clean_shutdown(TOKULOGGER *loggerp, CACHETABLE *ctp) {
 
 static inline void shutdown_after_recovery(TOKULOGGER *loggerp, CACHETABLE *ctp) {
     int r;
-    r = toku_logger_close_rollback(*loggerp, false);
-    CKERR(r);
-    r = toku_cachetable_close(ctp);
+    r = toku_logger_close_rollback(*loggerp);
     CKERR(r);
+    toku_cachetable_close(ctp);
     r = toku_logger_close(loggerp);
     CKERR(r);
 }
diff --git a/ft/tests/test-inc-split.cc b/ft/tests/test-inc-split.cc
index 4ab12403946..bf5c9ae8e4d 100644
--- a/ft/tests/test-inc-split.cc
+++ b/ft/tests/test-inc-split.cc
@@ -57,7 +57,7 @@ doit (int ksize __attribute__((__unused__))) {
     XMALLOC_N(fnamelen, fname);
 
     snprintf(fname, fnamelen, "%s.ft_handle", __SRCFILE__);
-    r = toku_create_cachetable(&ct, 16*1024, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 16*1024, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
     r = toku_open_ft_handle(fname, 1, &t, NODESIZE, NODESIZE, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     assert(r==0);
@@ -123,17 +123,17 @@ doit (int ksize __attribute__((__unused__))) {
 	int keylen=1+snprintf(key, sizeof(key), "%08d", 4);
 	int vallen=magic_size;
 	snprintf(data, magic_size, "%*s", magic_size-1, " ");
-	r=toku_ft_insert(t,
-			  toku_fill_dbt(&k, key, keylen),
-			  toku_fill_dbt(&v, data, vallen),
-			  null_txn);
+	toku_ft_insert(t,
+                      toku_fill_dbt(&k, key, keylen),
+                      toku_fill_dbt(&v, data, vallen),
+                      null_txn);
     }
 
     r = toku_testsetup_root(t, anode);
     assert(r==0);
 
     r = toku_close_ft_handle_nolsn(t, 0);    assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
 
     //printf("ksize=%d, unused\n", ksize);
 
diff --git a/ft/tests/test-merges-on-cleaner.cc b/ft/tests/test-merges-on-cleaner.cc
index e5fd74e8a32..580bc1cc060 100644
--- a/ft/tests/test-merges-on-cleaner.cc
+++ b/ft/tests/test-merges-on-cleaner.cc
@@ -51,7 +51,7 @@ doit (void) {
     XMALLOC_N(fnamelen, fname);
 
     snprintf(fname, fnamelen, "%s.ft_handle", __SRCFILE__);
-    r = toku_create_cachetable(&ct, 500*1024*1024, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 500*1024*1024, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
     r = toku_open_ft_handle(fname, 1, &brt, NODESIZE, NODESIZE/2, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     assert(r==0);
@@ -210,7 +210,7 @@ doit (void) {
 
 
     r = toku_close_ft_handle_nolsn(brt, 0);    assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
 
     toku_free(pivots[0]);
 }
diff --git a/ft/tests/test-pick-child-to-flush.cc b/ft/tests/test-pick-child-to-flush.cc
index fe2cb627dc2..9c4b06bc26b 100644
--- a/ft/tests/test-pick-child-to-flush.cc
+++ b/ft/tests/test-pick-child-to-flush.cc
@@ -85,7 +85,7 @@ doit (void) {
     XMALLOC_N(fnamelen, fname);
 
     snprintf(fname, fnamelen, "%s.ft_handle", __SRCFILE__);
-    r = toku_create_cachetable(&ct, 500*1024*1024, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 500*1024*1024, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
     r = toku_open_ft_handle(fname, 1, &t, NODESIZE, NODESIZE/2, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     assert(r==0);
@@ -300,7 +300,7 @@ doit (void) {
     assert(num_flushes_called == 2);
     
     r = toku_close_ft_handle_nolsn(t, 0);    assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
 
     toku_free(pivots[0]);
 }
diff --git a/ft/tests/test3681.cc b/ft/tests/test3681.cc
index deac90e1c8e..999d3b3f23e 100644
--- a/ft/tests/test3681.cc
+++ b/ft/tests/test3681.cc
@@ -22,7 +22,7 @@ static TOKUTXN const null_txn = 0;
 volatile bool done = false;
 
 static void setup (void) {
-    { int r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);                                  assert(r==0); }
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     char fname[] = __SRCFILE__ "test1.dat";
     unlink(fname);
     { int r = toku_open_ft_handle(fname, 1, &t, 1024, 256, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);         assert(r==0); }
@@ -31,7 +31,7 @@ static void setup (void) {
 
 static void finish (void) {
     { int r = toku_close_ft_handle_nolsn(t, 0);                                                                       assert(r==0); };
-    { int r = toku_cachetable_close(&ct);                                                    assert(r == 0 && ct == 0); }
+    toku_cachetable_close(&ct);
 }
 
 static void *starta (void *n) {
@@ -41,8 +41,7 @@ static void *starta (void *n) {
 	char ks[20], vs[20];
 	snprintf(ks, sizeof(ks), "hello%03d", i);
 	snprintf(vs, sizeof(vs), "there%03d", i);
-	int r = toku_ft_insert(t, toku_fill_dbt(&k, ks, strlen(ks)), toku_fill_dbt(&v, vs, strlen(vs)), null_txn);
-	assert(r==0);
+	toku_ft_insert(t, toku_fill_dbt(&k, ks, strlen(ks)), toku_fill_dbt(&v, vs, strlen(vs)), null_txn);
 	usleep(1);
     }
     done = true;
diff --git a/ft/tests/test3856.cc b/ft/tests/test3856.cc
index e81ada7ea29..31263713a25 100644
--- a/ft/tests/test3856.cc
+++ b/ft/tests/test3856.cc
@@ -38,22 +38,21 @@ test_main (int argc __attribute__((__unused__)), const char *argv[] __attribute_
     CACHETABLE ct;
     FT_HANDLE t;
 
-    int r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
-    r = toku_open_ft_handle(fname, 1, &t, nodesize, basementnodesize, compression_method, ct, null_txn, string_cmp); assert(r==0);
+    int r = toku_open_ft_handle(fname, 1, &t, nodesize, basementnodesize, compression_method, ct, null_txn, string_cmp); assert(r==0);
 
     for (int i = 0; i < count; ++i) {
         char key[100],val[100];
         DBT k,v;
         snprintf(key, 100, "hello%d", i);
         snprintf(val, 100, "there%d", i);
-        r = toku_ft_insert(t, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), null_txn);
-        assert(r==0);
+        toku_ft_insert(t, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), null_txn);
     }
     r = toku_close_ft_handle_nolsn(t, 0); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0);
+    toku_cachetable_close(&ct);
 
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER); assert(r == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 1, &t, nodesize, basementnodesize, compression_method, ct, null_txn, string_cmp); assert(r == 0);
 
     for (int n = 0; n < count/100; ++n) {
@@ -71,11 +70,11 @@ test_main (int argc __attribute__((__unused__)), const char *argv[] __attribute_
         for (int j = 0; j < 100; ++j) {
             r = toku_ft_cursor_next(c, found, NULL); assert(r == 0);
         }
-        r = toku_ft_cursor_close(c); assert(r == 0);
+        toku_ft_cursor_close(c);
     }
 
     r = toku_close_ft_handle_nolsn(t, 0); assert(r == 0);
-    r = toku_cachetable_close(&ct), assert(r == 0);
+    toku_cachetable_close(&ct);
 
     return 0;
 }
diff --git a/ft/tests/test3884.cc b/ft/tests/test3884.cc
index 863ae80d68f..920d3993916 100644
--- a/ft/tests/test3884.cc
+++ b/ft/tests/test3884.cc
@@ -165,7 +165,7 @@ test_split_on_boundary(void)
     unlink(fname);
     CACHETABLE ct;
     FT_HANDLE brt;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);   assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 1, &brt, nodesize, bnsize, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun); assert(r==0);
 
     FTNODE nodea, nodeb;
@@ -178,7 +178,7 @@ test_split_on_boundary(void)
 
     toku_unpin_ftnode(brt->ft, nodeb);
     r = toku_close_ft_handle_nolsn(brt, NULL); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0);
+    toku_cachetable_close(&ct);
 
     if (splitk.data) {
         toku_free(splitk.data);
@@ -238,7 +238,7 @@ test_split_with_everything_on_the_left(void)
     unlink(fname);
     CACHETABLE ct;
     FT_HANDLE brt;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);   assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 1, &brt, nodesize, bnsize, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun); assert(r==0);
 
     FTNODE nodea, nodeb;
@@ -248,7 +248,7 @@ test_split_with_everything_on_the_left(void)
 
     toku_unpin_ftnode(brt->ft, nodeb);
     r = toku_close_ft_handle_nolsn(brt, NULL); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0);
+    toku_cachetable_close(&ct);
 
     if (splitk.data) {
         toku_free(splitk.data);
@@ -313,7 +313,7 @@ test_split_on_boundary_of_last_node(void)
     unlink(fname);
     CACHETABLE ct;
     FT_HANDLE brt;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);   assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 1, &brt, nodesize, bnsize, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun); assert(r==0);
 
     FTNODE nodea, nodeb;
@@ -323,7 +323,7 @@ test_split_on_boundary_of_last_node(void)
 
     toku_unpin_ftnode(brt->ft, nodeb);
     r = toku_close_ft_handle_nolsn(brt, NULL); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0);
+    toku_cachetable_close(&ct);
 
     if (splitk.data) {
         toku_free(splitk.data);
@@ -381,7 +381,7 @@ test_split_at_begin(void)
     unlink(fname);
     CACHETABLE ct;
     FT_HANDLE brt;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);   assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 1, &brt, nodesize, bnsize, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun); assert(r==0);
 
     FTNODE nodea, nodeb;
@@ -391,7 +391,7 @@ test_split_at_begin(void)
 
     toku_unpin_ftnode(brt->ft, nodeb);
     r = toku_close_ft_handle_nolsn(brt, NULL); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0);
+    toku_cachetable_close(&ct);
 
     if (splitk.data) {
         toku_free(splitk.data);
@@ -445,7 +445,7 @@ test_split_at_end(void)
     unlink(fname);
     CACHETABLE ct;
     FT_HANDLE brt;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);   assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 1, &brt, nodesize, bnsize, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun); assert(r==0);
 
     FTNODE nodea, nodeb;
@@ -455,7 +455,7 @@ test_split_at_end(void)
 
     toku_unpin_ftnode(brt->ft, nodeb);
     r = toku_close_ft_handle_nolsn(brt, NULL); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0);
+    toku_cachetable_close(&ct);
 
     if (splitk.data) {
         toku_free(splitk.data);
@@ -499,7 +499,7 @@ test_split_odd_nodes(void)
     unlink(fname);
     CACHETABLE ct;
     FT_HANDLE brt;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);   assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 1, &brt, nodesize, bnsize, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun); assert(r==0);
 
     FTNODE nodea, nodeb;
@@ -512,7 +512,7 @@ test_split_odd_nodes(void)
 
     toku_unpin_ftnode(brt->ft, nodeb);
     r = toku_close_ft_handle_nolsn(brt, NULL); assert(r == 0);
-    r = toku_cachetable_close(&ct); assert(r == 0);
+    toku_cachetable_close(&ct);
 
     if (splitk.data) {
         toku_free(splitk.data);
diff --git a/ft/tests/test4115.cc b/ft/tests/test4115.cc
index 0f694a2df99..ffa60f16d1d 100644
--- a/ft/tests/test4115.cc
+++ b/ft/tests/test4115.cc
@@ -26,15 +26,15 @@ static int dont_allow_prefix (DB *db __attribute__((__unused__)), const DBT *a,
 static void close_ft_and_ct (void) {
     int r;
     r = toku_close_ft_handle_nolsn(t, 0);          assert(r==0);
-    r = toku_cachetable_close(&ct);    assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 static void open_ft_and_ct (bool unlink_old) {
     int r;
     if (unlink_old) unlink(fname);
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);                                assert(r==0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 1, &t, 1<<12, 1<<9, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);   assert(r==0);
-    r = toku_ft_set_bt_compare(t, dont_allow_prefix);
+    toku_ft_set_bt_compare(t, dont_allow_prefix);
 }
 
 static void test_4115 (void) {
@@ -45,12 +45,10 @@ static void test_4115 (void) {
 	snprintf(key, 100, "%08llu", (unsigned long long)2*i+1);
 	snprintf(val, 100, "%08llu", (unsigned long long)2*i+1);
 	DBT k,v;
-	int r = toku_ft_insert(t, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v,val, 1+strlen(val)), null_txn);
-	assert(r == 0);
+	toku_ft_insert(t, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v,val, 1+strlen(val)), null_txn);
     }
     struct ftstat64_s s;
-    int r = toku_ft_handle_stat64(t, NULL, &s);
-    assert(r==0);
+    toku_ft_handle_stat64(t, NULL, &s);
     assert(s.nkeys>0);
     assert(s.dsize>0);
     close_ft_and_ct();
diff --git a/ft/tests/test4244.cc b/ft/tests/test4244.cc
index f4386fff46c..1d13f1cc780 100644
--- a/ft/tests/test4244.cc
+++ b/ft/tests/test4244.cc
@@ -30,7 +30,7 @@ doit (void) {
     XMALLOC_N(fnamelen, fname);
 
     snprintf(fname, fnamelen, "%s.ft_handle", __SRCFILE__);
-    r = toku_create_cachetable(&ct, 500*1024*1024, ZERO_LSN, NULL_LOGGER); assert(r==0);
+    toku_cachetable_create(&ct, 500*1024*1024, ZERO_LSN, NULL_LOGGER);
     unlink(fname);
     r = toku_open_ft_handle(fname, 1, &t, NODESIZE, NODESIZE/2, TOKU_DEFAULT_COMPRESSION_METHOD, ct, null_txn, toku_builtin_compare_fun);
     assert(r==0);
@@ -57,11 +57,10 @@ doit (void) {
     memset(&k, 0, sizeof(k));
     memset(&v, 0, sizeof(v));
     for (int i = 0; i < 100; i++) {
-        r = toku_ft_insert(t,
-                            toku_fill_dbt(&k, "hello", 6),
-                            toku_fill_dbt(&v, big_val, big_val_size),
-                            null_txn);
-        assert(r==0);
+        toku_ft_insert(t,
+                       toku_fill_dbt(&k, "hello", 6),
+                       toku_fill_dbt(&v, big_val, big_val_size),
+                       null_txn);
     }
     toku_free(big_val);
 
@@ -89,7 +88,7 @@ doit (void) {
     toku_unpin_ftnode_off_client_thread(t->ft, node);
 
     r = toku_close_ft_handle_nolsn(t, 0);    assert(r==0);
-    r = toku_cachetable_close(&ct); assert(r==0);
+    toku_cachetable_close(&ct);
 }
 
 int
diff --git a/ft/tests/test_logcursor.cc b/ft/tests/test_logcursor.cc
index 218b8e7ee73..f3441f9b604 100644
--- a/ft/tests/test_logcursor.cc
+++ b/ft/tests/test_logcursor.cc
@@ -184,44 +184,43 @@ int create_logfiles() {
 
     // use old x1.tdb test log as basis
     //xbegin                    'b': lsn=1 parenttxnid=0 crc=00005f1f len=29
-    r = toku_log_xbegin(logger, &lsn, 1, NO_FSYNC, 0); assert(r==0); txnid = lsn.lsn;
+    toku_log_xbegin(logger, &lsn, 1, NO_FSYNC, 0); txnid = lsn.lsn;
     //fcreate                   'F': lsn=2 txnid=1 filenum=0 fname={len=4 data="a.db"} mode=0777 treeflags=0 crc=18a3d525 len=49
-    r = toku_log_fcreate(logger, &lsn, NO_FSYNC, NULL, txnid, fn_aname, bs_aname, 0x0777, 0, 0, TOKU_DEFAULT_COMPRESSION_METHOD, 0); assert(r==0);
+    toku_log_fcreate(logger, &lsn, NO_FSYNC, NULL, txnid, fn_aname, bs_aname, 0x0777, 0, 0, TOKU_DEFAULT_COMPRESSION_METHOD, 0);
     //commit                    'C': lsn=3 txnid=1 crc=00001f1e len=29
-    r = toku_log_xcommit(logger, &lsn, FSYNC, NULL, txnid); assert(r==0);
+    toku_log_xcommit(logger, &lsn, FSYNC, NULL, txnid);
     //xbegin                    'b': lsn=4 parenttxnid=0 crc=00000a1f len=29
-    r = toku_log_xbegin(logger, &lsn, 2, NO_FSYNC, 0); assert(r==0); txnid = lsn.lsn;
+    toku_log_xbegin(logger, &lsn, 2, NO_FSYNC, 0); txnid = lsn.lsn;
     //fcreate                   'F': lsn=5 txnid=4 filenum=1 fname={len=4 data="b.db"} mode=0777 treeflags=0 crc=14a47925 len=49
-    r = toku_log_fcreate(logger, &lsn, NO_FSYNC, NULL, txnid, fn_bname, bs_bname, 0x0777, 0, 0, TOKU_DEFAULT_COMPRESSION_METHOD, 0); assert(r==0);
+    toku_log_fcreate(logger, &lsn, NO_FSYNC, NULL, txnid, fn_bname, bs_bname, 0x0777, 0, 0, TOKU_DEFAULT_COMPRESSION_METHOD, 0);
     //commit                    'C': lsn=6 txnid=4 crc=0000c11e len=29
-    r = toku_log_xcommit(logger, &lsn, FSYNC, NULL, txnid); assert(r==0);
+    toku_log_xcommit(logger, &lsn, FSYNC, NULL, txnid);
     //xbegin                    'b': lsn=7 parenttxnid=0 crc=0000f91f len=29
-    r = toku_log_xbegin(logger, &lsn, 3, NO_FSYNC, 0); assert(r==0); txnid = lsn.lsn;
+    toku_log_xbegin(logger, &lsn, 3, NO_FSYNC, 0); txnid = lsn.lsn;
     //enq_insert                'I': lsn=8 filenum=0 xid=7 key={len=2 data="a\000"} value={len=2 data="b\000"} crc=40b863e4 len=45
-    r = toku_log_enq_insert(logger, &lsn, NO_FSYNC, NULL, fn_aname, txnid, bs_a, bs_b); assert(r==0);
+    toku_log_enq_insert(logger, &lsn, NO_FSYNC, NULL, fn_aname, txnid, bs_a, bs_b);
     //begin_checkpoint          'x': lsn=9 timestamp=1251309957584197 crc=cd067878 len=29
-    r = toku_log_begin_checkpoint(logger, &lsn, NO_FSYNC, 1251309957584197, 0); assert(r==0); cp_txnid = lsn.lsn;
+    toku_log_begin_checkpoint(logger, &lsn, NO_FSYNC, 1251309957584197, 0); cp_txnid = lsn.lsn;
     //fassociate                'f': lsn=11 filenum=1 fname={len=4 data="b.db"} crc=a7126035 len=33
-    r = toku_log_fassociate(logger, &lsn, NO_FSYNC, fn_bname, 0, bs_bname, 0); assert(r==0);
+    toku_log_fassociate(logger, &lsn, NO_FSYNC, fn_bname, 0, bs_bname, 0);
     num_fassociate++;
     //fassociate                'f': lsn=12 filenum=0 fname={len=4 data="a.db"} crc=a70c5f35 len=33
-    r = toku_log_fassociate(logger, &lsn, NO_FSYNC, fn_aname, 0, bs_aname, 0); assert(r==0);
+    toku_log_fassociate(logger, &lsn, NO_FSYNC, fn_aname, 0, bs_aname, 0);
     num_fassociate++;
    //xstillopen                's': lsn=10 txnid=7 parent=0 crc=00061816 len=37 <- obsolete
     {
         FILENUMS filenums = {0, NULL};
-        r = toku_log_xstillopen(logger, &lsn, NO_FSYNC, NULL, txnid, 0,
+        toku_log_xstillopen(logger, &lsn, NO_FSYNC, NULL, txnid, 0,
                                 0, filenums, 0, 0, 0,
                                 ROLLBACK_NONE, ROLLBACK_NONE, ROLLBACK_NONE);
-        assert(r==0);
     }
     num_xstillopen++;
     //end_checkpoint            'X': lsn=13 txnid=9 timestamp=1251309957586872 crc=cd285c30 len=37
-    r = toku_log_end_checkpoint(logger, &lsn, FSYNC, (LSN){cp_txnid}, 1251309957586872, num_fassociate, num_xstillopen); assert(r==0);
+    toku_log_end_checkpoint(logger, &lsn, FSYNC, (LSN){cp_txnid}, 1251309957586872, num_fassociate, num_xstillopen);
     //enq_insert                'I': lsn=14 filenum=1 xid=7 key={len=2 data="b\000"} value={len=2 data="a\000"} crc=40388be4 len=45
-    r = toku_log_enq_insert(logger, &lsn, NO_FSYNC, NULL, fn_bname, txnid, bs_b, bs_a); assert(r==0);
+    toku_log_enq_insert(logger, &lsn, NO_FSYNC, NULL, fn_bname, txnid, bs_b, bs_a);
     //commit                    'C': lsn=15 txnid=7 crc=00016d1e len=29
-    r = toku_log_xcommit(logger, &lsn, FSYNC, NULL, txnid); assert(r==0);
+    toku_log_xcommit(logger, &lsn, FSYNC, NULL, txnid);
 
     // close logger
     r = toku_logger_close(&logger); assert(r==0);
diff --git a/ft/tests/upgrade_test_simple.cc b/ft/tests/upgrade_test_simple.cc
index 347fb1c6f1e..3ff69ca34cd 100644
--- a/ft/tests/upgrade_test_simple.cc
+++ b/ft/tests/upgrade_test_simple.cc
@@ -37,7 +37,7 @@ get_one_value(FT_HANDLE t, CACHETABLE UU(ct), void *UU(extra))
     r = toku_ft_cursor_first(cursor, noop_getf, &called);
     CKERR(r);
     assert(called == 1);
-    r = toku_ft_cursor_close(cursor);
+    toku_ft_cursor_close(cursor);
     CKERR(r);
 
     return 0;
@@ -71,14 +71,12 @@ static int
 insert_something(FT_HANDLE t, CACHETABLE UU(ct), void *UU(extra))
 {
     assert(t);
-    int r = 0;
     unsigned int dummy_value = 1U << 31;
     DBT key;
     DBT val;
     toku_fill_dbt(&key, &dummy_value, sizeof(unsigned int));
     toku_fill_dbt(&val, &dummy_value, sizeof(unsigned int));
-    r = toku_ft_insert (t, &key, &val, 0);
-    CKERR(r);
+    toku_ft_insert (t, &key, &val, 0);
     return 0;
 }
 
@@ -91,8 +89,7 @@ with_open_tree(const char *fname, tree_cb cb, void *cb_extra)
     FT_HANDLE t;
     CACHETABLE ct;
 
-    r = toku_create_cachetable(&ct, 16*(1<<20), ZERO_LSN, NULL_LOGGER);
-    CKERR(r);
+    toku_cachetable_create(&ct, 16*(1<<20), ZERO_LSN, NULL_LOGGER);
     r = toku_open_ft_handle(fname, 
                       0, 
                       &t, 
@@ -113,8 +110,7 @@ with_open_tree(const char *fname, tree_cb cb, void *cb_extra)
     CKERR(r);
     r = toku_close_ft_handle_nolsn(t, 0);
     CKERR(r);
-    r = toku_cachetable_close(&ct);
-    CKERR(r);
+    toku_cachetable_close(&ct);
 
     return r2;
 }
diff --git a/ft/tests/verify-bad-msn.cc b/ft/tests/verify-bad-msn.cc
index f7e84e0bb45..1fb154d729e 100644
--- a/ft/tests/verify-bad-msn.cc
+++ b/ft/tests/verify-bad-msn.cc
@@ -126,8 +126,7 @@ test_make_tree(int height, int fanout, int nperleaf, int do_verify) {
 
     // create a cachetable
     CACHETABLE ct = NULL;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     // create the brt
     TOKUTXN null_txn = NULL;
@@ -158,8 +157,7 @@ test_make_tree(int height, int fanout, int nperleaf, int do_verify) {
     assert(r == 0);
 
     // shutdown the cachetable
-    r = toku_cachetable_close(&ct);
-    assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 static int
diff --git a/ft/tests/verify-bad-pivots.cc b/ft/tests/verify-bad-pivots.cc
index a2f9cee1d2d..141d8a31aba 100644
--- a/ft/tests/verify-bad-pivots.cc
+++ b/ft/tests/verify-bad-pivots.cc
@@ -96,8 +96,7 @@ test_make_tree(int height, int fanout, int nperleaf, int do_verify) {
 
     // create a cachetable
     CACHETABLE ct = NULL;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     // create the brt
     TOKUTXN null_txn = NULL;
@@ -125,8 +124,7 @@ test_make_tree(int height, int fanout, int nperleaf, int do_verify) {
     assert(r == 0);
 
     // shutdown the cachetable
-    r = toku_cachetable_close(&ct);
-    assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 static int
diff --git a/ft/tests/verify-dup-in-leaf.cc b/ft/tests/verify-dup-in-leaf.cc
index b79598bee39..6f87777a88c 100644
--- a/ft/tests/verify-dup-in-leaf.cc
+++ b/ft/tests/verify-dup-in-leaf.cc
@@ -54,8 +54,7 @@ test_dup_in_leaf(int do_verify) {
 
     // create a cachetable
     CACHETABLE ct = NULL;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     // create the brt
     TOKUTXN null_txn = NULL;
@@ -85,8 +84,7 @@ test_dup_in_leaf(int do_verify) {
     assert(r == 0);
 
     // shutdown the cachetable
-    r = toku_cachetable_close(&ct);
-    assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 static int
diff --git a/ft/tests/verify-dup-pivots.cc b/ft/tests/verify-dup-pivots.cc
index e08b97cf7ed..4a7d2b50d7f 100644
--- a/ft/tests/verify-dup-pivots.cc
+++ b/ft/tests/verify-dup-pivots.cc
@@ -99,8 +99,7 @@ test_make_tree(int height, int fanout, int nperleaf, int do_verify) {
 
     // create a cachetable
     CACHETABLE ct = NULL;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     // create the brt
     TOKUTXN null_txn = NULL;
@@ -129,8 +128,7 @@ test_make_tree(int height, int fanout, int nperleaf, int do_verify) {
     assert(r == 0);
 
     // shutdown the cachetable
-    r = toku_cachetable_close(&ct);
-    assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 static int
diff --git a/ft/tests/verify-misrouted-msgs.cc b/ft/tests/verify-misrouted-msgs.cc
index 5a5523d0a37..6c58c3c4e8a 100644
--- a/ft/tests/verify-misrouted-msgs.cc
+++ b/ft/tests/verify-misrouted-msgs.cc
@@ -111,8 +111,7 @@ test_make_tree(int height, int fanout, int nperleaf, int do_verify) {
 
     // create a cachetable
     CACHETABLE ct = NULL;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     // create the brt
     TOKUTXN null_txn = NULL;
@@ -141,8 +140,7 @@ test_make_tree(int height, int fanout, int nperleaf, int do_verify) {
     assert(r == 0);
 
     // shutdown the cachetable
-    r = toku_cachetable_close(&ct);
-    assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 static int
diff --git a/ft/tests/verify-unsorted-leaf.cc b/ft/tests/verify-unsorted-leaf.cc
index 428aa1eb6fd..8ad91eed5c3 100644
--- a/ft/tests/verify-unsorted-leaf.cc
+++ b/ft/tests/verify-unsorted-leaf.cc
@@ -56,8 +56,7 @@ test_dup_in_leaf(int do_verify) {
 
     // create a cachetable
     CACHETABLE ct = NULL;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     // create the brt
     TOKUTXN null_txn = NULL;
@@ -86,8 +85,7 @@ test_dup_in_leaf(int do_verify) {
     assert(r == 0);
 
     // shutdown the cachetable
-    r = toku_cachetable_close(&ct);
-    assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 static int
diff --git a/ft/tests/verify-unsorted-pivots.cc b/ft/tests/verify-unsorted-pivots.cc
index 2eb925be279..0b848792ecd 100644
--- a/ft/tests/verify-unsorted-pivots.cc
+++ b/ft/tests/verify-unsorted-pivots.cc
@@ -96,8 +96,7 @@ test_make_tree(int height, int fanout, int nperleaf, int do_verify) {
 
     // create a cachetable
     CACHETABLE ct = NULL;
-    r = toku_create_cachetable(&ct, 0, ZERO_LSN, NULL_LOGGER);
-    assert(r == 0);
+    toku_cachetable_create(&ct, 0, ZERO_LSN, NULL_LOGGER);
 
     // create the brt
     TOKUTXN null_txn = NULL;
@@ -125,8 +124,7 @@ test_make_tree(int height, int fanout, int nperleaf, int do_verify) {
     assert(r == 0);
 
     // shutdown the cachetable
-    r = toku_cachetable_close(&ct);
-    assert(r == 0);
+    toku_cachetable_close(&ct);
 }
 
 static int
diff --git a/ft/tests/xid_lsn_independent.cc b/ft/tests/xid_lsn_independent.cc
index c72108ac0f2..dc09b11bd87 100644
--- a/ft/tests/xid_lsn_independent.cc
+++ b/ft/tests/xid_lsn_independent.cc
@@ -61,8 +61,7 @@ static void test_xid_lsn_independent(int N) {
 	snprintf(key, sizeof(key), "key%x.%x", rands[i], i);
 	memset(val, 'v', sizeof(val));
 	val[sizeof(val)-1]=0;
-	r = toku_ft_insert(brt, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), txn);
-        CKERR(r);
+	toku_ft_insert(brt, toku_fill_dbt(&k, key, 1+strlen(key)), toku_fill_dbt(&v, val, 1+strlen(val)), txn);
     }
     {
         TOKUTXN txn2;
@@ -117,11 +116,9 @@ static void test_xid_lsn_independent_crash_recovery(int N) {
 
     TXNID last_xid_before = logger_get_last_xid(logger);
 
-    r = toku_logger_close_rollback(logger, false);
-    CKERR(r);
+    toku_logger_close_rollback(logger);
 
-    r = toku_cachetable_close(&ct);
-    CKERR(r);
+    toku_cachetable_close(&ct);
     // "Crash"
     r = toku_logger_close(&logger);
     CKERR(r);
diff --git a/ft/txn.cc b/ft/txn.cc
index a14e5593837..8ea6ffa0db7 100644
--- a/ft/txn.cc
+++ b/ft/txn.cc
@@ -111,8 +111,7 @@ static void invalidate_xa_xid (TOKU_XA_XID *xid) {
     xid->formatID = -1; // According to the XA spec, -1 means "invalid data"
 }
 
-int
-toku_txn_create_txn (
+void toku_txn_create_txn (
     TOKUTXN *tokutxn, 
     TOKUTXN parent_tokutxn, 
     TOKULOGGER logger, 
@@ -122,9 +121,6 @@ toku_txn_create_txn (
     bool for_checkpoint
     )
 {
-    if (logger->is_panicked) {
-        return EINVAL;
-    }
     assert(logger->rollback_cachefile);
 
     omt<FT> open_fts;
@@ -181,8 +177,6 @@ toku_txn_create_txn (
     STATUS_VALUE(TXN_NUM_OPEN)++;
     if (STATUS_VALUE(TXN_NUM_OPEN) > STATUS_VALUE(TXN_MAX_OPEN))
         STATUS_VALUE(TXN_MAX_OPEN) = STATUS_VALUE(TXN_NUM_OPEN);
-
-    return 0;
 }
 
 void
@@ -271,8 +265,6 @@ int toku_txn_commit_with_lsn(TOKUTXN txn, int nosync, LSN oplsn,
                              TXN_PROGRESS_POLL_FUNCTION poll, void *poll_extra) 
 {
     toku_txn_manager_note_commit_txn(txn->logger->txn_manager, txn);
-    int r;
-    // panic handled in log_commit
 
     // Child transactions do not actually 'commit'.  They promote their 
     // changes to parent, so no need to fsync if this txn has a parent. The
@@ -289,18 +281,14 @@ int toku_txn_commit_with_lsn(TOKUTXN txn, int nosync, LSN oplsn,
     txn->progress_poll_fun_extra = poll_extra;
 
     if (!toku_txn_is_read_only(txn)) {
-        r = toku_log_xcommit(txn->logger, &txn->do_fsync_lsn, 0, txn, txn->txnid64);
-        if (r != 0) {
-            goto cleanup;
-        }
+        toku_log_xcommit(txn->logger, &txn->do_fsync_lsn, 0, txn, txn->txnid64);
     }
     // If !txn->begin_was_logged, we could skip toku_rollback_commit
     // but it's cheap (only a number of function calls that return immediately)
     // since there were no writes.  Skipping it would mean we would need to be careful
     // in case we added any additional required cleanup into those functions in the future.
-    r = toku_rollback_commit(txn, oplsn);
+    int r = toku_rollback_commit(txn, oplsn);
     STATUS_VALUE(TXN_COMMIT)++;
-cleanup:
     return r;
 }
 
@@ -320,22 +308,17 @@ int toku_txn_abort_with_lsn(TOKUTXN txn, LSN oplsn,
 
     txn->progress_poll_fun = poll;
     txn->progress_poll_fun_extra = poll_extra;
-    int r;
     txn->do_fsync = false;
 
     if (!toku_txn_is_read_only(txn)) {
-        r = toku_log_xabort(txn->logger, &txn->do_fsync_lsn, 0, txn, txn->txnid64);
-        if (r != 0) {
-            goto cleanup;
-        }
+        toku_log_xabort(txn->logger, &txn->do_fsync_lsn, 0, txn, txn->txnid64);
     }
     // If !txn->begin_was_logged, we could skip toku_rollback_abort
     // but it's cheap (only a number of function calls that return immediately)
     // since there were no writes.  Skipping it would mean we would need to be careful
     // in case we added any additional required cleanup into those functions in the future.
-    r = toku_rollback_abort(txn, oplsn);
+    int r = toku_rollback_abort(txn, oplsn);
     STATUS_VALUE(TXN_ABORT)++;
-cleanup:
     return r;
 }
 
@@ -347,23 +330,20 @@ static void copy_xid (TOKU_XA_XID *dest, TOKU_XA_XID *source) {
     memcpy(dest->data, source->data, source->gtrid_length+source->bqual_length);
 }
 
-int toku_txn_prepare_txn (TOKUTXN txn, TOKU_XA_XID *xa_xid) {
-    int r = 0;
+void toku_txn_prepare_txn (TOKUTXN txn, TOKU_XA_XID *xa_xid) {
     if (txn->parent || toku_txn_is_read_only(txn)) {
         // We do not prepare children.
         //
         // Readonly transactions do the same if they commit or abort, so
         // XA guarantees are free.  No need to pay for overhead of prepare.
-        goto cleanup;
+        return;
     }
     toku_txn_manager_add_prepared_txn(txn->logger->txn_manager, txn);
     // Do we need to do an fsync?
     txn->do_fsync = (txn->force_fsync_on_commit || txn->roll_info.num_rollentries>0);
     copy_xid(&txn->xa_xid, xa_xid);
     // This list will go away with #4683, so we wn't need the ydb lock for this anymore.
-    r = toku_log_xprepare(txn->logger, &txn->do_fsync_lsn, 0, txn, txn->txnid64, xa_xid);
-cleanup:
-    return r;
+    toku_log_xprepare(txn->logger, &txn->do_fsync_lsn, 0, txn, txn->txnid64, xa_xid);
 }
 
 void toku_txn_get_prepared_xa_xid (TOKUTXN txn, TOKU_XA_XID *xid) {
@@ -481,7 +461,7 @@ static void
 maybe_log_begin_txn_for_write_operation_unlocked(TOKUTXN txn) {
     // We now hold the lock.
     if (txn->begin_was_logged) {
-        goto cleanup;
+        return;
     }
     TOKUTXN parent;
     parent = txn->parent;
@@ -497,13 +477,8 @@ maybe_log_begin_txn_for_write_operation_unlocked(TOKUTXN txn) {
         pxid = parent->txnid64;
     }
 
-    int r;
-    r = toku_log_xbegin(txn->logger, NULL, 0, xid, pxid);
-    lazy_assert_zero(r);
-
+    toku_log_xbegin(txn->logger, NULL, 0, xid, pxid);
     txn->begin_was_logged = true;
-cleanup:
-    return;
 }
 
 void
diff --git a/ft/txn.h b/ft/txn.h
index 07a391a4d86..bcb9e074db1 100644
--- a/ft/txn.h
+++ b/ft/txn.h
@@ -37,7 +37,7 @@ int toku_txn_begin_with_xid (
     );
 
 // Allocate and initialize a txn
-int toku_txn_create_txn(TOKUTXN *txn_ptr, TOKUTXN parent, TOKULOGGER logger, TXN_SNAPSHOT_TYPE snapshot_type, DB_TXN *container_db_txn, XIDS xids, bool for_checkpoint);
+void toku_txn_create_txn(TOKUTXN *txn_ptr, TOKUTXN parent, TOKULOGGER logger, TXN_SNAPSHOT_TYPE snapshot_type, DB_TXN *container_db_txn, XIDS xids, bool for_checkpoint);
 void toku_txn_update_xids_in_txn(TOKUTXN txn, TXNID xid);
 
 int toku_txn_load_txninfo (TOKUTXN txn, TXNINFO info);
@@ -53,7 +53,7 @@ int toku_txn_abort_txn(TOKUTXN txn,
 int toku_txn_abort_with_lsn(TOKUTXN txn, LSN oplsn,
                             TXN_PROGRESS_POLL_FUNCTION poll, void *poll_extra);
 
-int toku_txn_prepare_txn (TOKUTXN txn, TOKU_XA_XID *xid) __attribute__((warn_unused_result));
+void toku_txn_prepare_txn (TOKUTXN txn, TOKU_XA_XID *xid);
 // Effect: Do the internal work of preparing a transaction (does not log the prepare record).
 
 void toku_txn_get_prepared_xa_xid (TOKUTXN, TOKU_XA_XID *);
diff --git a/ft/txn_manager.cc b/ft/txn_manager.cc
index 4cc2aac9e5d..e3fea6b8f3c 100644
--- a/ft/txn_manager.cc
+++ b/ft/txn_manager.cc
@@ -280,11 +280,7 @@ int toku_txn_manager_start_txn(
         return r;
     }
 
-    r = toku_txn_create_txn(&txn, parent, logger, snapshot_type, container_db_txn, xids, for_recovery);
-    if (r != 0) {
-        // logger is panicked
-        return r;
-    }
+    toku_txn_create_txn(&txn, parent, logger, snapshot_type, container_db_txn, xids, for_recovery);
 
     // the act of getting a transaction ID and adding the
     // txn to the proper OMTs must be atomic. MVCC depends
diff --git a/ft/ule.cc b/ft/ule.cc
index 3914bc190b1..fc61a475587 100644
--- a/ft/ule.cc
+++ b/ft/ule.cc
@@ -2101,54 +2101,6 @@ verify_is_empty:;
     return r;
 }
 
-void
-le_clean(uint8_t *key, uint32_t keylen,
-         uint8_t *val, uint32_t vallen,
-         void (*bytes)(struct dbuf *dbuf, const void *bytes, int nbytes),
-         struct dbuf *d) {
-    struct leafentry le = {
-        .type = LE_CLEAN,
-        .keylen = toku_htod32(keylen),
-        .u = { .clean = { .vallen = toku_htod32(vallen) } }
-    };
-    size_t header_size = __builtin_offsetof(struct leafentry, u.clean) + sizeof(le.u.clean);
-    invariant(header_size==1+4+4);
-    bytes(d, &le, header_size); //Fixed
-    bytes(d, key, keylen); //key
-    bytes(d, val, vallen); //val
-}
-
-void
-le_committed_mvcc(uint8_t *key, uint32_t keylen,
-                  uint8_t *val, uint32_t vallen,
-                  TXNID xid,
-                  void (*bytes)(struct dbuf *dbuf, const void *bytes, int nbytes),
-                  struct dbuf *d) {
-    struct leafentry le = {
-        .type = LE_MVCC,
-        .keylen = toku_htod32(keylen),
-        .u = { .mvcc = {
-                .num_cxrs = toku_htod32(2), //TXNID_NONE and xid each have committed xrs
-                .num_pxrs = 0               //No provisional
-            }
-        }
-    };
-    size_t header_size = __builtin_offsetof(struct leafentry, u.mvcc) + sizeof(le.u.mvcc);
-    invariant(header_size==1+4+4+1);
-    bytes(d, &le, header_size); //Fixed
-    bytes(d, key, keylen); //key
-    invariant(xid!=TXNID_NONE);
-    xid = toku_htod64(xid);
-    bytes(d, &xid, 8); //xid of transaction
-                       //TXNID_NONE is implicit
-    uint32_t insert_length_and_bit = toku_htod32(INSERT_LENGTH(vallen));
-    bytes(d, &insert_length_and_bit, 4); //vallen insert
-    uint32_t delete_length_and_bit = toku_htod32(DELETE_LENGTH(0));
-    bytes(d, &delete_length_and_bit, 4); //committed delete
-    bytes(d, val, vallen); //val
-}
-
-
 #if TOKU_WINDOWS
 #pragma pack(push, 1)
 #endif
diff --git a/ft/xids.cc b/ft/xids.cc
index b25cfabfed7..6bf27f9f7c7 100644
--- a/ft/xids.cc
+++ b/ft/xids.cc
@@ -209,35 +209,12 @@ xids_get_serialize_size(XIDS xids){
 }
 
 
-// Include TXNID zero in checksum to maintain compatibility
-// with previously released version.  
-void
-toku_calc_more_murmur_xids (struct x1764 *mm, XIDS xids) {
-    x1764_add(mm, &xids->num_xids, 1);
-    TXNID zero = 0;
-    x1764_add(mm, &zero, 8);
-    uint8_t index;
-    uint8_t num_xids = xids_get_num_xids(xids);
-    for (index = 0; index < num_xids; index++) {
-        TXNID current_xid = xids_get_xid(xids, index);
-        x1764_add(mm, &current_xid, 8);
-    }
-}
-
 unsigned char *
 xids_get_end_of_array(XIDS xids) {
     TXNID *r = xids->ids + xids->num_xids;
     return (unsigned char*)r;
 }
 
-void wbuf_xids(struct wbuf *wb, XIDS xids) {
-    wbuf_char(wb, (unsigned char)xids->num_xids);
-    uint8_t index;
-    for (index = 0; index < xids->num_xids; index++) {
-        wbuf_TXNID(wb, xids->ids[index]);
-    }
-}
-
 void wbuf_nocrc_xids(struct wbuf *wb, XIDS xids) {
     wbuf_nocrc_char(wb, (unsigned char)xids->num_xids);
     uint8_t index;
diff --git a/ft/xids.h b/ft/xids.h
index 8e211bd08ad..4f8e20cce4b 100644
--- a/ft/xids.h
+++ b/ft/xids.h
@@ -57,11 +57,8 @@ uint32_t xids_get_size(XIDS xids);
 
 uint32_t xids_get_serialize_size(XIDS xids);
 
-void toku_calc_more_murmur_xids (struct x1764 *mm, XIDS xids);
-
 unsigned char *xids_get_end_of_array(XIDS xids);
 
-void wbuf_xids(struct wbuf *wb, XIDS xids);
 void wbuf_nocrc_xids(struct wbuf *wb, XIDS xids);
 
 void xids_fprintf(FILE* fp, XIDS xids);
diff --git a/portability/file.cc b/portability/file.cc
index 4da4c4197f8..0642699d3ea 100644
--- a/portability/file.cc
+++ b/portability/file.cc
@@ -9,12 +9,13 @@
 #include <toku_assert.h>
 #include <stdio.h>
 #include <string.h>
-#include <time.h>
 #include <dirent.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
+
 #include "memory.h"
+#include "toku_time.h"
 
 static int toku_assert_on_write_enospc = 0;
 static const int toku_write_enospc_sleep = 1;
@@ -27,8 +28,7 @@ void toku_set_assert_on_write_enospc(int do_assert) {
     toku_assert_on_write_enospc = do_assert;
 }
 
-void
-toku_fs_get_write_info(time_t *enospc_last_time, uint64_t *enospc_current, uint64_t *enospc_total) {
+void toku_fs_get_write_info(time_t *enospc_last_time, uint64_t *enospc_current, uint64_t *enospc_total) {
     *enospc_last_time = toku_write_enospc_last_time;
     *enospc_current = toku_write_enospc_current;
     *enospc_total = toku_write_enospc_total;
@@ -100,77 +100,55 @@ try_again_after_handling_write_error(int fd, size_t len, ssize_t r_write) {
     errno = errno_write;
 }
 
-static ssize_t (*t_write)(int, const void *, size_t) = 0;
-static ssize_t (*t_full_write)(int, const void *, size_t) = 0;
-static ssize_t (*t_pwrite)(int, const void *, size_t, off_t) = 0;
-static ssize_t (*t_full_pwrite)(int, const void *, size_t, off_t) = 0;
-static FILE *  (*t_fdopen)(int, const char *) = 0;
-static FILE *  (*t_fopen)(const char *, const char *) = 0;
-static int     (*t_open)(const char *, int, int) = 0;  // no implementation of variadic form until needed
-static int     (*t_fclose)(FILE *) = 0;
-static ssize_t (*t_read)(int, void *, size_t) = 0;
-static ssize_t (*t_pread)(int, void *, size_t, off_t) = 0;
+static ssize_t (*t_write)(int, const void *, size_t);
+static ssize_t (*t_full_write)(int, const void *, size_t);
+static ssize_t (*t_pwrite)(int, const void *, size_t, off_t);
+static ssize_t (*t_full_pwrite)(int, const void *, size_t, off_t);
+static FILE *  (*t_fdopen)(int, const char *);
+static FILE *  (*t_fopen)(const char *, const char *);
+static int     (*t_open)(const char *, int, int);
+static int     (*t_fclose)(FILE *);
+static ssize_t (*t_read)(int, void *, size_t);
+static ssize_t (*t_pread)(int, void *, size_t, off_t);
 
-int 
-toku_set_func_write (ssize_t (*write_fun)(int, const void *, size_t)) {
+void toku_set_func_write (ssize_t (*write_fun)(int, const void *, size_t)) {
     t_write = write_fun;
-    return 0;
 }
 
-int 
-toku_set_func_full_write (ssize_t (*write_fun)(int, const void *, size_t)) {
+void toku_set_func_full_write (ssize_t (*write_fun)(int, const void *, size_t)) {
     t_full_write = write_fun;
-    return 0;
 }
 
-int 
-toku_set_func_pwrite (ssize_t (*pwrite_fun)(int, const void *, size_t, off_t)) {
+void toku_set_func_pwrite (ssize_t (*pwrite_fun)(int, const void *, size_t, off_t)) {
     t_pwrite = pwrite_fun;
-    return 0;
 }
 
-int 
-toku_set_func_full_pwrite (ssize_t (*pwrite_fun)(int, const void *, size_t, off_t)) {
+void toku_set_func_full_pwrite (ssize_t (*pwrite_fun)(int, const void *, size_t, off_t)) {
     t_full_pwrite = pwrite_fun;
-    return 0;
 }
 
-int 
-toku_set_func_fdopen(FILE * (*fdopen_fun)(int, const char *)) {
+void toku_set_func_fdopen(FILE * (*fdopen_fun)(int, const char *)) {
     t_fdopen = fdopen_fun;
-    return 0;
 }
 
-
-int 
-toku_set_func_fopen(FILE * (*fopen_fun)(const char *, const char *)) {
+void toku_set_func_fopen(FILE * (*fopen_fun)(const char *, const char *)) {
     t_fopen = fopen_fun;
-    return 0;
 }
 
-
-int 
-toku_set_func_open(int (*open_fun)(const char *, int, int)) {
+void toku_set_func_open(int (*open_fun)(const char *, int, int)) {
     t_open = open_fun;
-    return 0;
 }
 
-int 
-toku_set_func_fclose(int (*fclose_fun)(FILE*)) {
+void toku_set_func_fclose(int (*fclose_fun)(FILE*)) {
     t_fclose = fclose_fun;
-    return 0;
 }
 
-int 
-toku_set_func_read (ssize_t (*read_fun)(int, void *, size_t)) {
+void toku_set_func_read (ssize_t (*read_fun)(int, void *, size_t)) {
     t_read = read_fun;
-    return 0;
 }
 
-int
-toku_set_func_pread (ssize_t (*pread_fun)(int, void *, size_t, off_t)) {
+void toku_set_func_pread (ssize_t (*pread_fun)(int, void *, size_t, off_t)) {
     t_pread = pread_fun;
-    return 0;
 }
 
 void
@@ -306,7 +284,7 @@ toku_os_fclose(FILE * stream) {
 }
 
 int 
-toku_os_close (int fd) {  // if EINTR, retry until success
+toku_os_close(int fd) {  // if EINTR, retry until success
     int r = -1;
     while (r != 0) {
 	r = close(fd);
@@ -351,106 +329,77 @@ static uint64_t toku_fsync_time;
 static uint64_t sched_fsync_count;
 static uint64_t sched_fsync_time;
 
-int
-toku_set_func_fsync(int (*fsync_function)(int)) {
+void toku_set_func_fsync(int (*fsync_function)(int)) {
     t_fsync = fsync_function;
-    return 0;
-}
-
-static uint64_t get_tnow(void) {
-    struct timeval tv;
-    int r = gettimeofday(&tv, NULL); assert(r == 0);
-    return tv.tv_sec * 1000000ULL + tv.tv_usec;
 }
 
 // keep trying if fsync fails because of EINTR
-static int 
-file_fsync_internal (int fd, uint64_t *duration_p) {
-    uint64_t tstart = get_tnow();
+static void file_fsync_internal (int fd, uint64_t *duration_p) {
+    uint64_t tstart = toku_current_time_usec();
     int r = -1;
     while (r != 0) {
-	if (t_fsync)
+	if (t_fsync) {
 	    r = t_fsync(fd);
-	else 
+        } else {
 	    r = fsync(fd);
+        }
 	if (r) {
-	    int rr = errno;
-	    if (rr!=EINTR) printf("rr=%d (%s)\n", rr, strerror(rr));
-	    assert(rr==EINTR);
+            assert(get_error_errno() == EINTR);
 	}
     }
     __sync_fetch_and_add(&toku_fsync_count, 1);
-    uint64_t duration;
-    duration = get_tnow() - tstart;
+    uint64_t duration = toku_current_time_usec() - tstart;
     __sync_fetch_and_add(&toku_fsync_time, duration);
-    if (duration_p) *duration_p = duration;
-    return r;
+    if (duration_p) {
+        *duration_p = duration;
+    }
 }
 
-int
-toku_file_fsync_without_accounting (int fd) {
-    int r = file_fsync_internal (fd, NULL);
-    return r;
+void toku_file_fsync_without_accounting(int fd) {
+    file_fsync_internal(fd, NULL);
 }
 
-
-int
-toku_fsync_dirfd_without_accounting(DIR *dirp) {
-    int r;
-    int fd = dirfd(dirp);
-    if (fd < 0) {
-        r = -1;
-    } else {
-        r = toku_file_fsync_without_accounting(fd);
-    }
-    return r;
+void toku_fsync_dirfd_without_accounting(DIR *dir) {
+    int fd = dirfd(dir);
+    toku_file_fsync_without_accounting(fd);
 }
 
-int
-toku_fsync_dir_by_name_without_accounting(const char *dir_name) {
+int toku_fsync_dir_by_name_without_accounting(const char *dir_name) {
     int r = 0;
     DIR * dir = opendir(dir_name);
     if (!dir) {
-        r = errno;
-        assert(r);
-    }
-    else {
-        r = toku_fsync_dirfd_without_accounting(dir);
-        int rc = closedir(dir);
-        if (r==0 && rc!=0) {
-            r = errno;
-            assert(r);
+        r = get_error_errno();
+    } else {
+        toku_fsync_dirfd_without_accounting(dir);
+        r = closedir(dir);
+        if (r != 0) {
+            r = get_error_errno();
         }
     }
     return r;
 }
 
 // include fsync in scheduling accounting
-int
-toku_file_fsync(int fd) {
+void toku_file_fsync(int fd) {
     uint64_t duration;
-    int r = file_fsync_internal (fd, &duration);
+    file_fsync_internal (fd, &duration);
     __sync_fetch_and_add(&sched_fsync_count, 1);
     __sync_fetch_and_add(&sched_fsync_time, duration);
-    return r;
 }
 
 // for real accounting
-void
-toku_get_fsync_times(uint64_t *fsync_count, uint64_t *fsync_time) {
+void toku_get_fsync_times(uint64_t *fsync_count, uint64_t *fsync_time) {
     *fsync_count = toku_fsync_count;
     *fsync_time = toku_fsync_time;
 }
 
 // for scheduling algorithm only
-void
-toku_get_fsync_sched(uint64_t *fsync_count, uint64_t *fsync_time) {
+void toku_get_fsync_sched(uint64_t *fsync_count, uint64_t *fsync_time) {
     *fsync_count = sched_fsync_count;
     *fsync_time  = sched_fsync_time;
 }
 
-int 
-toku_fsync_directory(const char *fname) {
+int toku_fsync_directory(const char *fname) {
     int result = 0;
     
     // extract dirname from fname
@@ -461,16 +410,17 @@ toku_fsync_directory(const char *fname) {
         resource_assert(sp >= fname);
         len = sp - fname + 1;
         MALLOC_N(len+1, dirname);
-        if (dirname == NULL)
-            result = errno;
-        else {
+        if (dirname == NULL) {
+            result = get_error_errno();;
+        } else {
             strncpy(dirname, fname, len);
             dirname[len] = 0;
         }
     } else {
         dirname = toku_strdup(".");
-        if (dirname == NULL)
-            result = errno;
+        if (dirname == NULL) {
+            result = get_error_errno();;
+        }
     }
 
     if (result == 0) {
diff --git a/portability/portability.cc b/portability/portability.cc
index 4d5e59b28d3..5a6464f2e2a 100644
--- a/portability/portability.cc
+++ b/portability/portability.cc
@@ -256,8 +256,7 @@ toku_os_get_rss(int64_t *rss) {
     return r;
 }
 
-int 
-toku_os_is_absolute_name(const char* path) {
+bool toku_os_is_absolute_name(const char* path) {
     return path[0] == '/';
 }
 
diff --git a/portability/toku_pthread.h b/portability/toku_pthread.h
index 98e246ea0da..09444a90ffb 100644
--- a/portability/toku_pthread.h
+++ b/portability/toku_pthread.h
@@ -4,14 +4,14 @@
 #ident "$Id$"
 #ident "Copyright (c) 2007-2012 Tokutek Inc.  All rights reserved."
 
-#ifndef _TOKU_PTHREAD_H
-#define _TOKU_PTHREAD_H
+#ifndef TOKU_PTHREAD_H
+#define TOKU_PTHREAD_H
 
 #include <pthread.h>
 #include <time.h>
 #include <stdint.h>
-#include "toku_assert.h"
 
+#include "toku_assert.h"
 
 typedef pthread_attr_t toku_pthread_attr_t;
 typedef pthread_t toku_pthread_t;
@@ -162,12 +162,14 @@ toku_cond_timedwait(toku_cond_t *cond, toku_mutex_t *mutex, toku_timespec_t *wak
 
 static inline void 
 toku_cond_signal(toku_cond_t *cond) {
-    pthread_cond_signal(&cond->pcond);
+    int r = pthread_cond_signal(&cond->pcond);
+    assert_zero(r);
 }
 
 static inline void
 toku_cond_broadcast(toku_cond_t *cond) {
-    pthread_cond_broadcast(&cond->pcond);
+    int r =pthread_cond_broadcast(&cond->pcond);
+    assert_zero(r);
 }
 
 int 
@@ -178,7 +180,6 @@ toku_pthread_self(void) {
     return pthread_self();
 }
 
-#if 1
 static inline void
 toku_pthread_rwlock_init(toku_pthread_rwlock_t *__restrict rwlock, const toku_pthread_rwlockattr_t *__restrict attr) {
     int r = pthread_rwlock_init(rwlock, attr);
@@ -214,7 +215,6 @@ toku_pthread_rwlock_wrunlock(toku_pthread_rwlock_t *rwlock) {
     int r = pthread_rwlock_unlock(rwlock);
     assert_zero(r);
 }
-#endif
 
 static inline int 
 toku_pthread_create(toku_pthread_t *thread, const toku_pthread_attr_t *attr, void *(*start_function)(void *), void *arg) {
@@ -251,5 +251,4 @@ toku_pthread_setspecific(toku_pthread_key_t key, void *data) {
     return pthread_setspecific(key, data);
 }
 
-
-#endif
+#endif /* TOKU_PTHREAD_H */
diff --git a/portability/toku_time.h b/portability/toku_time.h
index f9da3e3c65d..e3a1772d30d 100644
--- a/portability/toku_time.h
+++ b/portability/toku_time.h
@@ -89,5 +89,10 @@ static inline tokutime_t get_tokutime (void) {
     return (uint64_t)hi << 32 | lo;
 }
 
+static inline uint64_t toku_current_time_usec(void) {
+    struct timeval t;
+    gettimeofday(&t, NULL);
+    return t.tv_sec * 1000000UL + t.tv_usec;
+}
 
 #endif
diff --git a/src/errors.cc b/src/errors.cc
index 08fce3f960a..fce3103431d 100644
--- a/src/errors.cc
+++ b/src/errors.cc
@@ -20,7 +20,7 @@
 /** Checks whether the environment has panicked */
 int toku_env_is_panicked(DB_ENV *dbenv /**< The environment to check */) {
     if (dbenv==0) return 0;
-    return dbenv->i->is_panicked || toku_logger_panicked(dbenv->i->logger);
+    return dbenv->i->is_panicked;
 }
 
 
@@ -91,7 +91,6 @@ void toku_ydb_error_all_cases(const DB_ENV * env,
     \param fmt    The format string for additional variable arguments to
                   be printed   */
 int toku_ydb_do_error (const DB_ENV *dbenv, int error, const char *fmt, ...) {
-    if (toku_logger_panicked(dbenv->i->logger)) dbenv->i->is_panicked=1;
     va_list ap;
     va_start(ap, fmt);
     toku_ydb_error_all_cases(dbenv, error, false, false, fmt, ap);
diff --git a/src/indexer-undo-do.cc b/src/indexer-undo-do.cc
index a22a15e14a2..d7e4c8fdf85 100644
--- a/src/indexer-undo-do.cc
+++ b/src/indexer-undo-do.cc
@@ -490,7 +490,7 @@ indexer_ft_delete_provisional(DB_INDEXER *indexer, DB *hotdb, DBT *hotkey, XIDS
             // this question apples to delete_committed, insert_provisional
             // and insert_committed
             toku_multi_operation_client_lock();
-            result = toku_ft_maybe_delete (hotdb->i->ft_handle, hotkey, txn, false, ZERO_LSN, true);
+            toku_ft_maybe_delete (hotdb->i->ft_handle, hotkey, txn, false, ZERO_LSN, true);
             toku_multi_operation_client_unlock();
         }
     }
@@ -507,7 +507,7 @@ indexer_ft_delete_committed(DB_INDEXER *indexer, DB *hotdb, DBT *hotkey, XIDS xi
     } else {
         result = toku_ydb_check_avail_fs_space(indexer->i->env);
         if (result == 0) {
-            result = toku_ft_send_delete(db_struct_i(hotdb)->ft_handle, hotkey, xids);
+            toku_ft_send_delete(db_struct_i(hotdb)->ft_handle, hotkey, xids);
         }
     }
     return result;
@@ -527,7 +527,7 @@ indexer_ft_insert_provisional(DB_INDEXER *indexer, DB *hotdb, DBT *hotkey, DBT *
             assert(txn != NULL);
             // comment/question in indexer_ft_delete_provisional applies
             toku_multi_operation_client_lock();
-            result = toku_ft_maybe_insert (hotdb->i->ft_handle, hotkey, hotval, txn, false, ZERO_LSN, true, FT_INSERT);
+            toku_ft_maybe_insert (hotdb->i->ft_handle, hotkey, hotval, txn, false, ZERO_LSN, true, FT_INSERT);
             toku_multi_operation_client_unlock();
         }
     }
@@ -545,7 +545,7 @@ indexer_ft_insert_committed(DB_INDEXER *indexer, DB *hotdb, DBT *hotkey, DBT *ho
     } else {
         result = toku_ydb_check_avail_fs_space(indexer->i->env);
         if (result == 0) {
-            result  = toku_ft_send_insert(db_struct_i(hotdb)->ft_handle, hotkey, hotval, xids, FT_INSERT);
+            toku_ft_send_insert(db_struct_i(hotdb)->ft_handle, hotkey, hotval, xids, FT_INSERT);
         }
     }
     return result;
@@ -565,7 +565,7 @@ indexer_ft_commit(DB_INDEXER *indexer, DB *hotdb, DBT *hotkey, XIDS xids) {
         } else {
             result = toku_ydb_check_avail_fs_space(indexer->i->env);
             if (result == 0)
-                result = toku_ft_send_commit_any(db_struct_i(hotdb)->ft_handle, hotkey, xids);
+                toku_ft_send_commit_any(db_struct_i(hotdb)->ft_handle, hotkey, xids);
         }
     }
     return result;
diff --git a/src/indexer.cc b/src/indexer.cc
index 357b07d8e2a..ad7e0f702c6 100644
--- a/src/indexer.cc
+++ b/src/indexer.cc
@@ -223,7 +223,7 @@ toku_indexer_create_indexer(DB_ENV *env,
     FILENUMS filenums;
     filenums = indexer->i->filenums;
     toku_multi_operation_client_lock();
-    rval = toku_ft_hot_index(NULL, ttxn, filenums, 1, &hot_index_lsn);
+    toku_ft_hot_index(NULL, ttxn, filenums, 1, &hot_index_lsn);
     toku_multi_operation_client_unlock();
 
     if (rval == 0) {
diff --git a/src/tests/test.h b/src/tests/test.h
index f58ec31f340..d2a1d90b992 100644
--- a/src/tests/test.h
+++ b/src/tests/test.h
@@ -377,9 +377,9 @@ main(int argc, char * const argv[])
     CKERR(rinit);
 #endif
 #if !IS_TDB && DB_VERSION_MINOR==4 && DB_VERSION_MINOR == 7
-    r = db_env_set_func_malloc(toku_malloc);   assert(r==0);
-    r = db_env_set_func_free(toku_free);      assert(r==0);
-    r = db_env_set_func_realloc(toku_realloc);   assert(r==0);
+    db_env_set_func_malloc(toku_malloc);
+    db_env_set_func_free(toku_free);
+    db_env_set_func_realloc(toku_realloc);
 #endif
     toku_os_initialize_settings(1);
     r = test_main(argc, argv);
diff --git a/src/tests/test_groupcommit_count.cc b/src/tests/test_groupcommit_count.cc
index 4fb83c7498b..446c3e33811 100644
--- a/src/tests/test_groupcommit_count.cc
+++ b/src/tests/test_groupcommit_count.cc
@@ -179,7 +179,7 @@ test_main (int argc, char *const argv[]) {
     gettimeofday(&prevtime, 0);
     prev_count=0;
 
-    { int r = db_env_set_func_fsync(do_fsync); CKERR(r); }
+    db_env_set_func_fsync(do_fsync);
 
     {
 	int size=20+strlen(env_path);
diff --git a/src/tests/test_set_func_malloc.cc b/src/tests/test_set_func_malloc.cc
index 0a776078622..8d1875fd2ee 100644
--- a/src/tests/test_set_func_malloc.cc
+++ b/src/tests/test_set_func_malloc.cc
@@ -47,7 +47,7 @@ test1 (void)
     assert(free_counter==0);
     assert(realloc_counter==0);
 
-    r = db_env_set_func_malloc(bmalloc);   assert(r==0);
+    db_env_set_func_malloc(bmalloc);
     r = db_env_create(&env, 0);            assert(r==0);
     r = env->close(env, 0);                assert(r==0);
     assert(malloc_counter>0);
@@ -56,17 +56,17 @@ test1 (void)
 
     malloc_counter = realloc_counter = free_counter = 0;
 
-    r = db_env_set_func_free(bfree);       assert(r==0);
-    r = db_env_set_func_malloc(NULL);      assert(r==0);
+    db_env_set_func_free(bfree);
+    db_env_set_func_malloc(NULL);
     r = db_env_create(&env, 0);            assert(r==0);
     r = env->close(env, 0);                assert(r==0);
     assert(malloc_counter==0);
     assert(free_counter>=0);
     assert(realloc_counter==0);
     
-    r = db_env_set_func_malloc(bmalloc);   assert(r==0);
-    r = db_env_set_func_realloc(brealloc); assert(r==0);
-    r = db_env_set_func_free(bfree);       assert(r==0);
+    db_env_set_func_malloc(bmalloc);
+    db_env_set_func_realloc(brealloc);
+    db_env_set_func_free(bfree);
     
 #ifdef USE_TDB
     // toku_malloc isn't affected by calling the BDB set_fun_malloc calls.
@@ -78,9 +78,9 @@ test1 (void)
 	toku_free(x);	                        assert(malloc_counter==1 && free_counter==1 && realloc_counter==1);
     }
 
-    r = db_env_set_func_malloc(NULL);   assert(r==0);
-    r = db_env_set_func_realloc(NULL);  assert(r==0);
-    r = db_env_set_func_free(NULL);     assert(r==0);
+    db_env_set_func_malloc(NULL);
+    db_env_set_func_realloc(NULL);
+    db_env_set_func_free(NULL);
 
 #endif
 }
diff --git a/src/ydb.cc b/src/ydb.cc
index b28e17428c0..781d7494b03 100644
--- a/src/ydb.cc
+++ b/src/ydb.cc
@@ -812,12 +812,6 @@ env_open(DB_ENV * env, const char *home, uint32_t flags, int mode) {
         r = toku_ydb_do_error(env, ENOMEM, "Out of memory\n");
         goto cleanup;
     }
-    if (0) {
-        died1:
-        toku_free(env->i->dir);
-        env->i->dir = NULL;
-        goto cleanup;
-    }
     env->i->open_flags = flags;
     env->i->open_mode = mode;
 
@@ -834,7 +828,6 @@ env_open(DB_ENV * env, const char *home, uint32_t flags, int mode) {
     r = single_process_lock(env->i->real_tmp_dir, "temp", &env->i->tmpdir_lockfd);
     if (r!=0) goto cleanup;
 
-
     bool need_rollback_cachefile;
     need_rollback_cachefile = false;
     if (flags & (DB_INIT_TXN | DB_INIT_LOG)) {
@@ -893,9 +886,6 @@ env_open(DB_ENV * env, const char *home, uint32_t flags, int mode) {
             r = toku_logger_open(env->i->real_log_dir, env->i->logger);
             if (r!=0) {
                 toku_ydb_do_error(env, r, "Could not open logger\n");
-            died2:
-                toku_logger_close(&env->i->logger);
-                goto died1;
             }
         }
     } else {
@@ -925,8 +915,7 @@ env_open(DB_ENV * env, const char *home, uint32_t flags, int mode) {
 
     if (env->i->cachetable==NULL) {
         // If we ran recovery then the cachetable should be set here.
-        r = toku_create_cachetable(&env->i->cachetable, env->i->cachetable_size, ZERO_LSN, env->i->logger);
-        if (r!=0) goto died2;
+        toku_cachetable_create(&env->i->cachetable, env->i->cachetable_size, ZERO_LSN, env->i->logger);
     }
 
     toku_cachetable_set_env_dir(env->i->cachetable, env->i->dir);
@@ -1070,7 +1059,7 @@ env_close(DB_ENV * env, uint32_t flags) {
                 toku_ydb_do_error(env, r, "%s", err_msg);
                 goto panic_and_quit_early;
             }
-            r = toku_logger_close_rollback(env->i->logger, false);
+            r = toku_logger_close_rollback(env->i->logger);
             if (r) {
                 err_msg = "Cannot close environment (error during closing rollback cachefile)\n";
                 toku_ydb_do_error(env, r, "%s", err_msg);
@@ -1083,19 +1072,9 @@ env_close(DB_ENV * env, uint32_t flags) {
                 toku_ydb_do_error(env, r, "%s", err_msg);
                 goto panic_and_quit_early;
             }
-            r = toku_logger_shutdown(env->i->logger); 
-            if (r) {
-                err_msg = "Cannot close environment (error during logger shutdown)\n";
-                toku_ydb_do_error(env, r, "%s", err_msg);
-                goto panic_and_quit_early;
-            }
-        }
-        r=toku_cachetable_close(&env->i->cachetable);
-        if (r) {
-            err_msg = "Cannot close environment (cachetable close error)\n";
-            toku_ydb_do_error(env, r, "%s", err_msg);
-            goto panic_and_quit_early;
+            toku_logger_shutdown(env->i->logger); 
         }
+        toku_cachetable_close(&env->i->cachetable);
     }
     if (env->i->logger) {
         r=toku_logger_close(&env->i->logger);
@@ -1502,30 +1481,36 @@ env_get_txn_from_xid (DB_ENV *env, /*in*/ TOKU_XA_XID *xid, /*out*/ DB_TXN **txn
 static int
 env_checkpointing_set_period(DB_ENV * env, uint32_t seconds) {
     HANDLE_PANICKED_ENV(env);
-    int r;
-    if (!env_opened(env)) r = EINVAL;
-    else
-        r = toku_set_checkpoint_period(env->i->cachetable, seconds);
+    int r = 0;
+    if (!env_opened(env)) {
+        r = EINVAL;
+    } else {
+        toku_set_checkpoint_period(env->i->cachetable, seconds);
+    }
     return r;
 }
 
 static int
 env_cleaner_set_period(DB_ENV * env, uint32_t seconds) {
     HANDLE_PANICKED_ENV(env);
-    int r;
-    if (!env_opened(env)) r = EINVAL;
-    else
-        r = toku_set_cleaner_period(env->i->cachetable, seconds);
+    int r = 0;
+    if (!env_opened(env)) {
+        r = EINVAL;
+    } else {
+        toku_set_cleaner_period(env->i->cachetable, seconds);
+    }
     return r;
 }
 
 static int
 env_cleaner_set_iterations(DB_ENV * env, uint32_t iterations) {
     HANDLE_PANICKED_ENV(env);
-    int r;
-    if (!env_opened(env)) r = EINVAL;
-    else
-        r = toku_set_cleaner_iterations(env->i->cachetable, iterations);
+    int r = 0;
+    if (!env_opened(env)) {
+        r = EINVAL;
+    } else {
+        toku_set_cleaner_iterations(env->i->cachetable, iterations);
+    }
     return r;
 }
 
@@ -2512,8 +2497,7 @@ toku_env_dbremove(DB_ENV * env, DB_TXN *txn, const char *fname, const char *dbna
             goto exit;
         }
         // The ft will be unlinked when the txn commits
-        r = toku_ft_unlink_on_commit(db->i->ft_handle, db_txn_struct_i(txn)->tokutxn);
-        lazy_assert_zero(r);
+        toku_ft_unlink_on_commit(db->i->ft_handle, db_txn_struct_i(txn)->tokutxn);
     }
     else {
         // unlink the ft without a txn
diff --git a/src/ydb_cursor.cc b/src/ydb_cursor.cc
index b9b535346f5..a7ee992672c 100644
--- a/src/ydb_cursor.cc
+++ b/src/ydb_cursor.cc
@@ -636,14 +636,14 @@ int
 toku_c_close(DBC * c) {
     HANDLE_PANICKED_DB(c->dbp);
     HANDLE_CURSOR_ILLEGAL_WORKING_PARENT_TXN(c);
-    int r = toku_ft_cursor_close(dbc_struct_i(c)->c);
+    toku_ft_cursor_close(dbc_struct_i(c)->c);
     toku_sdbt_cleanup(&dbc_struct_i(c)->skey_s);
     toku_sdbt_cleanup(&dbc_struct_i(c)->sval_s);
 #if !TOKUDB_NATIVE_H
     toku_free(dbc_struct_i(c));
 #endif
     toku_free(c);
-    return r;
+    return 0;
 }
 
 // these next two static functions are defined
diff --git a/src/ydb_db.cc b/src/ydb_db.cc
index c19dc39823a..388f7cdd1c9 100644
--- a/src/ydb_db.cc
+++ b/src/ydb_db.cc
@@ -356,17 +356,13 @@ lt_on_close_callback(toku_lock_tree *lt) {
 
 int 
 db_open_iname(DB * db, DB_TXN * txn, const char *iname_in_env, uint32_t flags, int mode) {
-    int r;
-
     //Set comparison functions if not yet set.
     if (!db->i->key_compare_was_set && db->dbenv->i->bt_compare) {
-        r = toku_ft_set_bt_compare(db->i->ft_handle, db->dbenv->i->bt_compare);
-        assert(r==0);
+        toku_ft_set_bt_compare(db->i->ft_handle, db->dbenv->i->bt_compare);
         db->i->key_compare_was_set = true;
     }
     if (db->dbenv->i->update_function) {
-        r = toku_ft_set_update(db->i->ft_handle,db->dbenv->i->update_function);
-        assert(r==0);
+        toku_ft_set_update(db->i->ft_handle,db->dbenv->i->update_function);
     }
     toku_ft_set_redirect_callback(
         db->i->ft_handle,
@@ -398,7 +394,7 @@ db_open_iname(DB * db, DB_TXN * txn, const char *iname_in_env, uint32_t flags, i
     db->i->open_mode = mode;
 
     FT_HANDLE ft_handle = db->i->ft_handle;
-    r = toku_ft_handle_open(ft_handle, iname_in_env,
+    int r = toku_ft_handle_open(ft_handle, iname_in_env,
                       is_db_create, is_db_excl,
                       db->dbenv->i->cachetable,
                       txn ? db_txn_struct_i(txn)->tokutxn : NULL_TXN);
@@ -506,7 +502,7 @@ toku_db_change_descriptor(DB *db, DB_TXN* txn, const DBT* descriptor, uint32_t f
 
     old_descriptor.size = db->descriptor->dbt.size;
     old_descriptor.data = toku_memdup(db->descriptor->dbt.data, db->descriptor->dbt.size);
-    r = toku_ft_change_descriptor(
+    toku_ft_change_descriptor(
         db->i->ft_handle, 
         &old_descriptor, 
         descriptor, 
@@ -514,7 +510,6 @@ toku_db_change_descriptor(DB *db, DB_TXN* txn, const DBT* descriptor, uint32_t f
         ttxn, 
         update_cmp_descriptor
         );
-    if (r != 0) { goto cleanup; }
 
     // the lock tree uses a copy of the header's descriptor for comparisons.
     // if we need to update the cmp descriptor, we need to make sure the lock
@@ -623,17 +618,15 @@ toku_db_stat64(DB * db, DB_TXN *txn, DB_BTREE_STAT64 *s) {
     if (txn != NULL) {
         tokutxn = db_txn_struct_i(txn)->tokutxn;
     }
-    int r = toku_ft_handle_stat64(db->i->ft_handle, tokutxn, &ftstat);
-    if (r==0) {
-        s->bt_nkeys = ftstat.nkeys;
-        s->bt_ndata = ftstat.ndata;
-        s->bt_dsize = ftstat.dsize;
-        s->bt_fsize = ftstat.fsize;
-        s->bt_create_time_sec = ftstat.create_time_sec;
-        s->bt_modify_time_sec = ftstat.modify_time_sec;
-        s->bt_verify_time_sec = ftstat.verify_time_sec;
-    }
-    return r;
+    toku_ft_handle_stat64(db->i->ft_handle, tokutxn, &ftstat);
+    s->bt_nkeys = ftstat.nkeys;
+    s->bt_ndata = ftstat.ndata;
+    s->bt_dsize = ftstat.dsize;
+    s->bt_fsize = ftstat.fsize;
+    s->bt_create_time_sec = ftstat.create_time_sec;
+    s->bt_modify_time_sec = ftstat.modify_time_sec;
+    s->bt_verify_time_sec = ftstat.verify_time_sec;
+    return 0;
 }
 
 static int 
@@ -645,12 +638,10 @@ toku_db_key_range64(DB* db, DB_TXN* txn __attribute__((__unused__)), DBT* key, u
     // this will be fixed later
     // temporarily, because the caller, locked_db_keyrange, 
     // has the ydb lock, we are ok
-    int r = toku_ft_keyrange(db->i->ft_handle, key, less, equal, greater);
-    if (r != 0) { goto cleanup; }
+    toku_ft_keyrange(db->i->ft_handle, key, less, equal, greater);
     // temporarily set is_exact to 0 because ft_keyrange does not have this parameter
     *is_exact = 0;
-cleanup:
-    return r;
+    return 0;
 }
 
 // needed by loader.c
@@ -769,8 +760,8 @@ toku_db_dbt_neg_infty(void) {
 static int
 toku_db_optimize(DB *db) {
     HANDLE_PANICKED_DB(db);
-    int r = toku_ft_optimize(db->i->ft_handle);
-    return r;
+    toku_ft_optimize(db->i->ft_handle);
+    return 0;
 }
 
 static int
@@ -889,11 +880,9 @@ toku_db_create(DB ** db, DB_ENV * env, uint32_t flags) {
     
 
     FT_HANDLE brt;
-    int r;
-    r = toku_ft_handle_create(&brt);
-    if (r!=0) return r;
+    toku_ft_handle_create(&brt);
 
-    r = toku_setup_db_internal(db, env, flags, brt, false);
+    int r = toku_setup_db_internal(db, env, flags, brt, false);
     if (r != 0) return r;
 
 
@@ -1013,8 +1002,7 @@ load_inames(DB_ENV * env, DB_TXN * txn, int N, DB * dbs[/*N*/], const char * new
                 do_fsync = 1; //We only need a single fsync of logs.
                 get_lsn  = load_lsn; //Set pointer to capture the last lsn.
             }
-            rval = toku_ft_load(brt, ttxn, new_inames_in_env[i], do_fsync, get_lsn);
-            if (rval) break;
+            toku_ft_load(brt, ttxn, new_inames_in_env[i], do_fsync, get_lsn);
         }
     }
     return rval;
diff --git a/src/ydb_env_func.cc b/src/ydb_env_func.cc
index 3e66825896a..1190961865a 100644
--- a/src/ydb_env_func.cc
+++ b/src/ydb_env_func.cc
@@ -22,77 +22,60 @@ void * checkpoint_callback2_extra     = NULL;
 
 uint32_t  engine_status_enable = 1;   // if zero, suppress engine status output on failed assert, for test programs only
 
-int 
-db_env_set_func_fsync (int (*fsync_function)(int)) {
-    return toku_set_func_fsync(fsync_function);
+void db_env_set_func_fsync (int (*fsync_function)(int)) {
+    toku_set_func_fsync(fsync_function);
 }
 
-int 
-db_env_set_func_pwrite (ssize_t (*pwrite_function)(int, const void *, size_t, toku_off_t)) {
-    return toku_set_func_pwrite(pwrite_function);
+void db_env_set_func_pwrite (ssize_t (*pwrite_function)(int, const void *, size_t, toku_off_t)) {
+    toku_set_func_pwrite(pwrite_function);
 }
 
-int 
-db_env_set_func_full_pwrite (ssize_t (*pwrite_function)(int, const void *, size_t, toku_off_t)) {
-    return toku_set_func_full_pwrite(pwrite_function);
+void db_env_set_func_full_pwrite (ssize_t (*pwrite_function)(int, const void *, size_t, toku_off_t)) {
+    toku_set_func_full_pwrite(pwrite_function);
 }
 
-int 
-db_env_set_func_write (ssize_t (*write_function)(int, const void *, size_t)) {
-    return toku_set_func_write(write_function);
+void db_env_set_func_write (ssize_t (*write_function)(int, const void *, size_t)) {
+    toku_set_func_write(write_function);
 }
 
-int 
-db_env_set_func_full_write (ssize_t (*write_function)(int, const void *, size_t)) {
-    return toku_set_func_full_write(write_function);
+void db_env_set_func_full_write (ssize_t (*write_function)(int, const void *, size_t)) {
+    toku_set_func_full_write(write_function);
 }
 
-int 
-db_env_set_func_fdopen (FILE * (*fdopen_function)(int, const char *)) {
-    return toku_set_func_fdopen(fdopen_function);
+void db_env_set_func_fdopen (FILE * (*fdopen_function)(int, const char *)) {
+    toku_set_func_fdopen(fdopen_function);
 }
 
-int 
-db_env_set_func_fopen (FILE * (*fopen_function)(const char *, const char *)) {
-    return toku_set_func_fopen(fopen_function);
+void db_env_set_func_fopen (FILE * (*fopen_function)(const char *, const char *)) {
+    toku_set_func_fopen(fopen_function);
 }
 
-int 
-db_env_set_func_open (int (*open_function)(const char *, int, int)) {
-    return toku_set_func_open(open_function);
+void db_env_set_func_open (int (*open_function)(const char *, int, int)) {
+    toku_set_func_open(open_function);
 }
 
-int 
-db_env_set_func_fclose (int (*fclose_function)(FILE*)) {
-    return toku_set_func_fclose(fclose_function);
+void db_env_set_func_fclose (int (*fclose_function)(FILE*)) {
+    toku_set_func_fclose(fclose_function);
 }
 
-int
-db_env_set_func_pread (ssize_t (*fun)(int, void *, size_t, off_t)) {
-    return toku_set_func_pread(fun);
+void db_env_set_func_pread (ssize_t (*fun)(int, void *, size_t, off_t)) {
+    toku_set_func_pread(fun);
 }
 
-void 
-db_env_set_func_loader_fwrite (size_t (*fwrite_fun)(const void*,size_t,size_t,FILE*)) {
+void db_env_set_func_loader_fwrite (size_t (*fwrite_fun)(const void*,size_t,size_t,FILE*)) {
     ft_loader_set_os_fwrite(fwrite_fun);
 }
 
-int 
-db_env_set_func_malloc (void *(*f)(size_t)) {
+void db_env_set_func_malloc (void *(*f)(size_t)) {
     toku_set_func_malloc(f);
-    return 0;
 }
 
-int 
-db_env_set_func_realloc (void *(*f)(void*, size_t)) {
+void db_env_set_func_realloc (void *(*f)(void*, size_t)) {
     toku_set_func_realloc(f);
-    return 0;
 }
 
-int 
-db_env_set_func_free (void (*f)(void*)) {
+void db_env_set_func_free (void (*f)(void*)) {
     toku_set_func_free(f);
-    return 0;
 }
 
 // For test purposes only.
@@ -103,7 +86,6 @@ db_env_set_checkpoint_callback (void (*callback_f)(void*), void* extra) {
     checkpoint_callback_f = callback_f;
     checkpoint_callback_extra = extra;
     toku_checkpoint_safe_client_unlock();
-    //printf("set callback = %p, extra = %p\n", callback_f, extra);
 }
 
 void 
@@ -112,7 +94,6 @@ db_env_set_checkpoint_callback2 (void (*callback_f)(void*), void* extra) {
     checkpoint_callback2_f = callback_f;
     checkpoint_callback2_extra = extra;
     toku_checkpoint_safe_client_unlock();
-    //printf("set callback2 = %p, extra2 = %p\n", callback2_f, extra2);
 }
 
 void 
diff --git a/src/ydb_env_func.h b/src/ydb_env_func.h
index 2c9c61e2c30..91ad3da991c 100644
--- a/src/ydb_env_func.h
+++ b/src/ydb_env_func.h
@@ -8,18 +8,17 @@
 #if !defined(TOKU_YDB_ENV_FUNC_H)
 #define TOKU_YDB_ENV_FUNC_H
 
-
 extern void (*checkpoint_callback_f)(void*);
 extern void * checkpoint_callback_extra;
 extern void (*checkpoint_callback2_f)(void*);
 extern void * checkpoint_callback2_extra;
 
 extern uint32_t engine_status_enable;
+
 // Called to use dlmalloc functions.
 void setup_dlmalloc(void) __attribute__((__visibility__("default")));
 
 // Test-only function
 void toku_env_increase_last_xid(DB_ENV *env, uint64_t increment);
 
-
 #endif
diff --git a/src/ydb_txn.cc b/src/ydb_txn.cc
index 410ec41b06c..ca9be294059 100644
--- a/src/ydb_txn.cc
+++ b/src/ydb_txn.cc
@@ -208,7 +208,7 @@ toku_txn_xa_prepare (DB_TXN *txn, TOKU_XA_XID *xid) {
     assert(!db_txn_struct_i(txn)->child);
     TOKUTXN ttxn;
     ttxn = db_txn_struct_i(txn)->tokutxn;
-    r = toku_txn_prepare_txn(ttxn, xid);
+    toku_txn_prepare_txn(ttxn, xid);
     TOKULOGGER logger;
     logger = txn->mgrp->i->logger;
     LSN do_fsync_lsn;
diff --git a/src/ydb_write.cc b/src/ydb_write.cc
index 07e3433ab47..8aa96943273 100644
--- a/src/ydb_write.cc
+++ b/src/ydb_write.cc
@@ -156,7 +156,7 @@ toku_db_del(DB *db, DB_TXN *txn, DBT *key, uint32_t flags, bool holds_mo_lock) {
     if (r == 0) {
         //Do the actual deleting.
         if (!holds_mo_lock) toku_multi_operation_client_lock();
-        r = toku_ft_delete(db->i->ft_handle, key, txn ? db_txn_struct_i(txn)->tokutxn : 0);
+        toku_ft_delete(db->i->ft_handle, key, txn ? db_txn_struct_i(txn)->tokutxn : 0);
         if (!holds_mo_lock) toku_multi_operation_client_unlock();
     }
 
@@ -197,7 +197,7 @@ toku_db_put(DB *db, DB_TXN *txn, DBT *key, DBT *val, uint32_t flags, bool holds_
             type = FT_INSERT_NO_OVERWRITE;
         }
         if (!holds_mo_lock) toku_multi_operation_client_lock();
-        r = toku_ft_maybe_insert(db->i->ft_handle, key, val, ttxn, false, ZERO_LSN, true, type);
+        toku_ft_maybe_insert(db->i->ft_handle, key, val, ttxn, false, ZERO_LSN, true, type);
         if (!holds_mo_lock) toku_multi_operation_client_unlock();
     }
 
@@ -238,7 +238,7 @@ toku_db_update(DB *db, DB_TXN *txn,
     TOKUTXN ttxn;
     ttxn = txn ? db_txn_struct_i(txn)->tokutxn : NULL;
     toku_multi_operation_client_lock();
-    r = toku_ft_maybe_update(db->i->ft_handle, key, update_function_extra, ttxn,
+    toku_ft_maybe_update(db->i->ft_handle, key, update_function_extra, ttxn,
                               false, ZERO_LSN, true);
     toku_multi_operation_client_unlock();
 
@@ -295,7 +295,7 @@ toku_db_update_broadcast(DB *db, DB_TXN *txn,
     TOKUTXN ttxn;
     ttxn = txn ? db_txn_struct_i(txn)->tokutxn : NULL;
     toku_multi_operation_client_lock();
-    r = toku_ft_maybe_update_broadcast(db->i->ft_handle, update_function_extra, ttxn,
+    toku_ft_maybe_update_broadcast(db->i->ft_handle, update_function_extra, ttxn,
                                         false, ZERO_LSN, true, is_resetting_op);
     toku_multi_operation_client_unlock();
 
@@ -307,11 +307,10 @@ toku_db_update_broadcast(DB *db, DB_TXN *txn,
     return r;
 }
 
-static int
+static void
 log_del_single(DB_TXN *txn, FT_HANDLE brt, const DBT *key) {
     TOKUTXN ttxn = db_txn_struct_i(txn)->tokutxn;
-    int r = toku_ft_log_del(ttxn, brt, key);
-    return r;
+    toku_ft_log_del(ttxn, brt, key);
 }
 
 static uint32_t
@@ -322,22 +321,21 @@ sum_size(uint32_t num_keys, DBT keys[], uint32_t overhead) {
     return sum;
 }
 
-static int
+static void
 log_del_multiple(DB_TXN *txn, DB *src_db, const DBT *key, const DBT *val, uint32_t num_dbs, FT_HANDLE brts[], DBT keys[]) {
-    int r = 0;
     if (num_dbs > 0) {
         TOKUTXN ttxn = db_txn_struct_i(txn)->tokutxn;
         FT_HANDLE src_ft  = src_db ? src_db->i->ft_handle : NULL;
         uint32_t del_multiple_size = key->size + val->size + num_dbs*sizeof (uint32_t) + toku_log_enq_delete_multiple_overhead;
         uint32_t del_single_sizes = sum_size(num_dbs, keys, toku_log_enq_delete_any_overhead);
         if (del_single_sizes < del_multiple_size) {
-            for (uint32_t i = 0; r == 0 && i < num_dbs; i++)
-                r = log_del_single(txn, brts[i], &keys[i]);
+            for (uint32_t i = 0; i < num_dbs; i++) {
+                log_del_single(txn, brts[i], &keys[i]);
+            }
         } else {
-            r = toku_ft_log_del_multiple(ttxn, src_ft, brts, num_dbs, key, val);
+            toku_ft_log_del_multiple(ttxn, src_ft, brts, num_dbs, key, val);
         }
     }
-    return r;
 }
 
 static uint32_t 
@@ -374,7 +372,7 @@ do_del_multiple(DB_TXN *txn, uint32_t num_dbs, DB *db_array[], DBT keys[], DB *s
             do_delete = !toku_indexer_is_key_right_of_le_cursor(indexer, indexer_src_key);
         }
         if (r == 0 && do_delete) {
-            r = toku_ft_maybe_delete(db->i->ft_handle, &keys[which_db], ttxn, false, ZERO_LSN, false);
+            toku_ft_maybe_delete(db->i->ft_handle, &keys[which_db], ttxn, false, ZERO_LSN, false);
         }
     }
     return r;
@@ -488,10 +486,10 @@ env_del_multiple(
     }
     toku_multi_operation_client_lock();
     if (num_dbs == 1) {
-        r = log_del_single(txn, brts[0], &del_keys[0]);
+        log_del_single(txn, brts[0], &del_keys[0]);
     }
     else {
-        r = log_del_multiple(txn, src_db, src_key, src_val, num_dbs, brts, del_keys);
+        log_del_multiple(txn, src_db, src_key, src_val, num_dbs, brts, del_keys);
     }
     if (r == 0) {
         r = do_del_multiple(txn, num_dbs, db_array, del_keys, src_db, src_key);
@@ -509,22 +507,19 @@ env_del_multiple(
     return r;
 }
 
-static int
+static void
 log_put_single(DB_TXN *txn, FT_HANDLE brt, const DBT *key, const DBT *val) {
     TOKUTXN ttxn = db_txn_struct_i(txn)->tokutxn;
-    int r = toku_ft_log_put(ttxn, brt, key, val);
-    return r;
+    toku_ft_log_put(ttxn, brt, key, val);
 }
 
-static int
+static void
 log_put_multiple(DB_TXN *txn, DB *src_db, const DBT *src_key, const DBT *src_val, uint32_t num_dbs, FT_HANDLE brts[]) {
-    int r = 0;
     if (num_dbs > 0) {
         TOKUTXN ttxn = db_txn_struct_i(txn)->tokutxn;
         FT_HANDLE src_ft  = src_db ? src_db->i->ft_handle : NULL;
-        r = toku_ft_log_put_multiple(ttxn, src_ft, brts, num_dbs, src_key, src_val);
+        toku_ft_log_put_multiple(ttxn, src_ft, brts, num_dbs, src_key, src_val);
     }
-    return r;
 }
 
 static int
@@ -552,7 +547,7 @@ do_put_multiple(DB_TXN *txn, uint32_t num_dbs, DB *db_array[], DBT keys[], DBT v
             do_put = !toku_indexer_is_key_right_of_le_cursor(indexer, indexer_src_key);
         }
         if (r == 0 && do_put) {
-            r = toku_ft_maybe_insert(db->i->ft_handle, &keys[which_db], &vals[which_db], ttxn, false, ZERO_LSN, false, FT_INSERT);
+            toku_ft_maybe_insert(db->i->ft_handle, &keys[which_db], &vals[which_db], ttxn, false, ZERO_LSN, false, FT_INSERT);
         }
     }
     return r;
@@ -644,10 +639,10 @@ env_put_multiple_internal(
     }
     toku_multi_operation_client_lock();
     if (num_dbs == 1) {
-        r = log_put_single(txn, brts[0], &put_keys[0], &put_vals[0]);
+        log_put_single(txn, brts[0], &put_keys[0], &put_vals[0]);
     }
     else {
-        r = log_put_multiple(txn, src_db, src_key, src_val, num_dbs, brts);
+        log_put_multiple(txn, src_db, src_key, src_val, num_dbs, brts);
     }
     if (r == 0) {
         r = do_put_multiple(txn, num_dbs, db_array, put_keys, put_vals, src_db, src_key);
@@ -799,19 +794,21 @@ env_update_multiple(DB_ENV *env, DB *src_db, DB_TXN *txn,
         }
         toku_multi_operation_client_lock();
         if (r == 0 && n_del_dbs > 0) {
-            if (n_del_dbs == 1)
-                r = log_del_single(txn, del_fts[0], &del_keys[0]);
-            else
-                r = log_del_multiple(txn, src_db, old_src_key, old_src_data, n_del_dbs, del_fts, del_keys);
-            if (r == 0)
+            if (n_del_dbs == 1) {
+                log_del_single(txn, del_fts[0], &del_keys[0]);
+            } else {
+                log_del_multiple(txn, src_db, old_src_key, old_src_data, n_del_dbs, del_fts, del_keys);
+            }
+            if (r == 0) {
                 r = do_del_multiple(txn, n_del_dbs, del_dbs, del_keys, src_db, old_src_key);
+            }
         }
 
         if (r == 0 && n_put_dbs > 0) {
             if (n_put_dbs == 1)
-                r = log_put_single(txn, put_fts[0], &put_keys[0], &put_vals[0]);
+                log_put_single(txn, put_fts[0], &put_keys[0], &put_vals[0]);
             else
-                r = log_put_multiple(txn, src_db, new_src_key, new_src_data, n_put_dbs, put_fts);
+                log_put_multiple(txn, src_db, new_src_key, new_src_data, n_put_dbs, put_fts);
             if (r == 0)
                 r = do_put_multiple(txn, n_put_dbs, put_dbs, put_keys, put_vals, src_db, new_src_key);
         }
diff --git a/toku_include/toku_os.h b/toku_include/toku_os.h
index 567d8252c26..030ce8a38a7 100644
--- a/toku_include/toku_os.h
+++ b/toku_include/toku_os.h
@@ -3,13 +3,13 @@
 #ident "$Id$"
 #ident "Copyright (c) 2007-2012 Tokutek Inc.  All rights reserved."
 #ident "The technology is licensed by the Massachusetts Institute of Technology, Rutgers State University of New Jersey, and the Research Foundation of State University of New York at Stony Brook under United States of America Serial No. 11/760379 and to the patents and/or patent applications resulting from it."
-#if !defined(TOKU_OS_INTERFACE_H)
-#define TOKU_OS_INTERFACE_H
+
+#ifndef TOKU_OS_H
+#define TOKU_OS_H
 
 #include <dirent.h>
 #include <sys/time.h>
 
-
 #include <toku_os_types.h>
 
 // Returns: the current process id
@@ -67,10 +67,7 @@ int toku_os_get_max_process_data_size(uint64_t *maxdata) __attribute__((__visibi
 
 int toku_os_initialize_settings(int verbosity)  __attribute__((__visibility__("default")));
 
-//
-// this int acts like a bool, returns 0 for false, 1 for true
-//
-int toku_os_is_absolute_name(const char* path)  __attribute__((__visibility__("default")));
+bool toku_os_is_absolute_name(const char* path)  __attribute__((__visibility__("default")));
 
 // Set whether or not writes assert when ENOSPC is returned or they wait for space
 void toku_set_assert_on_write_enospc(int do_assert) __attribute__((__visibility__("default")));
@@ -81,8 +78,7 @@ void toku_set_assert_on_write_enospc(int do_assert) __attribute__((__visibility_
 // *enospc_total     is the number of times ENOSPC was returned by write or pwrite
 void toku_fs_get_write_info(time_t *enospc_last_time, uint64_t *enospc_current, uint64_t *enospc_total);
 
-
-int toku_fsync_dirfd_without_accounting(DIR *dirp);
+void toku_fsync_dirfd_without_accounting(DIR *dirp);
 
 int toku_fsync_dir_by_name_without_accounting(const char *dir_name);
 
@@ -108,6 +104,4 @@ int toku_fstat(int fd, toku_struct_stat *statbuf) __attribute__((__visibility__(
 // Portable linux 'dup2'
 int toku_dup2(int fd, int fd2) __attribute__((__visibility__("default")));
 
-
-#endif
-
+#endif /* TOKU_OS_H */
diff --git a/toku_include/toku_portability.h b/toku_include/toku_portability.h
index 88fdc6b87df..0280f03fcc3 100644
--- a/toku_include/toku_portability.h
+++ b/toku_include/toku_portability.h
@@ -10,7 +10,6 @@
 
 // Tokutek portability layer
 
-
 #if defined(_MSC_VER) || (defined(__INTEL_COMPILER) && defined(__ICL))
 
 #define TOKU_WINDOWS 1
@@ -24,7 +23,6 @@
 #  define TOKU_WINDOWS_64 2
 #endif
 
-
 #else
 
 #define TOKU_WINDOWS 0
@@ -205,7 +203,7 @@ extern void *realloc(void*, size_t)            __THROW __attribute__((__deprecat
 
 void *os_malloc(size_t) __attribute__((__visibility__("default")));
 void *os_realloc(void*,size_t) __attribute__((__visibility__("default")));
-void  os_free(void*) __attribute__((__visibility__("default")));
+void os_free(void*) __attribute__((__visibility__("default")));
 
 // full_pwrite and full_write performs a pwrite, and checks errors.  It doesn't return unless all the data was written. */
 void toku_os_full_pwrite (int fd, const void *buf, size_t len, toku_off_t off) __attribute__((__visibility__("default")));
@@ -225,10 +223,9 @@ ssize_t toku_os_read(int fd, void *buf, size_t count);
 ssize_t toku_os_pread(int fd, void *buf, size_t count, off_t offset);
 
 // wrapper around fsync
-int toku_file_fsync_without_accounting(int fd);
-int toku_file_fsync(int fd);
-
-    int toku_fsync_directory(const char *fname);
+void toku_file_fsync_without_accounting(int fd);
+void toku_file_fsync(int fd);
+int toku_fsync_directory(const char *fname);
 
 // get the number of fsync calls and the fsync times (total)
 void toku_get_fsync_times(uint64_t *fsync_count, uint64_t *fsync_time);
@@ -236,21 +233,19 @@ void toku_get_fsync_times(uint64_t *fsync_count, uint64_t *fsync_time);
 // get the number of fsync calls and the fsync times for use by scheduler (subset of total)
 void toku_get_fsync_sched(uint64_t *fsync_count, uint64_t *fsync_time);
 
-// set a new fsync function (for debugging)
-int toku_set_func_fsync (int (*fsync_function)(int));
-
-int toku_set_func_pwrite (ssize_t (*)(int, const void *, size_t, toku_off_t));
-int toku_set_func_full_pwrite (ssize_t (*)(int, const void *, size_t, toku_off_t));
-int toku_set_func_write (ssize_t (*)(int, const void *, size_t));
-int toku_set_func_full_write (ssize_t (*)(int, const void *, size_t));
-int toku_set_func_fdopen (FILE * (*)(int, const char *));
-int toku_set_func_fopen (FILE * (*)(const char *, const char *));
-int toku_set_func_open (int (*)(const char *, int, int));  // variadic form not implemented until needed
-int toku_set_func_fclose(int (*)(FILE*));
-int toku_set_func_read(ssize_t (*)(int, void *, size_t));
-int toku_set_func_pread (ssize_t (*)(int, void *, size_t, off_t));
-int toku_portability_init    (void);
-void toku_portability_destroy (void);
-
-
-#endif
+void toku_set_func_fsync (int (*fsync_function)(int));
+void toku_set_func_pwrite (ssize_t (*)(int, const void *, size_t, toku_off_t));
+void toku_set_func_full_pwrite (ssize_t (*)(int, const void *, size_t, toku_off_t));
+void toku_set_func_write (ssize_t (*)(int, const void *, size_t));
+void toku_set_func_full_write (ssize_t (*)(int, const void *, size_t));
+void toku_set_func_fdopen (FILE * (*)(int, const char *));
+void toku_set_func_fopen (FILE * (*)(const char *, const char *));
+void toku_set_func_open (int (*)(const char *, int, int));
+void toku_set_func_fclose(int (*)(FILE*));
+void toku_set_func_read(ssize_t (*)(int, void *, size_t));
+void toku_set_func_pread (ssize_t (*)(int, void *, size_t, off_t));
+
+int toku_portability_init(void);
+void toku_portability_destroy(void);
+
+#endif /* TOKU_PORTABILITY_H */

