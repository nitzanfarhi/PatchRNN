commit 8ac0e95d6467ced054565312ecdf0a55a5333c64
Author: Axel Lin <axel.lin@gmail.com>
Date:   Sat Apr 14 09:14:34 2012 +0800

    regulator: core: Support setting suspend_[mode|voltage] if set_suspend_[en|dis]able is NULL
    
    In current implementation, to support set_suspend_voltage and set_suspend_mode
    the regulator code needs the regulator driver to implement both
    set_suspend_enable and set_suspend_disable callbacks.
    
    This patch removes this limitation. In the case set_suspend_enable and/or
    set_suspend_disable are NULL, the regulator code assumes we don't need to
    do any thing to enable/disable regulator when system is suspended and
    then will continue to handle set_suspend_mode and set_suspend_voltage.
    
    Currently the regulator core creates suspend state related sysfs entries only
    if both set_suspend_enable and set_suspend_disable callbacks are not NULL.
    A side-effect of this change is that the regulator core will create suspend
    state related sysfs entries unconditionally now.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 713981b52f2a..5c0c975e5ac2 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -673,17 +673,14 @@ static int suspend_set_state(struct regulator_dev *rdev,
 	struct regulator_state *rstate)
 {
 	int ret = 0;
-	bool can_set_state;
-
-	can_set_state = rdev->desc->ops->set_suspend_enable &&
-		rdev->desc->ops->set_suspend_disable;
 
 	/* If we have no suspend mode configration don't set anything;
-	 * only warn if the driver actually makes the suspend mode
-	 * configurable.
+	 * only warn if the driver implements set_suspend_voltage or
+	 * set_suspend_mode callback.
 	 */
 	if (!rstate->enabled && !rstate->disabled) {
-		if (can_set_state)
+		if (rdev->desc->ops->set_suspend_voltage ||
+		    rdev->desc->ops->set_suspend_mode)
 			rdev_warn(rdev, "No configuration\n");
 		return 0;
 	}
@@ -693,15 +690,13 @@ static int suspend_set_state(struct regulator_dev *rdev,
 		return -EINVAL;
 	}
 
-	if (!can_set_state) {
-		rdev_err(rdev, "no way to set suspend state\n");
-		return -EINVAL;
-	}
-
-	if (rstate->enabled)
+	if (rstate->enabled && rdev->desc->ops->set_suspend_enable)
 		ret = rdev->desc->ops->set_suspend_enable(rdev);
-	else
+	else if (rstate->disabled && rdev->desc->ops->set_suspend_disable)
 		ret = rdev->desc->ops->set_suspend_disable(rdev);
+	else /* OK if set_suspend_enable or set_suspend_disable is NULL */
+		ret = 0;
+
 	if (ret < 0) {
 		rdev_err(rdev, "failed to enabled/disable\n");
 		return ret;
@@ -2776,10 +2771,6 @@ static int add_regulator_attributes(struct regulator_dev *rdev)
 			return status;
 	}
 
-	/* suspend mode constraints need multiple supporting methods */
-	if (!(ops->set_suspend_enable && ops->set_suspend_disable))
-		return status;
-
 	status = device_create_file(dev, &dev_attr_suspend_standby_state);
 	if (status < 0)
 		return status;

