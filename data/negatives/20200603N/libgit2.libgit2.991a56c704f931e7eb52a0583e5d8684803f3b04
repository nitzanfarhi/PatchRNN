commit 991a56c704f931e7eb52a0583e5d8684803f3b04
Author: Russell Belfer <rb@github.com>
Date:   Tue Jul 10 15:35:38 2012 -0700

    Add flag to write gitlink on setting repo workdir
    
    This added a flag to the `git_repository_set_workdir()` function
    that enables generation of a `.git` gitlink file that links the
    new workdir to the parent repository.  Essentially, the flag tells
    the function to write out the changes to disk to permanently set
    the workdir of the repository to the new path.
    
    If you pass this flag as true, then setting the workdir to something
    other than the default workdir (i.e. the parent of the .git repo
    directory), will create a plain file named ".git" with the standard
    gitlink contents "gitdir: <repo-path>", and also update the
    "core.worktree" and "core.bare" config values.
    
    Setting the workdir to the default repo workdir will clear the
    core.worktree flag (but still permanently set core.bare to false).
    
    BTW, the libgit2 API does not currently provide a function for
    clearing the workdir and converting a non-bare repo into a bare one.

diff --git a/include/git2/repository.h b/include/git2/repository.h
index 0b56a0870..ff81b75ec 100644
--- a/include/git2/repository.h
+++ b/include/git2/repository.h
@@ -194,9 +194,12 @@ GIT_EXTERN(const char *) git_repository_workdir(git_repository *repo);
  *
  * @param repo A repository object
  * @param workdir The path to a working directory
+ * @param update_gitlink Create/update gitlink in workdir and set config
+ *        "core.worktree" (if workdir is not the parent of the .git directory)
  * @return 0, or an error code
  */
-GIT_EXTERN(int) git_repository_set_workdir(git_repository *repo, const char *workdir);
+GIT_EXTERN(int) git_repository_set_workdir(
+	git_repository *repo, const char *workdir, int update_gitlink);
 
 /**
  * Check if a repository is bare
diff --git a/src/repository.c b/src/repository.c
index bee7b3ee6..a2931713e 100644
--- a/src/repository.c
+++ b/src/repository.c
@@ -741,15 +741,24 @@ static int repo_init_config(const char *git_dir, bool is_bare, bool is_reinit)
 #define GIT_DESC_CONTENT "Unnamed repository; edit this file 'description' to name the repository.\n"
 
 static int repo_write_template(
-	const char *git_dir, const char *file, mode_t mode, const char *content)
+	const char *git_dir,
+	bool allow_overwrite,
+	const char *file,
+	mode_t mode,
+	const char *content)
 {
 	git_buf path = GIT_BUF_INIT;
-	int fd, error = 0;
+	int fd, error = 0, flags;
 
 	if (git_buf_joinpath(&path, git_dir, file) < 0)
 		return -1;
 
-	fd = p_open(git_buf_cstr(&path), O_WRONLY | O_CREAT | O_EXCL, mode);
+	if (allow_overwrite)
+		flags = O_WRONLY | O_CREAT | O_TRUNC;
+	else
+		flags = O_WRONLY | O_CREAT | O_EXCL;
+
+	fd = p_open(git_buf_cstr(&path), flags, mode);
 
 	if (fd >= 0) {
 		error = p_write(fd, content, strlen(content));
@@ -811,7 +820,7 @@ static int repo_init_structure(const char *git_dir, int is_bare)
 	/* Make template files as needed */
 	for (i = 0; tmpl[i].file != NULL; ++i) {
 		if (repo_write_template(
-				git_dir, tmpl[i].file, tmpl[i].mode, tmpl[i].content) < 0)
+				git_dir, false, tmpl[i].file, tmpl[i].mode, tmpl[i].content) < 0)
 			return -1;
 	}
 
@@ -943,8 +952,47 @@ const char *git_repository_workdir(git_repository *repo)
 	return repo->workdir;
 }
 
-int git_repository_set_workdir(git_repository *repo, const char *workdir)
+static int write_gitlink(
+	const char *in_dir, const char *to_repo)
+{
+	int error;
+	git_buf buf = GIT_BUF_INIT;
+	struct stat st;
+
+	if (git_path_dirname_r(&buf, to_repo) < 0 ||
+		git_path_to_dir(&buf) < 0)
+		return -1;
+
+	/* don't write gitlink to natural workdir */
+	if (git__suffixcmp(to_repo, "/" DOT_GIT "/") == 0 &&
+		strcmp(in_dir, buf.ptr) == 0)
+		return GIT_PASSTHROUGH;
+
+	if (git_buf_joinpath(&buf, in_dir, DOT_GIT) < 0)
+		return -1;
+
+	if (!p_stat(buf.ptr, &st) && !S_ISREG(st.st_mode)) {
+		giterr_set(GITERR_REPOSITORY,
+			"Cannot overwrite gitlink file into path '%s'", in_dir);
+		return GIT_EEXISTS;
+	}
+
+	git_buf_clear(&buf);
+
+	if (git_buf_printf(&buf, "%s %s", GIT_FILE_CONTENT_PREFIX, to_repo) < 0)
+		return -1;
+
+	error = repo_write_template(in_dir, true, DOT_GIT, 0644, buf.ptr);
+
+	git_buf_free(&buf);
+
+	return error;
+}
+
+int git_repository_set_workdir(
+	git_repository *repo, const char *workdir, int update_gitlink)
 {
+	int error = 0;
 	git_buf path = GIT_BUF_INIT;
 
 	assert(repo && workdir);
@@ -952,11 +1000,37 @@ int git_repository_set_workdir(git_repository *repo, const char *workdir)
 	if (git_path_prettify_dir(&path, workdir, NULL) < 0)
 		return -1;
 
-	git__free(repo->workdir);
+	if (repo->workdir && strcmp(repo->workdir, path.ptr) == 0)
+		return 0;
 
-	repo->workdir = git_buf_detach(&path);
-	repo->is_bare = 0;
-	return 0;
+	if (update_gitlink) {
+		git_config *config;
+
+		if (git_repository_config__weakptr(&config, repo) < 0)
+			return -1;
+
+		error = write_gitlink(path.ptr, git_repository_path(repo));
+
+		/* passthrough error means gitlink is unnecessary */
+		if (error == GIT_PASSTHROUGH)
+			error = git_config_delete(config, "core.worktree");
+		else if (!error)
+			error = git_config_set_string(config, "core.worktree", path.ptr);
+
+		if (!error)
+			error = git_config_set_bool(config, "core.bare", false);
+	}
+
+	if (!error) {
+		char *old_workdir = repo->workdir;
+
+		repo->workdir = git_buf_detach(&path);
+		repo->is_bare = 0;
+
+		git__free(old_workdir);
+	}
+
+	return error;
 }
 
 int git_repository_is_bare(git_repository *repo)
diff --git a/tests-clar/repo/setters.c b/tests-clar/repo/setters.c
index 6242d8541..cd6e389ae 100644
--- a/tests-clar/repo/setters.c
+++ b/tests-clar/repo/setters.c
@@ -2,6 +2,8 @@
 #include "buffer.h"
 #include "posix.h"
 #include "util.h"
+#include "path.h"
+#include "fileops.h"
 
 static git_repository *repo;
 
@@ -16,7 +18,7 @@ void test_repo_setters__cleanup(void)
 {
 	git_repository_free(repo);
 	cl_fixture_cleanup("testrepo.git");
-	cl_must_pass(p_rmdir("new_workdir"));
+	cl_fixture_cleanup("new_workdir");
 }
 
 void test_repo_setters__setting_a_workdir_turns_a_bare_repository_into_a_standard_one(void)
@@ -24,7 +26,7 @@ void test_repo_setters__setting_a_workdir_turns_a_bare_repository_into_a_standar
 	cl_assert(git_repository_is_bare(repo) == 1);
 
 	cl_assert(git_repository_workdir(repo) == NULL);
-	cl_git_pass(git_repository_set_workdir(repo, "./new_workdir"));
+	cl_git_pass(git_repository_set_workdir(repo, "./new_workdir", false));
 
 	cl_assert(git_repository_workdir(repo) != NULL);
 	cl_assert(git_repository_is_bare(repo) == 0);
@@ -32,9 +34,30 @@ void test_repo_setters__setting_a_workdir_turns_a_bare_repository_into_a_standar
 
 void test_repo_setters__setting_a_workdir_prettifies_its_path(void)
 {
-	cl_git_pass(git_repository_set_workdir(repo, "./new_workdir"));
+	cl_git_pass(git_repository_set_workdir(repo, "./new_workdir", false));
 
-	cl_assert(git__suffixcmp(git_repository_workdir(repo), "/") == 0);
+	cl_assert(git__suffixcmp(git_repository_workdir(repo), "new_workdir/") == 0);
+}
+
+void test_repo_setters__setting_a_workdir_creates_a_gitlink(void)
+{
+	git_config *cfg;
+	const char *val;
+	git_buf content = GIT_BUF_INIT;
+
+	cl_git_pass(git_repository_set_workdir(repo, "./new_workdir", true));
+
+	cl_assert(git_path_isfile("./new_workdir/.git"));
+
+	cl_git_pass(git_futils_readbuffer(&content, "./new_workdir/.git"));
+	cl_assert(git__prefixcmp(git_buf_cstr(&content), "gitdir: ") == 0);
+	cl_assert(git__suffixcmp(git_buf_cstr(&content), "testrepo.git/") == 0);
+	git_buf_free(&content);
+
+	cl_git_pass(git_repository_config(&cfg, repo));
+	cl_git_pass(git_config_get_string(&val, cfg, "core.worktree"));
+	cl_assert(git__suffixcmp(val, "new_workdir/") == 0);
+	git_config_free(cfg);
 }
 
 void test_repo_setters__setting_a_new_index_on_a_repo_which_has_already_loaded_one_properly_honors_the_refcount(void)
diff --git a/tests-clar/status/worktree.c b/tests-clar/status/worktree.c
index 3670b72a8..fed81e570 100644
--- a/tests-clar/status/worktree.c
+++ b/tests-clar/status/worktree.c
@@ -459,7 +459,7 @@ void test_status_worktree__status_file_without_index_or_workdir(void)
 	cl_git_pass(p_mkdir("wd", 0777));
 
 	cl_git_pass(git_repository_open(&repo, cl_fixture("testrepo.git")));
-	cl_git_pass(git_repository_set_workdir(repo, "wd"));
+	cl_git_pass(git_repository_set_workdir(repo, "wd", false));
 
 	cl_git_pass(git_index_open(&index, "empty-index"));
 	cl_assert_equal_i(0, git_index_entrycount(index));
@@ -500,7 +500,7 @@ void test_status_worktree__status_file_with_clean_index_and_empty_workdir(void)
 	cl_git_pass(p_mkdir("wd", 0777));
 
 	cl_git_pass(git_repository_open(&repo, cl_fixture("testrepo.git")));
-	cl_git_pass(git_repository_set_workdir(repo, "wd"));
+	cl_git_pass(git_repository_set_workdir(repo, "wd", false));
 
 	cl_git_pass(git_index_open(&index, "my-index"));
 	fill_index_wth_head_entries(repo, index);

