commit 392ea69c2d80dcdd93e5b30c6d8034baf8644b27
Author: Paul Saab <ps@fb.com>
Date:   Thu Apr 17 11:17:04 2014 -0700

    Fix dns_get_record with ipv6 only nameservers in /etc/resolv.conf
    
    Every dns lookup needs to zero and re-init the resolver state,
    otherwise undefined behaviour can happen.  With IPv4 nameservers in
    /etc/resolv.conf, things seemed to work just fine, but when IPv6
    namesevers are in /etc/resolv.conf, then the second request to
    res_nsearch failed since it was not re-initialized.  This matches what
    is done in php-git.
    
    Reviewed By: @ptarjan
    
    Differential Revision: D1281701

diff --git a/hphp/runtime/ext/std/ext_std_network.cpp b/hphp/runtime/ext/std/ext_std_network.cpp
index 9ea68592c0..2591f9f2f9 100644
--- a/hphp/runtime/ext/std/ext_std_network.cpp
+++ b/hphp/runtime/ext/std/ext_std_network.cpp
@@ -89,25 +89,33 @@ static Mutex NetworkMutex;
 
 class ResolverInit {
 public:
-  ResolverInit() : m_res(NULL) {
+  ResolverInit() : m_res(nullptr) {
     m_res = (struct __res_state *)calloc(1, sizeof(*m_res));
-    if (res_ninit(m_res)) {
-      free(m_res);
-      m_res = NULL;
-    }
+    initRes();
   }
   ~ResolverInit() {
     if (m_res)
       free(m_res);
-    m_res = NULL;
+    m_res = nullptr;
   }
 
   struct __res_state *getResolver(void) {
+    initRes();
     return m_res;
   }
 
   static DECLARE_THREAD_LOCAL(ResolverInit, s_res);
 private:
+  void initRes(void) {
+    if (m_res) {
+      memset(m_res, 0, sizeof(*m_res));
+      if (res_ninit(m_res)) {
+        free(m_res);
+        m_res = nullptr;
+      }
+    }
+  }
+
   struct __res_state *m_res;
 };
 IMPLEMENT_THREAD_LOCAL(ResolverInit, ResolverInit::s_res);

