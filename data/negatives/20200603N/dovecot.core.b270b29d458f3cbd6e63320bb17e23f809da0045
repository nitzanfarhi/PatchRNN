commit b270b29d458f3cbd6e63320bb17e23f809da0045
Author: Timo Sirainen <tss@iki.fi>
Date:   Sat Nov 4 17:09:26 2006 +0200

    Crashfixes
    
    --HG--
    branch : HEAD

diff --git a/src/auth/db-ldap.c b/src/auth/db-ldap.c
index 3da26d45b..246957b35 100644
--- a/src/auth/db-ldap.c
+++ b/src/auth/db-ldap.c
@@ -142,11 +142,9 @@ void db_ldap_search(struct ldap_connection *conn, struct ldap_request *request,
 {
 	int msgid;
 
-	if (!conn->connected && !conn->connecting) {
-		if (db_ldap_connect(conn) < 0) {
-			request->callback(conn, request, NULL);
-			return;
-		}
+	if (db_ldap_connect(conn) < 0) {
+		request->callback(conn, request, NULL);
+		return;
 	}
 
 	if (conn->last_auth_bind) {
@@ -370,6 +368,7 @@ static int db_ldap_bind(struct ldap_connection *conn)
 	if (msgid == -1) {
 		i_error("ldap_bind(%s) failed: %s",
 			conn->set.dn, ldap_get_error(conn));
+		i_free(ldap_request);
 		return -1;
 	}
 	hash_insert(conn->requests, POINTER_CAST(msgid), ldap_request);
@@ -380,13 +379,26 @@ static int db_ldap_bind(struct ldap_connection *conn)
 	return 0;
 }
 
+static void db_ldap_get_fd(struct ldap_connection *conn)
+{
+	int ret;
+
+	/* get the connection's fd */
+	ret = ldap_get_option(conn->ld, LDAP_OPT_DESC, (void *)&conn->fd);
+	if (ret != LDAP_SUCCESS) {
+		i_fatal("LDAP: Can't get connection fd: %s",
+			ldap_err2string(ret));
+	}
+	i_assert(conn->fd != -1);
+	net_set_nonblock(conn->fd, TRUE);
+}
+
 int db_ldap_connect(struct ldap_connection *conn)
 {
 	unsigned int ldap_version;
 	int ret;
 
-	i_assert(!conn->connecting);
-	if (conn->connected)
+	if (conn->connected || conn->connecting)
 		return 0;
 
 	if (conn->ld == NULL) {
@@ -423,17 +435,7 @@ int db_ldap_connect(struct ldap_connection *conn)
 			i_fatal("LDAP: Can't set protocol version %u: %s",
 				ldap_version, ldap_err2string(ret));
 		}
-
-		/* get the connection's fd */
-		ret = ldap_get_option(conn->ld, LDAP_OPT_DESC,
-				      (void *)&conn->fd);
-		if (ret != LDAP_SUCCESS) {
-			i_fatal("LDAP: Can't get connection fd: %s",
-				ldap_err2string(ret));
-		}
-		net_set_nonblock(conn->fd, TRUE);
 	}
-	i_assert(conn->fd != -1);
 
 	if (conn->set.tls) {
 #ifdef LDAP_HAVE_START_TLS_S
@@ -469,9 +471,11 @@ int db_ldap_connect(struct ldap_connection *conn)
 #endif
 		if (db_ldap_connect_finish(conn, ret) < 0)
 			return -1;
+		db_ldap_get_fd(conn);
 	} else {
 		if (db_ldap_bind(conn) < 0)
 			return -1;
+		db_ldap_get_fd(conn);
 	}
 
 	conn->io = io_add(conn->fd, IO_READ, ldap_input, conn);
diff --git a/src/auth/db-ldap.h b/src/auth/db-ldap.h
index e61888af1..82013032a 100644
--- a/src/auth/db-ldap.h
+++ b/src/auth/db-ldap.h
@@ -56,7 +56,7 @@ struct ldap_connection {
         struct ldap_settings set;
 
 	LDAP *ld;
-	int fd; /* only set when ld is not NULL */
+	int fd; /* only set when connected/connecting */
 	struct io *io;
 	struct hash_table *requests;
 
diff --git a/src/auth/passdb-ldap.c b/src/auth/passdb-ldap.c
index acd2f1cc6..763dba601 100644
--- a/src/auth/passdb-ldap.c
+++ b/src/auth/passdb-ldap.c
@@ -439,11 +439,9 @@ ldap_verify_plain(struct auth_request *request,
 
 	/* reconnect if needed. this is also done by db_ldap_search(), but
 	   with auth binds we'll have to do it ourself */
-	if (!conn->connected && !conn->connecting) {
-		if (db_ldap_connect(conn)< 0) {
-			callback(PASSDB_RESULT_INTERNAL_FAILURE, request);
-			return;
-		}
+	if (db_ldap_connect(conn)< 0) {
+		callback(PASSDB_RESULT_INTERNAL_FAILURE, request);
+		return;
 	}
 
 	ldap_request = p_new(request->pool, struct passdb_ldap_request, 1);

