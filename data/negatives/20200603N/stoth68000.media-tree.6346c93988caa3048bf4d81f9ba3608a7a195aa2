commit 6346c93988caa3048bf4d81f9ba3608a7a195aa2
Author: Josef Bacik <josef@redhat.com>
Date:   Tue Nov 10 21:23:47 2009 -0500

    Btrfs: fix data allocation hint start
    
    Sometimes our start allocation hint when we cow a file can be either
    EXTENT_HOLE or some other such place holder, which is not optimal.  So if we
    find that our em->block_start is one of these special values, check to see
    where the first block of the inode is stored, and use that as a hint.  If that
    block is also a special value, just fallback on a hint of 0 and let the
    allocator figure out a good place to put the data.
    
    Signed-off-by: Josef Bacik <josef@redhat.com>
    Signed-off-by: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c
index 78139efe41fc..d8393ddc72a3 100644
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -743,8 +743,22 @@ static noinline int cow_file_range(struct inode *inode,
 	em = search_extent_mapping(&BTRFS_I(inode)->extent_tree,
 				   start, num_bytes);
 	if (em) {
-		alloc_hint = em->block_start;
-		free_extent_map(em);
+		/*
+		 * if block start isn't an actual block number then find the
+		 * first block in this inode and use that as a hint.  If that
+		 * block is also bogus then just don't worry about it.
+		 */
+		if (em->block_start >= EXTENT_MAP_LAST_BYTE) {
+			free_extent_map(em);
+			em = search_extent_mapping(em_tree, 0, 0);
+			if (em && em->block_start < EXTENT_MAP_LAST_BYTE)
+				alloc_hint = em->block_start;
+			if (em)
+				free_extent_map(em);
+		} else {
+			alloc_hint = em->block_start;
+			free_extent_map(em);
+		}
 	}
 	read_unlock(&BTRFS_I(inode)->extent_tree.lock);
 	btrfs_drop_extent_cache(inode, start, start + num_bytes - 1, 0);

