commit d9355f8934a4c54d81a29ae7bd5ae4329c02aa48
Author: Ken Cox <jkc@redhat.com>
Date:   Wed Mar 19 13:06:22 2014 -0500

    Staging: unisys: Remove RETPTR macro
    
    The RETPTR macro contained a goto statement which is not allowed in
    the kernel.
    
    Signed-off-by: Ken Cox <jkc@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/timskmod.h b/drivers/staging/unisys/include/timskmod.h
index 0623f55ec764..41cbcde7c15c 100644
--- a/drivers/staging/unisys/include/timskmod.h
+++ b/drivers/staging/unisys/include/timskmod.h
@@ -128,10 +128,6 @@ typedef long VMMIO32;/**< #VMMIO pointing to 32-bit data */
  *  @param x the value to return
  */
 #define RETINT(x)  do { rc = (x); RETTRACE(x); goto Away; } while (0)
-/** return from a void* function, using a common exit point "Away"
- *  @param x the value to return
- */
-#define RETPTR(x)  do { rc = (x); RETTRACE(x); goto Away; } while (0)
 /** Given a typedef/struct/union and a member field name,
  *  return the number of bytes occupied by that field.
  *  @param TYPE     the typedef name, or "struct xx" or "union xx"
diff --git a/drivers/staging/unisys/uislib/uislib.c b/drivers/staging/unisys/uislib/uislib.c
index 1737f3ad007b..4f8a8081f8d0 100644
--- a/drivers/staging/unisys/uislib/uislib.c
+++ b/drivers/staging/unisys/uislib/uislib.c
@@ -270,24 +270,27 @@ init_vbus_channel(U64 channelAddr, U32 channelBytes, int isServer)
 		LOGERR("CONTROLVM_BUS_CREATE error: ioremap_cache of channelAddr:%Lx for channelBytes:%llu failed",
 		     (unsigned long long) channelAddr,
 		     (unsigned long long) channelBytes);
-		RETPTR(NULL);
+		rc = NULL;
+		goto Away;
 	}
 	if (isServer) {
 		memset_io(pChan, 0, channelBytes);
 		if (!ULTRA_VBUS_CHANNEL_OK_SERVER(channelBytes, NULL)) {
 			ERRDRV("%s channel cannot be used", __func__);
 			uislib_iounmap(pChan);
-			RETPTR(NULL);
+			rc = NULL;
+			goto Away;
 		}
 		ULTRA_VBUS_init_channel(pChan, channelBytes);
 	} else {
 		if (!ULTRA_VBUS_CHANNEL_OK_CLIENT(pChan, NULL)) {
 			ERRDRV("%s channel cannot be used", __func__);
 			uislib_iounmap(pChan);
-			RETPTR(NULL);
+			rc = NULL;
+			goto Away;
 		}
 	}
-	RETPTR(pChan);
+	rc = pChan;
 Away:
 	return rc;
 }
diff --git a/drivers/staging/unisys/uislib/uisqueue.c b/drivers/staging/unisys/uislib/uisqueue.c
index 7ea306e52ba8..7bd05f7fe5ef 100644
--- a/drivers/staging/unisys/uislib/uisqueue.c
+++ b/drivers/staging/unisys/uislib/uisqueue.c
@@ -30,7 +30,6 @@
 
 #define RETVOID    do { goto Away; } while (0)
 #define RETINT(x)  do { rc = (x); goto Away; } while (0)
-#define RETPTR(x)  do { rc = (x); goto Away; } while (0)
 
 #define CHECK_CACHE_ALIGN 0
 
diff --git a/drivers/staging/unisys/visorchannel/visorchannel_funcs.c b/drivers/staging/unisys/visorchannel/visorchannel_funcs.c
index ff4556b59262..99889fd2ea1e 100644
--- a/drivers/staging/unisys/visorchannel/visorchannel_funcs.c
+++ b/drivers/staging/unisys/visorchannel/visorchannel_funcs.c
@@ -89,8 +89,7 @@ visorchannel_create_guts(HOSTADDRESS physaddr, ulong channelBytes,
 	p->size = channelBytes;
 	p->guid = guid;
 
-	RETPTR(p);
-
+	rc = p;
 Away:
 
 	if (rc == NULL) {
diff --git a/drivers/staging/unisys/visorchipset/parser.c b/drivers/staging/unisys/visorchipset/parser.c
index de0a4c23ffaf..6904dcce312b 100644
--- a/drivers/staging/unisys/visorchipset/parser.c
+++ b/drivers/staging/unisys/visorchipset/parser.c
@@ -63,7 +63,8 @@ parser_init_guts(U64 addr, U32 bytes, BOOL isLocal,
 		       MAX_CONTROLVM_PAYLOAD_BYTES);
 		if (tryAgain)
 			*tryAgain = TRUE;
-		RETPTR(NULL);
+		rc = NULL;
+		goto Away;
 	}
 	ctx = kzalloc(allocbytes, GFP_KERNEL|__GFP_NORETRY);
 	if (ctx == NULL) {
@@ -71,7 +72,8 @@ parser_init_guts(U64 addr, U32 bytes, BOOL isLocal,
 		       __func__, __FILE__, __LINE__, allocbytes);
 		if (tryAgain)
 			*tryAgain = TRUE;
-		RETPTR(NULL);
+		rc = NULL;
+		goto Away;
 	}
 
 	ctx->allocbytes = allocbytes;
@@ -85,45 +87,53 @@ parser_init_guts(U64 addr, U32 bytes, BOOL isLocal,
 			ERRDRV("%s - bad local address (0x%-16.16Lx for %lu)",
 			       __func__,
 			       (unsigned long long) addr, (ulong) bytes);
-			RETPTR(NULL);
+			rc = NULL;
+			goto Away;
 		}
 		p = __va((ulong) (addr));
 		memcpy(ctx->data, p, bytes);
 	} else {
 		rgn = visor_memregion_create(addr, bytes);
-		if (!rgn)
-			RETPTR(NULL);
-		if (visor_memregion_read(rgn, 0, ctx->data, bytes) < 0)
-			RETPTR(NULL);
+		if (!rgn) {
+			rc = NULL;
+			goto Away;
+		}
+		if (visor_memregion_read(rgn, 0, ctx->data, bytes) < 0) {
+			rc = NULL;
+			goto Away;
+		}
 	}
 	if (!hasStandardPayloadHeader) {
 		ctx->byte_stream = TRUE;
-		RETPTR(ctx);
+		rc = ctx;
+		goto Away;
 	}
 	phdr = (ULTRA_CONTROLVM_PARAMETERS_HEADER *) (ctx->data);
 	if (phdr->TotalLength != bytes) {
 		ERRDRV("%s - bad total length %lu (should be %lu)",
 		       __func__,
 		       (ulong) (phdr->TotalLength), (ulong) (bytes));
-		RETPTR(NULL);
+		rc = NULL;
+		goto Away;
 	}
 	if (phdr->TotalLength < phdr->HeaderLength) {
 		ERRDRV("%s - total length < header length (%lu < %lu)",
 		       __func__,
 		       (ulong) (phdr->TotalLength),
 		       (ulong) (phdr->HeaderLength));
-		RETPTR(NULL);
+		rc = NULL;
+		goto Away;
 	}
 	if (phdr->HeaderLength < sizeof(ULTRA_CONTROLVM_PARAMETERS_HEADER)) {
 		ERRDRV("%s - header is too small (%lu < %lu)",
 		       __func__,
 		       (ulong) (phdr->HeaderLength),
 		       (ulong) (sizeof(ULTRA_CONTROLVM_PARAMETERS_HEADER)));
-		RETPTR(NULL);
+		rc = NULL;
+		goto Away;
 	}
 
-	RETPTR(ctx);
-
+	rc = ctx;
 Away:
 	if (rgn) {
 		visor_memregion_destroy(rgn);
diff --git a/drivers/staging/unisys/visorutil/memregion_direct.c b/drivers/staging/unisys/visorutil/memregion_direct.c
index b9b61e8a8e71..2c1061d55ee9 100644
--- a/drivers/staging/unisys/visorutil/memregion_direct.c
+++ b/drivers/staging/unisys/visorutil/memregion_direct.c
@@ -50,10 +50,11 @@ visor_memregion_create(HOSTADDRESS physaddr, ulong nbytes)
 	memregion->physaddr = physaddr;
 	memregion->nbytes = nbytes;
 	memregion->overlapped = FALSE;
-	if (!mapit(memregion))
-		RETPTR(NULL);
-	RETPTR(memregion);
-
+	if (!mapit(memregion)) {
+		rc = NULL;
+		goto Away;
+	}
+	rc = memregion;
 Away:
 	if (rc == NULL) {
 		if (memregion != NULL) {
diff --git a/drivers/staging/unisys/visorutil/procobjecttree.c b/drivers/staging/unisys/visorutil/procobjecttree.c
index 1da9958a08c6..6a082b952066 100644
--- a/drivers/staging/unisys/visorutil/procobjecttree.c
+++ b/drivers/staging/unisys/visorutil/procobjecttree.c
@@ -162,12 +162,14 @@ MYPROCTYPE *visor_proc_CreateType(struct proc_dir_entry *procDirRoot,
 	parent = procDirRoot;
 	for (i = 0; i < type->nNames; i++) {
 		type->procDirs[i] = createProcDir(type->name[i], parent);
-		if (type->procDirs[i] == NULL)
-			RETPTR(NULL);
+		if (type->procDirs[i] == NULL) {
+			rc = NULL;
+			goto Away;
+		}
 		parent = type->procDirs[i];
 	}
 	type->procDir = type->procDirs[type->nNames-1];
-	RETPTR(type);
+	rc = type;
 Away:
 	if (rc == NULL) {
 		if (type != NULL) {
@@ -232,8 +234,10 @@ MYPROCOBJECT *visor_proc_CreateObject(MYPROCTYPE *type,
 		}
 		strcpy(obj->name, name);
 		obj->procDir = createProcDir(obj->name, type->procDir);
-		if (obj->procDir == NULL)
-			RETPTR(NULL);
+		if (obj->procDir == NULL) {
+			rc = NULL;
+			goto Away;
+		}
 	}
 	obj->procDirPropertyContexts =
 		kzalloc((type->nProperties + 1) * sizeof(PROCDIRENTRYCONTEXT),
@@ -256,11 +260,13 @@ MYPROCOBJECT *visor_proc_CreateObject(MYPROCTYPE *type,
 				createProcFile(type->propertyNames[i],
 					       obj->procDir, &proc_fops,
 					       &obj->procDirPropertyContexts[i]);
-			if (obj->procDirProperties[i] == NULL)
-				RETPTR(NULL);
+			if (obj->procDirProperties[i] == NULL) {
+				rc = NULL;
+				goto Away;
+			}
 		}
 	}
-	RETPTR(obj);
+	rc = obj;
 Away:
 	if (rc == NULL) {
 		if (obj != NULL) {
diff --git a/drivers/staging/unisys/visorutil/visorkmodutils.c b/drivers/staging/unisys/visorutil/visorkmodutils.c
index ef064692e2fe..a7d1e94ca3c3 100644
--- a/drivers/staging/unisys/visorutil/visorkmodutils.c
+++ b/drivers/staging/unisys/visorutil/visorkmodutils.c
@@ -43,12 +43,14 @@ struct seq_file *visor_seq_file_new_buffer(void *buf, size_t buf_size)
 	struct seq_file *rc = NULL;
 	struct seq_file *m = kmalloc_kernel(sizeof(struct seq_file));
 
-	if (m == NULL)
-		RETPTR(NULL);
+	if (m == NULL) {
+		rc = NULL;
+		goto Away;
+	}
 	memset(m, 0, sizeof(struct seq_file));
 	m->buf = buf;
 	m->size = buf_size;
-	RETPTR(m);
+	rc = m;
 Away:
 	if (rc == NULL) {
 		visor_seq_file_done_buffer(m);

