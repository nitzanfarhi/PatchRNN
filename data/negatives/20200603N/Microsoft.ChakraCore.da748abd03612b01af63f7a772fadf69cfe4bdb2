commit da748abd03612b01af63f7a772fadf69cfe4bdb2
Author: Kunal Pathak <Kunal.Pathak@microsoft.com>
Date:   Tue Sep 13 10:49:58 2016 -0700

    CheckIfTypeIsEquivalent improvement
    
    * Bailout for EquivTypeCheck - Today we emit helper instead of bailout if type is not alive. This is bad for performance because we might never match equivalent type check and we will always go to helper instead of bailing out and rejitting the code.
    * Eviction - If we get a non-shared type and if cache is full, we will consider that there is no point in checking for equivalence and we would just go to slow path / helper for doing the operation. However if shared type comes and cache is full, we will first try to evict non-shared type before evicting shared types. Empty slots takes first priority over non-shared types in eviction.

diff --git a/lib/Backend/BackwardPass.cpp b/lib/Backend/BackwardPass.cpp
index f2feec895..61a649125 100644
--- a/lib/Backend/BackwardPass.cpp
+++ b/lib/Backend/BackwardPass.cpp
@@ -2107,6 +2107,13 @@ BackwardPass::DeadStoreTypeCheckBailOut(IR::Instr * instr)
         return;
     }
 
+    // If bailOutKind is equivTypeCheck then leave alone the bailout
+    if (bailOutKind == IR::BailOutFailedEquivalentTypeCheck ||
+        bailOutKind == IR::BailOutFailedEquivalentFixedFieldTypeCheck)
+    {
+        return;
+    }
+
     // We're not checking for polymorphism, so don't let the bailout indicate that we
     // detected polymorphism.
     instr->GetBailOutInfo()->polymorphicCacheIndex = (uint)-1;
diff --git a/lib/Backend/Lower.cpp b/lib/Backend/Lower.cpp
index c64fcc759..034dfbb96 100644
--- a/lib/Backend/Lower.cpp
+++ b/lib/Backend/Lower.cpp
@@ -6825,7 +6825,7 @@ Lowerer::GenerateStFldWithCachedType(IR::Instr *instrStFld, bool* continueAsHelp
 
     if (hasTypeCheckBailout)
     {
-        AssertMsg(PHASE_ON1(Js::ObjTypeSpecIsolatedFldOpsWithBailOutPhase) || !propertySymOpnd->IsTypeDead(),
+        AssertMsg(PHASE_ON1(Js::ObjTypeSpecIsolatedFldOpsWithBailOutPhase) || !propertySymOpnd->IsTypeDead(), 
             "Why does a field store have a type check bailout, if its type is dead?");
 
         if (instrStFld->GetBailOutInfo()->bailOutInstr != instrStFld)
diff --git a/lib/Runtime/Language/JavascriptOperators.cpp b/lib/Runtime/Language/JavascriptOperators.cpp
index a0f7483ea..d59cd3644 100644
--- a/lib/Runtime/Language/JavascriptOperators.cpp
+++ b/lib/Runtime/Language/JavascriptOperators.cpp
@@ -8243,6 +8243,19 @@ namespace Js
             return true;
         }
 
+        // Since the equivTypes cache is always compacted, if last entry is non-nullptr, it means the cache is full.
+        DynamicType * dynamicType = (type && DynamicType::Is(type->GetTypeId())) ? static_cast<DynamicType*>(type) : nullptr;
+        bool isEquivTypesCacheFull = equivTypes[EQUIVALENT_TYPE_CACHE_SIZE - 1] != nullptr;
+        if (dynamicType != nullptr)
+        {
+            if (!dynamicType->GetIsShared() && isEquivTypesCacheFull)
+            {
+                // If this is non-shared type and we don't have space to cache it, just consider
+                // it as non-equivalent so we will eventually bailout
+                return false;
+            }
+        }
+
         // If we didn't find the type in the cache, let's check if it's equivalent the slow way, by comparing
         // each of its relevant property slots to its equivalent in one of the cached types.
         // We are making a few assumption that simplify the process:
@@ -8266,6 +8279,7 @@ namespace Js
             return false;
         }
 
+#pragma prefast(suppress:6011) // If type is nullptr, we would AV at the beginning of this method
         if (type->GetTypeId() != refType->GetTypeId())
         {
             if (PHASE_TRACE1(Js::EquivObjTypeSpecPhase))
@@ -8290,9 +8304,9 @@ namespace Js
 
         bool isEquivalent;
         uint failedPropertyIndex;
-        if (DynamicType::Is(type->GetTypeId()))
+        if (dynamicType != nullptr)
         {
-            Js::DynamicTypeHandler* typeHandler = (static_cast<DynamicType*>(type))->GetTypeHandler();
+            Js::DynamicTypeHandler* typeHandler = dynamicType->GetTypeHandler();
             isEquivalent = typeHandler->IsObjTypeSpecEquivalent(type, cache->record, failedPropertyIndex);
         }
         else
@@ -8311,6 +8325,7 @@ namespace Js
         }
 
         int emptySlotIndex = -1;
+        int nonSharedTypeSlotIndex = -1;
         for (int i = 0;i < EQUIVALENT_TYPE_CACHE_SIZE;i++)
         {
             if (equivTypes[i] == nullptr)
@@ -8318,8 +8333,23 @@ namespace Js
                 emptySlotIndex = i;
                 break;
             };
+
+            // If equivTypes cache is full, also look for
+            // non-shared type to evict
+            if (isEquivTypesCacheFull &&
+                DynamicType::Is(equivTypes[i]->GetTypeId()) &&
+                !(static_cast<DynamicType*>(equivTypes[i]))->GetIsShared())
+            {
+                nonSharedTypeSlotIndex = i;
+            }
         }
 
+        AssertMsg(!isEquivTypesCacheFull || !dynamicType || dynamicType->GetIsShared(), "If equiv cache is full, then this should be sharedType.");
+        
+        // If cache is full, then this is definitely a sharedType, so evict non-shared type.
+        // Else evict next empty slot (only applicable for DynamicTypes)
+        emptySlotIndex = (isEquivTypesCacheFull && dynamicType) ? nonSharedTypeSlotIndex : emptySlotIndex;
+
         // We have some empty slots, let us use those first
         if (emptySlotIndex != -1)
         {
@@ -8364,9 +8394,8 @@ namespace Js
         // valid if we lock the type. Otherwise, the type ID may change out from under us without
         // evolving the type.
         // We also need to lock the type in case of, for instance, adding a property to a dictionary type handler.
-        if (DynamicType::Is(type->GetTypeId()))
+        if (dynamicType != nullptr)
         {
-            DynamicType *dynamicType = static_cast<DynamicType*>(type);
             if (!dynamicType->GetIsLocked())
             {
                 dynamicType->LockType();

