commit 4a865905f685eaefaedf6ade362323dc52aa703b
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Mar 16 22:40:36 2009 +0100

    PCI PM: Make pci_set_power_state() handle devices with no PM support
    
    There is a problem with PCI devices without any PM support (either
    native or through the platform) that pci_set_power_state() always
    returns error code for them, even if they are being put into D0.
    However, such devices are always in D0, so pci_set_power_state()
    should return success when attempting to put such a device into D0.
    It also should update the current_state field for these devices as
    appropriate.  This modification is necessary so that the standard
    configuration registers of these devices are successfully restored by
    pci_restore_standard_config() during the "early" phase of resume.
    
    In addition, pci_set_power_state() should check the value of
    current_state before calling the platform to change the power state
    of the device to avoid doing that unnecessarily.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index a4ecc2f15126..979ceb1d37e8 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -439,6 +439,10 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 	u16 pmcsr;
 	bool need_restore = false;
 
+	/* Check if we're already there */
+	if (dev->current_state == state)
+		return 0;
+
 	if (!dev->pm_cap)
 		return -EIO;
 
@@ -449,10 +453,7 @@ static int pci_raw_set_power_state(struct pci_dev *dev, pci_power_t state)
 	 * Can enter D0 from any state, but if we can only go deeper 
 	 * to sleep if we're already in a low power state
 	 */
-	if (dev->current_state == state) {
-		/* we're already there */
-		return 0;
-	} else if (state != PCI_D0 && dev->current_state <= PCI_D3cold
+	if (state != PCI_D0 && dev->current_state <= PCI_D3cold
 	    && dev->current_state > state) {
 		dev_err(&dev->dev, "invalid power transition "
 			"(from state %d to %d)\n", dev->current_state, state);
@@ -570,12 +571,17 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		 */
 		return 0;
 
-	if (state == PCI_D0 && platform_pci_power_manageable(dev)) {
+	/* Check if we're already there */
+	if (dev->current_state == state)
+		return 0;
+
+	if (state == PCI_D0) {
 		/*
 		 * Allow the platform to change the state, for example via ACPI
 		 * _PR0, _PS0 and some such, but do not trust it.
 		 */
-		int ret = platform_pci_set_power_state(dev, PCI_D0);
+		int ret = platform_pci_power_manageable(dev) ?
+			platform_pci_set_power_state(dev, PCI_D0) : 0;
 		if (!ret)
 			pci_update_current_state(dev, PCI_D0);
 	}

