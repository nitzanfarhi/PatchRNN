commit 0d27bc0f8763cb6dd6307dbab7713058dee18b2c
Author: lloyd <lloyd@randombit.net>
Date:   Tue Nov 17 05:03:06 2009 +0000

    Rename/remove some secmem member variables for better matching with STL
    containers (specifically vector).
    
    Rename is_empty to empty
    Remove has_items
    Rename create to resize

diff --git a/checks/block.cpp b/checks/block.cpp
index 1e7de3726..8f07cd65c 100644
--- a/checks/block.cpp
+++ b/checks/block.cpp
@@ -30,7 +30,7 @@ class ECB_Encryption_ErrorCheck : public Filter
          cipher = get_block_cipher(cipher_name);
          input_hash = get_hash(HASH);
          decrypt_hash = get_hash(HASH);
-         buffer.create(BLOCKSIZE);
+         buffer.resize(BLOCKSIZE);
          cipher->set_key(key);
          position = 0;
          }
diff --git a/checks/pk_bench.cpp b/checks/pk_bench.cpp
index 9a94d8474..31c48c1da 100644
--- a/checks/pk_bench.cpp
+++ b/checks/pk_bench.cpp
@@ -81,7 +81,7 @@ void benchmark_enc_dec(PK_Encryptor& enc, PK_Decryptor& dec,
       {
       if(enc_timer.seconds() < seconds || ciphertext.size() == 0)
          {
-         plaintext.create(enc.maximum_input_size());
+         plaintext.resize(enc.maximum_input_size());
 
          // Ensure for Raw, etc, it stays large
          if((i % 100) == 0)
@@ -122,7 +122,7 @@ void benchmark_sig_ver(PK_Verifier& ver, PK_Signer& sig,
          {
          if((i % 100) == 0)
             {
-            message.create(48);
+            message.resize(48);
             rng.randomize(message.begin(), message.size());
             }
 
@@ -142,7 +142,7 @@ void benchmark_sig_ver(PK_Verifier& ver, PK_Signer& sig,
 
          if((i % 100) == 0)
             {
-            sig_random.create(signature.size());
+            sig_random.resize(signature.size());
             rng.randomize(sig_random, sig_random.size());
 
             verify_timer.start();
diff --git a/src/alloc/secmem.h b/src/alloc/secmem.h
index d2c46a2e5..fd08c6198 100644
--- a/src/alloc/secmem.h
+++ b/src/alloc/secmem.h
@@ -32,13 +32,7 @@ class MemoryRegion
       * Find out whether this buffer is empty.
       * @return true if the buffer is empty, false otherwise
       */
-      bool is_empty() const { return (used == 0); }
-
-      /**
-      * Find out whether this buffer is non-empty
-      * @return true if the buffer is non-empty, false otherwise
-      */
-      bool has_items() const { return (used != 0); }
+      bool empty() const { return (used == 0); }
 
       /**
       * Get a pointer to the first element in the buffer.
@@ -97,8 +91,8 @@ class MemoryRegion
       * @return false if the content of both buffers is byte-wise equal, true
       * otherwise.
       */
-      bool operator!=(const MemoryRegion<T>& in) const
-         { return (!(*this == in)); }
+      bool operator!=(const MemoryRegion<T>& other) const
+         { return (!(*this == other)); }
 
       /**
       * Copy the contents of another buffer into this buffer.
@@ -137,7 +131,7 @@ class MemoryRegion
       * @param in the array of objects of type T to copy the contents from
       * @param n the size of array in
       */
-      void set(const T in[], u32bit n)    { create(n); copy(in, n); }
+      void set(const T in[], u32bit n)    { resize(n); copy(in, n); }
 
       /**
       * Set the contents of this according to the argument. The size of
@@ -164,7 +158,8 @@ class MemoryRegion
       * Append data to the end of this buffer.
       * @param data the buffer containing the data to append
       */
-      void append(const MemoryRegion<T>& x) { append(x.begin(), x.size()); }
+      void append(const MemoryRegion<T>& other)
+         { append(other.begin(), other.size()); }
 
       /**
       * Zeroise the bytes of this buffer. The length remains unchanged.
@@ -174,14 +169,14 @@ class MemoryRegion
       /**
       * Reset this buffer to an empty buffer with size zero.
       */
-      void destroy() { create(0); }
+      void destroy() { resize(0); }
 
       /**
       * Reset this buffer to a buffer of specified length. The content will be
       * initialized to zero bytes.
       * @param n the new length of the buffer
       */
-      void create(u32bit n);
+      void resize(u32bit n);
 
       /**
       * Preallocate memory, so that this buffer can grow up to size n without
@@ -207,7 +202,7 @@ class MemoryRegion
          }
 
       void init(bool locking, u32bit length = 0)
-         { alloc = Allocator::get(locking); create(length); }
+         { alloc = Allocator::get(locking); resize(length); }
    private:
       T* allocate(u32bit n)
          {
@@ -227,7 +222,7 @@ class MemoryRegion
 * Create a new buffer
 */
 template<typename T>
-void MemoryRegion<T>::create(u32bit n)
+void MemoryRegion<T>::resize(u32bit n)
    {
    if(n <= allocated) { clear(); used = n; return; }
    deallocate(buf, allocated);
@@ -261,15 +256,15 @@ void MemoryRegion<T>::grow_to(u32bit n)
 * Compare this buffer with another one
 */
 template<typename T>
-bool MemoryRegion<T>::operator<(const MemoryRegion<T>& in) const
+bool MemoryRegion<T>::operator<(const MemoryRegion<T>& other) const
    {
-   if(size() < in.size()) return true;
-   if(size() > in.size()) return false;
+   if(size() < other.size()) return true;
+   if(size() > other.size()) return false;
 
    for(u32bit j = 0; j != size(); j++)
       {
-      if(buf[j] < in[j]) return true;
-      if(buf[j] > in[j]) return false;
+      if(buf[j] < other[j]) return true;
+      if(buf[j] > other[j]) return false;
       }
 
    return false;
@@ -306,7 +301,6 @@ class MemoryVector : public MemoryRegion<T>
       /**
       * Create a buffer of the specified length.
       * @param n the length of the buffer to create.
-
       */
       MemoryVector(u32bit n = 0) { MemoryRegion<T>::init(false, n); }
 
@@ -358,7 +352,6 @@ class SecureVector : public MemoryRegion<T>
       /**
       * Create a buffer of the specified length.
       * @param n the length of the buffer to create.
-
       */
       SecureVector(u32bit n = 0) { MemoryRegion<T>::init(true, n); }
 
diff --git a/src/asn1/asn1_dn.cpp b/src/asn1/asn1_dn.cpp
index c5a132d85..3005e3d5e 100644
--- a/src/asn1/asn1_dn.cpp
+++ b/src/asn1/asn1_dn.cpp
@@ -271,7 +271,7 @@ void X509_DN::encode_into(DER_Encoder& der) const
 
    der.start_cons(SEQUENCE);
 
-   if(dn_bits.has_items())
+   if(!dn_bits.empty())
       der.raw_bytes(dn_bits);
    else
       {
diff --git a/src/asn1/ber_dec.cpp b/src/asn1/ber_dec.cpp
index ce6046652..b34bf8ca2 100644
--- a/src/asn1/ber_dec.cpp
+++ b/src/asn1/ber_dec.cpp
@@ -205,7 +205,7 @@ BER_Object BER_Decoder::get_next_object()
       return next;
 
    u32bit length = decode_length(source);
-   next.value.create(length);
+   next.value.resize(length);
    if(source->read(next.value, length) != length)
       throw BER_Decoding_Error("Value truncated");
 
@@ -392,7 +392,7 @@ BER_Decoder& BER_Decoder::decode(BigInt& out,
    BER_Object obj = get_next_object();
    obj.assert_is_a(type_tag, class_tag);
 
-   if(obj.value.is_empty())
+   if(obj.value.empty())
       out = 0;
    else
       {
diff --git a/src/block/lion/lion.cpp b/src/block/lion/lion.cpp
index e71091258..d8822b9f2 100644
--- a/src/block/lion/lion.cpp
+++ b/src/block/lion/lion.cpp
@@ -119,8 +119,8 @@ Lion::Lion(HashFunction* hash_in, StreamCipher* sc_in, u32bit block_len) :
    if(!cipher->valid_keylength(LEFT_SIZE))
       throw Exception(name() + ": This stream/hash combination is invalid");
 
-   key1.create(LEFT_SIZE);
-   key2.create(LEFT_SIZE);
+   key1.resize(LEFT_SIZE);
+   key2.resize(LEFT_SIZE);
    }
 
 }
diff --git a/src/block/rc5/rc5.cpp b/src/block/rc5/rc5.cpp
index 4bfa27ea0..0bd596b10 100644
--- a/src/block/rc5/rc5.cpp
+++ b/src/block/rc5/rc5.cpp
@@ -109,7 +109,7 @@ RC5::RC5(u32bit r) : BlockCipher(8, 1, 32), ROUNDS(r)
    {
    if(ROUNDS < 8 || ROUNDS > 32 || (ROUNDS % 4 != 0))
       throw Invalid_Argument(name() + ": Invalid number of rounds");
-   S.create(2*ROUNDS + 2);
+   S.resize(2*ROUNDS + 2);
    }
 
 }
diff --git a/src/cms/cms_enc.cpp b/src/cms/cms_enc.cpp
index 2413676d7..3437c15e3 100644
--- a/src/cms/cms_enc.cpp
+++ b/src/cms/cms_enc.cpp
@@ -17,7 +17,7 @@ namespace Botan {
 */
 void CMS_Encoder::set_data(const byte buf[], u32bit length)
    {
-   if(data.has_items())
+   if(!data.empty())
       throw Invalid_State("Cannot call CMS_Encoder::set_data here");
 
    data.set(buf, length);
diff --git a/src/codec/base64/base64.cpp b/src/codec/base64/base64.cpp
index dfcc1cae7..9110dc57e 100644
--- a/src/codec/base64/base64.cpp
+++ b/src/codec/base64/base64.cpp
@@ -18,8 +18,8 @@ namespace Botan {
 Base64_Encoder::Base64_Encoder(bool breaks, u32bit length, bool t_n) :
    line_length(breaks ? length : 0), trailing_newline(t_n)
    {
-   in.create(48);
-   out.create(4);
+   in.resize(48);
+   out.resize(4);
 
    counter = position = 0;
    }
@@ -132,8 +132,8 @@ void Base64_Encoder::end_msg()
 */
 Base64_Decoder::Base64_Decoder(Decoder_Checking c) : checking(c)
    {
-   in.create(48);
-   out.create(3);
+   in.resize(48);
+   out.resize(3);
    position = 0;
    }
 
diff --git a/src/codec/hex/hex.cpp b/src/codec/hex/hex.cpp
index 201c9bfdf..651899b73 100644
--- a/src/codec/hex/hex.cpp
+++ b/src/codec/hex/hex.cpp
@@ -21,8 +21,8 @@ const u32bit HEX_CODEC_BUFFER_SIZE = 256;
 Hex_Encoder::Hex_Encoder(bool breaks, u32bit length, Case c) :
    casing(c), line_length(breaks ? length : 0)
    {
-   in.create(HEX_CODEC_BUFFER_SIZE);
-   out.create(2*in.size());
+   in.resize(HEX_CODEC_BUFFER_SIZE);
+   out.resize(2*in.size());
    counter = position = 0;
    }
 
@@ -31,8 +31,8 @@ Hex_Encoder::Hex_Encoder(bool breaks, u32bit length, Case c) :
 */
 Hex_Encoder::Hex_Encoder(Case c) : casing(c), line_length(0)
    {
-   in.create(HEX_CODEC_BUFFER_SIZE);
-   out.create(2*in.size());
+   in.resize(HEX_CODEC_BUFFER_SIZE);
+   out.resize(2*in.size());
    counter = position = 0;
    }
 
@@ -116,8 +116,8 @@ void Hex_Encoder::end_msg()
 */
 Hex_Decoder::Hex_Decoder(Decoder_Checking c) : checking(c)
    {
-   in.create(HEX_CODEC_BUFFER_SIZE);
-   out.create(in.size() / 2);
+   in.resize(HEX_CODEC_BUFFER_SIZE);
+   out.resize(in.size() / 2);
    position = 0;
    }
 
diff --git a/src/entropy/entropy_src.h b/src/entropy/entropy_src.h
index a1a53fafb..be1a16636 100644
--- a/src/entropy/entropy_src.h
+++ b/src/entropy/entropy_src.h
@@ -29,7 +29,7 @@ class Entropy_Accumulator
       @return cached I/O buffer for repeated polls
       */
       MemoryRegion<byte>& get_io_buffer(u32bit size)
-         { io_buffer.create(size); return io_buffer; }
+         { io_buffer.resize(size); return io_buffer; }
 
       u32bit bits_collected() const
          { return static_cast<u32bit>(collected_bits); }
diff --git a/src/filters/buf_filt.cpp b/src/filters/buf_filt.cpp
index 53352b54a..0509e76e2 100644
--- a/src/filters/buf_filt.cpp
+++ b/src/filters/buf_filt.cpp
@@ -18,8 +18,8 @@ Buffering_Filter::Buffering_Filter(u32bit b, u32bit i) : INITIAL_BLOCK_SIZE(i),
                                                          BLOCK_SIZE(b)
    {
    initial_block_pos = block_pos = 0;
-   initial.create(INITIAL_BLOCK_SIZE);
-   block.create(BLOCK_SIZE);
+   initial.resize(INITIAL_BLOCK_SIZE);
+   block.resize(BLOCK_SIZE);
    }
 
 /*
diff --git a/src/filters/filter.cpp b/src/filters/filter.cpp
index 4bf0ef912..ff223ae8c 100644
--- a/src/filters/filter.cpp
+++ b/src/filters/filter.cpp
@@ -31,14 +31,15 @@ void Filter::send(const byte input[], u32bit length)
    for(u32bit j = 0; j != total_ports(); ++j)
       if(next[j])
          {
-         if(write_queue.has_items())
+         if(write_queue.size())
             next[j]->write(write_queue, write_queue.size());
          next[j]->write(input, length);
          nothing_attached = false;
          }
+
    if(nothing_attached)
       write_queue.append(input, length);
-   else if(write_queue.has_items())
+   else
       write_queue.destroy();
    }
 
diff --git a/src/mac/cmac/cmac.cpp b/src/mac/cmac/cmac.cpp
index 58923138b..b689a4d3a 100644
--- a/src/mac/cmac/cmac.cpp
+++ b/src/mac/cmac/cmac.cpp
@@ -144,10 +144,10 @@ CMAC::CMAC(BlockCipher* e_in) :
    else
       throw Invalid_Argument("CMAC cannot use the cipher " + e->name());
 
-   state.create(OUTPUT_LENGTH);
-   buffer.create(OUTPUT_LENGTH);
-   B.create(OUTPUT_LENGTH);
-   P.create(OUTPUT_LENGTH);
+   state.resize(OUTPUT_LENGTH);
+   buffer.resize(OUTPUT_LENGTH);
+   B.resize(OUTPUT_LENGTH);
+   P.resize(OUTPUT_LENGTH);
    position = 0;
    }
 
diff --git a/src/mac/hmac/hmac.cpp b/src/mac/hmac/hmac.cpp
index 99be479fa..dcd6bce5d 100644
--- a/src/mac/hmac/hmac.cpp
+++ b/src/mac/hmac/hmac.cpp
@@ -92,8 +92,8 @@ HMAC::HMAC(HashFunction* hash_in) :
    if(hash->HASH_BLOCK_SIZE == 0)
       throw Invalid_Argument("HMAC cannot be used with " + hash->name());
 
-   i_key.create(hash->HASH_BLOCK_SIZE);
-   o_key.create(hash->HASH_BLOCK_SIZE);
+   i_key.resize(hash->HASH_BLOCK_SIZE);
+   o_key.resize(hash->HASH_BLOCK_SIZE);
    }
 
 }
diff --git a/src/mac/ssl3mac/ssl3_mac.cpp b/src/mac/ssl3mac/ssl3_mac.cpp
index 23a636424..a4c0c635e 100644
--- a/src/mac/ssl3mac/ssl3_mac.cpp
+++ b/src/mac/ssl3mac/ssl3_mac.cpp
@@ -83,8 +83,8 @@ SSL3_MAC::SSL3_MAC(HashFunction* hash_in) :
    u32bit INNER_HASH_LENGTH =
       (hash->name() == "SHA-160") ? 60 : hash->HASH_BLOCK_SIZE;
 
-   i_key.create(INNER_HASH_LENGTH);
-   o_key.create(INNER_HASH_LENGTH);
+   i_key.resize(INNER_HASH_LENGTH);
+   o_key.resize(INNER_HASH_LENGTH);
    }
 
 }
diff --git a/src/math/bigint/bigint.cpp b/src/math/bigint/bigint.cpp
index 63bdc3605..7592ec439 100644
--- a/src/math/bigint/bigint.cpp
+++ b/src/math/bigint/bigint.cpp
@@ -25,7 +25,7 @@ BigInt::BigInt(u64bit n)
 
    const u32bit limbs_needed = sizeof(u64bit) / sizeof(word);
 
-   reg.create(4*limbs_needed);
+   reg.resize(4*limbs_needed);
    for(u32bit j = 0; j != limbs_needed; ++j)
       reg[j] = ((n >> (j*MP_WORD_BITS)) & MP_WORD_MASK);
    }
@@ -35,7 +35,7 @@ BigInt::BigInt(u64bit n)
 */
 BigInt::BigInt(Sign s, u32bit size)
    {
-   reg.create(round_up(size, 8));
+   reg.resize(round_up(size, 8));
    signedness = s;
    }
 
@@ -48,13 +48,13 @@ BigInt::BigInt(const BigInt& b)
 
    if(b_words)
       {
-      reg.create(round_up(b_words, 8));
+      reg.resize(round_up(b_words, 8));
       reg.copy(b.data(), b_words);
       set_sign(b.sign());
       }
    else
       {
-      reg.create(2);
+      reg.resize(2);
       set_sign(Positive);
       }
    }
@@ -346,7 +346,7 @@ void BigInt::binary_decode(const byte buf[], u32bit length)
    {
    const u32bit WORD_BYTES = sizeof(word);
 
-   reg.create(round_up((length / WORD_BYTES) + 1, 8));
+   reg.resize(round_up((length / WORD_BYTES) + 1, 8));
 
    for(u32bit j = 0; j != length / WORD_BYTES; ++j)
       {
diff --git a/src/math/bigint/divide.cpp b/src/math/bigint/divide.cpp
index 6afaa0fee..45d31350d 100644
--- a/src/math/bigint/divide.cpp
+++ b/src/math/bigint/divide.cpp
@@ -62,7 +62,7 @@ void divide(const BigInt& x, const BigInt& y_arg, BigInt& q, BigInt& r)
 
       const u32bit n = r.sig_words() - 1, t = y_words - 1;
 
-      q.get_reg().create(n - t + 1);
+      q.get_reg().resize(n - t + 1);
       if(n <= t)
          {
          while(r > y) { r -= y; ++q; }
diff --git a/src/modes/cbc/cbc.cpp b/src/modes/cbc/cbc.cpp
index f26d4d6cf..fb7ae8f90 100644
--- a/src/modes/cbc/cbc.cpp
+++ b/src/modes/cbc/cbc.cpp
@@ -90,7 +90,7 @@ CBC_Decryption::CBC_Decryption(BlockCipher* ciph,
    {
    if(!padder->valid_blocksize(BLOCK_SIZE))
       throw Invalid_Block_Size(name(), padder->name());
-   temp.create(BLOCK_SIZE);
+   temp.resize(BLOCK_SIZE);
    }
 
 /*
@@ -105,7 +105,7 @@ CBC_Decryption::CBC_Decryption(BlockCipher* ciph,
    {
    if(!padder->valid_blocksize(BLOCK_SIZE))
       throw Invalid_Block_Size(name(), padder->name());
-   temp.create(BLOCK_SIZE);
+   temp.resize(BLOCK_SIZE);
    set_key(key);
    set_iv(iv);
    }
diff --git a/src/modes/cts/cts.h b/src/modes/cts/cts.h
index 9b17203f3..1a2cae44e 100644
--- a/src/modes/cts/cts.h
+++ b/src/modes/cts/cts.h
@@ -41,13 +41,13 @@ class BOTAN_DLL CTS_Decryption : public BlockCipherMode
    public:
       CTS_Decryption(BlockCipher* ciph) :
          BlockCipherMode(ciph, "CTS", ciph->BLOCK_SIZE, 0, 2)
-         { temp.create(BLOCK_SIZE); }
+         { temp.resize(BLOCK_SIZE); }
 
       CTS_Decryption(BlockCipher* ciph,
                      const SymmetricKey& key,
                      const InitializationVector& iv) :
          BlockCipherMode(ciph, "CTS", ciph->BLOCK_SIZE, 0, 2)
-         { set_key(key); set_iv(iv); temp.create(BLOCK_SIZE); }
+         { set_key(key); set_iv(iv); temp.resize(BLOCK_SIZE); }
    private:
       void write(const byte[], u32bit);
       void end_msg();
diff --git a/src/modes/eax/eax.cpp b/src/modes/eax/eax.cpp
index 67465a776..e2ef178b6 100644
--- a/src/modes/eax/eax.cpp
+++ b/src/modes/eax/eax.cpp
@@ -45,8 +45,8 @@ EAX_Base::EAX_Base(BlockCipher* ciph,
    if(tag_size % 8 != 0 || TAG_SIZE == 0 || TAG_SIZE > mac->OUTPUT_LENGTH)
       throw Invalid_Argument(name() + ": Bad tag size " + to_string(tag_size));
 
-   state.create(BLOCK_SIZE);
-   buffer.create(BLOCK_SIZE);
+   state.resize(BLOCK_SIZE);
+   buffer.resize(BLOCK_SIZE);
    position = 0;
    }
 
diff --git a/src/modes/eax/eax_dec.cpp b/src/modes/eax/eax_dec.cpp
index b7e5795f7..f395ce437 100644
--- a/src/modes/eax/eax_dec.cpp
+++ b/src/modes/eax/eax_dec.cpp
@@ -19,7 +19,7 @@ EAX_Decryption::EAX_Decryption(BlockCipher* ciph,
                                u32bit tag_size) :
    EAX_Base(ciph, tag_size)
    {
-   queue.create(2*TAG_SIZE + DEFAULT_BUFFERSIZE);
+   queue.resize(2*TAG_SIZE + DEFAULT_BUFFERSIZE);
    queue_start = queue_end = 0;
    }
 
@@ -34,7 +34,7 @@ EAX_Decryption::EAX_Decryption(BlockCipher* ciph,
    {
    set_key(key);
    set_iv(iv);
-   queue.create(2*TAG_SIZE + DEFAULT_BUFFERSIZE);
+   queue.resize(2*TAG_SIZE + DEFAULT_BUFFERSIZE);
    queue_start = queue_end = 0;
    }
 
diff --git a/src/modes/ecb/ecb.cpp b/src/modes/ecb/ecb.cpp
index 988a8b3f2..bff6d70f4 100644
--- a/src/modes/ecb/ecb.cpp
+++ b/src/modes/ecb/ecb.cpp
@@ -24,8 +24,8 @@ ECB_Encryption::ECB_Encryption(BlockCipher* ciph,
    cipher = ciph;
    padder = pad;
 
-   plaintext.create(cipher->BLOCK_SIZE);
-   ciphertext.create(cipher->BLOCK_SIZE * PARALLEL_BLOCKS);
+   plaintext.resize(cipher->BLOCK_SIZE);
+   ciphertext.resize(cipher->BLOCK_SIZE * PARALLEL_BLOCKS);
 
    position = 0;
    }
@@ -40,8 +40,8 @@ ECB_Encryption::ECB_Encryption(BlockCipher* ciph,
    cipher = ciph;
    padder = pad;
 
-   plaintext.create(cipher->BLOCK_SIZE);
-   ciphertext.create(cipher->BLOCK_SIZE * PARALLEL_BLOCKS);
+   plaintext.resize(cipher->BLOCK_SIZE);
+   ciphertext.resize(cipher->BLOCK_SIZE * PARALLEL_BLOCKS);
 
    position = 0;
 
@@ -124,8 +124,8 @@ ECB_Decryption::ECB_Decryption(BlockCipher* ciph,
    cipher = ciph;
    padder = pad;
 
-   ciphertext.create(cipher->BLOCK_SIZE);
-   plaintext.create(cipher->BLOCK_SIZE * PARALLEL_BLOCKS);
+   ciphertext.resize(cipher->BLOCK_SIZE);
+   plaintext.resize(cipher->BLOCK_SIZE * PARALLEL_BLOCKS);
 
    position = 0;
    }
@@ -140,8 +140,8 @@ ECB_Decryption::ECB_Decryption(BlockCipher* ciph,
    cipher = ciph;
    padder = pad;
 
-   ciphertext.create(cipher->BLOCK_SIZE);
-   plaintext.create(cipher->BLOCK_SIZE * PARALLEL_BLOCKS);
+   ciphertext.resize(cipher->BLOCK_SIZE);
+   plaintext.resize(cipher->BLOCK_SIZE * PARALLEL_BLOCKS);
 
    position = 0;
 
diff --git a/src/modes/modebase.cpp b/src/modes/modebase.cpp
index b048862a4..59ee55a8a 100644
--- a/src/modes/modebase.cpp
+++ b/src/modes/modebase.cpp
@@ -20,8 +20,8 @@ BlockCipherMode::BlockCipherMode(BlockCipher* cipher_ptr,
    IV_METHOD(iv_meth), mode_name(cipher_mode_name)
    {
    cipher = cipher_ptr;
-   buffer.create(BUFFER_SIZE);
-   state.create(iv_size);
+   buffer.resize(BUFFER_SIZE);
+   state.resize(iv_size);
    position = 0;
    }
 
diff --git a/src/modes/xts/xts.cpp b/src/modes/xts/xts.cpp
index 8780ae166..586cc92af 100644
--- a/src/modes/xts/xts.cpp
+++ b/src/modes/xts/xts.cpp
@@ -41,8 +41,8 @@ XTS_Encryption::XTS_Encryption(BlockCipher* ciph) : cipher(ciph)
       throw std::invalid_argument("Bad cipher for XTS: " + cipher->name());
 
    cipher2 = cipher->clone();
-   tweak.create(cipher->BLOCK_SIZE);
-   buffer.create(2 * cipher->BLOCK_SIZE);
+   tweak.resize(cipher->BLOCK_SIZE);
+   buffer.resize(2 * cipher->BLOCK_SIZE);
    position = 0;
    }
 
@@ -57,8 +57,8 @@ XTS_Encryption::XTS_Encryption(BlockCipher* ciph,
       throw std::invalid_argument("Bad cipher for XTS: " + cipher->name());
 
    cipher2 = cipher->clone();
-   tweak.create(cipher->BLOCK_SIZE);
-   buffer.create(2 * cipher->BLOCK_SIZE);
+   tweak.resize(cipher->BLOCK_SIZE);
+   buffer.resize(2 * cipher->BLOCK_SIZE);
    position = 0;
 
    set_key(key);
@@ -197,8 +197,8 @@ XTS_Decryption::XTS_Decryption(BlockCipher* ciph)
    {
    cipher = ciph;
    cipher2 = ciph->clone();
-   tweak.create(cipher->BLOCK_SIZE);
-   buffer.create(2 * cipher->BLOCK_SIZE);
+   tweak.resize(cipher->BLOCK_SIZE);
+   buffer.resize(2 * cipher->BLOCK_SIZE);
    position = 0;
    }
 
@@ -211,8 +211,8 @@ XTS_Decryption::XTS_Decryption(BlockCipher* ciph,
    {
    cipher = ciph;
    cipher2 = ciph->clone();
-   tweak.create(cipher->BLOCK_SIZE);
-   buffer.create(2 * cipher->BLOCK_SIZE);
+   tweak.resize(cipher->BLOCK_SIZE);
+   buffer.resize(2 * cipher->BLOCK_SIZE);
    position = 0;
 
    set_key(key);
diff --git a/src/pbe/pbes1/pbes1.cpp b/src/pbe/pbes1/pbes1.cpp
index 21bd330ff..1d851d1a5 100644
--- a/src/pbe/pbes1/pbes1.cpp
+++ b/src/pbe/pbes1/pbes1.cpp
@@ -94,7 +94,7 @@ void PBE_PKCS5v15::set_key(const std::string& passphrase)
 void PBE_PKCS5v15::new_params(RandomNumberGenerator& rng)
    {
    iterations = 2048;
-   salt.create(8);
+   salt.resize(8);
    rng.randomize(salt, salt.size());
    }
 
diff --git a/src/pbe/pbes2/pbes2.cpp b/src/pbe/pbes2/pbes2.cpp
index b7e2589d0..bd24c449b 100644
--- a/src/pbe/pbes2/pbes2.cpp
+++ b/src/pbe/pbes2/pbes2.cpp
@@ -100,10 +100,10 @@ void PBE_PKCS5v20::new_params(RandomNumberGenerator& rng)
    iterations = 2048;
    key_length = block_cipher->MAXIMUM_KEYLENGTH;
 
-   salt.create(8);
+   salt.resize(8);
    rng.randomize(salt, salt.size());
 
-   iv.create(block_cipher->BLOCK_SIZE);
+   iv.resize(block_cipher->BLOCK_SIZE);
    rng.randomize(iv, iv.size());
    }
 
diff --git a/src/pubkey/dlies/dlies.cpp b/src/pubkey/dlies/dlies.cpp
index c441ed17c..0f5d76726 100644
--- a/src/pubkey/dlies/dlies.cpp
+++ b/src/pubkey/dlies/dlies.cpp
@@ -36,7 +36,7 @@ SecureVector<byte> DLIES_Encryptor::enc(const byte in[], u32bit length,
    {
    if(length > maximum_input_size())
       throw Invalid_Argument("DLIES: Plaintext too large");
-   if(other_key.is_empty())
+   if(other_key.empty())
       throw Invalid_State("DLIES: The other key was never set");
 
    MemoryVector<byte> v = key.public_value();
diff --git a/src/pubkey/pk_codecs/pkcs8.cpp b/src/pubkey/pk_codecs/pkcs8.cpp
index 8a464ecfe..3d73b7ab1 100644
--- a/src/pubkey/pk_codecs/pkcs8.cpp
+++ b/src/pubkey/pk_codecs/pkcs8.cpp
@@ -66,7 +66,7 @@ SecureVector<byte> PKCS8_decode(DataSource& source, const User_Interface& ui,
             throw PKCS8_Exception("Unknown PEM label " + label);
          }
 
-      if(key_data.is_empty())
+      if(key_data.empty())
          throw PKCS8_Exception("No key data found");
       }
    catch(Decoding_Error)
@@ -126,7 +126,7 @@ SecureVector<byte> PKCS8_decode(DataSource& source, const User_Interface& ui,
          }
       }
 
-   if(key.is_empty())
+   if(key.empty())
       throw Decoding_Error("PKCS #8 private key decoding failed");
    return key;
    }
diff --git a/src/pubkey/pk_codecs/x509_key.cpp b/src/pubkey/pk_codecs/x509_key.cpp
index 455e627f3..3fec15f7f 100644
--- a/src/pubkey/pk_codecs/x509_key.cpp
+++ b/src/pubkey/pk_codecs/x509_key.cpp
@@ -86,7 +86,7 @@ Public_Key* load_key(DataSource& source)
          .end_cons();
          }
 
-      if(key_bits.is_empty())
+      if(key_bits.empty())
          throw Decoding_Error("X.509 public key decoding failed");
 
       const std::string alg_name = OIDS::lookup(alg_id.oid);
diff --git a/src/pubkey/pk_filts.cpp b/src/pubkey/pk_filts.cpp
index 18da9c10b..d604436e0 100644
--- a/src/pubkey/pk_filts.cpp
+++ b/src/pubkey/pk_filts.cpp
@@ -72,7 +72,7 @@ void PK_Verifier_Filter::write(const byte input[], u32bit length)
 */
 void PK_Verifier_Filter::end_msg()
    {
-   if(signature.is_empty())
+   if(signature.empty())
       throw Exception("PK_Verifier_Filter: No signature to check against");
    bool is_valid = verifier->check_signature(signature, signature.size());
    send((is_valid ? 1 : 0));
diff --git a/src/rng/hmac_rng/hmac_rng.cpp b/src/rng/hmac_rng/hmac_rng.cpp
index 9d5ee97e4..26ada9047 100644
--- a/src/rng/hmac_rng/hmac_rng.cpp
+++ b/src/rng/hmac_rng/hmac_rng.cpp
@@ -172,7 +172,7 @@ HMAC_RNG::HMAC_RNG(MessageAuthenticationCode* extractor_mac,
    extractor(extractor_mac), prf(prf_mac)
    {
    // First PRF inputs are all zero, as specified in section 2
-   K.create(prf->OUTPUT_LENGTH);
+   K.resize(prf->OUTPUT_LENGTH);
    counter = 0;
    seeded = false;
 
diff --git a/src/rng/randpool/randpool.cpp b/src/rng/randpool/randpool.cpp
index 9ec92267d..fb51db300 100644
--- a/src/rng/randpool/randpool.cpp
+++ b/src/rng/randpool/randpool.cpp
@@ -192,9 +192,9 @@ Randpool::Randpool(BlockCipher* cipher_in,
                            cipher->name() + "/" + mac->name());
       }
 
-   buffer.create(BLOCK_SIZE);
-   pool.create(POOL_BLOCKS * BLOCK_SIZE);
-   counter.create(12);
+   buffer.resize(BLOCK_SIZE);
+   pool.resize(POOL_BLOCKS * BLOCK_SIZE);
+   counter.resize(12);
    seeded = false;
    }
 
diff --git a/src/rng/x931_rng/x931_rng.cpp b/src/rng/x931_rng/x931_rng.cpp
index 64d57ac1c..bd66d22bf 100644
--- a/src/rng/x931_rng/x931_rng.cpp
+++ b/src/rng/x931_rng/x931_rng.cpp
@@ -64,7 +64,7 @@ void ANSI_X931_RNG::rekey()
       cipher->set_key(key, key.size());
 
       if(V.size() != cipher->BLOCK_SIZE)
-         V.create(cipher->BLOCK_SIZE);
+         V.resize(cipher->BLOCK_SIZE);
       prng->randomize(V, V.size());
 
       update_buffer();
@@ -102,7 +102,7 @@ void ANSI_X931_RNG::add_entropy(const byte input[], u32bit length)
 */
 bool ANSI_X931_RNG::is_seeded() const
    {
-   return V.has_items();
+   return (V.size() > 0);
    }
 
 /**
@@ -138,7 +138,7 @@ ANSI_X931_RNG::ANSI_X931_RNG(BlockCipher* cipher_in,
    cipher = cipher_in;
    prng = prng_in;
 
-   R.create(cipher->BLOCK_SIZE);
+   R.resize(cipher->BLOCK_SIZE);
    position = 0;
    }
 
diff --git a/src/s2k/s2k.cpp b/src/s2k/s2k.cpp
index b8a8ef719..42064529d 100644
--- a/src/s2k/s2k.cpp
+++ b/src/s2k/s2k.cpp
@@ -48,7 +48,7 @@ void S2K::change_salt(const MemoryRegion<byte>& new_salt)
 void S2K::new_random_salt(RandomNumberGenerator& rng,
                           u32bit length)
    {
-   salt.create(length);
+   salt.resize(length);
    rng.randomize(salt, length);
    }
 
diff --git a/src/stream/ctr/ctr.cpp b/src/stream/ctr/ctr.cpp
index 5f0880fa5..723b94f28 100644
--- a/src/stream/ctr/ctr.cpp
+++ b/src/stream/ctr/ctr.cpp
@@ -22,8 +22,8 @@ CTR_BE::CTR_BE(BlockCipher* ciph) :
    {
    position = 0;
 
-   counter.create(permutation->BLOCK_SIZE * BOTAN_PARALLEL_BLOCKS_CTR);
-   buffer.create(permutation->BLOCK_SIZE * BOTAN_PARALLEL_BLOCKS_CTR);
+   counter.resize(permutation->BLOCK_SIZE * BOTAN_PARALLEL_BLOCKS_CTR);
+   buffer.resize(permutation->BLOCK_SIZE * BOTAN_PARALLEL_BLOCKS_CTR);
    }
 
 /*
diff --git a/src/stream/ofb/ofb.cpp b/src/stream/ofb/ofb.cpp
index 0d12d23bd..b52617789 100644
--- a/src/stream/ofb/ofb.cpp
+++ b/src/stream/ofb/ofb.cpp
@@ -21,7 +21,7 @@ OFB::OFB(BlockCipher* ciph) :
    permutation(ciph)
    {
    position = 0;
-   buffer.create(permutation->BLOCK_SIZE);
+   buffer.resize(permutation->BLOCK_SIZE);
    }
 
 /*
diff --git a/src/stream/turing/turing.cpp b/src/stream/turing/turing.cpp
index 810f65ca4..f0dd90ab6 100644
--- a/src/stream/turing/turing.cpp
+++ b/src/stream/turing/turing.cpp
@@ -222,7 +222,7 @@ u32bit Turing::fixedS(u32bit W)
 */
 void Turing::key_schedule(const byte key[], u32bit length)
    {
-   K.create(length / 4);
+   K.resize(length / 4);
    for(u32bit j = 0; j != length; ++j)
       K[j/4] = (K[j/4] << 8) + key[j];
 
diff --git a/src/sym_algo/symkey.cpp b/src/sym_algo/symkey.cpp
index 32dfe68d5..e309f56ab 100644
--- a/src/sym_algo/symkey.cpp
+++ b/src/sym_algo/symkey.cpp
@@ -20,7 +20,7 @@ namespace Botan {
 OctetString::OctetString(RandomNumberGenerator& rng,
                          u32bit length)
    {
-   bits.create(length);
+   bits.resize(length);
    rng.randomize(bits, length);
    }
 
@@ -36,7 +36,7 @@ void OctetString::change(const std::string& hex_string)
 
    if(hex.size() % 2 != 0)
       throw Invalid_Argument("OctetString: hex string must encode full bytes");
-   bits.create(hex.size() / 2);
+   bits.resize(hex.size() / 2);
    for(u32bit j = 0; j != bits.size(); ++j)
       bits[j] = Hex_Decoder::decode(hex.begin() + 2*j);
    }
@@ -46,7 +46,7 @@ void OctetString::change(const std::string& hex_string)
 */
 void OctetString::change(const byte in[], u32bit n)
    {
-   bits.create(n);
+   bits.resize(n);
    bits.copy(in, n);
    }
 

