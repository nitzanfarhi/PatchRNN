commit e3999574b48125c9bb0c95e3e9f1c696bf96c3e3
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Mon Feb 13 18:16:10 2006 -0800

    [SPARC64]: Generic sun4v_build_irq().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/sparc64/kernel/irq.c b/arch/sparc64/kernel/irq.c
index 51f65054bf18..bcc889a53324 100644
--- a/arch/sparc64/kernel/irq.c
+++ b/arch/sparc64/kernel/irq.c
@@ -303,6 +303,38 @@ out:
 	return __irq(bucket);
 }
 
+unsigned int sun4v_build_irq(u32 devhandle, unsigned int devino, int pil, unsigned char flags)
+{
+	struct ino_bucket *bucket;
+	unsigned long sysino;
+
+	sysino = sun4v_devino_to_sysino(devhandle, devino);
+
+	printk(KERN_INFO "sun4v_irq: Mapping ( devh[%08x] devino[%08x] ) "
+	       "--> sysino[%016lx]\n", devhandle, devino, sysino);
+
+	bucket = &ivector_table[sysino];
+
+	/* Catch accidental accesses to these things.  IMAP/ICLR handling
+	 * is done by hypervisor calls on sun4v platforms, not by direct
+	 * register accesses.
+	 */
+	bucket->imap = ~0UL;
+	bucket->iclr = ~0UL;
+
+	bucket->pil = pil;
+	bucket->flags = flags;
+
+	bucket->irq_info = kmalloc(sizeof(struct irq_desc), GFP_ATOMIC);
+	if (!bucket->irq_info) {
+		prom_printf("IRQ: Error, kmalloc(irq_desc) failed.\n");
+		prom_halt();
+	}
+	memset(bucket->irq_info, 0, sizeof(struct irq_desc));
+
+	return __irq(bucket);
+}
+
 static void atomic_bucket_insert(struct ino_bucket *bucket)
 {
 	unsigned long pstate;
diff --git a/arch/sparc64/kernel/pci_sun4v.c b/arch/sparc64/kernel/pci_sun4v.c
index 5174346ce35d..b8846b271f96 100644
--- a/arch/sparc64/kernel/pci_sun4v.c
+++ b/arch/sparc64/kernel/pci_sun4v.c
@@ -644,18 +644,11 @@ static void pci_sun4v_scan_bus(struct pci_controller_info *p)
 
 static unsigned int pci_sun4v_irq_build(struct pci_pbm_info *pbm,
 					struct pci_dev *pdev,
-					unsigned int ino)
+					unsigned int devino)
 {
-	struct ino_bucket *bucket;
-	unsigned long sysino;
 	u32 devhandle = pbm->devhandle;
 	int pil;
 
-	sysino = sun4v_devino_to_sysino(devhandle, ino);
-
-	printk(KERN_INFO "pci_irq_buld: Mapping ( devh[%08x] ino[%08x] ) "
-	       "--> sysino[%016lx]\n", devhandle, ino, sysino);
-
 	pil = 4;
 	if (pdev) {
 		switch ((pdev->class >> 16) & 0xff) {
@@ -685,26 +678,7 @@ static unsigned int pci_sun4v_irq_build(struct pci_pbm_info *pbm,
 	}
 	BUG_ON(PIL_RESERVED(pil));
 
-	bucket = &ivector_table[sysino];
-
-	/* Catch accidental accesses to these things.  IMAP/ICLR handling
-	 * is done by hypervisor calls on sun4v platforms, not by direct
-	 * register accesses.
-	 */
-	bucket->imap = ~0UL;
-	bucket->iclr = ~0UL;
-
-	bucket->pil = pil;
-	bucket->flags = IBF_PCI;
-
-	bucket->irq_info = kmalloc(sizeof(struct irq_desc), GFP_ATOMIC);
-	if (!bucket->irq_info) {
-		prom_printf("IRQ: Error, kmalloc(irq_desc) failed.\n");
-		prom_halt();
-	}
-	memset(bucket->irq_info, 0, sizeof(struct irq_desc));
-
-	return __irq(bucket);
+	return sun4v_build_irq(devhandle, devino, pil, IBF_PCI);
 }
 
 static void pci_sun4v_base_address_update(struct pci_dev *pdev, int resource)
diff --git a/include/asm-sparc64/irq.h b/include/asm-sparc64/irq.h
index 8b70edcb80dc..529a9df1ad43 100644
--- a/include/asm-sparc64/irq.h
+++ b/include/asm-sparc64/irq.h
@@ -111,6 +111,7 @@ extern void disable_irq(unsigned int);
 #define disable_irq_nosync disable_irq
 extern void enable_irq(unsigned int);
 extern unsigned int build_irq(int pil, int inofixup, unsigned long iclr, unsigned long imap);
+extern unsigned int sun4v_build_irq(u32 devhandle, unsigned int devino, int pil, unsigned char flags);
 extern unsigned int sbus_build_irq(void *sbus, unsigned int ino);
 
 static __inline__ void set_softint(unsigned long bits)

