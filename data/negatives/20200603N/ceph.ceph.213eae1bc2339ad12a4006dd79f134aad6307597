commit 213eae1bc2339ad12a4006dd79f134aad6307597
Author: Sage Weil <sage@newdream.net>
Date:   Mon Dec 15 11:32:32 2008 -0800

    mds: mark new directories new in journal; add to new list on replay
    
    This ensures the dir is written when the logseg is eventually
    expired.

diff --git a/src/mds/Server.cc b/src/mds/Server.cc
index a21c6737ef..cdecab3a35 100644
--- a/src/mds/Server.cc
+++ b/src/mds/Server.cc
@@ -2217,7 +2217,7 @@ void Server::handle_client_mkdir(MDRequest *mdr)
   le->metablob.add_allocated_ino(newi->ino(), mds->inotable->get_version());
   mdcache->predirty_journal_parents(mdr, &le->metablob, newi, dn->dir, PREDIRTY_PRIMARY|PREDIRTY_DIR, 1);
   le->metablob.add_primary_dentry(dn, true, newi, &newi->inode);
-  le->metablob.add_dir(newdir, true, true); // dirty AND complete
+  le->metablob.add_dir(newdir, true, true, true); // dirty AND complete AND new
   
   // log + wait
   mdlog->submit_entry(le, new C_MDS_mknod_finish(mds, mdr, dn, newi, follows));
diff --git a/src/mds/events/EMetaBlob.h b/src/mds/events/EMetaBlob.h
index 201be8ba93..51e4719bd3 100644
--- a/src/mds/events/EMetaBlob.h
+++ b/src/mds/events/EMetaBlob.h
@@ -189,6 +189,7 @@ public:
   struct dirlump {
     static const int STATE_COMPLETE =    (1<<1);
     static const int STATE_DIRTY =       (1<<2);  // dirty due to THIS journal item, that is!
+    static const int STATE_NEW =         (1<<3);  // new directory
 
     //version_t  dirv;
     fnode_t fnode;
@@ -209,6 +210,8 @@ public:
     void mark_complete() { state |= STATE_COMPLETE; }
     bool is_dirty() { return state & STATE_DIRTY; }
     void mark_dirty() { state |= STATE_DIRTY; }
+    bool is_new() { return state & STATE_NEW; }
+    void mark_new() { state |= STATE_NEW; }
 
     list<fullbit>   &get_dfull()   { return dfull; }
     list<remotebit> &get_dremote() { return dremote; }
@@ -449,11 +452,11 @@ private:
   }
 
   
-  dirlump& add_dir(CDir *dir, bool dirty, bool complete=false) {
+  dirlump& add_dir(CDir *dir, bool dirty, bool complete=false, bool isnew=false) {
     return add_dir(dir->dirfrag(), dir->get_projected_fnode(), dir->get_projected_version(),
-		   dirty, complete);
+		   dirty, complete, isnew);
   }
-  dirlump& add_dir(dirfrag_t df, fnode_t *pf, version_t pv, bool dirty, bool complete=false) {
+  dirlump& add_dir(dirfrag_t df, fnode_t *pf, version_t pv, bool dirty, bool complete=false, bool isnew=false) {
     if (lump_map.count(df) == 0) {
       lump_order.push_back(df);
       lump_map[df].fnode = *pf;
@@ -462,6 +465,7 @@ private:
     dirlump& l = lump_map[df];
     if (complete) l.mark_complete();
     if (dirty) l.mark_dirty();
+    if (isnew) l.mark_new();
     return l;
   }
   
diff --git a/src/mds/journal.cc b/src/mds/journal.cc
index e511904d64..44390a49e1 100644
--- a/src/mds/journal.cc
+++ b/src/mds/journal.cc
@@ -344,11 +344,13 @@ void EMetaBlob::replay(MDS *mds, LogSegment *logseg)
       dout(10) << "EMetaBlob.replay added dir " << *dir << dendl;  
     }
     dir->set_version( lump.fnode.version );
+
     if (lump.is_dirty()) {
       dir->_mark_dirty(logseg);
       dir->get_inode()->dirlock.set_updated();
     }
-
+    if (lump.is_new())
+      dir->mark_new(logseg);
     if (lump.is_complete())
       dir->mark_complete();
     

