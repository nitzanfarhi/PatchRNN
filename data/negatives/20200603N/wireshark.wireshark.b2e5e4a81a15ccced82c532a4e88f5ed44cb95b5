commit b2e5e4a81a15ccced82c532a4e88f5ed44cb95b5
Author: Evan Huus <eapache@gmail.com>
Date:   Mon Dec 23 20:52:12 2013 +0000

    First round converting OIDs from emem to wmem. Just internal functions so far.
    
    svn path=/trunk/; revision=54420

diff --git a/epan/oids.c b/epan/oids.c
index d7c6539a63..7d6962d30a 100644
--- a/epan/oids.c
+++ b/epan/oids.c
@@ -180,7 +180,7 @@ void oid_add(const char* name, guint oid_len, guint32 *subids) {
 
 void oid_add_from_string(const char* name, const gchar *oid_str) {
 	guint32* subids;
-	guint oid_len = oid_string2subid(oid_str, &subids);
+	guint oid_len = oid_string2subid(NULL, oid_str, &subids);
 
 	if (oid_len) {
 		D(3,("\tOid (from string): %s %s ",name?name:"NULL", oid_subid2string(subids,oid_len)));
@@ -188,6 +188,7 @@ void oid_add_from_string(const char* name, const gchar *oid_str) {
 	} else {
 		D(1,("Failed to add Oid: %s %s ",name?name:"NULL", oid_str?oid_str:NULL));
 	}
+	wmem_free(NULL, subids);
 }
 
 extern void oid_add_from_encoded(const char* name, const guint8 *oid, gint oid_len) {
@@ -886,7 +887,7 @@ static guint check_num_oid(const char* str) {
 	return n;
 }
 
-guint oid_string2subid(const char* str, guint32** subids_p) {
+guint oid_string2subid(wmem_allocator_t *scope, const char* str, guint32** subids_p) {
 	const char* r = str;
 	guint32* subids;
 	guint32* subids_overflow;
@@ -904,7 +905,7 @@ guint oid_string2subid(const char* str, guint32** subids_p) {
 		return 0;
 	}
 
-	*subids_p = subids = (guint32 *)ep_alloc0(sizeof(guint32)*n);
+	*subids_p = subids = wmem_alloc0_array(scope, guint32, n);
 	subids_overflow = subids + n;
 	do switch(*r) {
 		case '.':
@@ -1032,8 +1033,8 @@ oid_info_t* oid_get_from_encoded(const guint8 *bytes, gint byteslen, guint32** s
 	return oid_get(subids_len, *subids_p, matched_p, left_p);
 }
 
-oid_info_t* oid_get_from_string(const gchar *oid_str, guint32** subids_p, guint* matched, guint* left) {
-	guint subids_len = oid_string2subid(oid_str, subids_p);
+oid_info_t* oid_get_from_string(wmem_allocator_t *scope, const gchar *oid_str, guint32** subids_p, guint* matched, guint* left) {
+	guint subids_len = oid_string2subid(scope, oid_str, subids_p);
 	return oid_get(subids_len, *subids_p, matched, left);
 }
 
@@ -1130,19 +1131,26 @@ guint oid_string2encoded(const char *oid_str, guint8 **bytes) {
 	guint32 subids_len;
 	guint byteslen;
 
-		if ( ( subids_len = oid_string2subid(oid_str, &subids) )
-			 &&
-			 ( byteslen = oid_subid2encoded(subids_len, subids, bytes) )  ) {
-			return byteslen;
-		}
+	if ( (subids_len = oid_string2subid(NULL, oid_str, &subids)) &&
+	     (byteslen   = oid_subid2encoded(subids_len, subids, bytes)) ) {
+		wmem_free(NULL, subids);
+		return byteslen;
+	}
+	wmem_free(NULL, subids);
 	return 0;
 }
 
 const gchar *oid_resolved_from_string(const gchar *oid_str) {
-	guint32 *subid_oid;
-	guint subid_oid_length = oid_string2subid(oid_str, &subid_oid);
+	guint32     *subid_oid;
+	guint        subid_oid_length;
+        const gchar *resolved;
 
-	return oid_resolved(subid_oid_length, subid_oid);
+	subid_oid_length = oid_string2subid(NULL, oid_str, &subid_oid);
+	resolved         = oid_resolved(subid_oid_length, subid_oid);
+
+	wmem_free(NULL, subid_oid);
+
+	return resolved;
 }
 
 const gchar *oid_resolved(guint32 num_subids, guint32* subids) {
@@ -1184,11 +1192,14 @@ extern void oid_both_from_encoded(const guint8 *oid, gint oid_len, char** resolv
 	*numeric_p = (char *)oid_subid2string(subids,subids_len);
 }
 
-extern void oid_both_from_string(const gchar *oid_str, char** resolved_p, char** numeric_p) {
-	guint32* subids;
-	guint subids_len = oid_string2subid(oid_str, &subids);
-	*resolved_p = (char *)oid_resolved(subids_len,subids);
-	*numeric_p = (char *)oid_subid2string(subids,subids_len);
+void oid_both_from_string(const gchar *oid_str, const char** resolved_p, const char** numeric_p) {
+	guint32 *subids;
+	guint    subids_len;
+
+	subids_len  = oid_string2subid(NULL, oid_str, &subids);
+	*resolved_p = oid_resolved(subids_len,subids);
+	*numeric_p  = oid_subid2string(subids,subids_len);
+	wmem_free(NULL, subids);
 }
 
 /**
@@ -1314,4 +1325,3 @@ void add_oid_debug_subtree(oid_info_t* oid_info, proto_tree *tree) {
  * ex: set shiftwidth=8 tabstop=8 noexpandtab:
  * :indentSize=8:tabSize=8:noTabs=false:
  */
-
diff --git a/epan/oids.h b/epan/oids.h
index 3e209e2b55..0150c8e24f 100644
--- a/epan/oids.h
+++ b/epan/oids.h
@@ -149,7 +149,7 @@ WS_DLL_PUBLIC
 guint oid_encoded2subid_sub(const guint8 *oid_bytes, gint oid_len, guint32** subids_pi,
 		gboolean is_first);
 WS_DLL_PUBLIC
-guint oid_string2subid(const gchar *oid_str, guint32** subids_p);
+guint oid_string2subid(wmem_allocator_t *scope, const gchar *oid_str, guint32** subids_p);
 
 WS_DLL_PUBLIC const gchar* oid_encoded2string(const guint8* encoded, guint len);
 WS_DLL_PUBLIC const gchar* rel_oid_encoded2string(const guint8* encoded, guint len);
@@ -165,7 +165,7 @@ WS_DLL_PUBLIC const gchar *oid_resolved_from_string(const gchar *oid_str);
 /* these yield two formated strings one resolved and one numeric */
 WS_DLL_PUBLIC void oid_both(guint oid_len, guint32 *subids, char** resolved_p, char** numeric_p);
 WS_DLL_PUBLIC void oid_both_from_encoded(const guint8 *oid, gint oid_len, char** resolved_p, char** numeric_p);
-WS_DLL_PUBLIC void oid_both_from_string(const gchar *oid_str, char** resolved_p, char** numeric_p);
+WS_DLL_PUBLIC void oid_both_from_string(const gchar *oid_str, const char** resolved_p, const char** numeric_p);
 
 /*
  * These return the info for the best match.
@@ -174,7 +174,7 @@ WS_DLL_PUBLIC void oid_both_from_string(const gchar *oid_str, char** resolved_p,
  */
 WS_DLL_PUBLIC oid_info_t* oid_get(guint oid_len, guint32 *subids, guint* matched_p, guint* left_p);
 WS_DLL_PUBLIC oid_info_t* oid_get_from_encoded(const guint8 *oid, gint oid_len, guint32 **subids, guint* matched, guint* left);
-WS_DLL_PUBLIC oid_info_t* oid_get_from_string(const gchar *oid_str, guint32 **subids, guint* matched, guint* left);
+WS_DLL_PUBLIC oid_info_t* oid_get_from_string(wmem_allocator_t *scope, const gchar *oid_str, guint32 **subids, guint* matched, guint* left);
 
 /* these are used to add oids to the collection */
 WS_DLL_PUBLIC void oid_add(const char* name, guint oid_len, guint32 *subids);
diff --git a/epan/oids_test.c b/epan/oids_test.c
index c73ead83d7..b01d3be223 100644
--- a/epan/oids_test.c
+++ b/epan/oids_test.c
@@ -33,6 +33,8 @@
 #include "oids.h"
 #include "wmem/wmem.h"
 
+static wmem_allocator_t *test_scope;
+
 typedef struct
 {
     const gchar *string;
@@ -133,7 +135,7 @@ oids_test_2subids_string(void)
     guint32 *subids = NULL;
     guint len, i;
 
-    len = oid_string2subid(ex1.string, &subids);
+    len = oid_string2subid(test_scope, ex1.string, &subids);
     g_assert(len == ex1.subids_len);
     for (i=0; i < len; i++)
         g_assert(subids[i] == ex1.subids[i]);
@@ -145,7 +147,7 @@ oids_test_2subids_string_tooshort(void)
     guint32 *subids = NULL;
     guint len, i;
 
-    len = oid_string2subid(ex5.string, &subids);
+    len = oid_string2subid(test_scope, ex5.string, &subids);
     g_assert(len == ex5.subids_len);
     for (i=0; i < len; i++)
         g_assert(subids[i] == ex5.subids[i]);
@@ -341,8 +343,8 @@ oids_test_2both_encoded(void)
 static void
 oids_test_2both_string(void)
 {
-    gchar* resolved;
-    gchar* oid;
+    const gchar* resolved;
+    const gchar* oid;
 
     oid_both_from_string(ex1.string, &resolved, &oid);
     g_assert_cmpstr(resolved, ==, ex1.resolved);
@@ -394,7 +396,7 @@ oids_test_2struct_string(void)
     oid_info_t *st;
     guint len, i;
 
-    st = oid_get_from_string(ex1.string, &subids, &matched, &left);
+    st = oid_get_from_string(test_scope, ex1.string, &subids, &matched, &left);
     g_assert(matched == 1);
     g_assert(left == ex1.subids_len - 1);
     g_assert(st != NULL);
@@ -490,9 +492,11 @@ main(int argc, char **argv)
 
     emem_init();
     wmem_init();
+    test_scope = wmem_allocator_new(WMEM_ALLOCATOR_STRICT);
     oids_init();
     result = g_test_run();
     oids_cleanup();
+    wmem_destroy_allocator(test_scope);
     wmem_cleanup();
     /*
      * This might have been a good place for a call to ep_free_all() but that is not part of the

