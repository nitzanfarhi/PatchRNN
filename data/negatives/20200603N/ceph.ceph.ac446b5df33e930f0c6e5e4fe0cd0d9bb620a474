commit ac446b5df33e930f0c6e5e4fe0cd0d9bb620a474
Author: Sage Weil <sage@inktank.com>
Date:   Mon Dec 30 12:54:03 2013 -0800

    osd/ReplicatedPG: preserve clean/dirty state on clone
    
    If we have a clean object and clone it in make_writeable(), the clone
    should also be clean (it does not need to be written back to the base
    pool).  If the object was dirty, the clone should be dirty.
    
    Signed-off-by: Sage Weil <sage@inktank.com>

diff --git a/src/osd/ReplicatedPG.cc b/src/osd/ReplicatedPG.cc
index ea862ccb70..69762096f9 100644
--- a/src/osd/ReplicatedPG.cc
+++ b/src/osd/ReplicatedPG.cc
@@ -4288,6 +4288,8 @@ void ReplicatedPG::make_writeable(OpContext *ctx)
   dout(20) << "make_writeable " << soid << " snapset=" << ctx->snapset
 	   << "  snapc=" << snapc << dendl;;
   
+  bool was_dirty = ctx->new_obs.oi.is_dirty();
+
   if (ctx->new_obs.exists) {
     // we will mark the object dirty
     if (ctx->undirty) {
@@ -4342,6 +4344,8 @@ void ReplicatedPG::make_writeable(OpContext *ctx)
     snap_oi->prior_version = ctx->obs->oi.version;
     snap_oi->copy_user_bits(ctx->obs->oi);
     snap_oi->snaps = snaps;
+    if (was_dirty)
+      snap_oi->set_flag(object_info_t::FLAG_DIRTY);
     _make_clone(t, soid, coid, snap_oi);
     
     OSDriver::OSTransaction _t(osdriver.get_transaction(&(ctx->local_t)));

