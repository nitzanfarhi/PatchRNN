commit 8dca05f188712d26efb0e126a00d4ac167a5c8dc
Author: AndersBroman <anders.broman@ericsson.com>
Date:   Fri Dec 9 13:04:28 2016 +0100

    [RTP]Rearrange the logic in process_rtp_payload() to make it a bit clearer
    what happens.
    
    Change-Id: Ib64c127ef5e2ba3fe57301c7ac7c75fd1d0e0d27
    Reviewed-on: https://code.wireshark.org/review/19176
    Reviewed-by: Anders Broman <a.broman58@gmail.com>

diff --git a/epan/dissectors/packet-rtp.c b/epan/dissectors/packet-rtp.c
index 2efc2deed4..1cd6cab66e 100644
--- a/epan/dissectors/packet-rtp.c
+++ b/epan/dissectors/packet-rtp.c
@@ -1438,7 +1438,6 @@ process_rtp_payload(tvbuff_t *newtvb, packet_info *pinfo, proto_tree *tree,
             proto_tree *rtp_tree, unsigned int payload_type)
 {
     struct _rtp_conversation_info *p_conv_data;
-    gboolean found_match = FALSE;
     int payload_len;
     struct srtp_info *srtp_info;
     int offset = 0;
@@ -1461,7 +1460,6 @@ process_rtp_payload(tvbuff_t *newtvb, packet_info *pinfo, proto_tree *tree,
         {
             if (rtp_tree)
                 proto_tree_add_item(rtp_tree, hf_srtp_encrypted_payload, newtvb, offset, payload_len, ENC_NA);
-            found_match = TRUE; /* use this flag to prevent dissection below */
         }
         offset += payload_len;
 
@@ -1474,33 +1472,12 @@ process_rtp_payload(tvbuff_t *newtvb, packet_info *pinfo, proto_tree *tree,
             proto_tree_add_item(rtp_tree, hf_srtp_auth_tag, newtvb, offset, srtp_info->auth_tag_len, ENC_NA);
             /*offset += srtp_info->auth_tag_len;*/
         }
-    } else if (p_conv_data && !p_conv_data->bta2dp_info && !p_conv_data->btvdp_info &&
-            payload_type >= PT_UNDF_96 && payload_type <= PT_UNDF_127) {
-        /* if the payload type is dynamic, we check if the conv is set and we look for the pt definition */
-        if (p_conv_data->rtp_dyn_payload) {
-            const gchar *payload_type_str = rtp_dyn_payload_get_name(p_conv_data->rtp_dyn_payload, payload_type);
-            if (payload_type_str) {
-                int len;
-                len = dissector_try_string(rtp_dyn_pt_dissector_table,
-                                   payload_type_str, newtvb, pinfo, tree, NULL);
-                /* If payload type string set from conversation and
-                 * no matching dissector found it's probably because no subdissector
-                 * exists. Don't call the dissectors based on payload number
-                 * as that'd probably be the wrong dissector in this case.
-                 * Just add it as data.
-                 */
-                if(len == 0)
-                    proto_tree_add_item( rtp_tree, hf_rtp_data, newtvb, 0, -1, ENC_NA );
-                return;
-            }
+        return;
 
-        }
-    } else if (p_conv_data && p_conv_data->bta2dp_info) {
+    } if (p_conv_data && p_conv_data->bta2dp_info) {
         tvbuff_t  *nexttvb;
         gint       suboffset = 0;
 
-        found_match = TRUE;
-
         if (p_conv_data->bta2dp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {
             nexttvb = tvb_new_subset_length(newtvb, 0, 1);
              call_dissector(bta2dp_content_protection_header_scms_t, nexttvb, pinfo, tree);
@@ -1512,12 +1489,13 @@ process_rtp_payload(tvbuff_t *newtvb, packet_info *pinfo, proto_tree *tree,
             call_dissector_with_data(p_conv_data->bta2dp_info->codec_dissector, nexttvb, pinfo, tree, p_conv_data->bta2dp_info);
         else
             call_data_dissector(nexttvb, pinfo, tree);
-    } else if (p_conv_data && p_conv_data->btvdp_info) {
+
+        return;
+
+    } if (p_conv_data && p_conv_data->btvdp_info) {
         tvbuff_t  *nexttvb;
         gint       suboffset = 0;
 
-        found_match = TRUE;
-
         if (p_conv_data->btvdp_info->content_protection_type == BTAVDTP_CONTENT_PROTECTION_TYPE_SCMS_T) {
             nexttvb = tvb_new_subset_length(newtvb, 0, 1);
             call_dissector(btvdp_content_protection_header_scms_t, nexttvb, pinfo, tree);
@@ -1529,10 +1507,33 @@ process_rtp_payload(tvbuff_t *newtvb, packet_info *pinfo, proto_tree *tree,
             call_dissector_with_data(p_conv_data->btvdp_info->codec_dissector, nexttvb, pinfo, tree, p_conv_data->btvdp_info);
         else
             call_data_dissector(nexttvb, pinfo, tree);
+
+        return;
+    }
+    /* We have checked for !p_conv_data->bta2dp_info && !p_conv_data->btvdp_info above*/
+    if (p_conv_data && payload_type >= PT_UNDF_96 && payload_type <= PT_UNDF_127) {
+        /* if the payload type is dynamic, we check if the conv is set and we look for the pt definition */
+        if (p_conv_data->rtp_dyn_payload) {
+            const gchar *payload_type_str = rtp_dyn_payload_get_name(p_conv_data->rtp_dyn_payload, payload_type);
+            if (payload_type_str) {
+                int len;
+                len = dissector_try_string(rtp_dyn_pt_dissector_table,
+                    payload_type_str, newtvb, pinfo, tree, NULL);
+                /* If payload type string set from conversation and
+                * no matching dissector found it's probably because no subdissector
+                * exists. Don't call the dissectors based on payload number
+                * as that'd probably be the wrong dissector in this case.
+                * Just add it as data.
+                */
+                if (len == 0)
+                    proto_tree_add_item(rtp_tree, hf_rtp_data, newtvb, 0, -1, ENC_NA);
+                return;
+            }
+        }
     }
 
     /* if we don't found, it is static OR could be set static from the preferences */
-    if (!found_match && !dissector_try_uint(rtp_pt_dissector_table, payload_type, newtvb, pinfo, tree))
+    if (!dissector_try_uint(rtp_pt_dissector_table, payload_type, newtvb, pinfo, tree))
         proto_tree_add_item( rtp_tree, hf_rtp_data, newtvb, 0, -1, ENC_NA );
 
 }

