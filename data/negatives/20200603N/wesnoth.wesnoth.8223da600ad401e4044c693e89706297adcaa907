commit 8223da600ad401e4044c693e89706297adcaa907
Author: Eugen Jiresch <e0204097@student.tuwien.ac.at>
Date:   Wed Jun 10 21:50:23 2009 +0000

    replaced turn related functions in play_controller...
    
    ...by the respective functions of tod_manager

diff --git a/src/play_controller.cpp b/src/play_controller.cpp
index b1fc56d0a3..96f6daa441 100644
--- a/src/play_controller.cpp
+++ b/src/play_controller.cpp
@@ -81,16 +81,6 @@ play_controller::play_controller(const config& level, game_state& state_of_game,
 	victory_music_(),
 	defeat_music_()
 {
-	//set current turn via wml formula (if available)
-	std::string turn_at = level["turn_at"];
-	if (&state_of_game)
-	{
-		turn_at = utils::interpolate_variables_into_string(turn_at, state_of_game);
-	}
-	if(turn_at.empty() == false) {
-		turn_ = atoi(turn_at.c_str());
-		start_turn_ = turn_;
-	}
 
 	// Setup victory and defeat music
 	set_victory_music_list(level_["victory_music"]);
@@ -403,7 +393,7 @@ void play_controller::fire_prestart(bool execute){
 		update_locker lock_display(gui_->video());
 		game_events::fire("prestart");
 		// prestart event may modify start turn with WML, reflect any changes.
-		start_turn_ = turn_;
+		start_turn_ = turn();
 	}
 }
 
@@ -411,10 +401,10 @@ void play_controller::fire_start(bool execute){
 	if(execute) {
 		game_events::fire("start");
 		// start event may modify start turn with WML, reflect any changes.
-		start_turn_ = turn_;
+		start_turn_ = turn();
 		gamestate_.set_variable("turn_number", str_cast<size_t>(start_turn_));
 	} else {
-		previous_turn_ = turn_;
+		previous_turn_ = turn();
 	}
 }
 
@@ -465,16 +455,16 @@ void play_controller::do_init_side(const unsigned int team_index){
 	team& current_team = teams_[team_index];
 
 	bool real_side_change = true;
-	if (!loading_game_ || int(team_index) + 1 != first_player_ || turn_ > start_turn_) {
-		if (turn_ != previous_turn_)
+	if (!loading_game_ || int(team_index) + 1 != first_player_ || turn() > start_turn_) {
+		if (turn() != previous_turn_)
 		{
 			std::stringstream event_stream;
-			event_stream << turn_;
+			event_stream << turn();
 			const std::string turn_num = event_stream.str();
 
 			game_events::fire("turn " + turn_num);
 			game_events::fire("new turn");
-			previous_turn_ = turn_;
+			previous_turn_ = turn();
 		}
 		// Fire side turn event only if real side change occurs,
 		// not counting changes from void to a side
@@ -488,9 +478,9 @@ void play_controller::do_init_side(const unsigned int team_index){
 	// Healing/income happen if it's not the first turn of processing,
 	// or if we are loading a game, and this is not the player it started with.
 	bool turn_refresh =
-		(turn_ > start_turn_ ||
+		(turn() > start_turn_ ||
 			(loading_game_ && int(team_index) + 1 != first_player_))
-								&& (turn_ > 1);
+								&& (turn() > 1);
 
 
 	if(turn_refresh) {
@@ -518,7 +508,7 @@ void play_controller::do_init_side(const unsigned int team_index){
 	}
 
 	const time_of_day &tod = status_.get_time_of_day();
-	current_team.set_time_of_day(int(turn_), tod);
+	current_team.set_time_of_day(int(turn()), tod);
 
 	if (int(team_index) + 1 == first_player_)
 		sound::play_sound(tod.sounds, sound::SOUND_SOURCES);
@@ -533,50 +523,15 @@ void play_controller::do_init_side(const unsigned int team_index){
 	}
 }
 
-void play_controller::modify_turns(const std::string& mod)
-{
-	numTurns_ = std::max<int>(utils::apply_modifier(numTurns_,mod,0),-1);
-}
-void play_controller::add_turns(int num)
-{
-	numTurns_ = std::max<int>(numTurns_ + num,-1);
-}
-
-void play_controller::set_turn(unsigned int num)
-{
-	VALIDATE(tod_manager_.times().size(), _("No time of day has been defined."));
-	const unsigned int old_num = turn_;
-	// Correct ToD
-	int current_time = (num  - 1) % tod_manager_.times().size();
-	if (current_time < 0) {
-		current_time += tod_manager_.times().size();
-	}
-	tod_manager_.set_time_of_day(current_time);
-
-	if(static_cast<int>(num) > numTurns_ && numTurns_ != -1) {
-		this->add_turns(numTurns_ - num);
-	}
-	turn_ = num;
-
-	LOG_NG << "changed current turn number from " << old_num << " to " << num << '\n';
-}
-
-bool play_controller::next_turn()
-{
-	tod_manager_.next_time_of_day();
-	++turn_;
-	return numTurns_ == -1 || turn_ <= size_t(numTurns_);
-}
-
 //builds the snapshot config from its members and their configs respectively
 config play_controller::to_config()
 {
 	config cfg;
 	std::stringstream buf;
-	buf << turn_;
+	buf << turn();
 	cfg["turn_at"] = buf.str();
 	buf.str(std::string());
-	buf << numTurns_;
+	buf << number_of_turns();
 	cfg["turns"] = buf.str();
 	buf.str(std::string());
 
@@ -605,7 +560,7 @@ void play_controller::finish_side_turn(){
 
 void play_controller::finish_turn(){
 	std::stringstream event_stream;
-	event_stream << turn_;
+	event_stream << turn();
 
 	{
 		LOG_NG << "turn event..." << (recorder.is_skipping() ? "skipping" : "no skip") << "\n";
@@ -913,7 +868,7 @@ void play_controller::expand_autosaves(std::vector<std::string>& items)
 			items.erase(items.begin() + i);
 			std::vector<std::string> newitems;
 			std::vector<std::string> newsaves;
-			for (unsigned int turn = turn_; turn != 0; turn--) {
+			for (unsigned int turn = this->turn(); turn != 0; turn--) {
 				std::string name = gamestate_.classification().label + "-" + _("Auto-Save") + lexical_cast<std::string>(turn);
 				if (savegame_manager::save_game_exists(name, preferences::compress_saves())) {
 					if(preferences::compress_saves()) {
diff --git a/src/play_controller.hpp b/src/play_controller.hpp
index 32906383f7..cf15dba2be 100644
--- a/src/play_controller.hpp
+++ b/src/play_controller.hpp
@@ -79,20 +79,20 @@ public:
 	virtual void play_side(const unsigned int team_num, bool save) = 0;
 
 	//turn functions
-	size_t turn() const {return turn_;}
-	int number_of_turns() const {return numTurns_;}
-	void modify_turns(const std::string& mod);
-	void add_turns(int num);
+	size_t turn() const {return tod_manager_.turn();}
+	int number_of_turns() const {return tod_manager_.number_of_turns();}
+	void modify_turns(const std::string& mod)  {tod_manager_.modify_turns(mod);}
+	void add_turns(int num) {tod_manager_.add_turns(num);}
 
 	/** Dynamically change the current turn number. */
-	void set_turn(unsigned int num);
+	void set_turn(unsigned int num) {tod_manager_.set_turn(num);}
 
 	/**
 	 * Function to move to the next turn.
 	 *
 	 * @returns                   True if time has not expired.
 	 */
-	bool next_turn();
+	bool next_turn() {return tod_manager_.next_turn();}
 
 	void add_time_area(const config& cfg) {tod_manager_.add_time_area(cfg);}
 	void add_time_area(const std::string& id, const std::set<map_location>& locs,
diff --git a/src/playmp_controller.cpp b/src/playmp_controller.cpp
index 03532da52f..d8f5d55fa7 100644
--- a/src/playmp_controller.cpp
+++ b/src/playmp_controller.cpp
@@ -355,7 +355,7 @@ void playmp_controller::linger(upload_log& log)
 		} catch (game::load_game_exception&) {
 			LOG_NG << "caught load-game-exception" << std::endl;
 			// this should not happen, the option to load a game is disabled
-			log.quit(turn_);
+			log.quit(turn());
 			throw;
 		} catch (end_level_exception&) {
 			// thrown if the host ends the scenario and let us advance
@@ -490,7 +490,7 @@ void playmp_controller::play_network_turn(){
 			}
 
 			if(have_data) {
-				if (skip_replay_ && replay_last_turn_ <= turn_){
+				if (skip_replay_ && replay_last_turn_ <= turn()){
 						skip_replay_ = false;
 				}
 				try{
diff --git a/src/playsingle_controller.cpp b/src/playsingle_controller.cpp
index eed6ccedcd..bdb67da20c 100644
--- a/src/playsingle_controller.cpp
+++ b/src/playsingle_controller.cpp
@@ -332,7 +332,7 @@ LEVEL_RESULT playsingle_controller::play_scenario(
 
 	} catch(game::load_game_exception&) {
 		// Loading a new game is effectively a quit.
-		log.quit(turn_);
+		log.quit(turn());
 		throw;
 	} catch(end_level_exception& end_level) {
 		ai_testing::log_game_end();
@@ -374,11 +374,11 @@ LEVEL_RESULT playsingle_controller::play_scenario(
 		}
 
 		if(end_level.result == QUIT) {
-			log.quit(turn_);
+			log.quit(turn());
 			return end_level.result;
 		} else if(end_level.result == DEFEAT) {
 			gamestate_.classification().completion = "defeat";
-			log.defeat(turn_);
+			log.defeat(turn());
 			try {
 				game_events::fire("defeat");
 			} catch(end_level_exception&) {
@@ -418,7 +418,7 @@ LEVEL_RESULT playsingle_controller::play_scenario(
 					sound::play_music_once(victory_music);
 			}
 			if (first_human_team_ != -1)
-				log.victory(turn_, teams_[first_human_team_].gold());
+				log.victory(turn(), teams_[first_human_team_].gold());
 
 			const bool has_next_scenario = !gamestate_.classification().next_scenario.empty() &&
 											gamestate_.classification().next_scenario != "null";
@@ -459,7 +459,7 @@ LEVEL_RESULT playsingle_controller::play_scenario(
 				const int finishing_bonus_per_turn =
 						 map_.villages().size() * game_config::village_income +
 						 game_config::base_income;
-				const int turns_left = std::max<int>(0, number_of_turns() - turn_);
+				const int turns_left = std::max<int>(0, number_of_turns() - turn());
 				const int finishing_bonus = (end_level.gold_bonus && (turns_left > -1)) ?
 						 (finishing_bonus_per_turn * turns_left) : 0;
 
@@ -531,10 +531,10 @@ void playsingle_controller::play_turn(bool save)
 	gui_->invalidate_game_status();
 	events::raise_draw_event();
 
-	LOG_NG << "turn: " << turn_ << "\n";
+	LOG_NG << "turn: " << turn() << "\n";
 
 	if(non_interactive())
-		std::cout << "Turn " << turn_ << ":" << std::endl;
+		std::cout << "Turn " << turn() << ":" << std::endl;
 
 
 	for (player_number_ = first_player_; player_number_ <= int(teams_.size()); ++player_number_)
@@ -783,7 +783,7 @@ void playsingle_controller::linger(upload_log& log)
 		}
 	} catch(game::load_game_exception&) {
 		// Loading a new game is effectively a quit.
-		log.quit(turn_);
+		log.quit(turn());
 		throw;
 	}
 
@@ -859,7 +859,7 @@ void playsingle_controller::handle_generic_event(const std::string& name){
 
 void playsingle_controller::check_time_over(){
 	//FIXME: remove these assertions once turn functionality is removed from gamestatus
-	assert (status_.turn() == turn_);
+	assert (status_.turn() == turn());
 	assert (status_.number_of_turns() == number_of_turns());
 	bool b = next_turn();
 	if(!status_.next_turn() && !b) {
diff --git a/src/replay_controller.cpp b/src/replay_controller.cpp
index bdda7ff83b..842f2764ba 100644
--- a/src/replay_controller.cpp
+++ b/src/replay_controller.cpp
@@ -59,7 +59,7 @@ replay_controller::replay_controller(const config& level,
 	gamestate_start_(state_of_game),
 	status_start_(level, num_turns, &state_of_game),
 	units_start_(),
-	numTurns_start_(numTurns_),
+	tod_manager_start_(level, num_turns, &state_of_game),
 	current_turn_(1),
 	delay_(0),
 	is_playing_(false),
@@ -164,8 +164,7 @@ void replay_controller::reset_replay(){
 	is_playing_ = false;
 	player_number_ = 1;
 	current_turn_ = 1;
-	turn_ = start_turn_;
-	numTurns_ = numTurns_start_;
+	tod_manager_= tod_manager_start_;
 	recorder.start_replay();
 	units_ = units_start_;
 	status_ = status_start_;
@@ -321,7 +320,7 @@ void replay_controller::play_side(const unsigned int /*team_index*/, bool){
 		return;
 	}
 
-	DBG_REPLAY << "Status turn number: " << turn_ << "\n";
+	DBG_REPLAY << "Status turn number: " << turn() << "\n";
 	DBG_REPLAY << "Replay_Controller turn number: " << current_turn_ << "\n";
 	DBG_REPLAY << "Player number: " << player_number_ << "\n";
 
@@ -363,7 +362,7 @@ void replay_controller::play_side(const unsigned int /*team_index*/, bool){
 
 		if (static_cast<size_t>(player_number_) > teams_.size()) {
 			//FIXME: remove these assertions once turn functionality is removed from gamestatus
-			assert (status_.turn() == turn_);
+			assert (status_.turn() == turn());
 			assert (status_.number_of_turns() == number_of_turns());
 			next_turn();
 			status_.next_turn();
diff --git a/src/replay_controller.hpp b/src/replay_controller.hpp
index da73d6ccb3..7b5e3d80de 100644
--- a/src/replay_controller.hpp
+++ b/src/replay_controller.hpp
@@ -64,7 +64,7 @@ private:
 	game_state gamestate_start_;
 	gamestatus status_start_;
 	unit_map units_start_;
-	int numTurns_start_;
+	tod_manager tod_manager_start_;
 
 	unsigned int current_turn_;
 	int delay_;

