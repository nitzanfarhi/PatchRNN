commit 714683950547ea8173aefe25f574874c06233455
Author: Sebastian Tanase <sebastian.tanase@openwide.fr>
Date:   Wed Jul 23 11:47:50 2014 +0200

    icount: Fix virtual clock start value on ARM
    
    When using the icount option on ARM, the virtual
    clock starts counting at realtime clock but it
    should start at 0.
    
    The reason why the virtual clock starts at realtime clock
    is because the first time we call qemu_clock_warp (which
    calls icount_warp_rt) in tcg_exec_all, qemu_icount_bias
    (which is part of the virtual time computation mechanism)
    will increment by realtime - vm_clock_warp_start, with
    vm_clock_warp_start being 0 (see icount_warp_rt in cpus.c).
    
    By changing the value of vm_clock_warp_start from 0 to -1,
    the first time we call qemu_clock_warp which calls
    icount_warp_rt, we will return immediatly because
    icount_warp_rt first checks if vm_clock_warp_start is -1
    and if it's the case it returns. Therefore, qemu_icount_bias
    will first be incremented by the value of a virtual timer
    deadline when the virtual cpu goes from active to inactive.
    
    The virtual time will start at 0 and increment based
    on the instruction counter when the vcpu is active or
    the qemu_icount_bias value when inactive.
    
    Signed-off-by: Sebastian Tanase <sebastian.tanase@openwide.fr>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/cpus.c b/cpus.c
index 62636a65a8..bbb8d4e8be 100644
--- a/cpus.c
+++ b/cpus.c
@@ -102,7 +102,7 @@ static bool all_cpu_threads_idle(void)
 
 /* Protected by TimersState seqlock */
 
-static int64_t vm_clock_warp_start;
+static int64_t vm_clock_warp_start = -1;
 /* Conversion factor from emulated instructions to virtual clock ticks.  */
 static int icount_time_shift;
 /* Arbitrarily pick 1MIPS as the minimum allowable speed.  */

