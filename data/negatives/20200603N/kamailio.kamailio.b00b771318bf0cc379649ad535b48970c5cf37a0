commit b00b771318bf0cc379649ad535b48970c5cf37a0
Author: Daniel-Constantin Mierla <miconda@gmail.com>
Date:   Wed Apr 22 17:08:12 2009 +0200

    libkcore: moved core stats and mi stats to kex module
    
    - core specific implementation for statistics api moved to kex module
    - initialization of statistics collector is done while adding a
      new statistic if not done before
    - destroying the stats collector is done in mod_destroy from kex module

diff --git a/lib/kcore/core_stats.c b/lib/kcore/core_stats.c
deleted file mode 100644
index 6f5ebb6bd..000000000
--- a/lib/kcore/core_stats.c
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * $Id$
- *
- * Copyright (C) 2006 Voice Sistem SRL
- *
- * This file is part of Kamailio, a free SIP server.
- *
- * Kamailio is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Kamailio is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- *
- * History:
- * ---------
- *  2006-01-23  first version (bogdan)
- *  2006-11-28  Added statistics for the number of bad URI's, methods, and 
- *              proxy requests (Jeffrey Magder - SOMA Networks)
- */
-
-/*!
- * \file
- * \brief Kamailio Core statistics
- */
-
-
-#include <string.h>
-
-#include "statistics.h"
-
-
-#ifdef STATISTICS
-
-stat_var* rcv_reqs;				/*!< received requests        */
-stat_var* rcv_rpls;				/*!< received replies         */
-stat_var* fwd_reqs;				/*!< forwarded requests       */
-stat_var* fwd_rpls;				/*!< forwarded replies        */
-stat_var* drp_reqs;				/*!< dropped requests         */
-stat_var* drp_rpls;				/*!< dropped replies          */
-stat_var* err_reqs;				/*!< error requests           */
-stat_var* err_rpls;				/*!< error replies            */
-stat_var* bad_URIs;				/*!< number of bad URIs       */
-stat_var* unsupported_methods;	/*!< unsupported methods      */
-stat_var* bad_msg_hdr;			/*!< messages with bad header */
-
-
-/*! exported core statistics */
-stat_export_t core_stats[] = {
-	{"rcv_requests" ,         0,  &rcv_reqs              },
-	{"rcv_replies" ,          0,  &rcv_rpls              },
-	{"fwd_requests" ,         0,  &fwd_reqs              },
-	{"fwd_replies" ,          0,  &fwd_rpls              },
-	{"drop_requests" ,        0,  &drp_reqs              },
-	{"drop_replies" ,         0,  &drp_rpls              },
-	{"err_requests" ,         0,  &err_reqs              },
-	{"err_replies" ,          0,  &err_rpls              },
-	{"bad_URIs_rcvd",         0,  &bad_URIs              },
-	{"unsupported_methods",   0,  &unsupported_methods   },
-	{"bad_msg_hdr",           0,  &bad_msg_hdr           },
-	{0,0,0}
-};
-
-#endif
diff --git a/lib/kcore/core_stats.h b/lib/kcore/core_stats.h
deleted file mode 100644
index cbd882160..000000000
--- a/lib/kcore/core_stats.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * $Id$
- *
- * Copyright (C) 2006 Voice Sistem SRL
- *
- * This file is part of Kamailio, a free SIP server.
- *
- * Kamailio is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * Kamailio is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- *
- * History:
- * ---------
- *  2006-01-23  first version (bogdan)
- *  2006-11-28  Added statistics for the number of bad URI's, methods, and 
- *              proxy requests (Jeffrey Magder - SOMA Networks)
- */
-
-/*!
- * \file
- * \brief  Kamailio statistics
- */
-
-
-#ifndef _CORE_STATS_H_
-#define _CORE_STATS_H_
-
-#include "statistics.h"
-
-#ifdef STATISTICS
-/*! exported core statistics */
-extern stat_export_t core_stats[];
-
-/*! \brief received requests */
-extern stat_var* rcv_reqs;
-
-/*! \brief received replies */
-extern stat_var* rcv_rpls;
-
-/*! \brief forwarded requests */
-extern stat_var* fwd_reqs;
-
-/*! \brief forwarded replies */
-extern stat_var* fwd_rpls;
-
-/*! \brief dropped requests */
-extern stat_var* drp_reqs;
-
-/*! \brief dropped replies */
-extern stat_var* drp_rpls;
-
-/*! \brief error requests */
-extern stat_var* err_reqs;
-
-/*! \brief error replies */
-extern stat_var* err_rpls;
-
-/*! \brief Set in parse_uri() */
-extern stat_var* bad_URIs;
-
-/*! \brief Set in parse_method() */
-extern stat_var* unsupported_methods;
-
-/*! \brief Set in get_hdr_field(). */
-extern stat_var* bad_msg_hdr;
- 
-#endif /*STATISTICS*/
-
-#endif /*_CORE_STATS_H_*/
diff --git a/lib/kcore/statistics.c b/lib/kcore/statistics.c
index f9c561f5f..5a13c9340 100644
--- a/lib/kcore/statistics.c
+++ b/lib/kcore/statistics.c
@@ -35,42 +35,28 @@
 
 #include <string.h>
 #include <stdio.h>
+#include <stdlib.h>
 
 #include "../../mem/shm_mem.h"
-#include "../kmi/mi.h"
 #include "../../ut.h"
 #include "../../dprint.h"
 #include "../../locking.h"
 #include "../../socket_info.h"
-#include "core_stats.h"
+#include "km_ut.h"
+#include "hash_func.h"
 #include "statistics.h"
 
 #ifdef STATISTICS
 
-#define MAX_PROC_BUFFER 256
-
-static stats_collector *collector;
-
-static struct mi_root *mi_get_stats(struct mi_root *cmd, void *param);
-static struct mi_root *mi_reset_stats(struct mi_root *cmd, void *param);
-
-static mi_export_t mi_stat_cmds[] = {
-	{ "get_statistics",    mi_get_stats,    0  ,  0,  0 },
-	{ "reset_statistics",  mi_reset_stats,  0  ,  0,  0 },
-	{ 0, 0, 0, 0, 0}
-};
-
-
+static stats_collector *collector = NULL;
 
-#ifdef NO_ATOMIC_OPS
-#warning STATISTICS: Architecture with no support for atomic operations. \
-         Using Locks!!
-gen_lock_t *stat_lock = 0;
-#endif
 
 #define stat_hash(_s) core_hash( _s, 0, STATS_HASH_SIZE)
 
-
+stats_collector* get_stats_collector(void)
+{
+	return collector;
+}
 
 /*! \brief
  * Returns the statistic associated with 'numerical_code' and 'out_codes'.
@@ -106,6 +92,8 @@ stat_var *get_stat_var_from_num_code(unsigned int numerical_code, int out_codes)
 
 int init_stats_collector(void)
 {
+	if(collector != NULL) /* already initialized */
+		return 0;
 	/* init the collector */
 	collector = (stats_collector*)shm_malloc(sizeof(stats_collector));
 	if (collector==0) {
@@ -114,31 +102,6 @@ int init_stats_collector(void)
 	}
 	memset( collector, 0 , sizeof(stats_collector));
 
-#ifdef NO_ATOMIC_OPS
-	/* init BIG (really BIG) lock */
-	stat_lock = lock_alloc();
-	if (stat_lock==0 || lock_init( stat_lock )==0 ) {
-		LM_ERR("failed to init the really BIG lock\n");
-		goto error;
-	}
-#endif
-
-	/* register MI commands */
-	if (register_mi_mod( "statistics", mi_stat_cmds)<0) {
-		LM_ERR("unable to register MI cmds\n");
-		goto error;
-	}
-
-	/* register core statistics */
-	if (register_module_stats( "core", core_stats)!=0 ) {
-		LM_ERR("failed to register core statistics\n");
-		goto error;
-	}
-	/* register sh_mem statistics */
-	if (register_module_stats( "shmem", shm_stats)!=0 ) {
-		LM_ERR("failed to register sh_mem statistics\n");
-		goto error;
-	}
 	LM_DBG("statistics manager successfully initialized\n");
 
 	return 0;
@@ -153,12 +116,6 @@ void destroy_stats_collector(void)
 	stat_var *tmp_stat;
 	int i;
 
-#ifdef NO_ATOMIC_OPS
-	/* destroy big lock */
-	if (stat_lock)
-		lock_destroy( stat_lock );
-#endif
-
 	if (collector) {
 		/* destroy hash table */
 		for( i=0 ; i<STATS_HASH_SIZE ; i++ ) {
@@ -179,13 +136,14 @@ void destroy_stats_collector(void)
 
 		/* destroy the collector */
 		shm_free(collector);
+		collector = NULL;
 	}
 
 	return;
 }
 
 
-static inline module_stats* get_stat_module( str *module)
+module_stats* get_stat_module(str *module)
 {
 	int i;
 
@@ -210,6 +168,8 @@ static inline module_stats* add_stat_module( char *module)
 
 	if ( (module==0) || ((len = strlen(module))==0 ) )
 		return 0;
+	if(init_stats_collector()!=0)
+		return 0;
 
 	amods = (module_stats*)shm_realloc( collector->amodules,
 			(collector->mod_no+1)*sizeof(module_stats) );
@@ -245,6 +205,9 @@ int register_stat( char *module, char *name, stat_var **pvar, int flags)
 		goto error;
 	}
 
+	if(init_stats_collector()!=0)
+		return -1;
+
 	stat = (stat_var*)shm_malloc(sizeof(stat_var));
 	if (stat==0) {
 		LM_ERR("no more shm memory\n");
@@ -258,11 +221,7 @@ int register_stat( char *module, char *name, stat_var **pvar, int flags)
 			LM_ERR("no more shm memory\n");
 			goto error1;
 		}
-#ifdef NO_ATOMIC_OPS
-		*(stat->u.val) = 0;
-#else
 		atomic_set(stat->u.val,0);
-#endif
 		*pvar = stat;
 	} else {
 		stat->u.f = (stat_function)(pvar);
@@ -368,6 +327,10 @@ stat_var* get_stat( str *name )
 	return 0;
 }
 
+#endif /*STATISTICS*/
+
+#define MAX_PROC_BUFFER 256
+
 /*!
  * This function will retrieve a list of all ip addresses and ports that OpenSER
  * is listening on, with respect to the transport protocol specified with
@@ -724,138 +687,3 @@ int get_total_bytes_waiting(void)
 }
 
 
-
-/***************************** MI STUFF ********************************/
-
-inline static int mi_add_stat(struct mi_node *rpl, stat_var *stat)
-{
-	struct mi_node *node;
-
-	node = addf_mi_node_child(rpl, 0, 0, 0, "%.*s:%.*s = %lu",
-		collector->amodules[stat->mod_idx].name.len,
-		collector->amodules[stat->mod_idx].name.s,
-		stat->name.len, stat->name.s,
-		get_stat_val(stat) );
-
-	if (node==0)
-		return -1;
-	return 0;
-}
-
-inline static int mi_add_module_stats(struct mi_node *rpl,
-													module_stats *mods)
-{
-	struct mi_node *node;
-	stat_var *stat;
-
-	for( stat=mods->head ; stat ; stat=stat->lnext) {
-		node = addf_mi_node_child(rpl, 0, 0, 0, "%.*s:%.*s = %lu",
-			mods->name.len, mods->name.s,
-			stat->name.len, stat->name.s,
-			get_stat_val(stat) );
-		if (node==0)
-			return -1;
-	}
-	return 0;
-}
-
-
-static struct mi_root *mi_get_stats(struct mi_root *cmd, void *param)
-{
-	struct mi_root *rpl_tree;
-	struct mi_node *rpl;
-	struct mi_node *arg;
-	module_stats   *mods;
-	stat_var       *stat;
-	str val;
-	int i;
-
-	if (cmd->node.kids==NULL)
-		return init_mi_tree( 400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
-
-	rpl_tree = init_mi_tree( 200, MI_OK_S, MI_OK_LEN);
-	if (rpl_tree==0)
-		return 0;
-	rpl = &rpl_tree->node;
-
-	for( arg=cmd->node.kids ; arg ; arg=arg->next) {
-		if (arg->value.len==0)
-			continue;
-
-		val = arg->value;
-
-		if ( val.len==3 && memcmp(val.s,"all",3)==0) {
-			/* add all statistic variables */
-			for( i=0 ; i<collector->mod_no ;i++ ) {
-				if (mi_add_module_stats( rpl, &collector->amodules[i] )!=0)
-					goto error;
-			}
-		} else if ( val.len>1 && val.s[val.len-1]==':') {
-			/* add module statistics */
-			val.len--;
-			mods = get_stat_module( &val );
-			if (mods==0)
-				continue;
-			if (mi_add_module_stats( rpl, mods )!=0)
-				goto error;
-		} else {
-			/* add only one statistic */
-			stat = get_stat( &val );
-			if (stat==0)
-				continue;
-			if (mi_add_stat(rpl,stat)!=0)
-				goto error;
-		}
-	}
-
-	if (rpl->kids==0) {
-		free_mi_tree(rpl_tree);
-		return init_mi_tree( 404, "Statistics Not Found", 20);
-	}
-
-	return rpl_tree;
-error:
-	free_mi_tree(rpl_tree);
-	return 0;
-}
-
-
-
-static struct mi_root *mi_reset_stats(struct mi_root *cmd, void *param)
-{
-	struct mi_root *rpl_tree;
-	struct mi_node *arg;
-	stat_var       *stat;
-	int found;
-
-	if (cmd->node.kids==NULL)
-		return init_mi_tree( 400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
-
-	rpl_tree = init_mi_tree( 200, MI_OK_S, MI_OK_LEN);
-	if (rpl_tree==0)
-		return 0;
-	found = 0;
-
-	for( arg=cmd->node.kids ; arg ; arg=arg->next) {
-		if (arg->value.len==0)
-			continue;
-
-		stat = get_stat( &arg->value );
-		if (stat==0)
-			continue;
-
-		reset_stat( stat );
-		found = 1;
-	}
-
-	if (!found) {
-		free_mi_tree(rpl_tree);
-		return init_mi_tree( 404, "Statistics Not Found", 20);
-	}
-
-	return rpl_tree;
-}
-
-
-#endif /*STATISTICS*/
-
diff --git a/lib/kcore/statistics.h b/lib/kcore/statistics.h
index 37a479024..b81a48a42 100644
--- a/lib/kcore/statistics.h
+++ b/lib/kcore/statistics.h
@@ -32,10 +32,11 @@
  */
 
 
-#ifndef _STATISTICS_H_
-#define _STATISTICS_H_
+#ifndef _KSTATISTICS_H_
+#define _KSTATISTICS_H_
 
-#include "hash_func.h"
+#include <string.h>
+#include "../../str.h"
 #include "../../atomic_ops.h"
 
 #define STATS_HASH_POWER   8
@@ -48,11 +49,7 @@
 #define STAT_SHM_NAME  (1<<2)
 #define STAT_IS_FUNC   (1<<3)
 
-#ifdef NO_ATOMIC_OPS
-typedef unsigned int stat_val;
-#else
 typedef atomic_t stat_val;
-#endif
 
 typedef unsigned long (*stat_function)(void);
 
@@ -116,11 +113,8 @@ unsigned int get_stat_val( stat_var *var );
  */
 stat_var *get_stat_var_from_num_code(unsigned int numerical_code, int in_codes);
 
-
-#ifdef NO_ATOMIC_OPS
-#include "locking.h"
-extern gen_lock_t *stat_lock;
-#endif
+stats_collector* get_stats_collector(void);
+module_stats* get_stat_module(str *module);
 
 #else
 	#define init_stats_collector()  0
@@ -130,56 +124,29 @@ extern gen_lock_t *stat_lock;
 	#define get_stat( _name )  0
 	#define get_stat_val( _var ) 0
 	#define get_stat_var_from_num_code( _n_code, _in_code) NULL
+	#define get_stats_collector() NULL
+	#define get_stat_module(_module) NULL
 #endif
 
 
 #ifdef STATISTICS
-	#ifdef NO_ATOMIC_OPS
-		#define update_stat( _var, _n) \
-			do { \
-				if ( !((_var)->flags&STAT_IS_FUNC) ) {\
-					if ((_var)->flags&STAT_NO_SYNC) {\
-						*((_var)->u.val) += _n;\
-					} else {\
-						lock_get(stat_lock);\
-						*((_var)->u.val) += _n;\
-						lock_release(stat_lock);\
-					}\
-				}\
-			}while(0)
-		#define reset_stat( _var) \
-			do { \
-				if ( ((_var)->flags&(STAT_NO_RESET|STAT_IS_FUNC))==0 ) {\
-					if ((_var)->flags&STAT_NO_SYNC) {\
-						*((_var)->u.val) = 0;\
-					} else {\
-						lock_get(stat_lock);\
-						*((_var)->u.val) = 0;\
-						lock_release(stat_lock);\
-					}\
-				}\
-			}while(0)
-		#define get_stat_val( _var ) ((unsigned long)\
-			((_var)->flags&STAT_IS_FUNC)?(_var)->u.f():*((_var)->u.val))
-	#else
-		#define update_stat( _var, _n) \
-			do { \
-				if ( !((_var)->flags&STAT_IS_FUNC) ) {\
-					if (_n>=0) \
-						atomic_add( _n, (_var)->u.val);\
-					else \
-						atomic_sub( -(_n), (_var)->u.val);\
-				}\
-			}while(0)
-		#define reset_stat( _var) \
-			do { \
-				if ( ((_var)->flags&(STAT_NO_RESET|STAT_IS_FUNC))==0 ) {\
-					atomic_set( (_var)->u.val, 0);\
-				}\
-			}while(0)
-		#define get_stat_val( _var ) ((unsigned long)\
-			((_var)->flags&STAT_IS_FUNC)?(_var)->u.f():(_var)->u.val->counter)
-	#endif /* NO_ATOMIC_OPS */
+	#define update_stat( _var, _n) \
+		do { \
+			if ( !((_var)->flags&STAT_IS_FUNC) ) {\
+				if (_n>=0) \
+					atomic_add( _n, (_var)->u.val);\
+				else \
+					atomic_sub( -(_n), (_var)->u.val);\
+			}\
+		}while(0)
+	#define reset_stat( _var) \
+		do { \
+			if ( ((_var)->flags&(STAT_NO_RESET|STAT_IS_FUNC))==0 ) {\
+				atomic_set( (_var)->u.val, 0);\
+			}\
+		}while(0)
+	#define get_stat_val( _var ) ((unsigned long)\
+		((_var)->flags&STAT_IS_FUNC)?(_var)->u.f():(_var)->u.val->val)
 
 	#define if_update_stat(_c, _var, _n) \
 		do { \
@@ -241,5 +208,4 @@ int get_socket_list_from_proto(int **ipList, int protocol);
 int get_total_bytes_waiting(void);
 
 
-
 #endif

