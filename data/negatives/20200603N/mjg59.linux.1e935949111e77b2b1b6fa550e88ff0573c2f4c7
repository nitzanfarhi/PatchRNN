commit 1e935949111e77b2b1b6fa550e88ff0573c2f4c7
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Sep 29 01:27:24 2015 -0700

    watchdog: Always evaluate new timeout against min_timeout
    
    Up to now, a new timeout value is only evaluated against min_timeout
    if max_timeout is provided. This does not really make sense; a driver
    can have a minimum timeout even if it does not have a maximum timeout.
    Ensure that it is not smaller than min_timeout, even if max_timeout
    is not set.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Uwe Kleine-KÃ¶nig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/include/linux/watchdog.h b/include/linux/watchdog.h
index d74a0e907b9e..e90e3ea5ebeb 100644
--- a/include/linux/watchdog.h
+++ b/include/linux/watchdog.h
@@ -119,8 +119,15 @@ static inline void watchdog_set_nowayout(struct watchdog_device *wdd, bool noway
 /* Use the following function to check if a timeout value is invalid */
 static inline bool watchdog_timeout_invalid(struct watchdog_device *wdd, unsigned int t)
 {
-	return ((wdd->max_timeout != 0) &&
-		(t < wdd->min_timeout || t > wdd->max_timeout));
+	/*
+	 * The timeout is invalid if
+	 * - the requested value is smaller than the configured minimum timeout,
+	 * or
+	 * - a maximum timeout is configured, and the requested value is larger
+	 *   than the maximum timeout.
+	 */
+	return t < wdd->min_timeout ||
+		(wdd->max_timeout && t > wdd->max_timeout);
 }
 
 /* Use the following functions to manipulate watchdog driver specific data */

