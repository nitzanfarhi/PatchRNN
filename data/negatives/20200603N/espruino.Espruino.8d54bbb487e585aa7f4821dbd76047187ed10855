commit 8d54bbb487e585aa7f4821dbd76047187ed10855
Author: Gordon Williams (u36) <gw@pur3.co.uk>
Date:   Wed May 11 16:53:03 2016 +0100

    improvements now memoryArea is usable

diff --git a/src/jsparse.c b/src/jsparse.c
index 8228193f..1270bd50 100644
--- a/src/jsparse.c
+++ b/src/jsparse.c
@@ -403,9 +403,9 @@ NO_INLINE JsVar *jspeFunctionDefinition(bool parseNamedFunction) {
       use another Native String to load function code straight from flash */
       funcCodeVar = jsvNewWithFlags(JSV_NATIVE_STRING);
       if (funcCodeVar) {
-        size_t s = jsvStringIteratorGetIndex(&funcBegin) - 1;
+        int s = (int)jsvStringIteratorGetIndex(&funcBegin.it) - 1;
         funcCodeVar->varData.nativeStr.ptr = lex->sourceVar->varData.nativeStr.ptr + s;
-        funcCodeVar->varData.nativeStr.len = lastTokenEnd - s;
+        funcCodeVar->varData.nativeStr.len = (uint16_t)(lastTokenEnd - s);
       }
     } else {
       funcCodeVar = jslNewFromLexer(&funcBegin, (size_t)lastTokenEnd);
@@ -2503,10 +2503,19 @@ JsVar *jspEvaluateVar(JsVar *str, JsVar *scope, uint16_t lineNumberOffset) {
   return 0;
 }
 
-JsVar *jspEvaluate(const char *str) {
-  JsVar *evCode = jswrap_espruino_memoryArea((int)(size_t)str, (int)strlen(str));
+JsVar *jspEvaluate(const char *str, bool stringIsStatic) {
+
+  /* using a memory area is more efficient, but the interpreter
+   * may use substrings from it for function code. This means that
+   * if the string goes away, everything gets corrupted - hence
+   * the option here.
+   */
+  JsVar *evCode;
+  if (stringIsStatic)
+    evCode = jswrap_espruino_memoryArea((int)(size_t)str, (int)strlen(str));
+  else
+    evCode = jsvNewFromString(str);
   if (!evCode) return 0;
-  // could always use jsvNewFromString, but not as efficient
 
   JsVar *v = 0;
   if (!jsvIsMemoryFull())
diff --git a/src/jsparse.h b/src/jsparse.h
index 90662aeb..5d514ba7 100644
--- a/src/jsparse.h
+++ b/src/jsparse.h
@@ -56,8 +56,11 @@ JsVar *jspGetStackTrace();
 /** Execute code form a variable and return the result. If lineNumberOffset
  * is nonzero it's added to the line numbers that get reported for errors/debug */
 JsVar *jspEvaluateVar(JsVar *str, JsVar *scope, uint16_t lineNumberOffset);
-/** Execute code form a string and return the result. */
-JsVar *jspEvaluate(const char *str);
+/** Execute code form a string and return the result.
+ * You should only set stringIsStatic if the string will hang around for
+ * the life of the interpreter, as then the interpreter will use a pointer
+ * to this data, which could hang around inside the code. */
+JsVar *jspEvaluate(const char *str, bool stringIsStatic);
 JsVar *jspExecuteFunction(JsVar *func, JsVar *thisArg, int argCount, JsVar **argPtr);
 
 /// Evaluate a JavaScript module and return its exports
diff --git a/src/jswrap_flash.c b/src/jswrap_flash.c
index 59fab73a..e8732577 100644
--- a/src/jswrap_flash.c
+++ b/src/jswrap_flash.c
@@ -524,7 +524,7 @@ bool jsfLoadBootCodeFromFlash(bool isReset) {
 
   code = (char *)(FLASH_DATA_LOCATION);
 #endif
-  jsvUnLock(jspEvaluate(code));
+  jsvUnLock(jspEvaluate(code, true /* We are expecting this ptr to hang around */));
   return true;
 }
 
diff --git a/targets/esp8266/user_main.c b/targets/esp8266/user_main.c
index 041eb691..7043bdea 100644
--- a/targets/esp8266/user_main.c
+++ b/targets/esp8266/user_main.c
@@ -68,7 +68,7 @@ static void telnetLineCB(char *line) {
   // Pass the line to the interactive module ...
 
   jshPushIOCharEvents(jsiGetConsoleDevice(), line, strlen(line));
-  //jspEvaluate(line);
+  //jspEvaluate(line, false);
   //jsiDumpState();
   telnet_send("JS> ");
 } // End of lineCB
diff --git a/targets/linux/main.c b/targets/linux/main.c
index 40426014..28818ff9 100644
--- a/targets/linux/main.c
+++ b/targets/linux/main.c
@@ -66,7 +66,7 @@ bool run_test(const char *filename) {
   addNativeFunction("quit", nativeQuit);
   addNativeFunction("interrupt", nativeInterrupt);
 
-  jsvUnLock(jspEvaluate(buffer));
+  jsvUnLock(jspEvaluate(buffer, false));
 
   isRunning = true;
   bool isBusy = true;
@@ -262,7 +262,7 @@ int main(int argc, char **argv) {
         jsvInit();
         jsiInit(true);
         addNativeFunction("quit", nativeQuit);
-        jsvUnLock(jspEvaluate(argv[i+1]));
+        jsvUnLock(jspEvaluate(argv[i+1], false));
         int errCode = handleErrors();
         isRunning = !errCode;
         bool isBusy = true;
@@ -322,7 +322,7 @@ int main(int argc, char **argv) {
     jsvInit();
     jsiInit(false /* do not autoload!!! */);
     addNativeFunction("quit", nativeQuit);
-    jsvUnLock(jspEvaluate(cmd));
+    jsvUnLock(jspEvaluate(cmd, false));
     int errCode = handleErrors();
     free(buffer);
     isRunning = !errCode;

