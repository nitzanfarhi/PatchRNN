commit 26efdd8ddc8abb06cd650315e87ec56a63100beb
Author: Owen Yamauchi <oyamauchi@fb.com>
Date:   Tue Apr 8 13:46:37 2014 -0700

    Allocate SIMD regs for doubles on ARM
    
    Turns out vixl already had gpr<->simd and simd<->mem instructions for
    the uses cases we need. This was just a matter of making the SIMD
    registers available to the register allocator and handling them in a few
    places in codegen.
    
    We're not allocating SIMD registers to hold Cells yet. vixl has no
    support at all for 128-bit-wide SIMD registers, so I'll have to
    implement that separately. This diff also doesn't add support for
    passing doubles to builtins on ARM; that'll come next.
    
    I also got rid of some now-useless isConst handling from ARM codegen.
    
    Reviewed By: @edwinsmith
    
    Differential Revision: D1262941

diff --git a/hphp/runtime/vm/jit/abi-arm.h b/hphp/runtime/vm/jit/abi-arm.h
index 6ff8f2d860..49a8c87224 100644
--- a/hphp/runtime/vm/jit/abi-arm.h
+++ b/hphp/runtime/vm/jit/abi-arm.h
@@ -32,6 +32,11 @@ inline vixl::Register x2a(PhysReg x64reg) {
   return vixl::Register(vixl::CPURegister(x64reg));
 }
 
+inline vixl::FPRegister x2simd(PhysReg x64reg) {
+  always_assert(x64reg.isSIMD());
+  return vixl::FPRegister(vixl::CPURegister(x64reg));
+}
+
 inline constexpr unsigned maxArgReg() { return 7; }
 
 inline vixl::Register argReg(unsigned index) {
@@ -87,7 +92,7 @@ const vixl::Register rLinkReg(vixl::x30);
 const vixl::Register rReturnReg(vixl::x0);
 const vixl::Register rHostCallReg(vixl::x16);
 
-const RegSet kCallerSaved = RegSet()
+const RegSet kGPCallerSaved = RegSet()
   | RegSet(vixl::x0)
   | RegSet(vixl::x1)
   | RegSet(vixl::x2)
@@ -108,7 +113,7 @@ const RegSet kCallerSaved = RegSet()
   | RegSet(vixl::x18)
   ;
 
-const RegSet kCalleeSaved = RegSet()
+const RegSet kGPCalleeSaved = RegSet()
   // x19 = rVmSp
   // x20 = rVmTl
   // x21 = rStashedAR
@@ -121,6 +126,46 @@ const RegSet kCalleeSaved = RegSet()
   | RegSet(vixl::x28)
   ;
 
+const RegSet kSIMDCallerSaved = RegSet()
+  | RegSet(vixl::d0)
+  | RegSet(vixl::d1)
+  | RegSet(vixl::d2)
+  | RegSet(vixl::d3)
+  | RegSet(vixl::d4)
+  | RegSet(vixl::d5)
+  | RegSet(vixl::d6)
+  | RegSet(vixl::d7)
+  // 8-15 are callee-saved
+  | RegSet(vixl::d16)
+  | RegSet(vixl::d17)
+  | RegSet(vixl::d18)
+  | RegSet(vixl::d19)
+  | RegSet(vixl::d20)
+  | RegSet(vixl::d21)
+  | RegSet(vixl::d22)
+  | RegSet(vixl::d23)
+  | RegSet(vixl::d24)
+  | RegSet(vixl::d25)
+  | RegSet(vixl::d26)
+  | RegSet(vixl::d27)
+  | RegSet(vixl::d28)
+  | RegSet(vixl::d29)
+  | RegSet(vixl::d30)
+  // d31 exists, but PhysReg can't represent it, so we don't use it.
+  ;
+
+const RegSet kSIMDCalleeSaved = RegSet()
+  | RegSet(vixl::d8)
+  | RegSet(vixl::d9)
+  | RegSet(vixl::d10)
+  | RegSet(vixl::d11)
+  | RegSet(vixl::d12)
+  | RegSet(vixl::d13)
+  | RegSet(vixl::d14)
+  | RegSet(vixl::d15)
+  ;
+
+
 }}}
 
 #endif
diff --git a/hphp/runtime/vm/jit/code-gen-arm.cpp b/hphp/runtime/vm/jit/code-gen-arm.cpp
index c6c86bb6d5..934ba7f498 100644
--- a/hphp/runtime/vm/jit/code-gen-arm.cpp
+++ b/hphp/runtime/vm/jit/code-gen-arm.cpp
@@ -927,7 +927,25 @@ void CodeGenerator::cgShuffle(IRInstruction* inst) {
     }
     if (rs.numAllocated() == 0) {
       assert(src->inst()->op() == DefConst);
-      m_as.  Mov  (x2a(rd.reg(0)), src->rawVal());
+      auto rDst = rd.reg(0);
+      if (rDst.isGP()) {
+        m_as.  Mov  (x2a(rDst), src->rawVal());
+      } else {
+        // Assembler::fmov (which you'd think shouldn't be a macro instruction)
+        // will emit a ldr from a literal pool if IsImmFP64 is false. vixl's
+        // literal pools don't work well with our codegen pattern, so if that
+        // would happen, emit the raw bits into a GPR first and then move them
+        // unmodified into a SIMD.
+        if (vixl::Assembler::IsImmFP64(src->dblVal())) {
+          m_as.  Fmov (x2simd(rDst), src->dblVal());
+        } else if (src->dblVal() == 0.0) {
+          // 0 is not encodeable as an immediate to Fmov, but this works.
+          m_as.  Fmov (x2simd(rDst), vixl::xzr);
+        } else {
+          m_as.  Mov  (rAsm, src->rawVal());
+          m_as.  Fmov (x2simd(rDst), rAsm);
+        }
+      }
     }
     if (rd.numAllocated() == 2 && rs.numAllocated() < 2) {
       // Move src known type to register
@@ -971,31 +989,32 @@ static void shuffleArgs(vixl::MacroAssembler& a,
   auto const howTo = doRegMoves(moves, rAsm);
 
   for (auto& how : howTo) {
-    auto srcReg = x2a(how.m_src);
-    auto dstReg = x2a(how.m_dst);
+    vixl::CPURegister srcReg{how.m_src};
+    vixl::CPURegister dstReg{how.m_dst};
     if (how.m_kind == MoveInfo::Kind::Move) {
       auto* argDesc = argDescs[how.m_dst];
       if (argDesc) {
         auto kind = argDesc->kind();
         if (kind == ArgDesc::Kind::Addr) {
-          emitRegGetsRegPlusImm(a, dstReg, srcReg, argDesc->disp().l());
+          emitRegGetsRegPlusImm(a, vixl::Register{dstReg},
+                                vixl::Register{srcReg}, argDesc->disp().l());
         } else {
           if (argDesc->isZeroExtend()) {
             // "Unsigned eXTend Byte". The dest reg is a 32-bit reg but this
             // zeroes the top 32 bits, so the intended effect is achieved.
             a.Uxtb (dstReg.W(), srcReg.W());
           } else {
-            a.Mov  (dstReg, srcReg);
+            emitRegRegMove(a, dstReg, srcReg);
           }
         }
         if (kind != ArgDesc::Kind::TypeReg) {
           argDesc->markDone();
         }
       } else {
-        a.  Mov  (dstReg, srcReg);
+        emitRegRegMove(a, dstReg, srcReg);
       }
     } else {
-      emitXorSwap(a, dstReg, srcReg);
+      emitXorSwap(a, vixl::Register{dstReg}, vixl::Register{srcReg});
     }
   }
 
@@ -1056,13 +1075,13 @@ void CodeGenerator::cgCallHelper(vixl::MacroAssembler& a,
   assert(m_curInst->isNative());
 
   auto dstReg0 = dstInfo.reg0;
-  auto dstReg1 = dstInfo.reg1;
+  DEBUG_ONLY auto dstReg1 = dstInfo.reg1;
 
   if (debug) {
     toSave.forEach([](PhysReg r) { assert(r.isGP()); });
   }
 
-  toSave = toSave & kCallerSaved;
+  toSave = toSave & kGPCallerSaved;
   assert((toSave & RegSet().add(dstReg0).add(dstReg1)).empty());
 
   // Use vixl's handy helper to push caller-save regs. It uses ldp/stp when
@@ -1104,18 +1123,19 @@ void CodeGenerator::cgCallHelper(vixl::MacroAssembler& a,
     recordHostCallSyncPoint(a, syncPoint);
   }
 
-  auto armDst0 = x2a(dstReg0);
-  DEBUG_ONLY auto armDst1 = x2a(dstReg1);
+  vixl::CPURegister armDst0{dstReg0};
 
   switch (dstInfo.type) {
     case DestType::TV: not_implemented();
     case DestType::SSA:
-      assert(!armDst1.IsValid());
-      if (armDst0.IsValid() && !armDst0.Is(vixl::x0)) a.Mov(armDst0, vixl::x0);
+      assert(dstReg1 == InvalidReg);
+      if (armDst0.IsValid() && !armDst0.Is(vixl::x0)) {
+        emitRegRegMove(a, armDst0, vixl::x0);
+      }
       break;
     case DestType::SSA2: not_implemented();
     case DestType::None:
-      assert(!armDst0.IsValid() && !armDst1.IsValid());
+      assert(dstReg0 == InvalidReg && dstReg1 == InvalidReg);
       break;
   }
 }
@@ -1523,9 +1543,6 @@ void CodeGenerator::cgSpillFrame(IRInstruction* inst) {
   if (func->isA(Type::Null)) {
     // Do nothing
     assert(func->isConst());
-  } else if (func->isConst()) {
-    m_as.  Mov  (rAsm, func->funcVal());
-    m_as.  Str  (rAsm, spReg[spOff + AROFF(m_func)]);
   } else {
     auto reg0 = x2a(funcLoc.reg(0));
     m_as.  Str  (reg0, spReg[spOff + AROFF(m_func)]);
@@ -1667,15 +1684,14 @@ void CodeGenerator::emitLoadTypedValue(PhysLoc dst,
                                        vixl::Register base,
                                        ptrdiff_t offset,
                                        Block* label) {
-  auto valueDstReg = x2a(dst.reg(0));
-  auto typeDstReg  = x2a(dst.reg(1));
-
   if (label) not_implemented();
-
-  if (valueDstReg.IsFPRegister()) {
+  if (dst.reg(0).isSIMD()) {
     not_implemented();
   }
 
+  auto valueDstReg = x2a(dst.reg(0));
+  auto typeDstReg  = x2a(dst.reg(1));
+
   // Avoid clobbering the base reg if we'll need it later
   if (base.Is(typeDstReg) && valueDstReg.IsValid()) {
     m_as.  Mov  (rAsm, base);
@@ -1713,10 +1729,15 @@ void CodeGenerator::emitLoad(Type type, PhysLoc dstLoc,
   }
   if (type <= Type::Null) return;
 
-  auto dstReg = x2a(dstLoc.reg());
-  if (!dstReg.IsValid()) return;
+  if (dstLoc.reg().isGP()) {
+    auto dstReg = x2a(dstLoc.reg());
+    if (!dstReg.IsValid()) return;
 
-  m_as.  Ldr  (dstReg, base[offset + TVOFF(m_data)]);
+    m_as.  Ldr  (dstReg, base[offset + TVOFF(m_data)]);
+  } else {
+    assert(type <= Type::Dbl);
+    m_as.  Ldr  (x2simd(dstLoc.reg()), base[offset + TVOFF(m_data)]);
+  }
 }
 
 void CodeGenerator::emitStore(vixl::Register base,
@@ -1740,22 +1761,17 @@ void CodeGenerator::emitStore(vixl::Register base,
   if (type <= Type::Null) {
     return;
   }
-  if (src->isConst()) {
-    int64_t val = 0;
-    if (type <= (Type::Bool | Type::Int | Type::Dbl |
-                 Type::Arr | Type::StaticStr | Type::Cls)) {
-      val = src->rawVal();
-    } else {
-      not_reached();
-    }
-    m_as.    Mov  (rAsm, val);
-    m_as.    Str  (rAsm, base[offset + TVOFF(m_data)]);
-  } else {
+
+  if (srcLoc.reg().isGP()) {
     auto reg = x2a(srcLoc.reg());
+    assert(reg.IsValid());
     if (src->isA(Type::Bool)) {
       m_as.  Uxtb (reg.W(), reg.W());
     }
     m_as.    Str  (x2a(srcLoc.reg()), base[offset + TVOFF(m_data)]);
+  } else {
+    assert(type <= Type::Dbl);
+    m_as.    Str  (x2simd(srcLoc.reg()), base[offset + TVOFF(m_data)]);
   }
 }
 
diff --git a/hphp/runtime/vm/jit/code-gen-helpers-arm.cpp b/hphp/runtime/vm/jit/code-gen-helpers-arm.cpp
index 67e33ab26b..3f4f722830 100644
--- a/hphp/runtime/vm/jit/code-gen-helpers-arm.cpp
+++ b/hphp/runtime/vm/jit/code-gen-helpers-arm.cpp
@@ -85,6 +85,21 @@ void emitXorSwap(vixl::MacroAssembler& a,
   a.  Eor  (r1, r1, r2);
 }
 
+void emitRegRegMove(vixl::MacroAssembler& a, const vixl::CPURegister& dst,
+                    const vixl::CPURegister& src) {
+  using namespace vixl;
+  if (dst.IsRegister() && src.IsRegister()) {
+    a.  Mov  (Register{dst}, Register{src});
+  } else if (dst.IsFPRegister() && src.IsFPRegister()) {
+    a.  Fmov (FPRegister{dst}, FPRegister{src});
+  } else if (dst.IsRegister() && src.IsFPRegister()) {
+    a.  Fmov (Register{dst}, FPRegister{src});
+  } else {
+    a.  Fmov (FPRegister{dst}, Register{src});
+  }
+}
+
+
 //////////////////////////////////////////////////////////////////////
 
 void emitTestSurpriseFlags(vixl::MacroAssembler& a) {
diff --git a/hphp/runtime/vm/jit/code-gen-helpers-arm.h b/hphp/runtime/vm/jit/code-gen-helpers-arm.h
index 180c8b3b4d..983ce3fc13 100644
--- a/hphp/runtime/vm/jit/code-gen-helpers-arm.h
+++ b/hphp/runtime/vm/jit/code-gen-helpers-arm.h
@@ -58,6 +58,13 @@ JIT::TCA emitCall(vixl::MacroAssembler& a, CppCall call);
 void emitXorSwap(vixl::MacroAssembler& a,
                  const vixl::Register& r1, const vixl::Register& r2);
 
+/*
+ * Moves one register into another. This can handle GP and SIMD registers,
+ * and dst and src don't have to be the same kind.
+ */
+void emitRegRegMove(vixl::MacroAssembler& a,
+                    const vixl::CPURegister& dst, const vixl::CPURegister& src);
+
 /*
  * Check the surprise flags. If surprised, call functionEnterHelper.
  */
diff --git a/hphp/runtime/vm/jit/phys-reg.h b/hphp/runtime/vm/jit/phys-reg.h
index 686af89cf5..54656bda74 100644
--- a/hphp/runtime/vm/jit/phys-reg.h
+++ b/hphp/runtime/vm/jit/phys-reg.h
@@ -83,6 +83,8 @@ struct PhysReg {
   explicit constexpr PhysReg(Reg32 r) : n(int(RegNumber(r))) {}
 
   constexpr /* implicit */ PhysReg(vixl::Register r) : n(r.code()) {}
+  constexpr /* implicit */ PhysReg(vixl::FPRegister r)
+    : n(r.code() + kSIMDOffset) {}
 
   explicit constexpr PhysReg(RegNumber r) : n(int(r)) {}
 
diff --git a/hphp/runtime/vm/jit/reg-alloc.cpp b/hphp/runtime/vm/jit/reg-alloc.cpp
index d19a0fcbdc..b3bb7c0c14 100644
--- a/hphp/runtime/vm/jit/reg-alloc.cpp
+++ b/hphp/runtime/vm/jit/reg-alloc.cpp
@@ -212,11 +212,18 @@ Constraint srcConstraint(const IRInstruction& inst, unsigned i) {
   if (inst.src(i)->isConst() && mayUseConst(inst, i)) {
     c |= Constraint::IMM;
   }
+  if (inst.src(i)->type() <= Type::Dbl) {
+    c |= Constraint::SIMD;
+  }
   return c;
 }
 
 Constraint dstConstraint(const IRInstruction& inst, unsigned i) {
-  return Constraint::GP;
+  Constraint c { Constraint::GP };
+  if (inst.dst(i)->type() <= Type::Dbl) {
+    c |= Constraint::SIMD;
+  }
+  return c;
 }
 
 }
diff --git a/hphp/runtime/vm/jit/xls.cpp b/hphp/runtime/vm/jit/xls.cpp
index 3a36c71f6e..daf303bbef 100644
--- a/hphp/runtime/vm/jit/xls.cpp
+++ b/hphp/runtime/vm/jit/xls.cpp
@@ -1364,11 +1364,9 @@ const Abi x64_abi {
 };
 
 const Abi arm_abi {
-  // For now this is the same as x64, since we're pretending arm
-  // has the same register conventions as x64.
-  ARM::kCallerSaved | ARM::kCalleeSaved,
-  RegSet(), // fp/simd
-  ARM::kCalleeSaved
+  ARM::kGPCallerSaved   | ARM::kGPCalleeSaved,    // GP
+  ARM::kSIMDCallerSaved | ARM::kSIMDCalleeSaved,  // SIMD
+  ARM::kGPCalleeSaved   | ARM::kSIMDCalleeSaved   // callee-saved
 };
 }
 
diff --git a/hphp/vixl/a64/assembler-a64.h b/hphp/vixl/a64/assembler-a64.h
index 2faf484479..152e71f376 100644
--- a/hphp/vixl/a64/assembler-a64.h
+++ b/hphp/vixl/a64/assembler-a64.h
@@ -212,7 +212,6 @@ class FPRegister : public CPURegister {
   static const FPRegister dregisters[];
 };
 
-
 // No*Reg is used to indicate an unused argument, or an error case. Note that
 // these all compare equal (using the Is() method). The Register and FPRegister
 // variants are provided for convenience.
@@ -1591,6 +1590,10 @@ class Assembler {
     return IsImmAddSub(value);
   }
 
+  // Encoding helpers.
+  static bool IsImmFP32(float imm);
+  static bool IsImmFP64(double imm);
+
  protected:
   inline const Register& AppropriateZeroRegFor(const CPURegister& reg) const {
     return reg.Is64Bits() ? xzr : wzr;
@@ -1716,10 +1719,6 @@ class Assembler {
                                const FPRegister& fa,
                                FPDataProcessing3SourceOp op);
 
-  // Encoding helpers.
-  static bool IsImmFP32(float imm);
-  static bool IsImmFP64(double imm);
-
   void RecordLiteral(int64_t imm, unsigned size);
 
   // Emit the instruction at pc_.
diff --git a/hphp/vixl/a64/macro-assembler-a64.h b/hphp/vixl/a64/macro-assembler-a64.h
index 79551e87d9..d4d1eb77be 100644
--- a/hphp/vixl/a64/macro-assembler-a64.h
+++ b/hphp/vixl/a64/macro-assembler-a64.h
@@ -549,7 +549,6 @@ class MacroAssembler : public Assembler {
   }
   void Fmov(FPRegister fd, Register rn) {
     assert(allow_macro_instructions_);
-    assert(!rn.IsZero());
     fmov(fd, rn);
   }
   void Fmov(FPRegister fd, double imm) {

