commit 5b1795aa15a82e903d182d91ddf6cac7848e22be
Author: Rainer Gerhards <rgerhards@adiscon.com>
Date:   Tue May 27 12:28:40 2014 +0200

    relicense
    
    own code + contribs from Red Hat, for which permision
    to relicense exists (email 2014-05-27).

diff --git a/tools/rsyslogd.c b/tools/rsyslogd.c
index 339d4279c..59175f112 100644
--- a/tools/rsyslogd.c
+++ b/tools/rsyslogd.c
@@ -784,6 +784,47 @@ doHUP(void)
 	lookupDoHUP();
 }
 
+/* rsyslogdDoDie() is a signal handler. If called, it sets the bFinished variable
+ * to indicate the program should terminate. However, it does not terminate
+ * it itself, because that causes issues with multi-threading. The actual
+ * termination is then done on the main thread. This solution might introduce
+ * a minimal delay, but it is much cleaner than the approach of doing everything
+ * inside the signal handler.
+ * rgerhards, 2005-10-26
+ * Note:
+ * - we do not call DBGPRINTF() as this may cause us to block in case something
+ *   with the threading is wrong.
+ * - we do not really care about the return state of write(), but we need this
+ *   strange check we do to silence compiler warnings (thanks, Ubuntu!)
+ */
+void
+rsyslogdDoDie(int sig)
+{
+#	define MSG1 "DoDie called.\n"
+#	define MSG2 "DoDie called 5 times - unconditional exit\n"
+	static int iRetries = 0; /* debug aid */
+	dbgprintf(MSG1);
+	if(Debug == DEBUG_FULL) {
+		if(write(1, MSG1, sizeof(MSG1) - 1)) {}
+	}
+	if(iRetries++ == 4) {
+		if(Debug == DEBUG_FULL) {
+			if(write(1, MSG2, sizeof(MSG2) - 1)) {}
+		}
+		abort();
+	}
+	bFinished = sig;
+	if(glblDebugOnShutdown) {
+		/* kind of hackish - set to 0, so that debug_swith will enable
+		 * and AND emit the "start debug log" message.
+		 */
+		debugging_on = 0;
+		rsyslogdDebugSwitch();
+	}
+#	undef MSG1
+#	undef MSG2
+}
+
 
 /* This is the main processing loop. It is called after successful initialization.
  * When it returns, the syslogd terminates.
diff --git a/tools/syslogd.c b/tools/syslogd.c
index fd903e727..5726b1a59 100644
--- a/tools/syslogd.c
+++ b/tools/syslogd.c
@@ -129,6 +129,7 @@ rsRetVal rsyslogd_InitGlobalClasses(void);
 rsRetVal rsyslogd_InitStdRatelimiters(void);
 rsRetVal rsyslogdInit(void);
 void rsyslogdDebugSwitch();
+void rsyslogdDoDie(int sig);
 
 
 #if defined(SYSLOGD_PIDNAME)
@@ -292,46 +293,6 @@ reapchild()
 }
 
 
-/* doDie() is a signal handler. If called, it sets the bFinished variable
- * to indicate the program should terminate. However, it does not terminate
- * it itself, because that causes issues with multi-threading. The actual
- * termination is then done on the main thread. This solution might introduce
- * a minimal delay, but it is much cleaner than the approach of doing everything
- * inside the signal handler.
- * rgerhards, 2005-10-26
- * Note:
- * - we do not call DBGPRINTF() as this may cause us to block in case something
- *   with the threading is wrong.
- * - we do not really care about the return state of write(), but we need this
- *   strange check we do to silence compiler warnings (thanks, Ubuntu!)
- */
-static void doDie(int sig)
-{
-#	define MSG1 "DoDie called.\n"
-#	define MSG2 "DoDie called 5 times - unconditional exit\n"
-	static int iRetries = 0; /* debug aid */
-	dbgprintf(MSG1);
-	if(Debug == DEBUG_FULL) {
-		if(write(1, MSG1, sizeof(MSG1) - 1)) {}
-	}
-	if(iRetries++ == 4) {
-		if(Debug == DEBUG_FULL) {
-			if(write(1, MSG2, sizeof(MSG2) - 1)) {}
-		}
-		abort();
-	}
-	bFinished = sig;
-	if(glblDebugOnShutdown) {
-		/* kind of hackish - set to 0, so that debug_swith will enable
-		 * and AND emit the "start debug log" message.
-		 */
-		debugging_on = 0;
-		rsyslogdDebugSwitch();
-	}
-#	undef MSG1
-#	undef MSG2
-}
-
 
 /* GPL code - maybe check BSD sources? */
 void
@@ -754,9 +715,9 @@ doGlblProcessInit(void)
 	sigaction(SIGSEGV, &sigAct, NULL);
 	sigAct.sa_handler = sigsegvHdlr;
 	sigaction(SIGABRT, &sigAct, NULL);
-	sigAct.sa_handler = doDie;
+	sigAct.sa_handler = rsyslogdDoDie;
 	sigaction(SIGTERM, &sigAct, NULL);
-	sigAct.sa_handler = Debug ? doDie : SIG_IGN;
+	sigAct.sa_handler = Debug ? rsyslogdDoDie : SIG_IGN;
 	sigaction(SIGINT, &sigAct, NULL);
 	sigaction(SIGQUIT, &sigAct, NULL);
 	sigAct.sa_handler = reapchild;

