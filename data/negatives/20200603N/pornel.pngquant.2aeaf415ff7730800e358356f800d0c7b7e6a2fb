commit 2aeaf415ff7730800e358356f800d0c7b7e6a2fb
Author: porneL <pornel@pornel.net>
Date:   Sun Sep 25 22:55:28 2011 +0100

    Storing representative subpalette

diff --git a/mediancut.c b/mediancut.c
index 501423d..9155f6d 100644
--- a/mediancut.c
+++ b/mediancut.c
@@ -198,11 +198,19 @@ colormap *mediancut(hist *hist, float min_opaque_val, int newcolors)
 
     int boxes = 1;
 
+    // remember smaller palette for fast searching
+    colormap *representative_subset = NULL;
+    int subset_size = sqrtf(newcolors)*3;
+
     /*
      ** Main loop: split boxes until we have enough.
      */
     while (boxes < newcolors) {
 
+        if (boxes == subset_size) {
+            representative_subset = colormap_from_boxes(bv, boxes, achv, min_opaque_val);
+        }
+
         int bi= best_splittable_box(bv, boxes);
         if (bi < 0)
             break;        /* ran out of colors! */
@@ -255,6 +263,7 @@ colormap *mediancut(hist *hist, float min_opaque_val, int newcolors)
     }
 
     colormap *map = colormap_from_boxes(bv, boxes, achv, min_opaque_val);
+    map->subset_palette = representative_subset;
     adjust_histogram(achv, map, bv, boxes);
 
     return map;
@@ -336,6 +345,7 @@ static f_pixel averagepixels(int indx, int clrs, const hist_item achv[], float m
     g /= sum;
     b /= sum;
 
+    assert(!isnan(r) && !isnan(g) && !isnan(b) && !isnan(a));
 
     /** if there was at least one completely opaque color, "round" final color to opaque */
     if (a >= min_opaque_val && maxa >= (255.0/256.0)) a = 1;
diff --git a/pam.h b/pam.h
index bf14206..d34210c 100644
--- a/pam.h
+++ b/pam.h
@@ -145,8 +145,9 @@ typedef struct {
     float popularity;
 } colormap_item;
 
-typedef struct {
+typedef struct colormap {
     colormap_item *palette;
+    struct colormap *subset_palette;
     int colors;
 } colormap;
 

