commit d9db6da6a87cedbbf775c3f48efb3f8b78811883
Author: dron <dron>
Date:   Tue Feb 7 11:00:22 2006 +0000

    Properly cast values to avoid warnings. As per bug
    http://bugzilla.remotesensing.org/show_bug.cgi?id=1033.

diff --git a/libtiff/tif_dirread.c b/libtiff/tif_dirread.c
index 6261446d..4b8c68bf 100644
--- a/libtiff/tif_dirread.c
+++ b/libtiff/tif_dirread.c
@@ -80,7 +80,6 @@ TIFFReadDirectory(TIFF* tif)
 	size_t fix;
 	uint16 dircount;
 	toff_t nextdiroff;
-	char* cp;
 	int diroutoforderwarning = 0;
 	toff_t* new_dirlist;
 
@@ -98,8 +97,8 @@ TIFFReadDirectory(TIFF* tif)
 			return (0);
 	}
 	tif->tif_dirnumber++;
-	new_dirlist = _TIFFrealloc(tif->tif_dirlist,
-				   tif->tif_dirnumber * sizeof(toff_t));
+	new_dirlist = (toff_t *)_TIFFrealloc(tif->tif_dirlist,
+					tif->tif_dirnumber * sizeof(toff_t));
 	if (!new_dirlist) {
 		TIFFErrorExt(tif->tif_clientdata, module,
 			  "%s: Failed to allocate space for IFD list",
@@ -464,34 +463,41 @@ TIFFReadDirectory(TIFF* tif)
 			break;
 		case TIFFTAG_COLORMAP:
 		case TIFFTAG_TRANSFERFUNCTION:
-			/*
-			 * TransferFunction can have either 1x or 3x data
-			 * values; Colormap can have only 3x items.
-			 */
-			v = 1L<<td->td_bitspersample;
-			if (dp->tdir_tag == TIFFTAG_COLORMAP ||
-			    dp->tdir_count != v) {
-				if (!CheckDirCount(tif, dp, 3 * v))
-					break;
-			}
-			v *= sizeof(uint16);
-			cp = _TIFFCheckMalloc(tif, dp->tdir_count, sizeof (uint16),
-			    "to read \"TransferFunction\" tag");
-			if (cp != NULL) {
-				if (TIFFFetchData(tif, dp, cp)) {
-					/*
-					 * This deals with there being only
-					 * one array to apply to all samples.
-					 */
-					uint32 c = 1L << td->td_bitspersample;
-					if (dp->tdir_count == c)
-						v = 0L;
-					TIFFSetField(tif, dp->tdir_tag,
-					    cp, cp+v, cp+2*v);
+			{
+				char* cp;
+				/*
+				 * TransferFunction can have either 1x or 3x
+				 * data values; Colormap can have only 3x
+				 * items.
+				 */
+				v = 1L<<td->td_bitspersample;
+				if (dp->tdir_tag == TIFFTAG_COLORMAP ||
+				    dp->tdir_count != v) {
+					if (!CheckDirCount(tif, dp, 3 * v))
+						break;
+				}
+				v *= sizeof(uint16);
+				cp = (char *)_TIFFCheckMalloc(tif,
+							      dp->tdir_count,
+							      sizeof (uint16),
+					"to read \"TransferFunction\" tag");
+				if (cp != NULL) {
+					if (TIFFFetchData(tif, dp, cp)) {
+						/*
+						 * This deals with there being
+						 * only one array to apply to
+						 * all samples.
+						 */
+						uint32 c = 1L << td->td_bitspersample;
+						if (dp->tdir_count == c)
+							v = 0L;
+						TIFFSetField(tif, dp->tdir_tag,
+						    cp, cp+v, cp+2*v);
+					}
+					_TIFFfree(cp);
 				}
-				_TIFFfree(cp);
+				break;
 			}
-			break;
 		case TIFFTAG_PAGENUMBER:
 		case TIFFTAG_HALFTONEHINTS:
 		case TIFFTAG_YCBCRSUBSAMPLING:
@@ -1156,7 +1162,7 @@ TIFFFetchShortPair(TIFF* tif, TIFFDirEntry* dir)
 		case TIFF_SHORT:
 		case TIFF_SSHORT:
 			{
-			uint16 v[4];
+			uint16 v[2];
 			return TIFFFetchShortArray(tif, dir, v)
 				&& TIFFSetField(tif, dir->tdir_tag, v[0], v[1]);
 			}
@@ -1342,35 +1348,35 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp)
 		switch (dp->tdir_type) {
 		case TIFF_BYTE:
 		case TIFF_SBYTE:
-			cp = _TIFFCheckMalloc(tif,
+			cp = (char *)_TIFFCheckMalloc(tif,
 			    dp->tdir_count, sizeof (uint8), mesg);
 			ok = cp && TIFFFetchByteArray(tif, dp, (uint8*) cp);
 			break;
 		case TIFF_SHORT:
 		case TIFF_SSHORT:
-			cp = _TIFFCheckMalloc(tif,
+			cp = (char *)_TIFFCheckMalloc(tif,
 			    dp->tdir_count, sizeof (uint16), mesg);
 			ok = cp && TIFFFetchShortArray(tif, dp, (uint16*) cp);
 			break;
 		case TIFF_LONG:
 		case TIFF_SLONG:
-			cp = _TIFFCheckMalloc(tif,
+			cp = (char *)_TIFFCheckMalloc(tif,
 			    dp->tdir_count, sizeof (uint32), mesg);
 			ok = cp && TIFFFetchLongArray(tif, dp, (uint32*) cp);
 			break;
 		case TIFF_RATIONAL:
 		case TIFF_SRATIONAL:
-			cp = _TIFFCheckMalloc(tif,
+			cp = (char *)_TIFFCheckMalloc(tif,
 			    dp->tdir_count, sizeof (float), mesg);
 			ok = cp && TIFFFetchRationalArray(tif, dp, (float*) cp);
 			break;
 		case TIFF_FLOAT:
-			cp = _TIFFCheckMalloc(tif,
+			cp = (char *)_TIFFCheckMalloc(tif,
 			    dp->tdir_count, sizeof (float), mesg);
 			ok = cp && TIFFFetchFloatArray(tif, dp, (float*) cp);
 			break;
 		case TIFF_DOUBLE:
-			cp = _TIFFCheckMalloc(tif,
+			cp = (char *)_TIFFCheckMalloc(tif,
 			    dp->tdir_count, sizeof (double), mesg);
 			ok = cp && TIFFFetchDoubleArray(tif, dp, (double*) cp);
 			break;
@@ -1380,7 +1386,8 @@ TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp)
 			 * Some vendors write strings w/o the trailing
 			 * NULL byte, so always append one just in case.
 			 */
-			cp = _TIFFCheckMalloc(tif, dp->tdir_count+1, 1, mesg);
+			cp = (char *)_TIFFCheckMalloc(tif, dp->tdir_count + 1,
+						      1, mesg);
 			if( (ok = (cp && TIFFFetchString(tif, dp, cp))) != 0 )
 				cp[dp->tdir_count] = '\0';	/* XXX */
 			break;
@@ -1671,7 +1678,8 @@ TIFFFetchRefBlackWhite(TIFF* tif, TIFFDirEntry* dir)
 	/*
 	 * Handle LONG's for backward compatibility.
 	 */
-	cp = _TIFFCheckMalloc(tif, dir->tdir_count, sizeof (uint32), mesg);
+	cp = (char *)_TIFFCheckMalloc(tif, dir->tdir_count,
+				      sizeof (uint32), mesg);
 	if( (ok = (cp && TIFFFetchLongArray(tif, dir, (uint32*) cp))) != 0) {
 		float* fp = (float*)
 		    _TIFFCheckMalloc(tif, dir->tdir_count, sizeof (float), mesg);
diff --git a/libtiff/tif_packbits.c b/libtiff/tif_packbits.c
index 4ec78467..7cd4dce9 100644
--- a/libtiff/tif_packbits.c
+++ b/libtiff/tif_packbits.c
@@ -38,7 +38,7 @@ PackBitsPreEncode(TIFF* tif, tsample_t s)
 {
 	(void) s;
 
-        if (!(tif->tif_data = _TIFFmalloc(sizeof(tsize_t))))
+        if (!(tif->tif_data = (tidata_t)_TIFFmalloc(sizeof(tsize_t))))
 		return (0);
 	/*
 	 * Calculate the scanline/tile-width size in bytes.
diff --git a/libtiff/tif_win32.c b/libtiff/tif_win32.c
index 76901be7..c26c85d5 100644
--- a/libtiff/tif_win32.c
+++ b/libtiff/tif_win32.c
@@ -251,7 +251,7 @@ TIFFOpenW(const wchar_t* name, const char* mode)
 	mbname = NULL;
 	mbsize = WideCharToMultiByte(CP_ACP, 0, name, -1, NULL, 0, NULL, NULL);
 	if (mbsize > 0) {
-		mbname = _TIFFmalloc(mbsize);
+		mbname = (char *)_TIFFmalloc(mbsize);
 		if (!mbname) {
 			TIFFErrorExt(0, module,
 			"Can't allocate space for filename conversion buffer");

