commit b126b4703afa4010b161784a43650337676dd03b
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Oct 26 15:41:39 2010 -0600

    PCI: allocate bus resources from the top down
    
    Allocate space from the highest-address PCI bus resource first, then work
    downward.
    
    Previously, we looked for space in PCI host bridge windows in the order
    we discovered the windows.  For example, given the following windows
    (discovered via an ACPI _CRS method):
    
        pci_root PNP0A03:00: host bridge window [mem 0x000a0000-0x000bffff]
        pci_root PNP0A03:00: host bridge window [mem 0x000c0000-0x000effff]
        pci_root PNP0A03:00: host bridge window [mem 0x000f0000-0x000fffff]
        pci_root PNP0A03:00: host bridge window [mem 0xbff00000-0xf7ffffff]
        pci_root PNP0A03:00: host bridge window [mem 0xff980000-0xff980fff]
        pci_root PNP0A03:00: host bridge window [mem 0xff97c000-0xff97ffff]
        pci_root PNP0A03:00: host bridge window [mem 0xfed20000-0xfed9ffff]
    
    we attempted to allocate from [mem 0x000a0000-0x000bffff] first, then
    [mem 0x000c0000-0x000effff], and so on.
    
    With this patch, we allocate from [mem 0xff980000-0xff980fff] first, then
    [mem 0xff97c000-0xff97ffff], [mem 0xfed20000-0xfed9ffff], etc.
    
    Allocating top-down follows Windows practice, so we're less likely to
    trip over BIOS defects in the _CRS description.
    
    On the machine above (a Dell T3500), the [mem 0xbff00000-0xbfffffff] region
    doesn't actually work and is likely a BIOS defect.  The symptom is that we
    move the AHCI controller to 0xbff00000, which leads to "Boot has failed,
    sleeping forever," a BUG in ahci_stop_engine(), or some other boot failure.
    
    Reference: https://bugzilla.kernel.org/show_bug.cgi?id=16228#c43
    Reference: https://bugzilla.redhat.com/show_bug.cgi?id=620313
    Reference: https://bugzilla.redhat.com/show_bug.cgi?id=629933
    Reported-by: Brian Bloniarz <phunge0@hotmail.com>
    Reported-and-tested-by: Stefan Becker <chemobejk@gmail.com>
    Reported-by: Denys Vlasenko <dvlasenk@redhat.com>
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c
index 7f0af0e9b826..172bf26e0680 100644
--- a/drivers/pci/bus.c
+++ b/drivers/pci/bus.c
@@ -64,6 +64,49 @@ void pci_bus_remove_resources(struct pci_bus *bus)
 	}
 }
 
+/*
+ * Find the highest-address bus resource below the cursor "res".  If the
+ * cursor is NULL, return the highest resource.
+ */
+static struct resource *pci_bus_find_resource_prev(struct pci_bus *bus,
+						   unsigned int type,
+						   struct resource *res)
+{
+	struct resource *r, *prev = NULL;
+	int i;
+
+	pci_bus_for_each_resource(bus, r, i) {
+		if (!r)
+			continue;
+
+		if ((r->flags & IORESOURCE_TYPE_BITS) != type)
+			continue;
+
+		/* If this resource is at or past the cursor, skip it */
+		if (res) {
+			if (r == res)
+				continue;
+			if (r->end > res->end)
+				continue;
+			if (r->end == res->end && r->start > res->start)
+				continue;
+		}
+
+		if (!prev)
+			prev = r;
+
+		/*
+		 * A small resource is higher than a large one that ends at
+		 * the same address.
+		 */
+		if (r->end > prev->end ||
+		    (r->end == prev->end && r->start > prev->start))
+			prev = r;
+	}
+
+	return prev;
+}
+
 /**
  * pci_bus_alloc_resource - allocate a resource from a parent bus
  * @bus: PCI bus
@@ -89,9 +132,10 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 					  resource_size_t),
 		void *alignf_data)
 {
-	int i, ret = -ENOMEM;
+	int ret = -ENOMEM;
 	struct resource *r;
 	resource_size_t max = -1;
+	unsigned int type = res->flags & IORESOURCE_TYPE_BITS;
 
 	type_mask |= IORESOURCE_IO | IORESOURCE_MEM;
 
@@ -99,10 +143,9 @@ pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
 	if (!(res->flags & IORESOURCE_MEM_64))
 		max = PCIBIOS_MAX_MEM_32;
 
-	pci_bus_for_each_resource(bus, r, i) {
-		if (!r)
-			continue;
-
+	/* Look for space at highest addresses first */
+	r = pci_bus_find_resource_prev(bus, type, NULL);
+	for ( ; r; r = pci_bus_find_resource_prev(bus, type, r)) {
 		/* type_mask must match */
 		if ((res->flags ^ r->flags) & type_mask)
 			continue;

