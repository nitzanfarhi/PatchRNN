commit 276c252dc637329f8ecd2a769d8fc53d719ba6f0
Author: bluhm <bluhm@openbsd.org>
Date:   Sun Aug 7 15:18:40 2011 +0000

    When checking wether a prefix belongs to an interface, also allow
    the route to be at the corresponding carp or physical interface or
    at an interface belonging to a common bridge.  This fixes IPv6
    neighbor discovery with carp.
    bug report and tested by Florian Fuessl
    put it in deraadt@

diff --git a/sys/netinet6/in6.c b/sys/netinet6/in6.c
index 12d7026d48d..6e977f8bce3 100644
--- a/sys/netinet6/in6.c
+++ b/sys/netinet6/in6.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: in6.c,v 1.91 2011/07/26 21:19:51 bluhm Exp $	*/
+/*	$OpenBSD: in6.c,v 1.92 2011/08/07 15:18:40 bluhm Exp $	*/
 /*	$KAME: in6.c,v 1.372 2004/06/14 08:14:21 itojun Exp $	*/
 
 /*
@@ -61,6 +61,9 @@
  *	@(#)in.c	8.2 (Berkeley) 11/15/93
  */
 
+#include "bridge.h"
+#include "carp.h"
+
 #include <sys/param.h>
 #include <sys/ioctl.h>
 #include <sys/errno.h>
@@ -1945,7 +1948,16 @@ in6_ifpprefix(const struct ifnet *ifp, const struct in6_addr *addr)
 	if (rt == NULL)
 		return (0);
 	if ((rt->rt_flags & (RTF_CLONING | RTF_CLONED)) == 0 ||
-	    rt->rt_ifp != ifp) {
+	    (rt->rt_ifp != ifp &&
+#if NBRIDGE > 0
+	    (rt->rt_ifp->if_bridge == NULL || ifp->if_bridge == NULL ||
+	    rt->rt_ifp->if_bridge != ifp->if_bridge) &&
+#endif
+#if NCARP > 0
+	    (ifp->if_type != IFT_CARP || rt->rt_ifp != ifp->if_carpdev) &&
+	    (rt->rt_ifp->if_type != IFT_CARP || rt->rt_ifp->if_carpdev != ifp)&&
+#endif
+	    1)) {
 		RTFREE(rt);
 		return (0);
 	}

