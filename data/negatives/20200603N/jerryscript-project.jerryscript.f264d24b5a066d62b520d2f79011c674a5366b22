commit f264d24b5a066d62b520d2f79011c674a5366b22
Author: Ilmir Usmanov <i.usmanov@samsung.com>
Date:   Wed Jul 23 17:36:11 2014 +0400

    Rewrite serializer and lexer: adjust nums' ids, dump strings, nums and rewrites

diff --git a/src/libjsparser/lexer.c b/src/libjsparser/lexer.c
index 50e07c03..9b17d8db 100644
--- a/src/libjsparser/lexer.c
+++ b/src/libjsparser/lexer.c
@@ -88,7 +88,7 @@ num_and_token;
 #define MAX_NAMES 100
 #define MAX_NUMS 25
 
-static string_and_token seen_names[MAX_NAMES];
+static string_and_token seen_names[MAX_NUMS];
 static uint8_t seen_names_count = 0;
 
 static num_and_token seen_nums[MAX_NAMES] = 
@@ -254,17 +254,21 @@ uint8_t
 lexer_get_strings (const char **strings)
 {
   if (strings)
-  {
-    int i;
-    for (i = 0; i < seen_names_count; i++)
     {
-      strings[i] = seen_names[i].str;
+      int i;
+      for (i = 0; i < seen_names_count; i++)
+        strings[i] = seen_names[i].str;
     }
-  }
 
   return seen_names_count;
 }
 
+uint8_t
+lexer_get_reserved_ids_count (void)
+{
+  return (uint8_t) (seen_names_count + seen_nums_count);
+}
+
 const char *
 lexer_get_string_by_id (uint8_t id)
 {
@@ -278,14 +282,31 @@ lexer_get_nums (int *nums)
 {
   int i;
 
+  if (!nums)
+    return seen_nums_count;
+
   for (i = 0; i < seen_nums_count; i++)
-  {
     nums[i] = seen_nums[i].num;
-  }
 
   return seen_nums_count;
 }
 
+void
+lexer_adjust_num_ids (void)
+{
+  size_t i;
+
+  for (i = 0; i < seen_nums_count; i++)
+    seen_nums[i].tok.data.uid = (uint8_t) (seen_nums[i].tok.data.uid + seen_names_count);
+
+  for (i = 0; i < sizeof (keyword_tokens) / sizeof (string_and_token); i++)
+    {
+      if (!__strncmp ("true", keyword_tokens[i].str, 4)
+          || !__strncmp ("false", keyword_tokens[i].str, 5))
+        keyword_tokens[i].tok.data.uid = (uint8_t) (keyword_tokens[i].tok.data.uid + seen_names_count);
+    }
+}
+
 static void
 new_token (void)
 {
diff --git a/src/libjsparser/lexer.h b/src/libjsparser/lexer.h
index 8868c2a4..bbc10b9c 100644
--- a/src/libjsparser/lexer.h
+++ b/src/libjsparser/lexer.h
@@ -156,7 +156,9 @@ token lexer_next_token (void);
 void lexer_save_token (token);
 void lexer_dump_buffer_state (void);
 uint8_t lexer_get_strings (const char **);
+uint8_t lexer_get_reserved_ids_count (void);
 const char *lexer_get_string_by_id (uint8_t);
 uint8_t lexer_get_nums (int *);
+void lexer_adjust_num_ids (void);
 
 #endif
diff --git a/src/libjsparser/parser.c b/src/libjsparser/parser.c
index cb558d7b..b7819790 100644
--- a/src/libjsparser/parser.c
+++ b/src/libjsparser/parser.c
@@ -130,19 +130,19 @@ insert_semicolon (void)
   do { skip_newlines (); ID = parse_##TYPE (); } while (0)
 
 #define DUMP_VOID_OPCODE(GETOP) \
-  do { opcode=getop_##GETOP (); serializer_dump_data (&opcode, sizeof (OPCODE)); opcode_counter++; } while (0)
+  do { opcode=getop_##GETOP (); serializer_dump_opcode (&opcode); opcode_counter++; } while (0)
 
 #define DUMP_OPCODE(GETOP, ...) \
-  do { opcode=getop_##GETOP (__VA_ARGS__); serializer_dump_data (&opcode, sizeof (OPCODE)); opcode_counter++; } while (0)
+  do { opcode=getop_##GETOP (__VA_ARGS__); serializer_dump_opcode (&opcode); opcode_counter++; } while (0)
 
 #define REWRITE_OPCODE(OC, GETOP, ...) \
-  do { opcode=getop_##GETOP (__VA_ARGS__); serializer_rewrite_data ((int8_t) (OC - opcode_counter), &opcode, sizeof (OPCODE)); } while (0)
+  do { opcode=getop_##GETOP (__VA_ARGS__); serializer_rewrite_opcode ((int8_t) (OC - opcode_counter), &opcode); } while (0)
 
 static T_IDX
 integer_zero (void)
 {
   T_IDX lhs = next_temp_name ();
-  DUMP_OPCODE (assignment, lhs, OPCODE_ARG_TYPE_NUMBER, 0);
+  DUMP_OPCODE (assignment, lhs, OPCODE_ARG_TYPE_SMALLINT, 0);
   return lhs;
 }
 
@@ -150,7 +150,7 @@ static T_IDX
 integer_one (void)
 {
   T_IDX lhs = next_temp_name ();
-  DUMP_OPCODE (assignment, lhs, OPCODE_ARG_TYPE_NUMBER, 1);
+  DUMP_OPCODE (assignment, lhs, OPCODE_ARG_TYPE_SMALLINT, 1);
   return lhs;
 }
 
@@ -167,7 +167,7 @@ dump_saved_opcodes (void)
 {
   uint8_t i;
   for (i = 0; i < current_opcode_in_buffer; i++)
-    serializer_dump_data (&opcodes_buffer[i], sizeof (OPCODE));
+    serializer_dump_opcode (&opcodes_buffer[i]);
   current_opcode_in_buffer = 0;
 }
 
@@ -1805,12 +1805,13 @@ parser_parse_program (void)
 
   skip_newlines ();
   JERRY_ASSERT (tok.type == TOK_EOF);
+  DUMP_OPCODE (exitval, 0);
 }
 
 void
 parser_init (void)
 {
-  temp_name = min_temp_name = lexer_get_strings (NULL);
+  temp_name = min_temp_name = lexer_get_reserved_ids_count ();
 #ifdef __HOST
   debug_file = __fopen ("parser.log", "w");
 #endif
diff --git a/src/libruntime/serializer.h b/src/libruntime/serializer.h
index 5a5314b0..4802c139 100644
--- a/src/libruntime/serializer.h
+++ b/src/libruntime/serializer.h
@@ -20,8 +20,12 @@
 
 void serializer_init (void);
 
-void serializer_dump_data (const void *, size_t);
+uint8_t serializer_dump_strings (const char **, uint8_t);
 
-void serializer_rewrite_data (const int8_t, const void *, size_t);
+void serializer_dump_nums (const int *, uint8_t, uint8_t, uint8_t);
+
+void serializer_dump_opcode (const void *);
+
+void serializer_rewrite_opcode (const int8_t, const void *);
 
 #endif // SERIALIZER_H
\ No newline at end of file
diff --git a/src/libruntime/target/linux/serializer.c b/src/libruntime/target/linux/serializer.c
index 5c176f16..782d6ad7 100644
--- a/src/libruntime/target/linux/serializer.c
+++ b/src/libruntime/target/linux/serializer.c
@@ -32,22 +32,58 @@ serializer_init (void)
 {
 }
 
+uint8_t
+serializer_dump_strings (const char *strings[], uint8_t size)
+{
+  uint8_t i;
+  uint8_t offset = size;
+
+  __printf ("STRINGS %d:\n", size);
+  for (i = 0; i < size; i++)
+    {
+      __printf ("%3d %3d %20s\n", i, offset, strings[i]);
+      offset = (uint8_t ) (offset + __strlen (strings[i]));
+    }
+
+  return offset;
+}
+
+void 
+serializer_dump_nums (const int nums[], uint8_t size, uint8_t offset, uint8_t strings_num)
+{
+  uint8_t i;
+
+  offset = (uint8_t) (offset + size);
+  __printf ("NUMS %d:\n", size);
+  for (i = 0; i < size; i++)
+    {
+      __printf ("%3d %3d %7d\n", i + strings_num, offset, nums[i]);
+      offset = (uint8_t) (offset + 4);
+    }
+}
+
 static int opcode_counter = 0;
 
 void
-serializer_dump_data (const void *data, size_t size)
+serializer_dump_opcode (const void *opcode)
 {
-  size_t i;
+  uint8_t i;
 
-  __printf ("%03d: %20s ", opcode_counter++, massive[(int)((char*)data)[0]]);
-  for (i = 1; i < size; i++)
-    __printf ("%4d ", ((char*)data)[i]);
+  __printf ("%03d: %20s ", opcode_counter++, massive[(int)((char*)opcode)[0]]);
+  for (i = 1; i < 4; i++)
+    __printf ("%4d ", ((char*)opcode)[i]);
 
   __printf ("\n");
 }
 
 void
-serializer_rewrite_data (const int8_t offset __unused, const void *data __unused, size_t size __unused)
+serializer_rewrite_opcode (const int8_t offset, const void *opcode)
 {
-  TODO (implement);
-}
\ No newline at end of file
+  uint8_t i;
+
+  __printf ("%03d: %20s ", opcode_counter + offset, massive[(int)((char*)opcode)[0]]);
+  for (i = 1; i < 4; i++)
+    __printf ("%4d ", ((char*)opcode)[i]);
+
+  __printf ("// REWRITE\n");
+}
diff --git a/src/libruntime/target/stm32f4/serializer.c b/src/libruntime/target/stm32f4/serializer.c
index 88d7bd20..3e707287 100644
--- a/src/libruntime/target/stm32f4/serializer.c
+++ b/src/libruntime/target/stm32f4/serializer.c
@@ -21,9 +21,25 @@ serializer_init (void)
 {
 }
 
+uint8_t
+serializer_dump_strings (const char *strings[] __unused, uint8_t size __unused)
+{
+}
+
+void 
+serializer_dump_nums (const int nums[] __unused, uint8_t size __unused, uint8_t offset __unused, uint8_t strings_num __unused)
+{
+}
+
 void
-serializer_dump_data (const void *data __unused, size_t size __unused)
+serializer_dump_opcode (const void *opcode __unused)
 {
 }
 
+void
+serializer_rewrite_opcode (const int8_t offset __unused, const void *opcode __unused)
+{
+}
+
+
 TODO (Dump memory)
\ No newline at end of file
diff --git a/src/main.c b/src/main.c
index e944ff09..a3e5a2ec 100644
--- a/src/main.c
+++ b/src/main.c
@@ -35,12 +35,10 @@
 #include "jerry-libc.h"
 #include "lexer.h"
 #include "parser.h"
-
-#define DUMP_TOKENS   (1u << 0)
-#define DUMP_AST      (1u << 1)
-#define DUMP_BYTECODE (1u << 2)
+#include "serializer.h"
 
 #define MAX_STRINGS 100
+#define MAX_NUMS 25
 
 void fake_exit (void);
 
@@ -104,6 +102,9 @@ main (int argc, char **argv)
   const char *file_name = NULL;
   FILE *file = NULL;
 #endif
+  const char *strings[MAX_STRINGS];
+  int nums[MAX_NUMS];
+  uint8_t strings_num, nums_count, offset;
 
   mem_init ();
 
@@ -133,14 +134,14 @@ main (int argc, char **argv)
   lexer_set_source (generated_source);
 #endif
 
-  // const char *strings[MAX_STRINGS];
-  // uint8_t strings_num;
   // First run parser to fill list of strings
   token tok = lexer_next_token ();
   while (tok.type != TOK_EOF)
     tok = lexer_next_token ();
 
-  // strings_num = lexer_get_strings (strings);
+  strings_num = lexer_get_strings (strings);
+  nums_count = lexer_get_nums (nums);
+  lexer_adjust_num_ids ();
 
   // Reset lexer
 #ifdef __HOST
@@ -151,13 +152,10 @@ main (int argc, char **argv)
 #endif
 
   parser_init ();
-  TODO (serializer_dump_data (strings strings_num));
+  offset = serializer_dump_strings (strings, strings_num);
+  serializer_dump_nums (nums, nums_count, offset, strings_num);
   parser_parse_program ();
 
-  //gen_bytecode (generated_source);
-  //gen_bytecode ();
-  //run_int ();
-
 #ifdef __TARGET_MCU
   fake_exit ();
 #endif 

