commit 59b98545e885a4833d915fe0dce28be9f05de46d
Author: Jani Taskinen <jani@php.net>
Date:   Sun Aug 3 12:11:13 2008 +0000

    MFH

diff --git a/ext/exif/exif.c b/ext/exif/exif.c
index b2d9811a94..cba20b899c 100644
--- a/ext/exif/exif.c
+++ b/ext/exif/exif.c
@@ -2862,11 +2862,9 @@ static int exif_process_IFD_TAG(image_info_type *ImageInfo, char *dir_entry, cha
 		/* If its bigger than 4 bytes, the dir entry contains an offset. */
 		value_ptr = offset_base+offset_val;
 		if (offset_val+byte_count > IFDlength || value_ptr < dir_entry) {
-			/*
-			// It is important to check for IMAGE_FILETYPE_TIFF
-			// JPEG does not use absolute pointers instead its pointers are relative to the start
-			// of the TIFF header in APP1 section.
-			*/
+			/* It is important to check for IMAGE_FILETYPE_TIFF
+			 * JPEG does not use absolute pointers instead its pointers are
+			 * relative to the start of the TIFF header in APP1 section. */
 			if (offset_val+byte_count>ImageInfo->FileSize || (ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_II && ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_MM && ImageInfo->FileType!=IMAGE_FILETYPE_JPEG)) {
 				if (value_ptr < dir_entry) {
 					/* we can read this if offset_val > 0 */
@@ -2884,13 +2882,11 @@ static int exif_process_IFD_TAG(image_info_type *ImageInfo, char *dir_entry, cha
 				value_ptr = safe_emalloc(byte_count, 1, 0);
 				outside = value_ptr;
 			} else {
-				/*
-				// in most cases we only access a small range so
-				// it is faster to use a static buffer there
-				// BUT it offers also the possibility to have
-				// pointers read without the need to free them
-				// explicitley before returning.
-				*/
+				/* In most cases we only access a small range so
+				 * it is faster to use a static buffer there
+				 * BUT it offers also the possibility to have
+				 * pointers read without the need to free them
+				 * explicitley before returning. */
 				memset(&cbuf, 0, sizeof(cbuf));
 				value_ptr = cbuf;
 			}

