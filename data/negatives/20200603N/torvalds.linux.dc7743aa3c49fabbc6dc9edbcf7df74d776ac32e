commit dc7743aa3c49fabbc6dc9edbcf7df74d776ac32e
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Oct 2 21:39:40 2013 -0700

    pinctrl: single: Add support for auxdata
    
    For omaps, we still have dependencies to the legacy code
    for handling the PRM (Power Reset Management) interrupts,
    and also for reconfiguring the io wake-up chain after
    changes.
    
    Let's pass the PRM interrupt and the rearm functions via
    auxdata. Then when at some point we have a proper PRM
    driver, we can get the interrupt via device tree and
    set up the rearm function as exported function in the
    PRM driver.
    
    By using auxdata we can remove a dependency to the
    wake-up events for converting omap3 to be device
    tree only.
    
    Cc: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Prakash Manjunathappa <prakash.pm@ti.com>
    Cc: Roger Quadros <rogerq@ti.com>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Cc: linux-kernel@vger.kernel.org
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/pinctrl/pinctrl-single.c b/drivers/pinctrl/pinctrl-single.c
index dad65df36f4b..c2aada71c915 100644
--- a/drivers/pinctrl/pinctrl-single.c
+++ b/drivers/pinctrl/pinctrl-single.c
@@ -28,6 +28,8 @@
 #include <linux/pinctrl/pinmux.h>
 #include <linux/pinctrl/pinconf-generic.h>
 
+#include <linux/platform_data/pinctrl-single.h>
+
 #include "core.h"
 #include "pinconf.h"
 
@@ -159,12 +161,14 @@ struct pcs_name {
  * @irq:	optional interrupt for the controller
  * @irq_enable_mask:	optional SoC specific interrupt enable mask
  * @irq_status_mask:	optional SoC specific interrupt status mask
+ * @rearm:	optional SoC specific wake-up rearm function
  */
 struct pcs_soc_data {
 	unsigned flags;
 	int irq;
 	unsigned irq_enable_mask;
 	unsigned irq_status_mask;
+	void (*rearm)(void);
 };
 
 /**
@@ -1622,6 +1626,8 @@ static void pcs_irq_unmask(struct irq_data *d)
 	struct pcs_soc_data *pcs_soc = irq_data_get_irq_chip_data(d);
 
 	pcs_irq_set(pcs_soc, d->irq, true);
+	if (pcs_soc->rearm)
+		pcs_soc->rearm();
 }
 
 /**
@@ -1672,6 +1678,11 @@ static int pcs_irq_handle(struct pcs_soc_data *pcs_soc)
 		}
 	}
 
+	/*
+	 * For debugging on omaps, you may want to call pcs_soc->rearm()
+	 * here to see wake-up interrupts during runtime also.
+	 */
+
 	return count;
 }
 
@@ -1835,6 +1846,7 @@ static int pcs_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
 	const struct of_device_id *match;
+	struct pcs_pdata *pdata;
 	struct resource *res;
 	struct pcs_device *pcs;
 	const struct pcs_soc_data *soc;
@@ -1949,6 +1961,17 @@ static int pcs_probe(struct platform_device *pdev)
 	if (pcs->socdata.irq)
 		pcs->flags |= PCS_FEAT_IRQ;
 
+	/* We still need auxdata for some omaps for PRM interrupts */
+	pdata = dev_get_platdata(&pdev->dev);
+	if (pdata) {
+		if (pdata->rearm)
+			pcs->socdata.rearm = pdata->rearm;
+		if (pdata->irq) {
+			pcs->socdata.irq = pdata->irq;
+			pcs->flags |= PCS_FEAT_IRQ;
+		}
+	}
+
 	if (PCS_HAS_IRQ) {
 		ret = pcs_irq_init_chained_handler(pcs, np);
 		if (ret < 0)
diff --git a/include/linux/platform_data/pinctrl-single.h b/include/linux/platform_data/pinctrl-single.h
new file mode 100644
index 000000000000..72eacda9b360
--- /dev/null
+++ b/include/linux/platform_data/pinctrl-single.h
@@ -0,0 +1,12 @@
+/**
+ * irq:		optional wake-up interrupt
+ * rearm:	optional soc specific rearm function
+ *
+ * Note that the irq and rearm setup should come from device
+ * tree except for omap where there are still some dependencies
+ * to the legacy PRM code.
+ */
+struct pcs_pdata {
+	int irq;
+	void (*rearm)(void);
+};

