commit 6208f57f487ac170df24a9018f1cc87a5ac8b4b3
Author: Sage Weil <sage@newdream.net>
Date:   Tue Mar 31 13:19:25 2009 -0700

    caps: track last_issue seq, check on release

diff --git a/src/kernel/caps.c b/src/kernel/caps.c
index 584b0a1181..6eba6ffff9 100644
--- a/src/kernel/caps.c
+++ b/src/kernel/caps.c
@@ -312,6 +312,7 @@ retry:
 	cap->implemented |= issued;
 	cap->mds_wanted |= wanted;
 	cap->seq = seq;
+	cap->issue_seq = seq;
 	cap->mseq = mseq;
 	cap->gen = session->s_cap_gen;
 
@@ -577,7 +578,7 @@ void ceph_queue_caps_release(struct inode *inode)
 		item->ino = cpu_to_le64(ceph_ino(inode));
 		item->cap_id = cpu_to_le64(cap->cap_id);
 		item->migrate_seq = cpu_to_le32(cap->mseq);
-		item->seq = cpu_to_le32(cap->seq);
+		item->seq = cpu_to_le32(cap->issue_seq);
 
 		session->s_num_cap_releases--;
 
@@ -1756,7 +1757,7 @@ void ceph_handle_caps(struct ceph_mds_client *mdsc,
 	     inode);
 	if (!inode) {
 		dout(10, " i don't have ino %llx, sending release\n", vino.ino);
-		goto release;
+		goto done;
 	}
 
 	/* these will work even if we don't have a cap yet */
@@ -1790,7 +1791,7 @@ void ceph_handle_caps(struct ceph_mds_client *mdsc,
 		dout(10, "no cap on %p ino %llx.%llx from mds%d, releasing\n",
 		     inode, ceph_ino(inode), ceph_snap(inode), mds);
 		spin_unlock(&inode->i_lock);
-		goto release;
+		goto done;
 	}
 	
 	/* note that each of these drops i_lock for us */
@@ -1835,15 +1836,6 @@ done:
 bad:
 	derr(10, "corrupt caps message\n");
 	return;
-
-release:
-	send_cap_msg(mdsc, vino.ino, cap_id, CEPH_CAP_OP_RELEASE,
-		     0, 0, 0,
-		     seq, 0,
-		     size, 0, NULL, NULL, 0,
-		     0, 0, 0,
-		     0, mds);
-	goto done;
 }
 
 /*
diff --git a/src/kernel/super.h b/src/kernel/super.h
index e0085de792..a89ddc25b2 100644
--- a/src/kernel/super.h
+++ b/src/kernel/super.h
@@ -153,7 +153,7 @@ struct ceph_cap {
 	int implemented;  /* implemented superset of issued (for revocation) */
 	int flushing;     /* dirty fields being written back to mds */
 	int mds_wanted;
-	u32 seq, mseq, gen;
+	u32 seq, issue_seq, mseq, gen;
 	unsigned long last_used;
 };
 
diff --git a/src/mds/CInode.cc b/src/mds/CInode.cc
index b234c44e3e..20029d9852 100644
--- a/src/mds/CInode.cc
+++ b/src/mds/CInode.cc
@@ -1475,6 +1475,7 @@ bool CInode::encode_inodestat(bufferlist& bl, Session *session,
       int issue = (cap->wanted() | likes) & allowed;
       cap->issue_norevoke(issue);
       issue = cap->pending();
+      cap->set_last_issue();
       cap->set_last_issue_stamp(g_clock.recent_now());
       cap->touch();   // move to back of session cap LRU
       e.cap.caps = issue;
diff --git a/src/mds/Capability.h b/src/mds/Capability.h
index ff2cba388c..8e3617c49c 100644
--- a/src/mds/Capability.h
+++ b/src/mds/Capability.h
@@ -105,35 +105,7 @@ private:
   utime_t last_issue_stamp;
 
 
-  // simplest --------------------------
-#if 0
-  __u32 _pending;
-  __u32 _issued;
-
-public:
-  int pending() {
-    return _pending;
-  }
-  int issued() {
-    return _pending | _issued;
-  }
-  ceph_seq_t issue(int c) {
-    _pending = c;
-    _issued |= c;
-    //last_issue = 
-    ++last_sent;
-    return last_sent;
-  }
-  void confirm_receipt(ceph_seq_t seq, int caps) {
-    if (seq == last_sent)
-      _pending = _issued = caps;
-  }    
-  bool is_null() { rinclude/eturn !_issued && !_pending; }
-#endif
-
-
   // track up to N revocations ---------
-#if 1
   static const int _max_revoke = 3;
   __u32 _pending, _issued;
   __u32 _revoke_before[_max_revoke];  // caps before this issue
@@ -197,12 +169,10 @@ public:
   bool is_null() {
     return !_pending && !_issued && !_num_revoke;
   }
-#endif
-
 
 private:
   ceph_seq_t last_sent;
-  //ceph_seq_t last_issue;
+  ceph_seq_t last_issue;
   ceph_seq_t mseq;
 
   int suppress;
@@ -243,6 +213,7 @@ public:
     return false;
   }
 
+  void set_last_issue() { last_issue = last_sent; }
   void set_last_issue_stamp(utime_t t) { last_issue_stamp = t; }
 
   __u64 get_cap_id() { return cap_id; }
@@ -271,6 +242,7 @@ public:
   }
 
   ceph_seq_t get_last_seq() { return last_sent; }
+  ceph_seq_t get_last_issue() { return last_issue; }
 
   bool is_rdcap() {
     return rdcaps_item.is_on_xlist();
diff --git a/src/mds/Locker.cc b/src/mds/Locker.cc
index 57af31576e..ef5939991c 100644
--- a/src/mds/Locker.cc
+++ b/src/mds/Locker.cc
@@ -1739,8 +1739,8 @@ void Locker::handle_client_cap_release(MClientCapRelease *m)
 	      << " on " << *in << dendl;
       continue;
     }
-    if (p->seq != cap->get_last_sent()) {
-      dout(10) << " seq " << p->seq << " != " << cap->get_last_seq() << " on " << *in << dendl;
+    if (p->seq != cap->get_last_issue()) {
+      dout(10) << " seq " << p->seq << " != " << cap->get_last_issue() << " on " << *in << dendl;
       continue;
     }
 
diff --git a/src/mds/MDCache.cc b/src/mds/MDCache.cc
index 7cbc3273a6..9918d7d166 100644
--- a/src/mds/MDCache.cc
+++ b/src/mds/MDCache.cc
@@ -3907,6 +3907,7 @@ void MDCache::do_cap_import(Session *session, CInode *in, Capability *cap)
   SnapRealm *realm = in->find_snaprealm();
   if (realm->have_past_parents_open()) {
     dout(10) << "do_cap_import " << session->inst.name << " mseq " << cap->get_mseq() << " on " << *in << dendl;
+    cap->set_last_issue();
     MClientCaps *reap = new MClientCaps(CEPH_CAP_OP_IMPORT,
 					in->ino(),
 					realm->inode->ino(),

