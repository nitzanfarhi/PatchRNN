commit 76f73ca1b291a8d014ff0d2d802c817404dd9887
Author: Jarod Wilson <jwilson@redhat.com>
Date:   Mon Apr 7 22:32:33 2008 +0200

    firewire: fw-ohci: don't append to AT context when it's not active
    
    I finally tracked down the issues with this JMicron PCI-e card in my
    possession to a failure to comply with section 7.2.3.2 of the OHCI 1.1
    specification (thanks to Kristian for the pointer to illustrate that it
    is indeed a flaw in this card, not the driver). The controller should
    simply flush the packets we've appended to its AT queue if a bus reset
    occurs before they've been transmitted and we'll try again, but
    something goes wrong and the controller winds up hung.
    
    However, we can avoid the problem by simply checking if the
    IntEvent.busReset register had been set before we try appending to the
    AT context. When busReset is set, the AT context is completely halted
    until busReset is cleared, so there's no point in appending AT packets
    until the register is cleared. So at_context_queue_packet() now checks
    for busReset being set, and bails with an RCODE_GENERATION packet ack,
    which results in us trying to append the packet again after recognizing
    the fact there has been a bus reset, and clearing busReset.
    
    Signed-off-by: Jarod Wilson <jwilson@redhat.com>
    Signed-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>

diff --git a/drivers/firewire/fw-ohci.c b/drivers/firewire/fw-ohci.c
index ce18bab3f9d5..4789300b8241 100644
--- a/drivers/firewire/fw-ohci.c
+++ b/drivers/firewire/fw-ohci.c
@@ -950,8 +950,19 @@ at_context_queue_packet(struct context *ctx, struct fw_packet *packet)
 				     DESCRIPTOR_IRQ_ALWAYS |
 				     DESCRIPTOR_BRANCH_ALWAYS);
 
-	/* FIXME: Document how the locking works. */
-	if (ohci->generation != packet->generation) {
+	/*
+	 * If the controller and packet generations don't match, we need to
+	 * bail out and try again.  If IntEvent.busReset is set, the AT context
+	 * is halted, so appending to the context and trying to run it is
+	 * futile.  Most controllers do the right thing and just flush the AT
+	 * queue (per section 7.2.3.2 of the OHCI 1.1 specification), but
+	 * some controllers (like a JMicron JMB381 PCI-e) misbehave and wind
+	 * up stalling out.  So we just bail out in software and try again
+	 * later, and everyone is happy.
+	 * FIXME: Document how the locking works.
+	 */
+	if (ohci->generation != packet->generation ||
+	    reg_read(ohci, OHCI1394_IntEventSet) & OHCI1394_busReset) {
 		if (packet->payload_length > 0)
 			dma_unmap_single(ohci->card.device, payload_bus,
 					 packet->payload_length, DMA_TO_DEVICE);

