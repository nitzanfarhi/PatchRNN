commit e9c3215b776b07faeb5184249fc0e43876f26723
Author: dexX7 <ugithub@bitwatch.co>
Date:   Fri Dec 19 06:59:16 2014 +0100

    [Wallet] sort pending wallet transactions before reaccepting
    
    During startup, when adding pending wallet transactions, which spend outputs of
    other pending wallet transactions, back to the memory pool, and when they are
    added out of order, it appears as if they are orphans with missing inputs.
    
    Those transactions are then rejected and flagged as "conflicting" (= not in the
    memory pool, not in the block chain).
    
    To prevent this, transactions are explicitly sorted.

diff --git a/src/wallet/wallet.cpp b/src/wallet/wallet.cpp
index 44b416d49..207bb8c97 100644
--- a/src/wallet/wallet.cpp
+++ b/src/wallet/wallet.cpp
@@ -1028,6 +1028,9 @@ int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)
 void CWallet::ReacceptWalletTransactions()
 {
     LOCK2(cs_main, cs_wallet);
+    std::map<int64_t, CWalletTx*> mapSorted;
+
+    // Sort pending wallet transactions based on their initial wallet insertion order
     BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)
     {
         const uint256& wtxid = item.first;
@@ -1036,13 +1039,19 @@ void CWallet::ReacceptWalletTransactions()
 
         int nDepth = wtx.GetDepthInMainChain();
 
-        if (!wtx.IsCoinBase() && nDepth < 0)
-        {
-            // Try to add to memory pool
-            LOCK(mempool.cs);
-            wtx.AcceptToMemoryPool(false);
+        if (!wtx.IsCoinBase() && nDepth < 0) {
+            mapSorted.insert(std::make_pair(wtx.nOrderPos, &wtx));
         }
     }
+
+    // Try to add wallet transactions to memory pool
+    BOOST_FOREACH(PAIRTYPE(const int64_t, CWalletTx*)& item, mapSorted)
+    {
+        CWalletTx& wtx = *(item.second);
+
+        LOCK(mempool.cs);
+        wtx.AcceptToMemoryPool(false);
+    }
 }
 
 void CWalletTx::RelayWalletTransaction()

