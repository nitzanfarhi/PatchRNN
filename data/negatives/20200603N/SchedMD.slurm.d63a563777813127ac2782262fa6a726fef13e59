commit d63a563777813127ac2782262fa6a726fef13e59
Author: Moe Jette <jette1@llnl.gov>
Date:   Thu Oct 31 18:03:55 2002 +0000

    Add new function to explicitly open primary or secondary slurmctld connection
    (so shutdown command can shutdown both servers).

diff --git a/src/common/slurm_protocol_api.c b/src/common/slurm_protocol_api.c
index 91b2d1a999..cecce44fd4 100644
--- a/src/common/slurm_protocol_api.c
+++ b/src/common/slurm_protocol_api.c
@@ -278,8 +278,7 @@ slurm_fd slurm_open_msg_conn(slurm_addr * slurm_address)
 	return _slurm_open_msg_conn(slurm_address);
 }
 
-/* calls connect to make a connection-less datagram connection to the the primary or secondary slurmctld message engine
- * slurm_address 	- for now it is really just a sockaddr_in
+/* calls connect to make a connection-less datagram connection to the primary or secondary slurmctld message engine
  * int			- the return code
  */
 slurm_fd slurm_open_controller_conn()
@@ -301,6 +300,33 @@ slurm_fd slurm_open_controller_conn()
 	return connection_fd;
 }
 
+/* calls connect to make a connection-less datagram connection to the primary or secondary slurmctld message engine
+ * dest 	- controller to contact, 1=primary, 2=secondary
+ * int		- the return code
+ */
+slurm_fd slurm_open_controller_conn_spec (enum controller_id dest)
+{
+	slurm_fd connection_fd;
+	slurm_api_set_default_config();
+
+	if (dest == PRIMARY_CONTROLLER) {
+		if ((connection_fd =
+		     slurm_open_msg_conn(&proto_conf->primary_controller)) ==
+		    SLURM_SOCKET_ERROR)
+			debug("Open connection to primary controller failed: %m");
+	} else if (slurmctld_conf.backup_controller) {
+		if ((connection_fd =
+		     slurm_open_msg_conn(&proto_conf->secondary_controller)) ==
+		    SLURM_SOCKET_ERROR)
+			debug("Open connection to secondary controller failed: %m");
+	} else {
+		debug("No secondary controller to contact");
+		connection_fd = SLURM_SOCKET_ERROR;
+	}
+
+	return connection_fd;
+}
+
 /* In the bsd implmentation maps directly to a accept call 
  * In the mongo it returns the open_fd and is essentially a no-op function call
  * open_fd		- file descriptor to accept connection on
diff --git a/src/common/slurm_protocol_api.h b/src/common/slurm_protocol_api.h
index 233364fb63..4805586193 100644
--- a/src/common/slurm_protocol_api.h
+++ b/src/common/slurm_protocol_api.h
@@ -23,6 +23,10 @@
 #include <src/common/slurm_protocol_defs.h>
 #include <src/common/slurm_errno.h>
 
+enum controller_id {
+PRIMARY_CONTROLLER   = 1,
+SECONDARY_CONTROLLER = 2 };
+
 /*****************************/
 /* configuration functions   */
 /*****************************/
@@ -142,10 +146,13 @@ int slurm_send_node_msg ( slurm_fd open_fd , slurm_msg_t * msg ) ;
 /* msg connection establishment functions used by msg clients         */
 /**********************************************************************/
 
-/* calls connect to make a connection-less datagram connection to the the primary or secondary slurmctld message engine
- * RET slurm_fd		- file descriptor of the connection created
+/* calls connect to make a connection-less datagram connection to the primary or 
+ * secondary slurmctld message engine
+ * RET slurm_fd	- file descriptor of the connection created
+ * dest 	- controller to contact, primary or secondary
  */
 slurm_fd inline slurm_open_controller_conn ( ) ;
+slurm_fd inline slurm_open_controller_conn_spec ( enum controller_id dest ) ;
 
 /* In the bsd socket implementation it creates a SOCK_STREAM socket and calls connect on it
  * In the mongo implementation it creates a SOCK_DGRAM socket and calls connect on it
diff --git a/src/common/slurm_protocol_defs.h b/src/common/slurm_protocol_defs.h
index 38d241ee89..247ca10884 100644
--- a/src/common/slurm_protocol_defs.h
+++ b/src/common/slurm_protocol_defs.h
@@ -109,6 +109,7 @@ typedef enum {
 	REQUEST_SHUTDOWN_IMMEDIATE,
 	RESPONSE_SHUTDOWN,
 	REQUEST_PING,
+	REQUEST_CONTROL,
 
 	REQUEST_BUILD_INFO = 2001,
 	RESPONSE_BUILD_INFO,
diff --git a/src/common/slurm_protocol_pack.c b/src/common/slurm_protocol_pack.c
index 904c9e5c7f..ca0462bca8 100644
--- a/src/common/slurm_protocol_pack.c
+++ b/src/common/slurm_protocol_pack.c
@@ -148,6 +148,7 @@ int pack_msg ( slurm_msg_t const * msg , Buf buffer )
 		case REQUEST_RECONFIGURE :
 		case REQUEST_SHUTDOWN_IMMEDIATE :
 		case REQUEST_PING :
+		case REQUEST_CONTROL :
 			/* Message contains no body/information */
 			break ;
 		case REQUEST_SHUTDOWN :
@@ -297,6 +298,7 @@ int unpack_msg ( slurm_msg_t * msg , Buf buffer )
 		case REQUEST_RECONFIGURE :
 		case REQUEST_SHUTDOWN_IMMEDIATE :
 		case REQUEST_PING :
+		case REQUEST_CONTROL :
 			/* Message contains no body/information */
 			break ;
 		case REQUEST_SHUTDOWN :
diff --git a/src/common/slurm_protocol_socket_implementation.c b/src/common/slurm_protocol_socket_implementation.c
index 245212014c..901eef9c44 100644
--- a/src/common/slurm_protocol_socket_implementation.c
+++ b/src/common/slurm_protocol_socket_implementation.c
@@ -491,6 +491,14 @@ slurm_fd _slurm_open_stream ( slurm_addr * slurm_address )
 {
 	int rc ;
 	slurm_fd connection_fd ;
+
+	if ( (slurm_address->sin_family == 0) &&
+	     (slurm_address->sin_port == 0) ) 
+	{
+		error ( "Attempt to open socket with null address" );
+		return SLURM_SOCKET_ERROR;
+	}
+
 	if ( ( connection_fd =_slurm_create_socket ( SLURM_STREAM ) ) == SLURM_SOCKET_ERROR )
 	{
 		debug ( "Error creating slurm stream socket: %m" ) ;
@@ -774,19 +782,21 @@ void _slurm_set_addr ( slurm_addr * slurm_address , uint16_t port , char * host
 }
 void _slurm_set_addr_char ( slurm_addr * slurm_address , uint16_t port , char * host )
 {
-	struct hostent * host_info; 
-	if (host != NULL) {
+	struct hostent * host_info = NULL; 
+
+	if (host != NULL)
 		host_info = gethostbyname ( host ) ;
-		if (host_info == NULL) {
-			error ("gethostbyname failure on %s", host);
-			slurm_address->sin_family = 0;
-			slurm_address->sin_port = 0;
-		}
+
+	if (host_info == NULL) {
+		error ("gethostbyname failure on %s", host);
+		slurm_address->sin_family = 0;
+		slurm_address->sin_port = 0;
+	} else {
 		memcpy ( & slurm_address -> sin_addr . s_addr , 
 			host_info -> h_addr , host_info -> h_length ) ;
+		slurm_address -> sin_family = AF_SLURM ;
+		slurm_address -> sin_port = htons ( port ) ;
 	}
-	slurm_address -> sin_family = AF_SLURM ;
-	slurm_address -> sin_port = htons ( port ) ;
 }
 
 void _slurm_get_addr ( slurm_addr * slurm_address , uint16_t * port , char * host , unsigned int buf_len )

