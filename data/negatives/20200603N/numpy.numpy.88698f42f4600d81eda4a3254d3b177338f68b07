commit 88698f42f4600d81eda4a3254d3b177338f68b07
Author: Travis Oliphant <oliphant@enthought.com>
Date:   Sun May 14 03:54:12 2006 +0000

    Fix defect #115

diff --git a/numpy/core/blasdot/_dotblas.c b/numpy/core/blasdot/_dotblas.c
index 94a725ed8..220dc6ab9 100644
--- a/numpy/core/blasdot/_dotblas.c
+++ b/numpy/core/blasdot/_dotblas.c
@@ -172,6 +172,7 @@ _select_matrix_shape(PyArrayObject *array)
 }
 
 
+
 static char doc_matrixproduct[] = "matrixproduct(a,b)\nReturns the dot product of a and b for arrays of floating point types.\nLike the generic numpy equivalent the product sum is over\nthe last dimension of a and the second-to-last dimension of b.\nNB: The first argument is not conjugated.";
 
 static PyObject *
@@ -200,7 +201,6 @@ dotblas_matrixproduct(PyObject *dummy, PyObject *args)
      * Only works for float double and complex types.
      */
 
-
     typenum = PyArray_ObjectType(op1, 0);  
     typenum = PyArray_ObjectType(op2, typenum);
     
@@ -216,7 +216,7 @@ dotblas_matrixproduct(PyObject *dummy, PyObject *args)
     Py_INCREF(dtype);
     ap2 = (PyArrayObject *)PyArray_FromAny(op2, dtype, 0, 0, ALIGNED, NULL);
     if (ap2 == NULL) goto fail;
-    
+
     if ((ap1->nd > 2) || (ap2->nd > 2)) {  
 	/* This function doesn't handle dimensions greater than 2 -- other
 	   than to ensure the dot function is altered
diff --git a/numpy/core/src/arrayobject.c b/numpy/core/src/arrayobject.c
index e9fc3fee9..7c4c22ae0 100644
--- a/numpy/core/src/arrayobject.c
+++ b/numpy/core/src/arrayobject.c
@@ -6408,8 +6408,8 @@ PyArray_FromArray(PyArrayObject *arr, PyArray_Descr *newtype, int flags)
 		/* If no copy then just increase the reference
 		   count and return the input */
 		else {
+			Py_DECREF(newtype);
                         if ((flags & ENSUREARRAY)) {
-				Py_DECREF(newtype);
 				Py_INCREF(arr->descr);
 				ret = (PyArrayObject *)			\
                                         PyArray_NewFromDescr(&PyArray_Type,
@@ -6467,6 +6467,7 @@ PyArray_FromArray(PyArrayObject *arr, PyArray_Descr *newtype, int flags)
 			}
 		}
 		else {
+			Py_DECREF(newtype);
 			PyErr_SetString(PyExc_TypeError,
 					"array cannot be safely cast " \
 					"to required type");
@@ -6853,7 +6854,7 @@ PyArray_FromAny(PyObject *op, PyArray_Descr *newtype, int min_depth,
                  ((r = PyArray_FromArrayAttr(op, newtype, context))     \
                   != Py_NotImplemented)) {
                 PyObject *new;
-                if (r == NULL) return NULL;
+                if (r == NULL) {Py_XDECREF(newtype); return NULL;}
                 if (newtype != NULL || flags != 0) {
                         new = PyArray_FromArray((PyArrayObject *)r, newtype, 
 						flags);
@@ -6918,6 +6919,7 @@ PyArray_FromAny(PyObject *op, PyArray_Descr *newtype, int min_depth,
         return r;
 
  err:
+	Py_XDECREF(newtype);
 	PyErr_SetString(PyExc_TypeError, 
 			"UPDATEIFCOPY used for non-array input.");
 	return NULL;

