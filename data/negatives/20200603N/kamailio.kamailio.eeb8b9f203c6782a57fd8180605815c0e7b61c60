commit eeb8b9f203c6782a57fd8180605815c0e7b61c60
Author: Daniel-Constantin Mierla <daniel@voice-system.ro>
Date:   Mon Nov 11 16:31:19 2002 +0000

    XJAB module:
            - added display name in From header when a Jabber message is delivered to
              SIP user - that is Jabber user name for user-to-user chat or room name for
              user-to-conference

diff --git a/modules_s/jabber/jabber.c b/modules_s/jabber/jabber.c
index ea3500aa0..52812a954 100644
--- a/modules_s/jabber/jabber.c
+++ b/modules_s/jabber/jabber.c
@@ -649,7 +649,7 @@ void destroy(void)
 
 void xjab_check_workers(int mpid)
 {
-	int i, n, stat;
+	int i, j, n, stat;
 	DBG("XJAB:%d:xjab_check_workers: time=%d\n", mpid, get_ticks());
 	if(!jwl || jwl->len <= 0)
 		return;
@@ -662,12 +662,13 @@ void xjab_check_workers(int mpid)
 		if(n == 0)
 			continue;
 		
-		DBG("XJAB:xjab_check_workers: worker[%d][pid=%d] has exited"
-			" - status %d err=%d errno=%d\n", i, 
-			jwl->workers[i].pid, stat, n, errno);
+		LOG(L_ERR,"XJAB:xjab_check_workers: worker[%d][pid=%d] has exited"
+			" - status=%d err=%d errno=%d\n", i, jwl->workers[i].pid, 
+			stat, n, errno);
 		if(n==jwl->workers[i].pid)
 		{
 			DBG("XJAB:%d:xjab_check_workers: create a new worker\n", mpid);
+			xj_wlist_send_info(jwl, i);
 			xj_wlist_set_pid(jwl, -1, i);
 			if ( (stat=fork())<0 )
 			{
diff --git a/modules_s/jabber/xjab_worker.c b/modules_s/jabber/xjab_worker.c
index 9eaae0c49..0fdd09d07 100644
--- a/modules_s/jabber/xjab_worker.c
+++ b/modules_s/jabber/xjab_worker.c
@@ -56,7 +56,7 @@
 #define XJ_ADDRTR_B2A	2
 #define XJ_ADDRTR_CON	4
 
-#define XJ_POOL_SIZE	10
+#define XJ_MSG_POOL_SIZE	10
 
 /** TM bind */
 extern struct tm_binds tmb;
@@ -70,467 +70,26 @@ int main_loop = 1;
 static str jab_gw_name = {"sip_to_jabber_gateway", 21};
 
 /**
- * init a workers list
- * - pipes : communication pipes
- * - size : size of list - number of workers
- * - max : maximum number of jobs per worker
- * #return : pointer to workers list or NULL on error
+ * send disconnected info to all SIP users associated with worker idx
  */
-xj_wlist xj_wlist_init(int **pipes, int size, int max, int cache_time,
-		int sleep_time, int delay_time)
+int xj_wlist_send_info(xj_wlist jwl, int idx)
 {
 	int i;
-	xj_wlist jwl = NULL;
-
-	if(pipes == NULL || size <= 0 || max <= 0)
-		return NULL;
-
-	DBG("XJAB:xj_wlist_init: -----START-----\n");
-	
-	jwl = (xj_wlist)_M_SHM_MALLOC(sizeof(t_xj_wlist));
-	if(jwl == NULL)
-		return NULL;
-	jwl->len = size;
-	jwl->maxj = max;
-	
-	jwl->cachet = cache_time;
-	jwl->delayt = delay_time;
-	jwl->sleept = sleep_time;
-
-	jwl->contact_h = NULL;
-	jwl->aliases = NULL;
-	jwl->sems = NULL;
-	i = 0;
-	if((jwl->sems = create_semaphores(size)) == NULL)
-		goto clean;
-	jwl->workers = (xj_worker)_M_SHM_MALLOC(size*sizeof(t_xj_worker));
-	if(jwl->workers == NULL)
-		goto clean;
-
-	for(i = 0; i < size; i++)
-	{
-		jwl->workers[i].nr = 0;
-		jwl->workers[i].pid = 0;
-		jwl->workers[i].wpipe = pipes[i][1];
-		jwl->workers[i].rpipe = pipes[i][0];
-		if((jwl->workers[i].sip_ids = newtree234(xj_jkey_cmp)) == NULL)
-			goto clean;
-	}	
-
-	return jwl;
-
-clean:
-	DBG("XJAB:xj_wlist_init: error ocurred -> cleaning\n");
-	if(jwl->sems != NULL)
-		destroy_semaphores(jwl->sems);
-	if(jwl->workers != NULL)
-	{
-		while(i>=0)
-		{
-			if(jwl->workers[i].sip_ids == NULL)
-				free2tree234(jwl->workers[i].sip_ids, xj_jkey_free_p);
-			i--;
-		}
-		_M_SHM_FREE(jwl->workers);
-	}
-	_M_SHM_FREE(jwl);
-	return NULL;
-
-}
-
-/**
- * init contact address for SIP messages that will be sent by workers
- * - jwl - pointer to workers list
- * - ch - string representation of the contact, e.g. 'sip:100.100.100.100:5060'
- * #return : 0 on success or <0 on error
- * info: still has 0 at the end of string
- */
-int xj_wlist_init_contact(xj_wlist jwl, char *ch)
-{
-	int f = 0; // correction flag: 1 -> must be converted to <sip: ... > 
-	if(ch == NULL)
-		return -1;
-	if((jwl->contact_h = (str*)_M_SHM_MALLOC(sizeof(str))) == NULL)
-		return -1;
-	jwl->contact_h->len = strlen(ch);
-
-	if(jwl->contact_h->len > 2 && strstr(ch, "sip:") == NULL)
-	{
-		// contact correction
-		jwl->contact_h->len += 6;
-		f = 1;
-	}
-
-	if((jwl->contact_h->s=(char*)_M_SHM_MALLOC(jwl->contact_h->len+1))==NULL)
-	{
-		_M_SHM_FREE(jwl->contact_h);
-		return -2;
-	}
-
-	if(f)
-	{
-		strncpy(jwl->contact_h->s, "<sip:", 5);
-		strcpy(jwl->contact_h->s+5, ch);
-		jwl->contact_h->s[jwl->contact_h->len-1] = '>';
-		jwl->contact_h->s[jwl->contact_h->len] = 0;
-	}
-	else
-		strcpy(jwl->contact_h->s, ch);
-
-	return 0;
-}
-
-
-/**
- * set the p.id's of the workers
- * - jwl : pointer to the workers list
- * - pids : p.id's array
- * - size : number of pids
- * #return : 0 on success or <0 on error
- */
-int xj_wlist_set_pid(xj_wlist jwl, int pid, int idx)
-{
-	if(jwl == NULL || pid <= 0 || idx < 0 || idx >= jwl->len)
+	xj_jkey p;
+	if(jwl==NULL || idx < 0 || idx >= jwl->len || !jwl->workers[idx].sip_ids)
 		return -1;
 	s_lock_at(jwl->sems, idx);
-	jwl->workers[idx].pid = pid;
-	s_unlock_at(jwl->sems, idx);
-	return 0;
-}
-
-/**
- * free jab_wlist
- * - jwl : pointer to the workers list
- */
-void xj_wlist_free(xj_wlist jwl)
-{
-	int i;
-	DBG("XJAB:xj_wlist_free: freeing 'xj_wlist' memory ...\n");
-	if(jwl == NULL)
-		return;
-
-	if(jwl->contact_h != NULL && jwl->contact_h->s != NULL)
-		_M_SHM_FREE(jwl->contact_h->s);
-	if(jwl->contact_h != NULL)
-		_M_SHM_FREE(jwl->contact_h);
-
-	if(jwl->workers != NULL)
-	{
-		for(i=0; i<jwl->len; i++)
-			free2tree234(jwl->workers[i].sip_ids, xj_jkey_free_p);
-		_M_SHM_FREE(jwl->workers);
-	}
-
-	if(jwl->aliases != NULL)
-	{
-		if(jwl->aliases->jdm != NULL)
-		{
-			_M_SHM_FREE(jwl->aliases->jdm->s);
-			_M_SHM_FREE(jwl->aliases->jdm);
-		}
-		if(jwl->aliases->size > 0)
-		{
-			for(i=0; i<jwl->aliases->size; i++)
-				_M_SHM_FREE(jwl->aliases->a[i].s);
-			_M_SHM_FREE(jwl->aliases->a);
-		}
-		_M_SHM_FREE(jwl->aliases);
-		jwl->aliases = NULL;
-	}
-	
-	//rm_sem(jwl->semid);
-	if(jwl->sems != NULL)
-		destroy_semaphores(jwl->sems);
-	
-	_M_SHM_FREE(jwl);
-}
-
-/**
- * return communication pipe with the worker that will process the message for
- * 		the id 'sid' only if it exsists, or -1 if error
- * - jwl : pointer to the workers list
- * - sid : id of the entity (connection to Jabber - usually SHOULD be FROM
- *   header of the incomming SIP message)
- * - p : will point to the SHM location of the 'sid' in jwl
- */
-int xj_wlist_check(xj_wlist jwl, xj_jkey jkey, xj_jkey *p)
-{
-	int i;
-	if(jwl==NULL || jkey==NULL || jkey->id==NULL || jkey->id->s==NULL)
-		return -1;
-	
-	i = 0;
-	*p = NULL;
-	while(i < jwl->len)
-	{
-		s_lock_at(jwl->sems, i);
-		if(jwl->workers[i].pid <= 0)
-		{
-			s_unlock_at(jwl->sems, i);
-			i++;
-			continue;
-		}
-		if((*p = find234(jwl->workers[i].sip_ids, (void*)jkey, NULL)) != NULL)
-		{
-			s_unlock_at(jwl->sems, i);
-			DBG("XJAB:xj_wlist_check: entry exists for <%.*s> in the"
-				" pool of <%d> [%d]\n",jkey->id->len, jkey->id->s,
-				jwl->workers[i].pid,i);
-			return jwl->workers[i].wpipe;
-		}
-		s_unlock_at(jwl->sems, i);
-		i++;
-	}
-	DBG("XJAB:xj_wlist_check: entry does not exist for <%.*s>\n",
-			jkey->id->len, jkey->id->s);	
-	return -1;
-}
-
-/**
- * return communication pipe with the worker that will process the message for
- * 		the id 'sid', or -1 if error
- * - jwl : pointer to the workers list
- * - sid : id of the entity (connection to Jabber - usually SHOULD be FROM
- *   header of the incomming SIP message)
- * - p : will point to the SHM location of the 'sid' in jwl
- */
-int xj_wlist_get(xj_wlist jwl, xj_jkey jkey, xj_jkey *p)
-{
-	int i = 0, pos = -1, min = 100000;
-	xj_jkey msid = NULL;
-	
-	if(jwl==NULL || jkey==NULL || jkey->id==NULL || jkey->id->s==NULL)
-		return -1;
-
-	*p = NULL;
-	while(i < jwl->len)
-	{
-		s_lock_at(jwl->sems, i);
-		if(jwl->workers[i].pid <= 0)
-		{
-			s_unlock_at(jwl->sems, i);
-			i++;
-			continue;
-		}
-		if((*p = find234(jwl->workers[i].sip_ids, (void*)jkey, NULL))!=NULL)
-		{
-			if(pos >= 0)
-				s_unlock_at(jwl->sems, pos);
-			s_unlock_at(jwl->sems, i);
-			DBG("XJAB:xj_wlist_get: entry already exists for <%.*s> in the"
-				" pool of <%d> [%d]\n",jkey->id->len, jkey->id->s,
-				jwl->workers[i].pid,i);
-			return jwl->workers[i].wpipe;
-		}
-		if(min > jwl->workers[i].nr)
-		{
-			if(pos >= 0)
-				s_unlock_at(jwl->sems, pos);
-			pos = i;
-			min = jwl->workers[i].nr;
-		}
-		else
-			s_unlock_at(jwl->sems, i);
-		i++;
-	}
-	if(pos >= 0 && jwl->workers[pos].nr < jwl->maxj)
-	{
-		jwl->workers[pos].nr++;
-
-		msid = (xj_jkey)_M_SHM_MALLOC(sizeof(t_xj_jkey));
-		if(msid == NULL)
-			goto error;
-		msid->id = (str*)_M_SHM_MALLOC(sizeof(str));
-		if(msid->id == NULL)
-		{
-			_M_SHM_FREE(msid);
-			goto error;
-		}
-		
-		msid->id->s = (char*)_M_SHM_MALLOC(jkey->id->len);
-		if(msid->id == NULL)
-		{
-			_M_SHM_FREE(msid->id);
-			_M_SHM_FREE(msid);
-			goto error;
-		}
-		
-		if((*p = add234(jwl->workers[pos].sip_ids, msid)) != NULL)
-		{
-			msid->id->len = jkey->id->len;
-			memcpy(msid->id->s, jkey->id->s, jkey->id->len);
-			msid->hash = jkey->hash;
-			msid->flag = 0;
-			s_unlock_at(jwl->sems, pos);
-			DBG("XJAB:xj_wlist_get: new entry for <%.*s> in the pool of"
-				" <%d> - [%d]\n", jkey->id->len, jkey->id->s,
-				jwl->workers[pos].pid, pos);
-			return jwl->workers[pos].wpipe;
-		}
-		_M_SHM_FREE(msid->id->s);
-		_M_SHM_FREE(msid->id);
-		_M_SHM_FREE(msid);
-	}
-
-error:
-	if(pos >= 0)
-		s_unlock_at(jwl->sems, pos);
-
-	DBG("XJAB:xj_wlist_get: can not create a new entry for <%.*s>\n",
-				jkey->id->len, jkey->id->s);
-	return -1;
-}
-
-int  xj_wlist_set_aliases(xj_wlist jwl, char *als, char *jd)
-{
-	char *p, *p0;
-	int i;
-	
-	DBG("XJAB:xj_wlist_set_aliases\n");
-	if(jwl == NULL)
-		return -1;
-	if(!jd) // || !als || strlen(als)<2)
-		return 0;
-	
-	if((jwl->aliases = (xj_jalias)_M_SHM_MALLOC(sizeof(t_xj_jalias)))==NULL)
-	{
-		DBG("XJAB:xj_wlist_set_aliases: not enough SHMemory.\n");
-		return -1;
-	}
-	
-	jwl->aliases->jdm = NULL;
-	jwl->aliases->size = 0;
-	jwl->aliases->a = NULL;
-	
-	if(jd != NULL && strlen(jd)>2)
-	{
-		if((jwl->aliases->jdm = (str*)_M_SHM_MALLOC(sizeof(str)))== NULL)
-		{
-			DBG("XJAB:xj_wlist_set_aliases: not enough SHMemory!?\n");
-			_M_SHM_FREE(jwl->aliases);
-			jwl->aliases = NULL;
-			return -1;		
-		}
-		jwl->aliases->jdm->len = strlen(jd);
-		if((jwl->aliases->jdm->s=(char*)_M_SHM_MALLOC(jwl->aliases->jdm->len))
-				== NULL)
-		{
-			DBG("XJAB:xj_wlist_set_aliases: not enough SHMemory!?!\n");
-			_M_SHM_FREE(jwl->aliases->jdm);
-			_M_SHM_FREE(jwl->aliases);
-			jwl->aliases = NULL;
-		}
-		strncpy(jwl->aliases->jdm->s, jd, jwl->aliases->jdm->len);
-	}
-	
-	if(!als || strlen(als)<2)
-		return 0;
-	
-	if((p = strchr(als, ';')) == NULL)
-	{
-		DBG("XJAB:xj_wlist_set_aliases: bad parameter value\n");
-		return -1;
-	}
-	
-	if((jwl->aliases->size = atoi(als)) <= 0)
-	{
-		DBG("XJAB:xj_wlist_set_aliases: wrong number of aliases\n");
-		return 0;
-	}
-	
-	if((jwl->aliases->a = (str*)_M_SHM_MALLOC(jwl->aliases->size*sizeof(str)))
-			== NULL)
+	for(i=0; (p=(xj_jkey)index234(jwl->workers[idx].sip_ids, i))!=NULL; i++)
 	{
-		DBG("XJAB:xj_wlist_set_aliases: not enough SHMemory..\n");
-		if(jwl->aliases->jdm)
-		{
-			_M_SHM_FREE(jwl->aliases->jdm->s);
-			_M_SHM_FREE(jwl->aliases->jdm);
-		}
-		_M_SHM_FREE(jwl->aliases);
-		jwl->aliases = NULL;
-		return -1;
-	}
-	
-	p++;
-	for(i=0; i<jwl->aliases->size; i++)
-	{
-		if((p0 = strchr(p, ';'))==NULL)
-		{
-			DBG("XJAB:xj_wlist_set_aliases: bad parameter value format\n");
-			goto clean;
-		}
-		jwl->aliases->a[i].len = p0 - p;
-		if((jwl->aliases->a[i].s = (char*)_M_SHM_MALLOC(jwl->aliases->a[i].len))
-				== NULL)
-		{
-			DBG("XJAB:xj_wlist_set_aliases: not enough SHMemory!\n");
-			goto clean;
-		}
-			
-		strncpy(jwl->aliases->a[i].s, p, jwl->aliases->a[i].len);
-		DBG("XJAB:xj_wlist_set_aliases: alias[%d/%d]=%.*s\n", 
-				i+1, jwl->aliases->size, jwl->aliases->a[i].len, 
-				jwl->aliases->a[i].s);
-		p = p0 + 1;
+		DBG("XJAB:xj_wlist_send_info: sending disconnect message to <%.*s>\n",
+			p->id->len, p->id->s);
+		xj_send_sip_msgz(p->id, &jab_gw_name, NULL,"ERROR:Connection to"
+			" Jabber server lost. You have to login to Jabber server again"
+			" (join the conferences again that you were participating, too)",
+			NULL);
 	}
+	s_unlock_at(jwl->sems, idx);
 	return 0;
-
-clean:
-	if(jwl->aliases->jdm)
-	{
-		_M_SHM_FREE(jwl->aliases->jdm->s);
-		_M_SHM_FREE(jwl->aliases->jdm);
-	}
-	while(i>0)
-	{
-		_M_SHM_FREE(jwl->aliases->a[i-1].s);
-		i--;
-	}
-	_M_SHM_FREE(jwl->aliases->a);
-	_M_SHM_FREE(jwl->aliases);
-	jwl->aliases = NULL;
-	return -1;
-}
-
-/**
- * delete an entity from working list of a worker
- * - jwl : pointer to the workers list
- * - sid : id of the entity (connection to Jabber - usually SHOULD be FROM
- *   header of the incomming SIP message
- * - _pid : process id of the worker
- */
-void xj_wlist_del(xj_wlist jwl, xj_jkey jkey, int _pid)
-{
-	int i;
-	void *p;
-	if(jwl==NULL || jkey==NULL || jkey->id==NULL || jkey->id->s==NULL)
-		return;
-	for(i=0; i < jwl->len; i++)
-		if(jwl->workers[i].pid == _pid)
-			break;
-	if(i >= jwl->len)
-	{
-		DBG("XJAB:xj_wlist_del:%d: key <%.*s> not found in [%d]...\n",
-			_pid, jkey->id->len, jkey->id->s, i);
-		return;
-	}
-	DBG("XJAB:xj_wlist_del:%d: trying to delete entry for <%.*s>...\n",
-		_pid, jkey->id->len, jkey->id->s);
-
-	s_lock_at(jwl->sems, i);
-	p = del234(jwl->workers[i].sip_ids, (void*)jkey);
-
-	if(p != NULL)
-	{
-		jwl->workers[i].nr--;
-
-		DBG("XJAB:xj_wlist_del:%d: sip id <%.*s> deleted\n", _pid,
-			jkey->id->len, jkey->id->s);
-		xj_jkey_free_p(p);
-	}
-
-	s_unlock_at(jwl->sems, i);
 }
 
 /**
@@ -649,11 +208,7 @@ done:
  * - jwl : pointer to the workers list
  * - jaddress : address of the jabber server
  * - jport : port of the jabber server
- * - pipe : communication pipe with SER
- * - size : maximun number of jobs - open connections to Jabber server
- * - ctime : cache time for a connection to Jabber
- * - wtime : wait time between cache checking
- * - dtime : delay time for first message
+ * - rank : worker's rank
  * - db_con : connection to database
  * #return : 0 on success or <0 on error
  */
@@ -696,7 +251,7 @@ int xj_worker_process(xj_wlist jwl, char* jaddress, int jport, int rank,
 	DBG("XJAB:xj_worker[%d]:%d: started - pipe=<%d> : 1st message delay"
 		" <%d>\n", rank, _xj_pid, pipe, jwl->delayt);
 
-	if((jcp=xj_jcon_pool_init(jwl->maxj,XJ_POOL_SIZE,jwl->delayt))==NULL)
+	if((jcp=xj_jcon_pool_init(jwl->maxj,XJ_MSG_POOL_SIZE,jwl->delayt))==NULL)
 	{
 		DBG("XJAB:xj_worker: cannot allocate the pool\n");
 		return -1;
@@ -828,7 +383,8 @@ int xj_worker_process(xj_wlist jwl, char* jaddress, int jport, int rank,
 				{
 					xj_send_sip_msgz(jsmsg->jkey->id, &jsmsg->to,
 						jwl->contact_h, "ERROR: Your message was not"
-						" sent. You are not joined in the conference.",
+						" sent. You are not joined in the conference."
+						" Please join the room before sending messages.",
 						NULL);
 					goto step_w;
 				}
@@ -1045,7 +601,8 @@ step_z:
 			case 3:
 				xj_send_sip_msgz(jsmsg->jkey->id, &jsmsg->to,
 						jwl->contact_h, "ERROR: Your message was not"
-						" sent. You are not joined in the conference.",
+						" sent. You are not joined in the conference."
+						" Please join the room before sending messages.",
 						&jbc->jkey->flag);
 				goto step_w;
 				
@@ -1118,8 +675,10 @@ step_y:
 						" connection to jabber lost on socket <%d> ...\n",
 						_xj_pid, jcp->ojc[i]->sock);
 					xj_send_sip_msgz(jcp->ojc[i]->jkey->id, &jab_gw_name, 
-						jwl->contact_h,"ERROR:Connection to Jabber server"
-						" lost. You have to re-login.", &jbc->jkey->flag);
+						jwl->contact_h,"ERROR: Connection to Jabber server"
+						" lost. You have to login to Jabber server again"
+						" (join the conferences again that you were"
+						" participating, too)", &jbc->jkey->flag);
 					// make sure that will ckeck expired connections
 					ltime = jcp->ojc[i]->expire = -1;
 					FD_CLR(jcp->ojc[i]->sock, &set);
@@ -1138,9 +697,8 @@ step_y:
 					" JABBER: JMSGL:%d END ----------\n", nr, recv_buff, nr);
 
 			
-			} while(xj_manage_jab(recv_buff, nr, &pos, jcp->ojc[i]->jkey->id, 
-						jwl->contact_h, jwl->aliases, jcp->ojc[i]) == 9
-					&& main_loop);
+			} while(xj_manage_jab(recv_buff, nr, &pos, jwl->contact_h,
+					jwl->aliases, jcp->ojc[i]) == 9	&& main_loop);
 	
 			/**
 			 * flush out the socket - set it back to blocking 
@@ -1230,7 +788,7 @@ step_xx:
 /**
  * parse incoming message from Jabber server
  */
-int xj_manage_jab(char *buf, int len, int *pos, str *sid, 
+int xj_manage_jab(char *buf, int len, int *pos, 
 		str *sct, xj_jalias als, xj_jcon jbc)
 {
 	int i, err=0;
@@ -1238,7 +796,12 @@ int xj_manage_jab(char *buf, int len, int *pos, str *sid,
 	xj_jconf jcf = NULL;
 	str ts, tf;
 	xode x, y, z;
-	
+	str *sid;
+
+	if(!jbc)
+		return -1;
+
+	sid = jbc->jkey->id;	
 	x = xode_from_strx(buf, len, &err, &i);
 	DBG("XJAB:xj_parse_jab: XODE ret:%d pos:%d\n", err, i);
 	
@@ -1467,7 +1030,7 @@ void xj_sig_handler(int s)
 	signal(SIGQUIT, xj_sig_handler);
 	signal(SIGSEGV, xj_sig_handler);
 	main_loop = 0;
-	DBG("XJAB:xj_worker:%d: SIGNAL received=%d\n", _xj_pid, s);
+	DBG("XJAB:xj_worker:%d: SIGNAL received=%d\n **************", _xj_pid, s);
 }
 
 /*****************************     ****************************************/
@@ -1486,23 +1049,33 @@ int xj_send_sip_msg(str *to, str *from, str *contact, str *msg, int *cbp)
 	char buf[512];
 	str  tfrom;
 	str  str_hdr;
-	int **pcbp = NULL;
+	int **pcbp = NULL, beg, end, crt;
 	char buf1[1024];
 
-	if(cbp && *cbp!=0)
+	if(!to || !from || !msg || (cbp && *cbp!=0))
 		return -1;
 
 	// from correction
-	strcpy(buf, "<sip:");
-	strncat(buf, from->s, from->len);
-	tfrom.len = from->len;
-	if(strstr(buf+5, "sip:") == NULL)
+	beg = crt = 0;
+	end = -1;
+	while(crt < from->len && from->s[crt]!='@')
 	{
-		tfrom.len += 5;
-		buf[tfrom.len++] = '>';
-		tfrom.s = buf;
-	} else
-		tfrom.s = buf+5;
+		if(from->s[crt]=='%')
+		{
+			beg = end + 1;
+			end = crt;
+		}
+		crt++;
+	}
+	if(end > 0)
+		sprintf(buf, "\"%.*s\" <sip:%.*s>", end-beg, from->s+beg,
+					from->len, from->s);
+	else
+		sprintf(buf, "<sip:%.*s>", from->len, from->s);
+		
+	tfrom.len = strlen(buf);
+	tfrom.s = buf;
+	
 	// building Contact and Content-Type
 	strcpy(buf1,"Content-Type: text/plain"CRLF"Contact: ");
 	str_hdr.len = 24 + CRLF_LEN + 9;
@@ -1519,10 +1092,9 @@ int xj_send_sip_msg(str *to, str *from, str *contact, str *msg, int *cbp)
 	strcat(buf1, CRLF);
 	str_hdr.len += CRLF_LEN;
 	str_hdr.s = buf1;
-	DBG("XJAB:xj_send_sip_msg: uac callback parameter [%p == %d]\n", cbp,
-			(cbp)?*cbp:0);
 	if(cbp)
 	{
+		DBG("XJAB:xj_send_sip_msg: uac callback parameter [%p==%d]\n",cbp,*cbp);
 		if((pcbp = (int**)shm_malloc(sizeof(int*))) == NULL)
 			return -1;
 		*pcbp = cbp;
@@ -1546,7 +1118,7 @@ int xj_send_sip_msgz(str *to, str *from, str *contact, char *msg, int *cbp)
 	str tstr;
 	int n;
 
-	if(cbp && *cbp!=0)
+	if(!to || !from || !msg || (cbp && *cbp!=0))
 		return -1;
 
 	tstr.s = msg;
@@ -1556,7 +1128,7 @@ int xj_send_sip_msgz(str *to, str *from, str *contact, char *msg, int *cbp)
 			" [%.*s]...\n", tstr.len, tstr.s);
 	else
 		DBG("JABBER: jab_send_sip_msgz: SIP MESSAGE was sent to [%.*s]...\n",
-			tstr.len, tstr.s);
+			to->len, to->s);
 	return n;
 }
 
diff --git a/modules_s/jabber/xjab_worker.h b/modules_s/jabber/xjab_worker.h
index 3c2c6c829..6af9967b4 100644
--- a/modules_s/jabber/xjab_worker.h
+++ b/modules_s/jabber/xjab_worker.h
@@ -79,12 +79,13 @@ int  xj_wlist_check(xj_wlist, xj_jkey, xj_jkey*);
 void xj_wlist_del(xj_wlist, xj_jkey, int);
 void xj_wlist_free(xj_wlist);
 int  xj_wlist_set_aliases(xj_wlist, char *, char *);
- 
+int  xj_wlist_send_info(xj_wlist, int); 
+
 int xj_worker_process(xj_wlist, char*, int, int, db_con_t*);
 
 int xj_address_translation(str *src, str *dst, xj_jalias als, int flag);
-int xj_manage_jab(char *buf, int len, int *pos, str *sid,
-		str *sct, xj_jalias als, xj_jcon jbc);
+int xj_manage_jab(char *buf, int len, int *pos, str *sct, 
+			xj_jalias als, xj_jcon jbc);
 
 void xj_sig_handler(int s);
 

