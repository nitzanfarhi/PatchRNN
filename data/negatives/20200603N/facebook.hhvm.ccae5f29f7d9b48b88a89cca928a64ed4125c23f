commit ccae5f29f7d9b48b88a89cca928a64ed4125c23f
Author: Edwin Smith <smith@fb.com>
Date:   Mon Dec 4 10:13:11 2017 -0800

    Remove unnecessary branch in mallocSmallSizeSlow
    
    Summary:
    When we run out of freelist objects, we attempt to find
    a larger object to split. The search for a larger object
    is guaranteed to start at a large size class than the
    empty freelist, and so when we split it, we're guaranteed
    to have a nonzero remainder after the first object in
    the split block.
    
    Reviewed By: alexeyt
    
    Differential Revision: D6473863
    
    fbshipit-source-id: 8dcb7b4c03f1b8e0c82245cdc6b2f0db3f1695a7

diff --git a/hphp/runtime/base/memory-manager.cpp b/hphp/runtime/base/memory-manager.cpp
index 028f06557f..a587e82b48 100644
--- a/hphp/runtime/base/memory-manager.cpp
+++ b/hphp/runtime/base/memory-manager.cpp
@@ -722,6 +722,7 @@ inline void* MemoryManager::slabAlloc(size_t nbytes, size_t index) {
 
 void* MemoryManager::mallocSmallSizeSlow(size_t nbytes, size_t index) {
   assert(nbytes == sizeIndex2Size(index));
+  assert(!m_freelists[index].head); // freelist[index] is empty
   auto nContig = kNContigTab[index];
   auto contigMin = nContig * nbytes;
   auto contigInd = size2Index(contigMin);
@@ -730,6 +731,7 @@ void* MemoryManager::mallocSmallSizeSlow(size_t nbytes, size_t index) {
               "contigInd={}, try i={}\n", nbytes, index, contigMin,
               contigInd, i);
     if (auto p = m_freelists[i].maybePop()) {
+      assert(i > index); // because freelist[index] was empty
       FTRACE(4, "MemoryManager::mallocSmallSizeSlow({}, {}): "
                 "contigMin={}, contigInd={}, use i={}, size={}, p={}\n",
                 nbytes, index, contigMin, contigInd, i, sizeIndex2Size(i),
@@ -737,10 +739,9 @@ void* MemoryManager::mallocSmallSizeSlow(size_t nbytes, size_t index) {
       // Split tail into preallocations and store them back into freelists.
       auto availBytes = sizeIndex2Size(i);
       auto tailBytes = availBytes - nbytes;
-      if (tailBytes > 0) {
-        auto tail = (void*)(uintptr_t(p) + nbytes);
-        splitTail(m_freelists, tail, tailBytes, nContig - 1, nbytes, index);
-      }
+      assert(tailBytes > 0); // because i > index
+      auto tail = (void*)(uintptr_t(p) + nbytes);
+      splitTail(m_freelists, tail, tailBytes, nContig - 1, nbytes, index);
       return p;
     }
   }

