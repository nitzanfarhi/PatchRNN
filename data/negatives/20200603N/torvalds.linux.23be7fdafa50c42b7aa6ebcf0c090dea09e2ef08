commit 23be7fdafa50c42b7aa6ebcf0c090dea09e2ef08
Author: Alexandre Courbot <gnurou@gmail.com>
Date:   Thu Feb 19 07:29:58 2015 +0100

    ARM: 8305/1: DMA: Fix kzalloc flags in __iommu_alloc_buffer()
    
    There doesn't seem to be any valid reason to allocate the pages array
    with the same flags as the buffer itself. Doing so can eventually lead
    to the following safeguard in mm/slab.c's cache_grow() to be hit:
    
            if (unlikely(flags & GFP_SLAB_BUG_MASK)) {
                    pr_emerg("gfp: %un", flags & GFP_SLAB_BUG_MASK);
                    BUG();
            }
    
    This happens when buffers are allocated with __GFP_DMA32 or
    __GFP_HIGHMEM.
    
    Fix this by allocating the pages array with GFP_KERNEL to follow what is
    done elsewhere in this file. Using GFP_KERNEL in __iommu_alloc_buffer()
    is safe because atomic allocations are handled by __iommu_alloc_atomic().
    
    Signed-off-by: Alexandre Courbot <acourbot@nvidia.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Acked-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
index f142ddd6c40a..50ffaed44ec0 100644
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@ -1106,7 +1106,7 @@ static struct page **__iommu_alloc_buffer(struct device *dev, size_t size,
 	int i = 0;
 
 	if (array_size <= PAGE_SIZE)
-		pages = kzalloc(array_size, gfp);
+		pages = kzalloc(array_size, GFP_KERNEL);
 	else
 		pages = vzalloc(array_size);
 	if (!pages)

