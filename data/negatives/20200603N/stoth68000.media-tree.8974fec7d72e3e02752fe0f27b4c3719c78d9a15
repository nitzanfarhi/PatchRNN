commit 8974fec7d72e3e02752fe0f27b4c3719c78d9a15
Author: Eryu Guan <guaneryu@gmail.com>
Date:   Sat Jul 4 00:03:44 2015 -0400

    ext4: correctly migrate a file with a hole at the beginning
    
    Currently ext4_ind_migrate() doesn't correctly handle a file which
    contains a hole at the beginning of the file.  This caused the migration
    to be done incorrectly, and then if there is a subsequent following
    delayed allocation write to the "hole", this would reclaim the same data
    blocks again and results in fs corruption.
    
      # assmuing 4k block size ext4, with delalloc enabled
      # skip the first block and write to the second block
      xfs_io -fc "pwrite 4k 4k" -c "fsync" /mnt/ext4/testfile
    
      # converting to indirect-mapped file, which would move the data blocks
      # to the beginning of the file, but extent status cache still marks
      # that region as a hole
      chattr -e /mnt/ext4/testfile
    
      # delayed allocation writes to the "hole", reclaim the same data block
      # again, results in i_blocks corruption
      xfs_io -c "pwrite 0 4k" /mnt/ext4/testfile
      umount /mnt/ext4
      e2fsck -nf /dev/sda6
      ...
      Inode 53, i_blocks is 16, should be 8.  Fix? no
      ...
    
    Signed-off-by: Eryu Guan <guaneryu@gmail.com>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Cc: stable@vger.kernel.org

diff --git a/fs/ext4/migrate.c b/fs/ext4/migrate.c
index 6d8b0c917364..6163ad21cb0e 100644
--- a/fs/ext4/migrate.c
+++ b/fs/ext4/migrate.c
@@ -620,7 +620,7 @@ int ext4_ind_migrate(struct inode *inode)
 	struct ext4_inode_info		*ei = EXT4_I(inode);
 	struct ext4_extent		*ex;
 	unsigned int			i, len;
-	ext4_lblk_t			end;
+	ext4_lblk_t			start, end;
 	ext4_fsblk_t			blk;
 	handle_t			*handle;
 	int				ret;
@@ -659,11 +659,12 @@ int ext4_ind_migrate(struct inode *inode)
 		goto errout;
 	}
 	if (eh->eh_entries == 0)
-		blk = len = 0;
+		blk = len = start = end = 0;
 	else {
 		len = le16_to_cpu(ex->ee_len);
 		blk = ext4_ext_pblock(ex);
-		end = le32_to_cpu(ex->ee_block) + len - 1;
+		start = le32_to_cpu(ex->ee_block);
+		end = start + len - 1;
 		if (end >= EXT4_NDIR_BLOCKS) {
 			ret = -EOPNOTSUPP;
 			goto errout;
@@ -672,7 +673,7 @@ int ext4_ind_migrate(struct inode *inode)
 
 	ext4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);
 	memset(ei->i_data, 0, sizeof(ei->i_data));
-	for (i=0; i < len; i++)
+	for (i = start; i <= end; i++)
 		ei->i_data[i] = cpu_to_le32(blk++);
 	ext4_mark_inode_dirty(handle, inode);
 errout:

