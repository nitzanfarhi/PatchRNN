commit 614410d5892af5f86d0ec14e28f9f6d5f4ac9e9b
Author: Christoph Lameter <clameter@sgi.com>
Date:   Sun May 6 14:49:38 2007 -0700

    SLUB: allocate smallest object size if the user asks for 0 bytes
    
    Makes SLUB behave like SLAB in this area to avoid issues....
    
    Throw a stack dump to alert people.
    
    At some point the behavior should be switched back.  NULL is no memory as
    far as I can tell and if the use asked for 0 bytes then he need to get no
    memory.
    
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/slub_def.h b/include/linux/slub_def.h
index 30b154ce7289..f8e0c86c48a9 100644
--- a/include/linux/slub_def.h
+++ b/include/linux/slub_def.h
@@ -80,8 +80,12 @@ extern struct kmem_cache kmalloc_caches[KMALLOC_SHIFT_HIGH + 1];
  */
 static inline int kmalloc_index(int size)
 {
-	if (size == 0)
-		return 0;
+	/*
+	 * We should return 0 if size == 0 but we use the smallest object
+	 * here for SLAB legacy reasons.
+	 */
+	WARN_ON_ONCE(size == 0);
+
 	if (size > 64 && size <= 96)
 		return 1;
 	if (size > 128 && size <= 192)
diff --git a/mm/slub.c b/mm/slub.c
index 4a8585befd84..9d52cce7c999 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -1979,7 +1979,7 @@ static struct kmem_cache *get_slab(size_t size, gfp_t flags)
 {
 	int index = kmalloc_index(size);
 
-	if (!size)
+	if (!index)
 		return NULL;
 
 	/* Allocation too large? */

