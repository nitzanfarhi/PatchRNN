commit 4eeff760f4236fbebf087b6ed1a94257151ef572
Author: csapuntz <csapuntz@openbsd.org>
Date:   Sat Dec 11 21:22:39 1999 +0000

    Bye-bye to the old ATAPI driver

diff --git a/sys/dev/atapi/acd.c b/sys/dev/atapi/acd.c
deleted file mode 100644
index 96fa1b0e70f..00000000000
--- a/sys/dev/atapi/acd.c
+++ /dev/null
@@ -1,1473 +0,0 @@
-/*	$OpenBSD: acd.c,v 1.36 1999/08/10 23:09:50 deraadt Exp $	*/
-
-/*
- * Copyright (c) 1996 Manuel Bouyer.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *  This product includes software developed by Manuel Bouyer.
- * 4. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <sys/types.h>
-#include <sys/param.h>
-#include <sys/systm.h>
-#include <sys/kernel.h>
-#include <sys/conf.h>
-#include <sys/file.h>
-#include <sys/stat.h>
-#include <sys/ioctl.h>
-#include <sys/malloc.h>
-#include <sys/mtio.h>
-#include <sys/buf.h>
-#include <sys/uio.h>
-#include <sys/errno.h>
-#include <sys/device.h>
-#include <sys/disklabel.h>
-#include <sys/disk.h>
-#include <sys/cdio.h>
-#include <sys/proc.h>  
-
-#include <dev/atapi/atapilink.h>
-#include <dev/atapi/atapi.h>
-
-#include <ufs/ffs/fs.h>			/* for BBSIZE and SBSIZE */
-
-#define	CDUNIT(z)			DISKUNIT(z)
-#define	CDPART(z)			DISKPART(z)
-#define	MAKECDDEV(maj, unit, part)	MAKEDISKDEV(maj, unit, part)
-
-#define MAXTRACK	99
-#define CD_BLOCK_OFFSET	150
-#define CD_FRAMES	75
-#define CD_SECS		60
-struct cd_toc {
-	struct ioc_toc_header hdr;
-	struct cd_toc_entry tab[MAXTRACK+1];	/* One extra for the leadout */
-};
-
-#define TOC_HEADER_LEN			0
-#define TOC_HEADER_STARTING_TRACK	2
-#define TOC_HEADER_ENDING_TRACK		3
-#define TOC_HEADER_SZ			4
-
-#define TOC_ENTRY_CONTROL_ADDR_TYPE	1
-#define TOC_ENTRY_TRACK			2
-#define TOC_ENTRY_MSF_LBA		4
-#define TOC_ENTRY_SZ			8
-
-#ifdef ACD_DEBUG
-#define ACD_DEBUG_PRINT(args)		printf args
-#else
-#define ACD_DEBUG_PRINT(args)
-#endif
-
-#ifdef ATAPI_DEBUG
-#define ATAPI_DEBUG_PRINT(args)		printf args
-#else
-#define ATAPI_DEBUG_PRINT(args)
-#endif
-
-struct acd_softc {
-	struct	device sc_dev;
-	struct	disk sc_dk;
-
-	int flags;
-#define	CDF_LOCKED	0x01
-#define	CDF_WANTED	0x02
-#define	CDF_WLABEL	0x04		/* label is writable */
-#define	CDF_LABELLING	0x08		/* writing label */
-#define CDF_NOTREADY	0x10		/* not ready at boot */
-	struct	at_dev_link *ad_link;	/* contains our drive number, etc ... */
-	struct	atapi_mode_data mode_page;	/* drive capabilities */
-
-	struct	cd_parms {
-		int	blksize;
-		u_int32_t disksize;	/* total number sectors */
-	} params;
-	struct	buf buf_queue;
-};
-
-int	acdmatch __P((struct device *, void *, void *));
-void	acdattach __P((struct device *, struct device *, void *));
-
-struct cfattach acd_ca = {
-	sizeof(struct acd_softc), acdmatch, acdattach
-};
-
-struct cfdriver acd_cd = {
-	NULL, "acd", DV_DISK
-};
-
-void	acdgetdisklabel __P((struct acd_softc *));
-int	acd_get_parms __P((struct acd_softc *, int));
-void	acdstrategy __P((struct buf *));
-void	acdstart __P((void *));
-int	acd_pause __P((struct acd_softc *, int));
-void	acdminphys __P((struct buf*));
-u_int32_t acd_size __P((struct acd_softc*, int));
-int	acddone __P((void *));
-int	acdlock __P((struct acd_softc *));
-void	acdunlock __P((struct acd_softc *));
-int	acdopen __P((dev_t, int, int));
-int	acdclose __P((dev_t, int, int));
-int	acdread __P((dev_t, struct uio*));
-int	acdwrite __P((dev_t, struct uio*));
-int	acdioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
-int	acd_reset __P((struct acd_softc *));
-int	acdsize __P((dev_t));
-int	acddump __P((dev_t, daddr_t, caddr_t, size_t));
-int	acd_get_mode __P((struct acd_softc *, struct atapi_mode_data *, int,
-	    int, int));
-int	acd_set_mode __P((struct acd_softc *, struct atapi_mode_data *, int));
-int	acd_setchan __P((struct acd_softc *, u_char, u_char, u_char, u_char));
-int	acd_play_big __P((struct acd_softc *, int, int));
-int	acd_load_toc __P((struct acd_softc *, struct cd_toc *));
-int	acd_play_tracks __P((struct acd_softc *, int, int, int, int));
-int	acd_play_msf __P((struct acd_softc *, int, int, int, int, int, int));
-int	acd_read_subchannel __P((struct acd_softc *, int, int, int,
-	    struct cd_sub_channel_info *, int));
-int	acd_read_toc __P((struct acd_softc *, int, int, void *, int));
-#if 0
-/* Not used anywhere, left here in case that changes. */
-static void lba2msf __P((u_int32_t, u_int8_t *, u_int8_t *, u_int8_t *));
-#endif
-static __inline u_int32_t msf2lba __P((u_int8_t, u_int8_t, u_int8_t));
-
-struct dkdriver acddkdriver = { acdstrategy };
-
-/*
- * Called by the low level atapi code to find the right driver
- * for a drive on the bus.
- */
-int
-acdmatch(parent, match, aux)
-	struct device *parent;
-	void *match, *aux;
-{
-	struct at_dev_link *sa = aux;
-
-#ifdef ATAPI_DEBUG_PROBE
-	printf("acdmatch: device %d\n",
-	    sa->id.config.device_type & ATAPI_DEVICE_TYPE_MASK);
-#endif
-
-	if (((sa->id.config.device_type & ATAPI_DEVICE_TYPE_MASK) ==
-	    ATAPI_DEVICE_TYPE_CD) || (sa->quirks & AQUIRK_CDROM))
-		return 1;
-	return 0;
-}
-
-/*
- * The routine called by the low level atapi routine when it discovers
- * A device suitable for this driver
- */
-void
-acdattach(parent, self, aux)
-	struct device *parent, *self;
-	void *aux;
-{
-	struct acd_softc *acd = (void *)self;
-	struct at_dev_link *sa = aux;
-	struct atapi_cappage *cap;
-
-	printf("\n");
-
-	sa->device_softc = acd;
-	sa->start = acdstart;
-	sa->done = acddone;
-	sa->flags |= ADEV_REMOVABLE;
-	sa->openings = 1;
-	acd->ad_link = sa;
-
-	/*
-	 * Initialize and attach the disk structure.
-	 */
-	acd->sc_dk.dk_driver = &acddkdriver;
-	acd->sc_dk.dk_name = acd->sc_dev.dv_xname;
-	disk_attach(&acd->sc_dk);
-
-	dk_establish(&acd->sc_dk, &acd->sc_dev);   
-
-	if (atapi_test_unit_ready(sa, A_POLLED | A_SILENT) != 0) {
-		/* To clear media change, etc ...*/
-		delay(1000);
-		if (atapi_test_unit_ready(sa, A_POLLED | A_SILENT) != 0)
-			acd->flags |= CDF_NOTREADY;
-	}
-
-	if (acd_get_mode(acd, &acd->mode_page, ATAPI_CAP_PAGE, CAPPAGESIZE,
-	    A_POLLED) != 0) {
-		printf("%s: can't MODE SENSE: acd_get_mode failed\n",
-		    self->dv_xname);
-		return;
-	}
-
-	/*
-	 * Display useful information about the drive (not media!).
-	 */
-	cap = &acd->mode_page.page_cap;
-
-	/* Don't print anything unless it looks valid. */
-	if (cap->cur_speed > 0) {
-		printf ("%s: ", self->dv_xname);
-		if (cap->cur_speed != cap->max_speed)
-			printf ("%d/", cap->cur_speed * 1000 / 1024);
-		printf ("%dKb/sec", cap->max_speed * 1000 / 1024);
-		if (cap->buf_size)
-			printf (", %dKb cache", cap->buf_size);
-		if (cap->format_cap & FORMAT_AUDIO_PLAY)
-			printf (", audio play");
-		if (cap->max_vol_levels)
-			printf (", %d volume levels", cap->max_vol_levels);
-		printf ("\n");
-	}
-
-	/* We can autoprobe AQUIRK_NODOORLOCK */
-	if (!(acd->ad_link->quirks & AQUIRK_NODOORLOCK)) {
-		if (atapi_prevent(acd->ad_link, PR_PREVENT)) {
-			acd->ad_link->quirks |= AQUIRK_NODOORLOCK;
-			printf ("%s: disabling door locks.\n", self->dv_xname);
-		} else
-			atapi_prevent(acd->ad_link, PR_ALLOW);
-	}
-}
-
-/*
- * Wait interruptibly for an exclusive lock.
- *
- * XXX
- * Several drivers do this; it should be abstracted and made MP-safe.
- */
-int
-acdlock(acd)
-	struct acd_softc *acd;
-{
-	int error;
-
-	while ((acd->flags & CDF_LOCKED) != 0) {
-		acd->flags |= CDF_WANTED;
-		if ((error = tsleep(acd, PRIBIO | PCATCH, "acdlck", 0)) != 0)
-			return error;
-	}
-	acd->flags |= CDF_LOCKED;
-	return 0;
-}
-
-/*
- * Unlock and wake up any waiters.
- */
-void
-acdunlock(acd)
-	struct acd_softc *acd;
-{
-
-	acd->flags &= ~CDF_LOCKED;
-	if ((acd->flags & CDF_WANTED) != 0) {
-		acd->flags &= ~CDF_WANTED;
-		wakeup(acd);
-	}
-}
-
-/*
- * open the device. Make sure the partition info is a up-to-date as can be.
- */
-int
-acdopen(dev, flag, fmt)
-	dev_t dev;
-	int flag, fmt;
-{
-	struct acd_softc *acd;
-	struct at_dev_link *ad_link;
-	int unit, part;
-	int error;
-
-	ACD_DEBUG_PRINT(("acd: open\n"));
-
-	unit = CDUNIT(dev);
-	if (unit >= acd_cd.cd_ndevs)
-		return ENXIO;
-	acd = acd_cd.cd_devs[unit];
-	if (acd == NULL)
-		return ENXIO;
-
-	ad_link = acd->ad_link;
-
-	error = atapi_test_unit_ready(ad_link, A_SILENT);
-	if ((error != 0) && (acd->flags & CDF_NOTREADY)) {
-		/* Do it again. */
-		delay(1000);
-		error = atapi_test_unit_ready(ad_link, A_SILENT);
-	}
-
-	if (error != 0) {
-		if (error != UNIT_ATTENTION)
-			return EIO;
-		if ((ad_link->flags & ADEV_OPEN) != 0)
-			return EIO;
-	}
-
-	error = acdlock(acd);
-	if (error)
-		return error;
-
-	if (acd->sc_dk.dk_openmask != 0) {
-		/*
-		 * If any partition is open, but the disk has been invalidated,
-		 * disallow further opens.
-		 */
-		if ((ad_link->flags & ADEV_MEDIA_LOADED) == 0) {
-			error = EIO;
-			goto bad3;
-		}
-	} else {
-		ad_link->flags |= ADEV_OPEN;
-
-		/* Lock the pack in. */
-		if ((error = atapi_prevent(ad_link, PR_PREVENT)) != 0)
-			goto bad;
-
-		if ((ad_link->flags & ADEV_MEDIA_LOADED) == 0) {
-			ad_link->flags |= ADEV_MEDIA_LOADED;
-
-			/* Load the physical device parameters. */
-			if (acd_get_parms(acd, 0) != 0) {
-				error = ENXIO;
-				goto bad2;
-			}
-
-			/* Fabricate a disk label. */
-			acdgetdisklabel(acd);
-		}
-	}
-
-	part = CDPART(dev);
-
-	/* Check that the partition exists. */
-	if (part != RAW_PART &&
-	    (part >= acd->sc_dk.dk_label->d_npartitions ||
-	    acd->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
-		error = ENXIO;
-		goto bad;
-	}
-
-	/* Insure only one open at a time. */
-	switch (fmt) {
-	case S_IFCHR:
-		acd->sc_dk.dk_copenmask |= (1 << part);
-		break;
-	case S_IFBLK:
-		acd->sc_dk.dk_bopenmask |= (1 << part);
-		break;
-	}
-	acd->sc_dk.dk_openmask =
-	    acd->sc_dk.dk_copenmask | acd->sc_dk.dk_bopenmask;
-
-	ACD_DEBUG_PRINT(("acd: open complete\n"));
-
-	acdunlock(acd);
-	return 0;
-
-bad2:
-	ad_link->flags &= ~ADEV_MEDIA_LOADED;
-
-bad:
-	if (acd->sc_dk.dk_openmask == 0) {
-		atapi_prevent(ad_link, PR_ALLOW);
-		ad_link->flags &= ~ADEV_OPEN;
-	}
-
-bad3:
-	acdunlock(acd);
-	return error;
-}
-
-/*
- * close the device.. only called if we are the LAST
- * occurence of an open device
- */
-int
-acdclose(dev, flag, fmt)
-	dev_t dev;
-	int flag, fmt;
-{
-	struct acd_softc *acd = acd_cd.cd_devs[CDUNIT(dev)];
-	int part = CDPART(dev);
-	int error;
-
-	if ((error = acdlock(acd)) != 0)
-		return error;
-
-	switch (fmt) {
-	case S_IFCHR:
-		acd->sc_dk.dk_copenmask &= ~(1 << part);
-		break;
-	case S_IFBLK:
-		acd->sc_dk.dk_bopenmask &= ~(1 << part);
-		break;
-	}
-	acd->sc_dk.dk_openmask =
-	    acd->sc_dk.dk_copenmask | acd->sc_dk.dk_bopenmask;
-
-	if (acd->sc_dk.dk_openmask == 0) {
-		/* XXXX Must wait for I/O to complete! */
-
-		atapi_prevent(acd->ad_link, PR_ALLOW);
-		acd->ad_link->flags &= ~ADEV_OPEN;
-
-		if (acd->ad_link->flags & ADEV_EJECTING) {
-			atapi_start_stop(acd->ad_link, SSS_STOP|SSS_LOEJ, 0);
-
-			acd->ad_link->flags &= ~ADEV_EJECTING;
-		}
-	}
-
-	acdunlock(acd);
-	return 0;
-}
-
-/*
- * Actually translate the requested transfer into one the physical driver can
- * understand.  The transfer is described by a buf and will include only one
- * physical transfer.
- */
-void
-acdstrategy(bp)
-	struct buf *bp;
-{
-	struct acd_softc *acd = acd_cd.cd_devs[CDUNIT(bp->b_dev)];
-	int opri;
-
-	ACD_DEBUG_PRINT(("acdstrategy\n"));
-
-	/*
-	 * The transfer must be a whole number of blocks.
-	 */
-	if ((bp->b_bcount % acd->sc_dk.dk_label->d_secsize) != 0) {
-		bp->b_error = EINVAL;
-		goto bad;
-	}
-	if ((bp->b_flags & (B_READ|B_WRITE)) == B_WRITE) {
-		bp->b_error = EROFS;
-		goto bad;
-	}
-	/*
-	 * If the device has been made invalid, error out
-	 * maybe the media changed
-	 */
-	if ((acd->ad_link->flags & ADEV_MEDIA_LOADED) == 0) {
-		bp->b_error = EIO;
-		goto bad;
-	}
-	/*
-	 * If it's a null transfer, return immediately
-	 */
-	if (bp->b_bcount == 0)
-		goto done;
-
-	/*
-	 * Do bounds checking, adjust transfer. if error, process.
-	 * If end of partition, just return.
-	 */
-	if (CDPART(bp->b_dev) != RAW_PART &&
-	    bounds_check_with_label(bp, acd->sc_dk.dk_label,
-	    acd->sc_dk.dk_cpulabel,
-	    (acd->flags & (CDF_WLABEL|CDF_LABELLING)) != 0) <= 0)
-		goto done;
-
-	opri = splbio();
-
-	/*
-	 * Place it in the queue of disk activities for this disk
-	 */
-	disksort(&acd->buf_queue, bp);
-
-	/*
-	 * Tell the device to get going on the transfer if it's
-	 * not doing anything, otherwise just wait for completion
-	 */
-	acdstart(acd);
-
-	splx(opri);
-	return;
-
-bad:
-	bp->b_flags |= B_ERROR;
-done:
-	/*
-	 * Correctly set the buf to indicate a completed xfer
-	 */
-	bp->b_resid = bp->b_bcount;
-	biodone(bp);
-}
-
-/*
- * acdstart looks to see if there is a buf waiting for the device
- * and that the device is not already busy. If both are true,
- * It deques the buf and creates a atapi command to perform the
- * transfer in the buf. The transfer request will call atapi_done
- * on completion, which will in turn call this routine again
- * so that the next queued transfer is performed.
- * The bufs are queued by the strategy routine (cdstrategy)
- *
- * This routine is also called after other non-queued requests
- * have been made of the atapi driver, to ensure that the queue
- * continues to be drained.
- *
- * must be called at the correct (highish) spl level
- * cdstart() is called at splbio from cdstrategy and atapi_done
- */
-void
-acdstart(vp)
-	void *vp;
-{
-	struct acd_softc *acd = vp;
-	struct at_dev_link *ad_link;
-	struct buf *bp = 0;
-	struct buf *dp;
-	struct atapi_read cmd;
-	u_int32_t blkno, nblks;
-	struct partition *p;
-
-	ACD_DEBUG_PRINT(("acd: acdstart\n"));
-
-#ifdef DIAGNOSTIC
-	if (acd == NULL) {
-		printf("acdstart: null acd\n");
-		return;
-	}
-#endif
-
-	ad_link = acd->ad_link;
-
-#ifdef DIAGNOSTIC
-	if (ad_link == NULL) {
-		printf("acdstart: null ad_link\n");
-		return;
-	}
-#endif
-	/*
-	 * Check if the device has room for another command
-	 */
-	while (ad_link->openings > 0) {
-		/*
-		 * there is excess capacity, but a special waits
-		 * It'll need the adapter as soon as we clear out of the
-		 * way and let it run (user level wait).
-		 */
-		if (ad_link->flags & ADEV_WAITING) {
-			ATAPI_DEBUG_PRINT(("acdstart: waking up\n"));
-
-			ad_link->flags &= ~ADEV_WAITING;
-			wakeup((caddr_t)ad_link);
-			return;
-		}
-		
-		/*
-		 * See if there is a buf with work for us to do..
-		 */
-		dp = &acd->buf_queue;
-#ifdef ACD_DEBUG
-		if (dp == NULL) {
-			printf("acdstart: null dp\n");
-			return;
-		}
-#endif
-		if ((bp = dp->b_actf) == NULL)	/* yes, an assign */
-			return;
-
-		ACD_DEBUG_PRINT(("acdstart: a buf\n"));
-
-		dp->b_actf = bp->b_actf;
-
-		/*
-		 * If the device has become invalid, abort all the
-		 * reads and writes until all files have been closed and
-		 * re-opened
-		 */
-		if ((ad_link->flags & ADEV_MEDIA_LOADED) == 0) {
-			bp->b_error = EIO;
-			bp->b_flags |= B_ERROR;
-			bp->b_resid = bp->b_bcount;
-			biodone(bp);
-			continue;
-		}
-
-		/*
-		 *
-		 * First, translate the block to absolute and put it in terms
-		 * of the logical blocksize of the device.
-		 */
-		blkno =
-		    bp->b_blkno / (acd->sc_dk.dk_label->d_secsize / DEV_BSIZE);
-		if (CDPART(bp->b_dev) != RAW_PART) {
-			p = &acd->sc_dk.dk_label->d_partitions[
-			    CDPART(bp->b_dev)];
-			blkno += p->p_offset;
-		}
-		nblks = howmany(bp->b_bcount, acd->sc_dk.dk_label->d_secsize);
-
-		ACD_DEBUG_PRINT(("acdstart: blkno %d nblk %d\n", blkno,
-		    nblks));
-
-		/*
-		 *  Fill out the atapi command
-		 */
-		bzero(&cmd, sizeof(cmd));
-		cmd.opcode = ATAPI_READ;
-		_lto4b(blkno, cmd.lba);
-		_lto2b(nblks, cmd.length);
-
-		/* Instrumentation. */
-		disk_busy(&acd->sc_dk);
-
-		/*
-		 * Call the routine that chats with the adapter.
-		 * Note: we cannot sleep as we may be an interrupt
-		 */
-		if (atapi_exec_io(ad_link, &cmd, sizeof(cmd), bp, A_NOSLEEP)) {
-		 	disk_unbusy(&acd->sc_dk, 0);
-			printf("%s: not queued", acd->sc_dev.dv_xname);
-		}
-	}
-}
-
-int
-acdread(dev, uio)
-	dev_t dev;
-	struct uio *uio;
-{
-
-	return (physio(acdstrategy, NULL, dev, B_READ, acdminphys, uio));
-}
-
-int
-acdwrite(dev, uio)
-	dev_t dev;
-	struct uio *uio;
-{
-
-	return (physio(acdstrategy, NULL, dev, B_WRITE, acdminphys, uio));
-}
-
-#if 0
-/* Not used anywhere, left here in case that changes. */
-
-/*
- * conversion between minute-seconde-frame and logical block adress
- * adresses format
- */
-static void
-lba2msf (lba, m, s, f)
-	u_int32_t lba;
-	u_int8_t *m, *s, *f;
-{
-	u_int32_t tmp;
-	tmp = lba + CD_BLOCK_OFFSET;	/* offset of first logical frame */
-	tmp &= 0xffffff;		/* negative lbas use only 24 bits */
-	*m = tmp / (CD_SECS * CD_FRAMES);
-	tmp %= (CD_SECS * CD_FRAMES);
-	*s = tmp / CD_FRAMES;
-	*f = tmp % CD_FRAMES;
-}
-#endif
-
-static __inline u_int32_t
-msf2lba (m, s, f)
-	u_int8_t m, s, f;
-{
-	return (((m * CD_SECS) + s) * CD_FRAMES + f) - CD_BLOCK_OFFSET;
-}
-
-/*
- * Perform special action on behalf of the user.
- * Knows about the internals of this device
- */
-int
-acdioctl(dev, cmd, addr, flag, p)
-	dev_t dev;
-	u_long cmd;
-	caddr_t addr;
-	int flag;
-	struct proc *p;
-{
-	struct acd_softc *acd = acd_cd.cd_devs[CDUNIT(dev)];
-	int error;
-
-	/*
-	 * If the device is not valid.. abandon ship
-	 */
-	if ((acd->ad_link->flags & ADEV_MEDIA_LOADED) == 0)
-		return EIO;
-
-	switch (cmd) {
-	case DIOCRLDINFO:
-		acdgetdisklabel(acd);
-		return 0;
-	case DIOCGDINFO:
-	case DIOCGPDINFO:
-		*(struct disklabel *)addr = *acd->sc_dk.dk_label;
-		return 0;
-
-	case DIOCGPART:
-		((struct partinfo *)addr)->disklab = acd->sc_dk.dk_label;
-		((struct partinfo *)addr)->part =
-		    &acd->sc_dk.dk_label->d_partitions[CDPART(dev)];
-		return 0;
-
-	case DIOCWDINFO:
-	case DIOCSDINFO:
-		if ((flag & FWRITE) == 0)
-			return EBADF;
-
-		if ((error = acdlock(acd)) != 0)
-			return error;
-		acd->flags |= CDF_LABELLING;
-
-		error = setdisklabel(acd->sc_dk.dk_label,
-		    (struct disklabel *)addr, /*acd->sc_dk.dk_openmask : */0,
-		    acd->sc_dk.dk_cpulabel);
-		if (error == 0) {
-			/* XXX ?? */
-		}
-
-		acd->flags &= ~CDF_LABELLING;
-		acdunlock(acd);
-		return error;
-
-	case DIOCWLABEL:
-		return EROFS;
-
-	case CDIOCPLAYTRACKS: {
-		struct ioc_play_track *args = (struct ioc_play_track *)addr;
-
-		return acd_play_tracks(acd, args->start_track,
-		    args->start_index, args->end_track, args->end_index);
-	}
-
-	case CDIOCPLAYMSF: {
-		struct ioc_play_msf *args = (struct ioc_play_msf *)addr;
-
-		return acd_play_msf(acd, args->start_m, args->start_s,
-		    args->start_f, args->end_m, args->end_s, args->end_f);
-	}
-
-	case CDIOCPLAYBLOCKS: {
-		struct ioc_play_blocks *args = (struct ioc_play_blocks *)addr;
-
-		return acd_play_big(acd, args->blk, args->len);
-	}
-
-	case CDIOCREADSUBCHANNEL: {
-		struct ioc_read_subchannel *args =
-		    (struct ioc_read_subchannel *)addr;
-		struct cd_sub_channel_info data;
-		int len = args->data_len;
-
-		if (len > (int)sizeof(data) ||
-		    len < (int)sizeof(struct cd_sub_channel_header))
-			return EINVAL;
-
-		error = acd_read_subchannel(acd, args->address_format,
-		    args->data_format, args->track, &data, len);
-		if (error)
-			return error;
-		return copyout(&data, args->data, len);
-	}
-
-	/* XXX Remove endian dependency */
-	case CDIOREADTOCHEADER: {
-		struct ioc_toc_header hdr;
-
-		error = acd_read_toc(acd, 0, 0, &hdr, sizeof(hdr));
-		if (error)
-			return error;
-		if (acd->ad_link->quirks & AQUIRK_LITTLETOC)
-			bswap((u_int8_t *)&hdr.len, sizeof(hdr.len));
-		bcopy(&hdr, addr, sizeof(hdr));
-		return 0;
-	}
-
-	/* XXX Remove endian dependency */
-	case CDIOREADTOCENTRYS: {
-		struct ioc_read_toc_entry *te =
-		    (struct ioc_read_toc_entry *)addr;
-		struct cd_toc toc;
-		struct ioc_toc_header *th = &toc.hdr;
-		int len = te->data_len;
-		int ntracks;
-
-		if (len > (int)sizeof(toc.tab) ||
-		    len < (int)sizeof(struct cd_toc_entry))
-			return EINVAL;
-
-		error = acd_read_toc(acd, te->address_format,
-		    te->starting_track, &toc,
-		    len + sizeof(struct ioc_toc_header));
-		if (error)
-			return error;
-
-		if (te->address_format == CD_LBA_FORMAT) {
-			for (ntracks =
-			    th->ending_track - th->starting_track + 1;
-		            ntracks >= 0; ntracks--) {
-				toc.tab[ntracks].addr_type = CD_LBA_FORMAT;
-				if (acd->ad_link->quirks & AQUIRK_LITTLETOC)
-					bswap((u_int8_t*)
-					    &toc.tab[ntracks].addr.addr,
-					    sizeof(toc.tab[ntracks].addr.addr));
-			}
-		}
-		if (acd->ad_link->quirks & AQUIRK_LITTLETOC)
-			bswap((u_int8_t*)&th->len, sizeof(th->len));
-		len = min(len, ntohs(th->len) - (sizeof(th->starting_track) +
-			sizeof(th->ending_track)));
-		return copyout(toc.tab, te->data, len);
-	}
-
-	case CDIOCSETPATCH: {
-		struct ioc_patch *arg = (struct ioc_patch *)addr;
-
-		return acd_setchan(acd, arg->patch[0], arg->patch[1],
-		    arg->patch[2], arg->patch[3]);
-	}
-
-	case CDIOCGETVOL: {
-		struct ioc_vol *arg = (struct ioc_vol *)addr;
-		struct atapi_mode_data data;
-
-		error = acd_get_mode(acd, &data, ATAPI_AUDIO_PAGE,
-		    AUDIOPAGESIZE, 0);
-		if (error)
-			return error;
-		arg->vol[0] = data.page_audio.port[0].volume;
-		arg->vol[1] = data.page_audio.port[1].volume;
-		arg->vol[2] = data.page_audio.port[2].volume;
-		arg->vol[3] = data.page_audio.port[3].volume;
-		return 0;
-	}
-
-	case CDIOCSETVOL: {
-		struct ioc_vol *arg = (struct ioc_vol *)addr;
-		struct atapi_mode_data data, mask;
-
-		error = acd_get_mode(acd, &data, ATAPI_AUDIO_PAGE,
-		    AUDIOPAGESIZE, 0);
-		if (error)
-			return error;
-
-		error = acd_get_mode(acd, &mask, ATAPI_AUDIO_PAGE_MASK,
-		    AUDIOPAGESIZE, 0);
-		if (error)
-			return error;
-
-		data.page_audio.port[0].volume = arg->vol[0] &
-		    mask.page_audio.port[0].volume;
-		data.page_audio.port[1].volume = arg->vol[1] &
-		    mask.page_audio.port[1].volume;
-		data.page_audio.port[2].volume = arg->vol[2] &
-		    mask.page_audio.port[2].volume;
-		data.page_audio.port[3].volume = arg->vol[3] &
-		    mask.page_audio.port[3].volume;
-
-		return acd_set_mode(acd, &data, AUDIOPAGESIZE);
-	}
-
-	case CDIOCSETMONO: {
-		return acd_setchan(acd, BOTH_CHANNEL, BOTH_CHANNEL,
-		    MUTE_CHANNEL, MUTE_CHANNEL);
-	}
-
-	case CDIOCSETSTEREO: {
-		return acd_setchan(acd, LEFT_CHANNEL, RIGHT_CHANNEL,
-		    MUTE_CHANNEL, MUTE_CHANNEL);
-	}
-
-	case CDIOCSETMUTE: {
-		return acd_setchan(acd, MUTE_CHANNEL, MUTE_CHANNEL,
-		    MUTE_CHANNEL, MUTE_CHANNEL);
-	}
-
-	case CDIOCSETLEFT: {
-		return acd_setchan(acd, LEFT_CHANNEL, LEFT_CHANNEL,
-		    MUTE_CHANNEL, MUTE_CHANNEL);
-	}
-
-	case CDIOCSETRIGHT: {
-		return acd_setchan(acd, RIGHT_CHANNEL, RIGHT_CHANNEL,
-		    MUTE_CHANNEL, MUTE_CHANNEL);
-	}
-
-	case CDIOCRESUME:
-		return acd_pause(acd, PA_RESUME);
-
-	case CDIOCPAUSE:
-		return acd_pause(acd, PA_PAUSE);
-
-	case CDIOCSTART:
-		return atapi_start_stop(acd->ad_link, SSS_START, 0);
-
-	case CDIOCSTOP:
-		return atapi_start_stop(acd->ad_link, SSS_STOP, 0);
-
-	case MTIOCTOP:
-		if (((struct mtop *)addr)->mt_op != MTOFFL)
-			return EIO;
-		/* FALLTHROUGH */
-
-	case CDIOCEJECT:	/* FALLTHROUGH */
-	case DIOCEJECT:
-		acd->ad_link->flags |= ADEV_EJECTING;
-		return 0;
-
-	case CDIOCALLOW:
-		return atapi_prevent(acd->ad_link, PR_ALLOW);
-
-	case CDIOCPREVENT:
-		return atapi_prevent(acd->ad_link, PR_PREVENT);
-
-	case DIOCLOCK:
-		return atapi_prevent(acd->ad_link,
-		    (*(int *)addr) ? PR_PREVENT : PR_ALLOW);
-
-	case CDIOCRESET:
-		return acd_reset(acd);
-
-	default:
-		return ENOTTY;
-	}
-
-#ifdef DIAGNOSTIC
-	panic("acdioctl: impossible");
-#endif
-}
-
-/*
- * Load the label information on the named device
- * Actually fabricate a disklabel
- *
- * EVENTUALLY take information about different
- * data tracks from the TOC and put it in the disklabel
- */
-void
-acdgetdisklabel(acd)
-	struct acd_softc *acd;
-{
-	struct disklabel *lp = acd->sc_dk.dk_label;
-	char *errstring;
-	u_int8_t hdr[TOC_HEADER_SZ], *toc, *ent;
-	u_int32_t lba, nlba;
-	int i, n, len, is_data, data_track = -1;
-
-	bzero(lp, sizeof(struct disklabel));
-	bzero(acd->sc_dk.dk_cpulabel, sizeof(struct cpu_disklabel));
-
-	lp->d_secsize = acd->params.blksize;
-	lp->d_ntracks = 1;
-	lp->d_nsectors = 100;
-	lp->d_ncylinders = (acd->params.disksize / 100) + 1;
-	lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;
-	if (lp->d_secpercyl == 0) {
-		lp->d_secpercyl = 100;
-		/* as long as it's not 0 - readdisklabel divides by it (?) */
-	}
-
-	strncpy(lp->d_typename, "ATAPI CD-ROM", 16);
-	lp->d_type = DTYPE_SCSI;	/* XXX */
-	strncpy(lp->d_packname, "fictitious", 16);
-	lp->d_secperunit = acd->params.disksize;
-	lp->d_rpm = 300;
-	lp->d_interleave = 1;
-	lp->d_flags = D_REMOVABLE;
-
-	lp->d_magic = DISKMAGIC;
-	lp->d_magic2 = DISKMAGIC;
-	lp->d_checksum = dkcksum(lp);
-
-	/*
-	 * Read the TOC and loop throught the individual tracks and lay them
-	 * out in our disklabel.  If there is a data track, call the generic
-	 * disklabel read routine.  XXX should we move all data tracks up front
-	 * before any other tracks?
-	 */
-	if (acd_read_toc(acd, 0, 0, hdr, TOC_HEADER_SZ))
-		return;
-	n = min(hdr[TOC_HEADER_ENDING_TRACK] - hdr[TOC_HEADER_STARTING_TRACK] +
-	   1, MAXPARTITIONS);
-	len = TOC_HEADER_SZ + (n + 1) * TOC_ENTRY_SZ;
-	MALLOC(toc, u_int8_t *, len, M_TEMP, M_WAITOK);
-	if (acd_read_toc (acd, CD_LBA_FORMAT, 0, toc, len))
-		goto done;
-
-	/* XXX - these values for BBSIZE and SBSIZE assume ffs */
-	lp->d_bbsize = BBSIZE;
-	lp->d_sbsize = SBSIZE;
-
-	/* The raw partition is special.  */
-	lp->d_partitions[RAW_PART].p_offset = 0;
-	lp->d_partitions[RAW_PART].p_size =
-	    lp->d_secperunit * lp->d_secsize / DEV_BSIZE;
-	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
-
-	/* Create the partition table.  */
-	lp->d_npartitions = max(RAW_PART, n) + 1;
-	ent = toc + TOC_HEADER_SZ;
-	lba = ((acd->ad_link->quirks & AQUIRK_LITTLETOC) ?
-	    ent[TOC_ENTRY_MSF_LBA] | ent[TOC_ENTRY_MSF_LBA + 1] << 8 |
-	    ent[TOC_ENTRY_MSF_LBA + 2] << 16 |
-	    ent[TOC_ENTRY_MSF_LBA + 3] << 24 :
-	    ent[TOC_ENTRY_MSF_LBA] << 24 | ent[TOC_ENTRY_MSF_LBA + 1] << 16 |
-	    ent[TOC_ENTRY_MSF_LBA + 2] << 8 | ent[TOC_ENTRY_MSF_LBA + 3]) *
-	    lp->d_secsize / DEV_BSIZE;
-
-	for (i = 0; i < (n > RAW_PART + 1 ? n + 1 : n); i++) {
-		/* The raw partition was specially handled above.  */
-		if (i != RAW_PART) {
-			is_data = toc[TOC_HEADER_SZ +
-			    TOC_ENTRY_CONTROL_ADDR_TYPE] & 4;
-			lp->d_partitions[i].p_fstype =
-			    is_data ? FS_UNUSED : FS_OTHER;
-			if (is_data && data_track == -1)
-				data_track = i;
-			ent += TOC_ENTRY_SZ;
-			nlba = ((acd->ad_link->quirks & AQUIRK_LITTLETOC) ?
-			    ent[TOC_ENTRY_MSF_LBA] |
-			    ent[TOC_ENTRY_MSF_LBA + 1] << 8 |
-			    ent[TOC_ENTRY_MSF_LBA + 2] << 16 |
-			    ent[TOC_ENTRY_MSF_LBA + 3] << 24 :
-			    ent[TOC_ENTRY_MSF_LBA] << 24 |
-			    ent[TOC_ENTRY_MSF_LBA + 1] << 16 |
-			    ent[TOC_ENTRY_MSF_LBA + 2] << 8 |
-			    ent[TOC_ENTRY_MSF_LBA + 3]) * lp->d_secsize /
-			    DEV_BSIZE;
-			lp->d_partitions[i].p_offset = lba;
-			lp->d_partitions[i].p_size = nlba - lba;
-			lba = nlba;
-		}
-	}
-
-	/* We have a data track, look in there for a real disklabel.  */
-	if (data_track != -1) {
-#ifdef notyet
-		/*
-		 * Reading a disklabel inside the track we setup above
-		 * does not yet work, for unknown reasons.
-		 */
-		errstring = readdisklabel(MAKECDDEV(0, acd->sc_dev.dv_unit,
-		    data_track), acdstrategy, lp, acd->sc_dk.dk_cpulabel, 0);
-#else
-		errstring = readdisklabel(MAKECDDEV(0, acd->sc_dev.dv_unit,
-		    RAW_PART), acdstrategy, lp, acd->sc_dk.dk_cpulabel, 0);
-#endif
-		/*if (errstring)
-			printf("%s: %s\n", acd->sc_dev.dv_xname, errstring);*/
-	}
-
-done:
-	FREE(toc, M_TEMP);
-}
-
-/*
- * Find out from the device what it's capacity is
- */
-u_int32_t
-acd_size(acd, flags)
-	struct acd_softc *acd;
-	int flags;
-{
-	struct atapi_read_cd_capacity_data rdcap;
-	struct atapi_read_cd_capacity cmd;
-	int result;
-
-	if (acd->ad_link->quirks & AQUIRK_NOCAPACITY) {
-		/*
-		 * the drive doesn't support the READ_CD_CAPACITY command
-		 * use a fake size
-		 */
-		acd->params.blksize = 2048;
-		acd->params.disksize = 400000;
-
-		return 400000;
-	}
-
-	/*
-	 * make up a atapi command and ask the atapi driver to do
-	 * it for you.
-	 */
-	bzero(&cmd, sizeof(cmd));
-	cmd.opcode = ATAPI_READ_CD_CAPACITY;
-	cmd.len = sizeof(rdcap);
-
-	/*
-	 * If the command works, interpret the result as a 4 byte
-	 * number of blocks and a blocksize
-	 */
-	result = atapi_exec_cmd(acd->ad_link, &cmd, sizeof(cmd),
-				&rdcap, sizeof(rdcap), B_READ, 0);
-	if (result != 0) {
-		u_int8_t error = result >> 8;
-		/* Get the sense key and check for an illegal request */
-		if ((error >> 4) == ATAPI_SK_ILLEGAL_REQUEST) {
-			acd->ad_link->quirks |= AQUIRK_NOCAPACITY;
-			return acd_size(acd, flags);
-		}
-		ATAPI_DEBUG_PRINT(("ATAPI_READ_CD_CAPACITY failed\n"));
-		return 0;
-	}
-
-	acd->params.blksize = _4btol((u_int8_t*)&rdcap.blksize);
-	if (acd->params.blksize < 512 || acd->params.blksize > 2048)
-		acd->params.blksize = 2048;	/* some drives lie ! */
-	acd->params.disksize = _4btol((u_int8_t*)&rdcap.size);
-
-	ATAPI_DEBUG_PRINT(("acd_size: %ld %ld\n", acd->params.blksize,
-	    acd->params.disksize));
-	return acd->params.disksize;
-}
-
-/*
- * Get the requested page into the buffer given
- */
-int
-acd_get_mode(acd, data, page, len, flags)
-	struct acd_softc *acd;
-	struct atapi_mode_data *data;
-	int page, len, flags;
-{
-	struct atapi_mode_sense atapi_cmd;
-	int error;
-
-	bzero(&atapi_cmd, sizeof(atapi_cmd));
-	bzero(data, sizeof(struct atapi_mode_data));
-	atapi_cmd.opcode = ATAPI_MODE_SENSE;
-	atapi_cmd.page_code_control = page;
-	_lto2b(len, atapi_cmd.length);
-
-	error = atapi_exec_cmd(acd->ad_link, &atapi_cmd, sizeof(atapi_cmd),
-	    data, len, B_READ, flags);
-	if (!error) {
-		switch(page) {
-		case ATAPI_CAP_PAGE: {
-			struct atapi_cappage *fix = &data->page_cap;
-
-        		/*
-	         	 * Fix cappage entries in place.
-			 */
-			fix->max_speed = _2btos((u_int8_t *)&fix->max_speed);
-			fix->max_vol_levels =
-			    _2btos((u_int8_t *)&fix->max_vol_levels);
-			fix->buf_size = _2btos((u_int8_t *)&fix->buf_size);
-			fix->cur_speed = _2btos((u_int8_t *)&fix->cur_speed);
-			break;
-		      }
-		}
-	}
-
-	return(error);
-}
-
-/*
- * Get the requested page into the buffer given
- */
-int
-acd_set_mode(acd, data, len)
-	struct acd_softc *acd;
-	struct atapi_mode_data *data;
-	int len;
-{
-	struct atapi_mode_select atapi_cmd;
-
-	bzero(&data->header.length, sizeof(data->header.length));
-	bzero(&atapi_cmd, sizeof(atapi_cmd));
-
-	atapi_cmd.opcode = ATAPI_MODE_SELECT;
-	atapi_cmd.flags |= MODE_BIT;
-	atapi_cmd.page = data->page_code;
-	_lto2b(len, atapi_cmd.length);
-
-	return atapi_exec_cmd(acd->ad_link, &atapi_cmd, sizeof(atapi_cmd),
-	    data, len, B_WRITE, 0);
-}
-
-int
-acd_setchan(acd, c0, c1, c2, c3)
-	struct acd_softc *acd;
-	u_char c0, c1, c2, c3;
-{
-	struct atapi_mode_data data;
-	int error;
-
-	error = acd_get_mode(acd, &data, ATAPI_AUDIO_PAGE, AUDIOPAGESIZE, 0);
-	if (error)
-		return error;
-
-	data.page_audio.port[0].channels = c0;
-	data.page_audio.port[1].channels = c1;
-	data.page_audio.port[2].channels = c2;
-	data.page_audio.port[3].channels = c3;
-
-	return acd_set_mode(acd, &data, AUDIOPAGESIZE);
-}
-
-/*
- * Get atapi driver to send a "start playing" command
- */
-int
-acd_play_big(acd, blkno, nblks)
-	struct acd_softc *acd;
-	int blkno, nblks;
-{
-	struct atapi_play_big atapi_cmd;
-
-	bzero(&atapi_cmd, sizeof(atapi_cmd));
-	atapi_cmd.opcode = ATAPI_PLAY_BIG;
-	_lto4b(blkno, atapi_cmd.lba);
-	_lto4b(nblks, atapi_cmd.length);
-
-	return atapi_exec_cmd(acd->ad_link, &atapi_cmd, sizeof(atapi_cmd),
-	    NULL, 0, 0, 0);
-}
-
-int
-acd_load_toc(acd, toc)
-	struct acd_softc *acd;
-	struct cd_toc *toc;
-{
-	int i, ntracks, len, error;
-	u_int32_t *lba;
-
-	error = acd_read_toc(acd, 0, 0, toc, sizeof(toc->hdr));
-	if (error)
-		return error;
-
-	ntracks = toc->hdr.ending_track-toc->hdr.starting_track + 1;
-	len = (ntracks+1) * sizeof(struct cd_toc_entry) + sizeof(toc->hdr);
-	error = acd_read_toc(acd, CD_MSF_FORMAT, 0, toc, len);
-	if (error)
-		return(error);
-	for (i = 0; i <= ntracks; i++) {
-		lba = (u_int32_t*)toc->tab[i].addr.addr;
-		*lba = msf2lba(toc->tab[i].addr.addr[1],
-		    toc->tab[i].addr.addr[2], toc->tab[i].addr.addr[3]);
-	}
-	return 0;
-}
-
-/*
- * Get atapi driver to send a "start playing" command
- */
-int
-acd_play_tracks(acd, strack, sindex, etrack, eindex)
-	struct acd_softc *acd;
-	int strack, sindex, etrack, eindex;
-{
-	u_int32_t *start, *end, len;
-	struct cd_toc toc;
-	int error;
-
-	if (!etrack)
-		return EIO;
-	if (strack > etrack)
-		return EINVAL;
-
-	error = acd_load_toc(acd, &toc);
-	if (error)
-		return error;
-
-	if (++etrack > (toc.hdr.ending_track + 1))
-		etrack = toc.hdr.ending_track + 1;
-
-	strack -= toc.hdr.starting_track;
-	etrack -= toc.hdr.starting_track;
-	if (strack < 0)
-		return EINVAL;
-
-	start = (u_int32_t*)toc.tab[strack].addr.addr;
-	end = (u_int32_t*)toc.tab[etrack].addr.addr;
-	len = *end - *start;
-
-	return acd_play_big(acd, *start, len);
-}
-
-/*
- * Get atapi driver to send a "play msf" command
- */
-int
-acd_play_msf(acd, startm, starts, startf, endm, ends, endf)
-	struct acd_softc *acd;
-	int startm, starts, startf, endm, ends, endf;
-{
-	struct atapi_play_msf atapi_cmd;
-
-	bzero(&atapi_cmd, sizeof(atapi_cmd));
-	atapi_cmd.opcode = ATAPI_PLAY_MSF;
-	atapi_cmd.start_m = startm;
-	atapi_cmd.start_s = starts;
-	atapi_cmd.start_f = startf;
-	atapi_cmd.end_m = endm;
-	atapi_cmd.end_s = ends;
-	atapi_cmd.end_f = endf;
-
-	return atapi_exec_cmd(acd->ad_link, (struct atapi_generic *)&atapi_cmd,
-	    sizeof(atapi_cmd), NULL, 0, 0, 0);
-}
-
-/*
- * Get atapi driver to send a "start up" command
- */
-int
-acd_pause(acd, go)
-	struct acd_softc *acd;
-	int go;
-{
-	struct atapi_pause_resume cmd;
-
-	bzero(&cmd, sizeof(cmd));
-	cmd.opcode = ATAPI_PAUSE_RESUME;
-	cmd.resume = go & 0xff;
-
-	return atapi_exec_cmd(acd->ad_link, &cmd , sizeof(cmd), 0, 0, 0, 0);
-}
-
-/*
- * Get atapi driver to send a "RESET" command
- */
-int
-acd_reset(acd)
-	struct acd_softc *acd;
-{
-#ifdef notyet	
-	return atapi_soft_reset(acd->ad_link);
-#else
- 	return 0;
-#endif
-}
-
-/*
- * Read subchannel
- */
-int
-acd_read_subchannel(acd, mode, format, track, data, len)
-	struct acd_softc *acd;
-	int mode, format, len;
-	struct cd_sub_channel_info *data;
-{
-	struct atapi_read_subchannel atapi_cmd;
-
-	bzero(&atapi_cmd, sizeof(atapi_cmd));
-
-	atapi_cmd.opcode = ATAPI_READ_SUBCHANNEL;
-	if (mode == CD_MSF_FORMAT)
-		atapi_cmd.flags[0] |= SUBCHAN_MSF;
-	if (len > (int)sizeof(struct cd_sub_channel_header))
-		atapi_cmd.flags[1] |= SUBCHAN_SUBQ;
-	atapi_cmd.subchan_format = format;
-	atapi_cmd.track = track;
-	_lto2b(len, atapi_cmd.length);
-
-	return atapi_exec_cmd(acd->ad_link, (struct atapi_generic *)&atapi_cmd,
-	    sizeof(struct atapi_read_subchannel), (u_char *)data, len, B_READ,
-	    0);
-}
-
-/*
- * Read table of contents
- */
-int
-acd_read_toc(acd, mode, start, data, len)
-	struct acd_softc *acd;
-	int mode, start, len;
-	void *data;
-{
-	struct atapi_read_toc atapi_cmd;
-
-	bzero(&atapi_cmd, sizeof(atapi_cmd));
-
-	atapi_cmd.opcode = ATAPI_READ_TOC;
-	if (mode == CD_MSF_FORMAT)
-		atapi_cmd.flags |= TOC_MSF;
-	atapi_cmd.track = start;
-	_lto2b(len, atapi_cmd.length);
-
-	return atapi_exec_cmd(acd->ad_link, (struct atapi_generic *)&atapi_cmd,
-	    sizeof(struct atapi_read_toc), data, len, B_READ, 0);
-}
-
-/*
- * Get the atapi driver to send a full inquiry to the device and use the
- * results to fill out the disk parameter structure.
- */
-int
-acd_get_parms(acd, flags)
-	struct acd_softc *acd;
-	int flags;
-{
-	/*
-	 * give a number of sectors so that sec * trks * cyls
-	 * is <= disk_size
-	 */
-	if (acd_size(acd, flags) == 0)
-		return ENXIO;
-
-	return 0;
-}
-
-int
-acdsize(dev)
-	dev_t dev;
-{
-	/* CD-ROMs are read-only. */
-	return -1;
-}
-
-void acdminphys(bp)
-	struct buf *bp;
-{
-	minphys(bp);
-}
-
-int
-acddump(dev, blkno, va, size)
-	dev_t dev;
-	daddr_t blkno;
-	caddr_t va;
-	size_t size;
-{
-	/* Not implemented. */
-	return ENXIO;
-}
-
-int
-acddone(vp)
-	void *vp;
-{
-	struct atapi_command_packet *acp = vp;
-	struct at_dev_link *ad_link = acp->ad_link;
-	struct acd_softc *acd = ad_link->device_softc;
-
-	if (acp->bp != NULL)
-		disk_unbusy(&acd->sc_dk,
-		    (acp->bp->b_bcount - acp->bp->b_resid));
-
-	return (0);     
-}
diff --git a/sys/dev/atapi/atapi.h b/sys/dev/atapi/atapi.h
deleted file mode 100644
index 4d82d3a1725..00000000000
--- a/sys/dev/atapi/atapi.h
+++ /dev/null
@@ -1,397 +0,0 @@
-/*	$OpenBSD: atapi.h,v 1.6 1997/07/07 19:48:48 niklas Exp $	*/
-
-/*
- * Copyright (c) 1996 Manuel Bouyer.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *  This product includes software developed by Manuel Bouyer.
- * 4. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
- * Definition of atapi commands and associated data structures
- */
-
-/* 
- * TEST UNIT READY (mandatory)
- */
-#define ATAPI_TEST_UNIT_READY		0x00
-
-struct atapi_test_unit_ready {
-	u_int8_t	opcode;
-	u_int8_t	reserved1[15];
-};
-
-/* 
- * START/STOP UNIT (mandatory)
- */ 
-#define ATAPI_START_STOP_UNIT		0x1b
- 
-struct atapi_start_stop_unit {
-	u_int8_t	opcode;
-	u_int8_t	flags;
-#define START_STOP_IMMED	0x01
-	u_int8_t	reserved2[2]; 
-	u_int8_t	how;
-#define SSS_STOP	0x00 
-#define SSS_START	0x01
-#define SSS_LOEJ	0x02
-	u_int8_t	reserved4[11];
-};
-
-/* 
- * PREVENT/ALLOW MEDIUM REMOVAL (mandatory)
- */ 
-#define ATAPI_PREVENT_ALLOW_MEDIUM_REMOVAL 0x1e
- 
-struct atapi_prevent_allow_medium_removal {
-	u_int8_t	opcode;
-	u_int8_t	reserved1[3];
-	u_int8_t	how;	
-#define PR_PREVENT	0x01
-#define PR_ALLOW	0x00
-	u_int8_t	reserved3[11];
-};
-
-
-/* 
- * READ CD CAPACITY (mandatory)
- */
-#define ATAPI_READ_CD_CAPACITY		0x25
-
-struct atapi_read_cd_capacity {
-	u_int8_t	opcode;
-	u_int8_t	reserved1[7];
-	u_int8_t	len;
-	u_int8_t	reserved2[7];
-};
-
-/* 
- * Volume size info.
- */
-struct atapi_read_cd_capacity_data {
-	u_int32_t	size;		/* Volume size in blocks */
-	u_int32_t	blksize;	/* Block size in bytes */
-};
-
-/*
- * READ (10) (mandatory)
- */  
-#define ATAPI_READ			0x28  
-
-struct atapi_read {
-	u_int8_t	opcode;
-	u_int8_t	reserved1;
-	u_int8_t	lba[4];
-	u_int8_t	reserved2;
-	u_int8_t	length[2];
-	u_int8_t	reserved3[7];
-}; 
-
-/*
- * READ_SUBCHANNEL
- */
-#define ATAPI_READ_SUBCHANNEL		0x42
-
-struct atapi_read_subchannel {
-	u_int8_t	opcode;
-	u_int8_t	flags[2];
-#define SUBCHAN_MSF	0x02
-#define SUBCHAN_SUBQ	0x40
-	u_int8_t	subchan_format;
-	u_int8_t	reserved5[2];
-	u_int8_t	track;
-	u_int8_t	length[2];
-	u_int8_t	reserved6[3];
-};
-
-/*
- * READ_TOC
- */
-#define ATAPI_READ_TOC			0x43
-
-struct atapi_read_toc {
-	u_int8_t	opcode;
-	u_int8_t	flags;
-#define TOC_MSF		0x02
-	u_int8_t	reserved3[4];
-	u_int8_t	track;
-	u_int8_t	length[2];
-	u_int8_t	format_flag;
-#define TOC_FORMAT	0x40
-	u_int8_t	reserved5[2];
-};
-
-/*
- * PLAY AUDIO (10)
- */
-#define ATAPI_PLAY_AUDIO		0x45
-
-struct atapi_play {
-	u_int8_t	opcode;
-	u_int8_t	reserved1;
-	u_int8_t	lba[4];
-	u_int8_t	reserved2;
-	u_int8_t	length[2];
-	u_int8_t	reserved3[7];
-};
-
-/*
- * PLAY AUDIO (12)
- */
-#define ATAPI_PLAY_BIG			0xa5
-
-struct atapi_play_big {
-	u_int8_t	opcode;
-	u_int8_t	reserved1;
-	u_int8_t	lba[4];
-	u_int8_t	length[4];
-	u_int8_t	reserved2[6];
-};
-
-/*
- * PLAY MSF
- */
-#define ATAPI_PLAY_MSF			0x47
-
-struct atapi_play_msf {
-	u_int8_t	opcode;
-	u_int8_t	reserved1[2];
-	u_int8_t	start_m;
-	u_int8_t	start_s;
-	u_int8_t	start_f;
-	u_int8_t	end_m;
-	u_int8_t	end_s;
-	u_int8_t	end_f;
-	u_int8_t	reserved3[3];
-};
-
-/* 
- * PAUSE/RESUME (optional) 
- */ 
-#define ATAPI_PAUSE_RESUME		0x4b
- 
-struct atapi_pause_resume {
-	u_int8_t	opcode;
-	u_int8_t	reserved1[7];
-	u_int8_t	resume;
-#define PA_PAUSE	0x00
-#define PA_RESUME	0x01
-	u_int8_t	reserved3[7];
-};
-
-/*
- * MODE SELECT
- */
-#define ATAPI_MODE_SELECT		0x55
-
-struct atapi_mode_select {
-	u_int8_t	opcode;
-	u_int8_t	flags;
-#define MODE_SAVEPAGE	0x01;
-#define MODE_BIT	0x10;
-	u_int8_t	page;
-	u_int8_t	reserved3[4];
-	u_int8_t	length[2];
-	u_int8_t	reserved4[7];
-};
-
-/*
- * MODE SENSE (mandatory)
- */
-#define ATAPI_MODE_SENSE        0x5a
-
-struct atapi_mode_sense {
-	u_int8_t	opcode;
-	u_int8_t	reserved1;
-	u_int8_t	page_code_control;
-#define PAGE_CODE_MASK		0x3f
-#define PAGE_CONTROL_MASK	0xc0
-	u_int8_t	reserved2[4];
-	u_int8_t	length[2];
-	u_int8_t	reserved3[7];
-};
-
-struct atapi_cappage {
-	/* Capabilities page */
-	u_int8_t	page_code;
-	u_int8_t	param_len;
-	u_int8_t	reserved2[2];
-
-	u_int8_t	format_cap;
-#define FORMAT_AUDIO_PLAY	0x01	/* audio play supported */
-#define FORMAT_COMPOSITE	0x02	/* composite audio/video supported */
-#define FORMAT_DPORT1		0x04	/* digital audio on port 1 */
-#define FORMAT_DPORT2		0x08	/* digital audio on port 2 */
-#define FORMAT_MODE2_FORM1	0x10	/* mode 2 form 1 (XA) read */
-#define FORMAT_MODE2_FORM2	0x20	/* mode 2 form 2 format */
-#define FORMAT_MULTISESSION	0x40	/* multi-session photo-CD */
-
-	u_int8_t	ops_cap;
-#define OPS_CDDA		0x01	/* audio-CD read supported */
-#define OPS_CDDA_STREAM		0x02	/* CDDA streaming */
-#define OPS_RW			0x04	/* combined R-W subchannels */
-#define OPS_RW_CORR		0x08	/* R-W subchannel data corrected */
-#define OPS_C2			0x10	/* C2 error pointers supported */
-#define OPS_ISRC		0x20	/* can return the ISRC info */
-#define OPS_UPC			0x40	/* can return the catalog number UPC */
-
-	u_int8_t	hw_cap;
-#define HW_LOCK			0x01	/* could be locked */
-#define HW_LOCKED		0x02	/* current lock state */
-#define HW_PREVENT		0x04	/* prevent jumper installed */
-#define HW_EJECT		0x08	/* can eject */
-#define HW_MECH_MASK		0xe0	/* loading mechanism type mask */
-
-#define MECH_CADDY		0x00
-#define MECH_TRAY		0x20
-#define MECH_POPUP		0x40
-#define MECH_CHANGER		0x80
-#define MECH_CARTRIDGE		0xa0
-
-	u_int8_t	sep_cap;
-#define SEP_VOL			0x01	/* independent volume controls */
-#define SEP_MUTE		0x02	/* independent mute controls */
-
-	u_int16_t	max_speed;	/* max raw data rate in bytes/1000 */
-	u_int16_t	max_vol_levels;	/* number of discrete volume levels */
-	u_int16_t	buf_size;	/* internal buffer size in bytes/1024 */
-	u_int16_t	cur_speed;	/* current data rate in bytes/1000  */
-
-	/* Digital drive output format description (optional?) */
-	u_int8_t	reserved3;
-	u_int8_t	ddofd;
-#define DDOFD_BCKF		0x01	/* data valid on failing edge of BCK */
-#define DDOFD_RCH		0x02	/* hight LRCK indicated left channel */
-#define DDOFD_LSBF		0x04	/* set if LSB first */
-#define DDOFD_DLEN_MASK		0x18	/* mask of DLEN values */
-
-#define DLEN_32			0x00	/* 32 BCKs */
-#define DLEN_16			0x08	/* 16 BCKs */
-#define DLEN_24			0x10	/* 24 BCKs */
-#define DLEN_24_I2S		0x18	/* 24 BCKs (I2S) */
-
-	u_int8_t	reserved4[2];
-};
-
-struct atapi_audiopage {
-	u_int8_t	page;
-	u_int8_t	length;
-	u_int8_t	flags;
-#define ATAPI_PA_SOTC	0x2
-#define ATAPI_PA_IMMED	0x4
-	u_int8_t	reserved4[3];
-	u_int8_t	lbaps[2];
-	struct port {
-#define CHANNEL_0	0x1
-#define CHANNEL_1	0x2
-#define CHANNEL_2	0x4
-#define CHANNEL_3	0x8
-#define MUTE_CHANNEL	0x0
-#define LEFT_CHANNEL	0x1
-#define RIGHT_CHANNEL	0x2
-#define BOTH_CHANNEL	0x3
-#define LEFT2_CHANNEL	0x4
-#define RIGHT2_CHANNEL	0x8
-		u_int8_t	channels;	/* first four bits */
-		u_int8_t	volume;
-	} port[4];
-};
-
-struct atapi_cdrompage {
-	u_int8_t	page;
-	u_int8_t	length;
-	u_int8_t	reserved1;
-	u_int8_t	inact_mult;		/* first four bits */
-	u_int16_t	spm;
-	u_int16_t	fps;
-};
-
-struct atapi_mode_data {
-	struct mode_header {
-		u_int8_t	length[2];
-		u_int8_t	medium;
-#define MDT_UNKNOWN	0x00
-#define MDT_DATA_120	0x01
-#define MDT_AUDIO_120	0x02
-#define MDT_COMB_120	0x03
-#define MDT_PHOTO_120	0x04
-#define MDT_DATA_80	0x05
-#define MDT_AUDIO_80	0x06
-#define MDT_COMB_80	0x07
-#define MDT_PHOTO_80	0x08
-#define MDT_NO_DISC	0x70
-#define MDT_DOOR_OPEN	0x71
-#define MDT_FMT_ERROR	0x72
-		u_int8_t	reserved[5];
-	} header;
-#define ATAPI_CDROM_PAGE	0x0d
-#define ATAPI_AUDIO_PAGE	0x0e
-#define ATAPI_AUDIO_PAGE_MASK	0x4e
-#define ATAPI_CAP_PAGE		0x2a
-	union {
-		u_int8_t		atapi_page_code;
-		struct atapi_cdrompage	atapi_page_cdrom;
-		struct atapi_cappage	atapi_page_cap;
-		struct atapi_audiopage	atapi_page_audio;
-	} page;
-#define page_code	page.atapi_page_code
-#define page_cdrom	page.atapi_page_cdrom
-#define	page_cap	page.atapi_page_cap
-#define page_audio	page.atapi_page_audio
-};
-
-#define AUDIOPAGESIZE	sizeof(struct atapi_audiopage)+sizeof(struct mode_header)
-#define CDROMPAGESIZE	sizeof(struct atapi_cdrompage)+sizeof(struct mode_header)
-#define CAPPAGESIZE	sizeof(struct atapi_cappage)+sizeof(struct mode_header)
-
-/* ATAPI error codes */
-#define ATAPI_SK_NO_SENSE		0x0
-#define ATAPI_SK_REC_ERROR		0x1	/* recovered error */
-#define ATAPI_SK_NOT_READY		0x2
-#define ATAPI_SK_MEDIUM_ERROR		0x3
-#define ATAPI_SK_HARDWARE_ERROR		0x4
-#define ATAPI_SK_ILLEGAL_REQUEST	0x5
-#define ATAPI_SK_UNIT_ATTENTION		0x6
-#define ATAPI_SK_DATA_PROTECT		0x7
-					/* 0x8 reserved */
-					/* 0x9-0xa reserved */
-#define ATAPI_SK_ABORTED_COMMAND	0xb
-					/* 0xc-0xd not referenced */
-#define ATAPI_SK_MISCOMPARE		0xe
-					/* 0xf reserved */
-
-#define ATAPI_MCR	0x08	/* media change requested */
-#define ATAPI_ABRT	0x04	/* aborted command */
-#define ATAPI_EOM	0x02	/* end of media */
-#define ATAPI_ILI	0x01	/* illegal length indication */
-
-
-int	atapi_exec_cmd __P((struct at_dev_link *, void *, int,
-	    void *, int, int, int));
-int	atapi_exec_io __P((struct at_dev_link *, void *, int,
-	    struct buf *, int));
-int	atapi_test_unit_ready __P((struct at_dev_link *, int));
-int	atapi_start_stop __P((struct at_dev_link *, int, int));
-int	atapi_prevent __P((struct at_dev_link *, int));
diff --git a/sys/dev/atapi/atapiconf.c b/sys/dev/atapi/atapiconf.c
deleted file mode 100644
index a026f90c393..00000000000
--- a/sys/dev/atapi/atapiconf.c
+++ /dev/null
@@ -1,744 +0,0 @@
-/*	$OpenBSD: atapiconf.c,v 1.23 1999/06/05 21:58:14 deraadt Exp $	*/
-
-/*
- * Copyright (c) 1996 Manuel Bouyer.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *  This product includes software developed by Manuel Bouyer.
- * 4. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <sys/types.h>
-#include <sys/param.h>
-#include <sys/systm.h>
-#include <sys/malloc.h>
-#include <sys/device.h>
-#include <sys/buf.h>
-#include <sys/proc.h>  
-
-#include <dev/atapi/atapilink.h>
-#include <dev/atapi/atapi.h>
-
-#define SILENT_PRINTF(flags,string) if (!(flags & A_SILENT)) printf string
-
-#ifdef ATAPI_DEBUG_CMD
-#define ATAPI_DEBUG_CMD_PRINT(args)	printf args
-#else
-#define ATAPI_DEBUG_CMD_PRINT(args)
-#endif
-
-#ifdef ATAPI_DEBUG_FCTN
-#define ATAPI_DEBUG_FCTN_PRINT(args)	printf args
-#else
-#define ATAPI_DEBUG_FCTN_PRINT(args)
-#endif
-
-struct atapibus_softc {
-	struct	device sc_dev;
-	struct	bus_link *b_link;
-};
-
-LIST_HEAD(pkt_free_list, atapi_command_packet) pkt_free_list;
-
-int atapi_error __P((struct atapi_command_packet *));
-void atapi_sense __P((struct atapi_command_packet *, u_int8_t, u_int8_t));
-void at_print_addr __P((struct at_dev_link *, u_int8_t));
-
-int atapibusmatch __P((struct device *, void *, void *));
-void atapibusattach __P((struct device *, struct device *, void *));
-void atapi_fixquirk __P((struct at_dev_link *));
-int atapiprint __P((void *, const char *));
-
-struct cfattach atapibus_ca = {
-	sizeof(struct atapibus_softc), atapibusmatch, atapibusattach
-};
-
-struct cfdriver atapibus_cd = {
-	NULL, "atapibus", DV_DULL
-};
-
-
-/*
- * ATAPI quirk table support.
- */
-
-struct atapi_quirk_inquiry_pattern {
-	u_int8_t type;
-	u_int8_t rem;
-	char *product;
-	char *revision;
-
-	u_int8_t quirks;
-};
-
-struct atapi_quirk_inquiry_pattern atapi_quirk_inquiry_patterns[] = {
-	/* GoldStar 8X */
-	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
-	 "GCD-R580B", "1.00", AQUIRK_LITTLETOC},
-	/* MATSHITA CR-574 */
-	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
-	 "MATSHITA CR-574", "1.06", AQUIRK_NOCAPACITY},
-	/* NEC Multispin 2Vi */
-	{ATAPI_DEVICE_TYPE_DAD, ATAPI_REMOVABLE,
-	 "NEC                 CD-ROM DRIVE:260", "3.04", AQUIRK_CDROM},
-	/* NEC 273 */
-	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
-	 "NEC                 CD-ROM DRIVE:273", "4.21", AQUIRK_NOTUR},
-	/* NEC 4CD changer CDR-C251 */
-	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
-	 "NEC                 CD-ROM DRIVE:251", "4.14", AQUIRK_NOCAPACITY},
-	/* Sanyo 4x */
-	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
-	 "SANYO CRD-254P", "1.02", AQUIRK_NOCAPACITY},
-	/* Sanyo 4x */
-	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
-	 "SANYO CRD-S54P", "1.08", AQUIRK_NOCAPACITY},
-	/* Sanyo 6x */
-	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
-	 "SANYO CRD-256P", "1.02", AQUIRK_NOCAPACITY},
-	/* Another Sanyo 4x */
-	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
-	 "CD-ROM  CDR-S1", "1.70",AQUIRK_NOCAPACITY},
-	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
-	 "CD-ROM  CDR-N16", "1.25",AQUIRK_NOCAPACITY},
-	/* Acer Notelight 370 */
-	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
-	 "UJDCD8730", "1.14", AQUIRK_NODOORLOCK},
-	/* ALPS CD changer */
-	{ATAPI_DEVICE_TYPE_CD, ATAPI_REMOVABLE,
-	 "ALPS ELECTRIC CO.,LTD. DC544C", "SW03D", AQUIRK_NOTUR},
-	{0, 0, NULL, NULL, 0}
-};
-
-int
-atapibusmatch(parent, match, aux)
-        struct device *parent;
-        void *match, *aux;
-{
-	struct bus_link *ab_link = aux;
-
-	if (ab_link == NULL)
-		return 0;
-	if (ab_link->type != BUS)
-		return 0;
-	return 1;
-}
-
-void
-atapi_fixquirk(ad_link)
-	struct at_dev_link *ad_link;
-{
-	struct atapi_identify *id = &ad_link->id;
-	struct atapi_quirk_inquiry_pattern *quirk;
-
-	/*
-	 * Shuffle string byte order.
-	 * Mitsumi and NEC drives don't need this.
-	 */
-	if (((id->model[0] == 'N' && id->model[1] == 'E') ||
-	    (id->model[0] == 'F' && id->model[1] == 'X')) == 0)
-		bswap(id->model, sizeof(id->model));
-	bswap(id->serial_number, sizeof(id->serial_number));
-	bswap(id->firmware_revision, sizeof(id->firmware_revision));
-
-	/*
-	 * Clean up the model name, serial and
-	 * revision numbers.
-	 */
-	btrim(id->model, sizeof(id->model));
-	btrim(id->serial_number, sizeof(id->serial_number));
-	btrim(id->firmware_revision, sizeof(id->firmware_revision));
-
-#define quirk_null(_q)	((_q->type == 0) && (_q->rem == 0) && \
-			 (_q->product == NULL) && (_q->revision == NULL))
-
-	for (quirk = atapi_quirk_inquiry_patterns;
-	     !quirk_null(quirk); quirk++) {
-		if ((id->config.device_type
-		    & ATAPI_DEVICE_TYPE_MASK) != quirk->type)
-			continue;
-		if ((id->config.cmd_drq_rem & quirk->rem) == 0)
-			continue;
-		if (strcmp(id->model, quirk->product))
-			continue;
-		if (strcmp(id->firmware_revision, quirk->revision))
-			continue;
-
-		break;
-	}
-
-	if (!quirk_null(quirk)) {
-		/* Found a quirk entry for this drive. */
-		ad_link->quirks = quirk->quirks;
-	}
-}
-
-int
-atapiprint(aux, bus)
-	void *aux;
-	const char *bus;
-{
-	struct at_dev_link *ad_link = aux;
-	struct atapi_identify *id = &ad_link->id;
-	char *dtype, *fixrem;
-
-	/*
-	 * Figure out basic device type.
-	 */
-	switch (id->config.device_type & ATAPI_DEVICE_TYPE_MASK) {
-	case ATAPI_DEVICE_TYPE_DAD:
-		dtype = "direct";
-		break;
-
-	case ATAPI_DEVICE_TYPE_CD:
-		dtype = "cdrom";
-		break;
-
-	case ATAPI_DEVICE_TYPE_OMD:
-		dtype = "optical";
-		break;
-
-	default:
-		dtype = "unknown";
-		break;
-	}
-
-	fixrem = (id->config.cmd_drq_rem & ATAPI_REMOVABLE) ?
-	    "removable" : "fixed";
-
-	if (bus != NULL)
-		printf("%s", bus);
-
-	if (id->serial_number[0]) {
-		printf(" drive %d: <%s, %s, %s> ATAPI %d/%s %s",
-	    	    ad_link->drive, id->model, id->serial_number,
-	    	    id->firmware_revision,
-	    	    (id->config.device_type & ATAPI_DEVICE_TYPE_MASK),
-		    dtype, fixrem);
-	} else {
-		printf(" drive %d: <%s, %s> ATAPI %d/%s %s",
-	    	    ad_link->drive, id->model, id->firmware_revision,
-	    	    (id->config.device_type & ATAPI_DEVICE_TYPE_MASK),
-		    dtype, fixrem);
-	}
-
-	return UNCONF;
-}
-
-
-void
-atapibusattach(parent, self, aux)
-        struct device *parent, *self;
-        void *aux;
-{
-	struct atapibus_softc *ab = (struct atapibus_softc *)self;
-	struct bus_link *ab_link_proto = aux;
-	struct atapi_identify ids;
-	struct atapi_identify *id = &ids;
-	struct at_dev_link *ad_link;
-	int drive;
-
-	printf("\n");
-
-	ab_link_proto->atapibus_softc = (caddr_t)ab;
-	ab->b_link = ab_link_proto;
-
-	for (drive = 0; drive < 2 ; drive++) {
-		if (wdc_atapi_get_params(ab_link_proto, drive, id)) {
-#ifdef ATAPI_DEBUG_PROBE
-			printf("%s drive %d: cmdsz 0x%x drqtype 0x%x\n",
-			    self->dv_xname, drive,
-			    id->config.cmd_drq_rem & ATAPI_PACKET_SIZE_MASK,
-			    id->config.cmd_drq_rem & ATAPI_DRQ_MASK);
-#endif
-
-			/*
-			 * Allocate a device link and try and attach
-			 * a driver to this device.  If we fail, free
-			 * the link.
-			 */
-			ad_link = malloc(sizeof(*ad_link), M_DEVBUF, M_NOWAIT);
-			if (ad_link == NULL) {
-				printf("%s: can't allocate link for drive %d\n",
-				    self->dv_xname, drive);
-				continue;
-			}
-
-			/* Fill in link. */
-			ad_link->drive = drive;
-			if (id->config.cmd_drq_rem & ATAPI_PACKET_SIZE_16)
-				ad_link->flags |= ACAP_LEN;
-			ad_link->flags |=
-			    (id->config.cmd_drq_rem & ATAPI_DRQ_MASK) << 3;
-			ad_link->bus = ab_link_proto;
-			bcopy(id, &ad_link->id, sizeof(*id));
-
-			/* Fix strings and look through the quirk table. */
-			atapi_fixquirk(ad_link);
-
-			/* Try to find a match. */
-			if (config_found(self, ad_link, atapiprint) == NULL)
-				free(ad_link, M_DEVBUF);
-		}
-	}
-}
-
-int
-atapi_exec_cmd(ad_link, cmd, cmd_size, databuf, datalen, rw, flags)
-	struct at_dev_link *ad_link;
-	void *cmd;
-	int cmd_size;
-	void *databuf;
-	int datalen;
-	int rw;
-	int flags;
-{
-	struct atapi_command_packet *pkt;
-	struct bus_link *b_link = ad_link->bus;
-	int status, s;
-
-	/* Allocate packet. */
-	pkt = atapi_get_pkt(ad_link, flags);
-	if (pkt == NULL)
-		return -1;
-
-	/* Fill it out. */
-	bcopy(cmd, &pkt->cmd_store, cmd_size);
-	pkt->command = &pkt->cmd_store;
-	pkt->command_size = (ad_link->flags & ACAP_LEN) ? 16 : 12;
-	pkt->databuf = databuf;
-	pkt->data_size = datalen;
-	pkt->flags = rw | (flags & 0xff) | (ad_link->flags & 0x0300);
-	pkt->drive = ad_link->drive;
-
-	/* Send it to drive. */
-	wdc_atapi_send_command_packet(b_link, pkt);
-	if ((flags & (A_POLLED | A_NOSLEEP)) == 0) {
-		ATAPI_DEBUG_CMD_PRINT(("atapi_exec_cmd: sleeping\n"));
-
-		s = splbio();
-		while ((pkt->status & ITSDONE) == 0)
-			tsleep(pkt, PRIBIO + 1,"atapicmd", 0);
-		splx(s);
-
-		ATAPI_DEBUG_CMD_PRINT(("atapi_exec_cmd: done sleeping\n"));
-
-		status = pkt->status & STATUS_MASK;
-		atapi_free_pkt(pkt);
-	} else {
-		if ((flags & A_POLLED) != 0) {
-			if ((pkt->status & ERROR) && (pkt->error)) {
-				atapi_error(pkt);
-				SILENT_PRINTF(flags,("\n"));
-			}
-		}
-		status = pkt->status & STATUS_MASK;
-		if ((flags & A_POLLED) != 0)
-			atapi_free_pkt(pkt);
-	}
-
-	if ((pkt->status & ERROR) && (pkt->error))
-	     status |= pkt->error << 8;
-
-	return status;
-}
-
-int
-atapi_exec_io(ad_link, cmd, cmd_size, bp, flags)
-	struct at_dev_link *ad_link;
-	void *cmd;
-	int cmd_size;
-	struct buf *bp;
-	int flags;
-{
-	struct atapi_command_packet *pkt;
-	struct bus_link *b_link = ad_link->bus;
-
-	/* Allocate a packet. */
-	pkt = atapi_get_pkt(ad_link, flags);
-	if (pkt == NULL) {
-		printf("atapi_exec_io: no pkt\n");
-		return ERROR;
-	}
-
-	/* Fill it in. */
-	bcopy(cmd, &pkt->cmd_store, cmd_size);
-	pkt->command = &pkt->cmd_store;
-	pkt->command_size = (ad_link->flags & ACAP_LEN) ? 16 : 12;
-	pkt->bp = bp;
-	pkt->databuf = bp->b_data;
-	pkt->data_size = bp->b_bcount;
-	pkt->flags = (bp->b_flags & (B_READ|B_WRITE)) | (flags & 0xff) |
-	    (ad_link->flags & 0x0300);
-	pkt->drive = ad_link->drive;
-
-	wdc_atapi_send_command_packet(b_link, pkt);
-	return (pkt->status & STATUS_MASK);
-}
-
-void
-atapi_done(acp)
-	struct atapi_command_packet *acp;
-{
-	struct at_dev_link *ad_link = acp->ad_link;
-	struct buf *bp = acp->bp;
-	int error = 0;
-
-	ATAPI_DEBUG_CMD_PRINT(("atapi_done\n"));
-
-	if ((acp->status & ERROR) && (acp->error)) {
-		atapi_error(acp);
-		if (acp->status & RETRY) {
-			if (acp->retries <ATAPI_NRETRIES) {
-				acp->retries++;
-				acp->status = 0;
-				acp->error = 0;
-				SILENT_PRINTF(acp->flags & 0xff,
-				    (", retry #%d\n", acp->retries));
-				wdc_atapi_send_command_packet(ad_link->bus,
-				    acp);
-				return;
-			} else
-				acp->status = ERROR;
-		}
-		SILENT_PRINTF(acp->flags & 0xff,("\n"));
-	}
-	acp->status |= ITSDONE;
-
-	if (ad_link->done) {
-		ATAPI_DEBUG_CMD_PRINT(("calling private done\n"));
-		error = (*ad_link->done)(acp);
-		if (error == EJUSTRETURN)
-			return;
-	}
-	if (acp->bp == NULL) {
-		ATAPI_DEBUG_CMD_PRINT(("atapidone: wakeup acp\n"));
-		wakeup(acp);
-		return;
-	}
-
-	ATAPI_DEBUG_CMD_PRINT(("atapi_done: status %d\n", acp->status));
-
-	switch (acp->status & 0x0f) {
-	case MEDIA_CHANGE:
-		if (ad_link->flags & ADEV_REMOVABLE)
-			ad_link->flags &= ~ADEV_MEDIA_LOADED;
-
-		error = EIO;
-		break;
-
-	case NO_ERROR:
-		error = 0;
-		break;
-
-	case ERROR:
-	case END_OF_MEDIA:
-	default:
-		error = EIO;
-		break;
-	}
-
-	switch (acp->status & 0xf0) {
-	case NOT_READY:
-	case UNIT_ATTENTION:
-		if (ad_link->flags & ADEV_REMOVABLE)
-			ad_link->flags &= ~ADEV_MEDIA_LOADED;
-
-		error = EIO;
-		break;
-	}
-
-	if (error) {
-		bp->b_error = error;
-		bp->b_flags |= B_ERROR;
-		bp->b_resid = bp->b_bcount;
-	} else {
-		bp->b_error = 0;
-		bp->b_resid = acp->data_size;
-	}
-	biodone(bp);
-	atapi_free_pkt(acp);
-}
-
-struct atapi_command_packet *
-atapi_get_pkt(ad_link, flags)
-	struct at_dev_link *ad_link;
-	int flags;
-{
-	struct atapi_command_packet *pkt;
-	int s;
-
-	s = splbio();
-	while (ad_link->openings <= 0) {
-		if (flags & A_NOSLEEP) {
-			splx(s);
-			return 0;
-		}
-
-		ATAPI_DEBUG_CMD_PRINT(("atapi_get_pkt: sleeping\n"));
-
-		ad_link->flags |= ADEV_WAITING;
-		(void)tsleep(ad_link, PRIBIO, "getpkt", 0);
-	}
-
-	ad_link->openings--;
-
-	if ((pkt = pkt_free_list.lh_first) != 0) {
-		LIST_REMOVE(pkt, free_list);
-		splx(s);
-	} else {
-		splx(s);
-		pkt = malloc(sizeof(struct atapi_command_packet), M_DEVBUF,
-		    ((flags & A_NOSLEEP) != 0 ? M_NOWAIT : M_WAITOK));
-		if (pkt == NULL) {
-			printf("atapi_get_pkt: cannot allocate pkt\n");
-			ad_link->openings++;
-			return 0;
-		}
-	}
-
-	bzero(pkt, sizeof(struct atapi_command_packet));
-	pkt->ad_link = ad_link;
-	return pkt;
-}
-
-void
-atapi_free_pkt(pkt)
-	struct atapi_command_packet *pkt;
-{
-	struct at_dev_link *ad_link = pkt->ad_link;
-	int s;
-
-	s = splbio();
-	LIST_INSERT_HEAD(&pkt_free_list, pkt, free_list);
-
-	ad_link->openings++;
-
-	if ((ad_link->flags & ADEV_WAITING) != 0) {
-		ad_link->flags &= ~ADEV_WAITING;
-		wakeup(ad_link);
-	} else {
-		if (ad_link->start) {
-			ATAPI_DEBUG_CMD_PRINT(("atapi_free_pkt: calling private start\n"));
-			(*ad_link->start)((void *)ad_link->device_softc);
-		}
-	}
-	splx(s);
-}
-
-int
-atapi_test_unit_ready(ad_link, flags)
-	struct at_dev_link *ad_link;
-	int flags;
-{	
-	int ret;
-	struct atapi_test_unit_ready cmd;
-
-	ATAPI_DEBUG_FCTN_PRINT(("atapi_test_unit_ready: "));
-
-	/* Device doesn't support TUR! */
-	if (ad_link->quirks & AQUIRK_NOTUR)
-		ret = 0;
-	else {
-		bzero(&cmd, sizeof(cmd));
-		cmd.opcode = ATAPI_TEST_UNIT_READY;
-		ret = atapi_exec_cmd(ad_link, &cmd, sizeof(cmd), 0, 0, 0,
-		    flags);
-	}
-	ATAPI_DEBUG_FCTN_PRINT(("atapi_test_unit_ready: ret %d\n", ret));
-	return ret;
-}
-
-int
-atapi_start_stop(ad_link, how, flags)
-	struct at_dev_link  *ad_link;
-	int how;
-	int flags;
-{
-	struct atapi_start_stop_unit cmd;
-	int ret;
-		
-	ATAPI_DEBUG_FCTN_PRINT(("atapi_start_stop: "));
-
-	bzero(&cmd, sizeof(cmd));
-	cmd.opcode = ATAPI_START_STOP_UNIT;
-	cmd.how = how;
-
-	ret = atapi_exec_cmd(ad_link, &cmd, sizeof(cmd), 0,0,0,flags);
-
-	ATAPI_DEBUG_FCTN_PRINT(("ret %d\n", ret));
-
-	return ret;
-}
-
-int
-atapi_prevent(ad_link, how)
-	struct at_dev_link *ad_link;
-	int how;
-{
-	struct atapi_prevent_allow_medium_removal cmd;
-	int ret;
-
-	ATAPI_DEBUG_FCTN_PRINT(("atapi_prevent: "));
-
-	if (ad_link->quirks & AQUIRK_NODOORLOCK) 
-	        ret = 0;
-	else { 
-	        bzero(&cmd, sizeof(cmd));
-		cmd.opcode = ATAPI_PREVENT_ALLOW_MEDIUM_REMOVAL;
-		cmd.how = how & 0xff;
-
-		ret = atapi_exec_cmd(ad_link, &cmd, sizeof(cmd), 0,0,0,0);
-	}
-	ATAPI_DEBUG_FCTN_PRINT(("ret %d\n", ret));
-
-	return ret;
-}
-
-int 
-atapi_error(acp)
-	struct atapi_command_packet* acp;
-{
-	int flags, error, ret = -1;
-	struct at_dev_link *ad_link = acp->ad_link;
-
-	flags = acp->flags & 0xff;
-	error = acp->error;
-
-	at_print_addr(ad_link, acp->flags & 0xff);
-
-	if (error & ATAPI_MCR) {
-		SILENT_PRINTF(flags,("media change requested "));
-		acp->status = MEDIA_CHANGE;
-	}
-
-	if (error & ATAPI_ABRT) {      
-		SILENT_PRINTF(flags,("command aborted "));
-		acp->status = ERROR; 
-	}
-
-	if (error & ATAPI_EOM) {
-		SILENT_PRINTF(flags,("end of media "));
-		acp->status = END_OF_MEDIA;
-	}
-
-	if (error & ATAPI_ILI) {
-		SILENT_PRINTF(flags,("illegal length indication "));
-		acp->status = ERROR;
-	}
-
-	if ((error & 0x0f) == 0)
-		ret = 0;
-
-	atapi_sense(acp, error >> 4, flags);
-
-	if (((flags & A_SILENT) == 0) && (acp->status != NO_ERROR)) {
-		int i;
-		printf(", command:");
-		for (i = 0; i < acp->command_size; i++)
-			printf(" %2x", ((u_int8_t *)acp->command)[i]);
-	}
-
-	return ret;
-}
-
-void
-atapi_sense(acp, sense_key, flags)
-	struct atapi_command_packet *acp;
-	u_int8_t sense_key;
-	u_int8_t flags;
-{
-	struct at_dev_link *ad_link = acp->ad_link;
-
-	switch (sense_key) {
-	case ATAPI_SK_NO_SENSE:
-		break;
-
-	case ATAPI_SK_REC_ERROR:
-		SILENT_PRINTF(flags,("recovered error"));
-		acp->status = 0;
-		break;
-
-	case ATAPI_SK_NOT_READY:
-		SILENT_PRINTF(flags,("not ready"));
-		acp->status = NOT_READY;
-		break;
-
-	case ATAPI_SK_MEDIUM_ERROR:
-		SILENT_PRINTF(flags,("media error"));
-		acp->status = ERROR;
-		break;
-
-	case ATAPI_SK_HARDWARE_ERROR:
-		SILENT_PRINTF(flags,("hardware error"));
-		acp->status = ERROR;
-		break;
-
-	case ATAPI_SK_ILLEGAL_REQUEST:
-		SILENT_PRINTF(flags,("illegal request"));
-		acp->status = ERROR;
-		break;
-
-	case ATAPI_SK_UNIT_ATTENTION:
-		SILENT_PRINTF(flags,("unit attention"));
-		acp->status = UNIT_ATTENTION;
-		if (ad_link->flags & ADEV_REMOVABLE)
-			ad_link->flags &= ~ADEV_MEDIA_LOADED;
-		break;
-
-	case ATAPI_SK_DATA_PROTECT:
-		SILENT_PRINTF(flags,("data protect"));
-		acp->status = ERROR;
-		break;
-
-	case ATAPI_SK_ABORTED_COMMAND:
-		SILENT_PRINTF(flags,("aborted command"));
-		acp->status = RETRY;
-		break;
-
-	case ATAPI_SK_MISCOMPARE:
-		SILENT_PRINTF(flags,("miscompare"));
-		acp->status = ERROR;
-		break;
-
-	default:
-		SILENT_PRINTF(flags,("unexpected sense key %02x", sense_key));
-		acp->status = ERROR;
-	}
-}
-
-void
-at_print_addr(ad_link, flags)
-	struct at_dev_link *ad_link; 
-	u_int8_t flags;
-{
-
-	if (flags & A_SILENT)
-		return;
-
-	printf("%s(%s:%d): ", ad_link->device_softc ?
-	    ((struct device *)ad_link->device_softc)->dv_xname : "probe",
-	    ((struct device *)ad_link->bus->wdc_softc)->dv_xname,
-	    ad_link->drive);
-}
diff --git a/sys/dev/atapi/atapilink.h b/sys/dev/atapi/atapilink.h
deleted file mode 100644
index c9cdb14989b..00000000000
--- a/sys/dev/atapi/atapilink.h
+++ /dev/null
@@ -1,401 +0,0 @@
-/*	$OpenBSD: atapilink.h,v 1.10 1997/06/24 05:29:54 downsj Exp $	*/
-
-/*
- * Copyright (c) 1996 Manuel Bouyer.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *  This product includes software developed by Manuel Bouyer.
- * 4. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/* #undef ATAPI_DEBUG */
-/* #undef ATAPI_DEBUG_PROBE */
-
-struct bus_link {
-	u_int8_t type;  
-#define DRIVE	0
-#define BUS	1
-	caddr_t	wdc_softc;
-	caddr_t	atapibus_softc;
-	struct	wdc_link *ctlr_link;
-	u_int8_t ctrl;
-};
-
-struct atapi_identify {
-	struct	config_s {
-		u_int8_t cmd_drq_rem;
-#define ATAPI_PACKET_SIZE_MASK	0x02
-#define ATAPI_PACKET_SIZE_12	0x00
-#define ATAPI_PACKET_SIZE_16	0x01
-
-#define ATAPI_DRQ_MASK		0x60
-#define ATAPI_MICROPROCESSOR_DRQ 0x00
-#define ATAPI_INTERRUPT_DRQ	0x20
-#define ATAPI_ACCELERATED_DRQ	0x40
-
-#define ATAPI_REMOVABLE		0x80
-
-		u_int8_t device_type;
-#define ATAPI_DEVICE_TYPE_MASK	0x1f
-#define ATAPI_DEVICE_TYPE_DAD	0x00	/* direct access device */
-					/* 0x1-0x4 reserved */
-#define ATAPI_DEVICE_TYPE_CD	0x05	/* CD-ROM */
-					/* 0x6 reserved */
-#define ATAPI_DEVICE_TYPE_OMD	0x07	/* optical memory device */
-					/* 0x8-0x1e reserved */
-#define ATAPI_DEVICE_TYPE_UNKNOWN 0x1f
-
-#define ATAPI_GC_PROTOCOL_MASK	0xc0	/* mask of protocol bits */
-					/* 0x00 and 0x01 are ATA */
-#define ATAPI_GC_PROTO_TYPE_ATAPI 0x80
-#define ATAPI_GC_PROTO_TYPE_RESERVED 0xc0
-	} config;				/* general configuration */
-
-	u_int8_t	cylinders[2];
-	u_int8_t	reserved1[2];
-	u_int8_t	heads[2];
-	u_int8_t	unf_bytes_per_track[2];
-	u_int8_t	unf_bytes_per_sector[2];
-	u_int8_t	sectors_per_track[2];
-	u_int8_t	reserved2[6];
-	char		serial_number[20];
-	u_int8_t	buffer_type[2];
-	u_int8_t	buffer_size[2];
-	u_int8_t	ECC_bytes_available[2];
-	char		firmware_revision[8];
-	char		model[40];
-	u_int8_t	sector_count[2];
-	u_int8_t	double_word[2];		/* == 0 for CD-ROMs */
-
-	struct capabilities_s {
-		u_int8_t vendor;
-		u_int8_t capflags;
-#define ATAPI_CAP_DMA			0x01	/* DMA supported */
-#define ATAPI_CAP_LBA			0x02	/* LBA supported */
-#define ATAPI_IORDY_DISABLE		0x04	/* IORDY can be disabled */
-#define ATAPI_IORDY			0x08	/* IORDY supported */
-	} capabilities;
-
-	u_int8_t	reserved3[2];
-	u_int8_t	PIO_cycle_timing[2];
-	u_int8_t	DMA_cycle_timing[2];
-	u_int8_t	validity[2]; /* of words 54-58, 64-70 in this table */
-
-#define ATAPI_VALID_FIRST	0x0	/* == 1 => words 54-58 are valid */
-#define ATAPI_VALID_SECOND	0x1	/* == 1 => words 64-70 are valid */
-
-	u_int8_t	current_chs[6];	/* cylinder/head/sector */
-	u_int8_t	current_capacity[4];
-	u_int8_t	reserved4[2];
-	u_int8_t	user_addressable_sectors[4];
-	u_int8_t	singleword_DMA_mode[2];
-
-#define ATAPI_SW_DMA_MODE_AVAIL	0x00ff	/* Mode 0 is supported */
-#define ATAPI_SW_DMA_MODE_ACTIVE 0xff00	/* which mode is active */
-
-	u_int8_t	multiword_DMA_mode[2];
-
-#define ATAPI_MW_DMA_MODE_AVAIL	0x00ff	/* Mode 0 is supported */
-#define ATAPI_MW_DMA_MODE_ACTIVE 0xff00	/* which mode is active */
-
-	u_int8_t	enhanced_PIO_mode[2];
-
-#define ATAPI_ENHANCED_PIO_AVAIL 0x0001	/* PIO Mode 3 is supported */
-
-	u_int8_t	blind_PIO_minimum_cycles[2];
-	u_int8_t	mw_dma_tct[2]; /* multi-word DMA transfer cycle time */
-	u_int8_t	min_PIO_tct_no_flow_control[2];
-	u_int8_t	min_PIO_tct_with_flow_control[2];
-	u_int8_t	reserved5[4];
-	u_int8_t	reserved6[114];
-	u_int8_t	vendor[64];	/* vendor unique */
-	u_int8_t	reserved7[192];
-};
-
-struct at_dev_link {
-	void	*device_softc;
-	u_int8_t drive;
-	u_int8_t openings;
-	struct	atapi_identify id;  
-	struct	bus_link *bus;
-	u_int16_t flags;
-#define ADEV_REMOVABLE		0x0001	/* media is removable */
-#define ADEV_MEDIA_LOADED	0x0002	/* device figures are still valid */  
-#define ADEV_WAITING		0x0004	/* a process is waiting for this */
-#define ADEV_OPEN		0x0008	/* at least 1 open session */
-#define ADEV_EJECTING		0x0010	/* eject on close */
-#define ACAP_DRQ_MPROC		0x0000	/* microprocessor DRQ */
-#define ACAP_DRQ_INTR		0x0100	/* interrupt DRQ */
-#define ACAP_DRQ_ACCEL		0x0200	/* accelerated DRQ */
-#define ACAP_LEN 		0x0400	/* 16 bit commands */
-	u_int8_t quirks;		/* per-device oddities */
-#define AQUIRK_CDROM		0x01	/* device is a CD-ROM */
-#define AQUIRK_LITTLETOC	0x02	/* Audio TOC uses wrong byte order */
-#define AQUIRK_NOCAPACITY	0x04	/* no READ_CD_CAPACITY command */
-#define AQUIRK_NODOORLOCK       0x08    /* can't lock the door */
-#define AQUIRK_NOTUR		0x10	/* no TEST_UNIT_READY command */
-	void	(*start) __P((void *));	/* device start routine */
-	int	(*done) __P((void *));	/* device done routine */
-};
-
-struct atapi_command_packet {
-	void	*ad_link;
-	void	*command;
-	char	cmd_store[16];
-	int	command_size;
-	struct	buf *bp; 
-	void	*databuf;
-	int	data_size;
-	int	flags;	/* handle B_READ/B_WRITE mask 0x00f00000 */
-			/* controller flags maks 0x0000000f */
-			/* ATAPI flags mask 0x000000f0 */
-			/* Capabilities flags 0x00000f00 */
-	u_int8_t drive;
-	u_int16_t status;
-#define STATUS_MASK	0xff
-#define NO_ERROR	0x00
-#define ERROR		0x01
-#define MEDIA_CHANGE	0x02
-#define END_OF_MEDIA	0x03
-#define NOT_READY	0x10
-#define UNIT_ATTENTION	0x20
-#define RETRY		0x40
-#define ITSDONE		0x100
-	u_int8_t error;
-	u_int8_t retries;
-#define ATAPI_NRETRIES 5
-	LIST_ENTRY(atapi_command_packet) free_list;
-};
-
-int	wdc_atapi_get_params __P((struct bus_link *, u_int8_t,
-	    struct atapi_identify *)); 
-void	wdc_atapi_send_command_packet __P((struct bus_link *,
-	    struct atapi_command_packet*));
-
-#define A_POLLED	0x10
-#define A_NOSLEEP	0x20
-#define A_SILENT	0x40
-
-void	atapi_done __P((struct atapi_command_packet *));
-struct	atapi_command_packet *atapi_get_pkt __P((struct at_dev_link *, int));
-void	atapi_free_pkt __P((struct atapi_command_packet *));
-
-/*
- * Functions used for reading and writing 2, 3, and 4 byte values
- * in ATAPI commands.
- */
-
-static __inline void _lto2b __P((u_int32_t val, u_int8_t *bytes));
-static __inline void _lto3b __P((u_int32_t val, u_int8_t *bytes));
-static __inline void _lto4b __P((u_int32_t val, u_int8_t *bytes));
-static __inline u_int32_t _2btol __P((u_int8_t *bytes));
-static __inline u_int16_t _2btos __P((u_int8_t *bytes));
-static __inline u_int32_t _3btol __P((u_int8_t *bytes));
-static __inline u_int32_t _4btol __P((u_int8_t *bytes));
-
-static __inline void _lto2l __P((u_int32_t val, u_int8_t *bytes));
-static __inline void _lto3l __P((u_int32_t val, u_int8_t *bytes));
-static __inline void _lto4l __P((u_int32_t val, u_int8_t *bytes));
-static __inline u_int32_t _2ltol __P((u_int8_t *bytes));
-static __inline u_int32_t _3ltol __P((u_int8_t *bytes));
-static __inline u_int32_t _4ltol __P((u_int8_t *bytes));
-
-static __inline void bswap __P((char *, int));
-static __inline void btrim __P((char *, int));
-
-static __inline void
-_lto2b(val, bytes)
-	u_int32_t val;
-	u_int8_t *bytes;
-{
-
-	bytes[0] = (val >> 8) & 0xff;
-	bytes[1] = val & 0xff;
-}
-
-static __inline void
-_lto3b(val, bytes)
-	u_int32_t val;
-	u_int8_t *bytes;
-{
-
-	bytes[0] = (val >> 16) & 0xff;
-	bytes[1] = (val >> 8) & 0xff;
-	bytes[2] = val & 0xff;
-}
-
-static __inline void
-_lto4b(val, bytes)
-	u_int32_t val;
-	u_int8_t *bytes;
-{
-
-	bytes[0] = (val >> 24) & 0xff;
-	bytes[1] = (val >> 16) & 0xff;
-	bytes[2] = (val >> 8) & 0xff;
-	bytes[3] = val & 0xff;
-}
-
-static __inline u_int32_t
-_2btol(bytes)
-	u_int8_t *bytes;
-{
-	register u_int32_t rv;
-
-	rv = (bytes[0] << 8) |
-	     bytes[1];
-	return (rv);
-}
-
-static __inline u_int16_t
-_2btos(bytes)
-	u_int8_t *bytes;
-{
-	register u_int16_t rv;
-
-	rv = (bytes[0] << 8) |
-	     bytes[1];
-	return (rv);
-}
-
-static __inline u_int32_t
-_3btol(bytes)
-	u_int8_t *bytes;
-{
-	register u_int32_t rv;
-
-	rv = (bytes[0] << 16) |
-	     (bytes[1] << 8) |
-	     bytes[2];
-	return (rv);
-}
-
-static __inline u_int32_t
-_4btol(bytes)
-	u_int8_t *bytes;
-{
-	register u_int32_t rv;
-
-	rv = (bytes[0] << 24) |
-	     (bytes[1] << 16) |
-	     (bytes[2] << 8) |
-	     bytes[3];
-	return (rv);
-}
-
-static __inline void
-_lto2l(val, bytes)
-	u_int32_t val;
-	u_int8_t *bytes;
-{
-
-	bytes[0] = val & 0xff;
-	bytes[1] = (val >> 8) & 0xff;
-}
-
-static __inline void
-_lto3l(val, bytes)
-	u_int32_t val;
-	u_int8_t *bytes;
-{
-
-	bytes[0] = val & 0xff;
-	bytes[1] = (val >> 8) & 0xff;
-	bytes[2] = (val >> 16) & 0xff;
-}
-
-static __inline void
-_lto4l(val, bytes)
-	u_int32_t val;
-	u_int8_t *bytes;
-{
-
-	bytes[0] = val & 0xff;
-	bytes[1] = (val >> 8) & 0xff;
-	bytes[2] = (val >> 16) & 0xff;
-	bytes[3] = (val >> 24) & 0xff;
-}
-
-static __inline u_int32_t
-_2ltol(bytes)
-	u_int8_t *bytes;
-{
-	register u_int32_t rv;
-
-	rv = bytes[0] |
-	     (bytes[1] << 8);
-	return (rv);
-}
-
-static __inline u_int32_t
-_3ltol(bytes)
-	u_int8_t *bytes;
-{
-	register u_int32_t rv;
-
-	rv = bytes[0] |
-	     (bytes[1] << 8) |
-	     (bytes[2] << 16);
-	return (rv);
-}
-
-static __inline u_int32_t
-_4ltol(bytes)
-	u_int8_t *bytes;
-{
-	register u_int32_t rv;
-
-	rv = bytes[0] |
-	     (bytes[1] << 8) |
-	     (bytes[2] << 16) |
-	     (bytes[3] << 24);
-	return (rv);
-}
-
-static __inline void
-bswap (buf, len)
-	char *buf;
-	int len;
-{
-	u_int16_t *p = (u_int16_t *)(buf + len);
-
-	while (--p >= (u_int16_t *)buf)
-		*p = (*p & 0xff) << 8 | (*p >> 8 & 0xff);
-}
-
-static __inline void
-btrim (buf, len)
-	char *buf;
-	int len;
-{
-	char *p;
-
-	/* Remove the trailing spaces. */
-	for (p = buf; p < buf + len; ++p)
-		if (*p == '\0')
-			*p = ' ';
-
-	for (p = buf + len - 1; p >= buf && *p == ' '; --p)
-		*p = '\0';
-}

