commit b4692770f7583dc41127ef1f2778a4f54c49d8ac
Author: Paul Wouters <paul@xelerance.com>
Date:   Tue Sep 21 19:19:58 2010 -0400

    Fix to compile without DEBUG (bug #1040)
    
    Note: sometimes there is a reliance on NO_DEBUG, so the safe way to actually
    disable DEBUG is to change -DDEBUG to -DNO_DEBUG.
    
    Mostly fixes to DBG macros, and moving variables inside the DBG macros.
    
    Since this touched so many files, I also updated the Copyrights on these
    as based on openswan-2 git history.

diff --git a/lib/libipsecconf/keywords.c b/lib/libipsecconf/keywords.c
index a68d097b1..70fc95bce 100644
--- a/lib/libipsecconf/keywords.c
+++ b/lib/libipsecconf/keywords.c
@@ -1,7 +1,7 @@
 /*
  * Openswan config file parser (keywords.c)
  * Copyright (C) 2003-2006 Michael Richardson <mcr@xelerance.com>
- * Copyright (C) 2007-2008 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2007-2010 Paul Wouters <paul@xelerance.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -207,7 +207,7 @@ struct keyword_enum_values kw_nm_configured=
 extern struct keyword_enum_values kw_host_list;
 
 
-
+#ifdef DEBUG
 struct keyword_enum_value kw_plutodebug_values[]={
     { "none",     DBG_NONE },
     { "all",      DBG_ALL },
@@ -264,7 +264,7 @@ struct keyword_enum_value kw_klipsdebug_values[]={
 
 struct keyword_enum_values kw_klipsdebug_list=
     { kw_klipsdebug_values, sizeof(kw_klipsdebug_values)/sizeof(struct keyword_enum_value)};
-    
+#endif
 
 struct keyword_enum_value kw_phase2types_values[]={
     { "ah+esp",   POLICY_ENCRYPT|POLICY_AUTHENTICATE },
@@ -295,8 +295,10 @@ struct keyword_def ipsec_conf_keywords_v2[]={
     {"interfaces",     kv_config, kt_string,    KSF_INTERFACES,NOT_ENUM},
     {"myid",           kv_config, kt_string,    KSF_MYID,NOT_ENUM},
     {"syslog",         kv_config, kt_string,    KSF_SYSLOG,NOT_ENUM},
+#ifdef DEBUG
     {"klipsdebug",     kv_config, kt_list,      KBF_KLIPSDEBUG, &kw_klipsdebug_list},
     {"plutodebug",     kv_config, kt_list,      KBF_PLUTODEBUG, &kw_plutodebug_list},
+#endif
     {"plutoopts",      kv_config, kt_string,    KSF_PLUTOOPTS,NOT_ENUM},
     {"plutostderrlog", kv_config, kt_filename,  KSF_PLUTOSTDERRLOG,NOT_ENUM},
     {"plutorestartoncrash", kv_config, kt_bool, KBF_PLUTORESTARTONCRASH,NOT_ENUM},
diff --git a/lib/libopenswan/oswlog.c b/lib/libopenswan/oswlog.c
index 924a0b5ee..8a4ad09b5 100644
--- a/lib/libopenswan/oswlog.c
+++ b/lib/libopenswan/oswlog.c
@@ -1,6 +1,7 @@
 /* error logging functions
  * Copyright (C) 1997 Angelos D. Keromytis.
  * Copyright (C) 1998-2001  D. Hugh Redelmeier.
+ * Copyright (C) 2007-2010 Paul Wouters <paul@xelerance.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -12,7 +13,6 @@
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  * for more details.
  *
- * RCSID $Id: oswlog.c,v 1.3 2004/10/16 23:42:13 mcr Exp $
  */
 
 #include <stdio.h>
@@ -42,9 +42,11 @@ bool
 bool
     logged_txt_warning = FALSE;  /* should we complain about finding KEY? */
 
+#ifdef DEBUG
 void openswanlib_passert_fail(const char *pred_str, const char *file_str,
 			      unsigned long line_no);
 openswan_passert_fail_t openswan_passert_fail = openswanlib_passert_fail;
+#endif
 
 void
 tool_init_log(void)
diff --git a/lib/libopenswan/x509chain.c b/lib/libopenswan/x509chain.c
index a7f4d1373..3027d3540 100644
--- a/lib/libopenswan/x509chain.c
+++ b/lib/libopenswan/x509chain.c
@@ -3,6 +3,8 @@
  * Copyright (C) 2001 Marco Bertossa, Andreas Schleiss
  * Copyright (C) 2002 Mario Strasser
  * Copyright (C) 2000-2004 Andreas Steffen, Zuercher Hochschule Winterthur
+ * Copyright (C) 2010 Paul Wouters <paul@xelerance.com>
+ *
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -416,9 +418,9 @@ trust_authcert_candidate(const x509cert_t *cert, const x509cert_t *alt_chain)
     for (pathlen = 0; pathlen < MAX_CA_PATH_LEN; pathlen++)
     {
        const x509cert_t *authcert = NULL;
-       char buf[ASN1_BUF_LEN];
 
        DBG(DBG_CONTROL,
+           char buf[ASN1_BUF_LEN];
            dntoa(buf, ASN1_BUF_LEN, cert->subject);
            DBG_log("subject: '%s'",buf);
            dntoa(buf, ASN1_BUF_LEN, cert->issuer);
diff --git a/lib/libopenswan/x509dn.c b/lib/libopenswan/x509dn.c
index c783e2969..b27141476 100644
--- a/lib/libopenswan/x509dn.c
+++ b/lib/libopenswan/x509dn.c
@@ -5,7 +5,7 @@
  * Copyright (C) 2000-2004 Andreas Steffen, Zuercher Hochschule Winterthur
  * Copyright (C) 2003-2008 Michael C Richardson <mcr@xelerance.com> 
  * Copyright (C) 2008 Antony Antony <antony@xelerance.com>
- * Copyright (C) 2003-2009 Paul Wouters <paul@xelerance.com> 
+ * Copyright (C) 2003-2010 Paul Wouters <paul@xelerance.com> 
  * Copyright (C) 2009 Avesh Agarwal <avagarwa@redhat.com>
  *
  * This program is free software; you can redistribute it and/or modify it
@@ -1605,7 +1605,6 @@ gntoid(struct id *id, const generalName_t *gn)
 static generalName_t*
 parse_generalName(chunk_t blob, int level0)
 {
-    u_char buf[ASN1_BUF_LEN];
     asn1_ctx_t ctx;
     chunk_t object;
     unsigned int objectID = 0;
@@ -1631,6 +1630,7 @@ parse_generalName(chunk_t blob, int level0)
 	    break;
 	case GN_OBJ_DIRECTORY_NAME:
 	    DBG(DBG_PARSING,
+		u_char buf[ASN1_BUF_LEN];
 		dntoa((char *)buf, ASN1_BUF_LEN, object);
 		DBG_log("  '%s'", buf)
 	    )
@@ -1960,7 +1960,6 @@ parse_crlDistributionPoints(chunk_t blob, int level0)
 bool
 parse_x509cert(chunk_t blob, u_int level0, x509cert_t *cert)
 {
-    u_char  buf[ASN1_BUF_LEN];
     asn1_ctx_t ctx;
     bool critical;
     chunk_t object;
@@ -2000,6 +1999,7 @@ parse_x509cert(chunk_t blob, u_int level0, x509cert_t *cert)
 	case X509_OBJ_ISSUER:
 	    cert->issuer = object;
 	    DBG(DBG_PARSING,
+		u_char  buf[ASN1_BUF_LEN];
 		dntoa((char *)buf, ASN1_BUF_LEN, object);
 		DBG_log("  '%s'",buf));
 	    break;
@@ -2012,6 +2012,7 @@ parse_x509cert(chunk_t blob, u_int level0, x509cert_t *cert)
 	case X509_OBJ_SUBJECT:
 	    cert->subject = object;
 	    DBG(DBG_PARSING,
+		u_char  buf[ASN1_BUF_LEN];
 		dntoa((char *)buf, ASN1_BUF_LEN, object);
 		DBG_log("  '%s'",buf));
 	    break;
@@ -2117,7 +2118,6 @@ parse_x509cert(chunk_t blob, u_int level0, x509cert_t *cert)
 bool
 parse_x509crl(chunk_t blob, u_int level0, x509crl_t *crl)
 {
-    u_char buf[ASN1_BUF_LEN];
     asn1_ctx_t ctx;
     bool critical;
     chunk_t extnID;
@@ -2158,6 +2158,7 @@ parse_x509crl(chunk_t blob, u_int level0, x509crl_t *crl)
 	case CRL_OBJ_ISSUER:
 	    crl->issuer = object;
 	    DBG(DBG_PARSING,
+		u_char buf[ASN1_BUF_LEN];
 		dntoa((char *)buf, ASN1_BUF_LEN, object);
 		DBG_log("  '%s'",buf));
 	    break;
diff --git a/programs/pluto/ac.c b/programs/pluto/ac.c
index 7b16a5679..e7bf110c7 100644
--- a/programs/pluto/ac.c
+++ b/programs/pluto/ac.c
@@ -1,6 +1,10 @@
 /* Support of X.509 attribute certificates
  * Copyright (C) 2002 Ueli Gallizzi, Ariane Seiler
  * Copyright (C) 2003 Martin Berner, Lukas Suter
+ * Copyright (C) 2005-2007 Michael Richardson <mcr@xelerance.com>
+ * Copyright (C) 2008-2010 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2009 David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2009 Gilles Espinasse <g.esp@free.fr>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -12,7 +16,6 @@
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  * for more details.
  *
- * RCSID $Id: ac.c,v 1.10 2005/09/19 00:22:00 mcr Exp $
  */
 
 #include <stdlib.h>
@@ -669,12 +672,12 @@ check_ac_validity(const x509acert_t *ac)
 static bool
 verify_x509acert(x509acert_t *ac, bool strict)
 {
-    u_char buf[BUF_LEN];
     x509cert_t *aacert;
     err_t ugh = NULL;
     time_t valid_until = ac->notAfter;
 
     DBG(DBG_CONTROL,
+	u_char buf[BUF_LEN];
 	dntoa((char *)buf, BUF_LEN, ac->entityName);
 	DBG_log("holder: '%s'",buf);
 	dntoa((char *)buf, BUF_LEN, ac->issuerName);
diff --git a/programs/pluto/connections.c b/programs/pluto/connections.c
index 159edabfa..62486f146 100644
--- a/programs/pluto/connections.c
+++ b/programs/pluto/connections.c
@@ -1574,7 +1574,9 @@ instantiate(struct connection *c, const ip_address *him
 	    , const struct id *his_id)
 {
     struct connection *d;
+#ifdef DEBUG
     int wildcards;
+#endif
 
     passert(c->kind == CK_TEMPLATE);
     passert(c->spd.next == NULL);
@@ -1661,7 +1663,6 @@ oppo_instantiate(struct connection *c
 		 , const ip_address *peer_client)
 {
     struct connection *d = instantiate(c, him, his_id);
-    char instbuf[512];
 
     DBG(DBG_CONTROL,
 	DBG_log("oppo instantiate d=%s from c=%s with c->routing %s, d->routing %s"
@@ -1669,6 +1670,7 @@ oppo_instantiate(struct connection *c
 		, enum_name(&routing_story, c->spd.routing)
 		, enum_name(&routing_story, d->spd.routing)));
     DBG(DBG_CONTROL,
+	char instbuf[512];
 	DBG_log("new oppo instance: %s"
 		, (format_connection(instbuf, sizeof(instbuf), d, &d->spd), instbuf)));
 
@@ -1841,18 +1843,17 @@ find_connection_for_clients(struct spd_route **srp,
     best_sr = NULL;
 
     passert(!isanyaddr(our_client) && !isanyaddr(peer_client));
-#ifdef DEBUG
-    if (DBGP(DBG_CONTROL))
-    {
-	char ocb[ADDRTOT_BUF], pcb[ADDRTOT_BUF];
+
+    DBG(DBG_CONTROL,
+	char ocb[ADDRTOT_BUF];
+	char pcb[ADDRTOT_BUF];
 
 	addrtot(our_client, 0, ocb, sizeof(ocb));
 	addrtot(peer_client, 0, pcb, sizeof(pcb));
 	DBG_log("find_connection: "
 		"looking for policy for connection: %s:%d/%d -> %s:%d/%d"
-		, ocb, transport_proto, our_port, pcb, transport_proto, peer_port);
-    }
-#endif /* DEBUG */
+		, ocb, transport_proto, our_port, pcb, transport_proto, peer_port));
+
 
     for (c = connections; c != NULL; c = c->ac_next)
     {
@@ -1868,18 +1869,17 @@ find_connection_for_clients(struct spd_route **srp,
  	    && (!sr->this.port || our_port == sr->this.port)
  	    && (!sr->that.port || peer_port == sr->that.port))
 	    {
-		char cib[CONN_INST_BUF];
-		char cib2[CONN_INST_BUF];
 
  		policy_prio_t prio = 8 * (c->prio + (c->kind == CK_INSTANCE))
  				   + 2 * (sr->this.port == our_port)
  				   + 2 * (sr->that.port == peer_port)
  				   +     (sr->this.protocol == transport_proto);
 
-#ifdef DEBUG
-		if (DBGP(DBG_CONTROL|DBG_CONTROLMORE))
+		DBG(DBG_CONTROLMORE,
 		{
-		    char c_ocb[SUBNETTOT_BUF], c_pcb[SUBNETTOT_BUF];
+		    char cib[CONN_INST_BUF];
+		    char c_ocb[SUBNETTOT_BUF];
+		    char c_pcb[SUBNETTOT_BUF];
 
 		    subnettot(&c->spd.this.client, 0, c_ocb, sizeof(c_ocb));
 		    subnettot(&c->spd.that.client, 0, c_pcb, sizeof(c_pcb));
@@ -1889,7 +1889,7 @@ find_connection_for_clients(struct spd_route **srp,
 			    , (fmt_conn_instance(c, cib), cib)
 			    , c_ocb, c_pcb, prio);
 		}
-#endif /* DEBUG */
+		);
 
 		if (best == NULL)
 		{
@@ -1899,6 +1899,9 @@ find_connection_for_clients(struct spd_route **srp,
 		}
 
 		DBG(DBG_CONTROLMORE,
+		{
+		    char cib[CONN_INST_BUF];
+		    char cib2[CONN_INST_BUF];
 		    DBG_log("find_connection: comparing best \"%s\"%s [pri:%ld]{%p} (child %s) to \"%s\"%s [pri:%ld]{%p} (child %s)"
 			    , best->name
 			    , (fmt_conn_instance(best, cib), cib)
@@ -1909,7 +1912,9 @@ find_connection_for_clients(struct spd_route **srp,
 			    , (fmt_conn_instance(c, cib2), cib2)
 			    , prio
 			    , c
-			    , (c->policy_next ? c->policy_next->name : "none")));
+			    , (c->policy_next ? c->policy_next->name : "none"));
+		}
+		);
 
 		if (prio > best_prio)
 		{
@@ -2199,8 +2204,9 @@ find_host_connection2(const char *func
 		     , const ip_address *him, u_int16_t his_port, lset_t policy)
 {
     struct connection *c;
-    char mebuf[ADDRTOT_BUF], himbuf[ADDRTOT_BUF];
     DBG(DBG_CONTROLMORE,
+        char mebuf[ADDRTOT_BUF];
+        char himbuf[ADDRTOT_BUF];
 	DBG_log("find_host_connection2 called from %s, me=%s:%d him=%s:%d policy=%s", func
 		, (addrtot(me,  0, mebuf,  sizeof(mebuf)),mebuf),   my_port
 		, him ?  (addrtot(him, 0, himbuf, sizeof(himbuf)),himbuf) : "%any"
diff --git a/programs/pluto/crypt_dh.c b/programs/pluto/crypt_dh.c
index 2572a100e..ec2dbf0e0 100644
--- a/programs/pluto/crypt_dh.c
+++ b/programs/pluto/crypt_dh.c
@@ -1,8 +1,11 @@
 /* 
  * Cryptographic helper function - calculate DH
  * Copyright (C) 2007-2008 Michael C. Richardson <mcr@xelerance.com>
- * Copyright (C) 2009 Avesh Agarwal <avagarwa@redhat.com>
- * Copyright (C) 2009 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2008 Antony Antony <antony@xelerance.com>
+ * Copyright (C) 2009 David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2009-2010 Avesh Agarwal <avagarwa@redhat.com>
+ * Copyright (C) 2009-2010 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2010 Tuomo Soini <tis@foobar.fi>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -1285,14 +1288,14 @@ calc_skeyseed_v2(struct pcr_skeyid_q *skq
 	vpss.t.len = 0;
 	total_keysize = skd_bytes + (2*(ska_bytes + ske_bytes + skp_bytes));
 
-	if(DBGP(DBG_CRYPT)) {
+	DBG(DBG_CRYPT,
 	    DBG_log("PRF+ input");
 	    DBG_dump_chunk("Ni", vpss.ni);
 	    DBG_dump_chunk("Nr", vpss.nr);
 	    DBG_dump_chunk("SPIi", vpss.spii);
 	    DBG_dump_chunk("SPIr", vpss.spir);
 	    DBG_log("Total keysize needed %d", (int)total_keysize);
-	}
+	);
 #ifdef HAVE_LIBNSS
 	counter.ptr = &vpss.counter[0];
 	counter.len =1;
diff --git a/programs/pluto/foodgroups.c b/programs/pluto/foodgroups.c
index 3a22e7940..f30e40861 100644
--- a/programs/pluto/foodgroups.c
+++ b/programs/pluto/foodgroups.c
@@ -1,5 +1,7 @@
 /* Implement policy groups-style control files (aka "foodgroups")
  * Copyright (C) 2002  D. Hugh Redelmeier.
+ * Copyright (C) 2005 Michael Richardson <mcr@xelerance.com>
+ * Copyright (C) 2009-2010 Paul Wouters <paul@xelerance.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -144,10 +146,10 @@ read_foodgroup(struct fg_groups *g)
     snprintf(fg_path, fg_path_space, "%s/%s", oco->policies_dir, fgn);
     if (!lexopen(&flp_space, fg_path, TRUE))
     {
-	char cwd[PATH_MAX];
 
-	DBG(DBG_CONTROL
-	    , DBG_log("no group file \"%s\" (pwd:%s)"
+	DBG(DBG_CONTROL,
+	    char cwd[PATH_MAX];
+	    DBG_log("no group file \"%s\" (pwd:%s)"
 		      , fg_path
 		      , getcwd(cwd, sizeof(cwd))));
     }
diff --git a/programs/pluto/hostpair.c b/programs/pluto/hostpair.c
index b73895124..35c8bf698 100644
--- a/programs/pluto/hostpair.c
+++ b/programs/pluto/hostpair.c
@@ -1,5 +1,9 @@
 /* information about connections between hosts and clients
  * Copyright (C) 1998-2002  D. Hugh Redelmeier.
+ * Copyright (C) 2007 Michael Richardson <mcr@xelerance.com>
+ * Copyright (C) 2007 Ken Bantoft <ken@xelerance.com>
+ * Copyright (C) 2008-2010 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2010 Tuomo Soini <tis@foobar.fi>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -128,7 +132,6 @@ find_host_pair(const ip_address *myaddr
 	       , u_int16_t hisport)
 {
     struct host_pair *p, *prev;
-    char b1[ADDRTOT_BUF],b2[ADDRTOT_BUF];
 
     /* default hisaddr to an appropriate any */
     if (hisaddr == NULL) {
@@ -163,8 +166,10 @@ find_host_pair(const ip_address *myaddr
 
     for (prev = NULL, p = host_pairs; p != NULL; prev = p, p = p->next)
     {
-	DBG(DBG_CONTROLMORE
-	    , DBG_log("find_host_pair: comparing to %s:%d %s:%d\n"
+	DBG(DBG_CONTROLMORE,
+	    char b1[ADDRTOT_BUF];
+	    char b2[ADDRTOT_BUF];
+	    DBG_log("find_host_pair: comparing to %s:%d %s:%d\n"
 		      , (addrtot(&p->me.addr, 0, b1, sizeof(b1)), b1)
 		      , p->me.host_port
 		      , (addrtot(&p->him.addr, 0, b2, sizeof(b2)), b2)
@@ -199,11 +204,12 @@ find_host_pair_connections(const char *func
 			   , const ip_address *myaddr, u_int16_t myport			   
 			   , const ip_address *hisaddr, u_int16_t hisport)
 {
-    char b1[ADDRTOT_BUF],b2[ADDRTOT_BUF];
     struct host_pair *hp = find_host_pair(myaddr, myport, hisaddr, hisport);
 
-    DBG(DBG_CONTROLMORE
-	, DBG_log("find_host_pair_conn (%s): %s:%d %s:%d -> hp:%s\n"
+    DBG(DBG_CONTROLMORE,
+	char b1[ADDRTOT_BUF];
+	char b2[ADDRTOT_BUF];
+	DBG_log("find_host_pair_conn (%s): %s:%d %s:%d -> hp:%s\n"
 		  , func
 		  , (addrtot(myaddr,  0, b1, sizeof(b1)), b1)
 		  , myport
@@ -224,10 +230,11 @@ connect_to_host_pair(struct connection *c)
 					      , &c->spd.that.host_addr
 					      , c->spd.that.host_port);
 
-	char b1[ADDRTOT_BUF],b2[ADDRTOT_BUF];
 
-	DBG(DBG_CONTROLMORE
-	    , DBG_log("connect_to_host_pair: %s:%d %s:%d -> hp:%s\n"
+	DBG(DBG_CONTROLMORE,
+	    char b1[ADDRTOT_BUF];
+	    char b2[ADDRTOT_BUF];
+	    DBG_log("connect_to_host_pair: %s:%d %s:%d -> hp:%s\n"
 		      , (addrtot(&c->spd.this.host_addr, 0, b1,sizeof(b1)), b1)
 		      , c->spd.this.host_port
 		      , (addrtot(&c->spd.that.host_addr, 0, b2,sizeof(b2)), b2)
diff --git a/programs/pluto/ikev1.c b/programs/pluto/ikev1.c
index 60ac6d50f..41fe48dbb 100644
--- a/programs/pluto/ikev1.c
+++ b/programs/pluto/ikev1.c
@@ -1,6 +1,11 @@
 /* State machine for IKEv1
  * Copyright (C) 1997 Angelos D. Keromytis.
- * Copyright (C) 1998-2002  D. Hugh Redelmeier.
+ * Copyright (C) 1998-2010  D. Hugh Redelmeier.
+ * Copyright (C) 2003-2008 Michael Richardson <mcr@xelerance.com>
+ * Copyright (C) 2008-2009 David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2008-2010 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2008 Hiren Joshi <joshihirenn@gmail.com>
+ * Copyright (C) 2009 Anthony Tong <atong@TrustedCS.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -707,14 +712,17 @@ informational(struct msg_digest *md)
 
                 DBG_cond_dump(DBG_PARSING, "redirected remote end info:", n_pbs->cur + pbs_left(n_pbs)-4, 4);
 
+#ifdef DEBUG
                 /*Current remote peer info*/
                 {
 
                 char buftest[ADDRTOT_BUF];
                 struct spd_route *tmp_spd = &tmp_c->spd;
                 int count_spd=0;
+
                 do {
-                DBG(DBG_CONTROLMORE, DBG_log("spd route number: %d", ++count_spd));
+                DBG(DBG_CONTROLMORE,
+                    DBG_log("spd route number: %d", ++count_spd));
 
                 /**that info**/
                 DBG(DBG_CONTROLMORE, DBG_log("that id kind: %d",tmp_spd->that.id.kind));
@@ -735,7 +743,6 @@ informational(struct msg_digest *md)
                 tmp_spd = tmp_spd->next;
                 } while(tmp_spd!=NULL);
 
-
                 if(tmp_c->interface!=NULL){
                 DBG(DBG_CONTROLMORE, 
                 DBG_log("Current interface_addr: %s", (addrtot(&tmp_c->interface->ip_addr, 0, buftest, sizeof(buftest)), buftest)));
@@ -749,7 +756,7 @@ informational(struct msg_digest *md)
                 }
 
                 }
-
+#endif
                 ip_address old_addr;
                 /*storing old address for comparison purposes*/
                 old_addr = tmp_c->spd.that.host_addr;
@@ -763,33 +770,27 @@ informational(struct msg_digest *md)
                 tmp_c->spd.that.host_addr_name = NULL;
                 tmp_c->spd.that.id.ip_addr= tmp_c->spd.that.host_addr;
 
-                if(sameaddr(&tmp_c->spd.this.host_nexthop, &old_addr)) {
-                char buftest[ADDRTOT_BUF];
-                DBG(DBG_CONTROLMORE, DBG_log("Old remote addr %s", (addrtot(&old_addr, 0, buftest, sizeof(buftest)), buftest)));
-                DBG(DBG_CONTROLMORE,
-                DBG_log("Old this host next hop %s", (addrtot(&tmp_c->spd.this.host_nexthop, 0, buftest, sizeof(buftest)), buftest)));
-                tmp_c->spd.this.host_nexthop = tmp_c->spd.that.host_addr;
                 DBG(DBG_CONTROLMORE,
-                DBG_log("New this host next hop %s", (addrtot(&tmp_c->spd.this.host_nexthop, 0, buftest, sizeof(buftest)), buftest)));
-                }
-
-                if(sameaddr(&tmp_c->spd.that.host_srcip, &old_addr)) {
-                char buftest[ADDRTOT_BUF];
-                DBG(DBG_CONTROLMORE, 
-                DBG_log("Old that host srcip %s", (addrtot(&tmp_c->spd.that.host_srcip, 0, buftest, sizeof(buftest)), buftest)));
-                tmp_c->spd.that.host_srcip = tmp_c->spd.that.host_addr;
-                DBG(DBG_CONTROLMORE, 
-                DBG_log("New that host srcip %s", (addrtot(&tmp_c->spd.that.host_srcip, 0, buftest, sizeof(buftest)), buftest)));
-                }
-
-                if(sameaddr(&tmp_c->spd.that.client.addr, &old_addr)) {
-                char buftest[ADDRTOT_BUF];
-                DBG(DBG_CONTROLMORE, 
-                DBG_log("Old that client ip %s", (addrtot(&tmp_c->spd.that.client.addr, 0, buftest, sizeof(buftest)), buftest)));
-                tmp_c->spd.that.client.addr = tmp_c->spd.that.host_addr;
-                DBG(DBG_CONTROLMORE, 
-                DBG_log("New that client ip %s", (addrtot(&tmp_c->spd.that.client.addr, 0, buftest, sizeof(buftest)), buftest)));
-                }
+                    char buftest[ADDRTOT_BUF];
+                    if(sameaddr(&tmp_c->spd.this.host_nexthop, &old_addr)) {
+                       DBG_log("Old remote addr %s", (addrtot(&old_addr, 0, buftest, sizeof(buftest)), buftest));
+                       DBG_log("Old this host next hop %s", (addrtot(&tmp_c->spd.this.host_nexthop, 0, buftest, sizeof(buftest)), buftest));
+                       tmp_c->spd.this.host_nexthop = tmp_c->spd.that.host_addr;
+                       DBG_log("New this host next hop %s", (addrtot(&tmp_c->spd.this.host_nexthop, 0, buftest, sizeof(buftest)), buftest));
+                    }
+
+                    if(sameaddr(&tmp_c->spd.that.host_srcip, &old_addr)) {
+                       DBG_log("Old that host srcip %s", (addrtot(&tmp_c->spd.that.host_srcip, 0, buftest, sizeof(buftest)), buftest));
+                       tmp_c->spd.that.host_srcip = tmp_c->spd.that.host_addr;
+                       DBG_log("New that host srcip %s", (addrtot(&tmp_c->spd.that.host_srcip, 0, buftest, sizeof(buftest)), buftest));
+                    }
+
+                    if(sameaddr(&tmp_c->spd.that.client.addr, &old_addr)) {
+                       DBG_log("Old that client ip %s", (addrtot(&tmp_c->spd.that.client.addr, 0, buftest, sizeof(buftest)), buftest));
+                       tmp_c->spd.that.client.addr = tmp_c->spd.that.host_addr;
+                       DBG_log("New that client ip %s", (addrtot(&tmp_c->spd.that.client.addr, 0, buftest, sizeof(buftest)), buftest));
+                    }
+                   );
 
 		tmp_c->host_pair->him.addr = tmp_c->spd.that.host_addr;
 
@@ -1993,10 +1994,10 @@ complete_v1_state_transition(struct msg_digest **mdp, stf_status result)
 	    /* if requested, send the new reply packet */
 	    if (smc->flags & SMF_REPLY)
 	    {
-		char buf[ADDRTOT_BUF];
 
-		DBG(DBG_CONTROL
-		    , DBG_log("sending reply packet to %s:%u (from port %u)"
+		DBG(DBG_CONTROL,
+		    char buf[ADDRTOT_BUF];
+		    DBG_log("sending reply packet to %s:%u (from port %u)"
 			      , (addrtot(&st->st_remoteaddr
 					 , 0, buf, sizeof(buf)), buf)
 			      , st->st_remoteport
diff --git a/programs/pluto/ikev1_main.c b/programs/pluto/ikev1_main.c
index 7af81e0df..5a75a3926 100644
--- a/programs/pluto/ikev1_main.c
+++ b/programs/pluto/ikev1_main.c
@@ -2,8 +2,12 @@
  * Copyright (C) 1997 Angelos D. Keromytis.
  * Copyright (C) 1998-2002  D. Hugh Redelmeier.
  * Copyright (C) 2003-2008 Michael C. Richardson <mcr@xelerance.com>
- * Copyright (C) 2003-2009 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2003-2010 Paul Wouters <paul@xelerance.com>
  * Copyright (C) 2009 Avesh Agarwal <avagarwa@redhat.com>
+ * Copyright (C) 2008 Ilia Sotnikov
+ * Copyright (C) 2009 Seong-hun Lim
+ * Copyright (C) 2008-2009 David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2010 Tuomo Soini <tis@foobar.fi>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -1331,7 +1335,6 @@ main_inI2_outR2_tail(struct pluto_crypto_req_cont *pcrc
     struct ke_continuation *ke = (struct ke_continuation *)pcrc;
     struct msg_digest *md = ke->md;
     struct state *st = md->st;
-    int next_payload;
 
     /* send CR if auth is RSA and no preloaded RSA public key exists*/
     bool send_cr = FALSE;
@@ -1355,7 +1358,9 @@ main_inI2_outR2_tail(struct pluto_crypto_req_cont *pcrc
 	}
 
 #ifdef DEBUG
+ {
     /* Nr out */
+    int next_payload;
     next_payload = ISAKMP_NEXT_NONE;
 
     if(cur_debugging & IMPAIR_BUST_MR2)
@@ -1384,6 +1389,7 @@ main_inI2_outR2_tail(struct pluto_crypto_req_cont *pcrc
 	    return STF_INTERNAL_ERROR;
 	close_output_pbs(&vid_pbs);
     }
+ }
 #else
     /* Nr out */
     if (!ship_nonce(&st->st_nr, r
diff --git a/programs/pluto/ikev2.c b/programs/pluto/ikev2.c
index bb104cf2f..e6c9564b0 100644
--- a/programs/pluto/ikev2.c
+++ b/programs/pluto/ikev2.c
@@ -1,6 +1,11 @@
 /* demultiplex incoming IKE messages
  * Copyright (C) 1997 Angelos D. Keromytis.
- * Copyright (C) 1998-2002  D. Hugh Redelmeier.
+ * Copyright (C) 1998-2010  D. Hugh Redelmeier.
+ * Copyright (C) 2007-2008 Michael Richardson <mcr@xelerance.com>
+ * Copyright (C) 2009 David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2008-2010 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2010 Simon Deziel <simon@xelerance.com>
+ * Copyright (C) 2010 Tuomo Soini <tis@foobar.fi>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -703,7 +708,6 @@ static void success_v2_state_transition(struct msg_digest **mdp)
     /* if requested, send the new reply packet */
     if (svm->flags & SMF2_REPLY)
     {
-	char buf[ADDRTOT_BUF];
 
 	/* free previously transmitted packet */
 	freeanychunk(st->st_tpacket);
@@ -713,8 +717,9 @@ static void success_v2_state_transition(struct msg_digest **mdp)
 	    nat_traversal_change_port_lookup(md, st);
 	}
 #endif
-	DBG(DBG_CONTROL
-	    , DBG_log("sending reply packet to %s:%u (from port %u)"
+	DBG(DBG_CONTROL,
+	    char buf[ADDRTOT_BUF];
+	    DBG_log("sending reply packet to %s:%u (from port %u)"
 		      , (addrtot(&st->st_remoteaddr
 				 , 0, buf, sizeof(buf)), buf)
 		      , st->st_remoteport
diff --git a/programs/pluto/ikev2_child.c b/programs/pluto/ikev2_child.c
index 1b61c5186..e1301f82c 100644
--- a/programs/pluto/ikev2_child.c
+++ b/programs/pluto/ikev2_child.c
@@ -1,7 +1,8 @@
 /* IKEv2 - CHILD SA - calculations
  *
- * Copyright (C) 2007 Michael Richardson <mcr@xelerance.com>
- * Copyright (C) 2008-2009 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2007-2008 Michael Richardson <mcr@xelerance.com>
+ * Copyright (C) 2009-2010 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2010 Tuomo Soini <tis@foobar.fi>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -283,8 +284,6 @@ static int ikev2_evaluate_connection_fit(struct connection *d
     int bestfit = -1;
     int best_tsr, best_tsi; 
     struct end *ei, *er;
-#ifdef DEBUG
-    char ei3[SUBNETTOT_BUF],er3[SUBNETTOT_BUF];
     
     if(role == INITIATOR) {
 	ei = &sr->this;
@@ -294,8 +293,10 @@ static int ikev2_evaluate_connection_fit(struct connection *d
 	er = &sr->this;
     }
 	
-    if (DBGP(DBG_CONTROLMORE))
+    DBG(DBG_CONTROLMORE,
     {
+	char ei3[SUBNETTOT_BUF];
+	char er3[SUBNETTOT_BUF];
 	subnettot(&ei->client,  0, ei3, sizeof(ei3));
 	subnettot(&er->client,  0, er3, sizeof(er3));
 	DBG_log("  ikev2_eval_conn evaluating "
@@ -304,17 +305,19 @@ static int ikev2_evaluate_connection_fit(struct connection *d
 		, er3, er->protocol, er->port
 		, is_virtual_connection(d) ? "(virt)" : "");
     }
-#endif /* DEBUG */
+    );
    
     /* compare tsi/r array to this/that, evaluating how well it fits */
     for(tsi_ni = 0; tsi_ni < tsi_n; tsi_ni++) {
 	for(tsr_ni=0; tsr_ni<tsr_n; tsr_ni++) {
 	    /* does it fit at all? */
 
-	    if (DBGP(DBG_CONTROLMORE))
+	    DBG(DBG_CONTROLMORE,
 	    {
-		char lbi[ADDRTOT_BUF], hbi[ADDRTOT_BUF];
-		char lbr[ADDRTOT_BUF], hbr[ADDRTOT_BUF];
+		char lbi[ADDRTOT_BUF];
+		char hbi[ADDRTOT_BUF];
+		char lbr[ADDRTOT_BUF];
+		char hbr[ADDRTOT_BUF];
 		addrtot(&tsi[tsi_ni].low,  0, lbi, sizeof(lbi));
 		addrtot(&tsi[tsi_ni].high, 0, hbi, sizeof(hbi));
 		addrtot(&tsr[tsr_ni].low,  0, lbr, sizeof(lbr));
@@ -324,7 +327,7 @@ static int ikev2_evaluate_connection_fit(struct connection *d
 			, tsi_ni, lbi, hbi
 			, tsr_ni, lbr, hbr);
 	    }
-
+	    );
 	    /* do addresses fit into the policy? */
 	    if(addrinsubnet(&tsi[tsi_ni].low, &ei->client)
 	       && addrinsubnet(&tsi[tsi_ni].high, &ei->client)
@@ -346,12 +349,13 @@ static int ikev2_evaluate_connection_fit(struct connection *d
 		int fitbits2  = maskbits2 + ts_range2;
 		int fitbits = (fitbits1 << 8) + fitbits2;
 
-		if (DBGP(DBG_CONTROLMORE))
+		DBG(DBG_CONTROLMORE,
 		{
 		    DBG_log("      has ts_range1=%u maskbits1=%u ts_range2=%u maskbits2=%u fitbits=%d <> %d"
 			    , ts_range1, maskbits1, ts_range2, maskbits2
 			    , fitbits, bestfit);
 		}
+		);
 
 		if(fitbits > bestfit) {
 		    best_tsi = tsi_ni;
diff --git a/programs/pluto/ikev2_crypto.c b/programs/pluto/ikev2_crypto.c
index 07e510e56..c924910d9 100644
--- a/programs/pluto/ikev2_crypto.c
+++ b/programs/pluto/ikev2_crypto.c
@@ -1,6 +1,7 @@
 /* IKEv2 - more cryptographic calculations
  *
  * Copyright (C) 2007 Michael Richardson <mcr@xelerance.com>
+ * Copyright (C) 2008-2010 Paul Wouters <paul@xelerance.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -114,17 +115,17 @@ void ikev2_derive_child_keys(struct state *st, enum phase1_role role)
 	 * if(role == INITIATOR) {
 	 */
 	if(role != INITIATOR) {
-	    if(DBGP(DBG_CRYPT)) {
+	    DBG(DBG_CRYPT,
 		DBG_dump_chunk("our  keymat", ikeymat);
 		DBG_dump_chunk("peer keymat", rkeymat);
-	    }
+	    );
 	    st->st_esp.our_keymat = ikeymat.ptr;
 	    st->st_esp.peer_keymat= rkeymat.ptr;
 	} else {
-	    if(DBGP(DBG_CRYPT)) {
+	    DBG(DBG_CRYPT,
 		DBG_dump_chunk("our  keymat", rkeymat);
 		DBG_dump_chunk("peer keymat", ikeymat);
-	    }
+	    );
 	    st->st_esp.peer_keymat= ikeymat.ptr;
 	    st->st_esp.our_keymat = rkeymat.ptr;
 	}
diff --git a/programs/pluto/ikev2_parent.c b/programs/pluto/ikev2_parent.c
index 79e8c8cf1..003221307 100644
--- a/programs/pluto/ikev2_parent.c
+++ b/programs/pluto/ikev2_parent.c
@@ -1,8 +1,11 @@
 /* 
  * IKEv2 parent SA creation routines
- * Copyright (C) 2007  Michael Richardson <mcr@xelerance.com>
- * Copyright (C) 2008  Paul Wouters <paul@xelerance.com>
- * Copyright (C) 2008  Antony Antony <antony@xelerance.com>
+ * Copyright (C) 2007-2008 Michael Richardson <mcr@xelerance.com>
+ * Copyright (C) 2008-2010 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2008 Antony Antony <antony@xelerance.com>
+ * Copyright (C) 2008-2009 David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2010 Avesh Agarwal <avagarwa@redhat.com>
+ * Copyright (C) 2010 Tuomo Soini <tis@foobar.fi
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -1064,11 +1067,11 @@ static stf_status ikev2_encrypt_msg(struct msg_digest *md,
 	hmac_init_chunk(&ctx, pst->st_oakley.integ_hasher, *authkey);
 	hmac_update(&ctx, authstart, authloc-authstart);
 	hmac_final(authloc, &ctx);
-	
-	if(DBGP(DBG_PARSING)) {
+
+	DBG(DBG_PARSING,
 	    DBG_dump("data being hmac:", authstart, authloc-authstart);
 	    DBG_dump("out calculated auth:", authloc, pst->st_oakley.integ_hasher->hash_integ_len); 
-	}
+           );
     }
     
     return STF_OK;
@@ -1115,11 +1118,11 @@ stf_status ikev2_decrypt_msg(struct msg_digest *md
 	hmac_update(&ctx, authstart, encend-authstart);
 	hmac_final(b12, &ctx);
 	
-	if(DBGP(DBG_PARSING)) {
+	DBG(DBG_PARSING,
 	    DBG_dump("data being hmac:", authstart, encend-authstart);
 	    DBG_dump("R2 calculated auth:", b12, pst->st_oakley.integ_hasher->hash_integ_len); 
 	    DBG_dump("R2  provided  auth:", encend, pst->st_oakley.integ_hasher->hash_integ_len);
-	}
+	);
 	
 	/* compare first 96 bits == 12 bytes */
 	/* It is not always 96 bytes, it depends upon which integ algo is used*/
@@ -1156,10 +1159,10 @@ stf_status ikev2_decrypt_msg(struct msg_digest *md
 	    return STF_FAIL;
 	}
 	
-	if(DBGP(DBG_CRYPT)) {
+	DBG(DBG_CRYPT,
 	    DBG_dump("decrypted payload:", encstart, enclen);
 	    DBG_log("striping %u bytes as pad", padlen+1);
-	}
+	);
 	
 	init_pbs(&md->clr_pbs, encstart, enclen - (padlen+1), "cleartext");
     }
diff --git a/programs/pluto/ikev2_prfplus.c b/programs/pluto/ikev2_prfplus.c
index e059c1c77..7110e85c2 100644
--- a/programs/pluto/ikev2_prfplus.c
+++ b/programs/pluto/ikev2_prfplus.c
@@ -1,6 +1,7 @@
 /* 
  * Cryptographic helper function - calculate prf+() for ikev2
  * Copyright (C) 2007 Michael C. Richardson <mcr@xelerance.com>
+ * Copyright (C) 2010 Paul Wouters <paul@xelerance.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -64,11 +65,11 @@ v2prfplus(struct v2prf_stuff *vps)
     hmac_update_chunk(&ctx, vps->spir);
     hmac_update(&ctx, vps->counter, 1);
     hmac_final_chunk(vps->t, "skeyseed_t1", &ctx);
-    if(DBGP(DBG_CRYPT)) {
+    DBG(DBG_CRYPT,
 	char b[20];
 	sprintf(b, "prf+[%u]:", vps->counter[0]);
 	DBG_dump_chunk(b, vps->t);
-    }
+    );
 
     vps->counter[0]++;
     vps->availbytes  = vps->t.len;
diff --git a/programs/pluto/ikev2_rsa.c b/programs/pluto/ikev2_rsa.c
index 326157e1c..640ed54eb 100644
--- a/programs/pluto/ikev2_rsa.c
+++ b/programs/pluto/ikev2_rsa.c
@@ -3,7 +3,7 @@
  * Copyright (C) 2007 Michael Richardson <mcr@xelerance.com>
  * Copyright (C) 2008 David McCullough <david_mccullough@securecomputing.com>
  * Copyright (C) 2009 Avesh Agarwal <avagarwa@redhat.com>
- * Copyright (C) 2003-2009 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2003-2010 Paul Wouters <paul@xelerance.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -209,10 +209,10 @@ try_RSA_signature_v2(const u_char hash_val[MAX_DIGEST_LEN]
 
     sig += der_digestinfo_len;
 
-    if(DBGP(DBG_CRYPT)) {
+    DBG(DBG_CRYPT,
 	DBG_dump("v2rsa decrypted SIG:", hash_val, hash_len);
 	DBG_dump("v2rsa computed hash:", sig, hash_len);
-    }
+    );
 	
     if(memcmp(sig, hash_val, hash_len) != 0) {
 	return "9""authentication failure: received SIG does not match computed HASH, but message is well-formed";
diff --git a/programs/pluto/ikev2_x509.c b/programs/pluto/ikev2_x509.c
index 240a2de32..d08c404b9 100644
--- a/programs/pluto/ikev2_x509.c
+++ b/programs/pluto/ikev2_x509.c
@@ -1,6 +1,9 @@
 /* do X.509 operations for IKEv2
  *
  * Copyright (C) 2008 Antony Antony <antony@xelerance.com>
+ * Copyright (C) 2008 Michael Richardson <mcr@xelerance.com>
+ * Copyright (C) 2008 David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2009-2010 Paul Wouters <paul@xelerance.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -226,7 +229,6 @@ doi_send_ikev2_cert_thinking(struct state *st)
     cert_t mycert = st->st_connection->spd.this.cert;
     enum ipsec_cert_type certtype = mycert.type;
     enum certpolicy policy = st->st_connection->spd.this.sendcert;
-    bool gotcertrequest = st->hidden_variables.st_got_certrequest;
     bool send_cert	 = FALSE;
 
     struct connection *c  = st->st_connection;
@@ -249,13 +251,14 @@ doi_send_ikev2_cert_thinking(struct state *st)
 		     (c->policy & POLICY_RSASIG) ? "" : "no",
 		     prettypolicy(c->policy)));
 
-    DBG(DBG_CONTROL
-	, DBG_log(" sendcert: %s and I did%s get a certificate request "
+    DBG(DBG_CONTROL,
+	bool gotcertrequest = st->hidden_variables.st_got_certrequest;
+	DBG_log(" sendcert: %s and I did%s get a certificate request "
 		  , enum_show(&certpolicy_type_names, policy)
-		  , gotcertrequest ? "" : " not"));
+		  , gotcertrequest ? "" : " not")
+       );
 
-    DBG(DBG_CONTROL
-	, DBG_log(" so %ssend cert.", send_cert ? "" : "do not "));
+    DBG(DBG_CONTROL, DBG_log(" so %ssend cert.", send_cert ? "" : "do not "));
 
     if(!send_cert) {
 	if(!(c->policy & POLICY_RSASIG))
diff --git a/programs/pluto/initiate.c b/programs/pluto/initiate.c
index 5db0116fd..20a948310 100644
--- a/programs/pluto/initiate.c
+++ b/programs/pluto/initiate.c
@@ -1,5 +1,12 @@
 /* information about connections between hosts and clients
- * Copyright (C) 1998-2002  D. Hugh Redelmeier.
+ * Copyright (C) 1998-2010  D. Hugh Redelmeier.
+ * Copyright (C) 2007 Michael Richardson <mcr@xelerance.com>
+ * Copyright (C) 2007 Ken Bantoft <ken@xelerance.com>
+ * Copyright (C) 2009 Stefan Arentz <stefan@arentz.ca>
+ * Copyright (C) 2009-2010 David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2007-2010 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2010 Avesh Agarwal <avagarwa@redhat.com>
+ * Copyright (C) 2010 Tuomo Soini <tis@foobar.fi>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -339,7 +346,6 @@ enum find_oppo_step {
     fos_done
 };
 
-#ifdef DEBUG
 static const char *const oppo_step_name[] = {
     "fos_start",
     "fos_myid_ip_txt",
@@ -354,7 +360,6 @@ static const char *const oppo_step_name[] = {
     "fos_his_client",
     "fos_done"
 };
-#endif /* DEBUG */
 
 struct find_oppo_bundle {
     enum find_oppo_step step;
@@ -829,10 +834,10 @@ initiate_ondemand_body(struct find_oppo_bundle *b
 	enum find_oppo_step next_step;
 	err_t ugh = ac_ugh;
 	char mycredentialstr[IDTOA_BUF];
-	char cib[CONN_INST_BUF];
 
-	DBG(DBG_CONTROL, DBG_log("creating new instance from \"%s\"%s"
-				 , c->name
+	DBG(DBG_CONTROL,
+	    char cib[CONN_INST_BUF];
+	    DBG_log("creating new instance from \"%s\"%s" , c->name
 				 , (fmt_conn_instance(c, cib), cib)));
 
 	idtoa(&sr->this.id, mycredentialstr, sizeof(mycredentialstr));
diff --git a/programs/pluto/kernel.c b/programs/pluto/kernel.c
index 979745fc4..f56f97b02 100644
--- a/programs/pluto/kernel.c
+++ b/programs/pluto/kernel.c
@@ -1,9 +1,12 @@
 /* routines that interface with the kernel's IPsec mechanism
  * Copyright (C) 1997 Angelos D. Keromytis.
- * Copyright (C) 1998-2002  D. Hugh Redelmeier.
+ * Copyright (C) 1998-2010  D. Hugh Redelmeier.
  * Copyright (C) 2003-2008 Michael Richardson <mcr@xelerance.com>
- * Copyright (C) 2007-2009 Paul Wouters <paul@xelerance.com>
- * Copyright (C) 2008-2009 David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2007-2010 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2008-2010 David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2010 Bart Trojanowski <bart@jukie.net>
+ * Copyright (C) 2009-2010 Tuomo Soini <tis@foobar.fi>
+ * Copyright (C) 2010 Avesh Agarwal <avagarwa@redhat.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -890,14 +893,14 @@ raw_eroute(const ip_address *this_host
            , const char *opname USED_BY_DEBUG)
 {
     char text_said[SATOT_BUF];
-    int sport = ntohs(portof(&this_client->addr));
-    int dport = ntohs(portof(&that_client->addr));
     bool result;
 
     set_text_said(text_said, that_host, spi, proto);
 
     DBG(DBG_CONTROL | DBG_KLIPS,
         {
+            int sport = ntohs(portof(&this_client->addr));
+            int dport = ntohs(portof(&that_client->addr));
             char mybuf[SUBNETTOT_BUF];
             char peerbuf[SUBNETTOT_BUF];
 
@@ -2577,10 +2580,10 @@ route_and_eroute(struct connection *c USED_BY_KLIPS
         }
         else
         {
-            char cib[CONN_INST_BUF];
             sr->routing = RT_ROUTED_TUNNEL;
 
             DBG(DBG_CONTROL,
+                char cib[CONN_INST_BUF];
                 DBG_log("route_and_eroute: instance \"%s\"%s, setting eroute_owner {spd=%p,sr=%p} to #%ld (was #%ld) (newest_ipsec_sa=#%ld)"
                         , st->st_connection->name
                         , (fmt_conn_instance(st->st_connection, cib), cib)
diff --git a/programs/pluto/kernel_netlink.c b/programs/pluto/kernel_netlink.c
index 9269cb7ec..0c841c6a4 100644
--- a/programs/pluto/kernel_netlink.c
+++ b/programs/pluto/kernel_netlink.c
@@ -1,6 +1,6 @@
 /* netlink interface to the kernel's IPsec mechanism
  *
- * Copyright (C) 2003,2008 Herbert Xu.
+ * Copyright (C) 2003-2008 Herbert Xu
  * Copyright (C) 2006-2008 Michael Richardson <mcr@xelerance.com>
  * Copyright (C) 2006 Ken Bantoft <ken@xelerance.com>
  * Copyright (C) 2007 Bart Trojanowski <bart@jukie.net>
@@ -8,10 +8,12 @@
  * Copyright (C) 2009 Carsten Schlote <c.schlote@konzeptpark.de>
  * Copyright (C) 2008 Andreas Steffen
  * Copyright (C) 2008 Neil Horman <nhorman@redhat.com>
- * Copyright (C) 2008-2009 David McCullough <david_mccullough@securecomputing.com>
- * Copyright (C) 2006-2009 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2008-2010 David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2006-2010 Paul Wouters <paul@xelerance.com>
  * Copyright (C) 2010 Tuomo Soini <tis@foobar.fi>
  * Copyright (C) 2010 Mika Ilmaranta <ilmis@foobar.fi>
+ * Copyright (C) 2010 Roman Hoog Antink <rha@open.ch>
+ * Copyright (C) 2010 D. Hugh Redelmeier
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -1457,7 +1459,7 @@ netlink_sag_eroute(struct state *st, struct spd_route *sr
     }
 
     /* check for no transform at all */
-    passert(i == sizeof(proto_info) / sizeof(proto_info[0]) - 1)
+    passert(i == sizeof(proto_info) / sizeof(proto_info[0]) - 1);
 
     if (tunnel)
     {
diff --git a/programs/pluto/kernel_pfkey.c b/programs/pluto/kernel_pfkey.c
index 26c602500..13586ac67 100644
--- a/programs/pluto/kernel_pfkey.c
+++ b/programs/pluto/kernel_pfkey.c
@@ -2,11 +2,14 @@
  * common routines for interfaces that use pfkey to talk to kernel
  *
  * Copyright (C) 1997 Angelos D. Keromytis.
- * Copyright (C) 1998-2002  D. Hugh Redelmeier.
+ * Copyright (C) 1998-2010  D. Hugh Redelmeier.
  * Copyright (C) 2003 Herbert Xu.
- * Copyright (C) 2006 Bart Trojanowski <bart@jukie.net>
+ * Copyright (C) 2006-2010 Bart Trojanowski <bart@jukie.net>
  * Copyright (C) 2003-2007  Michael Richardson <mcr@xelerance.com>
- * Copyright (C) 2007-2008  Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2007-2010  Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2009-2010 David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2010 Henry N <henrynmail-oswan@yahoo.de>
+ * Copyright (C) 2010 Ajay.V.Sarraju
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -1639,8 +1642,6 @@ scan_proc_shunts(void)
                 if (bare_shunt_ptr(&eri.ours, &eri.his, eri.transport_proto) == NULL
                 && shunt_owner(&eri.ours, &eri.his) == NULL)
                 {
-                    int ourport = ntohs(portof(&eri.ours.addr));
-                    int hisport = ntohs(portof(&eri.his.addr));
                     char ourst[SUBNETTOT_BUF];
                     char hist[SUBNETTOT_BUF];
                     char sat[SATOT_BUF];
@@ -1650,6 +1651,8 @@ scan_proc_shunts(void)
                     satot(&eri.said, 0, sat, sizeof(sat));
 
                     DBG(DBG_CONTROL,
+                        int ourport = ntohs(portof(&eri.ours.addr));
+                        int hisport = ntohs(portof(&eri.his.addr));
                         DBG_log("add orphaned shunt %s:%d -> %s:%d => %s:%d"
                             , ourst, ourport, hist, hisport, sat, eri.transport_proto)
                      )
@@ -1818,11 +1821,13 @@ void pfkey_set_debug(int cur_debug
 		     , openswan_keying_debug_func_t debug_func
 		     , openswan_keying_debug_func_t error_func)
 {
+#ifdef DEBUG
     pfkey_lib_debug = (cur_debug&DBG_PFKEY ?
 		       PF_KEY_DEBUG_PARSE_MAX : PF_KEY_DEBUG_PARSE_NONE);
     
     pfkey_debug_func = debug_func;
     pfkey_error_func = error_func;
+#endif
 }
 
 void pfkey_remove_orphaned_holds(int transport_proto
diff --git a/programs/pluto/keys.c b/programs/pluto/keys.c
index de09809da..70818361a 100644
--- a/programs/pluto/keys.c
+++ b/programs/pluto/keys.c
@@ -4,9 +4,10 @@
  *
  * Copyright (C) 1998-2001  D. Hugh Redelmeier.
  * Copyright (C) 2003-2008  Michael Richardson <mcr@xelerance.com>
- * Copyright (C) 2003-2009 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2003-2010 Paul Wouters <paul@xelerance.com>
  * Copyright (C) 2008 David McCullough <david_mccullough@securecomputing.com>
  * Copyright (C) 2009 Avesh Agarwal <avagarwa@redhat.com>
+ * Copyright (C) 2010 Tuomo Soini <tis@foobar.fi>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -485,9 +486,9 @@ RSA_check_signature_gen(struct state *st
 	pathlen = pathlen;      /* make sure it used even with !X509 */
 
 	{
-	  char buf[IDTOA_BUF];
 	  
 	  DBG(DBG_CONTROL,
+	      char buf[IDTOA_BUF];
 	      dntoa_or_null(buf, IDTOA_BUF, c->spd.that.ca, "%any");
 	      DBG_log("required CA is '%s'", buf));
 	}
@@ -502,13 +503,10 @@ RSA_check_signature_gen(struct state *st
 	    {
 		time_t tnow;
 
-		{
-		  char buf[IDTOA_BUF];
-		  
-		  DBG(DBG_CONTROL,
-		      dntoa_or_null(buf, IDTOA_BUF, key->issuer, "%any");
-		      DBG_log("key issuer CA is '%s'", buf));
-		}
+		DBG(DBG_CONTROL,
+		    char buf[IDTOA_BUF];
+		    dntoa_or_null(buf, IDTOA_BUF, key->issuer, "%any");
+		    DBG_log("key issuer CA is '%s'", buf));
 
 		/* check if found public key has expired */
 		time(&tnow);
diff --git a/programs/pluto/nat_traversal.c b/programs/pluto/nat_traversal.c
index 0002782e9..eafe94f52 100644
--- a/programs/pluto/nat_traversal.c
+++ b/programs/pluto/nat_traversal.c
@@ -1,5 +1,12 @@
 /* Openswan NAT-Traversal
  * Copyright (C) 2002-2003 Mathieu Lafon - Arkoon Network Security
+ * Copyright (C) 2005-2007 Michael Richardson <mcr@xelerance.com>
+ * Copyright (C) 2005 Ken Bantoft <ken@xelerance.com>
+ * Copyright (C) 2006 Bart Trojanowski <bart@jukie.net>
+ * Copyright (C) 2007-2010 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2009 Tuomo Soini <tis@foobar.fi>
+ * Copyright (C) 2009 Gilles Espinasse <g.esp@free.fr>
+ * Copyright (C) 2009 David McCullough <david_mccullough@securecomputing.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -990,14 +997,16 @@ void nat_traversal_change_port_lookup(struct msg_digest *md, struct state *st)
 	      && st->st_localport == st->st_interface->port))
 	    
 	{
-	    char b1[ADDRTOT_BUF], b2[ADDRTOT_BUF];
 
 	    DBG(DBG_NATT,
+	        char b1[ADDRTOT_BUF];
+	        char b2[ADDRTOT_BUF];
 		DBG_log("NAT-T connection has wrong interface definition %s:%u vs %s:%u"
 			, (addrtot(&st->st_localaddr, 0, b1, sizeof(b1)),b1)
 			, st->st_localport
 			, (addrtot(&st->st_interface->ip_addr, 0, b2, sizeof(b2)),b2)
-			, st->st_interface->port));
+			, st->st_interface->port)
+	    );
 
 	    for (i = interfaces; i !=  NULL; i = i->next) {
 		if ((sameaddr(&st->st_localaddr, &i->ip_addr))
@@ -1059,10 +1068,6 @@ void process_pfkey_nat_t_new_mapping(
 		ugh = "only AF_INET supported";
 	}
 	else {
-		char text_said[SATOT_BUF];
-		char _srca[ADDRTOT_BUF], _dsta[ADDRTOT_BUF];
-		ip_said said;
-
 		initaddr((const void *) &((const struct sockaddr_in *)srca)->sin_addr,
 			sizeof(((const struct sockaddr_in *)srca)->sin_addr),
 			srca->sa_family, &(nfo.src));
@@ -1073,6 +1078,11 @@ void process_pfkey_nat_t_new_mapping(
 		nfo.dport = ntohs(((const struct sockaddr_in *)dsta)->sin_port);
 
 		DBG(DBG_NATT,
+			char text_said[SATOT_BUF];
+			char _srca[ADDRTOT_BUF];
+			char _dsta[ADDRTOT_BUF];
+			ip_said said;
+
 			initsaid(&nfo.src, nfo.sa->sadb_sa_spi, SA_ESP, &said);
 			satot(&said, 0, text_said, SATOT_BUF);
 			addrtot(&nfo.src, 0, _srca, ADDRTOT_BUF);
diff --git a/programs/pluto/ocsp.c b/programs/pluto/ocsp.c
index 994fac205..fa970923e 100644
--- a/programs/pluto/ocsp.c
+++ b/programs/pluto/ocsp.c
@@ -2,6 +2,10 @@
  *
  * Copyright (C) 2003 Christoph Gysin, Simon Zwahlen
  *                    Zuercher Hochschule Winterthur
+ * Copyright (C) 2007-2010 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2005-2006 Michael Richardson <mcr@xelerance.com>
+ * Copyright (C) 2010 D. Hugh Redelmeier <hugh@mimosa.com>
+ * Copyright (C) 2010 Harald Jenny <harald@a-little-linux-box.at>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -12,7 +16,6 @@
  * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  * for more details.
- *
  */
 
 #include <unistd.h>
@@ -480,17 +483,18 @@ check_ocsp(void)
     
     while (location != NULL)
     {
-	char buf[BUF_LEN];
+#ifdef DEBUG
 	bool first = TRUE;
+#endif
 	ocsp_certinfo_t *certinfo = location->certinfo;
 
 	while (certinfo != NULL)
 	{
 	    if (!certinfo->once)
 	    {
-		time_t time_left = certinfo->nextUpdate - time(NULL);
-
 		DBG(DBG_CONTROL,
+		    time_t time_left = certinfo->nextUpdate - time(NULL);
+		    char buf[BUF_LEN];
 		    if (first)
 		    {
 			dntoa(buf, BUF_LEN, location->issuer);
@@ -737,7 +741,6 @@ get_ocsp_requestor_cert(ocsp_location_t *location)
 
     for (;;)
     {
-	char buf[BUF_LEN];
 
 	/* looking for a certificate from the same issuer */
 	cert = get_x509cert(location->issuer, location->authKeySerialNumber
@@ -746,6 +749,7 @@ get_ocsp_requestor_cert(ocsp_location_t *location)
 	    break;
 
 	DBG(DBG_CONTROL,
+	    char buf[BUF_LEN];
 	    dntoa(buf, BUF_LEN, cert->subject);
 	    DBG_log("candidate: '%s'", buf);
 	)
@@ -1059,10 +1063,10 @@ build_ocsp_request(ocsp_location_t *location)
 {
     bool has_requestor_cert;
     chunk_t request, tbsRequest, signature;
-    char buf[BUF_LEN];
     u_char *pos;
 
     DBG(DBG_CONTROL,
+        char buf[BUF_LEN];
 	DBG_log("assembling ocsp request");
 	dntoa(buf, BUF_LEN, location->issuer);
 	DBG_log("issuer: '%s'", buf);
@@ -1134,13 +1138,13 @@ valid_ocsp_response(response_t *res)
 
     for (pathlen = 0; pathlen < MAX_CA_PATH_LEN; pathlen++)
     {
-	char buf[BUF_LEN];
 	err_t ugh = NULL;
 	time_t until;
 
 	x509cert_t *cert = authcert;
 
 	DBG(DBG_CONTROL,
+	    char buf[BUF_LEN];
 	    dntoa(buf, BUF_LEN, cert->subject);
 	    DBG_log("subject: '%s'",buf);
 	    dntoa(buf, BUF_LEN, cert->issuer);
@@ -1213,7 +1217,6 @@ static bool
 parse_basic_ocsp_response(chunk_t blob, int level0, response_t *res)
 {
     u_int level, version, extn_oid = 0;
-    char buf[BUF_LEN];
     asn1_ctx_t ctx;
     bool critical;
     chunk_t object;
@@ -1242,6 +1245,7 @@ parse_basic_ocsp_response(chunk_t blob, int level0, response_t *res)
 	case BASIC_RESPONSE_ID_BY_NAME:
 	    res->responder_id_name = object;
 	    DBG(DBG_PARSING,
+		char buf[BUF_LEN];
 		dntoa(buf, BUF_LEN, object);
 		DBG_log("  '%s'",buf)
 	    )
@@ -1497,7 +1501,6 @@ add_certinfo(ocsp_location_t *loc, ocsp_certinfo_t *info, ocsp_location_t **chai
 {
     ocsp_location_t *location;
     ocsp_certinfo_t *certinfo, **certinfop;
-    char buf[BUF_LEN];
     time_t tnow;
     int cmp = -1;
 
@@ -1530,6 +1533,7 @@ add_certinfo(ocsp_location_t *loc, ocsp_certinfo_t *info, ocsp_location_t **chai
     }
 	
     DBG(DBG_CONTROL,
+	char buf[BUF_LEN];
 	datatot(info->serialNumber.ptr, info->serialNumber.len, ':'
 	    , buf, BUF_LEN);
 	DBG_log("ocsp %s for serial %s %s"
diff --git a/programs/pluto/pluto_crypt.c b/programs/pluto/pluto_crypt.c
index c1b0eb096..4a17920e6 100644
--- a/programs/pluto/pluto_crypt.c
+++ b/programs/pluto/pluto_crypt.c
@@ -1,11 +1,13 @@
 /* 
  * Cryptographic helper function.
  * Copyright (C) 2004-2007 Michael C. Richardson <mcr@xelerance.com>
- * Copyright (C) 2004-2009 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2004-2010 Paul Wouters <paul@xelerance.com>
  * Copyright (C) 2006 Luis F. Ortiz <lfo@polyad.org>
  * Copyright (C) 2008-2009 David McCullough <david_mccullough@securecomputing.com>
  * Copyright (C) 2008 Anthony Tong <atong@TrustedCS.com>
  * Copyright (C) 2009 Avesh Agarwal <avagarwa@redhat.com>
+ * Copyright (C) 2009 Stefan Arentz <stefan@arentz.ca>
+ * Copyright (C) 2010 Tuomo Soini <tis@foobar.fi>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -944,8 +946,10 @@ static void init_crypto_helper(struct pluto_crypto_worker *w, int n)
 	init_rnd_pool();
 	load_oswcrypto();
 	free_preshared_secrets();
+#ifdef DEBUG
 	openswan_passert_fail = helper_passert_fail;
 	debug_prefix='!';
+#endif
 
 	pluto_crypto_helper(fds[1], n);
 
diff --git a/programs/pluto/plutomain.c b/programs/pluto/plutomain.c
index 13d35654e..0f53eae1f 100644
--- a/programs/pluto/plutomain.c
+++ b/programs/pluto/plutomain.c
@@ -2,10 +2,11 @@
  * Copyright (C) 1997      Angelos D. Keromytis.
  * Copyright (C) 1998-2001 D. Hugh Redelmeier.
  * Copyright (C) 2003-2008 Michael C Richardson <mcr@xelerance.com> 
- * Copyright (C) 2003-2009 Paul Wouters <paul@xelerance.com> 
+ * Copyright (C) 2003-2010 Paul Wouters <paul@xelerance.com> 
  * Copyright (C) 2007 Ken Bantoft <ken@xelerance.com>
  * Copyright (C) 2008-2009 David McCullough <david_mccullough@securecomputing.com>
  * Copyright (C) 2009 Avesh Agarwal <avagarwa@redhat.com>
+ * Copyright (C) 2009-2010 Tuomo Soini <tis@foobar.fi>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -111,7 +112,9 @@
 
 const char *ctlbase = "/var/run/pluto";
 
+#ifdef DEBUG
 openswan_passert_fail_t openswan_passert_fail = passert_fail;
+#endif
 
 /** usage - print help messages
  *
@@ -333,7 +336,9 @@ main(int argc, char **argv)
 
     global_argv = argv;
     global_argc = argc;
+#ifdef DEBUG
     openswan_passert_fail = passert_fail;
+#endif
 
     /* see if there is an environment variable */
     coredir = getenv("PLUTO_CORE_DIR");
@@ -639,9 +644,11 @@ main(int argc, char **argv)
 	case '4':	/* --disable_port_floating */
 	    nat_t_spf = FALSE;
 	    continue;
+#ifdef DEBUG
 	case '5':	/* --debug-nat_t */
 	    base_debugging |= DBG_NATT;
 	    continue;
+#endif
 #endif
 	case '6':	/* --virtual_private */
 	    virtual_private = optarg;
diff --git a/programs/pluto/server.c b/programs/pluto/server.c
index 6e44d5927..58030ee9a 100644
--- a/programs/pluto/server.c
+++ b/programs/pluto/server.c
@@ -2,9 +2,10 @@
  * Copyright (C) 1997 Angelos D. Keromytis.
  * Copyright (C) 1998-2002  D. Hugh Redelmeier.
  * Copyright (C) 2003-2008 Michael C Richardson <mcr@xelerance.com> 
- * Copyright (C) 2003-2009 Paul Wouters <paul@xelerance.com> 
+ * Copyright (C) 2003-2010 Paul Wouters <paul@xelerance.com> 
  * Copyright (C) 2008-2009 David McCullough <david_mccullough@securecomputing.com>
  * Copyright (C) 2009 Avesh Agarwal <avagarwa@redhat.com>
+ * Copyright (C) 2010 Tuomo Soini <tis@foobar.fi>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -1094,7 +1095,6 @@ check_msg_errqueue(const struct iface_port *ifp, short interest)
 bool
 send_packet(struct state *st, const char *where, bool verbose)
 {
-    bool err;
     u_int8_t ike_pkt[MAX_OUTPUT_UDP_SIZE];
     u_int8_t *ptr;
     unsigned long len;
@@ -1136,15 +1136,6 @@ send_packet(struct state *st, const char *where, bool verbose)
     (void) check_msg_errqueue(st->st_interface, POLLOUT);
 #endif /* defined(IP_RECVERR) && defined(MSG_ERRQUEUE) */
 
-#if 0
-    wlen = sendfromto(st->st_interface->fd
-		      , ptr
-		      , len, 0
-		      , sockaddrof(&st->st_remoteaddr)
-		      , sockaddrlenof(&st->st_remoteaddr)
-		      , sockaddrof(&st->st_localaddr)
-		      , sockaddrlenof(&st->st_localaddr));
-#else
     wlen = sendto(st->st_interface->fd
 		  , ptr
 		  , len, 0
@@ -1152,6 +1143,9 @@ send_packet(struct state *st, const char *where, bool verbose)
 		  , sockaddrlenof(&st->st_remoteaddr));
 
 #ifdef DEBUG
+    /* XXX This is a flow change depending on debug. not good. I assume it is only useful
+     * for actual debugging something 
+     */
     if(DBGP(IMPAIR_JACOB_TWO_TWO)) {
 	/* sleep for half a second, and second another packet */
 	usleep(500000);
@@ -1163,7 +1157,6 @@ send_packet(struct state *st, const char *where, bool verbose)
 		, st->st_interface->port
 		, ip_str(&st->st_remoteaddr)
 		, st->st_remoteport);
-#endif
 
 	wlen = sendto(st->st_interface->fd
 		      , ptr
@@ -1171,12 +1164,9 @@ send_packet(struct state *st, const char *where, bool verbose)
 		      , sockaddrof(&st->st_remoteaddr)
 		      , sockaddrlenof(&st->st_remoteaddr));
     }
-
-	
 #endif
-    err = (wlen != (ssize_t)len);
 
-    if (err)
+    if (wlen != (ssize_t)len)
     {
         /* do not log NAT-T Keep Alive packets */
         if (!verbose)
diff --git a/programs/pluto/timer.c b/programs/pluto/timer.c
index 438a4603b..aa6d63a29 100644
--- a/programs/pluto/timer.c
+++ b/programs/pluto/timer.c
@@ -1,6 +1,10 @@
 /* timer event handling
  * Copyright (C) 1997 Angelos D. Keromytis.
  * Copyright (C) 1998-2001  D. Hugh Redelmeier.
+ * Copyright (C) 2005-2008 Michael Richardson <mcr@xelerance.com>
+ * Copyright (C) 2008-2010 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2009 David McCullough <david_mccullough@securecomputing.com>
+ *
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -155,7 +159,6 @@ retransmit_v1_msg(struct state *st)
 {
     time_t delay = 0;
     struct connection *c;
-    ip_address peer;
     unsigned long try;
     unsigned long try_limit;
 	
@@ -165,8 +168,9 @@ retransmit_v1_msg(struct state *st)
     try       = st->st_try;
     try_limit = c->sa_keying_tries;
 	
-    DBG(DBG_CONTROL, DBG_log(
-	    "handling event EVENT_RETRANSMIT for %s \"%s\" #%lu"
+    DBG(DBG_CONTROL, 
+	    ip_address peer;
+	    DBG_log("handling event EVENT_RETRANSMIT for %s \"%s\" #%lu"
 	    , ip_str(&peer), c->name, st->st_serialno));
     
     if (st->st_retransmit < maximum_retransmissions)
@@ -270,7 +274,6 @@ retransmit_v2_msg(struct state *st)
 {
     time_t delay = 0;
     struct connection *c;
-    ip_address peer;
     unsigned long try;
     unsigned long try_limit;
     const char *details = "";
@@ -281,8 +284,9 @@ retransmit_v2_msg(struct state *st)
     try = st->st_try;
     try++;
     
-    DBG(DBG_CONTROL, DBG_log(
-	    "handling event EVENT_RETRANSMIT for %s \"%s\" #%lu"
+    DBG(DBG_CONTROL, 
+	ip_address peer;
+	DBG_log("handling event EVENT_RETRANSMIT for %s \"%s\" #%lu"
 	    , ip_str(&peer), c->name, st->st_serialno));
     
     if (st->st_retransmit < maximum_retransmissions)
diff --git a/programs/pluto/x509.c b/programs/pluto/x509.c
index 481199a6e..65a866c42 100644
--- a/programs/pluto/x509.c
+++ b/programs/pluto/x509.c
@@ -3,6 +3,9 @@
  * Copyright (C) 2001 Marco Bertossa, Andreas Schleiss
  * Copyright (C) 2002 Mario Strasser
  * Copyright (C) 2000-2004 Andreas Steffen, Zuercher Hochschule Winterthur
+ * Copyright (C) 2006-2010 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2008-2009 David McCullough <david_mccullough@securecomputing.com>
+ * Copyright (C) 2009 Gilles Espinasse <g.esp@free.fr>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -611,7 +614,6 @@ verify_x509cert(/*const*/ x509cert_t *cert, bool strict, time_t *until)
 	x509cert_t *issuer_cert;
 	char sbuf[ASN1_BUF_LEN];
 	char ibuf[ASN1_BUF_LEN];
-	char abuf[ASN1_BUF_LEN];
 
 	err_t ugh = NULL;
 
@@ -623,6 +625,7 @@ verify_x509cert(/*const*/ x509cert_t *cert, bool strict, time_t *until)
 	    DBG_log("issuer:  '%s'", ibuf);
 	    if (cert->authKeyID.ptr != NULL)
 	    {
+		char abuf[ASN1_BUF_LEN];
 		datatot(cert->authKeyID.ptr, cert->authKeyID.len, ':'
 			, abuf, ASN1_BUF_LEN);
 		DBG_log("authkey:  %s", abuf);
diff --git a/programs/pluto/x509keys.c b/programs/pluto/x509keys.c
index e827ab54a..89eb1fa46 100644
--- a/programs/pluto/x509keys.c
+++ b/programs/pluto/x509keys.c
@@ -3,7 +3,10 @@
  * Copyright (C) 2001 Marco Bertossa, Andreas Schleiss
  * Copyright (C) 2002 Mario Strasser
  * Copyright (C) 2000-2004 Andreas Steffen, Zuercher Hochschule Winterthur
- * Copyright (C) 2004 Michael Richardson <mcr@xelerance.com>
+ * Copyright (C) 2004-2007 Michael Richardson <mcr@xelerance.com>
+ * Copyright (C) 2006 Matthias Haas" <mh@pompase.net>
+ * Copyright (C) 2007-2010 Paul Wouters <paul@xelerance.com>
+ * Copyright (C) 2008 Antony Antony <antony@xelerance.com>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -15,7 +18,6 @@
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  * for more details.
  *
- * RCSID $Id: x509keys.c,v 1.6 2005/08/05 19:18:47 mcr Exp $
  */
 
 #include <stdlib.h>
@@ -280,7 +282,6 @@ decode_cr(struct msg_digest *md, generalName_t **requested_ca)
 
 	if (cr->isacr_type == CERT_X509_SIGNATURE)
 	{
-	    char buf[IDTOA_BUF];
 
 	    if (ca_name.len > 0)
 	    {
@@ -298,6 +299,7 @@ decode_cr(struct msg_digest *md, generalName_t **requested_ca)
 	    }
 
 	    DBG(DBG_PARSING | DBG_CONTROL,
+		char buf[IDTOA_BUF];
 		dntoa_or_null(buf, IDTOA_BUF, ca_name, "%any");
 		DBG_log("requested CA: '%s'", buf);
 	    )
@@ -328,7 +330,6 @@ ikev2_decode_cr(struct msg_digest *md, generalName_t **requested_ca)
 
 	if (cr->isacertreq_enc == CERT_X509_SIGNATURE)
 	{
-	    char buf[IDTOA_BUF];
 
 	    if (ca_name.len > 0)
 	    {
@@ -346,6 +347,7 @@ ikev2_decode_cr(struct msg_digest *md, generalName_t **requested_ca)
 	    }
 
 	    DBG(DBG_PARSING | DBG_CONTROL,
+		char buf[IDTOA_BUF];
 		dntoa_or_null(buf, IDTOA_BUF, ca_name, "%any");
 		DBG_log("requested CA: '%s'", buf);
 	    )
diff --git a/programs/showhostkey/showhostkey.c b/programs/showhostkey/showhostkey.c
index 18800b205..73a0fabe8 100644
--- a/programs/showhostkey/showhostkey.c
+++ b/programs/showhostkey/showhostkey.c
@@ -5,6 +5,8 @@
  * Copyright (C) 2003-2008 Michael C Richardson <mcr@xelerance.com> 
  * Copyright (C) 2003-2010 Paul Wouters <paul@xelerance.com> 
  * Copyright (C) 2009 Avesh Agarwal <avagarwa@redhat.com>
+ * Copyright (C) 2009 Stefan Arentz <stefan@arentz.ca>
+ * Copyright (C) 2010 Tuomo Soini <tis@foobar.fi>
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -476,7 +478,11 @@ int main(int argc, char *argv[])
     }
 
     if(verbose > 2) {
+#ifdef DEBUG
 	set_debugging(DBG_ALL);
+#else
+	fprintf(stderr, "verbosity cannot be set - compiled without DEBUG\n");
+#endif
     }
 
     /* now load file from indicated location */
diff --git a/programs/spi/spi.c b/programs/spi/spi.c
index e5648888c..7e619681b 100644
--- a/programs/spi/spi.c
+++ b/programs/spi/spi.c
@@ -2,6 +2,8 @@
  * All-in-one program to set Security Association parameters
  * Copyright (C) 1996  John Ioannidis.
  * Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002  Richard Guy Briggs.
+ * Copyright (C) 2005-2007 Michael Richardson <mcr@xelerance.com>
+ * Copyright (C) 2007-2010 Paul Wouters <paul@xelerance.com>
  * 
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -547,10 +549,14 @@ main(int argc, char *argv[])
 	while((c = getopt_long(argc, argv, ""/*"H:P:Z:46dcA:E:e:s:a:w:i:D:S:hvgl:+:f:"*/, longopts, 0)) != EOF) {
 		switch(c) {
 		case 'g':
+#ifdef DEBUG
 			debug = 1;
 			pfkey_lib_debug = PF_KEY_DEBUG_PARSE_MAX;
 			cur_debugging = 0xffffffff;
 			argcount--;
+#else
+			fprintf(stderr, "%s: Cannot set debug - compiled without DEBUG\n", progname);
+#endif
 			break;
 
 		case 'R':

