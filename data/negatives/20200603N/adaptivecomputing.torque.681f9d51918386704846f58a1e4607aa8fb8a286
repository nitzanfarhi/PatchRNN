commit 681f9d51918386704846f58a1e4607aa8fb8a286
Author: knielson <knielson@adaptivecomputing.com>
Date:   Thu Aug 13 17:55:28 2015 -0600

    TRQ-3261 using place=socket or place=numanode with more than one task only returns stats for the first task
    
    The real bug for this is that we did not return an
    error when the spec was larger than the available
    hardware. We now return an error if the request
    does not fit.
    
    Also fixed several unit tests plus a bug
    in overwrite_complete_req.

diff --git a/src/include/complete_req.hpp b/src/include/complete_req.hpp
index dcfa0f9e6..4639c43f1 100644
--- a/src/include/complete_req.hpp
+++ b/src/include/complete_req.hpp
@@ -115,6 +115,7 @@ class complete_req
     int            set_task_memory_used(int req_index, int task_index, const unsigned long long mem_used);
     int            set_task_cput_used(int req_index, int task_index, const unsigned long cput_used);
     void           clear_allocations();
+    void           clear_reqs();
     int            get_task_stats(unsigned int &req_index, std::vector<int> &task_index,
                                   std::vector<unsigned long> &cput_used,
                                   std::vector<unsigned long long> &mem_used);
diff --git a/src/lib/Libattr/attr_fn_complete_req.c b/src/lib/Libattr/attr_fn_complete_req.c
index c978125e3..34dc7e661 100644
--- a/src/lib/Libattr/attr_fn_complete_req.c
+++ b/src/lib/Libattr/attr_fn_complete_req.c
@@ -280,7 +280,10 @@ void overwrite_complete_req(
     attr->at_val.at_ptr = cr;
     }
   else
+    {
     cr = (complete_req *)attr->at_val.at_ptr;
+    cr->clear_reqs();
+    }
 
 
   std::vector<std::string> names;
diff --git a/src/lib/Libattr/complete_req.cpp b/src/lib/Libattr/complete_req.cpp
index bb50309a8..488e1a8a9 100644
--- a/src/lib/Libattr/complete_req.cpp
+++ b/src/lib/Libattr/complete_req.cpp
@@ -652,6 +652,11 @@ void complete_req::clear_allocations()
   } // END clear_allocations()
 
 
+void complete_req::clear_reqs()
+
+  {
+  this->reqs.clear();
+  }
 
 int complete_req::get_task_stats(
 
diff --git a/src/lib/Libutils/machine.cpp b/src/lib/Libutils/machine.cpp
index 52c806bdb..e3739799d 100644
--- a/src/lib/Libutils/machine.cpp
+++ b/src/lib/Libutils/machine.cpp
@@ -636,7 +636,10 @@ int Machine::spread_place(
     master.add_allocation(task_alloc);
     }
 
-  return(tasks_placed);
+  if (tasks_placed != tasks_for_node)
+    return(PBSE_IVALREQ);
+
+  return(PBSE_NONE);
   } // END spread_place()
 
 
@@ -688,7 +691,11 @@ int Machine::place_job(
     if ((r.get_sockets() > 0) ||
         (r.get_numa_nodes() > 0))
       {
-      spread_place(r, a, tasks_for_node, hostname);
+      int rc;
+
+      rc = spread_place(r, a, tasks_for_node, hostname);
+      if (rc != PBSE_NONE)
+        return(rc);
       }
     else if (r.get_execution_slots() == ALL_EXECUTION_SLOTS)
       {
diff --git a/src/resmom/linux/test/node_internals/scaffolding.c b/src/resmom/linux/test/node_internals/scaffolding.c
index ad194be22..5fb72d98c 100644
--- a/src/resmom/linux/test/node_internals/scaffolding.c
+++ b/src/resmom/linux/test/node_internals/scaffolding.c
@@ -54,7 +54,7 @@ allocation::allocation(
   const allocation &alloc) : cpu_indices(alloc.cpu_indices), memory(alloc.memory), cpus(alloc.cpus)
 
   {
-  strcpy(this->jobid, alloc.jobid);
+  this->jobid = alloc.jobid;
   }
 
 allocation::allocation() : cpu_indices(), memory(0), cpus(0)
diff --git a/src/resmom/linux/test/numa_node/scaffolding.c b/src/resmom/linux/test/numa_node/scaffolding.c
index 58894e3ad..8baf0191d 100644
--- a/src/resmom/linux/test/numa_node/scaffolding.c
+++ b/src/resmom/linux/test/numa_node/scaffolding.c
@@ -8,13 +8,13 @@
 int MOMConfigUseSMT;
 char cpulist[1024];
 
-const char *use_cores = "usecores";
+/*const char *use_cores = "usecores";
 
 const char *place_node = "node";
 const char *place_socket = "socket";
 const char *place_numa_node = "numanode";
 const char *place_core = "core";
-const char *place_thread = "thread";
+const char *place_thread = "thread";*/
 
 proc_mem_t *get_proc_mem_from_path(const char *path)
   {
@@ -50,28 +50,79 @@ int is_whitespace(
     return(FALSE);
   } /* END is_whitespace */
 
-int req::getExecutionSlots() const
-  {
-  return(0);
-  }
+void log_err(int num, char const *a, char const *b) {}
 
-unsigned long req::getMemory() const
-  {
-  return(0);
-  }
+char *threadsafe_tokenizer(
+
+  char       **str,    /* M */
+  const char  *delims) /* I */
 
-std::string req::getThreadUsageString() const
   {
-  return("");
-  }
+  char *current_char;
+  char *start;
+
+  if ((str == NULL) ||
+      (*str == NULL))
+    return(NULL);
+
+  /* save start position */
+  start = *str;
+
+  /* return NULL at the end of the string */
+  if (*start == '\0')
+    return(NULL);
+
+  /* begin at the start */
+  current_char = start;
+
+  /* advance to the end of the string or until you find a delimiter */
+  while ((*current_char != '\0') &&
+         (!strchr(delims, *current_char)))
+    current_char++;
+
+  /* advance str */
+  if (*current_char != '\0')
+    {
+    /* not at the end of the string */
+    *str = current_char + 1;
+    *current_char = '\0';
+    }
+  else
+    {
+    /* at the end of the string */
+    *str = current_char;
+    }
+
+  return(start);
+  } /* END threadsafe_tokenizer() */
+
+
+
+char *pbse_to_txt(
+
+  int err)  /* I */
 
-int req::getMics() const
   {
-  return(0);
-  }
+  return (char*)0;
+  }  /* END pbse_to_txt() */
+
+
+void move_past_whitespace(
+
+  char **str)
 
-int req::getGpus() const
   {
-  return(0);
-  }
+  if ((str == NULL) ||
+      (*str == NULL))
+    return;
+
+  char *current = *str;
+
+  while (is_whitespace(*current) == TRUE)
+    current++;
+
+  *str = current;
+  } // END move_past_whitespace()
+
 
+#include "../../../src/lib/Libattr/req.cpp"
diff --git a/src/resmom/linux/test/numa_node/test_numa_node.c b/src/resmom/linux/test/numa_node/test_numa_node.c
index 639b15a86..8aa856d76 100644
--- a/src/resmom/linux/test/numa_node/test_numa_node.c
+++ b/src/resmom/linux/test/numa_node/test_numa_node.c
@@ -44,7 +44,7 @@ START_TEST(test_recover_reservation)
   fail_unless(a2.memory == 0);
 
   allocation a3("3.napali");
-  fail_unless(!strcmp(a3.jobid, "3.napali"));
+  fail_unless(!strcmp(a3.jobid.c_str(), "3.napali"));
 
   }
 END_TEST
diff --git a/src/server/node_manager.c b/src/server/node_manager.c
index 14c6e1481..4ca1c0c19 100644
--- a/src/server/node_manager.c
+++ b/src/server/node_manager.c
@@ -4215,7 +4215,10 @@ int place_subnodes_in_hostlist(
     std::string       cpus;
     std::string       mems;
 
-    pnode->nd_layout->place_job(pjob, cpus, mems, pnode->nd_name);
+    rc = pnode->nd_layout->place_job(pjob, cpus, mems, pnode->nd_name);
+    if (rc != PBSE_NONE)
+      return(rc);
+
     save_cpus_and_memory_cpusets(pjob, pnode->nd_name, cpus, mems);
     save_node_usage(pnode);
 #endif
@@ -4575,8 +4578,11 @@ int build_hostlist_nodes_req(
         }
       else
         {
+        int rc = PBSE_NONE;
+
         job_reservation_info host_single;
-        if (place_subnodes_in_hostlist(pjob, pnode, current, host_single, ProcBMStr) == PBSE_NONE)
+        rc = place_subnodes_in_hostlist(pjob, pnode, current, host_single, ProcBMStr);
+        if (rc == PBSE_NONE)
           {
           host_info.push_back(host_single);
           place_gpus_in_hostlist(pnode, pjob, current, gpu_list);
diff --git a/src/test/attr_fn_complete_req/scaffolding.c b/src/test/attr_fn_complete_req/scaffolding.c
index 328c0cafa..4d7f2abb5 100644
--- a/src/test/attr_fn_complete_req/scaffolding.c
+++ b/src/test/attr_fn_complete_req/scaffolding.c
@@ -4,6 +4,7 @@
 
 #include "utils.h"
 #include "attribute.h"
+#include "complete_req.hpp"
 
 int         called_encode;
 
@@ -96,5 +97,54 @@ void *get_next(
   return(NULL);
   }
 
+void overwrite_complete_req(
 
+  pbs_attribute *attr,
+  pbs_attribute *new_attr)
+
+  {
+  complete_req *cr;
+  complete_req *to_copy = (complete_req *)new_attr->at_val.at_ptr;
+
+  if (attr->at_val.at_ptr == NULL)
+    {
+    cr = new complete_req();
+    attr->at_val.at_ptr = cr;
+    }
+  else
+    {
+    cr = (complete_req *)attr->at_val.at_ptr;
+    cr->clear_reqs();
+    }
+
+
+  std::vector<std::string> names;
+  std::vector<std::string> values;
+  to_copy->get_values(names, values);
+
+  for (unsigned int i = 0; i < names.size(); i++)
+  {
+  if (!strncmp("task_usage", names[i].c_str(), strlen("task_usage")))
+    {
+    cr->set_value(names[i].c_str(), values[i].c_str());
+    }
+  else
+    {
+    char  *attr_name = strdup(names[i].c_str());
+    char  *dot;
+
+    dot = strchr(attr_name, '.');
+    if (dot != NULL)
+      {
+      int index = strtol(dot + 1, NULL, 10);
+      *dot = '\0';
+      cr->set_value(index, attr_name, values[i].c_str());
+      }
+    }
+  }
+
+  attr->at_flags |= ATR_VFLAG_SET;
+  } // END overwrite_complete_req
+
+void log_err(int errnum, const char *routine, const char *text) {}
 
diff --git a/src/test/pbsd_init/scaffolding.c b/src/test/pbsd_init/scaffolding.c
index 97da2eb27..7c309a525 100644
--- a/src/test/pbsd_init/scaffolding.c
+++ b/src/test/pbsd_init/scaffolding.c
@@ -706,6 +706,44 @@ void translate_range_string_to_vector(
   return;
   }
 
+
+bool job_id_exists(
+
+  const std::string job_id_string)
+
+  {
+  return(true);
+  }
+
+/*
+ *  * capture_until_close_character()
+ *   */
+
+void capture_until_close_character(
+
+  char        **start,
+  std::string  &storage,
+  char          end)
+
+  {
+  if ((start == NULL) ||
+      (*start == NULL))
+    return;
+
+  char *val = *start;
+  char *ptr = strchr(val, end);
+
+  // Make sure we found a close quote and this wasn't an empty string
+  if ((ptr != NULL) &&
+      (ptr != val))
+    {
+    storage = val;
+    storage.erase(ptr - val);
+    *start = ptr + 1; // add 1 to move past the character
+    }
+  } // capture_until_close_character()
+  
+
 #include "../../lib/Libutils/machine.cpp"
 #include "../../lib/Libutils/numa_pci_device.cpp"
 #include "../../lib/Libutils/numa_socket.cpp"
diff --git a/src/test/receive_mom_communication/scaffolding.c b/src/test/receive_mom_communication/scaffolding.c
index 1d346ef1a..1bfe1094b 100644
--- a/src/test/receive_mom_communication/scaffolding.c
+++ b/src/test/receive_mom_communication/scaffolding.c
@@ -15,6 +15,7 @@
 #include "mom_hierarchy_handler.h"
 #include "id_map.hpp"
 #include "node_manager.h"
+#include "pbs_ifl.h"
 
 
 id_map      job_mapper;
@@ -40,6 +41,15 @@ const char *dis_emsg[] =
 
 threadpool_t *task_pool;
 
+#define ATTR_NODE_total_sockets        "total_sockets"
+#define ATTR_NODE_total_numa_nodes     "total_numa_nodes"
+#define ATTR_NODE_total_cores          "total_cores"
+#define ATTR_NODE_total_threads        "total_threads"
+#define ATTR_NODE_available_sockets    "available_sockets"
+#define ATTR_NODE_available_numa_nodes "available_numa_nodes"
+#define ATTR_NODE_available_cores      "available_cores"
+#define ATTR_NODE_available_threads    "available_threads"
+
 
 char * netaddr(struct sockaddr_in *ap)
   {
@@ -700,8 +710,196 @@ char *csv_find_string(
   return(NULL);
   }
 
+int process_alps_status(
+
+  const char               *nd_name,
+  std::vector<std::string> &status_info)
+
+  {
+  return(PBSE_NONE);
+  }
+
+int is_whitespace(
+
+  char c)
+
+  {
+  if ((c == ' ')  ||
+      (c == '\n') ||
+      (c == '\t') ||
+      (c == '\r') ||
+      (c == '\f'))
+    return(TRUE);
+  else
+    return(FALSE);
+  } /* END is_whitespace */
+
+
+void move_past_whitespace(
+
+  char **str)
+
+  {
+  if ((str == NULL) ||
+      (*str == NULL))
+    return;
+
+  char *current = *str;
+
+  while (is_whitespace(*current) == TRUE)
+    current++;
+
+  *str = current;
+  } // END move_past_whitespace()
+
+
+/*
+ *  * capture_until_close_character()
+ *   */
+
+void capture_until_close_character(
+
+  char        **start,
+  std::string  &storage,
+  char          end)
+
+  {
+  if ((start == NULL) ||
+      (*start == NULL))
+    return;
+
+  char *val = *start;
+  char *ptr = strchr(val, end);
+
+  // Make sure we found a close quote and this wasn't an empty string
+  if ((ptr != NULL) &&
+      (ptr != val))
+    {
+    storage = val;
+    storage.erase(ptr - val);
+    *start = ptr + 1; // add 1 to move past the character
+    }
+  } // capture_until_close_character()
+
+
+#define MAXLINE 1024
+
+void add_range_to_string(
+
+  std::string &range_string,
+  int          begin,
+  int          end)
+
+  {
+  char buf[MAXLINE];
+
+  if (begin == end)
+    {
+    if (range_string.size() == 0)
+      sprintf(buf, "%d", begin);
+    else
+      sprintf(buf, ",%d", begin);
+    }
+  else
+    {
+    if (range_string.size() == 0)
+      sprintf(buf, "%d-%d", begin, end);
+    else
+      sprintf(buf, ",%d-%d", begin, end);
+    }
+
+  range_string += buf;
+  } // END add_range_to_string()
+
+
+void translate_vector_to_range_string(
+
+  std::string            &range_string,
+  const std::vector<int> &indices)
+
+  {
+  // range_string starts empty
+  range_string.clear();
+  
+  if (indices.size() == 0)
+    return;
+  
+  int first = indices[0];
+  int prev = first;
+  
+  for (unsigned int i = 1; i < indices.size(); i++)
+    {
+    if (indices[i] == prev + 1)
+      {
+      // Still in a consecutive range
+      prev = indices[i];
+      }
+    else
+      {
+      add_range_to_string(range_string, first, prev);
+  
+      first = prev = indices[i];
+      }
+    }
+  
+  // output final piece
+  add_range_to_string(range_string, first, prev);
+  } // END translate_vector_to_range_string()
+  
+
+void translate_range_string_to_vector(
+
+  const char       *range_string,
+  std::vector<int> &indices)
+
+  {
+  char *str = strdup(range_string);
+  char *ptr = str;
+  int   prev;
+  int   curr;
+
+  while (*ptr != '\0')
+    {
+    prev = strtol(ptr, &ptr, 10);
+
+    if (*ptr == '-')
+      {
+      ptr++;
+      curr = strtol(ptr, &ptr, 10);
+
+      while (prev <= curr)
+        {
+        indices.push_back(prev);
+
+        prev++;
+        }
+
+      if ((*ptr == ',') ||
+          (is_whitespace(*ptr)))
+        ptr++;
+      }
+    else
+      {
+      indices.push_back(prev);
+
+      if ((*ptr == ',') ||
+          (is_whitespace(*ptr)))
+        ptr++;
+      }
+    }
+
+  free(str);
+  } /* END translate_range_string_to_vector() */
 
 
 #include "../../src/server/id_map.cpp"
 #include "../../src/server/node_attr_def.c"
+#include "../../src/lib/Libutils/machine.cpp"
+#include "../../src/lib/Libutils/numa_chip.cpp"
+#include "../../src/lib/Libutils/numa_socket.cpp"
+#include "../../src/lib/Libutils/numa_core.cpp"
+#include "../../src/lib/Libutils/numa_pci_device.cpp"
+#include "../../src/lib/Libutils/allocation.cpp"
+#include "../../src/lib/Libattr/req.cpp"
+#include "../../src/lib/Libattr/complete_req.cpp"
 //#include "../../src/lib/Libattr/attr_fn_str.c"
diff --git a/src/test/req_modify/scaffolding.c b/src/test/req_modify/scaffolding.c
index 5af0022e3..1a6c77afb 100644
--- a/src/test/req_modify/scaffolding.c
+++ b/src/test/req_modify/scaffolding.c
@@ -285,5 +285,6 @@ job *chk_job_request(char *p, batch_request *b)
   return(jp);
   }
 
+void overwrite_complete_req( pbs_attribute *attr, pbs_attribute *new_attr) {}
 
 void reply_ack(struct batch_request *preq) {}

