commit 6479c79f5517e2881bc881e737b2dbce69553878
Author: Anton Khirnov <anton@khirnov.net>
Date:   Sat Jan 17 22:28:46 2015 +0100

    h264: move mvd_cache into the per-slice context

diff --git a/libavcodec/h264.h b/libavcodec/h264.h
index cd5788a0a..29c974681 100644
--- a/libavcodec/h264.h
+++ b/libavcodec/h264.h
@@ -392,6 +392,7 @@ typedef struct H264SliceContext {
      */
     DECLARE_ALIGNED(16, int16_t, mv_cache)[2][5 * 8][2];
     DECLARE_ALIGNED(8,  int8_t, ref_cache)[2][5 * 8];
+    DECLARE_ALIGNED(16, uint8_t, mvd_cache)[2][5 * 8][2];
 
     DECLARE_ALIGNED(8, uint16_t, sub_mb_type)[4];
 
@@ -495,7 +496,6 @@ typedef struct H264Context {
     /* chroma_pred_mode for i4x4 or i16x16, else 0 */
     uint8_t *chroma_pred_mode_table;
     uint8_t (*mvd_table[2])[2];
-    DECLARE_ALIGNED(16, uint8_t, mvd_cache)[2][5 * 8][2];
     uint8_t *direct_table;
     uint8_t direct_cache[5 * 8];
 
@@ -995,7 +995,7 @@ static av_always_inline void write_back_motion_list(H264Context *h,
     if (CABAC(h)) {
         uint8_t (*mvd_dst)[2] = &sl->mvd_table[list][FMO ? 8 * h->mb_xy
                                                         : h->mb2br_xy[h->mb_xy]];
-        uint8_t(*mvd_src)[2]  = &h->mvd_cache[list][scan8[0]];
+        uint8_t(*mvd_src)[2]  = &sl->mvd_cache[list][scan8[0]];
         if (IS_SKIP(mb_type)) {
             AV_ZERO128(mvd_dst);
         } else {
diff --git a/libavcodec/h264_cabac.c b/libavcodec/h264_cabac.c
index 24ce09349..cc3db5dc7 100644
--- a/libavcodec/h264_cabac.c
+++ b/libavcodec/h264_cabac.c
@@ -1535,10 +1535,10 @@ static int decode_cabac_mb_mvd(H264Context *h, H264SliceContext *sl, int ctxbase
 
 #define DECODE_CABAC_MB_MVD( h,  list,  n )\
 {\
-    int amvd0 = h->mvd_cache[list][scan8[n] - 1][0] +\
-                h->mvd_cache[list][scan8[n] - 8][0];\
-    int amvd1 = h->mvd_cache[list][scan8[n] - 1][1] +\
-                h->mvd_cache[list][scan8[n] - 8][1];\
+    int amvd0 = sl->mvd_cache[list][scan8[n] - 1][0] +\
+                sl->mvd_cache[list][scan8[n] - 8][0];\
+    int amvd1 = sl->mvd_cache[list][scan8[n] - 1][1] +\
+                sl->mvd_cache[list][scan8[n] - 8][1];\
 \
     mx += decode_cabac_mb_mvd(h, sl, 40, amvd0, &mpx);\
     my += decode_cabac_mb_mvd(h, sl, 47, amvd1, &mpy);\
@@ -2146,7 +2146,7 @@ decode_intra_mb:
             for(i=0; i<4; i++){
                 sl->ref_cache[list][scan8[4 * i]] = sl->ref_cache[list][scan8[4 * i] + 1];
                 if(IS_DIRECT(sl->sub_mb_type[i])){
-                    fill_rectangle(h->mvd_cache[list][scan8[4*i]], 2, 2, 8, 0, 2);
+                    fill_rectangle(sl->mvd_cache[list][scan8[4*i]], 2, 2, 8, 0, 2);
                     continue;
                 }
 
@@ -2158,7 +2158,7 @@ decode_intra_mb:
                         int mx, my;
                         const int index= 4*i + block_width*j;
                         int16_t (* mv_cache)[2] = &sl->mv_cache[list][ scan8[index] ];
-                        uint8_t (* mvd_cache)[2]= &h->mvd_cache[list][ scan8[index] ];
+                        uint8_t (* mvd_cache)[2]= &sl->mvd_cache[list][ scan8[index] ];
                         pred_motion(h, sl, index, block_width, list, sl->ref_cache[list][ scan8[index] ], &mx, &my);
                         DECODE_CABAC_MB_MVD( h, list, index)
                         tprintf(h->avctx, "final mv:%d %d\n", mx, my);
@@ -2194,14 +2194,14 @@ decode_intra_mb:
                     }
                 }else{
                     fill_rectangle(sl->mv_cache [list][ scan8[4*i] ], 2, 2, 8, 0, 4);
-                    fill_rectangle(h->mvd_cache[list][ scan8[4*i] ], 2, 2, 8, 0, 2);
+                    fill_rectangle(sl->mvd_cache[list][ scan8[4*i] ], 2, 2, 8, 0, 2);
                 }
             }
         }
     } else if( IS_DIRECT(mb_type) ) {
         ff_h264_pred_direct_motion(h, sl, &mb_type);
-        fill_rectangle(h->mvd_cache[0][scan8[0]], 4, 4, 8, 0, 2);
-        fill_rectangle(h->mvd_cache[1][scan8[0]], 4, 4, 8, 0, 2);
+        fill_rectangle(sl->mvd_cache[0][scan8[0]], 4, 4, 8, 0, 2);
+        fill_rectangle(sl->mvd_cache[1][scan8[0]], 4, 4, 8, 0, 2);
         dct8x8_allowed &= h->sps.direct_8x8_inference_flag;
     } else {
         int list, i;
@@ -2227,7 +2227,7 @@ decode_intra_mb:
                     DECODE_CABAC_MB_MVD( h, list, 0)
                     tprintf(h->avctx, "final mv:%d %d\n", mx, my);
 
-                    fill_rectangle(h->mvd_cache[list][ scan8[0] ], 4, 4, 8, pack8to16(mpx,mpy), 2);
+                    fill_rectangle(sl->mvd_cache[list][ scan8[0] ], 4, 4, 8, pack8to16(mpx,mpy), 2);
                     fill_rectangle(sl->mv_cache[list][ scan8[0] ], 4, 4, 8, pack16to32(mx,my), 4);
                 }
             }
@@ -2258,10 +2258,10 @@ decode_intra_mb:
                         DECODE_CABAC_MB_MVD( h, list, 8*i)
                         tprintf(h->avctx, "final mv:%d %d\n", mx, my);
 
-                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 16*i ], 4, 2, 8, pack8to16(mpx,mpy), 2);
+                        fill_rectangle(sl->mvd_cache[list][ scan8[0] + 16*i ], 4, 2, 8, pack8to16(mpx,mpy), 2);
                         fill_rectangle(sl->mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, pack16to32(mx,my), 4);
                     }else{
-                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 16*i ], 4, 2, 8, 0, 2);
+                        fill_rectangle(sl->mvd_cache[list][ scan8[0] + 16*i ], 4, 2, 8, 0, 2);
                         fill_rectangle(sl->mv_cache[list][ scan8[0] + 16*i ], 4, 2, 8, 0, 4);
                     }
                 }
@@ -2293,10 +2293,10 @@ decode_intra_mb:
                         DECODE_CABAC_MB_MVD( h, list, 4*i)
 
                         tprintf(h->avctx, "final mv:%d %d\n", mx, my);
-                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 2*i ], 2, 4, 8, pack8to16(mpx,mpy), 2);
+                        fill_rectangle(sl->mvd_cache[list][ scan8[0] + 2*i ], 2, 4, 8, pack8to16(mpx,mpy), 2);
                         fill_rectangle(sl->mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, pack16to32(mx,my), 4);
                     }else{
-                        fill_rectangle(h->mvd_cache[list][ scan8[0] + 2*i ], 2, 4, 8, 0, 2);
+                        fill_rectangle(sl->mvd_cache[list][ scan8[0] + 2*i ], 2, 4, 8, 0, 2);
                         fill_rectangle(sl->mv_cache[list][ scan8[0] + 2*i ], 2, 4, 8, 0, 4);
                     }
                 }
diff --git a/libavcodec/h264_mvpred.h b/libavcodec/h264_mvpred.h
index 9c2e1ac51..d325b73db 100644
--- a/libavcodec/h264_mvpred.h
+++ b/libavcodec/h264_mvpred.h
@@ -688,7 +688,7 @@ static void fill_decode_caches(H264Context *h, H264SliceContext *sl, int mb_type
                 continue;
 
             if (!(mb_type & (MB_TYPE_SKIP | MB_TYPE_DIRECT2))) {
-                uint8_t(*mvd_cache)[2]   = &h->mvd_cache[list][scan8[0]];
+                uint8_t(*mvd_cache)[2]   = &sl->mvd_cache[list][scan8[0]];
                 uint8_t(*mvd)[2]         = sl->mvd_table[list];
                 ref_cache[2 + 8 * 0] =
                 ref_cache[2 + 8 * 2] = PART_NOT_AVAILABLE;
@@ -773,7 +773,7 @@ static void fill_decode_caches(H264Context *h, H264SliceContext *sl, int mb_type
     if (!IS_INTERLACED(mb_type) && sl->ref_cache[list][idx] >= 0) {     \
         sl->ref_cache[list][idx]    <<= 1;                              \
         sl->mv_cache[list][idx][1]   /= 2;                              \
-        h->mvd_cache[list][idx][1] >>= 1;                               \
+        sl->mvd_cache[list][idx][1] >>= 1;                              \
     }
 
                     MAP_MVS
@@ -784,7 +784,7 @@ static void fill_decode_caches(H264Context *h, H264SliceContext *sl, int mb_type
     if (IS_INTERLACED(mb_type) && sl->ref_cache[list][idx] >= 0) {      \
         sl->ref_cache[list][idx]    >>= 1;                              \
         sl->mv_cache[list][idx][1]  <<= 1;                              \
-        h->mvd_cache[list][idx][1] <<= 1;                               \
+        sl->mvd_cache[list][idx][1] <<= 1;                              \
     }
 
                     MAP_MVS

