commit 650f48088d3fba23d8cb1b755adbc7406bf4a1b7
Author: niklas <niklas@openbsd.org>
Date:   Sun Feb 22 23:33:05 1998 +0000

    This has been in my tree for a *very* long time.  cua devices like on
    the com devices and sparc zs ones.  This replaces the old broken dialin/out
    mechanism.

diff --git a/sys/arch/amiga/dev/ser.c b/sys/arch/amiga/dev/ser.c
index 4bd9db43c42..0428bf82ebc 100644
--- a/sys/arch/amiga/dev/ser.c
+++ b/sys/arch/amiga/dev/ser.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: ser.c,v 1.8 1998/02/22 20:36:11 niklas Exp $	*/
+/*	$OpenBSD: ser.c,v 1.9 1998/02/22 23:33:05 niklas Exp $	*/
 /*	$NetBSD: ser.c,v 1.43 1998/01/12 10:40:11 thorpej Exp $	*/
 
 /*
@@ -52,7 +52,10 @@
 #include <sys/kernel.h>
 #include <sys/syslog.h>
 #include <sys/queue.h>
+#include <sys/conf.h>
+
 #include <machine/cpu.h>
+
 #include <amiga/amiga/device.h>
 #include <amiga/dev/serreg.h>
 #include <amiga/amiga/custom.h>
@@ -61,18 +64,35 @@
 
 #include <dev/cons.h>
 
-#include <sys/conf.h>
+#ifdef DDB
+#include <ddb/db_var.h>
+#endif
+
 #include <machine/conf.h>
 
 #include "ser.h"
 #if NSER > 0
 
+/* unit is in lower 7 bits (for now, only one unit:-))
+   dialin:    open blocks until carrier present, hangup on carrier drop
+   dialout:   carrier is ignored */
+
+#define SERUNIT(dev)   (minor(dev) & 0x7f)
+#define SERCUA(dev)    (minor(dev) & 0x80)
+
+/* Macros to clear/set/test flags. */
+#define	SET(t, f)	(t) |= (f)
+#define	CLR(t, f)	(t) &= ~(f)
+#define	ISSET(t, f)	((t) & (f))
+
 void serattach __P((struct device *, struct device *, void *));
 int sermatch __P((struct device *, void *, void *));
 
 struct ser_softc {
 	struct device dev;
 	struct tty *ser_tty;
+	u_char ser_cua;
+	int ser_swflags;
 };
 
 struct cfattach ser_ca = {
@@ -119,12 +139,9 @@ int	serconsole = -1;
 int	serconsinit;
 int	serdefaultrate = TTYDEF_SPEED;
 int	sermajor;
-int	serswflags;
-#define SWFLAGS(dev) (serswflags | (DIALOUT(dev) ? TIOCFLAG_SOFTCAR : 0))
 
 struct	vbl_node ser_vbl_node[NSER];
 struct	tty ser_cons;
-struct	tty *ser_tty[NSER];
 
 /* 
  * Since this UART is not particularly bright (to put it nicely), we'll
@@ -207,7 +224,7 @@ serattach(pdp, dp, auxp)
 		if (serconsole == 0)
 			kgdb_dev = NODEV; /* can't debug over console port */
 		else {
-			(void) serinit(0, kgdb_rate);
+			(void)serinit(0, kgdb_rate);
 			serconsinit = 1;       /* don't re-init in serputc */
 			if (kgdb_debug_init == 0)
 				printf(" kgdb enabled\n");
@@ -240,99 +257,110 @@ seropen(dev, flag, mode, p)
 	int flag, mode;
 	struct proc *p;
 {
+	int unit = SERUNIT(dev);
+	struct ser_softc *sc;
 	struct tty *tp;
-	int unit, error, s;
-
-	error = 0;
-	unit = SERUNIT(dev);
+	int s;
+	int error = 0;
 
 	if (unit >= NSER || (ser_active & (1 << unit)) == 0)
 		return (ENXIO);
+	sc = (struct ser_softc *)ser_cd.cd_devs[unit];
 
 	s = spltty();
-
-	if (ser_tty[unit]) 
-		tp = ser_tty[unit];
-	else {
-		tp = ((struct ser_softc *)ser_cd.cd_devs[unit])->ser_tty =
-		    ser_tty[unit] =  ttymalloc();
+	if (!sc->ser_tty) {
+		tp = sc->ser_tty = ttymalloc();
 		tty_attach(tp);
-	}
+	} else
+		tp = sc->ser_tty;
+	splx(s);
 
-	tp->t_oproc = (void (*) (struct tty *)) serstart;
+	tp->t_oproc = serstart;
 	tp->t_param = serparam;
-	tp->t_dev = dev;
 	tp->t_hwiflow = serhwiflow;
 
-	if ((tp->t_state & TS_ISOPEN) == 0) {
-		tp->t_state |= TS_WOPEN;
+	if (!ISSET(tp->t_state, TS_ISOPEN)) {
+		SET(tp->t_state, TS_WOPEN);
 		ttychars(tp);
-		if (tp->t_ispeed == 0) {
-			/*
-			 * only when cleared do we reset to defaults.
-			 */
-			tp->t_iflag = TTYDEF_IFLAG;
-			tp->t_oflag = TTYDEF_OFLAG;
-			tp->t_cflag = TTYDEF_CFLAG;
-			tp->t_lflag = TTYDEF_LFLAG;
-			tp->t_ispeed = tp->t_ospeed = serdefaultrate;
-		}
-		/*
-		 * do these all the time
-		 */
-		if (serswflags & TIOCFLAG_CLOCAL)
-			tp->t_cflag |= CLOCAL;
-		if (serswflags & TIOCFLAG_CRTSCTS)
-			tp->t_cflag |= CRTSCTS;
-		if (serswflags & TIOCFLAG_MDMBUF)
-			tp->t_cflag |= MDMBUF;
+		tp->t_iflag = TTYDEF_IFLAG;
+		tp->t_oflag = TTYDEF_OFLAG;
+		if (ISSET(sc->ser_swflags, TIOCFLAG_CLOCAL))
+			SET(tp->t_cflag, CLOCAL);
+		if (ISSET(sc->ser_swflags, TIOCFLAG_CRTSCTS))
+			SET(tp->t_cflag, CRTSCTS);
+		if (ISSET(sc->ser_swflags, TIOCFLAG_MDMBUF))
+			SET(tp->t_cflag, MDMBUF);
+		tp->t_cflag = TTYDEF_CFLAG;
+		tp->t_lflag = TTYDEF_LFLAG;
+		tp->t_ispeed = tp->t_ospeed = serdefaultrate;
+
+		s = spltty();
+
 		serparam(tp, &tp->t_termios);
 		ttsetwater(tp);
 		
-		(void)sermctl(dev, TIOCM_DTR | TIOCM_RTS, DMSET);
-		if ((SWFLAGS(dev) & TIOCFLAG_SOFTCAR) || 
-		    (sermctl(dev, 0, DMGET) & TIOCM_CD))
-			tp->t_state |= TS_CARR_ON;
+		sermctl(dev, TIOCM_DTR | TIOCM_RTS, DMSET);
+		if (ISSET(sc->ser_swflags, TIOCFLAG_SOFTCAR) || SERCUA(dev) || 
+		    ISSET(sermctl(dev, 0, DMGET), TIOCM_CD) ||
+		    ISSET(tp->t_cflag, MDMBUF))
+			SET(tp->t_state, TS_CARR_ON);
 		else
-			tp->t_state &= ~TS_CARR_ON;
-	} else if (tp->t_state & TS_XCLUDE && p->p_ucred->cr_uid != 0) {
-		splx(s);
-		return(EBUSY);
+			CLR(tp->t_state, TS_CARR_ON);
+	} else if (ISSET(tp->t_state, TS_XCLUDE) && p->p_ucred->cr_uid != 0) {
+		return (EBUSY);
+	} else
+		s = spltty();
+
+	if (SERCUA(dev)) {
+		if (ISSET(tp->t_state, TS_ISOPEN)) {
+			/* Ah, but someone already is dialed in... */
+			splx(s);
+			return (EBUSY);
+		}
+		sc->ser_cua = 1;		/* We go into CUA mode */
 	}
+	tp->t_dev = dev;
 
-	/*
-	 * if NONBLOCK requested, ignore carrier
-	 */
-	if (flag & O_NONBLOCK)
-		goto done;
-
-	/*
-	 * block waiting for carrier
-	 */
-	while ((tp->t_state & TS_CARR_ON) == 0 && (tp->t_cflag & CLOCAL) == 0) {
-		tp->t_state |= TS_WOPEN;
-		error = ttysleep(tp, (caddr_t)&tp->t_rawq, 
-		    TTIPRI | PCATCH, ttopen, 0);
-		if (error) {
+	if (ISSET(flag, O_NONBLOCK)) {
+		if (!SERCUA(dev) && sc->ser_cua) {
+			/* Opening TTY non-blocking... but the CUA is busy */
 			splx(s);
-			return(error);
+			return (EBUSY);
+		}
+	} else {
+		while (sc->ser_cua ||
+		    (!ISSET(tp->t_cflag, CLOCAL) &&
+		    !ISSET(tp->t_state, TS_CARR_ON))) {
+			SET(tp->t_state, TS_WOPEN);
+			error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH,
+			    ttopen, 0);
+			if (!SERCUA(dev) && sc->ser_cua && error == EINTR)
+				continue;
+			if (error) {
+				/* XXX should turn off chip if we're the
+				   only waiter */
+				if (SERCUA(dev)) {
+					sc->ser_cua = 0;
+					tp->t_dev = SERUNIT(dev);
+				}
+				CLR(tp->t_state, TS_WOPEN);
+				splx(s);
+				return error;
+			}
+			if (!SERCUA(dev) && sc->ser_cua)
+				continue;
 		}
 	}
-done:
+
 	/* This is a way to handle lost XON characters */
-	if ((flag & O_TRUNC) && (tp->t_state & TS_TTSTOP)) {
-		tp->t_state &= ~TS_TTSTOP;
-	        ttstart (tp);
+	if (ISSET(flag, O_TRUNC) && ISSET(tp->t_state, TS_TTSTOP)) {
+		CLR(tp->t_state, TS_TTSTOP);
+	        ttstart(tp);
 	}
-
 	splx(s);
-	/*
-	 * Reset the tty pointer, as there could have been a dialout
-	 * use of the tty with a dialin open waiting.
-	 */
-	tp->t_dev = dev;
+
 	ser_open_speed = tp->t_ispeed;
-	return((*linesw[tp->t_line].l_open)(dev, tp));
+	return ((*linesw[tp->t_line].l_open)(dev, tp));
 }
 
 /*ARGSUSED*/
@@ -342,13 +370,11 @@ serclose(dev, flag, mode, p)
 	int flag, mode;
 	struct proc *p;
 {
-	struct tty *tp;
-	int unit;
+	int unit = SERUNIT(dev);
+	struct ser_softc *sc = (struct ser_softc *)ser_cd.cd_devs[unit];
+	struct tty *tp = sc->ser_tty;
 	int closebits;
 
-	unit = SERUNIT(dev);
-
-	tp = ser_tty[unit];
 	(*linesw[tp->t_line].l_close)(tp, flag);
 	custom.adkcon = ADKCONF_UARTBRK;	/* clear break */
 #ifdef KGDB
@@ -376,12 +402,13 @@ serclose(dev, flag, mode, p)
 	 * immediately.
 	 */
 	(void)tsleep(tp, TTIPRI, ttclos, hz);
+	sc->ser_cua = 0;			/* XXX spltty? */
 	ttyclose(tp);
 #if not_yet
 	if (tp != &ser_cons) {
 		remove_vbl_function(&ser_vbl_node[unit]);
 		ttyfree(tp);
-		ser_tty[unit] = (struct tty *) NULL;
+		sc->ser_tty = NULL;
 	}
 #endif
 	ser_open_speed = tp->t_ispeed;
@@ -394,10 +421,13 @@ serread(dev, uio, flag)
 	struct uio *uio;
 	int flag;
 {
-	struct tty *tp;
-	if ((tp = ser_tty[SERUNIT(dev)]) == NULL)
-		return(ENXIO);
-	return((*linesw[tp->t_line].l_read)(tp, uio, flag));
+	int unit = SERUNIT(dev);
+	struct ser_softc *sc = (struct ser_softc *)ser_cd.cd_devs[unit];
+	struct tty *tp = sc->ser_tty;
+
+	if (!tp)
+		return (ENXIO);
+	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
 }
 
 int
@@ -406,18 +436,24 @@ serwrite(dev, uio, flag)
 	struct uio *uio;
 	int flag;
 {
-	struct tty *tp;
+	int unit = SERUNIT(dev);
+	struct ser_softc *sc = (struct ser_softc *)ser_cd.cd_devs[unit];
+	struct tty *tp = sc->ser_tty;
 
-	if((tp = ser_tty[SERUNIT(dev)]) == NULL)
-		return(ENXIO);
-	return((*linesw[tp->t_line].l_write)(tp, uio, flag));
+	if (!tp)
+		return (ENXIO);
+	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
 }
 
 struct tty *
 sertty(dev)
 	dev_t dev;
 {
-	return (ser_tty[SERUNIT(dev)]);
+	int unit = SERUNIT(dev);
+	struct ser_softc *sc = (struct ser_softc *)ser_cd.cd_devs[unit];
+	struct tty *tp = sc->ser_tty;
+
+	return (tp);
 }
 
 /*
@@ -487,7 +523,8 @@ serintr(unit)
 	int unit;
 {
 	int s1, s2, ovfl;
-	struct tty *tp = ser_tty[unit];
+	struct ser_softc *sc = (struct ser_softc *)ser_cd.cd_devs[unit];
+	struct tty *tp = sc->ser_tty;
 
 	/*
 	 * Make sure we're not interrupted by another
@@ -498,7 +535,7 @@ serintr(unit)
 	/*
 	 * pass along any acumulated information
 	 */
-	while (sbcnt > 0 && (tp->t_state & TS_TBLOCK) == 0) {
+	while (sbcnt > 0 && !ISSET(tp->t_state, TS_TBLOCK)) {
 		/* 
 		 * no collision with ser_fastint()
 		 */
@@ -520,7 +557,7 @@ serintr(unit)
 			    ovfl);
 	}
 	s2 = splser();
-	if (sbcnt == 0 && (tp->t_state & TS_TBLOCK) == 0)
+	if (sbcnt == 0 && ISSET(tp->t_state, TS_TBLOCK))
 		SETRTS(ciab.pra);	/* start accepting data again */
 	splx(s2);
 	splx(s1);
@@ -530,15 +567,15 @@ void
 sereint(unit, stat)
 	int unit, stat;
 {
-	struct tty *tp;
+	struct ser_softc *sc = (struct ser_softc *)ser_cd.cd_devs[unit];
+	struct tty *tp = sc->ser_tty;
 	u_char ch;
 	int c;
 
-	tp = ser_tty[unit];
 	ch = stat & 0xff;
 	c = ch;
 
-	if ((tp->t_state & TS_ISOPEN) == 0) {
+	if (!ISSET(tp->t_state, TS_ISOPEN)) {
 #ifdef KGDB
 		/* we don't care about parity errors */
 		if (kgdb_dev == makedev(sermajor, unit) && c == FRAME_END)
@@ -551,13 +588,13 @@ sereint(unit, stat)
 	 * Check for break and (if enabled) parity error.
 	 */
 	if ((stat & 0x1ff) == 0)
-		c |= TTY_FE;
-	else if ((tp->t_cflag & PARENB) &&
-		    (((ch >> 7) + even_parity[ch & 0x7f]
-		    + !!(tp->t_cflag & PARODD)) & 1))
-			c |= TTY_PE;
+		SET(c, TTY_FE);
+	else if (ISSET(tp->t_cflag, PARENB) &&
+	    ((ch >> 7) + even_parity[ch & 0x7f] +
+	    (ISSET(tp->t_cflag, PARODD) ? 1 : 0)))
+		SET(c, TTY_PE);
 
-	if (stat & SERDATRF_OVRUN)
+	if (ISSET(stat, SERDATRF_OVRUN))
 		log(LOG_WARNING, "ser0: silo overflow\n");
 
 	(*linesw[tp->t_line].l_rint)(c, tp);
@@ -573,14 +610,18 @@ void
 sermint(unit)
 	int unit;
 {
-	struct tty *tp;
+	struct ser_softc *sc = (struct ser_softc *)ser_cd.cd_devs[unit];
+	struct tty *tp = sc->ser_tty;
 	u_char stat, last, istat;
+#ifdef PPS_SYNC
+	struct timeval tv;
+	long usec;
+#endif /* PPS_SYNC */
 
-	tp = ser_tty[unit];
 	if (!tp)
 		return;
 
-	if ((tp->t_state & (TS_ISOPEN | TS_WOPEN)) == 0) {
+	if (!ISSET(tp->t_state, TS_ISOPEN | TS_WOPEN)) {
 		sbrpt = sbwpt = serbuf;
 		return;
 	}
@@ -598,32 +639,43 @@ sermint(unit)
 	 */
 	istat = stat ^ last;
 
-	if ((istat & CIAB_PRA_CD) && 
-	    (SWFLAGS(tp->t_dev) & TIOCFLAG_SOFTCAR) == 0) {
-		if (ISDCD(stat))
-			(*linesw[tp->t_line].l_modem)(tp, 1);
-		else if ((*linesw[tp->t_line].l_modem)(tp, 0) == 0) {
+	if (ISSET(istat, CIAB_PRA_CD)) {
+#ifdef PPS_SYNC
+		if (ISSET(sc->ser_swflags, TIOCFLAG_PPS)) {
+			if (ISDCD(stat)) {
+				usec = time.tv_usec;
+				microtime(&tv);                 
+				usec = tv.tv_usec - usec;
+				if (usec < 0)
+					usec += 1000000;
+				hardpps(&tv, usec);           
+			}
+		}
+#endif /* PPS_SYNC */
+		if (!ISSET(sc->ser_swflags, TIOCFLAG_SOFTCAR) &&
+		    (*linesw[tp->t_line].l_modem)(tp, ISDCD(stat)) ==
+		    0) {
 			CLRDTR(stat);
 			CLRRTS(stat);
 			ciab.pra = stat;
 			last_ciab_pra = stat;
 		}
 	}
-	if ((istat & CIAB_PRA_CTS) && (tp->t_state & TS_ISOPEN) &&
-	    (tp->t_cflag & CRTSCTS)) {
+	if (ISSET(istat, CIAB_PRA_CTS) && ISSET(tp->t_state, TS_ISOPEN) &&
+	    ISSET(tp->t_cflag, CRTSCTS)) {
 #if 0
 		/* the line is up and we want to do rts/cts flow control */
 		if (ISCTS(stat)) {
-			tp->t_state &= ~TS_TTSTOP;
+			CLR(tp->t_state, TS_TTSTOP);
 			ttstart(tp);
 			/* cause tbe-int if we were stuck there */
 			custom.intreq = INTF_SETCLR | INTF_TBE;
 		} else
-			tp->t_state |= TS_TTSTOP;
+			SET(tp->t_state, TS_TTSTOP);
 #else
 		/* do this on hardware level, not with tty driver */
 		if (ISCTS(stat)) {
-			tp->t_state &= ~TS_TTSTOP;
+			CLR(tp->t_state, TS_TTSTOP);
 			/* cause TBE interrupt */
 			custom.intreq = INTF_SETCLR | INTF_TBE;
 		}
@@ -639,21 +691,21 @@ serioctl(dev, cmd, data, flag, p)
 	int flag;
 	struct proc *p;
 {
-	register struct tty *tp;
-	register int unit = SERUNIT(dev);
-	register int error;
+	int unit = SERUNIT(dev);
+	struct ser_softc *sc = (struct ser_softc *)ser_cd.cd_devs[unit];
+	struct tty *tp = sc->ser_tty;
+	int error;
 
-	tp = ser_tty[unit];
 	if (!tp)
 		return ENXIO;
 
 	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
 	if (error >= 0)
-		return(error);
+		return (error);
 
 	error = ttioctl(tp, cmd, data, flag, p);
 	if (error >= 0)
-		return(error);
+		return (error);
 
 	switch (cmd) {
 	case TIOCSBRK:
@@ -665,45 +717,47 @@ serioctl(dev, cmd, data, flag, p)
 		break;
 
 	case TIOCSDTR:
-		(void) sermctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIS);
+		(void)sermctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIS);
 		break;
 
 	case TIOCCDTR:
-		(void) sermctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIC);
+		(void)sermctl(dev, TIOCM_DTR | TIOCM_RTS, DMBIC);
 		break;
 
 	case TIOCMSET:
-		(void) sermctl(dev, *(int *) data, DMSET);
+		(void)sermctl(dev, *(int *) data, DMSET);
 		break;
 
 	case TIOCMBIS:
-		(void) sermctl(dev, *(int *) data, DMBIS);
+		(void)sermctl(dev, *(int *) data, DMBIS);
 		break;
 
 	case TIOCMBIC:
-		(void) sermctl(dev, *(int *) data, DMBIC);
+		(void)sermctl(dev, *(int *) data, DMBIC);
 		break;
 
 	case TIOCMGET:
 		*(int *)data = sermctl(dev, 0, DMGET);
 		break;
+
 	case TIOCGFLAGS:
-		*(int *)data = SWFLAGS(dev);
+		*(int *)data = sc->ser_swflags;
 		break;
 	case TIOCSFLAGS:
 		error = suser(p->p_ucred, &p->p_acflag); 
 		if (error != 0)
-			return(EPERM); 
+			return (EPERM); 
 
-		serswflags = *(int *)data;
-                serswflags &= /* only allow valid flags */
-                  (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | TIOCFLAG_CRTSCTS);
+		sc->ser_swflags = *(int *)data;
+                sc->ser_swflags &= /* only allow valid flags */
+                    (TIOCFLAG_SOFTCAR | TIOCFLAG_CLOCAL | TIOCFLAG_CRTSCTS |
+		    TIOCFLAG_MDMBUF | TIOCFLAG_PPS);
 		break;
 	default:
-		return(ENOTTY);
+		return (ENOTTY);
 	}
 
-	return(0);
+	return (0);
 }
 
 int
@@ -711,27 +765,45 @@ serparam(tp, t)
 	struct tty *tp;
 	struct termios *t;
 {
-	int cflag, unit, ospeed = 0;
+	struct ser_softc *sc =
+	    (struct ser_softc *)ser_cd.cd_devs[SERUNIT(tp->t_dev)];
+	int ospeed = 0;
+	tcflag_t cflag, oldcflag;
+	int rec_mode, s;
 	
 	cflag = t->c_cflag;
-	unit = SERUNIT(tp->t_dev);
 
 	if (t->c_ospeed > 0) {
 		if (t->c_ospeed < 110)
-			return(EINVAL);
+			return (EINVAL);
 		ospeed = SERBRD(t->c_ospeed);
 	}
 
 	if (t->c_ispeed && t->c_ispeed != t->c_ospeed)
-		return(EINVAL);
+		return (EINVAL);
+
+	switch (t->c_cflag & CSIZE) {
+	case CS7:
+		if (!ISSET(t->c_cflag, PARENB))
+			return (EINVAL);
+		rec_mode = 0;				/* 8 bits */
+		break;
+	case CS8:
+		rec_mode = ISSET(t->c_cflag, PARENB) ? 1 : 0;
+		break;
+	default:
+		return (EINVAL);
+	}
+
+	s = spltty();
 
 	/* 
 	 * copy to tty
 	 */
-	tp->t_ispeed = t->c_ispeed;
+	ser_open_speed = tp->t_ispeed = t->c_ispeed;
 	tp->t_ospeed = t->c_ospeed;
+	oldcflag = tp->t_cflag;
 	tp->t_cflag = cflag;
-	ser_open_speed = tp->t_ispeed;
 
 	/*
 	 * enable interrupts
@@ -744,12 +816,27 @@ serparam(tp, t)
 	else {
 		/* 
 		 * (re)enable DTR
-		 * and set baud rate. (8 bit mode)
+		 * and set baud rate & 8/9-bit mode.
 		 */
 		(void)sermctl(tp->t_dev, TIOCM_DTR | TIOCM_RTS, DMSET);
-		custom.serper = (0 << 15) | ospeed;
+		custom.serper = (rec_mode << 15) | ospeed;
 	}
-	return(0);
+
+	/*
+	 * If DCD is off and MDMBUF is changed, ask the tty layer if we should
+	 * stop the device.                                      
+	 */                                                       
+	if (!ISDCD(last_ciab_pra) &&
+	    !ISSET(sc->ser_swflags, TIOCFLAG_SOFTCAR) &&
+	    ISSET(oldcflag, MDMBUF) != ISSET(tp->t_cflag, MDMBUF) &&
+	    (*linesw[tp->t_line].l_modem)(tp, 0) == 0) {
+		CLRDTR(ciab.pra);
+	}
+
+	/* Just to be sure... */
+	splx(s);
+	serstart(tp);
+	return (0);
 }
 
 int serhwiflow(tp, flag)
@@ -763,7 +850,7 @@ int serhwiflow(tp, flag)
 		CLRRTS(ciab.pra);
 	else
 	        SETRTS(ciab.pra);
-        return 1;
+        return (1);
 }
 
 static void
@@ -771,22 +858,22 @@ ser_putchar(tp, c)
 	struct tty *tp;
 	u_short c;
 {
-	if ((tp->t_cflag & CSIZE) == CS7 || (tp->t_cflag & PARENB))
+	if ((tp->t_cflag & CSIZE) == CS7 || ISSET(tp->t_cflag, PARENB))
 		c &= 0x7f;
 
 	/*
 	 * handle parity if necessary
 	 */
-	if (tp->t_cflag & PARENB) {
+	if (ISSET(tp->t_cflag, PARENB)) {
 		if (even_parity[c])
 			c |= 0x80;
-		if (tp->t_cflag & PARODD)
+		if (ISSET(tp->t_cflag, PARODD))
 			c ^= 0x80;
 	}
 	/* 
 	 * add stop bit(s)
 	 */
-	if (tp->t_cflag & CSTOPB)
+	if (ISSET(tp->t_cflag, CSTOPB))
 		c |= 0x300;
 	else
 		c |= 0x100;
@@ -801,16 +888,16 @@ static u_char *sob_ptr = ser_outbuf, *sob_end = ser_outbuf;
 void
 ser_outintr()
 {
-	struct tty *tp = ser_tty[0];
+	struct ser_softc *sc = (struct ser_softc *)ser_cd.cd_devs[0];
+	struct tty *tp = sc->ser_tty;
 	int s;
 
-	tp = ser_tty[0];
 	s = spltty();
 
 	if (tp == 0)
 		goto out;
 
-	if ((custom.intreqr & INTF_TBE) == 0)
+	if (!ISSET(custom.intreqr, INTF_TBE))
 		goto out;
 
 	/*
@@ -819,7 +906,7 @@ ser_outintr()
 	custom.intreq = INTF_TBE;
 
 	if (sob_ptr == sob_end) {
-		tp->t_state &= ~(TS_BUSY | TS_FLUSH);
+		CLR(tp->t_state, TS_BUSY | TS_FLUSH);
 		if (tp->t_line)
 			(*linesw[tp->t_line].l_start)(tp);
 		else
@@ -844,35 +931,33 @@ void
 serstart(tp)
 	struct tty *tp;
 {
-	int cc, s, unit, hiwat;
+	int cc, s, hiwat;
 	
 	hiwat = 0;
 
-	if ((tp->t_state & TS_ISOPEN) == 0)
+	if (!ISSET(tp->t_state, TS_ISOPEN))
 		return;
 
-	unit = SERUNIT(tp->t_dev);
-
 	s = spltty();
-	if (tp->t_state & (TS_TIMEOUT | TS_TTSTOP))
+	if (ISSET(tp->t_state, TS_TIMEOUT | TS_TTSTOP))
 		goto out;
 
 	cc = tp->t_outq.c_cc;
 	if (cc <= tp->t_lowat) {
-		if (tp->t_state & TS_ASLEEP) {
-			tp->t_state &= ~TS_ASLEEP;
-			wakeup((caddr_t) & tp->t_outq);
+		if (ISSET(tp->t_state, TS_ASLEEP)) {
+			CLR(tp->t_state, TS_ASLEEP);
+			wakeup((caddr_t)&tp->t_outq);
 		}
 		selwakeup(&tp->t_wsel);
 	}
-	if (cc == 0 || (tp->t_state & TS_BUSY))
+	if (cc == 0 || ISSET(tp->t_state, TS_BUSY))
 		goto out;
 
 	/*
 	 * We only do bulk transfers if using CTSRTS flow control, not for
 	 * (probably sloooow) ixon/ixoff devices.
 	 */
-	if ((tp->t_cflag & CRTSCTS) == 0)
+	if (!ISSET(tp->t_cflag, CRTSCTS))
 		cc = 1;
 
 	/*
@@ -885,7 +970,7 @@ serstart(tp)
 	}
 	cc = q_to_b(&tp->t_outq, ser_outbuf, cc);
 	if (cc > 0) {
-		tp->t_state |= TS_BUSY;
+		SET(tp->t_state, TS_BUSY);
 
 		sob_ptr = ser_outbuf;
 		sob_end = ser_outbuf + cc;
@@ -913,10 +998,8 @@ serstop(tp, flag)
 	int s;
 
 	s = spltty();
-	if (tp->t_state & TS_BUSY) {
-		if ((tp->t_state & TS_TTSTOP) == 0)
-			tp->t_state |= TS_FLUSH;
-	}
+	if (ISSET(tp->t_state, TS_BUSY) && !ISSET(tp->t_state, TS_TTSTOP))
+		SET(tp->t_state, TS_FLUSH);
 	splx(s);
 	return (0);
 }
@@ -926,29 +1009,27 @@ sermctl(dev, bits, how)
 	dev_t dev;
 	int bits, how;
 {
-	int unit, s;
+	int s;
 	u_char ub = 0;
 
-	unit = SERUNIT(dev);
-
 	/*
 	 * convert TIOCM* mask into CIA mask
 	 * which is active low
 	 */
 	if (how != DMGET) {
 		ub = 0;
-		if (bits & TIOCM_DTR)
-			ub |= CIAB_PRA_DTR;
-		if (bits & TIOCM_RTS)
-			ub |= CIAB_PRA_RTS;
-		if (bits & TIOCM_CTS)
-			ub |= CIAB_PRA_CTS;
-		if (bits & TIOCM_CD)
-			ub |= CIAB_PRA_CD;
-		if (bits & TIOCM_RI)
-			ub |= CIAB_PRA_SEL;	/* collision with /dev/par ! */
-		if (bits & TIOCM_DSR)
-			ub |= CIAB_PRA_DSR;
+		if (ISSET(bits, TIOCM_DTR))
+			SET(ub, CIAB_PRA_DTR);
+		if (ISSET(bits, TIOCM_RTS))
+			SET(ub, CIAB_PRA_RTS);
+		if (ISSET(bits, TIOCM_CTS))
+			SET(ub, CIAB_PRA_CTS);
+		if (ISSET(bits, TIOCM_CD))
+			SET(ub, CIAB_PRA_CD);
+		if (ISSET(bits, TIOCM_RI))
+			SET(ub, CIAB_PRA_SEL);	/* collision with /dev/par ! */
+		if (ISSET(bits, TIOCM_DSR))
+			SET(ub, CIAB_PRA_DSR);
 	}
 	s = spltty();
 	switch (how) {
@@ -974,20 +1055,20 @@ sermctl(dev, bits, how)
 	(void)splx(s);
 
 	bits = 0;
-	if (ub & CIAB_PRA_DTR)
-		bits |= TIOCM_DTR;
-	if (ub & CIAB_PRA_RTS)
-		bits |= TIOCM_RTS;
-	if (ub & CIAB_PRA_CTS)
-		bits |= TIOCM_CTS;
-	if (ub & CIAB_PRA_CD)
-		bits |= TIOCM_CD;
-	if (ub & CIAB_PRA_SEL)
-		bits |= TIOCM_RI;
-	if (ub & CIAB_PRA_DSR)
-		bits |= TIOCM_DSR;
-
-	return(bits);
+	if (ISSET(ub, CIAB_PRA_DTR))
+		SET(bits, TIOCM_DTR);
+	if (ISSET(ub, CIAB_PRA_RTS))
+		SET(bits, TIOCM_RTS);
+	if (ISSET(ub, CIAB_PRA_CTS))
+		SET(bits, TIOCM_CTS);
+	if (ISSET(ub, CIAB_PRA_CD))
+		SET(bits, TIOCM_CD);
+	if (ISSET(ub, CIAB_PRA_SEL))
+		SET(bits, TIOCM_RI);
+	if (ISSET(ub, CIAB_PRA_DSR))
+		SET(bits, TIOCM_DSR);
+
+	return (bits);
 }
 
 /*
@@ -1044,7 +1125,7 @@ serinit(unit, rate)
 	/*
 	 * might want to fiddle with the CIA later ???
 	 */
-	custom.serper = (rate>=110 ? SERBRD(rate) : 0);
+	custom.serper = (rate >= 110 ? SERBRD(rate) : 0);
 	splx(s);
 }
 
@@ -1059,7 +1140,7 @@ sercngetc(dev)
 	/*
 	 * poll
 	 */
-	while (((stat = custom.serdatr & 0xffff) & SERDATRF_RBF) == 0)
+	while (!ISSET(stat = custom.serdatr & 0xffff, SERDATRF_RBF))
 		;
 	c = stat & 0xff;
 	/*
@@ -1092,7 +1173,7 @@ sercnputc(dev, c)
 	 * wait for any pending transmission to finish 
 	 */
 	timo = 50000;
-	while (!(custom.serdatr & SERDATRF_TBE) && --timo);
+	while (!ISSET(custom.serdatr, SERDATRF_TBE) && --timo);
 
 	/*
 	 * transmit char.
@@ -1103,7 +1184,7 @@ sercnputc(dev, c)
 	 * wait for this transmission to complete
 	 */
 	timo = 1500000;
-	while (!(custom.serdatr & SERDATRF_TBE) && --timo)
+	while (!ISSET(custom.serdatr, SERDATRF_TBE) && --timo)
 		;
 
 	/*

