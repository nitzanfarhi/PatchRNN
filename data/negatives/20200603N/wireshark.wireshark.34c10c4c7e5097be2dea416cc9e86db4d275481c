commit 34c10c4c7e5097be2dea416cc9e86db4d275481c
Author: Ronnie Sahlberg <ronnie_sahlberg@ozemail.com.au>
Date:   Thu Jul 28 08:18:18 2005 +0000

    packet_ber has for some time been doing sanity checking of the BER Length fields
    that they are not longer than the reported length of the tvb.
    
    this triggers some bugs since in packet-ber we are a bit too lax in setting reported_length of the tvb_new_subset() tvb.
    
    this cause short kerberos packets to not be decoded at all and the same for other short asn based packets as well.
    
    
    fix some of these instances.
    
    
    svn path=/trunk/; revision=15127

diff --git a/epan/dissectors/packet-ber.c b/epan/dissectors/packet-ber.c
index 6c886a1682..2523c3a8c9 100644
--- a/epan/dissectors/packet-ber.c
+++ b/epan/dissectors/packet-ber.c
@@ -359,7 +359,7 @@ call_ber_oid_callback(char *oid, tvbuff_t *tvb, int offset, packet_info *pinfo,
 {
 	tvbuff_t *next_tvb;
 
-	next_tvb = tvb_new_subset(tvb, offset, tvb_length_remaining(tvb, offset), tvb_length_remaining(tvb, offset));
+	next_tvb = tvb_new_subset(tvb, offset, tvb_length_remaining(tvb, offset), tvb_reported_length_remaining(tvb, offset));
 	if(!dissector_try_string(ber_oid_dissector_table, oid, next_tvb, pinfo, tree)){
 		proto_item *item=NULL;
 		proto_tree *next_tree=NULL;
@@ -616,7 +616,7 @@ printf("OCTET STRING dissect_ber_octet_string(%s) entered\n",name);
 			if(len<=(guint32)tvb_length_remaining(tvb, offset)){
 				*out_tvb = tvb_new_subset(tvb, offset, len, len);
 			} else {
-				*out_tvb = tvb_new_subset(tvb, offset, tvb_length_remaining(tvb, offset), tvb_length_remaining(tvb, offset));
+				*out_tvb = tvb_new_subset(tvb, offset, tvb_length_remaining(tvb, offset), tvb_reported_length_remaining(tvb, offset));
 			}
 		}
 	}
@@ -1008,7 +1008,7 @@ ber_sequence_try_again:
 			 * length) of if the tvb is short, then just
 			 * give it all of the tvb and hope for the best.
 			 */
-			next_tvb = tvb_new_subset(tvb, hoffset, tvb_length_remaining(tvb,hoffset), tvb_length_remaining(tvb,hoffset));
+			next_tvb = tvb_new_subset(tvb, hoffset, tvb_length_remaining(tvb,hoffset), tvb_reported_length_remaining(tvb,hoffset));
 		} else {
 			next_tvb = tvb_new_subset(tvb, hoffset, eoffset-hoffset, eoffset-hoffset);
 		}
@@ -1778,7 +1778,7 @@ int dissect_ber_bitstring(gboolean implicit_tag, packet_info *pinfo, proto_tree
 			if(len<=(guint32)tvb_length_remaining(tvb, offset)){
 				*out_tvb = tvb_new_subset(tvb, offset, len, len);
 			} else {
-				*out_tvb = tvb_new_subset(tvb, offset, tvb_length_remaining(tvb, offset), tvb_length_remaining(tvb, offset));
+				*out_tvb = tvb_new_subset(tvb, offset, tvb_length_remaining(tvb, offset), tvb_reported_length_remaining(tvb, offset));
 			}
 		}
 	}
diff --git a/epan/dissectors/packet-kerberos.c b/epan/dissectors/packet-kerberos.c
index 62c3ee08ba..d9e991c547 100644
--- a/epan/dissectors/packet-kerberos.c
+++ b/epan/dissectors/packet-kerberos.c
@@ -4347,7 +4347,7 @@ static int wrap_dissect_gss_kerb(tvbuff_t *tvb, int offset, packet_info *pinfo,
 
 	auth_tvb = tvb_new_subset(
 		tvb, offset, tvb_length_remaining(tvb, offset),
-		tvb_length_remaining(tvb, offset));
+		tvb_reported_length_remaining(tvb, offset));
 
 	dissect_kerberos_main(auth_tvb, pinfo, tree, FALSE, NULL);
 

