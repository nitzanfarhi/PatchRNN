commit c4de0a5d671e3af38dc3496538e391782aecc3a5
Author: Eric Anholt <eric@anholt.net>
Date:   Sun Dec 14 19:05:04 2008 -0800

    drm/i915: Don't return busy for buffers left on the flushing list.
    
    These buffers don't have active rendering still occurring to them, they just
    need either a flush to be emitted or a retire_requests to occur so that we
    notice they're done.  Return unbusy so that one of the two occurs.  The two
    expected consumers of this interface (OpenGL and libdrm_intel BO cache) both
    want this behavior.
    
    Signed-off-by: Eric Anholt <eric@anholt.net>
    Acked-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Dave Airlie <airlied@redhat.com>

diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c
index ad672d854828..24fe8c10b4b2 100644
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -2309,7 +2309,14 @@ i915_gem_busy_ioctl(struct drm_device *dev, void *data,
 	}
 
 	obj_priv = obj->driver_private;
-	args->busy = obj_priv->active;
+	/* Don't count being on the flushing list against the object being
+	 * done.  Otherwise, a buffer left on the flushing list but not getting
+	 * flushed (because nobody's flushing that domain) won't ever return
+	 * unbusy and get reused by libdrm's bo cache.  The other expected
+	 * consumer of this interface, OpenGL's occlusion queries, also specs
+	 * that the objects get unbusy "eventually" without any interference.
+	 */
+	args->busy = obj_priv->active && obj_priv->last_rendering_seqno != 0;
 
 	drm_gem_object_unreference(obj);
 	mutex_unlock(&dev->struct_mutex);

