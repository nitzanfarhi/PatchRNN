commit d3e7e99f2faf9f44ec0a3379f735b41c9173dfa1
Author: Len Brown <len.brown@intel.com>
Date:   Thu Jul 22 17:23:10 2010 -0400

    ACPI: create "processor.bm_check_disable" boot param
    
    processor.bm_check_disable=1" prevents Linux from checking BM_STS
    before entering C3-type cpu power states.
    
    This may be useful for a system running acpi_idle
    where the BIOS exports FADT C-states, _CST IO C-states,
    or _CST FFH C-states with the BM_STS bit set;
    while configuring the chipset to set BM_STS
    more frequently than perhaps is optimal.
    
    Note that such systems may have been developed
    using a tickful OS that would quickly clear BM_STS,
    rather than a tickless OS that may go for some time
    between checking and clearing BM_STS.
    
    Note also that an alternative for newer systems
    is to use the intel_idle driver, which always
    ignores BM_STS, relying Linux device drivers
    to register constraints explicitly via PM_QOS.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=15886
    
    Signed-off-by: Len Brown <len.brown@intel.com>

diff --git a/drivers/acpi/processor_idle.c b/drivers/acpi/processor_idle.c
index b351342f1faf..1d4104855296 100644
--- a/drivers/acpi/processor_idle.c
+++ b/drivers/acpi/processor_idle.c
@@ -76,6 +76,8 @@ static unsigned int max_cstate __read_mostly = ACPI_PROCESSOR_MAX_POWER;
 module_param(max_cstate, uint, 0000);
 static unsigned int nocst __read_mostly;
 module_param(nocst, uint, 0000);
+static int bm_check_disable __read_mostly;
+module_param(bm_check_disable, uint, 0000);
 
 static unsigned int latency_factor __read_mostly = 2;
 module_param(latency_factor, uint, 0644);
@@ -763,6 +765,9 @@ static int acpi_idle_bm_check(void)
 {
 	u32 bm_status = 0;
 
+	if (bm_check_disable)
+		return 0;
+
 	acpi_read_bit_register(ACPI_BITREG_BUS_MASTER_STATUS, &bm_status);
 	if (bm_status)
 		acpi_write_bit_register(ACPI_BITREG_BUS_MASTER_STATUS, 1);

