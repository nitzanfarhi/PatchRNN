commit 4110b9bdc9cb38cff4a824d445bb057e363a342e
Author: Robert Moore <Robert.Moore@intel.com>
Date:   Tue Jan 11 10:25:15 2011 -0800

    Fix issues/fault with automatic "serialized" method support.
    
    History: This support changes a method to "serialized" on the fly if the
    method generates an AE_ALREADY_EXISTS error, indicating the possibility
    that it cannot handle reentrancy.
    
    This fix repairs a couple of issues seen in the field, especially on
    machines with many cores.
    
    1) Delete method children only upon the exit of the last thread, so
    as to not delete objects out from under running threads.
    
    2) Set the "serialized" bit for the method only upon the exit of the
    last thread, so as to not cause deadlock when running threads attempt
    to exit.
    
    3) Cleanup the use of the AML "MethodFlags" and internal method flags
    so that there is no longer any confustion between the two.
    
    Lin Ming, Bob Moore. Reported by dana.myers@oracle.com.

diff --git a/source/components/dispatcher/dsmethod.c b/source/components/dispatcher/dsmethod.c
index 4f266019b..8f7d6bd15 100644
--- a/source/components/dispatcher/dsmethod.c
+++ b/source/components/dispatcher/dsmethod.c
@@ -117,7 +117,6 @@
 
 #include "acpi.h"
 #include "accommon.h"
-#include "amlcode.h"
 #include "acdispat.h"
 #include "acinterp.h"
 #include "acnamesp.h"
@@ -291,7 +290,7 @@ AcpiDsBeginMethodExecution (
     /*
      * If this method is serialized, we need to acquire the method mutex.
      */
-    if (ObjDesc->Method.MethodFlags & AML_METHOD_SERIALIZED)
+    if (ObjDesc->Method.InfoFlags & ACPI_METHOD_SERIALIZED)
     {
         /*
          * Create a mutex for the method if it is defined to be Serialized
@@ -517,9 +516,9 @@ AcpiDsCallControlMethod (
 
     /* Invoke an internal method if necessary */
 
-    if (ObjDesc->Method.MethodFlags & AML_METHOD_INTERNAL_ONLY)
+    if (ObjDesc->Method.InfoFlags & ACPI_METHOD_INTERNAL_ONLY)
     {
-        Status = ObjDesc->Method.Extra.Implementation (NextWalkState);
+        Status = ObjDesc->Method.Dispatch.Implementation (NextWalkState);
         if (Status == AE_OK)
         {
             Status = AE_CTRL_TERMINATE;
@@ -694,11 +693,14 @@ AcpiDsTerminateControlMethod (
 
         /*
          * Delete any namespace objects created anywhere within the
-         * namespace by the execution of this method. Unless this method
-         * is a module-level executable code method, in which case we
-         * want make the objects permanent.
+         * namespace by the execution of this method. Unless:
+         * 1) This method is a module-level executable code method, in which
+         *    case we want make the objects permanent.
+         * 2) There are other threads executing the method, in which case we
+         *    will wait until the last thread has completed.
          */
-        if (!(MethodDesc->Method.Flags & AOPOBJ_MODULE_LEVEL))
+        if (!(MethodDesc->Method.InfoFlags & ACPI_METHOD_MODULE_LEVEL) &&
+             (MethodDesc->Method.ThreadCount == 1))
         {
             /* Delete any direct children of (created by) this method */
 
@@ -707,10 +709,14 @@ AcpiDsTerminateControlMethod (
             /*
              * Delete any objects that were created by this method
              * elsewhere in the namespace (if any were created).
+             * Use of the ACPI_METHOD_MODIFIED_NAMESPACE optimizes the
+             * deletion such that we don't have to perform an entire
+             * namespace walk for every control method execution.
              */
-            if (MethodDesc->Method.Flags & AOPOBJ_MODIFIED_NAMESPACE)
+            if (MethodDesc->Method.InfoFlags & ACPI_METHOD_MODIFIED_NAMESPACE)
             {
                 AcpiNsDeleteNamespaceByOwner (MethodDesc->Method.OwnerId);
+                MethodDesc->Method.InfoFlags &= ~ACPI_METHOD_MODIFIED_NAMESPACE;
             }
         }
     }
@@ -748,20 +754,39 @@ AcpiDsTerminateControlMethod (
          * Serialized if it appears that the method is incorrectly written and
          * does not support multiple thread execution. The best example of this
          * is if such a method creates namespace objects and blocks. A second
-         * thread will fail with an AE_ALREADY_EXISTS exception
+         * thread will fail with an AE_ALREADY_EXISTS exception.
          *
          * This code is here because we must wait until the last thread exits
-         * before creating the synchronization semaphore.
+         * before marking the method as serialized.
          */
-        if ((MethodDesc->Method.MethodFlags & AML_METHOD_SERIALIZED) &&
-            (!MethodDesc->Method.Mutex))
+        if (MethodDesc->Method.InfoFlags & ACPI_METHOD_SERIALIZED_PENDING)
         {
-            (void) AcpiDsCreateMethodMutex (MethodDesc);
+            if (WalkState)
+            {
+                ACPI_INFO ((AE_INFO,
+                    "Marking method %4.4s as Serialized because of AE_ALREADY_EXISTS error",
+                    WalkState->MethodNode->Name.Ascii));
+            }
+
+            /*
+             * Method tried to create an object twice and was marked as
+             * "pending serialized". The probable cause is that the method
+             * cannot handle reentrancy.
+             *
+             * The method was created as NotSerialized, but it tried to create
+             * a named object and then blocked, causing the second thread
+             * entrance to begin and then fail. Workaround this problem by
+             * marking the method permanently as Serialized when the last
+             * thread exits here.
+             */
+            MethodDesc->Method.InfoFlags &= ~ACPI_METHOD_SERIALIZED_PENDING;
+            MethodDesc->Method.InfoFlags |= ACPI_METHOD_SERIALIZED;
+            MethodDesc->Method.SyncLevel = 0;
         }
 
         /* No more threads, we can free the OwnerId */
 
-        if (!(MethodDesc->Method.Flags & AOPOBJ_MODULE_LEVEL))
+        if (!(MethodDesc->Method.InfoFlags & ACPI_METHOD_MODULE_LEVEL))
         {
             AcpiUtReleaseOwnerId (&MethodDesc->Method.OwnerId);
         }
diff --git a/source/components/events/evrgnini.c b/source/components/events/evrgnini.c
index 9cfeba95c..64363c592 100644
--- a/source/components/events/evrgnini.c
+++ b/source/components/events/evrgnini.c
@@ -729,9 +729,9 @@ AcpiEvInitializeRegion (
                  *
                  * See AcpiNsExecModuleCode
                  */
-                if (ObjDesc->Method.Flags & AOPOBJ_MODULE_LEVEL)
+                if (ObjDesc->Method.InfoFlags & ACPI_METHOD_MODULE_LEVEL)
                 {
-                    HandlerObj = ObjDesc->Method.Extra.Handler;
+                    HandlerObj = ObjDesc->Method.Dispatch.Handler;
                 }
                 break;
 
diff --git a/source/components/executer/excreate.c b/source/components/executer/excreate.c
index fbf75ccc8..9c9071621 100644
--- a/source/components/executer/excreate.c
+++ b/source/components/executer/excreate.c
@@ -595,12 +595,10 @@ AcpiExCreateMethod (
     ObjDesc->Method.AmlLength = AmlLength;
 
     /*
-     * Disassemble the method flags. Split off the Arg Count
-     * for efficiency
+     * Disassemble the method flags. Split off the ArgCount, Serialized
+     * flag, and SyncLevel for efficiency.
      */
     MethodFlags = (UINT8) Operand[1]->Integer.Value;
-
-    ObjDesc->Method.MethodFlags = (UINT8) (MethodFlags & ~AML_METHOD_ARG_COUNT);
     ObjDesc->Method.ParamCount = (UINT8) (MethodFlags & AML_METHOD_ARG_COUNT);
 
     /*
@@ -609,6 +607,8 @@ AcpiExCreateMethod (
      */
     if (MethodFlags & AML_METHOD_SERIALIZED)
     {
+        ObjDesc->Method.InfoFlags = ACPI_METHOD_SERIALIZED;
+
         /*
          * ACPI 1.0: SyncLevel = 0
          * ACPI 2.0: SyncLevel = SyncLevel in method declaration
diff --git a/source/components/executer/exdump.c b/source/components/executer/exdump.c
index d189e4921..44f7d3ba5 100644
--- a/source/components/executer/exdump.c
+++ b/source/components/executer/exdump.c
@@ -216,7 +216,7 @@ static ACPI_EXDUMP_INFO     AcpiExDumpEvent[2] =
 static ACPI_EXDUMP_INFO     AcpiExDumpMethod[9] =
 {
     {ACPI_EXD_INIT,     ACPI_EXD_TABLE_SIZE (AcpiExDumpMethod),         NULL},
-    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Method.MethodFlags),           "Method Flags"},
+    {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Method.InfoFlags),             "Info Flags"},
     {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Method.ParamCount),            "Parameter Count"},
     {ACPI_EXD_UINT8,    ACPI_EXD_OFFSET (Method.SyncLevel),             "Sync Level"},
     {ACPI_EXD_POINTER,  ACPI_EXD_OFFSET (Method.Mutex),                 "Mutex"},
diff --git a/source/components/namespace/nsaccess.c b/source/components/namespace/nsaccess.c
index ce6cdda68..e098e52b0 100644
--- a/source/components/namespace/nsaccess.c
+++ b/source/components/namespace/nsaccess.c
@@ -250,8 +250,8 @@ AcpiNsRootInitialize (
 #else
                 /* Mark this as a very SPECIAL method */
 
-                ObjDesc->Method.MethodFlags = AML_METHOD_INTERNAL_ONLY;
-                ObjDesc->Method.Extra.Implementation = AcpiUtOsiImplementation;
+                ObjDesc->Method.InfoFlags = ACPI_METHOD_INTERNAL_ONLY;
+                ObjDesc->Method.Dispatch.Implementation = AcpiUtOsiImplementation;
 #endif
                 break;
 
diff --git a/source/components/namespace/nsalloc.c b/source/components/namespace/nsalloc.c
index 4081c147a..de9f2293b 100644
--- a/source/components/namespace/nsalloc.c
+++ b/source/components/namespace/nsalloc.c
@@ -341,7 +341,7 @@ AcpiNsInstallNode (
              * modified the namespace. This is used for cleanup when the
              * method exits.
              */
-            WalkState->MethodDesc->Method.Flags |= AOPOBJ_MODIFIED_NAMESPACE;
+            WalkState->MethodDesc->Method.InfoFlags |= ACPI_METHOD_MODIFIED_NAMESPACE;
         }
     }
 
diff --git a/source/components/namespace/nseval.c b/source/components/namespace/nseval.c
index 764fe8bd5..c200e92b0 100644
--- a/source/components/namespace/nseval.c
+++ b/source/components/namespace/nseval.c
@@ -486,7 +486,7 @@ AcpiNsExecModuleCode (
      */
     if ((Type == ACPI_TYPE_DEVICE) && ParentNode->Object)
     {
-        MethodObj->Method.Extra.Handler =
+        MethodObj->Method.Dispatch.Handler =
             ParentNode->Object->Device.Handler;
     }
 
diff --git a/source/components/namespace/nsxfname.c b/source/components/namespace/nsxfname.c
index 16bb29ecd..911fad408 100644
--- a/source/components/namespace/nsxfname.c
+++ b/source/components/namespace/nsxfname.c
@@ -738,11 +738,10 @@ AcpiInstallMethod (
     MethodObj->Method.ParamCount = (UINT8)
         (MethodFlags & AML_METHOD_ARG_COUNT);
 
-    MethodObj->Method.MethodFlags = (UINT8)
-        (MethodFlags & ~AML_METHOD_ARG_COUNT);
-
     if (MethodFlags & AML_METHOD_SERIALIZED)
     {
+        MethodObj->Method.InfoFlags = ACPI_METHOD_SERIALIZED;
+
         MethodObj->Method.SyncLevel = (UINT8)
             ((MethodFlags & AML_METHOD_SYNC_LEVEL) >> 4);
     }
@@ -751,8 +750,7 @@ AcpiInstallMethod (
      * Now that it is complete, we can attach the new method object to
      * the method Node (detaches/deletes any existing object)
      */
-    Status = AcpiNsAttachObject (Node, MethodObj,
-                ACPI_TYPE_METHOD);
+    Status = AcpiNsAttachObject (Node, MethodObj, ACPI_TYPE_METHOD);
 
     /*
      * Flag indicates AML buffer is dynamic, must be deleted later.
diff --git a/source/components/parser/psloop.c b/source/components/parser/psloop.c
index 9b8f1c429..9791efcc7 100644
--- a/source/components/parser/psloop.c
+++ b/source/components/parser/psloop.c
@@ -767,7 +767,7 @@ AcpiPsLinkModuleCode (
         MethodObj->Method.AmlStart = AmlStart;
         MethodObj->Method.AmlLength = AmlLength;
         MethodObj->Method.OwnerId = OwnerId;
-        MethodObj->Method.Flags |= AOPOBJ_MODULE_LEVEL;
+        MethodObj->Method.InfoFlags |= ACPI_METHOD_MODULE_LEVEL;
 
         /*
          * Save the parent node in NextObject. This is cheating, but we
diff --git a/source/components/parser/psparse.c b/source/components/parser/psparse.c
index f13f54183..59af839be 100644
--- a/source/components/parser/psparse.c
+++ b/source/components/parser/psparse.c
@@ -128,7 +128,6 @@
 #include "acparser.h"
 #include "acdispat.h"
 #include "amlcode.h"
-#include "acnamesp.h"
 #include "acinterp.h"
 
 #define _COMPONENT          ACPI_PARSER
@@ -635,23 +634,16 @@ AcpiPsParseAml (
             /* Check for possible multi-thread reentrancy problem */
 
             if ((Status == AE_ALREADY_EXISTS) &&
-                (!WalkState->MethodDesc->Method.Mutex))
+                (!(WalkState->MethodDesc->Method.InfoFlags & ACPI_METHOD_SERIALIZED)))
             {
-                ACPI_INFO ((AE_INFO,
-                    "Marking method %4.4s as Serialized because of AE_ALREADY_EXISTS error",
-                    WalkState->MethodNode->Name.Ascii));
-
                 /*
-                 * Method tried to create an object twice. The probable cause is
-                 * that the method cannot handle reentrancy.
-                 *
-                 * The method is marked NotSerialized, but it tried to create
-                 * a named object, causing the second thread entrance to fail.
-                 * Workaround this problem by marking the method permanently
-                 * as Serialized.
+                 * Method is not serialized and tried to create an object
+                 * twice. The probable cause is that the method cannot
+                 * handle reentrancy. Mark as "pending serialized" now, and
+                 * then mark "serialized" when the last thread exits.
                  */
-                WalkState->MethodDesc->Method.MethodFlags |= AML_METHOD_SERIALIZED;
-                WalkState->MethodDesc->Method.SyncLevel = 0;
+                WalkState->MethodDesc->Method.InfoFlags |=
+                    ACPI_METHOD_SERIALIZED_PENDING;
             }
         }
 
diff --git a/source/components/parser/psxface.c b/source/components/parser/psxface.c
index b45359893..54af31828 100644
--- a/source/components/parser/psxface.c
+++ b/source/components/parser/psxface.c
@@ -121,7 +121,6 @@
 #include "acdispat.h"
 #include "acinterp.h"
 #include "actables.h"
-#include "amlcode.h"
 
 
 #define _COMPONENT          ACPI_PARSER
@@ -399,16 +398,16 @@ AcpiPsExecuteMethod (
         goto Cleanup;
     }
 
-    if (Info->ObjDesc->Method.Flags & AOPOBJ_MODULE_LEVEL)
+    if (Info->ObjDesc->Method.InfoFlags & ACPI_METHOD_MODULE_LEVEL)
     {
         WalkState->ParseFlags |= ACPI_PARSE_MODULE_LEVEL;
     }
 
     /* Invoke an internal method if necessary */
 
-    if (Info->ObjDesc->Method.MethodFlags & AML_METHOD_INTERNAL_ONLY)
+    if (Info->ObjDesc->Method.InfoFlags & ACPI_METHOD_INTERNAL_ONLY)
     {
-        Status = Info->ObjDesc->Method.Extra.Implementation (WalkState);
+        Status = Info->ObjDesc->Method.Dispatch.Implementation (WalkState);
         Info->ReturnObject = WalkState->ReturnDesc;
 
         /* Cleanup states */
diff --git a/source/include/acobject.h b/source/include/acobject.h
index 9c6cfbcb5..6a6ad334e 100644
--- a/source/include/acobject.h
+++ b/source/include/acobject.h
@@ -170,8 +170,6 @@
 #define AOPOBJ_OBJECT_INITIALIZED   0x08    /* Region is initialized, _REG was run */
 #define AOPOBJ_SETUP_COMPLETE       0x10    /* Region setup is complete */
 #define AOPOBJ_INVALID              0x20    /* Host OS won't allow a Region address */
-#define AOPOBJ_MODULE_LEVEL         0x40    /* Method is actually module-level code */
-#define AOPOBJ_MODIFIED_NAMESPACE   0x80    /* Method modified the namespace */
 
 
 /******************************************************************************
@@ -284,7 +282,7 @@ typedef struct acpi_object_region
 typedef struct acpi_object_method
 {
     ACPI_OBJECT_COMMON_HEADER
-    UINT8                           MethodFlags;
+    UINT8                           InfoFlags;
     UINT8                           ParamCount;
     UINT8                           SyncLevel;
     union acpi_operand_object       *Mutex;
@@ -293,7 +291,7 @@ typedef struct acpi_object_method
     {
         ACPI_INTERNAL_METHOD            Implementation;
         union acpi_operand_object       *Handler;
-    } Extra;
+    } Dispatch;
 
     UINT32                          AmlLength;
     UINT8                           ThreadCount;
@@ -301,6 +299,14 @@ typedef struct acpi_object_method
 
 } ACPI_OBJECT_METHOD;
 
+/* Flags for InfoFlags field above */
+
+#define ACPI_METHOD_MODULE_LEVEL        0x01    /* Method is actually module-level code */
+#define ACPI_METHOD_INTERNAL_ONLY       0x02    /* Method is implemented internally (_OSI) */
+#define ACPI_METHOD_SERIALIZED          0x04    /* Method is serialized */
+#define ACPI_METHOD_SERIALIZED_PENDING  0x08    /* Method is to be marked serialized */
+#define ACPI_METHOD_MODIFIED_NAMESPACE  0x10    /* Method modified the namespace */
+
 
 /******************************************************************************
  *
diff --git a/source/include/amlcode.h b/source/include/amlcode.h
index 7e3137f22..df9657f8e 100644
--- a/source/include/amlcode.h
+++ b/source/include/amlcode.h
@@ -579,17 +579,11 @@ typedef enum
 } AML_ACCESS_ATTRIBUTE;
 
 
-/* Bit fields in MethodFlags byte */
+/* Bit fields in the AML MethodFlags byte */
 
 #define AML_METHOD_ARG_COUNT        0x07
 #define AML_METHOD_SERIALIZED       0x08
 #define AML_METHOD_SYNC_LEVEL       0xF0
 
-/* METHOD_FLAGS_ARG_COUNT is not used internally, define additional flags */
-
-#define AML_METHOD_INTERNAL_ONLY    0x01
-#define AML_METHOD_RESERVED1        0x02
-#define AML_METHOD_RESERVED2        0x04
-
 
 #endif /* __AMLCODE_H__ */

