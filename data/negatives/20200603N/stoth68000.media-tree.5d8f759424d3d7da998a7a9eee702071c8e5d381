commit 5d8f759424d3d7da998a7a9eee702071c8e5d381
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Tue Sep 2 15:12:31 2014 -0700

    NFC: trf7970a: Reread FIFO Status Register when draining FIFO
    
    Receiving an interrupt whose Interrupt Status Register
    value has only the SRX bit set is supposed to mean that
    all of the data from the tag has been received.  That
    turns out to not be true so we need to reread the FIFO
    Status Register to tell if there are any new bytes in
    the FIFO.  If there are, continue receiving them; if
    there aren't, assume that the receive is complete and
    pass the data up.
    
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/drivers/nfc/trf7970a.c b/drivers/nfc/trf7970a.c
index 6d2b06ddf191..8c00827893f1 100644
--- a/drivers/nfc/trf7970a.c
+++ b/drivers/nfc/trf7970a.c
@@ -648,6 +648,21 @@ static void trf7970a_drain_fifo(struct trf7970a *trf, u8 status)
 		status = TRF7970A_IRQ_STATUS_SRX;
 	} else {
 		trf->state = TRF7970A_ST_WAIT_FOR_RX_DATA_CONT;
+
+		ret = trf7970a_read(trf, TRF7970A_FIFO_STATUS, &fifo_bytes);
+		if (ret) {
+			trf7970a_send_err_upstream(trf, ret);
+			return;
+		}
+
+		fifo_bytes &= ~TRF7970A_FIFO_STATUS_OVERFLOW;
+
+		/* If there are bytes in the FIFO, set status to '0' so
+		 * the if stmt below doesn't fire and the driver will wait
+		 * for the trf7970a to generate another RX interrupt.
+		 */
+		if (fifo_bytes)
+			status = 0;
 	}
 
 no_rx_data:

