commit 51daa88ebd8e0d437289f589af29d4b39379ea76
Author: Wu Fengguang <fengguang.wu@intel.com>
Date:   Tue Jun 16 15:31:24 2009 -0700

    readahead: remove sync/async readahead call dependency
    
    The readahead call scheme is error-prone in that it expects the call sites
    to check for async readahead after doing a sync one.  I.e.
    
                            if (!page)
                                    page_cache_sync_readahead();
                            page = find_get_page();
                            if (page && PageReadahead(page))
                                    page_cache_async_readahead();
    
    This is because PG_readahead could be set by a sync readahead for the
    _current_ newly faulted in page, and the readahead code simply expects one
    more callback on the same page to start the async readahead.  If the
    caller fails to do so, it will miss the PG_readahead bits and never able
    to start an async readahead.
    
    Eliminate this insane constraint by piggy-backing the async part into the
    current readahead window.
    
    Now if an async readahead should be started immediately after a sync one,
    the readahead logic itself will do it.  So the following code becomes
    valid: (the 'else' in particular)
    
                            if (!page)
                                    page_cache_sync_readahead();
                            else if (PageReadahead(page))
                                    page_cache_async_readahead();
    
    Cc: Nick Piggin <npiggin@suse.de>
    Signed-off-by: Wu Fengguang <fengguang.wu@intel.com>
    Cc: Ying Han <yinghan@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/mm/readahead.c b/mm/readahead.c
index 16378b90843e..d7c6e143a129 100644
--- a/mm/readahead.c
+++ b/mm/readahead.c
@@ -421,6 +421,16 @@ ondemand_readahead(struct address_space *mapping,
 	ra->async_size = ra->size > req_size ? ra->size - req_size : ra->size;
 
 readit:
+	/*
+	 * Will this read hit the readahead marker made by itself?
+	 * If so, trigger the readahead marker hit now, and merge
+	 * the resulted next readahead window into the current one.
+	 */
+	if (offset == ra->start && ra->size == ra->async_size) {
+		ra->async_size = get_next_ra_size(ra, max);
+		ra->size += ra->async_size;
+	}
+
 	return ra_submit(ra, mapping, filp);
 }
 

