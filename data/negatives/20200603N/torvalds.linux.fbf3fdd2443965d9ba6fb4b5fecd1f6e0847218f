commit fbf3fdd2443965d9ba6fb4b5fecd1f6e0847218f
Author: Menyhart Zoltan <Zoltan.Menyhart@bull.net>
Date:   Sun Sep 12 19:55:26 2010 -0400

    statfs() gives ESTALE error
    
    Hi,
    
    An NFS client executes a statfs("file", &buff) call.
    "file" exists / existed, the client has read / written it,
    but it has already closed it.
    
    user_path(pathname, &path) looks up "file" successfully in the
    directory-cache  and restarts the aging timer of the directory-entry.
    Even if "file" has already been removed from the server, because the
    lookupcache=positive option I use, keeps the entries valid for a while.
    
    nfs_statfs() returns ESTALE if "file" has already been removed from the
    server.
    
    If the user application repeats the statfs("file", &buff) call, we
    are stuck: "file" remains young forever in the directory-cache.
    
    Signed-off-by: Zoltan Menyhart  <Zoltan.Menyhart@bull.net>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>
    Cc: stable@kernel.org

diff --git a/fs/nfs/super.c b/fs/nfs/super.c
index ec3966e4706b..f4cbf0c306c6 100644
--- a/fs/nfs/super.c
+++ b/fs/nfs/super.c
@@ -431,7 +431,15 @@ static int nfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 		goto out_err;
 
 	error = server->nfs_client->rpc_ops->statfs(server, fh, &res);
+	if (unlikely(error == -ESTALE)) {
+		struct dentry *pd_dentry;
 
+		pd_dentry = dget_parent(dentry);
+		if (pd_dentry != NULL) {
+			nfs_zap_caches(pd_dentry->d_inode);
+			dput(pd_dentry);
+		}
+	}
 	nfs_free_fattr(res.fattr);
 	if (error < 0)
 		goto out_err;

