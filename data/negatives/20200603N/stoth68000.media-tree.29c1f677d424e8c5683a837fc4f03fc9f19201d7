commit 29c1f677d424e8c5683a837fc4f03fc9f19201d7
Author: Mel Gorman <mel@csn.ul.ie>
Date:   Thu Jan 13 15:47:21 2011 -0800

    mm: migration: use rcu_dereference_protected when dereferencing the radix tree slot during file page migration
    
    migrate_pages() -> unmap_and_move() only calls rcu_read_lock() for
    anonymous pages, as introduced by git commit
    989f89c57e6361e7d16fbd9572b5da7d313b073d ("fix rcu_read_lock() in page
    migraton").  The point of the RCU protection there is part of getting a
    stable reference to anon_vma and is only held for anon pages as file pages
    are locked which is sufficient protection against freeing.
    
    However, while a file page's mapping is being migrated, the radix tree is
    double checked to ensure it is the expected page.  This uses
    radix_tree_deref_slot() -> rcu_dereference() without the RCU lock held
    triggering the following warning.
    
    [  173.674290] ===================================================
    [  173.676016] [ INFO: suspicious rcu_dereference_check() usage. ]
    [  173.676016] ---------------------------------------------------
    [  173.676016] include/linux/radix-tree.h:145 invoked rcu_dereference_check() without protection!
    [  173.676016]
    [  173.676016] other info that might help us debug this:
    [  173.676016]
    [  173.676016]
    [  173.676016] rcu_scheduler_active = 1, debug_locks = 0
    [  173.676016] 1 lock held by hugeadm/2899:
    [  173.676016]  #0:  (&(&inode->i_data.tree_lock)->rlock){..-.-.}, at: [<c10e3d2b>] migrate_page_move_mapping+0x40/0x1ab
    [  173.676016]
    [  173.676016] stack backtrace:
    [  173.676016] Pid: 2899, comm: hugeadm Not tainted 2.6.37-rc5-autobuild
    [  173.676016] Call Trace:
    [  173.676016]  [<c128cc01>] ? printk+0x14/0x1b
    [  173.676016]  [<c1063502>] lockdep_rcu_dereference+0x7d/0x86
    [  173.676016]  [<c10e3db5>] migrate_page_move_mapping+0xca/0x1ab
    [  173.676016]  [<c10e41ad>] migrate_page+0x23/0x39
    [  173.676016]  [<c10e491b>] buffer_migrate_page+0x22/0x107
    [  173.676016]  [<c10e48f9>] ? buffer_migrate_page+0x0/0x107
    [  173.676016]  [<c10e425d>] move_to_new_page+0x9a/0x1ae
    [  173.676016]  [<c10e47e6>] migrate_pages+0x1e7/0x2fa
    
    This patch introduces radix_tree_deref_slot_protected() which calls
    rcu_dereference_protected().  Users of it must pass in the
    mapping->tree_lock that is protecting this dereference.  Holding the tree
    lock protects against parallel updaters of the radix tree meaning that
    rcu_dereference_protected is allowable.
    
    [akpm@linux-foundation.org: remove unneeded casts]
    Signed-off-by: Mel Gorman <mel@csn.ul.ie>
    Cc: Minchan Kim <minchan.kim@gmail.com>
    Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    Cc: Milton Miller <miltonm@bga.com>
    Cc: Nick Piggin <nickpiggin@yahoo.com.au>
    Cc: Wu Fengguang <fengguang.wu@intel.com>
    Cc: <stable@kernel.org>         [2.6.37.early]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/radix-tree.h b/include/linux/radix-tree.h
index ab2baa5c4884..23241c2fecce 100644
--- a/include/linux/radix-tree.h
+++ b/include/linux/radix-tree.h
@@ -145,6 +145,22 @@ static inline void *radix_tree_deref_slot(void **pslot)
 	return rcu_dereference(*pslot);
 }
 
+/**
+ * radix_tree_deref_slot_protected	- dereference a slot without RCU lock but with tree lock held
+ * @pslot:	pointer to slot, returned by radix_tree_lookup_slot
+ * Returns:	item that was stored in that slot with any direct pointer flag
+ *		removed.
+ *
+ * Similar to radix_tree_deref_slot but only used during migration when a pages
+ * mapping is being moved. The caller does not hold the RCU read lock but it
+ * must hold the tree lock to prevent parallel updates.
+ */
+static inline void *radix_tree_deref_slot_protected(void **pslot,
+							spinlock_t *treelock)
+{
+	return rcu_dereference_protected(*pslot, lockdep_is_held(treelock));
+}
+
 /**
  * radix_tree_deref_retry	- check radix_tree_deref_slot
  * @arg:	pointer returned by radix_tree_deref_slot
diff --git a/mm/migrate.c b/mm/migrate.c
index 1a531b760b3b..89a6bc8cd307 100644
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@ -248,7 +248,7 @@ static int migrate_page_move_mapping(struct address_space *mapping,
 
 	expected_count = 2 + page_has_private(page);
 	if (page_count(page) != expected_count ||
-			(struct page *)radix_tree_deref_slot(pslot) != page) {
+		radix_tree_deref_slot_protected(pslot, &mapping->tree_lock) != page) {
 		spin_unlock_irq(&mapping->tree_lock);
 		return -EAGAIN;
 	}
@@ -320,7 +320,7 @@ int migrate_huge_page_move_mapping(struct address_space *mapping,
 
 	expected_count = 2 + page_has_private(page);
 	if (page_count(page) != expected_count ||
-	    (struct page *)radix_tree_deref_slot(pslot) != page) {
+		radix_tree_deref_slot_protected(pslot, &mapping->tree_lock) != page) {
 		spin_unlock_irq(&mapping->tree_lock);
 		return -EAGAIN;
 	}

