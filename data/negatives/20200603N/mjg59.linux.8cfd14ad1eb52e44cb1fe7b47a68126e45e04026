commit 8cfd14ad1eb52e44cb1fe7b47a68126e45e04026
Author: Glauber Costa <glommer@parallels.com>
Date:   Fri Jan 20 04:57:15 2012 +0000

    cgroup: make sure memcg margin is 0 when over limit
    
    For the memcg sock code, we'll need to register allocations
    that are temporarily over limit. Let's make sure that margin
    is 0 in this case.
    
    I am keeping this as a separate patch, so that if any weirdness
    interaction appears in the future, we can now exactly what caused
    it.
    
    Suggested by Johannes Weiner
    
    Signed-off-by: Glauber Costa <glommer@parallels.com>
    CC: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
    CC: Johannes Weiner <hannes@cmpxchg.org>
    CC: Michal Hocko <mhocko@suse.cz>
    CC: Tejun Heo <tj@kernel.org>
    CC: Li Zefan <lizf@cn.fujitsu.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/res_counter.h b/include/linux/res_counter.h
index c9d625ca659e..d06d014afda6 100644
--- a/include/linux/res_counter.h
+++ b/include/linux/res_counter.h
@@ -142,7 +142,10 @@ static inline unsigned long long res_counter_margin(struct res_counter *cnt)
 	unsigned long flags;
 
 	spin_lock_irqsave(&cnt->lock, flags);
-	margin = cnt->limit - cnt->usage;
+	if (cnt->limit > cnt->usage)
+		margin = cnt->limit - cnt->usage;
+	else
+		margin = 0;
 	spin_unlock_irqrestore(&cnt->lock, flags);
 	return margin;
 }

