commit a8894274a3581125fb311eabfc97cd0123740c5e
Author: Brian Foster <bfoster@redhat.com>
Date:   Mon Jul 16 15:23:50 2012 -0400

    fuse: update attributes on aio_read
    
    A fuse-based network filesystem might allow for the inode
    and/or file data to change unexpectedly. A local client
    that opens and repeatedly reads a file might never pick
    up on such changes and indefinitely return stale data.
    
    Always invoke fuse_update_attributes() in the read path
    to cause an attr revalidation when the attributes expire.
    This leads to a page cache invalidation if necessary and
    ensures fuse issues new read requests to the fuse client.
    
    The original logic (reval only on reads beyond EOF) is
    preserved unless the client specifies FUSE_AUTO_INVAL_DATA
    on init.
    
    Signed-off-by: Brian Foster <bfoster@redhat.com>
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index b321a688cde7..5800101e5ce1 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -703,13 +703,16 @@ static ssize_t fuse_file_aio_read(struct kiocb *iocb, const struct iovec *iov,
 				  unsigned long nr_segs, loff_t pos)
 {
 	struct inode *inode = iocb->ki_filp->f_mapping->host;
+	struct fuse_conn *fc = get_fuse_conn(inode);
 
-	if (pos + iov_length(iov, nr_segs) > i_size_read(inode)) {
+	/*
+	 * In auto invalidate mode, always update attributes on read.
+	 * Otherwise, only update if we attempt to read past EOF (to ensure
+	 * i_size is up to date).
+	 */
+	if (fc->auto_inval_data ||
+	    (pos + iov_length(iov, nr_segs) > i_size_read(inode))) {
 		int err;
-		/*
-		 * If trying to read past EOF, make sure the i_size
-		 * attribute is up-to-date.
-		 */
 		err = fuse_update_attributes(inode, NULL, iocb->ki_filp, NULL);
 		if (err)
 			return err;

