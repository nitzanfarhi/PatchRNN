commit 94d5f0c2ae83c367fe870b49ed0c87025be2956e
Author: Anand Jain <Anand.Jain@oracle.com>
Date:   Wed Aug 13 14:24:22 2014 +0800

    btrfs: update sprout seed pointer when seed fs is relinquished
    
    We are not updating sprout fs seed pointer when all seed device
    is replaced. This patch will check if all seed device has been
    replaced and then update the sprout pointer accordingly.
    
    Same reproducer as in the previous patch would apply here.
    And notice that btrfs_close_device will check if seed fs is
    present and spits out the error with out this patch.
    
    int btrfs_close_devices(struct btrfs_fs_devices *fs_devices)
    {
    ::
                    seed_devices = fs_devices->seed;
    ::
            while (seed_devices) {
                    fs_devices = seed_devices;
                    seed_devices = fs_devices->seed;
                    __btrfs_close_devices(fs_devices);
                    free_fs_devices(fs_devices);
            }
    
    Signed-off-by: Anand Jain <anand.jain@oracle.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index 361a66e2c179..27a14f1c5a7c 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -1848,6 +1848,27 @@ void btrfs_rm_dev_replace_srcdev(struct btrfs_fs_info *fs_info,
 	}
 
 	call_rcu(&srcdev->rcu, free_device);
+
+	/*
+	 * unless fs_devices is seed fs, num_devices shouldn't go
+	 * zero
+	 */
+	BUG_ON(!fs_devices->num_devices && !fs_devices->seeding);
+
+	/* if this is no devs we rather delete the fs_devices */
+	if (!fs_devices->num_devices) {
+		struct btrfs_fs_devices *tmp_fs_devices;
+
+		tmp_fs_devices = fs_info->fs_devices;
+		while (tmp_fs_devices) {
+			if (tmp_fs_devices->seed == fs_devices) {
+				tmp_fs_devices->seed = fs_devices->seed;
+				break;
+			}
+			tmp_fs_devices = tmp_fs_devices->seed;
+		}
+		fs_devices->seed = NULL;
+	}
 }
 
 void btrfs_destroy_dev_replace_tgtdev(struct btrfs_fs_info *fs_info,

