commit 039e9362f50d8861520808c8b3fa0f0f1eaea3b0
Author: Michael Richardson <mcr@xelerance.com>
Date:   Thu Mar 13 11:10:55 2008 -0400

    added notification of capability to do IKEv2
    
    Signed-off-by: Michael Richardson <mcr@xelerance.com>

diff --git a/include/ietf_constants.h b/include/ietf_constants.h
index df1d04476..413e4b068 100644
--- a/include/ietf_constants.h
+++ b/include/ietf_constants.h
@@ -845,6 +845,8 @@ typedef enum {
     R_U_THERE =       36136,
     R_U_THERE_ACK =   36137,
 
+    PLUTO_PRIVATE_CAN_IKEV2      = 48917,
+
 
     /* IKEv2 */
     UNSUPPORTED_CRITICAL_PAYLOAD = 1,
diff --git a/lib/libopenswan/constants.c b/lib/libopenswan/constants.c
index 1162c1eeb..ba358285d 100644
--- a/lib/libopenswan/constants.c
+++ b/lib/libopenswan/constants.c
@@ -823,9 +823,17 @@ static const char *const notification_dpd_name[] = {
         "R_U_THERE_ACK",
 };
 
+static const char *const notification_pluto_name[] = {
+    "CAN_IKEv2",
+};
+
+enum_names notification_pluto_names =
+{ PLUTO_PRIVATE_CAN_IKEV2, PLUTO_PRIVATE_CAN_IKEV2,
+  notification_pluto_name, NULL };
+
 enum_names notification_dpd_names =
     { R_U_THERE, R_U_THERE_ACK,
-        notification_dpd_name, NULL };
+        notification_dpd_name, &notification_pluto_names };
 
 enum_names notification_names =
     { INVALID_PAYLOAD_TYPE, UNEQUAL_PAYLOAD_LENGTHS,
diff --git a/programs/pluto/ikev1_main.c b/programs/pluto/ikev1_main.c
index 435224436..052cf5c2e 100644
--- a/programs/pluto/ikev1_main.c
+++ b/programs/pluto/ikev1_main.c
@@ -1980,6 +1980,7 @@ main_inI3_outR3_tail(struct msg_digest *md
     pb_stream r_id_pbs;	/* ID Payload; also used for hash calculation */
     cert_t mycert;
     bool send_cert;
+    unsigned int np;
 
     /* ID and HASH_I or SIG_I in
      * Note: this may switch the connection being used!
@@ -2072,6 +2073,12 @@ main_inI3_outR3_tail(struct msg_digest *md
     }
 #endif
 
+    /* IKEv2 NOTIFY payload */
+    np = ISAKMP_NEXT_NONE;
+    if(st->st_connection->policy & POLICY_IKEV2_ALLOW) {
+	np = ISAKMP_NEXT_N;
+    }
+
     /* HASH_R or SIG_R out */
     {
 	u_char hash_val[MAX_DIGEST_LEN];
@@ -2080,7 +2087,7 @@ main_inI3_outR3_tail(struct msg_digest *md
 	if (auth_payload == ISAKMP_NEXT_HASH)
 	{
 	    /* HASH_R out */
-	    if (!out_generic_raw(ISAKMP_NEXT_NONE, &isakmp_hash_desc, &md->rbody
+	    if (!out_generic_raw(np, &isakmp_hash_desc, &md->rbody
 	    , hash_val, hash_len, "HASH_R"))
 		return STF_INTERNAL_ERROR;
 	}
@@ -2097,12 +2104,25 @@ main_inI3_outR3_tail(struct msg_digest *md
 		return STF_FAIL + AUTHENTICATION_FAILED;
 	    }
 
-	    if (!out_generic_raw(ISAKMP_NEXT_NONE, &isakmp_signature_desc
+	    if (!out_generic_raw(np, &isakmp_signature_desc
 	    , &md->rbody, sig_val, sig_len, "SIG_R"))
 		return STF_INTERNAL_ERROR;
 	}
     }
 
+    if(st->st_connection->policy & POLICY_IKEV2_ALLOW) {
+        struct isakmp_notification isan;
+
+        isan.isan_np = ISAKMP_NEXT_NONE;
+        isan.isan_doi = ISAKMP_DOI_IPSEC;
+        isan.isan_protoid = PROTO_ISAKMP;
+        isan.isan_spisize = 0;
+        isan.isan_type = PLUTO_PRIVATE_CAN_IKEV2;
+        if (!out_struct(&isan, &isakmp_notification_desc, &md->rbody, NULL))
+            return STF_INTERNAL_ERROR;
+    }
+
+
     /* encrypt message, sans fixed part of header */
 
     if (!encrypt_message(&md->rbody, st))

