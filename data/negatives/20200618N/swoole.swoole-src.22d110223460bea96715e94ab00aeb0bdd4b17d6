commit 22d110223460bea96715e94ab00aeb0bdd4b17d6
Author: matyhtf <mikan.tenny@gmail.com>
Date:   Tue Apr 23 21:33:41 2013 +0800

    严重bug.write写成read了

diff --git a/include/swoole.h b/include/swoole.h
index 6b145779..e40e0c1f 100644
--- a/include/swoole.h
+++ b/include/swoole.h
@@ -27,6 +27,7 @@
 #include <pthread.h>
 
 #include "swoole_config.h"
+#include "hashtable.h"
 
 #define SW_MAX_FDS             (1024*10)
 #define SW_THREAD_NUM          2
@@ -62,7 +63,7 @@
 #define sw_realloc             erealloc
 #else
 #define sw_malloc              malloc
-#define sw_free                free
+#define sw_free(s)             free(s)
 #define sw_calloc              calloc
 #define sw_realloc             realloc
 #endif
@@ -99,7 +100,7 @@
 #endif
 
 #ifdef SW_DEBUG
-#define swWarn(str,...)       {printf("[%s:%d:%s]"str,__FILE__,__LINE__,__func__,##__VA_ARGS__);exit(1);}
+#define swWarn(str,...)       {printf("[%s:%d:%s]"str,__FILE__,__LINE__,__func__,##__VA_ARGS__);}
 #else
 #define swWarn(str,...)       {snprintf(sw_error,SW_ERROR_MSG_SIZE,"[%s:%d:%s]"str,__FILE__,__LINE__,__func__,##__VA_ARGS__);}
 #endif
@@ -148,6 +149,13 @@ typedef struct _swEventConnect
 	socklen_t addrlen;
 } swEventConnect;
 
+typedef struct _swHashTable_FdInfo
+{
+	int fd;
+	int key;
+	UT_hash_handle hh;
+} swHashTable_FdInfo;
+
 typedef int (*swHandle)(swEventData *buf);
 typedef void (*swSignalFunc)(int);
 typedef void (*swCallback)(void *);
@@ -225,6 +233,7 @@ int swReactorPoll_create(swReactor *reactor, int max_event_num);
 int swReactorKqueue_create(swReactor *reactor, int max_event_num);
 int swReactorSelect_create(swReactor *reactor);
 
+inline ulong swHashFunc(const char *arKey, uint nKeyLength);
 inline int swRead(int, char *, int);
 inline int swWrite(int, char *, int);
 inline void swSetNonBlock(int);
diff --git a/main.c b/main.c
index 1a728e02..7eb887a9 100644
--- a/main.c
+++ b/main.c
@@ -19,9 +19,10 @@ void p_str(void *str)
 
 int main(int argc, char **argv)
 {
-	u1_test2();
+	//ds_test2();
+	//u1_test2();
 	//ds_test1();
-	//return 0;
+	serv_main();
 	return 0;
 }
 int serv_main()
@@ -34,9 +35,9 @@ int serv_main()
 
 	//config
 	serv.backlog = 128;
-	serv.poll_thread_num = 4;
-	serv.writer_num = 4;
-	serv.worker_num = 4;
+	serv.poll_thread_num = 1;
+	serv.writer_num = 1;
+	serv.worker_num = 1;
 	serv.factory_mode = 2;
 	serv.open_cpu_affinity = 1;
 	serv.open_tcp_nodelay = 1;
@@ -103,7 +104,7 @@ int my_onReceive(swFactory *factory, swEventData *req)
 	ret = factory->finish(factory, &resp);
 	if (ret < 0)
 	{
-
+		swWarn("send to client fail.errno=%d\n", errno);
 	}
 	swTrace("finish\n");
 	return SW_OK;
diff --git a/src/core/Base.c b/src/core/Base.c
index 02df7a78..5e0c0caa 100644
--- a/src/core/Base.c
+++ b/src/core/Base.c
@@ -1,6 +1,35 @@
 #include "swoole.h"
 #include "atomic.h"
 
+inline ulong swHashFunc(const char *arKey, uint nKeyLength)
+{
+	register ulong hash = 5381;
+
+	/* variant with the hash unrolled eight times */
+	for (; nKeyLength >= 8; nKeyLength -= 8) {
+		hash = ((hash << 5) + hash) + *arKey++;
+		hash = ((hash << 5) + hash) + *arKey++;
+		hash = ((hash << 5) + hash) + *arKey++;
+		hash = ((hash << 5) + hash) + *arKey++;
+		hash = ((hash << 5) + hash) + *arKey++;
+		hash = ((hash << 5) + hash) + *arKey++;
+		hash = ((hash << 5) + hash) + *arKey++;
+		hash = ((hash << 5) + hash) + *arKey++;
+	}
+	switch (nKeyLength) {
+		case 7: hash = ((hash << 5) + hash) + *arKey++; /* fallthrough... */
+		case 6: hash = ((hash << 5) + hash) + *arKey++; /* fallthrough... */
+		case 5: hash = ((hash << 5) + hash) + *arKey++; /* fallthrough... */
+		case 4: hash = ((hash << 5) + hash) + *arKey++; /* fallthrough... */
+		case 3: hash = ((hash << 5) + hash) + *arKey++; /* fallthrough... */
+		case 2: hash = ((hash << 5) + hash) + *arKey++; /* fallthrough... */
+		case 1: hash = ((hash << 5) + hash) + *arKey++; break;
+		case 0: break;
+		default: break;
+	}
+	return hash;
+}
+
 void swSpinlock(atomic_t *lock, atomic_int_t value, uint32_t spin)
 {
 	uint32_t i, n;
diff --git a/src/factory/FactoryThread.c b/src/factory/FactoryThread.c
index 91327788..372c7d1f 100644
--- a/src/factory/FactoryThread.c
+++ b/src/factory/FactoryThread.c
@@ -85,6 +85,7 @@ int swFactoryThread_start(swFactory *factory)
 		}
 		if (swRingQueue_init(&this->queues[i], SW_QUEUE_SIZE) < 0)
 		{
+			swTrace("create ring queue fail\n");
 			return SW_ERR;
 		}
 		this->writers[i].ptid = pidt;
@@ -112,8 +113,6 @@ int swFactoryThread_dispatch(swFactory *factory, swEventData *buf)
 	int datasize = sizeof(int)*3 + buf->len;
 	char *data;
 
-	printf("DDD:datasize=%d\n", datasize);
-
 	//使用pti，避免线程切换造成错误的writer_pti
 	pti = this->writer_pti;
 	if (this->writer_pti >= this->writer_num)
@@ -138,6 +137,7 @@ int swFactoryThread_dispatch(swFactory *factory, swEventData *buf)
 	else
 	{
 		ret = this->writers[pti].evfd.write(&this->writers[pti].evfd, &flag, sizeof(flag));
+		swWarn("Send queue notice fail.errno=%d\n", errno);
 		this->writer_pti++;
 		return ret;
 	}
diff --git a/src/network/Server.c b/src/network/Server.c
index 8c2451c5..01be00c1 100644
--- a/src/network/Server.c
+++ b/src/network/Server.c
@@ -222,7 +222,8 @@ int swServer_start(swServer *serv)
 	}
 
 	SW_START_SLEEP;
-	ret = swReactorSelect_create(&main_reactor);
+	//ret = swReactorSelect_create(&main_reactor);
+	ret = swReactorPoll_create(&main_reactor, 10);
 	if (ret < 0)
 	{
 		return SW_ERR;
diff --git a/src/pipe/PipeBase.c b/src/pipe/PipeBase.c
index 40f495f6..300555cf 100644
--- a/src/pipe/PipeBase.c
+++ b/src/pipe/PipeBase.c
@@ -44,13 +44,13 @@ int swPipeBase_create(swPipe *p, int blocking)
 int swPipeBase_read(swPipe *p, void *data, int length)
 {
 	swPipeBase *this = p->object;
-	return swRead(this->pipes[0], data, length);
+	return read(this->pipes[0], data, length);
 }
 
 int swPipeBase_write(swPipe *p, void *data, int length)
 {
 	swPipeBase *this = p->object;
-	return swWrite(this->pipes[1], data, length);
+	return write(this->pipes[1], data, length);
 }
 
 int swPipeBase_getFd(swPipe *p, int isWriteFd)
diff --git a/src/pipe/PipeEventfd.c b/src/pipe/PipeEventfd.c
index feadcf3e..81d74cbf 100644
--- a/src/pipe/PipeEventfd.c
+++ b/src/pipe/PipeEventfd.c
@@ -63,7 +63,7 @@ int swPipeEventfd_write(swPipe *p, void *data, int length)
 	swPipeEventfd *this = p->object;
 	while (1)
 	{
-		ret = read(this->event_fd, data, sizeof(uint64_t));
+		ret = write(this->event_fd, data, sizeof(uint64_t));
 		if (ret < 0)
 		{
 			if (errno == EINTR)
diff --git a/src/reactor/ReactorPoll.c b/src/reactor/ReactorPoll.c
index f448571c..7fe01423 100644
--- a/src/reactor/ReactorPoll.c
+++ b/src/reactor/ReactorPoll.c
@@ -1,13 +1,163 @@
-#include <sys/poll.h>
 #include "swoole.h"
+#include <sys/poll.h>
 
-typedef struct _swReactorPoll
+int swReactorPoll_add(swReactor *reactor, int fd, int fdtype);
+int swReactorPoll_del(swReactor *reactor, int fd);
+int swReactorPoll_wait(swReactor *reactor, struct timeval *timeo);
+void swReactorPoll_free(swReactor *reactor);
+
+typedef struct _swPollFdInfo
 {
+	int fdtype;
+} swPollFdInfo;
 
+typedef struct _swReactorPoll
+{
+	int fd_num;
+	int max_fd_num;
+	swPollFdInfo *fds;
+	struct pollfd *events;
 } swReactorPoll;
 
 int swReactorPoll_add(swReactor *reactor, int fd, int fdtype);
-int swReactorPoll_del(swReactor *reactor, int fd);
 int swReactorPoll_wait(swReactor *reactor, struct timeval *timeo);
 void swReactorPoll_free(swReactor *reactor);
+int swReactorPoll_del(swReactor *reactor, int fd);
+
+int swReactorPoll_create(swReactor *reactor, int max_fd_num)
+{
+	//create reactor object
+	swReactorPoll *this = sw_malloc(sizeof(swReactorPoll));
+	if (this == NULL)
+	{
+		swError("malloc[0] fail\n");
+		return SW_ERR;
+	}
+	this->fds = sw_calloc(max_fd_num, sizeof(swPollFdInfo));
+	if (this->fds == NULL)
+	{
+		swError("malloc[1] fail\n");
+		return SW_ERR;
+	}
+	this->events = sw_calloc(max_fd_num, sizeof(struct pollfd));
+	if (this->events == NULL)
+	{
+		swError("malloc[2] fail\n");
+		return SW_ERR;
+	}
+	this->fd_num = 0;
+	this->max_fd_num = max_fd_num;
+	bzero(reactor->handle, sizeof(reactor->handle));
+	reactor->object = this;
+	//binding method
+	reactor->add = swReactorPoll_add;
+	reactor->del = swReactorPoll_del;
+	reactor->wait = swReactorPoll_wait;
+	reactor->free = swReactorPoll_free;
+	reactor->setHandle = swReactor_setHandle;
+	return SW_OK;
+}
+
+void swReactorPoll_free(swReactor *reactor)
+{
+	swReactorPoll *this = reactor->object;
+	sw_free(this->fds);
+	sw_free(reactor->object);
+}
+
+int swReactorPoll_add(swReactor *reactor, int fd, int fdtype)
+{
+	swReactorPoll *this = reactor->object;
+	int cur = this->fd_num;
+	if(this->fd_num == this->max_fd_num)
+	{
+		swError("too many connection, more than %d\n", this->max_fd_num);
+		return SW_ERR;
+	}
+	this->fds[cur].fdtype = fdtype;
+	this->events[cur].fd = fd;
+	this->events[cur].events = POLLIN;
+	this->fd_num++;
+	return SW_OK;
+}
+
+int swReactorPoll_del(swReactor *reactor, int fd)
+{
+	uint32_t i;
+	swReactorPoll *this = reactor->object;
+
+	for (i = 0; i < this->fd_num; i++)
+	{
+		//找到了
+		if (this->events[i].fd == fd)
+		{
+			uint32_t old_num = this->fd_num;
+			this->fd_num--;
+			for (; i < old_num; i++)
+			{
+				if (i == old_num)
+				{
+					this->fds[i].fdtype = 0;
+					this->events[i].fd = 0;
+					this->events[i].events = 0;
+				}
+				else
+				{
+					this->fds[i] = this->fds[i + 1];
+					this->events[i] = this->events[i + 1];
+				}
+			}
+			return SW_OK;
+		}
+	}
+	return SW_ERR;
+}
+
+int swReactorPoll_wait(swReactor *reactor, struct timeval *timeo)
+{
+	swReactorPoll *this = reactor->object;
+	swEvent event;
+	struct timeval timeout;
+	int ret;
+	int i;
+	int msec = (timeout.tv_sec * 1000) + (timeout.tv_usec / 1000);
 
+	while (swoole_running > 0)
+	{
+		timeout.tv_sec = timeo->tv_sec;
+		timeout.tv_usec = timeo->tv_usec;
+		ret = poll(this->events, this->fd_num, msec);
+		if (ret < 0)
+		{
+			swTrace("select error. Errno=%d\n", errno);
+			if (swReactor_error(reactor) < 0)
+			{
+				return SW_ERR;
+			}
+			else
+			{
+				continue;
+			}
+		}
+		else if (ret == 0)
+		{
+			continue;
+		}
+		else
+		{
+			for (i = 0; i < this->fd_num; i++)
+			{
+				if (this->events[i].revents & POLLIN)
+				{
+					event.fd = this->events[i].fd;
+					event.from_id = reactor->id;
+					event.type = this->fds[i].fdtype;
+					swTrace("Event:Handle=%p|fd=%d|from_id=%d|type=%d\n",
+							reactor->handle[event.type], event.fd, reactor->id, this->fds[i].fdtype);
+					reactor->handle[event.type](reactor, &event);
+				}
+			}
+		}
+	}
+	return SW_OK;
+}
diff --git a/tests/ds.c b/tests/ds.c
index 0840dcfb..3e02c34d 100644
--- a/tests/ds.c
+++ b/tests/ds.c
@@ -4,32 +4,58 @@
 #include "hashtable.h"
 #include "RingMempool.h"
 #include <netinet/tcp.h>
+#include "tests.h"
 
-void p_str(void *str);
+/**
+ * HashTable Test
+ */
+void ds_test2()
+{
+	swHashTable_FdInfo *ht = NULL;
+	swHashTable_FdInfo *pkt, *tmp;
+	int i;
+
+	for (i = 0; i < 10; i++)
+	{
+		pkt = (swHashTable_FdInfo *) malloc(sizeof(swHashTable_FdInfo));
+		pkt->key = i;
+		pkt->fd = i * 34;
+		HASH_ADD_INT(ht, key, pkt);
+	}
+	i = 7;
+	HASH_FIND_INT(ht, &i, tmp);
+	if (tmp != NULL)
+	{
+
+		printf("The key(%d) exists in hash. Fd = %d\n", i, tmp->fd);
+	}
+}
 
 int ds_test1(int argc, char **argv)
 {
 	swRingMempool pool;
-	void *mem = malloc(1024*1024);
+	void *mem = malloc(1024 * 1024);
 	void *item1, *item2, *item3, *item4, *item5;
-	swRingMempool_init(&pool, mem, 1024*1024);
+	swRingMempool_init(&pool, mem, 1024 * 1024);
 
 	item1 = swRingMempool_alloc(&pool, 20);
 	sprintf(item1, "123456789");
-	swRingMempool_resize(&pool, item1, strlen(item1)+1);
+	swRingMempool_resize(&pool, item1, strlen(item1) + 1);
 
 	item2 = swRingMempool_alloc(&pool, 20);
 	sprintf(item2, "12345678901");
-	swRingMempool_resize(&pool, item2, strlen(item2)+1);
+	swRingMempool_resize(&pool, item2, strlen(item2) + 1);
 
 	item3 = swRingMempool_alloc(&pool, 6);
 	sprintf(item3, "12345");
-	swRingMempool_resize(&pool, item3, strlen(item3)+1);
+	swRingMempool_resize(&pool, item3, strlen(item3) + 1);
 
-	p_str(item1);p_str(item2);p_str(item3);
+	p_str(item1);
+	p_str(item2);
+	p_str(item3);
 
 	item4 = swRingMempool_alloc(&pool, 20);
-	if(item4 == NULL)
+	if (item4 == NULL)
 	{
 		printf("Alloc fail\n");
 	}
@@ -37,14 +63,15 @@ int ds_test1(int argc, char **argv)
 	swRingMempool_free(&pool, item2);
 
 	item4 = swRingMempool_alloc(&pool, 20);
-	if(item4 == NULL)
+	if (item4 == NULL)
 	{
 		printf("Alloc fail\n");
 		exit(1);
 	}
 	sprintf(item4, "hello world3.I'm death");
 	swRingMempool_resize(&pool, item4, strlen(item4) + 1);
-	p_str(item4);p_str(item3);
+	p_str(item4);
+	p_str(item3);
 	swRingMempool_free(&pool, item3);
 	swRingMempool_free(&pool, item4);
 

