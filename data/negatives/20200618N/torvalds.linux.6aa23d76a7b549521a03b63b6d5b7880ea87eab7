commit 6aa23d76a7b549521a03b63b6d5b7880ea87eab7
Author: Jeff Layton <jlayton@redhat.com>
Date:   Thu Nov 14 07:25:19 2013 -0500

    nfs: check if gssd is running before attempting to use krb5i auth in SETCLIENTID call
    
    Currently, the client will attempt to use krb5i in the SETCLIENTID call
    even if rpc.gssd isn't running. When that fails, it'll then fall back to
    RPC_AUTH_UNIX. This introduced a delay when mounting if rpc.gssd isn't
    running, and causes warning messages to pop up in the ring buffer.
    
    Check to see if rpc.gssd is running before even attempting to use krb5i
    auth, and just silently skip trying to do so if it isn't. In the event
    that the admin is actually trying to mount with krb5*, it will still
    fail at a later stage of the mount attempt.
    
    Signed-off-by: Jeff Layton <jlayton@redhat.com>
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/nfs4client.c b/fs/nfs/nfs4client.c
index b4a160a405ce..c1b7a80b6704 100644
--- a/fs/nfs/nfs4client.c
+++ b/fs/nfs/nfs4client.c
@@ -10,6 +10,7 @@
 #include <linux/sunrpc/auth.h>
 #include <linux/sunrpc/xprt.h>
 #include <linux/sunrpc/bc_xprt.h>
+#include <linux/sunrpc/rpc_pipe_fs.h>
 #include "internal.h"
 #include "callback.h"
 #include "delegation.h"
@@ -370,7 +371,11 @@ struct nfs_client *nfs4_init_client(struct nfs_client *clp,
 		__set_bit(NFS_CS_INFINITE_SLOTS, &clp->cl_flags);
 	__set_bit(NFS_CS_DISCRTRY, &clp->cl_flags);
 	__set_bit(NFS_CS_NO_RETRANS_TIMEOUT, &clp->cl_flags);
-	error = nfs_create_rpc_client(clp, timeparms, RPC_AUTH_GSS_KRB5I);
+
+	error = -EINVAL;
+	if (gssd_running(clp->cl_net))
+		error = nfs_create_rpc_client(clp, timeparms,
+					      RPC_AUTH_GSS_KRB5I);
 	if (error == -EINVAL)
 		error = nfs_create_rpc_client(clp, timeparms, RPC_AUTH_UNIX);
 	if (error < 0)

