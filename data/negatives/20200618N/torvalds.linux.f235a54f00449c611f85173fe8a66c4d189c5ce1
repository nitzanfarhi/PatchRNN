commit f235a54f00449c611f85173fe8a66c4d189c5ce1
Author: Vincent Guittot <vincent.guittot@linaro.org>
Date:   Sat Jul 1 07:06:13 2017 +0200

    sched/pelt: Fix false running accounting
    
    The running state is a subset of runnable state which means that running
    can't be set if runnable (weight) is cleared. There are corner cases
    where the current sched_entity has been already dequeued but cfs_rq->curr
    has not been updated yet and still points to the dequeued sched_entity.
    If ___update_load_avg() is called at that time, weight will be 0 and running
    will be set which is not possible.
    
    This case happens during pick_next_task_fair() when a cfs_rq becomes idles.
    The current sched_entity has been dequeued so se->on_rq is cleared and
    cfs_rq->weight is null. But cfs_rq->curr still points to se (it will be
    cleared when picking the idle thread). Because the cfs_rq becomes idle,
    idle_balance() is called and ends up to call update_blocked_averages()
    with these wrong running and runnable states.
    
    Add a test in ___update_load_avg() to correct the running state in this case.
    
    Signed-off-by: Vincent Guittot <vincent.guittot@linaro.org>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Morten.Rasmussen@arm.com
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: dietmar.eggemann@arm.com
    Link: http://lkml.kernel.org/r/1498885573-18984-1-git-send-email-vincent.guittot@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
index 75c58c77450a..ef5b66b110f8 100644
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -2990,6 +2990,18 @@ ___update_load_avg(u64 now, int cpu, struct sched_avg *sa,
 
 	sa->last_update_time += delta << 10;
 
+	/*
+	 * running is a subset of runnable (weight) so running can't be set if
+	 * runnable is clear. But there are some corner cases where the current
+	 * se has been already dequeued but cfs_rq->curr still points to it.
+	 * This means that weight will be 0 but not running for a sched_entity
+	 * but also for a cfs_rq if the latter becomes idle. As an example,
+	 * this happens during idle_balance() which calls
+	 * update_blocked_averages()
+	 */
+	if (!weight)
+		running = 0;
+
 	/*
 	 * Now we know we crossed measurement unit boundaries. The *_avg
 	 * accrues by two steps:

