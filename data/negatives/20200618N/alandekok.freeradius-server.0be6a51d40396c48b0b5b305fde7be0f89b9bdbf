commit 0be6a51d40396c48b0b5b305fde7be0f89b9bdbf
Author: Alan T. DeKok <aland@freeradius.org>
Date:   Mon Apr 26 15:32:29 2010 +0200

    More WITH_PROXY fixes

diff --git a/src/modules/rlm_eap/rlm_eap.c b/src/modules/rlm_eap/rlm_eap.c
index 2f9a99115..7f70fe22b 100644
--- a/src/modules/rlm_eap/rlm_eap.c
+++ b/src/modules/rlm_eap/rlm_eap.c
@@ -293,6 +293,7 @@ static int eap_authenticate(void *instance, REQUEST *request)
 		return RLM_MODULE_INVALID;
 	}
 
+#ifdef WITH_PROXY
 	/*
 	 *	If we're doing horrible tunneling work, remember it.
 	 */
@@ -311,8 +312,9 @@ static int eap_authenticate(void *instance, REQUEST *request)
 
 		return RLM_MODULE_HANDLED;
 	}
+#endif
 
-
+#ifdef WITH_PROXY
 	/*
 	 *	Maybe the request was marked to be proxied.  If so,
 	 *	proxy it.
@@ -358,6 +360,7 @@ static int eap_authenticate(void *instance, REQUEST *request)
 		RDEBUG2("  Tunneled session will be proxied.  Not doing EAP.");
 		return RLM_MODULE_HANDLED;
 	}
+#endif
 
 	/*
 	 *	We are done, wrap the EAP-request in RADIUS to send
@@ -457,12 +460,14 @@ static int eap_authorize(void *instance, REQUEST *request)
 
 	inst = (rlm_eap_t *)instance;
 
+#ifdef WITH_PROXY
 	/*
 	 *	We don't do authorization again, once we've seen the
 	 *	proxy reply (or the proxied packet)
 	 */
 	if (request->proxy != NULL)
                 return RLM_MODULE_NOOP;
+#endif
 
 	/*
 	 *	For EAP_START, send Access-Challenge with EAP Identity
@@ -514,6 +519,8 @@ static int eap_authorize(void *instance, REQUEST *request)
 	return RLM_MODULE_UPDATED;
 }
 
+
+#ifdef WITH_PROXY
 /*
  *	If we're proxying EAP, then there may be magic we need
  *	to do.
@@ -675,7 +682,7 @@ static int eap_post_proxy(void *inst, REQUEST *request)
 
 	return RLM_MODULE_UPDATED;
 }
-
+#endif
 
 /*
  *	The module name should be the only globally exported symbol.
@@ -694,7 +701,11 @@ module_t rlm_eap = {
 		NULL,			/* accounting */
 		NULL,			/* checksimul */
 		NULL,			/* pre-proxy */
+#ifdef WITH_PROXY
 		eap_post_proxy,		/* post-proxy */
+#else
+		NULL,
+#endif
 		NULL			/* post-auth */
 	},
 };
diff --git a/src/modules/rlm_eap/types/rlm_eap_mschapv2/rlm_eap_mschapv2.c b/src/modules/rlm_eap/types/rlm_eap_mschapv2/rlm_eap_mschapv2.c
index 20e7875ff..a680445c4 100644
--- a/src/modules/rlm_eap/types/rlm_eap_mschapv2/rlm_eap_mschapv2.c
+++ b/src/modules/rlm_eap/types/rlm_eap_mschapv2/rlm_eap_mschapv2.c
@@ -256,11 +256,13 @@ static int mschapv2_initiate(void *type_data, EAP_HANDLER *handler)
 	eapmschapv2_compose(handler, challenge);
 	pairfree(&challenge);
 
+#ifdef WITH_PROXY
 	/*
 	 *	The EAP session doesn't have enough information to
 	 *	proxy the "inside EAP" protocol.  Disable EAP proxying.
 	 */
 	handler->request->options &= ~RAD_REQUEST_OPTION_PROXY_EAP;
+#endif
 
 	/*
 	 *	We don't need to authorize the user at this point.
@@ -274,7 +276,7 @@ static int mschapv2_initiate(void *type_data, EAP_HANDLER *handler)
 	return 1;
 }
 
-
+#ifdef WITH_PROXY
 /*
  *	Do post-proxy processing,
  *	0 = fail
@@ -350,7 +352,7 @@ static int mschap_postproxy(EAP_HANDLER *handler, void *tunnel_data)
 
 	return 1;
 }
-
+#endif
 
 /*
  *	Authenticate a previously sent challenge.
@@ -454,10 +456,12 @@ static int mschapv2_authenticate(void *arg, EAP_HANDLER *handler)
 			return 0;
 		}
 
+#ifdef WITH_PROXY
 		/*
 		 *	It's a success.  Don't proxy it.
 		 */
 		handler->request->options &= ~RAD_REQUEST_OPTION_PROXY_EAP;
+#endif
 
 		eap_ds->request->code = PW_EAP_SUCCESS;
 		return 1;
@@ -509,6 +513,7 @@ static int mschapv2_authenticate(void *arg, EAP_HANDLER *handler)
 	pairadd(&handler->request->packet->vps, challenge);
 	pairadd(&handler->request->packet->vps, response);
 
+#ifdef WITH_PROXY
 	/*
 	 *	If this options is set, then we do NOT authenticate the
 	 *	user here.  Instead, now that we've added the MS-CHAP
@@ -583,6 +588,7 @@ static int mschapv2_authenticate(void *arg, EAP_HANDLER *handler)
 		 */
 		return 1;
 	}
+#endif
 
 	/*
 	 *	This is a wild & crazy hack.
diff --git a/src/modules/rlm_eap/types/rlm_eap_peap/rlm_eap_peap.c b/src/modules/rlm_eap/types/rlm_eap_peap/rlm_eap_peap.c
index 007f5b0b9..e244c8c8f 100644
--- a/src/modules/rlm_eap/types/rlm_eap_peap/rlm_eap_peap.c
+++ b/src/modules/rlm_eap/types/rlm_eap_peap/rlm_eap_peap.c
@@ -46,11 +46,13 @@ typedef struct rlm_eap_peap_t {
 	 */
 	int	copy_request_to_tunnel;
 
+#ifdef WITH_PROXY
 	/*
 	 *	Proxy tunneled session as EAP, or as de-capsulated
 	 *	protocol.
 	 */
 	int	proxy_tunneled_request_as_eap;
+#endif
 
 	/*
 	 *	Virtual server for inner tunnel session.
@@ -69,8 +71,10 @@ static CONF_PARSER module_config[] = {
 	{ "use_tunneled_reply", PW_TYPE_BOOLEAN,
 	  offsetof(rlm_eap_peap_t, use_tunneled_reply), NULL, "no" },
 
+#ifdef WITH_PROXY
 	{ "proxy_tunneled_request_as_eap", PW_TYPE_BOOLEAN,
 	  offsetof(rlm_eap_peap_t, proxy_tunneled_request_as_eap), NULL, "yes" },
+#endif
 
 	{ "virtual_server", PW_TYPE_STRING_PTR,
 	  offsetof(rlm_eap_peap_t, virtual_server), NULL, NULL },
@@ -160,7 +164,9 @@ static peap_tunnel_t *peap_alloc(rlm_eap_peap_t *inst)
 	t->default_eap_type = inst->default_eap_type;
 	t->copy_request_to_tunnel = inst->copy_request_to_tunnel;
 	t->use_tunneled_reply = inst->use_tunneled_reply;
+#ifdef WITH_PROXY
 	t->proxy_tunneled_request_as_eap = inst->proxy_tunneled_request_as_eap;
+#endif
 	t->virtual_server = inst->virtual_server;
 	t->session_resumption_state = PEAP_RESUMPTION_MAYBE;
 
@@ -325,7 +331,9 @@ static int eappeap_authenticate(void *arg, EAP_HANDLER *handler)
 		 *	will proxy it, rather than returning an EAP packet.
 		 */
 	case RLM_MODULE_UPDATED:
+#ifdef WITH_PROXY
 		rad_assert(handler->request->proxy != NULL);
+#endif
 		return 1;
 		break;
 
diff --git a/src/modules/rlm_eap/types/rlm_eap_ttls/eap_ttls.h b/src/modules/rlm_eap/types/rlm_eap_ttls/eap_ttls.h
index 6bdba3c0b..1525092cd 100644
--- a/src/modules/rlm_eap/types/rlm_eap_ttls/eap_ttls.h
+++ b/src/modules/rlm_eap/types/rlm_eap_ttls/eap_ttls.h
@@ -31,7 +31,7 @@ RCSIDH(eap_ttls_h, "$Id$")
 typedef struct ttls_tunnel_t {
 	VALUE_PAIR	*username;
 	VALUE_PAIR	*state;
-	VALUE_PAIR	*reply;
+	VALUE_PAIR	*accept_vps;
 	int		authenticated;
 	int		default_eap_type;
 	int		copy_request_to_tunnel;
diff --git a/src/modules/rlm_eap/types/rlm_eap_ttls/rlm_eap_ttls.c b/src/modules/rlm_eap/types/rlm_eap_ttls/rlm_eap_ttls.c
index 1a3b3c009..1a7775ca3 100644
--- a/src/modules/rlm_eap/types/rlm_eap_ttls/rlm_eap_ttls.c
+++ b/src/modules/rlm_eap/types/rlm_eap_ttls/rlm_eap_ttls.c
@@ -152,7 +152,7 @@ static void ttls_free(void *p)
 
 	pairfree(&t->username);
 	pairfree(&t->state);
-	pairfree(&t->reply);
+	pairfree(&t->accept_vps);
 	free(t);
 }
 
@@ -211,10 +211,10 @@ static int eapttls_authenticate(void *arg, EAP_HANDLER *handler)
 		}
 
 		if (t && t->authenticated) {
-			if (t->reply) {
-				pairmove(&handler->request->reply->vps,
-					 &t->reply);
-				pairfree(&t->reply);
+			if (t->accept_vps) {
+				pairadd(&handler->request->reply->vps,
+					 &t->accept_vps);
+				pairfree(&t->accept_vps);
 			}
 		do_keys:
 			/*
@@ -292,7 +292,9 @@ static int eapttls_authenticate(void *arg, EAP_HANDLER *handler)
 		 *	will proxy it, rather than returning an EAP packet.
 		 */
 	case PW_STATUS_CLIENT:
+#ifdef WITH_PROXY
 		rad_assert(handler->request->proxy != NULL);
+#endif
 		return 1;
 		break;
 

