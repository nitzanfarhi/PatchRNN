commit ec3eecbf43af93e63a86f4ccda539328aa967fef
Author: Mathias Stearn <mathias@10gen.com>
Date:   Fri Nov 14 16:04:18 2014 -0500

    SERVER-16164 Optimize table scans on wiredtiger

diff --git a/src/mongo/db/exec/collection_scan.cpp b/src/mongo/db/exec/collection_scan.cpp
index 1a2276b752..df49cadb07 100644
--- a/src/mongo/db/exec/collection_scan.cpp
+++ b/src/mongo/db/exec/collection_scan.cpp
@@ -112,12 +112,21 @@ namespace mongo {
         if (isEOF())
             return PlanStage::IS_EOF;
 
+        const DiskLoc curr = _iter->curr();
+        if (curr.isNull()) {
+            // We just hit EOF
+            if (_params.tailable)
+                _iter.reset(); // pick up where we left off on the next call to work()
+            return PlanStage::IS_EOF;
+        }
+
+        _lastSeenLoc = curr;
+
         // See if the record we're about to access is in memory. If not, pass a fetch request up.
-        // Note that curr() returns the same thing as getNext() will, except without advancing the
-        // iterator or touching the DiskLoc. This means that we can use curr() to check whether we
-        // need to fetch on the DiskLoc prior to touching it with getNext().
-        DiskLoc curr = _iter->curr();
-        if (!curr.isNull()) {
+        // Note that curr() does not touch the record (on MMAPv1 which is the only place we use
+        // NEED_FETCH) so we are able to yield before touching the record, as long as we do so
+        // before calling getNext().
+        {
             std::auto_ptr<RecordFetcher> fetcher(
                 _params.collection->documentNeedsFetch(_txn, curr));
             if (NULL != fetcher.get()) {
@@ -131,25 +140,15 @@ namespace mongo {
             }
         }
 
-        // What we'll return to the user.
-        DiskLoc nextLoc;
-
-        // See if _iter gives us anything new.
-        nextLoc = _iter->getNext();
-        if (nextLoc.isNull()) {
-            if (_params.tailable)
-                _iter.reset(); // pick up where we left off on the next call to work()
-            return PlanStage::IS_EOF;
-        }
-
-        _lastSeenLoc = nextLoc;
-
         WorkingSetID id = _workingSet->allocate();
         WorkingSetMember* member = _workingSet->get(id);
-        member->loc = nextLoc;
+        member->loc = curr;
         member->obj = _iter->dataFor(member->loc).releaseToBson();
         member->state = WorkingSetMember::LOC_AND_UNOWNED_OBJ;
 
+        // Advance the iterator.
+        invariant(_iter->getNext() == curr);
+
         return returnIfMatches(member, id, out);
     }
 
diff --git a/src/mongo/db/storage/wiredtiger/wiredtiger_record_store.cpp b/src/mongo/db/storage/wiredtiger/wiredtiger_record_store.cpp
index 82089fe16d..be88959659 100644
--- a/src/mongo/db/storage/wiredtiger/wiredtiger_record_store.cpp
+++ b/src/mongo/db/storage/wiredtiger/wiredtiger_record_store.cpp
@@ -893,11 +893,12 @@ namespace {
             bool forParallelCollectionScan)
         : _rs( rs ),
           _txn( txn ),
-          _dir( dir ),
+          _forward( dir == CollectionScanParams::FORWARD ),
           _forParallelCollectionScan( forParallelCollectionScan ),
-          _cursor( new WiredTigerCursor( rs.GetURI(), rs.instanceId(), txn ) ) {
+          _cursor( new WiredTigerCursor( rs.GetURI(), rs.instanceId(), txn ) ),
+          _eof(false),
+          _readUntilForOplog(WiredTigerRecoveryUnit::get(txn)->getOplogReadTill()) {
         RS_ITERATOR_TRACE("start");
-        _readUntilForOplog = WiredTigerRecoveryUnit::get(txn)->getOplogReadTill();
         _locate(start, true);
     }
 
@@ -910,12 +911,15 @@ namespace {
         invariant( c );
         int ret;
         if (loc.isNull()) {
-            ret = _forward() ? c->next(c) : c->prev(c);
-            if (ret != WT_NOTFOUND) invariantWTOK(ret);
+            ret = _forward ? c->next(c) : c->prev(c);
             _eof = (ret == WT_NOTFOUND);
+            if (!_eof) invariantWTOK(ret);
+            _loc = _curr();
+
             RS_ITERATOR_TRACE("_locate   null loc eof: " << _eof);
             return;
         }
+
         c->set_key(c, _makeKey(loc));
         if (exact) {
             ret = c->search(c);
@@ -928,10 +932,11 @@ namespace {
             ret = c->search_near(c, &cmp);
             if ( ret == WT_NOTFOUND ) {
                 _eof = true;
+                _loc = DiskLoc();
                 return;
             }
             invariantWTOK(ret);
-            if (_forward()) {
+            if (_forward) {
                 // return >= loc
                 if (cmp < 0)
                     ret = c->next(c);
@@ -944,6 +949,7 @@ namespace {
         }
         if (ret != WT_NOTFOUND) invariantWTOK(ret);
         _eof = (ret == WT_NOTFOUND);
+        _loc = _curr();
         RS_ITERATOR_TRACE("_locate   not null loc eof: " << _eof);
     }
 
@@ -959,7 +965,7 @@ namespace {
             return DiskLoc();
 
         WT_CURSOR *c = _cursor->get();
-        invariant( c );
+        dassert( c );
         uint64_t key;
         int ret = c->get_key(c, &key);
         invariantWTOK(ret);
@@ -967,50 +973,54 @@ namespace {
     }
 
     DiskLoc WiredTigerRecordStore::Iterator::curr() {
-        return _curr();
+        return _loc;
     }
 
     void WiredTigerRecordStore::Iterator::_getNext() {
+        // Once you go EOF you never go back.
+        if (_eof) return;
+
         RS_ITERATOR_TRACE("_getNext");
         WT_CURSOR *c = _cursor->get();
-        int ret = _forward() ? c->next(c) : c->prev(c);
-        if (ret != WT_NOTFOUND) invariantWTOK(ret);
+        int ret = _forward ? c->next(c) : c->prev(c);
         _eof = (ret == WT_NOTFOUND);
         RS_ITERATOR_TRACE("_getNext " << ret << " " << _eof );
         if ( !_eof ) {
             RS_ITERATOR_TRACE("_getNext " << ret << " " << _eof << " " << _curr() );
+            invariantWTOK(ret);
+            _loc = _curr();
+            RS_ITERATOR_TRACE("_getNext " << ret << " " << _eof << " " << _loc );
+            if ( _rs._isCapped ) {
+                DiskLoc loc = _curr();
+                if ( _readUntilForOplog.isNull() ) {
+                    // this is the normal capped case
+                    if ( _rs.isCappedHidden( loc ) ) {
+                        _eof = true;
+                    }
+                }
+                else {
+                    // this is for oplogs
+                    if ( loc > _readUntilForOplog ) {
+                        _eof = true;
+                    }
+                    else if ( loc == _readUntilForOplog && _rs.isCappedHidden( loc ) ) {
+                        // we allow if its been commited already
+                        _eof = true;
+                    }
+                }
+            }
+        }
+
+        if (_eof) {
+            _loc = DiskLoc();
         }
     }
 
     DiskLoc WiredTigerRecordStore::Iterator::getNext() {
         RS_ITERATOR_TRACE( "getNext" );
-        /* Take care not to restart a scan if we have hit the end */
-        if (isEOF())
-            return DiskLoc();
-
-        /* MongoDB expects "natural" ordering - which is the order that items are inserted. */
-        DiskLoc toReturn = curr();
+        const DiskLoc toReturn = _loc;
         RS_ITERATOR_TRACE( "getNext toReturn: " << toReturn );
         _getNext();
-        if ( !_eof && _rs.isCapped() ) {
-            DiskLoc loc = _curr();
-            if ( _readUntilForOplog.isNull() ) {
-                // this is the normal capped case
-                if ( _rs.isCappedHidden( loc ) ) {
-                    _eof = true;
-                }
-            }
-            else {
-                // this is for oplogs
-                if ( loc > _readUntilForOplog ) {
-                    _eof = true;
-                }
-                else if ( loc == _readUntilForOplog && _rs.isCappedHidden( loc ) ) {
-                    // we allow if its been commited already
-                    _eof = true;
-                }
-            }
-        }
         RS_ITERATOR_TRACE( " ----" );
         _lastLoc = toReturn;
         return toReturn;
@@ -1067,7 +1077,7 @@ namespace {
             if ( _eof ) {
                 _lastLoc = DiskLoc();
             }
-            else if ( _curr() != saved ) {
+            else if ( _loc != saved ) {
                 // old doc deleted, we're ok
             }
             else {
@@ -1085,14 +1095,13 @@ namespace {
         // Retrieve the data if the iterator is already positioned at loc, otherwise
         // open a new cursor and find the data to avoid upsetting the iterators
         // cursor position.
-        if (loc == _curr())
-            return (_rs._getData(*_cursor));
-        else
-            return (_rs.dataFor( _txn, loc ));
-    }
-
-    bool WiredTigerRecordStore::Iterator::_forward() const {
-        return _dir == CollectionScanParams::FORWARD;
+        if (loc == _loc) {
+            dassert(loc == _curr());
+            return _rs._getData(*_cursor);
+        }
+        else {
+            return _rs.dataFor( _txn, loc );
+        }
     }
 
     void WiredTigerRecordStore::temp_cappedTruncateAfter( OperationContext* txn,
diff --git a/src/mongo/db/storage/wiredtiger/wiredtiger_record_store.h b/src/mongo/db/storage/wiredtiger/wiredtiger_record_store.h
index 142d3ddee1..942900691f 100644
--- a/src/mongo/db/storage/wiredtiger/wiredtiger_record_store.h
+++ b/src/mongo/db/storage/wiredtiger/wiredtiger_record_store.h
@@ -201,21 +201,20 @@ namespace mongo {
             virtual RecordData dataFor( const DiskLoc& loc ) const;
 
         private:
-            bool _forward() const;
             void _getNext();
             void _locate( const DiskLoc &loc, bool exact );
-            void _checkStatus();
             DiskLoc _curr() const; // const version of public curr method
 
             const WiredTigerRecordStore& _rs;
             OperationContext* _txn;
             RecoveryUnit* _savedRecoveryUnit; // only used to sanity check between save/restore
-            CollectionScanParams::Direction _dir;
+            const bool _forward;
             bool _forParallelCollectionScan;
             scoped_ptr<WiredTigerCursor> _cursor;
             bool _eof;
-            DiskLoc _readUntilForOplog;
+            const DiskLoc _readUntilForOplog;
 
+            DiskLoc _loc; // Cached key of _cursor. Update any time _cursor is moved.
             DiskLoc _lastLoc; // the last thing returned from getNext()
         };
 
diff --git a/src/mongo/db/storage/wiredtiger/wiredtiger_recovery_unit.cpp b/src/mongo/db/storage/wiredtiger/wiredtiger_recovery_unit.cpp
index 114e8afb61..8da8ae5772 100644
--- a/src/mongo/db/storage/wiredtiger/wiredtiger_recovery_unit.cpp
+++ b/src/mongo/db/storage/wiredtiger/wiredtiger_recovery_unit.cpp
@@ -257,11 +257,6 @@ namespace mongo {
         _cursor = NULL;
     }
 
-    WT_CURSOR* WiredTigerCursor::get() const {
-        invariant( _session == _ru->getSession() );
-        return _cursor;
-    }
-
     void WiredTigerCursor::reset() {
         invariantWTOK( _cursor->reset( _cursor ) );
     }
diff --git a/src/mongo/db/storage/wiredtiger/wiredtiger_recovery_unit.h b/src/mongo/db/storage/wiredtiger/wiredtiger_recovery_unit.h
index 462e53ca2f..abfc3f8924 100644
--- a/src/mongo/db/storage/wiredtiger/wiredtiger_recovery_unit.h
+++ b/src/mongo/db/storage/wiredtiger/wiredtiger_recovery_unit.h
@@ -122,7 +122,12 @@ namespace mongo {
         WiredTigerCursor(const std::string& uri, uint64_t uriID, WiredTigerRecoveryUnit* ru);
         ~WiredTigerCursor();
 
-        WT_CURSOR* get() const;
+
+        WT_CURSOR* get() const {
+            dassert(_session == _ru->getSession());
+            return _cursor;
+        }
+
         WT_CURSOR* operator->() const { return get(); }
 
         WiredTigerSession* getSession() { return _session; }

