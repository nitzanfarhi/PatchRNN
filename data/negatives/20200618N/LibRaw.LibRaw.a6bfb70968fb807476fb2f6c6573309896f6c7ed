commit a6bfb70968fb807476fb2f6c6573309896f6c7ed
Author: Alex Tutubalin <lexa@lexa.ru>
Date:   Wed Mar 12 13:11:13 2014 +0400

    Nikon sRAW support finalized

diff --git a/dcraw/dcraw.c b/dcraw/dcraw.c
index 37ee07d..3394404 100644
--- a/dcraw/dcraw.c
+++ b/dcraw/dcraw.c
@@ -4762,6 +4762,14 @@ skip_block: ;
 	  sum[c] += val;
 	sum[c+4]++;
       }
+#ifdef LIBRAW_LIBRARY_BUILD
+    if(load_raw == &LibRaw::nikon_load_sraw)
+      {
+        // Nikon sRAW: camera WB already applied:
+        pre_mul[0]=pre_mul[1]=pre_mul[2]=pre_mul[3]=1.0;
+      }
+    else
+#endif
     if (sum[0] && sum[1] && sum[2] && sum[3])
       FORC4 pre_mul[c] = (float) sum[c+4] / sum[c];
     else if (cam_mul[0] && cam_mul[2])
@@ -4776,6 +4784,16 @@ skip_block: ;
 #endif
       }
   }
+#ifdef LIBRAW_LIBRARY_BUILD
+  // Nikon sRAW, daylight
+  if (load_raw == &LibRaw::nikon_load_sraw 
+      && !use_camera_wb && !use_auto_wb 
+      && cam_mul[0] > 0.001f && cam_mul[1] > 0.001f && cam_mul[2] > 0.001f )
+    {
+      for(c=0;c<3;c++)
+        pre_mul[c]/=cam_mul[c];
+  }
+#endif
   if (pre_mul[1] == 0) pre_mul[1] = 1;
   if (pre_mul[3] == 0) pre_mul[3] = colors < 4 ? pre_mul[1] : 1;
   dark = black;
diff --git a/internal/dcraw_common.cpp b/internal/dcraw_common.cpp
index ff97546..e3ae62c 100644
--- a/internal/dcraw_common.cpp
+++ b/internal/dcraw_common.cpp
@@ -3593,12 +3593,14 @@ skip_block: ;
 	  sum[c] += val;
 	sum[c+4]++;
       }
+#ifdef LIBRAW_LIBRARY_BUILD
     if(load_raw == &LibRaw::nikon_load_sraw)
-	{
-		// Nikon sRAW: camera WB already applied:
-		pre_mul[0]=pre_mul[1]=pre_mul[2]=pre_mul[3]=1.0;
-	}
-	else
+      {
+        // Nikon sRAW: camera WB already applied:
+        pre_mul[0]=pre_mul[1]=pre_mul[2]=pre_mul[3]=1.0;
+      }
+    else
+#endif
     if (sum[0] && sum[1] && sum[2] && sum[3])
       FORC4 pre_mul[c] = (float) sum[c+4] / sum[c];
     else if (cam_mul[0] && cam_mul[2])
@@ -3613,13 +3615,16 @@ skip_block: ;
 #endif
       }
   }
+#ifdef LIBRAW_LIBRARY_BUILD
   // Nikon sRAW, daylight
-  if (load_raw == &LibRaw::nikon_load_sraw && !use_camera_wb && cam_mul[0] > 0.001f && cam_mul[1] > 0.001f && cam_mul[2] > 0.001f && !use_auto_wb)
-  {
-	  for(c=0;c<3;c++)
-		  pre_mul[c]/=cam_mul[c];
+  if (load_raw == &LibRaw::nikon_load_sraw 
+      && !use_camera_wb && !use_auto_wb 
+      && cam_mul[0] > 0.001f && cam_mul[1] > 0.001f && cam_mul[2] > 0.001f )
+    {
+      for(c=0;c<3;c++)
+        pre_mul[c]/=cam_mul[c];
   }
-
+#endif
   if (pre_mul[1] == 0) pre_mul[1] = 1;
   if (pre_mul[3] == 0) pre_mul[3] = colors < 4 ? pre_mul[1] : 1;
   dark = black;
diff --git a/internal/dcraw_fileio.cpp b/internal/dcraw_fileio.cpp
index 6abdf19..9e32a15 100644
--- a/internal/dcraw_fileio.cpp
+++ b/internal/dcraw_fileio.cpp
@@ -154,7 +154,7 @@ void CLASS subtract (const char *fname)
   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);
 #endif
 }
-#line 10360 "dcraw/dcraw.c"
+#line 10378 "dcraw/dcraw.c"
 #ifndef NO_LCMS
 void CLASS apply_profile (const char *input, const char *output)
 {
diff --git a/src/libraw_cxx.cpp b/src/libraw_cxx.cpp
index b0fae06..870c5c5 100644
--- a/src/libraw_cxx.cpp
+++ b/src/libraw_cxx.cpp
@@ -514,10 +514,10 @@ int LibRaw::get_decoder_info(libraw_decoder_info_t* d_info)
       d_info->decoder_flags = LIBRAW_DECODER_FLATFIELD | LIBRAW_DECODER_TRYRAWSPEED;
     }
   else if (load_raw == &LibRaw::nikon_load_sraw )
-  {
-	  d_info->decoder_name = "nikon_load_sraw()";
-	  d_info->decoder_flags = LIBRAW_DECODER_LEGACY; 
-  }
+    {
+      d_info->decoder_name = "nikon_load_sraw()";
+      d_info->decoder_flags = LIBRAW_DECODER_LEGACY; 
+    }
   else if (load_raw == &LibRaw::rollei_load_raw )
     {
       // UNTESTED
@@ -986,19 +986,22 @@ int LibRaw::open_datastream(LibRaw_abstract_datastream *stream)
           C.cblack[6+c]/=4;
       }
 
-	if(load_raw == &LibRaw::nikon_load_raw && !strcasecmp(imgdata.idata.make,"Nikon") && !strcasecmp(imgdata.idata.model,"D4s") && imgdata.sizes.raw_width==2464
-		&& imgdata.sizes.raw_height == 1640)
-	{
-		load_raw= &LibRaw::nikon_load_sraw;
-		C.black =0;
-		memset(C.cblack,0,sizeof(C.cblack));
-		imgdata.idata.filters = 0;
-		libraw_internal_data.unpacker_data.tiff_samples=3;
-		imgdata.idata.colors = 3;
-	}
+    if(load_raw == &LibRaw::nikon_load_raw 
+       && !strcasecmp(imgdata.idata.make,"Nikon") 
+       && !strcasecmp(imgdata.idata.model,"D4s") 
+       && imgdata.sizes.raw_width==2464
+       && imgdata.sizes.raw_height == 1640)
+      {
+        load_raw= &LibRaw::nikon_load_sraw;
+        C.black =0;
+        memset(C.cblack,0,sizeof(C.cblack));
+        imgdata.idata.filters = 0;
+        libraw_internal_data.unpacker_data.tiff_samples=3;
+        imgdata.idata.colors = 3;
+      }
 	// Adjust BL for Nikon 14bit
-	else if(load_raw == &LibRaw::nikon_load_raw && !strcasecmp(imgdata.idata.make,"Nikon")
-       && libraw_internal_data.unpacker_data.tiff_bps == 12)
+    else if(load_raw == &LibRaw::nikon_load_raw && !strcasecmp(imgdata.idata.make,"Nikon")
+            && libraw_internal_data.unpacker_data.tiff_bps == 12)
       {
         C.maximum = 4095;
         C.black /=4;
@@ -1009,19 +1012,19 @@ int LibRaw::open_datastream(LibRaw_abstract_datastream *stream)
       }
 
 	// Adjust BL for Panasonic
-	if(load_raw == &LibRaw::panasonic_load_raw && !strcasecmp(imgdata.idata.make,"Panasonic")
-		&& !C.cblack[4] && !C.cblack[5] && C.cblack[6] && C.cblack[7] && C.cblack[8])
-	{
-		C.black=0;
-		C.cblack[0] = C.cblack[6]+C.cblack[9];
-		C.cblack[1] = C.cblack[3] = C.cblack[7]+C.cblack[9];
-		C.cblack[2] = C.cblack[8]+C.cblack[9];
-		C.cblack[6]=C.cblack[7]=C.cblack[8]=C.cblack[9]=0;
-		int i = C.cblack[3];
-		for(int c=0; c<3; c++) if(i>C.cblack[c]) i = C.cblack[c];
-		for(int c=0; c< 4; c++) C.cblack[c]-=i;
-		C.black = i;
-	}
+    if(load_raw == &LibRaw::panasonic_load_raw && !strcasecmp(imgdata.idata.make,"Panasonic")
+       && !C.cblack[4] && !C.cblack[5] && C.cblack[6] && C.cblack[7] && C.cblack[8])
+      {
+        C.black=0;
+        C.cblack[0] = C.cblack[6]+C.cblack[9];
+        C.cblack[1] = C.cblack[3] = C.cblack[7]+C.cblack[9];
+        C.cblack[2] = C.cblack[8]+C.cblack[9];
+        C.cblack[6]=C.cblack[7]=C.cblack[8]=C.cblack[9]=0;
+        int i = C.cblack[3];
+        for(int c=0; c<3; c++) if(i>C.cblack[c]) i = C.cblack[c];
+        for(int c=0; c< 4; c++) C.cblack[c]-=i;
+        C.black = i;
+      }
 
     // Adjust sizes for X3F processing
     if(load_raw == &LibRaw::x3f_load_raw)
@@ -1391,75 +1394,79 @@ int LibRaw::unpack(void)
 
 void LibRaw::nikon_load_sraw()
 {
-	// We're already seeked to data!
-	unsigned char *rd = (unsigned char *)malloc(3*(imgdata.sizes.raw_width+2));
-	if(!rd) throw LIBRAW_EXCEPTION_ALLOC;
-	try {
-		int row,col;
-		for(row = 0; row < imgdata.sizes.raw_height; row++)
-		{
-			checkCancel();
-			libraw_internal_data.internal_data.input->read(rd,3,imgdata.sizes.raw_width);
-			for(col = 0; col < imgdata.sizes.raw_width-1;col+=2)
-			{
-				int bi = col*3;	
-				ushort bits1 = (rd[bi+1] &0xf)<<8| rd[bi]; // 3,0,1
-				ushort bits2 = rd[bi+2] << 4 | ((rd[bi+1]>>4)& 0xf); //452
-				ushort bits3 =  ((rd[bi+4] & 0xf)<<8) | rd[bi+3]; // 967
-				ushort bits4 = rd[bi+5] << 4 | ((rd[bi+4]>>4)& 0xf); // ab8
-				imgdata.image[row*imgdata.sizes.raw_width+col][0]=bits1;
-				imgdata.image[row*imgdata.sizes.raw_width+col][1]=bits3;
-				imgdata.image[row*imgdata.sizes.raw_width+col][2]=bits4;
-				imgdata.image[row*imgdata.sizes.raw_width+col+1][0]=bits2;
-				imgdata.image[row*imgdata.sizes.raw_width+col+1][1]=2048;
-				imgdata.image[row*imgdata.sizes.raw_width+col+1][2]=2048;
-			}
-		}
-	}catch (...) {
-		free(rd);
-		throw ;
-	}
-	free(rd);
-	C.maximum = 0xfff; // 12 bit?
-	if(imgdata.params.sraw_ycc>=2)
-	{
-		return; // no CbCr interpolation
-	}
-	// Interpolate CC channels
-	int row,col;
-	for(row = 0; row < imgdata.sizes.raw_height; row++)
-	{
-		checkCancel(); // will throw out
-		for(col = 0; col < imgdata.sizes.raw_width;col+=2)
-		{
-			int col2 = col<imgdata.sizes.raw_width-2?col+2:col;
-			imgdata.image[row*imgdata.sizes.raw_width+col+1][1]=ushort(int(imgdata.image[row*imgdata.sizes.raw_width+col][1]+imgdata.image[row*imgdata.sizes.raw_width+col2][1])/2);
-			imgdata.image[row*imgdata.sizes.raw_width+col+1][2]=ushort(int(imgdata.image[row*imgdata.sizes.raw_width+col][2]+imgdata.image[row*imgdata.sizes.raw_width+col2][2])/2);
-		}
-	}
-	if(imgdata.params.sraw_ycc>0)
-		return;
-
-	for(row = 0; row < imgdata.sizes.raw_height; row++)
-	{
-		checkCancel(); // will throw out
-		for(col = 0; col < imgdata.sizes.raw_width;col++)
-		{
-			int Y = imgdata.image[row*imgdata.sizes.raw_width+col][0];
-			int Ch2 = imgdata.image[row*imgdata.sizes.raw_width+col][1];
-			int Ch3 = imgdata.image[row*imgdata.sizes.raw_width+col][2];
-			if(Y>2151) Y = 2151;
-			int R = Y + Ch3 - 2048;
-			if(R<0) R=0;
-			int G = Y - (Ch3 - 2048) - (Ch2-2048);
-			if(G<0) G=0;
-			int B = Y + (Ch2-2048);
-			if(B<0) B=0;
-			imgdata.image[row*imgdata.sizes.raw_width+col][0]=R;
-			imgdata.image[row*imgdata.sizes.raw_width+col][1]=G;
-			imgdata.image[row*imgdata.sizes.raw_width+col][2]=B;
-		}
-	}
+  // We're already seeked to data!
+  unsigned char *rd = (unsigned char *)malloc(3*(imgdata.sizes.raw_width+2));
+  if(!rd) throw LIBRAW_EXCEPTION_ALLOC;
+  try {
+    int row,col;
+    for(row = 0; row < imgdata.sizes.raw_height; row++)
+      {
+        checkCancel();
+        libraw_internal_data.internal_data.input->read(rd,3,imgdata.sizes.raw_width);
+        for(col = 0; col < imgdata.sizes.raw_width-1;col+=2)
+          {
+            int bi = col*3;	
+            ushort bits1 = (rd[bi+1] &0xf)<<8| rd[bi]; // 3,0,1
+            ushort bits2 = rd[bi+2] << 4 | ((rd[bi+1]>>4)& 0xf); //452
+            ushort bits3 =  ((rd[bi+4] & 0xf)<<8) | rd[bi+3]; // 967
+            ushort bits4 = rd[bi+5] << 4 | ((rd[bi+4]>>4)& 0xf); // ab8
+            imgdata.image[row*imgdata.sizes.raw_width+col][0]=bits1;
+            imgdata.image[row*imgdata.sizes.raw_width+col][1]=bits3;
+            imgdata.image[row*imgdata.sizes.raw_width+col][2]=bits4;
+            imgdata.image[row*imgdata.sizes.raw_width+col+1][0]=bits2;
+            imgdata.image[row*imgdata.sizes.raw_width+col+1][1]=2048;
+            imgdata.image[row*imgdata.sizes.raw_width+col+1][2]=2048;
+          }
+      }
+  }catch (...) {
+    free(rd);
+    throw ;
+  }
+  free(rd);
+  C.maximum = 0xfff; // 12 bit?
+  if(imgdata.params.sraw_ycc>=2)
+    {
+      return; // no CbCr interpolation
+    }
+  // Interpolate CC channels
+  int row,col;
+  for(row = 0; row < imgdata.sizes.raw_height; row++)
+    {
+      checkCancel(); // will throw out
+      for(col = 0; col < imgdata.sizes.raw_width;col+=2)
+        {
+          int col2 = col<imgdata.sizes.raw_width-2?col+2:col;
+          imgdata.image[row*imgdata.sizes.raw_width+col+1][1]
+            =(unsigned short)(int(imgdata.image[row*imgdata.sizes.raw_width+col][1]
+                                  +imgdata.image[row*imgdata.sizes.raw_width+col2][1])/2);
+          imgdata.image[row*imgdata.sizes.raw_width+col+1][2]
+            =(unsigned short)(int(imgdata.image[row*imgdata.sizes.raw_width+col][2]
+                                  +imgdata.image[row*imgdata.sizes.raw_width+col2][2])/2);
+        }
+    }
+  if(imgdata.params.sraw_ycc>0)
+    return;
+  
+  for(row = 0; row < imgdata.sizes.raw_height; row++)
+    {
+      checkCancel(); // will throw out
+      for(col = 0; col < imgdata.sizes.raw_width;col++)
+        {
+          int Y = imgdata.image[row*imgdata.sizes.raw_width+col][0];
+          int Ch2 = imgdata.image[row*imgdata.sizes.raw_width+col][1];
+          int Ch3 = imgdata.image[row*imgdata.sizes.raw_width+col][2];
+          if(Y>2151) Y = 2151;
+          int R = Y + Ch3 - 2048;
+          if(R<0) R=0;
+          int G = Y - (Ch3 - 2048) - (Ch2-2048);
+          if(G<0) G=0;
+          int B = Y + (Ch2-2048);
+          if(B<0) B=0;
+          imgdata.image[row*imgdata.sizes.raw_width+col][0]=R;
+          imgdata.image[row*imgdata.sizes.raw_width+col][1]=G;
+          imgdata.image[row*imgdata.sizes.raw_width+col][2]=B;
+        }
+    }
 }
 
 void LibRaw::free_image(void)

