commit e3ee9e5ec17767a24848035a1d759af8a03c971f
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Feb 8 08:43:41 2010 -0200

    V4L/DVB: tm6000: move board-specific init to tm6000-cards
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/staging/tm6000/tm6000-cards.c b/drivers/staging/tm6000/tm6000-cards.c
index 0a70c19df9e3..e09d75707714 100644
--- a/drivers/staging/tm6000/tm6000-cards.c
+++ b/drivers/staging/tm6000/tm6000-cards.c
@@ -297,6 +297,78 @@ int tm6000_tuner_callback(void *ptr, int component, int command, int arg)
 	return (rc);
 }
 
+int tm6000_cards_setup(struct tm6000_core *dev)
+{
+	int i, rc;
+
+	/*
+	 * Board-specific initialization sequence. Handles all GPIO
+	 * initialization sequences that are board-specific.
+	 * Up to now, all found devices use GPIO1 and GPIO4 at the same way.
+	 * Probably, they're all based on some reference device. Due to that,
+	 * there's a common routine at the end to handle those GPIO's. Devices
+	 * that use different pinups or init sequences can just return at
+	 * the board-specific session.
+	 */
+	switch (dev->model) {
+	case TM6010_BOARD_HAUPPAUGE_900H:
+		/* Turn xceive 3028 on */
+		tm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN, TM6010_GPIO_3, 0x01);
+		msleep(11);
+		break;
+	default:
+		break;
+	}
+
+	/*
+	 * Default initialization. Most of the devices seem to use GPIO1
+	 * and GPIO4.on the same way, so, this handles the common sequence
+	 * used by most devices.
+	 * If a device uses a different sequence or different GPIO pins for
+	 * reset, just add the code at the board-specific part
+	 */
+	for (i = 0; i < 2; i++) {
+		rc = tm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,
+					dev->tuner_reset_gpio, 0x00);
+		if (rc < 0) {
+			printk(KERN_ERR "Error %i doing GPIO1 reset\n", rc);
+			return rc;
+		}
+
+		msleep(10); /* Just to be conservative */
+		rc = tm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,
+					dev->tuner_reset_gpio, 0x01);
+		if (rc < 0) {
+			printk(KERN_ERR "Error %i doing GPIO1 reset\n", rc);
+			return rc;
+		}
+
+		msleep(10);
+		rc = tm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN, TM6000_GPIO_4, 0);
+		if (rc < 0) {
+			printk(KERN_ERR "Error %i doing GPIO4 reset\n", rc);
+			return rc;
+		}
+
+		msleep(10);
+		rc = tm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN, TM6000_GPIO_4, 1);
+		if (rc < 0) {
+			printk(KERN_ERR "Error %i doing GPIO4 reset\n", rc);
+			return rc;
+		}
+
+		if (!i) {
+			rc = tm6000_get_reg16(dev, 0x40, 0, 0);
+			if (rc >= 0)
+				printk(KERN_DEBUG "board=%d\n", rc);
+		}
+	}
+
+	msleep(50);
+
+	return 0;
+};
+
 static void tm6000_config_tuner (struct tm6000_core *dev)
 {
 	struct tuner_setup           tun_setup;
diff --git a/drivers/staging/tm6000/tm6000-core.c b/drivers/staging/tm6000/tm6000-core.c
index bc9ec2c9e202..9d66a3fc091d 100644
--- a/drivers/staging/tm6000/tm6000-core.c
+++ b/drivers/staging/tm6000/tm6000-core.c
@@ -453,54 +453,9 @@ int tm6000_init (struct tm6000_core *dev)
 		printk (KERN_ERR "Error %i while retrieving board version\n",board);
 	}
 
-	if (dev->dev_type == TM6010) {
-		/* Turn xceive 3028 on */
-		tm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN, TM6010_GPIO_3, 0x01);
-		msleep(11);
-	}
-
-	/* Reset GPIO1 and GPIO4. */
-	for (i=0; i< 2; i++) {
-		rc = tm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,
-					dev->tuner_reset_gpio, 0x00);
-		if (rc<0) {
-			printk (KERN_ERR "Error %i doing GPIO1 reset\n",rc);
-			return rc;
-		}
-
-		msleep(10); /* Just to be conservative */
-		rc = tm6000_set_reg(dev, REQ_03_SET_GET_MCU_PIN,
-					dev->tuner_reset_gpio, 0x01);
-		if (rc<0) {
-			printk (KERN_ERR "Error %i doing GPIO1 reset\n",rc);
-			return rc;
-		}
-
-		msleep(10);
-		rc=tm6000_set_reg (dev, REQ_03_SET_GET_MCU_PIN, TM6000_GPIO_4, 0);
-		if (rc<0) {
-			printk (KERN_ERR "Error %i doing GPIO4 reset\n",rc);
-			return rc;
-		}
-
-		msleep(10);
-		rc=tm6000_set_reg (dev, REQ_03_SET_GET_MCU_PIN, TM6000_GPIO_4, 1);
-		if (rc<0) {
-			printk (KERN_ERR "Error %i doing GPIO4 reset\n",rc);
-			return rc;
-		}
+	rc = tm6000_cards_setup(dev);
 
-		if (!i) {
-			rc=tm6000_get_reg16(dev, 0x40,0,0);
-			if (rc>=0) {
-				printk ("board=%d\n", rc);
-			}
-		}
-	}
-
-	msleep(50);
-
-	return 0;
+	return rc;
 }
 
 int tm6000_set_audio_bitrate(struct tm6000_core *dev, int bitrate)
diff --git a/drivers/staging/tm6000/tm6000.h b/drivers/staging/tm6000/tm6000.h
index b4b603204ed4..3ec5704092fc 100644
--- a/drivers/staging/tm6000/tm6000.h
+++ b/drivers/staging/tm6000/tm6000.h
@@ -206,11 +206,14 @@ struct tm6000_fh {
 /* In tm6000-cards.c */
 
 int tm6000_tuner_callback (void *ptr, int component, int command, int arg);
+int tm6000_cards_setup(struct tm6000_core *dev);
+
 /* In tm6000-core.c */
 
 int tm6000_read_write_usb (struct tm6000_core *dev, u8 reqtype, u8 req,
 			   u16 value, u16 index, u8 *buf, u16 len);
 int tm6000_get_reg (struct tm6000_core *dev, u8 req, u16 value, u16 index);
+int tm6000_get_reg16(struct tm6000_core *dev, u8 req, u16 value, u16 index);
 int tm6000_set_reg (struct tm6000_core *dev, u8 req, u16 value, u16 index);
 int tm6000_init (struct tm6000_core *dev);
 

