commit 4480e0df2a3d2fe2b63770e61d9cfd9fbe7d36fb
Author: Ken Raeburn <raeburn@mit.edu>
Date:   Tue Jul 22 19:34:24 2008 +0000

    Catch a few more cases of unchecked k5_mutex_lock calls
    
    ticket: 5962
    
    git-svn-id: svn://anonsvn.mit.edu/krb5/trunk@20567 dc483132-0cff-0310-8789-dd5450dbe970

diff --git a/src/lib/krb5/keytab/kt_file.c b/src/lib/krb5/keytab/kt_file.c
index 1baa80096..8137cf991 100644
--- a/src/lib/krb5/keytab/kt_file.c
+++ b/src/lib/krb5/keytab/kt_file.c
@@ -537,7 +537,9 @@ krb5_ktfile_end_get(krb5_context context, krb5_keytab id, krb5_kt_cursor *cursor
     krb5_error_code kerror;
 
     krb5_xfree(*cursor);
-    KTLOCK(id);
+    kerror = KTLOCK(id);
+    if (kerror)
+	return kerror;
     KTITERS(id)--;
     if (KTFILEP(id) != NULL && KTITERS(id) == 0)
 	kerror = krb5_ktfileint_close(context, id);
diff --git a/src/plugins/kdb/ldap/libkdb_ldap/kdb_ldap_conn.c b/src/plugins/kdb/ldap/libkdb_ldap/kdb_ldap_conn.c
index 8494681a1..08311e89b 100644
--- a/src/plugins/kdb/ldap/libkdb_ldap/kdb_ldap_conn.c
+++ b/src/plugins/kdb/ldap/libkdb_ldap/kdb_ldap_conn.c
@@ -203,7 +203,9 @@ krb5_ldap_db_init(krb5_context context, krb5_ldap_context *ldap_context)
     ldap_set_option(NULL, LDAP_X_OPT_CONNECT_TIMEOUT, &local_timelimit);
 #endif
 
-    HNDL_LOCK(ldap_context);
+    st = HNDL_LOCK(ldap_context);
+    if (st)
+	return st;
     while (ldap_context->server_info_list[cnt] != NULL) {
 	krb5_ldap_server_info *server_info=NULL;
 
diff --git a/src/plugins/kdb/ldap/libkdb_ldap/ldap_handle.c b/src/plugins/kdb/ldap/libkdb_ldap/ldap_handle.c
index 6f8e73d0e..dac02498d 100644
--- a/src/plugins/kdb/ldap/libkdb_ldap/ldap_handle.c
+++ b/src/plugins/kdb/ldap/libkdb_ldap/ldap_handle.c
@@ -223,7 +223,9 @@ krb5_ldap_request_handle_from_pool(ldap_context, ldap_server_handle)
 
     *ldap_server_handle = NULL;
 
-    HNDL_LOCK(ldap_context);
+    st = HNDL_LOCK(ldap_context);
+    if (st)
+	return st;
     if (((*ldap_server_handle)=krb5_get_ldap_handle(ldap_context)) == NULL)
 	(*ldap_server_handle)=krb5_retry_get_ldap_handle(ldap_context, &st);
     HNDL_UNLOCK(ldap_context);
@@ -242,7 +244,9 @@ krb5_ldap_request_next_handle_from_pool(ldap_context, ldap_server_handle)
 {
     krb5_error_code            st=0;
 
-    HNDL_LOCK(ldap_context);
+    st = HNDL_LOCK(ldap_context);
+    if (st)
+	return st;
     (*ldap_server_handle)->server_info->server_status = OFF;
     time(&(*ldap_server_handle)->server_info->downtime);
     krb5_put_ldap_handle(*ldap_server_handle);
@@ -263,11 +267,11 @@ krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle)
     krb5_ldap_context          *ldap_context;
     krb5_ldap_server_handle    *ldap_server_handle;
 {
-
     if (ldap_server_handle != NULL) {
-	HNDL_LOCK(ldap_context);
-	krb5_put_ldap_handle(ldap_server_handle);
-	HNDL_UNLOCK(ldap_context);
+	if (HNDL_LOCK(ldap_context) == 0) {
+	    krb5_put_ldap_handle(ldap_server_handle);
+	    HNDL_UNLOCK(ldap_context);
+	}
     }
     return;
 }
diff --git a/src/util/support/errors.c b/src/util/support/errors.c
index 36ea11c3a..d1aa485c5 100644
--- a/src/util/support/errors.c
+++ b/src/util/support/errors.c
@@ -85,9 +85,11 @@ krb5int_get_error (struct errinfo *ep, long code)
 	ep->msg = NULL;
 	return ep->scratch_buf;
     }
-    lock();
+    if (lock())
+	goto no_fptr;
     if (fptr == NULL) {
 	unlock();
+    no_fptr:
 #ifdef HAVE_STRERROR_R
 	if (strerror_r (code, ep->scratch_buf, sizeof(ep->scratch_buf)) == 0) {
 	    char *p = strdup(ep->scratch_buf);
@@ -157,7 +159,8 @@ void
 krb5int_set_error_info_callout_fn (const char *(KRB5_CALLCONV *f)(long))
 {
     initialize();
-    lock();
-    fptr = f;
-    unlock();
+    if (lock() == 0) {
+	fptr = f;
+	unlock();
+    }
 }

