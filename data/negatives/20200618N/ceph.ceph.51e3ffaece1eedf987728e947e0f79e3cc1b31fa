commit 51e3ffaece1eedf987728e947e0f79e3cc1b31fa
Author: Yehuda Sadeh <yehuda@redhat.com>
Date:   Fri Jan 23 09:27:38 2015 -0800

    rgw: reorder bucket cleanup on bucket overwrite
    
    First read the new instance info, then remove it, not the other way
    around. Artifact of bucket sharding merge with object versioning.
    
    Signed-off-by: Yehuda Sadeh <yehuda@redhat.com>

diff --git a/src/rgw/rgw_rados.cc b/src/rgw/rgw_rados.cc
index 4aea14b993..cdeb259f62 100644
--- a/src/rgw/rgw_rados.cc
+++ b/src/rgw/rgw_rados.cc
@@ -2479,13 +2479,6 @@ int RGWRados::create_bucket(RGWUserInfo& owner, rgw_bucket& bucket,
 
       /* only remove it if it's a different bucket instance */
       if (info.bucket.bucket_id != bucket.bucket_id) {
-        /* remove bucket meta instance */
-        string entry;
-        get_bucket_instance_entry(bucket, entry);
-        r = rgw_bucket_instance_remove_entry(this, entry, &instance_ver);
-        if (r < 0)
-          return r;
-
         /* remove bucket index */
         librados::IoCtx index_ctx; // context for new bucket
         map<int, string> bucket_objs;
@@ -2493,6 +2486,13 @@ int RGWRados::create_bucket(RGWUserInfo& owner, rgw_bucket& bucket,
         if (r < 0)
           return r;
 
+        /* remove bucket meta instance */
+        string entry;
+        get_bucket_instance_entry(bucket, entry);
+        r = rgw_bucket_instance_remove_entry(this, entry, &instance_ver);
+        if (r < 0)
+          return r;
+
         map<int, string>::const_iterator biter;
         for (biter = bucket_objs.begin(); biter != bucket_objs.end(); ++biter) {
           // Do best effort removal

