commit 461686c359e383739b8e0d23c68520a0e2e2c361
Author: Roland Mainz <roland.mainz@nexenta.com <none@none>
Date:   Thu Feb 17 14:49:38 2011 -0800

    702 tput calls gets()
    703 hashmake calls gets() but should use fgets().
    Reviewed by: Dan McDonald <danmcd@nexenta.com>
    Reviewed by: Olga Kryzhanoska <olga.kryzhanovska@gmail.com>
    Approved by: Garrett D'Amore <garrett@nexenta.com>

diff --git a/usr/src/cmd/spell/hashmake.c b/usr/src/cmd/spell/hashmake.c
index 3b7d3f5356..844f205841 100644
--- a/usr/src/cmd/spell/hashmake.c
+++ b/usr/src/cmd/spell/hashmake.c
@@ -26,8 +26,7 @@
 
 /*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
 /*	  All Rights Reserved  	*/
-
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
+/* Copyright 2011 Nexenta Systems, Inc.  All rights reserved. */
 
 #include <stdlib.h>
 #include <unistd.h>
@@ -51,7 +50,7 @@ main(int argc, char **argv)
 	(void) textdomain(TEXT_DOMAIN);
 
 	hashinit();
-	while (gets(word)) {
+	while (fgets(word, sizeof (word), stdin)) {
 		(void) printf("%.*lo\n", (HASHWIDTH+2)/3, hash(word));
 	}
 	return (0);
diff --git a/usr/src/cmd/tput/tput.c b/usr/src/cmd/tput/tput.c
index 18dce8d6cb..34e8ab120d 100644
--- a/usr/src/cmd/tput/tput.c
+++ b/usr/src/cmd/tput/tput.c
@@ -23,6 +23,7 @@
  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
+/* Copyright 2011 Nexenta Systems, Inc.  All rights reserved. */
 
 /*	Copyright (c) 1988 AT&T	*/
 /*	  All Rights Reserved  	*/
@@ -58,6 +59,7 @@
 #include <sys/types.h>
 #include <unistd.h>
 #include <locale.h>
+#include <err.h>
 
 /* externs from libcurses */
 extern int tigetnum();
@@ -166,15 +168,23 @@ main(int argc, char **argv)
 			exit(outputcap(cap, argc, argv));
 		return (0);
 	} else {			/* standard input argumets	*/
-		char buff[128];
+		char buff[256];
 		char **v;
 
-		/* allocate storage for the 'faked' argv[] array	*/
+		/*
+		 * allocate storage for the 'faked' argv[] array
+		 *
+		 * fixme: The algorithm here is botched. Who or what defines
+		 * that only 10 arguments with 32 bytes each are passed?
+		 */
 		v = (char **)malloc(10 * sizeof (char *));
-		for (i = 0; i < 10; i++)
-			v[i] = (char *)malloc(32 * sizeof (char));
+		for (i = 0; i < 10; i++) {
+			v[i] = (char *)malloc(32);
+			if (!v[i])
+				err(EXIT_FAILURE, "no memory for argv[] array");
+		}
 
-		while (gets(buff) != NULL) {
+		while (fgets(buff, sizeof (buff), stdin) != NULL) {
 			/* read standard input line; skip over empty lines */
 			if ((std_argc =
 			    sscanf(buff, "%s %s %s %s %s %s %s %s %s %s",

