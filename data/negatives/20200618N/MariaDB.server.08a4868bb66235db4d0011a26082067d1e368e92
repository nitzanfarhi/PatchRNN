commit 08a4868bb66235db4d0011a26082067d1e368e92
Author: unknown <sergefp@mysql.com>
Date:   Fri Nov 25 20:47:22 2005 +0300

    BUG#15024: get_best_covering_ror_intersect() tries to build ROR-intersection
    by starting with an empty index set and adding indexes to it until it
    becomes covering. If the set becomes covering after adding the first index,
    return NULL and don't try constructing ROR-intersection of one index (which
    caused a crash)

diff --git a/sql/opt_range.cc b/sql/opt_range.cc
index 323e829f219..bf7eb370e42 100644
--- a/sql/opt_range.cc
+++ b/sql/opt_range.cc
@@ -3136,10 +3136,10 @@ TRP_ROR_INTERSECT *get_best_covering_ror_intersect(PARAM *param,
     /* F=F-covered by first(I) */
     bitmap_union(&covered_fields, &(*ror_scan_mark)->covered_fields);
     all_covered= bitmap_is_subset(&param->needed_fields, &covered_fields);
-  } while (!all_covered && (++ror_scan_mark < ror_scans_end));
-
-  if (!all_covered)
-    DBUG_RETURN(NULL); /* should not happen actually */
+  } while ((++ror_scan_mark < ror_scans_end) && !all_covered);
+  
+  if (!all_covered || (ror_scan_mark - tree->ror_scans) == 1)
+    DBUG_RETURN(NULL);
 
   /*
     Ok, [tree->ror_scans .. ror_scan) holds covering index_intersection with

