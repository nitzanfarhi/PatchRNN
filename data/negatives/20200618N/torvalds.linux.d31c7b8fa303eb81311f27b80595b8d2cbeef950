commit d31c7b8fa303eb81311f27b80595b8d2cbeef950
Author: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
Date:   Fri Nov 30 23:36:08 2007 +1100

    [IPV6]: Restore IPv6 when MTU is big enough
    
    Avaid provided test application, so bug got fixed.
    
    IPv6 addrconf removes ipv6 inner device from netdev each time cmu
    changes and new value is less than IPV6_MIN_MTU (1280 bytes).
    When mtu is changed and new value is greater than IPV6_MIN_MTU,
    it does not add ipv6 addresses and inner device bac.
    
    This patch fixes that.
    
    Tested with Avaid's application, which works ok now.
    
    Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index 567664eac463..e8c347579da9 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -2293,6 +2293,9 @@ static int addrconf_notify(struct notifier_block *this, unsigned long event,
 				break;
 			}
 
+			if (!idev && dev->mtu >= IPV6_MIN_MTU)
+				idev = ipv6_add_dev(dev);
+
 			if (idev)
 				idev->if_flags |= IF_READY;
 		} else {
@@ -2357,12 +2360,18 @@ static int addrconf_notify(struct notifier_block *this, unsigned long event,
 		break;
 
 	case NETDEV_CHANGEMTU:
-		if ( idev && dev->mtu >= IPV6_MIN_MTU) {
+		if (idev && dev->mtu >= IPV6_MIN_MTU) {
 			rt6_mtu_change(dev, dev->mtu);
 			idev->cnf.mtu6 = dev->mtu;
 			break;
 		}
 
+		if (!idev && dev->mtu >= IPV6_MIN_MTU) {
+			idev = ipv6_add_dev(dev);
+			if (idev)
+				break;
+		}
+
 		/* MTU falled under IPV6_MIN_MTU. Stop IPv6 on this interface. */
 
 	case NETDEV_DOWN:

