commit f73a7eee900e95404b61408a23a1df5c5811704c
Author: KarimAllah Ahmed <karahmed@amazon.de>
Date:   Fri May 5 11:39:59 2017 -0700

    iommu/vt-d: Flush the IOTLB to get rid of the initial kdump mappings
    
    Ever since commit 091d42e43d ("iommu/vt-d: Copy translation tables from
    old kernel") the kdump kernel copies the IOMMU context tables from the
    previous kernel. Each device mappings will be destroyed once the driver
    for the respective device takes over.
    
    This unfortunately breaks the workflow of mapping and unmapping a new
    context to the IOMMU. The mapping function assumes that either:
    
    1) Unmapping did the proper IOMMU flushing and it only ever flush if the
       IOMMU unit supports caching invalid entries.
    2) The system just booted and the initialization code took care of
       flushing all IOMMU caches.
    
    This assumption is not true for the kdump kernel since the context
    tables have been copied from the previous kernel and translations could
    have been cached ever since. So make sure to flush the IOTLB as well
    when we destroy these old copied mappings.
    
    Cc: Joerg Roedel <joro@8bytes.org>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: David Woodhouse <dwmw@amazon.co.uk>
    Cc: Anthony Liguori <aliguori@amazon.com>
    Signed-off-by: KarimAllah Ahmed <karahmed@amazon.de>
    Acked-by: David Woodhouse <dwmw@amazon.co.uk>
    Cc: stable@vger.kernel.org  v4.2+
    Fixes: 091d42e43d ("iommu/vt-d: Copy translation tables from old kernel")
    Signed-off-by: Joerg Roedel <jroedel@suse.de>

diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c
index 90ab0115d78e..fc2765ccdb57 100644
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@ -2055,11 +2055,14 @@ static int domain_context_mapping_one(struct dmar_domain *domain,
 	if (context_copied(context)) {
 		u16 did_old = context_domain_id(context);
 
-		if (did_old >= 0 && did_old < cap_ndoms(iommu->cap))
+		if (did_old >= 0 && did_old < cap_ndoms(iommu->cap)) {
 			iommu->flush.flush_context(iommu, did_old,
 						   (((u16)bus) << 8) | devfn,
 						   DMA_CCMD_MASK_NOBIT,
 						   DMA_CCMD_DEVICE_INVL);
+			iommu->flush.flush_iotlb(iommu, did_old, 0, 0,
+						 DMA_TLB_DSI_FLUSH);
+		}
 	}
 
 	pgd = domain->pgd;

