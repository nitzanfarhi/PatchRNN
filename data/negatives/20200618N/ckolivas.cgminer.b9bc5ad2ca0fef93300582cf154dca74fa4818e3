commit b9bc5ad2ca0fef93300582cf154dca74fa4818e3
Author: Con Kolivas <kernel@kolivas.org>
Date:   Sat Nov 16 10:12:15 2013 +1100

    Send extra work regularly to the bxf device and parse the needwork command by sending the amount of work it requests.

diff --git a/driver-bitfury.c b/driver-bitfury.c
index b26ec8a8..7308faf7 100644
--- a/driver-bitfury.c
+++ b/driver-bitfury.c
@@ -231,6 +231,8 @@ static bool bxf_detect_one(struct cgpu_info *bitfury, struct bitfury_info *info)
 	       bitfury->drv->name, bitfury->device_id, bitfury->device_path);
 
 	info->total_nonces = 1;
+	/* This unsets it to make sure it gets set on the first pass */
+	info->maxroll = -1;
 
 	return true;
 }
@@ -379,6 +381,20 @@ static void parse_bxf_temp(struct cgpu_info *bitfury, struct bitfury_info *info,
 
 static void bxf_update_work(struct cgpu_info *bitfury, struct bitfury_info *info);
 
+static void parse_bxf_needwork(struct cgpu_info *bitfury, struct bitfury_info *info,
+			       char *buf)
+{
+	int needed;
+
+	if (!sscanf(&buf[9], "%d", &needed)) {
+		applog(LOG_INFO, "%s %d: Failed to parse needwork",
+		       bitfury->drv->name, bitfury->device_id);
+		return;
+	}
+	while (needed-- > 0)
+		bxf_update_work(bitfury, info);
+}
+
 static void *bxf_get_results(void *userdata)
 {
 	struct cgpu_info *bitfury = userdata;
@@ -397,6 +413,7 @@ static void *bxf_get_results(void *userdata)
 	/* Read thread sends the first work item to get the device started
 	 * since it will roll ntime and make work itself from there on. */
 	bxf_update_work(bitfury, info);
+	bxf_update_work(bitfury, info);
 
 	while (likely(!bitfury->shutdown)) {
 		char *msg;
@@ -424,6 +441,11 @@ static void *bxf_get_results(void *userdata)
 			parse_bxf_temp(bitfury, info, msg);
 			continue;
 		}
+		msg = strstr(buf, "needwork");
+		if (msg) {
+			parse_bxf_needwork(bitfury, info, msg);
+			continue;
+		}
 		applog(LOG_DEBUG, "%s %d: Unrecognised string %s",
 		       bitfury->drv->name, bitfury->device_id, buf);
 	}
@@ -634,7 +656,8 @@ static int64_t bxf_scan(struct cgpu_info *bitfury, struct bitfury_info *info)
 	int64_t ret;
 	int work_id;
 
-	cgsleep_ms(1200);
+	bxf_update_work(bitfury, info);
+	cgsleep_ms(600);
 
 	mutex_lock(&info->lock);
 	ret = bitfury_rate(info);
@@ -717,6 +740,7 @@ static void bitfury_flush_work(struct cgpu_info *bitfury)
 		case IDENT_BXF:
 			bxf_send_flush(bitfury);
 			bxf_update_work(bitfury, info);
+			bxf_update_work(bitfury, info);
 		case IDENT_BF1:
 		default:
 			break;

