commit fc444f6f95e373d93a8698a09571a9e67939b632
Author: Miklos Tirpak <miklos@iptel.org>
Date:   Tue Jan 4 16:21:04 2011 +0100

    cfg framework: cfg_group_inst_exists() added
    
    The function checkes whether or not a group instance exists.

diff --git a/cfg/cfg_ctx.c b/cfg/cfg_ctx.c
index 53d881a12..b90201ad5 100644
--- a/cfg/cfg_ctx.c
+++ b/cfg/cfg_ctx.c
@@ -1648,6 +1648,56 @@ error:
 	return -1;
 }
 
+/* Check the existance of a group instance.
+ * return value:
+ *	1: exists
+ *	0: does not exist
+ */
+int cfg_group_inst_exists(cfg_ctx_t *ctx, str *group_name, unsigned int group_id)
+{
+	cfg_group_t	*group;
+	cfg_add_var_t	*add_var;
+	int	found;
+
+	/* verify the context even if we do not need it now
+	to make sure that a cfg driver has called the function
+	(very very weak security) */
+	if (!ctx) {
+		LOG(L_ERR, "ERROR: cfg_group_inst_exists(): context is undefined\n");
+		return 0;
+	}
+
+	if (!(group = cfg_lookup_group(group_name->s, group_name->len))) {
+		LOG(L_ERR, "ERROR: cfg_group_inst_exists(): group not found\n");
+		return 0;
+	}
+
+	if (!cfg_shmized) {
+		/* group instances are stored in the additional variable list
+		 * before forking */
+		found = 0;
+		for (	add_var = group->add_var;
+			add_var;
+			add_var = add_var->next
+		)
+			if (add_var->group_id == group_id) {
+				found = 1;
+				break;
+			}
+
+	} else {
+		/* make sure that nobody else replaces the global config meantime */
+		CFG_WRITER_LOCK();
+		found = (cfg_find_group(CFG_GROUP_META(*cfg_global, group),
+								group->size,
+								group_id)
+				!= NULL);
+		CFG_WRITER_UNLOCK();
+	}
+
+	return found;
+}
+
 /* Apply the changes to a group instance as long as the additional variable
  * belongs to the specified group_id. *add_var_p is moved to the next additional
  * variable, and all the consumed variables are freed.
diff --git a/cfg/cfg_ctx.h b/cfg/cfg_ctx.h
index 359f59028..33b9b18e9 100644
--- a/cfg/cfg_ctx.h
+++ b/cfg/cfg_ctx.h
@@ -198,6 +198,13 @@ int cfg_add_group_inst(cfg_ctx_t *ctx, str *group_name, unsigned int group_id);
 /* Delete an instance of a group */
 int cfg_del_group_inst(cfg_ctx_t *ctx, str *group_name, unsigned int group_id);
 
+/* Check the existance of a group instance.
+ * return value:
+ *	1: exists
+ *	0: does not exist
+ */
+int cfg_group_inst_exists(cfg_ctx_t *ctx, str *group_name, unsigned int group_id);
+
 /* Apply the changes to a group instance as long as the additional variable
  * belongs to the specified group_id. *add_var_p is moved to the next additional
  * variable, and all the consumed variables are freed.

