commit 7787108d4ba1daa4a7cd821a81e3271707ee7e32
Author: Romain Bouqueau <romain.bouqueau.pro@gmail.com>
Date:   Mon Mar 14 15:06:57 2016 +0100

    WTF git! Where do these files come from?

diff --git a/src/ietfPrtp.c b/src/ietfPrtp.c
deleted file mode 100644
index b859aebc2..000000000
--- a/src/ietfPrtp.c
+++ /dev/null
@@ -1,982 +0,0 @@
-/*
- *			GPAC - Multimedia Framework C SDK
- *
- *			Authors: Jean Le Feuvre
- *			Copyright (c) Telecom ParisTech 2000-2012
- *					All rights reserved
- *
- *  This file is part of GPAC / IETF RTP/RTSP/SDP sub-project
- *
- *  GPAC is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU Lesser General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  GPAC is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#include <gpac/internal/ietf_dev.h>
-
-#ifndef GPAC_DISABLE_STREAMING
-
-#define MAX_RTP_SN	0x10000
-
-
-GF_EXPORT
-GF_RTPChannel *gf_rtp_new()
-{
-	GF_RTPChannel *tmp;
-	GF_SAFEALLOC(tmp, GF_RTPChannel);
-	if (!tmp)
-		return NULL;
-	tmp->first_SR = 1;
-	tmp->SSRC = gf_rand();
-	return tmp;
-}
-
-GF_EXPORT
-void gf_rtp_del(GF_RTPChannel *ch)
-{
-	if (!ch) return;
-	if (ch->rtp) gf_sk_del(ch->rtp);
-	if (ch->rtcp) gf_sk_del(ch->rtcp);
-	if (ch->net_info.source) gf_free(ch->net_info.source);
-	if (ch->net_info.destination) gf_free(ch->net_info.destination);
-	if (ch->net_info.Profile) gf_free(ch->net_info.Profile);
-	if (ch->po) gf_rtp_reorderer_del(ch->po);
-	if (ch->send_buffer) gf_free(ch->send_buffer);
-
-	if (ch->CName) gf_free(ch->CName);
-	if (ch->s_name) gf_free(ch->s_name);
-	if (ch->s_email) gf_free(ch->s_email);
-	if (ch->s_location) gf_free(ch->s_location);
-	if (ch->s_phone) gf_free(ch->s_phone);
-	if (ch->s_tool) gf_free(ch->s_tool);
-	if (ch->s_note) gf_free(ch->s_note);
-	if (ch->s_priv) gf_free(ch->s_priv);
-	memset(ch, 0, sizeof(GF_RTPChannel));
-	gf_free(ch);
-}
-
-
-
-GF_EXPORT
-GF_Err gf_rtp_setup_transport(GF_RTPChannel *ch, GF_RTSPTransport *trans_info, const char *remote_address)
-{
-	if (!ch || !trans_info) return GF_BAD_PARAM;
-	//assert we have at least ONE source ID
-	if (!trans_info->source && !remote_address) return GF_BAD_PARAM;
-
-	if (ch->net_info.destination) gf_free(ch->net_info.destination);
-	ch->net_info.destination = NULL;
-	if (ch->net_info.Profile) gf_free(ch->net_info.Profile);
-	ch->net_info.Profile = NULL;
-	if (ch->net_info.source) gf_free(ch->net_info.source);
-	ch->net_info.source = NULL;
-	memcpy(&ch->net_info, trans_info, sizeof(GF_RTSPTransport));
-
-	if (trans_info->destination)
-		ch->net_info.destination = gf_strdup(trans_info->destination);
-
-	if (trans_info->Profile)
-		ch->net_info.Profile = gf_strdup(trans_info->Profile);
-
-	if (!ch->net_info.IsUnicast && trans_info->destination) {
-		assert( trans_info->destination );
-		ch->net_info.source = gf_strdup(trans_info->destination);
-		if (ch->net_info.client_port_first) {
-			ch->net_info.port_first = ch->net_info.client_port_first;
-			ch->net_info.port_last = ch->net_info.client_port_last;
-		}
-	} else if (trans_info->source) {
-		ch->net_info.source = gf_strdup(trans_info->source);
-	} else {
-		ch->net_info.source = gf_strdup(remote_address);
-	}
-	if (trans_info->SSRC) ch->SenderSSRC = trans_info->SSRC;
-
-	//check we REALLY have unicast or multicast
-	if (gf_sk_is_multicast_address(ch->net_info.source) && ch->net_info.IsUnicast) return GF_SERVICE_ERROR;
-	return GF_OK;
-}
-
-
-GF_EXPORT
-void gf_rtp_reset_buffers(GF_RTPChannel *ch)
-{
-	if (ch->rtp) gf_sk_reset(ch->rtp);
-	if (ch->rtcp) gf_sk_reset(ch->rtcp);
-	if (ch->po) gf_rtp_reorderer_reset(ch->po);
-	/*also reset ssrc*/
-	//ch->SenderSSRC = 0;
-	ch->first_SR = 1;
-}
-
-
-GF_EXPORT
-void gf_rtp_enable_nat_keepalive(GF_RTPChannel *ch, u32 nat_timeout)
-{
-	if (ch) {
-		ch->nat_keepalive_time_period = nat_timeout;
-		ch->last_nat_keepalive_time = 0;
-	}
-}
-
-
-
-GF_EXPORT
-GF_Err gf_rtp_set_info_rtp(GF_RTPChannel *ch, u32 seq_num, u32 rtp_time, u32 ssrc)
-{
-	if (!ch) return GF_BAD_PARAM;
-	ch->rtp_time = rtp_time;
-	ch->last_pck_sn = 0;
-	ch->rtp_first_SN = seq_num;
-	ch->num_sn_loops = 0;
-	//reset RTCP
-	ch->ntp_init = 0;
-	ch->first_SR = 1;
-	if (ssrc) ch->SenderSSRC = ssrc;
-	ch->total_pck = ch->total_bytes = ch->last_num_pck_rcv = ch->last_num_pck_expected = ch->last_num_pck_loss = ch->tot_num_pck_rcv = ch->tot_num_pck_expected = ch->rtcp_bytes_sent = 0;
-	return GF_OK;
-}
-
-GF_EXPORT
-GF_Err gf_rtp_stop(GF_RTPChannel *ch)
-{
-	if (!ch) return GF_BAD_PARAM;
-	if (ch->rtp) gf_sk_del(ch->rtp);
-	ch->rtp = NULL;
-	if (ch->rtcp) gf_sk_del(ch->rtcp);
-	ch->rtcp = NULL;
-	if (ch->po) gf_rtp_reorderer_del(ch->po);
-	ch->po = NULL;
-	return GF_OK;
-}
-
-GF_EXPORT
-GF_Err gf_rtp_initialize(GF_RTPChannel *ch, u32 UDPBufferSize, Bool IsSource, u32 PathMTU, u32 ReorederingSize, u32 MaxReorderDelay, char *local_ip)
-{
-	u16 port;
-	GF_Err e;
-
-	if (IsSource && !PathMTU) return GF_BAD_PARAM;
-
-	if (ch->rtp) gf_sk_del(ch->rtp);
-	ch->rtp = NULL;
-	if (ch->rtcp) gf_sk_del(ch->rtcp);
-	ch->rtcp = NULL;
-	if (ch->po) gf_rtp_reorderer_del(ch->po);
-	ch->po = NULL;
-
-	ch->CurrentTime = 0;
-	ch->rtp_time = 0;
-
-	//create sockets for RTP/AVP profile only
-	if (ch->net_info.Profile &&
-	        ( !stricmp(ch->net_info.Profile, GF_RTSP_PROFILE_RTP_AVP)
-	          || !stricmp(ch->net_info.Profile, "RTP/AVP/UDP")
-	          || !stricmp(ch->net_info.Profile, "RTP/SAVP")
-	        )
-	   ) {
-		//destination MUST be specified for unicast
-		if (IsSource && ch->net_info.IsUnicast && !ch->net_info.destination) return GF_BAD_PARAM;
-
-		/* forcing unicast when the address is not a multicast */
-		if (!ch->net_info.IsUnicast) {
-			if (IsSource) {
-				if (ch->net_info.destination && !gf_sk_is_multicast_address(ch->net_info.destination)) {
-					ch->net_info.IsUnicast = GF_TRUE;
-				}
-			} else {
-				if (ch->net_info.source && !gf_sk_is_multicast_address(ch->net_info.source)) {
-					ch->net_info.IsUnicast = GF_TRUE;
-				}
-			}
-		}
-		//
-		//	RTP
-		//
-		ch->rtp = gf_sk_new(GF_SOCK_TYPE_UDP);
-		if (!ch->rtp) return GF_IP_NETWORK_FAILURE;
-		if (ch->net_info.IsUnicast) {
-			//if client, bind and connect the socket
-			if (!IsSource) {
-				port = ch->net_info.port_first;
-				if (!port) port = ch->net_info.client_port_first;
-				/*if a destination address was given (rtsd) use it*/
-				if (!local_ip && ch->net_info.destination) local_ip = ch->net_info.destination;
-
-				e = gf_sk_bind(ch->rtp, local_ip, ch->net_info.client_port_first, ch->net_info.source, port, GF_SOCK_REUSE_PORT);
-				if (e) return e;
-			}
-			//else bind and set remote destination
-			else {
-				if (!ch->net_info.port_first) ch->net_info.port_first = ch->net_info.client_port_first;
-				e = gf_sk_bind(ch->rtp, local_ip,ch->net_info.port_first, ch->net_info.destination, ch->net_info.client_port_first, GF_SOCK_REUSE_PORT);
-				if (e) return e;
-			}
-		} else {
-			//Bind to multicast (auto-join the group).
-			//we do not bind the socket if this is a source-only channel because some servers
-			//don't like that on local loop ...
-			e = gf_sk_setup_multicast(ch->rtp, ch->net_info.source, ch->net_info.port_first, ch->net_info.TTL, GF_FALSE, local_ip);
-			if (e) return e;
-		}
-		if (UDPBufferSize) gf_sk_set_buffer_size(ch->rtp, IsSource, UDPBufferSize);
-
-		if (IsSource) {
-			if (ch->send_buffer) gf_free(ch->send_buffer);
-			ch->send_buffer = (char *) gf_malloc(sizeof(char) * PathMTU);
-			ch->send_buffer_size = PathMTU;
-		}
-
-
-		//create re-ordering queue for UDP only, and receive
-		if (ReorederingSize && !IsSource) {
-			if (!MaxReorderDelay) MaxReorderDelay = 200;
-			ch->po = gf_rtp_reorderer_new(ReorederingSize, MaxReorderDelay);
-		}
-
-		//
-		//	RTCP
-		//
-		ch->rtcp = gf_sk_new(GF_SOCK_TYPE_UDP);
-		if (!ch->rtcp) return GF_IP_NETWORK_FAILURE;
-		if (ch->net_info.IsUnicast) {
-			if (!IsSource) {
-				port = ch->net_info.port_last;
-				if (!port) port = ch->net_info.client_port_last;
-				/*if a destination address was given (rtsd) use it*/
-				if (!local_ip && ch->net_info.destination) local_ip = ch->net_info.destination;
-
-				e = gf_sk_bind(ch->rtcp, local_ip, ch->net_info.client_port_last, ch->net_info.source, port, GF_SOCK_REUSE_PORT);
-				if (e) return e;
-			} else {
-				e = gf_sk_bind(ch->rtcp, local_ip, ch->net_info.port_last, ch->net_info.destination, ch->net_info.client_port_last, GF_SOCK_REUSE_PORT);
-				if (e) return e;
-			}
-		} else {
-			if (!ch->net_info.port_last) ch->net_info.port_last = ch->net_info.client_port_last;
-			//Bind to multicast (auto-join the group)
-			e = gf_sk_setup_multicast(ch->rtcp, ch->net_info.source, ch->net_info.port_last, ch->net_info.TTL, GF_FALSE, local_ip);
-			if (e) return e;
-		}
-	}
-
-	//format CNAME if not done yet
-	if (!ch->CName) {
-		//this is the real CName setup
-		if (!ch->rtp) {
-			ch->CName = gf_strdup("mpeg4rtp");
-		} else {
-			char name[GF_MAX_IP_NAME_LEN];
-
-			size_t start;
-			gf_get_user_name(name, 1024);
-			if (strlen(name)) strcat(name, "@");
-			start = strlen(name);
-			//get host IP or loopback if error
-			if (gf_sk_get_local_ip(ch->rtp, name+start) != GF_OK) strcpy(name+start, "127.0.0.1");
-			ch->CName = gf_strdup(name);
-		}
-	}
-
-
-#ifndef GPAC_DISABLE_LOG
-	if (gf_log_tool_level_on(GF_LOG_RTP, GF_LOG_DEBUG))  {
-		GF_LOG(GF_LOG_DEBUG, GF_LOG_RTP, ("[RTP] Packet Log Format: SSRC SequenceNumber TimeStamp NTP@recvTime deviance, Jiter, PckLost PckTotal BytesTotal\n"));
-	}
-#endif
-
-	return GF_OK;
-}
-
-/*get the UTC time expressed in RTP timescale*/
-u32 gf_rtp_channel_time(GF_RTPChannel *ch)
-{
-	u32 sec, frac, res;
-	gf_net_get_ntp(&sec, &frac);
-	res = ( (u32) ( (frac>>26)*ch->TimeScale) ) >> 6;
-	res += ch->TimeScale*(sec - ch->ntp_init);
-	return (u32) res;
-}
-
-u32 gf_rtp_get_report_time()
-{
-	u32 sec, frac;
-	gf_net_get_ntp(&sec, &frac);
-	/*in units of 1/65536 seconds*/
-	return (u32) ( (frac>>16) + 0x10000L*sec );
-}
-
-
-void gf_rtp_get_next_report_time(GF_RTPChannel *ch)
-{
-	Double d;
-
-	/*offset between .5 and 1.5 sec*/
-	d = 0.5 + ((Double) gf_rand()) / ((Double) RAND_MAX);
-	/*of a minimal 5sec interval expressed in 1/65536 of a sec*/
-	d = 5.0 * d * 65536;
-	/*we should estimate bandwidth sharing too, but as we only support one sender*/
-	ch->next_report_time = gf_rtp_get_report_time() + (u32) d;
-}
-
-
-GF_EXPORT
-u32 gf_rtp_read_rtp(GF_RTPChannel *ch, char *buffer, u32 buffer_size)
-{
-	GF_Err e;
-	u32 seq_num, res;
-	char *pck;
-
-	//only if the socket exist (otherwise RTSP interleaved channel)
-	if (!ch || !ch->rtp) return 0;
-
-	e = gf_sk_receive(ch->rtp, buffer, buffer_size, 0, &res);
-	if (!res || e || (res < 12)) res = 0;
-	if (res) {
-		ch->total_bytes+=res;
-		ch->total_pck++;
-	}
-	//add the packet to our Queue if any
-	if (ch->po) {
-		if (res) {
-			seq_num = ((buffer[2] << 8) & 0xFF00) | (buffer[3] & 0xFF);
-			gf_rtp_reorderer_add(ch->po, (void *) buffer, res, seq_num);
-		}
-
-		//pck queue may need to be flushed
-		pck = (char *) gf_rtp_reorderer_get(ch->po, &res);
-		if (pck) {
-			memcpy(buffer, pck, res);
-			gf_free(pck);
-		}
-	}
-	/*monitor keep-alive period*/
-	if (ch->nat_keepalive_time_period) {
-		u32 now = gf_sys_clock();
-		if (res) {
-			ch->last_nat_keepalive_time = now;
-		} else {
-			if (now - ch->last_nat_keepalive_time >= ch->nat_keepalive_time_period) {
-#if 0
-				char rtp_nat[12];
-				rtp_nat[0] = (u8) 0xC0;
-				rtp_nat[1] = ch->PayloadType;
-				rtp_nat[2] = (ch->last_pck_sn>>8)&0xFF;
-				rtp_nat[3] = (ch->last_pck_sn)&0xFF;
-				rtp_nat[4] = (ch->last_pck_ts>>24)&0xFF;
-				rtp_nat[5] = (ch->last_pck_ts>>16)&0xFF;
-				rtp_nat[6] = (ch->last_pck_ts>>8)&0xFF;
-				rtp_nat[7] = (ch->last_pck_ts)&0xFF;
-				rtp_nat[8] = (ch->SenderSSRC>>24)&0xFF;
-				rtp_nat[9] = (ch->SenderSSRC>>16)&0xFF;
-				rtp_nat[10] = (ch->SenderSSRC>>8)&0xFF;
-				rtp_nat[11] = (ch->SenderSSRC)&0xFF;
-#endif
-				e = gf_sk_send(ch->rtp, buffer, 12);
-				if (e) {
-					GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, ("[RTP] Error sending NAT keep-alive packet: %s - disabling NAT\n", gf_error_to_string(e) ));
-					ch->nat_keepalive_time_period = 0;
-				} else {
-					GF_LOG(GF_LOG_DEBUG, GF_LOG_RTP, ("[RTP] Sending NAT keep-alive packet - response %s\n", gf_error_to_string(e) ));
-				}
-				ch->last_nat_keepalive_time = now;
-			}
-		}
-	}
-	return res;
-}
-
-
-GF_EXPORT
-GF_Err gf_rtp_decode_rtp(GF_RTPChannel *ch, char *pck, u32 pck_size, GF_RTPHeader *rtp_hdr, u32 *PayloadStart)
-{
-	GF_Err e;
-	s32 deviance, delta;
-	u32 CurrSeq, LastSeq;
-	u32 ntp, lost, low16;
-
-	if (!rtp_hdr) return GF_BAD_PARAM;
-	e = GF_OK;
-
-	//we need to uncompress the RTP header
-	rtp_hdr->Version = (pck[0] & 0xC0 ) >> 6;
-	if (rtp_hdr->Version != 2) return GF_NOT_SUPPORTED;
-
-	rtp_hdr->Padding = ( pck[0] & 0x20 ) >> 5;
-	rtp_hdr->Extension = ( pck[0] & 0x10 ) >> 4;
-	rtp_hdr->CSRCCount = pck[0] & 0x0F;
-	rtp_hdr->Marker = ( pck[1] & 0x80 ) >> 7;
-	rtp_hdr->PayloadType = pck[1] & 0x7F;
-
-	/*we don't support multiple CSRC now. Only one source (the server) is allowed*/
-	if (rtp_hdr->CSRCCount) return GF_NOT_SUPPORTED;
-	/*SeqNum*/
-	rtp_hdr->SequenceNumber = ((pck[2] << 8) & 0xFF00) | (pck[3] & 0xFF);
-	/*TS*/
-	rtp_hdr->TimeStamp = (u32) ((pck[4]<<24) &0xFF000000) | ((pck[5]<<16) & 0xFF0000) | ((pck[6]<<8) & 0xFF00) | ((pck[7]) & 0xFF);
-	/*SSRC*/
-	rtp_hdr->SSRC = ((pck[8]<<24) &0xFF000000) | ((pck[9]<<16) & 0xFF0000) | ((pck[10]<<8) & 0xFF00) | ((pck[11]) & 0xFF);
-	/*first we only work with one payload type...*/
-	if (rtp_hdr->PayloadType != ch->PayloadType) return GF_NOT_SUPPORTED;
-
-	/*update RTP time if we didn't get the info*/
-	if (!ch->rtp_time) {
-		ch->rtp_time = rtp_hdr->TimeStamp;
-		ch->rtp_first_SN = rtp_hdr->SequenceNumber;
-		ch->num_sn_loops = 0;
-	}
-	if (ch->first_SR && !ch->SenderSSRC && rtp_hdr->SSRC) {
-		ch->SenderSSRC = rtp_hdr->SSRC;
-		GF_LOG(GF_LOG_INFO, GF_LOG_RTP, ("[RTP] Assigning SSRC to %d because none was specified through SDP/RTSP\n", ch->SenderSSRC));
-	}
-
-
-	if (!ch->ntp_init && ch->SenderSSRC && (ch->SenderSSRC != rtp_hdr->SSRC) ) {
-		GF_LOG(GF_LOG_WARNING, GF_LOG_RTP, ("[RTP] SSRC mismatch: %d vs %d\n", rtp_hdr->SSRC, ch->SenderSSRC));
-		return GF_IP_NETWORK_EMPTY;
-	}
-
-
-	/*RTP specs annexe A.8*/
-	if (!ch->ntp_init) {
-		gf_net_get_ntp(&ch->ntp_init, &lost);
-		ch->last_pck_sn = (u32) rtp_hdr->SequenceNumber-1;
-	}
-	/*this is a loop in SN - add it*/
-	if ( (ch->last_pck_sn + 1 > rtp_hdr->SequenceNumber)
-	        && (rtp_hdr->SequenceNumber >= ch->last_pck_sn + MAX_RTP_SN/2)) {
-		ch->num_sn_loops += 1;
-	}
-
-	if (ch->last_SR_rtp_time) {
-		s32 diff_sec = ((s32) rtp_hdr->TimeStamp - (s32) ch->last_SR_rtp_time) / (s32) ch->TimeScale;
-		u32 sec = ch->last_SR_NTP_sec;
-		s64 frac = ch->last_SR_NTP_frac;
-
-		frac = (s32) rtp_hdr->TimeStamp - (s32) ch->last_SR_rtp_time - diff_sec*(s32)ch->TimeScale;
-		frac *= 0xFFFFFFFF;
-		frac /= ch->TimeScale;
-		frac += ch->last_SR_NTP_frac;
-		if (frac>0xFFFFFFFF) {
-			sec += 1;
-			frac -= 0xFFFFFFFF;
-		}
-		rtp_hdr->recomputed_ntp_ts = sec + diff_sec;
-		rtp_hdr->recomputed_ntp_ts <<= 32;
-		rtp_hdr->recomputed_ntp_ts |= frac;
-	}
-
-	ntp = gf_rtp_channel_time(ch);
-	deviance = ntp - rtp_hdr->TimeStamp;
-	delta = deviance - ch->last_deviance;
-	ch->last_deviance = deviance;
-
-	if (delta < 0) delta = -delta;
-	ch->Jitter += delta - ( (ch->Jitter + 8) >> 4);
-
-	lost = 0;
-	LastSeq = ch->last_pck_sn;
-	CurrSeq = (u32) rtp_hdr->SequenceNumber;
-	ch->packet_loss = GF_FALSE;
-	/*next sequential pck*/
-	if ( ( (LastSeq + 1) & 0xffff ) == CurrSeq ) {
-		ch->last_num_pck_rcv += 1;
-		ch->last_num_pck_expected += 1;
-	}
-	/*repeated pck*/
-	else if ( (LastSeq & 0xffff ) == CurrSeq ) {
-		ch->last_num_pck_rcv += 1;
-	}
-	/*drop pck*/
-	else {
-		low16 = LastSeq & 0xffff;
-		if ( CurrSeq > low16 )
-			lost = CurrSeq - low16;
-		else
-			lost = 0xffff - low16 + CurrSeq + 1;
-
-		ch->last_num_pck_expected += lost;
-		ch->last_num_pck_rcv += 1;
-		ch->last_num_pck_loss += lost;
-		ch->packet_loss = GF_TRUE;
-	}
-	ch->last_pck_sn = CurrSeq;
-
-#ifndef GPAC_DISABLE_LOG
-	if (gf_log_tool_level_on(GF_LOG_RTP, GF_LOG_DEBUG))  {
-		ch->total_pck++;
-		ch->total_bytes += pck_size-12;
-
-		GF_LOG(GF_LOG_DEBUG, GF_LOG_RTP, ("[RTP]\t%d\t%d\t%u\t%d\t%d\t%d\t%d\t%d\t%d\n",
-		                                  ch->SenderSSRC,
-		                                  rtp_hdr->SequenceNumber,
-		                                  rtp_hdr->TimeStamp,
-		                                  ntp,
-		                                  delta,
-		                                  ch->Jitter >> 4,
-		                                  lost,
-		                                  ch->total_pck,
-		                                  ch->total_bytes
-		                                 ));
-	}
-#endif
-
-	//we work with no CSRC so payload offset is always 12
-	*PayloadStart = 12;
-
-	//store the time
-	ch->CurrentTime = rtp_hdr->TimeStamp;
-	return e;
-}
-
-
-GF_EXPORT
-Double gf_rtp_get_current_time(GF_RTPChannel *ch)
-{
-	Double ret;
-	if (!ch) return 0.0;
-	ret = (Double) ch->CurrentTime;
-	ret -= (Double) ch->rtp_time;
-	ret /= ch->TimeScale;
-	return ret;
-}
-
-
-
-
-
-
-GF_EXPORT
-GF_Err gf_rtp_send_packet(GF_RTPChannel *ch, GF_RTPHeader *rtp_hdr, char *pck, u32 pck_size, Bool fast_send)
-{
-	GF_Err e;
-	u32 i, Start;
-	char *hdr = NULL;
-
-	GF_BitStream *bs;
-
-	if (!ch || !rtp_hdr
-	        || !ch->send_buffer
-	        || !pck
-	        || (rtp_hdr->CSRCCount > 15)) return GF_BAD_PARAM;
-
-	if (rtp_hdr->CSRCCount) fast_send = GF_FALSE;
-
-	if (12 + pck_size + 4*rtp_hdr->CSRCCount > ch->send_buffer_size) return GF_IO_ERR;
-
-	if (fast_send) {
-		hdr = pck - 12;
-		bs = gf_bs_new(hdr, 12, GF_BITSTREAM_WRITE);
-	} else {
-		bs = gf_bs_new(ch->send_buffer, ch->send_buffer_size, GF_BITSTREAM_WRITE);
-	}
-	//write header
-	gf_bs_write_int(bs, rtp_hdr->Version, 2);
-	gf_bs_write_int(bs, rtp_hdr->Padding, 1);
-	gf_bs_write_int(bs, rtp_hdr->Extension, 1);
-	gf_bs_write_int(bs, rtp_hdr->CSRCCount, 4);
-	gf_bs_write_int(bs, rtp_hdr->Marker, 1);
-	gf_bs_write_int(bs, rtp_hdr->PayloadType, 7);
-	gf_bs_write_u16(bs, rtp_hdr->SequenceNumber);
-	gf_bs_write_u32(bs, rtp_hdr->TimeStamp);
-	gf_bs_write_u32(bs, ch->SSRC);
-
-	for (i=0; i<rtp_hdr->CSRCCount; i++) {
-		gf_bs_write_u32(bs, rtp_hdr->CSRC[i]);
-	}
-	//nb: RTP header is always aligned
-	Start = (u32) gf_bs_get_position(bs);
-	gf_bs_del(bs);
-
-	//copy payload
-	if (fast_send) {
-		e = gf_sk_send(ch->rtp, hdr, pck_size+12);
-	} else {
-		memcpy(ch->send_buffer + Start, pck, pck_size);
-		e = gf_sk_send(ch->rtp, ch->send_buffer, Start + pck_size);
-	}
-	if (e) return e;
-
-	//Update RTCP for sender reports
-	ch->pck_sent_since_last_sr += 1;
-	if (ch->first_SR) {
-		//get a new report time
-		gf_rtp_get_next_report_time(ch);
-		ch->num_payload_bytes = 0;
-		ch->num_pck_sent = 0;
-		ch->first_SR = 0;
-	}
-
-	ch->num_payload_bytes += pck_size;
-	ch->num_pck_sent += 1;
-	//store timing
-	ch->last_pck_ts = rtp_hdr->TimeStamp;
-	gf_net_get_ntp(&ch->last_pck_ntp_sec, &ch->last_pck_ntp_frac);
-
-	if (!ch->no_auto_rtcp) gf_rtp_send_rtcp_report(ch, NULL, NULL);
-	return GF_OK;
-}
-
-GF_EXPORT
-u32 gf_rtp_is_unicast(GF_RTPChannel *ch)
-{
-	if (!ch) return 0;
-	return ch->net_info.IsUnicast;
-}
-
-GF_EXPORT
-u32 gf_rtp_is_interleaved(GF_RTPChannel *ch)
-{
-	if (!ch || !ch->net_info.Profile) return 0;
-	return ch->net_info.IsInterleaved;
-}
-
-GF_EXPORT
-u32 gf_rtp_get_clockrate(GF_RTPChannel *ch)
-{
-	if (!ch || !ch->TimeScale) return 0;
-	return ch->TimeScale;
-}
-
-GF_EXPORT
-u32 gf_rtp_is_active(GF_RTPChannel *ch)
-{
-	if (!ch) return 0;
-	if (!ch->rtp_first_SN && !ch->rtp_time) return 0;
-	return 1;
-}
-
-GF_EXPORT
-u8 gf_rtp_get_low_interleave_id(GF_RTPChannel *ch)
-{
-	if (!ch || !ch->net_info.IsInterleaved) return 0;
-	return ch->net_info.rtpID;
-}
-
-GF_EXPORT
-u8 gf_rtp_get_hight_interleave_id(GF_RTPChannel *ch)
-{
-	if (!ch || !ch->net_info.IsInterleaved) return 0;
-	return ch->net_info.rtcpID;
-}
-
-
-#define RTP_DEFAULT_FIRSTPORT		7040
-
-static u16 NextAvailablePort = 0;
-
-GF_EXPORT
-GF_Err gf_rtp_set_ports(GF_RTPChannel *ch, u16 first_port)
-{
-	u16 p;
-	GF_Socket *sock;
-	if (!ch) return GF_BAD_PARAM;
-
-	if (!NextAvailablePort) {
-		NextAvailablePort = first_port ? first_port : RTP_DEFAULT_FIRSTPORT;
-	}
-	p = NextAvailablePort;
-	if (ch->net_info.client_port_first) return GF_OK;
-
-	sock = gf_sk_new(GF_SOCK_TYPE_UDP);
-	if (!sock) return GF_IO_ERR;
-
-	/*should be way enough (more than 100 rtp streams open on the machine)*/
-	while (1) {
-		/*try to bind without reuse. If fails this means the port is used on the machine, don't reuse it*/
-		GF_Err e = gf_sk_bind(sock, NULL, p, NULL, 0, 0);
-		if (e==GF_OK) break;
-		if (e!=GF_IP_CONNECTION_FAILURE) {
-			gf_sk_del(sock);
-			return GF_IP_NETWORK_FAILURE;
-		}
-		p+=2;
-	}
-	gf_sk_del(sock);
-	ch->net_info.client_port_first = p;
-	ch->net_info.client_port_last = p + 1;
-	NextAvailablePort = p + 2;
-	return GF_OK;
-}
-
-
-GF_EXPORT
-GF_Err gf_rtp_setup_payload(GF_RTPChannel *ch, GF_RTPMap *map)
-{
-	if (!ch || !map) return GF_BAD_PARAM;
-	ch->PayloadType = map->PayloadType;
-	ch->TimeScale = map->ClockRate;
-	return GF_OK;
-}
-
-GF_EXPORT
-GF_RTSPTransport *gf_rtp_get_transport(GF_RTPChannel *ch)
-{
-	if (!ch) return NULL;
-	return &ch->net_info;
-}
-
-GF_EXPORT
-u32 gf_rtp_get_local_ssrc(GF_RTPChannel *ch)
-{
-	if (!ch) return 0;
-	return ch->SSRC;
-}
-
-
-#if 0
-"#RTP log format:\n"
-"#RTP SenderSSRC RTP_TimeStamp RTP_SeqNum NTP@Recv Deviance Jitter NbLost NbTotPck NbTotBytes\n"
-"#RTCP Sender reports log format:\n"
-"#RTCP-SR SenderSSRC RTP_TimeStamp@NTP NbTotPck NbTotBytes NTP\n"
-"#RTCP Receiver reports log format:\n"
-"#RTCP-RR StreamSSRC Jitter ExtendedSeqNum ExpectDiff LossDiff NTP\n"
-#endif
-
-GF_EXPORT
-Float gf_rtp_get_loss(GF_RTPChannel *ch)
-{
-	if (!ch->tot_num_pck_expected) return 0.0f;
-	return 100.0f - (100.0f * ch->tot_num_pck_rcv) / ch->tot_num_pck_expected;
-}
-
-GF_EXPORT
-u32 gf_rtp_get_tcp_bytes_sent(GF_RTPChannel *ch)
-{
-	return ch->rtcp_bytes_sent;
-}
-
-GF_EXPORT
-void gf_rtp_get_ports(GF_RTPChannel *ch, u16 *rtp_port, u16 *rtcp_port)
-{
-	if (ch->net_info.client_port_first) {
-		if (rtp_port) *rtp_port = ch->net_info.client_port_first;
-		if (rtcp_port) *rtcp_port = ch->net_info.client_port_last;
-	} else {
-		if (rtp_port) *rtp_port = ch->net_info.port_first;
-		if (rtcp_port) *rtcp_port = ch->net_info.port_last;
-	}
-}
-
-
-/*
-	RTP packet reorderer
-*/
-
-#define SN_CHECK_OFFSET		0x0A
-
-GF_EXPORT
-GF_RTPReorder *gf_rtp_reorderer_new(u32 MaxCount, u32 MaxDelay)
-{
-	GF_RTPReorder *tmp;
-
-	if (MaxCount <= 1 || !MaxDelay) return NULL;
-
-	GF_SAFEALLOC(tmp , GF_RTPReorder);
-	tmp->MaxCount = MaxCount;
-	tmp->MaxDelay = MaxDelay;
-	return tmp;
-}
-
-static void DelItem(GF_POItem *it)
-{
-	if (it) {
-		if (it->next) DelItem(it->next);
-		gf_free(it->pck);
-		gf_free(it);
-	}
-}
-
-
-GF_EXPORT
-void gf_rtp_reorderer_del(GF_RTPReorder *po)
-{
-	if (po->in) DelItem(po->in);
-	gf_free(po);
-}
-
-GF_EXPORT
-void gf_rtp_reorderer_reset(GF_RTPReorder *po)
-{
-	if (!po) return;
-
-	if (po->in) DelItem(po->in);
-	po->head_seqnum = 0;
-	po->Count = 0;
-	po->IsInit = 0;
-	po->in = NULL;
-}
-
-GF_EXPORT
-GF_Err gf_rtp_reorderer_add(GF_RTPReorder *po, const void * pck, u32 pck_size, u32 pck_seqnum)
-{
-	GF_POItem *it, *cur;
-	u32 bounds;
-
-	if (!po) return GF_BAD_PARAM;
-
-	it = (GF_POItem *) gf_malloc(sizeof(GF_POItem));
-	it->pck_seq_num = pck_seqnum;
-	it->next = NULL;
-	it->size = pck_size;
-	it->pck = gf_malloc(pck_size);
-	memcpy(it->pck, pck, pck_size);
-	/*reset timeout*/
-	po->LastTime = 0;
-
-	//no input, this packet will be the input
-	if (!po->in) {
-		//the seq num was not initialized
-		if (!po->head_seqnum) {
-			po->head_seqnum = pck_seqnum;
-		} else if (!po->IsInit) {
-			//this is not in our current range for init
-			if (ABSDIFF(po->head_seqnum, pck_seqnum) > SN_CHECK_OFFSET) goto discard;
-			po->IsInit = 1;
-		}
-
-		po->in = it;
-		po->Count += 1;
-		return GF_OK;
-	}
-
-	//this is 16 bitr seq num, as we work with RTP only for now
-	bounds = 0;
-	if ( (po->head_seqnum >= 0xf000 ) || (po->head_seqnum <= 0x1000) ) bounds = 0x2000;
-
-	//first check the head of the list
-	//same seq num, we drop
-	if (po->in->pck_seq_num == pck_seqnum) goto discard;
-
-	if ( ( (u16) (pck_seqnum + bounds) <= (u16) (po->in->pck_seq_num + bounds) ) ) {
-
-		it->next = po->in;
-		po->in = it;
-		po->Count += 1;
-
-		GF_LOG(GF_LOG_DEBUG, GF_LOG_RTP, ("[rtp] Packet Reorderer: inserting packet %d at head\n", pck_seqnum));
-		return GF_OK;
-	}
-
-	//no, insert at the right place
-	cur = po->in;
-
-	while (1) {
-		//same seq num, we drop
-		if (cur->pck_seq_num == pck_seqnum) goto discard;
-
-		//end of list
-		if (!cur->next) {
-			cur->next = it;
-			po->Count += 1;
-			GF_LOG(GF_LOG_DEBUG, GF_LOG_RTP, ("[rtp] Packet Reorderer: Appending packet %d (last %d)\n", pck_seqnum, cur->pck_seq_num));
-			return GF_OK;
-		}
-
-		//are we in the bounds ??
-		if ( ( (u16) (cur->pck_seq_num + bounds) < (u16) (pck_seqnum + bounds) )
-		        && ( (u16) (pck_seqnum + bounds) < (u16) (cur->next->pck_seq_num + bounds)) ) {
-
-			//insert
-			it->next = cur->next;
-			cur->next = it;
-			po->Count += 1;
-
-			GF_LOG(GF_LOG_DEBUG, GF_LOG_RTP, ("[rtp] Packet Reorderer: Inserting packet %d\n", pck_seqnum));
-			//done
-			return GF_OK;
-		}
-		cur = cur->next;
-	}
-
-
-discard:
-	gf_free(it->pck);
-	gf_free(it);
-	GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, ("[rtp] Packet Reorderer: Dropping packet %d\n", pck_seqnum));
-	return GF_OK;
-}
-
-//retrieve the first available packet. Note that the behavior will be undefined if the first
-//ever received packet if its SeqNum was unknown
-//the BUFFER is yours, you must delete it
-GF_EXPORT
-void *gf_rtp_reorderer_get(GF_RTPReorder *po, u32 *pck_size)
-{
-	GF_POItem *t;
-	u32 bounds;
-	void *ret;
-
-	if (!po || !pck_size) return NULL;
-
-	*pck_size = 0;
-
-	//empty queue
-	if (!po->in) return NULL;
-
-	//check we have received the first packet
-	if ( po->head_seqnum && po->MaxCount
-	        && (po->MaxCount > po->Count)
-	        && (po->in->pck_seq_num != po->head_seqnum))
-		return NULL;
-
-	//no entry
-	if (!po->in->next) goto check_timeout;
-
-	bounds = 0;
-	if ( (po->head_seqnum >= 0xf000 ) || (po->head_seqnum <= 0x1000) ) bounds = 0x2000;
-
-	//release the output if SN in order or maxCount reached
-	if (( (u16) (po->in->pck_seq_num + bounds + 1) == (u16) (po->in->next->pck_seq_num + bounds))
-	        || (po->MaxCount && (po->Count >= po->MaxCount)) ) {
-
-#ifndef GPAC_DISABLE_LOG
-		if (po->in->pck_seq_num + 1 != po->in->next->pck_seq_num)
-			GF_LOG(GF_LOG_INFO, GF_LOG_RTP, ("[rtp] WARNING Packet Loss: Sending %d out of the queue but next is %d\n", po->in->pck_seq_num, po->in->next->pck_seq_num ));
-#endif
-		goto send_it;
-	}
-	//update timing
-	else {
-check_timeout:
-		if (!po->LastTime) {
-			po->LastTime = gf_sys_clock();
-			GF_LOG(GF_LOG_DEBUG, GF_LOG_RTP, ("[rtp] Packet Reorderer: starting timeout at %d\n", po->LastTime));
-			return NULL;
-		}
-		//if exceeding the delay send the head
-		if (gf_sys_clock() - po->LastTime >= po->MaxDelay) {
-			GF_LOG(GF_LOG_DEBUG, GF_LOG_RTP, ("[rtp] Packet Reorderer: Forcing output after %d ms wait (max allowed %d)\n", gf_sys_clock() - po->LastTime, po->MaxDelay));
-			goto send_it;
-		}
-	}
-	return NULL;
-
-
-send_it:
-	GF_LOG(GF_LOG_DEBUG, GF_LOG_RTP, ("[rtp] Packet Reorderer: Fetching %d\n", po->in->pck_seq_num));
-	*pck_size = po->in->size;
-	t = po->in;
-	po->in = po->in->next;
-	//no other output. reset the head seqnum
-	po->head_seqnum = po->in ? po->in->pck_seq_num : 0;
-	po->Count -= 1;
-	//release the item
-	ret = t->pck;
-	gf_free(t);
-	return ret;
-}
-
-#endif /*GPAC_DISABLE_STREAMING*/
-
diff --git a/src/ietfPrtp_depacketizer.c b/src/ietfPrtp_depacketizer.c
deleted file mode 100644
index 133404b06..000000000
--- a/src/ietfPrtp_depacketizer.c
+++ /dev/null
@@ -1,1783 +0,0 @@
-/*
- *			GPAC - Multimedia Framework C SDK
- *
- *			Authors: Jean Le Feuvre
- *			Copyright (c) Telecom ParisTech 2000-2012
- *					All rights reserved
- *
- *  This file is part of GPAC / RTP input module
- *
- *  GPAC is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU Lesser General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  GPAC is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#include <gpac/internal/ietf_dev.h>
-
-#ifndef GPAC_DISABLE_STREAMING
-
-#include <gpac/esi.h>
-#include <gpac/base_coding.h>
-#include <gpac/constants.h>
-#include <gpac/mpeg4_odf.h>
-#include <gpac/avparse.h>
-
-
-
-static void gf_rtp_parse_mpeg4(GF_RTPDepacketizer *rtp, GF_RTPHeader *hdr, char *payload, u32 size)
-{
-	u32 aux_size, first_idx, au_hdr_size, num_au;
-	u64 pay_start, au_size;
-	s32 au_idx;
-	GF_BitStream *hdr_bs, *aux_bs;
-
-	hdr_bs = gf_bs_new(payload, size, GF_BITSTREAM_READ);
-	aux_bs = gf_bs_new(payload, size, GF_BITSTREAM_READ);
-
-//	fprintf(stderr, "parsing packet %d size %d ts %d M %d\n", hdr->SequenceNumber, size, hdr->TimeStamp, hdr->Marker);
-
-	/*global AU header len*/
-	au_hdr_size = 0;
-	if (rtp->sl_map.auh_first_min_len) {
-		au_hdr_size = gf_bs_read_u16(hdr_bs);
-		gf_bs_read_u16(aux_bs);
-	}
-
-	/*jump to aux section, skip it and get payload start*/
-	gf_bs_read_int(aux_bs, au_hdr_size);
-	gf_bs_align(aux_bs);
-	if (rtp->sl_map.AuxiliaryDataSizeLength) {
-		aux_size = gf_bs_read_int(aux_bs, rtp->sl_map.AuxiliaryDataSizeLength);
-		gf_bs_read_int(aux_bs, aux_size);
-		gf_bs_align(aux_bs);
-	}
-	pay_start = gf_bs_get_position(aux_bs);
-	gf_bs_del(aux_bs);
-
-	first_idx = 0;
-	au_idx = 0;
-
-	rtp->sl_hdr.compositionTimeStamp = hdr->TimeStamp;
-	rtp->sl_hdr.decodingTimeStamp = hdr->TimeStamp;
-
-	num_au = 0;
-
-	rtp->sl_hdr.accessUnitEndFlag = hdr->Marker;
-	/*override some defaults for RFC 3016*/
-	if (rtp->flags & GF_RTP_NEW_AU) {
-		rtp->sl_hdr.accessUnitStartFlag = 1;
-	} else {
-		rtp->sl_hdr.accessUnitStartFlag = 0;
-	}
-	rtp->sl_hdr.randomAccessPointFlag = 0;
-
-	while (1) {
-		/*get default AU size*/
-		au_size = rtp->sl_map.ConstantSize;
-		/*not signaled, assume max one AU per packet*/
-		if (!au_size) au_size = size - pay_start;
-
-		if ((!num_au && rtp->sl_map.auh_first_min_len) || (num_au && rtp->sl_map.auh_min_len)) {
-			/*ISMACryp*/
-			if (rtp->flags & GF_RTP_HAS_ISMACRYP) {
-				u32 nbbits;
-				rtp->sl_hdr.isma_encrypted = 1;
-				if (rtp->flags & GF_RTP_ISMA_SEL_ENC) {
-					rtp->sl_hdr.isma_encrypted = gf_bs_read_int(hdr_bs, 1);
-					gf_bs_read_int(hdr_bs, 7);
-					au_hdr_size -= 8;
-				}
-				/*Note: ISMACryp ALWAYS indicates IV (BSO) and KEYIDX, even when sample is not encrypted.
-				This is quite a waste when using selective encryption....*/
-				if (!num_au) {
-					nbbits = 8*rtp->sl_map.IV_length;
-					if (nbbits) {
-						rtp->sl_hdr.isma_BSO = gf_bs_read_int(hdr_bs, nbbits);
-						au_hdr_size -= nbbits;
-					}
-				}
-				/*NOT SUPPORTED YET*/
-				else if (rtp->sl_map.IV_delta_length) {
-					nbbits = 8*rtp->sl_map.IV_delta_length;
-					if (nbbits) {
-						rtp->sl_hdr.isma_BSO += gf_bs_read_int(hdr_bs, nbbits);
-						au_hdr_size -= nbbits;
-					}
-				}
-				if (rtp->sl_map.KI_length) {
-					/*NOT SUPPORTED YET*/
-					if (!num_au || !(rtp->flags & GF_RTP_ISMA_HAS_KEY_IDX) ) {
-						nbbits = 8*rtp->sl_map.KI_length;
-						if (nbbits) {
-							gf_bs_read_int(hdr_bs, nbbits);
-							au_hdr_size -= nbbits;
-						}
-					}
-				}
-			}
-
-			/*AU size*/
-			if (rtp->sl_map.SizeLength) {
-				au_size = gf_bs_read_int(hdr_bs, rtp->sl_map.SizeLength);
-				if (au_size > size - pay_start) au_size = size - pay_start;
-				au_hdr_size -= rtp->sl_map.SizeLength;
-			}
-			/*AU index*/
-			if (! num_au) {
-				au_idx = first_idx = gf_bs_read_int(hdr_bs, rtp->sl_map.IndexLength);
-				au_hdr_size -= rtp->sl_map.IndexLength;
-			} else {
-				au_idx += 1 + (u32) gf_bs_read_int(hdr_bs, rtp->sl_map.IndexDeltaLength);
-				au_hdr_size -= rtp->sl_map.IndexDeltaLength;
-			}
-			/*CTS flag*/
-			if (rtp->sl_map.CTSDeltaLength) {
-				rtp->sl_hdr.compositionTimeStampFlag = gf_bs_read_int(hdr_bs, 1);
-				au_hdr_size -= 1;
-			} else {
-				/*get CTS from IDX*/
-				if (rtp->sl_map.ConstantDuration) {
-					rtp->sl_hdr.compositionTimeStamp = hdr->TimeStamp + (au_idx - first_idx) * rtp->sl_map.ConstantDuration;
-				} else {
-					rtp->sl_hdr.compositionTimeStamp = hdr->TimeStamp + (au_idx - first_idx) * rtp->sl_hdr.au_duration;
-				}
-			}
-
-			/*CTS in-band*/
-			if (rtp->sl_hdr.compositionTimeStampFlag) {
-				rtp->sl_hdr.compositionTimeStamp = hdr->TimeStamp + (u32) gf_bs_read_int(hdr_bs, rtp->sl_map.CTSDeltaLength);
-				au_hdr_size -= rtp->sl_map.CTSDeltaLength;
-			}
-			/*DTS flag is always present (needed for reconstruction of TSs in case of packet loss)*/
-			if (rtp->sl_map.DTSDeltaLength) {
-				rtp->sl_hdr.decodingTimeStampFlag = gf_bs_read_int(hdr_bs, 1);
-				au_hdr_size -= 1;
-			} else {
-				/*NO DTS otherwise*/
-				rtp->sl_hdr.decodingTimeStampFlag = 0;
-			}
-			if (rtp->sl_hdr.decodingTimeStampFlag) {
-				u32 ts_off = gf_bs_read_int(hdr_bs, rtp->sl_map.DTSDeltaLength);
-				/*TODO FIXME may not be true in case of TS wrapping*/
-				if (hdr->TimeStamp > ts_off) rtp->sl_hdr.decodingTimeStamp = hdr->TimeStamp - ts_off;
-				au_hdr_size -= rtp->sl_map.DTSDeltaLength;
-			}
-			/*RAP flag*/
-			if (rtp->sl_map.RandomAccessIndication) {
-				rtp->sl_hdr.randomAccessPointFlag = gf_bs_read_int(hdr_bs, 1);
-				au_hdr_size -= 1;
-				if (rtp->sl_hdr.randomAccessPointFlag)
-					rtp->sl_hdr.randomAccessPointFlag=1;
-			}
-			/*stream state - map directly to seqNum*/
-			if (rtp->sl_map.StreamStateIndication) {
-				rtp->sl_hdr.AU_sequenceNumber = gf_bs_read_int(hdr_bs, rtp->sl_map.StreamStateIndication);
-				au_hdr_size -= rtp->sl_map.StreamStateIndication;
-			}
-		}
-		/*no header present, update CTS/DTS - note we're sure there's no interleaving*/
-		else {
-			if (num_au) {
-				rtp->sl_hdr.compositionTimeStamp += rtp->sl_map.ConstantDuration;
-				rtp->sl_hdr.decodingTimeStamp += rtp->sl_map.ConstantDuration;
-			}
-		}
-		/*we cannot map RTP SN to SL SN since an RTP packet may carry several SL ones - only inc by 1 seq nums*/
-		rtp->sl_hdr.packetSequenceNumber += 1;
-
-		/*force indication of CTS whenever we have a new AU*/
-
-		rtp->sl_hdr.compositionTimeStampFlag = (rtp->flags & GF_RTP_NEW_AU) ? 1 : 0;
-
-		/*locate VOP start code*/
-		if (rtp->sl_hdr.accessUnitStartFlag && (rtp->flags & GF_RTP_M4V_CHECK_RAP)) {
-			u32 i;
-			Bool is_rap = GF_FALSE;
-			unsigned char *pay = (unsigned char *) payload + pay_start;
-			i=0;
-			while (i<au_size-4) {
-				if (!pay[i] && !pay[i+1] && (pay[i+2]==1) && (pay[i+3]==0xB6)) {
-					is_rap = ((pay[i+4] & 0xC0)==0) ? GF_TRUE : GF_FALSE;
-					break;
-				}
-				i++;
-			}
-			rtp->sl_hdr.randomAccessPointFlag = is_rap ? 1 : 0;
-		}
-
-		rtp->on_sl_packet(rtp->udta, payload + pay_start, (u32) au_size, &rtp->sl_hdr, GF_OK);
-
-		rtp->sl_hdr.compositionTimeStampFlag = 0;
-
-		if (rtp->flags & GF_RTP_HAS_ISMACRYP) rtp->sl_hdr.isma_BSO += au_size;
-
-		if (au_hdr_size < rtp->sl_map.auh_min_len) break;
-		pay_start += au_size;
-		if (pay_start >= size) break;
-		num_au ++;
-	}
-//	assert(!au_hdr_size);
-
-	if (hdr->Marker)
-		rtp->flags |= GF_RTP_NEW_AU;
-	else
-		rtp->flags &= ~GF_RTP_NEW_AU;
-
-	gf_bs_del(hdr_bs);
-}
-
-#ifndef GPAC_DISABLE_AV_PARSERS
-
-static void gf_rtp_parse_mpeg12_audio(GF_RTPDepacketizer *rtp, GF_RTPHeader *hdr, char *payload, u32 size)
-{
-	u16 offset;
-	u32 mp3hdr, ts;
-	GF_BitStream *bs;
-
-	rtp->sl_hdr.compositionTimeStamp = hdr->TimeStamp;
-	rtp->sl_hdr.decodingTimeStamp = hdr->TimeStamp;
-
-	rtp->sl_hdr.accessUnitStartFlag = rtp->sl_hdr.accessUnitEndFlag ? 1 : 0;
-	if (rtp->flags & GF_RTP_NEW_AU) rtp->sl_hdr.accessUnitStartFlag = 1;
-
-	/*get frag header*/
-	bs = gf_bs_new(payload, size, GF_BITSTREAM_READ);
-	gf_bs_read_u16(bs);
-	offset = gf_bs_read_u16(bs);
-	gf_bs_del(bs);
-	payload += 4;
-	size -= 4;
-	mp3hdr = 0;
-	while (1) {
-
-		/*frame start if no offset*/
-		rtp->sl_hdr.accessUnitStartFlag = offset ? 0 : 1;
-
-		/*new frame, store size*/
-		rtp->sl_hdr.compositionTimeStampFlag = 0;
-		if (rtp->sl_hdr.accessUnitStartFlag) {
-			mp3hdr = GF_4CC((u8) payload[0], (u8) payload[1], (u8) payload[2], (u8) payload[3]);
-			rtp->sl_hdr.accessUnitLength = gf_mp3_frame_size(mp3hdr);
-			rtp->sl_hdr.compositionTimeStampFlag = 1;
-		}
-		if (!rtp->sl_hdr.accessUnitLength) break;
-		/*fragmented frame*/
-		if (rtp->sl_hdr.accessUnitLength>size) {
-			rtp->on_sl_packet(rtp->udta, payload, rtp->sl_hdr.accessUnitLength, &rtp->sl_hdr, GF_OK);
-			rtp->sl_hdr.accessUnitLength -= size;
-			rtp->sl_hdr.accessUnitStartFlag = rtp->sl_hdr.accessUnitEndFlag = 0;
-			return;
-		}
-		/*complete frame*/
-		rtp->sl_hdr.accessUnitEndFlag = 1;
-		rtp->on_sl_packet(rtp->udta, payload, rtp->sl_hdr.accessUnitLength, &rtp->sl_hdr, GF_OK);
-		payload += rtp->sl_hdr.accessUnitLength;
-		size -= rtp->sl_hdr.accessUnitLength;
-		rtp->sl_hdr.accessUnitLength = 0;
-
-		/*if fragmented there shall not be other frames in the packet*/
-		if (!rtp->sl_hdr.accessUnitStartFlag) return;
-		if (!size) break;
-		offset = 0;
-		/*get ts*/
-		ts = gf_mp3_window_size(mp3hdr);
-		rtp->sl_hdr.compositionTimeStamp += ts;
-		rtp->sl_hdr.decodingTimeStamp += ts;
-	}
-	rtp->flags |= GF_RTP_NEW_AU;
-}
-
-#endif
-
-static void gf_rtp_parse_mpeg12_video(GF_RTPDepacketizer *rtp, GF_RTPHeader *hdr, char *payload, u32 size)
-{
-	u8 pic_type;
-
-	rtp->sl_hdr.compositionTimeStamp = hdr->TimeStamp;
-	rtp->sl_hdr.decodingTimeStamp = hdr->TimeStamp;
-
-
-	pic_type = payload[2] & 0x7;
-	payload += 4;
-	size -= 4;
-
-	/*missed something*/
-	if (rtp->sl_hdr.compositionTimeStamp != hdr->TimeStamp) rtp->flags |= GF_RTP_NEW_AU;
-
-	rtp->sl_hdr.accessUnitStartFlag = (rtp->flags & GF_RTP_NEW_AU) ? 1 : 0;
-	rtp->sl_hdr.accessUnitEndFlag = hdr->Marker ? 1 : 0;
-	rtp->sl_hdr.randomAccessPointFlag = (pic_type==1) ? 1 : 0;
-
-	if (rtp->sl_hdr.accessUnitStartFlag) {
-		rtp->sl_hdr.compositionTimeStamp = hdr->TimeStamp;
-		rtp->sl_hdr.compositionTimeStampFlag = 1;
-	} else {
-		rtp->sl_hdr.compositionTimeStampFlag = 0;
-	}
-	rtp->on_sl_packet(rtp->udta, payload, size, &rtp->sl_hdr, GF_OK);
-	if (hdr->Marker) {
-		rtp->flags |= GF_RTP_NEW_AU;
-	} else {
-		rtp->flags &= ~GF_RTP_NEW_AU;
-	}
-}
-
-static void gf_rtp_parse_amr(GF_RTPDepacketizer *rtp, GF_RTPHeader *hdr, char *payload, u32 size)
-{
-	unsigned char c, type;
-	char *data;
-	/*we support max 30 frames in one RTP packet...*/
-	u32 nbFrame, i, frame_size;
-	/*not supported yet*/
-	if (!(rtp->flags & GF_RTP_AMR_ALIGN) ) return;
-
-	/*process toc and locate start of payload data*/
-	nbFrame = 0;
-	while (1) {
-		c = payload[nbFrame + 1];
-		nbFrame++;
-		if (!(c & 0x80)) break;
-	}
-	data = payload + nbFrame + 1;
-	rtp->sl_hdr.compositionTimeStamp = hdr->TimeStamp;
-	/*then each frame*/
-	for (i=0; i<nbFrame; i++) {
-		c = payload[i + 1];
-		type = ((c & 0x78) >> 3);
-		if (rtp->payt==GF_RTP_PAYT_AMR) {
-			frame_size = (u32)GF_AMR_FRAME_SIZE[type];
-		} else {
-			frame_size = (u32)GF_AMR_WB_FRAME_SIZE[type];
-		}
-
-		rtp->sl_hdr.compositionTimeStampFlag = 1;
-		rtp->sl_hdr.accessUnitStartFlag = 1;
-		rtp->sl_hdr.accessUnitEndFlag = 0;
-		/*send TOC*/
-		rtp->on_sl_packet(rtp->udta, &payload[i+1], 1, &rtp->sl_hdr, GF_OK);
-		rtp->sl_hdr.packetSequenceNumber ++;
-		rtp->sl_hdr.compositionTimeStampFlag = 0;
-		rtp->sl_hdr.accessUnitStartFlag = 0;
-		rtp->sl_hdr.accessUnitEndFlag = 1;
-		/*send payload*/
-		rtp->on_sl_packet(rtp->udta, data, frame_size, &rtp->sl_hdr, GF_OK);
-		data += frame_size;
-		rtp->sl_hdr.compositionTimeStamp += 160;
-	}
-}
-
-
-static void gf_rtp_parse_h263(GF_RTPDepacketizer *rtp, GF_RTPHeader *hdr, char *payload, u32 size)
-{
-	GF_BitStream *bs;
-	Bool P_bit, V_bit;
-	u32 plen;
-	u64 offset;
-	char blank[2];
-
-	bs = gf_bs_new(payload, size, GF_BITSTREAM_READ);
-	/*reserved*/
-	gf_bs_read_int(bs, 5);
-	P_bit = (Bool)gf_bs_read_int(bs, 1);
-	V_bit = (Bool)gf_bs_read_int(bs, 1);
-	plen = gf_bs_read_int(bs, 6);
-	/*plen_bits = */gf_bs_read_int(bs, 3);
-
-	/*VRC not supported yet*/
-	if (V_bit) {
-		gf_bs_read_u8(bs);
-	}
-	/*extra picture header not supported yet*/
-	if (plen) {
-		gf_bs_skip_bytes(bs, plen);
-	}
-	offset = gf_bs_get_position(bs);
-	gf_bs_del(bs);
-
-	blank[0] = blank[1] = 0;
-	/*start*/
-	if (P_bit) {
-		rtp->sl_hdr.compositionTimeStamp = hdr->TimeStamp;
-		rtp->sl_hdr.compositionTimeStampFlag = 1;
-		rtp->sl_hdr.accessUnitStartFlag = 1;
-		rtp->sl_hdr.accessUnitEndFlag = 0;
-
-		if (rtp->sl_hdr.accessUnitStartFlag) {
-			/*the first 16 bytes are NOT sent on the wire*/
-			rtp->sl_hdr.randomAccessPointFlag = (payload[offset+2]&0x02) ? 0 : 1;
-		}
-		/*send missing start code*/
-		rtp->on_sl_packet(rtp->udta, (char *) blank, 2, &rtp->sl_hdr, GF_OK);
-		/*send payload*/
-		rtp->sl_hdr.compositionTimeStampFlag = 0;
-		rtp->sl_hdr.accessUnitStartFlag = 0;
-		rtp->sl_hdr.randomAccessPointFlag = 0;
-
-		/*if M bit set, end of frame*/
-		rtp->sl_hdr.accessUnitEndFlag = hdr->Marker;
-		rtp->on_sl_packet(rtp->udta, payload + offset, (u32) (size - offset), &rtp->sl_hdr, GF_OK);
-	} else {
-		/*middle/end of frames - if M bit set, end of frame*/
-		rtp->sl_hdr.accessUnitEndFlag = hdr->Marker;
-		rtp->on_sl_packet(rtp->udta, payload + offset, (u32) (size - offset), &rtp->sl_hdr, GF_OK);
-	}
-}
-
-static void gf_rtp_ttxt_flush(GF_RTPDepacketizer *rtp, u32 ts)
-{
-	GF_BitStream *bs;
-	char *data;
-	u32 data_size;
-	if (!rtp->inter_bs) return;
-
-	rtp->sl_hdr.compositionTimeStamp = ts;
-	rtp->sl_hdr.compositionTimeStampFlag = 1;
-	rtp->sl_hdr.accessUnitStartFlag = 1;
-	rtp->sl_hdr.accessUnitEndFlag = 0;
-	rtp->sl_hdr.randomAccessPointFlag = 1;
-
-	bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-	gf_bs_write_int(bs, rtp->sl_hdr.idleFlag, 1);
-	rtp->sl_hdr.idleFlag = 0;
-	gf_bs_write_int(bs, 0, 4);
-	gf_bs_write_int(bs, 1, 3);
-	gf_bs_write_u16(bs, 8 + (u16) gf_bs_get_position(rtp->inter_bs));
-	gf_bs_write_u8(bs, rtp->sidx);
-	gf_bs_write_u24(bs, rtp->sl_hdr.au_duration);
-	gf_bs_write_u16(bs, rtp->txt_len);
-	gf_bs_get_content(bs, &data, &data_size);
-	gf_bs_del(bs);
-
-	rtp->on_sl_packet(rtp->udta, data, data_size, &rtp->sl_hdr, GF_OK);
-	gf_free(data);
-	rtp->sl_hdr.accessUnitStartFlag = 0;
-	rtp->sl_hdr.accessUnitEndFlag = 1;
-	gf_bs_get_content(rtp->inter_bs, &data, &data_size);
-	rtp->on_sl_packet(rtp->udta, data, data_size, &rtp->sl_hdr, GF_OK);
-	gf_free(data);
-
-	gf_bs_del(rtp->inter_bs);
-	rtp->inter_bs = NULL;
-	rtp->nb_txt_frag = rtp->cur_txt_frag = rtp->sidx = rtp->txt_len = rtp->nb_mod_frag = 0;
-}
-
-static void gf_rtp_parse_ttxt(GF_RTPDepacketizer *rtp, GF_RTPHeader *hdr, char *payload, u32 size)
-{
-	Bool is_utf_16;
-	u32 type, ttu_len, duration, ts, sidx, txt_size;
-	u32 nb_frag, cur_frag;
-	u64 pay_start;
-	GF_BitStream *bs;
-
-	ts = hdr->TimeStamp;
-
-	bs = gf_bs_new(payload, size, GF_BITSTREAM_READ);
-	while (gf_bs_available(bs)) {
-		pay_start = gf_bs_get_position(bs);
-		is_utf_16 = (Bool)gf_bs_read_int(bs, 1);
-		gf_bs_read_int(bs, 4);
-		type = gf_bs_read_int(bs, 3);
-		ttu_len = gf_bs_read_u16(bs);
-		if (ttu_len<2) break;
-
-		if (type==1) {
-			/*flush any existing packet*/
-			gf_rtp_ttxt_flush(rtp, (u32) rtp->sl_hdr.compositionTimeStamp);
-
-			/*bad ttu(1)*/
-			if (ttu_len<8) break;
-			rtp->sl_hdr.compositionTimeStamp = ts;
-			rtp->sl_hdr.compositionTimeStampFlag = 1;
-			rtp->sl_hdr.accessUnitStartFlag = 1;
-			rtp->sl_hdr.accessUnitEndFlag = 1;
-			rtp->sl_hdr.randomAccessPointFlag = 1;
-			gf_bs_read_u8(bs);
-			rtp->sl_hdr.au_duration = gf_bs_read_u24(bs);
-			rtp->on_sl_packet(rtp->udta, payload + pay_start, ttu_len + 1, &rtp->sl_hdr, GF_OK);
-			gf_bs_skip_bytes(bs, ttu_len - 6);
-			ts += rtp->sl_hdr.au_duration;
-		}
-		/*text segment*/
-		else if (type==2) {
-			/*TS changed, flush packet*/
-			if (rtp->sl_hdr.compositionTimeStamp < ts) {
-				gf_rtp_ttxt_flush(rtp, (u32) rtp->sl_hdr.compositionTimeStamp);
-			}
-			if (ttu_len<9) break;
-			rtp->sl_hdr.compositionTimeStamp = ts;
-			rtp->sl_hdr.idleFlag = is_utf_16;
-			nb_frag = gf_bs_read_int(bs, 4);
-			cur_frag = gf_bs_read_int(bs, 4);
-			duration = gf_bs_read_u24(bs);
-			sidx = gf_bs_read_u8(bs);
-			gf_bs_read_u16(bs);/*complete text sample size, ignored*/
-			txt_size = size - 10;
-
-			/*init - 3GPP/MPEG-4 splitting is IMHO stupid:
-				- nb frag & cur frags are not needed: rtp reordering insures packet are in order, and
-			!!!we assume fragments are sent in order!!!
-				- any other TTU suffices to indicate end of text string (modifiers or != RTP TS)
-				- replacing these 8bits field with a 16 bit absolute character offset would add error recovery
-			*/
-			if (!rtp->nb_txt_frag) {
-				rtp->nb_txt_frag = nb_frag;
-				rtp->cur_txt_frag = 0;
-				rtp->sidx = sidx;
-			}
-			/*flush prev if any mismatch*/
-			if ((nb_frag != rtp->nb_txt_frag) || (rtp->cur_txt_frag > cur_frag)) {
-				gf_rtp_ttxt_flush(rtp, (u32) rtp->sl_hdr.compositionTimeStamp);
-				rtp->nb_txt_frag = nb_frag;
-				rtp->sidx = sidx;
-			}
-			if (!rtp->inter_bs) rtp->inter_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-
-			/*we don't reorder - RTP reordering is done at lower level, if this is out of order too bad*/
-			rtp->cur_txt_frag = cur_frag;
-			gf_bs_write_data(rtp->inter_bs, payload+10, txt_size);
-			gf_bs_skip_bytes(bs, txt_size);
-
-			rtp->sl_hdr.au_duration = duration;
-			/*done*/
-			if (hdr->Marker) {
-				assert(gf_bs_get_position(rtp->inter_bs) < 1<<7);
-				rtp->txt_len = (u8) gf_bs_get_position(rtp->inter_bs);
-				gf_rtp_ttxt_flush(rtp, ts);
-			}
-		} else if ((type==3) || (type==4)) {
-			if (!rtp->inter_bs) rtp->inter_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-			/*first modifier, store effective written text*/
-			if (type==3) {
-				assert(gf_bs_get_position(rtp->inter_bs) < 1<<7);
-				rtp->txt_len = (u8) gf_bs_get_position(rtp->inter_bs);
-			}
-			if (ttu_len<6) break;
-
-			nb_frag = gf_bs_read_int(bs, 4);
-			if (!rtp->nb_mod_frag) rtp->nb_mod_frag = nb_frag;
-			else if (rtp->nb_mod_frag != nb_frag) {
-				gf_rtp_ttxt_flush(rtp, (u32) rtp->sl_hdr.compositionTimeStamp);
-				rtp->nb_mod_frag = nb_frag;
-			}
-			gf_bs_read_int(bs, 4);  /*cur_frag, ignore*/
-			rtp->sl_hdr.au_duration = gf_bs_read_u24(bs);
-			gf_bs_write_data(rtp->inter_bs, payload+7, ttu_len-6);
-			gf_bs_skip_bytes(bs, ttu_len-6);
-
-			/*done*/
-			if (hdr->Marker) gf_rtp_ttxt_flush(rtp, ts);
-		}
-	}
-	gf_bs_del(bs);
-}
-
-static void gf_rtp_h264_flush(GF_RTPDepacketizer *rtp, GF_RTPHeader *hdr, Bool missed_end)
-{
-	char *data;
-	u32 data_size, nal_s;
-	if (!rtp->inter_bs) return;
-
-	data = NULL;
-	data_size = 0;
-	gf_bs_get_content(rtp->inter_bs, &data, &data_size);
-	gf_bs_del(rtp->inter_bs);
-	rtp->inter_bs = NULL;
-	nal_s = data_size-4;
-
-	if (rtp->flags & GF_RTP_AVC_USE_ANNEX_B) {
-		data[0] = data[1] = data[2] = 0;
-		data[3] = 1;
-	} else {
-		data[0] = nal_s>>24;
-		data[1] = nal_s>>16;
-		data[2] = nal_s>>8;
-		data[3] = nal_s&0xFF;
-	}
-	/*set F-bit since nal is corrupted*/
-	if (missed_end) data[4] |= 0x80;
-
-	rtp->sl_hdr.accessUnitEndFlag = (rtp->flags & GF_RTP_UNRELIABLE_M) ? 0 : hdr->Marker;
-	rtp->sl_hdr.compositionTimeStampFlag = 1;
-	rtp->sl_hdr.compositionTimeStamp = hdr->TimeStamp;
-	rtp->sl_hdr.decodingTimeStampFlag = 0;
-	rtp->on_sl_packet(rtp->udta, data, data_size, &rtp->sl_hdr, GF_OK);
-	rtp->sl_hdr.accessUnitStartFlag = 0;
-	rtp->sl_hdr.randomAccessPointFlag = 0;
-	gf_free(data);
-}
-
-void gf_rtp_parse_h264(GF_RTPDepacketizer *rtp, GF_RTPHeader *hdr, char *payload, u32 size)
-{
-	char nalhdr[4];
-	u32 nal_type;
-	if (rtp->h264_pck_mode==2) return;
-
-	nal_type = payload[0] & 0x1F;
-
-	/*set start*/
-	if (rtp->sl_hdr.compositionTimeStamp != hdr->TimeStamp) {
-		if (rtp->flags & GF_RTP_UNRELIABLE_M) {
-			rtp->sl_hdr.accessUnitEndFlag = 1;
-			rtp->on_sl_packet(rtp->udta, NULL, 0, &rtp->sl_hdr, GF_OK);
-		}
-		rtp->sl_hdr.accessUnitEndFlag = 0;
-		rtp->sl_hdr.accessUnitStartFlag = 1;
-		rtp->sl_hdr.compositionTimeStamp = hdr->TimeStamp;
-		rtp->sl_hdr.compositionTimeStampFlag = 1;
-		rtp->sl_hdr.decodingTimeStampFlag = 0;
-		rtp->sl_hdr.randomAccessPointFlag = 0;
-	} else if (rtp->sl_hdr.accessUnitEndFlag) {
-		rtp->flags |= GF_RTP_UNRELIABLE_M;
-		GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, ("[H264 RTP] error in Marker bit - switching to unreliable mode\n"));
-	}
-
-	/*single NALU*/
-	if (nal_type<23) {
-		if (nal_type==5) {
-			rtp->sl_hdr.randomAccessPointFlag = 1;
-			rtp->flags &= ~GF_RTP_AVC_WAIT_RAP;
-		}
-		else if (rtp->flags & GF_RTP_AVC_WAIT_RAP)
-			return;
-
-		rtp->sl_hdr.accessUnitEndFlag = 0;
-
-		if (rtp->flags & GF_RTP_AVC_USE_ANNEX_B) {
-			nalhdr[0] = 0;
-			nalhdr[1] = 0;
-			nalhdr[2] = 0;
-			nalhdr[3] = 1;
-		} else {
-			/*signal NALU size on 4 bytes*/
-			nalhdr[0] = size>>24;
-			nalhdr[1] = size>>16;
-			nalhdr[2] = size>>8;
-			nalhdr[3] = size&0xFF;
-		}
-		rtp->on_sl_packet(rtp->udta, nalhdr, 4, &rtp->sl_hdr, GF_OK);
-
-		rtp->sl_hdr.accessUnitStartFlag = 0;
-		rtp->sl_hdr.compositionTimeStampFlag = 1;
-		rtp->sl_hdr.compositionTimeStamp = hdr->TimeStamp;
-		rtp->sl_hdr.accessUnitEndFlag = (rtp->flags & GF_RTP_UNRELIABLE_M) ? 0 : hdr->Marker;
-
-		/*send NAL payload*/
-		rtp->on_sl_packet(rtp->udta, payload, size, &rtp->sl_hdr, GF_OK);
-	}
-	/*STAP-A NALU*/
-	else if (nal_type==24) {
-		u32 offset = 1;
-		while (offset<size) {
-			Bool send = GF_TRUE;
-			u32 nal_size = (u8) payload[offset];
-			nal_size<<=8;
-			nal_size |= (u8) payload[offset+1];
-			offset += 2;
-			if ((payload[offset] & 0x1F) == 5) {
-				rtp->sl_hdr.randomAccessPointFlag = 1;
-				rtp->flags &= ~GF_RTP_AVC_WAIT_RAP;
-			}
-			if (rtp->flags & GF_RTP_AVC_WAIT_RAP) send = GF_FALSE;
-
-			if (send) {
-				/*signal NALU size on 4 bytes*/
-				if (rtp->flags & GF_RTP_AVC_USE_ANNEX_B) {
-					nalhdr[0] = 0;
-					nalhdr[1] = 0;
-					nalhdr[2] = 0;
-					nalhdr[3] = 1;
-				} else {
-					nalhdr[0] = nal_size>>24;
-					nalhdr[1] = nal_size>>16;
-					nalhdr[2] = nal_size>>8;
-					nalhdr[3] = nal_size&0xFF;
-				}
-				rtp->on_sl_packet(rtp->udta, nalhdr, 4, &rtp->sl_hdr, GF_OK);
-				rtp->sl_hdr.accessUnitStartFlag = 0;
-				rtp->sl_hdr.compositionTimeStampFlag = 0;
-			}
-			rtp->sl_hdr.accessUnitEndFlag = (!(rtp->flags & GF_RTP_UNRELIABLE_M) && hdr->Marker && (offset+nal_size==size)) ? 1 : 0;
-			if (send) rtp->on_sl_packet(rtp->udta, payload+offset, nal_size, &rtp->sl_hdr, GF_OK);
-			offset += nal_size;
-		}
-	}
-	/*FU-A NALU*/
-	else if (nal_type==28) {
-		Bool is_start = payload[1] & 0x80;
-		Bool is_end = payload[1] & 0x40;
-		/*flush*/
-		if (is_start) gf_rtp_h264_flush(rtp, hdr, GF_TRUE);
-
-		if ((payload[1] & 0x1F) == 5) {
-			rtp->flags &= ~GF_RTP_AVC_WAIT_RAP;
-			rtp->sl_hdr.randomAccessPointFlag = 1;
-		} else if (rtp->flags & GF_RTP_AVC_WAIT_RAP)
-			return;
-
-		/*setup*/
-		if (!rtp->inter_bs) {
-			u8 nal_hdr;
-			rtp->inter_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-			/*copy F and NRI*/
-			nal_hdr = payload[0] & 0xE0;
-			/*start bit not set, signal corrupted data (we missed start packet)*/
-			if (!is_start) nal_hdr |= 0x80;
-			/*copy NALU type*/
-			nal_hdr |= (payload[1] & 0x1F);
-			/*dummy size field*/
-			gf_bs_write_u32(rtp->inter_bs, 0);
-			gf_bs_write_u8(rtp->inter_bs, nal_hdr);
-		}
-		gf_bs_write_data(rtp->inter_bs, payload+2, size-2);
-		if (is_end || hdr->Marker) gf_rtp_h264_flush(rtp, hdr, GF_FALSE);
-	}
-}
-
-#if !defined(GPAC_DISABLE_HEVC) && !defined(GPAC_DISABLE_AV_PARSERS)
-
-static void gf_rtp_hevc_flush(GF_RTPDepacketizer *rtp, GF_RTPHeader *hdr, Bool missed_end)
-{
-	char *data;
-	u32 data_size, nal_s;
-	if (!rtp->inter_bs) return;
-
-	data = NULL;
-	data_size = 0;
-	gf_bs_get_content(rtp->inter_bs, &data, &data_size);
-	gf_bs_del(rtp->inter_bs);
-	rtp->inter_bs = NULL;
-	nal_s = data_size-4;
-
-	data[0] = nal_s>>24;
-	data[1] = nal_s>>16;
-	data[2] = nal_s>>8;
-	data[3] = nal_s&0xFF;
-	/*set F-bit since nal is corrupted*/
-	if (missed_end) data[4] |= 0x80;
-
-	rtp->sl_hdr.accessUnitEndFlag = (rtp->flags & GF_RTP_UNRELIABLE_M) ? 0 : hdr->Marker;
-	rtp->sl_hdr.compositionTimeStampFlag = 1;
-	rtp->sl_hdr.compositionTimeStamp = hdr->TimeStamp;
-	rtp->sl_hdr.decodingTimeStampFlag = 0;
-	rtp->on_sl_packet(rtp->udta, data, data_size, &rtp->sl_hdr, GF_OK);
-	rtp->sl_hdr.accessUnitStartFlag = 0;
-	rtp->sl_hdr.randomAccessPointFlag = 0;
-	gf_free(data);
-}
-
-static void gf_rtp_parse_hevc(GF_RTPDepacketizer *rtp, GF_RTPHeader *hdr, char *payload, u32 size)
-{
-	u32 nal_type;
-	char nalu_size[4];
-
-	nal_type = (payload[0] & 0x7E) >> 1;
-
-	/*set start*/
-	if (rtp->sl_hdr.compositionTimeStamp != hdr->TimeStamp) {
-		if (rtp->flags & GF_RTP_UNRELIABLE_M) {
-			rtp->sl_hdr.accessUnitEndFlag = 1;
-			rtp->on_sl_packet(rtp->udta, NULL, 0, &rtp->sl_hdr, GF_OK);
-		}
-		rtp->sl_hdr.accessUnitEndFlag = 0;
-		rtp->sl_hdr.accessUnitStartFlag = 1;
-		rtp->sl_hdr.compositionTimeStamp = hdr->TimeStamp;
-		rtp->sl_hdr.compositionTimeStampFlag = 1;
-		rtp->sl_hdr.decodingTimeStampFlag = 0;
-		rtp->sl_hdr.randomAccessPointFlag = 0;
-	} else if (rtp->sl_hdr.accessUnitEndFlag) {
-		rtp->flags |= GF_RTP_UNRELIABLE_M;
-		GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, ("[HEVC RTP] error in Marker bit - switching to unreliable mode\n"));
-	}
-
-	/*Single NALU*/
-	if (nal_type <= 40) {
-		/*FIXME: strict condition for randomAccessPointFlag because of decoder's issue*/
-		if ((nal_type==GF_HEVC_NALU_SLICE_IDR_W_DLP) || (nal_type==GF_HEVC_NALU_SLICE_IDR_N_LP)) {
-			//if ((nal_type>=GF_HEVC_NALU_SLICE_BLA_W_LP) && (nal_type<=GF_HEVC_NALU_SLICE_CRA)) {
-			rtp->sl_hdr.randomAccessPointFlag = 1;
-		}
-
-		rtp->sl_hdr.accessUnitEndFlag = 0;
-
-		/*signal NALU size on 4 bytes*/
-		nalu_size[0] = size>>24;
-		nalu_size[1] = size>>16;
-		nalu_size[2] = size>>8;
-		nalu_size[3] = size&0xFF;
-		rtp->on_sl_packet(rtp->udta, nalu_size, 4, &rtp->sl_hdr, GF_OK);
-
-		rtp->sl_hdr.accessUnitStartFlag = 0;
-		rtp->sl_hdr.compositionTimeStampFlag = 1;
-		rtp->sl_hdr.compositionTimeStamp = hdr->TimeStamp;
-		rtp->sl_hdr.accessUnitEndFlag = (rtp->flags & GF_RTP_UNRELIABLE_M) ? 0 : hdr->Marker;
-
-		/*send NAL payload*/
-		rtp->on_sl_packet(rtp->udta, payload, size, &rtp->sl_hdr, GF_OK);
-	}
-	/*AP NALU*/
-	else if (nal_type == 48) {
-		u32 offset = 2;
-		while (offset<size) {
-			u32 nal_size = (u8) payload[offset];
-			nal_size<<=8;
-			nal_size |= (u8) payload[offset+1];
-			offset += 2;
-			nal_type = (payload[offset] & 0x7E) >> 1;
-			/*FIXME: strict condition for randomAccessPointFlag because of decoder's issue*/
-			if ((nal_type==GF_HEVC_NALU_SLICE_IDR_W_DLP) || (nal_type==GF_HEVC_NALU_SLICE_IDR_N_LP)) {
-				//if ((nal_type>=GF_HEVC_NALU_SLICE_BLA_W_LP) && (nal_type<=GF_HEVC_NALU_SLICE_CRA)) {
-				rtp->sl_hdr.randomAccessPointFlag = 1;
-			}
-
-			/*signal NALU size on 4 bytes*/
-			nalu_size[0] = nal_size>>24;
-			nalu_size[1] = nal_size>>16;
-			nalu_size[2] = nal_size>>8;
-			nalu_size[3] = nal_size&0xFF;
-			rtp->on_sl_packet(rtp->udta, nalu_size, 4, &rtp->sl_hdr, GF_OK);
-
-			rtp->sl_hdr.accessUnitStartFlag = 0;
-			rtp->sl_hdr.compositionTimeStampFlag = 0;
-			rtp->sl_hdr.accessUnitEndFlag = (!(rtp->flags & GF_RTP_UNRELIABLE_M) && hdr->Marker && (offset+nal_size==size)) ? 1 : 0;
-			rtp->on_sl_packet(rtp->udta, payload+offset, nal_size, &rtp->sl_hdr, GF_OK);
-			offset += nal_size;
-		}
-	}
-	/*FU NALU*/
-	else if (nal_type == 49) {
-		Bool is_start = payload[2] & 0x80;
-		Bool is_end = payload[2] & 0x40;
-		/*flush*/
-		if (is_start) gf_rtp_hevc_flush(rtp, hdr, GF_TRUE);
-
-		nal_type = payload[2] & 0x3F;
-		/*FIXME: strict condition for randomAccessPointFlag because of decoder's issue*/
-		if ((nal_type==GF_HEVC_NALU_SLICE_IDR_W_DLP) || (nal_type==GF_HEVC_NALU_SLICE_IDR_N_LP)) {
-			//if ((nal_type>=GF_HEVC_NALU_SLICE_BLA_W_LP) && (nal_type<=GF_HEVC_NALU_SLICE_CRA)) {
-			rtp->sl_hdr.randomAccessPointFlag = 1;
-		}
-
-		/*setup*/
-		if (!rtp->inter_bs) {
-			char nal_hdr[2];
-			rtp->inter_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-			/*coypy F bit highest bit of LayerId*/
-			nal_hdr[0] = payload[0] & 0x81;
-			/*assign NAL type*/
-			nal_hdr[0] |= (payload[2] & 0x3F) << 1;
-			/*copy LayerId and TID*/
-			nal_hdr[1] = payload[1];
-			/*dummy size field*/
-			gf_bs_write_u32(rtp->inter_bs, 0);
-			gf_bs_write_data(rtp->inter_bs, nal_hdr, 2);
-		}
-		gf_bs_write_data(rtp->inter_bs, payload+3, size-3);
-		if (is_end || hdr->Marker) gf_rtp_hevc_flush(rtp, hdr, GF_FALSE);
-	}
-}
-#endif
-
-#ifndef GPAC_DISABLE_AV_PARSERS
-
-static void gf_rtp_parse_latm(GF_RTPDepacketizer *rtp, GF_RTPHeader *hdr, char *payload, u32 size)
-{
-	u32 remain, latm_hdr_size, latm_size;
-
-	rtp->sl_hdr.compositionTimeStamp = hdr->TimeStamp;
-	rtp->sl_hdr.compositionTimeStampFlag = 1;
-	rtp->sl_hdr.accessUnitStartFlag = rtp->sl_hdr.accessUnitEndFlag = 1;
-	rtp->sl_hdr.randomAccessPointFlag = 1;
-
-	remain = size;
-	while (remain) {
-		latm_hdr_size = latm_size = 0;
-		while (1) {
-			u8 c = *payload;
-			latm_hdr_size += 1;
-			latm_size += c;
-			payload ++;
-			if (c < 0xFF) break;
-		}
-
-		rtp->on_sl_packet(rtp->udta, (char *) payload, latm_size, &rtp->sl_hdr, GF_OK);
-		payload += latm_size;
-		remain -= (latm_size+latm_hdr_size);
-		rtp->sl_hdr.compositionTimeStamp += rtp->sl_hdr.au_duration;
-	}
-}
-#endif
-
-static void gf_rtp_parse_3gpp_dims(GF_RTPDepacketizer *rtp, GF_RTPHeader *hdr, char *payload, u32 size)
-{
-	u32 du_size, offset, dsize, hdr_size;
-	char *data, dhdr[6];
-
-	u32 frag_state = ((payload[0]>>3) & 0x7);
-
-	rtp->sl_hdr.compositionTimeStamp = hdr->TimeStamp;
-	rtp->sl_hdr.compositionTimeStampFlag = 1;
-
-	if (rtp->flags & GF_RTP_NEW_AU) {
-		rtp->flags &= ~GF_RTP_NEW_AU;
-		rtp->sl_hdr.accessUnitStartFlag = 1;
-	}
-	rtp->sl_hdr.accessUnitEndFlag = 0;
-	if (hdr->Marker) rtp->flags |= GF_RTP_NEW_AU;
-
-	rtp->sl_hdr.randomAccessPointFlag = (payload[0] & 0x40);
-	rtp->sl_hdr.AU_sequenceNumber = (payload[0] & 0x7);
-
-	offset = 1;
-	while (offset < size) {
-		switch (frag_state) {
-		case 0:
-		{
-			GF_BitStream *bs;
-			bs = gf_bs_new(payload+offset, 2, GF_BITSTREAM_READ);
-			du_size = 2 + gf_bs_read_u16(bs);
-			gf_bs_del(bs);
-			if (hdr->Marker && offset+du_size>=size) {
-				rtp->sl_hdr.accessUnitEndFlag = 1;
-			}
-			rtp->on_sl_packet(rtp->udta, payload + offset, du_size, &rtp->sl_hdr, GF_OK);
-			rtp->sl_hdr.accessUnitStartFlag = 0;
-			offset += du_size;
-		}
-		break;
-		case 1:
-			if (rtp->inter_bs) gf_bs_del(rtp->inter_bs);
-
-			rtp->inter_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-			gf_bs_write_data(rtp->inter_bs, payload+offset, size-offset);
-			return;
-		case 2:
-			if (!rtp->inter_bs) return;
-			gf_bs_write_data(rtp->inter_bs, payload+offset, size-offset);
-			return;
-		case 3:
-			if (!rtp->inter_bs) return;
-			gf_bs_write_data(rtp->inter_bs, payload+offset, size-offset);
-			gf_bs_get_content(rtp->inter_bs, &data, &dsize);
-			gf_bs_del(rtp->inter_bs);
-
-			/*send unit header - if dims size is >0xFFFF, use our internal hack for large units*/
-			rtp->inter_bs = gf_bs_new(dhdr, 6, GF_BITSTREAM_WRITE);
-			if (dsize<=0xFFFF) {
-				gf_bs_write_u16(rtp->inter_bs, dsize);
-				hdr_size = 2;
-			} else {
-				gf_bs_write_u16(rtp->inter_bs, 0);
-				gf_bs_write_u32(rtp->inter_bs, dsize);
-				hdr_size = 6;
-			}
-			gf_bs_del(rtp->inter_bs);
-			rtp->inter_bs = NULL;
-
-			rtp->on_sl_packet(rtp->udta, dhdr, hdr_size, &rtp->sl_hdr, GF_OK);
-			rtp->sl_hdr.accessUnitStartFlag = 0;
-
-			rtp->sl_hdr.accessUnitEndFlag = hdr->Marker;
-			rtp->on_sl_packet(rtp->udta, data, dsize, &rtp->sl_hdr, GF_OK);
-			gf_free(data);
-			return;
-		}
-	}
-
-}
-
-#ifndef GPAC_DISABLE_AV_PARSERS
-
-static void gf_rtp_parse_ac3(GF_RTPDepacketizer *rtp, GF_RTPHeader *hdr, char *payload, u32 size)
-{
-	u8 ft;
-
-	rtp->sl_hdr.compositionTimeStampFlag = 1;
-	rtp->sl_hdr.compositionTimeStamp = hdr->TimeStamp;
-	ft = payload[0];
-	/*nb_pck = payload[1];*/
-	payload += 2;
-	size -= 2;
-
-	if (!ft) {
-		GF_AC3Header hdr;
-		memset(&hdr, 0, sizeof(GF_AC3Header));
-		rtp->sl_hdr.accessUnitStartFlag = rtp->sl_hdr.accessUnitEndFlag = 1;
-		while (size) {
-			u32 offset;
-			if (!gf_ac3_parser((u8*)payload, size, &offset, &hdr, GF_FALSE)) {
-				return;
-			}
-			if (offset) {
-				if (offset>size) return;
-				payload+=offset;
-				size-=offset;
-			}
-			rtp->on_sl_packet(rtp->udta, payload, hdr.framesize, &rtp->sl_hdr, GF_OK);
-			if (size < hdr.framesize) return;
-			size -= hdr.framesize;
-			payload += hdr.framesize;
-			rtp->sl_hdr.compositionTimeStamp += 1536;
-		}
-		rtp->flags |= GF_RTP_NEW_AU;
-	} else if (ft==3) {
-		rtp->sl_hdr.accessUnitStartFlag = 0;
-		rtp->sl_hdr.accessUnitEndFlag = hdr->Marker ? 1 : 0;
-		rtp->on_sl_packet(rtp->udta, payload, size, &rtp->sl_hdr, GF_OK);
-	} else {
-		rtp->sl_hdr.accessUnitStartFlag = 1;
-		rtp->sl_hdr.accessUnitEndFlag = 0;
-		rtp->on_sl_packet(rtp->udta, payload, size, &rtp->sl_hdr, GF_OK);
-	}
-}
-#endif /*GPAC_DISABLE_AV_PARSERS*/
-
-static u32 gf_rtp_get_payload_type(GF_RTPMap *map, GF_SDPMedia *media)
-{
-	u32 i, j;
-
-	if (!stricmp(map->payload_name, "MP4V-ES") ) return GF_RTP_PAYT_MPEG4;
-	else if (!stricmp(map->payload_name, "mpeg4-generic")) return GF_RTP_PAYT_MPEG4;
-	else if (!stricmp(map->payload_name, "enc-mpeg4-generic")) return GF_RTP_PAYT_MPEG4;
-	/*optibase mm400 card hack*/
-	else if (!stricmp(map->payload_name, "enc-generic-mp4") ) {
-		gf_free(map->payload_name);
-		map->payload_name = gf_strdup("enc-mpeg4-generic");
-		return GF_RTP_PAYT_MPEG4;
-	}
-
-	/*LATM: only without multiplexing (not tested but should be straight AUs)*/
-	else if (!stricmp(map->payload_name, "MP4A-LATM")) {
-		GF_SDP_FMTP *fmtp;
-		i=0;
-		while ((fmtp = (GF_SDP_FMTP *) gf_list_enum(media->FMTP, &i))) {
-			GF_X_Attribute *att;
-			if (fmtp->PayloadType != map->PayloadType) continue;
-			//this is our payload. check cpresent is 0
-			j=0;
-			while ((att = (GF_X_Attribute *)gf_list_enum(fmtp->Attributes, &j))) {
-				if (!stricmp(att->Name, "cpresent") && atoi(att->Value)) return 0;
-			}
-		}
-		return GF_RTP_PAYT_LATM;
-	}
-	else if (!stricmp(map->payload_name, "MPA")) return GF_RTP_PAYT_MPEG12_AUDIO;
-	else if (!stricmp(map->payload_name, "MPV")) return GF_RTP_PAYT_MPEG12_VIDEO;
-	else if (!stricmp(map->payload_name, "H263-1998") || !stricmp(map->payload_name, "H263-2000")) return GF_RTP_PAYT_H263;
-	else if (!stricmp(map->payload_name, "AMR")) return GF_RTP_PAYT_AMR;
-	else if (!stricmp(map->payload_name, "AMR-WB")) return GF_RTP_PAYT_AMR_WB;
-	else if (!stricmp(map->payload_name, "3gpp-tt")) return GF_RTP_PAYT_3GPP_TEXT;
-	else if (!stricmp(map->payload_name, "H264")) return GF_RTP_PAYT_H264_AVC;
-	else if (!stricmp(map->payload_name, "richmedia+xml")) return GF_RTP_PAYT_3GPP_DIMS;
-	else if (!stricmp(map->payload_name, "ac3")) return GF_RTP_PAYT_AC3;
-	else if (!stricmp(map->payload_name, "H264-SVC")) return GF_RTP_PAYT_H264_SVC;
-	else if (!stricmp(map->payload_name, "H265")) return GF_RTP_PAYT_HEVC;
-	else if (!stricmp(map->payload_name, "H265-SHVC")) return GF_RTP_PAYT_SHVC;
-	else return 0;
-}
-
-
-static GF_Err payt_set_param(GF_RTPDepacketizer *rtp, char *param_name, char *param_val)
-{
-	u32 i, val;
-	char valS[3];
-	GF_BitStream *bs;
-
-	if (!rtp || !param_name) return GF_BAD_PARAM;
-
-	/*1 - mpeg4-generic / RFC 3016 payload type items*/
-
-	/*PL (not needed when IOD is here)*/
-	if (!stricmp(param_name, "Profile-level-id")) {
-		if (rtp->payt == GF_RTP_PAYT_H264_AVC || rtp->payt == GF_RTP_PAYT_H264_SVC) {
-			sscanf(param_val, "%x", &rtp->sl_map.PL_ID);
-		} else {
-			rtp->sl_map.PL_ID = atoi(param_val);
-		}
-	}
-	/*decoder specific info (not needed when IOD is here)*/
-	else if (!stricmp(param_name, "config")) {
-		u32 len = (u32) strlen(param_val);
-		//decode the buffer - the string buffer is MSB hexadecimal
-		bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-		valS[2] = 0;
-		for (i=0; i<len; i+=2) {
-			valS[0] = param_val[i];
-			valS[1] = param_val[i+1];
-			sscanf(valS, "%x", &val);
-			gf_bs_write_u8(bs, val);
-		}
-		if (rtp->sl_map.config) gf_free(rtp->sl_map.config);
-		rtp->sl_map.config = NULL;
-		gf_bs_get_content(bs, &rtp->sl_map.config, &rtp->sl_map.configSize);
-		gf_bs_del(bs);
-	}
-	/*mpeg4-generic payload type items required*/
-
-	/*constant size (size of all AUs) */
-	else if (!stricmp(param_name, "ConstantSize")) {
-		rtp->sl_map.ConstantSize = atoi(param_val);
-	}
-	/*constant size (size of all AUs) */
-	else if (!stricmp(param_name, "ConstantDuration")) {
-		rtp->sl_map.ConstantDuration = atoi(param_val);
-	}
-	/*object type indication (not needed when IOD is here)*/
-	else if (!stricmp(param_name, "ObjectType")) {
-		rtp->sl_map.ObjectTypeIndication = atoi(param_val);
-	}
-	else if (!stricmp(param_name, "StreamType"))
-		rtp->sl_map.StreamType = atoi(param_val);
-	else if (!stricmp(param_name, "mode")) {
-		strcpy(rtp->sl_map.mode, param_val);
-		/*in case no IOD and no streamType/OTI in the file*/
-		if (!stricmp(param_val, "AAC-hbr") || !stricmp(param_val, "AAC-lbr") || !stricmp(param_val, "CELP-vbr") || !stricmp(param_val, "CELP-cbr")) {
-			rtp->sl_map.StreamType = GF_STREAM_AUDIO;
-			rtp->sl_map.ObjectTypeIndication = GPAC_OTI_AUDIO_AAC_MPEG4;
-		}
-		/*in case no IOD and no streamType/OTI in the file*/
-		else if (!stricmp(param_val, "avc-video") ) {
-			rtp->sl_map.StreamType = GF_STREAM_VISUAL;
-			rtp->sl_map.ObjectTypeIndication = GPAC_OTI_VIDEO_AVC;
-		}
-	}
-
-	else if (!stricmp(param_name, "DTSDeltaLength")) rtp->sl_map.DTSDeltaLength = atoi(param_val);
-	else if (!stricmp(param_name, "CTSDeltaLength")) rtp->sl_map.CTSDeltaLength = atoi(param_val);
-	else if (!stricmp(param_name, "SizeLength")) rtp->sl_map.SizeLength = atoi(param_val);
-	else if (!stricmp(param_name, "IndexLength")) rtp->sl_map.IndexLength = atoi(param_val);
-	else if (!stricmp(param_name, "IndexDeltaLength")) rtp->sl_map.IndexDeltaLength = atoi(param_val);
-	else if (!stricmp(param_name, "RandomAccessIndication")) rtp->sl_map.RandomAccessIndication = atoi(param_val);
-	else if (!stricmp(param_name, "StreamStateIndication")) rtp->sl_map.StreamStateIndication = atoi(param_val);
-	else if (!stricmp(param_name, "AuxiliaryDataSizeLength")) rtp->sl_map.AuxiliaryDataSizeLength = atoi(param_val);
-
-	/*H264/AVC config - we only handle mode 0 and 1*/
-	else if (!stricmp(param_name, "packetization-mode"))
-		rtp->h264_pck_mode = 1;
-	/*AMR config*/
-	else if (!stricmp(param_name, "octet-align")) {
-		if (!stricmp(param_val, "1"))
-			rtp->flags |= GF_RTP_AMR_ALIGN;
-	} /*ISMACryp config*/
-	else if (!stricmp(param_name, "ISMACrypCryptoSuite")) {
-		if (!stricmp(param_val, "AES_CTR_128"))
-			rtp->isma_scheme = GF_4CC('i','A','E','C');
-		else
-			rtp->isma_scheme = 0;
-	}
-	else if (!stricmp(param_name, "ISMACrypSelectiveEncryption")) {
-		if (!stricmp(param_val, "1") || !stricmp(param_val, "true"))
-			rtp->flags |= GF_RTP_ISMA_SEL_ENC;
-		else
-			rtp->flags &= ~GF_RTP_ISMA_SEL_ENC;
-	}
-	else if (!stricmp(param_name, "ISMACrypIVLength"))
-		rtp->sl_map.IV_length = atoi(param_val);
-	else if (!stricmp(param_name, "ISMACrypDeltaIVLength"))
-		rtp->sl_map.IV_delta_length = atoi(param_val);
-	else if (!stricmp(param_name, "ISMACrypKeyIndicatorLength"))
-		rtp->sl_map.KI_length = atoi(param_val);
-	else if (!stricmp(param_name, "ISMACrypKeyIndicatorPerAU")) {
-		if (!stricmp(param_val, "1") || !stricmp(param_val, "true"))
-			rtp->flags |= GF_RTP_ISMA_HAS_KEY_IDX;
-		else
-			rtp->flags &= ~GF_RTP_ISMA_HAS_KEY_IDX;
-	} else if (!stricmp(param_name, "ISMACrypKey")) {
-		rtp->key = gf_strdup(param_val);
-	}
-	return GF_OK;
-}
-
-static GF_Err gf_rtp_payt_setup(GF_RTPDepacketizer *rtp, GF_RTPMap *map, GF_SDPMedia *media)
-{
-	u32 i, j;
-	GF_SDP_FMTP *fmtp;
-
-	/*reset sl map*/
-	memset(&rtp->sl_map, 0, sizeof(GP_RTPSLMap));
-
-	if (!stricmp(map->payload_name, "enc-mpeg4-generic")) rtp->flags |= GF_RTP_HAS_ISMACRYP;
-
-
-	/*then process all FMTPs*/
-	i=0;
-	while ((fmtp = (GF_SDP_FMTP*)gf_list_enum(media->FMTP, &i))) {
-		GF_X_Attribute *att;
-		//we work with only one PayloadType for now
-		if (fmtp->PayloadType != map->PayloadType) continue;
-		j=0;
-		while ((att = (GF_X_Attribute *)gf_list_enum(fmtp->Attributes, &j))) {
-			payt_set_param(rtp, att->Name, att->Value);
-		}
-	}
-
-	switch (rtp->payt) {
-#ifndef GPAC_DISABLE_AV_PARSERS
-	case GF_RTP_PAYT_LATM:
-	{
-		u32 AudioMuxVersion, AllStreamsSameTime, numSubFrames, numPrograms, numLayers, ch_cfg;
-		GF_M4ADecSpecInfo cfg;
-		char *latm_dsi = rtp->sl_map.config;
-		GF_BitStream *bs = gf_bs_new(latm_dsi, rtp->sl_map.configSize, GF_BITSTREAM_READ);
-		AudioMuxVersion = gf_bs_read_int(bs, 1);
-		AllStreamsSameTime = gf_bs_read_int(bs, 1);
-		numSubFrames = gf_bs_read_int(bs, 6);
-		numPrograms = gf_bs_read_int(bs, 4);
-		numLayers = gf_bs_read_int(bs, 3);
-
-		if (AudioMuxVersion || !AllStreamsSameTime || numSubFrames || numPrograms || numLayers) {
-			gf_bs_del(bs);
-			return GF_NOT_SUPPORTED;
-		}
-		memset(&cfg, 0, sizeof(cfg));
-		cfg.base_object_type = gf_bs_read_int(bs, 5);
-		cfg.base_sr_index = gf_bs_read_int(bs, 4);
-		if (cfg.base_sr_index == 0x0F) {
-			cfg.base_sr = gf_bs_read_int(bs, 24);
-		} else {
-			cfg.base_sr = GF_M4ASampleRates[cfg.base_sr_index];
-		}
-		ch_cfg = gf_bs_read_int(bs, 4);
-		if (cfg.base_object_type==5 || cfg.base_object_type==29) {
-			if (cfg.base_object_type==29) {
-				cfg.has_ps = 1;
-				cfg.nb_chan = 1;
-			}
-			cfg.has_sbr = 1;
-			cfg.sbr_sr_index = gf_bs_read_int(bs, 4);
-			if (cfg.sbr_sr_index == 0x0F) {
-				cfg.sbr_sr = gf_bs_read_int(bs, 24);
-			} else {
-				cfg.sbr_sr = GF_M4ASampleRates[cfg.sbr_sr_index];
-			}
-			cfg.sbr_object_type = gf_bs_read_int(bs, 5);
-		}
-		gf_bs_del(bs);
-		gf_free(rtp->sl_map.config);
-		bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-		/*write as regular AAC*/
-		gf_bs_write_int(bs, cfg.base_object_type, 5);
-		gf_bs_write_int(bs, cfg.base_sr_index, 4);
-
-		gf_bs_write_int(bs, ch_cfg, 4);
-		gf_bs_align(bs);
-		gf_bs_get_content(bs, &rtp->sl_map.config, &rtp->sl_map.configSize);
-		gf_bs_del(bs);
-		rtp->sl_map.StreamType = GF_STREAM_AUDIO;
-		rtp->sl_map.ObjectTypeIndication = GPAC_OTI_AUDIO_AAC_MPEG4;
-
-		/*assign depacketizer*/
-		rtp->depacketize = gf_rtp_parse_latm;
-	}
-	break;
-#endif
-	case GF_RTP_PAYT_MPEG4:
-		/*mark if AU header is present*/
-		rtp->sl_map.auh_first_min_len = 0;
-		if (rtp->flags & GF_RTP_HAS_ISMACRYP) {
-			if (!rtp->isma_scheme) rtp->isma_scheme = GF_4CC('i','A','E','C');
-			if (!rtp->sl_map.IV_length) rtp->sl_map.IV_length = 4;
-
-			if (rtp->flags & GF_RTP_ISMA_SEL_ENC) rtp->sl_map.auh_first_min_len += 8;
-			else rtp->sl_map.auh_first_min_len += 8*(rtp->sl_map.IV_length + rtp->sl_map.KI_length);
-		}
-		rtp->sl_map.auh_first_min_len += rtp->sl_map.CTSDeltaLength;
-		rtp->sl_map.auh_first_min_len += rtp->sl_map.DTSDeltaLength;
-		rtp->sl_map.auh_first_min_len += rtp->sl_map.SizeLength;
-		rtp->sl_map.auh_first_min_len += rtp->sl_map.RandomAccessIndication;
-		rtp->sl_map.auh_first_min_len += rtp->sl_map.StreamStateIndication;
-		rtp->sl_map.auh_min_len = rtp->sl_map.auh_first_min_len;
-		rtp->sl_map.auh_first_min_len += rtp->sl_map.IndexLength;
-		rtp->sl_map.auh_min_len += rtp->sl_map.IndexDeltaLength;
-		/*RFC3016 flags*/
-		if (!stricmp(map->payload_name, "MP4V-ES")) {
-			rtp->sl_map.StreamType = GF_STREAM_VISUAL;
-			rtp->sl_map.ObjectTypeIndication = GPAC_OTI_VIDEO_MPEG4_PART2;
-		}
-		else if (!strnicmp(map->payload_name, "AAC", 3)) {
-			rtp->sl_map.StreamType = GF_STREAM_AUDIO;
-			rtp->sl_map.ObjectTypeIndication = GPAC_OTI_AUDIO_AAC_MPEG4;
-		}
-		else if (!stricmp(map->payload_name, "MP4A-LATM")) {
-			rtp->sl_map.StreamType = GF_STREAM_AUDIO;
-			rtp->sl_map.ObjectTypeIndication = GPAC_OTI_AUDIO_AAC_MPEG4;
-		}
-		/*MPEG-4 video, check RAPs if not indicated*/
-		if ((rtp->sl_map.StreamType == GF_STREAM_VISUAL) && (rtp->sl_map.ObjectTypeIndication == GPAC_OTI_VIDEO_MPEG4_PART2) && !rtp->sl_map.RandomAccessIndication) {
-			rtp->flags |= GF_RTP_M4V_CHECK_RAP;
-		}
-#ifndef GPAC_DISABLE_AV_PARSERS
-		if ((rtp->sl_map.ObjectTypeIndication == GPAC_OTI_AUDIO_AAC_MPEG4) && !rtp->sl_map.config) {
-			GF_M4ADecSpecInfo cfg;
-			GF_RTPMap*map = (GF_RTPMap*)gf_list_get(media->RTPMaps, 0);
-
-			memset(&cfg, 0, sizeof(GF_M4ADecSpecInfo));
-			cfg.audioPL = rtp->sl_map.PL_ID;
-			cfg.nb_chan = map->AudioChannels;
-			cfg.nb_chan = 1;
-			cfg.base_sr = map->ClockRate/2;
-			cfg.sbr_sr = map->ClockRate;
-			cfg.base_object_type = GF_M4A_AAC_LC;
-			cfg.base_object_type = 5;
-			cfg.sbr_object_type = GF_M4A_AAC_MAIN;
-			gf_m4a_write_config(&cfg, &rtp->sl_map.config, &rtp->sl_map.configSize);
-		}
-#endif
-		/*assign depacketizer*/
-		rtp->depacketize = gf_rtp_parse_mpeg4;
-		break;
-#ifndef GPAC_DISABLE_AV_PARSERS
-	case GF_RTP_PAYT_MPEG12_AUDIO:
-		rtp->sl_map.StreamType = GF_STREAM_AUDIO;
-		rtp->sl_map.ObjectTypeIndication = GPAC_OTI_AUDIO_MPEG2_PART3;
-		/*assign depacketizer*/
-		rtp->depacketize = gf_rtp_parse_mpeg12_audio;
-		break;
-#endif /*GPAC_DISABLE_AV_PARSERS*/
-
-	case GF_RTP_PAYT_MPEG12_VIDEO:
-		/*we signal RAPs*/
-		rtp->sl_map.RandomAccessIndication = GF_TRUE;
-		rtp->sl_map.StreamType = GF_STREAM_VISUAL;
-		/*FIXME: how to differentiate MPEG1 from MPEG2 video before any frame is received??*/
-		rtp->sl_map.ObjectTypeIndication = GPAC_OTI_VIDEO_MPEG1;
-		/*assign depacketizer*/
-		rtp->depacketize = gf_rtp_parse_mpeg12_video;
-		break;
-	case GF_RTP_PAYT_AMR:
-	case GF_RTP_PAYT_AMR_WB:
-	{
-		GF_BitStream *bs;
-		rtp->sl_map.StreamType = GF_STREAM_AUDIO;
-		rtp->sl_map.ObjectTypeIndication = GPAC_OTI_MEDIA_GENERIC;
-		/*create DSI*/
-		bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-		if (rtp->payt == GF_RTP_PAYT_AMR) {
-			gf_bs_write_u32(bs, GF_4CC('s', 'a', 'm', 'r'));
-			gf_bs_write_u32(bs, 8000);
-			gf_bs_write_u16(bs, 1);
-			gf_bs_write_u16(bs, 160);
-		} else {
-			gf_bs_write_u32(bs, GF_4CC('s', 'a', 'w', 'b'));
-			gf_bs_write_u32(bs, 16000);
-			gf_bs_write_u16(bs, 1);
-			gf_bs_write_u16(bs, 320);
-		}
-		gf_bs_write_u8(bs, 16);
-		gf_bs_write_u8(bs, 1);
-		gf_bs_get_content(bs, &rtp->sl_map.config, &rtp->sl_map.configSize);
-		gf_bs_del(bs);
-		/*assign depacketizer*/
-		rtp->depacketize = gf_rtp_parse_amr;
-	}
-	break;
-	case GF_RTP_PAYT_H263:
-	{
-		u32 x, y, w, h;
-		GF_X_Attribute *att;
-		GF_BitStream *bs;
-		x = y = w = h = 0;
-		j=0;
-		while ((att = (GF_X_Attribute *)gf_list_enum(media->Attributes, &j))) {
-			if (stricmp(att->Name, "cliprect")) continue;
-			/*only get the display area*/
-			sscanf(att->Value, "%u,%u,%u,%u", &y, &x, &h, &w);
-		}
-
-		rtp->sl_map.StreamType = GF_STREAM_VISUAL;
-		rtp->sl_map.ObjectTypeIndication = GPAC_OTI_MEDIA_GENERIC;
-		/*create DSI*/
-		bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-		gf_bs_write_u32(bs, GF_4CC('h', '2', '6', '3'));
-		gf_bs_write_u16(bs, w);
-		gf_bs_write_u16(bs, h);
-		gf_bs_get_content(bs, &rtp->sl_map.config, &rtp->sl_map.configSize);
-		gf_bs_del(bs);
-		/*we signal RAPs*/
-		rtp->sl_map.RandomAccessIndication = GF_TRUE;
-		/*assign depacketizer*/
-		rtp->depacketize = gf_rtp_parse_h263;
-	}
-	break;
-	case GF_RTP_PAYT_3GPP_TEXT:
-	{
-		char *tx3g, *a_tx3g;
-		GF_BitStream *bs;
-		u32 nb_desc;
-		GF_SDP_FMTP *fmtp;
-		GF_TextConfig tcfg;
-		memset(&tcfg, 0, sizeof(GF_TextConfig));
-		tcfg.tag = GF_ODF_TEXT_CFG_TAG;
-		tcfg.Base3GPPFormat = 0x10;
-		tcfg.MPEGExtendedFormat = 0x10;
-		tcfg.profileLevel = 0x10;
-		tcfg.timescale = map->ClockRate;
-		tcfg.sampleDescriptionFlags = 1;
-		tx3g = NULL;
-
-		i=0;
-		while ((fmtp = (GF_SDP_FMTP*)gf_list_enum(media->FMTP, &i))) {
-			GF_X_Attribute *att;
-			if (fmtp->PayloadType != map->PayloadType) continue;
-			j=0;
-			while ((att = (GF_X_Attribute *)gf_list_enum(fmtp->Attributes, &j))) {
-
-				if (!stricmp(att->Name, "width")) tcfg.text_width = atoi(att->Value);
-				else if (!stricmp(att->Name, "height")) tcfg.text_height = atoi(att->Value);
-				else if (!stricmp(att->Name, "tx")) tcfg.horiz_offset = atoi(att->Value);
-				else if (!stricmp(att->Name, "ty")) tcfg.vert_offset = atoi(att->Value);
-				else if (!stricmp(att->Name, "layer")) tcfg.layer = atoi(att->Value);
-				else if (!stricmp(att->Name, "max-w")) tcfg.video_width = atoi(att->Value);
-				else if (!stricmp(att->Name, "max-h")) tcfg.video_height = atoi(att->Value);
-				else if (!stricmp(att->Name, "tx3g")) tx3g = att->Value;
-			}
-		}
-		if (!tx3g) return GF_NON_COMPLIANT_BITSTREAM;
-
-		bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-		gf_bs_write_u8(bs, tcfg.Base3GPPFormat);
-		gf_bs_write_u8(bs, tcfg.MPEGExtendedFormat); /*MPEGExtendedFormat*/
-		gf_bs_write_u8(bs, tcfg.profileLevel); /*profileLevel*/
-		gf_bs_write_u24(bs, tcfg.timescale);
-		gf_bs_write_int(bs, 0, 1);	/*no alt formats*/
-		gf_bs_write_int(bs, tcfg.sampleDescriptionFlags, 2);
-		gf_bs_write_int(bs, 1, 1);	/*we will write sample desc*/
-		gf_bs_write_int(bs, 1, 1);	/*video info*/
-		gf_bs_write_int(bs, 0, 3);	/*reserved, spec doesn't say the values*/
-		gf_bs_write_u8(bs, tcfg.layer);
-		gf_bs_write_u16(bs, tcfg.text_width);
-		gf_bs_write_u16(bs, tcfg.text_height);
-		/*get all tx3g (comma separated)*/
-		nb_desc = 1;
-		a_tx3g = tx3g;
-		while ((a_tx3g = strchr(a_tx3g, ',')) ) {
-			a_tx3g ++;
-			nb_desc ++;
-		}
-		a_tx3g = tx3g;
-		gf_bs_write_u8(bs, nb_desc);
-		while (1) {
-			char *next_tx3g, szOut[1000];
-			u32 len;
-			strcpy(a_tx3g, tx3g);
-			next_tx3g = strchr(a_tx3g, ',');
-			if (next_tx3g) next_tx3g[0] = 0;
-			len = gf_base64_decode(a_tx3g, (u32) strlen(a_tx3g), szOut, 1000);
-			gf_bs_write_data(bs, szOut, len);
-			tx3g = strchr(tx3g, ',');
-			if (!tx3g) break;
-			tx3g += 1;
-			while (tx3g[0] == ' ') tx3g += 1;
-		}
-
-		/*write video cfg*/
-		gf_bs_write_u16(bs, tcfg.video_width);
-		gf_bs_write_u16(bs, tcfg.video_height);
-		gf_bs_write_u16(bs, tcfg.horiz_offset);
-		gf_bs_write_u16(bs, tcfg.vert_offset);
-		gf_bs_get_content(bs, &rtp->sl_map.config, &rtp->sl_map.configSize);
-		rtp->sl_map.StreamType = GF_STREAM_TEXT;
-		rtp->sl_map.ObjectTypeIndication = 0x08;
-		gf_bs_del(bs);
-		/*assign depacketizer*/
-		rtp->depacketize = gf_rtp_parse_ttxt;
-	}
-	break;
-#ifndef GPAC_DISABLE_AV_PARSERS
-	case GF_RTP_PAYT_H264_AVC:
-	case GF_RTP_PAYT_H264_SVC:
-	{
-		GF_SDP_FMTP *fmtp;
-		GF_AVCConfig *avcc = gf_odf_avc_cfg_new();
-		avcc->AVCProfileIndication = (rtp->sl_map.PL_ID>>16) & 0xFF;
-		avcc->profile_compatibility = (rtp->sl_map.PL_ID>>8) & 0xFF;
-		avcc->AVCLevelIndication = rtp->sl_map.PL_ID & 0xFF;
-		avcc->configurationVersion = 1;
-		avcc->nal_unit_size = 4;
-		rtp->sl_map.StreamType = 4;
-		rtp->sl_map.ObjectTypeIndication = GPAC_OTI_VIDEO_AVC;
-		/*we will signal RAPs*/
-		rtp->sl_map.RandomAccessIndication = GF_TRUE;
-		/*rewrite sps and pps*/
-		i=0;
-		while ((fmtp = (GF_SDP_FMTP*)gf_list_enum(media->FMTP, &i))) {
-			GF_X_Attribute *att;
-			if (fmtp->PayloadType != map->PayloadType) continue;
-			j=0;
-			while ((att = (GF_X_Attribute *)gf_list_enum(fmtp->Attributes, &j))) {
-				char *nal_ptr, *sep;
-				if (stricmp(att->Name, "sprop-parameter-sets")) continue;
-
-				nal_ptr = att->Value;
-				while (nal_ptr) {
-					u32 nalt, b64size, ret;
-					char *b64_d;
-
-					sep = strchr(nal_ptr, ',');
-					if (sep) sep[0] = 0;
-
-					b64size = (u32) strlen(nal_ptr);
-					b64_d = (char*)gf_malloc(sizeof(char)*b64size);
-					ret = gf_base64_decode(nal_ptr, b64size, b64_d, b64size);
-					b64_d[ret] = 0;
-
-					nalt = b64_d[0] & 0x1F;
-					if (/*SPS*/(nalt==0x07) || /*PPS*/(nalt==0x08) || /*SSPS*/(nalt==0x0F)) {
-						GF_AVCConfigSlot *sl = (GF_AVCConfigSlot *)gf_malloc(sizeof(GF_AVCConfigSlot));
-						sl->size = ret;
-						sl->data = (char*)gf_malloc(sizeof(char)*sl->size);
-						memcpy(sl->data, b64_d, sizeof(char)*sl->size);
-						if (nalt==0x07 || nalt==0x0F) {
-							gf_list_add(avcc->sequenceParameterSets, sl);
-						} else {
-							gf_list_add(avcc->pictureParameterSets, sl);
-						}
-					}
-					gf_free(b64_d);
-
-					if (sep) {
-						sep[0] = ',';
-						nal_ptr = sep+1;
-					} else {
-						break;
-					}
-				}
-			}
-		}
-		gf_odf_avc_cfg_write(avcc, &rtp->sl_map.config, &rtp->sl_map.configSize);
-		gf_odf_avc_cfg_del(avcc);
-	}
-		/*assign depacketizer*/
-	rtp->depacketize = gf_rtp_parse_h264;
-	break;
-	case GF_RTP_PAYT_HEVC:
-	case GF_RTP_PAYT_SHVC:
-#ifndef GPAC_DISABLE_HEVC
-	{
-		GF_SDP_FMTP *fmtp;
-		GF_HEVCConfig *hevcc = gf_odf_hevc_cfg_new();
-		hevcc->configurationVersion = 1;
-		hevcc->nal_unit_size = 4;
-		rtp->sl_map.StreamType = 4;
-		rtp->sl_map.ObjectTypeIndication = GPAC_OTI_VIDEO_HEVC;
-		/*we will signal RAPs*/
-		rtp->sl_map.RandomAccessIndication = GF_TRUE;
-		i=0;
-		while ((fmtp = (GF_SDP_FMTP*)gf_list_enum(media->FMTP, &i))) {
-			GF_X_Attribute *att;
-			if (fmtp->PayloadType != map->PayloadType) continue;
-			j=0;
-			while ((att = (GF_X_Attribute *)gf_list_enum(fmtp->Attributes, &j))) {
-				char *nal_ptr, *sep;
-				GF_HEVCParamArray *ar;
-				if (!stricmp(att->Name, "sprop-vps")) {
-					GF_SAFEALLOC(ar, GF_HEVCParamArray);
-					ar->nalus = gf_list_new();
-					ar->type = GF_HEVC_NALU_VID_PARAM;
-				}
-				else if (!stricmp(att->Name, "sprop-sps")) {
-					GF_SAFEALLOC(ar, GF_HEVCParamArray);
-					ar->nalus = gf_list_new();
-					ar->type = GF_HEVC_NALU_SEQ_PARAM;
-				}
-				else if (!stricmp(att->Name, "sprop-pps")) {
-					GF_SAFEALLOC(ar, GF_HEVCParamArray);
-					ar->nalus = gf_list_new();
-					ar->type = GF_HEVC_NALU_PIC_PARAM;
-				}
-				else
-					continue;
-				nal_ptr = att->Value;
-				while (nal_ptr) {
-					u32 b64size, ret;
-					char *b64_d;
-					GF_AVCConfigSlot *sl;
-
-					sep = strchr(nal_ptr, ',');
-					if (sep) sep[0] = 0;
-
-					b64size = (u32) strlen(nal_ptr);
-					b64_d = (char*)gf_malloc(sizeof(char)*b64size);
-					ret = gf_base64_decode(nal_ptr, b64size, b64_d, b64size);
-					b64_d[ret] = 0;
-
-					sl = (GF_AVCConfigSlot *)gf_malloc(sizeof(GF_AVCConfigSlot));
-					sl->size = ret;
-					sl->data = (char*)gf_malloc(sizeof(char)*sl->size);
-					memcpy(sl->data, b64_d, sizeof(char)*sl->size);
-					gf_list_add(ar->nalus, sl);
-
-					gf_free(b64_d);
-
-					if (sep) {
-						sep[0] = ',';
-						nal_ptr = sep+1;
-					} else {
-						break;
-					}
-				}
-				if (!hevcc->param_array) hevcc->param_array = gf_list_new();
-				gf_list_add(hevcc->param_array, ar);
-			}
-		}
-		gf_odf_hevc_cfg_write(hevcc, &rtp->sl_map.config, &rtp->sl_map.configSize);
-		gf_odf_hevc_cfg_del(hevcc);
-	}
-	rtp->depacketize = gf_rtp_parse_hevc;
-#else
-	return GF_NOT_SUPPORTED;
-#endif
-	break;
-#endif /*GPAC_DISABLE_AV_PARSERS*/
-
-	/*todo - rewrite DIMS config*/
-	case GF_RTP_PAYT_3GPP_DIMS:
-		rtp->sl_map.StreamType = GF_STREAM_SCENE;
-		rtp->sl_map.ObjectTypeIndication = GPAC_OTI_SCENE_DIMS;
-		/*we will signal RAPs*/
-		rtp->sl_map.RandomAccessIndication = GF_TRUE;
-		/*we map DIMS CTR to AU seq num, hence 3 bits*/
-		rtp->sl_map.StreamStateIndication = 3;
-		rtp->sl_map.IndexLength = 3;
-		/*assign depacketizer*/
-		rtp->depacketize = gf_rtp_parse_3gpp_dims;
-		break;
-#ifndef GPAC_DISABLE_AV_PARSERS
-	case GF_RTP_PAYT_AC3:
-		rtp->sl_map.StreamType = GF_STREAM_AUDIO;
-		rtp->sl_map.ObjectTypeIndication = 0xA5;
-		rtp->sl_map.RandomAccessIndication = GF_TRUE;
-		/*assign depacketizer*/
-		rtp->depacketize = gf_rtp_parse_ac3;
-		break;
-#endif /*GPAC_DISABLE_AV_PARSERS*/
-	default:
-		return GF_NOT_SUPPORTED;
-	}
-	return GF_OK;
-}
-
-GF_EXPORT
-GF_RTPDepacketizer *gf_rtp_depacketizer_new(GF_SDPMedia *media, void (*sl_packet_cbk)(void *udta, char *payload, u32 size, GF_SLHeader *hdr, GF_Err e), void *udta)
-{
-	GF_Err e;
-	GF_RTPMap *map;
-	u32 payt;
-	GF_RTPDepacketizer *tmp;
-
-	/*check RTP map. For now we only support 1 RTPMap*/
-	if (!sl_packet_cbk || !media || media->fmt_list || (gf_list_count(media->RTPMaps) > 1)) return NULL;
-
-	/*check payload type*/
-	map = (GF_RTPMap *)gf_list_get(media->RTPMaps, 0);
-
-	payt = gf_rtp_get_payload_type(map, media);
-	if (!payt) return NULL;
-
-	GF_SAFEALLOC(tmp, GF_RTPDepacketizer);
-	tmp->payt = payt;
-
-	e = gf_rtp_payt_setup(tmp, map, media);
-	if (e) {
-		gf_free(tmp);
-		return NULL;
-	}
-	assert(tmp->depacketize);
-	tmp->clock_rate = map->ClockRate;
-	tmp->on_sl_packet = sl_packet_cbk;
-	tmp->udta = udta;
-	return tmp;
-}
-
-GF_EXPORT
-void gf_rtp_depacketizer_reset(GF_RTPDepacketizer *rtp, Bool full_reset)
-{
-	if (rtp) {
-		if (rtp->inter_bs) gf_bs_del(rtp->inter_bs);
-		rtp->inter_bs = NULL;
-		rtp->flags |= GF_RTP_NEW_AU;
-		if (full_reset) {
-			u32 dur = rtp->sl_hdr.au_duration;
-			memset(&rtp->sl_hdr, 0, sizeof(GF_SLHeader));
-			rtp->sl_hdr.au_duration = dur;
-		}
-	}
-}
-
-GF_EXPORT
-void gf_rtp_depacketizer_del(GF_RTPDepacketizer *rtp)
-{
-	if (rtp) {
-		gf_rtp_depacketizer_reset(rtp, GF_FALSE);
-		if (rtp->sl_map.config) gf_free(rtp->sl_map.config);
-		if (rtp->key) gf_free(rtp->key);
-		gf_free(rtp);
-	}
-}
-
-GF_EXPORT
-void gf_rtp_depacketizer_process(GF_RTPDepacketizer *rtp, GF_RTPHeader *hdr, char *payload, u32 size)
-{
-	assert(rtp && rtp->depacketize);
-	rtp->sl_hdr.sender_ntp = hdr->recomputed_ntp_ts;
-	rtp->depacketize(rtp, hdr, payload, size);
-}
-
-
-GF_EXPORT
-void gf_rtp_depacketizer_get_slconfig(GF_RTPDepacketizer *rtp, GF_SLConfig *slc)
-{
-	memset(slc, 0, sizeof(GF_SLConfig));
-	slc->tag = GF_ODF_SLC_TAG;
-
-
-	slc->AULength = rtp->sl_map.ConstantSize;
-	if (rtp->sl_map.ConstantDuration) {
-		slc->CUDuration = slc->AUDuration = rtp->sl_map.ConstantDuration;
-	} else {
-		slc->CUDuration = slc->AUDuration = rtp->sl_hdr.au_duration;
-	}
-	/*AUSeqNum is only signaled if streamState is used (eg for carrouselling); otherwise we ignore it*/
-	slc->AUSeqNumLength = rtp->sl_map.StreamStateIndication;
-	slc->no_dts_signaling = rtp->sl_map.DTSDeltaLength ? GF_FALSE : GF_TRUE;
-
-
-	/*RTP SN is on 16 bits*/
-	slc->packetSeqNumLength = 0;
-	/*RTP TS is on 32 bits*/
-	slc->timestampLength = 32;
-	slc->timeScale = slc->timestampResolution = rtp->clock_rate;
-	slc->useTimestampsFlag = 1;
-
-	/*we override these flags because we emulate the flags through the marker bit */
-	slc->useAccessUnitEndFlag = slc->useAccessUnitStartFlag = 1;
-	slc->useRandomAccessPointFlag = rtp->sl_map.RandomAccessIndication;
-	/*checking RAP for video*/
-	if (rtp->flags & GF_RTP_M4V_CHECK_RAP) {
-		slc->useRandomAccessPointFlag = 1;
-		slc->hasRandomAccessUnitsOnlyFlag = 0;
-	}
-
-	/*try to signal caroussel if not set in StreamState*/
-	if (!slc->AUSeqNumLength && rtp->sl_map.RandomAccessIndication) {
-		switch (rtp->sl_map.StreamType) {
-		case GF_STREAM_OD:
-		case GF_STREAM_SCENE:
-			slc->AUSeqNumLength = rtp->sl_map.IndexLength;
-			break;
-		}
-	}
-}
-
-
-#endif /*GPAC_DISABLE_STREAMING*/
diff --git a/src/ietfPrtp_packetizer.c b/src/ietfPrtp_packetizer.c
deleted file mode 100644
index f85e49103..000000000
--- a/src/ietfPrtp_packetizer.c
+++ /dev/null
@@ -1,613 +0,0 @@
-/*
- *			GPAC - Multimedia Framework C SDK
- *
- *			Authors: Jean Le Feuvre
- *			Copyright (c) Telecom ParisTech 2000-2012
- *					All rights reserved
- *
- *  This file is part of GPAC / IETF RTP/RTSP/SDP sub-project
- *
- *  GPAC is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU Lesser General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  GPAC is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#include <gpac/internal/ietf_dev.h>
-
-#ifndef GPAC_DISABLE_STREAMING
-
-#include <gpac/constants.h>
-#include <gpac/maths.h>
-
-void InitSL_RTP(GF_SLConfig *slc);
-
-
-
-
-GF_EXPORT
-GP_RTPPacketizer *gf_rtp_builder_new(u32 rtp_payt, GF_SLConfig *slc, u32 flags,
-                                     void *cbk_obj,
-                                     void (*OnNewPacket)(void *cbk, GF_RTPHeader *header),
-                                     void (*OnPacketDone)(void *cbk, GF_RTPHeader *header),
-                                     void (*OnDataReference)(void *cbk, u32 payload_size, u32 offset_from_orig),
-                                     void (*OnData)(void *cbk, char *data, u32 data_size, Bool is_head)
-                                    )
-{
-	GP_RTPPacketizer *tmp;
-	if (!rtp_payt || !cbk_obj | !OnPacketDone) return NULL;
-
-	GF_SAFEALLOC(tmp, GP_RTPPacketizer);
-	if (!tmp) return NULL;
-
-	if (slc) {
-		memcpy(&tmp->sl_config, slc, sizeof(GF_SLConfig));
-	} else {
-		memset(&tmp->sl_config, 0, sizeof(GF_SLConfig));
-		tmp->sl_config.useTimestampsFlag = 1;
-		tmp->sl_config.timestampLength = 32;
-	}
-	tmp->OnNewPacket = OnNewPacket;
-	tmp->OnDataReference = OnDataReference;
-	tmp->OnData = OnData;
-	tmp->cbk_obj = cbk_obj;
-	tmp->OnPacketDone = OnPacketDone;
-	tmp->rtp_payt = rtp_payt;
-	tmp->flags = flags;
-	//default init
-	tmp->sl_header.AU_sequenceNumber = 1;
-	tmp->sl_header.packetSequenceNumber = 1;
-
-	//we assume we start on a new AU
-	tmp->sl_header.accessUnitStartFlag = 1;
-	return tmp;
-}
-
-GF_EXPORT
-void gf_rtp_builder_del(GP_RTPPacketizer *builder)
-{
-	if (!builder) return;
-
-	if (builder->payload) gf_bs_del(builder->payload);
-	if (builder->pck_hdr) gf_bs_del(builder->pck_hdr);
-	gf_free(builder);
-}
-
-GF_EXPORT
-GF_Err gf_rtp_builder_process(GP_RTPPacketizer *builder, char *data, u32 data_size, u8 IsAUEnd, u32 FullAUSize, u32 duration, u8 descIndex)
-{
-	if (!builder) return GF_BAD_PARAM;
-
-	switch (builder->rtp_payt) {
-	case GF_RTP_PAYT_MPEG4:
-		return gp_rtp_builder_do_mpeg4(builder, data, data_size, IsAUEnd, FullAUSize);
-#ifndef GPAC_DISABLE_AV_PARSERS
-	case GF_RTP_PAYT_MPEG12_VIDEO:
-		return gp_rtp_builder_do_mpeg12_video(builder, data, data_size, IsAUEnd, FullAUSize);
-#endif
-	case GF_RTP_PAYT_MPEG12_AUDIO:
-		return gp_rtp_builder_do_mpeg12_audio(builder, data, data_size, IsAUEnd, FullAUSize);
-	case GF_RTP_PAYT_H263:
-		return gp_rtp_builder_do_h263(builder, data, data_size, IsAUEnd, FullAUSize);
-	case GF_RTP_PAYT_AMR:
-	case GF_RTP_PAYT_AMR_WB:
-		return gp_rtp_builder_do_amr(builder, data, data_size, IsAUEnd, FullAUSize);
-	case GF_RTP_PAYT_3GPP_TEXT:
-		return gp_rtp_builder_do_tx3g(builder, data, data_size, IsAUEnd, FullAUSize, duration, descIndex);
-	case GF_RTP_PAYT_H264_AVC:
-	case GF_RTP_PAYT_H264_SVC:
-		return gp_rtp_builder_do_avc(builder, data, data_size, IsAUEnd, FullAUSize);
-	case GF_RTP_PAYT_QCELP:
-		return gp_rtp_builder_do_qcelp(builder, data, data_size, IsAUEnd, FullAUSize);
-	case GF_RTP_PAYT_EVRC_SMV:
-		return gp_rtp_builder_do_smv(builder, data, data_size, IsAUEnd, FullAUSize);
-	case GF_RTP_PAYT_LATM:
-		return gp_rtp_builder_do_latm(builder, data, data_size, IsAUEnd, FullAUSize, duration);
-	case GF_RTP_PAYT_3GPP_DIMS:
-		return gp_rtp_builder_do_dims(builder, data, data_size, IsAUEnd, FullAUSize, duration);
-	case GF_RTP_PAYT_AC3:
-		return gp_rtp_builder_do_ac3(builder, data, data_size, IsAUEnd, FullAUSize);
-	case GF_RTP_PAYT_HEVC:
-	case GF_RTP_PAYT_SHVC:
-		return gp_rtp_builder_do_hevc(builder, data, data_size, IsAUEnd, FullAUSize);
-	default:
-		return GF_NOT_SUPPORTED;
-	}
-}
-
-
-//Compute the #params of the slMap
-GF_EXPORT
-void gf_rtp_builder_init(GP_RTPPacketizer *builder, u8 PayloadType, u32 PathMTU, u32 max_ptime,
-                         u32 StreamType, u32 OTI, u32 PL_ID,
-                         u32 avgSize, u32 maxSize,
-                         u32 avgTS, u32 maxDTS,
-                         u32 IV_length, u32 KI_length,
-                         char *pref_mode)
-{
-	u32 k, ismacrypt_flags;
-
-	memset(&builder->slMap, 0, sizeof(GP_RTPSLMap));
-	builder->Path_MTU = PathMTU;
-	builder->PayloadType = PayloadType;
-	builder->slMap.StreamType = StreamType;
-	builder->slMap.ObjectTypeIndication = OTI;
-	builder->slMap.PL_ID = PL_ID;
-	builder->max_ptime = max_ptime;
-	if (pref_mode) strcpy(builder->slMap.mode, pref_mode);
-
-
-	//some cst vars
-	builder->rtp_header.Version = 2;
-	builder->rtp_header.PayloadType = builder->PayloadType;
-
-	/*our max config is with 1 packet only (SingleSL)*/
-	builder->first_sl_in_rtp = GF_TRUE;
-	/*no AUX data*/
-	builder->slMap.AuxiliaryDataSizeLength = 0;
-
-
-	/*just compute max aggregation size*/
-	switch (builder->rtp_payt) {
-	case GF_RTP_PAYT_QCELP:
-	case GF_RTP_PAYT_EVRC_SMV:
-	case GF_RTP_PAYT_AMR:
-	case GF_RTP_PAYT_AMR_WB:
-	{
-		u32 nb_pck = 1;
-		u32 block_size = 160;
-		/*compute max frames per packet - if no avg size, use max size per codec*/
-		if (builder->flags & GP_RTP_PCK_USE_MULTI) {
-			if (builder->rtp_payt == GF_RTP_PAYT_QCELP) {
-				if (!avgSize) avgSize = 35;
-				nb_pck = (PathMTU-1) / avgSize;	/*one-byte header*/
-				if (nb_pck>10) nb_pck=10;	/*cf RFC2658*/
-			} else if (builder->rtp_payt == GF_RTP_PAYT_EVRC_SMV) {
-				if (!avgSize) avgSize = 23;
-				nb_pck = (PathMTU) / avgSize;
-				if (nb_pck>32) nb_pck=32;	/*cf RFC3558*/
-			} else if (builder->rtp_payt == GF_RTP_PAYT_AMR_WB) {
-				if (!avgSize) avgSize = 61;
-				nb_pck = (PathMTU-1) / avgSize;
-				block_size = 320;
-			} else {
-				if (!avgSize) avgSize = 32;
-				nb_pck = (PathMTU-1) / avgSize;
-			}
-			if (max_ptime) {
-				u32 max_pck = max_ptime / block_size;
-				if (nb_pck > max_pck) nb_pck = max_pck;
-			}
-		}
-		if (nb_pck<=1) {
-			builder->flags &= ~(GP_RTP_PCK_USE_MULTI|GP_RTP_PCK_USE_INTERLEAVING);
-			builder->auh_size = 1;
-		} else {
-			builder->auh_size = nb_pck;
-		}
-		/*remove all MPEG-4 and ISMA flags */
-		builder->flags &= 0x07;
-	}
-	return;
-	case GF_RTP_PAYT_LATM:
-	case GF_RTP_PAYT_MPEG4:
-		break;
-	default:
-		/*remove all MPEG-4 and ISMA flags */
-		builder->flags &= 0x07;
-		/*disable aggregation for visual streams, except for AVC where STAP/MTAP can be used*/
-		if (StreamType==GF_STREAM_VISUAL) {
-			if ((OTI != GPAC_OTI_VIDEO_AVC) && (OTI != GPAC_OTI_VIDEO_SVC) && (OTI != GPAC_OTI_VIDEO_HEVC) && (OTI != GPAC_OTI_VIDEO_SHVC)) {
-				builder->flags &= ~GP_RTP_PCK_USE_MULTI;
-			}
-		}
-		else if (avgSize && (PathMTU <= avgSize) ) {
-			builder->flags &= ~GP_RTP_PCK_USE_MULTI;
-		}
-		return;
-	}
-
-	builder->slMap.IV_length = IV_length;
-	builder->slMap.KI_length = KI_length;
-
-	ismacrypt_flags = 0;
-	if (builder->flags & GP_RTP_PCK_SELECTIVE_ENCRYPTION) ismacrypt_flags |= GP_RTP_PCK_SELECTIVE_ENCRYPTION;
-	if (builder->flags & GP_RTP_PCK_KEY_IDX_PER_AU) ismacrypt_flags |= GP_RTP_PCK_KEY_IDX_PER_AU;
-
-	/*mode setup*/
-	if (!strnicmp(builder->slMap.mode, "AAC", 3)) {
-		builder->flags = GP_RTP_PCK_USE_MULTI | GP_RTP_PCK_SIGNAL_SIZE | GP_RTP_PCK_SIGNAL_AU_IDX | ismacrypt_flags;
-		/*if (builder->flags & GP_RTP_PCK_USE_INTERLEAVING) */
-		builder->slMap.ConstantDuration = avgTS;
-
-		/*AAC LBR*/
-		if (maxSize < 63) {
-			strcpy(builder->slMap.mode, "AAC-lbr");
-			builder->slMap.IndexLength = builder->slMap.IndexDeltaLength = 2;
-			builder->slMap.SizeLength = 6;
-		}
-		/*AAC HBR*/
-		else {
-			strcpy(builder->slMap.mode, "AAC-hbr");
-			builder->slMap.IndexLength = builder->slMap.IndexDeltaLength = 3;
-			builder->slMap.SizeLength = 13;
-		}
-		goto check_header;
-	}
-	if (!strnicmp(builder->slMap.mode, "CELP", 4)) {
-		/*CELP-cbr*/
-		if (maxSize == avgSize) {
-			/*reset flags (interleaving forbidden)*/
-			builder->flags = GP_RTP_PCK_USE_MULTI | ismacrypt_flags;
-			strcpy(builder->slMap.mode, "CELP-cbr");
-			builder->slMap.ConstantSize = avgSize;
-			builder->slMap.ConstantDuration = avgTS;
-		}
-		/*CELP VBR*/
-		else {
-			strcpy(builder->slMap.mode, "CELP-vbr");
-			builder->slMap.IndexLength = builder->slMap.IndexDeltaLength = 2;
-			builder->slMap.SizeLength = 6;
-			/*if (builder->flags & GP_RTP_PCK_USE_INTERLEAVING) */builder->slMap.ConstantDuration = avgTS;
-			builder->flags = GP_RTP_PCK_USE_MULTI | GP_RTP_PCK_SIGNAL_SIZE | GP_RTP_PCK_SIGNAL_AU_IDX | ismacrypt_flags;
-		}
-		goto check_header;
-	}
-
-	/*generic setup by flags*/
-
-	/*size*/
-	if (builder->flags & GP_RTP_PCK_SIGNAL_SIZE) {
-		if (avgSize==maxSize) {
-			builder->slMap.SizeLength = 0;
-			builder->slMap.ConstantSize = maxSize;
-		} else {
-			builder->slMap.SizeLength = gf_get_bit_size(maxSize ? maxSize : PathMTU);
-			builder->slMap.ConstantSize = 0;
-		}
-	} else {
-		builder->slMap.SizeLength = 0;
-		if (builder->flags & GP_RTP_PCK_USE_MULTI)
-			builder->slMap.ConstantSize = (avgSize==maxSize) ? maxSize : 0;
-		else
-			builder->slMap.ConstantSize = 0;
-	}
-
-	/*single SL per RTP*/
-	if (!(builder->flags & GP_RTP_PCK_USE_MULTI)) {
-		if ( builder->sl_config.AUSeqNumLength && (builder->flags & GP_RTP_PCK_SIGNAL_AU_IDX)) {
-			builder->slMap.IndexLength = builder->sl_config.AUSeqNumLength;
-		} else {
-			builder->slMap.IndexLength = 0;
-		}
-		/*one packet per RTP so no delta*/
-		builder->slMap.IndexDeltaLength = 0;
-		builder->slMap.IV_delta_length = 0;
-
-		/*CTS Delta is always 0 since we have one SL packet per RTP*/
-		builder->slMap.CTSDeltaLength = 0;
-
-		/*DTS Delta depends on the video type*/
-		if ((builder->flags & GP_RTP_PCK_SIGNAL_TS) && maxDTS )
-			builder->slMap.DTSDeltaLength = gf_get_bit_size(maxDTS);
-		else
-			builder->slMap.DTSDeltaLength = 0;
-
-		/*RAP*/
-		if (builder->sl_config.useRandomAccessPointFlag && (builder->flags & GP_RTP_PCK_SIGNAL_RAP)) {
-			builder->slMap.RandomAccessIndication = GF_TRUE;
-		} else {
-			builder->slMap.RandomAccessIndication = GF_FALSE;
-		}
-
-		/*stream state*/
-		if (builder->flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) {
-			if (!builder->sl_config.AUSeqNumLength) builder->sl_config.AUSeqNumLength = 4;
-			builder->slMap.StreamStateIndication = builder->sl_config.AUSeqNumLength;
-		}
-		goto check_header;
-	}
-
-	/*this is the avg samples we can store per RTP packet*/
-	k = PathMTU / avgSize;
-	if (k<=1) {
-		builder->flags &= ~GP_RTP_PCK_USE_MULTI;
-		/*keep TS signaling for B-frames (eg never default to M4V-ES when B-frames are present)*/
-		//builder->flags &= ~GP_RTP_PCK_SIGNAL_TS;
-		builder->flags &= ~GP_RTP_PCK_SIGNAL_SIZE;
-		builder->flags &= ~GP_RTP_PCK_SIGNAL_AU_IDX;
-		builder->flags &= ~GP_RTP_PCK_USE_INTERLEAVING;
-		builder->flags &= ~GP_RTP_PCK_KEY_IDX_PER_AU;
-		gf_rtp_builder_init(builder, PayloadType, PathMTU, max_ptime, StreamType, OTI, PL_ID, avgSize, maxSize, avgTS, maxDTS, IV_length, KI_length, pref_mode);
-		return;
-	}
-
-	/*multiple SL per RTP - check if we have to send TS*/
-	builder->slMap.ConstantDuration = builder->sl_config.CUDuration;
-	if (!builder->slMap.ConstantDuration) {
-		builder->flags |= GP_RTP_PCK_SIGNAL_TS;
-	}
-	/*if we have a constant duration and are not writting TSs, make sure we write AU IDX when interleaving*/
-	else if (! (builder->flags & GP_RTP_PCK_SIGNAL_TS) && (builder->flags & GP_RTP_PCK_USE_INTERLEAVING)) {
-		builder->flags |= GP_RTP_PCK_SIGNAL_AU_IDX;
-	}
-
-	if (builder->flags & GP_RTP_PCK_SIGNAL_TS) {
-		/*compute CTS delta*/
-		builder->slMap.CTSDeltaLength = gf_get_bit_size(k*avgTS);
-
-		/*compute DTS delta. Delta is ALWAYS from the CTS of the same sample*/
-		if (maxDTS)
-			builder->slMap.DTSDeltaLength = gf_get_bit_size(maxDTS);
-		else
-			builder->slMap.DTSDeltaLength = 0;
-	}
-
-	if ((builder->flags & GP_RTP_PCK_SIGNAL_AU_IDX) && builder->sl_config.AUSeqNumLength) {
-		builder->slMap.IndexLength = builder->sl_config.AUSeqNumLength;
-		/*and k-1 AUs in Delta*/
-		builder->slMap.IndexDeltaLength = (builder->flags & GP_RTP_PCK_USE_INTERLEAVING) ? gf_get_bit_size(k-1) : 0;
-	}
-	else if (builder->flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) {
-		if (!builder->sl_config.AUSeqNumLength) builder->sl_config.AUSeqNumLength = 4;
-		builder->slMap.StreamStateIndication = builder->sl_config.AUSeqNumLength;
-	}
-
-	/*RAP*/
-	if (builder->sl_config.useRandomAccessPointFlag && (builder->flags & GP_RTP_PCK_SIGNAL_RAP)) {
-		builder->slMap.RandomAccessIndication = GF_TRUE;
-	} else {
-		builder->slMap.RandomAccessIndication = GF_FALSE;
-	}
-
-check_header:
-
-	/*IV delta only if interleaving (otherwise reconstruction from IV is trivial)*/
-	if (IV_length && (builder->flags & GP_RTP_PCK_USE_INTERLEAVING)) {
-		builder->slMap.IV_delta_length = gf_get_bit_size(maxSize);
-	}
-	/*ISMACryp video mode*/
-	if ((builder->slMap.StreamType==GF_STREAM_VISUAL) && (builder->slMap.ObjectTypeIndication==GPAC_OTI_VIDEO_MPEG4_PART2)
-	        && (builder->flags & GP_RTP_PCK_SIGNAL_RAP) && builder->slMap.IV_length
-	        && !(builder->flags & GP_RTP_PCK_SIGNAL_AU_IDX) && !(builder->flags & GP_RTP_PCK_SIGNAL_SIZE)
-	        /*shall have SignalTS*/
-	        && (builder->flags & GP_RTP_PCK_SIGNAL_TS) && !(builder->flags & GP_RTP_PCK_USE_MULTI)
-	   ) {
-		strcpy(builder->slMap.mode, "mpeg4-video");
-	}
-	/*ISMACryp AVC video mode*/
-	else if ((builder->slMap.StreamType==GF_STREAM_VISUAL) && (builder->slMap.ObjectTypeIndication==GPAC_OTI_VIDEO_AVC)
-	         && (builder->flags & GP_RTP_PCK_SIGNAL_RAP) && builder->slMap.IV_length
-	         && !(builder->flags & GP_RTP_PCK_SIGNAL_AU_IDX) && !(builder->flags & GP_RTP_PCK_SIGNAL_SIZE)
-	         /*shall have SignalTS*/
-	         && (builder->flags & GP_RTP_PCK_SIGNAL_TS) && !(builder->flags & GP_RTP_PCK_USE_MULTI)
-	        ) {
-		strcpy(builder->slMap.mode, "avc-video");
-	}
-
-	/*check if we use AU header or not*/
-	if (!builder->slMap.SizeLength
-	        && !builder->slMap.IndexLength
-	        && !builder->slMap.IndexDeltaLength
-	        && !builder->slMap.DTSDeltaLength
-	        && !builder->slMap.CTSDeltaLength
-	        && !builder->slMap.RandomAccessIndication
-	        && !builder->slMap.IV_length
-	        && !builder->slMap.KI_length
-	   ) {
-		builder->has_AU_header = GF_FALSE;
-	} else {
-		builder->has_AU_header = GF_TRUE;
-	}
-}
-
-void gp_rtp_builder_set_cryp_info(GP_RTPPacketizer *builder, u64 IV, char *key_indicator, Bool is_encrypted)
-{
-	if (!key_indicator) {
-		if (builder->key_indicator) {
-			/*force flush if no provision for keyIndicator per AU*/
-			builder->force_flush = (builder->flags & GP_RTP_PCK_KEY_IDX_PER_AU) ? GF_FALSE : GF_TRUE;
-			gf_free(builder->key_indicator);
-			builder->key_indicator = NULL;
-		}
-	} else if (!builder->key_indicator
-	           ||
-	           memcmp(builder->key_indicator, key_indicator, sizeof(char)*builder->slMap.KI_length)
-	          ) {
-		/*force flush if no provision for keyIndicator per AU*/
-		builder->force_flush = (builder->flags & GP_RTP_PCK_KEY_IDX_PER_AU) ? GF_FALSE : GF_TRUE;
-
-		if (!builder->key_indicator) builder->key_indicator = (char *) gf_malloc(sizeof(char)*builder->slMap.KI_length);
-		memcpy(builder->key_indicator, key_indicator, sizeof(char)*builder->slMap.KI_length);
-	}
-	if (builder->IV != IV) {
-		builder->IV = IV;
-		if (builder->slMap.IV_delta_length && (builder->slMap.IV_delta_length < gf_get_bit_size((u32) (IV - builder->first_AU_IV) ))) {
-			builder->first_AU_IV = IV;
-			builder->force_flush = GF_TRUE;
-		}
-	}
-	builder->is_encrypted = is_encrypted;
-}
-
-GF_EXPORT
-Bool gf_rtp_builder_get_payload_name(GP_RTPPacketizer *rtpb, char *szPayloadName, char *szMediaName)
-{
-	u32 flags = rtpb->flags;
-
-	switch (rtpb->rtp_payt) {
-	case GF_RTP_PAYT_MPEG4:
-		if ((rtpb->slMap.StreamType==GF_STREAM_VISUAL) && (rtpb->slMap.ObjectTypeIndication==GPAC_OTI_VIDEO_MPEG4_PART2)) {
-			strcpy(szMediaName, "video");
-			/*ISMACryp video*/
-			if ( (flags & GP_RTP_PCK_SIGNAL_RAP) && rtpb->slMap.IV_length
-			        && !(flags & GP_RTP_PCK_SIGNAL_AU_IDX) && !(flags & GP_RTP_PCK_SIGNAL_SIZE)
-			        && (flags & GP_RTP_PCK_SIGNAL_TS) && !(flags & GP_RTP_PCK_USE_MULTI)
-			   )
-			{
-				strcpy(szPayloadName, "enc-mpeg4-generic");
-				return GF_TRUE;
-			}
-			/*mpeg4-generic*/
-			if ( (flags & GP_RTP_PCK_SIGNAL_RAP) || (flags & GP_RTP_PCK_SIGNAL_AU_IDX) || (flags & GP_RTP_PCK_SIGNAL_SIZE)
-			        || (flags & GP_RTP_PCK_SIGNAL_TS) || (flags & GP_RTP_PCK_USE_MULTI) ) {
-				strcpy(szPayloadName, "mpeg4-generic");
-				return GF_TRUE;
-			} else {
-				strcpy(szPayloadName, "MP4V-ES");
-				return GF_TRUE;
-			}
-		}
-		/*for all other types*/
-		if (rtpb->slMap.StreamType==GF_STREAM_AUDIO) strcpy(szMediaName, "audio");
-		else if (rtpb->slMap.StreamType==GF_STREAM_MPEGJ) strcpy(szMediaName, "application");
-		else strcpy(szMediaName, "video");
-		strcpy(szPayloadName, rtpb->slMap.IV_length ? "enc-mpeg4-generic" : "mpeg4-generic");
-		return GF_TRUE;
-	case GF_RTP_PAYT_MPEG12_VIDEO:
-		strcpy(szMediaName, "video");
-		strcpy(szPayloadName, "MPV");
-		return GF_TRUE;
-	case GF_RTP_PAYT_MPEG12_AUDIO:
-		strcpy(szMediaName, "audio");
-		strcpy(szPayloadName, "MPA");
-		return GF_TRUE;
-	case GF_RTP_PAYT_H263:
-		strcpy(szMediaName, "video");
-		strcpy(szPayloadName, "H263-1998");
-		return GF_TRUE;
-	case GF_RTP_PAYT_AMR:
-		strcpy(szMediaName, "audio");
-		strcpy(szPayloadName, "AMR");
-		return GF_TRUE;
-	case GF_RTP_PAYT_AMR_WB:
-		strcpy(szMediaName, "audio");
-		strcpy(szPayloadName, "AMR-WB");
-		return GF_TRUE;
-	case GF_RTP_PAYT_3GPP_TEXT:
-		strcpy(szMediaName, "text");
-		strcpy(szPayloadName, "3gpp-tt");
-		return GF_TRUE;
-	case GF_RTP_PAYT_H264_AVC:
-		strcpy(szMediaName, "video");
-		strcpy(szPayloadName, "H264");
-		return GF_TRUE;
-	case GF_RTP_PAYT_QCELP:
-		strcpy(szMediaName, "audio");
-		strcpy(szPayloadName, "QCELP");
-		return GF_TRUE;
-	case GF_RTP_PAYT_EVRC_SMV:
-		strcpy(szMediaName, "audio");
-		strcpy(szPayloadName, (rtpb->slMap.ObjectTypeIndication==0xA0) ? "EVRC" : "SMV");
-		/*header-free version*/
-		if (rtpb->auh_size<=1) strcat(szPayloadName, "0");
-		return GF_TRUE;
-	case GF_RTP_PAYT_LATM:
-		strcpy(szMediaName, "audio");
-		strcpy(szPayloadName, "MP4A-LATM");
-		return GF_TRUE;
-	case GF_RTP_PAYT_3GPP_DIMS:
-		strcpy(szMediaName, "video");
-		strcpy(szPayloadName, "richmedia+xml");
-		return GF_TRUE;
-	case GF_RTP_PAYT_AC3:
-		strcpy(szMediaName, "audio");
-		strcpy(szPayloadName, "ac3");
-		return GF_TRUE;
-	case GF_RTP_PAYT_H264_SVC:
-		strcpy(szMediaName, "video");
-		strcpy(szPayloadName, "H264-SVC");
-		return GF_TRUE;
-	case GF_RTP_PAYT_HEVC:
-		strcpy(szMediaName, "video");
-		strcpy(szPayloadName, "H265");
-		return GF_TRUE;
-	case GF_RTP_PAYT_SHVC:
-		strcpy(szMediaName, "video");
-		strcpy(szPayloadName, "H265-SHVC");
-		return GF_TRUE;
-	default:
-		strcpy(szMediaName, "");
-		strcpy(szPayloadName, "");
-		return GF_FALSE;
-	}
-	return GF_FALSE;
-}
-
-
-GF_EXPORT
-GF_Err gf_rtp_builder_format_sdp(GP_RTPPacketizer *builder, char *payload_name, char *sdpLine, char *dsi, u32 dsi_size)
-{
-	char buffer[20000], dsiString[20000];
-	u32 i, k;
-	Bool is_first = GF_TRUE;
-
-	if ((builder->rtp_payt!=GF_RTP_PAYT_MPEG4) && (builder->rtp_payt!=GF_RTP_PAYT_LATM) ) return GF_BAD_PARAM;
-
-#define SDP_ADD_INT(_name, _val) { if (!is_first) strcat(sdpLine, "; "); sprintf(buffer, "%s=%d", _name, _val); strcat(sdpLine, buffer); is_first = 0;}
-#define SDP_ADD_STR(_name, _val) { if (!is_first) strcat(sdpLine, "; "); sprintf(buffer, "%s=%s", _name, _val); strcat(sdpLine, buffer); is_first = 0;}
-
-	sprintf(sdpLine, "a=fmtp:%d ", builder->PayloadType);
-
-	/*mandatory fields*/
-	if (builder->slMap.PL_ID) SDP_ADD_INT("profile-level-id", builder->slMap.PL_ID);
-
-	if (builder->rtp_payt == GF_RTP_PAYT_LATM) SDP_ADD_INT("cpresent", 0);
-
-	if (dsi && dsi_size) {
-		k = 0;
-		for (i=0; i<dsi_size; i++) {
-			sprintf(&dsiString[k], "%02x", (unsigned char) dsi[i]);
-			k+=2;
-		}
-		dsiString[k] = 0;
-		SDP_ADD_STR("config", dsiString);
-	}
-	if (!strcmp(payload_name, "MP4V-ES") || (builder->rtp_payt == GF_RTP_PAYT_LATM) ) return GF_OK;
-
-	SDP_ADD_INT("streamType", builder->slMap.StreamType);
-	if (strcmp(builder->slMap.mode, "") && strcmp(builder->slMap.mode, "default")) {
-		SDP_ADD_STR("mode", builder->slMap.mode);
-	} else {
-		SDP_ADD_STR("mode", "generic");
-	}
-
-	/*optional fields*/
-	if (builder->slMap.ObjectTypeIndication) SDP_ADD_INT("objectType", builder->slMap.ObjectTypeIndication);
-	if (builder->slMap.ConstantSize) SDP_ADD_INT("constantSize", builder->slMap.ConstantSize);
-	if (builder->slMap.ConstantDuration) SDP_ADD_INT("constantDuration", builder->slMap.ConstantDuration);
-	if (builder->slMap.maxDisplacement) SDP_ADD_INT("maxDisplacement", builder->slMap.maxDisplacement);
-	if (builder->slMap.deinterleaveBufferSize) SDP_ADD_INT("de-interleaveBufferSize", builder->slMap.deinterleaveBufferSize);
-	if (builder->slMap.SizeLength) SDP_ADD_INT("sizeLength", builder->slMap.SizeLength);
-	if (builder->slMap.IndexLength) SDP_ADD_INT("indexLength", builder->slMap.IndexLength);
-	if (builder->slMap.IndexDeltaLength) SDP_ADD_INT("indexDeltaLength", builder->slMap.IndexDeltaLength);
-	if (builder->slMap.CTSDeltaLength) SDP_ADD_INT("CTSDeltaLength", builder->slMap.CTSDeltaLength);
-	if (builder->slMap.DTSDeltaLength) SDP_ADD_INT("DTSDeltaLength", builder->slMap.DTSDeltaLength);
-	if (builder->slMap.RandomAccessIndication) SDP_ADD_INT("randomAccessIndication", builder->slMap.RandomAccessIndication);
-	if (builder->slMap.StreamStateIndication) SDP_ADD_INT("streamStateIndication", builder->slMap.StreamStateIndication);
-	if (builder->slMap.AuxiliaryDataSizeLength) SDP_ADD_INT("auxiliaryDataSizeLength", builder->slMap.AuxiliaryDataSizeLength);
-
-	/*ISMACryp config*/
-	if (builder->slMap.IV_length) {
-		/*don't write default*/
-		/*SDP_ADD_STR("ISMACrypCryptoSuite", "AES_CTR_128");*/
-		if (builder->flags & GP_RTP_PCK_SELECTIVE_ENCRYPTION) SDP_ADD_INT("ISMACrypSelectiveEncryption", 1);
-		SDP_ADD_INT("ISMACrypIVLength", builder->slMap.IV_length);
-		if (builder->slMap.IV_delta_length) SDP_ADD_INT("ISMACrypDeltaIVLength", builder->slMap.IV_delta_length);
-		if (builder->slMap.KI_length) SDP_ADD_INT("ISMACrypKeyIndicatorLength", builder->slMap.KI_length);
-		if (builder->flags & GP_RTP_PCK_KEY_IDX_PER_AU) SDP_ADD_INT("ISMACrypKeyIndicatorPerAU", 1);
-	}
-	return GF_OK;
-}
-
-#endif /*GPAC_DISABLE_STREAMING*/
diff --git a/src/ietfPrtp_pck_3gpp.c b/src/ietfPrtp_pck_3gpp.c
deleted file mode 100644
index f927b6dbb..000000000
--- a/src/ietfPrtp_pck_3gpp.c
+++ /dev/null
@@ -1,778 +0,0 @@
-/*
- *			GPAC - Multimedia Framework C SDK
- *
- *			Authors: Jean Le Feuvre
- *			Copyright (c) Telecom ParisTech 2000-2012
- *					All rights reserved
- *
- *  This file is part of GPAC / IETF RTP/RTSP/SDP sub-project
- *
- *  GPAC is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU Lesser General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  GPAC is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#include <gpac/internal/ietf_dev.h>
-
-#ifndef GPAC_DISABLE_STREAMING
-
-#include <gpac/constants.h>
-
-static void rtp_amr_flush(GP_RTPPacketizer *builder)
-{
-	char *hdr;
-	u32 hdr_size;
-	if (!builder->bytesInPacket) return;
-	gf_bs_get_content(builder->pck_hdr, &hdr, &hdr_size);
-	gf_bs_del(builder->pck_hdr);
-	builder->pck_hdr = NULL;
-	/*overwrite last frame F bit*/
-	hdr[builder->last_au_sn] &= 0x7F;
-	builder->OnData(builder->cbk_obj, hdr, hdr_size, GF_TRUE);
-	gf_free(hdr);
-	builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-	builder->bytesInPacket = 0;
-	builder->last_au_sn = 0;
-}
-
-GF_Err gp_rtp_builder_do_amr(GP_RTPPacketizer *builder, char *data, u32 data_size, u8 IsAUEnd, u32 FullAUSize)
-{
-	u32 offset, rtp_ts, block_size;
-
-	if (!data) {
-		rtp_amr_flush(builder);
-		return GF_OK;
-	}
-
-	rtp_ts = (u32) builder->sl_header.compositionTimeStamp;
-
-	offset = 0;
-	while (data_size>offset) {
-		u8 ft = (data[offset] & 0x78) >> 3;
-		u8 size;
-
-		if (builder->rtp_payt == GF_RTP_PAYT_AMR_WB) {
-			size = (u32)GF_AMR_WB_FRAME_SIZE[ft];
-			block_size = 320;
-		} else {
-			size = (u32)GF_AMR_FRAME_SIZE[ft];
-			block_size = 160;
-		}
-
-		/*packet full or too long*/
-		if (builder->bytesInPacket + 1 + size > builder->Path_MTU)
-			rtp_amr_flush(builder);
-
-		/*need new*/
-		if (!builder->bytesInPacket) {
-			builder->rtp_header.TimeStamp = rtp_ts;
-			builder->rtp_header.Marker = 0;	/*never set*/
-			builder->rtp_header.SequenceNumber += 1;
-			builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-			assert(builder->pck_hdr==NULL);
-
-			/*always have header and TOC*/
-			builder->pck_hdr = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-			/*CMR + res (all 0, no interleaving)*/
-			gf_bs_write_int(builder->pck_hdr, ft, 4);
-			gf_bs_write_int(builder->pck_hdr, 0, 4);
-			builder->bytesInPacket = 1;
-			/*no interleaving*/
-		}
-
-		/*F always to 1*/
-		gf_bs_write_int(builder->pck_hdr, 1, 1);
-		gf_bs_write_int(builder->pck_hdr, ft, 4);
-		/*Q*/
-		gf_bs_write_int(builder->pck_hdr, (data[offset] & 0x4) ? 1 : 0, 1);
-		gf_bs_write_int(builder->pck_hdr, 0, 2);
-		builder->bytesInPacket ++;
-
-		/*remove frame type byte*/
-		offset++;
-
-		/*add frame data without rate_type byte header*/
-		if (builder->OnDataReference) {
-			builder->OnDataReference(builder->cbk_obj, size, offset);
-		} else {
-			builder->OnData(builder->cbk_obj, data+offset, size, GF_FALSE);
-		}
-		builder->last_au_sn++;
-		builder->bytesInPacket += size;
-		offset += size;
-		rtp_ts += block_size;
-		assert(builder->bytesInPacket<=builder->Path_MTU);
-		/*take care of aggregation, flush if needed*/
-		if (builder->last_au_sn==builder->auh_size) rtp_amr_flush(builder);
-	}
-	return GF_OK;
-}
-
-static GFINLINE u8 qes_get_rate_size(u32 idx, const unsigned int *rates, const unsigned int nb_rates)
-{
-	u32 i;
-	for (i=0; i<nb_rates; i++) {
-		if (rates[2*i]==idx) return rates[2*i+1];
-	}
-	return 0;
-}
-
-GF_Err gp_rtp_builder_do_qcelp(GP_RTPPacketizer *builder, char *data, u32 data_size, u8 IsAUEnd, u32 FullAUSize)
-{
-	u32 offset, rtp_ts;
-	u8 hdr;
-
-	if (!data) {
-		if (builder->bytesInPacket) builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-		builder->bytesInPacket = 0;
-		builder->last_au_sn = 0;
-		return GF_OK;
-	}
-
-	rtp_ts = (u32) builder->sl_header.compositionTimeStamp;
-
-
-	offset = 0;
-	while (data_size>offset) {
-		u8 frame_type = data[offset];
-		u8 size = qes_get_rate_size(frame_type, GF_QCELP_RATE_TO_SIZE, GF_QCELP_RATE_TO_SIZE_NB);
-		/*reserved, not sent)*/
-		if (frame_type>=5) {
-			offset += size;
-			continue;
-		}
-		/*packet full or too long*/
-		if (builder->bytesInPacket + size > builder->Path_MTU) {
-			builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-			builder->bytesInPacket = 0;
-			builder->last_au_sn = 0;
-		}
-
-		/*need new*/
-		if (!builder->bytesInPacket) {
-			builder->rtp_header.TimeStamp = rtp_ts;
-			builder->rtp_header.Marker = 0;	/*never set*/
-			builder->rtp_header.SequenceNumber += 1;
-			builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-			hdr = 0;/*no interleaving*/
-			builder->OnData(builder->cbk_obj, (char*)&hdr, 1, GF_FALSE);
-			builder->bytesInPacket = 1;
-		}
-		if (builder->OnDataReference) {
-			builder->OnDataReference(builder->cbk_obj, size, offset);
-		} else {
-			builder->OnData(builder->cbk_obj, data+offset, size, GF_FALSE);
-		}
-		builder->bytesInPacket += size;
-		offset += size;
-		rtp_ts += 160;
-		assert(builder->bytesInPacket<=builder->Path_MTU);
-
-		/*take care of aggregation, flush if needed*/
-		builder->last_au_sn++;
-		if (builder->last_au_sn==builder->auh_size) {
-			builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-			builder->bytesInPacket = 0;
-			builder->last_au_sn = 0;
-		}
-	}
-	return GF_OK;
-}
-
-
-static void rtp_evrc_smv_flush(GP_RTPPacketizer *builder)
-{
-	if (!builder->bytesInPacket) return;
-	if (builder->auh_size>1) {
-		char *hdr;
-		u32 hdr_size;
-		/*padding*/
-		if (builder->last_au_sn % 2) gf_bs_write_int(builder->pck_hdr, 0, 4);
-		gf_bs_get_content(builder->pck_hdr, &hdr, &hdr_size);
-		gf_bs_del(builder->pck_hdr);
-		builder->pck_hdr = NULL;
-		/*overwrite count*/
-		hdr[0] = 0;
-		hdr[1] = builder->last_au_sn-1;/*MMM + frameCount-1*/
-		builder->OnData(builder->cbk_obj, hdr, hdr_size, GF_TRUE);
-		gf_free(hdr);
-	}
-	builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-	builder->bytesInPacket = 0;
-	builder->last_au_sn = 0;
-}
-
-GF_Err gp_rtp_builder_do_smv(GP_RTPPacketizer *builder, char *data, u32 data_size, u8 IsAUEnd, u32 FullAUSize)
-{
-	u32 offset, rtp_ts;
-
-	if (!data) {
-		rtp_evrc_smv_flush(builder);
-		return GF_OK;
-	}
-
-	rtp_ts = (u32) builder->sl_header.compositionTimeStamp;
-
-	offset = 0;
-	while (data_size>offset) {
-		u8 frame_type = data[offset];
-		u8 size = qes_get_rate_size(frame_type, GF_SMV_EVRC_RATE_TO_SIZE, GF_SMV_EVRC_RATE_TO_SIZE_NB);
-
-		/*reserved, not sent)*/
-		if (frame_type>=5) {
-			offset += size;
-			continue;
-		}
-		/*packet full or too long*/
-		if (builder->bytesInPacket + size > builder->Path_MTU)
-			rtp_evrc_smv_flush(builder);
-
-		/*need new*/
-		if (!builder->bytesInPacket) {
-			builder->rtp_header.TimeStamp = rtp_ts;
-			builder->rtp_header.Marker = 0;	/*never set*/
-			builder->rtp_header.SequenceNumber += 1;
-			builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-			assert(builder->pck_hdr==NULL);
-
-			if (builder->auh_size>1) {
-				builder->pck_hdr = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-				/*RRLLLNNN (all 0, no interleaving)*/
-				gf_bs_write_u8(builder->pck_hdr, 0);
-				/*MMM + count-1 : overriden when flushing*/
-				gf_bs_write_u8(builder->pck_hdr, 0);
-				builder->bytesInPacket = 2;
-			}
-		}
-
-		/*bundle mode: cat rate byte to TOC, on 4 bits*/
-		if (builder->auh_size>1) {
-			gf_bs_write_int(builder->pck_hdr, data[offset], 4);
-			if (!(builder->last_au_sn % 2)) builder->bytesInPacket += 1;
-		}
-		/*note that EVEN in header-free format the rate_type byte is removed*/
-		offset++;
-		size--;
-
-		/*add frame data without rate_type byte header*/
-		if (builder->OnDataReference) {
-			builder->OnDataReference(builder->cbk_obj, size, offset);
-		} else {
-			builder->OnData(builder->cbk_obj, data+offset, size, GF_FALSE);
-		}
-		builder->last_au_sn++;
-		builder->bytesInPacket += size;
-		offset += size;
-		rtp_ts += 160;
-		assert(builder->bytesInPacket<=builder->Path_MTU);
-		/*take care of aggregation, flush if needed*/
-		if (builder->last_au_sn==builder->auh_size) rtp_evrc_smv_flush(builder);
-	}
-	return GF_OK;
-}
-
-GF_Err gp_rtp_builder_do_h263(GP_RTPPacketizer *builder, char *data, u32 data_size, u8 IsAUEnd, u32 FullAUSize)
-{
-	GF_BitStream *bs;
-	char hdr[2];
-	Bool Pbit;
-	u32 offset, size, max_size;
-
-	builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
-
-	/*the H263 hinter doesn't perform inter-sample concatenation*/
-	if (!data) return GF_OK;
-
-	Pbit = GF_TRUE;
-
-	/*skip 16 0'ed bits of start code*/
-	offset = 2;
-	data_size -= 2;
-	max_size = builder->Path_MTU - 2;
-
-	while(data_size > 0) {
-		if(data_size > max_size) {
-			size = max_size;
-			builder->rtp_header.Marker = 0;
-		} else {
-			size = data_size;
-			builder->rtp_header.Marker = 1;
-		}
-
-		data_size -= size;
-
-		/*create new RTP Packet */
-		builder->rtp_header.SequenceNumber += 1;
-		builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-
-		bs = gf_bs_new(hdr, 2, GF_BITSTREAM_WRITE);
-		gf_bs_write_int(bs, 0, 5);
-		gf_bs_write_int(bs, Pbit, 1);
-		gf_bs_write_int(bs, 0, 10);
-		gf_bs_del(bs);
-
-		/*add header*/
-		builder->OnData(builder->cbk_obj, (char*) hdr, 2, GF_TRUE);
-		/*add payload*/
-		if (builder->OnDataReference)
-			builder->OnDataReference(builder->cbk_obj, size, offset);
-		else
-			builder->OnData(builder->cbk_obj, data + offset, size, GF_FALSE);
-
-		builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-
-		offset += size;
-		Pbit = GF_FALSE;
-	}
-	return GF_OK;
-}
-
-GF_Err gp_rtp_builder_do_tx3g(GP_RTPPacketizer *builder, char *data, u32 data_size, u8 IsAUEnd, u32 FullAUSize, u32 duration, u8 descIndex)
-{
-	GF_BitStream *bs;
-	char *hdr;
-	u32 samp_size, txt_size, pay_start, hdr_size, txt_done, cur_frag, nb_frag;
-	Bool is_utf_16 = GF_FALSE;
-
-	if (!data) {
-		/*flush packet*/
-		if (builder->bytesInPacket) {
-			builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-			builder->bytesInPacket = 0;
-		}
-		return GF_OK;
-	}
-	/*cfg packet*/
-	txt_size = data[0];
-	txt_size <<= 8;
-	txt_size |= (unsigned char) data[1];
-	/*remove BOM*/
-	pay_start = 2;
-	if (txt_size>2) {
-		/*seems 3GP only accepts BE UTF-16 (no LE, no UTF32)*/
-		if (((u8) data[2]==(u8) 0xFE) && ((u8) data[3]==(u8) 0xFF)) {
-			is_utf_16 = GF_TRUE;
-			pay_start = 4;
-			txt_size -= 2;
-		}
-	}
-	samp_size = data_size - pay_start;
-
-	/*if TTU does not fit in packet flush packet*/
-	if (builder->bytesInPacket && (builder->bytesInPacket + 3 + 6 + samp_size > builder->Path_MTU)) {
-		builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-		builder->bytesInPacket = 0;
-	}
-
-	/*first TTU in packet*/
-	if (!builder->bytesInPacket) {
-		builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
-		builder->rtp_header.Marker = 1;
-		builder->rtp_header.SequenceNumber += 1;
-		builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-	}
-	/*fits entirely*/
-	if (builder->bytesInPacket + 3 + 6 + samp_size <= builder->Path_MTU) {
-		bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-		gf_bs_write_int(bs, is_utf_16, 1);
-		gf_bs_write_int(bs, 0, 4);
-		gf_bs_write_int(bs, 1, 3);
-		gf_bs_write_u16(bs, 8 + samp_size);
-		gf_bs_write_u8(bs, descIndex);
-		gf_bs_write_u24(bs, duration);
-		gf_bs_write_u16(bs, txt_size);
-		gf_bs_get_content(bs, &hdr, &hdr_size);
-		gf_bs_del(bs);
-		builder->OnData(builder->cbk_obj, (char *) hdr, hdr_size, GF_FALSE);
-		builder->bytesInPacket += hdr_size;
-		gf_free(hdr);
-
-		if (txt_size) {
-			if (builder->OnDataReference) {
-				builder->OnDataReference(builder->cbk_obj, samp_size, pay_start);
-			} else {
-				builder->OnData(builder->cbk_obj, data + pay_start, samp_size, GF_FALSE);
-			}
-			builder->bytesInPacket += samp_size;
-		}
-		/*disable aggregation*/
-		if (!(builder->flags & GP_RTP_PCK_USE_MULTI)) {
-			builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-			builder->bytesInPacket = 0;
-		}
-		return GF_OK;
-	}
-	/*doesn't fit and already data, flush packet*/
-	if (builder->bytesInPacket) {
-		builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-		builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
-		/*split unit*/
-		builder->rtp_header.Marker = 0;
-		builder->rtp_header.SequenceNumber += 1;
-		builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-		builder->bytesInPacket = 0;
-	}
-	/*write all type2 units (text only) - FIXME: split at char boundaries, NOT SUPPORTED YET*/
-	txt_done = 0;
-	nb_frag = 1;
-	/*all fragments needed for Type2 units*/
-	while (txt_done + (builder->Path_MTU-10) < txt_size) {
-		txt_done += (builder->Path_MTU-10);
-		nb_frag += 1;
-	}
-	/*all fragments needed for Type3/4 units*/
-	txt_done = txt_size;
-	while (txt_done + (builder->Path_MTU-7) < samp_size) {
-		txt_done += (builder->Path_MTU-7);
-		nb_frag += 1;
-	}
-
-
-	cur_frag = 0;
-	txt_done = 0;
-	while (txt_done<txt_size) {
-		u32 size;
-		if (txt_done + (builder->Path_MTU-10) < txt_size) {
-			size = builder->Path_MTU-10;
-		} else {
-			size = txt_size - txt_done;
-		}
-
-		bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-		gf_bs_write_int(bs, is_utf_16, 1);
-		gf_bs_write_int(bs, 0, 4);
-		gf_bs_write_int(bs, 2, 3);
-		gf_bs_write_u16(bs, 9 + size);
-		gf_bs_write_int(bs, nb_frag, 4);
-		gf_bs_write_int(bs, cur_frag, 4);
-		gf_bs_write_u24(bs, duration);
-		gf_bs_write_u8(bs, descIndex);
-		/*SLEN is the full original length minus text len and BOM (put here for buffer allocation purposes)*/
-		gf_bs_write_u16(bs, samp_size);
-		gf_bs_get_content(bs, &hdr, &hdr_size);
-		gf_bs_del(bs);
-		builder->OnData(builder->cbk_obj, (char *) hdr, hdr_size, GF_FALSE);
-		builder->bytesInPacket += hdr_size;
-		gf_free(hdr);
-
-		if (builder->OnDataReference) {
-			builder->OnDataReference(builder->cbk_obj, size, pay_start + txt_done);
-		} else {
-			builder->OnData(builder->cbk_obj, data + pay_start + txt_done, size, GF_FALSE);
-		}
-		builder->bytesInPacket += size;
-		cur_frag++;
-
-		/*flush packet*/
-		if (cur_frag == nb_frag) {
-			txt_done = txt_size;
-			if (pay_start + txt_done == data_size) {
-				builder->rtp_header.Marker = 1;
-				builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-				builder->bytesInPacket = 0;
-			}
-		} else {
-			txt_done += size;
-			builder->rtp_header.Marker = 0;
-			builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-			builder->rtp_header.SequenceNumber += 1;
-			builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-			builder->bytesInPacket = 0;
-		}
-	}
-
-	txt_done = txt_size;
-
-	/*write all modifiers - OPT: split at modifiers boundaries*/
-	while (txt_done<samp_size) {
-		u32 size, type;
-		type = (txt_done == txt_size) ? 3 : 4;
-
-		if (txt_done + (builder->Path_MTU-7) < samp_size) {
-			size = builder->Path_MTU-10;
-		} else {
-			size = samp_size - txt_done;
-		}
-
-		bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-		gf_bs_write_int(bs, is_utf_16, 1);
-		gf_bs_write_int(bs, 0, 4);
-		gf_bs_write_int(bs, type, 3);
-		gf_bs_write_u16(bs, 6 + size);
-		gf_bs_write_int(bs, nb_frag, 4);
-		gf_bs_write_int(bs, cur_frag, 4);
-		gf_bs_write_u24(bs, duration);
-
-		gf_bs_get_content(bs, &hdr, &hdr_size);
-		gf_bs_del(bs);
-		builder->OnData(builder->cbk_obj, (char *) hdr, hdr_size, GF_FALSE);
-		builder->bytesInPacket += hdr_size;
-		gf_free(hdr);
-
-		if (builder->OnDataReference) {
-			builder->OnDataReference(builder->cbk_obj, size, pay_start + txt_done);
-		} else {
-			builder->OnData(builder->cbk_obj, data + pay_start + txt_done, size, GF_FALSE);
-		}
-		builder->bytesInPacket += size;
-		cur_frag++;
-		if (cur_frag==nb_frag) {
-			builder->rtp_header.Marker = 1;
-			builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-			builder->bytesInPacket = 0;
-		} else {
-			builder->rtp_header.Marker = 0;
-			builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-			builder->rtp_header.SequenceNumber += 1;
-			builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-			builder->bytesInPacket = 0;
-		}
-		txt_done += size;
-	}
-	return GF_OK;
-}
-
-
-GF_Err gp_rtp_builder_do_dims(GP_RTPPacketizer *builder, char *data, u32 data_size, u8 IsAUEnd, u32 FullAUSize, u32 duration)
-{
-	u32 frag_state;
-	GF_BitStream *bs;
-	u32 offset;
-	Bool is_last_du;
-
-	/*the DIMS hinter doesn't perform inter-sample concatenation*/
-	if (!data) return GF_OK;
-
-	offset = 0;
-	builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
-	bs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);
-	while (offset < data_size) {
-		u32 du_offset = 0;
-		u32 hdr_offset = 0;
-		u32 orig_size, du_size;
-
-		orig_size = du_size = 2+gf_bs_read_u16(bs);
-		/*if dims size is >0xFFFF, use our internal hack for large units*/
-		if (du_size==2) {
-			orig_size = du_size = 2+gf_bs_read_u32(bs);
-			hdr_offset = 4;
-		}
-		gf_bs_skip_bytes(bs, du_size-2);
-
-		/*prepare M-bit*/
-		is_last_du = (offset+du_size==data_size) ? GF_TRUE : GF_FALSE;
-
-		frag_state = 0;
-		while (du_size) {
-			u32 size_offset = 0;
-			u32 size = du_size;
-
-			/*does not fit, flush required*/
-			if (builder->bytesInPacket && (du_size + 1 + builder->bytesInPacket > builder->Path_MTU)) {
-				builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-				builder->bytesInPacket = 0;
-			}
-
-			/*fragmentation required*/
-			if (du_size + 1 > builder->Path_MTU) {
-				size = builder->Path_MTU - 1;
-				/*first fragment*/
-				if (!frag_state) {
-					/*size field is skipped !!*/
-					size_offset = 2 + hdr_offset;
-					frag_state = 1;
-
-					while (du_size - size_offset <= size) {
-						size--;
-					}
-				}
-				/*any middle fragment*/
-				else frag_state = 2;
-
-				builder->rtp_header.Marker = 0;
-			}
-			/*last fragment*/
-			else if (frag_state) {
-				size = du_size;
-				frag_state = 3;
-				builder->rtp_header.Marker = is_last_du;
-			} else {
-				size = du_size;
-				builder->rtp_header.Marker = is_last_du;
-			}
-
-			if (frag_state && builder->bytesInPacket) {
-				builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-				builder->bytesInPacket = 0;
-			}
-
-			/*need a new packet*/
-			if (!builder->bytesInPacket) {
-				char dims_rtp_hdr[1];
-
-				/*the unit is critical, increase counter (coded on 3 bits)*/
-				if (! (data[2+hdr_offset] & GF_DIMS_UNIT_P) && (frag_state <= 1) ) {
-					builder->last_au_sn++;
-					builder->last_au_sn %= 8;
-				}
-				/*set CTR value*/
-				dims_rtp_hdr[0] = builder->last_au_sn;
-				/*if M-bit is set in the dims unit header, replicate it*/
-				if (data[2+hdr_offset] & (1<<1) ) dims_rtp_hdr[0] |= (1<<6);
-				/*add unit fragmentation type*/
-				dims_rtp_hdr[0] |= (frag_state<<3);
-
-				builder->rtp_header.SequenceNumber += 1;
-				builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-				builder->OnData(builder->cbk_obj, (char *) dims_rtp_hdr, 1, GF_TRUE);
-				builder->bytesInPacket = 1;
-			}
-
-			/*add payload*/
-			if (builder->OnDataReference)
-				builder->OnDataReference(builder->cbk_obj, size, offset+du_offset+size_offset);
-			else
-				builder->OnData(builder->cbk_obj, data+offset+du_offset+size_offset, size, GF_FALSE);
-
-			/*if fragmentation, force packet flush even on last packet since aggregation unit do not
-			use the same packet format*/
-			if (frag_state) {
-				builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-				builder->bytesInPacket = 0;
-			} else {
-				builder->bytesInPacket += size;
-			}
-			du_offset += size+size_offset;
-			assert(du_size>= size+size_offset);
-			du_size -= size+size_offset;
-		}
-		offset += orig_size;
-	}
-	if (builder->bytesInPacket) {
-		builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-		builder->bytesInPacket = 0;
-	}
-	gf_bs_del(bs);
-	return GF_OK;
-}
-
-
-
-static void gf_rtp_ac3_flush(GP_RTPPacketizer *builder)
-{
-	char hdr[2];
-	if (!builder->bytesInPacket) return;
-
-	hdr[0] = builder->ac3_ft;
-	hdr[1] = builder->last_au_sn;
-	builder->OnData(builder->cbk_obj, hdr, 2, GF_TRUE);
-
-	builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-	builder->bytesInPacket = 0;
-	builder->last_au_sn = 0;
-	builder->ac3_ft = 0;
-}
-
-GF_Err gp_rtp_builder_do_ac3(GP_RTPPacketizer *builder, char *data, u32 data_size, u8 IsAUEnd, u32 FullAUSize)
-{
-	char hdr[2];
-	u32 offset, nb_pck;
-
-	/*flush*/
-	if (!data) {
-		gf_rtp_ac3_flush(builder);
-		return GF_OK;
-	}
-
-	if (
-	    /*AU does not fit*/
-	    (builder->bytesInPacket + data_size > builder->Path_MTU)
-	    ||
-	    /*aggregation is not enabled*/
-	    !(builder->flags & GP_RTP_PCK_USE_MULTI)
-	    ||
-	    /*max ptime is exceeded*/
-	    (builder->max_ptime && ( (u32) builder->sl_header.compositionTimeStamp >= builder->rtp_header.TimeStamp + builder->max_ptime) )
-
-	) {
-		gf_rtp_ac3_flush(builder);
-	}
-
-	/*fits*/
-	if (builder->bytesInPacket + data_size < builder->Path_MTU) {
-		/*need a new packet*/
-		if (!builder->bytesInPacket) {
-			builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
-			builder->ac3_ft = 0;
-			builder->rtp_header.Marker = 1;
-			builder->rtp_header.SequenceNumber += 1;
-			builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-			/*2 bytes header*/
-			builder->bytesInPacket = 2;
-		}
-
-		/*add payload*/
-		if (builder->OnDataReference)
-			builder->OnDataReference(builder->cbk_obj, data_size, 0);
-		else
-			builder->OnData(builder->cbk_obj, data, data_size, GF_FALSE);
-
-		builder->bytesInPacket += data_size;
-		builder->last_au_sn++;
-		return GF_OK;
-	}
-
-	/*need fragmentation*/
-	assert(!builder->bytesInPacket);
-	offset = 0;
-	nb_pck = data_size / (builder->Path_MTU-2);
-	if (data_size % (builder->Path_MTU-2)) nb_pck++;
-	builder->last_au_sn = nb_pck;
-
-	while (offset < data_size) {
-		u32 pck_size = MIN(data_size-offset, builder->Path_MTU-2);
-
-		builder->rtp_header.Marker = 0;
-		builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
-		builder->rtp_header.SequenceNumber += 1;
-
-		if (!offset) {
-			builder->ac3_ft = (pck_size > 5*data_size/8) ? 1 : 2;
-		} else {
-			builder->ac3_ft = 3;
-			if (offset + pck_size == data_size)
-				builder->rtp_header.Marker = 1;
-		}
-		builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-
-		hdr[0] = builder->ac3_ft;
-		hdr[1] = builder->last_au_sn;
-		builder->OnData(builder->cbk_obj, hdr, 2, GF_TRUE);
-
-		/*add payload*/
-		if (builder->OnDataReference)
-			builder->OnDataReference(builder->cbk_obj, pck_size, offset);
-		else
-			builder->OnData(builder->cbk_obj, data+offset, pck_size, GF_FALSE);
-
-		builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-		offset += pck_size;
-		builder->bytesInPacket = 0;
-	}
-
-	return GF_OK;
-}
-
-#endif /*GPAC_DISABLE_STREAMING*/
-
diff --git a/src/ietfPrtp_pck_mpeg12.c b/src/ietfPrtp_pck_mpeg12.c
deleted file mode 100644
index 5f2c99ebb..000000000
--- a/src/ietfPrtp_pck_mpeg12.c
+++ /dev/null
@@ -1,241 +0,0 @@
-/*
- *			GPAC - Multimedia Framework C SDK
- *
- *			Authors: Jean Le Feuvre
- *			Copyright (c) Telecom ParisTech 2000-2012
- *					All rights reserved
- *
- *  This file is part of GPAC / IETF RTP/RTSP/SDP sub-project
- *
- *  GPAC is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU Lesser General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  GPAC is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#include <gpac/internal/ietf_dev.h>
-
-#ifndef GPAC_DISABLE_STREAMING
-
-#include <gpac/constants.h>
-#include <gpac/avparse.h>
-
-static void mpa12_do_flush(GP_RTPPacketizer *builder, Bool start_new)
-{
-	char *tmp;
-	u32 tmp_size;
-	/*flush*/
-	if (builder->pck_hdr) {
-		gf_bs_get_content(builder->pck_hdr, &tmp, &tmp_size);
-		builder->OnData(builder->cbk_obj, tmp, tmp_size, GF_TRUE);
-		gf_free(tmp);
-
-		if (gf_bs_get_size(builder->payload)) {
-			gf_bs_get_content(builder->payload, &tmp, &tmp_size);
-			builder->OnData(builder->cbk_obj, tmp, tmp_size, GF_FALSE);
-			gf_free(tmp);
-		}
-
-		builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-		gf_bs_del(builder->pck_hdr);
-		gf_bs_del(builder->payload);
-		builder->pck_hdr = NULL;
-		builder->payload = NULL;
-		builder->bytesInPacket = 0;
-	}
-	if (!start_new) return;
-
-	builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
-	builder->pck_hdr = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-	builder->payload = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-	/*create new RTP Packet */
-	builder->rtp_header.SequenceNumber += 1;
-	builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-	builder->first_sl_in_rtp = GF_TRUE;
-	builder->bytesInPacket = 0;
-}
-
-GF_Err gp_rtp_builder_do_mpeg12_audio(GP_RTPPacketizer *builder, char *data, u32 data_size, u8 IsAUEnd, u32 FullAUSize)
-{
-	u32 pck_size;
-	u16 offset;
-
-	/*if no data flush, if nothing start if not enough space restart*/
-	if (!data || !builder->bytesInPacket || (builder->bytesInPacket + data_size > builder->Path_MTU)) {
-		mpa12_do_flush(builder, data ? GF_TRUE : GF_FALSE);
-		if (!data) return GF_OK;
-	}
-
-	offset = 0;
-	while (data_size) {
-		if (data_size + 4 < builder->Path_MTU) {
-			pck_size = data_size;
-		} else {
-			pck_size = builder->Path_MTU - 4;
-		}
-		if (builder->first_sl_in_rtp) {
-			gf_bs_write_u16(builder->pck_hdr, 0);
-			gf_bs_write_u16(builder->pck_hdr, offset);
-			builder->first_sl_in_rtp = GF_FALSE;
-			builder->bytesInPacket = 2;
-		}
-		/*add reference*/
-		if (builder->OnDataReference)
-			builder->OnDataReference(builder->cbk_obj, pck_size, offset);
-		else
-			gf_bs_write_data(builder->payload, data + offset, pck_size);
-
-		data_size -= pck_size;
-		builder->bytesInPacket += pck_size;
-		/*start new packet if fragmenting*/
-		if (data_size) {
-			offset += (u16) pck_size;
-			mpa12_do_flush(builder, GF_TRUE);
-		}
-	}
-	/*if offset or no aggregation*/
-	if (offset || !(builder->flags & GP_RTP_PCK_USE_MULTI) ) mpa12_do_flush(builder, GF_FALSE);
-
-	return GF_OK;
-}
-
-#ifndef GPAC_DISABLE_AV_PARSERS
-
-#define MPEG12_PICTURE_START_CODE         0x00000100
-#define MPEG12_SEQUENCE_START_CODE        0x000001b3
-
-GF_Err gp_rtp_builder_do_mpeg12_video(GP_RTPPacketizer *builder, char *data, u32 data_size, u8 IsAUEnd, u32 FullAUSize)
-{
-	u32 startcode, pic_type, max_pck_size, offset, prev_slice, next_slice;
-	Bool start_with_slice, slices_done, got_slice, first_slice, have_seq;
-	char mpv_hdr[4];
-	char *payload, *buffer;
-
-	/*no flsuh (no aggregation)*/
-	if (!data) return GF_OK;
-
-	offset = 0;
-	have_seq = GF_FALSE;
-
-	while (1) {
-		u32 oldoffset;
-		oldoffset = offset;
-		if (gf_mv12_next_start_code((unsigned char *) data + offset, data_size - offset, &offset, &startcode) < 0)
-			break;
-
-		offset += oldoffset;
-		if (startcode == MPEG12_SEQUENCE_START_CODE) have_seq = GF_TRUE;
-		offset += 4;
-
-		if (startcode == MPEG12_PICTURE_START_CODE) break;
-	}
-
-	max_pck_size = builder->Path_MTU - 4;
-
-	payload = data + offset;
-	pic_type = (payload[1] >> 3) & 0x7;
-	/*first 6 bits (MBZ and T bit) not used*/
-	/*temp ref on 10 bits*/
-	mpv_hdr[0] = (payload[0] >> 6) & 0x3;
-	mpv_hdr[1] = (payload[0] << 2) | ((payload[1] >> 6) & 0x3);
-	mpv_hdr[2] = pic_type;
-	mpv_hdr[3] = 0;
-
-	if ((pic_type==2) || (pic_type== 3)) {
-		mpv_hdr[3] = payload[3] << 5;
-		if ((payload[4] & 0x80) != 0) mpv_hdr[3] |= 0x10;
-		if (pic_type == 3) mpv_hdr[3] |= (payload[4] >> 3) & 0xf;
-	}
-
-	/*start packet*/
-	builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
-	builder->rtp_header.Marker = 1;
-	builder->rtp_header.SequenceNumber += 1;
-	builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-
-	buffer = data;
-	prev_slice = 0;
-	start_with_slice = (gf_mv12_next_slice_start((unsigned char *)buffer, offset, data_size, &next_slice) >= 0) ? GF_TRUE : GF_FALSE;
-	offset = 0;
-	slices_done = GF_FALSE;
-	got_slice = start_with_slice;
-	first_slice = GF_TRUE;
-
-	while (data_size > 0) {
-		Bool last_pck;
-		u32 len_to_write;
-
-		if (data_size <= max_pck_size) {
-			len_to_write = data_size;
-			last_pck = GF_TRUE;
-			prev_slice = 0;
-		} else {
-			got_slice = (!first_slice && !slices_done && (next_slice <= max_pck_size)) ? GF_TRUE : GF_FALSE;
-			first_slice = GF_FALSE;
-			last_pck = GF_FALSE;
-
-			while (!slices_done && (next_slice <= max_pck_size)) {
-				prev_slice = next_slice;
-				if (gf_mv12_next_slice_start((unsigned char *)buffer, next_slice + 4, data_size, &next_slice) >= 0) {
-					got_slice = GF_TRUE;
-				} else {
-					slices_done = GF_TRUE;
-				}
-			}
-			if (got_slice) len_to_write = prev_slice;
-			else len_to_write = MIN(max_pck_size, data_size);
-		}
-
-		mpv_hdr[2] = pic_type;
-
-		if (have_seq) {
-			mpv_hdr[2] |= 0x20;
-			have_seq = GF_FALSE;
-		}
-		if (first_slice) mpv_hdr[2] |= 0x10;
-
-		if (got_slice || last_pck) {
-			mpv_hdr[2] |= 0x08;
-			start_with_slice = GF_TRUE;
-		} else {
-			start_with_slice = GF_FALSE;
-		}
-
-		builder->OnData(builder->cbk_obj, mpv_hdr, 4, GF_FALSE);
-		if (builder->OnDataReference) {
-			builder->OnDataReference(builder->cbk_obj, len_to_write, offset);
-		} else {
-			builder->OnData(builder->cbk_obj, data + offset, len_to_write, GF_FALSE);
-		}
-
-		builder->rtp_header.Marker = last_pck ? 1 : 0;
-		builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-
-		offset += len_to_write;
-		data_size -= len_to_write;
-		prev_slice = 0;
-		next_slice -= len_to_write;
-		buffer += len_to_write;
-
-		if (!last_pck) {
-			builder->rtp_header.Marker = 0;
-			builder->rtp_header.SequenceNumber += 1;
-			builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-		}
-	}
-	return GF_OK;
-}
-
-#endif
-
-#endif /*GPAC_DISABLE_STREAMING*/
diff --git a/src/ietfPrtp_pck_mpeg4.c b/src/ietfPrtp_pck_mpeg4.c
deleted file mode 100644
index 8901f1aca..000000000
--- a/src/ietfPrtp_pck_mpeg4.c
+++ /dev/null
@@ -1,782 +0,0 @@
-/*
- *			GPAC - Multimedia Framework C SDK
- *
- *			Authors: Jean Le Feuvre
- *			Copyright (c) Telecom ParisTech 2000-2012
- *					All rights reserved
- *
- *  This file is part of GPAC / IETF RTP/RTSP/SDP sub-project
- *
- *  GPAC is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU Lesser General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  GPAC is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#include <gpac/internal/ietf_dev.h>
-
-#ifndef GPAC_DISABLE_STREAMING
-
-#include <gpac/constants.h>
-
-//get the size of the RSLH section given the GF_SLHeader and the SLMap
-static u32 gf_rtp_build_au_hdr_size(GP_RTPPacketizer *builder, GF_SLHeader *slh)
-{
-	u32 nbBits = 0;
-
-	/*sel enc*/
-	if (builder->flags & GP_RTP_PCK_SELECTIVE_ENCRYPTION) nbBits += 8;
-	/*Note: ISMACryp ALWAYS indicates IV (BSO) and KEYIDX, even when sample is not encrypted. This is
-	quite a waste when using selective encryption....*/
-
-	/*IV*/
-	nbBits += builder->first_sl_in_rtp ? 8*builder->slMap.IV_length : 8*builder->slMap.IV_delta_length;
-	/*keyIndicator*/
-	if (builder->first_sl_in_rtp || (builder->flags & GP_RTP_PCK_KEY_IDX_PER_AU)) {
-		nbBits += 8*builder->slMap.KI_length;
-	}
-
-	/*no input header specified, compute the MAX size*/
-	if (!slh) {
-		/*size length*/
-		if (!builder->slMap.ConstantSize) nbBits += builder->slMap.SizeLength;
-		/*AU index length*/
-		nbBits += builder->first_sl_in_rtp ? builder->slMap.IndexLength : builder->slMap.IndexDeltaLength;
-		/*CTS flag*/
-		if (builder->slMap.CTSDeltaLength) {
-			nbBits += 1;
-			/*all non-first packets have the CTS written if asked*/
-			if (!builder->first_sl_in_rtp) nbBits += builder->slMap.CTSDeltaLength;
-		}
-		if (builder->slMap.DTSDeltaLength) nbBits += 1 + builder->slMap.DTSDeltaLength;
-		if (builder->flags & GP_RTP_PCK_SELECTIVE_ENCRYPTION) nbBits += 8;
-		return nbBits;
-	}
-
-	/*size length*/
-	if (!builder->slMap.ConstantSize) nbBits += builder->slMap.SizeLength;
-
-	/*AU index*/
-	if (builder->first_sl_in_rtp) {
-		if (builder->slMap.IndexLength) nbBits += builder->slMap.IndexLength;
-	} else {
-		if (builder->slMap.IndexDeltaLength) nbBits += builder->slMap.IndexDeltaLength;
-	}
-
-	/*CTS Flag*/
-	if (builder->slMap.CTSDeltaLength) {
-		/*CTS not written if first SL*/
-		if (builder->first_sl_in_rtp) slh->compositionTimeStampFlag = 0;
-		/*but CTS flag is always written*/
-		nbBits += 1;
-	} else {
-		slh->compositionTimeStampFlag = 0;
-	}
-	/*CTS*/
-	if (slh->compositionTimeStampFlag) nbBits += builder->slMap.CTSDeltaLength;
-
-	/*DTS Flag*/
-	if (builder->slMap.DTSDeltaLength) {
-		nbBits += 1;
-	} else {
-		slh->decodingTimeStampFlag = 0;
-	}
-	/*DTS*/
-	if (slh->decodingTimeStampFlag) nbBits += builder->slMap.DTSDeltaLength;
-	/*RAP indication*/
-	if (builder->slMap.RandomAccessIndication) nbBits ++;
-	/*streamState indication*/
-	nbBits += builder->slMap.StreamStateIndication;
-
-	return nbBits;
-}
-
-
-/*write the AU header section - return the nb of BITS written for AU header*/
-u32 gf_rtp_build_au_hdr_write(GP_RTPPacketizer *builder, u32 PayloadSize, u32 RTP_TS)
-{
-	u32 nbBits = 0;
-	s32 delta;
-
-	/*selective encryption*/
-	if (builder->flags & GP_RTP_PCK_SELECTIVE_ENCRYPTION) {
-		gf_bs_write_int(builder->pck_hdr, builder->is_encrypted, 1);
-		gf_bs_write_int(builder->pck_hdr, 0, 7);
-		nbBits = 8;
-	}
-	/*IV*/
-	if (builder->first_sl_in_rtp) {
-		if (builder->slMap.IV_length) {
-			gf_bs_write_long_int(builder->pck_hdr, builder->IV, 8*builder->slMap.IV_length);
-			nbBits += 8*builder->slMap.IV_length;
-		}
-	} else if (builder->slMap.IV_delta_length) {
-		/*NOT SUPPORTED!!! this only applies to interleaving*/
-	}
-	/*key*/
-	if (builder->slMap.KI_length) {
-		if (builder->first_sl_in_rtp || (builder->flags & GP_RTP_PCK_KEY_IDX_PER_AU)) {
-			if (builder->key_indicator) gf_bs_write_data(builder->pck_hdr, builder->key_indicator, builder->slMap.KI_length);
-			else gf_bs_write_int(builder->pck_hdr, 0, 8*builder->slMap.KI_length);
-			nbBits += 8*builder->slMap.KI_length;
-		}
-	}
-
-
-	/*size length*/
-	if (builder->slMap.ConstantSize) {
-		if (PayloadSize != builder->slMap.ConstantSize) return nbBits;
-	} else if (builder->slMap.SizeLength) {
-		/*write the AU size - if not enough bytes (real-time cases) set size to 0*/
-		if (builder->sl_header.accessUnitLength >= (1<<builder->slMap.SizeLength)) {
-			gf_bs_write_int(builder->pck_hdr, 0, builder->slMap.SizeLength);
-		} else {
-			gf_bs_write_int(builder->pck_hdr, builder->sl_header.accessUnitLength, builder->slMap.SizeLength);
-		}
-		nbBits += builder->slMap.SizeLength;
-	}
-	/*AU index*/
-	if (builder->first_sl_in_rtp) {
-		if (builder->slMap.IndexLength) {
-			gf_bs_write_int(builder->pck_hdr, builder->sl_header.AU_sequenceNumber, builder->slMap.IndexLength);
-			nbBits += builder->slMap.IndexLength;
-		}
-	} else {
-		if (builder->slMap.IndexDeltaLength) {
-			//check interleaving, otherwise force default (which is currently always the case)
-			delta = builder->sl_header.AU_sequenceNumber - builder->last_au_sn;
-			delta -= 1;
-			gf_bs_write_int(builder->pck_hdr, delta, builder->slMap.IndexDeltaLength);
-			nbBits += builder->slMap.IndexDeltaLength;
-		}
-	}
-
-	/*CTS Flag*/
-	if (builder->slMap.CTSDeltaLength) {
-		if (builder->first_sl_in_rtp) {
-			builder->sl_header.compositionTimeStampFlag = 0;
-			builder->sl_header.compositionTimeStamp = RTP_TS;
-		}
-		gf_bs_write_int(builder->pck_hdr, builder->sl_header.compositionTimeStampFlag, 1);
-		nbBits += 1;
-	}
-	/*CTS*/
-	if (builder->sl_header.compositionTimeStampFlag) {
-		delta = (u32) builder->sl_header.compositionTimeStamp - RTP_TS;
-		gf_bs_write_int(builder->pck_hdr, delta, builder->slMap.CTSDeltaLength);
-		nbBits += builder->slMap.CTSDeltaLength;
-	}
-	/*DTS Flag*/
-	if (builder->slMap.DTSDeltaLength) {
-		gf_bs_write_int(builder->pck_hdr, builder->sl_header.decodingTimeStampFlag, 1);
-		nbBits += 1;
-	}
-	/*DTS*/
-	if (builder->sl_header.decodingTimeStampFlag) {
-		delta = (u32) (builder->sl_header.compositionTimeStamp - builder->sl_header.decodingTimeStamp);
-		gf_bs_write_int(builder->pck_hdr, delta, builder->slMap.DTSDeltaLength);
-		nbBits += builder->slMap.DTSDeltaLength;
-	}
-	/*RAP indication*/
-	if (builder->slMap.RandomAccessIndication) {
-		gf_bs_write_int(builder->pck_hdr, builder->sl_header.randomAccessPointFlag, 1);
-		nbBits ++;
-	}
-	/*stream state - write AUSeqNum*/
-	if (builder->slMap.StreamStateIndication) {
-		gf_bs_write_int(builder->pck_hdr, builder->sl_header.AU_sequenceNumber, builder->slMap.StreamStateIndication);
-		nbBits += builder->slMap.StreamStateIndication;
-	}
-
-	return nbBits;
-}
-
-
-GF_Err gp_rtp_builder_do_mpeg4(GP_RTPPacketizer *builder, char *data, u32 data_size, u8 IsAUEnd, u32 FullAUSize)
-{
-	char *sl_buffer, *payl_buffer;
-	u32 sl_buffer_size, payl_buffer_size;
-	u32 auh_size_tmp, bytesLeftInPacket, infoSize, pckSize;
-	u64 pos;
-	u8 flush_pck, no_split;
-
-	flush_pck = 0;
-
-	bytesLeftInPacket = data_size;
-	/*flush everything*/
-	if (!data) {
-		if (builder->payload) goto flush_packet;
-		return GF_OK;
-	}
-	if (builder->payload && builder->force_flush) goto flush_packet;
-
-	//go till done
-	while (bytesLeftInPacket) {
-		no_split = 0;
-
-		if (builder->sl_header.accessUnitStartFlag) {
-			//init SL
-			if (builder->sl_header.compositionTimeStamp != builder->sl_header.decodingTimeStamp) {
-				builder->sl_header.decodingTimeStampFlag = 1;
-			}
-			builder->sl_header.compositionTimeStampFlag = 1;
-			builder->sl_header.accessUnitLength = FullAUSize;
-
-			//init some vars - based on the available size and the TS
-			//we decide if we go with the same RTP TS serie or not
-			if (builder->payload) {
-				//don't store more than what we can (that is 2^slMap->CTSDelta - 1)
-				if ( (builder->flags & GP_RTP_PCK_SIGNAL_TS)
-				        && (builder->sl_header.compositionTimeStamp - builder->rtp_header.TimeStamp >= (u32) ( 1 << builder->slMap.CTSDeltaLength) ) ) {
-					goto flush_packet;
-				}
-				//don't split AU if # TS , start a new RTP pck
-				if (builder->sl_header.compositionTimeStamp != builder->rtp_header.TimeStamp)
-					no_split = 1;
-			}
-		}
-
-		/*new RTP Packet*/
-		if (!builder->payload) {
-			/*first SL in RTP*/
-			builder->first_sl_in_rtp = GF_TRUE;
-
-			/*if this is the end of an AU we will set it to 0 as soon as an AU is splitted*/
-			builder->rtp_header.Marker = 1;
-			builder->rtp_header.PayloadType = builder->PayloadType;
-			builder->rtp_header.SequenceNumber += 1;
-
-			builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
-			/*prepare the mapped headers*/
-			builder->pck_hdr = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-			builder->payload = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
-			pckSize = infoSize = 0;
-			builder->bytesInPacket = 0;
-
-			/*in multiSL there is a MSLHSize structure on 2 bytes*/
-			builder->auh_size = 0;
-			if (builder->has_AU_header) {
-				builder->auh_size = 16;
-				gf_bs_write_int(builder->pck_hdr, 0, 16);
-			}
-			flush_pck = 0;
-			/*and create packet*/
-			builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-		}
-
-		//make sure we are not interleaving too much - this should never happen actually
-		if (builder->slMap.IndexDeltaLength
-		        && !builder->first_sl_in_rtp
-		        && (builder->sl_header.AU_sequenceNumber - builder->last_au_sn >= (u32) 1<<builder->slMap.IndexDeltaLength)) {
-			//we cannot write this packet here
-			goto flush_packet;
-		}
-		/*check max ptime*/
-		if (builder->max_ptime && ( (u32) builder->sl_header.compositionTimeStamp >= builder->rtp_header.TimeStamp + builder->max_ptime) )
-			goto flush_packet;
-
-		auh_size_tmp = gf_rtp_build_au_hdr_size(builder, &builder->sl_header);
-
-		infoSize = auh_size_tmp + builder->auh_size;
-		infoSize /= 8;
-		/*align*/
-		if ( (builder->auh_size + auh_size_tmp) % 8) infoSize += 1;
-
-
-		if (bytesLeftInPacket + infoSize + builder->bytesInPacket <= builder->Path_MTU) {
-			//End of our data chunk
-			pckSize = bytesLeftInPacket;
-			builder->sl_header.accessUnitEndFlag = IsAUEnd;
-
-			builder->auh_size += auh_size_tmp;
-
-			builder->sl_header.paddingFlag = builder->sl_header.paddingBits ? 1 : 0;
-		} else {
-
-			//AU cannot fit in packet. If no split, start a new packet
-			if (no_split) goto flush_packet;
-
-			builder->auh_size += auh_size_tmp;
-
-			pckSize = builder->Path_MTU - (infoSize + builder->bytesInPacket);
-			//that's the end of the rtp packet
-			flush_pck = 1;
-			//but not of the AU -> marker is 0
-			builder->rtp_header.Marker = 0;
-		}
-
-		gf_rtp_build_au_hdr_write(builder, pckSize, builder->rtp_header.TimeStamp);
-
-		//notify the user of our data structure
-		if (builder->OnDataReference)
-			builder->OnDataReference(builder->cbk_obj, pckSize, data_size - bytesLeftInPacket);
-		else
-			gf_bs_write_data(builder->payload, data + (data_size - bytesLeftInPacket), pckSize);
-
-
-		bytesLeftInPacket -= pckSize;
-		builder->bytesInPacket += pckSize;
-		/*update IV*/
-		builder->IV += pckSize;
-		builder->sl_header.paddingFlag = 0;
-		builder->sl_header.accessUnitStartFlag = 0;
-
-		//we are splitting a payload, auto increment SL seq num
-		if (bytesLeftInPacket) {
-			builder->sl_header.packetSequenceNumber += 1;
-		} else if (! (builder->flags & GP_RTP_PCK_USE_MULTI) ) {
-			builder->rtp_header.Marker = 1;
-			flush_pck = 1;
-		}
-
-		//first SL in RTP is done
-		builder->first_sl_in_rtp = GF_FALSE;
-
-		//store current sl
-		builder->last_au_sn = builder->sl_header.AU_sequenceNumber;
-
-		if (!flush_pck) continue;
-
-		//done with the packet
-flush_packet:
-
-		gf_bs_align(builder->pck_hdr);
-
-		/*no aux data yet*/
-		if (builder->slMap.AuxiliaryDataSizeLength)	{
-			//write RSLH after the MSLH
-			gf_bs_write_int(builder->pck_hdr, 0, builder->slMap.AuxiliaryDataSizeLength);
-		}
-		/*rewrite the size header*/
-		if (builder->has_AU_header) {
-			pos = gf_bs_get_position(builder->pck_hdr);
-			gf_bs_seek(builder->pck_hdr, 0);
-			builder->auh_size -= 16;
-			gf_bs_write_int(builder->pck_hdr, builder->auh_size, 16);
-			gf_bs_seek(builder->pck_hdr, pos);
-		}
-
-		sl_buffer = NULL;
-		gf_bs_get_content(builder->pck_hdr, &sl_buffer, &sl_buffer_size);
-		//delete our bitstream
-		gf_bs_del(builder->pck_hdr);
-		builder->pck_hdr = NULL;
-
-		payl_buffer = NULL;
-		payl_buffer_size = 0;
-		if (!builder->OnDataReference)
-			gf_bs_get_content(builder->payload, &payl_buffer, &payl_buffer_size);
-
-		gf_bs_del(builder->payload);
-		builder->payload = NULL;
-
-		/*notify header*/
-		builder->OnData(builder->cbk_obj, sl_buffer, sl_buffer_size, GF_TRUE);
-		/*notify payload*/
-		if (payl_buffer) {
-			builder->OnData(builder->cbk_obj, payl_buffer, payl_buffer_size, GF_FALSE);
-			gf_free(payl_buffer);
-		}
-		/*flush packet*/
-		builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-		gf_free(sl_buffer);
-	}
-	//packet is done, update AU markers
-	if (IsAUEnd) {
-		builder->sl_header.accessUnitStartFlag = 1;
-		builder->sl_header.accessUnitEndFlag = 0;
-	}
-	return GF_OK;
-}
-
-
-GF_Err gp_rtp_builder_do_avc(GP_RTPPacketizer *builder, char *nalu, u32 nalu_size, u8 IsAUEnd, u32 FullAUSize)
-{
-	u32 do_flush, bytesLeft, size, nal_type;
-	char shdr[2];
-	char stap_hdr;
-
-	do_flush = 0;
-	if (!nalu) do_flush = 1;
-	/*we only do STAP or SINGLE modes*/
-	else if (builder->sl_header.accessUnitStartFlag) do_flush = 1;
-	/*we must NOT fragment a NALU*/
-	else if (builder->bytesInPacket + nalu_size >= builder->Path_MTU) do_flush = 2;
-	/*aggregation is disabled*/
-	else if (! (builder->flags & GP_RTP_PCK_USE_MULTI) ) do_flush = 2;
-
-	if (builder->bytesInPacket && do_flush) {
-		builder->rtp_header.Marker = (do_flush==1) ? 1 : 0;
-		builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-		builder->bytesInPacket = 0;
-	}
-
-	if (!nalu) return GF_OK;
-
-	/*need a new RTP packet*/
-	if (!builder->bytesInPacket) {
-		builder->rtp_header.PayloadType = builder->PayloadType;
-		builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
-		builder->rtp_header.SequenceNumber += 1;
-		builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-		builder->avc_non_idr = GF_TRUE;
-	}
-
-	/*check NAL type to see if disposable or not*/
-	nal_type = nalu[0] & 0x1F;
-	switch (nal_type) {
-	case GF_AVC_NALU_NON_IDR_SLICE:
-	case GF_AVC_NALU_ACCESS_UNIT:
-	case GF_AVC_NALU_END_OF_SEQ:
-	case GF_AVC_NALU_END_OF_STREAM:
-	case GF_AVC_NALU_FILLER_DATA:
-		break;
-	default:
-		builder->avc_non_idr = GF_FALSE;
-		break;
-	}
-
-	/*at this point we're sure the NALU fits in current packet OR must be splitted*/
-
-	/*pb: we don't know if next NALU from this AU will be small enough to fit in the packet, so we always
-	go for stap...*/
-	if (builder->bytesInPacket+nalu_size<builder->Path_MTU) {
-		Bool use_stap = GF_TRUE;
-		/*if this is the AU end and no NALU in packet, go for single mode*/
-		if (IsAUEnd && !builder->bytesInPacket) use_stap = GF_FALSE;
-
-		if (use_stap) {
-			/*declare STAP-A NAL*/
-			if (!builder->bytesInPacket) {
-				/*copy over F and NRI from first nal in packet and assign type*/
-				stap_hdr = (nalu[0] & 0xE0) | 24;
-				builder->OnData(builder->cbk_obj, (char *) &stap_hdr, 1, GF_FALSE);
-				builder->bytesInPacket = 1;
-			}
-			/*add NALU size*/
-			shdr[0] = nalu_size>>8;
-			shdr[1] = nalu_size&0x00ff;
-			builder->OnData(builder->cbk_obj, (char *)shdr, 2, GF_FALSE);
-			builder->bytesInPacket += 2;
-		}
-		/*add data*/
-		if (builder->OnDataReference)
-			builder->OnDataReference(builder->cbk_obj, nalu_size, 0);
-		else
-			builder->OnData(builder->cbk_obj, nalu, nalu_size, GF_FALSE);
-
-		builder->bytesInPacket += nalu_size;
-
-		if (IsAUEnd) {
-			builder->rtp_header.Marker = 1;
-			builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-			builder->bytesInPacket = 0;
-		}
-	}
-	/*fragmentation unit*/
-	else {
-		u32 offset;
-		assert(nalu_size>=builder->Path_MTU);
-		assert(!builder->bytesInPacket);
-		/*FU payload doesn't have the NAL hdr*/
-		bytesLeft = nalu_size - 1;
-		offset = 1;
-		while (bytesLeft) {
-			if (2 + bytesLeft > builder->Path_MTU) {
-				size = builder->Path_MTU - 2;
-			} else {
-				size = bytesLeft;
-			}
-
-			/*copy over F and NRI from nal in packet and assign type*/
-			shdr[0] = (nalu[0] & 0xE0) | 28;
-			/*copy over NAL type from nal and set start bit and end bit*/
-			shdr[1] = (nalu[0] & 0x1F);
-			/*start bit*/
-			if (offset==1) shdr[1] |= 0x80;
-			/*end bit*/
-			else if (size == bytesLeft) shdr[1] |= 0x40;
-
-			builder->OnData(builder->cbk_obj, (char *)shdr, 2, GF_FALSE);
-
-			/*add data*/
-			if (builder->OnDataReference)
-				builder->OnDataReference(builder->cbk_obj, size, offset);
-			else
-				builder->OnData(builder->cbk_obj, nalu+offset, size, GF_FALSE);
-
-			offset += size;
-			bytesLeft -= size;
-
-			/*flush no matter what (FUs cannot be agreggated)*/
-			builder->rtp_header.Marker = (IsAUEnd && !bytesLeft) ? 1 : 0;
-			builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-			builder->bytesInPacket = 0;
-
-			if (bytesLeft) {
-				builder->rtp_header.PayloadType = builder->PayloadType;
-				builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
-				builder->rtp_header.SequenceNumber += 1;
-				builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-			}
-		}
-	}
-
-	return GF_OK;
-}
-
-GF_Err gp_rtp_builder_do_hevc(GP_RTPPacketizer *builder, char *nalu, u32 nalu_size, u8 IsAUEnd, u32 FullAUSize)
-{
-	u32 do_flush, bytesLeft, size;
-
-	do_flush = 0;
-	if (!nalu) do_flush = 1;
-	else if (builder->sl_header.accessUnitStartFlag) do_flush = 1;
-	/*we must NOT fragment a NALU*/
-	else if (builder->bytesInPacket + nalu_size + 4 >= builder->Path_MTU) do_flush = 2; //2 bytes PayloadHdr for AP + 2 bytes NAL size
-	/*aggregation is disabled*/
-	else if (! (builder->flags & GP_RTP_PCK_USE_MULTI) ) do_flush = 2;
-
-	if (builder->bytesInPacket && do_flush) {
-		builder->rtp_header.Marker = (do_flush==1) ? 1 : 0;
-		/*insert payload_hdr in case of AP*/
-		if (strlen(builder->hevc_payload_hdr)) {
-			builder->OnData(builder->cbk_obj, (char *)builder->hevc_payload_hdr, 2, GF_TRUE);
-			memset(builder->hevc_payload_hdr, 0, 2);
-		}
-		builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-		builder->bytesInPacket = 0;
-	}
-
-	if (!nalu) return GF_OK;
-
-	/*need a new RTP packet*/
-	if (!builder->bytesInPacket) {
-		builder->rtp_header.PayloadType = builder->PayloadType;
-		builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
-		builder->rtp_header.SequenceNumber += 1;
-		builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-	}
-
-	/*at this point we're sure the NALU fits in current packet OR must be splitted*/
-	/*check that we should use single NALU packet mode or aggreation packets mode*/
-	if (builder->bytesInPacket+nalu_size+4 < builder->Path_MTU) {
-		Bool use_AP = (builder->flags & GP_RTP_PCK_USE_MULTI) ? GF_TRUE : GF_FALSE;
-		/*if this is the AU end and no NALU in packet, go for single NALU packet mode*/
-		if (IsAUEnd && !builder->bytesInPacket) use_AP = GF_FALSE;
-
-		if (use_AP) {
-			char nal_s[2];
-			/*declare PayloadHdr for AP*/
-			if (!builder->bytesInPacket) {
-				/*copy F bit and assign type*/
-				builder->hevc_payload_hdr[0] = (nalu[0] & 0x81) | (48 << 1);
-				/*copy LayerId and TID*/
-				builder->hevc_payload_hdr[1] = nalu[1];
-			}
-			else {
-				/*F bit of AP is 0 if the F nit of each aggreated NALU is 0; otherwise its must be 1*/
-				/*LayerId and TID must ne the lowest value of LayerId and TID of all aggreated NALU*/
-				u8 cur_LayerId, cur_TID, new_LayerId, new_TID;
-
-				builder->hevc_payload_hdr[0] |= (nalu[0] & 0x80);
-				cur_LayerId = ((builder->hevc_payload_hdr[0] & 0x01) << 5) + ((builder->hevc_payload_hdr[1] & 0xF8) >> 3);
-				new_LayerId = ((nalu[0] & 0x01) << 5) + ((nalu[1] & 0xF8) >> 3);
-				if (cur_LayerId > new_LayerId) {
-					builder->hevc_payload_hdr[0] = (builder->hevc_payload_hdr[0] & 0xFE) | (nalu[0] & 0x01);
-					builder->hevc_payload_hdr[1] = (builder->hevc_payload_hdr[1] & 0x07) | (nalu[1] & 0xF8);
-				}
-				cur_TID = builder->hevc_payload_hdr[1] & 0x07;
-				new_TID = nalu[1] & 0x07;
-				if (cur_TID > new_TID) {
-					builder->hevc_payload_hdr[1] = (builder->hevc_payload_hdr[1] & 0xF8) | (nalu[1] & 0x07);
-				}
-			}
-
-			/*add NALU size*/
-			nal_s[0] = nalu_size>>8;
-			nal_s[1] = nalu_size&0x00ff;
-			builder->OnData(builder->cbk_obj, (char *)nal_s, 2, GF_FALSE);
-			builder->bytesInPacket += 2;
-		}
-		/*add data*/
-		if (builder->OnDataReference)
-			builder->OnDataReference(builder->cbk_obj, nalu_size, 0);
-		else
-			builder->OnData(builder->cbk_obj, nalu, nalu_size, GF_FALSE);
-
-		builder->bytesInPacket += nalu_size;
-
-		if (IsAUEnd) {
-			builder->rtp_header.Marker = 1;
-			if (strlen(builder->hevc_payload_hdr)) {
-				builder->OnData(builder->cbk_obj, (char *)builder->hevc_payload_hdr, 2, GF_TRUE);
-				memset(builder->hevc_payload_hdr, 0, 2);
-			}
-			builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-			builder->bytesInPacket = 0;
-		}
-	}
-	/*fragmentation unit*/
-	else {
-		u32 offset;
-		char payload_hdr[2];
-		char shdr;
-
-		assert(nalu_size + 4 >=builder->Path_MTU);
-		assert(!builder->bytesInPacket);
-
-		/*FU payload doesn't have the NAL hdr (2 bytes*/
-		bytesLeft = nalu_size - 2;
-		offset = 2;
-		while (bytesLeft) {
-			if (3 + bytesLeft > builder->Path_MTU) {
-				size = builder->Path_MTU - 3;
-			} else {
-				size = bytesLeft;
-			}
-
-			/*declare PayloadHdr for FU*/
-			memset(payload_hdr, 0, 2);
-			/*copy F bit and assign type*/
-			payload_hdr[0] = (nalu[0] & 0x81) | (49 << 1);
-			/*copy LayerId and TID*/
-			payload_hdr[1] = nalu[1];
-			builder->OnData(builder->cbk_obj, (char *)payload_hdr, 2, GF_FALSE);
-
-			/*declare FU header*/
-			shdr = 0;
-			/*assign type*/
-			shdr |= (nalu[0] & 0x7E) >> 1;
-			/*start bit*/
-			if (offset==2) shdr |= 0x80;
-			/*end bit*/
-			else if (size == bytesLeft) shdr |= 0x40;
-
-			builder->OnData(builder->cbk_obj, &shdr, 1, GF_FALSE);
-
-			/*add data*/
-			if (builder->OnDataReference)
-				builder->OnDataReference(builder->cbk_obj, size, offset);
-			else
-				builder->OnData(builder->cbk_obj, nalu+offset, size, GF_FALSE);
-
-			offset += size;
-			bytesLeft -= size;
-
-			/*flush no matter what (FUs cannot be agreggated)*/
-			builder->rtp_header.Marker = (IsAUEnd && !bytesLeft) ? 1 : 0;
-			builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-			builder->bytesInPacket = 0;
-
-			if (bytesLeft) {
-				builder->rtp_header.PayloadType = builder->PayloadType;
-				builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
-				builder->rtp_header.SequenceNumber += 1;
-				builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-			}
-		}
-	}
-	return GF_OK;
-}
-
-void latm_flush(GP_RTPPacketizer *builder)
-{
-	if (builder->bytesInPacket) {
-		builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header);
-		builder->bytesInPacket = 0;
-	}
-	builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
-}
-
-GF_Err gp_rtp_builder_do_latm(GP_RTPPacketizer *builder, char *data, u32 data_size, u8 IsAUEnd, u32 FullAUSize, u32 duration)
-{
-	u32 size, latm_hdr_size, i, data_offset;
-	Bool fragmented;
-	unsigned char *latm_hdr;
-
-	if (!data) {
-		latm_flush(builder);
-		return GF_OK;
-	}
-
-	if ((builder->flags & GP_RTP_PCK_USE_MULTI) && builder->max_ptime) {
-		if ((u32) builder->sl_header.compositionTimeStamp + duration >= builder->rtp_header.TimeStamp + builder->max_ptime)
-			latm_flush(builder);
-	}
-	/*compute max size for frame, flush current if this doesn't fit*/
-	latm_hdr_size = (data_size / 255) + 1;
-	if (latm_hdr_size+data_size > builder->Path_MTU - builder->bytesInPacket) {
-		latm_flush(builder);
-	}
-
-	data_offset = 0;
-	fragmented = GF_FALSE;
-	while (data_size > 0) {
-		latm_hdr_size = (data_size / 255) + 1;
-		/*fragmenting*/
-		if (latm_hdr_size + data_size > builder->Path_MTU) {
-			assert(!builder->bytesInPacket);
-			fragmented = GF_TRUE;
-			latm_hdr_size = (builder->Path_MTU / 255) + 1;
-			size = builder->Path_MTU - latm_hdr_size;
-			builder->rtp_header.Marker = 0;
-		}
-		/*last fragment or full AU*/
-		else {
-			fragmented = GF_FALSE;
-			size = data_size;
-			builder->rtp_header.Marker = 1;
-		}
-		data_size -= size;
-
-		/*create new RTP Packet if needed*/
-		if (!builder->bytesInPacket) {
-			builder->rtp_header.SequenceNumber += 1;
-			builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp;
-			builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header);
-		}
-
-		/* compute AudioMuxUnit header */
-		latm_hdr_size = (size / 255) + 1;
-		latm_hdr = (unsigned char *)gf_malloc( sizeof(char) * latm_hdr_size);
-		for (i=0; i<latm_hdr_size-1; i++)  latm_hdr[i] = 255;
-		latm_hdr[latm_hdr_size-1] = size % 255;
-
-		/*add LATM header IN ORDER in case we aggregate audioMuxElements in RTP*/
-		builder->OnData(builder->cbk_obj, (char*) latm_hdr, latm_hdr_size, GF_FALSE);
-		builder->bytesInPacket += latm_hdr_size;
-		gf_free(latm_hdr);
-
-		/*add payload*/
-		if (builder->OnDataReference) {
-			builder->OnDataReference(builder->cbk_obj, size, data_offset);
-		} else
-			builder->OnData(builder->cbk_obj, data, size, GF_FALSE);
-
-		builder->bytesInPacket += size;
-
-		data_offset += size;
-
-		/*fragmented AU, always flush packet*/
-		if (!builder->rtp_header.Marker) latm_flush(builder);
-	}
-	/*if the AU has been fragmented or we don't use RTP aggregation, flush*/
-	if (! (builder->flags & GP_RTP_PCK_USE_MULTI) ) fragmented = GF_TRUE;
-	if (fragmented) latm_flush(builder);
-
-	return GF_OK;
-}
-
-
-#endif /*GPAC_DISABLE_STREAMING*/
diff --git a/src/ietfPrtp_streamer.c b/src/ietfPrtp_streamer.c
deleted file mode 100644
index a1826130b..000000000
--- a/src/ietfPrtp_streamer.c
+++ /dev/null
@@ -1,851 +0,0 @@
-/*
- *			GPAC - Multimedia Framework C SDK
- *
- *			Authors: Jean Le Feuvre
- *			Copyright (c) Telecom ParisTech 2000-2012
- *					All rights reserved
- *
- *  This file is part of GPAC / IETF RTP/RTSP/SDP sub-project
- *
- *  GPAC is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU Lesser General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  GPAC is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-
-#include <gpac/rtp_streamer.h>
-#include <gpac/constants.h>
-#include <gpac/base_coding.h>
-#ifndef GPAC_DISABLE_AV_PARSERS
-#include <gpac/avparse.h>
-#endif
-#include <gpac/internal/ietf_dev.h>
-
-#if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_ISOM)
-
-struct __rtp_streamer
-{
-	GP_RTPPacketizer *packetizer;
-	GF_RTPChannel *channel;
-
-	/* The current packet being formed */
-	char *buffer;
-	u32 payload_len, buffer_alloc;
-
-	Double ts_scale;
-};
-
-
-/*callbacks from packetizer to channel*/
-
-static void rtp_stream_on_new_packet(void *cbk, GF_RTPHeader *header)
-{
-}
-
-static void rtp_stream_on_packet_done(void *cbk, GF_RTPHeader *header)
-{
-	GF_RTPStreamer *rtp = (GF_RTPStreamer*)cbk;
-	GF_Err e = gf_rtp_send_packet(rtp->channel, header, rtp->buffer+12, rtp->payload_len, GF_TRUE);
-
-#ifndef GPAC_DISABLE_LOG
-	if (e) {
-		GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, ("Error %s sending RTP packet\n", gf_error_to_string(e)));
-	} else {
-		GF_LOG(GF_LOG_DEBUG, GF_LOG_RTP, ("RTP SN %u - TS %u - M %u - Size %u\n", header->SequenceNumber, header->TimeStamp, header->Marker, rtp->payload_len + 12));
-	}
-#endif
-	rtp->payload_len = 0;
-}
-
-static void rtp_stream_on_data(void *cbk, char *data, u32 data_size, Bool is_head)
-{
-	GF_RTPStreamer *rtp = (GF_RTPStreamer*)cbk;
-	if (!data ||!data_size) return;
-
-	if (rtp->payload_len+data_size+12 > rtp->buffer_alloc) {
-		GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, ("[RTP] Packet size %d bigger than MTU size %d - discarding\n", rtp->payload_len+data_size+12, rtp->buffer_alloc));
-		rtp->payload_len += data_size;
-		return;
-	}
-	if (!is_head) {
-		memcpy(rtp->buffer + rtp->payload_len + 12, data, data_size);
-	} else {
-		memmove(rtp->buffer + data_size + 12, rtp->buffer + 12, rtp->payload_len);
-		memcpy(rtp->buffer + 12, data, data_size);
-	}
-	rtp->payload_len += data_size;
-}
-
-static GF_Err rtp_stream_init_channel(GF_RTPStreamer *rtp, u32 path_mtu, const char * dest, int port, int ttl, const char *ifce_addr)
-{
-	GF_RTSPTransport tr;
-	GF_Err res;
-
-	rtp->channel = gf_rtp_new();
-	gf_rtp_set_ports(rtp->channel, 0);
-	memset(&tr, 0, sizeof(GF_RTSPTransport));
-
-	tr.IsUnicast = gf_sk_is_multicast_address(dest) ? GF_FALSE : GF_TRUE;
-	tr.Profile="RTP/AVP";
-	tr.destination = (char *)dest;
-	tr.source = "0.0.0.0";
-	tr.IsRecord = GF_FALSE;
-	tr.Append = GF_FALSE;
-	tr.SSRC = rand();
-	tr.TTL = ttl;
-
-	tr.port_first = port;
-	tr.port_last = port+1;
-	if (tr.IsUnicast) {
-		tr.client_port_first = port;
-		tr.client_port_last  = port+1;
-	} else {
-		tr.source = (char *)dest;
-	}
-
-	res = gf_rtp_setup_transport(rtp->channel, &tr, dest);
-	if (res !=0) {
-		GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, ("Cannot setup RTP transport info: %s\n", gf_error_to_string(res) ));
-		return res;
-	}
-
-	res = gf_rtp_initialize(rtp->channel, 0, GF_TRUE, path_mtu, 0, 0, (char *)ifce_addr);
-	if (res !=0) {
-		GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, ("Cannot initialize RTP sockets: %s\n", gf_error_to_string(res) ));
-		return res;
-	}
-	return GF_OK;
-}
-
-GF_EXPORT
-GF_RTPStreamer *gf_rtp_streamer_new_extended(u32 streamType, u32 oti, u32 timeScale,
-        const char *ip_dest, u16 port, u32 MTU, u8 TTL, const char *ifce_addr,
-        u32 flags, char *dsi, u32 dsi_len,
-
-        u32 PayloadType, u32 sample_rate, u32 nb_ch,
-        Bool is_crypted, u32 IV_length, u32 KI_length,
-        u32 MinSize, u32 MaxSize, u32 avgTS, u32 maxDTSDelta, u32 const_dur, u32 bandwidth, u32 max_ptime,
-        u32 au_sn_len
-                                            )
-{
-	GF_SLConfig slc;
-	GF_RTPStreamer *stream;
-	u32 rtp_type, default_rtp_rate;
-	u8 OfficialPayloadType;
-	u32 required_rate, force_dts_delta, PL_ID;
-	char *mpeg4mode;
-	Bool has_mpeg4_mapping;
-	GF_Err e;
-
-	if (!timeScale) timeScale = 1000;
-
-	GF_SAFEALLOC(stream, GF_RTPStreamer);
-
-
-	/*by default NO PL signaled*/
-	PL_ID = 0;
-	OfficialPayloadType = 0;
-	force_dts_delta = 0;
-	mpeg4mode = NULL;
-	required_rate = 0;
-	nb_ch = 0;
-	has_mpeg4_mapping = GF_TRUE;
-	rtp_type = 0;
-
-	/*for max compatibility with QT*/
-	default_rtp_rate = 90000;
-
-	/*timed-text is a bit special, we support multiple stream descriptions & co*/
-	switch (streamType) {
-	case GF_STREAM_TEXT:
-		if (oti!=GPAC_OTI_TEXT_MPEG4)
-			return NULL;
-
-		rtp_type = GF_RTP_PAYT_3GPP_TEXT;
-		/*fixme - this works cos there's only one PL for text in mpeg4 at the current time*/
-		PL_ID = 0x10;
-		break;
-	case GF_STREAM_AUDIO:
-		required_rate = sample_rate;
-		switch (oti) {
-		/*AAC*/
-		case GPAC_OTI_AUDIO_AAC_MPEG4:
-		case GPAC_OTI_AUDIO_AAC_MPEG2_MP:
-		case GPAC_OTI_AUDIO_AAC_MPEG2_LCP:
-		case GPAC_OTI_AUDIO_AAC_MPEG2_SSRP:
-			PL_ID = 0x01;
-			mpeg4mode = "AAC";
-			rtp_type = GF_RTP_PAYT_MPEG4;
-			required_rate = sample_rate;
-
-#ifndef GPAC_DISABLE_AV_PARSERS
-			if (dsi) {
-				GF_M4ADecSpecInfo a_cfg;
-				gf_m4a_get_config(dsi, dsi_len, &a_cfg);
-				nb_ch = a_cfg.nb_chan;
-				sample_rate = a_cfg.base_sr;
-				PL_ID = a_cfg.audioPL;
-				switch (a_cfg.base_object_type) {
-				case GF_M4A_AAC_MAIN:
-				case GF_M4A_AAC_LC:
-					if (flags & GP_RTP_PCK_USE_LATM_AAC) {
-						rtp_type = GF_RTP_PAYT_LATM;
-						break;
-					}
-				case GF_M4A_AAC_SBR:
-				case GF_M4A_AAC_PS:
-				case GF_M4A_AAC_LTP:
-				case GF_M4A_AAC_SCALABLE:
-				case GF_M4A_ER_AAC_LC:
-				case GF_M4A_ER_AAC_LTP:
-				case GF_M4A_ER_AAC_SCALABLE:
-					mpeg4mode = "AAC";
-					break;
-				case GF_M4A_CELP:
-				case GF_M4A_ER_CELP:
-					mpeg4mode = "CELP";
-					break;
-				}
-			}
-#endif
-			break;
-
-		/*MPEG1/2 audio*/
-		case GPAC_OTI_AUDIO_MPEG2_PART3:
-		case GPAC_OTI_AUDIO_MPEG1:
-			if (!is_crypted) {
-				rtp_type = GF_RTP_PAYT_MPEG12_AUDIO;
-				/*use official RTP/AVP payload type*/
-				OfficialPayloadType = 14;
-				required_rate = 90000;
-			}
-			/*encrypted MP3 must be sent through MPEG-4 generic to signal all ISMACryp stuff*/
-			else {
-				rtp_type = GF_RTP_PAYT_MPEG4;
-			}
-			break;
-
-		/*QCELP audio*/
-		case GPAC_OTI_AUDIO_13K_VOICE:
-			rtp_type = GF_RTP_PAYT_QCELP;
-			OfficialPayloadType = 12;
-			required_rate = 8000;
-			nb_ch = 1;
-			break;
-
-		/*EVRC/SVM audio*/
-		case GPAC_OTI_AUDIO_EVRC_VOICE:
-		case GPAC_OTI_AUDIO_SMV_VOICE:
-			rtp_type = GF_RTP_PAYT_EVRC_SMV;
-			required_rate = 8000;
-			nb_ch = 1;
-		}
-
-		break;
-
-	case GF_STREAM_VISUAL:
-		rtp_type = GF_RTP_PAYT_MPEG4;
-		required_rate = default_rtp_rate;
-		if (is_crypted) {
-			/*that's another pain with ISMACryp, even if no B-frames the DTS is signaled...*/
-			if (oti==GPAC_OTI_VIDEO_MPEG4_PART2) force_dts_delta = 22;
-			flags |= GP_RTP_PCK_SIGNAL_RAP | GP_RTP_PCK_SIGNAL_TS;
-		}
-
-		switch (oti) {
-		/*ISO/IEC 14496-2*/
-		case GPAC_OTI_VIDEO_MPEG4_PART2:
-			PL_ID = 1;
-#ifndef GPAC_DISABLE_AV_PARSERS
-			if (dsi) {
-				GF_M4VDecSpecInfo vhdr;
-				gf_m4v_get_config(dsi, dsi_len, &vhdr);
-				PL_ID = vhdr.VideoPL;
-			}
-#endif
-			break;
-
-		/*MPEG1/2 video*/
-		case GPAC_OTI_VIDEO_MPEG1:
-		case GPAC_OTI_VIDEO_MPEG2_SIMPLE:
-		case GPAC_OTI_VIDEO_MPEG2_MAIN:
-		case GPAC_OTI_VIDEO_MPEG2_SNR:
-		case GPAC_OTI_VIDEO_MPEG2_SPATIAL:
-		case GPAC_OTI_VIDEO_MPEG2_HIGH:
-		case GPAC_OTI_VIDEO_MPEG2_422:
-			if (!is_crypted) {
-				rtp_type = GF_RTP_PAYT_MPEG12_VIDEO;
-				OfficialPayloadType = 32;
-			}
-			break;
-		/*AVC/H.264*/
-		case GPAC_OTI_VIDEO_AVC:
-			required_rate = 90000;	/* "90 kHz clock rate MUST be used"*/
-			rtp_type = GF_RTP_PAYT_H264_AVC;
-			PL_ID = 0x0F;
-			break;
-		/*H264-SVC*/
-		case GPAC_OTI_VIDEO_SVC:
-			required_rate = 90000;	/* "90 kHz clock rate MUST be used"*/
-			rtp_type = GF_RTP_PAYT_H264_SVC;
-			PL_ID = 0x0F;
-			break;
-		/*HEVC*/
-		case GPAC_OTI_VIDEO_HEVC:
-			required_rate = 90000;	/* "90 kHz clock rate MUST be used"*/
-			rtp_type = GF_RTP_PAYT_HEVC;
-			PL_ID = 0x0F;
-			break;
-		/*SHVC*/
-		case GPAC_OTI_VIDEO_SHVC:
-			required_rate = 90000;	/* "90 kHz clock rate MUST be used"*/
-			rtp_type = GF_RTP_PAYT_SHVC;
-			PL_ID = 0x0F;
-			break;
-		}
-		break;
-
-	case GF_STREAM_SCENE:
-	case GF_STREAM_OD:
-		if (oti == GPAC_OTI_SCENE_DIMS) {
-			rtp_type = GF_RTP_PAYT_3GPP_DIMS;
-			has_mpeg4_mapping = GF_FALSE;
-		} else {
-			rtp_type = GF_RTP_PAYT_MPEG4;
-		}
-		break;
-
-
-	case GF_STREAM_4CC:
-		switch (oti) {
-		case GF_ISOM_SUBTYPE_3GP_H263:
-			rtp_type = GF_RTP_PAYT_H263;
-			required_rate = 90000;
-			streamType = GF_STREAM_VISUAL;
-			OfficialPayloadType = 34;
-			/*not 100% compliant (short header is missing) but should still work*/
-			oti = GPAC_OTI_VIDEO_MPEG4_PART2;
-			PL_ID = 0x01;
-			break;
-		case GF_ISOM_SUBTYPE_3GP_AMR:
-			required_rate = 8000;
-			rtp_type = GF_RTP_PAYT_AMR;
-			streamType = GF_STREAM_AUDIO;
-			has_mpeg4_mapping = GF_FALSE;
-			nb_ch = 1;
-			break;
-		case GF_ISOM_SUBTYPE_3GP_AMR_WB:
-			required_rate = 16000;
-			rtp_type = GF_RTP_PAYT_AMR_WB;
-			streamType = GF_STREAM_AUDIO;
-			has_mpeg4_mapping = GF_FALSE;
-			nb_ch = 1;
-			break;
-		case GF_ISOM_SUBTYPE_AC3:
-			rtp_type = GF_RTP_PAYT_AC3;
-			streamType = GF_STREAM_AUDIO;
-			has_mpeg4_mapping = GF_TRUE;
-			nb_ch = 1;
-			break;
-		case GF_ISOM_SUBTYPE_AVC_H264:
-		case GF_ISOM_SUBTYPE_AVC2_H264:
-		case GF_ISOM_SUBTYPE_AVC3_H264:
-		case GF_ISOM_SUBTYPE_AVC4_H264:
-		case GF_ISOM_SUBTYPE_SVC_H264:
-		{
-			required_rate = 90000;	/* "90 kHz clock rate MUST be used"*/
-			rtp_type = GF_RTP_PAYT_H264_AVC;
-			streamType = GF_STREAM_VISUAL;
-			oti = GPAC_OTI_VIDEO_AVC;
-			PL_ID = 0x0F;
-		}
-		break;
-		case GF_ISOM_SUBTYPE_3GP_QCELP:
-			required_rate = 8000;
-			rtp_type = GF_RTP_PAYT_QCELP;
-			streamType = GF_STREAM_AUDIO;
-			oti = GPAC_OTI_AUDIO_13K_VOICE;
-			OfficialPayloadType = 12;
-			nb_ch = 1;
-			break;
-		case GF_ISOM_SUBTYPE_3GP_EVRC:
-		case GF_ISOM_SUBTYPE_3GP_SMV:
-			required_rate = 8000;
-			rtp_type = GF_RTP_PAYT_EVRC_SMV;
-			streamType = GF_STREAM_AUDIO;
-			oti = (oti==GF_ISOM_SUBTYPE_3GP_EVRC) ? GPAC_OTI_AUDIO_EVRC_VOICE : GPAC_OTI_AUDIO_SMV_VOICE;
-			nb_ch = 1;
-			break;
-		case GF_ISOM_SUBTYPE_MP3:
-			rtp_type = GF_RTP_PAYT_MPEG12_AUDIO;
-			/*use official RTP/AVP payload type*/
-			OfficialPayloadType = 14;
-			required_rate = 90000;
-			break;
-		}
-		break;
-
-	default:
-		GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, ("[RTP Packetizer] Unsupported stream type %x\n", streamType));
-		return NULL;
-	}
-
-	/*not supported*/
-	if (!rtp_type) return NULL;
-
-	/*override hinter type if requested and possible*/
-	if (has_mpeg4_mapping && (flags & GP_RTP_PCK_FORCE_MPEG4)) {
-		rtp_type = GF_RTP_PAYT_MPEG4;
-	}
-	/*use static payload ID if enabled*/
-	else if (OfficialPayloadType && (flags & GP_RTP_PCK_USE_STATIC_ID) ) {
-		PayloadType = OfficialPayloadType;
-	}
-
-	/*systems carousel: we need at least IDX and RAP signaling*/
-	if (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) {
-		flags |= GP_RTP_PCK_SIGNAL_RAP;
-	}
-
-	/*update flags in MultiSL*/
-	if (flags & GP_RTP_PCK_USE_MULTI) {
-		if (MinSize != MaxSize) flags |= GP_RTP_PCK_SIGNAL_SIZE;
-		if (!const_dur) flags |= GP_RTP_PCK_SIGNAL_TS;
-	}
-
-	/*default SL for RTP */
-	memset(&slc, 0, sizeof(GF_SLConfig));
-	slc.tag = GF_ODF_SLC_TAG;
-	slc.useTimestampsFlag = 1;
-	slc.timestampLength = 32;
-	slc.timestampResolution = timeScale;
-
-	/*override clockrate if set*/
-	if (required_rate) {
-		Double sc = required_rate;
-		sc /= slc.timestampResolution;
-		maxDTSDelta = (u32) (maxDTSDelta*sc);
-		slc.timestampResolution = required_rate;
-	}
-	/*switch to RTP TS*/
-	max_ptime = (u32) (max_ptime * slc.timestampResolution / 1000);
-
-	slc.AUSeqNumLength = au_sn_len;
-	slc.CUDuration = const_dur;
-
-	if (flags & GP_RTP_PCK_SIGNAL_RAP) {
-		slc.useRandomAccessPointFlag = 1;
-	} else {
-		slc.useRandomAccessPointFlag = 0;
-		slc.hasRandomAccessUnitsOnlyFlag = 1;
-	}
-
-	stream->packetizer = gf_rtp_builder_new(rtp_type, &slc, flags,
-	                                        stream,
-	                                        rtp_stream_on_new_packet, rtp_stream_on_packet_done,
-	                                        NULL, rtp_stream_on_data);
-
-	if (!stream->packetizer) {
-		GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, ("[RTP Packetizer] Failed to create packetizer\n"));
-		gf_free(stream);
-		return NULL;
-	}
-
-	gf_rtp_builder_init(stream->packetizer, PayloadType, MTU, max_ptime,
-	                    streamType, oti, PL_ID, MinSize, MaxSize, avgTS, maxDTSDelta, IV_length, KI_length, mpeg4mode);
-
-
-	if (force_dts_delta) stream->packetizer->slMap.DTSDeltaLength = force_dts_delta;
-
-	e = rtp_stream_init_channel(stream, MTU + 12, ip_dest, port, TTL, ifce_addr);
-	if (e) {
-		GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, ("[RTP Packetizer] Failed to create RTP channel - error %s\n", gf_error_to_string(e) ));
-		gf_free(stream);
-		return NULL;
-	}
-	stream->ts_scale = slc.timestampResolution;
-	stream->ts_scale /= timeScale;
-
-	stream->buffer_alloc = MTU+12;
-	stream->buffer = (char*)gf_malloc(sizeof(char) * stream->buffer_alloc);
-
-	return stream;
-}
-
-
-GF_EXPORT
-GF_RTPStreamer *gf_rtp_streamer_new(u32 streamType, u32 oti, u32 timeScale,
-                                    const char *ip_dest, u16 port, u32 MTU, u8 TTL, const char *ifce_addr,
-                                    u32 flags, char *dsi, u32 dsi_len)
-{
-	return gf_rtp_streamer_new_extended(streamType, oti, timeScale, ip_dest, port, MTU, TTL, ifce_addr, flags, dsi, dsi_len,
-
-	                                    96, 0, 0, GF_FALSE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
-
-}
-
-GF_EXPORT
-void gf_rtp_streamer_del(GF_RTPStreamer *streamer)
-{
-	if (streamer) {
-		if (streamer->channel) gf_rtp_del(streamer->channel);
-		if (streamer->packetizer) gf_rtp_builder_del(streamer->packetizer);
-		if (streamer->buffer) gf_free(streamer->buffer);
-		gf_free(streamer);
-	}
-}
-
-#if !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_STREAMING)
-
-void gf_media_format_ttxt_sdp(GP_RTPPacketizer *builder, char *payload_name, char *sdpLine, GF_ISOFile *file, u32 track)
-{
-	char buffer[2000];
-	u32 w, h, i, m_w, m_h;
-	s32 tx, ty;
-	s16 l;
-	sprintf(sdpLine, "a=fmtp:%d sver=60; ", builder->PayloadType);
-	gf_isom_get_track_layout_info(file, track, &w, &h, &tx, &ty, &l);
-	sprintf(buffer, "width=%d; height=%d; tx=%d; ty=%d; layer=%d; ", w, h, tx, ty, l);
-	strcat(sdpLine, buffer);
-	m_w = w;
-	m_h = h;
-	for (i=0; i<gf_isom_get_track_count(file); i++) {
-		switch (gf_isom_get_media_type(file, i+1)) {
-		case GF_ISOM_MEDIA_SCENE:
-		case GF_ISOM_MEDIA_VISUAL:
-			gf_isom_get_track_layout_info(file, i+1, &w, &h, &tx, &ty, &l);
-			if (w>m_w) m_w = w;
-			if (h>m_h) m_h = h;
-			break;
-		default:
-			break;
-		}
-	}
-	sprintf(buffer, "max-w=%d; max-h=%d", m_w, m_h);
-	strcat(sdpLine, buffer);
-
-	strcat(sdpLine, "; tx3g=");
-	for (i=0; i<gf_isom_get_sample_description_count(file, track); i++) {
-		char *tx3g;
-		u32 tx3g_len, len;
-		gf_isom_text_get_encoded_tx3g(file, track, i+1, GF_RTP_TX3G_SIDX_OFFSET, &tx3g, &tx3g_len);
-		len = gf_base64_encode(tx3g, tx3g_len, buffer, 2000);
-		gf_free(tx3g);
-		buffer[len] = 0;
-		if (i) strcat(sdpLine, ", ");
-		strcat(sdpLine, buffer);
-	}
-}
-
-#endif /*!defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_STREAMING)*/
-
-
-GF_EXPORT
-GF_Err gf_rtp_streamer_append_sdp_extended(GF_RTPStreamer *rtp, u16 ESID, char *dsi, u32 dsi_len, GF_ISOFile *isofile, u32 isotrack, char *KMS_URI, u32 width, u32 height, char **out_sdp_buffer)
-{
-	u32 size;
-	u16 port;
-	char mediaName[30], payloadName[30];
-	char sdp[20000], sdpLine[10000];
-
-	if (!out_sdp_buffer) return GF_BAD_PARAM;
-
-	gf_rtp_builder_get_payload_name(rtp->packetizer, payloadName, mediaName);
-	gf_rtp_get_ports(rtp->channel, &port, NULL);
-
-	sprintf(sdp, "m=%s %d RTP/%s %d\n", mediaName, port, rtp->packetizer->slMap.IV_length ? "SAVP" : "AVP", rtp->packetizer->PayloadType);
-	sprintf(sdpLine, "a=rtpmap:%d %s/%d\n", rtp->packetizer->PayloadType, payloadName, rtp->packetizer->sl_config.timestampResolution);
-	strcat(sdp, sdpLine);
-	if (ESID && (rtp->packetizer->rtp_payt != GF_RTP_PAYT_3GPP_DIMS)) {
-		sprintf(sdpLine, "a=mpeg4-esid:%d\n", ESID);
-		strcat(sdp, sdpLine);
-	}
-
-	if (width && height) {
-		if (rtp->packetizer->rtp_payt == GF_RTP_PAYT_H263) {
-			sprintf(sdpLine, "a=cliprect:0,0,%d,%d\n", height, width);
-			strcat(sdp, sdpLine);
-		}
-		/*extensions for some mobile phones*/
-		sprintf(sdpLine, "a=framesize:%d %d-%d\n", rtp->packetizer->PayloadType, width, height);
-		strcat(sdp, sdpLine);
-	}
-
-	strcpy(sdpLine, "");
-
-	/*AMR*/
-	if ((rtp->packetizer->rtp_payt == GF_RTP_PAYT_AMR) || (rtp->packetizer->rtp_payt == GF_RTP_PAYT_AMR_WB)) {
-		sprintf(sdpLine, "a=fmtp:%d octet-align=1\n", rtp->packetizer->PayloadType);
-	}
-	/*Text*/
-	else if (rtp->packetizer->rtp_payt == GF_RTP_PAYT_3GPP_TEXT) {
-		gf_media_format_ttxt_sdp(rtp->packetizer, payloadName, sdpLine, isofile, isotrack);
-		strcat(sdpLine, "\n");
-	}
-	/*EVRC/SMV in non header-free mode*/
-	else if ((rtp->packetizer->rtp_payt == GF_RTP_PAYT_EVRC_SMV) && (rtp->packetizer->auh_size>1)) {
-		sprintf(sdpLine, "a=fmtp:%d maxptime=%d\n", rtp->packetizer->PayloadType, rtp->packetizer->auh_size*20);
-	}
-	/*H264/AVC*/
-	else if ((rtp->packetizer->rtp_payt == GF_RTP_PAYT_H264_AVC) || (rtp->packetizer->rtp_payt == GF_RTP_PAYT_H264_SVC)) {
-		GF_AVCConfig *avcc = dsi ? gf_odf_avc_cfg_read(dsi, dsi_len) : NULL;
-
-		if (avcc) {
-			sprintf(sdpLine, "a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1", rtp->packetizer->PayloadType, avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);
-			if (gf_list_count(avcc->pictureParameterSets) || gf_list_count(avcc->sequenceParameterSets)) {
-				u32 i, count, b64s;
-				char b64[200];
-				strcat(sdpLine, "; sprop-parameter-sets=");
-				count = gf_list_count(avcc->sequenceParameterSets);
-				for (i=0; i<count; i++) {
-					GF_AVCConfigSlot *sl = (GF_AVCConfigSlot *)gf_list_get(avcc->sequenceParameterSets, i);
-					b64s = gf_base64_encode(sl->data, sl->size, b64, 200);
-					b64[b64s]=0;
-					strcat(sdpLine, b64);
-					if (i+1<count) strcat(sdpLine, ",");
-				}
-				if (i) strcat(sdpLine, ",");
-				count = gf_list_count(avcc->pictureParameterSets);
-				for (i=0; i<count; i++) {
-					GF_AVCConfigSlot *sl = (GF_AVCConfigSlot *)gf_list_get(avcc->pictureParameterSets, i);
-					b64s = gf_base64_encode(sl->data, sl->size, b64, 200);
-					b64[b64s]=0;
-					strcat(sdpLine, b64);
-					if (i+1<count) strcat(sdpLine, ",");
-				}
-			}
-			gf_odf_avc_cfg_del(avcc);
-			strcat(sdpLine, "\n");
-		}
-	}
-	else if ((rtp->packetizer->rtp_payt == GF_RTP_PAYT_HEVC) || (rtp->packetizer->rtp_payt == GF_RTP_PAYT_SHVC)) {
-#ifndef GPAC_DISABLE_HEVC
-		GF_HEVCConfig *hevcc = dsi ? gf_odf_hevc_cfg_read(dsi, dsi_len, GF_FALSE) : NULL;
-		if (hevcc) {
-			u32 count, i, j, b64s;
-			char b64[200];
-			sprintf(sdpLine, "a=fmtp:%d", rtp->packetizer->PayloadType);
-			count = gf_list_count(hevcc->param_array);
-			for (i = 0; i < count; i++) {
-				GF_HEVCParamArray *ar = (GF_HEVCParamArray *)gf_list_get(hevcc->param_array, i);
-				if (ar->type==GF_HEVC_NALU_SEQ_PARAM) {
-					strcat(sdpLine, "; sprop-sps=");
-				} else if (ar->type==GF_HEVC_NALU_PIC_PARAM) {
-					strcat(sdpLine, "; sprop-pps=");
-				} else if (ar->type==GF_HEVC_NALU_VID_PARAM) {
-					strcat(sdpLine, "; sprop-vps=");
-				}
-				for (j = 0; j < gf_list_count(ar->nalus); j++) {
-					GF_AVCConfigSlot *sl = (GF_AVCConfigSlot *)gf_list_get(ar->nalus, j);
-					b64s = gf_base64_encode(sl->data, sl->size, b64, 200);
-					b64[b64s]=0;
-					if (j) strcat(sdpLine, ", ");
-					strcat(sdpLine, b64);
-				}
-			}
-			gf_odf_hevc_cfg_del(hevcc);
-			strcat(sdpLine, "\n");
-		}
-#endif
-	}
-	/*MPEG-4 decoder config*/
-	else if (rtp->packetizer->rtp_payt==GF_RTP_PAYT_MPEG4) {
-		gf_rtp_builder_format_sdp(rtp->packetizer, payloadName, sdpLine, dsi, dsi_len);
-		strcat(sdpLine, "\n");
-
-		if (rtp->packetizer->slMap.IV_length && KMS_URI) {
-			if (!strnicmp(KMS_URI, "(key)", 5) || !strnicmp(KMS_URI, "(ipmp)", 6) || !strnicmp(KMS_URI, "(uri)", 5)) {
-				strcat(sdpLine, "; ISMACrypKey=");
-			} else {
-				strcat(sdpLine, "; ISMACrypKey=(uri)");
-			}
-			strcat(sdpLine, KMS_URI);
-			strcat(sdpLine, "\n");
-		}
-	}
-	/*DIMS decoder config*/
-	else if (rtp->packetizer->rtp_payt==GF_RTP_PAYT_3GPP_DIMS) {
-		sprintf(sdpLine, "a=fmtp:%d Version-profile=%d", rtp->packetizer->PayloadType, 10);
-		if (rtp->packetizer->flags & GP_RTP_DIMS_COMPRESSED) {
-			strcat(sdpLine, ";content-coding=deflate");
-		}
-		strcat(sdpLine, "\n");
-	}
-	/*MPEG-4 Audio LATM*/
-	else if (rtp->packetizer->rtp_payt==GF_RTP_PAYT_LATM) {
-		GF_BitStream *bs;
-		char *config_bytes;
-		u32 config_size;
-
-		/* form config string */
-		bs = gf_bs_new(NULL, 32, GF_BITSTREAM_WRITE);
-		gf_bs_write_int(bs, 0, 1); /* AudioMuxVersion */
-		gf_bs_write_int(bs, 1, 1); /* all streams same time */
-		gf_bs_write_int(bs, 0, 6); /* numSubFrames */
-		gf_bs_write_int(bs, 0, 4); /* numPrograms */
-		gf_bs_write_int(bs, 0, 3); /* numLayer */
-
-		/* audio-specific config  - PacketVideo patch: don't signal SBR and PS stuff, not allowed in LATM with audioMuxVersion=0*/
-		if (dsi) gf_bs_write_data(bs, dsi, MIN(dsi_len, 2) );
-
-		/* other data */
-		gf_bs_write_int(bs, 0, 3); /* frameLengthType */
-		gf_bs_write_int(bs, 0xff, 8); /* latmBufferFullness */
-		gf_bs_write_int(bs, 0, 1); /* otherDataPresent */
-		gf_bs_write_int(bs, 0, 1); /* crcCheckPresent */
-		gf_bs_get_content(bs, &config_bytes, &config_size);
-		gf_bs_del(bs);
-
-		gf_rtp_builder_format_sdp(rtp->packetizer, payloadName, sdpLine, config_bytes, config_size);
-		gf_free(config_bytes);
-		strcat(sdpLine, "\n");
-	}
-
-	strcat(sdp, sdpLine);
-
-	size = (u32) strlen(sdp) + (*out_sdp_buffer ? (u32) strlen(*out_sdp_buffer) : 0) + 1;
-	if ( !*out_sdp_buffer) {
-		*out_sdp_buffer = (char*)gf_malloc(sizeof(char)*size);
-		if (! *out_sdp_buffer) return GF_OUT_OF_MEM;
-		strcpy(*out_sdp_buffer, sdp);
-	} else {
-		*out_sdp_buffer = (char*)gf_realloc(*out_sdp_buffer, sizeof(char)*size);
-		if (! *out_sdp_buffer) return GF_OUT_OF_MEM;
-		strcat(*out_sdp_buffer, sdp);
-	}
-	return GF_OK;
-}
-
-GF_EXPORT
-GF_Err gf_rtp_streamer_append_sdp_decoding_dependency(GF_ISOFile *isofile, u32 isotrack, u8 *payload_type, char **out_sdp_buffer)
-{
-	u32 size, i, ref_track;
-	s32 count;
-	char sdp[20000], sdpLine[10000];
-
-	sprintf(sdp, "a=mid:L%d\n", isotrack);
-
-	count = gf_isom_get_reference_count(isofile, isotrack, GF_ISOM_REF_SCAL);
-	if (count > 0)
-	{
-		sprintf(sdpLine, "a=depend:%d lay", payload_type[isotrack-1]);
-		strcat(sdp, sdpLine);
-		for (i = 0; i < (u32) count; i++)
-		{
-			gf_isom_get_reference(isofile, isotrack, GF_ISOM_REF_SCAL, i+1, &ref_track);
-			sprintf(sdpLine, " L%d:%d", ref_track, payload_type[ref_track-1]);
-			strcat(sdp, sdpLine);
-		}
-		strcat(sdp, "\n");
-	}
-
-	size = (u32) strlen(sdp) + (*out_sdp_buffer ? (u32) strlen(*out_sdp_buffer) : 0) + 1;
-	if ( !*out_sdp_buffer) {
-		*out_sdp_buffer = (char*)gf_malloc(sizeof(char)*size);
-		if (! *out_sdp_buffer) return GF_OUT_OF_MEM;
-		strcpy(*out_sdp_buffer, sdp);
-	} else {
-		*out_sdp_buffer = (char*)gf_realloc(*out_sdp_buffer, sizeof(char)*size);
-		if (! *out_sdp_buffer) return GF_OUT_OF_MEM;
-		strcat(*out_sdp_buffer, sdp);
-	}
-	return GF_OK;
-}
-
-GF_EXPORT
-char *gf_rtp_streamer_format_sdp_header(char *app_name, char *ip_dest, char *session_name, char *iod64)
-{
-	u64 size;
-	char *sdp, *tmp_fn = NULL;
-	FILE *tmp = gf_temp_file_new(&tmp_fn);
-	if (!tmp) return NULL;
-
-	/* write SDP header*/
-	fprintf(tmp, "v=0\n");
-	fprintf(tmp, "o=%s 3326096807 1117107880000 IN IP%d %s\n", app_name, gf_net_is_ipv6(ip_dest) ? 6 : 4, ip_dest);
-	fprintf(tmp, "s=%s\n", (session_name ? session_name : "GPAC Scene Streaming Session"));
-	fprintf(tmp, "c=IN IP%d %s\n", gf_net_is_ipv6(ip_dest) ? 6 : 4, ip_dest);
-	fprintf(tmp, "t=0 0\n");
-
-	if (iod64) fprintf(tmp, "a=mpeg4-iod:\"data:application/mpeg4-iod;base64,%s\"\n", iod64);
-
-	gf_fseek(tmp, 0, SEEK_END);
-	size = gf_ftell(tmp);
-	gf_fseek(tmp, 0, SEEK_SET);
-	sdp = (char*)gf_malloc(sizeof(char) * (size_t)(size+1));
-	size = fread(sdp, 1, (size_t)size, tmp);
-	sdp[size] = 0;
-	gf_fclose(tmp);
-	gf_delete_file(tmp_fn);
-	gf_free(tmp_fn);
-	return sdp;
-}
-
-GF_EXPORT
-GF_Err gf_rtp_streamer_append_sdp(GF_RTPStreamer *rtp, u16 ESID, char *dsi, u32 dsi_len, char *KMS_URI, char **out_sdp_buffer)
-{
-	return gf_rtp_streamer_append_sdp_extended(rtp, ESID, dsi, dsi_len, NULL, 0, KMS_URI, 0, 0, out_sdp_buffer);
-}
-
-GF_Err gf_rtp_streamer_send_data(GF_RTPStreamer *rtp, char *data, u32 size, u32 fullsize, u64 cts, u64 dts, Bool is_rap, Bool au_start, Bool au_end, u32 au_sn, u32 sampleDuration, u32 sampleDescIndex)
-{
-	rtp->packetizer->sl_header.compositionTimeStamp = (u64) (cts*rtp->ts_scale);
-	rtp->packetizer->sl_header.decodingTimeStamp = (u64) (dts*rtp->ts_scale);
-	rtp->packetizer->sl_header.randomAccessPointFlag = is_rap;
-	rtp->packetizer->sl_header.accessUnitStartFlag = au_start;
-	rtp->packetizer->sl_header.accessUnitEndFlag = au_end;
-	rtp->packetizer->sl_header.randomAccessPointFlag = is_rap;
-	rtp->packetizer->sl_header.AU_sequenceNumber = au_sn;
-	sampleDuration = (u32) (sampleDuration * rtp->ts_scale);
-
-	return gf_rtp_builder_process(rtp->packetizer, data, size, (u8) au_end, fullsize, sampleDuration, sampleDescIndex);
-}
-
-GF_Err gf_rtp_streamer_send_au(GF_RTPStreamer *rtp, char *data, u32 size, u64 cts, u64 dts, Bool is_rap)
-{
-	return gf_rtp_streamer_send_data(rtp, data, size, size, cts, dts, is_rap, GF_TRUE, GF_TRUE, 0, 0, 0);
-}
-
-GF_EXPORT
-GF_Err gf_rtp_streamer_send_au_with_sn(GF_RTPStreamer *rtp, char *data, u32 size, u64 cts, u64 dts, Bool is_rap, u32 inc_au_sn)
-{
-	if (inc_au_sn) rtp->packetizer->sl_header.AU_sequenceNumber += inc_au_sn;
-	return gf_rtp_streamer_send_data(rtp, data, size, size, cts, dts, is_rap, GF_TRUE, GF_TRUE, rtp->packetizer->sl_header.AU_sequenceNumber, 0, 0);
-}
-
-GF_EXPORT
-void gf_rtp_streamer_disable_auto_rtcp(GF_RTPStreamer *streamer)
-{
-	streamer->channel->no_auto_rtcp = GF_TRUE;
-}
-
-GF_EXPORT
-GF_Err gf_rtp_streamer_send_rtcp(GF_RTPStreamer *streamer, Bool force_ts, u32 rtp_ts, u32 force_ntp_type, u32 ntp_sec, u32 ntp_frac)
-{
-	if (force_ts) streamer->channel->last_pck_ts = rtp_ts;
-	streamer->channel->forced_ntp_sec = force_ntp_type ? ntp_sec : 0;
-	streamer->channel->forced_ntp_frac = force_ntp_type ? ntp_frac : 0;
-	if (force_ntp_type==2)
-		streamer->channel->next_report_time = 0;
-	return gf_rtp_send_rtcp_report(streamer->channel, NULL, NULL);
-}
-
-GF_EXPORT
-u8 gf_rtp_streamer_get_payload_type(GF_RTPStreamer *streamer)
-{
-	return streamer->packetizer->PayloadType;
-}
-
-#endif /*GPAC_DISABLE_STREAMING && GPAC_DISABLE_ISOM*/
-
diff --git a/src/ietfPrtsp_command.c b/src/ietfPrtsp_command.c
deleted file mode 100644
index 7d673833d..000000000
--- a/src/ietfPrtsp_command.c
+++ /dev/null
@@ -1,571 +0,0 @@
-/*
- *			GPAC - Multimedia Framework C SDK
- *
- *			Authors: Jean Le Feuvre
- *			Copyright (c) Telecom ParisTech 2000-2012
- *					All rights reserved
- *
- *  This file is part of GPAC / IETF RTP/RTSP/SDP sub-project
- *
- *  GPAC is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU Lesser General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  GPAC is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-
-#include <gpac/internal/ietf_dev.h>
-
-#ifndef GPAC_DISABLE_STREAMING
-
-#include <gpac/token.h>
-
-GF_EXPORT
-GF_RTSPCommand *gf_rtsp_command_new()
-{
-	GF_RTSPCommand *tmp;
-	GF_SAFEALLOC(tmp, GF_RTSPCommand);
-	tmp->Xtensions = gf_list_new();
-	tmp->Transports = gf_list_new();
-	return tmp;
-}
-
-
-#define COM_FREE_CLEAN(hdr)		if (com->hdr) gf_free(com->hdr);	\
-								com->hdr = NULL;
-
-GF_EXPORT
-void gf_rtsp_command_reset(GF_RTSPCommand *com)
-{
-	GF_RTSPTransport *trans;
-	GF_X_Attribute *att;
-	if (!com) return;
-
-	//free all headers
-	COM_FREE_CLEAN(Accept);
-	COM_FREE_CLEAN(Accept_Encoding);
-	COM_FREE_CLEAN(Accept_Language);
-	COM_FREE_CLEAN(Authorization);
-	COM_FREE_CLEAN(Cache_Control);
-	COM_FREE_CLEAN(Conference);
-	COM_FREE_CLEAN(Connection);
-	COM_FREE_CLEAN(From);
-	COM_FREE_CLEAN(Proxy_Authorization);
-	COM_FREE_CLEAN(Proxy_Require);
-	COM_FREE_CLEAN(Referer);
-	COM_FREE_CLEAN(Session);
-	COM_FREE_CLEAN(User_Agent);
-	COM_FREE_CLEAN(body);
-	COM_FREE_CLEAN(service_name);
-	COM_FREE_CLEAN(ControlString);
-	COM_FREE_CLEAN(method);
-
-	//this is for server only, set to OK by default
-	com->StatusCode = NC_RTSP_OK;
-
-
-	com->user_data = NULL;
-
-	com->Bandwidth = com->Blocksize = com->Content_Length = com->CSeq = 0;
-	com->Scale = com->Speed = 0.0;
-	if (com->Range) gf_free(com->Range);
-	com->Range = NULL;
-
-	while (gf_list_count(com->Transports)) {
-		trans = (GF_RTSPTransport *) gf_list_get(com->Transports, 0);
-		gf_list_rem(com->Transports, 0);
-		gf_rtsp_transport_del(trans);
-	}
-	while (gf_list_count(com->Xtensions)) {
-		att = (GF_X_Attribute*)gf_list_get(com->Xtensions, 0);
-		gf_list_rem(com->Xtensions, 0);
-		gf_free(att->Name);
-		gf_free(att->Value);
-		gf_free(att);
-	}
-}
-
-GF_EXPORT
-void gf_rtsp_command_del(GF_RTSPCommand *com)
-{
-	if (!com) return;
-	gf_rtsp_command_reset(com);
-	gf_list_del(com->Xtensions);
-	gf_list_del(com->Transports);
-	gf_free(com);
-}
-
-
-GF_Err RTSP_WriteCommand(GF_RTSPSession *sess, GF_RTSPCommand *com, unsigned char *req_buffer,
-                         unsigned char **out_buffer, u32 *out_size)
-{
-	u32 i, cur_pos, size, count;
-	char *buffer, temp[50];
-	GF_RTSPTransport *trans;
-	GF_X_Attribute *att;
-
-	*out_buffer = NULL;
-
-	size = RTSP_WRITE_STEPALLOC;
-	buffer = (char *) gf_malloc(size);
-	cur_pos = 0;
-
-	//request
-	RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, req_buffer);
-
-	//then all headers
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Accept", com->Accept);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Accept-Encoding", com->Accept_Encoding);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Accept-Language", com->Accept_Language);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Authorization", com->Authorization);
-	if (com->Bandwidth) {
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "Bandwidth: ");
-		RTSP_WRITE_INT(buffer, size, cur_pos, com->Bandwidth, 0);
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-	}
-	if (com->Blocksize) {
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "Blocksize: ");
-		RTSP_WRITE_INT(buffer, size, cur_pos, com->Blocksize, 0);
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-	}
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Cache-Control", com->Cache_Control);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Conference", com->Conference);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Connection", com->Connection);
-	//if we have a body write the content length
-	if (com->body) {
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "Content-Length: ");
-		RTSP_WRITE_INT(buffer, size, cur_pos, (u32) strlen(com->body), 0);
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-	}
-	//write the CSeq - use the SESSION CSeq
-	RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "CSeq: ");
-	RTSP_WRITE_INT(buffer, size, cur_pos, sess->CSeq, 0);
-	RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "From", com->From);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Proxy-Authorization", com->Proxy_Authorization);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Proxy-Require", com->Proxy_Require);
-
-	//Range, only NPT
-	if (com->Range && !com->Range->UseSMPTE) {
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "Range: npt=");
-		RTSP_WRITE_FLOAT_WITHOUT_CHECK(buffer, size, cur_pos, com->Range->start);
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "-");
-		if (com->Range->end > com->Range->start) {
-			RTSP_WRITE_FLOAT_WITHOUT_CHECK(buffer, size, cur_pos, com->Range->end);
-		}
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-	}
-
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Referer", com->Referer);
-	if (com->Scale != 0.0) {
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "Scale: ");
-		RTSP_WRITE_FLOAT_WITHOUT_CHECK(buffer, size, cur_pos, com->Scale);
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-	}
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Session", com->Session);
-	if (com->Speed != 0.0) {
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "Speed: ");
-		RTSP_WRITE_FLOAT_WITHOUT_CHECK(buffer, size, cur_pos, com->Speed);
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-	}
-
-	//transport info
-	count = gf_list_count(com->Transports);
-	if (count) {
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "Transport: ");
-		for (i=0; i<count; i++) {
-			//line separator for headers
-			if (i) RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n ,");
-			trans = (GF_RTSPTransport *) gf_list_get(com->Transports, i);
-
-			//then write the structure
-			RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, trans->Profile);
-			RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, (trans->IsUnicast ? ";unicast" : ";multicast"));
-			if (trans->destination) {
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";destination=");
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, trans->destination);
-			}
-			if (trans->source) {
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";source=");
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, trans->source);
-			}
-			if (trans->IsRecord) {
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";mode=RECORD");
-				if (trans->Append) RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";append");
-			}
-			if (trans->IsInterleaved) {
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";interleaved=");
-				RTSP_WRITE_INT(buffer, size, cur_pos, trans->rtpID, 0);
-				if (trans->rtcpID != trans->rtpID) {
-					RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "-");
-					RTSP_WRITE_INT(buffer, size, cur_pos, trans->rtcpID, 0);
-				}
-			}
-			if (trans->port_first) {
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, (trans->IsUnicast ? ";server_port=" : ";port="));
-				RTSP_WRITE_INT(buffer, size, cur_pos, trans->port_first, 0);
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "-");
-				RTSP_WRITE_INT(buffer, size, cur_pos, trans->port_last, 0);
-			}
-			if (/*trans->IsUnicast && */trans->client_port_first) {
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";client_port=");
-				RTSP_WRITE_INT(buffer, size, cur_pos, trans->client_port_first, 0);
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "-");
-				RTSP_WRITE_INT(buffer, size, cur_pos, trans->client_port_last, 0);
-			}
-			//multicast specific
-			if (!trans->IsUnicast) {
-				if (trans->MulticastLayers) {
-					RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";layers=");
-					RTSP_WRITE_INT(buffer, size, cur_pos, trans->MulticastLayers, 0);
-				}
-				if (trans->TTL) {
-					RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";ttl=");
-					RTSP_WRITE_INT(buffer, size, cur_pos, trans->TTL, 0);
-				}
-			}
-			if (trans->SSRC) {
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";ssrc=");
-				RTSP_WRITE_INT(buffer, size, cur_pos, trans->SSRC, 0);
-			}
-		}
-		//done with transport
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-	}
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "User-Agent", com->User_Agent);
-
-	//eXtensions
-	count = gf_list_count(com->Xtensions);
-	for (i=0; i<count; i++) {
-		att = (GF_X_Attribute *) gf_list_get(com->Xtensions, i);
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "x-");
-		RTSP_WRITE_HEADER(buffer, size, cur_pos, att->Name, att->Value);
-	}
-
-	//the end of header
-	RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-	//then body
-	RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, com->body);
-	//the end of message ? to check, should not be needed...
-//	RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-
-	*out_buffer = (unsigned char *)buffer;
-	*out_size = (u32) strlen(buffer);
-	return GF_OK;
-}
-
-
-//format a DESCRIBE, SETUP, PLAY or PAUSE on a session
-//YOUR COMMAND MUST BE FORMATTED ACCORDINGLY
-//sCtrl contains a control string if needed, formating the REQUEST as server_url/service_name/sCtrl
-GF_EXPORT
-GF_Err gf_rtsp_send_command(GF_RTSPSession *sess, GF_RTSPCommand *com)
-{
-	GF_Err e;
-	char *sCtrl;
-	const char *rad;
-	u32 size;
-	char buffer[1024], *result, *body;
-
-	if (!com || !com->method) return GF_BAD_PARAM;
-
-	sCtrl = com->ControlString;
-
-	//NB: OPTIONS is not sent this way
-	if (strcmp(com->method, GF_RTSP_DESCRIBE)
-	        && strcmp(com->method, GF_RTSP_ANNOUNCE)
-	        && strcmp(com->method, GF_RTSP_GET_PARAMETER)
-	        && strcmp(com->method, GF_RTSP_SET_PARAMETER)
-	        && strcmp(com->method, GF_RTSP_SETUP)
-	        && strcmp(com->method, GF_RTSP_PLAY)
-	        && strcmp(com->method, GF_RTSP_PAUSE)
-	        && strcmp(com->method, GF_RTSP_RECORD)
-	        && strcmp(com->method, GF_RTSP_REDIRECTE)
-	        && strcmp(com->method, GF_RTSP_TEARDOWN)
-	        && strcmp(com->method, GF_RTSP_OPTIONS)
-
-	   ) return GF_BAD_PARAM;
-
-	//check the state machine
-	if (strcmp(com->method, GF_RTSP_PLAY)
-	        && strcmp(com->method, GF_RTSP_PAUSE)
-	        && strcmp(com->method, GF_RTSP_RECORD)
-	        && sess->RTSP_State != GF_RTSP_STATE_INIT)
-		return GF_SERVICE_ERROR;
-
-	//aggregation is ONLY for the same request - unclear in RFC2326 ...
-	//it is often mentioned "queued requests" at the server, like 3 PLAYS
-	//and a PAUSE ....
-
-	/*
-	else if (sess->RTSP_State == GF_RTSP_STATE_WAIT_FOR_CONTROL
-		&& strcmp(com->method, sess->RTSPLastRequest))
-		&& strcmp(com->method, GF_RTSP_OPTIONS))
-
-		return GF_BAD_PARAM;
-	*/
-
-	//OPTIONS must have a parameter string
-	if (!strcmp(com->method, GF_RTSP_OPTIONS) && !sCtrl) return GF_BAD_PARAM;
-
-
-	//update sequence number
-	sess->CSeq += 1;
-	sess->NbPending += 1;
-
-	if (!strcmp(com->method, GF_RTSP_OPTIONS)) {
-		sprintf(buffer, "OPTIONS %s %s\r\n", sCtrl, GF_RTSP_VERSION);
-	} else {
-		rad = (sess->ConnectionType == GF_SOCK_TYPE_TCP) ? "rtsp" : "rtspu";
-		if (sCtrl) {
-			//if both server and service names are included in the control, just
-			//use the control
-			if (strstr(sCtrl, sess->Server) && strstr(sCtrl, sess->Service)) {
-				sprintf(buffer, "%s %s %s\r\n", com->method, sCtrl, GF_RTSP_VERSION);
-			}
-			//if service is specified in ctrl, do not rewrite it
-			else if (strstr(sCtrl, sess->Service)) {
-				sprintf(buffer, "%s %s://%s:%d/%s %s\r\n", com->method, rad, sess->Server, sess->Port, sCtrl, GF_RTSP_VERSION);
-			}
-			else if (!strnicmp(sCtrl, "rtsp", 4)) {
-				sprintf(buffer, "%s %s %s\r\n", com->method, sCtrl, GF_RTSP_VERSION);
-			}
-			//otherwise rewrite full URL
-			else {
-				sprintf(buffer, "%s %s://%s/%s/%s %s\r\n", com->method, rad, sess->Server, sess->Service, sCtrl, GF_RTSP_VERSION);
-//				sprintf(buffer, "%s %s://%s:%d/%s/%s %s\r\n", com->method, rad, sess->Server, sess->Port, sess->Service, sCtrl, GF_RTSP_VERSION);
-			}
-		} else {
-			sprintf(buffer, "%s %s://%s:%d/%s %s\r\n", com->method, rad, sess->Server, sess->Port, sess->Service, GF_RTSP_VERSION);
-		}
-	}
-
-	//Body on ANNOUNCE, GET_PARAMETER, SET_PARAMETER ONLY
-	body = NULL;
-	if (strcmp(com->method, GF_RTSP_ANNOUNCE)
-	        && strcmp(com->method, GF_RTSP_GET_PARAMETER)
-	        && strcmp(com->method, GF_RTSP_SET_PARAMETER)
-	   ) {
-		//this is an error, but don't say anything
-		if (com->body) {
-			body = com->body;
-			com->body = NULL;
-		}
-	}
-
-	result = NULL;
-	e = RTSP_WriteCommand(sess, com, (unsigned char *)buffer, (unsigned char **) &result, &size);
-	//restore body if needed
-	if (body) com->body = body;
-	if (e) goto exit;
-
-
-	GF_LOG(GF_LOG_INFO, GF_LOG_RTP, ("[RTSP] Sending Command:\n%s\n", result));
-
-	//send buffer
-	e = gf_rtsp_send_data(sess, result, size);
-	if (e) goto exit;
-
-
-	//update our state
-	if (!strcmp(com->method, GF_RTSP_RECORD)) sess->RTSP_State = GF_RTSP_STATE_WAIT_FOR_CONTROL;
-	else if (!strcmp(com->method, GF_RTSP_PLAY)) sess->RTSP_State = GF_RTSP_STATE_WAIT_FOR_CONTROL;
-	else if (!strcmp(com->method, GF_RTSP_PAUSE)) sess->RTSP_State = GF_RTSP_STATE_WAIT_FOR_CONTROL;
-	else sess->RTSP_State = GF_RTSP_STATE_WAITING;
-	//teardown invalidates the session most of the time, so we force the user to wait for the reply
-	//as the reply may indicate a connection-closed
-	strcpy(sess->RTSPLastRequest, com->method);
-
-exit:
-	if (result) gf_free(result);
-	return e;
-}
-
-
-void gf_rtsp_set_command_value(GF_RTSPCommand *com, char *Header, char *Value)
-{
-	char LineBuffer[400];
-	s32 LinePos;
-	GF_RTSPTransport *trans;
-	GF_X_Attribute *x_Att;
-
-	if (!stricmp(Header, "Accept")) com->Accept = gf_strdup(Value);
-	else if (!stricmp(Header, "Accept-Encoding")) com->Accept_Encoding = gf_strdup(Value);
-	else if (!stricmp(Header, "Accept-Language")) com->Accept_Language = gf_strdup(Value);
-	else if (!stricmp(Header, "Authorization")) com->Authorization = gf_strdup(Value);
-	else if (!stricmp(Header, "Bandwidth")) sscanf(Value, "%u", &com->Bandwidth);
-	else if (!stricmp(Header, "Blocksize")) sscanf(Value, "%u", &com->Blocksize);
-	else if (!stricmp(Header, "Cache-Control")) com->Cache_Control = gf_strdup(Value);
-	else if (!stricmp(Header, "Conference")) com->Conference = gf_strdup(Value);
-	else if (!stricmp(Header, "Connection")) com->Connection = gf_strdup(Value);
-	else if (!stricmp(Header, "Content-Length")) sscanf(Value, "%u", &com->Content_Length);
-	else if (!stricmp(Header, "CSeq")) sscanf(Value, "%u", &com->CSeq);
-	else if (!stricmp(Header, "From")) com->From = gf_strdup(Value);
-	else if (!stricmp(Header, "Proxy_Authorization")) com->Proxy_Authorization = gf_strdup(Value);
-	else if (!stricmp(Header, "Proxy_Require")) com->Proxy_Require = gf_strdup(Value);
-	else if (!stricmp(Header, "Range")) com->Range = gf_rtsp_range_parse(Value);
-	else if (!stricmp(Header, "Referer")) com->Referer = gf_strdup(Value);
-	else if (!stricmp(Header, "Scale")) sscanf(Value, "%lf", &com->Scale);
-	else if (!stricmp(Header, "Session")) com->Session = gf_strdup(Value);
-	else if (!stricmp(Header, "Speed")) sscanf(Value, "%lf", &com->Speed);
-	else if (!stricmp(Header, "User_Agent")) com->User_Agent = gf_strdup(Value);
-	//Transports
-	else if (!stricmp(Header, "Transport")) {
-		LinePos = 0;
-		while (1) {
-			LinePos = gf_token_get(Value, LinePos, "\r\n", LineBuffer, 400);
-			if (LinePos <= 0) return;
-			trans = gf_rtsp_transport_parse(Value);
-			if (trans) gf_list_add(com->Transports, trans);
-		}
-	}
-	//eXtensions attributes
-	else if (!strnicmp(Header, "x-", 2)) {
-		x_Att = (GF_X_Attribute*)gf_malloc(sizeof(GF_X_Attribute));
-		x_Att->Name = gf_strdup(Header+2);
-		x_Att->Value = NULL;
-		if (Value && strlen(Value)) x_Att->Value = gf_strdup(Value);
-		gf_list_add(com->Xtensions, x_Att);
-	}
-	//the rest is ignored
-}
-
-GF_Err RTSP_ParseCommandHeader(GF_RTSPSession *sess, GF_RTSPCommand *com, u32 BodyStart)
-{
-	char LineBuffer[1024];
-	char ValBuf[1024];
-	char *buffer;
-	s32 Pos, ret;
-	u32 Size;
-
-	Size = sess->CurrentSize - sess->CurrentPos;
-	buffer = sess->TCPBuffer + sess->CurrentPos;
-
-	//by default the command is wrong ;)
-	com->StatusCode = NC_RTSP_Bad_Request;
-
-	//parse first line
-	ret = gf_token_get_line(buffer, 0, Size, LineBuffer, 1024);
-	if (ret < 0) return GF_REMOTE_SERVICE_ERROR;
-
-	//method
-	Pos = gf_token_get(LineBuffer, 0, " \t\r\n", ValBuf, 1024);
-	if (Pos <= 0) return GF_OK;
-	com->method = gf_strdup((const char *) ValBuf);
-
-	//URL
-	Pos = gf_token_get(LineBuffer, Pos, " \t\r\n", ValBuf, 1024);
-	if (Pos <= 0) return GF_OK;
-	com->service_name = gf_strdup(ValBuf);
-
-	//RTSP version
-	Pos = gf_token_get(LineBuffer, Pos, "\t\r\n", ValBuf, 1024);
-	if (Pos <= 0) return GF_OK;
-	if (strcmp(ValBuf, GF_RTSP_VERSION)) {
-		com->StatusCode = NC_RTSP_RTSP_Version_Not_Supported;
-		return GF_OK;
-	}
-
-	com->StatusCode = NC_RTSP_OK;
-
-	return gf_rtsp_parse_header(buffer + ret, Size - ret, BodyStart, com, NULL);
-}
-
-
-GF_EXPORT
-GF_Err gf_rtsp_get_command(GF_RTSPSession *sess, GF_RTSPCommand *com)
-{
-	GF_Err e;
-	u32 BodyStart, size;
-	if (!sess || !com) return GF_BAD_PARAM;
-
-	//reset the command
-	gf_rtsp_command_reset(com);
-	//if no connection, we have sent a "Connection: Close"
-	if (!sess->connection) return GF_IP_CONNECTION_CLOSED;
-
-	//lock
-	gf_mx_p(sess->mx);
-
-	//fill TCP buffer
-	e = gf_rtsp_fill_buffer(sess);
-	if (e) goto exit;
-	//this is upcoming, interleaved data
-	if (strncmp(sess->TCPBuffer+sess->CurrentPos, "RTSP", 4)) {
-		e = GF_IP_NETWORK_EMPTY;
-		goto exit;
-	}
-	e = gf_rtsp_read_reply(sess);
-	if (e) goto exit;
-
-	gf_rtsp_get_body_info(sess, &BodyStart, &size);
-	e = RTSP_ParseCommandHeader(sess, com, BodyStart);
-	//before returning an error we MUST reset the TCP buffer
-
-	//copy the body if any
-	if (!e && com->Content_Length) {
-		com->body = (char *) gf_malloc(sizeof(char) * (com->Content_Length));
-		memcpy(com->body, sess->TCPBuffer+sess->CurrentPos + BodyStart, com->Content_Length);
-	}
-	//reset TCP buffer
-	sess->CurrentPos += BodyStart + com->Content_Length;
-
-	if (!com->CSeq) com->StatusCode = NC_RTSP_Bad_Request;
-
-	if (e || (com->StatusCode != NC_RTSP_OK)) goto exit;
-
-	//NB: there is no "session state" in our lib when acting at the server side, as it depends
-	//on the server implementation. We cannot block responses / announcement to be sent
-	//dynamically, nor reset the session ourselves as we don't know the details of the session
-	//(eg TEARDOWN may keep resources up or not, ...)
-
-	//we also have the same pb for CSeq, as nothing forbids a server to buffer commands (and it
-	//happens during aggregation of PLAY/PAUSE with overlapping ranges)
-
-	//however store the last CSeq in case for client checking
-	if (!sess->CSeq) {
-		sess->CSeq = com->CSeq;
-	}
-	//check we're in the right range
-	else {
-		if (sess->CSeq >= com->CSeq)
-			com->StatusCode = NC_RTSP_Header_Field_Not_Valid;
-		else
-			sess->CSeq = com->CSeq;
-	}
-
-	//
-	//if a connection closed is signal, check this is the good session
-	// and reset it (the client is no longer connected)
-	if (sess->last_session_id && com->Session && !strcmp(com->Session, sess->last_session_id)
-	        && com->Connection && !stricmp(com->Connection, "Close")) {
-
-		gf_rtsp_session_reset(sess, GF_FALSE);
-		//destroy the socket
-		if (sess->connection) gf_sk_del(sess->connection);
-		sess->connection = NULL;
-
-		//destroy the http tunnel if any
-		if (sess->HasTunnel && sess->http) {
-			gf_sk_del(sess->http);
-			sess->http = NULL;
-		}
-	}
-
-exit:
-	gf_mx_v(sess->mx);
-	return e;
-}
-
-#endif /*GPAC_DISABLE_STREAMING*/
diff --git a/src/ietfPrtsp_common.c b/src/ietfPrtsp_common.c
deleted file mode 100644
index 2cbf01e90..000000000
--- a/src/ietfPrtsp_common.c
+++ /dev/null
@@ -1,390 +0,0 @@
-/*
- *			GPAC - Multimedia Framework C SDK
- *
- *			Authors: Jean Le Feuvre
- *			Copyright (c) Telecom ParisTech 2000-2012
- *					All rights reserved
- *
- *  This file is part of GPAC / IETF RTP/RTSP/SDP sub-project
- *
- *  GPAC is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU Lesser General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  GPAC is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#include <gpac/internal/ietf_dev.h>
-
-#ifndef GPAC_DISABLE_STREAMING
-
-#include <gpac/token.h>
-
-
-GF_Err gf_rtsp_read_reply(GF_RTSPSession *sess)
-{
-	GF_Err e;
-	u32 res, body_size = 0;
-	u32 BodyStart = 0;
-
-	//fetch more data on the socket if needed
-	while (1) {
-		//Locate header / body
-		if (!BodyStart) gf_rtsp_get_body_info(sess, &BodyStart, &body_size);
-
-		if (BodyStart) {
-			//enough data
-			res = sess->CurrentSize - sess->CurrentPos;
-			if (!body_size || (res >= body_size + BodyStart)) {
-				//done
-				break;
-			}
-		}
-		//this is the tricky part: if we do NOT have a body start -> we refill
-		e = gf_rtsp_refill_buffer(sess);
-		if (e) return e;
-	}
-	return GF_OK;
-}
-
-void gf_rtsp_get_body_info(GF_RTSPSession *sess, u32 *body_start, u32 *body_size)
-{
-	u32 i;
-	s32 start;
-	char *buffer;
-	char *cl_str, val[30];
-
-	*body_start = *body_size = 0;
-
-	buffer = sess->TCPBuffer + sess->CurrentPos;
-	start = gf_token_find(buffer, 0, sess->CurrentSize - sess->CurrentPos, "\r\n\r\n");
-	if (start<=0) {
-		return;
-	}
-
-	//if found add the 2 "\r\n" and parse it
-	*body_start = start + 4;
-
-	//get the content length
-	cl_str = strstr(buffer, "Content-Length: ");
-	if (!cl_str) cl_str = strstr(buffer, "Content-length: ");
-
-	if (cl_str) {
-		cl_str += 16;
-		i = 0;
-		while (cl_str[i] != '\r') {
-			val[i] = cl_str[i];
-			i += 1;
-		}
-		val[i] = 0;
-		*body_size = atoi(val);
-	} else {
-		*body_size = 0;
-	}
-}
-
-
-GF_Err gf_rtsp_refill_buffer(GF_RTSPSession *sess)
-{
-	GF_Err e;
-	u32 res;
-	char *ptr;
-
-	if (!sess) return GF_BAD_PARAM;
-	if (!sess->connection) return GF_IP_NETWORK_EMPTY;
-
-	res = sess->CurrentSize - sess->CurrentPos;
-	if (!res) return gf_rtsp_fill_buffer(sess);
-
-	ptr = (char *)gf_malloc(sizeof(char) * res);
-	memcpy(ptr, sess->TCPBuffer+sess->CurrentPos, res);
-	memcpy(sess->TCPBuffer, ptr, res);
-	gf_free(ptr);
-
-	sess->CurrentPos = 0;
-	sess->CurrentSize = res;
-
-	//now read from current pos
-	e = gf_sk_receive(sess->connection, sess->TCPBuffer + sess->CurrentSize,
-	                  RTSP_TCP_BUF_SIZE - sess->CurrentSize,
-	                  0, &res);
-
-	if (!e) {
-		sess->CurrentSize += res;
-	}
-	return e;
-}
-
-
-GF_Err gf_rtsp_fill_buffer(GF_RTSPSession *sess)
-{
-	GF_Err e = GF_OK;
-
-	if (!sess->connection) return GF_IP_NETWORK_EMPTY;
-
-	if (sess->CurrentSize == sess->CurrentPos) {
-		e = gf_sk_receive(sess->connection, sess->TCPBuffer, RTSP_TCP_BUF_SIZE, 0, &sess->CurrentSize);
-		sess->CurrentPos = 0;
-		sess->TCPBuffer[sess->CurrentSize] = 0;
-		if (e) sess->CurrentSize = 0;
-	} else if (!sess->CurrentSize) e = GF_IP_NETWORK_EMPTY;
-	return e;
-}
-
-
-GF_RTSPTransport *gf_rtsp_transport_parse(char *buffer)
-{
-	Bool IsFirst;
-	char buf[100], param_name[100], param_val[100];
-	s32 pos, nPos;
-	u32 v1, v2;
-	GF_RTSPTransport *tmp;
-	pos = 0;
-	if (!buffer) return NULL;
-	//only support for RTP/AVP for now
-	if (strnicmp(buffer, "RTP/AVP", 7) && strnicmp(buffer, "RTP/SAVP", 8)) return NULL;
-
-	GF_SAFEALLOC(tmp, GF_RTSPTransport);
-
-	IsFirst = GF_TRUE;
-	pos = 0;
-	while (1) {
-		pos = gf_token_get(buffer, pos, " ;", buf, 100);
-		if (pos <= 0) break;
-		if (strstr(buf, "=")) {
-			nPos = gf_token_get(buf, 0, "=", param_name, 100);
-			nPos = gf_token_get(buf, nPos, "=", param_val, 100);
-		} else {
-			strcpy(param_name, buf);
-		}
-
-		//very first param is the profile
-		if (IsFirst) {
-			tmp->Profile = gf_strdup(param_name);
-			IsFirst = GF_FALSE;
-			continue;
-		}
-
-		if (!stricmp(param_name, "destination")) {
-			if (tmp->destination) gf_free(tmp->destination);
-			tmp->destination = gf_strdup(param_val);
-		}
-		else if (!stricmp(param_name, "source")) {
-			if (tmp->source) gf_free(tmp->source);
-			tmp->source = gf_strdup(param_val);
-		}
-		else if (!stricmp(param_name, "unicast")) tmp->IsUnicast = GF_TRUE;
-		else if (!stricmp(param_name, "RECORD")) tmp->IsRecord = GF_TRUE;
-		else if (!stricmp(param_name, "append")) tmp->Append = GF_TRUE;
-		else if (!stricmp(param_name, "interleaved")) {
-			u32 rID, rcID;
-			tmp->IsInterleaved = GF_TRUE;
-			if (sscanf(param_val, "%u-%u", &rID, &rcID) == 1) {
-				sscanf(param_val, "%u", &rID);
-				tmp->rtcpID = tmp->rtpID = (u8) rID;
-			} else {
-				tmp->rtpID = (u8) rID;
-				tmp->rtcpID = (u8) rcID;
-			}
-		}
-		else if (!stricmp(param_name, "layers")) sscanf(param_val, "%u", &tmp->MulticastLayers);
-		else if (!stricmp(param_name, "ttl")) sscanf(param_val, "%c	", &tmp->TTL);
-		else if (!stricmp(param_name, "port")) {
-			sscanf(param_val, "%u-%u", &v1, &v2);
-			tmp->port_first = (u16) v1;
-			tmp->port_last = (u16) v2;
-		}
-		/*do not use %hud here, broken on Win32 (sscanf returns 1)*/
-		else if (!stricmp(param_name, "server_port")) {
-			sscanf(param_val, "%d-%d", &v1, &v2);
-			tmp->port_first = (u16) v1;
-			tmp->port_last = (u16) v2;
-		}
-		/*do not use %hud here, broken on Win32 (sscanf returns 1)*/
-		else if (!stricmp(param_name, "client_port")) {
-			sscanf(param_val, "%d-%d", &v1, &v2);
-			tmp->client_port_first = (u16) v1;
-			tmp->client_port_last = (u16) v2;
-		}
-		else if (!stricmp(param_name, "ssrc")) sscanf(param_val, "%X", &tmp->SSRC);
-	}
-	return tmp;
-}
-
-
-
-GF_Err gf_rtsp_parse_header(char *buffer, u32 BufferSize, u32 BodyStart, GF_RTSPCommand *com, GF_RTSPResponse *rsp)
-{
-	char LineBuffer[1024];
-	char HeaderBuf[100], ValBuf[1024], temp[400];
-	s32 Pos, LinePos;
-	u32 HeaderLine;
-
-	//then parse the full header
-	LinePos = 0;
-	strcpy(HeaderBuf, "");
-	while (1) {
-		HeaderLine = 0;
-		LinePos = gf_token_get_line(buffer, LinePos, BufferSize, LineBuffer, 1024);
-		if (LinePos <= 0) return GF_REMOTE_SERVICE_ERROR;
-
-		//extract field header and value. Warning: some params (transport, ..) may be on several lines
-		Pos = gf_token_get(LineBuffer, 0, ":\r\n", temp, 400);
-
-		//end of header
-		if (Pos <= 0) {
-			HeaderLine = 2;
-		}
-		//this is a header
-		else if (LineBuffer[0] != ' ') {
-			HeaderLine = 1;
-		} else {
-			Pos = gf_token_get(LineBuffer, 0, ", \r\n", temp, 400);
-			//end of header - process any pending one
-			if (Pos <= 0) {
-				HeaderLine = 2;
-			} else {
-				//n-line value - append
-				strcat(ValBuf, "\r\n");
-				strcat(ValBuf, temp);
-				continue;
-			}
-		}
-		//process current value
-		if (HeaderLine && strlen(HeaderBuf)) {
-			if (rsp) {
-				gf_rtsp_set_response_value(rsp, HeaderBuf, ValBuf);
-			}
-			else {
-				gf_rtsp_set_command_value(com, HeaderBuf, ValBuf);
-			}
-		}
-		//done with the header
-		if ( (HeaderLine == 2) || ((u32) LinePos >= BodyStart) ) return GF_OK;
-
-		//process current line
-		strcpy(HeaderBuf, temp);
-
-		//skip ':'
-		Pos += 1;
-		//a server should normally reply with a space, but check it
-		if (LineBuffer[Pos] == ' ') Pos += 1;
-		/*!! empty value !! - DSS may send these for CSeq if something goes wrong*/
-		if (!strcmp(LineBuffer+Pos, "\r\n")) {
-			HeaderBuf[0] = 0;
-			continue;
-		}
-		Pos = gf_token_get(LineBuffer, Pos, "\r\n", ValBuf, 400);
-		if (Pos <= 0) break;
-
-	}
-	//if we get here we haven't reached the BodyStart
-	return GF_REMOTE_SERVICE_ERROR;
-}
-
-
-GF_EXPORT
-const char *gf_rtsp_nc_to_string(u32 ErrCode)
-{
-	switch (ErrCode) {
-	case NC_RTSP_Continue:
-		return "Continue";
-	case NC_RTSP_OK:
-		return "OK";
-	case NC_RTSP_Created:
-		return "Created";
-	case NC_RTSP_Low_on_Storage_Space:
-		return "Low on Storage Space";
-	case NC_RTSP_Multiple_Choice:
-		return "Multiple Choice";
-	case NC_RTSP_Moved_Permanently:
-		return "Moved Permanently";
-	case NC_RTSP_Moved_Temporarily:
-		return "Moved Temporarily";
-	case NC_RTSP_See_Other:
-		return "See Other";
-	case NC_RTSP_Use_Proxy:
-		return "Use Proxy";
-	case NC_RTSP_Bad_Request:
-		return "Bad Request";
-	case NC_RTSP_Unauthorized:
-		return "Unauthorized";
-	case NC_RTSP_Payment_Required:
-		return "Payment Required";
-	case NC_RTSP_Forbidden:
-		return "Forbidden";
-	case NC_RTSP_Not_Found:
-		return "Not Found";
-	case NC_RTSP_Method_Not_Allowed:
-		return "Method Not Allowed";
-	case NC_RTSP_Not_Acceptable:
-		return "Not Acceptable";
-	case NC_RTSP_Proxy_Authentication_Required:
-		return "Proxy Authentication Required";
-	case NC_RTSP_Request_Timeout:
-		return "Request Timeout";
-	case NC_RTSP_Gone:
-		return "Gone";
-	case NC_RTSP_Length_Required:
-		return "Length Required";
-	case NC_RTSP_Precondition_Failed:
-		return "Precondition Failed";
-	case NC_RTSP_Request_Entity_Too_Large:
-		return "Request Entity Too Large";
-	case NC_RTSP_Request_URI_Too_Long:
-		return "Request URI Too Long";
-	case NC_RTSP_Unsupported_Media_Type:
-		return "Unsupported Media Type";
-	case NC_RTSP_Invalid_parameter:
-		return "Invalid parameter";
-	case NC_RTSP_Illegal_Conference_Identifier:
-		return "Illegal Conference Identifier";
-	case NC_RTSP_Not_Enough_Bandwidth:
-		return "Not Enough Bandwidth";
-	case NC_RTSP_Session_Not_Found:
-		return "Session Not Found";
-	case NC_RTSP_Method_Not_Valid_In_This_State:
-		return "Method Not Valid In This State";
-	case NC_RTSP_Header_Field_Not_Valid:
-		return "Header Field Not Valid";
-	case NC_RTSP_Invalid_Range:
-		return "Invalid Range";
-	case NC_RTSP_Parameter_Is_ReadOnly:
-		return "Parameter Is Read-Only";
-	case NC_RTSP_Aggregate_Operation_Not_Allowed:
-		return "Aggregate Operation Not Allowed";
-	case NC_RTSP_Only_Aggregate_Operation_Allowed:
-		return "Only Aggregate Operation Allowed";
-	case NC_RTSP_Unsupported_Transport:
-		return "Unsupported Transport";
-	case NC_RTSP_Destination_Unreachable:
-		return "Destination Unreachable";
-	case NC_RTSP_Internal_Server_Error:
-		return "Internal Server Error";
-	case NC_RTSP_Bad_Gateway:
-		return "Bad Gateway";
-	case NC_RTSP_Service_Unavailable:
-		return "Service Unavailable";
-	case NC_RTSP_Gateway_Timeout:
-		return "Gateway Timeout";
-	case NC_RTSP_RTSP_Version_Not_Supported:
-		return "RTSP Version Not Supported";
-	case NC_RTSP_Option_not_support:
-		return "Option not support";
-
-	case NC_RTSP_Not_Implemented:
-	default:
-		return "Not Implemented";
-	}
-}
-
-#endif /*GPAC_DISABLE_STREAMING*/
diff --git a/src/ietfPrtsp_response.c b/src/ietfPrtsp_response.c
deleted file mode 100644
index e358bdc28..000000000
--- a/src/ietfPrtsp_response.c
+++ /dev/null
@@ -1,721 +0,0 @@
-/*
- *			GPAC - Multimedia Framework C SDK
- *
- *			Authors: Jean Le Feuvre
- *			Copyright (c) Telecom ParisTech 2000-2012
- *					All rights reserved
- *
- *  This file is part of GPAC / IETF RTP/RTSP/SDP sub-project
- *
- *  GPAC is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU Lesser General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  GPAC is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#include <gpac/internal/ietf_dev.h>
-
-#ifndef GPAC_DISABLE_STREAMING
-
-#include <gpac/token.h>
-
-
-GF_EXPORT
-GF_RTSPResponse *gf_rtsp_response_new()
-{
-	GF_RTSPResponse *tmp;
-	GF_SAFEALLOC(tmp, GF_RTSPResponse);
-	tmp->Transports = gf_list_new();
-	tmp->RTP_Infos = gf_list_new();
-	tmp->Xtensions = gf_list_new();
-	return tmp;
-}
-
-
-#define RSP_FREE_CLEAN(hdr)		if (rsp->hdr) gf_free(rsp->hdr);	\
-								rsp->hdr = NULL;
-
-GF_EXPORT
-void gf_rtsp_response_reset(GF_RTSPResponse *rsp)
-{
-	GF_RTPInfo *inf;
-	GF_RTSPTransport *trans;
-	GF_X_Attribute *att;
-	if (!rsp) return;
-
-	//free all headers
-	RSP_FREE_CLEAN(Accept);
-	RSP_FREE_CLEAN(Accept_Encoding);
-	RSP_FREE_CLEAN(Accept_Language);
-	RSP_FREE_CLEAN(Allow);
-	RSP_FREE_CLEAN(Authorization);
-	RSP_FREE_CLEAN(Cache_Control);
-	RSP_FREE_CLEAN(Conference);
-	RSP_FREE_CLEAN(Connection);
-	RSP_FREE_CLEAN(Content_Base);
-	RSP_FREE_CLEAN(Content_Encoding);
-	RSP_FREE_CLEAN(Content_Language);
-	RSP_FREE_CLEAN(Content_Location);
-	RSP_FREE_CLEAN(Content_Type);
-	RSP_FREE_CLEAN(Date);
-	RSP_FREE_CLEAN(Expires);
-	RSP_FREE_CLEAN(From);
-	RSP_FREE_CLEAN(Host);
-	RSP_FREE_CLEAN(If_Match);
-	RSP_FREE_CLEAN(If_Modified_Since);
-	RSP_FREE_CLEAN(Last_Modified);
-	RSP_FREE_CLEAN(Location);
-	RSP_FREE_CLEAN(Proxy_Authenticate);
-	RSP_FREE_CLEAN(Proxy_Require);
-	RSP_FREE_CLEAN(Public);
-	RSP_FREE_CLEAN(Referer);
-	RSP_FREE_CLEAN(Require);
-	RSP_FREE_CLEAN(Retry_After);
-	RSP_FREE_CLEAN(Server);
-	RSP_FREE_CLEAN(Session);
-	RSP_FREE_CLEAN(Timestamp);
-	RSP_FREE_CLEAN(Unsupported);
-	RSP_FREE_CLEAN(User_Agent);
-	RSP_FREE_CLEAN(Vary);
-	RSP_FREE_CLEAN(Via);
-	RSP_FREE_CLEAN(WWW_Authenticate);
-
-	//this is for us
-	RSP_FREE_CLEAN(ResponseInfo);
-	RSP_FREE_CLEAN(body);
-
-	rsp->Bandwidth = rsp->Blocksize = rsp->ResponseCode = rsp->Content_Length = rsp->CSeq = 0;
-	rsp->Scale = rsp->Speed = 0.0;
-	if (rsp->Range) gf_free(rsp->Range);
-	rsp->Range = NULL;
-
-	rsp->SessionTimeOut = 0;
-
-	while (gf_list_count(rsp->Transports)) {
-		trans = (GF_RTSPTransport*) gf_list_get(rsp->Transports, 0);
-		gf_list_rem(rsp->Transports, 0);
-		gf_rtsp_transport_del(trans);
-	}
-
-	while (gf_list_count(rsp->RTP_Infos)) {
-		inf = (GF_RTPInfo*) gf_list_get(rsp->RTP_Infos, 0);
-		gf_list_rem(rsp->RTP_Infos, 0);
-		if (inf->url) gf_free(inf->url);
-		gf_free(inf);
-	}
-	while (gf_list_count(rsp->Xtensions)) {
-		att = (GF_X_Attribute*)gf_list_get(rsp->Xtensions, 0);
-		gf_list_rem(rsp->Xtensions, 0);
-		gf_free(att->Name);
-		gf_free(att->Value);
-		gf_free(att);
-	}
-}
-
-GF_EXPORT
-void gf_rtsp_response_del(GF_RTSPResponse *rsp)
-{
-	if (!rsp) return;
-
-	gf_rtsp_response_reset(rsp);
-	gf_list_del(rsp->RTP_Infos);
-	gf_list_del(rsp->Xtensions);
-	gf_list_del(rsp->Transports);
-	gf_free(rsp);
-}
-
-
-
-GF_EXPORT
-GF_RTSPRange *gf_rtsp_range_parse(char *range_buf)
-{
-	GF_RTSPRange *rg;
-
-	if (!strstr(range_buf, "npt")) return NULL;
-
-	GF_SAFEALLOC(rg, GF_RTSPRange);
-	if (sscanf(range_buf, "npt=%lf-%lf", &rg->start, &rg->end) != 2) {
-		rg->end = -1.0;
-		sscanf(range_buf, "npt=%lf-", &rg->start);
-	}
-	return rg;
-}
-
-GF_EXPORT
-void gf_rtsp_transport_del(GF_RTSPTransport *transp)
-{
-	if (!transp) return;
-	if (transp->destination) gf_free(transp->destination);
-	if (transp->Profile) gf_free(transp->Profile);
-	if (transp->source) gf_free(transp->source);
-	gf_free(transp);
-}
-
-GF_EXPORT
-GF_RTSPTransport *gf_rtsp_transport_clone(GF_RTSPTransport *original)
-{
-	GF_RTSPTransport *tr;
-
-	if (!original) return NULL;
-
-	tr = (GF_RTSPTransport*) gf_malloc(sizeof(GF_RTSPTransport));
-	memcpy(tr, original, sizeof(GF_RTSPTransport));
-	tr->destination = tr->source = tr->Profile = NULL;
-	if (original->destination) tr->destination = gf_strdup(original->destination);
-	if (original->source) tr->source = gf_strdup(original->source);
-	if (original->Profile) tr->Profile = gf_strdup(original->Profile);
-	return tr;
-}
-
-GF_EXPORT
-GF_RTSPRange *gf_rtsp_range_new()
-{
-	GF_RTSPRange *tmp;
-	GF_SAFEALLOC(tmp, GF_RTSPRange);
-	return tmp;
-}
-
-GF_EXPORT
-void gf_rtsp_range_del(GF_RTSPRange *range)
-{
-	if (!range) return;
-	gf_free(range);
-}
-
-void gf_rtsp_set_response_value(GF_RTSPResponse *rsp, char *Header, char *Value)
-{
-	char LineBuffer[400], buf[1000], param_name[100], param_val[1000];
-	s32 LinePos, Pos, nPos, s_val;
-	GF_RTPInfo *info;
-	GF_RTSPTransport *trans;
-	GF_X_Attribute *x_Att;
-
-	if (!stricmp(Header, "Accept")) rsp->Accept = gf_strdup(Value);
-	else if (!stricmp(Header, "Accept-Encoding")) rsp->Accept_Encoding = gf_strdup(Value);
-	else if (!stricmp(Header, "Accept-Language")) rsp->Accept_Language = gf_strdup(Value);
-	else if (!stricmp(Header, "Allow")) rsp->Allow = gf_strdup(Value);
-	else if (!stricmp(Header, "Authorization")) rsp->Authorization = gf_strdup(Value);
-	else if (!stricmp(Header, "Bandwidth")) sscanf(Value, "%u", &rsp->Bandwidth);
-	else if (!stricmp(Header, "Blocksize")) sscanf(Value, "%u", &rsp->Blocksize);
-	else if (!stricmp(Header, "Cache-Control")) rsp->Cache_Control = gf_strdup(Value);
-	else if (!stricmp(Header, "Conference")) rsp->Conference = gf_strdup(Value);
-	else if (!stricmp(Header, "Connection")) rsp->Connection = gf_strdup(Value);
-	else if (!stricmp(Header, "Content-Base")) rsp->Content_Base = gf_strdup(Value);
-	else if (!stricmp(Header, "Content-Encoding")) rsp->Content_Encoding = gf_strdup(Value);
-	else if (!stricmp(Header, "Content-Length")) sscanf(Value, "%u", &rsp->Content_Length);
-	else if (!stricmp(Header, "Content-Language")) rsp->Content_Language = gf_strdup(Value);
-	else if (!stricmp(Header, "Content-Location")) rsp->Content_Location = gf_strdup(Value);
-	else if (!stricmp(Header, "Content-Type")) rsp->Content_Type = gf_strdup(Value);
-	else if (!stricmp(Header, "CSeq")) sscanf(Value, "%u", &rsp->CSeq);
-	else if (!stricmp(Header, "Date")) rsp->Date = gf_strdup(Value);
-	else if (!stricmp(Header, "Expires")) rsp->Expires = gf_strdup(Value);
-	else if (!stricmp(Header, "From")) rsp->From = gf_strdup(Value);
-	else if (!stricmp(Header, "Host")) rsp->Host = gf_strdup(Value);
-	else if (!stricmp(Header, "If-Match")) rsp->If_Match = gf_strdup(Value);
-	else if (!stricmp(Header, "If-Modified-Since")) rsp->If_Modified_Since = gf_strdup(Value);
-	else if (!stricmp(Header, "Last-Modified")) rsp->Last_Modified = gf_strdup(Value);
-	else if (!stricmp(Header, "Location")) rsp->Location = gf_strdup(Value);
-	else if (!stricmp(Header, "Proxy-Authenticate")) rsp->Proxy_Authenticate = gf_strdup(Value);
-	else if (!stricmp(Header, "Proxy-Require")) rsp->Proxy_Require = gf_strdup(Value);
-	else if (!stricmp(Header, "Public")) rsp->Public = gf_strdup(Value);
-	else if (!stricmp(Header, "Referer")) rsp->Referer = gf_strdup(Value);
-	else if (!stricmp(Header, "Require")) rsp->Require = gf_strdup(Value);
-	else if (!stricmp(Header, "Retry-After")) rsp->Retry_After = gf_strdup(Value);
-	else if (!stricmp(Header, "Scale")) sscanf(Value, "%lf", &rsp->Scale);
-	else if (!stricmp(Header, "Server")) rsp->Server = gf_strdup(Value);
-	else if (!stricmp(Header, "Speed")) sscanf(Value, "%lf", &rsp->Speed);
-	else if (!stricmp(Header, "Timestamp")) rsp->Timestamp = gf_strdup(Value);
-	else if (!stricmp(Header, "Unsupported")) rsp->Unsupported = gf_strdup(Value);
-	else if (!stricmp(Header, "User-Agent")) rsp->User_Agent = gf_strdup(Value);
-	else if (!stricmp(Header, "Vary")) rsp->Vary = gf_strdup(Value);
-	else if (!stricmp(Header, "Via")) rsp->Vary = gf_strdup(Value);
-	else if (!stricmp(Header, "WWW_Authenticate")) rsp->Vary = gf_strdup(Value);
-	else if (!stricmp(Header, "Transport")) {
-		LinePos = 0;
-		while (1) {
-			LinePos = gf_token_get(Value, LinePos, "\r\n", LineBuffer, 400);
-			if (LinePos <= 0) return;
-			trans = gf_rtsp_transport_parse(Value);
-			if (trans) gf_list_add(rsp->Transports, trans);
-		}
-	}
-	//Session
-	else if (!stricmp(Header, "Session")) {
-		LinePos = gf_token_get(Value, 0, ";\r\n", LineBuffer, 400);
-		rsp->Session = gf_strdup(LineBuffer);
-		//get timeout if any
-		if (Value[LinePos] == ';') {
-			LinePos += 1;
-			LinePos = gf_token_get(Value, LinePos, ";\r\n", LineBuffer, 400);
-			//default
-			rsp->SessionTimeOut = 60;
-			sscanf(LineBuffer, "timeout=%u", &rsp->SessionTimeOut);
-		}
-	}
-
-	//Range
-	else if (!stricmp(Header, "Range")) rsp->Range = gf_rtsp_range_parse(Value);
-	//RTP-Info
-	else if (!stricmp(Header, "RTP-Info")) {
-		LinePos = 0;
-		while (1) {
-			LinePos = gf_token_get(Value, LinePos, ",\r\n", LineBuffer, 400);
-			if (LinePos <= 0) return;
-
-			GF_SAFEALLOC(info, GF_RTPInfo);
-			Pos = 0;
-			while (1) {
-				Pos = gf_token_get(LineBuffer, Pos, " ;", buf, 1000);
-				if (Pos <= 0) break;
-				if (strstr(buf, "=")) {
-					nPos = gf_token_get(buf, 0, "=", param_name, 100);
-					nPos += 1;
-					nPos = gf_token_get(buf, nPos, "", param_val, 1000);
-				} else {
-					strcpy(param_name, buf);
-				}
-				if (!stricmp(param_name, "url")) info->url = gf_strdup(param_val);
-				else if (!stricmp(param_name, "seq")) sscanf(param_val, "%u", &info->seq);
-				else if (!stricmp(param_name, "rtptime")) {
-					sscanf(param_val, "%i", &s_val);
-					info->rtp_time = (s_val>0) ? s_val : 0;
-				}
-				else if (!stricmp(param_name, "ssrc")) {
-					sscanf(param_val, "%i", &s_val);
-					info->ssrc = (s_val>0) ? s_val : 0;
-				}
-			}
-			gf_list_add(rsp->RTP_Infos, info);
-		}
-	}
-	//check for extended attributes
-	else if (!strnicmp(Header, "x-", 2)) {
-		x_Att = (GF_X_Attribute*)gf_malloc(sizeof(GF_X_Attribute));
-		x_Att->Name = gf_strdup(Header+2);
-		x_Att->Value = NULL;
-		if (Value && strlen(Value)) x_Att->Value = gf_strdup(Value);
-		gf_list_add(rsp->Xtensions, x_Att);
-	}
-	//unknown field - skip it
-}
-
-
-
-//parse all fields in the header
-GF_Err RTSP_ParseResponseHeader(GF_RTSPSession *sess, GF_RTSPResponse *rsp, u32 BodyStart)
-{
-	char LineBuffer[1024];
-	char ValBuf[400];
-	char *buffer;
-	s32 Pos, ret;
-	u32 Size;
-
-	Size = sess->CurrentSize - sess->CurrentPos;
-	buffer = sess->TCPBuffer + sess->CurrentPos;
-
-	//parse first line
-	ret = gf_token_get_line(buffer, 0, Size, LineBuffer, 1024);
-	if (ret < 0)
-		return GF_REMOTE_SERVICE_ERROR;
-	//RTSP/1.0
-	Pos = gf_token_get(LineBuffer, 0, " \t\r\n", ValBuf, 400);
-	if (Pos <= 0)
-		return GF_REMOTE_SERVICE_ERROR;
-	if (strcmp(ValBuf, GF_RTSP_VERSION))
-		return GF_SERVICE_ERROR;
-	//CODE
-	Pos = gf_token_get(LineBuffer, Pos, " \t\r\n", ValBuf, 400);
-	if (Pos <= 0)
-		return GF_REMOTE_SERVICE_ERROR;
-	rsp->ResponseCode = atoi(ValBuf);
-	//string info
-	Pos = gf_token_get(LineBuffer, Pos, "\t\r\n", ValBuf, 400);
-	if (Pos > 0) rsp->ResponseInfo = gf_strdup(ValBuf);
-
-	return gf_rtsp_parse_header(buffer + ret, Size - ret, BodyStart, NULL, rsp);
-}
-
-
-
-u32 IsRTSPMessage(char *buffer)
-{
-	if (!buffer) return 0;
-	if (buffer[0]=='$') return 0;
-
-	if (!strncmp(buffer, "RTSP", 4)) return 1;
-	if (!strncmp(buffer, "GET_PARAMETER", strlen("GET_PARAMETER"))) return 1;
-	if (!strncmp(buffer, "ANNOUNCE", strlen("ANNOUNCE"))) return 1;
-	if (!strncmp(buffer, "SET_PARAMETER", strlen("SET_PARAMETER"))) return 1;
-	if (!strncmp(buffer, "REDIRECT", strlen("REDIRECT"))) return 1;
-	if (!strncmp(buffer, "OPTIONS", strlen("OPTIONS"))) return 1;
-	return 0;
-}
-
-
-GF_EXPORT
-GF_Err gf_rtsp_get_response(GF_RTSPSession *sess, GF_RTSPResponse *rsp)
-{
-	GF_Err e;
-	Bool force_reset = GF_FALSE;
-	u32 BodyStart, size;
-
-	if (!sess || !rsp) return GF_BAD_PARAM;
-	gf_rtsp_response_reset(rsp);
-
-
-	//LOCK
-	gf_mx_p(sess->mx);
-
-
-	e = gf_rtsp_check_connection(sess);
-	if (e)
-		goto exit;
-
-	//push data in our queue
-	e = gf_rtsp_fill_buffer(sess);
-	if (e)
-		goto exit;
-
-	//this is interleaved data
-	if (!IsRTSPMessage(sess->TCPBuffer+sess->CurrentPos) ) {
-		gf_rtsp_session_read(sess);
-		e = GF_IP_NETWORK_EMPTY;
-		goto exit;
-	}
-	e = gf_rtsp_read_reply(sess);
-	if (e)
-		goto exit;
-
-	//get the reply
-	gf_rtsp_get_body_info(sess, &BodyStart, &size);
-	e = RTSP_ParseResponseHeader(sess, rsp, BodyStart);
-
-	//copy the body if any
-	if (!e && rsp->Content_Length) {
-		rsp->body = (char *)gf_malloc(sizeof(char) * (rsp->Content_Length));
-		memcpy(rsp->body, sess->TCPBuffer+sess->CurrentPos + BodyStart, rsp->Content_Length);
-	}
-
-	GF_LOG(GF_LOG_INFO, GF_LOG_RTP, ("[RTSP] Got Response:\n%s\n", sess->TCPBuffer+sess->CurrentPos));
-
-	//reset TCP buffer
-	sess->CurrentPos += BodyStart + rsp->Content_Length;
-
-	if (e) goto exit;
-
-	//update RTSP aggreagation info
-	if (sess->NbPending) sess->NbPending -= 1;
-
-	if (sess->RTSP_State == GF_RTSP_STATE_WAITING) sess->RTSP_State = GF_RTSP_STATE_INIT;
-	//control, and everything is received
-	else if (sess->RTSP_State == GF_RTSP_STATE_WAIT_FOR_CONTROL) {
-		if (!sess->NbPending) sess->RTSP_State = GF_RTSP_STATE_INIT;
-	}
-	//this is a late reply to an aggregated control - signal nothing
-	if (!strcmp(sess->RTSPLastRequest, "RESET") && sess->CSeq > rsp->CSeq) {
-		e = GF_IP_NETWORK_EMPTY;
-		goto exit;
-	}
-
-	//reset last request
-	if (sess->RTSP_State == GF_RTSP_STATE_INIT) strcpy(sess->RTSPLastRequest, "");
-
-	//check the CSeq is in the right range. The server should ALWAYS reply in sequence
-	//to an aggreagated sequence of requests
-	//if we have reseted the connection (due to an APP error) return empty
-	if (rsp->CSeq && sess->CSeq > rsp->CSeq + sess->NbPending) {
-		gf_mx_v(sess->mx);
-		return gf_rtsp_get_response(sess, rsp);
-	}
-
-	if (sess->CSeq != rsp->CSeq + sess->NbPending) {
-		GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, ("[RTSP] Invalid sequence number - got %d but expected %d\n", sess->CSeq, rsp->CSeq + sess->NbPending));
-		e = GF_REMOTE_SERVICE_ERROR;
-		goto exit;
-	}
-
-	/*check session ID*/
-	if (rsp->Session && sess->last_session_id && strcmp(sess->last_session_id, rsp->Session)) {
-		e = GF_REMOTE_SERVICE_ERROR;
-		goto exit;
-	}
-
-	//destroy sessionID if needed - real doesn't close the connection when destroying
-	//session
-	if (!strcmp(sess->RTSPLastRequest, GF_RTSP_TEARDOWN)) {
-		sess->last_session_id = NULL;
-	}
-
-exit:
-	if (rsp->Connection && !stricmp(rsp->Connection, "Close"))
-		force_reset = GF_TRUE;
-	else if (e && (e != GF_IP_NETWORK_EMPTY))
-		force_reset = GF_TRUE;
-
-	if (force_reset) {
-		gf_rtsp_session_reset(sess, GF_FALSE);
-		//destroy the socket
-		if (sess->connection) gf_sk_del(sess->connection);
-		sess->connection = NULL;
-
-		//destroy the http tunnel if any
-		if (sess->HasTunnel && sess->http) {
-			gf_sk_del(sess->http);
-			sess->http = NULL;
-		}
-	}
-
-	gf_mx_v(sess->mx);
-	return e;
-}
-
-
-
-
-GF_Err RTSP_WriteResponse(GF_RTSPSession *sess, GF_RTSPResponse *rsp,
-                          unsigned char **out_buffer, u32 *out_size)
-{
-	u32 i, cur_pos, size, count;
-	char *buffer, temp[50];
-	GF_RTSPTransport *trans;
-	GF_X_Attribute *att;
-	GF_RTPInfo *info;
-
-
-	*out_buffer = NULL;
-
-	size = RTSP_WRITE_STEPALLOC;
-	buffer = (char *) gf_malloc(size);
-	cur_pos = 0;
-
-	//RTSP line
-	RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, GF_RTSP_VERSION);
-	RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, " ");
-	RTSP_WRITE_INT(buffer, size, cur_pos, rsp->ResponseCode, 0);
-	RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, " ");
-	RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, gf_rtsp_nc_to_string(rsp->ResponseCode));
-	RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-
-	//all headers
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Accept", rsp->Accept);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Accept-Encoding", rsp->Accept_Encoding);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Accept-Language", rsp->Accept_Language);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Allow", rsp->Allow);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Authorization", rsp->Authorization);
-	if (rsp->Bandwidth) {
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "Bandwidth: ");
-		RTSP_WRITE_INT(buffer, size, cur_pos, rsp->Bandwidth, 0);
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-	}
-	if (rsp->Blocksize) {
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "Blocksize: ");
-		RTSP_WRITE_INT(buffer, size, cur_pos, rsp->Blocksize, 0);
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-	}
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Cache-Control", rsp->Cache_Control);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Conference", rsp->Conference);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Connection", rsp->Connection);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Content-Base", rsp->Content_Base);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Content-Encoding", rsp->Content_Encoding);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Content-Language", rsp->Content_Language);
-	//if we have a body write the content length
-	if (rsp->body) {
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "Content-Length: ");
-		RTSP_WRITE_INT(buffer, size, cur_pos, (u32) strlen(rsp->body), 0);
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-	}
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Content-Location", rsp->Content_Location);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Content-Type", rsp->Content_Type);
-	//write the CSeq - use the RESPONSE CSeq
-	RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "CSeq: ");
-	RTSP_WRITE_INT(buffer, size, cur_pos, rsp->CSeq, 0);
-	RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Date", rsp->Date);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Expires", rsp->Expires);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "From", rsp->From);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Host", rsp->Host);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "If-Match", rsp->If_Match);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "If-Modified-Since", rsp->If_Modified_Since);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Last-Modified", rsp->Last_Modified);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Location", rsp->Location);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Proxy-Authenticate", rsp->Proxy_Authenticate);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Proxy-Require", rsp->Proxy_Require);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Public", rsp->Public);
-
-	//Range, only NPT
-	if (rsp->Range && !rsp->Range->UseSMPTE) {
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "Range: npt:");
-		RTSP_WRITE_FLOAT_WITHOUT_CHECK(buffer, size, cur_pos, rsp->Range->start);
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "-");
-		if (rsp->Range->end > rsp->Range->start) {
-			RTSP_WRITE_FLOAT_WITHOUT_CHECK(buffer, size, cur_pos, rsp->Range->end);
-		}
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-	}
-
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Referer", rsp->Referer);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Require", rsp->Require);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Retry-After", rsp->Retry_After);
-
-	//RTP Infos
-	count = gf_list_count(rsp->RTP_Infos);
-	if (count) {
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "RTPInfo: ");
-
-		for (i=0; i<count; i++) {
-			//line separator for headers
-			if (i) RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n ,");
-			info = (GF_RTPInfo*)gf_list_get(rsp->RTP_Infos, i);
-
-			if (info->url) {
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "url=");
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, info->url);
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";");
-			}
-			RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "seq=");
-			RTSP_WRITE_INT(buffer, size, cur_pos, info->seq, 0);
-			RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";rtptime=");
-			RTSP_WRITE_INT(buffer, size, cur_pos, info->rtp_time, 0);
-		}
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-	}
-
-	if (rsp->Scale != 0.0) {
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "Scale: ");
-		RTSP_WRITE_FLOAT_WITHOUT_CHECK(buffer, size, cur_pos, rsp->Scale);
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-	}
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Server", rsp->Server);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Session", rsp->Session);
-	if (rsp->Speed != 0.0) {
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "Scale: ");
-		RTSP_WRITE_FLOAT_WITHOUT_CHECK(buffer, size, cur_pos, rsp->Speed);
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-	}
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Timestamp", rsp->Timestamp);
-
-	//transport info
-	count = gf_list_count(rsp->Transports);
-	if (count) {
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "Transport: ");
-		for (i=0; i<count; i++) {
-			//line separator for headers
-			if (i) RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n ,");
-			trans = (GF_RTSPTransport*)gf_list_get(rsp->Transports, i);
-
-			//then write the structure
-			RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, trans->Profile);
-			RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, (trans->IsUnicast ? ";unicast" : ";multicast"));
-			if (trans->destination) {
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";destination=");
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, trans->destination);
-			}
-			if (trans->source) {
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";source=");
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, trans->source);
-			}
-			if (trans->IsRecord) {
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";mode=RECORD");
-				if (trans->Append) RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";append");
-			}
-			if (trans->IsInterleaved) {
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";interleaved=");
-				RTSP_WRITE_INT(buffer, size, cur_pos, trans->rtpID, 0);
-				if (trans->rtcpID != trans->rtpID) {
-					RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "-");
-					RTSP_WRITE_INT(buffer, size, cur_pos, trans->rtcpID, 0);
-				}
-			}
-			//multicast specific
-			if (!trans->IsUnicast) {
-				if (trans->MulticastLayers) {
-					RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";layers=");
-					RTSP_WRITE_INT(buffer, size, cur_pos, trans->MulticastLayers, 0);
-				}
-				if (trans->TTL) {
-					RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";ttl=");
-					RTSP_WRITE_INT(buffer, size, cur_pos, trans->TTL, 0);
-				}
-			}
-			if (trans->port_first) {
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, (const char *) (trans->IsUnicast ? ";server_port=" : ";port="));
-				RTSP_WRITE_INT(buffer, size, cur_pos, trans->port_first, 0);
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "-");
-				RTSP_WRITE_INT(buffer, size, cur_pos, trans->port_last, 0);
-			}
-			if (trans->IsUnicast && trans->client_port_first) {
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";client_port=");
-				RTSP_WRITE_INT(buffer, size, cur_pos, trans->client_port_first, 0);
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "-");
-				RTSP_WRITE_INT(buffer, size, cur_pos, trans->client_port_last, 0);
-			}
-			if (trans->SSRC) {
-				RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, ";ssrc=");
-				RTSP_WRITE_INT(buffer, size, cur_pos, trans->SSRC, 0);
-			}
-		}
-		//done with transport
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-	}
-
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Unsupported", rsp->Unsupported);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "User-Agent", rsp->User_Agent);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Vary", rsp->Vary);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "Via", rsp->Via);
-	RTSP_WRITE_HEADER(buffer, size, cur_pos, "WWW-Authenticate", rsp->WWW_Authenticate);
-
-	//eXtensions
-	count = gf_list_count(rsp->Xtensions);
-	for (i=0; i<count; i++) {
-		att = (GF_X_Attribute*)gf_list_get(rsp->Xtensions, i);
-		RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "x-");
-		RTSP_WRITE_HEADER(buffer, size, cur_pos, att->Name, att->Value);
-	}
-	//end of header
-	RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, "\r\n");
-	//then body
-	RTSP_WRITE_ALLOC_STR(buffer, size, cur_pos, rsp->body);
-
-	*out_buffer = (unsigned char *) buffer;
-	*out_size = (u32) strlen(buffer);
-	return GF_OK;
-}
-
-
-GF_EXPORT
-GF_Err gf_rtsp_send_response(GF_RTSPSession *sess, GF_RTSPResponse *rsp)
-{
-	u32 size;
-	char *buffer;
-	GF_Err e;
-
-	if (!sess || !rsp || !rsp->CSeq) return GF_BAD_PARAM;
-
-	//check we're not sending something greater than the current CSeq
-	if (rsp->CSeq > sess->CSeq) return GF_BAD_PARAM;
-
-	e = RTSP_WriteResponse(sess, rsp, (unsigned char **) &buffer, &size);
-	if (e) goto exit;
-
-	//send buffer
-	e = gf_rtsp_send_data(sess, buffer, size);
-	if (e) return e;
-//	fprintf(stderr, "RTSP Send Response\n\n%s\n\n", buffer);
-
-exit:
-	if (buffer) gf_free(buffer);
-	return e;
-}
-
-#endif /*GPAC_DISABLE_STREAMING*/
diff --git a/src/ietfPrtsp_session.c b/src/ietfPrtsp_session.c
deleted file mode 100644
index 9c7ba0b6d..000000000
--- a/src/ietfPrtsp_session.c
+++ /dev/null
@@ -1,779 +0,0 @@
-/*
- *			GPAC - Multimedia Framework C SDK
- *
- *			Authors: Jean Le Feuvre
- *			Copyright (c) Telecom ParisTech 2000-2012
- *					All rights reserved
- *
- *  This file is part of GPAC / IETF RTP/RTSP/SDP sub-project
- *
- *  GPAC is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU Lesser General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  GPAC is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#include <gpac/internal/ietf_dev.h>
-#include <gpac/base_coding.h>
-
-
-#ifndef GPAC_DISABLE_STREAMING
-
-
-GF_Err RTSP_UnpackURL(char *sURL, char *Server, u16 *Port, char *Service, Bool *useTCP)
-{
-	char schema[10], *test, text[1024], *retest;
-	u32 i, len;
-	Bool is_ipv6;
-	if (!sURL) return GF_BAD_PARAM;
-
-	strcpy(Server, "");
-	strcpy(Service, "");
-	*Port = 0;
-	*useTCP = GF_FALSE;
-
-	if (!strchr(sURL, ':')) return GF_BAD_PARAM;
-
-	//extract the schema
-	i = 0;
-	while (i<=strlen(sURL)) {
-		if (sURL[i] == ':') goto found;
-		schema[i] = sURL[i];
-		i += 1;
-	}
-	return GF_BAD_PARAM;
-
-found:
-	schema[i] = 0;
-	if (stricmp(schema, "rtsp") && stricmp(schema, "rtspu")) return GF_URL_ERROR;
-	//check for user/pass - not allowed
-	/*
-		test = strstr(sURL, "@");
-		if (test) return GF_NOT_SUPPORTED;
-	*/
-	test = strstr(sURL, "://");
-	if (!test) return GF_URL_ERROR;
-	test += 3;
-	//check for service
-	retest = strstr(test, "/");
-	if (!retest) return GF_URL_ERROR;
-
-	if (!stricmp(schema, "rtsp")) *useTCP = GF_TRUE;
-
-	//check for port
-	retest = strrchr(test, ':');
-	/*IPV6 address*/
-	if (retest && strchr(retest, ']')) retest = NULL;
-
-	if (retest && strstr(retest, "/")) {
-		retest += 1;
-		i=0;
-		while (i<strlen(retest)) {
-			if (retest[i] == '/') break;
-			text[i] = retest[i];
-			i += 1;
-		}
-		text[i] = 0;
-		*Port = atoi(text);
-	}
-	//get the server name
-	is_ipv6 = GF_FALSE;
-	len = (u32) strlen(test);
-	i=0;
-	while (i<len) {
-		if (test[i]=='[') is_ipv6 = GF_TRUE;
-		else if (test[i]==']') is_ipv6 = GF_FALSE;
-		if ( (test[i] == '/') || (!is_ipv6 && (test[i] == ':')) ) break;
-		text[i] = test[i];
-		i += 1;
-	}
-	text[i] = 0;
-	strcpy(Server, text);
-
-	while (test[i] != '/') i += 1;
-	strcpy(Service, test+i+1);
-
-	return GF_OK;
-}
-
-
-//create a new GF_RTSPSession from URL - DO NOT USE WITH SDP
-GF_EXPORT
-GF_RTSPSession *gf_rtsp_session_new(char *sURL, u16 DefaultPort)
-{
-	GF_RTSPSession *sess;
-	char server[1024], service[1024];
-	GF_Err e;
-	u16 Port;
-	Bool UseTCP;
-
-	if (!sURL) return NULL;
-
-	e = RTSP_UnpackURL(sURL, server, &Port, service, &UseTCP);
-	if (e) return NULL;
-
-	GF_SAFEALLOC(sess, GF_RTSPSession);
-
-	sess->ConnectionType = UseTCP ? GF_SOCK_TYPE_TCP : GF_SOCK_TYPE_UDP;
-	if (Port) sess->Port = Port;
-	else if (DefaultPort) sess->Port = DefaultPort;
-	else sess->Port = 554;
-
-	//HTTP tunnel
-	if (sess->Port == 80) {
-		sess->ConnectionType = GF_SOCK_TYPE_TCP;
-		sess->HasTunnel = GF_TRUE;
-	}
-
-	sess->Server = gf_strdup(server);
-	sess->Service = gf_strdup(service);
-	sess->mx = gf_mx_new("RTSPSession");
-	sess->TCPChannels = gf_list_new();
-	gf_rtsp_session_reset(sess, GF_FALSE);
-	return sess;
-}
-
-
-GF_EXPORT
-void gf_rtsp_reset_aggregation(GF_RTSPSession *sess)
-{
-	if (!sess) return;
-
-	gf_mx_p(sess->mx);
-	if (sess->RTSP_State == GF_RTSP_STATE_WAIT_FOR_CONTROL) {
-		strcpy(sess->RTSPLastRequest, "RESET");
-		//skip all we haven't received
-		sess->CSeq += sess->NbPending;
-		sess->NbPending = 0;
-	}
-	sess->RTSP_State = GF_RTSP_STATE_INIT;
-	gf_mx_v(sess->mx);
-}
-
-void RTSP_AcknowledgeError(GF_RTSPSession *sess)
-{
-}
-
-void RemoveTCPChannels(GF_RTSPSession *sess)
-{
-	GF_TCPChan *ch;
-	while (gf_list_count(sess->TCPChannels)) {
-		ch = (GF_TCPChan*)gf_list_get(sess->TCPChannels, 0);
-		gf_free(ch);
-		gf_list_rem(sess->TCPChannels, 0);
-	}
-}
-
-
-GF_EXPORT
-void gf_rtsp_session_reset(GF_RTSPSession *sess, Bool ResetConnection)
-{
-	gf_mx_p(sess->mx);
-
-	sess->last_session_id = NULL;
-	sess->NeedConnection = 1;
-
-	if (ResetConnection) {
-		if (sess->connection) gf_sk_del(sess->connection);
-		sess->connection = NULL;
-		if (sess->http) {
-			gf_sk_del(sess->http);
-			sess->http = NULL;
-		}
-	}
-
-	sess->RTSP_State = GF_RTSP_STATE_INIT;
-//	sess->CSeq = sess->NbPending = 0;
-	sess->InterID = (u8) -1;
-	sess->pck_start = sess->payloadSize = 0;
-	sess->CurrentPos = sess->CurrentSize = 0;
-	strcpy(sess->RTSPLastRequest, "");
-	RemoveTCPChannels(sess);
-	gf_mx_v(sess->mx);
-}
-
-GF_EXPORT
-void gf_rtsp_session_del(GF_RTSPSession *sess)
-{
-	if (!sess) return;
-
-	gf_rtsp_session_reset(sess, GF_FALSE);
-
-	if (sess->connection) gf_sk_del(sess->connection);
-	if (sess->http) gf_sk_del(sess->http);
-	if (sess->Server) gf_free(sess->Server);
-	if (sess->Service) gf_free(sess->Service);
-	gf_list_del(sess->TCPChannels);
-	if (sess->rtsp_pck_buf) gf_free(sess->rtsp_pck_buf);
-	if (sess->MobileIP) gf_free(sess->MobileIP);
-	gf_mx_del(sess->mx);
-	gf_free(sess);
-}
-
-GF_EXPORT
-u32 gf_rtsp_get_session_state(GF_RTSPSession *sess)
-{
-	u32 state;
-	if (!sess) return GF_RTSP_STATE_INVALIDATED;
-
-	gf_mx_p(sess->mx);
-	state = sess->RTSP_State;
-	gf_mx_v(sess->mx);
-	return state;
-}
-
-GF_EXPORT
-void gf_rtsp_set_mobile_ip(GF_RTSPSession *sess, char *MobileIP)
-{
-	if (sess->MobileIP) gf_free(sess->MobileIP);
-	sess->MobileIP = NULL;
-	if (MobileIP) sess->MobileIP = gf_strdup(MobileIP);
-}
-
-
-GF_EXPORT
-char *gf_rtsp_get_last_request(GF_RTSPSession *sess)
-{
-	char *ret;
-	if (!sess) return NULL;
-	gf_mx_p(sess->mx);
-	ret = sess->RTSPLastRequest;
-	gf_mx_v(sess->mx);
-	return ret;
-}
-
-
-//check whether the url contains server and service name
-//no thread protection as this is const throughout the session
-GF_EXPORT
-u32 gf_rtsp_is_my_session(GF_RTSPSession *sess, char *url)
-{
-	if (!sess) return 0;
-	if (!strstr(url, sess->Server)) return 0;
-	//same url or sub-url
-	if (strstr(url, sess->Service)) return 1;
-	return 0;
-}
-
-GF_EXPORT
-const char *gf_rtsp_get_last_session_id(GF_RTSPSession *sess)
-{
-	if (!sess) return NULL;
-	return sess->last_session_id;
-}
-
-GF_EXPORT
-char *gf_rtsp_get_server_name(GF_RTSPSession *sess)
-{
-	if (!sess) return NULL;
-	return sess->Server;
-}
-
-GF_EXPORT
-char *gf_rtsp_get_service_name(GF_RTSPSession *sess)
-{
-	if (!sess) return NULL;
-	return sess->Service;
-}
-
-GF_EXPORT
-u16 gf_rtsp_get_session_port(GF_RTSPSession *sess)
-{
-	return (sess ? sess->Port : 0);
-}
-
-GF_Err gf_rtsp_check_connection(GF_RTSPSession *sess)
-{
-	GF_Err e;
-	//active, return
-	if (!sess->NeedConnection) return GF_OK;
-
-	//socket is destroyed, recreate
-	if (!sess->connection) {
-		sess->connection = gf_sk_new(sess->ConnectionType);
-		if (!sess->connection) return GF_OUT_OF_MEM;
-	}
-	//the session is down, reconnect
-	e = gf_sk_connect(sess->connection, sess->Server, sess->Port, sess->MobileIP);
-	if (e) return e;
-
-	if (sess->SockBufferSize) gf_sk_set_buffer_size(sess->connection, GF_FALSE, sess->SockBufferSize);
-
-	if (!sess->http && sess->HasTunnel) {
-		e = gf_rtsp_http_tunnel_start(sess, "toto is the king of RTSP");
-		if (e) return e;
-	}
-	sess->NeedConnection = 0;
-	return GF_OK;
-}
-
-
-GF_Err gf_rtsp_send_data(GF_RTSPSession *sess, char *buffer, u32 Size)
-{
-	GF_Err e;
-	u32 Size64;
-
-	e = gf_rtsp_check_connection(sess);
-	if (e) return e;
-
-	//RTSP requests on HTTP are base 64 encoded
-	if (sess->HasTunnel) {
-		char buf64[3000];
-		Size64 = gf_base64_encode(buffer, Size, buf64, 3000);
-		buf64[Size64] = 0;
-		//send on http connection
-		return gf_sk_send_wait(sess->http, buf64, Size64, 30);
-	} else {
-		return gf_sk_send(sess->connection, buffer, Size);
-	}
-}
-
-
-
-static GF_TCPChan *GetTCPChannel(GF_RTSPSession *sess, u8 rtpID, u8 rtcpID, Bool RemoveIt)
-{
-	GF_TCPChan *ptr;
-	u32 i, count = gf_list_count(sess->TCPChannels);
-	for (i=0; i<count; i++) {
-		ptr = (GF_TCPChan *)gf_list_get(sess->TCPChannels, i);
-		if (ptr->rtpID == rtpID) goto exit;;
-		if (ptr->rtcpID == rtcpID) goto exit;
-	}
-	return NULL;
-exit:
-	if (RemoveIt) gf_list_rem(sess->TCPChannels, i);
-	return ptr;
-}
-
-
-GF_Err gf_rtsp_set_deinterleave(GF_RTSPSession *sess)
-{
-	GF_TCPChan *ch;
-	Bool IsRTCP;
-	u8 InterID;
-	u16 paySize;
-	u32 res, Size;
-	char *buffer;
-
-	if (!sess) return GF_SERVICE_ERROR;
-
-	Size = sess->CurrentSize - sess->CurrentPos;
-	buffer = sess->TCPBuffer + sess->CurrentPos;
-
-	if (!Size) return GF_IP_NETWORK_EMPTY;
-
-	//we do not work with just a header -> force a refill
-	if (Size <= 4) return gf_rtsp_refill_buffer(sess);
-
-	//break if we get RTSP response on the wire
-	if (!strncmp(buffer, "RTSP", 4))
-		return GF_IP_NETWORK_EMPTY;
-
-	//new packet
-	if (!sess->pck_start && (buffer[0] == '$')) {
-		InterID = buffer[1];
-		paySize = ((buffer[2] << 8) & 0xFF00) | (buffer[3] & 0xFF);
-		/*this may be NULL (data fetched after a teardown) - resync and return*/
-		ch = GetTCPChannel(sess, InterID, InterID, GF_FALSE);
-
-		/*then check wether this is a full packet or a split*/
-		if (paySize <= Size-4) {
-			if (ch) {
-				IsRTCP = (ch->rtcpID == InterID) ? GF_TRUE : GF_FALSE;
-				sess->RTSP_SignalData(sess, ch->ch_ptr, buffer+4, paySize, IsRTCP);
-			}
-			sess->CurrentPos += paySize+4;
-			assert(sess->CurrentPos <= sess->CurrentSize);
-		} else {
-			/*missed end of pck ?*/
-			if (sess->payloadSize) {
-				GF_LOG(GF_LOG_DEBUG, GF_LOG_RTP, ("[RTP over RTSP] Missed end of packet (%d bytes) in stream %d\n", sess->payloadSize - sess->pck_start, sess->InterID));
-				ch = GetTCPChannel(sess, sess->InterID, sess->InterID, GF_FALSE);
-				if (ch) {
-					IsRTCP = (ch->rtcpID == sess->InterID) ? GF_TRUE : GF_FALSE;
-					sess->RTSP_SignalData(sess, ch->ch_ptr, sess->rtsp_pck_buf, sess->payloadSize, IsRTCP);
-				}
-			}
-			sess->InterID = InterID;
-			sess->payloadSize = paySize;
-			sess->pck_start = Size-4;
-			if (sess->rtsp_pck_size < paySize) {
-				sess->rtsp_pck_buf = (char *)gf_realloc(sess->rtsp_pck_buf, sizeof(char)*paySize);
-				sess->rtsp_pck_size = paySize;
-			}
-			memcpy(sess->rtsp_pck_buf, buffer+4, Size-4);
-			sess->CurrentPos += Size;
-			assert(sess->CurrentPos <= sess->CurrentSize);
-		}
-	}
-	/*end of packet*/
-	else if (sess->payloadSize - sess->pck_start <= Size) {
-//		GF_LOG(GF_LOG_DEBUG, GF_LOG_RTP, ("[RTP over RTSP] Missed beginning of packet (%d bytes) in stream %d\n", Size, sess->InterID));
-
-		res = sess->payloadSize - sess->pck_start;
-		memcpy(sess->rtsp_pck_buf + sess->pck_start, buffer, res);
-		//flush - same as above, don't complain if channel not found
-		ch = GetTCPChannel(sess, sess->InterID, sess->InterID, GF_FALSE);
-		if (ch) {
-			IsRTCP = (ch->rtcpID == sess->InterID) ? GF_TRUE : GF_FALSE;
-			sess->RTSP_SignalData(sess, ch->ch_ptr, sess->rtsp_pck_buf, sess->payloadSize, IsRTCP);
-		}
-		sess->payloadSize = 0;
-		sess->pck_start = 0;
-		sess->InterID = (u8) -1;
-		sess->CurrentPos += res;
-		assert(sess->CurrentPos <= sess->CurrentSize);
-	}
-	/*middle of packet*/
-	else {
-//		GF_LOG(GF_LOG_DEBUG, GF_LOG_RTP, ("[RTP over RTSP] Missed beginning of RTP packet in stream %d\n", sess->InterID));
-		memcpy(sess->rtsp_pck_buf + sess->pck_start, buffer, Size);
-		sess->pck_start += Size;
-		sess->CurrentPos += Size;
-		assert(sess->CurrentPos <= sess->CurrentSize);
-	}
-	return GF_OK;
-}
-
-
-
-
-
-
-
-
-/*
-		Exposed API, thread-safe
-*/
-
-GF_Err RTSP_ResetInterleaving(GF_RTSPSession *sess, Bool ResetChannels)
-{
-	if (!sess) return GF_BAD_PARAM;
-
-	gf_mx_p(sess->mx);
-	sess->payloadSize = 0;
-	sess->pck_start = 0;
-	sess->InterID = (u8) -1;
-	if (ResetChannels) RemoveTCPChannels(sess);
-	gf_mx_v(sess->mx);
-
-	return GF_OK;
-}
-
-
-GF_EXPORT
-GF_Err gf_rtsp_session_read(GF_RTSPSession *sess)
-{
-	GF_Err e;
-	if (!sess) return GF_BAD_PARAM;
-
-	gf_mx_p(sess->mx);
-	e = gf_rtsp_fill_buffer(sess);
-	if (!e) {
-		//only read if not RTSP
-		while (1) {
-			e = gf_rtsp_set_deinterleave(sess);
-			if (e) break;
-		}
-	}
-	gf_mx_v(sess->mx);
-	return e;
-}
-
-
-GF_EXPORT
-u32 gf_rtsp_unregister_interleave(GF_RTSPSession *sess, u8 LowInterID)
-{
-	GF_TCPChan *ptr;
-
-	gf_mx_p(sess->mx);
-	ptr = GetTCPChannel(sess, LowInterID, LowInterID, GF_TRUE);
-	if (ptr) gf_free(ptr);
-	gf_mx_v(sess->mx);
-	return gf_list_count(sess->TCPChannels);
-}
-
-GF_EXPORT
-GF_Err gf_rtsp_register_interleave(GF_RTSPSession *sess, void *the_ch, u8 LowInterID, u8 HighInterID)
-{
-	GF_TCPChan *ptr;
-
-	if (!sess) return GF_BAD_PARAM;
-
-	gf_mx_p(sess->mx);
-	//do NOT register twice
-	ptr = GetTCPChannel(sess, LowInterID, HighInterID, GF_FALSE);
-	if (!ptr) {
-		ptr = (GF_TCPChan *)gf_malloc(sizeof(GF_TCPChan));
-		ptr->ch_ptr = the_ch;
-		ptr->rtpID = LowInterID;
-		ptr->rtcpID = HighInterID;
-		gf_list_add(sess->TCPChannels, ptr);
-	}
-	gf_mx_v(sess->mx);
-	return GF_OK;
-}
-
-
-GF_EXPORT
-GF_Err gf_rtsp_set_interleave_callback(GF_RTSPSession *sess,
-                                       GF_Err (*SignalData)(GF_RTSPSession *sess, void *chan, char *buffer, u32 bufferSize, Bool IsRTCP)
-                                      )
-{
-	if (!sess) return GF_BAD_PARAM;
-
-	gf_mx_p(sess->mx);
-
-	//only if existing
-	if (SignalData) sess->RTSP_SignalData = SignalData;
-
-	//gf_realloc or alloc
-	if (sess->rtsp_pck_buf && sess->rtsp_pck_size != RTSP_PCK_SIZE) {
-		sess->rtsp_pck_size = RTSP_PCK_SIZE;
-		sess->rtsp_pck_buf = (char *)gf_realloc(sess->rtsp_pck_buf, sizeof(char)*sess->rtsp_pck_size);
-	} else if (!sess->rtsp_pck_buf) {
-		sess->rtsp_pck_size = RTSP_PCK_SIZE;
-		sess->rtsp_pck_buf = (char *)gf_realloc(sess->rtsp_pck_buf, sizeof(char)*sess->rtsp_pck_size);
-		sess->pck_start = 0;
-	}
-	gf_mx_v(sess->mx);
-	return GF_OK;
-}
-
-GF_EXPORT
-GF_Err gf_rtsp_set_buffer_size(GF_RTSPSession *sess, u32 BufferSize)
-{
-	if (!sess) return GF_BAD_PARAM;
-	sess->SockBufferSize = BufferSize;
-	return GF_OK;
-}
-
-
-static Bool HTTP_RandInit = GF_TRUE;
-
-#define HTTP_WAIT_SEC		30
-
-#define HTTP_RSP_OK	"HTTP/1.0 200 OK"
-
-
-void RTSP_GenerateHTTPCookie(GF_RTSPSession *sess)
-{
-	u32 i, num, temp;
-
-	if (HTTP_RandInit) {
-		gf_rand_init(GF_FALSE);
-		HTTP_RandInit = GF_FALSE;
-	}
-	if (!sess->CookieRadLen) {
-		strcpy(sess->HTTP_Cookie, "MPEG4M4");
-		sess->CookieRadLen = 8;
-	}
-	num = gf_rand();
-	for (i=0; i < 8; i++) {
-		temp = (num >> (i * 4)) & 0x0f;
-		sess->HTTP_Cookie[sess->CookieRadLen + i] = (u8) temp + sess->HTTP_Cookie[0];
-	}
-	sess->HTTP_Cookie[sess->CookieRadLen + i] = 0;
-}
-
-
-
-
-//http tunnelling start.
-GF_Err gf_rtsp_http_tunnel_start(GF_RTSPSession *sess, char *UserAgent)
-{
-	GF_Err e;
-	u32 size;
-	s32 pos;
-	char buffer[GF_RTSP_DEFAULT_BUFFER];
-
-	RTSP_GenerateHTTPCookie(sess);
-
-	//  1. send "GET /sample.mov HTTP/1.0\r\n ..."
-	memset(buffer, 0, GF_RTSP_DEFAULT_BUFFER);
-	pos = 0;
-	pos += sprintf(buffer + pos, "GET /%s HTTP/1.0\r\n", sess->Service);
-	pos += sprintf(buffer + pos, "User-Agent: %s\r\n", UserAgent);
-	pos += sprintf(buffer + pos, "x-sessioncookie: %s\r\n", sess->HTTP_Cookie);
-	pos += sprintf(buffer + pos, "Accept: application/x-rtsp-tunnelled\r\n" );
-	pos += sprintf(buffer + pos, "Pragma: no-cache\r\n" );
-	pos += sprintf(buffer + pos, "Cache-Control: no-cache\r\n\r\n" );
-
-	//	send it!
-	e = gf_sk_send_wait(sess->connection, buffer, (u32) strlen(buffer), HTTP_WAIT_SEC);
-	if (e) return e;
-
-	//	2. wait for "HTTP/1.0 200 OK"
-	e = gf_sk_receive_wait(sess->connection, buffer, GF_RTSP_DEFAULT_BUFFER, 0, &size, HTTP_WAIT_SEC);
-	if (e) return e;
-
-	//get HTTP/1.0 200 OK
-	if (strncmp(buffer, HTTP_RSP_OK, strlen(HTTP_RSP_OK)))
-		return GF_REMOTE_SERVICE_ERROR;
-
-	//	3. send "POST /sample.mov HTTP/1.0\r\n ..."
-	sess->http = gf_sk_new(GF_SOCK_TYPE_TCP);
-	if (!sess->http ) return GF_IP_NETWORK_FAILURE;
-
-	/*mobileIP is enabled, bind first*/
-	if (gf_sk_connect(sess->http, sess->Server, sess->Port, sess->MobileIP)) return GF_IP_CONNECTION_FAILURE;
-
-	memset(buffer, 0, GF_RTSP_DEFAULT_BUFFER);
-	pos = 0;
-	pos += sprintf(buffer + pos, "POST /%s HTTP/1.0\r\n", sess->Service);
-	pos += sprintf(buffer + pos, "User-Agent: %s\r\n", UserAgent);
-	pos += sprintf(buffer + pos, "x-sessioncookie: %s\r\n", sess->HTTP_Cookie);
-	pos += sprintf(buffer + pos, "Accept: application/x-rtsp-tunnelled\r\n");
-	pos += sprintf(buffer + pos, "Pragma: no-cache\r\n");
-	pos += sprintf(buffer + pos, "Cache-Control: no-cache\r\n");
-	pos += sprintf(buffer + pos, "Content-Length: 32767\r\n");
-	pos += sprintf(buffer + pos, "Expires: Sun. 9 Jan 1972 00:00:00 GMT\r\n\r\n");
-
-	//	send it!
-	e = gf_sk_send_wait(sess->http, buffer, (u32) strlen(buffer), HTTP_WAIT_SEC);
-
-	return e;
-}
-
-
-/*server-side RTSP sockets*/
-
-static u32 SessionID_RandInit = 0;
-
-
-GF_EXPORT
-GF_RTSPSession *gf_rtsp_session_new_server(GF_Socket *rtsp_listener)
-{
-	GF_RTSPSession *sess;
-	GF_Socket *new_conn;
-	GF_Err e;
-	u32 fam;
-	u16 port;
-	char name[GF_MAX_IP_NAME_LEN];
-
-	if (!rtsp_listener) return NULL;
-
-
-	e = gf_sk_accept(rtsp_listener, &new_conn);
-	if (!new_conn || e) return NULL;
-
-	e = gf_sk_get_local_info(new_conn, &port, &fam);
-	if (e) {
-		gf_sk_del(new_conn);
-		return NULL;
-	}
-	e = gf_sk_set_block_mode(new_conn, GF_TRUE);
-	if (e) {
-		gf_sk_del(new_conn);
-		return NULL;
-	}
-	e = gf_sk_server_mode(new_conn, GF_TRUE);
-	if (e) {
-		gf_sk_del(new_conn);
-		return NULL;
-	}
-
-	//OK create a new session
-	GF_SAFEALLOC(sess, GF_RTSPSession);
-
-	sess->connection = new_conn;
-	sess->Port = port;
-	sess->ConnectionType = fam;
-	gf_sk_get_host_name(name);
-	sess->Server = gf_strdup(name);
-
-	sess->TCPChannels = gf_list_new();
-	return sess;
-}
-
-
-GF_EXPORT
-GF_Err gf_rtsp_load_service_name(GF_RTSPSession *sess, char *URL)
-{
-	char server[1024], service[1024];
-	GF_Err e;
-	u16 Port;
-	Bool UseTCP;
-	u32 type;
-
-	if (!sess || !URL) return GF_BAD_PARAM;
-	e = RTSP_UnpackURL(URL, server, &Port, service, &UseTCP);
-	if (e) return e;
-
-	type = UseTCP ? GF_SOCK_TYPE_TCP : GF_SOCK_TYPE_UDP;
-	//check the network type matches, otherwise deny client
-	if (sess->ConnectionType != type) return GF_URL_ERROR;
-	if (sess->Port != Port) return GF_URL_ERROR;
-
-	//ok
-	sess->Server = gf_strdup(server);
-	sess->Service = gf_strdup(service);
-	return GF_OK;
-}
-
-
-GF_EXPORT
-char *gf_rtsp_generate_session_id(GF_RTSPSession *sess)
-{
-	u32 one;
-	u64 res;
-	char buffer[30];
-
-	if (!sess) return NULL;
-
-	if (!SessionID_RandInit) {
-		SessionID_RandInit = 1;
-		gf_rand_init(GF_FALSE);
-	}
-	one = gf_rand();
-	res = one;
-	res <<= 32;
-	res+= (PTR_TO_U_CAST sess) + sess->CurrentPos + sess->CurrentSize;
-	sprintf(buffer, LLU, res);
-	return gf_strdup(buffer);
-}
-
-
-GF_EXPORT
-GF_Err gf_rtsp_get_session_ip(GF_RTSPSession *sess, char *buffer)
-{
-	if (!sess || !sess->connection) return GF_BAD_PARAM;
-	gf_sk_get_local_ip(sess->connection, buffer);
-	return GF_OK;
-}
-
-
-GF_EXPORT
-u8 gf_rtsp_get_next_interleave_id(GF_RTSPSession *sess)
-{
-	u32 i;
-	u8 id;
-	GF_TCPChan *ch;
-	id = 0;
-	i=0;
-	while ((ch = (GF_TCPChan *)gf_list_enum(sess->TCPChannels, &i))) {
-		if (ch->rtpID >= id) id = ch->rtpID + 1;
-		if (ch->rtcpID >= id) id = ch->rtcpID + 1;
-	}
-	return id;
-}
-
-
-GF_EXPORT
-GF_Err gf_rtsp_get_remote_address(GF_RTSPSession *sess, char *buf)
-{
-	if (!sess || !sess->connection) return GF_BAD_PARAM;
-	return gf_sk_get_remote_address(sess->connection, buf);
-}
-
-#endif /*GPAC_DISABLE_STREAMING*/
diff --git a/src/ietfPsdp.c b/src/ietfPsdp.c
deleted file mode 100644
index c3065e07e..000000000
--- a/src/ietfPsdp.c
+++ /dev/null
@@ -1,1162 +0,0 @@
-/*
- *			GPAC - Multimedia Framework C SDK
- *
- *			Authors: Jean Le Feuvre
- *			Copyright (c) Telecom ParisTech 2000-2012
- *					All rights reserved
- *
- *  This file is part of GPAC / IETF RTP/RTSP/SDP sub-project
- *
- *  GPAC is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU Lesser General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  GPAC is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-
-
-#include <gpac/ietf.h>
-
-#ifndef GPAC_DISABLE_STREAMING
-
-#include <gpac/token.h>
-
-
-#define SDP_WRITE_STEPALLOC		2048
-
-
-GF_EXPORT
-GF_SDP_FMTP *gf_sdp_fmtp_new()
-{
-	GF_SDP_FMTP *tmp = (GF_SDP_FMTP*)gf_malloc(sizeof(GF_SDP_FMTP));
-	tmp->PayloadType = 0;
-	tmp->Attributes = gf_list_new();
-	return tmp;
-}
-
-GF_EXPORT
-void gf_sdp_fmtp_del(GF_SDP_FMTP *fmtp)
-{
-	GF_X_Attribute *att;
-	if (!fmtp) return;
-	while (gf_list_count(fmtp->Attributes)) {
-		att = (GF_X_Attribute*)gf_list_get(fmtp->Attributes, 0);
-		gf_list_rem(fmtp->Attributes, 0);
-		if (att->Name) gf_free(att->Name);
-		if (att->Value) gf_free(att->Value);
-		gf_free(att);
-	}
-	gf_list_del(fmtp->Attributes);
-	gf_free(fmtp);
-}
-
-GF_SDP_FMTP *SDP_GetFMTPForPayload(GF_SDPMedia *media, u32 PayloadType)
-{
-	GF_SDP_FMTP *tmp;
-	u32 i;
-	if (!media) return NULL;
-	i=0;
-	while ((tmp = (GF_SDP_FMTP*)gf_list_enum(media->FMTP, &i))) {
-		if (tmp->PayloadType == PayloadType) return tmp;
-	}
-	return NULL;
-}
-
-void SDP_ParseAttribute(GF_SDPInfo *sdp, char *buffer, GF_SDPMedia *media)
-{
-	s32 pos;
-	u32 PayT;
-	char comp[3000];
-	GF_RTPMap *map;
-	GF_SDP_FMTP *fmtp;
-	GF_X_Attribute *att;
-
-	pos = gf_token_get(buffer, 0, " :\t\r\n", comp, 3000);
-
-	if (!strcmp(comp, "cat")) {
-		if (media) return;
-		pos = gf_token_get(buffer, pos, ":\t\r\n", comp, 3000);
-		sdp->a_cat = gf_strdup(comp);
-		return;
-	}
-	if (!strcmp(comp, "keywds")) {
-		if (media) return;
-		pos = gf_token_get(buffer, pos, ":\t\r\n", comp, 3000);
-		sdp->a_keywds = gf_strdup(comp);
-		return;
-	}
-	if (!strcmp(comp, "tool")) {
-		if (media) return;
-		pos = gf_token_get(buffer, pos, ":\r\n", comp, 3000);
-		sdp->a_tool = gf_strdup(comp);
-		return;
-	}
-
-	if (!strcmp(comp, "ptime")) {
-		if (!media) return;
-		pos = gf_token_get(buffer, pos, ":\r\n", comp, 3000);
-		media->PacketTime = atoi(comp);
-		return;
-	}
-	if (!strcmp(comp, "recvonly")) {
-		if (!media) {
-			sdp->a_SendReceive = 1;
-		} else {
-			media->SendReceive = 1;
-		}
-		return;
-	}
-	if (!strcmp(comp, "sendonly")) {
-		if (!media) {
-			sdp->a_SendReceive = 2;
-		} else {
-			media->SendReceive = 2;
-		}
-		return;
-	}
-	if (!strcmp(comp, "sendrecv")) {
-		if (!media) {
-			sdp->a_SendReceive = 3;
-		} else {
-			media->SendReceive = 3;
-		}
-		return;
-	}
-	if (!strcmp(comp, "orient")) {
-		if (!media || media->Type) return;
-		pos = gf_token_get(buffer, pos, ":\r\n", comp, 3000);
-		media->orientation = gf_strdup(comp);
-		return;
-	}
-	if (!strcmp(comp, "type")) {
-		if (media) return;
-		pos = gf_token_get(buffer, pos, ":\r\n", comp, 3000);
-		sdp->a_type = gf_strdup(comp);
-		return;
-	}
-	if (!strcmp(comp, "charset")) {
-		if (media) return;
-		pos = gf_token_get(buffer, pos, ":\r\n", comp, 3000);
-		sdp->a_charset = gf_strdup(comp);
-		return;
-	}
-	if (!strcmp(comp, "sdplang")) {
-		pos = gf_token_get(buffer, pos, ":\r\n", comp, 3000);
-		if (media) {
-			media->sdplang = gf_strdup(comp);
-		} else {
-			sdp->a_sdplang = gf_strdup(comp);
-		}
-		return;
-	}
-	if (!strcmp(comp, "lang")) {
-		pos = gf_token_get(buffer, pos, ":\r\n", comp, 3000);
-		if (media) {
-			media->lang = gf_strdup(comp);
-		} else {
-			sdp->a_lang = gf_strdup(comp);
-		}
-		return;
-	}
-	if (!strcmp(comp, "framerate")) {
-		//only for video
-		if (!media || (media->Type != 1)) return;
-		pos = gf_token_get(buffer, pos, ":\r\n", comp, 3000);
-		media->FrameRate = atof(comp);
-		return;
-	}
-	if (!strcmp(comp, "quality")) {
-		if (!media) return;
-		pos = gf_token_get(buffer, pos, ":\r\n", comp, 3000);
-		media->Quality = atoi(comp);
-		return;
-	}
-	if (!strcmp(comp, "rtpmap")) {
-		if (!media) return;
-		map = (GF_RTPMap*)gf_malloc(sizeof(GF_RTPMap));
-		pos = gf_token_get(buffer, pos, ": \r\n", comp, 3000);
-		map->PayloadType = atoi(comp);
-		pos = gf_token_get(buffer, pos, " /\r\n", comp, 3000);
-		map->payload_name = gf_strdup(comp);
-		pos = gf_token_get(buffer, pos, " /\r\n", comp, 3000);
-		map->ClockRate = atoi(comp);
-		pos = gf_token_get(buffer, pos, " /\r\n", comp, 3000);
-		map->AudioChannels = (pos > 0) ? atoi(comp) : 0;
-		gf_list_add(media->RTPMaps, map);
-		return;
-	}
-	//FMTP
-	if (!strcmp(comp, "fmtp")) {
-		if (!media) return;
-		pos = gf_token_get(buffer, pos, ": \r\n", comp, 3000);
-		PayT = atoi(comp);
-		fmtp = SDP_GetFMTPForPayload(media, PayT);
-		if (!fmtp) {
-			fmtp = gf_sdp_fmtp_new();
-			fmtp->PayloadType = PayT;
-			gf_list_add(media->FMTP, fmtp);
-		}
-		while (1) {
-			pos = gf_token_get(buffer, pos, "; =\r\n", comp, 3000);
-			if (pos <= 0) break;
-			att = (GF_X_Attribute*)gf_malloc(sizeof(GF_X_Attribute));
-			att->Name = gf_strdup(comp);
-			att->Value = NULL;
-			pos ++;
-			pos = gf_token_get(buffer, pos, ";\r\n", comp, 3000);
-			if (pos > 0) att->Value = gf_strdup(comp);
-			gf_list_add(fmtp->Attributes, att);
-		}
-		return;
-	}
-	//the rest cannot be discarded that way as it may be application-specific
-	//so keep it.
-	//a= <attribute> || <attribute>:<value>
-	//we add <attribute> <value> in case ...
-	pos = gf_token_get(buffer, 0, " :\r\n", comp, 3000);
-	att = (GF_X_Attribute*)gf_malloc(sizeof(GF_X_Attribute));
-	att->Name = gf_strdup(comp);
-	att->Value = NULL;
-	pos += 1;
-	if (buffer[pos] == ' ') pos += 1;
-	pos = gf_token_get(buffer, pos, "\r\n", comp, 3000);
-	if (pos > 0) att->Value = gf_strdup(comp);
-
-	if (media) {
-		gf_list_add(media->Attributes, att);
-	} else {
-		gf_list_add(sdp->Attributes, att);
-	}
-}
-
-
-
-#define SDPM_DESTROY(p) if (media->p) gf_free(media->p)
-GF_EXPORT
-void gf_sdp_media_del(GF_SDPMedia *media)
-{
-	GF_SDPBandwidth *bw;
-	GF_RTPMap *map;
-	GF_SDPConnection *conn;
-	GF_SDP_FMTP *fmtp;
-	GF_X_Attribute *att;
-	if (!media) return;
-
-	while (gf_list_count(media->FMTP)) {
-		fmtp = (GF_SDP_FMTP*)gf_list_get(media->FMTP, 0);
-		gf_list_rem(media->FMTP, 0);
-		gf_sdp_fmtp_del(fmtp);
-	}
-	gf_list_del(media->FMTP);
-
-	while (gf_list_count(media->Attributes)) {
-		att = (GF_X_Attribute*)gf_list_get(media->Attributes, 0);
-		gf_list_rem(media->Attributes, 0);
-		if (att->Name) gf_free(att->Name);
-		if (att->Value) gf_free(att->Value);
-		gf_free(att);
-	}
-	gf_list_del(media->Attributes);
-
-	while (gf_list_count(media->RTPMaps)) {
-		map = (GF_RTPMap*)gf_list_get(media->RTPMaps, 0);
-		gf_free(map->payload_name);
-		gf_free(map);
-		gf_list_rem(media->RTPMaps, 0);
-	}
-	gf_list_del(media->RTPMaps);
-
-	while (gf_list_count(media->Connections)) {
-		conn = (GF_SDPConnection*)gf_list_get(media->Connections, 0);
-		gf_list_rem(media->Connections, 0);
-		gf_sdp_conn_del(conn);
-	}
-	gf_list_del(media->Connections);
-
-	while (gf_list_count(media->Bandwidths)) {
-		bw = (GF_SDPBandwidth*)gf_list_get(media->Bandwidths, 0);
-		gf_list_rem(media->Bandwidths, 0);
-		if (bw->name) gf_free(bw->name);
-		gf_free(bw);
-	}
-	gf_list_del(media->Bandwidths);
-
-	SDPM_DESTROY(orientation);
-	SDPM_DESTROY(sdplang);
-	SDPM_DESTROY(lang);
-	SDPM_DESTROY(Profile);
-	SDPM_DESTROY(fmt_list);
-	SDPM_DESTROY(k_method);
-	SDPM_DESTROY(k_key);
-	gf_free(media);
-}
-
-
-GF_EXPORT
-GF_SDPConnection *gf_sdp_conn_new()
-{
-	GF_SDPConnection *conn;
-	GF_SAFEALLOC(conn, GF_SDPConnection);
-	conn->TTL = -1;
-	return conn;
-}
-
-GF_EXPORT
-void gf_sdp_conn_del(GF_SDPConnection *conn)
-{
-	if (conn->add_type) gf_free(conn->add_type);
-	if (conn->host) gf_free(conn->host);
-	if (conn->net_type) gf_free(conn->net_type);
-	gf_free(conn);
-}
-
-GF_EXPORT
-GF_SDPMedia *gf_sdp_media_new()
-{
-	GF_SDPMedia *tmp;
-	GF_SAFEALLOC(tmp, GF_SDPMedia);
-	tmp->FMTP = gf_list_new();
-	tmp->RTPMaps = gf_list_new();
-	tmp->Attributes = gf_list_new();
-	tmp->Connections = gf_list_new();
-	tmp->Bandwidths = gf_list_new();
-	tmp->Quality = -1;
-	return tmp;
-}
-
-GF_EXPORT
-GF_SDPInfo *gf_sdp_info_new()
-{
-	GF_SDPInfo *sdp;
-	GF_SAFEALLOC(sdp, GF_SDPInfo);
-	sdp->b_bandwidth = gf_list_new();
-	sdp->media_desc = gf_list_new();
-	sdp->Attributes = gf_list_new();
-	sdp->Timing = gf_list_new();
-	return sdp;
-}
-
-#define SDP_DESTROY(p) if (sdp->p)	\
-					gf_free(sdp->p);	\
-					sdp->p = NULL;
-
-
-GF_EXPORT
-void gf_sdp_info_reset(GF_SDPInfo *sdp)
-{
-	GF_SDPBandwidth *bw;
-	GF_SDPMedia *media;
-	GF_SDPTiming *timing;
-	GF_X_Attribute *att;
-
-	if (!sdp) return;
-
-	while (gf_list_count(sdp->media_desc)) {
-		media = (GF_SDPMedia*)gf_list_get(sdp->media_desc, 0);
-		gf_list_rem(sdp->media_desc, 0);
-		gf_sdp_media_del(media);
-	}
-	while (gf_list_count(sdp->Attributes)) {
-		att = (GF_X_Attribute*)gf_list_get(sdp->Attributes, 0);
-		gf_list_rem(sdp->Attributes, 0);
-		if (att->Name) gf_free(att->Name);
-		if (att->Value) gf_free(att->Value);
-		gf_free(att);
-	}
-	while (gf_list_count(sdp->b_bandwidth)) {
-		bw = (GF_SDPBandwidth*)gf_list_get(sdp->b_bandwidth, 0);
-		gf_list_rem(sdp->b_bandwidth, 0);
-		if (bw->name) gf_free(bw->name);
-		gf_free(bw);
-	}
-	while (gf_list_count(sdp->Timing)) {
-		timing = (GF_SDPTiming*)gf_list_get(sdp->Timing, 0);
-		gf_list_rem(sdp->Timing, 0);
-		gf_free(timing);
-	}
-
-	//then delete all info ...
-	SDP_DESTROY(o_username);
-	SDP_DESTROY(o_session_id);
-	SDP_DESTROY(o_version);
-	SDP_DESTROY(o_address);
-	SDP_DESTROY(o_net_type);
-	SDP_DESTROY(o_add_type);
-	SDP_DESTROY(s_session_name);
-	SDP_DESTROY(i_description);
-	SDP_DESTROY(u_uri);
-	SDP_DESTROY(e_email);
-	SDP_DESTROY(p_phone);
-	SDP_DESTROY(k_method);
-	SDP_DESTROY(k_key);
-	SDP_DESTROY(a_cat);
-	SDP_DESTROY(a_keywds);
-	SDP_DESTROY(a_tool);
-	SDP_DESTROY(a_type);
-	SDP_DESTROY(a_charset);
-	SDP_DESTROY(a_sdplang);
-	SDP_DESTROY(a_lang);
-
-	if (sdp->c_connection) {
-		gf_sdp_conn_del(sdp->c_connection);
-		sdp->c_connection = NULL;
-	}
-	sdp->a_SendReceive = 0;
-}
-
-GF_EXPORT
-void gf_sdp_info_del(GF_SDPInfo *sdp)
-{
-	if (!sdp) return;
-	gf_sdp_info_reset(sdp);
-	gf_list_del(sdp->media_desc);
-	gf_list_del(sdp->Attributes);
-	gf_list_del(sdp->b_bandwidth);
-	gf_list_del(sdp->Timing);
-	gf_free(sdp);
-}
-
-
-Bool SDP_IsDynamicPayload(GF_SDPMedia *media, char *payt)
-{
-	u32 i;
-	GF_RTPMap *map;
-	char buf[10];
-	i=0;
-	while ((map = (GF_RTPMap*)gf_list_enum(media->RTPMaps, &i))) {
-		sprintf(buf, "%d", map->PayloadType);
-		if (!strcmp(payt, buf)) return GF_TRUE;
-	}
-	return GF_FALSE;
-}
-
-//translate h || m || d in sec. Fractions are not allowed with this writing
-s32 SDP_MakeSeconds(char *buf)
-{
-	s32 sign;
-	char num[30], *test;
-	sign = 1;
-	if (buf[0] == '-') {
-		sign = -1;
-		buf += 1;
-	}
-	memset(num, 0, 30);
-	test = strstr(buf, "d");
-	if (test) {
-		assert(strlen(buf)-strlen(test) < sizeof(num));
-		strncpy(num, buf, strlen(buf)-strlen(test));
-		return (atoi(num)*sign*86400);
-	}
-	test = strstr(buf, "h");
-	if (test) {
-		assert(strlen(buf)-strlen(test) < sizeof(num));
-		strncpy(num, buf, strlen(buf)-strlen(test));
-		return (atoi(num)*sign*3600);
-	}
-	test = strstr(buf, "m");
-	if (test) {
-		assert(strlen(buf)-strlen(test) < sizeof(num));
-		strncpy(num, buf, strlen(buf)-strlen(test));
-		return (atoi(num)*sign*60);
-	}
-	return (atoi(buf) * sign);
-}
-
-
-GF_EXPORT
-GF_Err gf_sdp_info_parse(GF_SDPInfo *sdp, char *sdp_text, u32 text_size)
-{
-	GF_SDPBandwidth *bw;
-	GF_SDPConnection *conn;
-	GF_SDPMedia *media;
-	GF_SDPTiming *timing;
-	u32 i;
-	s32 pos, LinePos;
-	char LineBuf[3000], comp[3000];
-
-	media = NULL;
-	timing = NULL;
-
-	if (!sdp) return GF_BAD_PARAM;
-
-	//Clean SDP info
-	gf_sdp_info_reset(sdp);
-
-	LinePos = 0;
-	while (1) {
-		LinePos = gf_token_get_line(sdp_text, LinePos, text_size, LineBuf, 3000);
-		if (LinePos <= 0) break;
-		if (!strcmp(LineBuf, "\r\n") || !strcmp(LineBuf, "\n") || !strcmp(LineBuf, "\r")) continue;
-
-
-		switch (LineBuf[0]) {
-		case 'v':
-			pos = gf_token_get(LineBuf, 2, "\t\r\n", comp, 3000);
-			sdp->Version = atoi(comp);
-			break;
-		case 'o':
-			pos = gf_token_get(LineBuf, 2, " \t\r\n", comp, 3000);
-			sdp->o_username = gf_strdup(comp);
-			pos = gf_token_get(LineBuf, pos, " \t\r\n", comp, 3000);
-			sdp->o_session_id = gf_strdup(comp);
-			pos = gf_token_get(LineBuf, pos, " \t\r\n", comp, 3000);
-			sdp->o_version = gf_strdup(comp);
-
-			pos = gf_token_get(LineBuf, pos, " \t\r\n", comp, 3000);
-			sdp->o_net_type = gf_strdup(comp);
-
-			pos = gf_token_get(LineBuf, pos, " \t\r\n", comp, 3000);
-			sdp->o_add_type = gf_strdup(comp);
-
-			pos = gf_token_get(LineBuf, pos, " \t\r\n", comp, 3000);
-			sdp->o_address = gf_strdup(comp);
-			break;
-		case 's':
-			pos = gf_token_get(LineBuf, 2, "\t\r\n", comp, 3000);
-			sdp->s_session_name = gf_strdup(comp);
-			break;
-		case 'i':
-			pos = gf_token_get(LineBuf, 2, "\t\r\n", comp, 3000);
-			sdp->i_description = gf_strdup(comp);
-			break;
-		case 'u':
-			pos = gf_token_get(LineBuf, 2, "\t\r\n", comp, 3000);
-			sdp->u_uri = gf_strdup(comp);
-			break;
-		case 'e':
-			pos = gf_token_get(LineBuf, 2, "\t\r\n", comp, 3000);
-			sdp->e_email = gf_strdup(comp);
-			break;
-		case 'p':
-			pos = gf_token_get(LineBuf, 2, "\t\r\n", comp, 3000);
-			sdp->p_phone = gf_strdup(comp);
-			break;
-		case 'c':
-			//if at session level, only 1 is allowed for all SDP
-			if (sdp->c_connection) break;
-
-			conn = gf_sdp_conn_new();
-
-			pos = gf_token_get(LineBuf, 2, " \t\r\n", comp, 3000);
-			conn->net_type = gf_strdup(comp);
-
-			pos = gf_token_get(LineBuf, pos, " \t\r\n", comp, 3000);
-			conn->add_type = gf_strdup(comp);
-
-			pos = gf_token_get(LineBuf, pos, " /\r\n", comp, 3000);
-			conn->host = gf_strdup(comp);
-			if (gf_sk_is_multicast_address(conn->host)) {
-				//a valid SDP will have TTL if address is multicast
-				pos = gf_token_get(LineBuf, pos, "/\r\n", comp, 3000);
-				if (pos > 0) {
-					conn->TTL = atoi(comp);
-					//multiple address indication is only valid for media
-					pos = gf_token_get(LineBuf, pos, "/\r\n", comp, 3000);
-				}
-				if (pos > 0) {
-					if (!media) {
-						gf_sdp_conn_del(conn);
-						break;
-					}
-					conn->add_count = atoi(comp);
-				}
-			}
-			if (!media)
-				sdp->c_connection = conn;
-			else
-				gf_list_add(media->Connections, conn);
-
-			break;
-		case 'b':
-			pos = gf_token_get(LineBuf, 2, ":\r\n", comp, 3000);
-			if (strcmp(comp, "CT") && strcmp(comp, "AS") && (comp[0] != 'X')) break;
-
-			bw = (GF_SDPBandwidth*)gf_malloc(sizeof(GF_SDPBandwidth));
-			bw->name = gf_strdup(comp);
-			pos = gf_token_get(LineBuf, pos, ":\r\n", comp, 3000);
-			bw->value = atoi(comp);
-			if (media) {
-				gf_list_add(media->Bandwidths, bw);
-			} else {
-				gf_list_add(sdp->b_bandwidth, bw);
-			}
-			break;
-
-		case 't':
-			if (media) break;
-			//create a new time structure for each entry
-			GF_SAFEALLOC(timing, GF_SDPTiming);
-			pos = gf_token_get(LineBuf, 2, " \t\r\n", comp, 3000);
-			timing->StartTime = atoi(comp);
-			pos = gf_token_get(LineBuf, pos, "\r\n", comp, 3000);
-			timing->StopTime = atoi(comp);
-			gf_list_add(sdp->Timing, timing);
-			break;
-		case 'r':
-			if (media) break;
-			pos = gf_token_get(LineBuf, 2, " \t\r\n", comp, 3000);
-			timing->RepeatInterval = SDP_MakeSeconds(comp);
-			pos = gf_token_get(LineBuf, pos, " \t\r\n", comp, 3000);
-			timing->ActiveDuration = SDP_MakeSeconds(comp);
-			while (1) {
-				pos = gf_token_get(LineBuf, pos, " \t\r\n", comp, 3000);
-				if (pos <= 0) break;
-				timing->OffsetFromStart[timing->NbRepeatOffsets] = SDP_MakeSeconds(comp);
-				timing->NbRepeatOffsets += 1;
-			}
-			break;
-		case 'z':
-			if (media) break;
-			pos = 2;
-			while (1) {
-				pos = gf_token_get(LineBuf, pos, " \t\r\n", comp, 3000);
-				if (pos <= 0) break;
-				timing->AdjustmentTime[timing->NbZoneOffsets] = atoi(comp);
-				pos = gf_token_get(LineBuf, pos, " \t\r\n", comp, 3000);
-				timing->AdjustmentOffset[timing->NbZoneOffsets] = SDP_MakeSeconds(comp);
-				timing->NbZoneOffsets += 1;
-			}
-			break;
-		case 'k':
-			pos = gf_token_get(LineBuf, 2, ":\t\r\n", comp, 3000);
-			if (media) {
-				media->k_method = gf_strdup(comp);
-			} else {
-				sdp->k_method = gf_strdup(comp);
-			}
-			pos = gf_token_get(LineBuf, pos, ":\r\n", comp, 3000);
-			if (pos > 0) {
-				if (media) {
-					media->k_key = gf_strdup(comp);
-				} else {
-					sdp->k_key = gf_strdup(comp);
-				}
-			}
-			break;
-		case 'a':
-			SDP_ParseAttribute(sdp, LineBuf+2, media);
-			break;
-		case 'm':
-			pos = gf_token_get(LineBuf, 2, " \t\r\n", comp, 3000);
-			if (strcmp(comp, "audio")
-			        && strcmp(comp, "data")
-			        && strcmp(comp, "control")
-			        && strcmp(comp, "video")
-			        && strcmp(comp, "text")
-			        && strcmp(comp, "application")) {
-				return GF_SERVICE_ERROR;
-			}
-			media = gf_sdp_media_new();
-			//media type
-			if (!strcmp(comp, "video")) media->Type = 1;
-			else if (!strcmp(comp, "audio")) media->Type = 2;
-			else if (!strcmp(comp, "text")) media->Type = 3;
-			else if (!strcmp(comp, "data")) media->Type = 4;
-			else if (!strcmp(comp, "control")) media->Type = 5;
-			else media->Type = 0;
-			//port numbers
-			gf_token_get(LineBuf, pos, " ", comp, 3000);
-			if (!strstr(comp, "/")) {
-				pos = gf_token_get(LineBuf, pos, " \r\n", comp, 3000);
-				media->PortNumber = atoi(comp);
-				media->NumPorts = 0;
-			} else {
-				pos = gf_token_get(LineBuf, pos, " /\r\n", comp, 3000);
-				media->PortNumber = atoi(comp);
-				pos = gf_token_get(LineBuf, pos, " \r\n", comp, 3000);
-				media->NumPorts = atoi(comp);
-			}
-			//transport Profile
-			pos = gf_token_get(LineBuf, pos, " \r\n", comp, 3000);
-			media->Profile = gf_strdup(comp);
-			pos = gf_token_get(LineBuf, pos, " \r\n", comp, 3000);
-			media->fmt_list = gf_strdup(comp);
-
-			gf_list_add(sdp->media_desc, media);
-			break;
-		}
-	}
-	//finally rewrite the fmt_list for all media, and remove dynamic payloads
-	//from the list
-	i=0;
-	while ((media = (GF_SDPMedia*)gf_list_enum(sdp->media_desc, &i))) {
-		pos = 0;
-		LinePos = 1;
-		strcpy(LineBuf, "");
-		while (1) {
-			if (!media->fmt_list) break;
-			pos = gf_token_get(media->fmt_list, pos, " ", comp, 3000);
-			if (pos <= 0) break;
-			if (!SDP_IsDynamicPayload(media, comp)) {
-				if (!LinePos) {
-					strcat(LineBuf, " ");
-				} else {
-					LinePos = 0;
-				}
-				strcat(LineBuf, comp);
-			}
-			gf_free(media->fmt_list);
-			media->fmt_list = NULL;
-			if (strlen(LineBuf)) {
-				media->fmt_list = gf_strdup(LineBuf);
-			}
-		}
-	}
-	return GF_OK;
-}
-
-
-
-GF_Err SDP_CheckConnection(GF_SDPConnection *conn)
-{
-	if (!conn) return GF_BAD_PARAM;
-	if (!conn->host || !conn->add_type || !conn->net_type) return GF_REMOTE_SERVICE_ERROR;
-	if (gf_sk_is_multicast_address(conn->host)) {
-		if (conn->TTL < 0 || conn->TTL > 255) return GF_REMOTE_SERVICE_ERROR;
-	} else {
-		conn->TTL = -1;
-		conn->add_count = 0;
-	}
-	return GF_OK;
-}
-
-//return GF_BAD_PARAM if invalid structure, GF_REMOTE_SERVICE_ERROR if bad formatting
-//or GF_OK
-GF_EXPORT
-GF_Err gf_sdp_info_check(GF_SDPInfo *sdp)
-{
-	GF_Err e;
-	u32 i, j, count;
-	GF_SDPMedia *media;
-	GF_SDPConnection *conn;
-	GF_RTPMap *map;
-	Bool HasGlobalConnection, HasSeveralPorts;
-
-	if (!sdp || !sdp->media_desc || !sdp->Attributes) return GF_BAD_PARAM;
-	//we force at least one media per SDP
-	if (!gf_list_count(sdp->media_desc)) return GF_REMOTE_SERVICE_ERROR;
-
-	//normative fields
-	//o=
-	if (!sdp->o_add_type || !sdp->o_address || !sdp->o_username || !sdp->o_session_id || !sdp->o_version)
-		return GF_REMOTE_SERVICE_ERROR;
-	//s=
-	//commented for intermedia demos
-//	if (!sdp->s_session_name) return GF_REMOTE_SERVICE_ERROR;
-	//t=
-//	if () return GF_REMOTE_SERVICE_ERROR;
-	//c=
-	if (sdp->c_connection) {
-		e = SDP_CheckConnection(sdp->c_connection);
-		if (e) return e;
-		//multiple addresses are only for media desc
-		if (sdp->c_connection->add_count >= 2) return GF_REMOTE_SERVICE_ERROR;
-		HasGlobalConnection = GF_TRUE;
-	} else {
-		HasGlobalConnection = GF_FALSE;
-	}
-
-	//then check all media
-	i=0;
-	while ((media = (GF_SDPMedia*)gf_list_enum(sdp->media_desc, &i))) {
-		HasSeveralPorts = GF_FALSE;
-
-		//m= : force non-null port, profile and fmt_list
-		if (/*!media->PortNumber || */ !media->Profile) return GF_REMOTE_SERVICE_ERROR;
-		if (media->NumPorts) HasSeveralPorts = GF_TRUE;
-
-		//no connections specified - THIS IS AN ERROR IN SDP BUT NOT IN ALL RTSP SESSIONS...
-//		if (!HasGlobalConnection && !gf_list_count(media->Connections)) return GF_REMOTE_SERVICE_ERROR;
-		//too many connections specified
-		if (HasGlobalConnection && gf_list_count(media->Connections)) return GF_REMOTE_SERVICE_ERROR;
-
-		//check all connections, and make sure we don't have multiple addresses
-		//and multiple ports at the same time
-		count = gf_list_count(media->Connections);
-		if (count>1 && HasSeveralPorts) return GF_REMOTE_SERVICE_ERROR;
-
-		for (j=0; j<count; j++) {
-			conn = (GF_SDPConnection*)gf_list_get(media->Connections, j);
-			e = SDP_CheckConnection(conn);
-			if (e) return e;
-			if ((conn->add_count >= 2) && HasSeveralPorts) return GF_REMOTE_SERVICE_ERROR;
-		}
-		//RTPMaps. 0 is tolerated, but if some are specified check them
-		j=0;
-		while ((map = (GF_RTPMap*)gf_list_enum(media->RTPMaps, &j))) {
-			//RFC2327 is not clear here, but we assume the PayloadType should be a DYN one
-			//however this depends on the profile (RTP/AVP or others) so don't check it
-			//ClockRate SHALL NOT be NULL
-			if (!map->payload_name || !map->ClockRate) return GF_REMOTE_SERVICE_ERROR;
-		}
-	}
-	//Encryption: nothing tells wether the scope of the global key is eclusive or not.
-	//we accept a global key + keys per media entry, assuming that the media key primes
-	//on the global key
-
-	return GF_OK;
-}
-
-
-#define SDP_WRITE_ALLOC_STR_WITHOUT_CHECK(str, space)		\
-	if (strlen(str)+pos + (space ? 1 : 0) >= buf_size) {	\
-		buf_size += SDP_WRITE_STEPALLOC;	\
-		buf = (char*)gf_realloc(buf, sizeof(char)*buf_size);		\
-	}	\
-	strcpy(buf+pos, str);		\
-	pos += (u32) strlen(str);		\
-	if (space) {			\
-		strcat(buf+pos, " ");	\
-		pos += 1;		\
-	}
-
-#define SDP_WRITE_ALLOC_STR(str, space)		\
-	if (str) { \
-		SDP_WRITE_ALLOC_STR_WITHOUT_CHECK(str, space); \
-	}		\
- 
-#define SDP_WRITE_ALLOC_INT(d, spa, sig)		\
-	if (sig < 0) { \
-		sprintf(temp, "%d", d);		\
-	} else { \
-		sprintf(temp, "%u", d);		\
-	}	\
-	SDP_WRITE_ALLOC_STR_WITHOUT_CHECK(temp, spa);
-
-#define SDP_WRITE_ALLOC_FLOAT(d, spa)		\
-	sprintf(temp, "%.2f", d);		\
-	SDP_WRITE_ALLOC_STR_WITHOUT_CHECK(temp, spa);
-
-#define TEST_SDP_WRITE_SINGLE(type, str, sep)		\
-	if (str) {		\
-		SDP_WRITE_ALLOC_STR(type, 0);		\
-		if (sep) SDP_WRITE_ALLOC_STR(":", 0);		\
-		SDP_WRITE_ALLOC_STR(str, 0);		\
-		SDP_WRITE_ALLOC_STR("\r\n", 0);		\
-	}
-
-
-#define SDP_WRITE_CONN(conn)		\
-	if (conn) {			\
-		SDP_WRITE_ALLOC_STR("c=", 0);	\
-		SDP_WRITE_ALLOC_STR(conn->net_type, 1);		\
-		SDP_WRITE_ALLOC_STR(conn->add_type, 1);		\
-		SDP_WRITE_ALLOC_STR(conn->host, 0);			\
-		if (gf_sk_is_multicast_address(conn->host)) {	\
-			SDP_WRITE_ALLOC_STR("/", 0);			\
-			SDP_WRITE_ALLOC_INT(conn->TTL, 0, 0);		\
-			if (conn->add_count >= 2) {		\
-				SDP_WRITE_ALLOC_STR("/", 0);		\
-				SDP_WRITE_ALLOC_INT(conn->add_count, 0, 0);	\
-			}		\
-		}	\
-		SDP_WRITE_ALLOC_STR("\r\n", 0);		\
-	}
-
-GF_EXPORT
-GF_Err gf_sdp_info_write(GF_SDPInfo *sdp, char **out_str_buf)
-{
-	char *buf;
-	GF_SDP_FMTP *fmtp;
-	char temp[50];
-	GF_SDPMedia *media;
-	GF_SDPBandwidth *bw;
-	u32 buf_size, pos, i, j, k;
-	GF_RTPMap *map;
-	GF_SDPConnection *conn;
-	GF_Err e;
-	GF_SDPTiming *timing;
-	GF_X_Attribute *att;
-
-	e = gf_sdp_info_check(sdp);
-	if (e) return e;
-
-	buf = (char *)gf_malloc(SDP_WRITE_STEPALLOC);
-	buf_size = SDP_WRITE_STEPALLOC;
-	pos = 0;
-
-	//v
-	SDP_WRITE_ALLOC_STR("v=", 0);
-	SDP_WRITE_ALLOC_INT(sdp->Version, 0, 0);
-	SDP_WRITE_ALLOC_STR("\r\n", 0);
-	//o
-	SDP_WRITE_ALLOC_STR("o=", 0);
-	SDP_WRITE_ALLOC_STR(sdp->o_username, 1);
-	SDP_WRITE_ALLOC_STR(sdp->o_session_id, 1);
-	SDP_WRITE_ALLOC_STR(sdp->o_version, 1);
-	SDP_WRITE_ALLOC_STR(sdp->o_net_type, 1);
-	SDP_WRITE_ALLOC_STR(sdp->o_add_type, 1);
-	SDP_WRITE_ALLOC_STR(sdp->o_address, 0);
-	SDP_WRITE_ALLOC_STR("\r\n", 0);
-	//s
-	TEST_SDP_WRITE_SINGLE("s=", sdp->s_session_name, 0);
-	//i
-	TEST_SDP_WRITE_SINGLE("i=", sdp->i_description, 0);
-	//u
-	TEST_SDP_WRITE_SINGLE("u=", sdp->u_uri, 0);
-	//e
-	TEST_SDP_WRITE_SINGLE("e=", sdp->e_email, 0);
-	//p
-	TEST_SDP_WRITE_SINGLE("p=", sdp->p_phone, 0);
-	//c
-	SDP_WRITE_CONN(sdp->c_connection);
-	//b
-	i=0;
-	while ((bw = (GF_SDPBandwidth*)gf_list_enum(sdp->b_bandwidth, &i))) {
-		SDP_WRITE_ALLOC_STR("b=", 0);
-		SDP_WRITE_ALLOC_STR(bw->name, 0);
-		SDP_WRITE_ALLOC_STR(":", 0);
-		SDP_WRITE_ALLOC_INT(bw->value, 0, 0);
-		SDP_WRITE_ALLOC_STR("\r\n", 0);
-	}
-	//t+r+z
-	i=0;
-	while ((timing = (GF_SDPTiming*)gf_list_enum(sdp->Timing, &i))) {
-		if (timing->NbRepeatOffsets > GF_SDP_MAX_TIMEOFFSET) timing->NbRepeatOffsets = GF_SDP_MAX_TIMEOFFSET;
-		if (timing->NbZoneOffsets > GF_SDP_MAX_TIMEOFFSET) timing->NbZoneOffsets = GF_SDP_MAX_TIMEOFFSET;
-		//t
-		SDP_WRITE_ALLOC_STR("t=", 0);
-		SDP_WRITE_ALLOC_INT(timing->StartTime, 1, 0);
-		SDP_WRITE_ALLOC_INT(timing->StopTime, 0, 0);
-		SDP_WRITE_ALLOC_STR("\r\n", 0);
-		if (timing->NbRepeatOffsets) {
-			SDP_WRITE_ALLOC_STR("r=", 0);
-			SDP_WRITE_ALLOC_INT(timing->RepeatInterval, 1, 0);
-			SDP_WRITE_ALLOC_INT(timing->ActiveDuration, 0, 0);
-			for (j=0; j<timing->NbRepeatOffsets; j++) {
-				SDP_WRITE_ALLOC_STR(" ", 0);
-				SDP_WRITE_ALLOC_INT(timing->OffsetFromStart[j], 0, 0);
-			}
-			SDP_WRITE_ALLOC_STR("\r\n", 0);
-		}
-		if (timing->NbZoneOffsets) {
-			SDP_WRITE_ALLOC_STR("z=", 0);
-			for (j=0; j<timing->NbZoneOffsets; j++) {
-				SDP_WRITE_ALLOC_INT(timing->AdjustmentTime[j], 1, 0);
-				if (j+1 == timing->NbRepeatOffsets) {
-					SDP_WRITE_ALLOC_INT(timing->AdjustmentOffset[j], 0, 1);
-				} else {
-					SDP_WRITE_ALLOC_INT(timing->AdjustmentOffset[j], 1, 1);
-				}
-			}
-			SDP_WRITE_ALLOC_STR("\r\n", 0);
-		}
-	}
-	//k
-	if (sdp->k_method) {
-		SDP_WRITE_ALLOC_STR("k=", 0);
-		SDP_WRITE_ALLOC_STR(sdp->k_method, 0);
-		if (sdp->k_key) {
-			SDP_WRITE_ALLOC_STR(":", 0);
-			SDP_WRITE_ALLOC_STR(sdp->k_key, 0);
-		}
-		SDP_WRITE_ALLOC_STR("\r\n", 0);
-	}
-	//a=cat
-	TEST_SDP_WRITE_SINGLE("a=cat", sdp->a_cat, 1);
-	//a=keywds
-	TEST_SDP_WRITE_SINGLE("a=keywds", sdp->a_keywds, 1);
-	//a=tool
-	TEST_SDP_WRITE_SINGLE("a=tool", sdp->a_tool, 1);
-	//a=SendRecv
-	switch (sdp->a_SendReceive) {
-	case 1:
-		TEST_SDP_WRITE_SINGLE("a=", "recvonly", 0);
-		break;
-	case 2:
-		TEST_SDP_WRITE_SINGLE("a=", "sendonly", 0);
-		break;
-	case 3:
-		TEST_SDP_WRITE_SINGLE("a=", "sendrecv", 0);
-		break;
-	default:
-		break;
-	}
-	//a=type
-	TEST_SDP_WRITE_SINGLE("a=type", sdp->a_type, 1);
-	//a=charset
-	TEST_SDP_WRITE_SINGLE("a=charset", sdp->a_charset, 1);
-	//a=sdplang
-	TEST_SDP_WRITE_SINGLE("a=sdplang", sdp->a_sdplang, 1);
-	//a=lang
-	TEST_SDP_WRITE_SINGLE("a=lang", sdp->a_lang, 1);
-
-	//the rest
-	i=0;
-	while ((att = (GF_X_Attribute*)gf_list_enum(sdp->Attributes, &i))) {
-		SDP_WRITE_ALLOC_STR("a=", 0);
-		SDP_WRITE_ALLOC_STR(att->Name, 0);
-		if (att->Value) {
-			SDP_WRITE_ALLOC_STR(":", 0);
-			SDP_WRITE_ALLOC_STR(att->Value, 0);
-		}
-		SDP_WRITE_ALLOC_STR("\r\n", 0);
-	}
-
-	//now write media specific
-	i=0;
-	while ((media = (GF_SDPMedia*)gf_list_enum(sdp->media_desc, &i))) {
-		//m=
-		SDP_WRITE_ALLOC_STR("m=", 0);
-		switch (media->Type) {
-		case 1:
-			SDP_WRITE_ALLOC_STR("video", 1);
-			break;
-		case 2:
-			SDP_WRITE_ALLOC_STR("audio", 1);
-			break;
-		case 3:
-			SDP_WRITE_ALLOC_STR("data", 1);
-			break;
-		case 4:
-			SDP_WRITE_ALLOC_STR("control", 1);
-			break;
-		default:
-			SDP_WRITE_ALLOC_STR("application", 1);
-			break;
-		}
-		SDP_WRITE_ALLOC_INT(media->PortNumber, 0, 0);
-		if (media->NumPorts >= 2) {
-			SDP_WRITE_ALLOC_STR("/", 0);
-			SDP_WRITE_ALLOC_INT(media->NumPorts, 1, 0);
-		} else {
-			SDP_WRITE_ALLOC_STR(" ", 0);
-		}
-		SDP_WRITE_ALLOC_STR(media->Profile, 1);
-		SDP_WRITE_ALLOC_STR(media->fmt_list, 0);
-
-		j=0;
-		while ((map = (GF_RTPMap*)gf_list_enum(media->RTPMaps, &j))) {
-			SDP_WRITE_ALLOC_STR(" ", 0);
-			SDP_WRITE_ALLOC_INT(map->PayloadType, 0, 0);
-		}
-		SDP_WRITE_ALLOC_STR("\r\n", 0);
-
-		//c=
-		j=0;
-		while ((conn = (GF_SDPConnection*)gf_list_enum(media->Connections, &j))) {
-			SDP_WRITE_CONN(conn);
-		}
-
-		//k=
-		if (media->k_method) {
-			SDP_WRITE_ALLOC_STR("k=", 0);
-			SDP_WRITE_ALLOC_STR(media->k_method, 0);
-			if (media->k_key) {
-				SDP_WRITE_ALLOC_STR(":", 0);
-				SDP_WRITE_ALLOC_STR(media->k_key, 0);
-			}
-			SDP_WRITE_ALLOC_STR("\r\n", 0);
-		}
-		//b
-		j=0;
-		while ((bw = (GF_SDPBandwidth*)gf_list_enum(media->Bandwidths, &j))) {
-			SDP_WRITE_ALLOC_STR("b=", 0);
-			SDP_WRITE_ALLOC_STR(bw->name, 0);
-			SDP_WRITE_ALLOC_STR(":", 0);
-			SDP_WRITE_ALLOC_INT(bw->value, 0, 0);
-			SDP_WRITE_ALLOC_STR("\r\n", 0);
-		}
-
-		//a=rtpmap
-		j=0;
-		while ((map = (GF_RTPMap*)gf_list_enum(media->RTPMaps, &j))) {
-
-			SDP_WRITE_ALLOC_STR("a=rtpmap", 0);
-			SDP_WRITE_ALLOC_STR(":", 0);
-			SDP_WRITE_ALLOC_INT(map->PayloadType, 1, 0);
-			SDP_WRITE_ALLOC_STR(map->payload_name, 0);
-			SDP_WRITE_ALLOC_STR("/", 0);
-			SDP_WRITE_ALLOC_INT(map->ClockRate, 0, 0);
-			if (map->AudioChannels > 1) {
-				SDP_WRITE_ALLOC_STR("/", 0);
-				SDP_WRITE_ALLOC_INT(map->AudioChannels, 0, 0);
-			}
-			SDP_WRITE_ALLOC_STR("\r\n", 0);
-		}
-		//a=fmtp
-		j=0;
-		while ((fmtp = (GF_SDP_FMTP*)gf_list_enum(media->FMTP, &j))) {
-			SDP_WRITE_ALLOC_STR("a=fmtp:", 0);
-			SDP_WRITE_ALLOC_INT(fmtp->PayloadType, 1 , 0);
-			k=0;
-			while ((att = (GF_X_Attribute*)gf_list_enum(fmtp->Attributes, &k)) ) {
-				if (k>1) SDP_WRITE_ALLOC_STR(";", 0);
-				SDP_WRITE_ALLOC_STR(att->Name, 0);
-				if (att->Value) {
-					SDP_WRITE_ALLOC_STR("=", 0);
-					SDP_WRITE_ALLOC_STR(att->Value, 0);
-				}
-			}
-			SDP_WRITE_ALLOC_STR("\r\n", 0);
-		}
-		//a=ptime
-		if (media->PacketTime) {
-			SDP_WRITE_ALLOC_STR("a=ptime:", 0);
-			SDP_WRITE_ALLOC_INT(media->PacketTime, 0, 0);
-			SDP_WRITE_ALLOC_STR("\r\n", 0);
-		}
-		//a=FrameRate
-		if (media->Type == 1 && media->FrameRate) {
-			SDP_WRITE_ALLOC_STR("a=framerate:", 0);
-			SDP_WRITE_ALLOC_FLOAT(media->FrameRate, 0);
-			SDP_WRITE_ALLOC_STR("\r\n", 0);
-		}
-		//a=SendRecv
-		switch (media->SendReceive) {
-		case 1:
-			TEST_SDP_WRITE_SINGLE("a=", "recvonly", 0);
-			break;
-		case 2:
-			TEST_SDP_WRITE_SINGLE("a=", "sendonly", 0);
-			break;
-		case 3:
-			TEST_SDP_WRITE_SINGLE("a=", "sendrecv", 0);
-			break;
-		default:
-			break;
-		}
-		//a=orient
-		TEST_SDP_WRITE_SINGLE("a=orient", media->orientation, 1);
-		//a=sdplang
-		TEST_SDP_WRITE_SINGLE("a=sdplang", media->sdplang, 1);
-		//a=lang
-		TEST_SDP_WRITE_SINGLE("a=lang", media->lang, 1);
-		//a=quality
-		if (media->Quality >= 0) {
-			SDP_WRITE_ALLOC_STR("a=quality:", 0);
-			SDP_WRITE_ALLOC_INT(media->Quality, 0, 0);
-			SDP_WRITE_ALLOC_STR("\r\n", 0);
-		}
-		//the rest
-		j=0;
-		while ((att = (GF_X_Attribute*)gf_list_enum(media->Attributes, &j))) {
-			SDP_WRITE_ALLOC_STR("a=", 0);
-			SDP_WRITE_ALLOC_STR(att->Name, 0);
-			if (att->Value) {
-				SDP_WRITE_ALLOC_STR(":", 0);
-				SDP_WRITE_ALLOC_STR(att->Value, 0);
-			}
-			SDP_WRITE_ALLOC_STR("\r\n", 0);
-		}
-	}
-
-	//finally gf_realloc
-	//finall NULL char
-	pos += 1;
-	buf = (char *)gf_realloc(buf, pos);
-	*out_str_buf = buf;
-	return GF_OK;
-}
-
-#endif /*GPAC_DISABLE_STREAMING*/

