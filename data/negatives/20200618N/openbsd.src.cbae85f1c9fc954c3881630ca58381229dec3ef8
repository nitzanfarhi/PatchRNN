commit cbae85f1c9fc954c3881630ca58381229dec3ef8
Author: jason <jason@openbsd.org>
Date:   Mon Mar 26 19:00:58 2001 +0000

    - move if_vlan back to a default if_type of IFT_PROPVIRTUAL
    - change if_type to match parent at vlan_configure time
    - comment typo
    - implement promiscuous mode for vlan interfaces (from NetBSD)
    - change if_flags inheritance mask to UP|BROADCAST|SIMPLE|MULTICAST
    (upshot of all this: bridging vlan interfaces works, with some limitations...
    documentation soon)

diff --git a/sys/net/if_types.h b/sys/net/if_types.h
index 2c90897c4b5..889ed824ab1 100644
--- a/sys/net/if_types.h
+++ b/sys/net/if_types.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: if_types.h,v 1.7 2001/03/22 05:26:35 jason Exp $	*/
+/*	$OpenBSD: if_types.h,v 1.8 2001/03/26 19:00:58 jason Exp $	*/
 /*	$NetBSD: if_types.h,v 1.7 1995/02/27 09:10:24 glass Exp $	*/
 
 /*
@@ -100,7 +100,6 @@
 
 /* private usage... how should we define these? */
 #define	IFT_BRIDGE	0xe8		/* bridge interfaces */
-#define	IFT_8021_VLAN	0xe9		/* vlan interfaces */
 #define	IFT_GIF		0xf0
 #define	IFT_DUMMY	0xf1
 #define IFT_PVC		0xf2
diff --git a/sys/net/if_vlan.c b/sys/net/if_vlan.c
index 7e9ba36f770..6cff8ead00d 100644
--- a/sys/net/if_vlan.c
+++ b/sys/net/if_vlan.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: if_vlan.c,v 1.12 2001/03/23 07:45:42 jason Exp $ */
+/*	$OpenBSD: if_vlan.c,v 1.13 2001/03/26 19:00:58 jason Exp $ */
 /*
  * Copyright 1998 Massachusetts Institute of Technology
  *
@@ -48,7 +48,7 @@
  * one can change the behavior of the vlan interface by setting
  * the LINK0 flag on it (that is setting the vlan interface's LINK0
  * flag, _not_ the parent's LINK0 flag; we try to leave the parent
- * alone). If the interface as the LINK0 flag set, then it will
+ * alone). If the interface has the LINK0 flag set, then it will
  * not modify the ethernet header on output because the parent
  * can do that for itself. On input, the parent can call vlan_input_tag()
  * directly in order to supply us with an incoming mbuf and the vlan
@@ -97,6 +97,7 @@ int	vlan_setmulti (struct ifnet *ifp);
 int	vlan_unconfig (struct ifnet *ifp);
 int	vlan_config (struct ifvlan *ifv, struct ifnet *p);
 void	vlanattach (void *dummy);
+int	vlan_set_promisc (struct ifnet *ifp);
 
 /*
  * Program our multicast filter. What we're actually doing is
@@ -407,11 +408,14 @@ vlan_config(struct ifvlan *ifv, struct ifnet *p)
 		return EBUSY;
 	ifv->ifv_p = p;
 	ifv->ifv_if.if_mtu = p->if_data.ifi_mtu;
+	ifv->ifv_if.if_flags = p->if_flags &
+	    (IFF_UP | IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST);
 
 	/*
-	 * Preserve the state of the LINK0 flag for ourselves.
+	 * Inherit the if_type from the parent.  This allows us to
+	 * participate in bridges of that type.
 	 */
-	ifv->ifv_if.if_flags = (p->if_flags & ~(IFF_LINK0));
+	ifv->ifv_if.if_type = p->if_type;
 
 	/*
 	 * Set up our ``Ethernet address'' to reflect the underlying
@@ -476,6 +480,29 @@ vlan_unconfig(struct ifnet *ifp)
 	return 0;
 }
 
+int
+vlan_set_promisc(struct ifnet *ifp)
+{
+	struct ifvlan *ifv = ifp->if_softc;
+	int error = 0;
+
+	if ((ifp->if_flags & IFF_PROMISC) != 0) {
+		if ((ifv->ifv_flags & IFVF_PROMISC) == 0) {
+			error = ifpromisc(ifv->ifv_p, 1);
+			if (error == 0)
+				ifv->ifv_flags |= IFVF_PROMISC;
+		}
+	} else {
+		if ((ifv->ifv_flags & IFVF_PROMISC) != 0) {
+			error = ifpromisc(ifv->ifv_p, 0);
+			if (error == 0)
+				ifv->ifv_flags &= ~IFVF_PROMISC;
+		}
+	}
+
+	return (0);
+}
+
 int
 vlan_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
 {
@@ -559,6 +586,9 @@ vlan_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
 			break;
 		ifv->ifv_tag = vlr.vlr_tag;
 		ifp->if_flags |= IFF_RUNNING;
+
+		/* Update promiscuous mode, if necessary. */
+		vlan_set_promisc(ifp);
 		break;
 		
 	case SIOCGETVLAN:
@@ -573,14 +603,11 @@ vlan_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
 		
 	case SIOCSIFFLAGS:
 		/*
-		 * We don't support promiscuous mode
-		 * right now because it would require help from the
-		 * underlying drivers, which hasn't been implemented.
+		 * For promiscuous mode, we enable promiscuous mode on
+		 * the parent if we need promiscuous on the VLAN interface.
 		 */
-		if (ifr->ifr_flags & (IFF_PROMISC)) {
-			ifp->if_flags &= ~(IFF_PROMISC);
-			error = EINVAL;
-		}
+		if (ifv->ifv_p != NULL)
+			error = vlan_set_promisc(ifp);
 		break;
 	case SIOCADDMULTI:
 	case SIOCDELMULTI:
diff --git a/sys/net/if_vlan_var.h b/sys/net/if_vlan_var.h
index 57731911a5c..6a1560afeb0 100644
--- a/sys/net/if_vlan_var.h
+++ b/sys/net/if_vlan_var.h
@@ -47,9 +47,11 @@ struct	ifvlan {
 		u_int16_t ifvm_tag; /* tag to apply on packets leaving if */
 	}	ifv_mib;
 	SLIST_HEAD(__vlan_mchead, vlan_mc_entry)	vlan_mc_listhead;
+	int ifv_flags;
 };
 #define	ifv_if		ifv_ac.ac_if
 #define	ifv_tag		ifv_mib.ifvm_tag
+#define	IFVF_PROMISC	0x01
 #endif /* _KERNEL */
 
 struct	ether_vlan_header {
@@ -64,6 +66,9 @@ struct	ether_vlan_header {
 #define	EVL_PRIOFTAG(tag) (((tag) >> 13) & 7)
 #define	EVL_ENCAPLEN	4	/* length in octets of encapsulation */
 
+/* When these sorts of interfaces get their own identifier... */
+#define	IFT_8021_VLAN	IFT_PROPVIRTUAL
+
 /* sysctl(3) tags, for compatibility purposes */
 #define	VLANCTL_PROTO	1
 #define	VLANCTL_MAX	2

