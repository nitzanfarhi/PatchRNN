commit 3626479e482aa3247aac03724094ba6c13ea1e46
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue Apr 17 18:32:19 2012 -0300

    [media] dvb_frontend: Fix a regression when switching back to DVB-S
    
    There are some softwares (Kaffeine and likely xine) that uses a
    DVBv5 call to switch to DVB-S2, but expects that a DVBv3 call to
    switch back to DVB-S. Well, this is not right, as a DVBv3 call
    doesn't know anything about delivery systems.
    
    However, as, by accident, this used to work, we need to restore its
    behavior, in order to avoid regressions with those softwares.
    
    Reported on this Fedora 16 bugzilla:
            https://bugzilla.redhat.com/show_bug.cgi?id=812895
    
    Reported-by: Dieter Roever <Dieter.Roever@gmx.de>
    Cc: stable@kernel.org # for version 3.3
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/dvb/dvb-core/dvb_frontend.c b/drivers/media/dvb/dvb-core/dvb_frontend.c
index 39696c6a4ed7..0f64d7182657 100644
--- a/drivers/media/dvb/dvb-core/dvb_frontend.c
+++ b/drivers/media/dvb/dvb-core/dvb_frontend.c
@@ -1446,6 +1446,28 @@ static int set_delivery_system(struct dvb_frontend *fe, u32 desired_system)
 				__func__);
 			return -EINVAL;
 		}
+		/*
+		 * Get a delivery system that is compatible with DVBv3
+		 * NOTE: in order for this to work with softwares like Kaffeine that
+		 *	uses a DVBv5 call for DVB-S2 and a DVBv3 call to go back to
+		 *	DVB-S, drivers that support both should put the SYS_DVBS entry
+		 *	before the SYS_DVBS2, otherwise it won't switch back to DVB-S.
+		 *	The real fix is that userspace applications should not use DVBv3
+		 *	and not trust on calling FE_SET_FRONTEND to switch the delivery
+		 *	system.
+		 */
+		ncaps = 0;
+		while (fe->ops.delsys[ncaps] && ncaps < MAX_DELSYS) {
+			if (fe->ops.delsys[ncaps] == desired_system) {
+				delsys = desired_system;
+				break;
+			}
+			ncaps++;
+		}
+		if (delsys == SYS_UNDEFINED) {
+			dprintk("%s() Couldn't find a delivery system that matches %d\n",
+				__func__, desired_system);
+		}
 	} else {
 		/*
 		 * This is a DVBv5 call. So, it likely knows the supported
@@ -1494,9 +1516,10 @@ static int set_delivery_system(struct dvb_frontend *fe, u32 desired_system)
 				__func__);
 			return -EINVAL;
 		}
-		c->delivery_system = delsys;
 	}
 
+	c->delivery_system = delsys;
+
 	/*
 	 * The DVBv3 or DVBv5 call is requesting a different system. So,
 	 * emulation is needed.

