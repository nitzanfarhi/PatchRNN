commit ac04add5965a010d8a9e3333444c3d72efab6a2e
Author: Gunter Knauf <gk@gknw.de>
Date:   Sat Feb 13 18:29:59 2010 +0000

    replaced tabs by spaces, removed trailing tabs/spaces.

diff --git a/lib/hostthre.c b/lib/hostthre.c
index 7526d6db8..121a60869 100644
--- a/lib/hostthre.c
+++ b/lib/hostthre.c
@@ -136,7 +136,7 @@ void destroy_thread_sync_data(struct thread_sync_data * tsd)
 
   if(tsd->hostname)
     free(tsd->hostname);
-  
+
   if (tsd->res)
     Curl_freeaddrinfo(tsd->res);
 
@@ -147,8 +147,8 @@ void destroy_thread_sync_data(struct thread_sync_data * tsd)
 static
 int init_thread_sync_data(struct thread_sync_data * tsd,
                            const char * hostname,
-			   int port,
-			   const struct addrinfo *hints)
+                           int port,
+                           const struct addrinfo *hints)
 {
   memset(tsd, 0, sizeof(*tsd));
 
@@ -194,7 +194,7 @@ static unsigned int CURL_STDCALL gethostbyname_thread (void *arg)
     tsd->sock_error = SOCKERRNO;
     if (tsd->sock_error == 0)
       tsd->sock_error = ENOMEM;
-  } 
+  }
 
   Curl_mutex_acquire(tsd->mtx);
   tsd->done = 1;
@@ -208,7 +208,7 @@ static int getaddrinfo_complete(struct connectdata *conn)
   struct thread_sync_data *tsd = conn_thread_sync_data(conn);
   int rc;
 
-  rc = Curl_addrinfo_callback(conn, tsd->sock_error, tsd->res); 
+  rc = Curl_addrinfo_callback(conn, tsd->sock_error, tsd->res);
   /* The tsd->res structure has been copied to async.dns and perhaps the DNS cache.
      Set our copy to NULL so destroy_thread_sync_data doesn't free it.
    */
@@ -268,9 +268,9 @@ void Curl_destroy_thread_data (struct Curl_async *async)
 
     if (td->thread_hnd != curl_thread_t_null)
       Curl_thread_join(&td->thread_hnd);
- 
+
     destroy_thread_sync_data(&td->tsd);
-    
+
     free(async->os_specific);
   }
   async->hostname = NULL;
@@ -291,7 +291,7 @@ static bool init_resolve_thread (struct connectdata *conn,
   int err = ENOMEM;
 
   conn->async.os_specific = (void*) td;
-  if(!td) 
+  if(!td)
     goto err_exit;
 
   conn->async.port = port;
@@ -301,7 +301,7 @@ static bool init_resolve_thread (struct connectdata *conn,
   td->dummy_sock = CURL_SOCKET_BAD;
   td->thread_hnd = curl_thread_t_null;
 
-  if (!init_thread_sync_data(&td->tsd, hostname, port, hints)) 
+  if (!init_thread_sync_data(&td->tsd, hostname, port, hints))
     goto err_exit;
 
   Curl_safefree(conn->async.hostname);
@@ -364,11 +364,11 @@ CURLcode Curl_wait_for_resolv(struct connectdata *conn,
   if (Curl_thread_join(&td->thread_hnd)) {
     rc = getaddrinfo_complete(conn);
   } else {
-    DEBUGASSERT(0);    
+    DEBUGASSERT(0);
   }
 
   conn->async.done = TRUE;
-    
+
   if(entry)
     *entry = conn->async.dns;
 
@@ -404,7 +404,7 @@ CURLcode Curl_is_resolved(struct connectdata *conn,
   struct SessionHandle *data = conn->data;
   struct thread_data   *td = (struct thread_data*) conn->async.os_specific;
   int done = 0;
- 
+
   *entry = NULL;
 
   if (!td) {
@@ -416,7 +416,7 @@ CURLcode Curl_is_resolved(struct connectdata *conn,
   done = td->tsd.done;
   Curl_mutex_release(td->tsd.mtx);
 
-  if (done) { 
+  if (done) {
     getaddrinfo_complete(conn);
     if (td->poll_interval != 0)
         Curl_expire(conn->data, 0);

