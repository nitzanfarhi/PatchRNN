commit 03b1dfdac2c2d46d7923accb067481114b01e7b3
Author: Mark Grondona <mgrondona@llnl.gov>
Date:   Tue Apr 29 20:43:53 2003 +0000

     o replace hard tabs with soft tabs to undo formatting problems resulting from
       an assumption of tabstop=4
     o Try not to let lines exceed 80 chars
     o Replace calls to error() with verbose() to avoid unexpected messages to
       stderr in API clients.

diff --git a/src/common/plugin.c b/src/common/plugin.c
index 4190f53a19..dc93fd7acb 100644
--- a/src/common/plugin.c
+++ b/src/common/plugin.c
@@ -30,7 +30,7 @@
 
 #include <sys/types.h>
 #include <stdio.h>
-#include <dlfcn.h>	/* don't know if there's an autoconf for this. */
+#include <dlfcn.h>        /* don't know if there's an autoconf for this. */
 
 #include "src/common/plugin.h"
 #include <slurm/slurm_errno.h>
@@ -39,42 +39,42 @@
 plugin_handle_t
 plugin_load_from_file( const char *fq_path )
 {
-	plugin_handle_t plug;
-	int (*init)( void );
-	
-	/*
-	 * Try to open the shared object.  We have a choice of trying to
-	 * resolve all the symbols (in both directions) now or when the
-	 * symbols are first dereferenced and used.  While it's slower to
-	 * do it this way, it's a lot easier to debug.  If you get an
-	 * error somewhere down the line, you're likely to think it's
-	 * some condition that happened then instead of way back here.
-	 */
-	plug = dlopen( fq_path, RTLD_NOW );
-	if ( plug == NULL ) {
-		return PLUGIN_INVALID_HANDLE;
-	}
-
-	/* Now see if our required symbols are defined. */
-	if ( ( dlsym( plug, PLUGIN_NAME ) == NULL ) ||
-	     ( dlsym( plug, PLUGIN_TYPE ) == NULL ) ||
-	     ( dlsym( plug, PLUGIN_VERSION ) == NULL ) ) {
-		/* slurm_seterrno( SLURM_PLUGIN_SYMBOLS ); */
-		return PLUGIN_INVALID_HANDLE;
-	}
-
-	/*
-	 * Now call its init() function, if present.  If the function
-	 * returns nonzero, unload the plugin and signal an error.
-	 */
-	if ( ( init = dlsym( plug, "init" ) ) != NULL ) {
-		if ( (*init)() != 0 ) {
-			(void) dlclose( plug );
-			return PLUGIN_INVALID_HANDLE;
-		}
-	}
-	
-	return plug;
+        plugin_handle_t plug;
+        int (*init)( void );
+        
+        /*
+         * Try to open the shared object.  We have a choice of trying to
+         * resolve all the symbols (in both directions) now or when the
+         * symbols are first dereferenced and used.  While it's slower to
+         * do it this way, it's a lot easier to debug.  If you get an
+         * error somewhere down the line, you're likely to think it's
+         * some condition that happened then instead of way back here.
+         */
+        plug = dlopen( fq_path, RTLD_NOW );
+        if ( plug == NULL ) {
+                return PLUGIN_INVALID_HANDLE;
+        }
+
+        /* Now see if our required symbols are defined. */
+        if ( ( dlsym( plug, PLUGIN_NAME ) == NULL ) ||
+             ( dlsym( plug, PLUGIN_TYPE ) == NULL ) ||
+             ( dlsym( plug, PLUGIN_VERSION ) == NULL ) ) {
+                /* slurm_seterrno( SLURM_PLUGIN_SYMBOLS ); */
+                return PLUGIN_INVALID_HANDLE;
+        }
+
+        /*
+         * Now call its init() function, if present.  If the function
+         * returns nonzero, unload the plugin and signal an error.
+         */
+        if ( ( init = dlsym( plug, "init" ) ) != NULL ) {
+                if ( (*init)() != 0 ) {
+                        (void) dlclose( plug );
+                        return PLUGIN_INVALID_HANDLE;
+                }
+        }
+        
+        return plug;
 }
 
 
@@ -87,68 +87,68 @@ plugin_load_from_file( const char *fq_path )
 void
 plugin_unload( plugin_handle_t plug )
 {
-	void (*fini)(void);
-	
-	if ( plug != PLUGIN_INVALID_HANDLE ) {
-		if ( ( fini = dlsym( plug, "fini" ) ) != NULL ) {
-			(*fini)();
-		}
-		(void) dlclose( plug );
-	}
+        void (*fini)(void);
+        
+        if ( plug != PLUGIN_INVALID_HANDLE ) {
+                if ( ( fini = dlsym( plug, "fini" ) ) != NULL ) {
+                        (*fini)();
+                }
+                (void) dlclose( plug );
+        }
 }
 
 
 void *
 plugin_get_sym( plugin_handle_t plug, const char *name )
 {
-	if ( plug != PLUGIN_INVALID_HANDLE )
-		return dlsym( plug, name );
-	else
-		return NULL;
+        if ( plug != PLUGIN_INVALID_HANDLE )
+                return dlsym( plug, name );
+        else
+                return NULL;
 }
 
 const char *
 plugin_get_name( plugin_handle_t plug )
 {
-	if ( plug != PLUGIN_INVALID_HANDLE )
-		return (const char *) dlsym( plug, PLUGIN_NAME );
-	else
-		return NULL;
+        if ( plug != PLUGIN_INVALID_HANDLE )
+                return (const char *) dlsym( plug, PLUGIN_NAME );
+        else
+                return NULL;
 }
 
 const char *
 plugin_get_type( plugin_handle_t plug )
 {
-	if ( plug != PLUGIN_INVALID_HANDLE )
-		return (const char *) dlsym( plug, PLUGIN_TYPE );
-	else
-		return NULL;
+        if ( plug != PLUGIN_INVALID_HANDLE )
+                return (const char *) dlsym( plug, PLUGIN_TYPE );
+        else
+                return NULL;
 }
 
 uint32_t
 plugin_get_version( plugin_handle_t plug )
 {
-	uint32_t *ptr;
+        uint32_t *ptr;
 
-	if ( plug == PLUGIN_INVALID_HANDLE ) return 0;	
-	ptr = (uint32_t *) dlsym( plug, PLUGIN_VERSION );
-	return ptr ? *ptr : 0;
+        if ( plug == PLUGIN_INVALID_HANDLE ) return 0;        
+        ptr = (uint32_t *) dlsym( plug, PLUGIN_VERSION );
+        return ptr ? *ptr : 0;
 }
 
 int
 plugin_get_syms( plugin_handle_t plug,
-				 int n_syms,
-				 const char *names[],
-				 void *ptrs[] )
+                 int n_syms,
+                 const char *names[],
+                 void *ptrs[] )
 {
-	int i, count;
+        int i, count;
 
-	count = 0;
-	for ( i = 0; i < n_syms; ++i ) {
-		ptrs[ i ] = dlsym( plug, names[ i ] );
-		if ( ptrs[ i ] ) ++count;
-	}
+        count = 0;
+        for ( i = 0; i < n_syms; ++i ) {
+                ptrs[ i ] = dlsym( plug, names[ i ] );
+                if ( ptrs[ i ] ) ++count;
+        }
 
-	return count;
+        return count;
 }
 
diff --git a/src/common/plugrack.c b/src/common/plugrack.c
index d8461db382..3e2b257d21 100644
--- a/src/common/plugrack.c
+++ b/src/common/plugrack.c
@@ -3,7 +3,7 @@
  *****************************************************************************
  *  Copyright (C) 2002 The Regents of the University of California.
  *  Produced at Lawrence Livermore National Laboratory (cf, DISCLAIMER).
- *  Written by AUTHOR <AUTHOR@llnl.gov>.
+ *  Written by Jay Windley <jwindley@lnxi.com>.
  *  UCRL-CODE-2002-040.
  *  
  *  This file is part of SLURM, a resource management program.
@@ -88,10 +88,10 @@
  * If this is zero, the rack code may decide to unload the plugin.
  */
 typedef struct _plugrack_entry {
-	const char *full_type;
-	const char *fq_path;
-	plugin_handle_t	plug;
-	int refcount;
+        const char *full_type;
+        const char *fq_path;
+        plugin_handle_t        plug;
+        int refcount;
 } plugrack_entry_t;
 
 /*
@@ -108,13 +108,13 @@ typedef struct _plugrack_entry {
  * loading it.
  */
 struct _plugrack {
-	List entries;
-	const char *major_type;
-	uid_t uid;
-	uint8_t	paranoia;
+        List entries;
+        const char *major_type;
+        uid_t uid;
+        uint8_t     paranoia;
 };
 
-#define PLUGRACK_UID_NOBODY		99	/* RedHat's, anyway. */
+#define PLUGRACK_UID_NOBODY                99        /* RedHat's, anyway. */
 
 /*
  * Destructor function for the List code.  This should entirely
@@ -123,20 +123,21 @@ struct _plugrack {
 static void
 plugrack_entry_destructor( void *v )
 {
-	plugrack_entry_t *victim = v;
+        plugrack_entry_t *victim = v;
   
-	if ( victim == NULL ) return;
-
-	/*
-	 * Free memory and unload the plugin if necessary.  The assert
-	 * is to make sure we were actually called from the List destructor
-	 * which should only be callable from plugrack_destroy().
-	 */
-	xassert( victim->refcount == 0 );
-	if ( victim->full_type ) xfree( victim->full_type );
-	if ( victim->fq_path ) xfree( victim->fq_path );
-	if ( victim->plug != PLUGIN_INVALID_HANDLE ) plugin_unload( victim->plug );
-	xfree( victim );
+        if ( victim == NULL ) return;
+
+        /*
+         * Free memory and unload the plugin if necessary.  The assert
+         * is to make sure we were actually called from the List destructor
+         * which should only be callable from plugrack_destroy().
+         */
+        xassert( victim->refcount == 0 );
+        if ( victim->full_type ) xfree( victim->full_type );
+        if ( victim->fq_path ) xfree( victim->fq_path );
+        if ( victim->plug != PLUGIN_INVALID_HANDLE ) 
+		plugin_unload( victim->plug );
+        xfree( victim );
 }
 
 /*
@@ -151,31 +152,33 @@ plugrack_entry_destructor( void *v )
  */
 static int
 accept_path_paranoia( plugrack_t rack,
-		      const char *fq_path,
-		      int check_own,
-		      int check_write )
+                      const char *fq_path,
+                      int check_own,
+                      int check_write )
 {
-	struct stat st;
+        struct stat st;
 
-	/* Internal function, so assert rather than fail gracefully. */
-	xassert( rack );
-	xassert( fq_path );
+        /* Internal function, so assert rather than fail gracefully. */
+        xassert( rack );
+        xassert( fq_path );
   
-	if ( stat( fq_path, &st ) < 0 ) {
-		return 0;
-	}
+        if ( stat( fq_path, &st ) < 0 ) {
+                return 0;
+        }
   
-	/* Is path owned by authorized user? */
-	if ( check_own ) {
-		if ( st.st_uid != rack->uid ) return 0;
-	}
-
-	/* Is path writable by others? */
-	if ( check_write ) {
-		if ( ( st.st_mode & S_IWGRP ) || ( st.st_mode & S_IWOTH ) ) return 0;
-	}
-
-	return 1;
+        /* Is path owned by authorized user? */
+        if ( check_own ) {
+                if ( st.st_uid != rack->uid ) return 0;
+        }
+
+        /* Is path writable by others? */
+        if ( check_write ) {
+                if (  ( st.st_mode & S_IWGRP ) 
+		   || ( st.st_mode & S_IWOTH ) ) 
+			return 0;
+        }
+
+        return 1;
 }
 
 
@@ -192,41 +195,45 @@ accept_path_paranoia( plugrack_t rack,
 static int
 accept_paranoia( plugrack_t rack, const char *fq_path )
 {
-	char *local;
-	char *p;
+        char *local;
+        char *p;
   
-	xassert( rack );
-	xassert( fq_path );
+        xassert( rack );
+        xassert( fq_path );
 
-	/* Trivial accept. */
-	if ( ! rack->paranoia ) return 1;
+        /* Trivial accept. */
+        if ( ! rack->paranoia ) return 1;
   
-	/* Make a local copy of the path name so we can write into it. */
-	local = alloca( strlen( fq_path ) + 1 );
-	strcpy( local, fq_path );
-
-	if ( ! accept_path_paranoia( rack,
-								 local,
-								 rack->paranoia & PLUGRACK_PARANOIA_FILE_OWN,
-								 rack->paranoia & PLUGRACK_PARANOIA_FILE_WRITABLE ) ) {
-		return 0;
-	}
-
-	/*
-	 * Find the directory name by chopping off the last path element.
-	 * This also helps weed out malformed file names.  We specify that
-	 * plugins be specified by fully-qualified pathnames and that means
-	 * it should have at least one delimiter.
-	 */
-	if ( ( p = strrchr( local, '/' ) ) == NULL ) {
-		return 0;
-	}
-	if ( p != local ) *p = 0;
-
-	return accept_path_paranoia( rack,
-								 local,
-								 rack->paranoia & PLUGRACK_PARANOIA_DIR_OWN,
-								 rack->paranoia & PLUGRACK_PARANOIA_DIR_WRITABLE );
+        /* Make a local copy of the path name so we can write into it. */
+        local = alloca( strlen( fq_path ) + 1 );
+        strcpy( local, fq_path );
+
+        if ( ! accept_path_paranoia( rack,
+                                     local,
+                                     rack->paranoia & 
+				     PLUGRACK_PARANOIA_FILE_OWN,
+                                     rack->paranoia & 
+				     PLUGRACK_PARANOIA_FILE_WRITABLE ) ) {
+                return 0;
+        }
+
+        /*
+         * Find the directory name by chopping off the last path element.
+         * This also helps weed out malformed file names.  We specify that
+         * plugins be specified by fully-qualified pathnames and that means
+         * it should have at least one delimiter.
+         */
+        if ( ( p = strrchr( local, '/' ) ) == NULL ) {
+                return 0;
+        }
+        if ( p != local ) *p = 0;
+
+        return accept_path_paranoia( rack,
+                                     local,
+                                     rack->paranoia & 
+				     PLUGRACK_PARANOIA_DIR_OWN,
+                                     rack->paranoia & 
+				     PLUGRACK_PARANOIA_DIR_WRITABLE );
 }
 
 /*
@@ -236,353 +243,358 @@ accept_paranoia( plugrack_t rack, const char *fq_path )
 static plugin_handle_t
 plugrack_open_plugin( plugrack_t rack, const char *fq_path )
 {
-	plugin_handle_t plug;
+        plugin_handle_t plug;
 
-	if ( ! rack ) return PLUGIN_INVALID_HANDLE;
-	if ( ! fq_path ) return PLUGIN_INVALID_HANDLE;
+        if ( ! rack ) return PLUGIN_INVALID_HANDLE;
+        if ( ! fq_path ) return PLUGIN_INVALID_HANDLE;
   
-	/* See if we can actually load the plugin. */
-	plug = plugin_load_from_file( fq_path );
-	if ( plug == PLUGIN_INVALID_HANDLE ) return PLUGIN_INVALID_HANDLE;
-
-	/* Now see if this is the right type. */
-	if ( rack->major_type &&
-		 ( strncmp( rack->major_type,
-					plugin_get_type( plug ),
-					strlen( rack->major_type ) ) != 0 ) ) {
-		plugin_unload( plug );
-		return PLUGIN_INVALID_HANDLE;
-	}
-
-	return plug;
+        /* See if we can actually load the plugin. */
+        plug = plugin_load_from_file( fq_path );
+        if ( plug == PLUGIN_INVALID_HANDLE ) return PLUGIN_INVALID_HANDLE;
+
+        /* Now see if this is the right type. */
+        if (   rack->major_type 
+	    && ( strncmp( rack->major_type,
+                          plugin_get_type( plug ),
+                          strlen( rack->major_type ) ) != 0 ) ) {
+                plugin_unload( plug );
+                return PLUGIN_INVALID_HANDLE;
+        }
+
+        return plug;
 }
 
 
 plugrack_t plugrack_create( void )
 {
-	plugrack_t rack = (plugrack_t) xmalloc( sizeof( struct _plugrack ) );
-
-	rack->paranoia     = PLUGRACK_PARANOIA_NONE;
-	rack->major_type   = NULL;
-	rack->uid          = PLUGRACK_UID_NOBODY;
-	rack->entries      = list_create( plugrack_entry_destructor );
-	if ( rack->entries == NULL ) {
-		xfree( rack );
-		return NULL;
-	}
-	return rack;
+        plugrack_t rack = (plugrack_t) xmalloc( sizeof( struct _plugrack ) );
+
+        rack->paranoia     = PLUGRACK_PARANOIA_NONE;
+        rack->major_type   = NULL;
+        rack->uid          = PLUGRACK_UID_NOBODY;
+        rack->entries      = list_create( plugrack_entry_destructor );
+        if ( rack->entries == NULL ) {
+                xfree( rack );
+                return NULL;
+        }
+        return rack;
 }
 
 
 int
 plugrack_destroy( plugrack_t rack )
 {
-	ListIterator it;
-	plugrack_entry_t *e;
+        ListIterator it;
+        plugrack_entry_t *e;
   
-	if ( ! rack ) return SLURM_ERROR;
-
-	/*
-	 * See if there are any plugins still being used.  If we unload them,
-	 * the program might crash because cached virtual mapped addresses
-	 * will suddenly be outside our virtual address space.
-	 */
-	it = list_iterator_create( rack->entries );
-	while ( ( e = list_next( it ) ) != NULL ) {
-		if ( e->refcount > 0 ) {
-			list_iterator_destroy( it );
-			return SLURM_ERROR; /* plugins still in use. */
-		}
-	}
-	list_iterator_destroy( it );
-
-	list_destroy( rack->entries );
-	xfree( rack );
-	return SLURM_SUCCESS;
+        if ( ! rack ) return SLURM_ERROR;
+
+        /*
+         * See if there are any plugins still being used.  If we unload them,
+         * the program might crash because cached virtual mapped addresses
+         * will suddenly be outside our virtual address space.
+         */
+        it = list_iterator_create( rack->entries );
+        while ( ( e = list_next( it ) ) != NULL ) {
+                if ( e->refcount > 0 ) {
+                        list_iterator_destroy( it );
+                        return SLURM_ERROR; /* plugins still in use. */
+                }
+        }
+        list_iterator_destroy( it );
+
+        list_destroy( rack->entries );
+        xfree( rack );
+        return SLURM_SUCCESS;
 }
 
 
 int
 plugrack_set_major_type( plugrack_t rack, const char *type )
 {
-	if ( ! rack ) return SLURM_ERROR;
-	if ( ! type ) return SLURM_ERROR;
-
-	/* Free any pre-existing type. */
-	if ( rack->major_type ) xfree( rack->major_type );
-	rack->major_type = NULL;
-
-	/* Install a new one. */
-	if ( type != NULL ) {
-		rack->major_type = xstrdup( type );
-		if ( rack->major_type == NULL ) return SLURM_ERROR;
-	}
+        if ( ! rack ) return SLURM_ERROR;
+        if ( ! type ) return SLURM_ERROR;
+
+        /* Free any pre-existing type. */
+        if ( rack->major_type ) xfree( rack->major_type );
+        rack->major_type = NULL;
+
+        /* Install a new one. */
+        if ( type != NULL ) {
+                rack->major_type = xstrdup( type );
+                if ( rack->major_type == NULL ) return SLURM_ERROR;
+        }
   
-	return SLURM_SUCCESS;
+        return SLURM_SUCCESS;
 }
 
 
 int
 plugrack_set_paranoia( plugrack_t rack,
-		       const uint32_t flags,
-		       const uid_t uid )
+                       const uint32_t flags,
+                       const uid_t uid )
 
 {
-	if ( ! rack ) return SLURM_ERROR;
+        if ( ! rack ) return SLURM_ERROR;
 
-	rack->paranoia = flags;
-	if ( flags ) {
-		rack->uid = uid;
-	}
+        rack->paranoia = flags;
+        if ( flags ) {
+                rack->uid = uid;
+        }
 
-	return SLURM_SUCCESS;
+        return SLURM_SUCCESS;
 }
 
 int
 plugrack_add_opened_plugin( plugrack_t rack,
-							plugin_handle_t *plug,
-							const char *fq_path )
+                                                        plugin_handle_t *plug,
+                                                        const char *fq_path )
 {
-	plugrack_entry_t *e;
+        plugrack_entry_t *e;
   
-	if ( ! rack ) return SLURM_ERROR;
-	if ( ! plug ) return SLURM_ERROR;
-	if ( ! fq_path ) return SLURM_ERROR;
+        if ( ! rack ) return SLURM_ERROR;
+        if ( ! plug ) return SLURM_ERROR;
+        if ( ! fq_path ) return SLURM_ERROR;
 
-	e = (plugrack_entry_t *) xmalloc( sizeof( plugrack_entry_t ) );
+        e = (plugrack_entry_t *) xmalloc( sizeof( plugrack_entry_t ) );
 
-	e->full_type = xstrdup( plugin_get_type( plug ) );
-	e->fq_path	= xstrdup( fq_path );
-	e->plug	= plug;
-	e->refcount	= 0;
+        e->full_type = xstrdup( plugin_get_type( plug ) );
+        e->fq_path   = xstrdup( fq_path );
+        e->plug      = plug;
+        e->refcount  = 0;
   
-	list_append( rack->entries, e );
+        list_append( rack->entries, e );
 
-	return SLURM_SUCCESS;
+        return SLURM_SUCCESS;
 }
 
   
 int
 plugrack_add_plugin_file( plugrack_t rack, const char *fq_path )
 {
-	plugin_handle_t plug;
+        plugin_handle_t plug;
 
-	if ( ! rack ) return SLURM_ERROR;
-	if ( ! fq_path ) return SLURM_ERROR;
+        if ( ! rack ) return SLURM_ERROR;
+        if ( ! fq_path ) return SLURM_ERROR;
 
-	/*
-	 * See if we should open this plugin.  Paranoia checks must
-	 * always be done first since code can be executed in the plugin
-	 * simply by opening it.
-	 */
-	if ( ! accept_paranoia( rack, fq_path ) ) return SLURM_ERROR;
+        /*
+         * See if we should open this plugin.  Paranoia checks must
+         * always be done first since code can be executed in the plugin
+         * simply by opening it.
+         */
+        if ( ! accept_paranoia( rack, fq_path ) ) return SLURM_ERROR;
 
-	/* Try to open plugin, testing the type. */
-	plug = plugrack_open_plugin( rack, fq_path );
-	if ( plug == PLUGIN_INVALID_HANDLE ) return SLURM_ERROR;
+        /* Try to open plugin, testing the type. */
+        plug = plugrack_open_plugin( rack, fq_path );
+        if ( plug == PLUGIN_INVALID_HANDLE ) return SLURM_ERROR;
 
-	/* Add it to the list. */
-	return plugrack_add_opened_plugin( rack, plug, fq_path );
+        /* Add it to the list. */
+        return plugrack_add_opened_plugin( rack, plug, fq_path );
 }
 
 
 
 int
 plugrack_read_dir( plugrack_t rack,
-		   const char *dir )
+                   const char *dir )
 {
-	char *fq_path;
-	char *tail;
-	DIR *dirp;
-	struct dirent *e;
-	struct stat st;
-	plugin_handle_t plug;
-
-	if ( ! rack ) return SLURM_ERROR;
-	if ( ! dir ) return SLURM_ERROR;
+        char *fq_path;
+        char *tail;
+        DIR *dirp;
+        struct dirent *e;
+        struct stat st;
+        plugin_handle_t plug;
+
+        if ( ! rack ) return SLURM_ERROR;
+        if ( ! dir ) return SLURM_ERROR;
   
-	/* Allocate a buffer for fully-qualified path names. */
-	fq_path = alloca( strlen( dir ) + NAME_MAX + 1 );
-	xassert( fq_path );
-
-	/*
-	 * Write the directory name in it, then a separator, then
-	 * keep track of where we want to write the individual file
-	 * names.
-	 */
-	strcpy( fq_path, dir );
-	tail = &fq_path[ strlen( dir ) ];
-	*tail = '/';
-	++tail;
-
-	/* Check whether we should be paranoid about this directory. */
-	if ( ! accept_path_paranoia( rack,
-								 dir,
-								 rack->paranoia & PLUGRACK_PARANOIA_DIR_OWN,
-								 rack->paranoia & PLUGRACK_PARANOIA_DIR_WRITABLE ) ) {
-		return SLURM_ERROR;
-	}
+        /* Allocate a buffer for fully-qualified path names. */
+        fq_path = alloca( strlen( dir ) + NAME_MAX + 1 );
+        xassert( fq_path );
+
+        /*
+         * Write the directory name in it, then a separator, then
+         * keep track of where we want to write the individual file
+         * names.
+         */
+        strcpy( fq_path, dir );
+        tail = &fq_path[ strlen( dir ) ];
+        *tail = '/';
+        ++tail;
+
+        /* Check whether we should be paranoid about this directory. */
+        if ( ! accept_path_paranoia( rack,
+                                     dir,
+                                     rack->paranoia & 
+				     PLUGRACK_PARANOIA_DIR_OWN,
+                                     rack->paranoia & 
+				     PLUGRACK_PARANOIA_DIR_WRITABLE ) ) {
+                return SLURM_ERROR;
+        }
   
-	/* Open the directory. */
-	dirp = opendir( dir );
-	if ( dirp == NULL ) return SLURM_ERROR;
+        /* Open the directory. */
+        dirp = opendir( dir );
+        if ( dirp == NULL ) return SLURM_ERROR;
   
-	while ( 1 ) {
-		e = readdir( dirp );
-		if ( e == NULL ) break;
-
-		/*
-		 * Compose file name.  Where NAME_MAX is defined it represents the
-		 * largest file name given in a dirent.  This macro is used in the
-		 * allocation of "tail" above, so this unbounded copy should work.
-		 */
-		strcpy( tail, e->d_name );
-
-		/* Check only regular files. */
-		if ( stat( fq_path, &st ) < 0 ) continue;
-		if ( ! S_ISREG( st.st_mode ) ) continue;
-
-		/* See if we should be paranoid about this file. */
-		if ( ! accept_path_paranoia( rack,
-									 dir,
-									 rack->paranoia & PLUGRACK_PARANOIA_FILE_OWN,
-									 rack->paranoia & PLUGRACK_PARANOIA_FILE_WRITABLE ) ) {
-			continue;
-		}
-
-		/* Load the plugin. */
-		plug = plugrack_open_plugin( rack, fq_path );
-		if ( plug == PLUGIN_INVALID_HANDLE ) {
-			continue;
-		}
+        while ( 1 ) {
+                e = readdir( dirp );
+                if ( e == NULL ) break;
+
+                /*
+                 * Compose file name.  Where NAME_MAX is defined it represents 
+		 * the largest file name given in a dirent.  This macro is used
+		 * in the  allocation of "tail" above, so this unbounded copy 
+		 * should work.
+                 */
+                strcpy( tail, e->d_name );
+
+                /* Check only regular files. */
+                if ( stat( fq_path, &st ) < 0 ) continue;
+                if ( ! S_ISREG( st.st_mode ) ) continue;
+
+                /* See if we should be paranoid about this file. */
+                if (!accept_path_paranoia( rack,
+                                           dir,
+                                           rack->paranoia & 
+                                           PLUGRACK_PARANOIA_FILE_OWN,
+                                           rack->paranoia & 
+                                           PLUGRACK_PARANOIA_FILE_WRITABLE )) {
+                        continue;
+                }
+
+                /* Load the plugin. */
+                plug = plugrack_open_plugin( rack, fq_path );
+                if ( plug == PLUGIN_INVALID_HANDLE ) {
+                        continue;
+                }
     
-		/* Add it to the list. */
-		(void) plugrack_add_opened_plugin( rack, plug, fq_path );    
-	}
+                /* Add it to the list. */
+                (void) plugrack_add_opened_plugin( rack, plug, fq_path );    
+        }
 
-	return SLURM_SUCCESS;
+        return SLURM_SUCCESS;
 }
 
 int
 plugrack_read_cache( plugrack_t rack,
-		     const char *cache_file )
+                     const char *cache_file )
 {
-	/* Don't care for now. */
+        /* Don't care for now. */
   
-	return SLURM_ERROR;
+        return SLURM_ERROR;
 }
 
 
 int
 plugrack_purge_idle( plugrack_t rack )
 {
-	ListIterator it;
-	plugrack_entry_t *e;
+        ListIterator it;
+        plugrack_entry_t *e;
   
-	if ( ! rack ) return SLURM_ERROR;
-
-	it = list_iterator_create( rack->entries );
-	while ( ( e = list_next( it ) ) != NULL ) {
-		if ( ( e->plug != PLUGIN_INVALID_HANDLE ) &&
-			 ( e->refcount == 0 ) ){
-			plugin_unload( e->plug );
-			e->plug = PLUGIN_INVALID_HANDLE;
-		}
-	}
-
-	list_iterator_destroy( it );
-	return SLURM_SUCCESS;
+        if ( ! rack ) return SLURM_ERROR;
+
+        it = list_iterator_create( rack->entries );
+        while ( ( e = list_next( it ) ) != NULL ) {
+                if ( ( e->plug != PLUGIN_INVALID_HANDLE ) &&
+                         ( e->refcount == 0 ) ){
+                        plugin_unload( e->plug );
+                        e->plug = PLUGIN_INVALID_HANDLE;
+                }
+        }
+
+        list_iterator_destroy( it );
+        return SLURM_SUCCESS;
 }
 
 
 int
 plugrack_load_all( plugrack_t rack )
 {
-	ListIterator it;
-	plugrack_entry_t *e;
+        ListIterator it;
+        plugrack_entry_t *e;
 
-	if ( ! rack ) return SLURM_ERROR;
+        if ( ! rack ) return SLURM_ERROR;
 
-	it = list_iterator_create( rack->entries );
-	while ( ( e = list_next( it ) ) != NULL ) {
-		if ( e->plug == PLUGIN_INVALID_HANDLE ) {
-			(void) plugin_load_from_file( e->fq_path );
-		}
-	}
+        it = list_iterator_create( rack->entries );
+        while ( ( e = list_next( it ) ) != NULL ) {
+                if ( e->plug == PLUGIN_INVALID_HANDLE ) {
+                        (void) plugin_load_from_file( e->fq_path );
+                }
+        }
 
-	list_iterator_destroy( it );
-	return SLURM_SUCCESS;
+        list_iterator_destroy( it );
+        return SLURM_SUCCESS;
 }
 
 
 int
 plugrack_write_cache( plugrack_t rack,
-		      const char *cache )
+                      const char *cache )
 {
-	/* Not implemented. */
+        /* Not implemented. */
   
-	return SLURM_SUCCESS;
+        return SLURM_SUCCESS;
 }
 
 plugin_handle_t
 plugrack_use_by_type( plugrack_t rack,
-		      const char *full_type )
+                      const char *full_type )
 {
-	ListIterator it;
-	plugrack_entry_t *e;
+        ListIterator it;
+        plugrack_entry_t *e;
   
-	if ( ! rack ) return PLUGIN_INVALID_HANDLE;
-	if ( ! full_type ) return PLUGIN_INVALID_HANDLE;
-
-	it = list_iterator_create( rack->entries );
-	while ( ( e = list_next( it ) ) != NULL ) {
-		if ( strcmp( full_type, e->full_type ) != 0 ) continue;
-
-		/* See if plugin is loaded. */
-		if ( e->plug == PLUGIN_INVALID_HANDLE ) {
-			e->plug = plugin_load_from_file( e->fq_path );
-		}
-
-		/* If load was successful, increment the reference count. */
-		if ( e->plug == PLUGIN_INVALID_HANDLE )
-			e->refcount++;
-
-		/*
-		 * Return the plugin, even if it failed to load -- this serves
-		 * as an error return value.
-		 */
-		list_iterator_destroy( it );
-		return e->plug;
-	}
-
-	/* Couldn't find a suitable plugin. */
-	list_iterator_destroy( it );
-	return PLUGIN_INVALID_HANDLE;
+        if ( ! rack ) return PLUGIN_INVALID_HANDLE;
+        if ( ! full_type ) return PLUGIN_INVALID_HANDLE;
+
+        it = list_iterator_create( rack->entries );
+        while ( ( e = list_next( it ) ) != NULL ) {
+                if ( strcmp( full_type, e->full_type ) != 0 ) continue;
+
+                /* See if plugin is loaded. */
+                if ( e->plug == PLUGIN_INVALID_HANDLE ) {
+                        e->plug = plugin_load_from_file( e->fq_path );
+                }
+
+                /* If load was successful, increment the reference count. */
+                if ( e->plug == PLUGIN_INVALID_HANDLE )
+                        e->refcount++;
+
+                /*
+                 * Return the plugin, even if it failed to load -- this serves
+                 * as an error return value.
+                 */
+                list_iterator_destroy( it );
+                return e->plug;
+        }
+
+        /* Couldn't find a suitable plugin. */
+        list_iterator_destroy( it );
+        return PLUGIN_INVALID_HANDLE;
 }
 
 
 int
 plugrack_finished_with_plugin( plugrack_t rack, plugin_handle_t plug )
 {
-	ListIterator it;
-	plugrack_entry_t *e;
+        ListIterator it;
+        plugrack_entry_t *e;
 
-	if ( ! rack ) return SLURM_ERROR;
+        if ( ! rack ) return SLURM_ERROR;
 
-	it = list_iterator_create( rack->entries );
-	while ( ( e = list_next( it ) ) != NULL ) {
-		if ( e->plug == plug ) {
-			e->refcount--;
-			if ( e->refcount < 0 ) e->refcount = 0;
+        it = list_iterator_create( rack->entries );
+        while ( ( e = list_next( it ) ) != NULL ) {
+                if ( e->plug == plug ) {
+                        e->refcount--;
+                        if ( e->refcount < 0 ) e->refcount = 0;
 
-			/* Do something here with purge policy. */
+                        /* Do something here with purge policy. */
 
-			list_iterator_destroy( it );
-			return SLURM_SUCCESS;
-		}
-	}
+                        list_iterator_destroy( it );
+                        return SLURM_SUCCESS;
+                }
+        }
 
-	/* Plugin not in this rack. */
-	list_iterator_destroy( it );
-	return SLURM_ERROR;
+        /* Plugin not in this rack. */
+        list_iterator_destroy( it );
+        return SLURM_ERROR;
 }
diff --git a/src/common/slurm_auth.c b/src/common/slurm_auth.c
index 53ae50788f..f2eb72518c 100644
--- a/src/common/slurm_auth.c
+++ b/src/common/slurm_auth.c
@@ -46,16 +46,16 @@
  * end of the structure.
  */
 typedef struct slurm_auth_ops {
-	void *	(*create)	( void *argv[] );
-	int	(*destroy)		( void *cred );
-	int	(*verify)	( void *cred, void *argv[] );
-	uid_t	(*get_uid)	( void *cred );
-	gid_t	(*get_gid)	( void *cred );
-	int	(*pack)		( void *cred, Buf buf );
-	void *	(*unpack)	( Buf buf );
-	int	(*print)	( void *cred, FILE *fp );
-	int	(*sa_errno)	( void *cred );
-	const char * (*sa_errstr) ( int slurm_errno );
+        void *       (*create)    ( void *argv[] );
+        int          (*destroy)   ( void *cred );
+        int          (*verify)    ( void *cred, void *argv[] );
+        uid_t        (*get_uid)   ( void *cred );
+        gid_t        (*get_gid)   ( void *cred );
+        int          (*pack)      ( void *cred, Buf buf );
+        void *       (*unpack)    ( Buf buf );
+        int          (*print)     ( void *cred, FILE *fp );
+        int          (*sa_errno)  ( void *cred );
+        const char * (*sa_errstr) ( int slurm_errno );
 } slurm_auth_ops_t;
 
 /*
@@ -78,11 +78,11 @@ typedef struct slurm_auth_ops {
  * into the plugin's symbol table.
  */
 struct slurm_auth_context {
-	char *auth_type;
-	plugrack_t plugin_list;
-	plugin_handle_t	cur_plugin;
-	int auth_errno;
-	slurm_auth_ops_t ops;
+        char *           auth_type;
+        plugrack_t       plugin_list;
+        plugin_handle_t  cur_plugin;
+        int              auth_errno;
+        slurm_auth_ops_t ops;
 };
 
 /*
@@ -92,47 +92,47 @@ struct slurm_auth_context {
 static slurm_auth_context_t g_context    = NULL;
 static pthread_mutex_t      context_lock = PTHREAD_MUTEX_INITIALIZER;
 
-static slurm_ctl_conf_t conf;
-static pthread_mutex_t config_lock = PTHREAD_MUTEX_INITIALIZER;
+static slurm_ctl_conf_t     conf;
+static pthread_mutex_t      config_lock  = PTHREAD_MUTEX_INITIALIZER;
 
 /*
  * Order of advisory arguments passed to some of the plugins.
  */
 static arg_desc_t auth_args[] = {
-	{ ARG_HOST_LIST },
-	{ ARG_TIMEOUT },
-	{ NULL }
+        { ARG_HOST_LIST },
+        { ARG_TIMEOUT },
+        { NULL }
 };
 
 
 static char *
 get_plugin_dir( void )
 {
-	slurm_mutex_lock( &config_lock );
-	if ( conf.slurmd_port == 0 ) {
-		read_slurm_conf_ctl( &conf );
-	}
-	if ( conf.plugindir == NULL ) {
-		conf.plugindir = xstrdup( SLURM_PLUGIN_PATH );
-	}
-	slurm_mutex_unlock( &config_lock );
-	
-	return conf.plugindir;
+        slurm_mutex_lock( &config_lock );
+        if ( conf.slurmd_port == 0 ) {
+                read_slurm_conf_ctl( &conf );
+        }
+        if ( conf.plugindir == NULL ) {
+                conf.plugindir = xstrdup( SLURM_PLUGIN_PATH );
+        }
+        slurm_mutex_unlock( &config_lock );
+        
+        return conf.plugindir;
 }
 
 static char *
 get_auth_type( void )
 {
-	slurm_mutex_lock( &config_lock );
-	if ( conf.slurmd_port == 0 ) {
-		read_slurm_conf_ctl( &conf );
-	}
-	if ( conf.authtype == NULL ) {
-		conf.authtype = xstrdup( "auth/none" );
-	}
-	slurm_mutex_unlock( &config_lock );
-
-	return conf.authtype;
+        slurm_mutex_lock( &config_lock );
+        if ( conf.slurmd_port == 0 ) {
+                read_slurm_conf_ctl( &conf );
+        }
+        if ( conf.authtype == NULL ) {
+                conf.authtype = xstrdup( "auth/none" );
+        }
+        slurm_mutex_unlock( &config_lock );
+
+        return conf.authtype;
 }
 
 
@@ -142,194 +142,196 @@ get_auth_type( void )
 static slurm_auth_ops_t *
 slurm_auth_get_ops( slurm_auth_context_t c )
 {
-	/*
-	 * These strings must be kept in the same order as the fields
-	 * declared for slurm_auth_ops_t.
-	 */
-	static const char *syms[] = {
-		"slurm_auth_create",
-		"slurm_auth_destroy",
-		"slurm_auth_verify",
-		"slurm_auth_get_uid",
-		"slurm_auth_get_gid",
-		"slurm_auth_pack",
-		"slurm_auth_unpack",
-		"slurm_auth_print",
-		"slurm_auth_errno",
-		"slurm_auth_errstr"
-	};
-	int n_syms = sizeof( syms ) / sizeof( char * );
-
-	/* Get the plugin list, if needed. */
-	if ( c->plugin_list == NULL ) {
-		c->plugin_list = plugrack_create();
-		if ( c->plugin_list == NULL ) {
-			verbose( "Unable to create a plugin manager" );
-			return NULL;
-		}
-
-		plugrack_set_major_type( c->plugin_list, "auth" );
-		plugrack_set_paranoia( c->plugin_list, PLUGRACK_PARANOIA_NONE, 0 );
-		plugrack_read_dir( c->plugin_list, get_plugin_dir() );
-	}
+        /*
+         * These strings must be kept in the same order as the fields
+         * declared for slurm_auth_ops_t.
+         */
+        static const char *syms[] = {
+                "slurm_auth_create",
+                "slurm_auth_destroy",
+                "slurm_auth_verify",
+                "slurm_auth_get_uid",
+                "slurm_auth_get_gid",
+                "slurm_auth_pack",
+                "slurm_auth_unpack",
+                "slurm_auth_print",
+                "slurm_auth_errno",
+                "slurm_auth_errstr"
+        };
+        int n_syms = sizeof( syms ) / sizeof( char * );
+
+        /* Get the plugin list, if needed. */
+        if ( c->plugin_list == NULL ) {
+                c->plugin_list = plugrack_create();
+                if ( c->plugin_list == NULL ) {
+                        verbose( "Unable to create a plugin manager" );
+                        return NULL;
+                }
+
+                plugrack_set_major_type( c->plugin_list, "auth" );
+                plugrack_set_paranoia( c->plugin_list, 
+				       PLUGRACK_PARANOIA_NONE, 
+				       0 );
+                plugrack_read_dir( c->plugin_list, get_plugin_dir() );
+        }
   
-	/* Find the correct plugin. */
-	c->cur_plugin = plugrack_use_by_type( c->plugin_list, c->auth_type );
-	if ( c->cur_plugin == PLUGIN_INVALID_HANDLE ) {
-		verbose( "can't find a plugin for type %s", c->auth_type );
-		return NULL;
-	}  
-
-	/* Dereference the API. */
-	if ( plugin_get_syms( c->cur_plugin,
-						  n_syms,
-						  syms,
-						  (void **) &c->ops ) < n_syms ) {
-		verbose( "incomplete plugin detected" );
-		return NULL;
-	}
-
-	return &c->ops;
+        /* Find the correct plugin. */
+        c->cur_plugin = plugrack_use_by_type( c->plugin_list, c->auth_type );
+        if ( c->cur_plugin == PLUGIN_INVALID_HANDLE ) {
+                verbose( "can't find a plugin for type %s", c->auth_type );
+                return NULL;
+        }  
+
+        /* Dereference the API. */
+        if ( plugin_get_syms( c->cur_plugin,
+                              n_syms,
+                              syms,
+                              (void **) &c->ops ) < n_syms ) {
+                verbose( "incomplete plugin detected" );
+                return NULL;
+        }
+
+        return &c->ops;
 }
 
 const arg_desc_t *
 slurm_auth_get_arg_desc( void )
 {
-	return auth_args;
+        return auth_args;
 }
 
 static void **
 slurm_auth_marshal_args( void *hosts, int timeout )
 {
-	static int hostlist_idx = -1;
-	static int timeout_idx = -1;
-	static int count = sizeof( auth_args ) / sizeof( struct _arg_desc ) - 1;
-	void **argv;
-	
-	/* Get indices from descriptor, if we haven't already. */
-	if ( ( hostlist_idx == -1 ) &&
-		 ( timeout_idx == -1 ) ) {
-		hostlist_idx = arg_idx_by_name( auth_args, ARG_HOST_LIST );
-		timeout_idx = arg_idx_by_name( auth_args, ARG_TIMEOUT );		
-	}
-
-	argv = xmalloc( count * sizeof( void * ) );
-	
-	/* Marshal host list.  Don't quite know how to do this yet. */
-	argv[ hostlist_idx ] = hosts;
-
-	/* Marshal timeout.
-	 * This strange looking code avoids warnings on IA64 */
-	argv[ timeout_idx ] = ((char *) NULL) + timeout;
-
-	return argv;
+        static int hostlist_idx = -1;
+        static int timeout_idx = -1;
+        static int count = sizeof( auth_args ) / sizeof( struct _arg_desc ) - 1;
+        void **argv;
+        
+        /* Get indices from descriptor, if we haven't already. */
+        if ( ( hostlist_idx == -1 ) &&
+             ( timeout_idx == -1 ) ) {
+                hostlist_idx = arg_idx_by_name( auth_args, ARG_HOST_LIST );
+                timeout_idx = arg_idx_by_name( auth_args, ARG_TIMEOUT );                
+        }
+
+        argv = xmalloc( count * sizeof( void * ) );
+        
+        /* Marshal host list.  Don't quite know how to do this yet. */
+        argv[ hostlist_idx ] = hosts;
+
+        /* Marshal timeout.
+         * This strange looking code avoids warnings on IA64 */
+        argv[ timeout_idx ] = ((char *) NULL) + timeout;
+
+        return argv;
 }
 
 
 slurm_auth_context_t
 slurm_auth_context_create( const char *auth_type )
 {
-	slurm_auth_context_t c;
+        slurm_auth_context_t c;
 
-	if ( auth_type == NULL ) {
-		debug3( "slurm_auth_context_create: no authentication type" );
-		return NULL;
-	}
+        if ( auth_type == NULL ) {
+                debug3( "slurm_auth_context_create: no authentication type" );
+                return NULL;
+        }
 
-	c = (slurm_auth_context_t) xmalloc( sizeof( struct slurm_auth_context ) );
+        c = xmalloc( sizeof( struct slurm_auth_context ) );
 
-	c->auth_errno = SLURM_SUCCESS;
+        c->auth_errno = SLURM_SUCCESS;
 
-	/* Copy the authentication type. */
-	c->auth_type = strdup( auth_type );
-	if ( c->auth_type == NULL ) {
-		debug3( "can't make local copy of authentication type" );
-		xfree( c );
-		return NULL;
-	}
+        /* Copy the authentication type. */
+        c->auth_type = strdup( auth_type );
+        if ( c->auth_type == NULL ) {
+                debug3( "can't make local copy of authentication type" );
+                xfree( c );
+                return NULL;
+        }
 
-	/* Plugin rack is demand-loaded on first reference. */
-	c->plugin_list = NULL;
-	c->cur_plugin = PLUGIN_INVALID_HANDLE;  
+        /* Plugin rack is demand-loaded on first reference. */
+        c->plugin_list = NULL;
+        c->cur_plugin = PLUGIN_INVALID_HANDLE;  
 
-	return c;
+        return c;
 }
 
 
 static const char *
-slurm_auth_generic_errstr( int slurm_errno )	 
+slurm_auth_generic_errstr( int slurm_errno )         
 {
-	static struct {
-		int err;
-		const char *msg;
-	} generic_table[] = {
-		{ SLURM_SUCCESS, "no error" },
-		{ SLURM_ERROR, "unknown error" },
-		{ SLURM_AUTH_NOPLUGIN, "no authentication plugin installed" },
-		{ SLURM_AUTH_BADARG, "bad argument to plugin function" },
-		{ SLURM_AUTH_MEMORY, "memory management error" },
-		{ SLURM_AUTH_NOUSER, "no such user" },
-		{ SLURM_AUTH_INVALID, "authentication credential invalid" },
-		{ SLURM_AUTH_MISMATCH, "authentication type mismatch" },
-		{ 0, NULL }
-	};
-
-	int i;
-
-	for ( i = 0; ; ++i ) {
-		if ( generic_table[ i ].msg == NULL ) return NULL;
-		if ( generic_table[ i ].err == slurm_errno )
-			return generic_table[ i ].msg;
-	}
+        static struct {
+                int err;
+                const char *msg;
+        } generic_table[] = {
+                { SLURM_SUCCESS, "no error" },
+                { SLURM_ERROR, "unknown error" },
+                { SLURM_AUTH_NOPLUGIN, "no authentication plugin installed" },
+                { SLURM_AUTH_BADARG, "bad argument to plugin function" },
+                { SLURM_AUTH_MEMORY, "memory management error" },
+                { SLURM_AUTH_NOUSER, "no such user" },
+                { SLURM_AUTH_INVALID, "authentication credential invalid" },
+                { SLURM_AUTH_MISMATCH, "authentication type mismatch" },
+                { 0, NULL }
+        };
+
+        int i;
+
+        for ( i = 0; ; ++i ) {
+                if ( generic_table[ i ].msg == NULL ) return NULL;
+                if ( generic_table[ i ].err == slurm_errno )
+                        return generic_table[ i ].msg;
+        }
 }
 
 
 int
 slurm_auth_context_destroy( slurm_auth_context_t c )
 {    
-	/*
-	 * Must check return code here because plugins might still
-	 * be loaded and active.
-	 */
-	if ( c->plugin_list ) {
-		if ( plugrack_destroy( c->plugin_list ) != SLURM_SUCCESS ) {
-			return SLURM_ERROR;
-		}
-	}  
-
-	free( c->auth_type );
-	xfree( c );
-	
-	return SLURM_SUCCESS;
+        /*
+         * Must check return code here because plugins might still
+         * be loaded and active.
+         */
+        if ( c->plugin_list ) {
+                if ( plugrack_destroy( c->plugin_list ) != SLURM_SUCCESS ) {
+                        return SLURM_ERROR;
+                }
+        }  
+
+        free( c->auth_type );
+        xfree( c );
+        
+        return SLURM_SUCCESS;
 }
 
 int
 slurm_auth_init( void )
 {
-	int retval = SLURM_SUCCESS;
-
-	slurm_mutex_lock( &context_lock );
-
-	if ( g_context ) 
-		goto done;
-	
-	g_context = slurm_auth_context_create( get_auth_type() );
-	if ( g_context == NULL ) {
-		error( "cannot create a context for %s", get_auth_type() );
-		retval = SLURM_ERROR;
-		goto done;
-	}
-	
-	if ( slurm_auth_get_ops( g_context ) == NULL ) {
-		error( "cannot resolve plugin operations" );
-		slurm_auth_context_destroy( g_context );
-		g_context = NULL;
-		retval = SLURM_ERROR;
-	}
+        int retval = SLURM_SUCCESS;
+
+        slurm_mutex_lock( &context_lock );
+
+        if ( g_context ) 
+                goto done;
+        
+        g_context = slurm_auth_context_create( get_auth_type() );
+        if ( g_context == NULL ) {
+                verbose( "cannot create a context for %s", get_auth_type() );
+                retval = SLURM_ERROR;
+                goto done;
+        }
+        
+        if ( slurm_auth_get_ops( g_context ) == NULL ) {
+                verbose( "cannot resolve plugin operations" );
+                slurm_auth_context_destroy( g_context );
+                g_context = NULL;
+                retval = SLURM_ERROR;
+        }
 
  done:
-	slurm_mutex_unlock( &context_lock );
-	return retval;
+        slurm_mutex_unlock( &context_lock );
+        return retval;
 }
 
 
@@ -339,119 +341,117 @@ slurm_auth_init( void )
  * context initialization includes a test for the completeness of
  * the API function dispatcher.
  */
-	  
+          
 void *
 g_slurm_auth_create( void *hosts, int timeout )
 {
-	void **argv;
-	void *ret;
-	
-	if ( slurm_auth_init() < 0 )
-		return NULL;
-
-	if ( ( argv = slurm_auth_marshal_args( hosts, timeout ) ) == NULL ) {
-		return NULL;
-	}
-
-	ret = (*(g_context->ops.create))( argv );
-	xfree( argv );
-	return ret;
+        void **argv;
+        void *ret;
+        
+        if ( slurm_auth_init() < 0 )
+                return NULL;
+
+        if ( ( argv = slurm_auth_marshal_args( hosts, timeout ) ) == NULL ) {
+                return NULL;
+        }
+
+        ret = (*(g_context->ops.create))( argv );
+        xfree( argv );
+        return ret;
 }
 
 int
 g_slurm_auth_destroy( void *cred )
 {
-	if ( slurm_auth_init() < 0 )
-		return SLURM_ERROR;
+        if ( slurm_auth_init() < 0 )
+                return SLURM_ERROR;
 
-	return (*(g_context->ops.destroy))( cred );
+        return (*(g_context->ops.destroy))( cred );
 }
 
 int
 g_slurm_auth_verify( void *cred, void *hosts, int timeout )
 {
-	int ret;
-	void **argv;
-	
-	if ( slurm_auth_init() < 0 )
-		return SLURM_ERROR;
-
-	if ( ( argv = slurm_auth_marshal_args( hosts, timeout ) ) == NULL ) {
-		return SLURM_ERROR;
-	}
-	
-	ret = (*(g_context->ops.verify))( cred, argv );
-	xfree( argv );
-	return ret;
+        int ret;
+        void **argv;
+        
+        if ( slurm_auth_init() < 0 )
+                return SLURM_ERROR;
+
+        if ( ( argv = slurm_auth_marshal_args( hosts, timeout ) ) == NULL ) {
+                return SLURM_ERROR;
+        }
+        
+        ret = (*(g_context->ops.verify))( cred, argv );
+        xfree( argv );
+        return ret;
 }
 
 uid_t
 g_slurm_auth_get_uid( void *cred )
 {
-	if ( slurm_auth_init() < 0 )
-		return SLURM_AUTH_NOBODY;
-	
-	return (*(g_context->ops.get_uid))( cred );
+        if ( slurm_auth_init() < 0 )
+                return SLURM_AUTH_NOBODY;
+        
+        return (*(g_context->ops.get_uid))( cred );
 }
 
 gid_t
 g_slurm_auth_get_gid( void *cred )
 {
-	if ( slurm_auth_init() < 0 )
-		return SLURM_AUTH_NOBODY;
-	
-	return (*(g_context->ops.get_gid))( cred );
+        if ( slurm_auth_init() < 0 )
+                return SLURM_AUTH_NOBODY;
+        
+        return (*(g_context->ops.get_gid))( cred );
 }
 
 int
 g_slurm_auth_pack( void *cred, Buf buf )
 {
-	if ( slurm_auth_init() < 0 )
-		return SLURM_ERROR;
-	
-	return (*(g_context->ops.pack))( cred, buf );
+        if ( slurm_auth_init() < 0 )
+                return SLURM_ERROR;
+        
+        return (*(g_context->ops.pack))( cred, buf );
 }
 
 void *
 g_slurm_auth_unpack( Buf buf )
 {
-	if ( slurm_auth_init() < 0 )
-		return NULL;
-	
-	return (*(g_context->ops.unpack))( buf );
+        if ( slurm_auth_init() < 0 )
+                return NULL;
+        
+        return (*(g_context->ops.unpack))( buf );
 }
 
 int
 g_slurm_auth_print( void *cred, FILE *fp )
 {
-	if ( slurm_auth_init() < 0 )
-		return SLURM_ERROR;
-	
-	return (*(g_context->ops.print))( cred, fp );
+        if ( slurm_auth_init() < 0 )
+                return SLURM_ERROR;
+        
+        return (*(g_context->ops.print))( cred, fp );
 }
 
 int
 g_slurm_auth_errno( void *cred )
 {
-	if ( slurm_auth_init() < 0 )
-		return SLURM_ERROR;
+        if ( slurm_auth_init() < 0 )
+                return SLURM_ERROR;
 
-	return (*(g_context->ops.sa_errno))( cred );
+        return (*(g_context->ops.sa_errno))( cred );
 }
 
 const char *
 g_slurm_auth_errstr( int slurm_errno )
 {
-	static char auth_init_msg[] = "authentication initialization failure";
-	char *generic;
-	
-	if ( slurm_auth_init() < 0 )
-		return auth_init_msg;
-
-	if ( ( generic = (char *)
-		   slurm_auth_generic_errstr( slurm_errno ) ) != NULL ) {
-		return generic;
-	}
-
-	return (*(g_context->ops.sa_errstr))( slurm_errno );
+        static char auth_init_msg[] = "authentication initialization failure";
+        char *generic;
+        
+        if ( slurm_auth_init() < 0 )
+                return auth_init_msg;
+
+        if (( generic = (char *) slurm_auth_generic_errstr( slurm_errno ) ))
+                return generic;
+
+        return (*(g_context->ops.sa_errstr))( slurm_errno );
 }

