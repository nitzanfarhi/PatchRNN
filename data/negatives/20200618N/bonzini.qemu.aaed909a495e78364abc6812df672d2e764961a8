commit aaed909a495e78364abc6812df672d2e764961a8
Author: bellard <bellard@c046a42c-6fe2-441c-8c8c-71466251a162>
Date:   Sat Nov 10 15:15:54 2007 +0000

    added cpu_model parameter to cpu_init()
    
    
    git-svn-id: svn://svn.savannah.nongnu.org/qemu/trunk@3562 c046a42c-6fe2-441c-8c8c-71466251a162

diff --git a/darwin-user/main.c b/darwin-user/main.c
index f240f35a66..607d3d65f1 100644
--- a/darwin-user/main.c
+++ b/darwin-user/main.c
@@ -785,6 +785,7 @@ int main(int argc, char **argv)
     int optind;
     short use_gdbstub = 0;
     const char *r;
+    const char *cpu_model;
 
     if (argc <= 1)
         usage();
@@ -855,7 +856,15 @@ int main(int argc, char **argv)
 
     /* NOTE: we need to init the CPU at this stage to get
        qemu_host_page_size */
-    env = cpu_init();
+#if defined(TARGET_I386)
+    cpu_model = "qemu32";
+#elif defined(TARGET_PPC)
+    cpu_model = "750";
+#else
+#error unsupported CPU
+#endif
+    
+    env = cpu_init(cpu_model);
 
     printf("Starting %s with qemu\n----------------\n", filename);
 
diff --git a/exec.c b/exec.c
index b49e520c18..7987803634 100644
--- a/exec.c
+++ b/exec.c
@@ -1314,6 +1314,8 @@ void cpu_abort(CPUState *env, const char *fmt, ...)
 
 CPUState *cpu_copy(CPUState *env)
 {
+#if 0
+    /* XXX: broken, must be handled by each CPU */
     CPUState *new_env = cpu_init();
     /* preserve chaining and index */
     CPUState *next_cpu = new_env->next_cpu;
@@ -1322,6 +1324,9 @@ CPUState *cpu_copy(CPUState *env)
     new_env->next_cpu = next_cpu;
     new_env->cpu_index = cpu_index;
     return new_env;
+#else
+    return NULL;
+#endif
 }
 
 #if !defined(CONFIG_USER_ONLY)
diff --git a/hw/an5206.c b/hw/an5206.c
index d9931df595..b5f93f6711 100644
--- a/hw/an5206.c
+++ b/hw/an5206.c
@@ -37,10 +37,10 @@ static void an5206_init(int ram_size, int vga_ram_size, const char *boot_device,
     uint64_t elf_entry;
     target_ulong entry;
 
-    env = cpu_init();
     if (!cpu_model)
         cpu_model = "m5206";
-    if (cpu_m68k_set_model(env, cpu_model)) {
+    env = cpu_init(cpu_model);
+    if (!env) {
         cpu_abort(env, "Unable to find m68k CPU definition\n");
     }
 
diff --git a/hw/etraxfs.c b/hw/etraxfs.c
index 6697c7d5d5..da2196834a 100644
--- a/hw/etraxfs.c
+++ b/hw/etraxfs.c
@@ -121,7 +121,7 @@ void bareetraxfs_init (int ram_size, int vga_ram_size, const char *boot_device,
     if (cpu_model == NULL) {
         cpu_model = "crisv32";
     }
-    env = cpu_init();
+    env = cpu_init(cpu_model);
 /*    register_savevm("cpu", 0, 3, cpu_save, cpu_load, env); */
     qemu_register_reset(main_cpu_reset, env);
     irqs = qemu_allocate_irqs(dummy_cpu_set_irq, env, 32);
diff --git a/hw/integratorcp.c b/hw/integratorcp.c
index 5d2c651259..0091f4fd18 100644
--- a/hw/integratorcp.c
+++ b/hw/integratorcp.c
@@ -473,10 +473,13 @@ static void integratorcp_init(int ram_size, int vga_ram_size,
     qemu_irq *pic;
     qemu_irq *cpu_pic;
 
-    env = cpu_init();
     if (!cpu_model)
         cpu_model = "arm926";
-    cpu_arm_set_model(env, cpu_model);
+    env = cpu_init(cpu_model);
+    if (!env) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
     bios_offset = ram_size + vga_ram_size;
     /* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash.  */
     /* ??? RAM shoud repeat to fill physical memory space.  */
diff --git a/hw/mcf5208.c b/hw/mcf5208.c
index bcb1c80beb..93f78906d3 100644
--- a/hw/mcf5208.c
+++ b/hw/mcf5208.c
@@ -209,11 +209,12 @@ static void mcf5208evb_init(int ram_size, int vga_ram_size,
     target_ulong entry;
     qemu_irq *pic;
 
-    env = cpu_init();
     if (!cpu_model)
         cpu_model = "m5208";
-    if (cpu_m68k_set_model(env, cpu_model)) {
-        cpu_abort(env, "Unable to find m68k CPU definition\n");
+    env = cpu_init(cpu_model);
+    if (!env) {
+        fprintf(stderr, "Unable to find m68k CPU definition\n");
+        exit(1);
     }
 
     /* Initialize CPU registers.  */
diff --git a/hw/mips_malta.c b/hw/mips_malta.c
index 3b9170a48a..2c193be23d 100644
--- a/hw/mips_malta.c
+++ b/hw/mips_malta.c
@@ -735,7 +735,6 @@ static void main_cpu_reset(void *opaque)
 {
     CPUState *env = opaque;
     cpu_reset(env);
-    cpu_mips_register(env, NULL);
 
     /* The bootload does not need to be rewritten as it is located in a
        read only location. The kernel location and the arguments table
@@ -761,7 +760,6 @@ void mips_malta_init (int ram_size, int vga_ram_size, const char *boot_device,
     /* fdctrl_t *floppy_controller; */
     MaltaFPGAState *malta_fpga;
     int ret;
-    mips_def_t *def;
     qemu_irq *i8259;
     int piix4_devfn;
     uint8_t *eeprom_buf;
@@ -776,10 +774,11 @@ void mips_malta_init (int ram_size, int vga_ram_size, const char *boot_device,
         cpu_model = "24Kf";
 #endif
     }
-    if (mips_find_by_name(cpu_model, &def) != 0)
-        def = NULL;
-    env = cpu_init();
-    cpu_mips_register(env, def);
+    env = cpu_init(cpu_model);
+    if (!env) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
     register_savevm("cpu", 0, 3, cpu_save, cpu_load, env);
     qemu_register_reset(main_cpu_reset, env);
 
diff --git a/hw/mips_mipssim.c b/hw/mips_mipssim.c
index 08e4b0b018..93288a6ef7 100644
--- a/hw/mips_mipssim.c
+++ b/hw/mips_mipssim.c
@@ -94,7 +94,6 @@ static void main_cpu_reset(void *opaque)
 {
     CPUState *env = opaque;
     cpu_reset(env);
-    cpu_mips_register(env, NULL);
 
     if (loaderparams.kernel_filename)
         load_kernel (env);
@@ -120,10 +119,11 @@ mips_mipssim_init (int ram_size, int vga_ram_size, const char *boot_device,
         cpu_model = "24Kf";
 #endif
     }
-    if (mips_find_by_name(cpu_model, &def) != 0)
-        def = NULL;
-    env = cpu_init();
-    cpu_mips_register(env, def);
+    env = cpu_init(cpu_model);
+    if (!env) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
     register_savevm("cpu", 0, 3, cpu_save, cpu_load, env);
     qemu_register_reset(main_cpu_reset, env);
 
diff --git a/hw/mips_pica61.c b/hw/mips_pica61.c
index d79f7bea35..8e7ce6ce37 100644
--- a/hw/mips_pica61.c
+++ b/hw/mips_pica61.c
@@ -51,7 +51,6 @@ static void main_cpu_reset(void *opaque)
 {
     CPUState *env = opaque;
     cpu_reset(env);
-    cpu_mips_register(env, NULL);
 }
 
 static
@@ -78,10 +77,11 @@ void mips_pica61_init (int ram_size, int vga_ram_size, const char *boot_device,
         cpu_model = "24Kf";
 #endif
     }
-    if (mips_find_by_name(cpu_model, &def) != 0)
-        def = NULL;
-    env = cpu_init();
-    cpu_mips_register(env, def);
+    env = cpu_init(cpu_model);
+    if (!env) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
     register_savevm("cpu", 0, 3, cpu_save, cpu_load, env);
     qemu_register_reset(main_cpu_reset, env);
 
diff --git a/hw/mips_r4k.c b/hw/mips_r4k.c
index e4817e6b7f..5a8bf6c244 100644
--- a/hw/mips_r4k.c
+++ b/hw/mips_r4k.c
@@ -135,7 +135,6 @@ static void main_cpu_reset(void *opaque)
 {
     CPUState *env = opaque;
     cpu_reset(env);
-    cpu_mips_register(env, NULL);
 
     if (loaderparams.kernel_filename)
         load_kernel (env);
@@ -164,10 +163,11 @@ void mips_r4k_init (int ram_size, int vga_ram_size, const char *boot_device,
         cpu_model = "24Kf";
 #endif
     }
-    if (mips_find_by_name(cpu_model, &def) != 0)
-        def = NULL;
-    env = cpu_init();
-    cpu_mips_register(env, def);
+    env = cpu_init(cpu_model);
+    if (!env) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
     register_savevm("cpu", 0, 3, cpu_save, cpu_load, env);
     qemu_register_reset(main_cpu_reset, env);
 
diff --git a/hw/omap.c b/hw/omap.c
index 4efc5fa1be..a0f0a1925e 100644
--- a/hw/omap.c
+++ b/hw/omap.c
@@ -4620,15 +4620,20 @@ struct omap_mpu_state_s *omap310_mpu_init(unsigned long sdram_size,
     struct omap_mpu_state_s *s = (struct omap_mpu_state_s *)
             qemu_mallocz(sizeof(struct omap_mpu_state_s));
     ram_addr_t imif_base, emiff_base;
+    
+    if (!core)
+        core = "ti925t";
 
     /* Core */
     s->mpu_model = omap310;
-    s->env = cpu_init();
+    s->env = cpu_init(core);
+    if (!s->env) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
     s->sdram_size = sdram_size;
     s->sram_size = OMAP15XX_SRAM_SIZE;
 
-    cpu_arm_set_model(s->env, core ?: "ti925t");
-
     s->wakeup = qemu_allocate_irqs(omap_mpu_wakeup, s, 1)[0];
 
     /* Clocks */
diff --git a/hw/pc.c b/hw/pc.c
index f6192f76bc..727ae3a235 100644
--- a/hw/pc.c
+++ b/hw/pc.c
@@ -700,12 +700,12 @@ static void pc_init1(int ram_size, int vga_ram_size, const char *boot_device,
 #endif
     }
     
-    if (x86_find_cpu_by_name(cpu_model)) {
-        fprintf(stderr, "Unable to find x86 CPU definition\n");
-        exit(1);
-    }
     for(i = 0; i < smp_cpus; i++) {
-        env = cpu_init();
+        env = cpu_init(cpu_model);
+        if (!env) {
+            fprintf(stderr, "Unable to find x86 CPU definition\n");
+            exit(1);
+        }
         if (i != 0)
             env->hflags |= HF_HALTED_MASK;
         if (smp_cpus > 1) {
diff --git a/hw/ppc4xx_devs.c b/hw/ppc4xx_devs.c
index 8cefd74703..72490b0894 100644
--- a/hw/ppc4xx_devs.c
+++ b/hw/ppc4xx_devs.c
@@ -37,17 +37,14 @@ CPUState *ppc4xx_init (const unsigned char *cpu_model,
                        uint32_t sysclk)
 {
     CPUState *env;
-    ppc_def_t *def;
 
     /* init CPUs */
-    env = cpu_init();
-    ppc_find_by_name(cpu_model, &def);
-    if (def == NULL) {
-        cpu_abort(env, "Unable to find PowerPC %s CPU definition\n",
-                  cpu_model);
+    env = cpu_init(cpu_model);
+    if (!env) {
+        fprintf(stderr, "Unable to find PowerPC %s CPU definition\n",
+                cpu_model);
+        exit(1);
     }
-    cpu_ppc_register(env, def);
-    cpu_ppc_reset(env);
     cpu_clk->cb = NULL; /* We don't care about CPU clock frequency changes */
     cpu_clk->opaque = env;
     /* Set time-base frequency to sysclk */
diff --git a/hw/ppc_chrp.c b/hw/ppc_chrp.c
index 387da50aef..a791af2693 100644
--- a/hw/ppc_chrp.c
+++ b/hw/ppc_chrp.c
@@ -56,14 +56,13 @@ static void ppc_core99_init (int ram_size, int vga_ram_size,
                              const char *initrd_filename,
                              const char *cpu_model)
 {
-    CPUState *env, *envs[MAX_CPUS];
+    CPUState *env = NULL, *envs[MAX_CPUS];
     char buf[1024];
     qemu_irq *pic, **openpic_irqs;
     int unin_memory;
     int linux_boot, i;
     unsigned long bios_offset, vga_bios_offset;
     uint32_t kernel_base, kernel_size, initrd_base, initrd_size;
-    ppc_def_t *def;
     PCIBus *pci_bus;
     nvram_t nvram;
 #if 0
@@ -80,16 +79,14 @@ static void ppc_core99_init (int ram_size, int vga_ram_size,
     linux_boot = (kernel_filename != NULL);
 
     /* init CPUs */
-    env = cpu_init();
     if (cpu_model == NULL)
         cpu_model = "default";
-    ppc_find_by_name(cpu_model, &def);
-    if (def == NULL) {
-        cpu_abort(env, "Unable to find PowerPC CPU definition\n");
-    }
     for (i = 0; i < smp_cpus; i++) {
-        cpu_ppc_register(env, def);
-        cpu_ppc_reset(env);
+        env = cpu_init(cpu_model);
+        if (!env) {
+            fprintf(stderr, "Unable to find PowerPC CPU definition\n");
+            exit(1);
+        }
         /* Set time-base frequency to 100 Mhz */
         cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);
 #if 0
diff --git a/hw/ppc_oldworld.c b/hw/ppc_oldworld.c
index 49012cddfb..bafe7b5195 100644
--- a/hw/ppc_oldworld.c
+++ b/hw/ppc_oldworld.c
@@ -100,7 +100,7 @@ static void ppc_heathrow_init (int ram_size, int vga_ram_size,
                                const char *initrd_filename,
                                const char *cpu_model)
 {
-    CPUState *env, *envs[MAX_CPUS];
+    CPUState *env = NULL, *envs[MAX_CPUS];
     char buf[1024];
     qemu_irq *pic, **heathrow_irqs;
     nvram_t nvram;
@@ -108,7 +108,6 @@ static void ppc_heathrow_init (int ram_size, int vga_ram_size,
     int linux_boot, i;
     unsigned long bios_offset, vga_bios_offset;
     uint32_t kernel_base, kernel_size, initrd_base, initrd_size;
-    ppc_def_t *def;
     PCIBus *pci_bus;
     MacIONVRAMState *nvr;
     int vga_bios_size, bios_size;
@@ -119,16 +118,14 @@ static void ppc_heathrow_init (int ram_size, int vga_ram_size,
     linux_boot = (kernel_filename != NULL);
 
     /* init CPUs */
-    env = cpu_init();
     if (cpu_model == NULL)
         cpu_model = "default";
-    ppc_find_by_name(cpu_model, &def);
-    if (def == NULL) {
-        cpu_abort(env, "Unable to find PowerPC CPU definition\n");
-    }
     for (i = 0; i < smp_cpus; i++) {
-        cpu_ppc_register(env, def);
-        cpu_ppc_reset(env);
+        env = cpu_init(cpu_model);
+        if (!env) {
+            fprintf(stderr, "Unable to find PowerPC CPU definition\n");
+            exit(1);
+        }
         /* Set time-base frequency to 100 Mhz */
         cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);
         env->osi_call = vga_osi_call;
diff --git a/hw/ppc_prep.c b/hw/ppc_prep.c
index c557f878a3..5474d512ce 100644
--- a/hw/ppc_prep.c
+++ b/hw/ppc_prep.c
@@ -536,7 +536,6 @@ static void ppc_prep_init (int ram_size, int vga_ram_size, const char *boot_devi
     int linux_boot, i, nb_nics1, bios_size;
     unsigned long bios_offset;
     uint32_t kernel_base, kernel_size, initrd_base, initrd_size;
-    ppc_def_t *def;
     PCIBus *pci_bus;
     qemu_irq *i8259;
     int ppc_boot_device = boot_device[0];
@@ -548,16 +547,14 @@ static void ppc_prep_init (int ram_size, int vga_ram_size, const char *boot_devi
     linux_boot = (kernel_filename != NULL);
 
     /* init CPUs */
-    env = cpu_init();
     if (cpu_model == NULL)
         cpu_model = "default";
-    ppc_find_by_name(cpu_model, &def);
-    if (def == NULL) {
-        cpu_abort(env, "Unable to find PowerPC CPU definition\n");
-    }
     for (i = 0; i < smp_cpus; i++) {
-        cpu_ppc_register(env, def);
-        cpu_ppc_reset(env);
+        env = cpu_init(cpu_model);
+        if (!env) {
+            fprintf(stderr, "Unable to find PowerPC CPU definition\n");
+            exit(1);
+        }
         /* Set time-base frequency to 100 Mhz */
         cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);
         qemu_register_reset(&cpu_ppc_reset, env);
diff --git a/hw/pxa2xx.c b/hw/pxa2xx.c
index 6109fc13e9..ebaff1320a 100644
--- a/hw/pxa2xx.c
+++ b/hw/pxa2xx.c
@@ -2023,9 +2023,14 @@ struct pxa2xx_state_s *pxa270_init(unsigned int sdram_size,
         fprintf(stderr, "Machine requires a PXA27x processor.\n");
         exit(1);
     }
-
-    s->env = cpu_init();
-    cpu_arm_set_model(s->env, revision ?: "pxa270");
+    if (!revision)
+        revision = "pxa270";
+    
+    s->env = cpu_init(revision);
+    if (!s->env) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
     register_savevm("cpu", 0, 0, cpu_save, cpu_load, s->env);
 
     /* SDRAM & Internal Memory Storage */
@@ -2132,10 +2137,14 @@ struct pxa2xx_state_s *pxa255_init(unsigned int sdram_size,
     struct pxa2xx_state_s *s;
     struct pxa2xx_ssp_s *ssp;
     int iomemtype, i;
+
     s = (struct pxa2xx_state_s *) qemu_mallocz(sizeof(struct pxa2xx_state_s));
 
-    s->env = cpu_init();
-    cpu_arm_set_model(s->env, "pxa255");
+    s->env = cpu_init("pxa255");
+    if (!s->env) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
     register_savevm("cpu", 0, 0, cpu_save, cpu_load, s->env);
 
     /* SDRAM & Internal Memory Storage */
diff --git a/hw/r2d.c b/hw/r2d.c
index fa35051009..ec6540e36d 100644
--- a/hw/r2d.c
+++ b/hw/r2d.c
@@ -35,7 +35,14 @@ static void r2d_init(int ram_size, int vga_ram_size, const char *boot_device,
     CPUState *env;
     struct SH7750State *s;
 
-    env = cpu_init();
+    if (!cpu_model)
+        cpu_model = "any";
+
+    env = cpu_init(cpu_model);
+    if (!env) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
 
     /* Allocate memory space */
     cpu_register_physical_memory(SDRAM_BASE, SDRAM_SIZE, 0);
diff --git a/hw/realview.c b/hw/realview.c
index b2f4ff278c..f97d6e625a 100644
--- a/hw/realview.c
+++ b/hw/realview.c
@@ -26,10 +26,14 @@ static void realview_init(int ram_size, int vga_ram_size,
     int n;
     int done_smc = 0;
 
-    env = cpu_init();
     if (!cpu_model)
         cpu_model = "arm926";
-    cpu_arm_set_model(env, cpu_model);
+    env = cpu_init(cpu_model);
+    if (!env) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
+
     /* ??? RAM shoud repeat to fill physical memory space.  */
     /* SDRAM at address zero.  */
     cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);
diff --git a/hw/shix.c b/hw/shix.c
index e65427a4c3..0ec2b0e37f 100644
--- a/hw/shix.c
+++ b/hw/shix.c
@@ -70,9 +70,12 @@ static void shix_init(int ram_size, int vga_ram_size, const char *boot_device,
     int ret;
     CPUState *env;
     struct SH7750State *s;
+    
+    if (!cpu_model)
+        cpu_model = "any";
 
     printf("Initializing CPU\n");
-    env = cpu_init();
+    env = cpu_init(cpu_model);
 
     /* Allocate memory space */
     printf("Allocating ROM\n");
diff --git a/hw/sun4m.c b/hw/sun4m.c
index 01e0deead5..7b92add95f 100644
--- a/hw/sun4m.c
+++ b/hw/sun4m.c
@@ -313,21 +313,19 @@ static void *sun4m_hw_init(const struct hwdef *hwdef, int RAM_size,
     CPUState *env, *envs[MAX_CPUS];
     unsigned int i;
     void *iommu, *espdma, *ledma, *main_esp, *nvram;
-    const sparc_def_t *def;
     qemu_irq *cpu_irqs[MAX_CPUS], *slavio_irq, *slavio_cpu_irq,
         *espdma_irq, *ledma_irq;
     qemu_irq *esp_reset, *le_reset;
 
     /* init CPUs */
-    sparc_find_by_name(cpu_model, &def);
-    if (def == NULL) {
-        fprintf(stderr, "Unable to find Sparc CPU definition\n");
-        exit(1);
-    }
 
     for(i = 0; i < smp_cpus; i++) {
-        env = cpu_init();
-        cpu_sparc_register(env, def, i);
+        env = cpu_init(cpu_model);
+        if (!env) {
+            fprintf(stderr, "Unable to find Sparc CPU definition\n");
+            exit(1);
+        }
+        cpu_sparc_set_id(env, i);
         envs[i] = env;
         if (i == 0) {
             qemu_register_reset(main_cpu_reset, env);
diff --git a/hw/sun4u.c b/hw/sun4u.c
index 317ba741a7..bdc6f9510e 100644
--- a/hw/sun4u.c
+++ b/hw/sun4u.c
@@ -343,7 +343,6 @@ static void sun4u_init(int ram_size, int vga_ram_size, const char *boot_device,
     unsigned int i;
     long prom_offset, initrd_size, kernel_size;
     PCIBus *pci_bus;
-    const sparc_def_t *def;
     QEMUBH *bh;
     qemu_irq *irq;
 
@@ -352,13 +351,11 @@ static void sun4u_init(int ram_size, int vga_ram_size, const char *boot_device,
     /* init CPUs */
     if (cpu_model == NULL)
         cpu_model = "TI UltraSparc II";
-    sparc_find_by_name(cpu_model, &def);
-    if (def == NULL) {
+    env = cpu_init(cpu_model);
+    if (!env) {
         fprintf(stderr, "Unable to find Sparc CPU definition\n");
         exit(1);
     }
-    env = cpu_init();
-    cpu_sparc_register(env, def, 0);
     bh = qemu_bh_new(tick_irq, env);
     env->tick = ptimer_init(bh);
     ptimer_set_period(env->tick, 1ULL);
diff --git a/hw/versatilepb.c b/hw/versatilepb.c
index 31d58ef7a2..fc27c4688d 100644
--- a/hw/versatilepb.c
+++ b/hw/versatilepb.c
@@ -167,10 +167,13 @@ static void versatile_init(int ram_size, int vga_ram_size,
     int n;
     int done_smc = 0;
 
-    env = cpu_init();
     if (!cpu_model)
         cpu_model = "arm926";
-    cpu_arm_set_model(env, cpu_model);
+    env = cpu_init(cpu_model);
+    if (!env) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
     /* ??? RAM shoud repeat to fill physical memory space.  */
     /* SDRAM at address zero.  */
     cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);
diff --git a/linux-user/main.c b/linux-user/main.c
index 77667a55e2..18e509d082 100644
--- a/linux-user/main.c
+++ b/linux-user/main.c
@@ -1970,26 +1970,42 @@ int main(int argc, char **argv)
     /* Scan interp_prefix dir for replacement files. */
     init_paths(interp_prefix);
 
-#if defined(TARGET_I386)
-    /* must be done before cpu_init() for x86 XXX: suppress this hack
-       by adding a new parameter to cpu_init and by suppressing
-       cpu_xxx_register() */
     if (cpu_model == NULL) {
+#if defined(TARGET_I386)
 #ifdef TARGET_X86_64
         cpu_model = "qemu64";
 #else
         cpu_model = "qemu32";
 #endif
-    }
-    if (x86_find_cpu_by_name(cpu_model)) {
-        fprintf(stderr, "Unable to find x86 CPU definition\n");
-        exit(1);
-    }
+#elif defined(TARGET_ARM)
+        cpu_model = "arm926";
+#elif defined(TARGET_M68K)
+        cpu_model = "any";
+#elif defined(TARGET_SPARC)
+#ifdef TARGET_SPARC64
+        cpu_model = "TI UltraSparc II";
+#else
+        cpu_model = "Fujitsu MB86904";
 #endif
-
+#elif defined(TARGET_MIPS)
+#if defined(TARGET_ABI_MIPSN32) || defined(TARGET_ABI_MIPSN64)
+        cpu_model = "20Kc";
+#else
+        cpu_model = "24Kf";
+#endif
+#elif defined(TARGET_PPC)
+        cpu_model = "750";
+#else
+        cpu_model = "any";
+#endif
+    }
     /* NOTE: we need to init the CPU at this stage to get
        qemu_host_page_size */
-    env = cpu_init();
+    env = cpu_init(cpu_model);
+    if (!env) {
+        fprintf(stderr, "Unable to find CPU definition\n");
+        exit(1);
+    }
     global_env = env;
 
     if(getenv("QEMU_STRACE") ){
@@ -2130,9 +2146,6 @@ int main(int argc, char **argv)
 #elif defined(TARGET_ARM)
     {
         int i;
-        if (cpu_model == NULL)
-            cpu_model = "arm926";
-        cpu_arm_set_model(env, cpu_model);
         cpsr_write(env, regs->uregs[16], 0xffffffff);
         for(i = 0; i < 16; i++) {
             env->regs[i] = regs->uregs[i];
@@ -2141,20 +2154,6 @@ int main(int argc, char **argv)
 #elif defined(TARGET_SPARC)
     {
         int i;
-        const sparc_def_t *def;
-#ifdef TARGET_SPARC64
-        if (cpu_model == NULL)
-            cpu_model = "TI UltraSparc II";
-#else
-        if (cpu_model == NULL)
-            cpu_model = "Fujitsu MB86904";
-#endif
-        sparc_find_by_name(cpu_model, &def);
-        if (def == NULL) {
-            fprintf(stderr, "Unable to find Sparc CPU definition\n");
-            exit(1);
-        }
-        cpu_sparc_register(env, def, 0);
 	env->pc = regs->pc;
 	env->npc = regs->npc;
         env->y = regs->y;
@@ -2165,19 +2164,8 @@ int main(int argc, char **argv)
     }
 #elif defined(TARGET_PPC)
     {
-        ppc_def_t *def;
         int i;
 
-        /* Choose and initialise CPU */
-        if (cpu_model == NULL)
-            cpu_model = "750";
-        ppc_find_by_name(cpu_model, &def);
-        if (def == NULL) {
-            cpu_abort(env,
-                      "Unable to find PowerPC CPU definition\n");
-        }
-        cpu_ppc_register(env, def);
-        cpu_ppc_reset(env);
 #if defined(TARGET_PPC64)
 #if defined(TARGET_ABI32)
         env->msr &= ~((target_ulong)1 << MSR_SF);
@@ -2192,12 +2180,6 @@ int main(int argc, char **argv)
     }
 #elif defined(TARGET_M68K)
     {
-        if (cpu_model == NULL)
-            cpu_model = "any";
-        if (cpu_m68k_set_model(env, cpu_model)) {
-            cpu_abort(cpu_single_env,
-                      "Unable to find m68k CPU definition\n");
-        }
         env->pc = regs->pc;
         env->dregs[0] = regs->d0;
         env->dregs[1] = regs->d1;
@@ -2220,21 +2202,8 @@ int main(int argc, char **argv)
     }
 #elif defined(TARGET_MIPS)
     {
-        mips_def_t *def;
         int i;
 
-        /* Choose and initialise CPU */
-        if (cpu_model == NULL)
-#if defined(TARGET_ABI_MIPSN32) || defined(TARGET_ABI_MIPSN64)
-            cpu_model = "20Kc";
-#else
-            cpu_model = "24Kf";
-#endif
-        mips_find_by_name(cpu_model, &def);
-        if (def == NULL)
-            cpu_abort(env, "Unable to find MIPS CPU definition\n");
-        cpu_mips_register(env, def);
-
         for(i = 0; i < 32; i++) {
             env->gpr[i][env->current_tc] = regs->regs[i];
         }
diff --git a/target-alpha/cpu.h b/target-alpha/cpu.h
index d65ccdea5b..f8bbc70d7b 100644
--- a/target-alpha/cpu.h
+++ b/target-alpha/cpu.h
@@ -396,7 +396,7 @@ enum {
     IR_ZERO = 31,
 };
 
-CPUAlphaState * cpu_alpha_init (void);
+CPUAlphaState * cpu_alpha_init (const char *cpu_model);
 int cpu_alpha_exec(CPUAlphaState *s);
 /* you can call this signal handler from your SIGBUS and SIGSEGV
    signal handlers to inform the virtual CPU of exceptions. non zero
diff --git a/target-alpha/translate.c b/target-alpha/translate.c
index 6f224b0162..01e6ded123 100644
--- a/target-alpha/translate.c
+++ b/target-alpha/translate.c
@@ -2095,7 +2095,7 @@ int gen_intermediate_code_pc (CPUState *env, struct TranslationBlock *tb)
     return gen_intermediate_code_internal(env, tb, 1);
 }
 
-CPUAlphaState * cpu_alpha_init (void)
+CPUAlphaState * cpu_alpha_init (const char *cpu_model)
 {
     CPUAlphaState *env;
     uint64_t hwpcb;
@@ -2133,3 +2133,4 @@ CPUAlphaState * cpu_alpha_init (void)
 
     return env;
 }
+
diff --git a/target-arm/cpu.h b/target-arm/cpu.h
index 5ffca1145b..fb22b908d7 100644
--- a/target-arm/cpu.h
+++ b/target-arm/cpu.h
@@ -164,7 +164,7 @@ typedef struct CPUARMState {
     target_phys_addr_t loader_start;
 } CPUARMState;
 
-CPUARMState *cpu_arm_init(void);
+CPUARMState *cpu_arm_init(const char *cpu_model);
 int cpu_arm_exec(CPUARMState *s);
 void cpu_arm_close(CPUARMState *s);
 void do_interrupt(CPUARMState *);
@@ -263,7 +263,6 @@ static inline int arm_feature(CPUARMState *env, int feature)
 }
 
 void arm_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...));
-void cpu_arm_set_model(CPUARMState *env, const char *name);
 
 void cpu_arm_set_cp_io(CPUARMState *env, int cpnum,
                        ARMReadCPFunc *cp_read, ARMWriteCPFunc *cp_write,
diff --git a/target-arm/helper.c b/target-arm/helper.c
index d06ee69e7a..06eac66a15 100644
--- a/target-arm/helper.c
+++ b/target-arm/helper.c
@@ -5,6 +5,8 @@
 #include "cpu.h"
 #include "exec-all.h"
 
+static uint32_t cpu_arm_find_by_name(const char *name);
+
 static inline void set_feature(CPUARMState *env, int feature)
 {
     env->features |= 1u << feature;
@@ -89,14 +91,19 @@ void cpu_reset(CPUARMState *env)
     tlb_flush(env, 1);
 }
 
-CPUARMState *cpu_arm_init(void)
+CPUARMState *cpu_arm_init(const char *cpu_model)
 {
     CPUARMState *env;
+    uint32_t id;
 
+    id = cpu_arm_find_by_name(cpu_model);
+    if (id == 0)
+        return NULL;
     env = qemu_mallocz(sizeof(CPUARMState));
     if (!env)
         return NULL;
     cpu_exec_init(env);
+    env->cp15.c0_cpuid = id;
     cpu_reset(env);
     return env;
 }
@@ -136,24 +143,20 @@ void arm_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))
     }
 }
 
-void cpu_arm_set_model(CPUARMState *env, const char *name)
+/* return 0 if not found */
+static uint32_t cpu_arm_find_by_name(const char *name)
 {
     int i;
     uint32_t id;
 
     id = 0;
-    i = 0;
     for (i = 0; arm_cpu_names[i].name; i++) {
         if (strcmp(name, arm_cpu_names[i].name) == 0) {
             id = arm_cpu_names[i].id;
             break;
         }
     }
-    if (!id) {
-        cpu_abort(env, "Unknown CPU '%s'", name);
-        return;
-    }
-    cpu_reset_model_id(env, id);
+    return id;
 }
 
 void cpu_arm_close(CPUARMState *env)
diff --git a/target-cris/cpu.h b/target-cris/cpu.h
index ef0953b263..56b0497f12 100644
--- a/target-cris/cpu.h
+++ b/target-cris/cpu.h
@@ -147,7 +147,7 @@ typedef struct CPUCRISState {
 	CPU_COMMON
 } CPUCRISState;
 
-CPUCRISState *cpu_cris_init(void);
+CPUCRISState *cpu_cris_init(const char *cpu_model);
 int cpu_cris_exec(CPUCRISState *s);
 void cpu_cris_close(CPUCRISState *s);
 void do_interrupt(CPUCRISState *env);
@@ -201,10 +201,6 @@ enum {
 #define CRIS_SSP    0
 #define CRIS_USP    1
 
-typedef struct cris_def_t cris_def_t;
-
-int cpu_cris_set_model(CPUCRISState *env, const char * name);
-
 void cris_set_irq_level(CPUCRISState *env, int level, uint8_t vector);
 void cris_set_macsr(CPUCRISState *env, uint32_t val);
 void cris_switch_sp(CPUCRISState *env);
diff --git a/target-cris/translate.c b/target-cris/translate.c
index 40caef0734..44ba804f25 100644
--- a/target-cris/translate.c
+++ b/target-cris/translate.c
@@ -2488,7 +2488,7 @@ void cpu_dump_state (CPUState *env, FILE *f,
 
 }
 
-CPUCRISState *cpu_cris_init (void)
+CPUCRISState *cpu_cris_init (const char *cpu_model)
 {
 	CPUCRISState *env;
 
diff --git a/target-i386/cpu.h b/target-i386/cpu.h
index c8fb125916..a6ad54be3a 100644
--- a/target-i386/cpu.h
+++ b/target-i386/cpu.h
@@ -585,10 +585,9 @@ typedef struct CPUX86State {
     struct APICState *apic_state;
 } CPUX86State;
 
-CPUX86State *cpu_x86_init(void);
+CPUX86State *cpu_x86_init(const char *cpu_model);
 int cpu_x86_exec(CPUX86State *s);
 void cpu_x86_close(CPUX86State *s);
-int x86_find_cpu_by_name (const unsigned char *name);
 void x86_cpu_list (FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt,
                                                  ...));
 int cpu_get_pic_interrupt(CPUX86State *s);
diff --git a/target-i386/helper2.c b/target-i386/helper2.c
index 065532049a..b46475e302 100644
--- a/target-i386/helper2.c
+++ b/target-i386/helper2.c
@@ -31,9 +31,7 @@
 
 //#define DEBUG_MMU
 
-static struct x86_def_t *x86_cpu_def;
-typedef struct x86_def_t x86_def_t;
-static int cpu_x86_register (CPUX86State *env, const x86_def_t *def);
+static int cpu_x86_register (CPUX86State *env, const char *cpu_model);
 
 static void add_flagname_to_bitmaps(char *flagname, uint32_t *features, 
                                     uint32_t *ext_features, 
@@ -92,7 +90,7 @@ static void add_flagname_to_bitmaps(char *flagname, uint32_t *features,
     fprintf(stderr, "CPU feature %s not found\n", flagname);
 }
 
-CPUX86State *cpu_x86_init(void)
+CPUX86State *cpu_x86_init(const char *cpu_model)
 {
     CPUX86State *env;
     static int inited;
@@ -107,7 +105,10 @@ CPUX86State *cpu_x86_init(void)
         inited = 1;
         optimize_flags_init();
     }
-    cpu_x86_register(env, x86_cpu_def);
+    if (cpu_x86_register(env, cpu_model) < 0) {
+        cpu_x86_close(env);
+        return NULL;
+    }
     cpu_reset(env);
 #ifdef USE_KQEMU
     kqemu_init(env);
@@ -115,7 +116,7 @@ CPUX86State *cpu_x86_init(void)
     return env;
 }
 
-struct x86_def_t {
+typedef struct x86_def_t {
     const char *name;
     uint32_t vendor1, vendor2, vendor3;
     int family;
@@ -123,7 +124,7 @@ struct x86_def_t {
     int stepping;
     uint32_t features, ext_features, ext2_features, ext3_features;
     uint32_t xlevel;
-};
+} x86_def_t;
 
 #define PPRO_FEATURES (CPUID_FP87 | CPUID_DE | CPUID_PSE | CPUID_TSC | \
           CPUID_MSR | CPUID_MCE | CPUID_CX8 | CPUID_PGE | CPUID_CMOV | \
@@ -194,10 +195,10 @@ static x86_def_t x86_defs[] = {
     },
 };
 
-int x86_find_cpu_by_name(const unsigned char *cpu_model)
+static int cpu_x86_find_by_name(x86_def_t *x86_cpu_def, const char *cpu_model)
 {
-    int ret;
     unsigned int i;
+    x86_def_t *def;
 
     char *s = strdup(cpu_model);
     char *featurestr, *name = strtok(s, ",");
@@ -205,17 +206,16 @@ int x86_find_cpu_by_name(const unsigned char *cpu_model)
     uint32_t minus_features = 0, minus_ext_features = 0, minus_ext2_features = 0, minus_ext3_features = 0;
     int family = -1, model = -1, stepping = -1;
 
-    ret = -1;
-    x86_cpu_def = NULL;
+    def = NULL;
     for (i = 0; i < sizeof(x86_defs) / sizeof(x86_def_t); i++) {
         if (strcmp(name, x86_defs[i].name) == 0) {
-            x86_cpu_def = &x86_defs[i];
-            ret = 0;
+            def = &x86_defs[i];
             break;
         }
     }
-    if (!x86_cpu_def)
+    if (!def)
         goto error;
+    memcpy(x86_cpu_def, def, sizeof(*def));
 
     featurestr = strtok(NULL, ",");
 
@@ -274,10 +274,12 @@ int x86_find_cpu_by_name(const unsigned char *cpu_model)
     x86_cpu_def->ext_features &= ~minus_ext_features;
     x86_cpu_def->ext2_features &= ~minus_ext2_features;
     x86_cpu_def->ext3_features &= ~minus_ext3_features;
+    free(s);
+    return 0;
 
 error:
     free(s);
-    return ret;
+    return -1;
 }
 
 void x86_cpu_list (FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))
@@ -288,8 +290,12 @@ void x86_cpu_list (FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))
         (*cpu_fprintf)(f, "x86 %16s\n", x86_defs[i].name);
 }
 
-int cpu_x86_register (CPUX86State *env, const x86_def_t *def)
+static int cpu_x86_register (CPUX86State *env, const char *cpu_model)
 {
+    x86_def_t def1, *def = &def1;
+
+    if (cpu_x86_find_by_name(def, cpu_model) < 0)
+        return -1;
     if (def->vendor1) {
         env->cpuid_vendor1 = def->vendor1;
         env->cpuid_vendor2 = def->vendor2;
diff --git a/target-m68k/cpu.h b/target-m68k/cpu.h
index 5004a9168b..732929bfa0 100644
--- a/target-m68k/cpu.h
+++ b/target-m68k/cpu.h
@@ -100,8 +100,6 @@ typedef struct CPUM68KState {
     uint32_t rambar0;
     uint32_t cacr;
 
-    uint32_t features;
-
     /* ??? remove this.  */
     uint32_t t1;
 
@@ -118,9 +116,11 @@ typedef struct CPUM68KState {
     uint32_t qregs[MAX_QREGS];
 
     CPU_COMMON
+
+    uint32_t features;
 } CPUM68KState;
 
-CPUM68KState *cpu_m68k_init(void);
+CPUM68KState *cpu_m68k_init(const char *cpu_model);
 int cpu_m68k_exec(CPUM68KState *s);
 void cpu_m68k_close(CPUM68KState *s);
 void do_interrupt(int is_hw);
@@ -174,10 +174,6 @@ enum {
 #define MACSR_V     0x002
 #define MACSR_EV    0x001
 
-typedef struct m68k_def_t m68k_def_t;
-
-int cpu_m68k_set_model(CPUM68KState *env, const char * name);
-
 void m68k_set_irq_level(CPUM68KState *env, int level, uint8_t vector);
 void m68k_set_macsr(CPUM68KState *env, uint32_t val);
 void m68k_switch_sp(CPUM68KState *env);
diff --git a/target-m68k/helper.c b/target-m68k/helper.c
index f3c629979d..8fef672264 100644
--- a/target-m68k/helper.c
+++ b/target-m68k/helper.c
@@ -33,6 +33,8 @@ enum m68k_cpuid {
     M68K_CPUID_ANY,
 };
 
+typedef struct m68k_def_t m68k_def_t;
+
 struct m68k_def_t {
     const char * name;
     enum m68k_cpuid id;
@@ -51,7 +53,7 @@ static void m68k_set_feature(CPUM68KState *env, int feature)
     env->features |= (1u << feature);
 }
 
-int cpu_m68k_set_model(CPUM68KState *env, const char * name)
+static int cpu_m68k_set_model(CPUM68KState *env, const char *name)
 {
     m68k_def_t *def;
 
@@ -60,7 +62,7 @@ int cpu_m68k_set_model(CPUM68KState *env, const char * name)
             break;
     }
     if (!def->name)
-        return 1;
+        return -1;
 
     switch (def->id) {
     case M68K_CPUID_M5206:
@@ -98,8 +100,43 @@ int cpu_m68k_set_model(CPUM68KState *env, const char * name)
     }
 
     register_m68k_insns(env);
+}
+
+void cpu_reset(CPUM68KState *env)
+{
+    memset(env, 0, offsetof(CPUM68KState, breakpoints));
+#if !defined (CONFIG_USER_ONLY)
+    env->sr = 0x2700;
+#endif
+    m68k_switch_sp(env);
+    /* ??? FP regs should be initialized to NaN.  */
+    env->cc_op = CC_OP_FLAGS;
+    /* TODO: We should set PC from the interrupt vector.  */
+    env->pc = 0;
+    tlb_flush(env, 1);
+}
 
-    return 0;
+CPUM68KState *cpu_m68k_init(const char *cpu_model)
+{
+    CPUM68KState *env;
+
+    env = malloc(sizeof(CPUM68KState));
+    if (!env)
+        return NULL;
+    cpu_exec_init(env);
+
+    if (cpu_m68k_set_model(env, cpu_model) < 0) {
+        cpu_m68k_close(env);
+        return NULL;
+    }
+        
+    cpu_reset(env);
+    return env;
+}
+
+void cpu_m68k_close(CPUM68KState *env)
+{
+    qemu_free(env);
 }
 
 void cpu_m68k_flush_flags(CPUM68KState *env, int cc_op)
diff --git a/target-m68k/translate.c b/target-m68k/translate.c
index f6b4fad640..499f053e3f 100644
--- a/target-m68k/translate.c
+++ b/target-m68k/translate.c
@@ -3279,38 +3279,6 @@ int gen_intermediate_code_pc(CPUState *env, TranslationBlock *tb)
     return gen_intermediate_code_internal(env, tb, 1);
 }
 
-void cpu_reset(CPUM68KState *env)
-{
-    memset(env, 0, offsetof(CPUM68KState, breakpoints));
-#if !defined (CONFIG_USER_ONLY)
-    env->sr = 0x2700;
-#endif
-    m68k_switch_sp(env);
-    /* ??? FP regs should be initialized to NaN.  */
-    env->cc_op = CC_OP_FLAGS;
-    /* TODO: We should set PC from the interrupt vector.  */
-    env->pc = 0;
-    tlb_flush(env, 1);
-}
-
-CPUM68KState *cpu_m68k_init(void)
-{
-    CPUM68KState *env;
-
-    env = malloc(sizeof(CPUM68KState));
-    if (!env)
-        return NULL;
-    cpu_exec_init(env);
-
-    cpu_reset(env);
-    return env;
-}
-
-void cpu_m68k_close(CPUM68KState *env)
-{
-    free(env);
-}
-
 void cpu_dump_state(CPUState *env, FILE *f,
                     int (*cpu_fprintf)(FILE *f, const char *fmt, ...),
                     int flags)
diff --git a/target-mips/cpu.h b/target-mips/cpu.h
index 1c850c782b..482f27d1e2 100644
--- a/target-mips/cpu.h
+++ b/target-mips/cpu.h
@@ -456,7 +456,7 @@ struct CPUMIPSState {
 
     CPU_COMMON
 
-    mips_def_t *cpu_model;
+    const mips_def_t *cpu_model;
 #ifndef CONFIG_USER_ONLY
     void *irq[8];
 #endif
@@ -474,9 +474,7 @@ void r4k_do_tlbwi (void);
 void r4k_do_tlbwr (void);
 void r4k_do_tlbp (void);
 void r4k_do_tlbr (void);
-int mips_find_by_name (const unsigned char *name, mips_def_t **def);
 void mips_cpu_list (FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...));
-int cpu_mips_register (CPUMIPSState *env, mips_def_t *def);
 
 void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,
                           int unused);
@@ -560,7 +558,7 @@ enum {
 };
 
 int cpu_mips_exec(CPUMIPSState *s);
-CPUMIPSState *cpu_mips_init(void);
+CPUMIPSState *cpu_mips_init(const char *cpu_model);
 uint32_t cpu_mips_get_clock (void);
 int cpu_mips_signal_handler(int host_signum, void *pinfo, void *puc);
 
diff --git a/target-mips/translate.c b/target-mips/translate.c
index 578cd9a25c..ac439d27a1 100644
--- a/target-mips/translate.c
+++ b/target-mips/translate.c
@@ -6725,13 +6725,21 @@ void cpu_dump_state (CPUState *env, FILE *f,
 #endif
 }
 
-CPUMIPSState *cpu_mips_init (void)
+#include "translate_init.c"
+
+CPUMIPSState *cpu_mips_init (const char *cpu_model)
 {
     CPUMIPSState *env;
+    const mips_def_t *def;
 
+    def = cpu_mips_find_by_name(cpu_model);
+    if (!def)
+        return NULL;
     env = qemu_mallocz(sizeof(CPUMIPSState));
     if (!env)
         return NULL;
+    env->cpu_model = def;
+
     cpu_exec_init(env);
     cpu_reset(env);
     return env;
@@ -6780,6 +6788,5 @@ void cpu_reset (CPUMIPSState *env)
 #else
     env->hflags = MIPS_HFLAG_CP0;
 #endif
+    cpu_mips_register(env, env->cpu_model);
 }
-
-#include "translate_init.c"
diff --git a/target-mips/translate_init.c b/target-mips/translate_init.c
index 1302b76caa..44aff7f37c 100644
--- a/target-mips/translate_init.c
+++ b/target-mips/translate_init.c
@@ -53,7 +53,6 @@
    Define a major version 1, minor version 0. */
 #define MIPS_FCR0 ((0 << FCR0_S) | (0x1 << FCR0_PRID) | (0x10 << FCR0_REV))
 
-
 struct mips_def_t {
     const unsigned char *name;
     int32_t CP0_PRid;
@@ -300,21 +299,16 @@ static mips_def_t mips_defs[] =
 #endif
 };
 
-int mips_find_by_name (const unsigned char *name, mips_def_t **def)
+static const mips_def_t *cpu_mips_find_by_name (const unsigned char *name)
 {
-    int i, ret;
+    int i;
 
-    ret = -1;
-    *def = NULL;
     for (i = 0; i < sizeof(mips_defs) / sizeof(mips_defs[0]); i++) {
         if (strcasecmp(name, mips_defs[i].name) == 0) {
-            *def = &mips_defs[i];
-            ret = 0;
-            break;
+            return &mips_defs[i];
         }
     }
-
-    return ret;
+    return NULL;
 }
 
 void mips_cpu_list (FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))
@@ -328,19 +322,19 @@ void mips_cpu_list (FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))
 }
 
 #ifndef CONFIG_USER_ONLY
-static void no_mmu_init (CPUMIPSState *env, mips_def_t *def)
+static void no_mmu_init (CPUMIPSState *env, const mips_def_t *def)
 {
     env->tlb->nb_tlb = 1;
     env->tlb->map_address = &no_mmu_map_address;
 }
 
-static void fixed_mmu_init (CPUMIPSState *env, mips_def_t *def)
+static void fixed_mmu_init (CPUMIPSState *env, const mips_def_t *def)
 {
     env->tlb->nb_tlb = 1;
     env->tlb->map_address = &fixed_mmu_map_address;
 }
 
-static void r4k_mmu_init (CPUMIPSState *env, mips_def_t *def)
+static void r4k_mmu_init (CPUMIPSState *env, const mips_def_t *def)
 {
     env->tlb->nb_tlb = 1 + ((def->CP0_Config1 >> CP0C1_MMU) & 63);
     env->tlb->map_address = &r4k_map_address;
@@ -350,7 +344,7 @@ static void r4k_mmu_init (CPUMIPSState *env, mips_def_t *def)
     env->tlb->do_tlbr = r4k_do_tlbr;
 }
 
-static void mmu_init (CPUMIPSState *env, mips_def_t *def)
+static void mmu_init (CPUMIPSState *env, const mips_def_t *def)
 {
     env->tlb = qemu_mallocz(sizeof(CPUMIPSTLBContext));
 
@@ -376,7 +370,7 @@ static void mmu_init (CPUMIPSState *env, mips_def_t *def)
 }
 #endif /* CONFIG_USER_ONLY */
 
-static void fpu_init (CPUMIPSState *env, mips_def_t *def)
+static void fpu_init (CPUMIPSState *env, const mips_def_t *def)
 {
     env->fpu = qemu_mallocz(sizeof(CPUMIPSFPUContext));
 
@@ -389,7 +383,7 @@ static void fpu_init (CPUMIPSState *env, mips_def_t *def)
 #endif
 }
 
-static void mvp_init (CPUMIPSState *env, mips_def_t *def)
+static void mvp_init (CPUMIPSState *env, const mips_def_t *def)
 {
     env->mvp = qemu_mallocz(sizeof(CPUMIPSMVPContext));
 
@@ -415,13 +409,8 @@ static void mvp_init (CPUMIPSState *env, mips_def_t *def)
                              (0x1 << CP0MVPC1_PCP1);
 }
 
-int cpu_mips_register (CPUMIPSState *env, mips_def_t *def)
+static int cpu_mips_register (CPUMIPSState *env, const mips_def_t *def)
 {
-    if (!def)
-        def = env->cpu_model;
-    if (!def)
-        cpu_abort(env, "Unable to find MIPS CPU definition\n");
-    env->cpu_model = def;
     env->CP0_PRid = def->CP0_PRid;
     env->CP0_Config0 = def->CP0_Config0;
 #ifdef TARGET_WORDS_BIGENDIAN
diff --git a/target-ppc/cpu.h b/target-ppc/cpu.h
index 939dbcd982..7fcdd4121f 100644
--- a/target-ppc/cpu.h
+++ b/target-ppc/cpu.h
@@ -675,7 +675,7 @@ struct mmu_ctx_t {
 };
 
 /*****************************************************************************/
-CPUPPCState *cpu_ppc_init (void);
+CPUPPCState *cpu_ppc_init (const char *cpu_model);
 int cpu_ppc_exec (CPUPPCState *s);
 void cpu_ppc_close (CPUPPCState *s);
 /* you can call this signal handler from your SIGBUS and SIGSEGV
@@ -719,13 +719,12 @@ void ppc_store_xer (CPUPPCState *env, target_ulong value);
 void ppc_store_msr (CPUPPCState *env, target_ulong value);
 
 void cpu_ppc_reset (void *opaque);
-CPUPPCState *cpu_ppc_init (void);
-void cpu_ppc_close(CPUPPCState *env);
 
-int ppc_find_by_name (const unsigned char *name, ppc_def_t **def);
-int ppc_find_by_pvr (uint32_t apvr, ppc_def_t **def);
 void ppc_cpu_list (FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...));
-int cpu_ppc_register (CPUPPCState *env, ppc_def_t *def);
+
+const ppc_def_t *cpu_ppc_find_by_name (const unsigned char *name);
+const ppc_def_t *cpu_ppc_find_by_pvr (uint32_t pvr);
+int cpu_ppc_register_internal (CPUPPCState *env, const ppc_def_t *def);
 
 /* Time-base and decrementer management */
 #ifndef NO_CPU_IO_DEFS
diff --git a/target-ppc/helper.c b/target-ppc/helper.c
index 9fd9721cde..f7df19e1c0 100644
--- a/target-ppc/helper.c
+++ b/target-ppc/helper.c
@@ -2970,20 +2970,26 @@ void cpu_ppc_reset (void *opaque)
     tlb_flush(env, 1);
 }
 
-CPUPPCState *cpu_ppc_init (void)
+CPUPPCState *cpu_ppc_init (const char *cpu_model)
 {
     CPUPPCState *env;
+    const ppc_def_t *def;
+
+    def = cpu_ppc_find_by_name(cpu_model);
+    if (!def)
+        return NULL;
 
     env = qemu_mallocz(sizeof(CPUPPCState));
     if (!env)
         return NULL;
     cpu_exec_init(env);
-
+    cpu_ppc_register_internal(env, def);
+    cpu_ppc_reset(env);
     return env;
 }
 
 void cpu_ppc_close (CPUPPCState *env)
 {
     /* Should also remove all opcode tables... */
-    free(env);
+    qemu_free(env);
 }
diff --git a/target-ppc/translate_init.c b/target-ppc/translate_init.c
index eae228b26a..973e0c5db0 100644
--- a/target-ppc/translate_init.c
+++ b/target-ppc/translate_init.c
@@ -5931,7 +5931,7 @@ static ppc_def_t ppc_defs[] = {
 
 /*****************************************************************************/
 /* Generic CPU instanciation routine                                         */
-static void init_ppc_proc (CPUPPCState *env, ppc_def_t *def)
+static void init_ppc_proc (CPUPPCState *env, const ppc_def_t *def)
 {
 #if !defined(CONFIG_USER_ONLY)
     int i;
@@ -6276,7 +6276,7 @@ static void fix_opcode_tables (opc_handler_t **ppc_opcodes)
 }
 
 /*****************************************************************************/
-static int create_ppc_opcodes (CPUPPCState *env, ppc_def_t *def)
+static int create_ppc_opcodes (CPUPPCState *env, const ppc_def_t *def)
 {
     opcode_t *opc, *start, *end;
 
@@ -6351,7 +6351,7 @@ static void dump_ppc_insns (CPUPPCState *env)
 }
 #endif
 
-int cpu_ppc_register (CPUPPCState *env, ppc_def_t *def)
+int cpu_ppc_register_internal (CPUPPCState *env, const ppc_def_t *def)
 {
     env->msr_mask = def->msr_mask;
     env->mmu_model = def->mmu_model;
@@ -6514,41 +6514,31 @@ int cpu_ppc_register (CPUPPCState *env, ppc_def_t *def)
     return 0;
 }
 
-int ppc_find_by_name (const unsigned char *name, ppc_def_t **def)
+const ppc_def_t *cpu_ppc_find_by_name (const unsigned char *name)
 {
-    int i, max, ret;
+    int i, max;
 
-    ret = -1;
-    *def = NULL;
     max = sizeof(ppc_defs) / sizeof(ppc_def_t);
     for (i = 0; i < max; i++) {
         if (strcasecmp(name, ppc_defs[i].name) == 0) {
-            *def = &ppc_defs[i];
-            ret = 0;
-            break;
+            return &ppc_defs[i];
         }
     }
-
-    return ret;
+    return NULL;
 }
 
-int ppc_find_by_pvr (uint32_t pvr, ppc_def_t **def)
+const ppc_def_t *cpu_ppc_find_by_pvr (uint32_t pvr)
 {
-    int i, max, ret;
+    int i, max;
 
-    ret = -1;
-    *def = NULL;
     max = sizeof(ppc_defs) / sizeof(ppc_def_t);
     for (i = 0; i < max; i++) {
         if ((pvr & ppc_defs[i].pvr_mask) ==
             (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) {
-            *def = &ppc_defs[i];
-            ret = 0;
-            break;
+            return &ppc_defs[i];
         }
     }
-
-    return ret;
+    return NULL;
 }
 
 void ppc_cpu_list (FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))
diff --git a/target-sh4/cpu.h b/target-sh4/cpu.h
index edfda1f90a..79701306c6 100644
--- a/target-sh4/cpu.h
+++ b/target-sh4/cpu.h
@@ -123,7 +123,7 @@ typedef struct CPUSH4State {
     tlb_t itlb[ITLB_SIZE];	/* instruction translation table */
 } CPUSH4State;
 
-CPUSH4State *cpu_sh4_init(void);
+CPUSH4State *cpu_sh4_init(const char *cpu_model);
 int cpu_sh4_exec(CPUSH4State * s);
 int cpu_sh4_signal_handler(int host_signum, void *pinfo,
                            void *puc);
diff --git a/target-sh4/translate.c b/target-sh4/translate.c
index 35b6f08dcc..8d5e99e97a 100644
--- a/target-sh4/translate.c
+++ b/target-sh4/translate.c
@@ -141,7 +141,7 @@ void cpu_sh4_reset(CPUSH4State * env)
     env->mmucr = 0;
 }
 
-CPUSH4State *cpu_sh4_init(void)
+CPUSH4State *cpu_sh4_init(const char *cpu_model)
 {
     CPUSH4State *env;
 
diff --git a/target-sparc/cpu.h b/target-sparc/cpu.h
index 0e5a4e2227..23f9ab136e 100644
--- a/target-sparc/cpu.h
+++ b/target-sparc/cpu.h
@@ -165,8 +165,6 @@
 /* 2 <= NWINDOWS <= 32. In QEMU it must also be a power of two. */
 #define NWINDOWS  8
 
-typedef struct sparc_def_t sparc_def_t;
-
 #if !defined(TARGET_SPARC64)
 #define NB_MMU_MODES 2
 #else
@@ -270,14 +268,12 @@ typedef struct CPUSPARCState {
     } while (0)
 #endif
 
-CPUSPARCState *cpu_sparc_init(void);
+CPUSPARCState *cpu_sparc_init(const char *cpu_model);
 int cpu_sparc_exec(CPUSPARCState *s);
 int cpu_sparc_close(CPUSPARCState *s);
-int sparc_find_by_name (const unsigned char *name, const sparc_def_t **def);
 void sparc_cpu_list (FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt,
                                                  ...));
-int cpu_sparc_register (CPUSPARCState *env, const sparc_def_t *def,
-                        unsigned int cpu);
+void cpu_sparc_set_id(CPUSPARCState *env, unsigned int cpu);
 
 #define GET_PSR(env) (env->version | (env->psr & PSR_ICC) |             \
                       (env->psref? PSR_EF : 0) |                        \
diff --git a/target-sparc/translate.c b/target-sparc/translate.c
index 6aeb3273ac..1e373cea39 100644
--- a/target-sparc/translate.c
+++ b/target-sparc/translate.c
@@ -54,6 +54,8 @@ typedef struct DisasContext {
     struct TranslationBlock *tb;
 } DisasContext;
 
+typedef struct sparc_def_t sparc_def_t;
+
 struct sparc_def_t {
     const unsigned char *name;
     target_ulong iu_version;
@@ -62,6 +64,8 @@ struct sparc_def_t {
     uint32_t mmu_bm;
 };
 
+static const sparc_def_t *cpu_sparc_find_by_name(const unsigned char *name);
+
 static uint16_t *gen_opc_ptr;
 static uint32_t *gen_opparam_ptr;
 extern FILE *logfile;
@@ -3489,15 +3493,36 @@ void cpu_reset(CPUSPARCState *env)
 #endif
 }
 
-CPUSPARCState *cpu_sparc_init(void)
+CPUSPARCState *cpu_sparc_init(const char *cpu_model)
 {
     CPUSPARCState *env;
+    const sparc_def_t *def;
+
+    def = cpu_sparc_find_by_name(cpu_model);
+    if (!def)
+        return NULL;
 
     env = qemu_mallocz(sizeof(CPUSPARCState));
     if (!env)
         return NULL;
     cpu_exec_init(env);
-    return (env);
+    env->version = def->iu_version;
+    env->fsr = def->fpu_version;
+#if !defined(TARGET_SPARC64)
+    env->mmu_bm = def->mmu_bm;
+    env->mmuregs[0] |= def->mmu_version;
+    cpu_sparc_set_id(env, 0);
+#endif
+    cpu_reset(env);
+    
+    return env;
+}
+
+void cpu_sparc_set_id(CPUSPARCState *env, unsigned int cpu)
+{
+#if !defined(TARGET_SPARC64)
+    env->mxccregs[7] = ((cpu + 8) & 0xf) << 24;
+#endif
 }
 
 static const sparc_def_t sparc_defs[] = {
@@ -3744,22 +3769,16 @@ static const sparc_def_t sparc_defs[] = {
 #endif
 };
 
-int sparc_find_by_name(const unsigned char *name, const sparc_def_t **def)
+static const sparc_def_t *cpu_sparc_find_by_name(const unsigned char *name)
 {
-    int ret;
     unsigned int i;
 
-    ret = -1;
-    *def = NULL;
     for (i = 0; i < sizeof(sparc_defs) / sizeof(sparc_def_t); i++) {
         if (strcasecmp(name, sparc_defs[i].name) == 0) {
-            *def = &sparc_defs[i];
-            ret = 0;
-            break;
+            return &sparc_defs[i];
         }
     }
-
-    return ret;
+    return NULL;
 }
 
 void sparc_cpu_list (FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))
@@ -3775,19 +3794,6 @@ void sparc_cpu_list (FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))
     }
 }
 
-int cpu_sparc_register (CPUSPARCState *env, const sparc_def_t *def, unsigned int cpu)
-{
-    env->version = def->iu_version;
-    env->fsr = def->fpu_version;
-#if !defined(TARGET_SPARC64)
-    env->mmu_bm = def->mmu_bm;
-    env->mmuregs[0] |= def->mmu_version;
-    env->mxccregs[7] = ((cpu + 8) & 0xf) << 24;
-#endif
-    cpu_reset(env);
-    return 0;
-}
-
 #define GET_FLAG(a,b) ((env->psr & a)?b:'-')
 
 void cpu_dump_state(CPUState *env, FILE *f,
diff --git a/tests/qruncom.c b/tests/qruncom.c
index 1f2b63e3c7..7b25fcdedc 100644
--- a/tests/qruncom.c
+++ b/tests/qruncom.c
@@ -197,7 +197,7 @@ int main(int argc, char **argv)
 
     //    cpu_set_log(CPU_LOG_TB_IN_ASM | CPU_LOG_TB_OUT_ASM | CPU_LOG_EXEC);
 
-    env = cpu_init();
+    env = cpu_init("qemu32");
 
     /* disable code copy to simplify debugging */
     code_copy_enabled = 0;

