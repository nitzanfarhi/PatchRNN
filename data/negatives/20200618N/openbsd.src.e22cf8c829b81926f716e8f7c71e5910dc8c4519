commit e22cf8c829b81926f716e8f7c71e5910dc8c4519
Author: claudio <claudio@openbsd.org>
Date:   Mon Feb 16 12:53:15 2004 +0000

    Make the path attribute handling more RFC conformant. Also move the
    parser to rde_attr.c where it belongs. Still missing: better aspath loop
    detection (should be done afterwards) and some basic error checking for
    optional attributes. OK henning@

diff --git a/usr.sbin/bgpd/bgpd.h b/usr.sbin/bgpd/bgpd.h
index 9331768ddc4..080e6593089 100644
--- a/usr.sbin/bgpd/bgpd.h
+++ b/usr.sbin/bgpd/bgpd.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: bgpd.h,v 1.94 2004/02/10 23:10:23 henning Exp $ */
+/*	$OpenBSD: bgpd.h,v 1.95 2004/02/16 12:53:15 claudio Exp $ */
 
 /*
  * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
@@ -214,7 +214,16 @@ struct imsg {
 /* needed for session.h parse prototype */
 LIST_HEAD(mrt_head, mrt);
 
-/* error subcode for UPDATE; needed in SE and RDE */
+/* error codes and subcodes needed in SE and RDE */
+enum err_codes {
+	ERR_HEADER = 1,
+	ERR_OPEN,
+	ERR_UPDATE,
+	ERR_HOLDTIMEREXPIRED,
+	ERR_FSM,
+	ERR_CEASE
+};
+
 enum suberr_update {
 	ERR_UPD_UNSPECIFIC,
 	ERR_UPD_ATTRLIST,
@@ -230,6 +239,17 @@ enum suberr_update {
 	ERR_UPD_ASPATH
 };
 
+enum suberr_cease {
+	ERR_CEASE_MAX_PREFIX = 1,
+	ERR_CEASE_ADMIN_DOWN,
+	ERR_CEASE_PEER_UNCONF,
+	ERR_CEASE_ADMIN_RESET,
+	ERR_CEASE_CONN_REJECT,
+	ERR_CEASE_OTHER_CHANGE,
+	ERR_CEASE_COLLISION,
+	ERR_CEASE_RSRC_EXHAUST
+};
+
 struct kroute {
 	struct in_addr	prefix;
 	u_int8_t	prefixlen;
diff --git a/usr.sbin/bgpd/rde.c b/usr.sbin/bgpd/rde.c
index 2adb0d5797b..1c6b26a6881 100644
--- a/usr.sbin/bgpd/rde.c
+++ b/usr.sbin/bgpd/rde.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: rde.c,v 1.76 2004/02/09 01:56:18 henning Exp $ */
+/*	$OpenBSD: rde.c,v 1.77 2004/02/16 12:53:15 claudio Exp $ */
 
 /*
  * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
@@ -41,10 +41,8 @@ void		 rde_dispatch_imsg_parent(struct imsgbuf *);
 int		 rde_update_dispatch(struct imsg *);
 int		 rde_update_get_prefix(u_char *, u_int16_t, struct bgpd_addr *,
 		     u_int8_t *);
-void		 init_attr_flags(struct attr_flags *);
-int		 rde_update_get_attr(struct rde_peer *, u_char *, u_int16_t,
-		     struct attr_flags *);
-void		 rde_update_err(struct rde_peer *, enum suberr_update);
+void		 rde_update_err(struct rde_peer *, u_int8_t , u_int8_t,
+		     void *, u_int16_t);
 void		 rde_update_log(const char *,
 		     const struct rde_peer *, const struct attr_flags *,
 		     const struct bgpd_addr *, u_int8_t);
@@ -351,8 +349,8 @@ rde_update_dispatch(struct imsg *imsg)
 	u_int16_t		 len;
 	u_int16_t		 withdrawn_len;
 	u_int16_t		 attrpath_len;
-	u_int16_t		 nlri_len;
-	u_int8_t		 prefixlen;
+	u_int16_t		 nlri_len, size;
+	u_int8_t		 prefixlen, subtype;
 	struct bgpd_addr	 prefix;
 	struct attr_flags	 attrs;
 
@@ -373,14 +371,19 @@ rde_update_dispatch(struct imsg *imsg)
 	withdrawn_len = ntohs(len);
 	p += 2;
 	if (imsg->hdr.len < IMSG_HEADER_SIZE + 2 + withdrawn_len + 2) {
-		rde_update_err(peer, ERR_UPD_ATTRLIST);
+		rde_update_err(peer, ERR_UPDATE, ERR_UPD_ATTRLIST, NULL, 0);
 		return (-1);
 	}
 
 	while (withdrawn_len > 0) {
 		if ((pos = rde_update_get_prefix(p, withdrawn_len, &prefix,
 		    &prefixlen)) == -1) {
-			rde_update_err(peer, ERR_UPD_ATTRLIST);
+			/*
+			 * the rfc does not mention what we should do in
+			 * this case. Let's do the same as in the NLRI case.
+			 */
+			rde_update_err(peer, ERR_UPDATE, ERR_UPD_NETWORK,
+			    NULL, 0);
 			return (-1);
 		}
 		p += pos;
@@ -394,7 +397,7 @@ rde_update_dispatch(struct imsg *imsg)
 	p += 2;
 	if (imsg->hdr.len <
 	    IMSG_HEADER_SIZE + 2 + withdrawn_len + 2 + attrpath_len) {
-		rde_update_err(peer, ERR_UPD_ATTRLIST);
+		rde_update_err(peer, ERR_UPDATE, ERR_UPD_ATTRLIST, NULL, 0);
 		return (-1);
 	}
 	nlri_len =
@@ -402,11 +405,14 @@ rde_update_dispatch(struct imsg *imsg)
 	if (attrpath_len == 0) /* 0 = no NLRI information in this message */
 		return (0);
 
-	init_attr_flags(&attrs);
+	attr_init(&attrs);
 	while (attrpath_len > 0) {
-		if ((pos = rde_update_get_attr(peer, p, attrpath_len,
-		    &attrs)) < 0) {
-			rde_update_err(peer, ERR_UPD_ATTRLIST);
+		if ((pos = attr_parse(p, attrpath_len, &attrs,
+		    peer->conf.ebgp, conf->as)) < 0) {
+			rde_update_err(peer, ERR_UPDATE, subtype,
+			    attr_error(p, attrpath_len, &subtype, &size), size);
+			aspath_destroy(attrs.aspath);
+			attr_optfree(&attrs);
 			return (-1);
 		}
 		p += pos;
@@ -416,7 +422,10 @@ rde_update_dispatch(struct imsg *imsg)
 	while (nlri_len > 0) {
 		if ((pos = rde_update_get_prefix(p, nlri_len, &prefix,
 		    &prefixlen)) == -1) {
-			rde_update_err(peer, ERR_UPD_ATTRLIST);
+			rde_update_err(peer, ERR_UPDATE, ERR_UPD_NETWORK,
+			    NULL, 0);
+			aspath_destroy(attrs.aspath);
+			attr_optfree(&attrs);
 			return (-1);
 		}
 		p += pos;
@@ -425,8 +434,11 @@ rde_update_dispatch(struct imsg *imsg)
 		if (peer->conf.max_prefix &&
 		    peer->prefix_cnt >= peer->conf.max_prefix) {
 			log_peer_warnx(&peer->conf, "prefix limit reached");
-			rde_update_err(peer, ERR_UPD_UNSPECIFIC);
-			break;
+			rde_update_err(peer, ERR_CEASE, ERR_CEASE_MAX_PREFIX,
+			    NULL, 0);
+			aspath_destroy(attrs.aspath);
+			attr_optfree(&attrs);
+			return (-1);
 		}
 		path_update(peer, &attrs, &prefix, prefixlen);
 	}
@@ -473,112 +485,19 @@ rde_update_get_prefix(u_char *p, u_int16_t len, struct bgpd_addr *prefix,
 	return (plen);
 }
 
-#define UPD_READ(t, p, plen, n) \
-	do { \
-		memcpy(t, p, n); \
-		p += n; \
-		plen += n; \
-	} while (0)
-
-void
-init_attr_flags(struct attr_flags *a)
-{
-	bzero(a, sizeof(struct attr_flags));
-	a->origin = ORIGIN_INCOMPLETE;
-	TAILQ_INIT(&a->others);
-}
-
-int
-rde_update_get_attr(struct rde_peer *peer, u_char *p, u_int16_t len,
-    struct attr_flags *a)
-{
-	u_int32_t	 tmp32;
-	u_int16_t	 attr_len;
-	u_int16_t	 plen = 0;
-	u_int8_t	 flags;
-	u_int8_t	 type;
-	u_int8_t	 tmp8;
-	int		 r; /* XXX */
-
-	if (len < 3)
-		return (-1);
-
-	UPD_READ(&flags, p, plen, 1);
-	UPD_READ(&type, p, plen, 1);
-
-	if (flags & ATTR_EXTLEN) {
-		if (len - plen < 2)
-			return (-1);
-		UPD_READ(&attr_len, p, plen, 2);
-	} else {
-		UPD_READ(&tmp8, p, plen, 1);
-		attr_len = tmp8;
-	}
-
-	if (len - plen < attr_len)
-		return (-1);
-
-	switch (type) {
-	case ATTR_UNDEF:
-		/* error! */
-		return (-1);
-	case ATTR_ORIGIN:
-		if (attr_len != 1)
-			return (-1);
-		UPD_READ(&a->origin, p, plen, 1);
-		break;
-	case ATTR_ASPATH:
-		if ((r = aspath_verify(p, attr_len, conf->as)) != 0) {
-			/* XXX could also be a aspath loop but this
-			 * check should be moved to the filtering. */
-			log_warnx("XXX aspath_verify failed: error %i", r);
-			return (-1);
-		}
-		a->aspath = aspath_create(p, attr_len);
-		plen += attr_len;
-		break;
-	case ATTR_NEXTHOP:
-		if (attr_len != 4)
-			return (-1);
-		UPD_READ(&a->nexthop, p, plen, 4);	/* network byte order */
-		break;
-	case ATTR_MED:
-		if (attr_len != 4)
-			return (-1);
-		UPD_READ(&tmp32, p, plen, 4);
-		a->med = ntohl(tmp32);
-		break;
-	case ATTR_LOCALPREF:
-		if (attr_len != 4)
-			return (-1);
-		if (peer->conf.ebgp) {
-			/* ignore local-pref attr for non ibgp peers */
-			a->lpref = 0;	/* set a default value */
-			break;
-		}
-		UPD_READ(&tmp32, p, plen, 4);
-		a->lpref = ntohl(tmp32);
-		break;
-	case ATTR_ATOMIC_AGGREGATE:
-	case ATTR_AGGREGATOR:
-	default:
-		attr_optadd(a, flags, type, p, attr_len);
-		plen += attr_len;
-		break;
-	}
-
-	return (plen);
-
-}
-
 void
-rde_update_err(struct rde_peer *peer, enum suberr_update errorcode)
+rde_update_err(struct rde_peer *peer, u_int8_t error, u_int8_t suberr,
+    void *data, u_int16_t size)
 {
-	u_int8_t	errcode;
+	u_char	buf[1024];
 
-	errcode = errorcode;
+	buf[0] = error;
+	buf[1] = suberr;
+	if (size > sizeof(buf) - 2)
+		size = sizeof(buf) - 2;
+	memcpy(buf + 2, data, size);
 	if (imsg_compose(&ibuf_se, IMSG_UPDATE_ERR, peer->conf.id,
-	    &errcode, sizeof(errcode)) == -1)
+	    buf, size + 2) == -1)
 		fatal("imsg_compose error");
 	peer->state = PEER_ERR;
 }
diff --git a/usr.sbin/bgpd/rde.h b/usr.sbin/bgpd/rde.h
index bc64ec3c8d5..5ef22236f3a 100644
--- a/usr.sbin/bgpd/rde.h
+++ b/usr.sbin/bgpd/rde.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: rde.h,v 1.23 2004/02/09 01:56:18 henning Exp $ */
+/*	$OpenBSD: rde.h,v 1.24 2004/02/16 12:53:15 claudio Exp $ */
 
 /*
  * Copyright (c) 2003, 2004 Claudio Jeker <claudio@openbsd.org> and
@@ -212,11 +212,15 @@ void		 rde_generate_updates(struct prefix *, struct prefix *);
 u_int16_t	 rde_local_as(void);
 
 /* rde_rib.c */
+void		 attr_init(struct attr_flags *);
+int		 attr_parse(u_char *, u_int16_t, struct attr_flags *, int,
+		     u_int16_t);
+u_char		*attr_error(u_char *, u_int16_t, u_int8_t *, u_int16_t *);
 int		 attr_compare(struct attr_flags *, struct attr_flags *);
 void		 attr_copy(struct attr_flags *, struct attr_flags *);
 int		 attr_write(void *, u_int16_t, u_int8_t, u_int8_t, void *,
 		     u_int16_t);
-void		 attr_optadd(struct attr_flags *, u_int8_t, u_int8_t,
+int		 attr_optadd(struct attr_flags *, u_int8_t, u_int8_t,
 		     u_char *, u_int16_t);
 void		 attr_optfree(struct attr_flags *);
 
diff --git a/usr.sbin/bgpd/rde_attr.c b/usr.sbin/bgpd/rde_attr.c
index 9fc75b1e40f..57839c68ff1 100644
--- a/usr.sbin/bgpd/rde_attr.c
+++ b/usr.sbin/bgpd/rde_attr.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: rde_attr.c,v 1.2 2004/02/09 01:56:18 henning Exp $ */
+/*	$OpenBSD: rde_attr.c,v 1.3 2004/02/16 12:53:15 claudio Exp $ */
 
 /*
  * Copyright (c) 2004 Claudio Jeker <claudio@openbsd.org>
@@ -27,6 +27,230 @@
 #include "rde.h"
 
 /* attribute specific functions */
+#define UPD_READ(t, p, plen, n) \
+	do { \
+		memcpy(t, p, n); \
+		p += n; \
+		plen += n; \
+	} while (0)
+
+#define CHECK_FLAGS(s, t)	\
+	(((s) & ~ATTR_EXTLEN) == (t))
+
+void
+attr_init(struct attr_flags *a)
+{
+	bzero(a, sizeof(struct attr_flags));
+	a->origin = ORIGIN_INCOMPLETE;
+	TAILQ_INIT(&a->others);
+}
+
+int
+attr_parse(u_char *p, u_int16_t len, struct attr_flags *a, int ebgp,
+    u_int16_t as)
+{
+	u_int32_t	 tmp32;
+	u_int16_t	 attr_len;
+	u_int16_t	 plen = 0;
+	u_int8_t	 flags;
+	u_int8_t	 type;
+	u_int8_t	 tmp8;
+	int		 r; /* XXX */
+
+	if (len < 3)
+		return (-1);
+
+	UPD_READ(&flags, p, plen, 1);
+	UPD_READ(&type, p, plen, 1);
+
+	if (flags & ATTR_EXTLEN) {
+		if (len - plen < 2)
+			return (-1);
+		UPD_READ(&attr_len, p, plen, 2);
+	} else {
+		UPD_READ(&tmp8, p, plen, 1);
+		attr_len = tmp8;
+	}
+
+	if (len - plen < attr_len)
+		return (-1);
+
+	switch (type) {
+	case ATTR_UNDEF:
+		/* error! */
+		return (-1);
+	case ATTR_ORIGIN:
+		if (attr_len != 1)
+			return (-1);
+		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN))
+			return (-1);
+		UPD_READ(&a->origin, p, plen, 1);
+		if (a->origin > ORIGIN_INCOMPLETE)
+			return (-1);
+		break;
+	case ATTR_ASPATH:
+		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN))
+			return (-1);
+		if ((r = aspath_verify(p, attr_len, as)) != 0) {
+			/* XXX could also be a aspath loop but this
+			 * check should be moved to the filtering. */
+			/* XXX loop detection should be done afterwards
+			 * because this is not an error */
+			log_warnx("XXX aspath_verify failed: error %i", r);
+			return (-1);
+		}
+		a->aspath = aspath_create(p, attr_len);
+		/* XXX enforce remote-as == left most AS if not disabled */
+		plen += attr_len;
+		break;
+	case ATTR_NEXTHOP:
+		if (attr_len != 4)
+			return (-1);
+		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN))
+			return (-1);
+		UPD_READ(&a->nexthop, p, plen, 4);	/* network byte order */
+		/* XXX check if the nexthop is a valid IP address */
+		break;
+	case ATTR_MED:
+		if (attr_len != 4)
+			return (-1);
+		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL))
+			return (-1);
+		UPD_READ(&tmp32, p, plen, 4);
+		a->med = ntohl(tmp32);
+		break;
+	case ATTR_LOCALPREF:
+		if (attr_len != 4)
+			return (-1);
+		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN))
+			return (-1);
+		if (ebgp) {
+			/* ignore local-pref attr for non ibgp peers */
+			a->lpref = 0;	/* set a default value */
+			break;
+		}
+		UPD_READ(&tmp32, p, plen, 4);
+		a->lpref = ntohl(tmp32);
+		break;
+	case ATTR_ATOMIC_AGGREGATE:
+		if (attr_len != 0)
+			return (-1);
+		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN))
+			return (-1);
+		goto optattr;
+	case ATTR_AGGREGATOR:
+		if (attr_len != 6)
+			return (-1);
+		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL|ATTR_TRANSITIVE))
+			return (-1);
+		goto optattr;
+	default:
+optattr:
+		/* XXX error checking */
+		attr_optadd(a, flags, type, p, attr_len);
+		plen += attr_len;
+		break;
+	}
+
+	return (plen);
+}
+
+u_char *
+attr_error(u_char *p, u_int16_t len, u_int8_t *suberr, u_int16_t *size)
+{
+	u_int16_t	 attr_len;
+	u_int16_t	 plen = 0;
+	u_int8_t	 flags;
+	u_int8_t	 type;
+	u_int8_t	 tmp8;
+
+	*suberr = ERR_UPD_ATTRLEN;
+	*size = len;
+	if (len < 3)
+		return (p);
+
+	UPD_READ(&flags, p, plen, 1);
+	UPD_READ(&type, p, plen, 1);
+
+	if (flags & ATTR_EXTLEN) {
+		if (len - plen < 2)
+			return (p);
+		UPD_READ(&attr_len, p, plen, 2);
+	} else {
+		UPD_READ(&tmp8, p, plen, 1);
+		attr_len = tmp8;
+	}
+
+	if (len - plen < attr_len)
+		return (p);
+	*size = attr_len;
+
+	switch (type) {
+	case ATTR_UNDEF:
+		/* error! */
+		*suberr = ERR_UPD_UNSPECIFIC;
+		*size = 0;
+		return (NULL);
+	case ATTR_ORIGIN:
+		if (attr_len != 1)
+			return (p);
+		UPD_READ(&tmp8, p, plen, 1);
+		if (tmp8 > ORIGIN_INCOMPLETE) {
+			*suberr = ERR_UPD_ORIGIN;
+			return (p);
+		}
+		break;
+	case ATTR_ASPATH:
+		if (CHECK_FLAGS(flags, ATTR_WELL_KNOWN)) {
+			/* malformed aspath detected by exclusion method */
+			*size = 0;
+			*suberr = ERR_UPD_ASPATH;
+			return (NULL);
+		}
+		break;
+	case ATTR_NEXTHOP:
+		if (attr_len != 4)
+			return (p);
+		if (CHECK_FLAGS(flags, ATTR_WELL_KNOWN)) {
+			/* malformed nexthop detected by exclusion method */
+			*suberr = ERR_UPD_NETWORK;
+			return (p);
+		}
+		break;
+	case ATTR_MED:
+		if (attr_len != 4)
+			return (p);
+		break;
+	case ATTR_LOCALPREF:
+		if (attr_len != 4)
+			return (p);
+		break;
+	case ATTR_ATOMIC_AGGREGATE:
+		if (attr_len != 0)
+			return (p);
+		break;
+	case ATTR_AGGREGATOR:
+		if (attr_len != 6)
+			return (p);
+		break;
+	default:
+		if (!CHECK_FLAGS(flags, ATTR_WELL_KNOWN)) {
+			*suberr = ERR_UPD_UNKNWN_WK_ATTR;
+			return (p);
+		}
+		if (!CHECK_FLAGS(flags, ATTR_OPTIONAL)) {
+			*suberr = ERR_UPD_ATTRFLAGS;
+			return (p);
+		}
+		*suberr = ERR_UPD_OPTATTR;
+		return (p);
+	}
+	/* can only be a attribute flag error */
+	*suberr = ERR_UPD_ATTRFLAGS;
+	return (p);
+}
+#undef UPD_READ
+
 int
 attr_compare(struct attr_flags *a, struct attr_flags *b)
 {
@@ -125,19 +349,20 @@ attr_write(void *p, u_int16_t p_len, u_int8_t flags, u_int8_t type,
 	return (tot_len);
 }
 
-void
+int
 attr_optadd(struct attr_flags *attr, u_int8_t flags, u_int8_t type,
     u_char *data, u_int16_t len)
 {
 	struct attr	*a, *p;
 
+	/* XXX we need to do some basic checks (flags, len if known,...) */
 	if (flags & ATTR_OPTIONAL && ! flags & ATTR_TRANSITIVE)
 		/*
 		 * We already know that we're not intrested in this attribute.
 		 * Currently only the MED is optional and non-transitive but
 		 * MED is directly stored in struct attr_flags.
 		 */
-		return;
+		return (0);
 
 	a = calloc(1, sizeof(struct attr));
 	if (a == NULL)
@@ -150,15 +375,19 @@ attr_optadd(struct attr_flags *attr, u_int8_t flags, u_int8_t type,
 		if (a->data == NULL)
 			fatal("attr_optadd");
 		memcpy(a->data, data, len);
-	}
+	} else
+		a->data = NULL;
+
 	/* keep a sorted list */
 	TAILQ_FOREACH_REVERSE(p, &attr->others, attr_l, attr_list) {
 		if (type > p->type) {
 			TAILQ_INSERT_AFTER(&attr->others, p, a, attr_l);
-			return;
+			return (0);
 		}
 		ENSURE(type != p->type);
 	}
+	TAILQ_INSERT_HEAD(&attr->others, a, attr_l);
+	return (0);
 }
 
 void
@@ -166,9 +395,8 @@ attr_optfree(struct attr_flags *attr)
 {
 	struct attr	*a, *xa;
 
-	for (a = TAILQ_FIRST(&attr->others); a != TAILQ_END(&attr->others);
-	    a = xa) {
-		xa = TAILQ_NEXT(a, attr_l);
+	while ((a = TAILQ_FIRST(&attr->others)) != NULL) {
+		TAILQ_REMOVE(&attr->others, a, attr_l);
 		free(a->data);
 		free(a);
 	}
@@ -207,6 +435,7 @@ int
 aspath_verify(void *data, u_int16_t len, u_int16_t myAS)
 {
 	u_int8_t	*seg = data;
+	int		 error = 0;
 	u_int16_t	 seg_size;
 	u_int8_t	 i, seg_len, seg_type;
 
@@ -225,12 +454,13 @@ aspath_verify(void *data, u_int16_t len, u_int16_t myAS)
 			/* empty aspath segment are not allowed */
 			return AS_ERR_BAD;
 
+		/* XXX not needed */
 		for (i = 0; i < seg_len; i++) {
 			if (myAS == aspath_extract(seg, i))
-				return AS_ERR_LOOP;
+				error = AS_ERR_LOOP;
 		}
 	}
-	return 0;	/* all OK */
+	return (error);	/* aspath is valid but probably not loop free */
 }
 
 struct aspath *
diff --git a/usr.sbin/bgpd/session.c b/usr.sbin/bgpd/session.c
index 85b174cf94b..47924a394fb 100644
--- a/usr.sbin/bgpd/session.c
+++ b/usr.sbin/bgpd/session.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: session.c,v 1.108 2004/02/02 23:15:00 henning Exp $ */
+/*	$OpenBSD: session.c,v 1.109 2004/02/16 12:53:15 claudio Exp $ */
 
 /*
  * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
@@ -1431,9 +1431,10 @@ session_dispatch_imsg(struct imsgbuf *ibuf, int idx)
 	struct mrt_config	 mrt;
 	struct peer_config	*pconf;
 	struct peer		*p, *next;
+	u_char			*data;
 	enum reconf_action	 reconf;
 	int			 n;
-	u_int8_t		 suberr;
+	u_int8_t		 errcode, subcode;
 
 	if ((n = imsg_read(ibuf)) == -1)
 		fatal("session_dispatch_imsg: imsg_read error");
@@ -1542,18 +1543,24 @@ session_dispatch_imsg(struct imsgbuf *ibuf, int idx)
 		case IMSG_UPDATE_ERR:
 			if (idx != PFD_PIPE_ROUTE)
 				fatalx("update request not from RDE");
-			if (imsg.hdr.len != IMSG_HEADER_SIZE + sizeof(suberr)) {
+			if (imsg.hdr.len < IMSG_HEADER_SIZE + 2) {
 				log_warnx("RDE sent invalid notification");
 				break;
 			}
-			if ((p = getpeerbyid(imsg.hdr.peerid)) == NULL)
+			if ((p = getpeerbyid(imsg.hdr.peerid)) == NULL) {
 				log_warnx("no such peer: id=%u",
 				    imsg.hdr.peerid);
-			else {
-				memcpy(&suberr, imsg.data, sizeof(suberr));
-				session_notification(p, ERR_UPDATE, suberr,
-				    NULL, 0);
+				break;
 			}
+			data = imsg.data;
+			errcode = *data++;
+			subcode = *data++;
+			
+			if (imsg.hdr.len == IMSG_HEADER_SIZE + 2)
+				data = NULL;
+
+			session_notification(p, errcode, subcode,
+			    data, imsg.hdr.len - IMSG_HEADER_SIZE - 2);
 			break;
 		default:
 			break;
diff --git a/usr.sbin/bgpd/session.h b/usr.sbin/bgpd/session.h
index 237eb4bbec3..1868f80dd67 100644
--- a/usr.sbin/bgpd/session.h
+++ b/usr.sbin/bgpd/session.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: session.h,v 1.29 2004/02/09 23:16:46 henning Exp $ */
+/*	$OpenBSD: session.h,v 1.30 2004/02/16 12:53:15 claudio Exp $ */
 
 /*
  * Copyright (c) 2003, 2004 Henning Brauer <henning@openbsd.org>
@@ -72,15 +72,6 @@ enum msg_type {
 	KEEPALIVE
 };
 
-enum err_codes {
-	ERR_HEADER = 1,
-	ERR_OPEN,
-	ERR_UPDATE,
-	ERR_HOLDTIMEREXPIRED,
-	ERR_FSM,
-	ERR_CEASE
-};
-
 enum suberr_header {
 	ERR_HDR_SYNC = 1,
 	ERR_HDR_LEN,

