commit 6f261fe82bcfff45346a0ff8a5b1bcf4956d3624
Author: Andrew Beekhof <andrew@beekhof.net>
Date:   Wed Nov 5 14:01:12 2008 +0100

    High: ais: Allow the crmd to get callbacks whenever a node's state changes
    This is required so that a node's resource list and transient node attributes
    can be cleared when it re-joins the cluster
    
    Mercurial revision: 34cde591c618ff2dc9b66dca98d538c6f4b5f488

diff --git a/crmd/callbacks.c b/crmd/callbacks.c
index 0bca6d9dd..5b3c57e5a 100644
--- a/crmd/callbacks.c
+++ b/crmd/callbacks.c
@@ -268,6 +268,34 @@ lrm_op_callback(lrm_op_t* op)
 	process_lrm_event(op);
 }
 
+void ais_status_callback(enum crm_status_type type, crm_node_t *node, const void *data) 
+{
+    gboolean reset_status_entry = FALSE;
+    if(AM_I_DC == FALSE || node->uname == NULL) {
+	return;
+    }
+    
+    switch(type) {
+	case crm_status_uname:
+	    crm_info("status: %s is now %s", node->uname, node->state);
+	    /* reset_status_entry = TRUE; */
+	    /* If we've never seen the node, then it also wont be in the status section */
+	    break;
+	case crm_status_nstate:
+	    crm_info("status: %s is now %s (was %s)", node->uname, node->state, (const char *)data);
+	    reset_status_entry = TRUE;
+	    break;
+	case crm_status_processes:
+	    break;
+    }
+
+    if(reset_status_entry && safe_str_eq(ONLINESTATUS, node->state)) {
+	erase_status_tag(fsa_our_uname, XML_CIB_TAG_LRM);
+	erase_status_tag(fsa_our_uname, XML_TAG_TRANSIENT_NODEATTRS);
+    }
+
+}
+
 void
 crmd_ha_status_callback(const char *node, const char *status, void *private)
 {
@@ -375,12 +403,10 @@ crmd_client_status_callback(const char * node, const char * client,
 
 	} else {
 	    crm_debug_3("Got client status callback");
-
-	    if(fsa_cib_conn != NULL && safe_str_eq(status, ONLINESTATUS)) {
+	    if(safe_str_eq(status, ONLINESTATUS)) {
 		erase_status_tag(fsa_our_uname, XML_CIB_TAG_LRM);
 		erase_status_tag(fsa_our_uname, XML_TAG_TRANSIENT_NODEATTRS);
 	    }
-	    
 	    update = create_node_state(
 		node, NULL, NULL, status, join, NULL, clear_shutdown, __FUNCTION__);
 	    
diff --git a/crmd/control.c b/crmd/control.c
index 2530c278c..27b39d61d 100644
--- a/crmd/control.c
+++ b/crmd/control.c
@@ -130,6 +130,8 @@ do_ha_control(long long action,
 #if SUPPORT_AIS
 		destroy = crm_ais_destroy;
 		dispatch = crm_ais_dispatch;
+		crm_set_status_callback(&ais_status_callback);
+		
 #endif
 	    } else if(is_heartbeat_cluster()) {
 #if SUPPORT_HEARTBEAT
diff --git a/crmd/crmd_callbacks.h b/crmd/crmd_callbacks.h
index 2d288640d..725a6e6da 100644
--- a/crmd/crmd_callbacks.h
+++ b/crmd/crmd_callbacks.h
@@ -17,6 +17,8 @@
  */
 
 #include <clplumbing/ipc.h>
+#include <crm/ais_common.h>
+#include <crm/common/cluster.h>
 
 #if SUPPORT_HEARTBEAT
 #include <hb_api.h>
@@ -61,3 +63,5 @@ extern gboolean crmd_client_connect(
 extern void crmd_cib_connection_destroy(gpointer user_data);
 
 extern gboolean crm_fsa_trigger(gpointer user_data);
+
+extern void ais_status_callback(enum crm_status_type type, crm_node_t *node, const void *data);
diff --git a/include/crm/common/cluster.h b/include/crm/common/cluster.h
index f07694972..61dde710f 100644
--- a/include/crm/common/cluster.h
+++ b/include/crm/common/cluster.h
@@ -88,6 +88,15 @@ extern const char *get_uname(const char *uuid);
 extern void set_uuid(xmlNode *node, const char *attr, const char *uname);
 extern void unget_uuid(const char *uname);
 
+enum crm_status_type 
+{
+    crm_status_uname,
+    crm_status_nstate,
+    crm_status_processes,
+};
+
 enum crm_ais_msg_types text2msg_type(const char *text);
+extern void crm_set_status_callback(
+    void (*dispatch)(enum crm_status_type, crm_node_t*, const void*));
 
 #endif
diff --git a/lib/common/membership.c b/lib/common/membership.c
index 11eb71882..b8263c60d 100644
--- a/lib/common/membership.c
+++ b/lib/common/membership.c
@@ -195,6 +195,15 @@ crm_node_t *crm_get_peer(unsigned int id, const char *uname)
     return node;
 }
 
+void (*crm_status_callback)(enum crm_status_type, crm_node_t*, const void*) = NULL;
+    
+void crm_set_status_callback(
+    void (*dispatch)(enum crm_status_type,crm_node_t*, const void*))
+{
+    crm_status_callback = dispatch;
+}
+
+
 crm_node_t *crm_update_peer(
     unsigned int id, uint64_t born, uint64_t seen, int32_t votes, uint32_t children,
     const char *uuid, const char *uname, const char *addr, const char *state) 
@@ -240,6 +249,9 @@ crm_node_t *crm_update_peer(
 	node->uname = crm_strdup(uname);
 	crm_info("Node %u is now known as %s", id, uname);	
 	g_hash_table_insert(crm_peer_cache, node->uname, node);
+	if(crm_status_callback) {
+	    crm_status_callback(crm_status_uname, node, NULL);
+	}
     }
     
     if(node->uuid == NULL) {
@@ -260,8 +272,13 @@ crm_node_t *crm_update_peer(
     }
 
     if(children > 0 && children != node->processes) {
-	procs_changed = TRUE;
+	uint32_t last = node->processes;
 	node->processes = children;
+	procs_changed = TRUE;
+
+	if(crm_status_callback) {
+	    crm_status_callback(crm_status_processes, node, &last);
+	}
     }
 
     if(born != 0) {
@@ -269,9 +286,14 @@ crm_node_t *crm_update_peer(
     }
 
     if(state != NULL && safe_str_neq(node->state, state)) {
-	state_changed = TRUE;
-	crm_free(node->state);
+	char *last = node->state;
 	node->state = crm_strdup(state);
+	state_changed = TRUE;
+
+	if(crm_status_callback) {
+	    crm_status_callback(crm_status_nstate, node, last);
+	}
+	crm_free(last);
     }
 
     if(seen != 0 && crm_is_member_active(node)) {

