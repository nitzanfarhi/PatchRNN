commit 81d05d18f8c8dca1ceba06ce3f1e04e1f160aceb
Author: Bruce Pascoe <fatcerberus@icloud.com>
Date:   Tue Apr 10 01:44:18 2018 -0400

    Factor out all uses of longjmp (except JSAL)
    
    Well, technically, main() still calls longjmp internally... but that was
    only because removing them entirely would have required major surgery on
    main(), which I'm not up for at the moment.  The point is that no
    *other* function ever longjmp's into main(), which fully fixes #255.

diff --git a/src/minisphere/dispatch.c b/src/minisphere/dispatch.c
index cf58b58e..b48760f9 100644
--- a/src/minisphere/dispatch.c
+++ b/src/minisphere/dispatch.c
@@ -66,7 +66,7 @@ dispatch_init(void)
 	s_onetime_jobs = vector_new(sizeof(struct job));
 	s_recurring_jobs = vector_new(sizeof(struct job));
 	s_exit_jobs = vector_new(sizeof(struct job));
-	
+
 	// reserve extra slots for one-time jobs.  realloc() is fairly expensive
 	// and the one-time queue gets very heavy traffic.
 	vector_reserve(s_onetime_jobs, 32);
@@ -121,6 +121,12 @@ dispatch_cancel_all(bool recurring, bool also_critical)
 			job->finished = true;
 	}
 
+	iter = vector_enum(s_exit_jobs);
+	while ((job = iter_next(&iter))) {
+		if (!job->critical || also_critical)
+			job->finished = true;
+	}
+
 	if (recurring) {
 		iter = vector_enum(s_recurring_jobs);
 		while ((job = iter_next(&iter)))
@@ -246,7 +252,7 @@ static struct job*
 job_from_token(int64_t token)
 {
 	struct job* job;
-	
+
 	iter_t iter;
 
 	iter = vector_enum(s_recurring_jobs);
diff --git a/src/minisphere/main.c b/src/minisphere/main.c
index e7307fe3..07e55b12 100644
--- a/src/minisphere/main.c
+++ b/src/minisphere/main.c
@@ -255,7 +255,7 @@ main(int argc, char* argv[])
 #else
 		fprintf(stderr, "ERROR: couldn't start game '%s'\n", path_cstr(g_game_path));
 #endif
-		sphere_exit(false);
+		longjmp(s_jmp_exit, 1);
 	}
 
 	// set up the render context ("screen") so we can draw stuff
@@ -311,7 +311,7 @@ main(int argc, char* argv[])
 
 	g_event_loop_version = 1;
 	g_restarting = false;
-	
+
 	// evaluate the main script (v1) or module (v2)
 	script_path = game_script_path(g_game);
 	api_version = game_version(g_game);
@@ -354,19 +354,18 @@ main(int argc, char* argv[])
 	// start up the event loop.  we can do this even in compatibility mode:
 	// the event loop terminates when there are no pending jobs or promises to settle,
 	// and neither one was available in Sphere 1.x.
-	jsal_disable_vm(false);  // in case of early bailout, onExit() jobs still need to run
 	if (!pegasus_start_event_loop())
 		goto on_js_error;
-	
+
 #if defined(MINISPHERE_SPHERUN)
 	if (ssj_mode == SSJ_OFF)
 		profiler_uninit();
 #endif
 
 	if (g_restarting)
-		sphere_restart();
+		longjmp(s_jmp_restart, 1);
 
-	sphere_exit(false);
+	longjmp(s_jmp_exit, 1);
 
 on_js_error:
 	jsal_dup(-1);
@@ -400,24 +399,29 @@ on_js_error:
 	else
 		jsal_push_sprintf("uncaught JavaScript exception.\n\n%s\n", error_text);
 	show_error_screen(jsal_get_string(-1));
-	sphere_exit(false);
+	longjmp(s_jmp_exit, 1);
 }
 
-no_return
+void
 sphere_abort(const char* message)
 {
 	show_error_screen(message);
 	sphere_exit(false);
 }
 
-no_return
+void
 sphere_exit(bool shutting_down)
 {
+	// note: this won't exit immediately.  it merely cancels Dispatch jobs and
+	//       disables the JavaScript VM so that control will fall through the event
+	//       loop naturally.
+
 	if (shutting_down) {
 		path_free(g_last_game_path);
 		g_last_game_path = NULL;
 	}
-	longjmp(s_jmp_exit, 1);
+	dispatch_cancel_all(true, true);
+	jsal_disable_vm(true);
 }
 
 void
@@ -435,7 +439,7 @@ sphere_heartbeat(bool in_event_loop)
 	if (in_event_loop)
 		start_time = al_get_time();
 #endif
-	
+
 	sockets_update();
 
 	if (in_event_loop) {
@@ -470,12 +474,6 @@ sphere_heartbeat(bool in_event_loop)
 #endif
 }
 
-no_return
-sphere_restart(void)
-{
-	longjmp(s_jmp_restart, 1);
-}
-
 void
 sphere_sleep(double time)
 {
@@ -653,7 +651,7 @@ find_startup_game(path_t* *out_path)
 		"startup/game.sgm",
 		"dist/game.sgm",
 	};
-	
+
 	ALLEGRO_FS_ENTRY* engine_dir;
 	const char*       file_ext;
 	const char*       filename;
@@ -930,7 +928,7 @@ show_error_screen(const char* message)
 	transform_orthographic(projection, 0, 0, resolution.width, resolution.height, -1.0f, 1.0f);
 	image_set_transform(screen_backbuffer(g_screen), projection);
 	transform_unref(projection);
-	
+
 	is_finished = false;
 	frames_till_close = 30;
 	while (!is_finished) {
diff --git a/src/minisphere/minisphere.h b/src/minisphere/minisphere.h
index 237b6579..3eb6a64c 100644
--- a/src/minisphere/minisphere.h
+++ b/src/minisphere/minisphere.h
@@ -96,8 +96,7 @@ extern screen_t*            g_screen;
 extern font_t*              g_system_font;
 extern uint32_t             g_tick_count;
 
-no_return sphere_abort     (const char* message);
-no_return sphere_exit      (bool shutting_down);
-void      sphere_heartbeat (bool in_event_loop);
-no_return sphere_restart   (void);
-void      sphere_sleep     (double time);
+void sphere_abort     (const char* message);
+void sphere_exit      (bool shutting_down);
+void sphere_heartbeat (bool in_event_loop);
+void sphere_sleep     (double time);
diff --git a/src/minisphere/pegasus.c b/src/minisphere/pegasus.c
index dbc2824e..59d1ba57 100644
--- a/src/minisphere/pegasus.c
+++ b/src/minisphere/pegasus.c
@@ -841,7 +841,7 @@ pegasus_init(void)
 	jsal_push_eval("Surface.Screen");
 	s_screen_obj = jsal_ref(-1);
 	jsal_pop(1);
-	
+
 	// pre-create joystick objects for Joystick.getDevices().  this ensures that
 	// multiple requests for the device list return the same Joystick object(s).
 	create_joystick_objects();
@@ -863,7 +863,7 @@ void
 pegasus_uninit(void)
 {
 	jsal_unref(s_screen_obj);
-	
+
 	jsal_unref(s_key_color);
 	jsal_unref(s_key_done);
 	jsal_unref(s_key_inBackground);
@@ -1032,7 +1032,7 @@ static void
 jsal_pegasus_push_color(color_t color, bool in_ctor)
 {
 	color_t* color_ptr;
-	
+
 	jsal_push_class_fatobj(PEGASUS_COLOR, in_ctor, sizeof(color_t), (void**)&color_ptr);
 	*color_ptr = color;
 }
@@ -1050,7 +1050,7 @@ static void
 jsal_pegasus_push_require(const char* module_id)
 {
 	jsal_push_new_function(js_require, "require", 1, 0);
-	
+
 	// assign 'require.cache'
 	jsal_push_new_object();
 	jsal_push_hidden_stash();
@@ -1058,7 +1058,7 @@ jsal_pegasus_push_require(const char* module_id)
 	jsal_remove(-2);
 	jsal_put_prop_string(-2, "value");
 	jsal_def_prop_string(-2, "cache");
-	
+
 	if (module_id != NULL) {
 		jsal_push_new_object();
 		jsal_push_string(module_id);
@@ -1199,14 +1199,17 @@ handle_main_event_loop(int num_args, bool is_ctor, intptr_t magic)
 		++g_tick_count;
 	}
 
-	// miniature "exit loop" to deal with .onExit() jobs
+	// deal with Dispatch.onExit() jobs
+	// note: Sphere v1 Exit() disables the VM to cause the engine to fall out of
+	//       JavaScript naturally, so we need to re-enable it here.
+	jsal_disable_vm(false);
 	s_shutting_down = true;
 	while (!dispatch_can_exit() || jsal_busy()) {
 		sphere_heartbeat(true);
 		dispatch_run(JOB_ON_TICK);
 		dispatch_run(JOB_ON_EXIT);
 	}
-	
+
 	return false;
 }
 
@@ -1318,7 +1321,7 @@ js_require(int num_args, bool is_ctor, intptr_t magic)
 		"#/game_modules",
 		"#/runtime",
 	};
-	
+
 	const char* id;
 	const char* parent_id = NULL;
 	path_t*     path;
@@ -1461,6 +1464,7 @@ js_Sphere_abort(int num_args, bool is_ctor, intptr_t magic)
 
 	text = strnewf("abort requested...\n\n%s\n", message);
 	sphere_abort(text);
+	return false;
 }
 
 static bool
@@ -2863,7 +2867,7 @@ js_new_Mixer(int num_args, bool is_ctor, intptr_t magic)
 		jsal_error(JS_RANGE_ERROR, "Invalid audio bit depth '%d'", bits);
 	if (channels < 1 || channels > 7)
 		jsal_error(JS_RANGE_ERROR, "Invalid channel count '%d'", channels);
-	
+
 	if (!(mixer = mixer_new(frequency, bits, channels)))
 		jsal_error(JS_ERROR, "Couldn't create %d-bit %dch voice", bits, channels);
 	jsal_push_class_obj(PEGASUS_MIXER, mixer, true);
@@ -3401,7 +3405,7 @@ js_RNG_next(int num_args, bool is_ctor, intptr_t magic)
 	xoro = jsal_require_class_obj(-1, PEGASUS_RNG);
 
 	value = xoro_gen_double(xoro);
-	
+
 	jsal_push_new_object();
 	jsal_push_boolean_false();
 	jsal_put_prop_key(-2, s_key_done);
@@ -3424,7 +3428,7 @@ js_SSj_instrument(int num_args, bool is_ctor, intptr_t magic)
 {
 #if defined(MINISPHERE_SPHERUN)
 	static unsigned int next_function_id = 1;
-	
+
 	js_ref_t*   function_ref;
 	const char* name = NULL;
 	js_ref_t*   shim_ref;
@@ -3465,11 +3469,11 @@ js_SSj_log(int num_args, bool is_ctor, intptr_t magic)
 			jsal_replace(0);
 		else
 			jsal_pop(1);
-	} 
+	}
 	else if (jsal_is_object(0) && !jsal_is_function(0)) {
 		jsal_stringify(0);
 	}
-	
+
 	text = jsal_to_string(0);
 	debugger_log(text, (ki_log_op_t)magic, true);
 #endif
@@ -3554,7 +3558,7 @@ js_SSj_profile(int num_args, bool is_ctor, intptr_t magic)
 	jsal_push_ref_weak(shim_ref);
 	jsal_put_prop_key(-2, s_key_value);
 	jsal_def_prop_string(0, key);
-	
+
 	jsal_unref(shim_ref);
 	free(record_name);
 #endif
@@ -3789,7 +3793,7 @@ js_Shape_drawImmediate(int num_args, bool is_ctor, intptr_t magic)
 			: al_map_rgba_f(1.0f, 1.0f, 1.0f, 1.0f);
 		jsal_pop(7);
 	}
-	
+
 	draw_mode = type == SHAPE_LINES ? ALLEGRO_PRIM_LINE_LIST
 		: type == SHAPE_LINE_LOOP ? ALLEGRO_PRIM_LINE_LOOP
 		: type == SHAPE_LINE_STRIP ? ALLEGRO_PRIM_LINE_STRIP
@@ -4716,7 +4720,7 @@ js_new_Texture(int num_args, bool is_ctor, intptr_t magic)
 	int y;
 
 	class_id = magic;
-	
+
 	if (num_args >= 3 && (buffer = jsal_get_buffer_ptr(2, &buffer_size))) {
 		// create an Image from an ArrayBuffer or similar object
 		width = jsal_require_int(0);
@@ -4918,11 +4922,11 @@ js_Transform_get_matrix(int num_args, bool is_ctor, intptr_t magic)
 				jsal_push_new_function(js_Transform_get_matrix, "get", 0, 1 + (j * 4 + i));
 				jsal_push_this();
 				jsal_put_prop_string(-2, "\xFF" "transform");
-				
+
 				jsal_push_new_function(js_Transform_set_matrix, "set", 0, 1 + (j * 4 + i));
 				jsal_push_this();
 				jsal_put_prop_string(-2, "\xFF" "transform");
-				
+
 				jsal_push_eval("({ enumerable: true })");
 				jsal_pull(-2);
 				jsal_put_prop_string(-2, "set");
@@ -5129,7 +5133,7 @@ js_new_VertexList(int num_args, bool is_ctor, intptr_t magic)
 	num_entries = (int)jsal_get_length(0);
 	if (num_entries == 0)
 		jsal_error(JS_RANGE_ERROR, "Empty list is not allowed");
-	
+
 	vbo = vbo_new();
 	for (i = 0; i < num_entries; ++i) {
 		jsal_get_prop_index(0, i);
@@ -5156,7 +5160,7 @@ js_new_VertexList(int num_args, bool is_ctor, intptr_t magic)
 		vbo_unref(vbo);
 		jsal_error(JS_ERROR, "Couldn't upload VertexList to GPU");
 	}
-	
+
 	jsal_push_class_obj(PEGASUS_VERTEX_LIST, vbo, true);
 	return true;
 }
@@ -5180,10 +5184,10 @@ js_Z_deflate(int num_args, bool is_ctor, intptr_t magic)
 	input_data = jsal_require_buffer_ptr(0, &input_size);
 	if (num_args >= 2)
 		level = jsal_require_int(1);
-	
+
 	if (level < 0 || level > 9)
 		jsal_error(JS_RANGE_ERROR, "Invalid compression level '%d'", level);
-	
+
 	if (!(output_data = z_deflate(input_data, input_size, level, &output_size)))
 		jsal_error(JS_ERROR, "Couldn't deflate THE PIG (it's too fat)");
 	jsal_push_new_buffer(JS_ARRAYBUFFER, output_size, &buffer);
@@ -5201,7 +5205,7 @@ js_Z_inflate(int num_args, bool is_ctor, intptr_t magic)
 	int         max_size = 0;
 	void*       output_data;
 	size_t      output_size;
-	
+
 	input_data = jsal_require_buffer_ptr(0, &input_size);
 	if (num_args >= 2)
 		max_size = jsal_require_int(1);
diff --git a/src/minisphere/vanilla.c b/src/minisphere/vanilla.c
index c90ec15c..886606c8 100644
--- a/src/minisphere/vanilla.c
+++ b/src/minisphere/vanilla.c
@@ -1511,6 +1511,7 @@ js_Abort(int num_args, bool is_ctor, intptr_t magic)
 
 	text = strnewf("abort requested...\n\n%s\n", message);
 	sphere_abort(text);
+	return false;
 }
 
 static bool
@@ -2098,7 +2099,7 @@ js_DeflateByteArray(int num_args, bool is_ctor, intptr_t magic)
 	input_array = jsal_require_class_obj(0, SV1_BYTE_ARRAY);
 	if (num_args >= 2)
 		level = jsal_to_int(1);
-	
+
 	if (level < 0 || level > 9)
 		jsal_error(JS_RANGE_ERROR, "Invalid compression level '%d'", level);
 
@@ -2738,7 +2739,7 @@ js_GetKeyString(int num_args, bool is_ctor, intptr_t magic)
 {
 	int  keycode;
 	bool shift = false;
-	
+
 	keycode = jsal_to_int(0);
 	if (num_args >= 2)
 		shift = jsal_to_boolean(1);
@@ -4803,7 +4804,7 @@ js_OutlinedRoundRectangle(int num_args, bool is_ctor, intptr_t magic)
 	double  width;
 	double  x;
 	double  y;
-	
+
 	x = trunc(jsal_to_number(0)) + 0.5;
 	y = trunc(jsal_to_number(1)) + 0.5;
 	width = trunc(jsal_to_number(2));
@@ -4881,7 +4882,7 @@ static bool
 js_Print(int num_args, bool is_ctor, intptr_t magic)
 {
 	const char* text;
-	
+
 	if (jsal_is_object(0))
 		jsal_stringify(0);
 	text = jsal_to_string(0);
@@ -4944,7 +4945,7 @@ js_Rectangle(int num_args, bool is_ctor, intptr_t magic)
 	double  width;
 	double  x;
 	double  y;
-	
+
 	x = trunc(jsal_to_number(0));
 	y = trunc(jsal_to_number(1));
 	width = trunc(jsal_to_number(2));
@@ -6710,7 +6711,7 @@ js_File_read(int num_args, bool is_ctor, intptr_t magic)
 	jsal_push_this();
 	if (!(file = jsal_require_class_obj(-1, SV1_FILE)))
 		jsal_error(JS_ERROR, "file is already closed");
-	
+
 	if (jsal_is_boolean(1)) {
 		def_bool = jsal_get_boolean(1);
 		jsal_push_boolean(kev_read_bool(file, key, def_bool));

