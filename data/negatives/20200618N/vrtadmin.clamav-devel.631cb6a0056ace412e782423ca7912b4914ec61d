commit 631cb6a0056ace412e782423ca7912b4914ec61d
Author: Mickey Sola <msola@sourcefire.com>
Date:   Wed Feb 1 17:29:27 2017 -0500

    Fixes and updates to intermediate container sig rules based on code review

diff --git a/libclamav/bytecode_api.c b/libclamav/bytecode_api.c
index 6838c28d9..f60b7ddca 100644
--- a/libclamav/bytecode_api.c
+++ b/libclamav/bytecode_api.c
@@ -527,7 +527,7 @@ int32_t cli_bcapi_extract_new(struct cli_bc_ctx *ctx, int32_t id)
     if (cctx) {
         cctx->recursion++;
         if (ctx->containertype != CL_TYPE_ANY) {
-            size_t csize = cli_get_container_size(cctx, -1);
+            size_t csize = cli_get_container_size(cctx, -2);
             cli_set_container(cctx, ctx->containertype, csize);
         }
         res = cli_magic_scandesc(ctx->outfd, cctx);
diff --git a/libclamav/others.c b/libclamav/others.c
index 75c627b08..2a0ef5a2a 100644
--- a/libclamav/others.c
+++ b/libclamav/others.c
@@ -1144,7 +1144,7 @@ cli_file_t cli_get_container_type(cli_ctx *ctx, int index)
 {
     if (index < 0)
 	index = ctx->recursion + index + 1;
-    if (index >= 0 || index <= ctx->recursion)
+    if (index >= 0 && index <= ctx->recursion)
 	return ctx->containers[index].type;
     return CL_TYPE_ANY;
 }
@@ -1153,7 +1153,7 @@ size_t cli_get_container_size(cli_ctx *ctx, int index)
 {
     if (index < 0)
 	index = ctx->recursion + index + 1;
-    if (index >= 0 || index <= ctx->recursion)
+    if (index >= 0 && index <= ctx->recursion)
 	return ctx->containers[index].size;
     return 0;
 }
diff --git a/libclamav/readdb.c b/libclamav/readdb.c
index feb0728c9..6e126eade 100644
--- a/libclamav/readdb.c
+++ b/libclamav/readdb.c
@@ -1458,6 +1458,10 @@ static int lsigattribs(char *attribs, struct cli_lsig_tdb *tdb)
 
                 off[i] = cnt = tdb->cnt[CLI_TDB_UINT];
                 ftypes_count = cli_strtokenize(pt, '>', EXPR_TOKEN_MAX, (const char **) ftypes);
+                if(!ftypes_count) {
+                    cli_dbgmsg("lsigattribs: No intermediate container tokens found.");
+                    return 1;
+                }
                 tdb->cnt[CLI_TDB_UINT] += (ftypes_count + 1);
                 tdb->val = (uint32_t *) mpool_realloc2(tdb->mempool, tdb->val, tdb->cnt[CLI_TDB_UINT] * sizeof(uint32_t));
                 if(!tdb->val) {
diff --git a/libclamav/scanners.c b/libclamav/scanners.c
index 3b81ba2ce..f7774df12 100644
--- a/libclamav/scanners.c
+++ b/libclamav/scanners.c
@@ -2370,7 +2370,7 @@ static int cli_scanraw(cli_ctx *ctx, cli_file_t type, uint8_t typercg, cli_file_
 	if(nret != CL_VIRUS) switch(ret) {
 	    case CL_TYPE_HTML:
 		/* bb#11196 - autoit script file misclassified as HTML */
-		if (cli_get_container_type(ctx, -1) == CL_TYPE_AUTOIT) {
+		if (cli_get_container_type(ctx, -2) == CL_TYPE_AUTOIT) {
 		    ret = CL_TYPE_TEXT_ASCII;
 		} else if (SCAN_HTML && (type == CL_TYPE_TEXT_ASCII || type == CL_TYPE_GRAPHICS) &&
                     (DCONF_DOC & DOC_CONF_HTML)) {
diff --git a/sigtool/sigtool.c b/sigtool/sigtool.c
index ee636e730..06c5734e0 100644
--- a/sigtool/sigtool.c
+++ b/sigtool/sigtool.c
@@ -211,6 +211,7 @@ static int hashpe(const char *filename, unsigned int class, int type)
     ctx.dconf = (struct cli_dconf *) engine->dconf;
     ctx.fmap = calloc(sizeof(fmap_t *), 1);
     if(!ctx.fmap) {
+        free(ctx.containers);
 	cl_engine_free(engine);
 	return -1;
     }
@@ -219,6 +220,7 @@ static int hashpe(const char *filename, unsigned int class, int type)
     fd = open(filename, O_RDONLY);
     if(fd < 0) {
 	mprintf("!hashpe: Can't open file %s!\n", filename);
+        free(ctx.containers);
         cl_engine_free(engine);
         return -1;
     }
@@ -226,6 +228,7 @@ static int hashpe(const char *filename, unsigned int class, int type)
     lseek(fd, 0, SEEK_SET);
     FSTAT(fd, &sb);
     if(!(*ctx.fmap = fmap(fd, 0, sb.st_size))) {
+        free(ctx.containers);
 	free(ctx.fmap);
 	close(fd);
 	cl_engine_free(engine);
@@ -235,6 +238,7 @@ static int hashpe(const char *filename, unsigned int class, int type)
     fmptr = fmap_need_off_once(*ctx.fmap, 0, sb.st_size);
     if(!fmptr) {
         mprintf("!hashpe: fmap_need_off_once failed!\n");
+        free(ctx.containers);
         free(ctx.fmap);
         close(fd);
         cl_engine_free(engine);
@@ -276,6 +280,7 @@ static int hashpe(const char *filename, unsigned int class, int type)
     }
 
     /* Cleanup */
+    free(ctx.containers);
     free(ctx.fmap);
     close(fd);
     cl_engine_free(engine);
@@ -2241,12 +2246,14 @@ static void matchsig(const char *sig, const char *offset, int fd)
     ctx.dconf = (struct cli_dconf *) engine->dconf;
     ctx.fmap = calloc(sizeof(fmap_t *), 1);
     if(!ctx.fmap) {
+        free(ctx.containers);
 	cl_engine_free(engine);
 	return;
     }
     lseek(fd, 0, SEEK_SET);
     FSTAT(fd, &sb);
     if(!(*ctx.fmap = fmap(fd, 0, sb.st_size))) {
+        free(ctx.containers);
 	free(ctx.fmap);
 	cl_engine_free(engine);
 	return;
@@ -2274,6 +2281,7 @@ static void matchsig(const char *sig, const char *offset, int fd)
 	acres = acres->next;
 	free(res);
     }
+    free(ctx.containers);
     free(ctx.fmap);
     cl_engine_free(engine);
 }
@@ -3432,6 +3440,7 @@ static int dumpcerts(const struct optstruct *opts)
     ctx.dconf = (struct cli_dconf *) engine->dconf;
     ctx.fmap = calloc(sizeof(fmap_t *), 1);
     if(!ctx.fmap) {
+        free(ctx.containers);
 	cl_engine_free(engine);
 	return -1;
     }
@@ -3440,6 +3449,7 @@ static int dumpcerts(const struct optstruct *opts)
     fd = open(filename, O_RDONLY);
     if(fd < 0) {
 	mprintf("!dumpcerts: Can't open file %s!\n", filename);
+        free(ctx.containers);
         cl_engine_free(engine);
         return -1;
     }
@@ -3447,6 +3457,7 @@ static int dumpcerts(const struct optstruct *opts)
     lseek(fd, 0, SEEK_SET);
     FSTAT(fd, &sb);
     if(!(*ctx.fmap = fmap(fd, 0, sb.st_size))) {
+        free(ctx.containers);
 	free(ctx.fmap);
 	close(fd);
 	cl_engine_free(engine);
@@ -3456,6 +3467,7 @@ static int dumpcerts(const struct optstruct *opts)
     fmptr = fmap_need_off_once(*ctx.fmap, 0, sb.st_size);
     if(!fmptr) {
         mprintf("!dumpcerts: fmap_need_off_once failed!\n");
+        free(ctx.containers);
         free(ctx.fmap);
         close(fd);
         cl_engine_free(engine);
@@ -3486,6 +3498,7 @@ static int dumpcerts(const struct optstruct *opts)
     }
 
     /* Cleanup */
+    free(ctx.containers);
     free(ctx.fmap);
     close(fd);
     cl_engine_free(engine);

