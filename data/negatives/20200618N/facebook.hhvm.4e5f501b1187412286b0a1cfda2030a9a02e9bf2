commit 4e5f501b1187412286b0a1cfda2030a9a02e9bf2
Author: Edwin Smith <smith@fb.com>
Date:   Wed Dec 9 11:54:17 2015 -0800

    Put NamedEntitys in lowmem, use LowPtr<NamedEntity>
    
    Summary:
    Move the named entity table contents to lowmem, so pointers to
    NamedEntitys in the table can be LowPtr.
    
    Reviewed By: jasone
    
    Differential Revision: D2681409
    
    fb-gh-sync-id: 5bc1abb63e53f12bd9338f20f7c9454b239a50ab

diff --git a/hphp/runtime/vm/func-inl.h b/hphp/runtime/vm/func-inl.h
index 2be8568207..57eea7b62b 100644
--- a/hphp/runtime/vm/func-inl.h
+++ b/hphp/runtime/vm/func-inl.h
@@ -133,7 +133,11 @@ inline StrNR Func::fullNameStr() const {
 
 inline const NamedEntity* Func::getNamedEntity() const {
   assert(!shared()->m_preClass);
-  return m_namedEntity;
+  return *reinterpret_cast<const LowPtr<const NamedEntity>*>(&m_namedEntity);
+}
+
+inline void Func::setNamedEntity(const NamedEntity* e) {
+  *reinterpret_cast<LowPtr<const NamedEntity>*>(&m_namedEntity) = e;
 }
 
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/hphp/runtime/vm/func.cpp b/hphp/runtime/vm/func.cpp
index ee37e520d6..fbcc46a094 100644
--- a/hphp/runtime/vm/func.cpp
+++ b/hphp/runtime/vm/func.cpp
@@ -265,7 +265,7 @@ void Func::setFullName(int numParams) {
     // `methodSlot', which refers to its slot in its `baseCls' (which still
     // points to a subclass of Closure).
     if (!isMethod()) {
-      m_namedEntity = NamedEntity::get(m_name);
+      setNamedEntity(NamedEntity::get(m_name));
     }
   }
   if (RuntimeOption::EvalPerfDataMap) {
diff --git a/hphp/runtime/vm/func.h b/hphp/runtime/vm/func.h
index bf2a50bd60..12bea125a7 100644
--- a/hphp/runtime/vm/func.h
+++ b/hphp/runtime/vm/func.h
@@ -1153,7 +1153,7 @@ private:
   void appendParam(bool ref, const ParamInfo& info,
                    std::vector<ParamInfo>& pBuilder);
   void finishedEmittingParams(std::vector<ParamInfo>& pBuilder);
-
+  void setNamedEntity(const NamedEntity*);
 
   /////////////////////////////////////////////////////////////////////////////
   // Internal types.
@@ -1209,7 +1209,6 @@ public:
   static std::atomic<bool>     s_treadmill;
   static std::atomic<uint32_t> s_totalClonedClosures;
 
-
   /////////////////////////////////////////////////////////////////////////////
   // Data members.
   //
@@ -1233,8 +1232,8 @@ private:
   // The Class that provided this method implementation.
   AtomicLowPtr<Class> m_cls{nullptr};
   union {
-    const NamedEntity* m_namedEntity{nullptr};
-    Slot m_methodSlot;
+    Slot m_methodSlot{0};
+    LowPtr<const NamedEntity>::storage_type m_namedEntity;
   };
   // Atomically-accessed intercept flag.  -1, 0, or 1.
   // TODO(#1114385) intercept should work via invalidation.
diff --git a/hphp/runtime/vm/named-entity-pair-table-inl.h b/hphp/runtime/vm/named-entity-pair-table-inl.h
index d3f315a238..51cc53f655 100644
--- a/hphp/runtime/vm/named-entity-pair-table-inl.h
+++ b/hphp/runtime/vm/named-entity-pair-table-inl.h
@@ -28,7 +28,7 @@ inline bool NamedEntityPairTable::contains(Id id) const {
 
 inline StringData* NamedEntityPairTable::lookupLitstr(Id id) const {
   assert(contains(id));
-  return const_cast<StringData*>((*this)[id].first);
+  return const_cast<StringData*>((*this)[id].first.get());
 }
 
 inline const NamedEntity*
@@ -48,7 +48,8 @@ NamedEntityPairTable::lookupNamedEntityPair(Id id) const {
 
   // Create the NamedEntity if necessary.
   if (UNLIKELY(!nep.second)) {
-    const_cast<const NamedEntity*&>(nep.second) = NamedEntity::get(nep.first);
+    const_cast<LowPtr<const NamedEntity>&>(nep.second) =
+      NamedEntity::get(nep.first);
   }
   return nep;
 }
diff --git a/hphp/runtime/vm/named-entity.h b/hphp/runtime/vm/named-entity.h
index 9e5c3a35b9..6f43b0c401 100644
--- a/hphp/runtime/vm/named-entity.h
+++ b/hphp/runtime/vm/named-entity.h
@@ -23,6 +23,7 @@
 
 #include "hphp/util/portability.h"
 #include "hphp/util/low-ptr.h"
+#include "hphp/util/alloc.h"
 
 #include <folly/AtomicHashMap.h>
 
@@ -77,7 +78,8 @@ struct NamedEntity {
   typedef folly::AtomicHashMap<const StringData*,
                                NamedEntity,
                                string_data_hash,
-                               ahm_string_data_isame> Map;
+                               ahm_string_data_isame,
+                               LowAllocator<char>> Map;
 
   /////////////////////////////////////////////////////////////////////////////
   // Constructors.
@@ -203,7 +205,7 @@ private:
 /*
  * Litstr and NamedEntity pair.
  */
-using NamedEntityPair = std::pair<const StringData*, const NamedEntity*>;
+using NamedEntityPair = std::pair<LowStringPtr,LowPtr<const NamedEntity>>;
 
 }
 
diff --git a/hphp/runtime/vm/preclass.h b/hphp/runtime/vm/preclass.h
index bbdb6427e2..68bbb2d083 100644
--- a/hphp/runtime/vm/preclass.h
+++ b/hphp/runtime/vm/preclass.h
@@ -446,7 +446,7 @@ public:
 
 private:
   Unit* m_unit;
-  NamedEntity* m_namedEntity;
+  LowPtr<NamedEntity> m_namedEntity;
   int m_line1;
   int m_line2;
   Offset m_offset;
diff --git a/hphp/runtime/vm/type-constraint.cpp b/hphp/runtime/vm/type-constraint.cpp
index e155ef360d..7b5d68b004 100644
--- a/hphp/runtime/vm/type-constraint.cpp
+++ b/hphp/runtime/vm/type-constraint.cpp
@@ -57,7 +57,7 @@ void TypeConstraint::init() {
         this, m_typeName->data());
   m_type = Type::Object;
   m_namedEntity = NamedEntity::get(m_typeName);
-  TRACE(5, "TypeConstraint: NamedEntity: %p\n", m_namedEntity);
+  TRACE(5, "TypeConstraint: NamedEntity: %p\n", m_namedEntity.get());
 }
 
 std::string TypeConstraint::displayName(const Func* func /*= nullptr*/) const {
diff --git a/hphp/runtime/vm/type-constraint.h b/hphp/runtime/vm/type-constraint.h
index 3da3e2967a..36970f0793 100644
--- a/hphp/runtime/vm/type-constraint.h
+++ b/hphp/runtime/vm/type-constraint.h
@@ -260,7 +260,7 @@ private:
   Type m_type;
   Flags m_flags;
   LowStringPtr m_typeName;
-  const NamedEntity* m_namedEntity;
+  LowPtr<const NamedEntity> m_namedEntity;
 };
 
 //////////////////////////////////////////////////////////////////////
diff --git a/hphp/util/alloc.h b/hphp/util/alloc.h
index 9ab05a27f7..3b3fa8ccdb 100644
--- a/hphp/util/alloc.h
+++ b/hphp/util/alloc.h
@@ -315,6 +315,61 @@ int jemalloc_pprof_dump(const std::string& prefix, bool force);
 
 #endif // USE_JEMALLOC
 
+template <class T>
+struct LowAllocator {
+  typedef T              value_type;
+  typedef T*             pointer;
+  typedef const T*       const_pointer;
+  typedef T&             reference;
+  typedef const T&       const_reference;
+  typedef std::size_t    size_type;
+  typedef std::ptrdiff_t difference_type;
+
+  template <class U>
+  struct rebind { using other = LowAllocator<U>; };
+
+  pointer address(reference value) {
+    return &value;
+  }
+  const_pointer address(const_reference value) const {
+    return &value;
+  }
+
+  LowAllocator() noexcept {}
+  template<class U> LowAllocator(const LowAllocator<U>&) noexcept {}
+  ~LowAllocator() noexcept {}
+
+  size_type max_size() const {
+    return std::numeric_limits<std::size_t>::max() / sizeof(T);
+  }
+
+  pointer allocate(size_type num, const void* = 0) {
+    pointer ret = (pointer)low_malloc(num * sizeof(T));
+    return ret;
+  }
+
+  template<class U, class... Args>
+  void construct(U* p, Args&&... args) {
+    ::new ((void*)p) U(std::forward<Args>(args)...);
+  }
+
+  void destroy(pointer p) {
+    p->~T();
+  }
+
+  void deallocate(pointer p, size_type num) {
+    low_free((void*)p);
+  }
+
+  template<class U> bool operator==(const LowAllocator<U>&) const {
+    return true;
+  }
+
+  template<class U> bool operator!=(const LowAllocator<U>&) const {
+    return false;
+  }
+};
+
 ///////////////////////////////////////////////////////////////////////////////
 }
 

