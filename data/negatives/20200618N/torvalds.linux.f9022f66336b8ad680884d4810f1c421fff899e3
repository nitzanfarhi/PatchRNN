commit f9022f66336b8ad680884d4810f1c421fff899e3
Author: Ian Kent <raven@themaw.net>
Date:   Sun Jun 25 05:48:47 2006 -0700

    [PATCH] autofs4: need to invalidate children on tree mount expire
    
    I've found a case where invalid dentrys in a mount tree, waiting to be
    cleaned up by d_invalidate, prevent the expected expire.
    
    In this case dentrys created during a lookup for which a mount fails or has
    no entry in the mount map contribute to the d_count of the parent dentry.
    These dentrys may not be invalidated prior to comparing the interanl usage
    count of valid autofs dentrys against the dentry d_count which makes a
    mount tree appear busy so it doesn't expire.
    
    Signed-off-by: Ian Kent <raven@themaw.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/fs/autofs4/expire.c b/fs/autofs4/expire.c
index b8ce02607d66..4456d1daa40f 100644
--- a/fs/autofs4/expire.c
+++ b/fs/autofs4/expire.c
@@ -174,6 +174,12 @@ static int autofs4_tree_busy(struct vfsmount *mnt,
 			struct autofs_info *ino = autofs4_dentry_ino(p);
 			unsigned int ino_count = atomic_read(&ino->count);
 
+			/*
+			 * Clean stale dentries below that have not been
+			 * invalidated after a mount fail during lookup
+			 */
+			d_invalidate(p);
+
 			/* allow for dget above and top is already dgot */
 			if (p == top)
 				ino_count += 2;

