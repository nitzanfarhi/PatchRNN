commit c30b981260e26dfeff315b766e2887d4f7404f89
Author: Randolph Tan <randolph@10gen.com>
Date:   Mon Jul 28 11:35:11 2014 -0400

    SERVER-14506 special top chunk logic can move max chunk to a shard with incompatible tag
    
    Make DistributionStatus store ChunkTypes instead of BSONObj

diff --git a/src/mongo/base/owned_pointer_map.h b/src/mongo/base/owned_pointer_map.h
index eb0594c32f..63745b9bc1 100644
--- a/src/mongo/base/owned_pointer_map.h
+++ b/src/mongo/base/owned_pointer_map.h
@@ -49,7 +49,7 @@ namespace mongo {
         ~OwnedPointerMap();
 
         /** Access the map. */
-        const MapType& map() { return _map; }
+        const MapType& map() const { return _map; }
         MapType& mutableMap() { return _map; }
 
         void clear();
diff --git a/src/mongo/s/balance.cpp b/src/mongo/s/balance.cpp
index f3bf9dc09c..78c357068f 100644
--- a/src/mongo/s/balance.cpp
+++ b/src/mongo/s/balance.cpp
@@ -30,6 +30,7 @@
 
 #include "mongo/s/balance.h"
 
+#include "mongo/base/owned_pointer_map.h"
 #include "mongo/client/dbclientcursor.h"
 #include "mongo/db/jsobj.h"
 #include "mongo/db/write_concern.h"
@@ -279,21 +280,36 @@ namespace mongo {
         for (vector<string>::const_iterator it = collections.begin(); it != collections.end(); ++it ) {
             const string& ns = *it;
 
-            map< string,vector<BSONObj> > shardToChunksMap;
+            OwnedPointerMap<string, OwnedPointerVector<ChunkType> > shardToChunksMap;
             cursor = conn.query(ChunkType::ConfigNS,
                                 QUERY(ChunkType::ns(ns)).sort(ChunkType::min()));
 
             set<BSONObj> allChunkMinimums;
 
             while ( cursor->more() ) {
-                BSONObj chunk = cursor->nextSafe().getOwned();
-                vector<BSONObj>& chunks = shardToChunksMap[chunk[ChunkType::shard()].String()];
-                allChunkMinimums.insert( chunk[ChunkType::min()].Obj() );
-                chunks.push_back( chunk );
+                BSONObj chunkDoc = cursor->nextSafe().getOwned();
+
+                auto_ptr<ChunkType> chunk(new ChunkType());
+                string errmsg;
+                if (!chunk->parseBSON(chunkDoc, &errmsg)) {
+                    error() << "bad chunk format for " << chunkDoc
+                            << ": " << errmsg << endl;
+                    return;
+                }
+
+                allChunkMinimums.insert(chunk->getMin().getOwned());
+                OwnedPointerVector<ChunkType>*& chunkList =
+                        shardToChunksMap.mutableMap()[chunk->getShard()];
+
+                if (chunkList == NULL) {
+                    chunkList = new OwnedPointerVector<ChunkType>();
+                }
+
+                chunkList->mutableVector().push_back(chunk.release());
             }
             cursor.reset();
 
-            if (shardToChunksMap.empty()) {
+            if (shardToChunksMap.map().empty()) {
                 LOG(1) << "skipping empty collection (" << ns << ")";
                 continue;
             }
@@ -301,10 +317,15 @@ namespace mongo {
             for ( vector<Shard>::iterator i=allShards.begin(); i!=allShards.end(); ++i ) {
                 // this just makes sure there is an entry in shardToChunksMap for every shard
                 Shard s = *i;
-                shardToChunksMap[s.getName()].size();
+                OwnedPointerVector<ChunkType>*& chunkList =
+                        shardToChunksMap.mutableMap()[s.getName()];
+
+                if (chunkList == NULL) {
+                    chunkList = new OwnedPointerVector<ChunkType>();
+                }
             }
 
-            DistributionStatus status( shardInfo, shardToChunksMap );
+            DistributionStatus status(shardInfo, shardToChunksMap.map());
 
             // load tags
             Status result = clusterCreateIndex(TagsType::ConfigNS,
diff --git a/src/mongo/s/balancer_policy.cpp b/src/mongo/s/balancer_policy.cpp
index 484a86da9d..b6add34c47 100644
--- a/src/mongo/s/balancer_policy.cpp
+++ b/src/mongo/s/balancer_policy.cpp
@@ -63,27 +63,37 @@ namespace mongo {
 
     unsigned DistributionStatus::totalChunks() const {
         unsigned total = 0;
-        for ( ShardToChunksMap::const_iterator i = _shardChunks.begin(); i != _shardChunks.end(); ++i )
-            total += i->second.size();
+
+        for (ShardToChunksMap::const_iterator i = _shardChunks.begin();
+                i != _shardChunks.end(); ++i) {
+            total += i->second->size();
+        }
+
         return total;
     }
 
     unsigned DistributionStatus::numberOfChunksInShard( const string& shard ) const {
-        ShardToChunksMap::const_iterator i = _shardChunks.find( shard );
-        if ( i == _shardChunks.end() )
+        ShardToChunksMap::const_iterator i = _shardChunks.find(shard);
+        if (i == _shardChunks.end()) {
             return 0;
-        return i->second.size();
+        }
+
+        return i->second->size();
     }
 
     unsigned DistributionStatus::numberOfChunksInShardWithTag( const string& shard , const string& tag ) const {
-        ShardToChunksMap::const_iterator i = _shardChunks.find( shard );
-        if ( i == _shardChunks.end() )
+        ShardToChunksMap::const_iterator i = _shardChunks.find(shard);
+        if (i == _shardChunks.end()) {
             return 0;
+        }
 
         unsigned total = 0;
-        for ( unsigned j=0; j<i->second.size(); j++ )
-            if ( tag == getTagForChunk( i->second[j] ) )
+        const vector<ChunkType*>& chunkList = i->second->vector();
+        for (unsigned j = 0; j < i->second->size(); j++) {
+            if (tag == getTagForChunk(*chunkList[j])) {
                 total++;
+            }
+        }
 
         return total;
     }
@@ -148,10 +158,12 @@ namespace mongo {
         return worst;
     }
 
-    const vector<BSONObj>& DistributionStatus::getChunks( const string& shard ) const {
+    const vector<ChunkType*>& DistributionStatus::getChunks(
+            const string& shard) const {
         ShardToChunksMap::const_iterator i = _shardChunks.find(shard);
-        verify( i != _shardChunks.end() );
-        return i->second;
+        verify(i != _shardChunks.end());
+
+        return i->second->vector();
     }
 
     bool DistributionStatus::addTagRange( const TagRange& range ) {
@@ -188,11 +200,11 @@ namespace mongo {
         return true;
     }
 
-    string DistributionStatus::getTagForChunk( const BSONObj& chunk ) const {
+    string DistributionStatus::getTagForChunk( const ChunkType& chunk ) const {
         if ( _tagRanges.size() == 0 )
             return "";
 
-        BSONObj min = chunk[ChunkType::min()].Obj();
+        const BSONObj min(chunk.getMin());
 
         map<BSONObj,TagRange>::const_iterator i = _tagRanges.upper_bound( min );
         if ( i == _tagRanges.end() )
@@ -210,11 +222,13 @@ namespace mongo {
         log() << "  shards" << endl;
         for ( ShardInfoMap::const_iterator i = _shardInfo.begin(); i != _shardInfo.end(); ++i ) {
             log() << "      " << i->first << "\t" << i->second.toString() << endl;
-            ShardToChunksMap::const_iterator j = _shardChunks.find( i->first );
-            verify( j != _shardChunks.end() );
-            const vector<BSONObj>& v = j->second;
+
+            ShardToChunksMap::const_iterator j = _shardChunks.find(i->first);
+            verify(j != _shardChunks.end());
+
+            const OwnedPointerVector<ChunkType>& v = *j->second;
             for ( unsigned x = 0; x < v.size(); x++ )
-                log() << "          " << v[x] << endl;
+                log() << "          " << *v[x] << endl;
         }
 
         if ( _tagRanges.size() > 0 ) {
@@ -227,13 +241,6 @@ namespace mongo {
         }
     }
 
-    bool BalancerPolicy::_isJumbo( const BSONObj& chunk ) {
-        if ( chunk[ChunkType::jumbo()].trueValue() ) {
-            LOG(1) << "chunk: " << chunk << "is marked as jumbo" << endl;
-            return true;
-        }
-        return false;
-    }
     MigrateInfo* BalancerPolicy::balance( const string& ns,
                                           const DistributionStatus& distribution,
                                           int balancedLastTime ) {
@@ -267,13 +274,13 @@ namespace mongo {
                     continue;
                 }
 
-                const vector<BSONObj>& chunks = distribution.getChunks( shard );
+                const vector<ChunkType* >& chunks = distribution.getChunks( shard );
                 unsigned numJumboChunks = 0;
 
                 // since we have to move all chunks, lets just do in order
                 for ( unsigned i=0; i<chunks.size(); i++ ) {
-                    BSONObj chunkToMove = chunks[i];
-                    if ( _isJumbo( chunkToMove ) ) {
+                    const ChunkType& chunkToMove = *chunks[i];
+                    if (chunkToMove.isJumboSet() && chunkToMove.getJumbo()) {
                         numJumboChunks++;
                         continue;
                     }
@@ -282,14 +289,19 @@ namespace mongo {
                     string to = distribution.getBestReceieverShard( tag );
 
                     if ( to.size() == 0 ) {
-                        warning() << "want to move chunk: " << chunkToMove << "(" << tag << ") "
-                                  << "from " << shard << " but can't find anywhere to put it" << endl;
+                        warning() << "want to move chunk: " << chunkToMove
+                                  << "(" << tag << ") "
+                                  << "from " << shard
+                                  << " but can't find anywhere to put it" << endl;
                         continue;
                     }
 
-                    log() << "going to move " << chunkToMove << " from " << shard << "(" << tag << ")" << " to " << to << endl;
+                    log() << "going to move " << chunkToMove
+                          << " from " << shard
+                          << "(" << tag << ")"
+                          << " to " << to << endl;
 
-                    return new MigrateInfo( ns, to, shard, chunkToMove.getOwned() );
+                    return new MigrateInfo(ns, to, shard, chunkToMove.toBSON());
                 }
 
                 warning() << "can't find any chunk to move from: " << shard
@@ -307,20 +319,21 @@ namespace mongo {
                 string shard = *i;
                 const ShardInfo& info = distribution.shardInfo( shard );
 
-                const vector<BSONObj>& chunks = distribution.getChunks( shard );
+                const vector<ChunkType *>& chunks = distribution.getChunks(shard);
                 for ( unsigned j = 0; j < chunks.size(); j++ ) {
-                    string tag = distribution.getTagForChunk( chunks[j] );
+                    const ChunkType& chunk = *chunks[j];
+                    string tag = distribution.getTagForChunk(chunk);
 
                     if ( info.hasTag( tag ) )
                         continue;
 
                     // uh oh, this chunk is in the wrong place
-                    log() << "chunk " << chunks[j]
+                    log() << "chunk " << chunk
                           << " is not on a shard with the right tag: "
                           << tag << endl;
 
-                    if ( _isJumbo( chunks[j] ) ) {
-                        warning() << "chunk " << chunks[j] << " is jumbo, so cannot be moved" << endl;
+                    if (chunk.isJumboSet() && chunk.getJumbo()) {
+                        warning() << "chunk " << chunk << " is jumbo, so cannot be moved" << endl;
                         continue;
                     }
 
@@ -331,7 +344,7 @@ namespace mongo {
                     }
                     verify( to != shard );
                     log() << " going to move to: " << to << endl;
-                    return new MigrateInfo( ns, to, shard, chunks[j].getOwned() );
+                    return new MigrateInfo(ns, to, shard, chunk.toBSON());
                 }
             }
         }
@@ -385,21 +398,22 @@ namespace mongo {
             if ( imbalance < threshold )
                 continue;
 
-            const vector<BSONObj>& chunks = distribution.getChunks( from );
+            const vector<ChunkType *>& chunks = distribution.getChunks(from);
             unsigned numJumboChunks = 0;
             for ( unsigned j = 0; j < chunks.size(); j++ ) {
-                if ( distribution.getTagForChunk( chunks[j] ) != tag )
+                const ChunkType& chunk = *chunks[j];
+                if (distribution.getTagForChunk(chunk) != tag)
                     continue;
 
-                if ( _isJumbo( chunks[j] ) ) {
+                if (chunk.isJumboSet() && chunk.getJumbo()) {
                     numJumboChunks++;
                     continue;
                 }
 
-                log() << " ns: " << ns << " going to move " << chunks[j]
+                log() << " ns: " << ns << " going to move " << chunk
                       << " from: " << from << " to: " << to << " tag [" << tag << "]"
                       << endl;
-                return new MigrateInfo( ns, to, from, chunks[j] );
+                return new MigrateInfo(ns, to, from, chunk.toBSON());
             }
 
             if ( numJumboChunks ) {
diff --git a/src/mongo/s/balancer_policy.h b/src/mongo/s/balancer_policy.h
index 1bd674aeeb..6da9de0eee 100644
--- a/src/mongo/s/balancer_policy.h
+++ b/src/mongo/s/balancer_policy.h
@@ -31,6 +31,7 @@
 #ifndef S_BALANCER_POLICY_HEADER
 #define S_BALANCER_POLICY_HEADER
 
+#include "mongo/base/owned_pointer_vector.h"
 #include "mongo/db/jsobj.h"
 #include "mongo/s/type_chunk.h"
 
@@ -125,7 +126,7 @@ namespace mongo {
     };
 
     typedef std::map< std::string,ShardInfo > ShardInfoMap;
-    typedef std::map< std::string,std::vector<BSONObj> > ShardToChunksMap;
+    typedef std::map<std::string, OwnedPointerVector<ChunkType>* > ShardToChunksMap;
 
     class DistributionStatus : boost::noncopyable {
     public:
@@ -166,13 +167,13 @@ namespace mongo {
         unsigned numberOfChunksInShardWithTag( const std::string& shard, const std::string& tag ) const;
 
         /** @return chunks for the shard */
-        const std::vector<BSONObj>& getChunks( const std::string& shard ) const;
+        const std::vector<ChunkType*>& getChunks(const std::string& shard) const;
 
         /** @return all tags we know about, not include "" */
         const std::set<std::string>& tags() const { return _allTags; }
 
         /** @return the right tag for chunk, possibly "" */
-        std::string getTagForChunk( const BSONObj& chunk ) const;
+        std::string getTagForChunk(const ChunkType& chunk) const;
         
         /** @return all shards we know about */
         const std::set<std::string>& shards() const { return _shards; }
@@ -208,9 +209,6 @@ namespace mongo {
         static MigrateInfo* balance( const std::string& ns,
                                      const DistributionStatus& distribution,
                                      int balancedLastTime );
-
-    private:
-        static bool _isJumbo( const BSONObj& chunk );
     };
 
 
diff --git a/src/mongo/s/balancer_policy_tests.cpp b/src/mongo/s/balancer_policy_tests.cpp
index 0bc5470341..cde493c587 100644
--- a/src/mongo/s/balancer_policy_tests.cpp
+++ b/src/mongo/s/balancer_policy_tests.cpp
@@ -25,6 +25,7 @@
  *    then also delete it in the license file.
  */
 
+#include "mongo/base/owned_pointer_map.h"
 #include "mongo/platform/random.h"
 #include "mongo/s/balancer_policy.h"
 #include "mongo/s/config.h"
@@ -35,6 +36,8 @@ namespace mongo {
 
     namespace {
         
+        typedef OwnedPointerMap<string, OwnedPointerVector<ChunkType> > OwnedShardToChunksMap;
+
         TEST( BalancerPolicyTests , SizeMaxedShardTest ) {
             ASSERT( ! ShardInfo( 0, 0, false, false ).isSizeMaxed() );
             ASSERT( ! ShardInfo( 100LL, 80LL, false, false ).isSizeMaxed() );
@@ -43,15 +46,21 @@ namespace mongo {
 
         TEST( BalancerPolicyTests , BalanceNormalTest  ) {
             // 2 chunks and 0 chunk shards
-            ShardToChunksMap chunkMap;
-            vector<BSONObj> chunks;
-            chunks.push_back(BSON(ChunkType::min(BSON("x" << BSON("$minKey"<<1))) <<
-                                  ChunkType::max(BSON("x" << 49))));
-            chunks.push_back(BSON(ChunkType::min(BSON("x" << 49)) <<
-                                  ChunkType::max(BSON("x" << BSON("$maxkey"<<1)))));
-            chunkMap["shard0"] = chunks;
-            chunks.clear();
-            chunkMap["shard1"] = chunks;
+            OwnedShardToChunksMap chunkMap;
+            auto_ptr<OwnedPointerVector<ChunkType> > chunks(new OwnedPointerVector<ChunkType>());
+
+            auto_ptr<ChunkType> chunk(new ChunkType());
+            chunk->setMin(BSON("x" << BSON("$minKey" << 1)));
+            chunk->setMax(BSON("x" << 49));
+            chunks->push_back(chunk.release());
+
+            chunk.reset(new ChunkType());
+            chunk->setMin(BSON("x" << 49));
+            chunk->setMax(BSON("x" << BSON("$maxKey" << 1)));
+            chunks->push_back(chunk.release());
+
+            chunkMap.mutableMap()["shard0"] = chunks.release();
+            chunkMap.mutableMap()["shard1"] = new OwnedPointerVector<ChunkType>();
 
             // no limits
             ShardInfoMap info;
@@ -59,7 +68,7 @@ namespace mongo {
             info["shard1"] = ShardInfo( 0, 0, false, false );
 
             MigrateInfo* c = NULL;
-            DistributionStatus status( info, chunkMap );
+            DistributionStatus status(info, chunkMap.map());
             c = BalancerPolicy::balance( "ns", status, 1 );
             ASSERT( c );
         }
@@ -67,25 +76,39 @@ namespace mongo {
 
         TEST( BalancerPolicyTests , BalanceJumbo  ) {
             // 2 chunks and 0 chunk shards
-            ShardToChunksMap chunkMap;
-            vector<BSONObj> chunks;
-            chunks.push_back(BSON(ChunkType::min(BSON("x" << BSON("$minKey"<<1))) <<
-                                  ChunkType::max(BSON("x" << 10)) <<
-                                  ChunkType::jumbo(true)));
-            chunks.push_back(BSON(ChunkType::min(BSON("x" << 10)) <<
-                                  ChunkType::max(BSON("x" << 20)) <<
-                                  ChunkType::jumbo(true)));
-            chunks.push_back(BSON(ChunkType::min(BSON("x" << 20)) <<
-                                  ChunkType::max(BSON("x" << 30))));
-            chunks.push_back(BSON(ChunkType::min(BSON("x" << 30)) <<
-                                  ChunkType::max(BSON("x" << 40)) <<
-                                  ChunkType::jumbo(true)));
-            chunks.push_back(BSON(ChunkType::min(BSON("x" << 40)) <<
-                                  ChunkType::max(BSON("x" << BSON("$maxkey"<<1))) <<
-                                  ChunkType::jumbo(true)));
-            chunkMap["shard0"] = chunks;
-            chunks.clear();
-            chunkMap["shard1"] = chunks;
+            OwnedShardToChunksMap chunkMap;
+            auto_ptr<OwnedPointerVector<ChunkType> > chunks(new OwnedPointerVector<ChunkType>());
+
+            auto_ptr<ChunkType> chunk(new ChunkType());
+            chunk->setMin(BSON("x" << BSON("$minKey" << 1)));
+            chunk->setMax(BSON("x" << 10));
+            chunk->setJumbo(true);
+            chunks->push_back(chunk.release());
+
+            chunk.reset(new ChunkType());
+            chunk->setMin(BSON("x" << 10));
+            chunk->setMax(BSON("x" << 20));
+            chunk->setJumbo(true);
+            chunks->push_back(chunk.release());
+
+            chunk.reset(new ChunkType());
+            chunk->setMin(BSON("x" << 20));
+            chunk->setMax(BSON("x" << 30));
+            chunks->push_back(chunk.release());
+
+            chunk.reset(new ChunkType());
+            chunk->setMin(BSON("x" << 30));
+            chunk->setMax(BSON("x" << 40));
+            chunk->setJumbo(true);
+            chunks->push_back(chunk.release());
+
+            chunk.reset(new ChunkType());
+            chunk->setMin(BSON("x" << 40));
+            chunk->setMax(BSON("x" << BSON("$maxKey" << 1)));
+            chunks->push_back(chunk.release());
+
+            chunkMap.mutableMap()["shard0"] = chunks.release();
+            chunkMap.mutableMap()["shard1"] = new OwnedPointerVector<ChunkType>;
 
             // no limits
             ShardInfoMap info;
@@ -93,7 +116,7 @@ namespace mongo {
             info["shard1"] = ShardInfo( 0, 0, false, false );
 
             MigrateInfo* c = NULL;
-            DistributionStatus status( info, chunkMap );
+            DistributionStatus status(info, chunkMap.map());
             c = BalancerPolicy::balance( "ns", status, 1 );
             ASSERT( c );
             ASSERT_EQUALS( 30, c->chunk.max["x"].numberInt() );
@@ -103,22 +126,28 @@ namespace mongo {
         TEST( BalanceNormalTests ,  BalanceDrainingTest ) {
             // one normal, one draining
             // 2 chunks and 0 chunk shards
-            ShardToChunksMap chunkMap;
-            vector<BSONObj> chunks;
-            chunks.push_back(BSON(ChunkType::min(BSON("x" << BSON("$minKey"<<1))) <<
-                                  ChunkType::max(BSON("x" << 49))));
-            chunkMap["shard0"] = chunks;
-            chunks.clear();
-            chunks.push_back(BSON(ChunkType::min(BSON("x" << 49))<<
-                                  ChunkType::max(BSON("x" << BSON("$maxkey"<<1)))));
-            chunkMap["shard1"] = chunks;
+            OwnedShardToChunksMap chunkMap;
+            auto_ptr<OwnedPointerVector<ChunkType> > chunks(new OwnedPointerVector<ChunkType>());
+
+            auto_ptr<ChunkType> chunk(new ChunkType());
+            chunk->setMin(BSON("x" << BSON("$minKey" << 1)));
+            chunk->setMax(BSON("x" << 49));
+            chunks->push_back(chunk.release());
+
+            chunk.reset(new ChunkType());
+            chunk->setMin(BSON("x" << 49));
+            chunk->setMax(BSON("x" << BSON("$maxKey" << 1)));
+            chunks->push_back(chunk.release());
+
+            chunkMap.mutableMap()["shard0"] = chunks.release();
+            chunkMap.mutableMap()["shard1"] = new OwnedPointerVector<ChunkType>();
 
             // shard0 is draining
             ShardInfoMap limitsMap;
             limitsMap["shard0"] = ShardInfo( 0LL, 2LL, true, false );
             limitsMap["shard1"] = ShardInfo( 0LL, 0LL, false, false );
 
-            DistributionStatus status( limitsMap, chunkMap );
+            DistributionStatus status(limitsMap, chunkMap.map());
             MigrateInfo* c = BalancerPolicy::balance( "ns", status, 0 );
             ASSERT( c );
             ASSERT_EQUALS( c->to , "shard1" );
@@ -128,22 +157,28 @@ namespace mongo {
 
         TEST( BalancerPolicyTests , BalanceEndedDrainingTest ) {
             // 2 chunks and 0 chunk (drain completed) shards
-            ShardToChunksMap chunkMap;
-            vector<BSONObj> chunks;
-            chunks.push_back(BSON(ChunkType::min(BSON("x" << BSON("$minKey"<<1))) <<
-                                  ChunkType::max(BSON("x" << 49))));
-            chunks.push_back(BSON(ChunkType::min(BSON("x" << 49))<<
-                                  ChunkType::max(BSON("x" << BSON("$maxkey"<<1)))));
-            chunkMap["shard0"] = chunks;
-            chunks.clear();
-            chunkMap["shard1"] = chunks;
+            OwnedShardToChunksMap chunkMap;
+            auto_ptr<OwnedPointerVector<ChunkType> > chunks(new OwnedPointerVector<ChunkType>());
+
+            auto_ptr<ChunkType> chunk(new ChunkType());
+            chunk->setMin(BSON("x" << BSON("$minKey" << 1)));
+            chunk->setMax(BSON("x" << 49));
+            chunks->push_back(chunk.release());
+
+            chunk.reset(new ChunkType());
+            chunk->setMin(BSON("x" << 49));
+            chunk->setMax(BSON("x" << BSON("$maxKey" << 1)));
+            chunks->push_back(chunk.release());
+
+            chunkMap.mutableMap()["shard0"] = chunks.release();
+            chunkMap.mutableMap()["shard1"] = new OwnedPointerVector<ChunkType>();
 
             // no limits
             ShardInfoMap limitsMap;
             limitsMap["shard0"] = ShardInfo( 0, 2, false, false );
             limitsMap["shard1"] = ShardInfo( 0, 0, true, false );
 
-            DistributionStatus status( limitsMap, chunkMap );
+            DistributionStatus status(limitsMap, chunkMap.map());
             MigrateInfo* c = BalancerPolicy::balance( "ns", status, 0 );
             ASSERT( ! c );
         }
@@ -151,15 +186,22 @@ namespace mongo {
         TEST( BalancerPolicyTests , BalanceImpasseTest ) {
             // one maxed out, one draining
             // 2 chunks and 0 chunk shards
-            ShardToChunksMap chunkMap;
-            vector<BSONObj> chunks;
-            chunks.push_back(BSON(ChunkType::min(BSON("x" << BSON("$minKey"<<1))) <<
-                                  ChunkType::max(BSON("x" << 49))));
-            chunkMap["shard0"] = chunks;
-            chunks.clear();
-            chunks.push_back(BSON(ChunkType::min(BSON("x" << 49)) <<
-                                  ChunkType::max(BSON("x" << BSON("$maxkey"<<1)))));
-            chunkMap["shard1"] = chunks;
+            OwnedShardToChunksMap chunkMap;
+            auto_ptr<OwnedPointerVector<ChunkType> > chunks(new OwnedPointerVector<ChunkType>());
+
+            auto_ptr<ChunkType> chunk(new ChunkType());
+            chunk->setMin(BSON("x" << BSON("$minKey" << 1)));
+            chunk->setMax(BSON("x" << 49));
+            chunks->push_back(chunk.release());
+
+            chunk.reset(new ChunkType());
+            chunk->setMin(BSON("x" << 49));
+            chunk->setMax(BSON("x" << BSON("$maxKey" << 1)));
+            chunks->push_back(chunk.release());
+
+            chunkMap.mutableMap()["shard0"] = new OwnedPointerVector<ChunkType>();
+            chunkMap.mutableMap()["shard1"] = chunks.release();
+            chunkMap.mutableMap()["shard2"] = new OwnedPointerVector<ChunkType>();
 
             // shard0 is draining, shard1 is maxed out, shard2 has writebacks pending
             ShardInfoMap limitsMap;
@@ -167,46 +209,52 @@ namespace mongo {
             limitsMap["shard1"] = ShardInfo( 1, 1, false, false );
             limitsMap["shard2"] = ShardInfo( 0, 1, true, false );
 
-            DistributionStatus status(limitsMap, chunkMap);
+            DistributionStatus status(limitsMap, chunkMap.map());
             MigrateInfo* c = BalancerPolicy::balance( "ns", status, 0 );
             ASSERT( ! c );
         }
 
 
-        void addShard( ShardToChunksMap& map, unsigned numChunks, bool last ) {
+        void addShard( OwnedShardToChunksMap& map, unsigned numChunks, bool last ) {
             unsigned total = 0;
-            for ( ShardToChunksMap::const_iterator i = map.begin(); i != map.end(); ++i ) 
-                total += i->second.size();
+            const OwnedShardToChunksMap::MapType& shardToChunks = map.map();
+            for (OwnedShardToChunksMap::MapType::const_iterator i = shardToChunks.begin();
+                    i != shardToChunks.end(); ++i) {
+                total += i->second->size();
+            }
             
             stringstream ss;
-            ss << "shard" << map.size();
+            ss << "shard" << shardToChunks.size();
             string myName = ss.str();
-            vector<BSONObj>& chunks = map[myName];
+            auto_ptr<OwnedPointerVector<ChunkType> > chunksList(
+                    new OwnedPointerVector<ChunkType>());
             
             for ( unsigned i=0; i<numChunks; i++ ) {
-                BSONObj min,max;
+                auto_ptr<ChunkType> chunk(new ChunkType());
                 
                 if ( i == 0 && total == 0 )
-                    min = BSON( "x" << BSON( "$minKey" << 1 ) );
+                    chunk->setMin(BSON("x" << BSON("$minKey" << 1)));
                 else
-                    min = BSON( "x" << total + i );
+                    chunk->setMin(BSON("x" << total + i));
                 
                 if ( last && i == ( numChunks - 1 ) )
-                    max = BSON( "x" << BSON( "$maxKey" << 1 ) );
+                    chunk->setMax(BSON("x" << BSON("$maxKey" << 1)));
                 else
-                    max = BSON( "x" << 1 + total + i );
+                    chunk->setMax(BSON("x" << 1 + total + i));
 
-                chunks.push_back( BSON(ChunkType::min(min) << ChunkType::max(max)));
+                chunksList->push_back(chunk.release());
             }
 
+            OwnedShardToChunksMap::MapType& mutableShardToChunks = map.mutableMap();
+            mutableShardToChunks[myName] = chunksList.release();
         }
 
-        void moveChunk( ShardToChunksMap& map, MigrateInfo* m ) {
-            vector<BSONObj>& chunks = map[m->from];
-            for ( vector<BSONObj>::iterator i = chunks.begin(); i != chunks.end(); ++i ) {
-                if (i->getField(ChunkType::min()).Obj() == m->chunk.min) {
-                    map[m->to].push_back( *i );
-                    chunks.erase( i );
+        void moveChunk( OwnedShardToChunksMap& map, MigrateInfo* m ) {
+            vector<ChunkType*>& chunks = map.mutableMap()[m->from]->mutableVector();
+            for (vector<ChunkType*>::iterator i = chunks.begin(); i != chunks.end(); ++i) {
+                if ((*i)->getMin() == m->chunk.min) {
+                    map.mutableMap()[m->to]->push_back(*i);
+                    chunks.erase(i);
                     return;
                 }
             }
@@ -214,7 +262,7 @@ namespace mongo {
         }
 
         TEST( BalancerPolicyTests, MultipleDraining ) {
-            ShardToChunksMap chunks;
+            OwnedShardToChunksMap chunks;
             addShard( chunks, 5 , false );
             addShard( chunks, 10 , false );
             addShard( chunks, 5 , true );
@@ -224,7 +272,7 @@ namespace mongo {
             shards["shard1"] = ShardInfo( 0, 5, true, false );
             shards["shard2"] = ShardInfo( 0, 5, false, false );
             
-            DistributionStatus d( shards, chunks );
+            DistributionStatus d(shards, chunks.map());
             MigrateInfo* m = BalancerPolicy::balance( "ns", d, 0 );
             ASSERT( m );
             ASSERT_EQUALS( "shard2" , m->to );
@@ -233,7 +281,7 @@ namespace mongo {
 
         TEST( BalancerPolicyTests, TagsDraining ) {
 
-            ShardToChunksMap chunks;
+            OwnedShardToChunksMap chunks;
             addShard( chunks, 5 , false );
             addShard( chunks, 5 , false );
             addShard( chunks, 5 , true );
@@ -249,7 +297,7 @@ namespace mongo {
             shards["shard2"].addTag( "b" );
             
             while ( true ) {
-                DistributionStatus d( shards, chunks );
+                DistributionStatus d(shards, chunks.map());
                 d.addTagRange( TagRange( BSON( "x" << -1 ), BSON( "x" << 7 ) , "a" ) );
                 d.addTagRange( TagRange( BSON( "x" << 7 ), BSON( "x" << 1000 ) , "b" ) );
                 
@@ -265,14 +313,14 @@ namespace mongo {
                 moveChunk( chunks, m );
             }
 
-            ASSERT_EQUALS( 7U , chunks["shard0"].size() );
-            ASSERT_EQUALS( 0U , chunks["shard1"].size() );
-            ASSERT_EQUALS( 8U , chunks["shard2"].size() );
+            ASSERT_EQUALS( 7U , chunks.mutableMap()["shard0"]->size() );
+            ASSERT_EQUALS( 0U , chunks.mutableMap()["shard1"]->size() );
+            ASSERT_EQUALS( 8U , chunks.mutableMap()["shard2"]->size() );
         }
 
 
         TEST( BalancerPolicyTests, TagsPolicyChange ) {
-            ShardToChunksMap chunks;
+            OwnedShardToChunksMap chunks;
             addShard( chunks, 5 , false );
             addShard( chunks, 5 , false );
             addShard( chunks, 5 , true );
@@ -287,7 +335,7 @@ namespace mongo {
             
             while ( true ) {
                 
-                DistributionStatus d( shards, chunks );
+                DistributionStatus d(shards, chunks.map());
                 d.addTagRange( TagRange( BSON( "x" << -1 ), BSON( "x" << 1000 ) , "a" ) );
                 
                 MigrateInfo* m = BalancerPolicy::balance( "ns", d, 0 );
@@ -297,17 +345,19 @@ namespace mongo {
                 moveChunk( chunks, m );
             }
             
-            ASSERT_EQUALS( 15U , chunks["shard0"].size() + chunks["shard1"].size() );
-            ASSERT( chunks["shard0"].size() == 7U || chunks["shard0"].size() == 8U );
-            ASSERT_EQUALS( 0U , chunks["shard2"].size() );
+            const size_t shard0Size = chunks.mutableMap()["shard0"]->size();
+            const size_t shard1Size = chunks.mutableMap()["shard1"]->size();
+            ASSERT_EQUALS( 15U , shard0Size + shard1Size );
+            ASSERT(shard0Size == 7U || shard0Size == 8U);
+            ASSERT_EQUALS(0U, chunks.mutableMap()["shard2"]->size());
 
         }
 
 
         TEST( BalancerPolicyTests, TagsSelector ) {
-            ShardToChunksMap chunks;
+            OwnedShardToChunksMap chunks;
             ShardInfoMap shards;
-            DistributionStatus d( shards, chunks );
+            DistributionStatus d(shards, chunks.map());
             ASSERT( d.addTagRange( TagRange( BSON( "x" << 1 ), BSON( "x" << 10 ) , "a" ) ) );
             ASSERT( d.addTagRange( TagRange( BSON( "x" << 10 ), BSON( "x" << 20 ) , "b" ) ) );
             ASSERT( d.addTagRange( TagRange( BSON( "x" << 20 ), BSON( "x" << 30 ) , "c" ) ) );
@@ -316,13 +366,27 @@ namespace mongo {
             ASSERT( ! d.addTagRange( TagRange( BSON( "x" << 22 ), BSON( "x" << 28 ) , "c" ) ) );
             ASSERT( ! d.addTagRange( TagRange( BSON( "x" << 28 ), BSON( "x" << 33 ) , "c" ) ) );
 
-            ASSERT_EQUALS("", d.getTagForChunk(BSON(ChunkType::min(BSON("x" << -4)))));
-            ASSERT_EQUALS("", d.getTagForChunk(BSON(ChunkType::min(BSON("x" << 0)))));
-            ASSERT_EQUALS("a", d.getTagForChunk(BSON(ChunkType::min(BSON("x" << 1)))));
-            ASSERT_EQUALS("b", d.getTagForChunk(BSON(ChunkType::min(BSON("x" << 10)))));
-            ASSERT_EQUALS("b", d.getTagForChunk(BSON(ChunkType::min(BSON("x" << 15)))));
-            ASSERT_EQUALS("c", d.getTagForChunk(BSON(ChunkType::min(BSON("x" << 25)))));
-            ASSERT_EQUALS("", d.getTagForChunk(BSON(ChunkType::min(BSON("x" << 35)))));
+            ChunkType chunk;
+            chunk.setMin(BSON("x" << -4));
+            ASSERT_EQUALS("", d.getTagForChunk(chunk));
+
+            chunk.setMin(BSON("x" << 0));
+            ASSERT_EQUALS("", d.getTagForChunk(chunk));
+
+            chunk.setMin(BSON("x" << 1));
+            ASSERT_EQUALS("a", d.getTagForChunk(chunk));
+
+            chunk.setMin(BSON("x" << 10));
+            ASSERT_EQUALS("b", d.getTagForChunk(chunk));
+
+            chunk.setMin(BSON("x" << 15));
+            ASSERT_EQUALS("b", d.getTagForChunk(chunk));
+
+            chunk.setMin(BSON("x" << 25));
+            ASSERT_EQUALS("c", d.getTagForChunk(chunk));
+
+            chunk.setMin(BSON("x" << 35));
+            ASSERT_EQUALS("", d.getTagForChunk(chunk));
         }
 
         /**
@@ -332,7 +396,7 @@ namespace mongo {
          */
         TEST( BalancerPolicyTests, MaxSizeRespect ) {
 
-            ShardToChunksMap chunks;
+            OwnedShardToChunksMap chunks;
             addShard( chunks, 3 , false );
             addShard( chunks, 4 , false );
             addShard( chunks, 6 , true );
@@ -346,7 +410,7 @@ namespace mongo {
             shards["shard1"] = ShardInfo( 0, 4, false, false );
             shards["shard2"] = ShardInfo( 0, 6, false, false );
 
-            DistributionStatus d( shards, chunks );
+            DistributionStatus d(shards, chunks.map());
             MigrateInfo* m = BalancerPolicy::balance( "ns", d, 0 );
             ASSERT( m );
             ASSERT_EQUALS( "shard2" , m->from );
@@ -360,7 +424,7 @@ namespace mongo {
          */
         TEST( BalancerPolicyTests, MaxSizeNoDrain ) {
 
-            ShardToChunksMap chunks;
+            OwnedShardToChunksMap chunks;
             // Shard0 will be overloaded
             addShard( chunks, 4 , false );
             addShard( chunks, 4 , false );
@@ -375,7 +439,7 @@ namespace mongo {
             shards["shard1"] = ShardInfo( 0, 4, false, false );
             shards["shard2"] = ShardInfo( 0, 4, false, false );
 
-            DistributionStatus d( shards, chunks );
+            DistributionStatus d(shards, chunks.map());
             MigrateInfo* m = BalancerPolicy::balance( "ns", d, 0 );
             ASSERT( !m );
         }
@@ -410,7 +474,7 @@ namespace mongo {
                 int numShards = 7;
                 int numChunks = 0;
 
-                ShardToChunksMap chunks;
+                OwnedShardToChunksMap chunks;
                 ShardInfoMap shards;
 
                 map<string,int> expected;
@@ -442,7 +506,7 @@ namespace mongo {
 
                 for (int i = 0; i < numChunks; i++) {
 
-                    DistributionStatus d( shards, chunks );
+                    DistributionStatus d(shards, chunks.map());
                     MigrateInfo* m = BalancerPolicy::balance( "ns", d, i != 0 );
 
                     if (!m) {

