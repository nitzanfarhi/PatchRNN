commit e0377cdebaf3913bff693c9eea17ff6eb4d7abc8
Author: Aaron Sierra <asierra@xes-inc.com>
Date:   Wed Jan 14 17:41:31 2015 -0600

    mtd: nand: Request strength instead of bytes for soft BCH
    
    Previously, we requested that drivers pass ecc.size and ecc.bytes when
    using NAND_ECC_SOFT_BCH. However, a driver is likely to only know the ECC
    strength required for its NAND, so each driver would need to perform a
    strength-to-bytes calculation.
    
    Avoid duplicating this calculation in each driver by asking drivers to
    pass ecc.size and ecc.strength so that the strength-to-bytes calculation
    need only be implemented once.
    
    This reverts/generalizes this commit:
        mtd: nand: Base BCH ECC bytes on required strength
    
    Signed-off-by: Aaron Sierra <asierra@xes-inc.com>
    Reviewed-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 3f24b587304f..f6af96926f00 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -4037,22 +4037,24 @@ int nand_scan_tail(struct mtd_info *mtd)
 		ecc->read_oob = nand_read_oob_std;
 		ecc->write_oob = nand_write_oob_std;
 		/*
-		 * Board driver should supply ecc.size and ecc.bytes values to
-		 * select how many bits are correctable; see nand_bch_init()
-		 * for details. Otherwise, default to 4 bits for large page
-		 * devices.
+		 * Board driver should supply ecc.size and ecc.strength values
+		 * to select how many bits are correctable. Otherwise, default
+		 * to 4 bits for large page devices.
 		 */
 		if (!ecc->size && (mtd->oobsize >= 64)) {
 			ecc->size = 512;
-			ecc->bytes = DIV_ROUND_UP(13 * ecc->strength, 8);
+			ecc->strength = 4;
 		}
+
+		/* See nand_bch_init() for details. */
+		ecc->bytes = DIV_ROUND_UP(
+				ecc->strength * fls(8 * ecc->size), 8);
 		ecc->priv = nand_bch_init(mtd, ecc->size, ecc->bytes,
 					       &ecc->layout);
 		if (!ecc->priv) {
 			pr_warn("BCH ECC initialization failed!\n");
 			BUG();
 		}
-		ecc->strength = ecc->bytes * 8 / fls(8 * ecc->size);
 		break;
 
 	case NAND_ECC_NONE:
diff --git a/drivers/mtd/nand/nandsim.c b/drivers/mtd/nand/nandsim.c
index a8fa8dad9b23..f2324271b94e 100644
--- a/drivers/mtd/nand/nandsim.c
+++ b/drivers/mtd/nand/nandsim.c
@@ -2337,6 +2337,7 @@ static int __init ns_init_module(void)
 		}
 		chip->ecc.mode = NAND_ECC_SOFT_BCH;
 		chip->ecc.size = 512;
+		chip->ecc.strength = bch;
 		chip->ecc.bytes = eccbytes;
 		NS_INFO("using %u-bit/%u bytes BCH ECC\n", bch, chip->ecc.size);
 	}
diff --git a/drivers/mtd/nand/sunxi_nand.c b/drivers/mtd/nand/sunxi_nand.c
index ccaa8e283388..6f93b2990d25 100644
--- a/drivers/mtd/nand/sunxi_nand.c
+++ b/drivers/mtd/nand/sunxi_nand.c
@@ -1110,8 +1110,6 @@ static int sunxi_nand_ecc_init(struct mtd_info *mtd, struct nand_ecc_ctrl *ecc,
 
 	switch (ecc->mode) {
 	case NAND_ECC_SOFT_BCH:
-		ecc->bytes = DIV_ROUND_UP(ecc->strength * fls(8 * ecc->size),
-					  8);
 		break;
 	case NAND_ECC_HW:
 		ret = sunxi_nand_hw_ecc_ctrl_init(mtd, ecc, np);

