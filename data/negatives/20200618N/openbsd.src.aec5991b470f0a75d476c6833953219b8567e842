commit aec5991b470f0a75d476c6833953219b8567e842
Author: bluhm <bluhm@openbsd.org>
Date:   Tue Oct 10 11:59:35 2017 +0000

    At reboot all vnodes are flushed, but when it sleeps, the update
    process has a chance to create new dirty vnodes.  Resolving soft
    dependencies adds vnodes to the dirty list.
    In softdep_flushfiles() vnodes and softdeps are flushed in a loop.
    But if they sleep, it is not guaranteed that all vnodes have been
    flushed when the softdep worklist flush reports that nothing has
    to be done.
    The solution is to do a final vnode flush after the softdep worklist
    has been flushed.  Then the dirty list is empty and the final check
    in dounmount_leaf() does not panic with "unmount: dangling vnode".
    OK mikeb@

diff --git a/sys/ufs/ffs/ffs_softdep.c b/sys/ufs/ffs/ffs_softdep.c
index 0c9e10c1052..5da4c6217a2 100644
--- a/sys/ufs/ffs/ffs_softdep.c
+++ b/sys/ufs/ffs/ffs_softdep.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: ffs_softdep.c,v 1.135 2016/11/07 00:26:33 guenther Exp $	*/
+/*	$OpenBSD: ffs_softdep.c,v 1.136 2017/10/10 11:59:35 bluhm Exp $	*/
 
 /*
  * Copyright 1998, 2000 Marshall Kirk McKusick. All Rights Reserved.
@@ -903,6 +903,14 @@ softdep_flushfiles(struct mount *oldmnt, int flags, struct proc *p)
 		    count == 0)
 			break;
 	}
+	/*
+	 * If the reboot process sleeps during the loop, the update
+	 * process may call softdep_process_worklist() and create
+	 * new dirty vnodes at the mount point.  Call ffs_flushfiles()
+	 * again after the loop has flushed all soft dependencies.
+	 */
+	if (error == 0)
+		error = ffs_flushfiles(oldmnt, flags, p);
 	/*
 	 * If we are unmounting then it is an error to fail. If we
 	 * are simply trying to downgrade to read-only, then filesystem

