commit 062deb4b69174076566b7538bc4532cb6a74b7b7
Author: pancake <pancake@nopcode.org>
Date:   Wed Aug 29 14:46:19 2012 +0200

    Fix build. enhace mips anal, add recursive disasm
    
    Fix UCALL opcode analysis in mips
    Initial implementation of 'pdr' recursive disassembler
    Workaround for code wrong basic block size in pdr

diff --git a/libr/anal/bb.c b/libr/anal/bb.c
index dd5e58f30..72743f3b5 100644
--- a/libr/anal/bb.c
+++ b/libr/anal/bb.c
@@ -1,5 +1,4 @@
-/* radare - LGPL - Copyright 2010-2011 */
-/* - nibble<.ds@gmail.com> + pancake<nopcode.org> */
+/* radare - LGPL - Copyright 2010-2012 - pancake, nibble */
 
 #include <r_anal.h>
 #include <r_util.h>
diff --git a/libr/anal/p/anal_mips.c b/libr/anal/p/anal_mips.c
index 6278d5b20..62a671f5b 100644
--- a/libr/anal/p/anal_mips.c
+++ b/libr/anal/p/anal_mips.c
@@ -1,4 +1,4 @@
-/* radare - LGPL - Copyright 2010 - pancake<nopcode.org> */
+/* radare - LGPL - Copyright 2010-2012 - pancake */
 
 #include <string.h>
 #include <r_types.h>
@@ -47,7 +47,7 @@ static int mips_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *bytes, int le
 		// calculate jump
 		break;
 	case 3: // jalr
-	//case 9: // jalr
+	case 9: // jalr
 		reg = opcode>>24;
 		if (reg<10) {
 			op->type = R_ANAL_OP_TYPE_UCALL;
diff --git a/libr/anal/var.c b/libr/anal/var.c
index 776a6727a..a7b78b425 100644
--- a/libr/anal/var.c
+++ b/libr/anal/var.c
@@ -165,11 +165,11 @@ R_API void r_anal_var_list_show(RAnal *anal, RAnalFunction *fcn, ut64 addr) {
 			if (v->type->type == R_ANAL_TYPE_ARRAY)
 				eprintf ("%s %s %s[%d] = ",
 					r_anal_var_scope_to_str (anal, v->scope),
-					r_anal_type_to_str (anal->types, v->type),
+					r_anal_type_to_str (anal, v->type, ""),
 					v->name, (int)v->type->custom.a->count);
 			else
 				eprintf ("%s %s %s = ", r_anal_var_scope_to_str (anal, v->scope),
-					r_anal_type_to_str(anal->types, v->type), v->name);
+					r_anal_type_to_str (anal, v->type, ""), v->name, "");
 			// TODO: implement r_var_dbg_read using r_vm or r_num maybe?? sounds dupped
 			// XXX: not fully implemented
 			eprintf ("0x%"PFMT64x, 0LL);
@@ -194,11 +194,11 @@ R_API void r_anal_var_list(RAnal *anal, RAnalFunction *fcn, ut64 addr, int delta
 			if (v->type->type == R_ANAL_TYPE_ARRAY)
 				eprintf ("0x%08"PFMT64x" - 0x%08"PFMT64x" type=%s type=%s name=%s delta=%d array=%d\n",
 					v->addr, v->eaddr, r_anal_var_scope_to_str(anal, v->scope),
-					r_anal_type_to_str(anal->types, v->type), v->name, v->delta, (int)v->type->custom.a->count);
+					r_anal_type_to_str(anal, v->type, ""), v->name, v->delta, (int)v->type->custom.a->count);
 			else
 				eprintf ("0x%08"PFMT64x" - 0x%08"PFMT64x" type=%s type=%s name=%s delta=%d\n",
 					v->addr, v->eaddr, r_anal_var_scope_to_str(anal, v->scope),
-					r_anal_type_to_str(anal->types, v->type), v->name, v->delta);
+					r_anal_type_to_str(anal, v->type, ""), v->name, v->delta);
 
 			r_list_foreach (v->accesses, iter2, x) {
 				eprintf ("  0x%08"PFMT64x" %s\n", x->addr, x->set?"set":"get");
diff --git a/libr/bin/p/bin_elf.c b/libr/bin/p/bin_elf.c
index 2a9f2d327..4f64d8d32 100644
--- a/libr/bin/p/bin_elf.c
+++ b/libr/bin/p/bin_elf.c
@@ -70,6 +70,7 @@ static RList* sections(RBinArch *arch) {
 	if (!(section = Elf_(r_bin_elf_get_sections) (arch->bin_obj)))
 		return ret;
 	for (i = 0; !section[i].last; i++) {
+		if (!section[i].size) continue;
 		if (!(ptr = R_NEW (RBinSection)))
 			break;
 		strncpy (ptr->name, (char*)section[i].name, R_BIN_SIZEOF_STRINGS);
diff --git a/libr/core/anal.c b/libr/core/anal.c
index 9995ccfd6..241af28b8 100644
--- a/libr/core/anal.c
+++ b/libr/core/anal.c
@@ -1,6 +1,4 @@
-/* radare - LGPL - Copyright 2009-2012 */
-/* pancake<nopcode.org> */
-/* nibble<.ds@gmail.com> */
+/* radare - LGPL - Copyright 2009-2012 - pancake, nibble */
 
 #include <r_types.h>
 #include <r_list.h>
@@ -439,7 +437,7 @@ R_API int r_core_anal_fcn_list(RCore *core, const char *input, int rad) {
 					r_cons_printf ("\n  vars:");
 					r_list_foreach (fcni->vars, iter2, vari)
 						r_cons_printf ("\n  %-10s delta=0x%02x type=%s", vari->name,
-							vari->delta, r_anal_type_to_str (core->anal, vari->type));
+							vari->delta, r_anal_type_to_str (core->anal, vari->type, ";"));
 					r_cons_printf ("\n  diff: type=%s",
 							fcni->diff->type==R_ANAL_DIFF_TYPE_MATCH?"match":
 							fcni->diff->type==R_ANAL_DIFF_TYPE_UNMATCH?"unmatch":"new");
diff --git a/libr/core/cmd_print.c b/libr/core/cmd_print.c
index a630f57ca..4b627be4e 100644
--- a/libr/core/cmd_print.c
+++ b/libr/core/cmd_print.c
@@ -251,6 +251,28 @@ static int cmd_print(void *data, const char *input) {
 				return R_TRUE;
 			}
 			break;
+		case 'r':
+			eprintf ("TODO: recursive disassembler based on code analysis\n");
+			{
+			RAnalFunction *f = r_anal_fcn_find (core->anal, core->offset,
+					R_ANAL_FCN_TYPE_FCN|R_ANAL_FCN_TYPE_SYM);
+			if (f) {
+				RListIter *iter;
+				RAnalBlock *b;
+				// XXX: hack must be reviewed/fixed in code analysis
+				if (r_list_length (f->bbs) == 1) {
+					b = r_list_get_top (f->bbs);
+					if (b->size > f->size) b->size = f->size;
+				}
+				// TODO: sort by addr
+				r_list_foreach (f->bbs, iter, b) {
+					r_core_cmdf (core, "pD %"PFMT64d" @0x%"PFMT64x, b->size, b->addr);
+					//eprintf ( "pD %"PFMT64d" @0x%"PFMT64x"\n", b->size, b->addr);
+				}
+			} else eprintf ("Cannot find function at 0x%08"PFMT64x"\n", core->offset);
+			return R_TRUE;
+			}
+			break;
 		case 'b': {
 			RAnalBlock *b = r_anal_bb_from_offset (core->anal, core->offset);
 			if (b) {
@@ -292,13 +314,14 @@ static int cmd_print(void *data, const char *input) {
 			}
 			break;
 		case '?':
-			eprintf ("Usage: pd[f|i|l] [len] @ [addr]\n");
+			eprintf ("Usage: pd[f|i|l] [len] @ [addr]\n"
 			//TODO: eprintf ("  pdr  : disassemble resume\n");
-			eprintf ("  pda  : disassemble all possible opcodes (byte per byte)\n");
-			eprintf ("  pdb  : disassemble basic block\n");
-			eprintf ("  pdf  : disassemble function\n");
-			eprintf ("  pdi  : like 'pi', with offset and bytes\n");
-			eprintf ("  pdl  : show instruction sizes\n");
+			"  pda  : disassemble all possible opcodes (byte per byte)\n"
+			"  pdb  : disassemble basic block\n"
+			"  pdr  : recursive disassemble across the function graph\n"
+			"  pdf  : disassemble function\n"
+			"  pdi  : like 'pi', with offset and bytes\n"
+			"  pdl  : show instruction sizes\n");
 			return 0;
 			break;
 		}
diff --git a/libr/core/vmenus.c b/libr/core/vmenus.c
index 733ffb94f..9e2187f26 100644
--- a/libr/core/vmenus.c
+++ b/libr/core/vmenus.c
@@ -881,11 +881,12 @@ static void var_index_show(RAnal *anal, RAnalFunction *fcn, ut64 addr, int idx)
 				if (v->type->type == R_ANAL_TYPE_ARRAY)
 					r_cons_printf ("0x%08llx - 0x%08llx scope=%s type=%s name=%s delta=%d array=%d\n",
 						v->addr, v->eaddr, r_anal_var_scope_to_str (anal, v->scope),
-						r_anal_type_to_str(anal, v->type), v->name, v->delta, v->type->custom.a->count);
+						r_anal_type_to_str (anal, v->type, ""),
+						v->name, v->delta, v->type->custom.a->count);
 				else
 					r_cons_printf ("0x%08llx - 0x%08llx scope=%s type=%s name=%s delta=%d\n",
 						v->addr, v->eaddr, r_anal_var_scope_to_str (anal, v->scope),
-						r_anal_type_to_str(anal, v->type), v->name, v->delta);
+						r_anal_type_to_str (anal, v->type, ""), v->name, v->delta);
 				r_list_foreach (v->accesses, iter2, x) {
 					r_cons_printf ("  0x%08llx %s\n", x->addr, x->set?"set":"get");
 				}

