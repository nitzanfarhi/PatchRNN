commit d21ee9f00fe5825965029c75d6686b45367e6f19
Author: √Ålvaro Felipe Melchor <alvaro.felipe91@gmail.com>
Date:   Sun Jul 3 19:32:06 2016 +0200

    fix crash due to UAF with io.vio option

diff --git a/libr/io/section.c b/libr/io/section.c
index acd6adae8..2f4a6581e 100644
--- a/libr/io/section.c
+++ b/libr/io/section.c
@@ -69,7 +69,7 @@ R_API RIOSection *r_io_section_add(RIO *io, ut64 offset, ut64 vaddr, ut64 size,
 		return s;
 	}
 	s = r_io_section_get_name (io, name);
-	if (s == NULL) {
+	if (!s) {
 		s = R_NEW0 (RIOSection);
 		s->id = io->next_section_id++;
 	} else {
@@ -470,15 +470,17 @@ R_API RList *r_io_section_get_in_vaddr_range(RIO *io, ut64 addr, ut64 endaddr) {
 	RListIter *iter;
 	RList *sections = r_list_new ();
 	if (!sections) return NULL;
-	sections->free = r_io_section_free;
+	//Here section->free is not needed and wrong since we are appending into
+	//the list sections from io->sections that are widely used so just free the
+	//list but not the elements to avoid UAF. r_io_free will free sections for us
 	ut64 sec_from, sec_to;
 	r_list_foreach (io->sections, iter, s) {
 		if (!(s->rwx & R_IO_MAP)) continue;
 		sec_from = s->vaddr;
 		sec_to = sec_from + s->vsize;
-		if (sec_from <= addr && addr < sec_to) r_list_append(sections, s);
-		if (sec_from < endaddr && endaddr < sec_to) r_list_append(sections, s);
-		if (addr <= sec_from && sec_to <= endaddr) r_list_append(sections, s);
+		if (sec_from <= addr && addr < sec_to) r_list_append (sections, s);
+		if (sec_from < endaddr && endaddr < sec_to) r_list_append (sections, s);
+		if (addr <= sec_from && sec_to <= endaddr) r_list_append (sections, s);
 	}
 	return sections;
 }
diff --git a/libr/io/vio.c b/libr/io/vio.c
index 7fbb3c1b5..8e07f9cb4 100644
--- a/libr/io/vio.c
+++ b/libr/io/vio.c
@@ -68,9 +68,7 @@ R_API int r_io_vread (RIO *io, ut64 vaddr, ut8 *buf, int len) {
 			return false;
 		}
 		r_list_foreach (sections, iter, section) {
-			if (section->vaddr==0) {
-				continue;
-			}
+			if (!section->vaddr) continue; 
 			if (section->vaddr > tmp_vaddr) {
 				range = r_io_range_new ();			//create a new range
 				if (!range) {
@@ -80,16 +78,16 @@ R_API int r_io_vread (RIO *io, ut64 vaddr, ut8 *buf, int len) {
 				}
 				range->from = tmp_vaddr;			//record unsectioned area
 				range->to = section->vaddr;
-				r_list_append (ranges, range);			//store the range
+				r_list_append (ranges, range);		//store the range
 				tmp_vaddr = section->vaddr;			//prepare for resolving the maddr
 				tmp_len -= (tmp_vaddr - vaddr);
-				tmp_buf += (tmp_vaddr - vaddr);			//adjust buffer
+				tmp_buf += (tmp_vaddr - vaddr);		//adjust buffer
 			}
-			vendaddr = tmp_vaddr + tmp_len;				//calculate the virtual end address
-			if (vendaddr > (section->vaddr + section->vsize))	//check if the virual end address is in the section too
-				vendaddr = section->vaddr + section->vsize;	//if not, size it down
+			vendaddr = tmp_vaddr + tmp_len;				            //calculate the virtual end address
+			if (vendaddr > (section->vaddr + section->vsize))	    //check if the virtual end address is in the section too
+				vendaddr = section->vaddr + section->vsize;	        //if not, size it down
 			maddr = tmp_vaddr - section->vaddr + section->offset;	//calculate the map address (address inside the map)
-			if (maddr > ( section->offset + section->size)) {	//check if the maddr is inside the physical section, if not, skip some things
+			if (maddr > (section->offset + section->size)) {	    //check if the maddr is inside the physical section, if not, skip some things
 			} else {
 				if ((vendaddr - section->vaddr + section->offset) > (section->offset + section->size)) {	//check if the virtual part of the section fits into the physical part
 					r_io_mread (io, section->fd, maddr, tmp_buf, (section->offset + section->size) - maddr);//if not, read as far as possible
@@ -97,8 +95,8 @@ R_API int r_io_vread (RIO *io, ut64 vaddr, ut8 *buf, int len) {
 					r_io_mread (io, section->fd, maddr, tmp_buf, vendaddr - tmp_vaddr);	//read from the sections fd
 				}
 			}
-			tmp_buf += (vendaddr - tmp_vaddr);			//adjust buffer
-			tmp_len -= (vendaddr - tmp_vaddr);			//adjust length
+			tmp_buf += (vendaddr - tmp_vaddr);		//adjust buffer
+			tmp_len -= (vendaddr - tmp_vaddr);		//adjust length
 			tmp_vaddr = vendaddr;					//adjust address
 		}
 	}
@@ -108,7 +106,7 @@ R_API int r_io_vread (RIO *io, ut64 vaddr, ut8 *buf, int len) {
 			maps = r_io_map_get_maps_in_range (io, range->from, range->to - range->from);	//get all maps in the range
 			tmp_vaddr = range->from;
 			tmp_len = range->to - range->from;			//adjust length
-			tmp_buf = buf + (tmp_vaddr - vaddr);			//adjust pointer
+			tmp_buf = buf + (tmp_vaddr - vaddr);		//adjust pointer
 			r_list_foreach (maps, ator, map) {			//start filling the gaps
 				r_io_mread (io, map->fd, tmp_vaddr, tmp_buf, tmp_len);	//read from maps, the ranges will adjusted in mread
 			}
@@ -121,8 +119,8 @@ R_API int r_io_vread (RIO *io, ut64 vaddr, ut8 *buf, int len) {
 		r_list_foreach (maps, iter, map) {
 			r_io_mread (io, map->fd, vaddr, buf, len);		//read from the maps, the ranges will be adjusted in mread
 		}
-		r_list_free (maps);						//free the list
-		r_io_mread (io, io->desc->fd, vaddr, buf, len);			//ensure that io->desc is always on the top
+		r_list_free (maps);						            //free the list
+		r_io_mread (io, io->desc->fd, vaddr, buf, len);		//ensure that io->desc is always on the top
 	}
 	return true;
 }

