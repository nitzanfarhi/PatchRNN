commit cac651c83417dde3b64a6620cac32f078c9c399f
Author: Anton Khirnov <anton@khirnov.net>
Date:   Mon Aug 29 07:11:57 2011 +0200

    cmdutils: move grow_array() from avconv to cmdutils.

diff --git a/avconv.c b/avconv.c
index 52a71085f..33da836a9 100644
--- a/avconv.c
+++ b/avconv.c
@@ -511,26 +511,6 @@ static void assert_codec_experimental(AVCodecContext *c, int encoder)
     }
 }
 
-/* similar to ff_dynarray_add() and av_fast_realloc() */
-static void *grow_array(void *array, int elem_size, int *size, int new_size)
-{
-    if (new_size >= INT_MAX / elem_size) {
-        fprintf(stderr, "Array too big.\n");
-        exit_program(1);
-    }
-    if (*size < new_size) {
-        uint8_t *tmp = av_realloc(array, new_size*elem_size);
-        if (!tmp) {
-            fprintf(stderr, "Could not alloc buffer.\n");
-            exit_program(1);
-        }
-        memset(tmp + *size*elem_size, 0, (new_size-*size) * elem_size);
-        *size = new_size;
-        return tmp;
-    }
-    return array;
-}
-
 static void choose_sample_fmt(AVStream *st, AVCodec *codec)
 {
     if(codec && codec->sample_fmts){
diff --git a/cmdutils.c b/cmdutils.c
index a86c55bc6..9e34e4312 100644
--- a/cmdutils.c
+++ b/cmdutils.c
@@ -931,4 +931,23 @@ int get_filtered_video_frame(AVFilterContext *ctx, AVFrame *frame,
     return 1;
 }
 
+void *grow_array(void *array, int elem_size, int *size, int new_size)
+{
+    if (new_size >= INT_MAX / elem_size) {
+        av_log(NULL, AV_LOG_ERROR, "Array too big.\n");
+        exit_program(1);
+    }
+    if (*size < new_size) {
+        uint8_t *tmp = av_realloc(array, new_size*elem_size);
+        if (!tmp) {
+            av_log(NULL, AV_LOG_ERROR, "Could not alloc buffer.\n");
+            exit_program(1);
+        }
+        memset(tmp + *size*elem_size, 0, (new_size-*size) * elem_size);
+        *size = new_size;
+        return tmp;
+    }
+    return array;
+}
+
 #endif /* CONFIG_AVFILTER */
diff --git a/cmdutils.h b/cmdutils.h
index 65b1ae48b..2173f0d34 100644
--- a/cmdutils.h
+++ b/cmdutils.h
@@ -333,4 +333,14 @@ int get_filtered_video_frame(AVFilterContext *sink, AVFrame *frame,
  */
 void exit_program(int ret);
 
+/**
+ * Realloc array to hold new_size elements of elem_size.
+ * Calls exit_program() on failure.
+ *
+ * @param elem_size size in bytes of each element
+ * @param size new element count will be written here
+ * @return reallocated array
+ */
+void *grow_array(void *array, int elem_size, int *size, int new_size);
+
 #endif /* LIBAV_CMDUTILS_H */
diff --git a/ffmpeg.c b/ffmpeg.c
index eec028f8e..242cd3ffa 100644
--- a/ffmpeg.c
+++ b/ffmpeg.c
@@ -529,26 +529,6 @@ static void assert_codec_experimental(AVCodecContext *c, int encoder)
     }
 }
 
-/* similar to ff_dynarray_add() and av_fast_realloc() */
-static void *grow_array(void *array, int elem_size, int *size, int new_size)
-{
-    if (new_size >= INT_MAX / elem_size) {
-        fprintf(stderr, "Array too big.\n");
-        exit_program(1);
-    }
-    if (*size < new_size) {
-        uint8_t *tmp = av_realloc(array, new_size*elem_size);
-        if (!tmp) {
-            fprintf(stderr, "Could not alloc buffer.\n");
-            exit_program(1);
-        }
-        memset(tmp + *size*elem_size, 0, (new_size-*size) * elem_size);
-        *size = new_size;
-        return tmp;
-    }
-    return array;
-}
-
 static void choose_sample_fmt(AVStream *st, AVCodec *codec)
 {
     if(codec && codec->sample_fmts){

