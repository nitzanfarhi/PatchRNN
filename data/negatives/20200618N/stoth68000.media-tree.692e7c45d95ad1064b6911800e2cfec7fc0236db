commit 692e7c45d95ad1064b6911800e2cfec7fc0236db
Author: Johannes Weiner <hannes@cmpxchg.org>
Date:   Wed Aug 6 16:05:57 2014 -0700

    mm: memcontrol: catch root bypass in move precharge
    
    When mem_cgroup_try_charge() returns -EINTR, it bypassed the charge to
    the root memcg.  But move precharging does not catch this and treats
    this case as if no charge had happened, thus leaking a charge against
    root.  Because of an old optimization, the root memcg's res_counter is
    not actually charged right now, but it's still an imbalance and
    subsequent patches will charge the root memcg again.
    
    Catch those bypasses to the root memcg and properly cancel them before
    giving up the move.
    
    Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
    Acked-by: Michal Hocko <mhocko@suse.cz>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Vladimir Davydov <vdavydov@parallels.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/mm/memcontrol.c b/mm/memcontrol.c
index 8a4159efa3c0..e0ac636315f8 100644
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@ -6401,6 +6401,10 @@ static int mem_cgroup_do_precharge(unsigned long count)
 		mc.precharge += count;
 		return ret;
 	}
+	if (ret == -EINTR) {
+		__mem_cgroup_cancel_charge(root_mem_cgroup, count);
+		return ret;
+	}
 
 	/* Try charges one by one with reclaim */
 	while (count--) {
@@ -6409,8 +6413,11 @@ static int mem_cgroup_do_precharge(unsigned long count)
 		/*
 		 * In case of failure, any residual charges against
 		 * mc.to will be dropped by mem_cgroup_clear_mc()
-		 * later on.
+		 * later on.  However, cancel any charges that are
+		 * bypassed to root right away or they'll be lost.
 		 */
+		if (ret == -EINTR)
+			__mem_cgroup_cancel_charge(root_mem_cgroup, 1);
 		if (ret)
 			return ret;
 		mc.precharge++;

