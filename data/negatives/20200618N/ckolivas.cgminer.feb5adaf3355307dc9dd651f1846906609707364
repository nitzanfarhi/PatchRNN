commit feb5adaf3355307dc9dd651f1846906609707364
Author: Con Kolivas <kernel@kolivas.org>
Date:   Tue Nov 4 16:04:08 2014 +1100

    Selectively yield on dropping a lock only on single CPU platforms

diff --git a/cgminer.c b/cgminer.c
index fed80aac..4207fd00 100644
--- a/cgminer.c
+++ b/cgminer.c
@@ -9350,6 +9350,14 @@ int main(int argc, char *argv[])
 	if (unlikely(curl_global_init(CURL_GLOBAL_ALL)))
 		early_quit(1, "Failed to curl_global_init");
 
+# ifdef __linux
+	/* If we're on a small lowspec platform with only one CPU, we should
+	 * yield after dropping a lock to allow a thread waiting for it to be
+	 * able to get CPU time to grab the lock. */
+	if (sysconf(_SC_NPROCESSORS_ONLN) == 1)
+		selective_yield = &sched_yield;
+#endif
+
 #if LOCK_TRACKING
 	// Must be first
 	if (unlikely(pthread_mutex_init(&lockstat_lock, NULL)))
diff --git a/miner.h b/miner.h
index 58c6f5d9..c3c78fee 100644
--- a/miner.h
+++ b/miner.h
@@ -782,7 +782,7 @@ static inline void _mutex_unlock_noyield(pthread_mutex_t *lock, const char *file
 static inline void _mutex_unlock(pthread_mutex_t *lock, const char *file, const char *func, const int line)
 {
 	_mutex_unlock_noyield(lock, file, func, line);
-	sched_yield();
+	selective_yield();
 }
 
 static inline int _mutex_trylock(pthread_mutex_t *lock, __maybe_unused const char *file, __maybe_unused const char *func, __maybe_unused const int line)
@@ -837,13 +837,13 @@ static inline void _wr_unlock_noyield(pthread_rwlock_t *lock, const char *file,
 static inline void _rd_unlock(pthread_rwlock_t *lock, const char *file, const char *func, const int line)
 {
 	_rw_unlock(lock, file, func, line);
-	sched_yield();
+	selective_yield();
 }
 
 static inline void _wr_unlock(pthread_rwlock_t *lock, const char *file, const char *func, const int line)
 {
 	_rw_unlock(lock, file, func, line);
-	sched_yield();
+	selective_yield();
 }
 
 static inline void _mutex_init(pthread_mutex_t *lock, const char *file, const char *func, const int line)
diff --git a/util.c b/util.c
index f6554559..ec99a469 100644
--- a/util.c
+++ b/util.c
@@ -37,6 +37,7 @@
 # include <ws2tcpip.h>
 # include <mmsystem.h>
 #endif
+#include <sched.h>
 
 #include "miner.h"
 #include "elist.h"
@@ -47,6 +48,13 @@
 
 bool successful_connect = false;
 
+int no_yield(void)
+{
+	return 0;
+}
+
+int (*selective_yield)(void) = &no_yield;
+
 static void keep_sockalive(SOCKETTYPE fd)
 {
 	const int tcp_one = 1;
diff --git a/util.h b/util.h
index abaab6ff..ea689efc 100644
--- a/util.h
+++ b/util.h
@@ -102,6 +102,8 @@ typedef LARGE_INTEGER cgtimer_t;
 typedef struct timespec cgtimer_t;
 #endif
 
+int no_yield(void);
+int (*selective_yield)(void);
 struct thr_info;
 struct pool;
 enum dev_reason;

