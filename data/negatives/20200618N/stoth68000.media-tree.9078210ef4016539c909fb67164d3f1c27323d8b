commit 9078210ef4016539c909fb67164d3f1c27323d8b
Author: James Hogan <james.hogan@imgtec.com>
Date:   Tue Oct 25 16:08:19 2016 +0100

    KVM: MIPS: Fix lazy user ASID regenerate for SMP
    
    kvm_mips_check_asids() runs before entering the guest and performs lazy
    regeneration of host ASID for guest usermode, using last_user_gasid to
    track the last guest ASID in the VCPU that was used by guest usermode on
    any host CPU.
    
    last_user_gasid is reset after performing the lazy ASID regeneration on
    the current CPU, and by kvm_arch_vcpu_load() if the host ASID for guest
    usermode is regenerated due to staleness (to cancel outstanding lazy
    ASID regenerations). Unfortunately neither case handles SMP hosts
    correctly:
    
     - When the lazy ASID regeneration is performed it should apply to all
       CPUs (as last_user_gasid does), so reset the ASID on other CPUs to
       zero to trigger regeneration when the VCPU is next loaded on those
       CPUs.
    
     - When the ASID is found to be stale on the current CPU, we should not
       cancel lazy ASID regenerations globally, so drop the reset of
       last_user_gasid altogether here.
    
    Both cases would require a guest ASID change and two host CPU migrations
    (and in the latter case one of the CPUs to start a new ASID cycle)
    before guest usermode could potentially access stale user pages from a
    previously running ASID in the same VCPU.
    
    Fixes: 25b08c7fb0e4 ("KVM: MIPS: Invalidate TLB by regenerating ASIDs")
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: "Radim Krčmář <rkrcmar@redhat.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Cc: kvm@vger.kernel.org
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/mips/kvm/mips.c b/arch/mips/kvm/mips.c
index 622037d851a3..06a60b19acfb 100644
--- a/arch/mips/kvm/mips.c
+++ b/arch/mips/kvm/mips.c
@@ -426,7 +426,7 @@ int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,
 static void kvm_mips_check_asids(struct kvm_vcpu *vcpu)
 {
 	struct mips_coproc *cop0 = vcpu->arch.cop0;
-	int cpu = smp_processor_id();
+	int i, cpu = smp_processor_id();
 	unsigned int gasid;
 
 	/*
@@ -442,6 +442,9 @@ static void kvm_mips_check_asids(struct kvm_vcpu *vcpu)
 						vcpu);
 			vcpu->arch.guest_user_asid[cpu] =
 				vcpu->arch.guest_user_mm.context.asid[cpu];
+			for_each_possible_cpu(i)
+				if (i != cpu)
+					vcpu->arch.guest_user_asid[cpu] = 0;
 			vcpu->arch.last_user_gasid = gasid;
 		}
 	}
diff --git a/arch/mips/kvm/mmu.c b/arch/mips/kvm/mmu.c
index 03883ba806e2..3b677c851be0 100644
--- a/arch/mips/kvm/mmu.c
+++ b/arch/mips/kvm/mmu.c
@@ -260,13 +260,9 @@ void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
 
 	if ((vcpu->arch.guest_user_asid[cpu] ^ asid_cache(cpu)) &
 						asid_version_mask(cpu)) {
-		u32 gasid = kvm_read_c0_guest_entryhi(vcpu->arch.cop0) &
-				KVM_ENTRYHI_ASID;
-
 		kvm_get_new_mmu_context(&vcpu->arch.guest_user_mm, cpu, vcpu);
 		vcpu->arch.guest_user_asid[cpu] =
 		    vcpu->arch.guest_user_mm.context.asid[cpu];
-		vcpu->arch.last_user_gasid = gasid;
 		newasid++;
 
 		kvm_debug("[%d]: cpu_context: %#lx\n", cpu,

