commit ff329cb78fd63ad37008403c59502e1a3be14622
Author: aystarik <aystarik>
Date:   Wed Jun 29 16:57:02 2005 +0000

    added entersleepstate
    
    
    date    2001.01.25.19.29.00;    author agrover; state Exp;

diff --git a/source/components/hardware/hwsleep.c b/source/components/hardware/hwsleep.c
index 71cd56a55..8227a5748 100644
--- a/source/components/hardware/hwsleep.c
+++ b/source/components/hardware/hwsleep.c
@@ -2,7 +2,7 @@
 /******************************************************************************
  *
  * Name: hwsleep.c - ACPI Hardware Sleep/Wake Interface
- *              $Revision: 1.56 $
+ *              $Revision: 1.2 $
  *
  *****************************************************************************/
 
@@ -10,7 +10,7 @@
  *
  * 1. Copyright Notice
  *
- * Some or all of this work - Copyright (c) 1999 - 2003, Intel Corp.
+ * Some or all of this work - Copyright (c) 1999, 2000, 2001, Intel Corp.
  * All rights reserved.
  *
  * 2. License
@@ -116,9 +116,11 @@
  *****************************************************************************/
 
 #include "acpi.h"
+#include "acnamesp.h"
+#include "achware.h"
 
-#define _COMPONENT          ACPI_HARDWARE
-        ACPI_MODULE_NAME    ("hwsleep")
+#define _COMPONENT          HARDWARE
+        MODULE_NAME         ("hwsleep")
 
 
 /******************************************************************************
@@ -128,7 +130,7 @@
  * PARAMETERS:  PhysicalAddress     - Physical address of ACPI real mode
  *                                    entry point.
  *
- * RETURN:      Status
+ * RETURN:      AE_OK or AE_ERROR
  *
  * DESCRIPTION: Access function for dFirmwareWakingVector field in FACS
  *
@@ -139,20 +141,25 @@ AcpiSetFirmwareWakingVector (
     ACPI_PHYSICAL_ADDRESS PhysicalAddress)
 {
 
-    ACPI_FUNCTION_TRACE ("AcpiSetFirmwareWakingVector");
+    FUNCTION_TRACE ("AcpiSetFirmwareWakingVector");
+
+
+    /* Make sure that we have an FACS */
 
+    if (!AcpiGbl_FACS)
+    {
+        return_ACPI_STATUS (AE_NO_ACPI_TABLES);
+    }
 
     /* Set the vector */
 
-    if (AcpiGbl_CommonFACS.VectorWidth == 32)
+    if (AcpiGbl_FACS->VectorWidth == 32)
     {
-        *(ACPI_CAST_PTR (UINT32, AcpiGbl_CommonFACS.FirmwareWakingVector))
-                = (UINT32) PhysicalAddress;
+        * (UINT32 *) AcpiGbl_FACS->FirmwareWakingVector = (UINT32) PhysicalAddress;
     }
     else
     {
-        *AcpiGbl_CommonFACS.FirmwareWakingVector
-                = PhysicalAddress;
+        *AcpiGbl_FACS->FirmwareWakingVector = PhysicalAddress;
     }
 
     return_ACPI_STATUS (AE_OK);
@@ -169,7 +176,7 @@ AcpiSetFirmwareWakingVector (
  *
  * RETURN:      Status
  *
- * DESCRIPTION: Access function for FirmwareWakingVector field in FACS
+ * DESCRIPTION: Access function for dFirmwareWakingVector field in FACS
  *
  ******************************************************************************/
 
@@ -178,7 +185,7 @@ AcpiGetFirmwareWakingVector (
     ACPI_PHYSICAL_ADDRESS *PhysicalAddress)
 {
 
-    ACPI_FUNCTION_TRACE ("AcpiGetFirmwareWakingVector");
+    FUNCTION_TRACE ("AcpiGetFirmwareWakingVector");
 
 
     if (!PhysicalAddress)
@@ -186,86 +193,27 @@ AcpiGetFirmwareWakingVector (
         return_ACPI_STATUS (AE_BAD_PARAMETER);
     }
 
-    /* Get the vector */
+    /* Make sure that we have an FACS */
 
-    if (AcpiGbl_CommonFACS.VectorWidth == 32)
-    {
-        *PhysicalAddress = (ACPI_PHYSICAL_ADDRESS)
-            *(ACPI_CAST_PTR (UINT32, AcpiGbl_CommonFACS.FirmwareWakingVector));
-    }
-    else
+    if (!AcpiGbl_FACS)
     {
-        *PhysicalAddress =
-            *AcpiGbl_CommonFACS.FirmwareWakingVector;
+        return_ACPI_STATUS (AE_NO_ACPI_TABLES);
     }
 
-    return_ACPI_STATUS (AE_OK);
-}
-
-
-/******************************************************************************
- *
- * FUNCTION:    AcpiEnterSleepStatePrep
- *
- * PARAMETERS:  SleepState          - Which sleep state to enter
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Prepare to enter a system sleep state (see ACPI 2.0 spec p 231)
- *              This function must execute with interrupts enabled.
- *              We break sleeping into 2 stages so that OSPM can handle
- *              various OS-specific tasks between the two steps.
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiEnterSleepStatePrep (
-    UINT8               SleepState)
-{
-    ACPI_STATUS         Status;
-    ACPI_OBJECT_LIST    ArgList;
-    ACPI_OBJECT         Arg;
-
-
-    ACPI_FUNCTION_TRACE ("AcpiEnterSleepStatePrep");
-
-
-    /*
-     * _PSW methods could be run here to enable wake-on keyboard, LAN, etc.
-     */
-    Status = AcpiGetSleepTypeData (SleepState,
-                    &AcpiGbl_SleepTypeA, &AcpiGbl_SleepTypeB);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
-
-    /* Setup parameter object */
-
-    ArgList.Count = 1;
-    ArgList.Pointer = &Arg;
-
-    Arg.Type = ACPI_TYPE_INTEGER;
-    Arg.Integer.Value = SleepState;
-
-    /* Run the _PTS and _GTS methods */
+    /* Get the vector */
 
-    Status = AcpiEvaluateObject (NULL, "\\_PTS", &ArgList, NULL);
-    if (ACPI_FAILURE (Status) && Status != AE_NOT_FOUND)
+    if (AcpiGbl_FACS->VectorWidth == 32)
     {
-        return_ACPI_STATUS (Status);
+        *PhysicalAddress = * (UINT32 *) AcpiGbl_FACS->FirmwareWakingVector;
     }
-
-    Status = AcpiEvaluateObject (NULL, "\\_GTS", &ArgList, NULL);
-    if (ACPI_FAILURE (Status) && Status != AE_NOT_FOUND)
+    else
     {
-        return_ACPI_STATUS (Status);
+        *PhysicalAddress = *AcpiGbl_FACS->FirmwareWakingVector;
     }
 
     return_ACPI_STATUS (AE_OK);
 }
 
-
 /******************************************************************************
  *
  * FUNCTION:    AcpiEnterSleepState
@@ -275,262 +223,77 @@ AcpiEnterSleepStatePrep (
  * RETURN:      Status
  *
  * DESCRIPTION: Enter a system sleep state (see ACPI 2.0 spec p 231)
- *              THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED
  *
  ******************************************************************************/
 
 ACPI_STATUS
 AcpiEnterSleepState (
-    UINT8                   SleepState)
+    UINT8 SleepState)
 {
-    UINT32                  PM1AControl;
-    UINT32                  PM1BControl;
-    ACPI_BIT_REGISTER_INFO  *SleepTypeRegInfo;
-    ACPI_BIT_REGISTER_INFO  *SleepEnableRegInfo;
-    UINT32                  InValue;
-    ACPI_STATUS             Status;
-
-
-    ACPI_FUNCTION_TRACE ("AcpiEnterSleepState");
-
-
-    if ((AcpiGbl_SleepTypeA > ACPI_SLEEP_TYPE_MAX) ||
-        (AcpiGbl_SleepTypeB > ACPI_SLEEP_TYPE_MAX))
-    {
-        ACPI_REPORT_ERROR (("Sleep values out of range: A=%X B=%X\n",
-            AcpiGbl_SleepTypeA, AcpiGbl_SleepTypeB));
-        return_ACPI_STATUS (AE_AML_OPERAND_VALUE);
-    }
-
-
-    SleepTypeRegInfo   = AcpiHwGetBitRegisterInfo (ACPI_BITREG_SLEEP_TYPE_A);
-    SleepEnableRegInfo = AcpiHwGetBitRegisterInfo (ACPI_BITREG_SLEEP_ENABLE);
-
-    /* Clear wake status */
-
-    Status = AcpiSetRegister (ACPI_BITREG_WAKE_STATUS, 1, ACPI_MTX_DO_NOT_LOCK);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
-
-    Status = AcpiHwClearAcpiStatus(ACPI_MTX_DO_NOT_LOCK);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
+    ACPI_STATUS Status;
+    ACPI_OBJECT_LIST ArgList;
+    ACPI_OBJECT Arg;
+    UINT8 TypeA;
+    UINT8 TypeB;
+    UINT16 PM1AControl;
+    UINT16 PM1BControl;
+
+    FUNCTION_TRACE ("AcpiEnterSleepState");
+    
+    /*
+     * _PSW methods could be run here to enable wake-on keyboard, LAN, etc.
+     */
 
-    /* Disable BM arbitration */
+    Status = AcpiHwObtainSleepTypeRegisterData(SleepState, &TypeA, &TypeB);
 
-    Status = AcpiSetRegister (ACPI_BITREG_ARB_DISABLE, 1, ACPI_MTX_DO_NOT_LOCK);
-    if (ACPI_FAILURE (Status))
+    if (!ACPI_SUCCESS(Status))
     {
-        return_ACPI_STATUS (Status);
+        return Status;
     }
 
-    Status = AcpiHwDisableNonWakeupGpes();
-    if (ACPI_FAILURE (Status))
+    if (SleepState != ACPI_STATE_S5)
     {
-        return_ACPI_STATUS (Status);
+        /* run the _PTS method */
+        MEMSET(&ArgList, 0, sizeof(ArgList));
+        ArgList.Count = 1;
+        ArgList.Pointer = &Arg;
+
+        MEMSET(&Arg, 0, sizeof(Arg));
+        Arg.Type = ACPI_TYPE_INTEGER;
+        Arg.Integer.Value = SleepState;
+
+        /* acpi 2.0 requires _GTS as well as _PTS */
+        AcpiEvaluateObject(NULL, "\\_PTS", &ArgList, NULL);
+        AcpiEvaluateObject(NULL, "\\_GTS", &ArgList, NULL);
     }
 
-    /* Get current value of PM1A control */
+    /* clear wake status by writing a 1 */
+    AcpiHwRegisterBitAccess(ACPI_WRITE, ACPI_MTX_LOCK, WAK_STS, 1);
 
-    Status = AcpiHwRegisterRead (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_CONTROL, &PM1AControl);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
-    ACPI_DEBUG_PRINT ((ACPI_DB_INIT, "Entering sleep state [S%d]\n", SleepState));
+    PM1AControl = (UINT16) AcpiHwRegisterRead(ACPI_MTX_LOCK, PM1_CONTROL);
 
-    /* Clear SLP_EN and SLP_TYP fields */
-
-    PM1AControl &= ~(SleepTypeRegInfo->AccessBitMask | SleepEnableRegInfo->AccessBitMask);
+    /* mask off SLP_EN and SLP_TYP fields */
+    PM1AControl &= 0xC3FF;
+    
+    /* mask in SLP_EN */
+    PM1AControl |= (1 << AcpiHwGetBitShift (SLP_EN_MASK));
+    
     PM1BControl = PM1AControl;
 
-    /* Insert SLP_TYP bits */
-
-    PM1AControl |= (AcpiGbl_SleepTypeA << SleepTypeRegInfo->BitPosition);
-    PM1BControl |= (AcpiGbl_SleepTypeB << SleepTypeRegInfo->BitPosition);
+    /* mask in SLP_TYP */
+    PM1AControl |= (TypeA << AcpiHwGetBitShift (SLP_TYPE_X_MASK));
+    PM1BControl |= (TypeB << AcpiHwGetBitShift (SLP_TYPE_X_MASK));
 
-    /* Write #1: fill in SLP_TYP data */
+    DEBUG_PRINT(ACPI_OK, ("Entering S%d\n", SleepState));
 
-    Status = AcpiHwRegisterWrite (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1A_CONTROL, PM1AControl);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
-
-    Status = AcpiHwRegisterWrite (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1B_CONTROL, PM1BControl);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
+    /* the old version was disabling interrupts. let's try it without
+    /* and see how that works */
+    /*disable();*/
 
-    /* Insert SLP_ENABLE bit */
+    AcpiHwRegisterWrite(ACPI_MTX_LOCK, PM1A_CONTROL, PM1AControl);
+    AcpiHwRegisterWrite(ACPI_MTX_LOCK, PM1B_CONTROL, PM1BControl);
 
-    PM1AControl |= SleepEnableRegInfo->AccessBitMask;
-    PM1BControl |= SleepEnableRegInfo->AccessBitMask;
-
-    /* Write #2: SLP_TYP + SLP_EN */
-
-    ACPI_FLUSH_CPU_CACHE ();
-
-    Status = AcpiHwRegisterWrite (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1A_CONTROL, PM1AControl);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
-
-    Status = AcpiHwRegisterWrite (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1B_CONTROL, PM1BControl);
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
-
-    /*
-     * Wait a second, then try again. This is to get S4/5 to work on all machines.
-     */
-    if (SleepState > ACPI_STATE_S3)
-    {
-        /*
-         * We wait so long to allow chipsets that poll this reg very slowly to
-         * still read the right value. Ideally, this entire block would go
-         * away entirely.
-         */
-        AcpiOsStall (10000000);
-
-        Status = AcpiHwRegisterWrite (ACPI_MTX_DO_NOT_LOCK, ACPI_REGISTER_PM1_CONTROL,
-                    SleepEnableRegInfo->AccessBitMask);
-        if (ACPI_FAILURE (Status))
-        {
-            return_ACPI_STATUS (Status);
-        }
-    }
-
-    /* Wait until we enter sleep state */
-
-    do
-    {
-        Status = AcpiGetRegister (ACPI_BITREG_WAKE_STATUS, &InValue, ACPI_MTX_DO_NOT_LOCK);
-        if (ACPI_FAILURE (Status))
-        {
-            return_ACPI_STATUS (Status);
-        }
-
-        /* Spin until we wake */
-
-    } while (!InValue);
-
-    return_ACPI_STATUS (AE_OK);
-}
-
-
-/******************************************************************************
- *
- * FUNCTION:    AcpiEnterSleepStateS4bios
- *
- * PARAMETERS:  None
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Perform a S4 bios request.
- *              THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiEnterSleepStateS4bios (
-    void)
-{
-    UINT32                  InValue;
-    ACPI_STATUS             Status;
-
-
-    ACPI_FUNCTION_TRACE ("AcpiEnterSleepStateS4bios");
-
-    AcpiSetRegister (ACPI_BITREG_WAKE_STATUS, 1, ACPI_MTX_DO_NOT_LOCK);
-    AcpiHwClearAcpiStatus(ACPI_MTX_DO_NOT_LOCK);
-
-    AcpiHwDisableNonWakeupGpes();
-
-    ACPI_FLUSH_CPU_CACHE();
-
-    Status = AcpiOsWritePort (AcpiGbl_FADT->SmiCmd, (UINT32) AcpiGbl_FADT->S4BiosReq, 8);
-
-    do {
-        AcpiOsStall(1000);
-        Status = AcpiGetRegister (ACPI_BITREG_WAKE_STATUS, &InValue, ACPI_MTX_DO_NOT_LOCK);
-        if (ACPI_FAILURE (Status))
-        {
-            return_ACPI_STATUS (Status);
-        }
-    } while (!InValue);
+    /*enable();*/
 
     return_ACPI_STATUS (AE_OK);
-}
-
-
-/******************************************************************************
- *
- * FUNCTION:    AcpiLeaveSleepState
- *
- * PARAMETERS:  SleepState          - Which sleep state we just exited
- *
- * RETURN:      Status
- *
- * DESCRIPTION: Perform OS-independent ACPI cleanup after a sleep
- *
- ******************************************************************************/
-
-ACPI_STATUS
-AcpiLeaveSleepState (
-    UINT8               SleepState)
-{
-    ACPI_OBJECT_LIST    ArgList;
-    ACPI_OBJECT         Arg;
-    ACPI_STATUS         Status;
-
-
-    ACPI_FUNCTION_TRACE ("AcpiLeaveSleepState");
-
-
-    /* Ensure EnterSleepStatePrep -> EnterSleepState ordering */
-
-    AcpiGbl_SleepTypeA = ACPI_SLEEP_TYPE_INVALID;
-
-    /* Setup parameter object */
-
-    ArgList.Count = 1;
-    ArgList.Pointer = &Arg;
-
-    Arg.Type = ACPI_TYPE_INTEGER;
-    Arg.Integer.Value = SleepState;
-
-    /* Ignore any errors from these methods */
-
-    Status = AcpiEvaluateObject (NULL, "\\_BFS", &ArgList, NULL);
-    if (ACPI_FAILURE (Status) && Status != AE_NOT_FOUND)
-    {
-        ACPI_REPORT_ERROR (("Method _BFS failed, %s\n", AcpiFormatException (Status)));
-    }
-
-    Status = AcpiEvaluateObject (NULL, "\\_WAK", &ArgList, NULL);
-    if (ACPI_FAILURE (Status) && Status != AE_NOT_FOUND)
-    {
-        ACPI_REPORT_ERROR (("Method _WAK failed, %s\n", AcpiFormatException (Status)));
-    }
-
-    /* _WAK returns stuff - do we want to look at it? */
-
-    Status = AcpiHwEnableNonWakeupGpes();
-    if (ACPI_FAILURE (Status))
-    {
-        return_ACPI_STATUS (Status);
-    }
-
-    /* Disable BM arbitration */
-    Status = AcpiSetRegister (ACPI_BITREG_ARB_DISABLE, 0, ACPI_MTX_LOCK);
-
-    return_ACPI_STATUS (Status);
-}
+}
\ No newline at end of file

