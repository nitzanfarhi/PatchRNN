commit 7e1c0624f1b3d21faaab455fb1b9906d00a1b2ee
Author: Bron Gondwana <brong@fastmail.fm>
Date:   Wed Mar 25 21:07:45 2015 +1100

    enough fixes to get it compiling and passing master cassandane tests

diff --git a/imap/http_caldav.c b/imap/http_caldav.c
index ace27fc38..9f123320f 100644
--- a/imap/http_caldav.c
+++ b/imap/http_caldav.c
@@ -723,7 +723,9 @@ struct namespace_t namespace_calendar = {
 
 /* Namespace for Freebusy Read URL */
 struct namespace_t namespace_freebusy = {
-    URL_NS_FREEBUSY, 0, "/freebusy", NULL, 1 /* auth */, ALLOW_READ,
+    URL_NS_FREEBUSY, 0, "/freebusy", NULL, 1 /* auth */, 
+    MBTYPE_CALENDAR,
+    ALLOW_READ,
     NULL, NULL, NULL, NULL,
     {
 	{ NULL,			NULL },			/* ACL		*/
@@ -1671,7 +1673,7 @@ static int list_calendars(struct transaction_t *txn, int rights)
     char mboxlist[MAX_MAILBOX_PATH+1];
     struct stat sbuf;
     time_t lastmod;
-    const char *etag, *host, *base_path = txn->req_tgt.path;
+    const char *etag, *base_path = txn->req_tgt.path;
     unsigned level = 0, i;
     struct buf *body = &txn->resp_body.payload;
     struct list_cal_rock lrock;
@@ -2142,9 +2144,9 @@ static int caldav_get(struct transaction_t *txn, struct mailbox *mailbox,
 
 	    /* Fetch the new DAV and index records */
 	    caldav_lookup_resource(caldavdb, mailbox->name,
-				  cdata->dav.resource, 0, data);
+				   cdata->dav.resource, 0, data, /*tombstones*/0);
 
-	    mailbox_find_index_record(mailbox, cdata->dav.imap_uid, record);
+	    mailbox_find_index_record(mailbox, cdata->dav.imap_uid, record, NULL);
 
 	    /* Fill in new ETag and Last-Modified */
 	    txn->resp_body.etag = message_guid_encode(&record->guid);
@@ -2158,7 +2160,7 @@ static int caldav_get(struct transaction_t *txn, struct mailbox *mailbox,
     }
 
     /* Get on a user/collection */
-    if (!(txn->req_tgt.collection || txn->req_tgt.user)) {
+    if (!(txn->req_tgt.collection || txn->req_tgt.userid)) {
 	/* GET server-info resource */
 	return server_info(txn);
     }
@@ -2199,7 +2201,7 @@ static int caldav_get(struct transaction_t *txn, struct mailbox *mailbox,
 	/* Download an entire calendar collection */ 
 	return dump_calendar(txn, rights);
     }
-    else if (txn->req_tgt.user) {
+    else if (txn->req_tgt.userid) {
 	/* GET a list of calendars under calendar-home-set */
 	return list_calendars(txn, rights);
     }
@@ -2300,14 +2302,14 @@ static int caldav_post_attach(struct transaction_t *txn, int rights)
 
     /* Find message UID for the cal resource */
     caldav_lookup_resource(caldavdb, txn->req_tgt.mboxname,
-			   txn->req_tgt.resource, 0, &cdata);
+			   txn->req_tgt.resource, 0, &cdata, 0);
     if (!cdata->dav.rowid) ret = HTTP_NOT_FOUND;
     else if (!cdata->dav.imap_uid) ret = HTTP_CONFLICT;
     if (ret) goto done;
 
     /* Fetch index record for the cal resource */
     memset(&record, 0, sizeof(struct index_record));
-    r = mailbox_find_index_record(calendar, cdata->dav.imap_uid, &record);
+    r = mailbox_find_index_record(calendar, cdata->dav.imap_uid, &record, NULL);
     if (r) {
 	txn->error.desc = error_message(r);
 	ret = HTTP_SERVER_ERROR;
@@ -2353,7 +2355,7 @@ static int caldav_post_attach(struct transaction_t *txn, int rights)
     }
 
     /* Open the WebDAV DB corresponding to the attachments collection */
-    webdavdb = webdav_open_mailbox(attachments, WEBDAV_CREATE);
+    webdavdb = webdav_open_mailbox(attachments);
 
     switch (op) {
     case ATTACH_ADD: {
@@ -2369,9 +2371,9 @@ static int caldav_post_attach(struct transaction_t *txn, int rights)
 	/* Create new ATTACH property */
 	assert(!buf_len(&txn->buf));
 	http_proto_host(txn->req_hdrs, &proto, &host);
-	buf_printf(&txn->buf, "%s://%s%s/user/%.*s/%s%s",
+	buf_printf(&txn->buf, "%s://%s%s/user/%s/%s%s",
 		   proto, host, namespace_calendar.prefix,
-		   (int) txn->req_tgt.userlen, txn->req_tgt.user,
+		   txn->req_tgt.userid,
 		   MANAGED_ATTACH, resource);
 	attach = icalattach_new_from_url(buf_cstring(&txn->buf));
 	buf_reset(&txn->buf);
@@ -2770,8 +2772,7 @@ const char *get_icalcomponent_errstr(icalcomponent *ical)
 		    if (!strcasecmp(propname, "COMMENT")) continue;
 		    if (!strcasecmp(propname, "DESCRIPTION")) continue;
 		}
-		else if (icalparameter_get_xlicerrortype(param) ==
-			 ICAL_XLICERRORTYPE_PROPERTYPARSEERROR) {
+		else {
 		    /* Ignore unknown property errors */
 		    if (!strncmp(errstr, "Parse error in property name", 28))
 			continue;
@@ -3561,7 +3562,7 @@ static int caldav_propfind_by_resource(void *rock, void *data)
 	if (!fctx->record) {
 	    /* Fetch index record for the resource */
 	    r = mailbox_find_index_record(fctx->mailbox,
-					  cdata->dav.imap_uid, &record);
+					  cdata->dav.imap_uid, &record, NULL);
 	    /* XXX  Check errors */
 
 	    fctx->record = r ? NULL : &record;
@@ -3596,7 +3597,7 @@ static int caldav_propfind_by_resource(void *rock, void *data)
 	    icalcomponent_free(ical);
 
 	    caldav_lookup_resource(fctx->davdb, fctx->mailbox->name,
-				   cdata->dav.resource, 0, &cdata);
+				   cdata->dav.resource, 0, &cdata, 0);
 	}
 
 	fctx->record = NULL;
@@ -5385,7 +5386,7 @@ static int store_resource(struct transaction_t *txn, icalcomponent *ical,
     }
 
     /* Find message UID for the resource, if exists */
-    caldav_lookup_resource(caldavdb, mailbox->name, resource, 0, &cdata);
+    caldav_lookup_resource(caldavdb, mailbox->name, resource, 0, &cdata, 0);
 
     /* Check for change of iCalendar UID */
     if (cdata->ical_uid && strcmp(cdata->ical_uid, uid)) {
@@ -5399,7 +5400,7 @@ static int store_resource(struct transaction_t *txn, icalcomponent *ical,
     if (cdata->dav.imap_uid) {
 	/* Fetch index record for the resource */
 	oldrecord = &record;
-	mailbox_find_index_record(mailbox, cdata->dav.imap_uid, oldrecord);
+	mailbox_find_index_record(mailbox, cdata->dav.imap_uid, oldrecord, NULL);
     }
 
     /* Remove all X-LIC-ERROR properties */
@@ -7873,7 +7874,7 @@ static int meth_get_fb(struct transaction_t *txn,
 			       &txn->req_tgt, &txn->error.desc))) return r;
 
     if (txn->req_tgt.resource ||
-	!(txn->req_tgt.user || txn->req_tgt.collection)) {
+	!(txn->req_tgt.userid)) {
 	/* We don't handle GET on a resources or non-calendar collections */
 	return HTTP_NO_CONTENT;
     }
@@ -8026,8 +8027,8 @@ static int meth_get_fb(struct transaction_t *txn,
 
 	/* Set filename of resource */
 	buf_reset(&txn->buf);
-	buf_printf(&txn->buf, "%.*s.%s",
-		   (int) txn->req_tgt.userlen, txn->req_tgt.user,
+	buf_printf(&txn->buf, "%s.%s",
+		   txn->req_tgt.userid,
 		   mime->file_ext);
 	txn->resp_body.fname = buf_cstring(&txn->buf);
 
diff --git a/imap/http_carddav.c b/imap/http_carddav.c
index d5cc46176..cdd72dc01 100644
--- a/imap/http_carddav.c
+++ b/imap/http_carddav.c
@@ -640,7 +640,7 @@ static int carddav_put(struct transaction_t *txn, struct vparse_state *vparser,
     if (cdata->dav.imap_uid) {
 	/* Fetch index record for the resource */
 	oldrecord = &record;
-	mailbox_find_index_record(mailbox, cdata->dav.imap_uid, oldrecord);
+	mailbox_find_index_record(mailbox, cdata->dav.imap_uid, oldrecord, 0);
     }
 
     /* Create and cache RFC 5322 header fields for resource */
diff --git a/imap/http_dav.c b/imap/http_dav.c
index 41af08db4..c4283b116 100644
--- a/imap/http_dav.c
+++ b/imap/http_dav.c
@@ -3201,26 +3201,6 @@ int meth_copy(struct transaction_t *txn, void *params)
     /* Finished our initial read of dest mailbox */
     mailbox_unlock_index(dest_mbox, NULL);
 
-    /* Check any preconditions on destination */
-    if ((hdr = spool_getheader(txn->req_hdrs, "Overwrite")) &&
-	!strcmp(hdr[0], "F")) {
-
-	if (ddata->rowid) {
-	    /* Don't overwrite the destination resource */
-	    ret = HTTP_PRECOND_FAILED;
-	    goto done;
-	}
-	overwrite = OVERWRITE_NO;
-    }
-    if (r) {
-	syslog(LOG_ERR, "mailbox_open_%s(%s) failed: %s",
-	       txn->meth == METH_MOVE ? "iwl" : "irl",
-	       txn->req_tgt.mboxname, error_message(r));
-	txn->error.desc = error_message(r);
-	ret = HTTP_SERVER_ERROR;
-	goto done;
-    }
-
     /* Open the DAV DB corresponding to the src mailbox */
     src_davdb = cparams->davdb.open_db(src_mbox);
 
@@ -3293,7 +3273,7 @@ int meth_copy(struct transaction_t *txn, void *params)
 
     /* Find message UID for the dest resource, if exists */
     cparams->davdb.lookup_resource(dest_davdb, dest_tgt.mboxname,
-				   dest_tgt.resource, 0, (void **) &ddata);
+				   dest_tgt.resource, 0, (void **) &ddata, 0);
     /* XXX  Check errors */
 
     /* Check any preconditions on destination */
@@ -3375,7 +3355,6 @@ int meth_delete(struct transaction_t *txn, void *params)
 {
     struct meth_params *dparams = (struct meth_params *) params;
     int ret = HTTP_NO_CONTENT, r = 0, precond, rights, needrights;
-    struct buf synctoken = BUF_INITIALIZER;
     struct mboxevent *mboxevent = NULL;
     struct mailbox *mailbox = NULL;
     mbentry_t *mbentry = NULL;
@@ -3566,13 +3545,8 @@ int meth_delete(struct transaction_t *txn, void *params)
     /* Do any special processing */
     if (dparams->delete) dparams->delete(txn, mailbox, &record, ddata);
 
-    get_synctoken(mailbox, &synctoken);
-    txn->resp_body.synctoken = buf_cstring(&synctoken);
-
     write_body(ret, txn, NULL, 0);
 
-    buf_free(&synctoken);
-
   done:
     if (davdb) dparams->davdb.close_db(davdb);
     mailbox_close(&mailbox);
@@ -3595,7 +3569,6 @@ int meth_get_dav(struct transaction_t *txn, void *params)
     const char *data = NULL;
     unsigned long datalen = 0, offset = 0;
     struct buf msg_buf = BUF_INITIALIZER;
-    struct buf synctoken = BUF_INITIALIZER;
     struct resp_body_t *resp_body = &txn->resp_body;
     struct mailbox *mailbox = NULL;
     mbentry_t *mbentry = NULL;
@@ -3767,17 +3740,11 @@ int meth_get_dav(struct transaction_t *txn, void *params)
 	}
     }
 
-    r = get_synctoken(mailbox, &synctoken);
-    if (r) goto done;
-    resp_body->synctoken = buf_cstring(&synctoken);
-
     write_body(precond, txn, data, datalen);
 
     buf_free(&msg_buf);
 
   done:
-    buf_free(&synctoken);
-
     if (davdb) gparams->davdb.close_db(davdb);
     if (r) {
 	txn->error.desc = error_message(r);
@@ -4742,7 +4709,7 @@ int meth_proppatch(struct transaction_t *txn, void *params)
     if ((r = pparams->parse_path(txn->req_uri->path,
 				 &txn->req_tgt, &txn->error.desc))) return r;
 
-    if (!txn->req_tgt.collection && !txn->req_tgt.user) {
+    if (!txn->req_tgt.collection && !txn->req_tgt.userid) {
 	txn->error.desc = "PROPPATCH requires a collection";
 	return HTTP_NOT_ALLOWED;
     }
@@ -4946,7 +4913,6 @@ int meth_put(struct transaction_t *txn, void *params)
     int ret, r, precond, rights;
     const char **hdr, *etag;
     struct mime_type_t *mime = NULL;
-    struct buf synctoken = BUF_INITIALIZER;
     struct mailbox *mailbox = NULL;
     mbentry_t *mbentry = NULL;
     struct dav_data *ddata;
@@ -5187,13 +5153,8 @@ int meth_put(struct transaction_t *txn, void *params)
 	}
     }
 
-    get_synctoken(mailbox, &synctoken);
-    txn->resp_body.synctoken = buf_cstring(&synctoken);
-
     write_body(ret, txn, NULL, 0);
 
-    buf_free(&synctoken);
-
   done:
     if (obj) {
 	pparams->mime_types[0].free(obj);
@@ -5277,7 +5238,7 @@ int report_multiget(struct transaction_t *txn, struct meth_params *rparams,
 
 	    /* Find message UID for the resource */
 	    rparams->davdb.lookup_resource(fctx->davdb, tgt.mboxname,
-					   tgt.resource, 0, (void **) &ddata);
+					   tgt.resource, 0, (void **) &ddata, 0);
 	    ddata->resource = tgt.resource;
 	    /* XXX  Check errors */
 
@@ -5744,8 +5705,7 @@ int report_acl_prin_prop(struct transaction_t *txn,
 	if (strcmp(userid, "anyone") && strcmp(userid, "anonymous")) {
 	    /* Add userid to principal URL */
 	    strcpy(req_tgt.tail, userid);
-	    req_tgt.user = userid;
-	    req_tgt.userlen = strlen(userid);
+	    req_tgt.userid = xstrdup(userid);
 
 	    /* Add response for URL */
 	    xml_add_response(fctx, 0, 0);
@@ -6517,8 +6477,19 @@ int dav_store_resource(struct transaction_t *txn,
     else {
 	struct body *body = NULL;
 
+	strarray_t *flaglist = NULL;
+	struct entryattlist *annots = NULL;
+
+	if (oldrecord) {
+	    flaglist = mailbox_extract_flags(mailbox, oldrecord, httpd_userid);
+	    annots = mailbox_extract_annots(mailbox, oldrecord);
+	}
+
+	/* XXX - casemerge?  Doesn't matter with flags */
+	strarray_cat(flaglist, imapflags);
+
 	/* Append the message to the mailbox */
-	if ((r = append_fromstage(&as, &body, stage, now, imapflags, 0, 0))) {
+	if ((r = append_fromstage(&as, &body, stage, now, flaglist, 0, annots))) {
 	    syslog(LOG_ERR, "append_fromstage(%s) failed: %s",
 		   mailbox->name, error_message(r));
 	    ret = HTTP_SERVER_ERROR;
@@ -6528,6 +6499,8 @@ int dav_store_resource(struct transaction_t *txn,
 	    message_free_body(body);
 	    free(body);
 	}
+	strarray_free(flaglist);
+	freeentryatts(annots);
 
 	if (r) append_abort(&as);
 	else {
diff --git a/imap/http_webdav.c b/imap/http_webdav.c
index 3ae0f633c..0e093267b 100644
--- a/imap/http_webdav.c
+++ b/imap/http_webdav.c
@@ -92,7 +92,7 @@ static int webdav_parse_path(const char *path __attribute__((unused)),
 /* Open DAV DB corresponding to mailbox */
 static struct webdav_db *my_webdav_open(struct mailbox *mailbox)
 {
-    return webdav_open_mailbox(mailbox, WEBDAV_CREATE);
+    return webdav_open_mailbox(mailbox);
 }
 
 
@@ -138,7 +138,7 @@ static int webdav_put(struct transaction_t *txn, struct buf *obj,
     if (wdata->dav.imap_uid) {
 	/* Fetch index record for the resource */
 	oldrecord = &record;
-	mailbox_find_index_record(mailbox, wdata->dav.imap_uid, oldrecord);
+	mailbox_find_index_record(mailbox, wdata->dav.imap_uid, oldrecord, 0);
     }
 
     /* Get filename of attachment */
diff --git a/imap/httpd.c b/imap/httpd.c
index 95520a447..a134bd75e 100644
--- a/imap/httpd.c
+++ b/imap/httpd.c
@@ -2100,9 +2100,6 @@ EXPORTED void response_header(long code, struct transaction_t *txn)
 	httpdate_gen(datestr, sizeof(datestr), resp_body->lastmod);
 	prot_printf(httpd_out, "Last-Modified: %s\r\n", datestr);
     }
-    if (resp_body->synctoken) {
-	prot_printf(httpd_out, "X-Sync-Token: %s\r\n", resp_body->synctoken);
-    }
 
 
     /* Representation Metadata */
diff --git a/imap/mailbox.c b/imap/mailbox.c
index 504e0a889..ecd6f9df1 100644
--- a/imap/mailbox.c
+++ b/imap/mailbox.c
@@ -3095,7 +3095,7 @@ static int mailbox_update_webdav(struct mailbox *mailbox,
         }
     }
 
-    webdavdb = webdav_open_mailbox(mailbox, 0);
+    webdavdb = webdav_open_mailbox(mailbox);
 
     /* Find existing record for this resource */
     webdav_lookup_resource(webdavdb, mailbox->name, resource, 1, &wdata);
diff --git a/imap/sync_server.c b/imap/sync_server.c
index befe3e695..fb2d8c615 100644
--- a/imap/sync_server.c
+++ b/imap/sync_server.c
@@ -2291,7 +2291,7 @@ static int do_fetch(struct dlist *kin)
 	return IMAP_PROTOCOL_BAD_PARAMETERS;
 
     fname = mboxname_datapath(partition, mboxname, uniqueid, uid);
-    if (stat(fname, &sbuf) == -1)
+    if (stat(fname, &sbuf) == -1) {
 	fname = mboxname_archivepath(partition, mboxname, uniqueid, uid);
 	if (stat(fname, &sbuf) == -1)
 	    return IMAP_MAILBOX_NONEXISTENT;
diff --git a/imap/webdav_db.c b/imap/webdav_db.c
index f4eaca9c0..40965324e 100644
--- a/imap/webdav_db.c
+++ b/imap/webdav_db.c
@@ -75,6 +75,7 @@ enum {
 
 struct webdav_db {
     sqlite3 *db;			/* DB handle */
+    char *userid;
     sqlite3_stmt *stmt[NUM_STMT];	/* prepared statements */
     struct buf mailbox;			/* buffers for copies of column text */
     struct buf resource;
@@ -100,10 +101,7 @@ EXPORTED int webdav_done(void)
     return dav_done();
 }
 
-
-#define CMD_DROP "DROP TABLE IF EXISTS dav_objs;"
-
-#define CMD_CREATE							\
+#define CMD_CREATE_OBJS							\
     "CREATE TABLE IF NOT EXISTS dav_objs ("				\
     " rowid INTEGER PRIMARY KEY,"					\
     " creationdate INTEGER,"						\
@@ -122,46 +120,36 @@ EXPORTED int webdav_done(void)
     " UNIQUE( mailbox, resource ) );"					\
     "CREATE INDEX IF NOT EXISTS idx_res_uid ON dav_objs ( res_uid );"
 
-static struct webdav_db *webdav_open_fname(const char *fname, int flags)
+/* Open DAV DB corresponding to userid */
+EXPORTED struct webdav_db *webdav_open_userid(const char *userid)
 {
-    sqlite3 *db;
     struct webdav_db *webdavdb = NULL;
-    const char *cmds = CMD_CREATE;
 
-    if (flags & WEBDAV_TRUNC) cmds = CMD_DROP CMD_CREATE;
+    sqlite3 *db = dav_open_userid(userid);
+    if (!db) return NULL;
 
-    db = dav_open(fname, cmds);
-
-    if (db) {
-	webdavdb = xzmalloc(sizeof(struct webdav_db));
-	webdavdb->db = db;
-    }
+    webdavdb = xzmalloc(sizeof(struct webdav_db));
+    webdavdb->userid = xstrdup(userid);
+    webdavdb->db = db;
 
     return webdavdb;
 }
 
-/* Open DAV DB corresponding to userid */
-EXPORTED struct webdav_db *webdav_open_userid(const char *userid, int flags)
+/* Open DAV DB corresponding to mailbox */
+EXPORTED struct webdav_db *webdav_open_mailbox(struct mailbox *mailbox)
 {
-    struct buf fname = BUF_INITIALIZER;
     struct webdav_db *webdavdb = NULL;
+    const char *userid = mboxname_to_userid(mailbox->name);
 
-    dav_getpath_byuserid(&fname, userid);
-    webdavdb = webdav_open_fname(buf_cstring(&fname), flags);
-    buf_free(&fname);
+    if (userid)
+	return webdav_open_userid(userid);
 
-    return webdavdb;
-}
-
-/* Open DAV DB corresponding to mailbox */
-EXPORTED struct webdav_db *webdav_open_mailbox(struct mailbox *mailbox, int flags)
-{
-    struct buf fname = BUF_INITIALIZER;
-    struct webdav_db *webdavdb = NULL;
+    sqlite3 *db = dav_open_mailbox(mailbox);
+    if (!db) return NULL;
 
-    dav_getpath(&fname, mailbox);
-    webdavdb = webdav_open_fname(buf_cstring(&fname), flags);
-    buf_free(&fname);
+    webdavdb = xzmalloc(sizeof(struct webdav_db));
+    webdavdb->userid = xstrdup(userid);
+    webdavdb->db = db;
 
     return webdavdb;
 }
@@ -190,6 +178,7 @@ EXPORTED int webdav_close(struct webdav_db *webdavdb)
 
     r = dav_close(webdavdb->db);
 
+    free(webdavdb->userid);
     free(webdavdb);
 
     return r;
diff --git a/imap/webdav_db.h b/imap/webdav_db.h
index 59bf73c42..45ba10797 100644
--- a/imap/webdav_db.h
+++ b/imap/webdav_db.h
@@ -71,10 +71,10 @@ struct webdav_data {
 };
 
 /* get a database handle corresponding to userid */
-struct webdav_db *webdav_open_userid(const char *userid, int flags);
+struct webdav_db *webdav_open_userid(const char *userid);
 
 /* get a database handle corresponding to mailbox */
-struct webdav_db *webdav_open_mailbox(struct mailbox *mailbox, int flags);
+struct webdav_db *webdav_open_mailbox(struct mailbox *mailbox);
 
 /* close this handle */
 int webdav_close(struct webdav_db *webdavdb);
diff --git a/lib/strarray.c b/lib/strarray.c
index 4ac643a34..3b30d17ac 100644
--- a/lib/strarray.c
+++ b/lib/strarray.c
@@ -155,6 +155,13 @@ EXPORTED int strarray_append(strarray_t *sa, const char *s)
     return strarray_appendm(sa, xstrdup(s));
 }
 
+EXPORTED void strarray_cat(strarray_t *dest, const strarray_t *src)
+{
+    int i;
+    for (i = 0 ; i < src->count ; i++)
+	strarray_append(dest, strarray_nth(src, i));
+}
+
 EXPORTED int strarray_add(strarray_t *sa, const char *s)
 {
     int pos = strarray_find(sa, s, 0);
diff --git a/lib/strarray.h b/lib/strarray.h
index 648b5286a..f03a9d604 100644
--- a/lib/strarray.h
+++ b/lib/strarray.h
@@ -79,6 +79,7 @@ const char *strarray_nth(const strarray_t *sa, int idx);
 const char *strarray_safenth(const strarray_t *sa, int idx);
 void strarray_truncate(strarray_t *sa, int newlen);
 strarray_t *strarray_dup(const strarray_t *);
+void strarray_cat(strarray_t *dest, const strarray_t *src);
 
 #define strarray_shift(sa)	    strarray_remove((sa), 0)
 #define strarray_unshift(sa, s)	    strarray_insert((sa), 0, (s))

