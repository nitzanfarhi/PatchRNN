commit f2f66a2f886383fb76aca8ecc1bcc116c5d1f6fe
Author: Zhao Lei <zhaolei@cn.fujitsu.com>
Date:   Tue Jul 21 12:22:29 2015 +0800

    btrfs: Check cancel and pause in interval of scrub operation
    
    Old code checking cancel and pause request inside scrub stripe
    operation, like:
      loop() {
        if (parity) {
          scrub_parity_stripe();
          continue;
        }
    
        check_cancel_and_pause()
    
        scrub_normal_stripe();
      }
    
    Reason is when introduce raid56 stripe scrub, new code is inserted
    simplely to front of loop.
    
    Better to:
      loop() {
        check_cancel_and_pause()
    
        if (parity)
          scrub_parity_stripe();
        else
          scrub_normal_stripe();
      }
    
    This patch adjusted code place to realize above sequence.
    
    Signed-off-by: Zhao Lei <zhaolei@cn.fujitsu.com>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/scrub.c b/fs/btrfs/scrub.c
index 35d49b28a688..d99cdb11d4d9 100644
--- a/fs/btrfs/scrub.c
+++ b/fs/btrfs/scrub.c
@@ -3105,22 +3105,6 @@ static noinline_for_stack int scrub_stripe(struct scrub_ctx *sctx,
 	 */
 	ret = 0;
 	while (physical < physical_end) {
-		/* for raid56, we skip parity stripe */
-		if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {
-			ret = get_raid56_logic_offset(physical, num,
-					map, &logical, &stripe_logical);
-			logical += base;
-			if (ret) {
-				stripe_logical += base;
-				stripe_end = stripe_logical + increment - 1;
-				ret = scrub_raid56_parity(sctx, map, scrub_dev,
-						ppath, stripe_logical,
-						stripe_end);
-				if (ret)
-					goto out;
-				goto skip;
-			}
-		}
 		/*
 		 * canceled?
 		 */
@@ -3145,6 +3129,24 @@ static noinline_for_stack int scrub_stripe(struct scrub_ctx *sctx,
 			scrub_blocked_if_needed(fs_info);
 		}
 
+		/* for raid56, we skip parity stripe */
+		if (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK) {
+			ret = get_raid56_logic_offset(physical, num, map,
+						      &logical,
+						      &stripe_logical);
+			logical += base;
+			if (ret) {
+				stripe_logical += base;
+				stripe_end = stripe_logical + increment - 1;
+				ret = scrub_raid56_parity(sctx, map, scrub_dev,
+							  ppath, stripe_logical,
+							  stripe_end);
+				if (ret)
+					goto out;
+				goto skip;
+			}
+		}
+
 		if (btrfs_fs_incompat(fs_info, SKINNY_METADATA))
 			key.type = BTRFS_METADATA_ITEM_KEY;
 		else

