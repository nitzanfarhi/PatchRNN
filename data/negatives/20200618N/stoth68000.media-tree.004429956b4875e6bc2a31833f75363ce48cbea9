commit 004429956b4875e6bc2a31833f75363ce48cbea9
Author: Jan Beulich <jbeulich@novell.com>
Date:   Tue Oct 16 23:29:33 2007 -0700

    handle recursive calls to bust_spinlocks()
    
    Various architectures may call bust_spinlocks() recursively; the function
    itself, however, doesn't appear to be meant to be called in this manner.
    Nevertheless, this doesn't appear to be a problem as long as
    bust_spinlocks(0) doesn't get called twice in a row (otherwise,
    unblank_screen() may enter the scheduler).  However, at least on i386 die()
    has been capable of returning (and on other architectures this should
    really be that way, too) when notify_die() returns NOTIFY_STOP.
    
    Short of getting a reply to a respective query, this patch makes
    bust_spinlocks() increment/decrement oops_in_progress, and wake klogd only
    when the count drops back to zero.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/lib/bust_spinlocks.c b/lib/bust_spinlocks.c
index accb35658169..486da62b2b07 100644
--- a/lib/bust_spinlocks.c
+++ b/lib/bust_spinlocks.c
@@ -17,13 +17,13 @@
 void __attribute__((weak)) bust_spinlocks(int yes)
 {
 	if (yes) {
-		oops_in_progress = 1;
+		++oops_in_progress;
 	} else {
 #ifdef CONFIG_VT
 		unblank_screen();
 #endif
-		oops_in_progress = 0;
-		wake_up_klogd();
+		if (--oops_in_progress == 0)
+			wake_up_klogd();
 	}
 }
 

