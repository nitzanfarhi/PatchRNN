commit 94c525eed7372fd3852e2ba80019a326da541d6d
Author: dbeer <dbeer@8f940c70-5916-0410-ac46-d1fa2fa6ea29>
Date:   Fri Sep 28 17:24:03 2012 +0000

    Make display_job_server_suffix=false compatible with job arrays. Previously this was crashing - bugzilla #216.

diff --git a/src/resmom/catch_child.c b/src/resmom/catch_child.c
index 5b3d558e8..b3deddab8 100644
--- a/src/resmom/catch_child.c
+++ b/src/resmom/catch_child.c
@@ -417,10 +417,10 @@ void scan_for_exiting(void)
       }
 
 
-    for (
-      ptask = (task *)GET_NEXT(pjob->ji_tasks);
-      ptask != NULL;
-      ptask = (task *)GET_NEXT(ptask->ti_jobtask))
+    for (ptask = (task *)GET_NEXT(pjob->ji_tasks);
+         ptask != NULL;
+         ptask = (task *)GET_NEXT(ptask->ti_jobtask))
+
       {
       if (ptask->ti_qs.ti_status != TI_STATE_EXITED)
         continue;
@@ -438,11 +438,7 @@ void scan_for_exiting(void)
           pjob->ji_qs.ji_un.ji_momt.ji_exitstat = ptask->ti_qs.ti_exitstat;
           }
 
-        log_event(
-          PBSEVENT_JOB,
-          PBS_EVENTCLASS_JOB,
-          pjob->ji_qs.ji_jobid,
-          "job was terminated");
+        log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, pjob->ji_qs.ji_jobid, "job was terminated");
           
         mom_radix = pjob->ji_wattr[JOB_ATR_job_radix].at_val.at_long;
 
@@ -453,9 +449,11 @@ void scan_for_exiting(void)
         else
           {
           NumSisters = 1; /* We use this for later */
+
           if (pjob->ji_sampletim == 0)
             {
             pjob->ji_sampletim = time(NULL);
+
             if ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_INTERMEDIATE_MOM) == 0)
               {
               /* only call send_sisters with radix == TRUE if this
@@ -472,16 +470,16 @@ void scan_for_exiting(void)
             time_now = time(NULL);
             if (time_now - pjob->ji_sampletim > 5)
               {
-               
-               if ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_INTERMEDIATE_MOM) == 0)
-                 {
-                 /* only call send_sisters with radix == TRUE if this is
-                  * mother superior intermediate moms already called this
-                  * in im_request IM_KILL_JOB_RADIX */
-                 NumSisters = send_sisters(pjob, IM_KILL_JOB_RADIX, TRUE);
-                 pjob->ji_outstanding = NumSisters;
-                 }
-               }
+
+              if ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_INTERMEDIATE_MOM) == 0)
+                {
+                /* only call send_sisters with radix == TRUE if this is
+                 * mother superior intermediate moms already called this
+                 * in im_request IM_KILL_JOB_RADIX */
+                NumSisters = send_sisters(pjob, IM_KILL_JOB_RADIX, TRUE);
+                pjob->ji_outstanding = NumSisters;
+                }
+              }
             }
           } 
 
@@ -504,6 +502,7 @@ void scan_for_exiting(void)
             {
             momport = pbs_rm_port;
             }
+
           job_save(pjob, SAVEJOB_QUICK, momport);
           }
         else if (LOGLEVEL >= 3)
@@ -586,7 +585,8 @@ void scan_for_exiting(void)
     /* If we are an intermediate mom we need to see if everyone has checked in */
 	  if ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_INTERMEDIATE_MOM))
 	    {
-	    if ((pjob->ji_qs.ji_substate != JOB_SUBSTATE_EXITING) && (pjob->ji_qs.ji_substate != JOB_SUBSTATE_NOTERM_REQUE))
+	    if ((pjob->ji_qs.ji_substate != JOB_SUBSTATE_EXITING) &&
+          (pjob->ji_qs.ji_substate != JOB_SUBSTATE_NOTERM_REQUE))
 	  	  {
 	  	  if (LOGLEVEL >= 3)
 	  	    {
@@ -627,6 +627,7 @@ void scan_for_exiting(void)
            server. If we have tasks to complete continue. But if there
            are no tasks left to run we need to delete the job.*/
         ptask = (task *)GET_NEXT(pjob->ji_tasks);
+
         if (ptask == NULL)
           mom_deljob(pjob);
         }
@@ -691,7 +692,7 @@ void scan_for_exiting(void)
     pjob->ji_qs.ji_svrflags &= ~JOB_SVFLG_Suspend;
 
     if ((pjob->ji_qs.ji_substate != JOB_SUBSTATE_NOTERM_REQUE) &&
-       (pjob->ji_qs.ji_substate != JOB_SUBSTATE_EXIT_WAIT))
+        (pjob->ji_qs.ji_substate != JOB_SUBSTATE_EXIT_WAIT))
       kill_job(pjob, SIGKILL, __func__, "local task termination detected");
     else
       {
@@ -753,20 +754,19 @@ void scan_for_exiting(void)
 
     if (pjob->ji_qs.ji_substate != JOB_SUBSTATE_EXIT_WAIT)
       run_epilogues(pjob);
+
     pjob->ji_qs.ji_substate = JOB_SUBSTATE_PREOBIT;
+
     rc = send_job_status(pjob);
+
     if (rc != PBSE_NONE)
       {
       pjob->ji_qs.ji_substate = JOB_SUBSTATE_EXIT_WAIT;
-      if(LOGLEVEL >= 4)
+      if (LOGLEVEL >= 4)
         {
         snprintf(log_buf, LOCAL_LOG_BUF_SIZE, "could not contact server for job %s: error: %d", 
-            pjob->ji_qs.ji_jobid, rc);
-        log_record(
-            PBSEVENT_JOB,
-            PBS_EVENTCLASS_JOB,
-            __func__,
-            log_buf);
+          pjob->ji_qs.ji_jobid, rc);
+        log_record(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, __func__, log_buf);
         }
       }
 
@@ -803,12 +803,12 @@ int run_epilogues(
 
   /* check epilog script */
 
-  if ((pjob->ji_wattr[(int)JOB_ATR_interactive].at_flags & ATR_VFLAG_SET) &&
-       pjob->ji_wattr[(int)JOB_ATR_interactive].at_val.at_long)
+  if ((pjob->ji_wattr[JOB_ATR_interactive].at_flags & ATR_VFLAG_SET) &&
+       pjob->ji_wattr[JOB_ATR_interactive].at_val.at_long)
     {
     /* job is interactive */
 
-    presc = find_resc_entry( &pjob->ji_wattr[(int)JOB_ATR_resource],
+    presc = find_resc_entry( &pjob->ji_wattr[JOB_ATR_resource],
                              find_resc_def(svr_resc_def, "epilogue", svr_resc_size));
     if ((presc != NULL))
       if ((presc->rs_value.at_flags & ATR_VFLAG_SET) && (presc->rs_value.at_val.at_str != NULL))
@@ -838,7 +838,7 @@ int run_epilogues(
     {
     /* job is not interactive */
 
-    presc = find_resc_entry( &pjob->ji_wattr[(int)JOB_ATR_resource], 
+    presc = find_resc_entry( &pjob->ji_wattr[JOB_ATR_resource], 
                              find_resc_def(svr_resc_def, "epilogue", svr_resc_size));
     if ((presc != NULL))
       if ((presc->rs_value.at_flags & ATR_VFLAG_SET) && 
diff --git a/src/resmom/mom_server.c b/src/resmom/mom_server.c
index 3d3642a67..b7fc9e99c 100644
--- a/src/resmom/mom_server.c
+++ b/src/resmom/mom_server.c
@@ -4946,8 +4946,7 @@ int is_mom_server_down(
  * @see scan_for_exiting
  */
 
-int
-no_mom_servers_down(void)
+int no_mom_servers_down(void)
 
   {
   if (down_svraddrs[0] == 0)
diff --git a/src/resmom/start_exec.c b/src/resmom/start_exec.c
index c8eb5c88e..0dbe46180 100644
--- a/src/resmom/start_exec.c
+++ b/src/resmom/start_exec.c
@@ -6474,31 +6474,31 @@ char *std_file_name(
 
   {
   static char  path[MAXPATHLEN + 1];
-  char  key;
-  int   len;
-  char *pd;
-  char *suffix;
-  char *jobpath = NULL;
+  char         key;
+  int          len;
+  char        *pd;
+  char        *suffix;
+  char        *jobpath = NULL;
 #ifdef QSUB_KEEP_NO_OVERRIDE
-  char *pt;
-  char endpath[MAXPATHLEN + 1];
+  char        *pt;
+  char         endpath[MAXPATHLEN + 1];
 #endif
 
 #if NO_SPOOL_OUTPUT == 0
-  int   havehomespool = 0;
+  int          havehomespool = 0;
 
   extern char *TNoSpoolDirList[];
 #else /* NO_SPOOL_OUTPUT */
 
-  struct stat myspooldir;
+  struct stat  myspooldir;
   static char  path_alt[MAXPATHLEN + 1];
-  int   rcstat;
+  int          rcstat;
 #endif /* NO_SPOOL_OUTPUT */
 
   if (LOGLEVEL >= 5)
     {
     sprintf(log_buffer, "getting %s file name",
-            (which == StdOut) ? "stdout" : "stderr");
+      (which == StdOut) ? "stdout" : "stderr");
 
     log_record(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, pjob->ji_qs.ji_jobid, log_buffer);
     }
@@ -6542,7 +6542,7 @@ char *std_file_name(
           {
           remove_leading_hostname(&jobpath);
 
-          if (expand_path(pjob,jobpath,sizeof(path),path) != SUCCESS)
+          if (expand_path(pjob, jobpath, sizeof(path), path) != SUCCESS)
             {
             return(NULL);
             }
diff --git a/src/server/job_func.c b/src/server/job_func.c
index 2e6eaede3..74f7904b8 100644
--- a/src/server/job_func.c
+++ b/src/server/job_func.c
@@ -880,13 +880,17 @@ job *job_clone(
   hostname = index(oldid, '.');
 
   *bracket = '\0';
-  hostname++;
-
-  pnewjob->ji_qs.ji_jobid[PBS_MAXSVRJOBID-1] = '\0';
-
-  snprintf(pnewjob->ji_qs.ji_jobid, PBS_MAXSVRJOBID, "%s[%d].%s",
-    oldid, taskid, hostname);
-
+  if (hostname != NULL)
+    {
+    hostname++;
+    snprintf(pnewjob->ji_qs.ji_jobid, sizeof(pnewjob->ji_qs.ji_jobid), 
+      "%s[%d].%s",
+      oldid, taskid, hostname);
+    }
+  else
+    snprintf(pnewjob->ji_qs.ji_jobid, sizeof(pnewjob->ji_qs.ji_jobid),
+      "%s[%d]",
+      oldid, taskid);
 
   /* update the job filename
    * We could optimize the sub-jobs to all use the same file. We would need a
@@ -898,7 +902,11 @@ job *job_clone(
    * make up new job file name, it is based on the new jobid
    */
 
-  snprintf(basename, PBS_JOBBASE, "%s-%d.%s", oldid, taskid, hostname);
+  if (hostname != NULL)
+    snprintf(basename, sizeof(basename), "%s-%d.%s", oldid, taskid, hostname);
+  else
+    snprintf(basename, sizeof(basename), "%s-%d", oldid, taskid);
+
   free(oldid);
 
   do
diff --git a/src/server/req_quejob.c b/src/server/req_quejob.c
index e6506abf2..134e7e0b9 100644
--- a/src/server/req_quejob.c
+++ b/src/server/req_quejob.c
@@ -1375,11 +1375,16 @@ int req_quejob(
 
     hostname = index(oldid, '.');
 
-    *(hostname++) = '\0';
-
-    snprintf(pj->ji_qs.ji_jobid, PBS_MAXSVRJOBID, "%s[].%s",
-      oldid,
-      hostname);
+    if (hostname != NULL)
+      {
+      *(hostname++) = '\0';
+      
+      snprintf(pj->ji_qs.ji_jobid, PBS_MAXSVRJOBID, "%s[].%s",
+        oldid,
+        hostname);
+      }
+    else
+      snprintf(pj->ji_qs.ji_jobid, sizeof(pj->ji_qs.ji_jobid), "%s[]", oldid);
 
     free(oldid);    
     }

