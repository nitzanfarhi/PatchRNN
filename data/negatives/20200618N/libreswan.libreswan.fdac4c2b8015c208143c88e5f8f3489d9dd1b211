commit fdac4c2b8015c208143c88e5f8f3489d9dd1b211
Author: Paul Wouters <paul@xelerance.com>
Date:   Mon Dec 21 23:16:41 2009 -0500

    Merged in David's Fixes for 2.6.32 kernels. Compilation tested on a few
    kernels, and late kernels works, but I did notice slightly older kernels
    like 2.6.21 are still broken.

diff --git a/linux/include/openswan/ipsec_kversion.h b/linux/include/openswan/ipsec_kversion.h
index 4b2295d94..b855f88ee 100644
--- a/linux/include/openswan/ipsec_kversion.h
+++ b/linux/include/openswan/ipsec_kversion.h
@@ -342,6 +342,7 @@
 # define HAVE_SKB_DST 1
 #endif
 
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,31)
 #ifndef NETDEV_TX_BUSY
 # ifdef NETDEV_XMIT_CN
 #  define NETDEV_TX_BUSY NETDEV_XMIT_CN
@@ -349,6 +350,7 @@
 #  define NETDEV_TX_BUSY 1
 # endif
 #endif
+#endif
 
 #if 0
 /* nicely, latest netdevice.h includes this define */
@@ -463,6 +465,19 @@
 # define NF_INET_LOCAL_OUT NF_IP_LOCAL_OUT
 #endif
 
+/* TODO: Fedora kernels (eg 2.6.31.6-166.fc12) also need this */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+# define USE_NETDEV_OPS
+#else
+# define skb_dst_drop(s)	({ \
+					if ((s)->dst) \
+						dst_release((s)->dst); \
+					(s)->dst = NULL; \
+				})
+# define skb_dst_set(s,p)	(s)->dst = (p)
+# define skb_dst(s)		(s)->dst
+#endif
+
 #if __KERNEL__
 # if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,0)
 #  if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0) 
diff --git a/linux/include/openswan/ipsec_param.h b/linux/include/openswan/ipsec_param.h
index a73e88ca0..9a3a1d669 100644
--- a/linux/include/openswan/ipsec_param.h
+++ b/linux/include/openswan/ipsec_param.h
@@ -227,10 +227,13 @@ extern int sysctl_ipsec_regress_pfkey_lossage;
 #define IPSEC_DEFAULT_TTL 64
 #endif
 
+#if 0
+see ipsec_kversion.h
 #ifndef HAVE_SKB_DST
 #define skb_dst(skb) (skb->dst)
 #define skb_dst_set(skb,D) do { (skb)->dst=(D); } while(0)
 #endif
+#endif
 
 #define _IPSEC_PARAM_H_
 #endif /* _IPSEC_PARAM_H_ */
diff --git a/linux/include/openswan/ipsec_param2.h b/linux/include/openswan/ipsec_param2.h
index de8065dff..01b6e331e 100644
--- a/linux/include/openswan/ipsec_param2.h
+++ b/linux/include/openswan/ipsec_param2.h
@@ -40,12 +40,12 @@
 
 /* kernels > 2.3.37-ish */
 #if defined(IP_SELECT_IDENT) && !defined(IP_SELECT_IDENT_NEW)
-#define KLIPS_IP_SELECT_IDENT(iph, skb) ip_select_ident(iph, skb->dst)
+#define KLIPS_IP_SELECT_IDENT(iph, skb) ip_select_ident(iph, skb_dst(skb))
 #endif
 
 /* kernels > 2.4.2 */
 #if defined(IP_SELECT_IDENT) && defined(IP_SELECT_IDENT_NEW)
-#define KLIPS_IP_SELECT_IDENT(iph, skb) ip_select_ident(iph, skb->dst, NULL)
+#define KLIPS_IP_SELECT_IDENT(iph, skb) ip_select_ident(iph, skb_dst(skb), NULL)
 #endif
 
 #endif /* SUSE_LINUX_2_4_19_IS_STUPID */
diff --git a/linux/include/openswan/ipsec_tunnel.h b/linux/include/openswan/ipsec_tunnel.h
index 4bafc2a6d..e236ca725 100644
--- a/linux/include/openswan/ipsec_tunnel.h
+++ b/linux/include/openswan/ipsec_tunnel.h
@@ -85,6 +85,10 @@ struct ipsecpriv
 				 unsigned short htype, __u32 daddr);
 #endif /* !NET_21 */
 	void (*header_cache_update)(struct hh_cache *hh, struct net_device *dev, unsigned char *  haddr);
+#endif
+#ifdef USE_NETDEV_OPS
+	const struct net_device_ops *saved_netdev_ops;
+	struct net_device_ops netdev_ops;
 #endif
 	int  (*set_mac_address)(struct net_device *dev, void *addr);
 	struct net_device_stats *(*get_stats)(struct net_device *dev);
diff --git a/linux/net/ipsec/ipsec_mast.c b/linux/net/ipsec/ipsec_mast.c
index 1288f7402..4f56b70f0 100644
--- a/linux/net/ipsec/ipsec_mast.c
+++ b/linux/net/ipsec/ipsec_mast.c
@@ -661,11 +661,17 @@ ipsec_mast_probe(struct net_device *dev)
 		    (unsigned long) sizeof(struct mastpriv),
 		    dev->name ? dev->name : "NULL");
 
+#ifndef USE_NETDEV_OPS
 	/* Add our mast functions to the device */
 	dev->open		= ipsec_mast_open;
 	dev->stop		= ipsec_mast_close;
 	dev->hard_start_xmit	= ipsec_mast_start_xmit;
 	dev->get_stats		= ipsec_mast_get_stats;
+	dev->set_multicast_list = NULL;
+	dev->do_ioctl		= ipsec_mast_ioctl;
+	dev->set_mac_address 	= NULL;
+	dev->neigh_setup        = ipsec_mast_neigh_setup_dev;
+#endif
 #ifdef alloc_netdev
 	dev->destructor         = free_netdev;
 #endif
@@ -682,8 +688,6 @@ ipsec_mast_probe(struct net_device *dev)
 		((__u8*)(zeroes))[i] = 0;
 	}
 	
-	dev->set_multicast_list = NULL;
-	dev->do_ioctl		= ipsec_mast_ioctl;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
 	dev->header_ops = NULL;
 #else
@@ -691,8 +695,6 @@ ipsec_mast_probe(struct net_device *dev)
 	dev->rebuild_header 	= NULL;
 	dev->header_cache_update= NULL;
 #endif
-	dev->set_mac_address 	= NULL;
-	dev->neigh_setup        = ipsec_mast_neigh_setup_dev;
 	dev->hard_header_len 	= 8+20+20+8;
 	dev->mtu		= 0;
 	dev->addr_len		= 0;
@@ -718,6 +720,18 @@ static void ipsec_mast_netdev_setup(struct net_device *dev)
 struct net_device *mastdevices[IPSEC_NUM_IFMAX];
 int mastdevices_max=-1;
 
+#ifdef USE_NETDEV_OPS
+static const struct net_device_ops ipsec_mast_ops = {
+	.ndo_init		= ipsec_mast_probe,
+	.ndo_open		= ipsec_mast_open,
+	.ndo_stop		= ipsec_mast_close,
+	.ndo_start_xmit		= ipsec_mast_start_xmit,
+	.ndo_get_stats		= ipsec_mast_get_stats,
+	.ndo_do_ioctl		= ipsec_mast_ioctl,
+	.ndo_neigh_setup	= ipsec_mast_neigh_setup_dev,
+};
+#endif
+
 int ipsec_mast_createnum(int vifnum) 
 {
 	struct net_device *im;
@@ -755,7 +769,11 @@ int ipsec_mast_createnum(int vifnum)
 	memcpy(im->name, name, IFNAMSIZ);
 #endif
 		
+#ifdef USE_NETDEV_OPS
+	im->netdev_ops = &ipsec_mast_ops;
+#else
 	im->init = ipsec_mast_probe;
+#endif
 
 	if(register_netdev(im) != 0) {
 		printk(KERN_ERR "ipsec_mast: failed to register %s\n",
diff --git a/linux/net/ipsec/ipsec_rcv.c b/linux/net/ipsec/ipsec_rcv.c
index 842b13949..3c89ada71 100644
--- a/linux/net/ipsec/ipsec_rcv.c
+++ b/linux/net/ipsec/ipsec_rcv.c
@@ -483,10 +483,17 @@ void ipsec_rcv_setoutif(struct ipsec_rcv_state *irs)
 		}
 		skb->dev = irs->ipsp->ips_out;
 		
+#ifdef USE_NETDEV_OPS
+		if(skb->dev && skb->dev->netdev_ops->ndo_get_stats) {
+			struct net_device_stats *stats = skb->dev->netdev_ops->ndo_get_stats(skb->dev);
+			irs->stats = stats;
+		}
+#else
 		if(skb->dev && skb->dev->get_stats) {
 			struct net_device_stats *stats = skb->dev->get_stats(skb->dev);
 			irs->stats = stats;
 		}
+#endif
 	} 
 }
 
@@ -1701,10 +1708,8 @@ ipsec_rcv_cleanup(struct ipsec_rcv_state *irs)
 	/* release the dst that was attached, since we have likely
 	 * changed the actual destination of the packet.
 	 */
-	if(skb_dst(skb)) {
-		dst_release(skb_dst(skb));
-		skb->dst = NULL;
-	}
+	if(skb_dst(skb))
+		skb_dst_drop(skb);
 	skb->pkt_type = PACKET_HOST;
 	if(irs->hard_header_len &&
 	   (skb_mac_header(skb) != (skb_network_header(skb) - irs->hard_header_len)) &&
diff --git a/linux/net/ipsec/ipsec_tunnel.c b/linux/net/ipsec/ipsec_tunnel.c
index 7b9cb3d14..09af8fb46 100644
--- a/linux/net/ipsec/ipsec_tunnel.c
+++ b/linux/net/ipsec/ipsec_tunnel.c
@@ -1159,6 +1159,7 @@ ipsec_tunnel_rebuild_header(void *buff, struct net_device *dev,
 	return ret;
 }
 
+#ifdef HAVE_SET_MAC_ADDR
 DEBUG_NO_STATIC int
 ipsec_tunnel_set_mac_address(struct net_device *dev, void *addr)
 {
@@ -1207,6 +1208,7 @@ ipsec_tunnel_set_mac_address(struct net_device *dev, void *addr)
 	return prv->set_mac_address(prv->dev, addr);
 
 }
+#endif /* HAVE_SET_MAC_ADDR */
 
 #ifndef NET_21
 DEBUG_NO_STATIC void
@@ -1422,7 +1424,9 @@ ipsec_tunnel_detach(struct net_device *dev)
 	dev->neigh_setup        = NULL;
 #endif
 #endif
+#ifdef HAVE_SET_MAC_ADDR
 	dev->set_mac_address = NULL;
+#endif
 	dev->mtu = 0;
 #endif /* DETACH_AND_DOWN */
 	
@@ -1787,9 +1791,6 @@ ipsec_tunnel_init(struct net_device *dev)
 		    (unsigned long) sizeof(struct ipsecpriv),
 		    dev->name ? dev->name : "NULL");
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
-	dev->get_stats		= ipsec_tunnel_get_stats;
-#endif
 	dev->destructor         = free_netdev;
 
 #ifndef HAVE_NETDEV_PRIV
@@ -1824,7 +1825,9 @@ ipsec_tunnel_init(struct net_device *dev)
         dev->stop               = ipsec_tunnel_close;
         dev->hard_start_xmit    = ipsec_tunnel_start_xmit;
         dev->get_stats          = ipsec_tunnel_get_stats;
+#ifdef HAVE_SET_MAC_ADDR
         dev->set_mac_address    = NULL;
+#endif
         dev->do_ioctl           = ipsec_tunnel_ioctl;
         dev->neigh_setup        = ipsec_tunnel_neigh_setup_dev;
 #endif
@@ -1924,7 +1927,11 @@ ipsec_tunnel_createnum(int ifnum)
 	dev_ipsec->next = NULL;
 #endif
 #endif /* alloc_netdev */
+#ifndef USE_NETDEV_OPS
 	dev_ipsec->init = &ipsec_tunnel_probe;
+#else
+	dev_ipsec->netdev_ops = &klips_device_ops;
+#endif
 	KLIPS_PRINT(debug_tunnel & DB_TN_INIT,
 		    "klips_debug:ipsec_tunnel_init_devices: "
 		    "registering device %s\n",
@@ -2196,6 +2203,7 @@ ipsec_xmit_state_delete (struct ipsec_xmit_state *ixs)
 #ifdef HAVE_NET_DEVICE_OPS
 const struct net_device_ops klips_device_ops = {
 	/* Add our tunnel functions to the device */
+	.ndo_init               = ipsec_tunnel_probe,
 	.ndo_open               = ipsec_tunnel_open,
 	.ndo_stop		= ipsec_tunnel_close,
 	.ndo_start_xmit 	= ipsec_tunnel_start_xmit,
@@ -2237,7 +2245,7 @@ ipsec_tunnel_attach(struct net_device *dev, struct net_device *physdev)
 #ifdef HAVE_NET_DEVICE_OPS
 	dev->netdev_ops = &klips_device_ops;
 #else
-# ifndef HAVE_SET_MAC_ADDR
+# ifdef HAVE_SET_MAC_ADDR
 	dev->set_mac_address = ipsec_tunnel_set_mac_address;
 # endif
 #endif /* HAVE_NET_DEVICE_OPS */
diff --git a/linux/net/ipsec/ipsec_xmit.c b/linux/net/ipsec/ipsec_xmit.c
index 115352345..1c10b1067 100644
--- a/linux/net/ipsec/ipsec_xmit.c
+++ b/linux/net/ipsec/ipsec_xmit.c
@@ -118,8 +118,8 @@
 #endif
 
 /* kernels > 2.4.2 */
-#if defined(IP_SELECT_IDENT) && defined(IP_SELECT_IDENT_NEW) && !defined(HAVE_SKB_DST)
-#define KLIPS_IP_SELECT_IDENT(iph, skb) ip_select_ident(iph, skb->dst, NULL)
+#if defined(IP_SELECT_IDENT) && defined(IP_SELECT_IDENT_NEW)
+#define KLIPS_IP_SELECT_IDENT(iph, skb) ip_select_ident(iph, skb_dst(skb), NULL)
 #endif
 
 #endif /* SUSE_LINUX_2_4_19_IS_STUPID */
@@ -2043,7 +2043,7 @@ ipsec_xmit_send(struct ipsec_xmit_state*ixs, struct flowi *fl)
 		return IPSEC_XMIT_RECURSDETECT;
 	}
 
-	dst_release(skb_dst(ixs->skb));
+	skb_dst_drop(ixs->skb);
 	skb_dst_set(ixs->skb, &ixs->route->u.dst);
 	if(ixs->stats) {
 		ixs->stats->tx_bytes += ixs->skb->len;

