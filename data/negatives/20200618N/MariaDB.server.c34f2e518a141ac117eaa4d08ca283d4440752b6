commit c34f2e518a141ac117eaa4d08ca283d4440752b6
Author: Sreeharsha Ramanavarapu <sreeharsha.ramanavarapu@oracle.com>
Date:   Wed May 24 08:50:05 2017 +0530

    Bug #24595639: INCORRECT BEHAVIOR IN QUERY WITH UNION AND
                   GROUP BY
    
    Issue 1:
    --------
    This problem occurs in the following conditions:
    1) A UNION is present in the subquery of select list and
       handles multiple columns.
    2) Query has a GROUP BY.
    
    A temporary table is created to handle the UNION.
    Item_field objects are based on the expressions of the
    result of the UNION (ie. the fake_select_lex). While
    checking validity of the columns in the GROUP BY list, the
    columns of the temporary table are checked in
    Item_ident::local_column. But the Item_field objects
    created for the temporary table don't have information like
    the Name_resolution_context that they belong to or whether
    they are dependent on an outer query. Since these members
    are null, incorrect behavior is caused.
    
    This can happen when such Item objects are cached to apply
    the IN-to-EXISTS transform for Item_row.
    
    Solution to Issue 1:
    --------------------
    Context information of the first select in the UNION will
    be assigned to the new Item_field objects.
    
    
    Issue 2:
    --------
    This problem occurs in the following conditions:
    1) A UNION is present in the subquery of select list.
    2) A column in the UNION's first SELECT refers to a table
       in the outer-query making it a dependent union.
    3) GROUP BY column refers to the outer-referencing column.
    
    While resolving the select list with an outer-reference, an
    Item_outer_ref object is created to handle the
    outer-query's GROUP BY list. The Item_outer_ref object
    replaces the Item_field object in the item tree.
    Item_outer_ref::fix_fields will be called only while fixing
    the inner references of the outer query.
    
    Before resolving the outer-query, an Item_type_holder
    object needs to be created to handle the UNION. But as
    explained above, the Item_outer_ref object has not been
    fixed yet. Having a fixed Item object is a pre-condition
    for creating an Item_type_holder.
    
    Solution to Issue 2:
    --------------------
    Use the reference (real_item()) of an Item_outer_ref object
    instead of the object itself while creating an
    Item_type_holder.

diff --git a/sql/item.cc b/sql/item.cc
index 34157c33cf4..6f1fdaae398 100644
--- a/sql/item.cc
+++ b/sql/item.cc
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -1949,6 +1949,9 @@ Item_field::Item_field(Field *f)
    item_equal(0), no_const_subst(0),
    have_privileges(0), any_privileges(0)
 {
+  if (f->table->pos_in_table_list != NULL)
+    context= &(f->table->pos_in_table_list->select_lex->context);
+
   set_field(f);
   /*
     field_name and table_name should not point to garbage
diff --git a/sql/sql_union.cc b/sql/sql_union.cc
index d230b903d2c..ca6870dab9c 100644
--- a/sql/sql_union.cc
+++ b/sql/sql_union.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -282,6 +282,19 @@ bool st_select_lex_unit::prepare(THD *thd_arg, select_result *sel_result,
       Item *item_tmp;
       while ((item_tmp= it++))
       {
+        /*
+          If the outer query has a GROUP BY clause, an outer reference to this
+          query block may have been wrapped in a Item_outer_ref, which has not
+          been fixed yet. An Item_type_holder must be created based on a fixed
+          Item, so use the inner Item instead.
+        */
+        DBUG_ASSERT(item_tmp->fixed ||
+                    (item_tmp->type() == Item::REF_ITEM &&
+                     ((Item_ref *)(item_tmp))->ref_type() ==
+                     Item_ref::OUTER_REF));
+        if (!item_tmp->fixed)
+          item_tmp= item_tmp->real_item();
+
 	/* Error's in 'new' will be detected after loop */
 	types.push_back(new Item_type_holder(thd_arg, item_tmp));
       }

