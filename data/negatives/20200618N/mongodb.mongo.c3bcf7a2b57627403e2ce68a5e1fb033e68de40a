commit c3bcf7a2b57627403e2ce68a5e1fb033e68de40a
Author: Eliot Horowitz <eliot@10gen.com>
Date:   Thu Oct 30 18:00:58 2014 -0400

    CollectionInfoCache::reset should reset index keys under X lock

diff --git a/src/mongo/db/catalog/collection.cpp b/src/mongo/db/catalog/collection.cpp
index 3dbb2ad5a9..9b9df921bf 100644
--- a/src/mongo/db/catalog/collection.cpp
+++ b/src/mongo/db/catalog/collection.cpp
@@ -478,7 +478,7 @@ namespace mongo {
         if ( !status.isOK() )
             return status;
         _cursorCache.invalidateAll( false );
-        _infoCache.reset();
+        _infoCache.reset( txn );
 
         // 3) truncate record store
         status = _recordStore->truncate(txn);
diff --git a/src/mongo/db/catalog/collection_compact.cpp b/src/mongo/db/catalog/collection_compact.cpp
index c03de80733..8441716149 100644
--- a/src/mongo/db/catalog/collection_compact.cpp
+++ b/src/mongo/db/catalog/collection_compact.cpp
@@ -112,7 +112,7 @@ namespace mongo {
 
 
         // same data, but might perform a little different after compact?
-        _infoCache.reset();
+        _infoCache.reset( txn );
 
         vector<BSONObj> indexSpecs;
         {
diff --git a/src/mongo/db/catalog/collection_info_cache.cpp b/src/mongo/db/catalog/collection_info_cache.cpp
index d9783b6db0..9797e16104 100644
--- a/src/mongo/db/catalog/collection_info_cache.cpp
+++ b/src/mongo/db/catalog/collection_info_cache.cpp
@@ -52,10 +52,11 @@ namespace mongo {
           _planCache(new PlanCache(collection->ns().ns())),
           _querySettings(new QuerySettings()) { }
 
-    void CollectionInfoCache::reset() {
+    void CollectionInfoCache::reset( OperationContext* txn ) {
         LOG(1) << _collection->ns().ns() << ": clearing plan cache - collection info cache reset";
         clearQueryCache();
         _keysComputed = false;
+        computeIndexKeys( txn );
         // query settings is not affected by info cache reset.
         // index filters should persist throughout life of collection
     }
diff --git a/src/mongo/db/catalog/collection_info_cache.h b/src/mongo/db/catalog/collection_info_cache.h
index 092d436b2c..c4405dd5fe 100644
--- a/src/mongo/db/catalog/collection_info_cache.h
+++ b/src/mongo/db/catalog/collection_info_cache.h
@@ -52,7 +52,7 @@ namespace mongo {
         /*
          * Resets entire cache state. Must be called under exclusive DB lock.
          */
-        void reset();
+        void reset( OperationContext* txn );
 
         //
         // New Query Execution
@@ -84,7 +84,7 @@ namespace mongo {
         /**
          * Called when an index is added to this collection.
          */
-        void addedIndex() { reset(); }
+        void addedIndex( OperationContext* txn ) { reset( txn ); }
 
         void clearQueryCache();
 
diff --git a/src/mongo/db/catalog/index_catalog.cpp b/src/mongo/db/catalog/index_catalog.cpp
index e3a72d7ebd..591bf9cc2b 100644
--- a/src/mongo/db/catalog/index_catalog.cpp
+++ b/src/mongo/db/catalog/index_catalog.cpp
@@ -279,10 +279,12 @@ namespace {
         /**
          * None of these pointers are owned by this class.
          */
-        IndexCleanupOnRollback(Collection* collection,
+        IndexCleanupOnRollback(OperationContext* txn,
+                               Collection* collection,
                                IndexCatalogEntryContainer* entries,
                                const IndexDescriptor* desc)
-            : _collection(collection),
+            : _txn(txn),
+              _collection(collection),
               _entries(entries),
               _desc(desc) {
         }
@@ -291,10 +293,11 @@ namespace {
 
         virtual void rollback() {
             _entries->remove(_desc);
-            _collection->infoCache()->reset();
+            _collection->infoCache()->reset(_txn);
         }
 
     private:
+        OperationContext* _txn;
         Collection* _collection;
         IndexCatalogEntryContainer* _entries;
         const IndexDescriptor* _desc;
@@ -302,10 +305,12 @@ namespace {
 
     class IndexRemoveChange : public RecoveryUnit::Change {
     public:
-        IndexRemoveChange(Collection* collection,
-                               IndexCatalogEntryContainer* entries,
-                               IndexCatalogEntry* entry)
-            : _collection(collection),
+        IndexRemoveChange(OperationContext* txn,
+                          Collection* collection,
+                          IndexCatalogEntryContainer* entries,
+                          IndexCatalogEntry* entry)
+            : _txn(txn),
+              _collection(collection),
               _entries(entries),
               _entry(entry) {
         }
@@ -316,10 +321,11 @@ namespace {
 
         virtual void rollback() {
             _entries->add(_entry);
-            _collection->infoCache()->reset();
+            _collection->infoCache()->reset(_txn);
         }
 
     private:
+        OperationContext* _txn;
         Collection* _collection;
         IndexCatalogEntryContainer* _entries;
         IndexCatalogEntry* _entry;
@@ -365,7 +371,8 @@ namespace {
         if (!status.isOK())
             return status;
 
-        txn->recoveryUnit()->registerChange(new IndexCleanupOnRollback(_collection,
+        txn->recoveryUnit()->registerChange(new IndexCleanupOnRollback(txn,
+                                                                       _collection,
                                                                        &_entries,
                                                                        entry->descriptor()));
         indexBuildBlock.success();
@@ -473,7 +480,7 @@ namespace {
 
         _catalog->_collection->getCatalogEntry()->indexBuildSuccess( _txn, _indexName );
 
-        _catalog->_collection->infoCache()->addedIndex();
+        _catalog->_collection->infoCache()->addedIndex( _txn );
 
         IndexDescriptor* desc = _catalog->findIndexByName( _txn, _indexName, true );
         fassert( 17330, desc );
@@ -767,7 +774,7 @@ namespace {
         _collection->cursorCache()->invalidateAll( false );
 
         // wipe out stats
-        _collection->infoCache()->reset();
+        _collection->infoCache()->reset(txn);
 
         string indexNamespace = entry->descriptor()->indexNamespace();
         string indexName = entry->descriptor()->indexName();
@@ -777,7 +784,8 @@ namespace {
         audit::logDropIndex( currentClient.get(), indexName, _collection->ns().ns() );
 
         invariant(_entries.release(entry->descriptor()) == entry);
-        txn->recoveryUnit()->registerChange(new IndexRemoveChange(_collection, &_entries, entry));
+        txn->recoveryUnit()->registerChange(new IndexRemoveChange(txn, _collection,
+                                                                  &_entries, entry));
         entry = NULL;
 
         try {
diff --git a/src/mongo/db/catalog/index_create.cpp b/src/mongo/db/catalog/index_create.cpp
index 9c3f576b81..6f6146bce1 100644
--- a/src/mongo/db/catalog/index_create.cpp
+++ b/src/mongo/db/catalog/index_create.cpp
@@ -181,7 +181,7 @@ namespace mongo {
 
         // this is so that operations examining the list of indexes know there are more keys to look
         // at when doing things like in place updates, etc...
-        _collection->infoCache()->addedIndex();
+        _collection->infoCache()->addedIndex(_txn);
 
         if (_buildInBackground)
             _backgroundOperation.reset(new BackgroundOperation(ns));
@@ -293,7 +293,7 @@ namespace mongo {
         }
 
         // this one is so operations examining the list of indexes know that the index is finished
-        _collection->infoCache()->addedIndex();
+        _collection->infoCache()->addedIndex(_txn);
 
         _txn->recoveryUnit()->registerChange(new SetNeedToCleanupOnRollback(this));
         _needToCleanup = false;

