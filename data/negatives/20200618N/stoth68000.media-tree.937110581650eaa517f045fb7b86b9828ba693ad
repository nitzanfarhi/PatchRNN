commit 937110581650eaa517f045fb7b86b9828ba693ad
Author: Stephen Hemminger <stephen.hemminger@vyatta.com>
Date:   Sun Oct 31 23:55:21 2010 -0400

    beceem: support multiple queues
    
    Current kernels have multi-queue support which can be used by
    this device. This has the advantage that a single type of traffic
    will not block other types.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>

diff --git a/drivers/staging/bcm/Bcmnet.c b/drivers/staging/bcm/Bcmnet.c
index e3575ad65e91..5b466174a580 100644
--- a/drivers/staging/bcm/Bcmnet.c
+++ b/drivers/staging/bcm/Bcmnet.c
@@ -54,6 +54,71 @@ static struct net_device_stats *bcm_get_stats(struct net_device *dev)
 	return netstats;
 }
 
+static u16 bcm_select_queue(struct net_device *dev, struct sk_buff *skb)
+{
+	return ClassifyPacket(netdev_priv(dev), skb);
+}
+
+
+/*******************************************************************
+* Function    -	bcm_transmit()
+*
+* Description - This is the main transmit function for our virtual
+*				interface(eth0). It handles the ARP packets. It
+*				clones this packet and then Queue it to a suitable
+* 		 		Queue. Then calls the transmit_packet().
+*
+* Parameter   -	 skb - Pointer to the socket buffer structure
+*				 dev - Pointer to the virtual net device structure
+*
+*********************************************************************/
+
+static netdev_tx_t bcm_transmit(struct sk_buff *skb, struct net_device *dev)
+{
+	PMINI_ADAPTER      Adapter = GET_BCM_ADAPTER(dev);
+	u16 qindex = skb_get_queue_mapping(skb);
+
+	if (Adapter->device_removed || !Adapter->LinkUpStatus)
+		goto drop;
+
+	if (Adapter->TransferMode != IP_PACKET_ONLY_MODE )
+		goto drop;
+
+	if (INVALID_QUEUE_INDEX==qindex)
+		goto drop;
+
+	if (Adapter->PackInfo[qindex].uiCurrentPacketsOnHost >= SF_MAX_ALLOWED_PACKETS_TO_BACKUP)
+		return NETDEV_TX_BUSY;
+
+	/* Now Enqueue the packet */
+	BCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, NEXT_SEND, DBG_LVL_ALL,
+			"bcm_transmit Enqueueing the Packet To Queue %d",qindex);
+	spin_lock(&Adapter->PackInfo[qindex].SFQueueLock);
+	Adapter->PackInfo[qindex].uiCurrentBytesOnHost += skb->len;
+	Adapter->PackInfo[qindex].uiCurrentPacketsOnHost++;
+
+	*((B_UINT32 *)skb->cb + SKB_CB_LATENCY_OFFSET ) = jiffies;
+	ENQUEUEPACKET(Adapter->PackInfo[qindex].FirstTxQueue,
+		      Adapter->PackInfo[qindex].LastTxQueue, skb);
+	atomic_inc(&Adapter->TotalPacketCount);
+	spin_unlock(&Adapter->PackInfo[qindex].SFQueueLock);
+
+	BCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_OSAL_DBG, DBG_LVL_ALL,"ENQ: \n");
+
+	/* FIXME - this is racy and incorrect, replace with work queue */
+	if (!atomic_read(&Adapter->TxPktAvail)) {
+		atomic_set(&Adapter->TxPktAvail, 1);
+		wake_up(&Adapter->tx_packet_wait_queue);
+	}
+	return NETDEV_TX_OK;
+
+ drop:
+	dev_kfree_skb(skb);
+	return NETDEV_TX_OK;
+}
+
+
+
 /**
 @ingroup init_functions
 Register other driver entry points with the kernel
@@ -66,6 +131,7 @@ static const struct net_device_ops bcmNetDevOps = {
     .ndo_change_mtu	= eth_change_mtu,
     .ndo_set_mac_address = eth_mac_addr,
     .ndo_validate_addr	= eth_validate_addr,
+    .ndo_select_queue	= bcm_select_queue,
 };
 
 static struct device_type wimax_type = {
diff --git a/drivers/staging/bcm/InterfaceInit.c b/drivers/staging/bcm/InterfaceInit.c
index 14866e9c8cd2..845ced1670ee 100644
--- a/drivers/staging/bcm/InterfaceInit.c
+++ b/drivers/staging/bcm/InterfaceInit.c
@@ -188,7 +188,7 @@ usbbcm_device_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	PS_INTERFACE_ADAPTER psIntfAdapter;
 	struct net_device *ndev;
 
-	ndev = alloc_etherdev(sizeof(MINI_ADAPTER));
+	ndev = alloc_etherdev_mq(sizeof(MINI_ADAPTER), NO_OF_QUEUES);
 	if(ndev == NULL) {
 		dev_err(&udev->dev, DRV_NAME ": no memory for device\n");
 		return -ENOMEM;
diff --git a/drivers/staging/bcm/Prototypes.h b/drivers/staging/bcm/Prototypes.h
index 8ca6b9eb4e34..a4b57bb07fa1 100644
--- a/drivers/staging/bcm/Prototypes.h
+++ b/drivers/staging/bcm/Prototypes.h
@@ -46,13 +46,12 @@ VOID PruneQueueAllSF(PMINI_ADAPTER Adapter);
 
 INT SearchSfid(PMINI_ADAPTER Adapter,UINT uiSfid);
 
-USHORT GetPacketQueueIndex(PMINI_ADAPTER Adapter, /**<Pointer to the driver control structure */
-								struct sk_buff* Packet /**< Pointer to the Packet to be sent*/
-								);
+USHORT ClassifyPacket(PMINI_ADAPTER Adapter,struct sk_buff* skb);
+
+BOOLEAN MatchSrcPort(S_CLASSIFIER_RULE *pstClassifierRule,USHORT ushSrcPort);
+BOOLEAN MatchDestPort(S_CLASSIFIER_RULE *pstClassifierRule,USHORT ushSrcPort);
+BOOLEAN MatchProtocol(S_CLASSIFIER_RULE *pstClassifierRule,UCHAR ucProtocol);
 
-VOID
-reply_to_arp_request(struct sk_buff *skb  /**<sk_buff of ARP request*/
-						);
 
 INT SetupNextSend(PMINI_ADAPTER Adapter, /**<Logical Adapter*/
 					struct sk_buff *Packet, /**<data buffer*/
@@ -66,9 +65,6 @@ INT SendControlPacket(PMINI_ADAPTER Adapter, /**<Logical Adapter*/
 							char *pControlPacket/**<Control Packet*/
 							);
 
-INT bcm_transmit(struct sk_buff *skb, 		/**< skb */
-					struct net_device *dev 	/**< net device pointer */
-					);
 
 int register_networkdev(PMINI_ADAPTER Adapter);
 
diff --git a/drivers/staging/bcm/Qos.c b/drivers/staging/bcm/Qos.c
index 6e4064629046..f85a5a85ad5c 100644
--- a/drivers/staging/bcm/Qos.c
+++ b/drivers/staging/bcm/Qos.c
@@ -4,13 +4,6 @@ This file contains the routines related to Quality of Service.
 */
 #include "headers.h"
 
-BOOLEAN MatchSrcIpAddress(S_CLASSIFIER_RULE *pstClassifierRule,ULONG ulSrcIP);
-BOOLEAN MatchTos(S_CLASSIFIER_RULE *pstClassifierRule,UCHAR ucTypeOfService);
-BOOLEAN MatchSrcPort(S_CLASSIFIER_RULE *pstClassifierRule,USHORT ushSrcPort);
-BOOLEAN MatchDestPort(S_CLASSIFIER_RULE *pstClassifierRule,USHORT ushDestPort);
-BOOLEAN MatchProtocol(S_CLASSIFIER_RULE *pstClassifierRule,UCHAR ucProtocol);
-BOOLEAN MatchDestIpAddress(S_CLASSIFIER_RULE *pstClassifierRule,ULONG ulDestIP);
-USHORT ClassifyPacket(PMINI_ADAPTER Adapter,struct sk_buff* skb);
 void EThCSGetPktInfo(PMINI_ADAPTER Adapter,PVOID pvEthPayload,PS_ETHCS_PKT_INFO pstEthCsPktInfo);
 BOOLEAN EThCSClassifyPkt(PMINI_ADAPTER Adapter,struct sk_buff* skb,PS_ETHCS_PKT_INFO pstEthCsPktInfo,S_CLASSIFIER_RULE *pstClassifierRule, B_UINT8 EthCSCupport);
 
@@ -312,29 +305,6 @@ USHORT	IpVersion4(PMINI_ADAPTER Adapter, /**< Pointer to the driver control stru
 
 	return bClassificationSucceed;
 }
-/**
-@ingroup tx_functions
-@return  Queue Index based on priority.
-*/
-USHORT GetPacketQueueIndex(PMINI_ADAPTER Adapter, /**<Pointer to the driver control structure */
-								struct sk_buff* Packet /**< Pointer to the Packet to be sent*/
-								)
-{
-	USHORT			usIndex=-1;
-	BCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, QUEUE_INDEX, DBG_LVL_ALL, "=====>");
-
-	if(NULL==Adapter || NULL==Packet)
-	{
-		BCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, QUEUE_INDEX, DBG_LVL_ALL, "Got NULL Values<======");
-		return -1;
-	}
-
-	usIndex = ClassifyPacket(Adapter,Packet);
-
-	BCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, QUEUE_INDEX, DBG_LVL_ALL, "Got Queue Index %x",usIndex);
-	BCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, QUEUE_INDEX, DBG_LVL_ALL, "GetPacketQueueIndex <==============");
-	return usIndex;
-}
 
 VOID PruneQueueAllSF(PMINI_ADAPTER Adapter)
 {
diff --git a/drivers/staging/bcm/Transmit.c b/drivers/staging/bcm/Transmit.c
index 4b94d822578c..734bbbd14e22 100644
--- a/drivers/staging/bcm/Transmit.c
+++ b/drivers/staging/bcm/Transmit.c
@@ -35,67 +35,6 @@ SendPacketFromQueue->SetupNextSend->bcm_cmd53
 
 #include "headers.h"
 
-/*******************************************************************
-* Function    -	bcm_transmit()
-*
-* Description - This is the main transmit function for our virtual
-*				interface(eth0). It handles the ARP packets. It
-*				clones this packet and then Queue it to a suitable
-* 		 		Queue. Then calls the transmit_packet().
-*
-* Parameter   -	 skb - Pointer to the socket buffer structure
-*				 dev - Pointer to the virtual net device structure
-*
-* Returns     -	 zero (success) or -ve value (failure)
-*
-*********************************************************************/
-
-netdev_tx_t bcm_transmit(struct sk_buff *skb, struct net_device *dev)
-{
-	PMINI_ADAPTER      	Adapter = GET_BCM_ADAPTER(dev);
-	SHORT qindex;
-
-	if (Adapter->device_removed || !Adapter->LinkUpStatus)
-		goto drop;
-
-	if (Adapter->TransferMode != IP_PACKET_ONLY_MODE )
-		goto drop;
-
-	qindex = GetPacketQueueIndex(Adapter, skb);
-
-	if (INVALID_QUEUE_INDEX==qindex)
-		goto drop;
-
-	if (Adapter->PackInfo[qindex].uiCurrentPacketsOnHost >= SF_MAX_ALLOWED_PACKETS_TO_BACKUP)
-		return NETDEV_TX_BUSY;
-
-	/* Now Enqueue the packet */
-	BCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, NEXT_SEND, DBG_LVL_ALL,
-			"bcm_transmit Enqueueing the Packet To Queue %d",qindex);
-	spin_lock(&Adapter->PackInfo[qindex].SFQueueLock);
-	Adapter->PackInfo[qindex].uiCurrentBytesOnHost += skb->len;
-	Adapter->PackInfo[qindex].uiCurrentPacketsOnHost++;
-
-	*((B_UINT32 *)skb->cb + SKB_CB_LATENCY_OFFSET ) = jiffies;
-	ENQUEUEPACKET(Adapter->PackInfo[qindex].FirstTxQueue,
-		      Adapter->PackInfo[qindex].LastTxQueue, skb);
-	atomic_inc(&Adapter->TotalPacketCount);
-	spin_unlock(&Adapter->PackInfo[qindex].SFQueueLock);
-
-	BCM_DEBUG_PRINT(Adapter,DBG_TYPE_TX, TX_OSAL_DBG, DBG_LVL_ALL,"ENQ: \n");
-
-	/* FIXME - this is racy and incorrect, replace with work queue */
-	if (!atomic_read(&Adapter->TxPktAvail)) {
-		atomic_set(&Adapter->TxPktAvail, 1);
-		wake_up(&Adapter->tx_packet_wait_queue);
-	}
-	return NETDEV_TX_OK;
-
- drop:
-	dev_kfree_skb(skb);
-	return NETDEV_TX_OK;
-}
-
 
 /**
 @ingroup ctrl_pkt_functions

