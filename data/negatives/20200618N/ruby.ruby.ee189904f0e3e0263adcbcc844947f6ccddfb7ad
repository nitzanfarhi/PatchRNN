commit ee189904f0e3e0263adcbcc844947f6ccddfb7ad
Author: ko1 <ko1@b2dd03c8-39d4-4d8f-98ff-823fe69b080e>
Date:   Tue Nov 7 05:12:39 2017 +0000

    rename to rb_ec_set_raised().
    
    * thread.c (rb_threadptr_set_raised): rename to rb_ec_set_raised
      and accepts `ec`
    
    
    git-svn-id: svn+ssh://ci.ruby-lang.org/ruby/trunk@60683 b2dd03c8-39d4-4d8f-98ff-823fe69b080e

diff --git a/eval.c b/eval.c
index 49411ddd32..76df7370fb 100644
--- a/eval.c
+++ b/eval.c
@@ -509,7 +509,7 @@ setup_exception(rb_execution_context_t *ec, int tag, volatile VALUE mesg, VALUE
 	volatile int state = 0;
 
 	EC_PUSH_TAG(ec);
-	if (EXEC_TAG() == TAG_NONE && !(state = rb_threadptr_set_raised(rb_ec_thread_ptr(ec)))) {
+	if (EXEC_TAG() == TAG_NONE && !(state = rb_ec_set_raised(ec))) {
 	    VALUE bt = rb_get_backtrace(mesg);
 	    if (!NIL_P(bt) || cause == Qundef) {
 		if (OBJ_FROZEN(mesg)) {
@@ -568,7 +568,7 @@ setup_exception(rb_execution_context_t *ec, int tag, volatile VALUE mesg, VALUE
 	}
     }
 
-    if (rb_threadptr_set_raised(rb_ec_thread_ptr(ec))) {
+    if (rb_ec_set_raised(ec)) {
       fatal:
 	ec->errinfo = exception_error;
 	rb_ec_reset_raised(ec);
diff --git a/eval_error.c b/eval_error.c
index ed2e43facc..cd4e703e66 100644
--- a/eval_error.c
+++ b/eval_error.c
@@ -271,7 +271,7 @@ error_handle(int ex)
     int status = EXIT_FAILURE;
     rb_execution_context_t *ec = GET_EC();
 
-    if (rb_threadptr_set_raised(rb_ec_thread_ptr(ec)))
+    if (rb_ec_set_raised(ec))
 	return EXIT_FAILURE;
     switch (ex & TAG_MASK) {
       case 0:
diff --git a/eval_intern.h b/eval_intern.h
index e9b9ba0b14..ed94921da6 100644
--- a/eval_intern.h
+++ b/eval_intern.h
@@ -280,11 +280,11 @@ enum {
     RAISED_STACKOVERFLOW = 2,
     RAISED_NOMEMORY = 4
 };
-int rb_threadptr_set_raised(rb_thread_t *th);
 #define rb_thread_raised_set(th, f)   ((th)->ec->raised_flag |= (f))
 #define rb_thread_raised_reset(th, f) ((th)->ec->raised_flag &= ~(f))
 #define rb_thread_raised_p(th, f)     (((th)->ec->raised_flag & (f)) != 0)
 #define rb_thread_raised_clear(th)    ((th)->ec->raised_flag = 0)
+int rb_ec_set_raised(rb_execution_context_t *ec);
 int rb_ec_reset_raised(rb_execution_context_t *th);
 int rb_ec_stack_check(rb_execution_context_t *ec);
 
diff --git a/thread.c b/thread.c
index 5084e9789e..642d48f81c 100644
--- a/thread.c
+++ b/thread.c
@@ -2167,12 +2167,12 @@ rb_threadptr_signal_exit(rb_thread_t *th)
 #endif
 
 int
-rb_threadptr_set_raised(rb_thread_t *th)
+rb_ec_set_raised(rb_execution_context_t *ec)
 {
-    if (th->ec->raised_flag & RAISED_EXCEPTION) {
+    if (ec->raised_flag & RAISED_EXCEPTION) {
 	return 1;
     }
-    th->ec->raised_flag |= RAISED_EXCEPTION;
+    ec->raised_flag |= RAISED_EXCEPTION;
     return 0;
 }
 
diff --git a/vm_trace.c b/vm_trace.c
index bdf0b83057..f26808fa63 100644
--- a/vm_trace.c
+++ b/vm_trace.c
@@ -292,7 +292,7 @@ exec_hooks_protected(rb_execution_context_t *ec, rb_hook_list_t *list, const rb_
     EC_POP_TAG();
 
     if (raised) {
-	rb_threadptr_set_raised(rb_ec_thread_ptr(ec));
+	rb_ec_set_raised(ec);
     }
 
     return state;

