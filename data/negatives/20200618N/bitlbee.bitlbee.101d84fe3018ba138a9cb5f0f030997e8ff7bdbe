commit 101d84fe3018ba138a9cb5f0f030997e8ff7bdbe
Author: Wilmer van der Gaast <wilmer@gaast.net>
Date:   Fri Oct 6 00:55:54 2006 +0200

    Added max. recursion depth arguments to xt_handle()/_cleanup() to make sure
    commands that still have to be handled don't get (partially) cleaned up
    already.

diff --git a/protocols/jabber/io.c b/protocols/jabber/io.c
index 88ebf5d9..04b98626 100644
--- a/protocols/jabber/io.c
+++ b/protocols/jabber/io.c
@@ -169,7 +169,7 @@ static gboolean jabber_read_callback( gpointer data, gint fd, b_input_condition
 		}
 		
 		/* Execute all handlers. */
-		if( !xt_handle( jd->xt, NULL ) )
+		if( !xt_handle( jd->xt, NULL, 1 ) )
 		{
 			/* Don't do anything, the handlers should have
 			   aborted the connection already... Or not? FIXME */
@@ -183,7 +183,7 @@ static gboolean jabber_read_callback( gpointer data, gint fd, b_input_condition
 		}
 		
 		/* Garbage collection. */
-		xt_cleanup( jd->xt, NULL );
+		xt_cleanup( jd->xt, NULL, 1 );
 		
 		/* This is a bit hackish, unfortunately. Although xmltree
 		   has nifty event handler stuff, it only calls handlers
diff --git a/protocols/jabber/xmltree.c b/protocols/jabber/xmltree.c
index da316f99..d4063476 100644
--- a/protocols/jabber/xmltree.c
+++ b/protocols/jabber/xmltree.c
@@ -151,20 +151,24 @@ int xt_feed( struct xt_parser *xt, char *text, int text_len )
 
 /* Find completed nodes and see if a handler has to be called. Passing
    a node isn't necessary if you want to start at the root, just pass
-   NULL. This second argument is needed for recursive calls. FIXME: Retval? */
-int xt_handle( struct xt_parser *xt, struct xt_node *node )
+   NULL. This second argument is needed for recursive calls. */
+int xt_handle( struct xt_parser *xt, struct xt_node *node, int depth )
 {
 	struct xt_node *c;
 	xt_status st;
 	int i;
 	
-	/* Let's just hope xt->root isn't NULL! */
+	/* Just in case someone likes infinite loops... */
+	if( xt->root == NULL )
+		return 0;
+	
 	if( node == NULL )
-		return xt_handle( xt, xt->root );
+		return xt_handle( xt, xt->root, depth );
 	
-	for( c = node->children; c; c = c->next )
-		if( !xt_handle( xt, c ) )
-			return 0;
+	if( depth != 0 )
+		for( c = node->children; c; c = c->next )
+			if( !xt_handle( xt, c, depth > 0 ? depth - 1 : depth ) )
+				return 0;
 	
 	if( node->flags & XT_COMPLETE && !( node->flags & XT_SEEN ) )
 	{
@@ -201,7 +205,7 @@ int xt_handle( struct xt_parser *xt, struct xt_node *node )
 /* Garbage collection: Cleans up all nodes that are handled. Useful for
    streams because there's no reason to keep a complete packet history
    in memory. */
-void xt_cleanup( struct xt_parser *xt, struct xt_node *node )
+void xt_cleanup( struct xt_parser *xt, struct xt_node *node, int depth )
 {
 	struct xt_node *c, *prev;
 	
@@ -209,7 +213,7 @@ void xt_cleanup( struct xt_parser *xt, struct xt_node *node )
 		return;
 	
 	if( node == NULL )
-		return xt_cleanup( xt, xt->root );
+		return xt_cleanup( xt, xt->root, depth );
 	
 	if( node->flags & XT_SEEN && node == xt->root )
 	{
@@ -245,7 +249,8 @@ void xt_cleanup( struct xt_parser *xt, struct xt_node *node )
 		{
 			/* This node can't be cleaned up yet, but maybe a
 			   subnode can. */
-			xt_cleanup( xt, c );
+			if( depth != 0 )
+				xt_cleanup( xt, c, depth > 0 ? depth - 1 : depth );
 		}
 	}
 }
diff --git a/protocols/jabber/xmltree.h b/protocols/jabber/xmltree.h
index 55030d83..4abb094f 100644
--- a/protocols/jabber/xmltree.h
+++ b/protocols/jabber/xmltree.h
@@ -79,8 +79,8 @@ struct xt_parser
 struct xt_parser *xt_new( gpointer data );
 void xt_reset( struct xt_parser *xt );
 int xt_feed( struct xt_parser *xt, char *text, int text_len );
-int xt_handle( struct xt_parser *xt, struct xt_node *node );
-void xt_cleanup( struct xt_parser *xt, struct xt_node *node );
+int xt_handle( struct xt_parser *xt, struct xt_node *node, int depth );
+void xt_cleanup( struct xt_parser *xt, struct xt_node *node, int depth );
 char *xt_to_string( struct xt_node *node );
 void xt_print( struct xt_node *node );
 struct xt_node *xt_dup( struct xt_node *node );

