commit b2d8514c720ebb89d709b57522951f2960ca9432
Author: Ilya V. Matveychikov <matvejchikov@gmail.com>
Date:   Thu Feb 6 00:08:46 2014 +0400

    Add support for setting cpu value for anal module
    
    Now, anal has it's own `anal.cpu` config value. It can be used to
    support multiple CPUs handled by one analysis module.

diff --git a/libr/anal/anal.c b/libr/anal/anal.c
index f229dd271..999e3ac50 100644
--- a/libr/anal/anal.c
+++ b/libr/anal/anal.c
@@ -47,6 +47,7 @@ R_API RAnal *r_anal_new() {
 	RAnal *anal = R_NEW0 (RAnal);
 	if (!anal) return NULL;
 	memset (anal, 0, sizeof (RAnal));
+	anal->cpu = NULL;
 	anal->decode = R_TRUE; // slow slow if not used
 	anal->sdb_xrefs = NULL;
 	anal->sdb_types = sdb_new (NULL, NULL, 0);
@@ -90,6 +91,7 @@ R_API RAnal *r_anal_new() {
 R_API void r_anal_free(RAnal *anal) {
 	if (!anal) return;
 	/* TODO: Free anals here */
+	free(anal->cpu);
 	anal->fcns->free = r_anal_fcn_free;
 	r_list_free (anal->fcns);
 	// r_listrange_free (anal->fcnstore); // might provoke double frees since this is used in r_anal_fcn_insert()
@@ -157,6 +159,11 @@ R_API int r_anal_set_bits(RAnal *anal, int bits) {
 	return R_FALSE;
 }
 
+R_API void r_anal_set_cpu(RAnal *anal, const char *cpu) {
+	free(anal->cpu);
+	anal->cpu = cpu ? strdup(cpu) : NULL;
+}
+
 R_API int r_anal_set_big_endian(RAnal *anal, int bigend) {
 	anal->big_endian = bigend;
 	return R_TRUE;
diff --git a/libr/core/config.c b/libr/core/config.c
index 401b30200..794bd37ba 100644
--- a/libr/core/config.c
+++ b/libr/core/config.c
@@ -86,7 +86,7 @@ static int asm_profile(RConfig *cfg, const char *profile) {
 	return R_TRUE;
 }
 
-static int cb_analplugin(void *user, void *data) {
+static int cb_analarch(void *user, void *data) {
 	RCore *core = (RCore*) user;
 	RConfigNode *node = (RConfigNode*) data;
 	if (*node->value == '?') {
@@ -101,6 +101,13 @@ static int cb_analplugin(void *user, void *data) {
 	return R_TRUE;
 }
 
+static int cb_analcpu(void *user, void *data) {
+	RCore *core = (RCore *) user;
+	RConfigNode *node = (RConfigNode *) data;
+	r_anal_set_cpu (core->anal, node->value);
+	return R_TRUE;
+}
+
 static int cb_analsplit(void *user, void *data) {
 	RCore *core = (RCore*) user;
 	RConfigNode *node = (RConfigNode*) data;
@@ -586,7 +593,8 @@ R_API int r_core_config_init(RCore *core) {
 	/* anal */
 	SETI("anal.depth", 50, "Max depth at code analysis"); // XXX: warn if depth is > 50 .. can be problematic
 	SETPREF("anal.hasnext", "true", "Continue analysis after each function");
-	SETCB("anal.arch", R_SYS_ARCH, &cb_analplugin, "Specify the anal.arch to use");
+	SETCB("anal.arch", R_SYS_ARCH, &cb_analarch, "Specify the anal.arch to use");
+	SETCB("anal.cpu", R_SYS_ARCH, &cb_analcpu, "Specify the anal.cpu to use");
 	SETPREF("anal.prelude", "", "Specify an hexpair to find preludes in code");
 	SETCB("anal.split", "true", &cb_analsplit, "Split functions into basic blocks in analysis.");
 	SETI("anal.ptrdepth", 3, "Maximum number of nested pointers to follow in analysis");
diff --git a/libr/include/r_anal.h b/libr/include/r_anal.h
index ebfccaa7d..1fe7bf3da 100644
--- a/libr/include/r_anal.h
+++ b/libr/include/r_anal.h
@@ -523,6 +523,7 @@ typedef struct r_anal_switch_obj_t {
 } RAnalSwitchOp;
 
 typedef struct r_anal_t {
+	char *cpu;
 	int bits;
 	int lineswidth; // wtf
 	int big_endian;
@@ -857,6 +858,7 @@ R_API int r_anal_list(RAnal *anal);
 R_API int r_anal_use(RAnal *anal, const char *name);
 R_API int r_anal_set_reg_profile(RAnal *anal);
 R_API int r_anal_set_bits(RAnal *anal, int bits);
+R_API void r_anal_set_cpu(RAnal *anal, const char *cpu);
 R_API int r_anal_set_big_endian(RAnal *anal, int boolean);
 R_API char *r_anal_strmask (RAnal *anal, const char *data);
 R_API void r_anal_trace_bb(RAnal *anal, ut64 addr);

