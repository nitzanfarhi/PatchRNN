commit 07247649496653b0ece32ce7ea710057f85fa9da
Author: Madhavan Venkataraman <Madhavan.Venkataraman@Sun.COM>
Date:   Sat Mar 14 09:09:41 2009 -0700

    6811269 The clock tick accounting code uses softints wrongly
    6802283 hang in delay() called from glm during boot
    6810916 sparc system repeatedly hangs doing mpt tasks
    6811294 APIs like nanosleep() wakeup prematurely when system time is changed
    6809548 assertion failure expiration > 0 in callout.c

diff --git a/usr/src/cmd/mdb/common/modules/genunix/genunix.c b/usr/src/cmd/mdb/common/modules/genunix/genunix.c
index 631973b558..eab107669c 100644
--- a/usr/src/cmd/mdb/common/modules/genunix/genunix.c
+++ b/usr/src/cmd/mdb/common/modules/genunix/genunix.c
@@ -649,7 +649,7 @@ callout_table_walk_fini(mdb_walk_state_t *wsp)
 
 static const char *co_typenames[] = { "R", "N" };
 
-#define	CO_PLAIN_ID(xid)	 ((xid) & ~CALLOUT_EXECUTING)
+#define	CO_PLAIN_ID(xid)	((xid) & CALLOUT_ID_MASK)
 
 #define	TABLE_TO_SEQID(x)	((x) >> CALLOUT_TYPE_BITS)
 
@@ -667,7 +667,7 @@ static const char *co_typenames[] = { "R", "N" };
 #define	COF_ADDR	0x0000400
 #define	COF_EXEC	0x0000800
 #define	COF_HIRES	0x0001000
-/* 0x0002000 reserved for future flags */
+#define	COF_ABS		0x0002000
 #define	COF_TABLE	0x0004000
 #define	COF_BYIDH	0x0008000
 #define	COF_FREE	0x0010000
@@ -702,6 +702,7 @@ typedef struct callout_data {
 	int ndx;		/* table index. */
 	int bucket;		/* which list/id bucket are we in */
 	hrtime_t exp;		/* expire time */
+	int list_flags;		/* copy of cl_flags */
 } callout_data_t;
 
 /* this callback does the actual callback itself (finally). */
@@ -726,7 +727,6 @@ callouts_cb(uintptr_t addr, const void *data, void *priv)
 	    (coargs->param != (uintptr_t)co->c_arg)) {
 		return (WALK_NEXT);
 	}
-
 	if (!(coargs->flags & COF_LONG) && (co->c_xid & CALLOUT_LONGTERM)) {
 		return (WALK_NEXT);
 	}
@@ -736,9 +736,6 @@ callouts_cb(uintptr_t addr, const void *data, void *priv)
 	if ((coargs->flags & COF_EXEC) && !(co->c_xid & CALLOUT_EXECUTING)) {
 		return (WALK_NEXT);
 	}
-	if ((coargs->flags & COF_HIRES) && !(co->c_xid & CALLOUT_HRESTIME)) {
-		return (WALK_NEXT);
-	}
 
 	/* it is possible we don't have the exp time */
 	if (coargs->flags & COF_BYIDH) {
@@ -751,9 +748,50 @@ callouts_cb(uintptr_t addr, const void *data, void *priv)
 				    "time from %p", co->c_list);
 				coargs->exp = 0;
 			}
+			/* and flags. */
+			if (mdb_vread(&coargs->list_flags, sizeof (int),
+			    (uintptr_t)co->c_list + offsetof(callout_list_t,
+			    cl_flags)) == -1) {
+				mdb_warn("failed to read list flags"
+				    "from %p", co->c_list);
+				coargs->list_flags = 0;
+			}
 		} else {
 			/* free callouts can't use list pointer. */
 			coargs->exp = 0;
+			coargs->list_flags = 0;
+		}
+		if (coargs->exp != 0) {
+			if ((coargs->flags & COF_TIME) &&
+			    (coargs->exp != coargs->time)) {
+				return (WALK_NEXT);
+			}
+			if ((coargs->flags & COF_BEFORE) &&
+			    (coargs->exp > coargs->btime)) {
+				return (WALK_NEXT);
+			}
+			if ((coargs->flags & COF_AFTER) &&
+			    (coargs->exp < coargs->atime)) {
+				return (WALK_NEXT);
+			}
+		}
+		/* tricky part, since both HIRES and ABS can be set */
+		if ((coargs->flags & COF_HIRES) && (coargs->flags & COF_ABS)) {
+			/* both flags are set, only skip "regular" ones */
+			if (! (coargs->list_flags &
+			    (CALLOUT_FLAG_HRESTIME | CALLOUT_FLAG_ABSOLUTE))) {
+				return (WALK_NEXT);
+			}
+		} else {
+			/* individual flags, or no flags */
+			if ((coargs->flags & COF_HIRES) &&
+			    !(coargs->list_flags & CALLOUT_FLAG_HRESTIME)) {
+				return (WALK_NEXT);
+			}
+			if ((coargs->flags & COF_ABS) &&
+			    !(coargs->list_flags & CALLOUT_FLAG_ABSOLUTE)) {
+				return (WALK_NEXT);
+			}
 		}
 	}
 
@@ -774,11 +812,13 @@ callouts_cb(uintptr_t addr, const void *data, void *priv)
 		} else if (coargs->flags & COF_BYIDH) {
 			mdb_printf("%<u>%-14s %</u>", "EXP");
 		}
-		mdb_printf("%<u>%-3s %-?s %-20s%</u>",
-		    "XHL", "XID", "FUNC(ARG)");
+		mdb_printf("%<u>%-4s %-?s %-20s%</u>",
+		    "XHAL", "XID", "FUNC(ARG)");
 		if (coargs->flags & COF_LONGLIST) {
 			mdb_printf("%<u> %-?s %-?s %-?s %-?s%</u>",
 			    "PREVID", "NEXTID", "PREVL", "NEXTL");
+			mdb_printf("%<u> %-?s %-4s %-?s%</u>",
+			    "DONE", "UTOS", "THREAD");
 		}
 		mdb_printf("\n");
 		coargs->flags &= ~COF_CHDR;
@@ -786,6 +826,7 @@ callouts_cb(uintptr_t addr, const void *data, void *priv)
 	}
 
 	if (!(coargs->flags & COF_ADDR)) {
+		int list_flags = coargs->list_flags;
 		if (!(coargs->flags & COF_VERBOSE)) {
 			mdb_printf("%-3d %1s %-14llx ",
 			    TABLE_TO_SEQID(tableid),
@@ -797,15 +838,18 @@ callouts_cb(uintptr_t addr, const void *data, void *priv)
 			    (coargs->flags & COF_EXPREL) ?
 			    coargs->exp - coargs->now : coargs->exp);
 		}
-		mdb_printf("%1s%1s%1s %-?llx %a(%p)",
+		mdb_printf("%1s%1s%1s%1s %-?llx %a(%p)",
 		    (co->c_xid & CALLOUT_EXECUTING) ? "X" : " ",
-		    (co->c_xid & CALLOUT_HRESTIME) ? "H" : " ",
+		    (list_flags & CALLOUT_FLAG_HRESTIME) ? "H" : " ",
+		    (list_flags & CALLOUT_FLAG_ABSOLUTE) ? "A" : " ",
 		    (co->c_xid & CALLOUT_LONGTERM) ? "L" : " ",
 		    (long long)coid, co->c_func, co->c_arg);
 		if (coargs->flags & COF_LONGLIST) {
 			mdb_printf(" %-?p %-?p %-?p %-?p",
 			    co->c_idprev, co->c_idnext, co->c_clprev,
 			    co->c_clnext);
+			mdb_printf(" %-?p %-4d %-0?p",
+			    co->c_done, co->c_waiting, co->c_executor);
 		}
 	} else {
 		/* address only */
@@ -829,6 +873,8 @@ callout_list_cb(uintptr_t addr, const void *data, void *priv)
 	}
 
 	coargs->exp = cl->cl_expiration;
+	coargs->list_flags = cl->cl_flags;
+
 	if ((coargs->flags & COF_TIME) &&
 	    (cl->cl_expiration != coargs->time)) {
 		return (WALK_NEXT);
@@ -845,6 +891,23 @@ callout_list_cb(uintptr_t addr, const void *data, void *priv)
 	    (cl->cl_callouts.ch_head == NULL)) {
 		return (WALK_NEXT);
 	}
+	/* FOUR cases, each different, !A!B, !AB, A!B, AB */
+	if ((coargs->flags & COF_HIRES) && (coargs->flags & COF_ABS)) {
+		/* both flags are set, only skip "regular" ones */
+		if (! (cl->cl_flags &
+		    (CALLOUT_FLAG_HRESTIME | CALLOUT_FLAG_ABSOLUTE))) {
+			return (WALK_NEXT);
+		}
+	} else {
+		if ((coargs->flags & COF_HIRES) &&
+		    !(cl->cl_flags & CALLOUT_FLAG_HRESTIME)) {
+			return (WALK_NEXT);
+		}
+		if ((coargs->flags & COF_ABS) &&
+		    !(cl->cl_flags & CALLOUT_FLAG_ABSOLUTE)) {
+			return (WALK_NEXT);
+		}
+	}
 
 	if ((coargs->flags & COF_LHDR) && !(coargs->flags & COF_ADDR) &&
 	    (coargs->flags & (COF_LIST | COF_VERBOSE))) {
@@ -852,12 +915,12 @@ callout_list_cb(uintptr_t addr, const void *data, void *priv)
 			/* don't be redundant again */
 			mdb_printf("%<u>SEQ T %</u>");
 		}
-		mdb_printf("%<u>EXP            BUCKET "
-		    "CALLOUTS         UTOS THREAD         %</u>");
+		mdb_printf("%<u>EXP            HA BUCKET "
+		    "CALLOUTS         %</u>");
 
 		if (coargs->flags & COF_LONGLIST) {
-			mdb_printf("%<u> %-?s %-?s %-?s%</u>",
-			    "DONE", "PREV", "NEXT");
+			mdb_printf("%<u> %-?s %-?s%</u>",
+			    "PREV", "NEXT");
 		}
 		mdb_printf("\n");
 		coargs->flags &= ~COF_LHDR;
@@ -872,15 +935,18 @@ callout_list_cb(uintptr_t addr, const void *data, void *priv)
 				    CALLOUT_TYPE_MASK]);
 			}
 
-			mdb_printf("%-14llx %-6d %-0?p %-4d %-0?p",
+			mdb_printf("%-14llx %1s%1s %-6d %-0?p ",
 			    (coargs->flags & COF_EXPREL) ?
 			    coargs->exp - coargs->now : coargs->exp,
-			    coargs->bucket, cl->cl_callouts.ch_head,
-			    cl->cl_waiting, cl->cl_executor);
+			    (coargs->list_flags & CALLOUT_FLAG_HRESTIME) ?
+			    "H" : " ",
+			    (coargs->list_flags & CALLOUT_FLAG_ABSOLUTE) ?
+			    "A" : " ",
+			    coargs->bucket, cl->cl_callouts.ch_head);
 
 			if (coargs->flags & COF_LONGLIST) {
-				mdb_printf(" %-?p %-?p %-?p",
-				    cl->cl_done, cl->cl_prev, cl->cl_next);
+				mdb_printf(" %-?p %-?p",
+				    cl->cl_prev, cl->cl_next);
 			}
 		} else {
 			/* address only */
@@ -1159,6 +1225,7 @@ callout(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 	    's', MDB_OPT_CLRBITS, COF_LONG, &coargs.flags,
 	    'x', MDB_OPT_SETBITS, COF_EXEC, &coargs.flags,
 	    'h', MDB_OPT_SETBITS, COF_HIRES, &coargs.flags,
+	    'B', MDB_OPT_SETBITS, COF_ABS, &coargs.flags,
 	    'E', MDB_OPT_SETBITS, COF_EMPTY, &coargs.flags,
 	    'd', MDB_OPT_SETBITS, 1, &dflag,
 	    'C', MDB_OPT_UINTPTR_SET, &Cflag, &Ctmp,
@@ -1372,14 +1439,13 @@ calloutid(uintptr_t addr, uint_t flags, int argc, const mdb_arg_t *argv)
 
 	if (coargs.flags & COF_DECODE) {
 		if (DCMD_HDRSPEC(flags)) {
-			mdb_printf("%<u>%3s %1s %3s %-?s %-6s %</u>\n",
-			    "SEQ", "T", "XHL", "XID", "IDHASH");
+			mdb_printf("%<u>%3s %1s %2s %-?s %-6s %</u>\n",
+			    "SEQ", "T", "XL", "XID", "IDHASH");
 		}
-		mdb_printf("%-3d %1s %1s%1s%1s %-?llx %-6d\n",
+		mdb_printf("%-3d %1s %1s%1s %-?llx %-6d\n",
 		    TABLE_TO_SEQID(tableid),
 		    co_typenames[tableid & CALLOUT_TYPE_MASK],
 		    (xid & CALLOUT_EXECUTING) ? "X" : " ",
-		    (xid & CALLOUT_HRESTIME) ? "H" : " ",
 		    (xid & CALLOUT_LONGTERM) ? "L" : " ",
 		    (long long)coid, idhash);
 		return (DCMD_OK);
@@ -1436,6 +1502,7 @@ callout_help(void)
 	    " -s|l : limit display to (s)hort-term ids or (l)ong-term ids\n"
 	    " -x : limit display to callouts which are executing\n"
 	    " -h : limit display to callouts based on hrestime\n"
+	    " -B : limit display to callouts based on absolute time\n"
 	    " -t|a|b nsec: limit display to callouts that expire a(t) time,"
 	    " (a)fter time,\n     or (b)efore time. Use -a and -b together "
 	    " to specify a range.\n     For \"now\", use -d[t|a|b] 0.\n"
@@ -4190,7 +4257,7 @@ static const mdb_dcmd_t dcmds[] = {
 	{ "as2proc", ":", "convert as to proc_t address", as2proc },
 	{ "binding_hash_entry", ":", "print driver names hash table entry",
 		binding_hash_entry },
-	{ "callout", "?[-r|n] [-s|l] [-xh] [-t | -ab nsec [-dkD]]"
+	{ "callout", "?[-r|n] [-s|l] [-xhB] [-t | -ab nsec [-dkD]]"
 	    " [-C addr | -S seqid] [-f name|addr] [-p name| addr] [-T|L [-E]]"
 	    " [-FivVA]",
 	    "display callouts", callout, callout_help },
diff --git a/usr/src/uts/common/os/callout.c b/usr/src/uts/common/os/callout.c
index 65e94f0f59..adab6f16e6 100644
--- a/usr/src/uts/common/os/callout.c
+++ b/usr/src/uts/common/os/callout.c
@@ -52,6 +52,15 @@ static callout_cache_t *callout_caches;		/* linked list of caches */
 #pragma align 64(callout_table)
 static callout_table_t *callout_table;		/* global callout table array */
 
+/*
+ * We run normal callouts from PIL 10. This means that no other handler that
+ * runs at PIL 10 is allowed to wait for normal callouts directly or indirectly
+ * as it will cause a deadlock. This has always been an unwritten rule.
+ * We are making it explicit here.
+ */
+static int callout_realtime_level = CY_LOW_LEVEL;
+static int callout_normal_level = CY_LOCK_LEVEL;
+
 static char *callout_kstat_names[] = {
 	"callout_timeouts",
 	"callout_timeouts_pending",
@@ -143,6 +152,53 @@ static char *callout_kstat_names[] = {
 #define	CALLOUT_LIST_DELETE(hash, cl)				\
 	CALLOUT_HASH_DELETE(hash, cl, cl_next, cl_prev)
 
+/*
+ * For normal callouts, there is a deadlock scenario if two callouts that
+ * have an inter-dependency end up on the same callout list. To break the
+ * deadlock, you need two taskq threads running in parallel. We compute
+ * the number of taskq threads here using a bunch of conditions to make
+ * it optimal for the common case. This is an ugly hack, but one that is
+ * necessary (sigh).
+ */
+#define	CALLOUT_THRESHOLD	100000000
+#define	CALLOUT_EXEC_COMPUTE(ct, exec)					\
+{									\
+	callout_list_t *cl;						\
+									\
+	cl = ct->ct_expired.ch_head;					\
+	if (cl == NULL) {						\
+		/*							\
+		 * If the expired list is NULL, there is nothing to	\
+		 * process.						\
+		 */							\
+		exec = 0;						\
+	} else if ((cl->cl_next == NULL) &&				\
+	    (cl->cl_callouts.ch_head == cl->cl_callouts.ch_tail)) {	\
+		/*							\
+		 * If there is only one callout list and it contains	\
+		 * only one callout, there is no need for two threads.	\
+		 */							\
+		exec = 1;						\
+	} else if ((ct->ct_heap_num == 0) ||				\
+	    (ct->ct_heap[0] > gethrtime() + CALLOUT_THRESHOLD)) {	\
+		/*							\
+		 * If the heap has become empty, we need two threads as	\
+		 * there is no one to kick off the second thread in the	\
+		 * future. If the heap is not empty and the top of the	\
+		 * heap does not expire in the near future, we need two	\
+		 * threads.						\
+		 */							\
+		exec = 2;						\
+	} else {							\
+		/*							\
+		 * We have multiple callouts to process. But the cyclic	\
+		 * will fire in the near future. So, we only need one	\
+		 * thread for now.					\
+		 */							\
+		exec = 1;						\
+	}								\
+}
+
 /*
  * Allocate a callout structure.  We try quite hard because we
  * can't sleep, and if we can't do the allocation, we're toast.
@@ -164,6 +220,9 @@ callout_alloc(callout_table_t *ct)
 		cp = kmem_alloc_tryhard(size, &size, KM_NOSLEEP | KM_PANIC);
 	}
 	cp->c_xid = 0;
+	cp->c_executor = NULL;
+	cv_init(&cp->c_done, NULL, CV_DEFAULT, NULL);
+	cp->c_waiting = 0;
 
 	mutex_enter(&ct->ct_mutex);
 	ct->ct_allocations++;
@@ -198,18 +257,18 @@ callout_list_alloc(callout_table_t *ct)
 }
 
 /*
- * Find the callout list that corresponds to an expiration. There can
- * be only one.
+ * Find a callout list that corresponds to an expiration.
  */
 static callout_list_t *
-callout_list_get(callout_table_t *ct, hrtime_t expiration, int hash)
+callout_list_get(callout_table_t *ct, hrtime_t expiration, int flags, int hash)
 {
 	callout_list_t *cl;
 
 	ASSERT(MUTEX_HELD(&ct->ct_mutex));
 
 	for (cl = ct->ct_clhash[hash].ch_head; (cl != NULL); cl = cl->cl_next) {
-		if (cl->cl_expiration == expiration)
+		if ((cl->cl_expiration == expiration) &&
+		    (cl->cl_flags == flags))
 			return (cl);
 	}
 
@@ -217,8 +276,8 @@ callout_list_get(callout_table_t *ct, hrtime_t expiration, int hash)
 }
 
 /*
- * Find the callout list that corresponds to an expiration. There can
- * be only one. If the callout list is null, free it. Else, return it.
+ * Find the callout list that corresponds to an expiration.
+ * If the callout list is null, free it. Else, return it.
  */
 static callout_list_t *
 callout_list_check(callout_table_t *ct, hrtime_t expiration, int hash)
@@ -227,24 +286,25 @@ callout_list_check(callout_table_t *ct, hrtime_t expiration, int hash)
 
 	ASSERT(MUTEX_HELD(&ct->ct_mutex));
 
-	cl = callout_list_get(ct, expiration, hash);
-	if (cl != NULL) {
-		if (cl->cl_callouts.ch_head != NULL) {
-			/*
-			 * There is exactly one callout list for every
-			 * unique expiration. So, we are done.
-			 */
-			return (cl);
-		}
+	for (cl = ct->ct_clhash[hash].ch_head; (cl != NULL); cl = cl->cl_next) {
+		if (cl->cl_expiration == expiration) {
+			if (cl->cl_callouts.ch_head != NULL) {
+				/*
+				 * Found a match.
+				 */
+				return (cl);
+			}
+
+			CALLOUT_LIST_DELETE(ct->ct_clhash[hash], cl);
+			cl->cl_next = ct->ct_lfree;
+			ct->ct_lfree = cl;
 
-		CALLOUT_LIST_DELETE(ct->ct_clhash[hash], cl);
-		cl->cl_next = ct->ct_lfree;
-		ct->ct_lfree = cl;
+			return (NULL);
+		}
 	}
 
 	return (NULL);
 }
-
 /*
  * Initialize a callout table's heap, if necessary. Preallocate some free
  * entries so we don't have to check for NULL elsewhere.
@@ -354,7 +414,7 @@ callout_upheap(callout_table_t *ct)
 }
 
 /*
- * Insert a new, unique expiration into a callout table's heap.
+ * Insert a new expiration into a callout table's heap.
  */
 static void
 callout_heap_insert(callout_table_t *ct, hrtime_t expiration)
@@ -597,12 +657,10 @@ timeout_generic(int type, void (*func)(void *), void *arg,
 	 */
 	now = gethrtime();
 	if (flags & CALLOUT_FLAG_ABSOLUTE) {
-		ASSERT(expiration > 0);
 		interval = expiration - now;
 	} else {
 		interval = expiration;
 		expiration += now;
-		ASSERT(expiration > 0);
 	}
 	if (flags & CALLOUT_FLAG_ROUNDUP)
 		expiration += resolution - 1;
@@ -638,9 +696,8 @@ timeout_generic(int type, void (*func)(void *), void *arg,
 	}
 
 	cp->c_xid = id;
-	if (flags & CALLOUT_FLAG_HRESTIME)
-		cp->c_xid |= CALLOUT_HRESTIME;
 
+	flags &= CALLOUT_LIST_FLAGS;
 	hash = CALLOUT_CLHASH(expiration);
 
 again:
@@ -648,7 +705,7 @@ again:
 	 * Try to see if a callout list already exists for this expiration.
 	 * Most of the time, this will be the case.
 	 */
-	cl = callout_list_get(ct, expiration, hash);
+	cl = callout_list_get(ct, expiration, flags, hash);
 	if (cl == NULL) {
 		/*
 		 * Check if we have enough space in the heap to insert one
@@ -686,6 +743,7 @@ again:
 		}
 		ct->ct_lfree = cl->cl_next;
 		cl->cl_expiration = expiration;
+		cl->cl_flags = flags;
 
 		CALLOUT_LIST_INSERT(ct->ct_clhash[hash], cl);
 
@@ -803,7 +861,6 @@ untimeout_generic(callout_id_t id, int nowait)
 	callout_table_t *ct;
 	callout_t *cp;
 	callout_id_t xid;
-	callout_list_t *cl;
 	int hash;
 	callout_id_t bogus;
 
@@ -825,7 +882,6 @@ untimeout_generic(callout_id_t id, int nowait)
 		if ((xid & CALLOUT_ID_MASK) != id)
 			continue;
 
-		cl = cp->c_list;
 		if ((xid & CALLOUT_EXECUTING) == 0) {
 			hrtime_t expiration;
 
@@ -838,7 +894,7 @@ untimeout_generic(callout_id_t id, int nowait)
 			 * order to avoid lots of X-calls to the CPU associated
 			 * with the callout table.
 			 */
-			expiration = cl->cl_expiration;
+			expiration = cp->c_list->cl_expiration;
 			CALLOUT_DELETE(ct, cp);
 			cp->c_idnext = ct->ct_free;
 			ct->ct_free = cp;
@@ -857,12 +913,12 @@ untimeout_generic(callout_id_t id, int nowait)
 		/*
 		 * The callout we want to delete is currently executing.
 		 * The DDI states that we must wait until the callout
-		 * completes before returning, so we block on cl_done until the
+		 * completes before returning, so we block on c_done until the
 		 * callout ID changes (to the old ID if it's on the freelist,
 		 * or to a new callout ID if it's in use).  This implicitly
 		 * assumes that callout structures are persistent (they are).
 		 */
-		if (cl->cl_executor == curthread) {
+		if (cp->c_executor == curthread) {
 			/*
 			 * The timeout handler called untimeout() on itself.
 			 * Stupid, but legal.  We can't wait for the timeout
@@ -876,13 +932,13 @@ untimeout_generic(callout_id_t id, int nowait)
 		if (nowait == 0) {
 			/*
 			 * We need to wait. Indicate that we are waiting by
-			 * incrementing cl_waiting. This prevents the executor
-			 * from doing a wakeup on cl_done if there are no
+			 * incrementing c_waiting. This prevents the executor
+			 * from doing a wakeup on c_done if there are no
 			 * waiters.
 			 */
 			while (cp->c_xid == xid) {
-				cl->cl_waiting = 1;
-				cv_wait(&cl->cl_done, &ct->ct_mutex);
+				cp->c_waiting = 1;
+				cv_wait(&cp->c_done, &ct->ct_mutex);
 			}
 		}
 		mutex_exit(&ct->ct_mutex);
@@ -901,7 +957,7 @@ untimeout_generic(callout_id_t id, int nowait)
 	 * (1) the callout already fired, or (2) the caller passed us
 	 * a bogus value.  Perform a sanity check to detect case (2).
 	 */
-	bogus = (CALLOUT_EXECUTING | CALLOUT_HRESTIME | CALLOUT_COUNTER_HIGH);
+	bogus = (CALLOUT_EXECUTING | CALLOUT_COUNTER_HIGH);
 	if (((id & bogus) != CALLOUT_COUNTER_HIGH) && (id != 0))
 		panic("untimeout: impossible timeout id %llx",
 		    (unsigned long long)id);
@@ -955,19 +1011,28 @@ untimeout_default(callout_id_t id, int nowait)
 static void
 callout_list_expire(callout_table_t *ct, callout_list_t *cl)
 {
-	callout_t *cp;
+	callout_t *cp, *cnext;
 
 	ASSERT(MUTEX_HELD(&ct->ct_mutex));
 	ASSERT(cl != NULL);
 
-	cl->cl_executor = curthread;
+	for (cp = cl->cl_callouts.ch_head; cp != NULL; cp = cnext) {
+		/*
+		 * Multiple executor threads could be running at the same
+		 * time. If this callout is already being executed,
+		 * go on to the next one.
+		 */
+		if (cp->c_xid & CALLOUT_EXECUTING) {
+			cnext = cp->c_clnext;
+			continue;
+		}
 
-	while ((cp = cl->cl_callouts.ch_head) != NULL) {
 		/*
 		 * Indicate to untimeout() that a callout is
 		 * being expired by the executor.
 		 */
 		cp->c_xid |= CALLOUT_EXECUTING;
+		cp->c_executor = curthread;
 		mutex_exit(&ct->ct_mutex);
 
 		DTRACE_PROBE1(callout__start, callout_t *, cp);
@@ -979,9 +1044,11 @@ callout_list_expire(callout_table_t *ct, callout_list_t *cl)
 		ct->ct_expirations++;
 		ct->ct_timeouts_pending--;
 		/*
-		 * Indicate completion for cl_done.
+		 * Indicate completion for c_done.
 		 */
 		cp->c_xid &= ~CALLOUT_EXECUTING;
+		cp->c_executor = NULL;
+		cnext = cp->c_clnext;
 
 		/*
 		 * Delete callout from ID hash table and the callout
@@ -992,13 +1059,11 @@ callout_list_expire(callout_table_t *ct, callout_list_t *cl)
 		cp->c_idnext = ct->ct_free;
 		ct->ct_free = cp;
 
-		if (cl->cl_waiting) {
-			cl->cl_waiting = 0;
-			cv_broadcast(&cl->cl_done);
+		if (cp->c_waiting) {
+			cp->c_waiting = 0;
+			cv_broadcast(&cp->c_done);
 		}
 	}
-
-	cl->cl_executor = NULL;
 }
 
 /*
@@ -1012,29 +1077,20 @@ callout_expire(callout_table_t *ct)
 	ASSERT(MUTEX_HELD(&ct->ct_mutex));
 
 	for (cl = ct->ct_expired.ch_head; (cl != NULL); cl = clnext) {
-		/*
-		 * Multiple executor threads could be running at the same
-		 * time. Each callout list is processed by only one thread.
-		 * If this callout list is already being processed by another
-		 * executor, go on to the next one.
-		 */
-		if (cl->cl_executor != NULL) {
-			clnext = cl->cl_next;
-			continue;
-		}
-
 		/*
 		 * Expire all the callouts in this callout list.
 		 */
 		callout_list_expire(ct, cl);
 
-		/*
-		 * Free the callout list.
-		 */
 		clnext = cl->cl_next;
-		CALLOUT_LIST_DELETE(ct->ct_expired, cl);
-		cl->cl_next = ct->ct_lfree;
-		ct->ct_lfree = cl;
+		if (cl->cl_callouts.ch_head == NULL) {
+			/*
+			 * Free the callout list.
+			 */
+			CALLOUT_LIST_DELETE(ct->ct_expired, cl);
+			cl->cl_next = ct->ct_lfree;
+			ct->ct_lfree = cl;
+		}
 	}
 }
 
@@ -1082,14 +1138,14 @@ callout_execute(callout_table_t *ct)
 void
 callout_normal(callout_table_t *ct)
 {
-	int exec;
+	int i, exec;
 
 	mutex_enter(&ct->ct_mutex);
 	callout_heap_delete(ct);
-	exec = (ct->ct_expired.ch_head != NULL);
+	CALLOUT_EXEC_COMPUTE(ct, exec);
 	mutex_exit(&ct->ct_mutex);
 
-	if (exec) {
+	for (i = 0; i < exec; i++) {
 		ASSERT(ct->ct_taskq != NULL);
 		(void) taskq_dispatch(ct->ct_taskq,
 		    (task_func_t *)callout_execute, ct, TQ_NOSLEEP);
@@ -1271,16 +1327,15 @@ callout_debug_callb(void *arg, int code)
 }
 
 /*
- * Move the hrestime callouts to the expired list. Then program the table's
- * cyclic to expire immediately so that the callouts can be executed
+ * Move the absolute hrestime callouts to the expired list. Then program the
+ * table's cyclic to expire immediately so that the callouts can be executed
  * immediately.
  */
 static void
 callout_hrestime_one(callout_table_t *ct)
 {
-	callout_list_t *cl, *ecl;
-	callout_t *cp;
-	int hash;
+	callout_list_t *cl, *clnext;
+	int hash, flags;
 
 	mutex_enter(&ct->ct_mutex);
 	if (ct->ct_heap_num == 0) {
@@ -1288,34 +1343,20 @@ callout_hrestime_one(callout_table_t *ct)
 		return;
 	}
 
-	if (ct->ct_lfree == NULL)
-		callout_list_alloc(ct);
-	ecl = ct->ct_lfree;
-	ct->ct_lfree = ecl->cl_next;
-
+	flags = CALLOUT_LIST_FLAGS;
 	for (hash = 0; hash < CALLOUT_BUCKETS; hash++) {
-		for (cl = ct->ct_clhash[hash].ch_head; cl; cl = cl->cl_next) {
-			for (cp = cl->cl_callouts.ch_head; cp;
-			    cp = cp->c_clnext) {
-				if ((cp->c_xid & CALLOUT_HRESTIME) == 0)
-					continue;
-				CALLOUT_HASH_DELETE(cl->cl_callouts, cp,
-				    c_clnext, c_clprev);
-				cp->c_list = ecl;
-				CALLOUT_HASH_APPEND(ecl->cl_callouts, cp,
-				    c_clnext, c_clprev);
+		for (cl = ct->ct_clhash[hash].ch_head; cl; cl = clnext) {
+			clnext = cl->cl_next;
+			if (cl->cl_flags == flags) {
+				CALLOUT_LIST_DELETE(ct->ct_clhash[hash], cl);
+				CALLOUT_LIST_APPEND(ct->ct_expired, cl);
 			}
 		}
 	}
 
-	if (ecl->cl_callouts.ch_head != NULL) {
-		CALLOUT_LIST_APPEND(ct->ct_expired, ecl);
-		if (ct->ct_suspend == 0)
-			(void) cyclic_reprogram(ct->ct_cyclic, gethrtime());
-	} else {
-		ecl->cl_next = ct->ct_lfree;
-		ct->ct_lfree = ecl;
-	}
+	if ((ct->ct_expired.ch_head != NULL) && (ct->ct_suspend == 0))
+		(void) cyclic_reprogram(ct->ct_cyclic, gethrtime());
+
 	mutex_exit(&ct->ct_mutex);
 }
 
@@ -1439,11 +1480,21 @@ callout_cyclic_init(callout_table_t *ct)
 
 	/*
 	 * Create the callout table cyclics.
+	 *
+	 * The realtime cyclic handler executes at low PIL. The normal cyclic
+	 * handler executes at lock PIL. This is because there are cases
+	 * where code can block at PIL > 1 waiting for a normal callout handler
+	 * to unblock it directly or indirectly. If the normal cyclic were to
+	 * be executed at low PIL, it could get blocked out by the waiter
+	 * and cause a deadlock.
 	 */
 	ASSERT(ct->ct_cyclic == CYCLIC_NONE);
 
 	hdlr.cyh_func = (cyc_func_t)CALLOUT_CYCLIC_HANDLER(t);
-	hdlr.cyh_level = CY_LOW_LEVEL;
+	if (ct->ct_type == CALLOUT_REALTIME)
+		hdlr.cyh_level = callout_realtime_level;
+	else
+		hdlr.cyh_level = callout_normal_level;
 	hdlr.cyh_arg = ct;
 	when.cyt_when = CY_INFINITY;
 	when.cyt_interval = CY_INFINITY;
diff --git a/usr/src/uts/common/os/clock.c b/usr/src/uts/common/os/clock.c
index 45f7f53e39..f6e856799b 100644
--- a/usr/src/uts/common/os/clock.c
+++ b/usr/src/uts/common/os/clock.c
@@ -1591,9 +1591,8 @@ delay(clock_t ticks)
 	timeout_id_t id;
 	extern hrtime_t volatile devinfo_freeze;
 
-	if ((getpil() > 0 || panicstr || devinfo_freeze) && ticks > 0) {
+	if ((panicstr || devinfo_freeze) && ticks > 0) {
 		/*
-		 * Either the caller's PIL is not safe for timeout wait or
 		 * Timeouts aren't running, so all we can do is spin.
 		 */
 		drv_usecwait(TICK_TO_USEC(ticks));
diff --git a/usr/src/uts/common/os/clock_tick.c b/usr/src/uts/common/os/clock_tick.c
index 816f4978b1..b1b94720ff 100644
--- a/usr/src/uts/common/os/clock_tick.c
+++ b/usr/src/uts/common/os/clock_tick.c
@@ -20,12 +20,10 @@
  */
 
 /*
- * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
+ * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <sys/thread.h>
 #include <sys/proc.h>
 #include <sys/task.h>
@@ -148,6 +146,7 @@ clock_t			clock_tick_proc_max;
 clock_tick_set_t	*clock_tick_set;
 int			clock_tick_nsets;
 int			clock_tick_scan;
+ulong_t			clock_tick_intr;
 
 static uint_t	clock_tick_execute(caddr_t, caddr_t);
 static void	clock_tick_execute_common(int, int, int, clock_t, int);
@@ -182,13 +181,16 @@ clock_tick_init_pre(void)
 	/*
 	 * Perform initialization in case multi-threading is chosen later.
 	 */
+	if (&create_softint != NULL) {
+		clock_tick_intr = create_softint(LOCK_LEVEL,
+		    clock_tick_execute, (caddr_t)NULL);
+	}
 	for (i = 0; i < NCPU; i++, buf += size) {
 		ctp = (clock_tick_cpu_t *)buf;
 		clock_tick_cpu[i] = ctp;
 		mutex_init(&ctp->ct_lock, NULL, MUTEX_DEFAULT, NULL);
 		if (&create_softint != NULL) {
-			ctp->ct_intr = create_softint(LOCK_LEVEL,
-			    clock_tick_execute, (caddr_t)ctp);
+			ctp->ct_intr = clock_tick_intr;
 		}
 		ctp->ct_pending = 0;
 	}
@@ -264,6 +266,9 @@ clock_tick_schedule_one(clock_tick_set_t *csp, int pending, processorid_t cid)
 	clock_tick_cpu_t	*ctp;
 
 	ASSERT(&invoke_softint != NULL);
+
+	atomic_inc_ulong(&clock_tick_active);
+
 	/*
 	 * Schedule tick accounting for a set of CPUs.
 	 */
@@ -569,11 +574,10 @@ clock_tick_execute(caddr_t arg1, caddr_t arg2)
 	 * later on.
 	 */
 	if (!CLOCK_TICK_XCALL_SAFE(CPU))
-		return (1);
+		goto out;
 
-	atomic_inc_ulong(&clock_tick_active);
+	ctp = clock_tick_cpu[CPU->cpu_id];
 
-	ctp = (clock_tick_cpu_t *)arg1;
 	mutex_enter(&ctp->ct_lock);
 	pending = ctp->ct_pending;
 	if (pending == 0) {
diff --git a/usr/src/uts/common/sys/callo.h b/usr/src/uts/common/sys/callo.h
index 95ec7e769c..2b76fe62a8 100644
--- a/usr/src/uts/common/sys/callo.h
+++ b/usr/src/uts/common/sys/callo.h
@@ -61,6 +61,9 @@ typedef struct callout {
 	callout_list_t	*c_list;	/* callout list */
 	void		(*c_func)(void *); /* function to call */
 	void		*c_arg;		/* argument to function */
+	kthread_t	*c_executor;	/* executing thread */
+	kcondvar_t	c_done;		/* signal callout completion */
+	ushort_t	c_waiting;	/* untimeout waiting flag */
 } callout_t;
 
 /*
@@ -84,27 +87,17 @@ typedef struct callout {
  *
  * Here is the bit layout for the callout ID:
  *
- *      63    62    61  ...  32   31       30    29 .. X+1  X ... 1   0
- *  -----------------------------------------------------------------------
- *  | Exec | Hres | Generation | Long | Counter | ID bits | Table  | Type |
- *  |      | time | number     | term | High    |         | number |      |
- *  -----------------------------------------------------------------------
+ *      63   62  ...  32   31      30     29 .. X+1  X ... 1   0
+ *  ----------------------------------------------------------------
+ *  | Exec | Generation | Long | Counter | ID bits | Table  | Type |
+ *  |      | number     | term | High    |         | number |      |
+ *  ----------------------------------------------------------------
  *
  * Exec(uting):
  *    This is the executing bit which is only set in the extended callout
  *    ID. This bit indicates that the callout handler is currently being
  *    executed.
  *
- * Hrestime:
- *    Kernel features like condition variables use hrestime (system date) in
- *    conjunction with callouts. Under normal circumstances, these callouts
- *    are handled in the usual manner. They go off at specified times. But
- *    when the system time is changed abruptly (e.g., via stime()), these
- *    callouts are required to be processed immediately so that they can
- *    wakeup their threads immediately. The Hrestime bit is used to mark
- *    such callouts. When the system time is changed, the callout subsystem
- *    is called to process all callouts with this bit set.
- *
  * Generation number:
  *    This is the generation part of the ID.
  *
@@ -143,8 +136,7 @@ typedef struct callout {
  *    and one normal callout table.
  */
 #define	CALLOUT_EXECUTING	0x8000000000000000ULL
-#define	CALLOUT_HRESTIME	0x4000000000000000ULL
-#define	CALLOUT_ID_MASK		~(CALLOUT_EXECUTING | CALLOUT_HRESTIME)
+#define	CALLOUT_ID_MASK		~(CALLOUT_EXECUTING)
 #define	CALLOUT_GENERATION_LOW	0x100000000ULL
 #define	CALLOUT_LONGTERM	0x80000000
 #define	CALLOUT_COUNTER_HIGH	0x40000000
@@ -226,10 +218,7 @@ struct callout_list {
 	callout_list_t	*cl_prev;	/* prev in clhash */
 	hrtime_t	cl_expiration;	/* expiration for callouts in list */
 	callout_hash_t	cl_callouts;	/* list of callouts */
-	kcondvar_t	cl_done;	/* signal callout completion */
-	ushort_t	cl_waiting;	/* count of waiting untimeouts */
-	kthread_id_t	cl_executor;	/* thread executing callout */
-	ulong_t		cl_pad;		/* cache alignment */
+	int		cl_flags;	/* callout flags */
 };
 
 /*
@@ -267,7 +256,7 @@ typedef enum callout_stat_type {
  * Callout flags:
  *
  * CALLOUT_FLAG_ROUNDUP
- *	Roundup the expiration time to the nearest resolution boundary.
+ *	Roundup the expiration time to the next resolution boundary.
  *	If this flag is not specified, the expiration time is rounded down.
  * CALLOUT_FLAG_ABSOLUTE
  *	Normally, the expiration passed to the timeout API functions is an
@@ -276,9 +265,9 @@ typedef enum callout_stat_type {
  * CALLOUT_FLAG_HRESTIME
  *	Normally, callouts are not affected by changes to system time
  *	(hrestime). This flag is used to create a callout that is affected
- *	by system time. If system time changes, these timers must expire
- *	at once. These are used by condition variables and LWP timers that
- *	need this behavior.
+ *	by system time. If system time changes, these timers must be
+ *	handled in a special way (see callout.c). These are used by condition
+ *	variables and LWP timers that need this behavior.
  * CALLOUT_FLAG_32BIT
  *	Legacy interfaces timeout() and realtime_timeout() pass this flag
  *	to timeout_generic() to indicate that a 32-bit ID should be allocated.
@@ -288,6 +277,7 @@ typedef enum callout_stat_type {
 #define	CALLOUT_FLAG_HRESTIME		0x4
 #define	CALLOUT_FLAG_32BIT		0x8
 
+#define	CALLOUT_LIST_FLAGS	(CALLOUT_FLAG_ABSOLUTE | CALLOUT_FLAG_HRESTIME)
 /*
  * On 32-bit systems, the legacy interfaces, timeout() and realtime_timeout(),
  * must pass CALLOUT_FLAG_32BIT to timeout_generic() so that a 32-bit ID
diff --git a/usr/src/uts/sun4/os/intr.c b/usr/src/uts/sun4/os/intr.c
index b6fc7e570c..cefc121b5c 100644
--- a/usr/src/uts/sun4/os/intr.c
+++ b/usr/src/uts/sun4/os/intr.c
@@ -19,7 +19,7 @@
  * CDDL HEADER END
  */
 /*
- * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
+ * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
 
@@ -839,7 +839,7 @@ create_softint(uint_t pil, uint_t (*func)(caddr_t, caddr_t), caddr_t arg1)
 {
 	uint64_t inum;
 
-	inum = add_softintr(pil, func, arg1, SOFTINT_ST);
+	inum = add_softintr(pil, func, arg1, SOFTINT_MT);
 	return ((ulong_t)inum);
 }
 

