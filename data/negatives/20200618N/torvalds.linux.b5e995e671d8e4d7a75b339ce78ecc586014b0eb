commit b5e995e671d8e4d7a75b339ce78ecc586014b0eb
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 12 16:24:41 2014 +0530

    nohz: Fix spurious periodic tick behaviour in low-res dynticks mode
    
    When we reach the end of the tick handler, we unconditionally reschedule
    the next tick to the next jiffy. Then on irq exit, the nohz code
    overrides that setting if needed and defers the next tick as far away in
    the future as possible.
    
    Now in the best dynticks case, when we actually don't need any tick in
    the future (ie: expires == KTIME_MAX), low-res and high-res behave
    differently. What we want in this case is to cancel the next tick
    programmed by the previous one. That's what we do in high-res mode. OTOH
    we lack a low-res mode equivalent of hrtimer_cancel() so we simply don't
    do anything in this case and the next tick remains scheduled to jiffies + 1.
    
    As a result, in low-res mode, when the dynticks code determines that no
    tick is needed in the future, we can recursively get a spurious tick
    every jiffy because then the next tick is always reprogrammed from the
    tick handler and is never cancelled. And this can happen indefinetly
    until some subsystem actually needs a precise tick in the future and only
    then we eventually overwrite the previous tick handler setting to defer
    the next tick.
    
    We are fixing this by introducing the ONESHOT_STOPPED mode which will
    let us pause a clockevent when no further interrupt is needed. Meanwhile
    we can't expect all drivers to support this new mode.
    
    So lets reduce much of the symptoms by skipping the nohz-blind tick
    rescheduling from the tick-handler when the CPU is in dynticks mode.
    That tick rescheduling wrongly assumed periodicity and the low-res
    dynticks code can't cancel such decision. This breaks the recursive (and
    thus the worst) part of the problem. In the worst case now, we'll get
    only one extra tick due to uncancelled tick scheduled before we entered
    dynticks mode.
    
    This also removes a needless clockevent write on idle ticks. Since those
    clock write are usually considered to be slow, it's a general win.
    
    Reviewed-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/kernel/time/tick-sched.c b/kernel/time/tick-sched.c
index 99aa6ee3908f..153870a91350 100644
--- a/kernel/time/tick-sched.c
+++ b/kernel/time/tick-sched.c
@@ -968,6 +968,10 @@ static void tick_nohz_handler(struct clock_event_device *dev)
 	tick_sched_do_timer(now);
 	tick_sched_handle(ts, regs);
 
+	/* No need to reprogram if we are running tickless  */
+	if (unlikely(ts->tick_stopped))
+		return;
+
 	while (tick_nohz_reprogram(ts, now)) {
 		now = ktime_get();
 		tick_do_update_jiffies64(now);

