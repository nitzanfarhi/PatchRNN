commit 77a343ab1b2bc518f178bc7b473e770e3da2bb79
Author: abalfour <none@none>
Date:   Tue Dec 12 13:11:44 2006 -0800

    6431006 new fsck_ufs(1M) should be more helpful when encountering a bad CG with bad CG_MAGIC

diff --git a/usr/src/cmd/fs.d/ufs/fsck/fsck.h b/usr/src/cmd/fs.d/ufs/fsck/fsck.h
index fd5519046a..4f48654c5d 100644
--- a/usr/src/cmd/fs.d/ufs/fsck/fsck.h
+++ b/usr/src/cmd/fs.d/ufs/fsck/fsck.h
@@ -21,7 +21,7 @@
  */
 
 /*
- * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
+ * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
 
@@ -530,7 +530,7 @@ void		cacheacl(struct dinode *, fsck_ino_t);
 void		cacheino(struct dinode *, fsck_ino_t);
 void		catch(int);
 void		catchquit(int);
-caddr_t		cg_sanity(struct cg *, int, int *);
+caddr_t		cg_sanity(struct cg *, int);
 void		cgflush(void);
 int		cgisdirty(void);
 int		changeino(fsck_ino_t, caddr_t, fsck_ino_t);
diff --git a/usr/src/cmd/fs.d/ufs/fsck/inode.c b/usr/src/cmd/fs.d/ufs/fsck/inode.c
index 546a43862d..741fa30ba4 100644
--- a/usr/src/cmd/fs.d/ufs/fsck/inode.c
+++ b/usr/src/cmd/fs.d/ufs/fsck/inode.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
+ * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
 
@@ -1131,7 +1131,7 @@ allocino(fsck_ino_t request, int type)
 	fsck_ino_t ino;
 	struct dinode *dp;
 	struct cg *cgp = &cgrp;
-	int cg, cg_fatal;
+	int cg;
 	time_t t;
 	caddr_t err;
 
@@ -1176,13 +1176,10 @@ allocino(fsck_ino_t request, int type)
 	 */
 	cg = itog(&sblock, ino);
 	(void) getblk(&cgblk, cgtod(&sblock, cg), (size_t)sblock.fs_cgsize);
-	err = cg_sanity(cgp, cg, &cg_fatal);
+	err = cg_sanity(cgp, cg);
 	if (err != NULL) {
 		pfatal("CG %d: %s\n", cg, err);
 		free((void *)err);
-		if (cg_fatal)
-			errexit(
-	    "Irreparable cylinder group header problem.  Program terminated.");
 		if (reply("REPAIR") == 0)
 			errexit("Program terminated.");
 		fix_cg(cgp, cg);
diff --git a/usr/src/cmd/fs.d/ufs/fsck/pass4.c b/usr/src/cmd/fs.d/ufs/fsck/pass4.c
index e7f6a923f7..bb5015fb32 100644
--- a/usr/src/cmd/fs.d/ufs/fsck/pass4.c
+++ b/usr/src/cmd/fs.d/ufs/fsck/pass4.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
+ * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
  * Use is subject to license terms.
  */
 
@@ -163,7 +163,6 @@ pass4check(struct inodesc *idesc)
 	int cylno;
 	struct cg *cgp = &cgrp;
 	caddr_t err;
-	int cg_fatal;
 
 	if ((idesc->id_truncto >= 0) && (idesc->id_lbn < idesc->id_truncto)) {
 		if (debug)
@@ -210,13 +209,10 @@ pass4check(struct inodesc *idesc)
 				cylno = dtog(&sblock, cg_frag);
 				(void) getblk(&cgblk, cgtod(&sblock, cylno),
 				    (size_t)sblock.fs_cgsize);
-				err = cg_sanity(cgp, cylno, &cg_fatal);
+				err = cg_sanity(cgp, cylno);
 				if (err != NULL) {
 					pfatal("CG %d: %s\n", cylno, err);
 					free((void *)err);
-					if (cg_fatal)
-						errexit(
-	    "Irreparable cylinder group header problem.  Program terminated.");
 					if (reply("REPAIR") == 0)
 						errexit("Program terminated.");
 					fix_cg(cgp, cylno);
diff --git a/usr/src/cmd/fs.d/ufs/fsck/pass5.c b/usr/src/cmd/fs.d/ufs/fsck/pass5.c
index 15768dbdd6..66d7b14289 100644
--- a/usr/src/cmd/fs.d/ufs/fsck/pass5.c
+++ b/usr/src/cmd/fs.d/ufs/fsck/pass5.c
@@ -45,11 +45,10 @@ pass5(void)
 {
 	caddr_t err;
 	int32_t c, blk, frags;
-	int cg_fatal;
 	size_t	basesize, sumsize, mapsize;
 	int excessdirs;
 	int inomapsize, blkmapsize;
-	int update_csums, bad_csum, update_bitmaps;
+	int update_csums, bad_csum_sb, bad_csum_cg, update_bitmaps;
 	struct fs *fs = &sblock;
 	struct cg *cg = &cgrp;
 	diskaddr_t dbase, dmax;
@@ -143,13 +142,10 @@ pass5(void)
 		 */
 		(void) getblk(&cgblk, (diskaddr_t)cgtod(fs, c),
 		    (size_t)fs->fs_cgsize);
-		err = cg_sanity(cg, c, &cg_fatal);
+		err = cg_sanity(cg, c);
 		if (err != NULL) {
 			pfatal("CG %d: %s\n", c, err);
 			free((void *)err);
-			if (cg_fatal)
-				errexit(
-	    "Irreparable cylinder group header problem.  Program terminated.");
 			if (reply("REPAIR") == 0)
 				errexit("Program terminated.");
 			fix_cg(cg, c);
@@ -273,37 +269,52 @@ pass5(void)
 		 * field.  This means that the fs_u field contains a
 		 * random value when the disk version is examined, but
 		 * fs_cs() gives us a valid pointer nonetheless.
+		 * We need to compare the recalculated summaries to
+		 * both the superblock version and the on disk version.
+		 * If either is bad, copy the calculated version over
+		 * the corrupt values.
 		 */
+
 		cs = &fs->fs_cs(fs, c);
-		bad_csum = (memcmp((void *)cs, (void *)&newcg->cg_cs,
+		bad_csum_sb = (memcmp((void *)cs, (void *)&newcg->cg_cs,
 		    sizeof (*cs)) != 0);
 
+		bad_csum_cg = (memcmp((void *)&cg->cg_cs, (void *)&newcg->cg_cs,
+		    sizeof (struct csum)) != 0);
+
 		/*
 		 * Has the user told us what to do yet?  If not, find out.
 		 */
-		if (bad_csum && (update_csums == -1)) {
+		if ((bad_csum_sb || bad_csum_cg) && (update_csums == -1)) {
 			if (preen) {
 				update_csums = 1;
-				(void) printf("CORRECTING BAD CG SUMMARIES\n");
+				(void) printf("CORRECTING BAD CG SUMMARIES"
+					" FOR CG %d\n", c);
 			} else if (update_csums == -1) {
 				update_csums = (reply(
-				    "CORRECT BAD CG SUMMARIES") == 1);
+				    "CORRECT BAD CG SUMMARIES FOR CG %d",
+				    c) == 1);
 			}
 		}
 
-		if (bad_csum && (update_csums == 1)) {
+		if (bad_csum_sb && (update_csums == 1)) {
 			(void) memmove((void *)cs, (void *)&newcg->cg_cs,
 			    sizeof (*cs));
 			sbdirty();
+			(void) printf("CORRECTED SUPERBLOCK SUMMARIES FOR"
+				    " CG %d\n", c);
+		}
 
-			(void) memmove((void *)cg, (void *)newcg,
-			    (size_t)basesize);
+		if (bad_csum_cg && (update_csums == 1)) {
+			(void) memmove((void *)&cg->cg_cs,
+				    (void *)&newcg->cg_cs,
+				    sizeof (struct csum));
 			/* LINTED per cg_sanity() */
 			(void) memmove((void *)&cg_blktot(cg)[0],
 			    /* LINTED macro aligned as above */
 			    (void *)&cg_blktot(newcg)[0], sumsize);
 			cgdirty();
-			(void) printf("CORRECTED SUMMARY FOR CG %d\n", c);
+			(void) printf("CORRECTED SUMMARIES FOR CG %d\n", c);
 		}
 
 		excessdirs = cg->cg_cs.cs_ndir - newcg->cg_cs.cs_ndir;
diff --git a/usr/src/cmd/fs.d/ufs/fsck/utilities.c b/usr/src/cmd/fs.d/ufs/fsck/utilities.c
index 26d816b47a..fc622b4ba1 100644
--- a/usr/src/cmd/fs.d/ufs/fsck/utilities.c
+++ b/usr/src/cmd/fs.d/ufs/fsck/utilities.c
@@ -1906,7 +1906,7 @@ rawname(caddr_t name)
 	}
 
 caddr_t
-cg_sanity(struct cg *cgp, int cgno, int *is_fatal)
+cg_sanity(struct cg *cgp, int cgno)
 {
 	caddr_t full_err;
 	caddr_t this_err = NULL;
@@ -1920,14 +1920,12 @@ cg_sanity(struct cg *cgp, int cgno, int *is_fatal)
 
 	full_err = NULL;
 	full_len = 0;
-	*is_fatal = 0;
 
 	if (!cg_chkmagic(cgp)) {
 		this_len = fsck_asprintf(&this_err,
 		    "BAD CG MAGIC NUMBER (0x%x should be 0x%x)\n",
 		    cgp->cg_magic, CG_MAGIC);
 		Append_Error(full_err, full_len, this_err, this_len);
-		*is_fatal = 1;
 	}
 
 	if (cgp->cg_cgx != cgno) {
@@ -2157,6 +2155,13 @@ fix_cg(struct cg *cgp, int cgno)
 		cgp->cg_nextfreeoff = exp_nextfreeoff;
 	}
 
+	/*
+	 * Reset the magic, as we've recreated this cg, also
+	 * update the cg_time, as we're writing out the cg
+	 */
+	cgp->cg_magic = CG_MAGIC;
+	cgp->cg_time = time(NULL);
+
 	/*
 	 * We know there was at least one correctable problem,
 	 * or else we wouldn't have been called.  So instead of

