commit a0e4a7563fd575d89cd34411a2c090fae1d826f4
Author: dormando <dormando@rydia.net>
Date:   Fri Apr 10 23:02:14 2009 -0700

    fix resumption of accept loop under multithread
    
    critical fix:
    under multithreaded mode, in version 1.2.7, memcached would not resume
    accepting connections after hitting the max connections limit.
    
    this is due to a pre-existing bug in the accept_new_conns code, which
    was hit when the "fix" was rolled in to ensure listening threads never
    did real work.  Previously, at least one closing connection would
    (randomly) be on the accepting thread, so the test for (are we the
    listening thread?) would still work.

diff --git a/memcached.c b/memcached.c
index 3b89701..e3af50f 100644
--- a/memcached.c
+++ b/memcached.c
@@ -86,7 +86,6 @@ static void settings_init(void);
 static void event_handler(const int fd, const short which, void *arg);
 static void conn_close(conn *c);
 static void conn_init(void);
-static void accept_new_conns(const bool do_accept);
 static bool update_event(conn *c, const int new_flags);
 static void complete_nread(conn *c);
 static void process_command(conn *c, char *command);
@@ -3073,12 +3072,9 @@ static bool update_event(conn *c, const int new_flags) {
 /*
  * Sets whether we are listening for new connections or not.
  */
-void accept_new_conns(const bool do_accept) {
+void do_accept_new_conns(const bool do_accept) {
     conn *next;
 
-    if (! is_listen_thread())
-        return;
-
     for (next = listen_conn; next; next = next->next) {
         if (do_accept) {
             update_event(next, EV_READ | EV_PERSIST);
diff --git a/memcached.h b/memcached.h
index 1d6aabe..5011044 100644
--- a/memcached.h
+++ b/memcached.h
@@ -359,6 +359,7 @@ extern volatile rel_time_t current_time;
 /*
  * Functions
  */
+void do_accept_new_conns(const bool do_accept);
 char *do_add_delta(conn *c, item *item, const bool incr, const int64_t delta,
                    char *buf);
 enum store_item_type do_store_item(item *item, int comm, conn* c);
@@ -388,6 +389,7 @@ void dispatch_conn_new(int sfd, enum conn_states init_state, int event_flags, in
 /* Lock wrappers for cache functions that are called from main loop. */
 char *add_delta(conn *c, item *item, const int incr, const int64_t delta,
                 char *buf);
+void accept_new_conns(const bool do_accept);
 conn *conn_from_freelist(void);
 bool  conn_add_to_freelist(conn *c);
 char *suffix_from_freelist(void);
diff --git a/thread.c b/thread.c
index f46a4b9..b903709 100644
--- a/thread.c
+++ b/thread.c
@@ -36,6 +36,9 @@ struct conn_queue {
 /* Lock for cache operations (item_*, assoc_*) */
 pthread_mutex_t cache_lock;
 
+/* Connection lock around accepting new connections */
+pthread_mutex_t conn_lock = PTHREAD_MUTEX_INITIALIZER;
+
 /* Lock for global stats */
 static pthread_mutex_t stats_lock;
 
@@ -171,6 +174,14 @@ static void create_worker(void *(*func)(void *), void *arg) {
     }
 }
 
+/*
+ * Sets whether or not we accept new connections.
+ */
+void accept_new_conns(const bool do_accept) {
+    pthread_mutex_lock(&conn_lock);
+    do_accept_new_conns(do_accept);
+    pthread_mutex_unlock(&conn_lock);
+}
 /****************************** LIBEVENT THREADS *****************************/
 
 /*

