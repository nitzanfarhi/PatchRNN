commit 94999eaa3e8f176ba5785c0525c2a31daf3292ba
Author: Moe Jette <jette1@llnl.gov>
Date:   Wed Nov 17 00:49:23 2004 +0000

    Add logic to read current BGL partition information (first step of
      synchronizing data in configuration with BGL state).

diff --git a/src/plugins/select/bluegene/bluegene.c b/src/plugins/select/bluegene/bluegene.c
index dd2b466e33..b9e5a36263 100644
--- a/src/plugins/select/bluegene/bluegene.c
+++ b/src/plugins/select/bluegene/bluegene.c
@@ -57,6 +57,7 @@ List bgl_conf_list = NULL;              /* list of bgl_conf_record entries */
 char *bluegene_serial = NULL;
 
 /* Global variables */
+rm_BGL_t *bgl;
 List bgl_list = NULL;			/* list of bgl_record entries */
 
 #define SWAP(a,b,t)	\
@@ -103,7 +104,8 @@ static void _set_bp_node_state(rm_BP_state_t state, rm_element_t *element);
  */
 extern int create_static_partitions(List part_list)
 {
-	/** purge the old list.  Later on, it may be more efficient just to amend the list */
+	int rc = SLURM_SUCCESS;
+
 	if (bgl_list) {
 		bgl_record_t *record;
 		while ((record = list_pop(bgl_list)))
@@ -112,16 +114,17 @@ extern int create_static_partitions(List part_list)
 		bgl_list = list_create(_destroy_bgl_record);
 
 	/** copy the slurm conf partition info, this will fill in bgl_list */
-	if (_copy_slurm_partition_list(part_list))
-		return SLURM_ERROR;
+	if ((rc = _copy_slurm_partition_list(part_list)))
+		return rc;
 
 	_process_config();
 	/* after reading in the configuration, we have a list of partition 
 	 * requests (List <int*>) that we can use to partition up the system
 	 */
-	_wire_bgl_partitions();
+	if ((rc = _wire_bgl_partitions()))
+		return rc;
 
-	return SLURM_SUCCESS;
+	return rc;
 }
 
 /**
@@ -129,10 +132,15 @@ extern int create_static_partitions(List part_list)
  */
 static int _wire_bgl_partitions(void)
 {
+	int rc = SLURM_SUCCESS;
 	bgl_record_t* cur_record;
 	partition_t* cur_partition;
 	ListIterator itr;
 
+	/* read current bgl partition info */
+	if ((rc = read_bgl_partitions()))
+		return rc;
+
 	itr = list_iterator_create(bgl_list);
 	while ((cur_record = (bgl_record_t*) list_next(itr))) {
 		cur_partition = (partition_t*) cur_record->alloc_part;
@@ -141,7 +149,7 @@ static int _wire_bgl_partitions(void)
 	}	
 	list_iterator_destroy(itr);
 
-	return SLURM_SUCCESS;
+	return rc;
 }
 
 /** 
@@ -636,27 +644,27 @@ extern void print_bgl_record(bgl_record_t* record)
 	info(" bgl_record: ");
 	info("\tslurm_part_id: %s", record->slurm_part_id);
 	if (record->bgl_part_id)
-		info("\tbgl_part_id: %d", *(record->bgl_part_id));
+		info("\tbgl_part_id: %s", record->bgl_part_id);
 	info("\tnodes: %s", record->nodes);
 	info("\tsize: %d", record->size);
 	info("\tlifecycle: %s", convert_lifecycle(record->part_lifecycle));
 	info("\tconn_type: %s", convert_conn_type(record->conn_type));
 	info("\tnode_use: %s", convert_node_use(record->node_use));
 
-	if (record->hostlist){
+	if (record->hostlist) {
 		char buffer[BUFSIZE];
 		hostlist_ranged_string(record->hostlist, BUFSIZE, buffer);
 		info("\thostlist %s", buffer);
 	}
 
-	if (record->alloc_part){
+	if (record->alloc_part) {
 		info("\talloc_part:");
 		print_partition(record->alloc_part);
 	} else {
 		info("\talloc_part: NULL");
 	}
 
-	if (record->bitmap){
+	if (record->bitmap) {
 		char bitstring[BITSIZE];
 		bit_fmt(bitstring, BITSIZE, record->bitmap);
 		info("\tbitmap: %s", bitstring);
@@ -931,7 +939,7 @@ extern int submit_job(struct job_record *job_ptr, bitstr_t *slurm_part_bitmap,
 		 */
 		char bgl_part_id[BITSIZE];
 #ifdef USE_BGL_FILES
-		snprintf(bgl_part_id, BITSIZE, "%s", *record->bgl_part_id);
+		snprintf(bgl_part_id, BITSIZE, "%s", record->bgl_part_id);
 #else
 		snprintf(bgl_part_id, BITSIZE, "LLNL_128_16");
 #endif
diff --git a/src/plugins/select/bluegene/bluegene.h b/src/plugins/select/bluegene/bluegene.h
index 1bbb72edc9..e326bcb5e2 100644
--- a/src/plugins/select/bluegene/bluegene.h
+++ b/src/plugins/select/bluegene/bluegene.h
@@ -57,14 +57,14 @@
 #endif
 
 /* Global variables */
-rm_BGL_t *bgl;
+extern rm_BGL_t *bgl;
 
 typedef int lifecycle_type_t;
 enum part_lifecycle {DYNAMIC, STATIC};
 
 typedef struct bgl_record {
 	char* slurm_part_id;		/* ID specified by admins	*/
-	pm_partition_id_t* bgl_part_id;	/* ID returned from CMCS	*/
+	pm_partition_id_t bgl_part_id;	/* ID returned from CMCS	*/
 	char* nodes;			/* String of nodes in partition */
 	lifecycle_type_t part_lifecycle;/* either STATIC or DYNAMIC	*/
 	hostlist_t hostlist;		/* expanded form of hosts */
diff --git a/src/plugins/select/bluegene/partition_sys.c b/src/plugins/select/bluegene/partition_sys.c
index ebbdb1d992..da8de7fa74 100755
--- a/src/plugins/select/bluegene/partition_sys.c
+++ b/src/plugins/select/bluegene/partition_sys.c
@@ -32,6 +32,8 @@
 #include <unistd.h>
 #include "src/common/list.h"
 #include "src/common/xmalloc.h"
+#include "src/common/xstring.h"
+
 #include "partition_sys.h"
 #include "bluegene.h"
 
@@ -55,7 +57,10 @@ List bgl_sys_free = NULL;
 /* global system = list of allocated partitions */
 List bgl_sys_allocated = NULL;
 
-void _init_sys(partition_t*);
+/* Initial bgl partition state information */
+List bgl_init_part_list = NULL;
+
+static void _init_sys(partition_t*);
 
 #ifdef USE_BGL_FILES
    char *BGL_MLOADER_IMAGE = "/bgl/edi/build/bglsys/bin/mmcs-mloader.rts";
@@ -85,14 +90,20 @@ void _init_sys(partition_t*);
    int _get_bp_by_location(rm_BGL_t* my_bgl, int* cur_coord, rm_BP_t** bp);
 #endif
 
-int _create_bgl_partitions(List requests);
+static int  _create_bgl_partitions(List requests);
 
-int _break_up_partition(List sys, partition_t* partition_to_break, 
+static int  _break_up_partition(List sys, partition_t* partition_to_break, 
 		int index);
-int _fit_request(List sys, List allocated, uint16_t* request);
+static int  _fit_request(List sys, List allocated, uint16_t* request);
+
+static void _int_array_destroy(void* object);
+static int  _int_array_cmpf(uint16_t* rec_a, uint16_t* rec_b);
 
-void _int_array_destroy(void* object);
-int _int_array_cmpf(uint16_t* rec_a, uint16_t* rec_b);
+#ifdef HAVE_BGL_FILES
+static void _part_list_del(void *object);
+static int  _part_list_find(void *object, void *key);
+static int  _post_bgl_init_read(void *object, void *arg);
+#endif
 
 #ifdef _UNIT_TESTS_
   extern void debug(const char *fmt, ...);
@@ -108,8 +119,8 @@ int _int_array_cmpf(uint16_t* rec_a, uint16_t* rec_b);
  * 
  * example usage: admin wants to partition system as such: 4x4x4,
  * 2x4x4, 2x4x4 to do this, we would run partition_sys three times with
- * the config as {4,2,2} (X-direction), then {4,4,4}(for Y) and
- * finally {4,4,4}( for Z).
+ * the config as {4,2,2} (X-direction), then {4,4,4} (for Y) and
+ * finally {4,4,4} (for Z).
  * 
  * we should really just have all the config stuff in one struct
  * and then have each element in the configs be of type part_config
@@ -122,8 +133,7 @@ int _int_array_cmpf(uint16_t* rec_a, uint16_t* rec_b);
  * SIDE EFFECT: calls BGL CMCS API that changes the DB2 and
  * essentially wires up the system
  */
-
-int partition_sys(List requests)
+extern int partition_sys(List requests)
 {
 
 	ListIterator itr;
@@ -171,7 +181,7 @@ int partition_sys(List requests)
  * IN - requests: List <partition_t*> to wire up.
  * 
  */
-int _create_bgl_partitions(List requests)
+static int _create_bgl_partitions(List requests)
 {
 	partition_t* cur_partition;	
 	ListIterator itr;
@@ -197,7 +207,7 @@ int _create_bgl_partitions(List requests)
  * we assume that the partitioning done before hand
  * 
  */
- int _fit_request(List sys, List allocated, uint16_t* request)
+static int _fit_request(List sys, List allocated, uint16_t* request)
 {
 	int i, rc = 1;
 	uint16_t* new_request = NULL;
@@ -296,7 +306,7 @@ int _create_bgl_partitions(List requests)
  * odd number sizes, and dimensions will kill this!!!
  * 
  */
- int _break_up_partition(List sys, partition_t* partition_to_break, 
+static int _break_up_partition(List sys, partition_t* partition_to_break, 
 		int index)
 {
 	/* the two new partitions to create */
@@ -496,7 +506,7 @@ void sort_int_array_by_dec_size(List configs)
  * Note: return values are "reversed" so that we can have the list
  * sorted in decreasing order (largest to smallest)
  */
- int _int_array_cmpf(uint16_t* rec_a, uint16_t* rec_b)
+static int _int_array_cmpf(uint16_t* rec_a, uint16_t* rec_b)
 {
 	int vol_a, vol_b;
 
@@ -522,7 +532,7 @@ extern int configure_switches(partition_t* partition)
 {
 	bgl_record_t* bgl_rec;
 	int cur_coord[SYSTEM_DIMENSIONS]; 
-	pm_partition_id_t* bgl_part_id;
+	pm_partition_id_t bgl_part_id;
 	List switch_list;
 	ListIterator itr;
 #ifdef USE_BGL_FILES
@@ -663,20 +673,18 @@ extern int configure_switches(partition_t* partition)
 		} /* end of cur_coord[1]*/
 	} /* end of cur_coord[1]*/
 
-	bgl_part_id = (pm_partition_id_t*) xmalloc(sizeof(pm_partition_id_t));
-
 #ifdef USE_BGL_FILES
-	_post_allocate(bgl_part, bgl_part_id);
+	_post_allocate(bgl_part, &bgl_part_id);
 	bgl_rec = (bgl_record_t*) partition->bgl_record_ptr;
-	bgl_rec->bgl_part_id = bgl_part_id;
-	partition->bgl_part_id = bgl_part_id;
+	bgl_rec->bgl_part_id   = xstrdup(bgl_part_id);
+	partition->bgl_part_id = xstrdup(bgl_part_id);
 
 #else 
 
-	*bgl_part_id = "LLNL_128_16";
+	bgl_part_id = "LLNL_128_16";
 	bgl_rec = (bgl_record_t*) partition->bgl_record_ptr;
-	bgl_rec->bgl_part_id   = bgl_part_id;
-	partition->bgl_part_id = bgl_part_id;
+	bgl_rec->bgl_part_id   = xstrdup(bgl_part_id);
+	partition->bgl_part_id = xstrdup(bgl_part_id);
 
 #endif
 	return SLURM_SUCCESS;
@@ -814,7 +822,7 @@ void rotate_part(const uint16_t* config, uint16_t** new_config)
  * this should really go out and get BGL specific information
  * 
  */
-void _init_sys(partition_t *part)
+static void _init_sys(partition_t *part)
 {
 	/* initialize the system wide partition */
 	bgl_sys_free = list_create((ListDelF) _int_array_destroy);
@@ -840,7 +848,7 @@ void _init_sys(partition_t *part)
 /** 
  * to be used by list object to destroy the array elements
  */
- void _int_array_destroy(void* object)
+static void _int_array_destroy(void* object)
 {
 	xfree(object);
 }
@@ -849,7 +857,7 @@ void _init_sys(partition_t *part)
 /** 
  * initialize the BGL partition in the resource manager 
  */
-void _pre_allocate(rm_partition_t *my_part, 
+static void _pre_allocate(rm_partition_t *my_part, 
 		   rm_connection_type_t part_conn)
 {
 	rm_new_partition(&my_part); /* new partition to be added */
@@ -863,7 +871,7 @@ void _pre_allocate(rm_partition_t *my_part,
 /** 
  * add the partition record to the DB and boot it up!
  */
-int _post_allocate(rm_partition_t *my_part, pm_partition_id_t *part_id)
+static int _post_allocate(rm_partition_t *my_part, pm_partition_id_t *part_id)
 {
 	int rc;
 	rm_partition_state_t state;
@@ -878,7 +886,7 @@ int _post_allocate(rm_partition_t *my_part, pm_partition_id_t *part_id)
 	/* Get back the new partition id */
 	rm_get_data(my_part, RM_PartitionID, &part_id);
 
-	//Initiate boot of the partition
+	/* Initiate boot of the partition */
 	debug("Booting Partition %s", part_id);
 	rc = pm_create_partition(*part_id);
 	if (rc != STATUS_OK) {
@@ -902,7 +910,7 @@ int _post_allocate(rm_partition_t *my_part, pm_partition_id_t *part_id)
 /** 
  * get switch of the BP of these coordinates
  */
-int _get_switch_list(int cur_coord[SYSTEM_DIMENSIONS], List* switch_list)
+static int _get_switch_list(int cur_coord[SYSTEM_DIMENSIONS], List* switch_list)
 {
 	int switch_num, i;
 	rm_BP_t * bp;
@@ -968,7 +976,7 @@ void rm_switch_t_destroy(void* object)
  * this is just stupid.  there are some implicit rules for where
  * "NextBP" goes to, but we don't know, so we have to do this.
  */
-int _get_bp_by_location(rm_BGL_t* my_bgl, int* cur_coord, rm_BP_t** bp)
+static int _get_bp_by_location(rm_BGL_t* my_bgl, int* cur_coord, rm_BP_t** bp)
 {
 	int i, bp_num;
 	rm_location_t loc;
@@ -995,7 +1003,7 @@ int _get_bp_by_location(rm_BGL_t* my_bgl, int* cur_coord, rm_BP_t** bp)
  * 
  * returns 0 if equals, 1 if not equals
  */
-int _is_not_equals_some_coord(int* rec_a, int* rec_b)
+static int _is_not_equals_some_coord(int* rec_a, int* rec_b)
 {
 	int i;
 	for (i=0; i<SYSTEM_DIMENSIONS; i++){
@@ -1010,7 +1018,7 @@ int _is_not_equals_some_coord(int* rec_a, int* rec_b)
  * 
  * returns 0 if equals, 1 if not equals
  */
-int _is_not_equals_all_coord(int* rec_a, int* rec_b)
+static int _is_not_equals_all_coord(int* rec_a, int* rec_b)
 {
 	int i;
 	for (i=0; i<SYSTEM_DIMENSIONS; i++){
@@ -1033,3 +1041,127 @@ extern void init_bgl_partition_num(void)
 	bgl_partition_number = 0;
 }
 
+/*
+ * Download from CMCS the initial BGL partition information
+ */
+extern int read_bgl_partitions(void)
+{
+	int rc = SLURM_SUCCESS;
+
+#ifdef HAVE_BGL_FILES
+	int bp_cnt, i;
+	rm_element_t *bp_ptr;
+	rm_location_t bp_loc;
+	pm_partition_id_t part_id;
+	rm_partition_t *part_ptr;
+	char node_name_tmp[16];
+	bgl_record_t *bgl_part_ptr;
+
+	rm_get_data(bgl, RM_BPNum, &bp_cnt);
+	for (i=0; i<bp_cnt; i++) {
+		if (i)
+			rm_get_data(bgl, RM_NextBP, &bp_ptr);
+		else
+			rm_get_data(bgl, RM_FirstBP, &bp_ptr);
+
+		rm_get_data(bp_ptr, RM_BPLoc, &bp_loc);
+		sprintf(node_name_tmp, "bgl%d%d%d", 
+			bp_loc.X, bp_loc.Y, bp_loc.Z);
+		rm_get_data(bp_ptr, RM_BPPartID, &part_id);
+
+/* FIXME: part_id not returned on LLNL_128_16 system */
+part_id = "LLNL_128_16";
+		if (!part_id || (part_id[0] == '\0')) {
+			info("Node %s in blue gene partition NONE",
+				node_name_tmp);
+			continue;
+		}
+		if (!bgl_init_part_list)
+			bgl_init_part_list = list_create(_part_list_del);
+
+		bgl_part_ptr = list_find_first(bgl_init_part_list, _part_list_find, 
+			part_id);
+		if (!bgl_part_ptr) {
+			/* New BGL partition record */
+			rc = rm_get_partition(part_id, &part_ptr);
+			if (rc) {
+				info("rm_get_partition %s errno=%d",
+					part_id, rc);
+				continue;
+			}
+			bgl_part_ptr = xmalloc(sizeof(bgl_record_t));
+			list_push(bgl_init_part_list, bgl_part_ptr);
+			bgl_part_ptr->bgl_part_id = xstrdup(part_id);
+			bgl_part_ptr->hostlist = hostlist_create(node_name_tmp);
+			rm_get_data(part_ptr, RM_PartitionConnection,
+				&bgl_part_ptr->conn_type);
+			rm_get_data(part_ptr, RM_PartitionMode,
+				&bgl_part_ptr->node_use);
+			bgl_part_ptr->part_lifecycle = STATIC;
+			rm_free_partition(part_ptr);
+		} else {
+			/* Add node name to existing BGL partition record */
+			hostlist_push(bgl_part_ptr->hostlist, node_name_tmp);
+		}
+
+		(bgl_part_ptr->size)++;
+	}
+
+	/* perform post-processing for each bluegene partition */
+	list_for_each(bgl_init_part_list, _post_bgl_init_read, NULL);
+#endif
+	return rc;
+}
+
+#ifdef HAVE_BGL_FILES
+static int _post_bgl_init_read(void *object, void *arg)
+{
+	bgl_record_t *bgl_part_ptr = (bgl_record_t *) object;
+	int i = 32;
+
+	bgl_part_ptr->nodes = xmalloc(i);
+	while (hostlist_ranged_string(bgl_part_ptr->hostlist, i,
+			bgl_part_ptr->nodes) < 0) {
+		i *= 2;
+		xrealloc(bgl_part_ptr->nodes, i);
+	}
+
+bgl_part_ptr->slurm_part_id = xstrdup("TBD");
+	
+	print_bgl_record(bgl_part_ptr);
+
+	return SLURM_SUCCESS;
+}
+
+static void _part_list_del(void *object)
+{
+	bgl_record_t *part_ptr = (bgl_record_t *) object;
+
+	if (part_ptr) {
+		xfree(part_ptr->bgl_part_id);
+		xfree(part_ptr->nodes);
+		xfree(part_ptr->slurm_part_id);
+		if (part_ptr->hostlist)
+			hostlist_destroy(part_ptr->hostlist);
+		xfree(part_ptr);
+	}
+}
+
+static int  _part_list_find(void *object, void *key)
+{
+	bgl_record_t *part_ptr = (bgl_record_t *) object;
+	pm_partition_id_t part_id = (pm_partition_id_t) key;
+
+	if (!part_ptr->bgl_part_id) {
+		error("_part_list_find: bgl_part_id == NULL");
+		return -1;
+	}
+	if (!part_id) {
+		error("_part_list_find: part_id == NULL");
+		return -1;
+	}
+
+	return strcmp(part_ptr->bgl_part_id, part_id);
+}
+#endif
+
diff --git a/src/plugins/select/bluegene/partition_sys.h b/src/plugins/select/bluegene/partition_sys.h
index b19813a91e..d428c10ece 100644
--- a/src/plugins/select/bluegene/partition_sys.h
+++ b/src/plugins/select/bluegene/partition_sys.h
@@ -48,7 +48,7 @@ typedef struct partition {
 	ushort dimensions[SYSTEM_DIMENSIONS]; /* X,Y,Z dimensions */
 	void* bgl_record_ptr;		/* pointer to referring bgl_record */
 	int size;
-	pm_partition_id_t *bgl_part_id;	/* ID returned from CMCS	*/
+	pm_partition_id_t bgl_part_id;	/* ID returned from CMCS	*/
 	ushort conn_type;	/* Type=Mesh/Torus/NAV		*/
 	ushort node_use;	/* Use=Virtual/Coprocessor	*/
 } partition_t;
@@ -71,4 +71,9 @@ extern void sort_partitions_by_inc_size(List partitions);
 extern void sort_partitions_by_dec_size(List partitions);
 extern void init_bgl_partition_num(void);
 
+/*
+ * Download from CMCS the initial BGL partition information
+ */
+extern int read_bgl_partitions(void);
+
 #endif /* _PARTITION_SYS_H_ */

