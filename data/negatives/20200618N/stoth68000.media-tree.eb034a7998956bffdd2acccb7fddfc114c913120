commit eb034a7998956bffdd2acccb7fddfc114c913120
Author: Richard Knutsson <ricknu-0@student.ltu.se>
Date:   Sat May 19 22:18:10 2007 +0200

    tulip: Convert to generic boolean
    
    Signed-off-by: Richard Knutsson <ricknu-0@student.ltu.se>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/net/tulip/de4x5.c b/drivers/net/tulip/de4x5.c
index 62143f92c231..42fca26afc50 100644
--- a/drivers/net/tulip/de4x5.c
+++ b/drivers/net/tulip/de4x5.c
@@ -597,7 +597,7 @@ static char *args;
 #endif
 
 struct parameters {
-    int fdx;
+    bool fdx;
     int autosense;
 };
 
@@ -809,10 +809,10 @@ struct de4x5_private {
     s32  irq_en;                            /* Summary interrupt bits       */
     int  media;                             /* Media (eg TP), mode (eg 100B)*/
     int  c_media;                           /* Remember the last media conn */
-    int  fdx;                               /* media full duplex flag       */
+    bool fdx;                               /* media full duplex flag       */
     int  linkOK;                            /* Link is OK                   */
     int  autosense;                         /* Allow/disallow autosensing   */
-    int  tx_enable;                         /* Enable descriptor polling    */
+    bool tx_enable;                         /* Enable descriptor polling    */
     int  setup_f;                           /* Setup frame filtering type   */
     int  local_state;                       /* State within a 'media' state */
     struct mii_phy phy[DE4X5_MAX_PHY];      /* List of attached PHY devices */
@@ -838,8 +838,8 @@ struct de4x5_private {
     struct de4x5_srom srom;                 /* A copy of the SROM           */
     int cfrv;				    /* Card CFRV copy */
     int rx_ovf;                             /* Check for 'RX overflow' tag  */
-    int useSROM;                            /* For non-DEC card use SROM    */
-    int useMII;                             /* Infoblock using the MII      */
+    bool useSROM;                           /* For non-DEC card use SROM    */
+    bool useMII;                            /* Infoblock using the MII      */
     int asBitValid;                         /* Autosense bits in GEP?       */
     int asPolarity;                         /* 0 => asserted high           */
     int asBit;                              /* Autosense bit number in GEP  */
@@ -928,7 +928,7 @@ static int     dc21040_state(struct net_device *dev, int csr13, int csr14, int c
 static int     test_media(struct net_device *dev, s32 irqs, s32 irq_mask, s32 csr13, s32 csr14, s32 csr15, s32 msec);
 static int     test_for_100Mb(struct net_device *dev, int msec);
 static int     wait_for_link(struct net_device *dev);
-static int     test_mii_reg(struct net_device *dev, int reg, int mask, int pol, long msec);
+static int     test_mii_reg(struct net_device *dev, int reg, int mask, bool pol, long msec);
 static int     is_spd_100(struct net_device *dev);
 static int     is_100_up(struct net_device *dev);
 static int     is_10_up(struct net_device *dev);
@@ -1109,7 +1109,7 @@ de4x5_hw_init(struct net_device *dev, u_long iobase, struct device *gendev)
     /*
     ** Now find out what kind of DC21040/DC21041/DC21140 board we have.
     */
-    lp->useSROM = FALSE;
+    lp->useSROM = false;
     if (lp->bus == PCI) {
 	PCI_signature(name, lp);
     } else {
@@ -1137,7 +1137,7 @@ de4x5_hw_init(struct net_device *dev, u_long iobase, struct device *gendev)
 	lp->cache.gepc = GEP_INIT;
 	lp->asBit = GEP_SLNK;
 	lp->asPolarity = GEP_SLNK;
-	lp->asBitValid = TRUE;
+	lp->asBitValid = ~0;
 	lp->timeout = -1;
 	lp->gendev = gendev;
 	spin_lock_init(&lp->lock);
@@ -1463,7 +1463,7 @@ de4x5_queue_pkt(struct sk_buff *skb, struct net_device *dev)
     u_long flags = 0;
 
     netif_stop_queue(dev);
-    if (lp->tx_enable == NO) {                   /* Cannot send for now */
+    if (!lp->tx_enable) {                   /* Cannot send for now */
 	return -1;
     }
 
@@ -2424,7 +2424,7 @@ dc21040_autoconf(struct net_device *dev)
     switch (lp->media) {
     case INIT:
 	DISABLE_IRQs;
-	lp->tx_enable = NO;
+	lp->tx_enable = false;
 	lp->timeout = -1;
 	de4x5_save_skbs(dev);
 	if ((lp->autosense == AUTO) || (lp->autosense == TP)) {
@@ -2477,7 +2477,7 @@ dc21040_autoconf(struct net_device *dev)
 	    lp->c_media = lp->media;
 	}
 	lp->media = INIT;
-	lp->tx_enable = NO;
+	lp->tx_enable = false;
 	break;
     }
 
@@ -2578,7 +2578,7 @@ dc21041_autoconf(struct net_device *dev)
     switch (lp->media) {
     case INIT:
 	DISABLE_IRQs;
-	lp->tx_enable = NO;
+	lp->tx_enable = false;
 	lp->timeout = -1;
 	de4x5_save_skbs(dev);          /* Save non transmitted skb's */
 	if ((lp->autosense == AUTO) || (lp->autosense == TP_NW)) {
@@ -2757,7 +2757,7 @@ dc21041_autoconf(struct net_device *dev)
 	    lp->c_media = lp->media;
 	}
 	lp->media = INIT;
-	lp->tx_enable = NO;
+	lp->tx_enable = false;
 	break;
     }
 
@@ -2781,7 +2781,7 @@ dc21140m_autoconf(struct net_device *dev)
     case INIT:
         if (lp->timeout < 0) {
 	    DISABLE_IRQs;
-	    lp->tx_enable = FALSE;
+	    lp->tx_enable = false;
 	    lp->linkOK = 0;
 	    de4x5_save_skbs(dev);          /* Save non transmitted skb's */
 	}
@@ -2830,7 +2830,7 @@ dc21140m_autoconf(struct net_device *dev)
 	    if (lp->timeout < 0) {
 		mii_wr(MII_CR_ASSE | MII_CR_RAN, MII_CR, lp->phy[lp->active].addr, DE4X5_MII);
 	    }
-	    cr = test_mii_reg(dev, MII_CR, MII_CR_RAN, FALSE, 500);
+	    cr = test_mii_reg(dev, MII_CR, MII_CR_RAN, false, 500);
 	    if (cr < 0) {
 		next_tick = cr & ~TIMER_CB;
 	    } else {
@@ -2845,7 +2845,7 @@ dc21140m_autoconf(struct net_device *dev)
 	    break;
 
 	case 1:
-	    if ((sr=test_mii_reg(dev, MII_SR, MII_SR_ASSC, TRUE, 2000)) < 0) {
+	    if ((sr=test_mii_reg(dev, MII_SR, MII_SR_ASSC, true, 2000)) < 0) {
 		next_tick = sr & ~TIMER_CB;
 	    } else {
 		lp->media = SPD_DET;
@@ -2857,10 +2857,10 @@ dc21140m_autoconf(struct net_device *dev)
 		    if (!(anlpa & MII_ANLPA_RF) &&
 			 (cap = anlpa & MII_ANLPA_TAF & ana)) {
 			if (cap & MII_ANA_100M) {
-			    lp->fdx = ((ana & anlpa & MII_ANA_FDAM & MII_ANA_100M) ? TRUE : FALSE);
+			    lp->fdx = (ana & anlpa & MII_ANA_FDAM & MII_ANA_100M) != 0;
 			    lp->media = _100Mb;
 			} else if (cap & MII_ANA_10M) {
-			    lp->fdx = ((ana & anlpa & MII_ANA_FDAM & MII_ANA_10M) ? TRUE : FALSE);
+			    lp->fdx = (ana & anlpa & MII_ANA_FDAM & MII_ANA_10M) != 0;
 
 			    lp->media = _10Mb;
 			}
@@ -2932,7 +2932,7 @@ dc21140m_autoconf(struct net_device *dev)
 	    lp->c_media = lp->media;
 	}
 	lp->media = INIT;
-	lp->tx_enable = FALSE;
+	lp->tx_enable = false;
 	break;
     }
 
@@ -2965,7 +2965,7 @@ dc2114x_autoconf(struct net_device *dev)
     case INIT:
         if (lp->timeout < 0) {
 	    DISABLE_IRQs;
-	    lp->tx_enable = FALSE;
+	    lp->tx_enable = false;
 	    lp->linkOK = 0;
             lp->timeout = -1;
 	    de4x5_save_skbs(dev);            /* Save non transmitted skb's */
@@ -3013,7 +3013,7 @@ dc2114x_autoconf(struct net_device *dev)
 	    if (lp->timeout < 0) {
 		mii_wr(MII_CR_ASSE | MII_CR_RAN, MII_CR, lp->phy[lp->active].addr, DE4X5_MII);
 	    }
-	    cr = test_mii_reg(dev, MII_CR, MII_CR_RAN, FALSE, 500);
+	    cr = test_mii_reg(dev, MII_CR, MII_CR_RAN, false, 500);
 	    if (cr < 0) {
 		next_tick = cr & ~TIMER_CB;
 	    } else {
@@ -3028,7 +3028,8 @@ dc2114x_autoconf(struct net_device *dev)
 	    break;
 
 	case 1:
-	    if ((sr=test_mii_reg(dev, MII_SR, MII_SR_ASSC, TRUE, 2000)) < 0) {
+	    sr = test_mii_reg(dev, MII_SR, MII_SR_ASSC, true, 2000);
+	    if (sr < 0) {
 		next_tick = sr & ~TIMER_CB;
 	    } else {
 		lp->media = SPD_DET;
@@ -3040,10 +3041,10 @@ dc2114x_autoconf(struct net_device *dev)
 		    if (!(anlpa & MII_ANLPA_RF) &&
 			 (cap = anlpa & MII_ANLPA_TAF & ana)) {
 			if (cap & MII_ANA_100M) {
-			    lp->fdx = ((ana & anlpa & MII_ANA_FDAM & MII_ANA_100M) ? TRUE : FALSE);
+			    lp->fdx = (ana & anlpa & MII_ANA_FDAM & MII_ANA_100M) != 0;
 			    lp->media = _100Mb;
 			} else if (cap & MII_ANA_10M) {
-			    lp->fdx = ((ana & anlpa & MII_ANA_FDAM & MII_ANA_10M) ? TRUE : FALSE);
+			    lp->fdx = (ana & anlpa & MII_ANA_FDAM & MII_ANA_10M) != 0;
 			    lp->media = _10Mb;
 			}
 		    }
@@ -3222,14 +3223,14 @@ srom_map_media(struct net_device *dev)
 {
     struct de4x5_private *lp = netdev_priv(dev);
 
-    lp->fdx = 0;
+    lp->fdx = false;
     if (lp->infoblock_media == lp->media)
       return 0;
 
     switch(lp->infoblock_media) {
       case SROM_10BASETF:
 	if (!lp->params.fdx) return -1;
-	lp->fdx = TRUE;
+	lp->fdx = true;
       case SROM_10BASET:
 	if (lp->params.fdx && !lp->fdx) return -1;
 	if ((lp->chipset == DC21140) || ((lp->chipset & ~0x00ff) == DC2114x)) {
@@ -3249,7 +3250,7 @@ srom_map_media(struct net_device *dev)
 
       case SROM_100BASETF:
         if (!lp->params.fdx) return -1;
-	lp->fdx = TRUE;
+	lp->fdx = true;
       case SROM_100BASET:
 	if (lp->params.fdx && !lp->fdx) return -1;
 	lp->media = _100Mb;
@@ -3261,7 +3262,7 @@ srom_map_media(struct net_device *dev)
 
       case SROM_100BASEFF:
 	if (!lp->params.fdx) return -1;
-	lp->fdx = TRUE;
+	lp->fdx = true;
       case SROM_100BASEF:
 	if (lp->params.fdx && !lp->fdx) return -1;
 	lp->media = _100Mb;
@@ -3297,7 +3298,7 @@ de4x5_init_connection(struct net_device *dev)
     spin_lock_irqsave(&lp->lock, flags);
     de4x5_rst_desc_ring(dev);
     de4x5_setup_intr(dev);
-    lp->tx_enable = YES;
+    lp->tx_enable = true;
     spin_unlock_irqrestore(&lp->lock, flags);
     outl(POLL_DEMAND, DE4X5_TPD);
 
@@ -3336,7 +3337,7 @@ de4x5_reset_phy(struct net_device *dev)
             }
         }
 	if (lp->useMII) {
-	    next_tick = test_mii_reg(dev, MII_CR, MII_CR_RST, FALSE, 500);
+	    next_tick = test_mii_reg(dev, MII_CR, MII_CR_RST, false, 500);
 	}
     } else if (lp->chipset == DC21140) {
 	PHY_HARD_RESET;
@@ -3466,7 +3467,7 @@ wait_for_link(struct net_device *dev)
 **
 */
 static int
-test_mii_reg(struct net_device *dev, int reg, int mask, int pol, long msec)
+test_mii_reg(struct net_device *dev, int reg, int mask, bool pol, long msec)
 {
     struct de4x5_private *lp = netdev_priv(dev);
     int test;
@@ -3476,9 +3477,8 @@ test_mii_reg(struct net_device *dev, int reg, int mask, int pol, long msec)
 	lp->timeout = msec/100;
     }
 
-    if (pol) pol = ~0;
     reg = mii_rd((u_char)reg, lp->phy[lp->active].addr, DE4X5_MII) & mask;
-    test = (reg ^ pol) & mask;
+    test = (reg ^ (pol ? ~0 : 0)) & mask;
 
     if (test && --lp->timeout) {
 	reg = 100 | TIMER_CB;
@@ -3992,10 +3992,10 @@ PCI_signature(char *name, struct de4x5_private *lp)
 			     )))))));
 	}
 	if (lp->chipset != DC21041) {
-	    lp->useSROM = TRUE;             /* card is not recognisably DEC */
+	    lp->useSROM = true;             /* card is not recognisably DEC */
 	}
     } else if ((lp->chipset & ~0x00ff) == DC2114x) {
-	lp->useSROM = TRUE;
+	lp->useSROM = true;
     }
 
     return status;
@@ -4216,7 +4216,7 @@ srom_repair(struct net_device *dev, int card)
 	memset((char *)&lp->srom, 0, sizeof(struct de4x5_srom));
 	memcpy(lp->srom.ieee_addr, (char *)dev->dev_addr, ETH_ALEN);
 	memcpy(lp->srom.info, (char *)&srom_repair_info[SMC-1], 100);
-	lp->useSROM = TRUE;
+	lp->useSROM = true;
 	break;
     }
 
@@ -4392,7 +4392,7 @@ srom_infoleaf_info(struct net_device *dev)
 	if (lp->chipset == infoleaf_array[i].chipset) break;
     }
     if (i == INFOLEAF_SIZE) {
-	lp->useSROM = FALSE;
+	lp->useSROM = false;
 	printk("%s: Cannot find correct chipset for SROM decoding!\n",
 	                                                          dev->name);
 	return -ENXIO;
@@ -4409,7 +4409,7 @@ srom_infoleaf_info(struct net_device *dev)
 	    if (lp->device == *p) break;
 	}
 	if (i == 0) {
-	    lp->useSROM = FALSE;
+	    lp->useSROM = false;
 	    printk("%s: Cannot find correct PCI device [%d] for SROM decoding!\n",
 	                                               dev->name, lp->device);
 	    return -ENXIO;
@@ -4542,7 +4542,7 @@ dc21140_infoleaf(struct net_device *dev)
 	}
 	lp->media = INIT;
 	lp->tcount = 0;
-	lp->tx_enable = FALSE;
+	lp->tx_enable = false;
     }
 
     return next_tick & ~TIMER_CB;
@@ -4577,7 +4577,7 @@ dc21142_infoleaf(struct net_device *dev)
 	}
 	lp->media = INIT;
 	lp->tcount = 0;
-	lp->tx_enable = FALSE;
+	lp->tx_enable = false;
     }
 
     return next_tick & ~TIMER_CB;
@@ -4611,7 +4611,7 @@ dc21143_infoleaf(struct net_device *dev)
 	}
 	lp->media = INIT;
 	lp->tcount = 0;
-	lp->tx_enable = FALSE;
+	lp->tx_enable = false;
     }
 
     return next_tick & ~TIMER_CB;
@@ -4650,7 +4650,7 @@ compact_infoblock(struct net_device *dev, u_char count, u_char *p)
 	lp->asBit = 1 << ((csr6 >> 1) & 0x07);
 	lp->asPolarity = ((csr6 & 0x80) ? -1 : 0) & lp->asBit;
 	lp->infoblock_csr6 = OMR_DEF | ((csr6 & 0x71) << 18);
-	lp->useMII = FALSE;
+	lp->useMII = false;
 
 	de4x5_switch_mac_port(dev);
     }
@@ -4691,7 +4691,7 @@ type0_infoblock(struct net_device *dev, u_char count, u_char *p)
 	lp->asBit = 1 << ((csr6 >> 1) & 0x07);
 	lp->asPolarity = ((csr6 & 0x80) ? -1 : 0) & lp->asBit;
 	lp->infoblock_csr6 = OMR_DEF | ((csr6 & 0x71) << 18);
-	lp->useMII = FALSE;
+	lp->useMII = false;
 
 	de4x5_switch_mac_port(dev);
     }
@@ -4731,7 +4731,7 @@ type1_infoblock(struct net_device *dev, u_char count, u_char *p)
         lp->ibn = 1;
         lp->active = *p;
 	lp->infoblock_csr6 = OMR_MII_100;
-	lp->useMII = TRUE;
+	lp->useMII = true;
 	lp->infoblock_media = ANS;
 
 	de4x5_switch_mac_port(dev);
@@ -4773,7 +4773,7 @@ type2_infoblock(struct net_device *dev, u_char count, u_char *p)
         lp->cache.gepc = ((s32)(TWIDDLE(p)) << 16); p += 2;
         lp->cache.gep  = ((s32)(TWIDDLE(p)) << 16);
 	lp->infoblock_csr6 = OMR_SIA;
-	lp->useMII = FALSE;
+	lp->useMII = false;
 
 	de4x5_switch_mac_port(dev);
     }
@@ -4814,7 +4814,7 @@ type3_infoblock(struct net_device *dev, u_char count, u_char *p)
 	lp->active = *p;
 	if (MOTO_SROM_BUG) lp->active = 0;
 	lp->infoblock_csr6 = OMR_MII_100;
-	lp->useMII = TRUE;
+	lp->useMII = true;
 	lp->infoblock_media = ANS;
 
 	de4x5_switch_mac_port(dev);
@@ -4856,7 +4856,7 @@ type4_infoblock(struct net_device *dev, u_char count, u_char *p)
 	lp->asBit = 1 << ((csr6 >> 1) & 0x07);
 	lp->asPolarity = ((csr6 & 0x80) ? -1 : 0) & lp->asBit;
 	lp->infoblock_csr6 = OMR_DEF | ((csr6 & 0x71) << 18);
-	lp->useMII = FALSE;
+	lp->useMII = false;
 
 	de4x5_switch_mac_port(dev);
     }
@@ -5077,7 +5077,7 @@ mii_get_phy(struct net_device *dev)
     int id;
 
     lp->active = 0;
-    lp->useMII = TRUE;
+    lp->useMII = true;
 
     /* Search the MII address space for possible PHY devices */
     for (n=0, lp->mii_cnt=0, i=1; !((i==1) && (n==1)); i=(i+1)%DE4X5_MAX_MII) {
@@ -5127,7 +5127,7 @@ mii_get_phy(struct net_device *dev)
 	    de4x5_dbg_mii(dev, k);
 	}
     }
-    if (!lp->mii_cnt) lp->useMII = FALSE;
+    if (!lp->mii_cnt) lp->useMII = false;
 
     return lp->mii_cnt;
 }
diff --git a/drivers/net/tulip/de4x5.h b/drivers/net/tulip/de4x5.h
index 57226e5eb8a6..12af0cc037fb 100644
--- a/drivers/net/tulip/de4x5.h
+++ b/drivers/net/tulip/de4x5.h
@@ -892,15 +892,6 @@
 #define ALL                  0     /* Clear out all the setup frame */
 #define PHYS_ADDR_ONLY       1     /* Update the physical address only */
 
-/*
-** Booleans
-*/
-#define NO                   0
-#define FALSE                0
-
-#define YES                  ~0
-#define TRUE                 ~0
-
 /*
 ** Adapter state
 */

