commit d5553a556165535337ece8592f066407c62eec2e
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Jan 20 15:26:13 2011 -0800

    RTC: Properly handle rtc_read_alarm error propagation and fix bug
    
    In reviewing cases where the virtualized interfaces didn't propagate
    errors properly, I noticed rtc_read_alarm needed fixing. In doing
    so I noticed my RTC rework dropped a memset and that the behavior
    of rtc_read_alarm shouldn't be conditionalized on the alarm.enabled
    flag (as the alarm may be set, but the irqs may be disabled). So
    those were corrected as well.
    
    CC: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    LKML-Reference: <1295565973-14358-2-git-send-email-john.stultz@linaro.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/rtc/interface.c b/drivers/rtc/interface.c
index f1ba2c696528..925006d33109 100644
--- a/drivers/rtc/interface.c
+++ b/drivers/rtc/interface.c
@@ -123,12 +123,18 @@ int rtc_read_alarm(struct rtc_device *rtc, struct rtc_wkalrm *alarm)
 	err = mutex_lock_interruptible(&rtc->ops_lock);
 	if (err)
 		return err;
-	alarm->enabled = rtc->aie_timer.enabled;
-	if (alarm->enabled)
+	if (rtc->ops == NULL)
+		err = -ENODEV;
+	else if (!rtc->ops->read_alarm)
+		err = -EINVAL;
+	else {
+		memset(alarm, 0, sizeof(struct rtc_wkalrm));
+		alarm->enabled = rtc->aie_timer.enabled;
 		alarm->time = rtc_ktime_to_tm(rtc->aie_timer.node.expires);
+	}
 	mutex_unlock(&rtc->ops_lock);
 
-	return 0;
+	return err;
 }
 EXPORT_SYMBOL_GPL(rtc_read_alarm);
 

