commit 0cce8fe64fda23e32a76e79965d6e0860cdbc7e2
Author: wm4 <wm4@nowhere>
Date:   Thu Jul 31 04:49:24 2014 +0200

    audio: fix A/V sync in encoding mode
    
    In encoding mode, the AO pretends to be infinitely fast (it will take
    whatever we write, without ever rejecting input). Commit 261506e3 broke
    this somehow. It turns out an old hack dealing with this was accidentally
    dropped.
    
    This is the hunk of code whose semantics were (partially) dropped:
    
        if (mpctx->d_audio && (mpctx->restart_playback ? !video_left :
                               ao_untimed(mpctx->ao) && (mpctx->delay <= 0 ||
                                                         !video_left)))
        {
            int status = fill_audio_out_buffers(mpctx, endpts);
            // Not at audio stream EOF yet
            audio_left = status > -2;
        }
    
    This if condition is pretty wild, and it looked like it was pretty much
    for audio-only mode, rather than subtle handling for encoding mode.

diff --git a/player/audio.c b/player/audio.c
index 849944cf91..f23f6db5cc 100644
--- a/player/audio.c
+++ b/player/audio.c
@@ -383,6 +383,11 @@ void fill_audio_out_buffers(struct MPContext *mpctx, double endpts)
         return; // try again next iteration
     }
 
+    // If audio is infinitely fast, somehow try keeping approximate A/V sync.
+    if (mpctx->audio_status == STATUS_PLAYING && ao_untimed(mpctx->ao) &&
+        !(mpctx->video_status == STATUS_EOF || mpctx->delay <= 0))
+        return;
+
     // if paused, just initialize things (audio format & pts)
     int playsize = 1;
     if (!mpctx->paused)

