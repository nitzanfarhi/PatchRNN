commit 0cdfbbd340bc783ce80435531177b3c069bedf46
Author: Jordan DeLong <jdelong@fb.com>
Date:   Thu Nov 21 16:02:10 2013 -0800

    Flatten APCObject
    
    Put the property vector immediate following APCObject in
    memory.
    
    Reviewed By: @edwinsmith
    
    Differential Revision: D1070249

diff --git a/hphp/runtime/base/apc-handle.cpp b/hphp/runtime/base/apc-handle.cpp
index b285252670..29950b31bf 100644
--- a/hphp/runtime/base/apc-handle.cpp
+++ b/hphp/runtime/base/apc-handle.cpp
@@ -115,8 +115,8 @@ StringCase:
       return APCArray::MakeShared();
 
     case KindOfObject:
-      return (unserializeObj) ? APCObject::MakeShared(source.getObjectData())
-                              : APCObject::MakeShared(apc_serialize(source));
+      return unserializeObj ? APCObject::Construct(source.getObjectData())
+                            : APCObject::MakeShared(apc_serialize(source));
 
     default:
       return nullptr;
diff --git a/hphp/runtime/base/apc-object.cpp b/hphp/runtime/base/apc-object.cpp
index 1f9c04746e..7be2eaca9a 100644
--- a/hphp/runtime/base/apc-object.cpp
+++ b/hphp/runtime/base/apc-object.cpp
@@ -34,30 +34,32 @@ namespace HPHP {
 //////////////////////////////////////////////////////////////////////
 
 ALWAYS_INLINE
-APCObject::APCObject(ObjectData* obj)
+APCObject::APCObject(ObjectData* obj, uint32_t propCount)
   : m_handle(KindOfObject)
   , m_cls{obj->getVMClass()}
+  , m_propCount{propCount}
 {
+  m_handle.setIsObj();
+  m_handle.mustCache();
+}
+
+APCHandle* APCObject::Construct(ObjectData* objectData) {
   // This function assumes the object and object/array down the tree
   // have no internal references and do not implement the serializable
   // interface.
-  assert(!obj->instanceof(SystemLib::s_SerializableClass));
+  assert(!objectData->instanceof(SystemLib::s_SerializableClass));
 
-  m_handle.setIsObj();
-  m_handle.mustCache();
+  Array odProps;
+  objectData->o_getArray(odProps, false);
+  auto const propCount = odProps.size();
 
-  Array props;
-  obj->o_getArray(props, false);
-  m_propCount = 0;
-  if (props.empty()) {
-    m_props = nullptr;
-    return;
-  }
-
-  m_props = static_cast<Prop*>(malloc(sizeof(Prop) * props.size()));
+  auto const apcObj = new (
+    std::malloc(sizeof(APCObject) + sizeof(Prop) * propCount)
+  ) APCObject(objectData, propCount);
+  if (!propCount) return apcObj->getHandle();
 
-  for (ArrayIter it(props); !it.end(); it.next()) {
-    assert(m_propCount < props.size());
+  auto prop = apcObj->props();
+  for (ArrayIter it(odProps); !it.end(); it.next()) {
     Variant key(it.first());
     assert(key.isString());
     CVarRef value = it.secondRef();
@@ -67,48 +69,55 @@ APCObject::APCObject(ObjectData* obj)
     }
 
     const String& keySD = key.asCStrRef();
-    auto& prop = m_props[m_propCount];
 
     if (!keySD->empty() && *keySD->data() == '\0') {
       int32_t subLen = keySD.find('\0', 1) + 1;
       String cls = keySD.substr(1, subLen - 2);
       if (cls.size() == 1 && cls[0] == '*') {
         // Protected.
-        prop.ctx = ClassOrString{nullptr};
+        prop->ctx = ClassOrString{nullptr};
       } else {
         // Private.
-        prop.ctx = ClassOrString{Unit::lookupClass(cls.get())};
+        prop->ctx = ClassOrString{Unit::lookupClass(cls.get())};
       }
 
-      prop.name = makeStaticString(keySD.substr(subLen));
+      prop->name = makeStaticString(keySD.substr(subLen));
     } else {
-      prop.ctx = ClassOrString{nullptr};
-      prop.name = makeStaticString(keySD.get());
+      prop->ctx = ClassOrString{nullptr};
+      prop->name = makeStaticString(keySD.get());
     }
 
-    prop.val = val;
+    prop->val = val;
 
-    ++m_propCount;
+    ++prop;
   }
+  assert(prop == apcObj->props() + propCount);
+
+  return apcObj->getHandle();
 }
 
 ALWAYS_INLINE
 APCObject::~APCObject() {
-  if (!m_props) return;
-  for (int i = 0; i < m_propCount; i++) {
-    if (m_props[i].val) m_props[i].val->decRef();
-    assert(m_props[i].name->isStatic());
+  for (auto i = uint32_t{0}; i < m_propCount; ++i) {
+    if (props()[i].val) props()[i].val->decRef();
+    assert(props()[i].name->isStatic());
   }
-  free(m_props);
 }
 
-//////////////////////////////////////////////////////////////////////
+void APCObject::Delete(APCHandle* handle) {
+  if (!handle->getIsObj()) {
+    delete APCString::fromHandle(handle);
+    return;
+  }
 
-APCHandle* APCObject::MakeShared(ObjectData* data) {
-  auto const apcObj = new APCObject(data);
-  return apcObj->getHandle();
+  auto const obj = fromHandle(handle);
+  obj->~APCObject();
+  // No need to run Prop destructors.
+  std::free(obj);
 }
 
+//////////////////////////////////////////////////////////////////////
+
 APCHandle* APCObject::MakeAPCObject(APCHandle* obj, CVarRef value) {
   if (!value.is(KindOfObject) || obj->getObjAttempted()) {
     return nullptr;
@@ -136,11 +145,6 @@ Variant APCObject::MakeObject(APCHandle* handle) {
   return apc_unserialize(serObj->data(), serObj->size());
 }
 
-void APCObject::Delete(APCHandle* handle) {
-  (handle->getIsObj()) ? delete APCObject::fromHandle(handle)
-                       : delete APCString::fromHandle(handle);
-}
-
 Object APCObject::createObject() const {
   Object obj;
 
@@ -158,26 +162,25 @@ Object APCObject::createObject() const {
   obj = ObjectData::newInstance(const_cast<Class*>(klass));
   obj.get()->clearNoDestruct();
 
-  if (auto prop = m_props) {
-    auto const propEnd = prop + m_propCount;
-    for (; prop != propEnd; ++prop) {
-      auto const key = prop->name;
+  auto prop = props();
+  auto const propEnd = prop + m_propCount;
+  for (; prop != propEnd; ++prop) {
+    auto const key = prop->name;
 
-      const Class* ctx = nullptr;
-      if (prop->ctx.isNull()) {
-        ctx = klass;
+    const Class* ctx = nullptr;
+    if (prop->ctx.isNull()) {
+      ctx = klass;
+    } else {
+      if (auto const cls = prop->ctx.cls()) {
+        ctx = prop->ctx.cls();
       } else {
-        if (auto const cls = prop->ctx.cls()) {
-          ctx = prop->ctx.cls();
-        } else {
-          ctx = Unit::lookupClass(prop->ctx.name());
-          if (!ctx) continue;
-        }
+        ctx = Unit::lookupClass(prop->ctx.name());
+        if (!ctx) continue;
       }
-
-      auto val = prop->val ? prop->val->toLocal() : null_variant;
-      obj->setProp(const_cast<Class*>(ctx), key, val.asTypedValue(), false);
     }
+
+    auto val = prop->val ? prop->val->toLocal() : null_variant;
+    obj->setProp(const_cast<Class*>(ctx), key, val.asTypedValue(), false);
   }
 
   obj->invokeWakeup();
@@ -192,15 +195,11 @@ void APCObject::getSizeStats(APCHandleStats* stats) const {
   stats->initStats();
   stats->dataTotalSize += sizeof(APCObject) + sizeof(Prop) * m_propCount;
 
-  for (int i = 0; i < m_propCount; i++) {
-    auto const sd = m_props[i].name;
-    if (!sd->isStatic()) {
-      stats->dataSize += sd->size();
-      stats->dataTotalSize += sizeof(StringData) + sd->size();
-    }
-    if (m_props[i].val) {
+  for (auto i = uint32_t{0}; i < m_propCount; ++i) {
+    assert(props()[i].name->isStatic());
+    if (props()[i].val) {
       APCHandleStats childStats;
-      m_props[i].val->getStats(&childStats);
+      props()[i].val->getStats(&childStats);
       stats->addChildStats(&childStats);
     }
   }
@@ -209,13 +208,9 @@ void APCObject::getSizeStats(APCHandleStats* stats) const {
 int32_t APCObject::getSpaceUsage() const {
   int32_t size = sizeof(APCObject) + sizeof(Prop) * m_propCount;
 
-  for (int i = 0; i < m_propCount; i++) {
-    auto const sd = m_props[i].name;
-    if (!sd->isStatic()) {
-      size += sizeof(StringData) + sd->size();
-    }
-    if (m_props[i].val) {
-      size += m_props[i].val->getSpaceUsage();
+  for (auto i = uint32_t{0}; i < m_propCount; ++i) {
+    if (props()[i].val) {
+      size += props()[i].val->getSpaceUsage();
     }
   }
   return size;
diff --git a/hphp/runtime/base/apc-object.h b/hphp/runtime/base/apc-object.h
index ba1926b774..e93940964a 100644
--- a/hphp/runtime/base/apc-object.h
+++ b/hphp/runtime/base/apc-object.h
@@ -36,6 +36,11 @@ namespace HPHP {
  * MakeObject and Delete take care of isolating callers from that detail.
  */
 struct APCObject {
+  /*
+   * Create an APCObject from an ObjectData*; returns its APCHandle.
+   */
+  static APCHandle* Construct(ObjectData* data);
+
   // Return an APCObject instance from a serialized version of the
   // object.  May return null.
   static APCHandle* MakeAPCObject(APCHandle* obj, CVarRef value);
@@ -100,7 +105,7 @@ private:
   };
 
 private:
-  explicit APCObject(ObjectData* obj);
+  explicit APCObject(ObjectData*, uint32_t propCount);
   ~APCObject();
   APCObject(const APCObject&) = delete;
   APCObject& operator=(const APCObject&) = delete;
@@ -111,14 +116,19 @@ private:
     handle->mustCache();
     return handle;
   }
-  static APCHandle* MakeShared(ObjectData* data);
+
+private:
   Object createObject() const;
 
+  Prop* props() { return reinterpret_cast<Prop*>(this + 1); }
+  const Prop* props() const {
+    return const_cast<APCObject*>(this)->props();
+  }
+
 private:
   APCHandle m_handle;
   ClassOrString m_cls;
-  Prop* m_props;
-  int m_propCount;
+  uint32_t m_propCount;
 };
 
 //////////////////////////////////////////////////////////////////////

