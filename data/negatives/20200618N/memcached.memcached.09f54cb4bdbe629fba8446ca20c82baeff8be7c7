commit 09f54cb4bdbe629fba8446ca20c82baeff8be7c7
Author: dormando <dormando@rydia.net>
Date:   Mon Oct 3 04:24:00 2011 -0700

    push cache_lock deeper into item_alloc
    
    easy win without restructuring item_alloc more: push the lock down after it's
    done fiddling with snprintf.

diff --git a/items.c b/items.c
index ea8852c..ebd2cb5 100644
--- a/items.c
+++ b/items.c
@@ -98,6 +98,7 @@ item *do_item_alloc(char *key, const size_t nkey, const int flags, const rel_tim
     if (id == 0)
         return 0;
 
+    mutex_lock(&cache_lock);
     /* do a quick check if we have any expired items in the tail.. */
     item *search;
     rel_time_t oldest_live = settings.oldest_live;
@@ -133,6 +134,7 @@ item *do_item_alloc(char *key, const size_t nkey, const int flags, const rel_tim
             (search->exptime == 0 || search->exptime > current_time)) {
             if (settings.evict_to_free == 0) {
                 itemstats[id].outofmemory++;
+                pthread_mutex_unlock(&cache_lock);
                 return NULL;
             }
             itemstats[id].evicted++;
@@ -174,6 +176,7 @@ item *do_item_alloc(char *key, const size_t nkey, const int flags, const rel_tim
             search->refcount = 0;
             do_item_unlink_nolock(search, hash(ITEM_key(search), search->nkey, 0));
         }
+        pthread_mutex_unlock(&cache_lock);
         return NULL;
     }
 
@@ -193,6 +196,7 @@ item *do_item_alloc(char *key, const size_t nkey, const int flags, const rel_tim
     it->exptime = exptime;
     memcpy(ITEM_suffix(it), suffix, (size_t)nsuffix);
     it->nsuffix = nsuffix;
+    pthread_mutex_unlock(&cache_lock);
     return it;
 }
 
diff --git a/thread.c b/thread.c
index c201c5d..cce176b 100644
--- a/thread.c
+++ b/thread.c
@@ -340,9 +340,8 @@ int is_listen_thread() {
  */
 item *item_alloc(char *key, size_t nkey, int flags, rel_time_t exptime, int nbytes) {
     item *it;
-    mutex_lock(&cache_lock);
+    /* do_item_alloc handles its own locks */
     it = do_item_alloc(key, nkey, flags, exptime, nbytes);
-    pthread_mutex_unlock(&cache_lock);
     return it;
 }
 

