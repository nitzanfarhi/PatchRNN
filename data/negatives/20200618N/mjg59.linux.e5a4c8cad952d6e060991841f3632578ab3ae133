commit e5a4c8cad952d6e060991841f3632578ab3ae133
Author: Avi Kivity <avi@qumranet.com>
Date:   Tue Nov 20 21:39:54 2007 +0200

    KVM: MMU: Implement guest page fault bypass for nonpae
    
    I spent an hour worrying why I see so many guest page faults on FC6 i386.
    Turns out bypass wasn't implemented for nonpae.  Implement it so it doesn't
    happen again.
    
    Signed-off-by: Avi Kivity <avi@qumranet.com>

diff --git a/drivers/kvm/paging_tmpl.h b/drivers/kvm/paging_tmpl.h
index bf15d127a48f..92b93134a2a6 100644
--- a/drivers/kvm/paging_tmpl.h
+++ b/drivers/kvm/paging_tmpl.h
@@ -486,19 +486,22 @@ static gpa_t FNAME(gva_to_gpa)(struct kvm_vcpu *vcpu, gva_t vaddr)
 static void FNAME(prefetch_page)(struct kvm_vcpu *vcpu,
 				 struct kvm_mmu_page *sp)
 {
-	int i;
+	int i, offset = 0;
 	pt_element_t *gpt;
 	struct page *page;
 
-	if (sp->role.metaphysical || PTTYPE == 32) {
+	if (sp->role.metaphysical
+	    || (PTTYPE == 32 && sp->role.level > PT_PAGE_TABLE_LEVEL)) {
 		nonpaging_prefetch_page(vcpu, sp);
 		return;
 	}
 
+	if (PTTYPE == 32)
+		offset = sp->role.quadrant << PT64_LEVEL_BITS;
 	page = gfn_to_page(vcpu->kvm, sp->gfn);
 	gpt = kmap_atomic(page, KM_USER0);
 	for (i = 0; i < PT64_ENT_PER_PAGE; ++i)
-		if (is_present_pte(gpt[i]))
+		if (is_present_pte(gpt[offset + i]))
 			sp->spt[i] = shadow_trap_nonpresent_pte;
 		else
 			sp->spt[i] = shadow_notrap_nonpresent_pte;

