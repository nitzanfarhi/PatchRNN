commit f6e8cb72ad4b0381d79df4575ec1f5c5df2e73b9
Author: Eliad Peller <eliad@wizery.com>
Date:   Fri Dec 23 01:48:06 2011 +0200

    mac80211: always clear SDATA_STATE_OFFCHANNEL flag
    
    If the vif is stopped while it is offchannel (e.g. right
    after p2p negotiation) the SDATA_STATE_OFFCHANNEL flag
    is never get cleared, resulting in various bad effects
    (e.g. GO can't start beaconing).
    
    Fix it by clearing the SDATA_STATE_OFFCHANNEL flag
    even if the vif is stopped.
    
    Signed-off-by: Eliad Peller <eliad@wizery.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/offchannel.c b/net/mac80211/offchannel.c
index e4330d843575..2948f8e2e675 100644
--- a/net/mac80211/offchannel.c
+++ b/net/mac80211/offchannel.c
@@ -162,6 +162,9 @@ void ieee80211_offchannel_return(struct ieee80211_local *local,
 
 	mutex_lock(&local->iflist_mtx);
 	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (sdata->vif.type != NL80211_IFTYPE_MONITOR)
+			clear_bit(SDATA_STATE_OFFCHANNEL, &sdata->state);
+
 		if (!ieee80211_sdata_running(sdata))
 			continue;
 
@@ -173,7 +176,6 @@ void ieee80211_offchannel_return(struct ieee80211_local *local,
 		}
 
 		if (sdata->vif.type != NL80211_IFTYPE_MONITOR) {
-			clear_bit(SDATA_STATE_OFFCHANNEL, &sdata->state);
 			/*
 			 * This may wake up queues even though the driver
 			 * currently has them stopped. This is not very

