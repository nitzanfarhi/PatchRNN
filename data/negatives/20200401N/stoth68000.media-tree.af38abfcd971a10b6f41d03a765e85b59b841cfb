commit af38abfcd971a10b6f41d03a765e85b59b841cfb
Author: Vitaly Fertman <vitaly.fertman@seagate.com>
Date:   Mon Jun 20 16:55:32 2016 -0400

    staging/lustre/ptlrpc: Early Reply vs Reply MDunlink
    
    A race between unregister_reply & early reply.
    When buffers are busy for the early transfer, they cannon be unlinked
    by unregister_reply, so the RPC gets into UNREGISTERING state. The
    coming reply_in_callback for the early RPC already has unlinked flag
    set due to previous mdunlink attempt, but we handle it properly only
    for UNILNK event, whereas this is PUT in this case.
    
    Signed-off-by: Vitaly Fertman <vitaly.fertman@seagate.com>
    Seagate-bug-id: MRP-3323
    Reviewed-by: Alexey Leonidovich Lyashkov <alexey.lyashkov@seagate.com>
    Reviewed-by: Andriy Skulysh <andriy.skulysh@seagate.com>
    Tested-by: Parinay Vijayprakash Kondekar <parinay.kondekar@seagate.com>
    Reviewed-on: http://review.whamcloud.com/18934
    Intel-bug-id: https://jira.hpdd.intel.com/browse/LU-7434
    Reviewed-by: Chris Horn <hornc@cray.com>
    Reviewed-by: Andreas Dilger <andreas.dilger@intel.com>
    Signed-off-by: Oleg Drokin <green@linuxhacker.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/lustre/lustre/ptlrpc/events.c b/drivers/staging/lustre/lustre/ptlrpc/events.c
index a2433425936a..b1ce72511509 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/events.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/events.c
@@ -137,7 +137,8 @@ void reply_in_callback(lnet_event_t *ev)
 
 		req->rq_early_count++; /* number received, client side */
 
-		if (req->rq_replied)   /* already got the real reply */
+		/* already got the real reply or buffers are already unlinked */
+		if (req->rq_replied || req->rq_reply_unlinked == 1)
 			goto out_wake;
 
 		req->rq_early = 1;

