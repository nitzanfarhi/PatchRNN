commit d5b30ae6b9e2d03beb003f1eb6504b363d70006d
Author: Guillaume Melquiond <guillaume.melquiond@gmail.com>
Date:   Thu May 27 16:28:00 2010 +0000

    Avoided costly roundtrip through strings.
    
    Removed half-backed copy constructor and assignment.
    
    Factored code.

diff --git a/src/sound_music_track.cpp b/src/sound_music_track.cpp
index 0ca4d37c95..9d23013b66 100644
--- a/src/sound_music_track.cpp
+++ b/src/sound_music_track.cpp
@@ -28,93 +28,51 @@ static lg::log_domain log_audio("audio");
 namespace sound {
 
 music_track::music_track() :
-	id_(""),
-	file_path_(""),
+	id_(),
+	file_path_(),
 	ms_before_(0),
 	ms_after_(0),
 	once_(false),
 	append_(false),
 	immediate_(false)
 {
-	//
-	// The first music_track may be initialized before main()
-	// is reached. Using the logging facilities may lead to a SIGSEGV
-	// because it's not guaranteed that their objects are already alive.
-	//
-	// We are safe only because the early music_track objects use
-	// this default constructor.
-	//
 }
 
 music_track::music_track(const config& node) :
 	id_(node["name"]),
-	file_path_(""),
-	ms_before_(lexical_cast_default<int>(node["ms_before"])),
-	ms_after_(lexical_cast_default<int>(node["ms_after"])),
-	once_(utils::string_bool(node["play_once"])),
-	append_(utils::string_bool(node["append"])),
-	immediate_(utils::string_bool(node["immediate"]))
+	file_path_(),
+	ms_before_(node["ms_before"]),
+	ms_after_(node["ms_after"]),
+	once_(node["play_once"].to_bool()),
+	append_(node["append"].to_bool()),
+	immediate_(node["immediate"].to_bool())
 {
-	if(id_.empty()) {
-		ERR_AUDIO << "empty track filename specified\n";
-	} else {
-		this->resolve();
-	}
+	resolve();
 }
 
 music_track::music_track(const std::string& v_name) :
 	id_(v_name),
-	file_path_(""),
+	file_path_(),
 	ms_before_(0),
 	ms_after_(0),
 	once_(false),
 	append_(false),
 	immediate_(false)
 {
-	if(id_.empty()) {
-		ERR_AUDIO << "empty track filename specified\n";
-	} else {
-		this->resolve();
-	}
-}
-
-music_track::music_track(const music_track& mt) :
-	id_(mt.id_),
-	file_path_(mt.file_path_),
-	ms_before_(mt.ms_before_),
-	ms_after_(mt.ms_after_),
-	once_(mt.once_),
-	append_(mt.append_),
-	immediate_(mt.immediate_)
-{
-	// Assume mt has already been resolved...
-}
-
-music_track& music_track::operator=(const music_track& mt)
-{
-	if(this != &mt) {
-		this->id_ = mt.id_;
-		this->file_path_ = mt.file_path_;
-		this->ms_before_ = mt.ms_before_;
-		this->ms_after_ = mt.ms_after_;
-		this->once_ = mt.once_;
-		// Assume mt has already been resolved...
-	}
-
-	return *this;
+	resolve();
 }
 
 void music_track::resolve()
 {
-	if(id_.empty()) {
-		LOG_AUDIO << "cannot resolve an empty track filename\n";
+	if (id_.empty()) {
+		ERR_AUDIO << "empty track filename specified\n";
 		return;
 	}
 
-	file_path_ = get_binary_file_location("music", this->id_);
+	file_path_ = get_binary_file_location("music", id_);
 
-	if(file_path_.empty()) {
-		LOG_AUDIO << "could not resolve a file path to track '" << id_ << "'\n";
+	if (file_path_.empty()) {
+		ERR_AUDIO << "could not find track '" << id_ << "'\n";
 		return;
 	}
 
@@ -125,8 +83,8 @@ void music_track::write(config &parent_node, bool append)
 {
 	config& m = parent_node.add_child("music");
 	m["name"] = id_;
-	m["ms_before"] = lexical_cast<std::string>(ms_before_);
-	m["ms_after"] = lexical_cast<std::string>(ms_after_);
+	m["ms_before"] = ms_before_;
+	m["ms_after"] = ms_after_;
 	if(append) {
 		m["append"] = true;
 	}
diff --git a/src/sound_music_track.hpp b/src/sound_music_track.hpp
index 4496acede4..93ebd45674 100644
--- a/src/sound_music_track.hpp
+++ b/src/sound_music_track.hpp
@@ -29,7 +29,6 @@ class music_track
 {
 public:
 	music_track();
-	music_track(const music_track& mt);
 	music_track(const config& node);
 	music_track(const std::string& v_name);
 	void write(config& parent_node, bool append);
@@ -39,23 +38,21 @@ public:
 	bool append() const { return append_; }
 	bool immediate() const { return immediate_; }
 	bool play_once() const { return once_; }
-	unsigned int ms_before() const { return ms_before_; }
-	unsigned int ms_after()  const { return ms_after_;  }
+	int ms_before() const { return ms_before_; }
+	int ms_after()  const { return ms_after_;  }
 
 	const std::string& file_path() const { return file_path_; }
 	const std::string& id() const { return id_; }
 
 	void set_play_once(bool v) { once_ = v; }
 
-	music_track& operator=(const music_track& mt);
-
 private:
 	void resolve();
 
 	std::string id_;
 	std::string file_path_;
 
-	unsigned int ms_before_, ms_after_;
+	int ms_before_, ms_after_;
 
 	bool once_;
 	bool append_;

