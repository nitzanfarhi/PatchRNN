commit 9c866ff971c1c8c94ccb699d040dda34abafb55a
Author: Bill Meier <wmeier@newsguy.com>
Date:   Fri Feb 13 12:05:26 2015 -0500

    Replace tabs by spaces when editor modelines has "expandtab"
    
    Change-Id: If7a6f2697be732ae4f94ed8b845fd293c32510f7
    Also: tabs-stops should be 8
    Reviewed-on: https://code.wireshark.org/review/7100
    Reviewed-by: Bill Meier <wmeier@newsguy.com>

diff --git a/asn1/rtse/packet-rtse-template.c b/asn1/rtse/packet-rtse-template.c
index 1ec56ca684..d65043a2c6 100644
--- a/asn1/rtse/packet-rtse-template.c
+++ b/asn1/rtse/packet-rtse-template.c
@@ -181,7 +181,7 @@ call_rtse_external_type_callback(gboolean implicit_tag _U_, tvbuff_t *tvb, int o
     }
 
     if (oid)
-    	offset = call_rtse_oid_callback(oid, tvb, offset, actx->pinfo, top_tree ? top_tree : tree, actx->private_data);
+   	offset = call_rtse_oid_callback(oid, tvb, offset, actx->pinfo, top_tree ? top_tree : tree, actx->private_data);
 
     return offset;
 }
diff --git a/epan/address_types.c b/epan/address_types.c
index 61d3f52a2d..10fa0ca888 100644
--- a/epan/address_types.c
+++ b/epan/address_types.c
@@ -791,10 +791,10 @@ void address_types_initialize(void)
 }
 
 /* Given an address type id, return an address_type_t* */
-#define ADDR_TYPE_LOOKUP(addr_type, result)	\
-	/* Check input */		\
-	g_assert(addr_type < MAX_ADDR_TYPE_VALUE);	\
-	result = type_list[addr_type];
+#define ADDR_TYPE_LOOKUP(addr_type, result)    \
+    /* Check input */                          \
+    g_assert(addr_type < MAX_ADDR_TYPE_VALUE); \
+    result = type_list[addr_type];
 
 static int address_type_get_length(const address* addr)
 {
diff --git a/epan/conversation_table.c b/epan/conversation_table.c
index 3f0d828036..5ae0e81138 100644
--- a/epan/conversation_table.c
+++ b/epan/conversation_table.c
@@ -166,7 +166,7 @@ set_conv_gui_data(gpointer data, gpointer user_data)
     g_string_append(conv_cmd_str, proto_get_protocol_filter_name(table->proto_id));
     cmd_string_list_ = g_list_append(cmd_string_list_, conv_cmd_str->str);
     ui_info.group = REGISTER_STAT_GROUP_CONVERSATION_LIST;
-    ui_info.title = NULL;	/* construct this from the protocol info? */
+    ui_info.title = NULL;   /* construct this from the protocol info? */
     ui_info.cli_string = g_string_free(conv_cmd_str, FALSE);
     ui_info.tap_init_cb = dissector_conversation_init;
     ui_info.index = -1;
@@ -191,7 +191,7 @@ set_host_gui_data(gpointer data, gpointer user_data)
 
     g_string_printf(host_cmd_str, "%s,%s", HOSTLIST_TAP_PREFIX, proto_get_protocol_filter_name(table->proto_id));
     ui_info.group = REGISTER_STAT_GROUP_ENDPOINT_LIST;
-    ui_info.title = NULL;	/* construct this from the protocol info? */
+    ui_info.title = NULL;   /* construct this from the protocol info? */
     ui_info.cli_string = g_string_free(host_cmd_str, FALSE);
     ui_info.tap_init_cb = dissector_hostlist_init;
     ui_info.index = -1;
diff --git a/epan/dissectors/packet-3g-a11.c b/epan/dissectors/packet-3g-a11.c
index 8cd50a4d07..50c5d574cf 100644
--- a/epan/dissectors/packet-3g-a11.c
+++ b/epan/dissectors/packet-3g-a11.c
@@ -1585,7 +1585,7 @@ dissect_a11( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_
 
             /* flags */
             proto_tree_add_bitmask(a11_tree, tvb, offset, hf_a11_flags,
-			                ett_a11_flags, a11_flags, ENC_NA);
+                                   ett_a11_flags, a11_flags, ENC_NA);
             offset += 1;
 
             /* lifetime */
@@ -1905,7 +1905,7 @@ dissect_a11( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_
 
                /* flags */
                proto_tree_add_bitmask(a11_tree, tvb, offset, hf_a11_flags,
-			                ett_a11_flags, a11_flags, ENC_NA);
+                                      ett_a11_flags, a11_flags, ENC_NA);
                offset += 1;
 
                /* lifetime */
diff --git a/epan/dissectors/packet-ansi_683.c b/epan/dissectors/packet-ansi_683.c
index c62e082ddb..0cf7d2718c 100644
--- a/epan/dissectors/packet-ansi_683.c
+++ b/epan/dissectors/packet-ansi_683.c
@@ -1123,11 +1123,11 @@ msg_download_req(tvbuff_t *tvb, packet_info* pinfo, proto_tree *tree, guint len,
  * 4.5.1.3
  */
 static const value_string akey_protocol_revision_vals[] = {
-	{ 0x02,	"2G A-key generation" },
-	{ 0x03,	"2G A-key and 3G Root Key generation" },
-	{ 0x04,	"3G Root Key generation" },
-	{ 0x05,	"Enhanced 3G Root Key generation" },
-	{ 0, NULL },
+    { 0x02,     "2G A-key generation" },
+    { 0x03,     "2G A-key and 3G Root Key generation" },
+    { 0x04,     "3G Root Key generation" },
+    { 0x05,     "Enhanced 3G Root Key generation" },
+    { 0, NULL },
 };
 
 static void
diff --git a/epan/dissectors/packet-assa_r3.c b/epan/dissectors/packet-assa_r3.c
index 762a82ac23..3d69586c1c 100644
--- a/epan/dissectors/packet-assa_r3.c
+++ b/epan/dissectors/packet-assa_r3.c
@@ -6040,7 +6040,7 @@ dissect_r3_cmd_clearnvram (tvbuff_t *tvb, guint32 start_offset, guint32 length _
   proto_tree_add_item (tree, hf_r3_commandlength, tvb, start_offset + 0, 1, ENC_LITTLE_ENDIAN);
   proto_tree_add_item (tree, hf_r3_command,       tvb, start_offset + 1, 1, ENC_LITTLE_ENDIAN);
   proto_tree_add_bitmask(tree, tvb, start_offset + 2, hf_r3_nvramclearoptions,
-			       ett_r3clearnvram, r3_nvramclearoptions, ENC_LITTLE_ENDIAN);
+                         ett_r3clearnvram, r3_nvramclearoptions, ENC_LITTLE_ENDIAN);
 }
 
 static void
diff --git a/epan/dissectors/packet-dtn.c b/epan/dissectors/packet-dtn.c
index 9358bf6760..728262ece3 100644
--- a/epan/dissectors/packet-dtn.c
+++ b/epan/dissectors/packet-dtn.c
@@ -1072,13 +1072,13 @@ dissect_payload_header(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int
     /* This is really a SDNV but there are only 7 bits defined so leave it this way*/
 
     if (version == 4) {
-		static const gint *flags[] = {
-			&hf_bundle_payload_flags_replicate_hdr,
-			&hf_bundle_payload_flags_xmit_report,
-			&hf_bundle_payload_flags_discard_on_fail,
-			&hf_bundle_payload_flags_last_header,
-			NULL
-		};
+        static const gint *flags[] = {
+            &hf_bundle_payload_flags_replicate_hdr,
+            &hf_bundle_payload_flags_xmit_report,
+            &hf_bundle_payload_flags_discard_on_fail,
+            &hf_bundle_payload_flags_last_header,
+            NULL
+        };
         guint8      procflags;
 
         procflags = tvb_get_guint8(tvb, offset);
@@ -1088,8 +1088,8 @@ dissect_payload_header(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int
         else {
             *lastheader = FALSE;
         }
-		proto_tree_add_bitmask(payload_tree, tvb, offset, hf_bundle_payload_flags,
-					ett_payload_flags, flags, ENC_BIG_ENDIAN);
+        proto_tree_add_bitmask(payload_tree, tvb, offset, hf_bundle_payload_flags,
+                               ett_payload_flags, flags, ENC_BIG_ENDIAN);
         ++offset;
     }
     else {      /*Bundle Protocol Version 5*/
diff --git a/epan/dissectors/packet-e212.h b/epan/dissectors/packet-e212.h
index 45f1c24f2d..8434a9b19f 100644
--- a/epan/dissectors/packet-e212.h
+++ b/epan/dissectors/packet-e212.h
@@ -30,10 +30,10 @@
 extern value_string_ext E212_codes_ext;
 
 typedef enum {
-	E212_NONE,
-	E212_LAI,
-	E212_RAI,
-	E212_SAI
+    E212_NONE,
+    E212_LAI,
+    E212_RAI,
+    E212_SAI
 } e212_number_type_t;
 
 gchar* dissect_e212_mcc_mnc_wmem_packet_str(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, e212_number_type_t number_type, gboolean little_endian);
diff --git a/epan/dissectors/packet-gsm_a_dtap.c b/epan/dissectors/packet-gsm_a_dtap.c
index 9a7d76ad95..75e6a18dcd 100644
--- a/epan/dissectors/packet-gsm_a_dtap.c
+++ b/epan/dissectors/packet-gsm_a_dtap.c
@@ -1100,8 +1100,8 @@ de_emerg_num_list(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 o
         item = proto_tree_add_string(subtree, hf_gsm_a_dtap_emergency_bcd_num, tvb, curr_offset, en_len, digit_str);
 
         /* Check for overdicadic digits, we used the standard digit map from tvbuff.c
-		 *  0   1   2   3   4   5   6   7   8   9   a   b   c   d   e  f
-		 * '0','1','2','3','4','5','6','7','8','9','?','?','?','?','?','?'
+         *  0   1   2   3   4   5   6   7   8   9   a   b   c   d   e  f
+         * '0','1','2','3','4','5','6','7','8','9','?','?','?','?','?','?'
          *
          */
         if(strchr(digit_str,'?')){
@@ -2171,10 +2171,10 @@ de_bcd_num(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset,
         a_bigbuf);
 
     /* Check for overdicadic digits, we used the standard digit map from tvbuff.c
-		*  0   1   2   3   4   5   6   7   8   9   a   b   c   d   e  f
-		* '0','1','2','3','4','5','6','7','8','9','?','?','?','?','?','?'
-        *
-        */
+     *  0   1   2   3   4   5   6   7   8   9   a   b   c   d   e  f
+     * '0','1','2','3','4','5','6','7','8','9','?','?','?','?','?','?'
+     *
+     */
     if(strchr(digit_str,'?')){
         expert_add_info(pinfo, item, &ei_gsm_a_dtap_end_mark_unexpected);
     }
diff --git a/epan/dissectors/packet-ieee80211-radio.c b/epan/dissectors/packet-ieee80211-radio.c
index 0280160a5b..da32cfd376 100644
--- a/epan/dissectors/packet-ieee80211-radio.c
+++ b/epan/dissectors/packet-ieee80211-radio.c
@@ -64,398 +64,398 @@ static const value_string bandwidth_vals[] = {
  *
  * Indices are:
  *
- *	the MCS index (0-76);
+ *  the MCS index (0-76);
  *
- *	0 for 20 MHz, 1 for 40 MHz;
+ *  0 for 20 MHz, 1 for 40 MHz;
  *
- *	0 for a long guard interval, 1 for a short guard interval.
+ *  0 for a long guard interval, 1 for a short guard interval.
  */
 WS_DLL_PUBLIC_DEF
 const float ieee80211_float_htrates[MAX_MCS_INDEX+1][2][2] = {
-	/* MCS  0  */
-	{	/* 20 Mhz */ {    6.5f,		/* SGI */    7.2f, },
-		/* 40 Mhz */ {   13.5f,		/* SGI */   15.0f, },
-	},
-
-	/* MCS  1  */
-	{	/* 20 Mhz */ {   13.0f,		/* SGI */   14.4f, },
-		/* 40 Mhz */ {   27.0f,		/* SGI */   30.0f, },
-	},
-
-	/* MCS  2  */
-	{	/* 20 Mhz */ {   19.5f,		/* SGI */   21.7f, },
-		/* 40 Mhz */ {   40.5f,		/* SGI */   45.0f, },
-	},
-
-	/* MCS  3  */
-	{	/* 20 Mhz */ {   26.0f,		/* SGI */   28.9f, },
-		/* 40 Mhz */ {   54.0f,		/* SGI */   60.0f, },
-	},
-
-	/* MCS  4  */
-	{	/* 20 Mhz */ {   39.0f,		/* SGI */   43.3f, },
-		/* 40 Mhz */ {   81.0f,		/* SGI */   90.0f, },
-	},
-
-	/* MCS  5  */
-	{	/* 20 Mhz */ {   52.0f,		/* SGI */   57.8f, },
-		/* 40 Mhz */ {  108.0f,		/* SGI */  120.0f, },
-	},
-
-	/* MCS  6  */
-	{	/* 20 Mhz */ {   58.5f,		/* SGI */   65.0f, },
-		/* 40 Mhz */ {  121.5f,		/* SGI */  135.0f, },
-	},
-
-	/* MCS  7  */
-	{	/* 20 Mhz */ {   65.0f,		/* SGI */   72.2f, },
-		/* 40 Mhz */ {   135.0f,	/* SGI */  150.0f, },
-	},
-
-	/* MCS  8  */
-	{	/* 20 Mhz */ {   13.0f,		/* SGI */   14.4f, },
-		/* 40 Mhz */ {   27.0f,		/* SGI */   30.0f, },
-	},
-
-	/* MCS  9  */
-	{	/* 20 Mhz */ {   26.0f,		/* SGI */   28.9f, },
-		/* 40 Mhz */ {   54.0f,		/* SGI */   60.0f, },
-	},
-
-	/* MCS 10  */
-	{	/* 20 Mhz */ {   39.0f,		/* SGI */   43.3f, },
-		/* 40 Mhz */ {   81.0f,		/* SGI */   90.0f, },
-	},
-
-	/* MCS 11  */
-	{	/* 20 Mhz */ {   52.0f,		/* SGI */   57.8f, },
-		/* 40 Mhz */ {  108.0f,		/* SGI */  120.0f, },
-	},
-
-	/* MCS 12  */
-	{	/* 20 Mhz */ {   78.0f,		/* SGI */   86.7f, },
-		/* 40 Mhz */ {  162.0f,		/* SGI */  180.0f, },
-	},
-
-	/* MCS 13  */
-	{	/* 20 Mhz */ {  104.0f,		/* SGI */  115.6f, },
-		/* 40 Mhz */ {  216.0f,		/* SGI */  240.0f, },
-	},
-
-	/* MCS 14  */
-	{	/* 20 Mhz */ {  117.0f,		/* SGI */  130.0f, },
-		/* 40 Mhz */ {  243.0f,		/* SGI */  270.0f, },
-	},
-
-	/* MCS 15  */
-	{	/* 20 Mhz */ {  130.0f,		/* SGI */  144.4f, },
-		/* 40 Mhz */ {  270.0f,		/* SGI */  300.0f, },
-	},
-
-	/* MCS 16  */
-	{	/* 20 Mhz */ {   19.5f,		/* SGI */   21.7f, },
-		/* 40 Mhz */ {   40.5f,		/* SGI */   45.0f, },
-	},
-
-	/* MCS 17  */
-	{	/* 20 Mhz */ {   39.0f,		/* SGI */   43.3f, },
-		/* 40 Mhz */ {   81.0f,		/* SGI */   90.0f, },
-	},
-
-	/* MCS 18  */
-	{	/* 20 Mhz */ {   58.5f,		/* SGI */   65.0f, },
-		/* 40 Mhz */ {  121.5f,		/* SGI */  135.0f, },
-	},
-
-	/* MCS 19  */
-	{	/* 20 Mhz */ {   78.0f,		/* SGI */   86.7f, },
-		/* 40 Mhz */ {  162.0f,		/* SGI */  180.0f, },
-	},
-
-	/* MCS 20  */
-	{	/* 20 Mhz */ {  117.0f,		/* SGI */  130.0f, },
-		/* 40 Mhz */ {  243.0f,		/* SGI */  270.0f, },
-	},
-
-	/* MCS 21  */
-	{	/* 20 Mhz */ {  156.0f,		/* SGI */  173.3f, },
-		/* 40 Mhz */ {  324.0f,		/* SGI */  360.0f, },
-	},
-
-	/* MCS 22  */
-	{	/* 20 Mhz */ {  175.5f,		/* SGI */  195.0f, },
-		/* 40 Mhz */ {  364.5f,		/* SGI */  405.0f, },
-	},
-
-	/* MCS 23  */
-	{	/* 20 Mhz */ {  195.0f,		/* SGI */  216.7f, },
-		/* 40 Mhz */ {  405.0f,		/* SGI */  450.0f, },
-	},
-
-	/* MCS 24  */
-	{	/* 20 Mhz */ {   26.0f,		/* SGI */   28.9f, },
-		/* 40 Mhz */ {   54.0f,		/* SGI */   60.0f, },
-	},
-
-	/* MCS 25  */
-	{	/* 20 Mhz */ {   52.0f,		/* SGI */   57.8f, },
-		/* 40 Mhz */ {  108.0f,		/* SGI */  120.0f, },
-	},
-
-	/* MCS 26  */
-	{	/* 20 Mhz */ {   78.0f,		/* SGI */   86.7f, },
-		/* 40 Mhz */ {  162.0f,		/* SGI */  180.0f, },
-	},
-
-	/* MCS 27  */
-	{	/* 20 Mhz */ {  104.0f,		/* SGI */  115.6f, },
-		/* 40 Mhz */ {  216.0f,		/* SGI */  240.0f, },
-	},
-
-	/* MCS 28  */
-	{	/* 20 Mhz */ {  156.0f,		/* SGI */  173.3f, },
-		/* 40 Mhz */ {  324.0f,		/* SGI */  360.0f, },
-	},
-
-	/* MCS 29  */
-	{	/* 20 Mhz */ {  208.0f,		/* SGI */  231.1f, },
-		/* 40 Mhz */ {  432.0f,		/* SGI */  480.0f, },
-	},
-
-	/* MCS 30  */
-	{	/* 20 Mhz */ {  234.0f,		/* SGI */  260.0f, },
-		/* 40 Mhz */ {  486.0f,		/* SGI */  540.0f, },
-	},
-
-	/* MCS 31  */
-	{	/* 20 Mhz */ {  260.0f,		/* SGI */  288.9f, },
-		/* 40 Mhz */ {  540.0f,		/* SGI */  600.0f, },
-	},
-
-	/* MCS 32  */
-	{	/* 20 Mhz */ {    0.0f,		/* SGI */    0.0f, }, /* not valid */
-		/* 40 Mhz */ {    6.0f,		/* SGI */    6.7f, },
-	},
-
-	/* MCS 33  */
-	{	/* 20 Mhz */ {   39.0f,		/* SGI */   43.3f, },
-		/* 40 Mhz */ {   81.0f,		/* SGI */   90.0f, },
-	},
-
-	/* MCS 34  */
-	{	/* 20 Mhz */ {   52.0f,		/* SGI */   57.8f, },
-		/* 40 Mhz */ {  108.0f,		/* SGI */  120.0f, },
-	},
-
-	/* MCS 35  */
-	{	/* 20 Mhz */ {   65.0f,		/* SGI */   72.2f, },
-		/* 40 Mhz */ {  135.0f,		/* SGI */  150.0f, },
-	},
-
-	/* MCS 36  */
-	{	/* 20 Mhz */ {   58.5f,		/* SGI */   65.0f, },
-		/* 40 Mhz */ {  121.5f,		/* SGI */  135.0f, },
-	},
-
-	/* MCS 37  */
-	{	/* 20 Mhz */ {   78.0f,		/* SGI */   86.7f, },
-		/* 40 Mhz */ {  162.0f,		/* SGI */  180.0f, },
-	},
-
-	/* MCS 38  */
-	{	/* 20 Mhz */ {   97.5f,		/* SGI */  108.3f, },
-		/* 40 Mhz */ {  202.5f,		/* SGI */  225.0f, },
-	},
-
-	/* MCS 39  */
-	{	/* 20 Mhz */ {   52.0f,		/* SGI */   57.8f, },
-		/* 40 Mhz */ {  108.0f,		/* SGI */  120.0f, },
-	},
-
-	/* MCS 40  */
-	{	/* 20 Mhz */ {   65.0f,		/* SGI */   72.2f, },
-		/* 40 Mhz */ {  135.0f,		/* SGI */  150.0f, },
-	},
-
-	/* MCS 41  */
-	{	/* 20 Mhz */ {   65.0f,		/* SGI */   72.2f, },
-		/* 40 Mhz */ {  135.0f,		/* SGI */  150.0f, },
-	},
-
-	/* MCS 42  */
-	{	/* 20 Mhz */ {   78.0f,		/* SGI */   86.7f, },
-		/* 40 Mhz */ {  162.0f,		/* SGI */  180.0f, },
-	},
-
-	/* MCS 43  */
-	{	/* 20 Mhz */ {   91.0f,		/* SGI */  101.1f, },
-		/* 40 Mhz */ {  189.0f,		/* SGI */  210.0f, },
-	},
-
-	/* MCS 44  */
-	{	/* 20 Mhz */ {   91.0f,		/* SGI */  101.1f, },
-		/* 40 Mhz */ {  189.0f,		/* SGI */  210.0f, },
-	},
-
-	/* MCS 45  */
-	{	/* 20 Mhz */ {  104.0f,		/* SGI */  115.6f, },
-		/* 40 Mhz */ {  216.0f,		/* SGI */  240.0f, },
-	},
-
-	/* MCS 46  */
-	{	/* 20 Mhz */ {   78.0f,		/* SGI */   86.7f, },
-		/* 40 Mhz */ {  162.0f,		/* SGI */  180.0f, },
-	},
-
-	/* MCS 47  */
-	{	/* 20 Mhz */ {   97.5f,		/* SGI */  108.3f, },
-		/* 40 Mhz */ {  202.5f,		/* SGI */  225.0f, },
-	},
-
-	/* MCS 48  */
-	{	/* 20 Mhz */ {   97.5f,		/* SGI */  108.3f, },
-		/* 40 Mhz */ {  202.5f,		/* SGI */  225.0f, },
-	},
-
-	/* MCS 49  */
-	{	/* 20 Mhz */ {  117.0f,		/* SGI */  130.0f, },
-		/* 40 Mhz */ {  243.0f,		/* SGI */  270.0f, },
-	},
-
-	/* MCS 50  */
-	{	/* 20 Mhz */ {  136.5f,		/* SGI */  151.7f, },
-		/* 40 Mhz */ {  283.5f,		/* SGI */  315.0f, },
-	},
-
-	/* MCS 51  */
-	{	/* 20 Mhz */ {  136.5f,		/* SGI */  151.7f, },
-		/* 40 Mhz */ {  283.5f,		/* SGI */  315.0f, },
-	},
-
-	/* MCS 52  */
-	{	/* 20 Mhz */ {  156.0f,		/* SGI */  173.3f, },
-		/* 40 Mhz */ {  324.0f,		/* SGI */  360.0f, },
-	},
-
-	/* MCS 53  */
-	{	/* 20 Mhz */ {   65.0f,		/* SGI */   72.2f, },
-		/* 40 Mhz */ {  135.0f,		/* SGI */  150.0f, },
-	},
-
-	/* MCS 54  */
-	{	/* 20 Mhz */ {   78.0f,		/* SGI */   86.7f, },
-		/* 40 Mhz */ {  162.0f,		/* SGI */  180.0f, },
-	},
-
-	/* MCS 55  */
-	{	/* 20 Mhz */ {   91.0f,		/* SGI */  101.1f, },
-		/* 40 Mhz */ {  189.0f,		/* SGI */  210.0f, },
-	},
-
-	/* MCS 56  */
-	{	/* 20 Mhz */ {   78.0f,		/* SGI */   86.7f, },
-		/* 40 Mhz */ {  162.0f,		/* SGI */  180.0f, },
-	},
-
-	/* MCS 57  */
-	{	/* 20 Mhz */ {   91.0f,		/* SGI */  101.1f, },
-		/* 40 Mhz */ {  189.0f,		/* SGI */  210.0f, },
-	},
-
-	/* MCS 58  */
-	{	/* 20 Mhz */ {  104.0f,		/* SGI */  115.6f, },
-		/* 40 Mhz */ {  216.0f,		/* SGI */  240.0f, },
-	},
-
-	/* MCS 59  */
-	{	/* 20 Mhz */ {  117.0f,		/* SGI */  130.0f, },
-		/* 40 Mhz */ {  243.0f,		/* SGI */  270.0f, },
-	},
-
-	/* MCS 60  */
-	{	/* 20 Mhz */ {  104.0f,		/* SGI */  115.6f, },
-		/* 40 Mhz */ {  216.0f,		/* SGI */  240.0f, },
-	},
-
-	/* MCS 61  */
-	{	/* 20 Mhz */ {  117.0f,		/* SGI */  130.0f, },
-		/* 40 Mhz */ {  243.0f,		/* SGI */  270.0f, },
-	},
-
-	/* MCS 62  */
-	{	/* 20 Mhz */ {  130.0f,		/* SGI */  144.4f, },
-		/* 40 Mhz */ {  270.0f,		/* SGI */  300.0f, },
-	},
-
-	/* MCS 63  */
-	{	/* 20 Mhz */ {  130.0f,		/* SGI */  144.4f, },
-		/* 40 Mhz */ {  270.0f,		/* SGI */  300.0f, },
-	},
-
-	/* MCS 64  */
-	{	/* 20 Mhz */ {  143.0f,		/* SGI */  158.9f, },
-		/* 40 Mhz */ {  297.0f,		/* SGI */  330.0f, },
-	},
-
-	/* MCS 65  */
-	{	/* 20 Mhz */ {   97.5f,		/* SGI */  108.3f, },
-		/* 40 Mhz */ {  202.5f,		/* SGI */  225.0f, },
-	},
-
-	/* MCS 66  */
-	{	/* 20 Mhz */ {  117.0f,		/* SGI */  130.0f, },
-		/* 40 Mhz */ {  243.0f,		/* SGI */  270.0f, },
-	},
-
-	/* MCS 67  */
-	{	/* 20 Mhz */ {  136.5f,		/* SGI */  151.7f, },
-		/* 40 Mhz */ {  283.5f,		/* SGI */  315.0f, },
-	},
-
-	/* MCS 68  */
-	{	/* 20 Mhz */ {  117.0f,		/* SGI */  130.0f, },
-		/* 40 Mhz */ {  243.0f,		/* SGI */  270.0f, },
-	},
-
-	/* MCS 69  */
-	{	/* 20 Mhz */ {  136.5f,		/* SGI */  151.7f, },
-		/* 40 Mhz */ {  283.5f,		/* SGI */  315.0f, },
-	},
-
-	/* MCS 70  */
-	{	/* 20 Mhz */ {  156.0f,		/* SGI */  173.3f, },
-		/* 40 Mhz */ {  324.0f,		/* SGI */  360.0f, },
-	},
-
-	/* MCS 71  */
-	{	/* 20 Mhz */ {  175.5f,		/* SGI */  195.0f, },
-		/* 40 Mhz */ {  364.5f,		/* SGI */  405.0f, },
-	},
-
-	/* MCS 72  */
-	{	/* 20 Mhz */ {  156.0f,		/* SGI */  173.3f, },
-		/* 40 Mhz */ {  324.0f,		/* SGI */  360.0f, },
-	},
-
-	/* MCS 73  */
-	{	/* 20 Mhz */ {  175.5f,		/* SGI */  195.0f, },
-		/* 40 Mhz */ {  364.5f,		/* SGI */  405.0f, },
-	},
-
-	/* MCS 74  */
-	{	/* 20 Mhz */ {  195.0f,		/* SGI */  216.7f, },
-		/* 40 Mhz */ {  405.0f,		/* SGI */  450.0f, },
-	},
-
-	/* MCS 75  */
-	{	/* 20 Mhz */ {  195.0f,		/* SGI */  216.7f, },
-		/* 40 Mhz */ {  405.0f,		/* SGI */  450.0f, },
-	},
-
-	/* MCS 76  */
-	{	/* 20 Mhz */ {  214.5f,		/* SGI */  238.3f, },
-		/* 40 Mhz */ {  445.5f,		/* SGI */  495.0f, },
-	},
+  /* MCS  0  */
+  { /* 20 Mhz */ {    6.5f,   /* SGI */    7.2f, },
+    /* 40 Mhz */ {   13.5f,   /* SGI */   15.0f, },
+  },
+
+  /* MCS  1  */
+  { /* 20 Mhz */ {   13.0f,   /* SGI */   14.4f, },
+    /* 40 Mhz */ {   27.0f,   /* SGI */   30.0f, },
+  },
+
+  /* MCS  2  */
+  { /* 20 Mhz */ {   19.5f,   /* SGI */   21.7f, },
+    /* 40 Mhz */ {   40.5f,   /* SGI */   45.0f, },
+  },
+
+  /* MCS  3  */
+  { /* 20 Mhz */ {   26.0f,   /* SGI */   28.9f, },
+    /* 40 Mhz */ {   54.0f,   /* SGI */   60.0f, },
+  },
+
+  /* MCS  4  */
+  { /* 20 Mhz */ {   39.0f,   /* SGI */   43.3f, },
+    /* 40 Mhz */ {   81.0f,   /* SGI */   90.0f, },
+  },
+
+  /* MCS  5  */
+  { /* 20 Mhz */ {   52.0f,   /* SGI */   57.8f, },
+    /* 40 Mhz */ {  108.0f,   /* SGI */  120.0f, },
+  },
+
+  /* MCS  6  */
+  { /* 20 Mhz */ {   58.5f,   /* SGI */   65.0f, },
+    /* 40 Mhz */ {  121.5f,   /* SGI */  135.0f, },
+  },
+
+  /* MCS  7  */
+  { /* 20 Mhz */ {   65.0f,   /* SGI */   72.2f, },
+    /* 40 Mhz */ {   135.0f,  /* SGI */  150.0f, },
+  },
+
+  /* MCS  8  */
+  { /* 20 Mhz */ {   13.0f,   /* SGI */   14.4f, },
+    /* 40 Mhz */ {   27.0f,   /* SGI */   30.0f, },
+  },
+
+  /* MCS  9  */
+  { /* 20 Mhz */ {   26.0f,   /* SGI */   28.9f, },
+    /* 40 Mhz */ {   54.0f,   /* SGI */   60.0f, },
+  },
+
+  /* MCS 10  */
+  { /* 20 Mhz */ {   39.0f,   /* SGI */   43.3f, },
+    /* 40 Mhz */ {   81.0f,   /* SGI */   90.0f, },
+  },
+
+  /* MCS 11  */
+  { /* 20 Mhz */ {   52.0f,   /* SGI */   57.8f, },
+    /* 40 Mhz */ {  108.0f,   /* SGI */  120.0f, },
+  },
+
+  /* MCS 12  */
+  { /* 20 Mhz */ {   78.0f,   /* SGI */   86.7f, },
+    /* 40 Mhz */ {  162.0f,   /* SGI */  180.0f, },
+  },
+
+  /* MCS 13  */
+  { /* 20 Mhz */ {  104.0f,   /* SGI */  115.6f, },
+    /* 40 Mhz */ {  216.0f,   /* SGI */  240.0f, },
+  },
+
+  /* MCS 14  */
+  { /* 20 Mhz */ {  117.0f,   /* SGI */  130.0f, },
+    /* 40 Mhz */ {  243.0f,   /* SGI */  270.0f, },
+  },
+
+  /* MCS 15  */
+  { /* 20 Mhz */ {  130.0f,   /* SGI */  144.4f, },
+    /* 40 Mhz */ {  270.0f,   /* SGI */  300.0f, },
+  },
+
+  /* MCS 16  */
+  { /* 20 Mhz */ {   19.5f,   /* SGI */   21.7f, },
+    /* 40 Mhz */ {   40.5f,   /* SGI */   45.0f, },
+  },
+
+  /* MCS 17  */
+  { /* 20 Mhz */ {   39.0f,   /* SGI */   43.3f, },
+    /* 40 Mhz */ {   81.0f,   /* SGI */   90.0f, },
+  },
+
+  /* MCS 18  */
+  { /* 20 Mhz */ {   58.5f,   /* SGI */   65.0f, },
+    /* 40 Mhz */ {  121.5f,   /* SGI */  135.0f, },
+  },
+
+  /* MCS 19  */
+  { /* 20 Mhz */ {   78.0f,   /* SGI */   86.7f, },
+    /* 40 Mhz */ {  162.0f,   /* SGI */  180.0f, },
+  },
+
+  /* MCS 20  */
+  { /* 20 Mhz */ {  117.0f,   /* SGI */  130.0f, },
+    /* 40 Mhz */ {  243.0f,   /* SGI */  270.0f, },
+  },
+
+  /* MCS 21  */
+  { /* 20 Mhz */ {  156.0f,   /* SGI */  173.3f, },
+    /* 40 Mhz */ {  324.0f,   /* SGI */  360.0f, },
+  },
+
+  /* MCS 22  */
+  { /* 20 Mhz */ {  175.5f,   /* SGI */  195.0f, },
+    /* 40 Mhz */ {  364.5f,   /* SGI */  405.0f, },
+  },
+
+  /* MCS 23  */
+  { /* 20 Mhz */ {  195.0f,   /* SGI */  216.7f, },
+    /* 40 Mhz */ {  405.0f,   /* SGI */  450.0f, },
+  },
+
+  /* MCS 24  */
+  { /* 20 Mhz */ {   26.0f,   /* SGI */   28.9f, },
+    /* 40 Mhz */ {   54.0f,   /* SGI */   60.0f, },
+  },
+
+  /* MCS 25  */
+  { /* 20 Mhz */ {   52.0f,   /* SGI */   57.8f, },
+    /* 40 Mhz */ {  108.0f,   /* SGI */  120.0f, },
+  },
+
+  /* MCS 26  */
+  { /* 20 Mhz */ {   78.0f,   /* SGI */   86.7f, },
+    /* 40 Mhz */ {  162.0f,   /* SGI */  180.0f, },
+  },
+
+  /* MCS 27  */
+  { /* 20 Mhz */ {  104.0f,   /* SGI */  115.6f, },
+    /* 40 Mhz */ {  216.0f,   /* SGI */  240.0f, },
+  },
+
+  /* MCS 28  */
+  { /* 20 Mhz */ {  156.0f,   /* SGI */  173.3f, },
+    /* 40 Mhz */ {  324.0f,   /* SGI */  360.0f, },
+  },
+
+  /* MCS 29  */
+  { /* 20 Mhz */ {  208.0f,   /* SGI */  231.1f, },
+    /* 40 Mhz */ {  432.0f,   /* SGI */  480.0f, },
+  },
+
+  /* MCS 30  */
+  { /* 20 Mhz */ {  234.0f,   /* SGI */  260.0f, },
+    /* 40 Mhz */ {  486.0f,   /* SGI */  540.0f, },
+  },
+
+  /* MCS 31  */
+  { /* 20 Mhz */ {  260.0f,   /* SGI */  288.9f, },
+    /* 40 Mhz */ {  540.0f,   /* SGI */  600.0f, },
+  },
+
+  /* MCS 32  */
+  { /* 20 Mhz */ {    0.0f,   /* SGI */    0.0f, }, /* not valid */
+    /* 40 Mhz */ {    6.0f,   /* SGI */    6.7f, },
+  },
+
+  /* MCS 33  */
+  { /* 20 Mhz */ {   39.0f,   /* SGI */   43.3f, },
+    /* 40 Mhz */ {   81.0f,   /* SGI */   90.0f, },
+  },
+
+  /* MCS 34  */
+  { /* 20 Mhz */ {   52.0f,   /* SGI */   57.8f, },
+    /* 40 Mhz */ {  108.0f,   /* SGI */  120.0f, },
+  },
+
+  /* MCS 35  */
+  { /* 20 Mhz */ {   65.0f,   /* SGI */   72.2f, },
+    /* 40 Mhz */ {  135.0f,   /* SGI */  150.0f, },
+  },
+
+  /* MCS 36  */
+  { /* 20 Mhz */ {   58.5f,   /* SGI */   65.0f, },
+    /* 40 Mhz */ {  121.5f,   /* SGI */  135.0f, },
+  },
+
+  /* MCS 37  */
+  { /* 20 Mhz */ {   78.0f,   /* SGI */   86.7f, },
+    /* 40 Mhz */ {  162.0f,   /* SGI */  180.0f, },
+  },
+
+  /* MCS 38  */
+  { /* 20 Mhz */ {   97.5f,   /* SGI */  108.3f, },
+    /* 40 Mhz */ {  202.5f,   /* SGI */  225.0f, },
+  },
+
+  /* MCS 39  */
+  { /* 20 Mhz */ {   52.0f,   /* SGI */   57.8f, },
+    /* 40 Mhz */ {  108.0f,   /* SGI */  120.0f, },
+  },
+
+  /* MCS 40  */
+  { /* 20 Mhz */ {   65.0f,   /* SGI */   72.2f, },
+    /* 40 Mhz */ {  135.0f,   /* SGI */  150.0f, },
+  },
+
+  /* MCS 41  */
+  { /* 20 Mhz */ {   65.0f,   /* SGI */   72.2f, },
+    /* 40 Mhz */ {  135.0f,   /* SGI */  150.0f, },
+  },
+
+  /* MCS 42  */
+  { /* 20 Mhz */ {   78.0f,   /* SGI */   86.7f, },
+    /* 40 Mhz */ {  162.0f,   /* SGI */  180.0f, },
+  },
+
+  /* MCS 43  */
+  { /* 20 Mhz */ {   91.0f,   /* SGI */  101.1f, },
+    /* 40 Mhz */ {  189.0f,   /* SGI */  210.0f, },
+  },
+
+  /* MCS 44  */
+  { /* 20 Mhz */ {   91.0f,   /* SGI */  101.1f, },
+    /* 40 Mhz */ {  189.0f,   /* SGI */  210.0f, },
+  },
+
+  /* MCS 45  */
+  { /* 20 Mhz */ {  104.0f,   /* SGI */  115.6f, },
+    /* 40 Mhz */ {  216.0f,   /* SGI */  240.0f, },
+  },
+
+  /* MCS 46  */
+  { /* 20 Mhz */ {   78.0f,   /* SGI */   86.7f, },
+    /* 40 Mhz */ {  162.0f,   /* SGI */  180.0f, },
+  },
+
+  /* MCS 47  */
+  { /* 20 Mhz */ {   97.5f,   /* SGI */  108.3f, },
+    /* 40 Mhz */ {  202.5f,   /* SGI */  225.0f, },
+  },
+
+  /* MCS 48  */
+  { /* 20 Mhz */ {   97.5f,   /* SGI */  108.3f, },
+    /* 40 Mhz */ {  202.5f,   /* SGI */  225.0f, },
+  },
+
+  /* MCS 49  */
+  { /* 20 Mhz */ {  117.0f,   /* SGI */  130.0f, },
+    /* 40 Mhz */ {  243.0f,   /* SGI */  270.0f, },
+  },
+
+  /* MCS 50  */
+  { /* 20 Mhz */ {  136.5f,   /* SGI */  151.7f, },
+    /* 40 Mhz */ {  283.5f,   /* SGI */  315.0f, },
+  },
+
+  /* MCS 51  */
+  { /* 20 Mhz */ {  136.5f,   /* SGI */  151.7f, },
+    /* 40 Mhz */ {  283.5f,   /* SGI */  315.0f, },
+  },
+
+  /* MCS 52  */
+  { /* 20 Mhz */ {  156.0f,   /* SGI */  173.3f, },
+    /* 40 Mhz */ {  324.0f,   /* SGI */  360.0f, },
+  },
+
+  /* MCS 53  */
+  { /* 20 Mhz */ {   65.0f,   /* SGI */   72.2f, },
+    /* 40 Mhz */ {  135.0f,   /* SGI */  150.0f, },
+  },
+
+  /* MCS 54  */
+  { /* 20 Mhz */ {   78.0f,   /* SGI */   86.7f, },
+    /* 40 Mhz */ {  162.0f,   /* SGI */  180.0f, },
+  },
+
+  /* MCS 55  */
+  { /* 20 Mhz */ {   91.0f,   /* SGI */  101.1f, },
+    /* 40 Mhz */ {  189.0f,   /* SGI */  210.0f, },
+  },
+
+  /* MCS 56  */
+  { /* 20 Mhz */ {   78.0f,   /* SGI */   86.7f, },
+    /* 40 Mhz */ {  162.0f,   /* SGI */  180.0f, },
+  },
+
+  /* MCS 57  */
+  { /* 20 Mhz */ {   91.0f,   /* SGI */  101.1f, },
+    /* 40 Mhz */ {  189.0f,   /* SGI */  210.0f, },
+  },
+
+  /* MCS 58  */
+  { /* 20 Mhz */ {  104.0f,   /* SGI */  115.6f, },
+    /* 40 Mhz */ {  216.0f,   /* SGI */  240.0f, },
+  },
+
+  /* MCS 59  */
+  { /* 20 Mhz */ {  117.0f,   /* SGI */  130.0f, },
+    /* 40 Mhz */ {  243.0f,   /* SGI */  270.0f, },
+  },
+
+  /* MCS 60  */
+  { /* 20 Mhz */ {  104.0f,   /* SGI */  115.6f, },
+    /* 40 Mhz */ {  216.0f,   /* SGI */  240.0f, },
+  },
+
+  /* MCS 61  */
+  { /* 20 Mhz */ {  117.0f,   /* SGI */  130.0f, },
+    /* 40 Mhz */ {  243.0f,   /* SGI */  270.0f, },
+  },
+
+  /* MCS 62  */
+  { /* 20 Mhz */ {  130.0f,   /* SGI */  144.4f, },
+    /* 40 Mhz */ {  270.0f,   /* SGI */  300.0f, },
+  },
+
+  /* MCS 63  */
+  { /* 20 Mhz */ {  130.0f,   /* SGI */  144.4f, },
+    /* 40 Mhz */ {  270.0f,   /* SGI */  300.0f, },
+  },
+
+  /* MCS 64  */
+  { /* 20 Mhz */ {  143.0f,   /* SGI */  158.9f, },
+    /* 40 Mhz */ {  297.0f,   /* SGI */  330.0f, },
+  },
+
+  /* MCS 65  */
+  { /* 20 Mhz */ {   97.5f,   /* SGI */  108.3f, },
+    /* 40 Mhz */ {  202.5f,   /* SGI */  225.0f, },
+  },
+
+  /* MCS 66  */
+  { /* 20 Mhz */ {  117.0f,   /* SGI */  130.0f, },
+    /* 40 Mhz */ {  243.0f,   /* SGI */  270.0f, },
+  },
+
+  /* MCS 67  */
+  { /* 20 Mhz */ {  136.5f,   /* SGI */  151.7f, },
+    /* 40 Mhz */ {  283.5f,   /* SGI */  315.0f, },
+  },
+
+  /* MCS 68  */
+  { /* 20 Mhz */ {  117.0f,   /* SGI */  130.0f, },
+    /* 40 Mhz */ {  243.0f,   /* SGI */  270.0f, },
+  },
+
+  /* MCS 69  */
+  { /* 20 Mhz */ {  136.5f,   /* SGI */  151.7f, },
+    /* 40 Mhz */ {  283.5f,   /* SGI */  315.0f, },
+  },
+
+  /* MCS 70  */
+  { /* 20 Mhz */ {  156.0f,   /* SGI */  173.3f, },
+    /* 40 Mhz */ {  324.0f,   /* SGI */  360.0f, },
+  },
+
+  /* MCS 71  */
+  { /* 20 Mhz */ {  175.5f,   /* SGI */  195.0f, },
+    /* 40 Mhz */ {  364.5f,   /* SGI */  405.0f, },
+  },
+
+  /* MCS 72  */
+  { /* 20 Mhz */ {  156.0f,   /* SGI */  173.3f, },
+    /* 40 Mhz */ {  324.0f,   /* SGI */  360.0f, },
+  },
+
+  /* MCS 73  */
+  { /* 20 Mhz */ {  175.5f,   /* SGI */  195.0f, },
+    /* 40 Mhz */ {  364.5f,   /* SGI */  405.0f, },
+  },
+
+  /* MCS 74  */
+  { /* 20 Mhz */ {  195.0f,   /* SGI */  216.7f, },
+    /* 40 Mhz */ {  405.0f,   /* SGI */  450.0f, },
+  },
+
+  /* MCS 75  */
+  { /* 20 Mhz */ {  195.0f,   /* SGI */  216.7f, },
+    /* 40 Mhz */ {  405.0f,   /* SGI */  450.0f, },
+  },
+
+  /* MCS 76  */
+  { /* 20 Mhz */ {  214.5f,   /* SGI */  238.3f, },
+    /* 40 Mhz */ {  445.5f,   /* SGI */  495.0f, },
+  },
 };
 
 static gint ett_radio = -1;
diff --git a/epan/dissectors/packet-mpls-psc.c b/epan/dissectors/packet-mpls-psc.c
index 1374fb6f40..e3400fa8d4 100644
--- a/epan/dissectors/packet-mpls-psc.c
+++ b/epan/dissectors/packet-mpls-psc.c
@@ -237,7 +237,7 @@ proto_register_mpls_psc(void)
 void
 proto_reg_handoff_mpls_psc(void)
 {
-	dissector_handle_t mpls_psc_handle;
+    dissector_handle_t mpls_psc_handle;
 
     mpls_psc_handle    = create_dissector_handle( dissect_mpls_psc, proto_mpls_psc );
     dissector_add_uint("pwach.channel_type", 0x0024, mpls_psc_handle); /* FF: PSC, RFC 6378 */
diff --git a/epan/dissectors/packet-mpls.c b/epan/dissectors/packet-mpls.c
index 75b0c9a5da..154477628d 100644
--- a/epan/dissectors/packet-mpls.c
+++ b/epan/dissectors/packet-mpls.c
@@ -399,10 +399,10 @@ dissect_pw_ach(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
 
     next_tvb     = tvb_new_subset_remaining(tvb, 4);
 
-	if (!dissector_try_uint(pw_ach_subdissector_table, channel_type, next_tvb, pinfo, tree))
-	{
+    if (!dissector_try_uint(pw_ach_subdissector_table, channel_type, next_tvb, pinfo, tree))
+    {
         call_dissector(dissector_data, next_tvb, pinfo, tree);
-	}
+    }
 
     if (channel_type == ACH_TYPE_BFD_CV)
     {
diff --git a/epan/dissectors/packet-nbns.c b/epan/dissectors/packet-nbns.c
index ce849582ab..d2b0b0f03d 100644
--- a/epan/dissectors/packet-nbns.c
+++ b/epan/dissectors/packet-nbns.c
@@ -1108,15 +1108,15 @@ static dissector_handle_t data_handle;
 static void
 dissect_netbios_payload(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
 {
-	heur_dtbl_entry_t *hdtbl_entry;
-
-	/*
-	 * Try the heuristic dissectors for NetBIOS; if none of them
-	 * accept the packet, dissect it as data.
-	 */
-	if (!dissector_try_heuristic(netbios_heur_subdissector_list,
-				    tvb, pinfo, tree, &hdtbl_entry, NULL))
-		call_dissector(data_handle,tvb, pinfo, tree);
+    heur_dtbl_entry_t *hdtbl_entry;
+
+    /*
+     * Try the heuristic dissectors for NetBIOS; if none of them
+     * accept the packet, dissect it as data.
+     */
+    if (!dissector_try_heuristic(netbios_heur_subdissector_list,
+                                 tvb, pinfo, tree, &hdtbl_entry, NULL))
+        call_dissector(data_handle,tvb, pinfo, tree);
 }
 
 /* NetBIOS datagram packet, from RFC 1002, page 32 */
diff --git a/epan/dissectors/packet-nsip.c b/epan/dissectors/packet-nsip.c
index 9022c74d23..128a50cf8f 100644
--- a/epan/dissectors/packet-nsip.c
+++ b/epan/dissectors/packet-nsip.c
@@ -603,7 +603,7 @@ decode_iei_control_bits(nsip_ie_t *ie _U_, build_info_t *bi, int ie_start_offset
 
   control_bits = tvb_get_guint8(bi->tvb, bi->offset);
   proto_tree_add_bitmask(bi->nsip_tree, bi->tvb, ie_start_offset, hf_nsip_control_bits,
-			       ett_nsip_control_bits, flags, ENC_NA);
+                         ett_nsip_control_bits, flags, ENC_NA);
   bi->offset++;
 
   if (control_bits & NSIP_MASK_CONTROL_BITS_R) {
diff --git a/epan/dissectors/packet-ppp.c b/epan/dissectors/packet-ppp.c
index 5a108a021c..d35dd4abb8 100644
--- a/epan/dissectors/packet-ppp.c
+++ b/epan/dissectors/packet-ppp.c
@@ -4116,13 +4116,13 @@ dissect_bcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
     guint8 mac_type;
     gint captured_length, reported_length, pad_length;
     tvbuff_t *next_tvb;
-	static const int * bcp_flags[] = {
-		&hf_bcp_fcs_present,
-		&hf_bcp_zeropad,
-		&hf_bcp_bcontrol,
-		&hf_bcp_pads,
-		NULL
-	};
+    static const int * bcp_flags[] = {
+        &hf_bcp_fcs_present,
+        &hf_bcp_zeropad,
+        &hf_bcp_bcontrol,
+        &hf_bcp_pads,
+        NULL
+    };
 
     col_set_str(pinfo->cinfo, COL_PROTOCOL, "PPP BCP");
     col_clear(pinfo->cinfo, COL_INFO);
@@ -5457,7 +5457,7 @@ proto_reg_handoff_ppp(void)
     dissector_add_uint("osinl.excl", NLPID_PPP, ppp_handle);
     dissector_add_uint("gre.proto", ETHERTYPE_PPP, ppp_hdlc_handle);
     dissector_add_uint("juniper.proto", JUNIPER_PROTO_PPP, ppp_handle);
-	dissector_add_uint("sflow_245.header_protocol", SFLOW_245_HEADER_PPP, ppp_hdlc_handle);
+    dissector_add_uint("sflow_245.header_protocol", SFLOW_245_HEADER_PPP, ppp_hdlc_handle);
 }
 
 void
diff --git a/epan/dissectors/packet-rgmp.c b/epan/dissectors/packet-rgmp.c
index 0729b69301..a0070f1185 100644
--- a/epan/dissectors/packet-rgmp.c
+++ b/epan/dissectors/packet-rgmp.c
@@ -43,7 +43,7 @@ static int hf_maddr        = -1;
 
 static int ett_rgmp = -1;
 
-#define MC_RGMP			0xe0000019
+#define MC_RGMP 0xe0000019
 
 static const value_string rgmp_types[] = {
     {IGMP_RGMP_LEAVE, "Leave"},
diff --git a/epan/dissectors/packet-rtse.c b/epan/dissectors/packet-rtse.c
index b28b3977b1..32a2a81e40 100644
--- a/epan/dissectors/packet-rtse.c
+++ b/epan/dissectors/packet-rtse.c
@@ -231,7 +231,7 @@ call_rtse_external_type_callback(gboolean implicit_tag _U_, tvbuff_t *tvb, int o
     }
 
     if (oid)
-    	offset = call_rtse_oid_callback(oid, tvb, offset, actx->pinfo, top_tree ? top_tree : tree, actx->private_data);
+   	offset = call_rtse_oid_callback(oid, tvb, offset, actx->pinfo, top_tree ? top_tree : tree, actx->private_data);
 
     return offset;
 }
diff --git a/epan/dissectors/packet-sflow.c b/epan/dissectors/packet-sflow.c
index 7fe4fba112..2f1a725726 100644
--- a/epan/dissectors/packet-sflow.c
+++ b/epan/dissectors/packet-sflow.c
@@ -688,11 +688,11 @@ dissect_sflow_245_sampled_header(tvbuff_t *tvb, packet_info *pinfo,
 
     TRY
     {
-	    if ((global_dissect_samp_headers == FALSE) ||
+        if ((global_dissect_samp_headers == FALSE) ||
             !dissector_try_uint(header_subdissector_table, header_proto, next_tvb, pinfo, sflow_245_header_tree))
-	    {
+        {
             call_dissector(data_handle, next_tvb, pinfo, sflow_245_header_tree);
-	    }
+        }
     }
 
     CATCH_BOUNDS_ERRORS {
diff --git a/epan/dissectors/packet-sigcomp.c b/epan/dissectors/packet-sigcomp.c
index 3dbbe5d089..531934bb21 100644
--- a/epan/dissectors/packet-sigcomp.c
+++ b/epan/dissectors/packet-sigcomp.c
@@ -331,7 +331,7 @@ static int dissect_sigcomp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree
 
 static proto_tree *top_tree;
 
-#define UDVM_MEMORY_SIZE						65536
+#define UDVM_MEMORY_SIZE   65536
 
 /**********************************************************************************************
  *
@@ -903,266 +903,266 @@ static GHashTable *state_buffer_table=NULL;
 
 
 static void
-sigcomp_init_udvm(void){
-
-	gchar *partial_state_str;
-	guint8 *sip_sdp_buff, *presence_buff;
-
-	/* Destroy any existing memory chunks / hashes. */
-	if (state_buffer_table){
-		g_hash_table_destroy(state_buffer_table);
-	}
-
-
-	state_buffer_table = g_hash_table_new_full(g_str_hash,
-		g_str_equal,
-		g_free, /* key_destroy_func */
-		g_free); /* value_destroy_func */
-	/*
-	 * Store static dictionaries in hash table
-	 */
-	sip_sdp_buff = (guint8 *)g_malloc(SIP_SDP_STATE_LENGTH + 8);
-
-	partial_state_str = bytes_to_str(NULL, sip_sdp_state_identifier, 6);
-
-	/*
-	 * Debug 	g_warning("Sigcomp init: Storing partial state =%s",partial_state_str);
-	 */
-	memset(sip_sdp_buff, 0, 8);
-	sip_sdp_buff[0] = SIP_SDP_STATE_LENGTH >> 8;
-	sip_sdp_buff[1] = SIP_SDP_STATE_LENGTH & 0xff;
-	memcpy(sip_sdp_buff+8, sip_sdp_static_dictionaty_for_sigcomp, SIP_SDP_STATE_LENGTH);
-
-	g_hash_table_insert(state_buffer_table, g_strdup(partial_state_str), sip_sdp_buff);
-	wmem_free(NULL, partial_state_str);
-	/*	Debug
-	 *	g_warning("g_hash_table_insert = 0x%x",sip_sdp_buff);
-	 *  g_warning("g_hash_table_insert = 0x%x",sip_sdp_buff);
-	 */
-
-	presence_buff = (guint8 *)g_malloc(PRESENCE_STATE_LENGTH + 8);
-
-	partial_state_str = bytes_to_str(NULL, presence_state_identifier, 6);
-
-	memset(presence_buff, 0, 8);
-	presence_buff[0] = PRESENCE_STATE_LENGTH >> 8;
-	presence_buff[1] = PRESENCE_STATE_LENGTH & 0xff;
-	memcpy(presence_buff+8, presence_static_dictionary_for_sigcomp, PRESENCE_STATE_LENGTH);
-
-	g_hash_table_insert(state_buffer_table, g_strdup(partial_state_str), presence_buff);
-	wmem_free(NULL, partial_state_str);
+sigcomp_init_udvm(void) {
+
+    gchar  *partial_state_str;
+    guint8 *sip_sdp_buff, *presence_buff;
+
+    /* Destroy any existing memory chunks / hashes. */
+    if (state_buffer_table) {
+        g_hash_table_destroy(state_buffer_table);
+    }
+
+
+    state_buffer_table = g_hash_table_new_full(g_str_hash,
+                                               g_str_equal,
+                                               g_free, /* key_destroy_func */
+                                               g_free); /* value_destroy_func */
+    /*
+     * Store static dictionaries in hash table
+     */
+    sip_sdp_buff = (guint8 *)g_malloc(SIP_SDP_STATE_LENGTH + 8);
+
+    partial_state_str = bytes_to_str(NULL, sip_sdp_state_identifier, 6);
+
+    /*
+     * Debug  g_warning("Sigcomp init: Storing partial state =%s",partial_state_str);
+     */
+    memset(sip_sdp_buff, 0, 8);
+    sip_sdp_buff[0] = SIP_SDP_STATE_LENGTH >> 8;
+    sip_sdp_buff[1] = SIP_SDP_STATE_LENGTH & 0xff;
+    memcpy(sip_sdp_buff+8, sip_sdp_static_dictionaty_for_sigcomp, SIP_SDP_STATE_LENGTH);
+
+    g_hash_table_insert(state_buffer_table, g_strdup(partial_state_str), sip_sdp_buff);
+    wmem_free(NULL, partial_state_str);
+    /* Debug
+     *  g_warning("g_hash_table_insert = 0x%x",sip_sdp_buff);
+     *  g_warning("g_hash_table_insert = 0x%x",sip_sdp_buff);
+     */
+
+    presence_buff = (guint8 *)g_malloc(PRESENCE_STATE_LENGTH + 8);
+
+    partial_state_str = bytes_to_str(NULL, presence_state_identifier, 6);
+
+    memset(presence_buff, 0, 8);
+    presence_buff[0] = PRESENCE_STATE_LENGTH >> 8;
+    presence_buff[1] = PRESENCE_STATE_LENGTH & 0xff;
+    memcpy(presence_buff+8, presence_static_dictionary_for_sigcomp, PRESENCE_STATE_LENGTH);
+
+    g_hash_table_insert(state_buffer_table, g_strdup(partial_state_str), presence_buff);
+    wmem_free(NULL, partial_state_str);
 }
 
 
 static int udvm_state_access(tvbuff_t *tvb, proto_tree *tree,guint8 *buff,guint16 p_id_start, guint16 p_id_length, guint16 state_begin, guint16 *state_length,
-					   guint16 *state_address, guint16 *state_instruction,
-					   gint hf_id)
+                             guint16 *state_address, guint16 *state_instruction,
+                             gint hf_id)
 {
-	int			result_code = 0;
-	guint32		n;
-	guint16		k;
-	guint16		buf_size_real;
-	guint16		byte_copy_right;
-	guint16		byte_copy_left;
-	char		partial_state[STATE_BUFFER_SIZE]; /* Size is 6 - 20 */
-	guint8		*state_buff;
-	gchar		*partial_state_str;
-
-	/*
-	 * Perform initial checks on validity of data
-	 * RFC 3320 :
-	 * 9.4.5.  STATE-ACCESS
-	 * :
-	 * Decompression failure occurs if partial_identifier_length does not
-	 * lie between 6 and 20 inclusive.  Decompression failure also occurs if
-	 * no state item matching the partial state identifier can be found, if
-	 * more than one state item matches the partial identifier, or if
-	 * partial_identifier_length is less than the minimum_access_length of
-	 * the matched state item. Otherwise, a state item is returned from the
-	 * state handler.
-	 */
-
-	if (( p_id_length < STATE_MIN_ACCESS_LEN ) || ( p_id_length > STATE_BUFFER_SIZE )){
-		result_code = 1;
-		return result_code;
-	}
-
-	n = 0;
-	while ( n < p_id_length && n < STATE_BUFFER_SIZE && p_id_start + n < UDVM_MEMORY_SIZE ){
-		partial_state[n] = buff[p_id_start + n];
-		n++;
-	}
-	partial_state_str = bytes_to_str(wmem_packet_scope(), partial_state, p_id_length);
-	proto_tree_add_text(tree,tvb, 0, -1,"### Accessing state ###");
-	proto_tree_add_string(tree,hf_id, tvb, 0, 0, partial_state_str);
-
-	/*  Debug
-	 *	g_warning("State Access: partial state =%s",partial_state_str);
-	 *	g_warning("g_hash_table_lookup = 0x%x",state_buff);
-	 * g_warning("State Access: partial state =%s",partial_state_str);
-	 */
-	state_buff = (guint8 *)g_hash_table_lookup(state_buffer_table, partial_state_str);
-	if ( state_buff == NULL ){
-		result_code = 2; /* No state match */
-		return result_code;
-	}
-	/*
-	 * sip_sdp_static_dictionaty
-	 *
-	 * 8.4.  Byte copying
-	 * :
-	 * The string of bytes is copied in ascending order of memory address,
-	 * respecting the bounds set by byte_copy_left and byte_copy_right.
-	 * More precisely, if a byte is copied from/to Address m then the next
-	 * byte is copied from/to Address n where n is calculated as follows:
-	 *
-	 * Set k := m + 1 (modulo 2^16)
-	 * If k = byte_copy_right then set n := byte_copy_left, else set n := k
-	 *
-	 */
-
-	/*
-	 * buff					= Where "state" will be stored
-	 * p_id_start			= Partial state identifier start pos in the buffer(buff)
-	 * p-id_length			= Partial state identifier length
-	 * state_begin			= Where to start to read state from
-	 * state_length			= Length of state
-	 * state_address		= Address where to store the state in the buffer(buff)
-	 * state_instruction	=
-	 * FALSE				= Indicates that state_* is in the stored state
-	 */
-
-	buf_size_real = (state_buff[0] << 8) | state_buff[1];
-
-	/*
-	 * The value of
-	 * state_length MUST be taken from the returned item of state in the
-	 * case that the state_length operand is set to 0.
-	 *
-	 * The same is true of state_address, state_instruction.
-	 */
-	if (*state_length == 0) {
-		*state_length = buf_size_real;
-	}
-	if ( *state_address == 0 ){
-		*state_address = state_buff[2] << 8;
-		*state_address = *state_address | state_buff[3];
-	}
-	if ( *state_instruction == 0 ){
-		*state_instruction = state_buff[4] << 8;
-		*state_instruction = *state_instruction | state_buff[5];
-	}
-
-	/*
-	 * Decompression failure occurs if bytes are copied from beyond the end of
-	 * the state_value.
-	 */
-	if ((state_begin + *state_length) > buf_size_real) {
-		return 3;
-	}
-
-	/*
-	 * Note that decompression failure will always occur if the state_length
-	 * operand is set to 0 but the state_begin operand is non-zero.
-	 */
-	if (*state_length == 0 && state_begin != 0) {
-		return 17;
-	}
-
-	n = state_begin + 8;
-	k = *state_address;
-
-	/*
-	 * NOTE: Strictly speaking, byte_copy_left and byte_copy_right should
-	 *       not be used if this has been called for bytecode referenced in
-	 *       the message header. However, since the memory is initialised
-	 *       to zero, the code works OK.
-	 */
-	byte_copy_right = buff[66] << 8;
-	byte_copy_right = byte_copy_right | buff[67];
-	byte_copy_left = buff[64] << 8;
-	byte_copy_left = byte_copy_left | buff[65];
-	/* debug
-	 *g_warning(" state_begin %u state_address %u",state_begin , *state_address);
-	 */
-	while ( (gint32) n < (state_begin + *state_length + 8) && n < UDVM_MEMORY_SIZE ){
-		buff[k] = state_buff[n];
-		/*  debug
-		 g_warning(" Loading 0x%x at address %u",buff[k] , k);
-		 */
-		k = ( k + 1 ) & 0xffff;
-		if ( k == byte_copy_right ){
-			k = byte_copy_left;
-		}
-		n++;
-	}
-	return 0;
-	/*
-	 * End SIP
-	 */
+    int      result_code = 0;
+    guint32  n;
+    guint16  k;
+    guint16  buf_size_real;
+    guint16  byte_copy_right;
+    guint16  byte_copy_left;
+    char     partial_state[STATE_BUFFER_SIZE]; /* Size is 6 - 20 */
+    guint8  *state_buff;
+    gchar   *partial_state_str;
+
+    /*
+     * Perform initial checks on validity of data
+     * RFC 3320 :
+     * 9.4.5.  STATE-ACCESS
+     * :
+     * Decompression failure occurs if partial_identifier_length does not
+     * lie between 6 and 20 inclusive.  Decompression failure also occurs if
+     * no state item matching the partial state identifier can be found, if
+     * more than one state item matches the partial identifier, or if
+     * partial_identifier_length is less than the minimum_access_length of
+     * the matched state item. Otherwise, a state item is returned from the
+     * state handler.
+     */
+
+    if (( p_id_length < STATE_MIN_ACCESS_LEN ) || ( p_id_length > STATE_BUFFER_SIZE )) {
+        result_code = 1;
+        return result_code;
+    }
+
+    n = 0;
+    while ( n < p_id_length && n < STATE_BUFFER_SIZE && p_id_start + n < UDVM_MEMORY_SIZE ) {
+        partial_state[n] = buff[p_id_start + n];
+        n++;
+    }
+    partial_state_str = bytes_to_str(wmem_packet_scope(), partial_state, p_id_length);
+    proto_tree_add_text(tree,tvb, 0, -1,"### Accessing state ###");
+    proto_tree_add_string(tree,hf_id, tvb, 0, 0, partial_state_str);
+
+    /* Debug
+     * g_warning("State Access: partial state =%s",partial_state_str);
+     * g_warning("g_hash_table_lookup = 0x%x",state_buff);
+     * g_warning("State Access: partial state =%s",partial_state_str);
+     */
+    state_buff = (guint8 *)g_hash_table_lookup(state_buffer_table, partial_state_str);
+    if ( state_buff == NULL ) {
+        result_code = 2; /* No state match */
+        return result_code;
+    }
+    /*
+     * sip_sdp_static_dictionaty
+     *
+     * 8.4.  Byte copying
+     * :
+     * The string of bytes is copied in ascending order of memory address,
+     * respecting the bounds set by byte_copy_left and byte_copy_right.
+     * More precisely, if a byte is copied from/to Address m then the next
+     * byte is copied from/to Address n where n is calculated as follows:
+     *
+     * Set k := m + 1 (modulo 2^16)
+     * If k = byte_copy_right then set n := byte_copy_left, else set n := k
+     *
+     */
+
+    /*
+     * buff              = Where "state" will be stored
+     * p_id_start        = Partial state identifier start pos in the buffer(buff)
+     * p-id_length       = Partial state identifier length
+     * state_begin       = Where to start to read state from
+     * state_length      = Length of state
+     * state_address     = Address where to store the state in the buffer(buff)
+     * state_instruction =
+     * FALSE             = Indicates that state_* is in the stored state
+     */
+
+    buf_size_real = (state_buff[0] << 8) | state_buff[1];
+
+    /*
+     * The value of
+     * state_length MUST be taken from the returned item of state in the
+     * case that the state_length operand is set to 0.
+     *
+     * The same is true of state_address, state_instruction.
+     */
+    if (*state_length == 0) {
+        *state_length = buf_size_real;
+    }
+    if ( *state_address == 0 ) {
+        *state_address = state_buff[2] << 8;
+        *state_address = *state_address | state_buff[3];
+    }
+    if ( *state_instruction == 0 ) {
+        *state_instruction = state_buff[4] << 8;
+        *state_instruction = *state_instruction | state_buff[5];
+    }
+
+    /*
+     * Decompression failure occurs if bytes are copied from beyond the end of
+     * the state_value.
+     */
+    if ((state_begin + *state_length) > buf_size_real) {
+        return 3;
+    }
+
+    /*
+     * Note that decompression failure will always occur if the state_length
+     * operand is set to 0 but the state_begin operand is non-zero.
+     */
+    if (*state_length == 0 && state_begin != 0) {
+        return 17;
+    }
+
+    n = state_begin + 8;
+    k = *state_address;
+
+    /*
+     * NOTE: Strictly speaking, byte_copy_left and byte_copy_right should
+     *       not be used if this has been called for bytecode referenced in
+     *       the message header. However, since the memory is initialised
+     *       to zero, the code works OK.
+     */
+    byte_copy_right = buff[66] << 8;
+    byte_copy_right = byte_copy_right | buff[67];
+    byte_copy_left = buff[64] << 8;
+    byte_copy_left = byte_copy_left | buff[65];
+    /* debug
+     *g_warning(" state_begin %u state_address %u",state_begin , *state_address);
+     */
+    while ( (gint32) n < (state_begin + *state_length + 8) && n < UDVM_MEMORY_SIZE ) {
+        buff[k] = state_buff[n];
+        /*  debug
+            g_warning(" Loading 0x%x at address %u",buff[k] , k);
+        */
+        k = ( k + 1 ) & 0xffff;
+        if ( k == byte_copy_right ) {
+            k = byte_copy_left;
+        }
+        n++;
+    }
+    return 0;
+    /*
+     * End SIP
+     */
 
 }
 
-static void udvm_state_create(guint8 *state_buff,guint8 *state_identifier,guint16 p_id_length){
-
-	char partial_state[STATE_BUFFER_SIZE];
-	guint i;
-	gchar *partial_state_str;
-	gchar *dummy_buff;
-	/*
-	 * Debug
-	g_warning("Received items of state,state_length_buff[0]= %u, state_length_buff[1]= %u",
-		state_length_buff[0],state_length_buff[1]);
-
-	 */
-	i = 0;
-	while ( i < p_id_length && i < STATE_BUFFER_SIZE ){
-		partial_state[i] = state_identifier[i];
-		i++;
-	}
-	partial_state_str = bytes_to_str(NULL, partial_state, p_id_length);
-
-	dummy_buff = (gchar *)g_hash_table_lookup(state_buffer_table, partial_state_str);
-	if ( dummy_buff == NULL ){
-		g_hash_table_insert(state_buffer_table, g_strdup(partial_state_str), state_buff);
-	}else{
-		/* The buffer allocated by sigcomp-udvm.c wasen't needed so free it
-		 */
-		g_free(state_buff);
-
-	}
-	wmem_free(NULL, partial_state_str);
+static void udvm_state_create(guint8 *state_buff,guint8 *state_identifier,guint16 p_id_length) {
+
+    char   partial_state[STATE_BUFFER_SIZE];
+    guint  i;
+    gchar *partial_state_str;
+    gchar *dummy_buff;
+    /*
+     * Debug
+     g_warning("Received items of state,state_length_buff[0]= %u, state_length_buff[1]= %u",
+     state_length_buff[0],state_length_buff[1]);
+
+    */
+    i = 0;
+    while ( i < p_id_length && i < STATE_BUFFER_SIZE ) {
+        partial_state[i] = state_identifier[i];
+        i++;
+    }
+    partial_state_str = bytes_to_str(NULL, partial_state, p_id_length);
+
+    dummy_buff = (gchar *)g_hash_table_lookup(state_buffer_table, partial_state_str);
+    if ( dummy_buff == NULL ) {
+        g_hash_table_insert(state_buffer_table, g_strdup(partial_state_str), state_buff);
+    } else {
+        /* The buffer allocated by sigcomp-udvm.c wasen't needed so free it
+         */
+        g_free(state_buff);
+
+    }
+    wmem_free(NULL, partial_state_str);
 }
 
 #if 1
-static void udvm_state_free(guint8 buff[] _U_,guint16 p_id_start _U_,guint16 p_id_length _U_){
+static void udvm_state_free(guint8 buff[] _U_,guint16 p_id_start _U_,guint16 p_id_length _U_) {
 }
 #else
-void udvm_state_free(guint8 buff[],guint16 p_id_start,guint16 p_id_length){
-	char partial_state[STATE_BUFFER_SIZE];
-	guint i;
-	gchar *partial_state_str;
-
-	gchar *dummy_buff;
-
-	i = 0;
-	while ( i < p_id_length && i < STATE_BUFFER_SIZE && p_id_start + i < UDVM_MEMORY_SIZE ){
-		partial_state[i] = buff[p_id_start + i];
-		i++;
-	}
-	partial_state_str = bytes_to_str(NULL, partial_state, p_id_length);
-	/* TODO Implement a state create counter before actually freeing states
-	 * Hmm is it a good idea to free the buffer at all?
-	 */
-	g_warning("State-free on  %s ",partial_state_str);
-	dummy_buff = g_hash_table_lookup(state_buffer_table, partial_state_str);
-	if ( dummy_buff == NULL ){
-		g_warning("State-free, state not found  %s",partial_state_str);
-	}else{
-		g_hash_table_remove (state_buffer_table, partial_state_str);
-		g_free(dummy_buff);
-	}
-	wmem_free(NULL, partial_state_str);
+void udvm_state_free(guint8 buff[],guint16 p_id_start,guint16 p_id_length) {
+    char   partial_state[STATE_BUFFER_SIZE];
+    guint  i;
+    gchar *partial_state_str;
+
+    gchar *dummy_buff;
+
+    i = 0;
+    while ( i < p_id_length && i < STATE_BUFFER_SIZE && p_id_start + i < UDVM_MEMORY_SIZE ) {
+        partial_state[i] = buff[p_id_start + i];
+        i++;
+    }
+    partial_state_str = bytes_to_str(NULL, partial_state, p_id_length);
+    /* TODO Implement a state create counter before actually freeing states
+     * Hmm is it a good idea to free the buffer at all?
+     */
+    g_warning("State-free on  %s ",partial_state_str);
+    dummy_buff = g_hash_table_lookup(state_buffer_table, partial_state_str);
+    if ( dummy_buff == NULL ) {
+        g_warning("State-free, state not found  %s",partial_state_str);
+    } else {
+        g_hash_table_remove (state_buffer_table, partial_state_str);
+        g_free(dummy_buff);
+    }
+    wmem_free(NULL, partial_state_str);
 }
 #endif
 
@@ -1171,7 +1171,7 @@ void udvm_state_free(guint8 buff[],guint16 p_id_start,guint16 p_id_length){
  *                       SIGCOMP DECOMPRESSION
  *
  **********************************************************************************************/
-#define	SIGCOMP_INSTR_DECOMPRESSION_FAILURE     0
+#define SIGCOMP_INSTR_DECOMPRESSION_FAILURE     0
 #define SIGCOMP_INSTR_AND                       1
 #define SIGCOMP_INSTR_OR                        2
 #define SIGCOMP_INSTR_NOT                       3
@@ -1214,3111 +1214,3111 @@ static gboolean print_level_2;
 static gboolean print_level_3;
 static gint show_instr_detail_level;
 
-/* Internal result code values of decompression failures */
-static const value_string result_code_vals[] = {
-	{ 0,	"No decompression failure" },
-	{ 1,	"Partial state length less than 6 or greater than 20 bytes long" },
-	{ 2,	"No state match" },
-	{ 3,	"state_begin + state_length > size of state" },
-	{ 4,	"Operand_2 is Zero" },
-	{ 5,	"Switch statement failed j >= n" },
-	{ 6,	"Attempt to jump outside of UDVM memory" },
-	{ 7,	"L in input-bits > 16" },
-	{ 8,	"input_bit_order > 7" },
-	{ 9,	"Instruction Decompression failure encountered" },
-	{10,	"Input huffman failed j > n" },
-	{11,	"Input bits requested beyond end of message" },
-	{12,	"more than four state creation requests are made before the END-MESSAGE instruction" },
-	{13,	"state_retention_priority is 65535" },
-	{14,	"Input bytes requested beyond end of message" },
-	{15,	"Maximum number of UDVM cycles reached" },
-	{16,	"UDVM stack underflow" },
-	{17,	"state_length is 0, but state_begin is non-zero" },
-	{ 255,	"This branch isn't coded yet" },
-	{ 0,    NULL }
-};
+/* Internal result code values of decompression failures */
+static const value_string result_code_vals[] = {
+    {  0, "No decompression failure" },
+    {  1, "Partial state length less than 6 or greater than 20 bytes long" },
+    {  2, "No state match" },
+    {  3, "state_begin + state_length > size of state" },
+    {  4, "Operand_2 is Zero" },
+    {  5, "Switch statement failed j >= n" },
+    {  6, "Attempt to jump outside of UDVM memory" },
+    {  7, "L in input-bits > 16" },
+    {  8, "input_bit_order > 7" },
+    {  9, "Instruction Decompression failure encountered" },
+    { 10, "Input huffman failed j > n" },
+    { 11, "Input bits requested beyond end of message" },
+    { 12, "more than four state creation requests are made before the END-MESSAGE instruction" },
+    { 13, "state_retention_priority is 65535" },
+    { 14, "Input bytes requested beyond end of message" },
+    { 15, "Maximum number of UDVM cycles reached" },
+    { 16, "UDVM stack underflow" },
+    { 17, "state_length is 0, but state_begin is non-zero" },
+    {255, "This branch isn't coded yet" },
+    { 0,    NULL }
+};
+
+ /*  The simplest operand type is the literal (#), which encodes a
+  * constant integer from 0 to 65535 inclusive.  A literal operand may
+  * require between 1 and 3 bytes depending on its value.
+  * Bytecode:                       Operand value:      Range:
+  * 0nnnnnnn                        N                   0 - 127
+  * 10nnnnnn nnnnnnnn               N                   0 - 16383
+  * 11000000 nnnnnnnn nnnnnnnn      N                   0 - 65535
+  *
+  *            Figure 8: Bytecode for a literal (#) operand
+  *
+  */
+static int
+decode_udvm_literal_operand(guint8 *buff,guint operand_address, guint16 *value)
+{
+    guint   bytecode;
+    guint16 operand;
+    guint   test_bits;
+    guint   offset = operand_address;
+    guint8  temp_data;
+
+    bytecode = buff[operand_address];
+    test_bits = bytecode >> 7;
+    if (test_bits == 1) {
+        test_bits = bytecode >> 6;
+        if (test_bits == 2) {
+            /*
+             * 10nnnnnn nnnnnnnn               N                   0 - 16383
+             */
+            temp_data = buff[operand_address] & 0x1f;
+            operand = temp_data << 8;
+            temp_data = buff[(operand_address + 1) & 0xffff];
+            operand = operand | temp_data;
+            *value = operand;
+            offset = offset + 2;
+
+        } else {
+            /*
+             * 111000000 nnnnnnnn nnnnnnnn      N                   0 - 65535
+             */
+            offset ++;
+            temp_data = buff[operand_address] & 0x1f;
+            operand = temp_data << 8;
+            temp_data = buff[(operand_address + 1) & 0xffff];
+            operand = operand | temp_data;
+            *value = operand;
+            offset = offset + 2;
+
+        }
+    } else {
+        /*
+         * 0nnnnnnn                        N                   0 - 127
+         */
+        operand = ( bytecode & 0x7f);
+        *value = operand;
+        offset ++;
+    }
+
+    return offset;
+
+}
+
+/*
+ * The second operand type is the reference ($), which is always used to
+ * access a 2-byte value located elsewhere in the UDVM memory.  The
+ * bytecode for a reference operand is decoded to be a constant integer
+ * from 0 to 65535 inclusive, which is interpreted as the memory address
+ * containing the actual value of the operand.
+ * Bytecode:                       Operand value:      Range:
+ *
+ * 0nnnnnnn                        memory[2 * N]       0 - 65535
+ * 10nnnnnn nnnnnnnn               memory[2 * N]       0 - 65535
+ * 11000000 nnnnnnnn nnnnnnnn      memory[N]           0 - 65535
+ *
+ *            Figure 9: Bytecode for a reference ($) operand
+ */
+static int
+dissect_udvm_reference_operand_memory(guint8 *buff,guint operand_address, guint16 *value,guint *result_dest)
+{
+    guint   bytecode;
+    guint16 operand;
+    guint   offset = operand_address;
+    guint   test_bits;
+    guint8  temp_data;
+    guint16 temp_data16;
+
+    bytecode = buff[operand_address];
+    test_bits = bytecode >> 7;
+    if (test_bits == 1) {
+        test_bits = bytecode >> 6;
+        if (test_bits == 2) {
+            /*
+             * 10nnnnnn nnnnnnnn               memory[2 * N]       0 - 65535
+             */
+            temp_data = buff[operand_address] & 0x3f;
+            operand = temp_data << 8;
+            temp_data = buff[(operand_address + 1) & 0xffff];
+            operand = operand | temp_data;
+            operand = (operand * 2);
+            *result_dest = operand;
+            temp_data16 = buff[operand] << 8;
+            temp_data16 = temp_data16 | buff[(operand+1) & 0xffff];
+            *value = temp_data16;
+            offset = offset + 2;
+
+        } else {
+            /*
+             * 11000000 nnnnnnnn nnnnnnnn      memory[N]           0 - 65535
+             */
+            operand_address++;
+            operand = buff[operand_address] << 8;
+            operand = operand | buff[(operand_address + 1) & 0xffff];
+            *result_dest = operand;
+            temp_data16 = buff[operand] << 8;
+            temp_data16 = temp_data16 | buff[(operand+1) & 0xffff];
+            *value = temp_data16;
+            offset = offset + 3;
+
+        }
+    } else {
+        /*
+         * 0nnnnnnn                        memory[2 * N]       0 - 65535
+         */
+        operand = ( bytecode & 0x7f);
+        operand = (operand * 2);
+        *result_dest = operand;
+        temp_data16 = buff[operand] << 8;
+        temp_data16 = temp_data16 | buff[(operand+1) & 0xffff];
+        *value = temp_data16;
+        offset ++;
+    }
+
+    if (offset >= UDVM_MEMORY_SIZE || *result_dest >= UDVM_MEMORY_SIZE - 1 )
+        THROW(ReportedBoundsError);
+
+    return offset;
+}
+
+/* RFC3320
+ * Figure 10: Bytecode for a multitype (%) operand
+ * Bytecode:                       Operand value:      Range:           HEX val
+ * 00nnnnnn                        N                   0 - 63           0x00
+ * 01nnnnnn                        memory[2 * N]       0 - 65535        0x40
+ * 1000011n                        2 ^ (N + 6)        64 , 128          0x86
+ * 10001nnn                        2 ^ (N + 8)    256 , ... , 32768     0x88
+ * 111nnnnn                        N + 65504       65504 - 65535        0xe0
+ * 1001nnnn nnnnnnnn               N + 61440       61440 - 65535        0x90
+ * 101nnnnn nnnnnnnn               N                   0 - 8191         0xa0
+ * 110nnnnn nnnnnnnn               memory[N]           0 - 65535        0xc0
+ * 10000000 nnnnnnnn nnnnnnnn      N                   0 - 65535        0x80
+ * 10000001 nnnnnnnn nnnnnnnn      memory[N]           0 - 65535        0x81
+ */
+static int
+decode_udvm_multitype_operand(guint8 *buff,guint operand_address, guint16 *value)
+{
+    guint   test_bits;
+    guint   bytecode;
+    guint   offset = operand_address;
+    guint16 operand;
+    guint32 result;
+    guint8  temp_data;
+    guint16 temp_data16;
+    guint16 memmory_addr = 0;
+
+    *value = 0;
+
+    bytecode = buff[operand_address];
+    test_bits = ( bytecode & 0xc0 ) >> 6;
+    switch (test_bits ) {
+    case 0:
+        /*
+         * 00nnnnnn                        N                   0 - 63
+         */
+        operand =  buff[operand_address];
+        /* debug
+         *g_warning("Reading 0x%x From address %u",operand,offset);
+         */
+        *value = operand;
+        offset ++;
+        break;
+    case 1:
+        /*
+         * 01nnnnnn                        memory[2 * N]       0 - 65535
+         */
+        memmory_addr = ( bytecode & 0x3f) * 2;
+        temp_data16 = buff[memmory_addr] << 8;
+        temp_data16 = temp_data16 | buff[(memmory_addr+1) & 0xffff];
+        *value = temp_data16;
+        offset ++;
+        break;
+    case 2:
+        /* Check tree most significant bits */
+        test_bits = ( bytecode & 0xe0 ) >> 5;
+        if ( test_bits == 5 ) {
+            /*
+             * 101nnnnn nnnnnnnn               N                   0 - 8191
+             */
+            temp_data = buff[operand_address] & 0x1f;
+            operand = temp_data << 8;
+            temp_data = buff[(operand_address + 1) & 0xffff];
+            operand = operand | temp_data;
+            *value = operand;
+            offset = offset + 2;
+        } else {
+            test_bits = ( bytecode & 0xf0 ) >> 4;
+            if ( test_bits == 9 ) {
+                /*
+                 * 1001nnnn nnnnnnnn               N + 61440       61440 - 65535
+                 */
+                temp_data = buff[operand_address] & 0x0f;
+                operand = temp_data << 8;
+                temp_data = buff[(operand_address + 1) & 0xffff];
+                operand = operand | temp_data;
+                operand = operand + 61440;
+                *value = operand;
+                offset = offset + 2;
+            } else {
+                test_bits = ( bytecode & 0x08 ) >> 3;
+                if ( test_bits == 1) {
+                    /*
+                     * 10001nnn                        2 ^ (N + 8)    256 , ... , 32768
+                     */
+
+                    result = 1 << ((buff[operand_address] & 0x07) + 8);
+                    operand = result & 0xffff;
+                    *value = operand;
+                    offset ++;
+                } else {
+                    test_bits = ( bytecode & 0x0e ) >> 1;
+                    if ( test_bits == 3 ) {
+                        /*
+                         * 1000 011n                        2 ^ (N + 6)        64 , 128
+                         */
+                        result = 1 << ((buff[operand_address] & 0x01) + 6);
+                        operand = result & 0xffff;
+                        *value = operand;
+                        offset ++;
+                    } else {
+                        /*
+                         * 1000 0000 nnnnnnnn nnnnnnnn      N                   0 - 65535
+                         * 1000 0001 nnnnnnnn nnnnnnnn      memory[N]           0 - 65535
+                         */
+                        offset ++;
+                        temp_data16 = buff[(operand_address + 1) & 0xffff] << 8;
+                        temp_data16 = temp_data16 | buff[(operand_address + 2) & 0xffff];
+                        /*  debug
+                         * g_warning("Reading 0x%x From address %u",temp_data16,operand_address);
+                         */
+                        if ( (bytecode & 0x01) == 1 ) {
+                            memmory_addr = temp_data16;
+                            temp_data16 = buff[memmory_addr] << 8;
+                            temp_data16 = temp_data16 | buff[(memmory_addr+1) & 0xffff];
+                        }
+                        *value = temp_data16;
+                        offset = offset +2;
+                    }
+
+
+                }
+            }
+        }
+        break;
+
+    case 3:
+        test_bits = ( bytecode & 0x20 ) >> 5;
+        if ( test_bits == 1 ) {
+            /*
+             * 111nnnnn                        N + 65504       65504 - 65535
+             */
+            operand = ( buff[operand_address] & 0x1f) + 65504;
+            *value = operand;
+            offset ++;
+        } else {
+            /*
+             * 110nnnnn nnnnnnnn               memory[N]           0 - 65535
+             */
+            memmory_addr = buff[operand_address] & 0x1f;
+            memmory_addr = memmory_addr << 8;
+            memmory_addr = memmory_addr | buff[(operand_address + 1) & 0xffff];
+            temp_data16 = buff[memmory_addr] << 8;
+            temp_data16 = temp_data16 | buff[(memmory_addr+1) & 0xffff];
+            *value = temp_data16;
+            /*  debug
+             * g_warning("Reading 0x%x From address %u",temp_data16,memmory_addr);
+             */
+            offset = offset +2;
+        }
+
+    default :
+        break;
+    }
+    return offset;
+}
+/*
+ *
+ * The fourth operand type is the address (@).  This operand is decoded
+ * as a multitype operand followed by a further step: the memory address
+ * of the UDVM instruction containing the address operand is added to
+ * obtain the correct operand value.  So if the operand value from
+ * Figure 10 is D then the actual operand value of an address is
+ * calculated as follows:
+ *
+ * operand_value = (memory_address_of_instruction + D) modulo 2^16
+ *
+ * Address operands are always used in instructions that control program
+ * flow, because they ensure that the UDVM bytecode is position-
+ * independent code (i.e., it will run independently of where it is
+ * placed in the UDVM memory).
+ */
+static int
+decode_udvm_address_operand(guint8 *buff,guint operand_address, guint16 *value,guint current_address)
+{
+    guint32 result;
+    guint16 value1;
+    guint   next_opreand_address;
+
+    next_opreand_address = decode_udvm_multitype_operand(buff, operand_address, &value1);
+    result = value1 & 0xffff;
+    result = result + current_address;
+    *value = result & 0xffff;
+    return next_opreand_address;
+}
+
+
+/*
+ * This is a lookup table used to reverse the bits in a byte.
+ */
+static guint8 reverse [] = {
+    0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
+    0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
+    0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
+    0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
+    0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
+    0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
+    0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
+    0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
+    0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
+    0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
+    0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
+    0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
+    0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
+    0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
+    0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
+    0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
+    0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
+    0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
+    0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
+    0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
+    0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
+    0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
+    0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
+    0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
+    0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
+    0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
+    0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
+    0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
+    0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
+    0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
+    0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
+    0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
+};
+
+
+static int
+decomp_dispatch_get_bits(
+    tvbuff_t   *message_tvb,
+    proto_tree *udvm_tree,
+    guint8      bit_order,
+    guint8     *buff,
+    guint16    *old_input_bit_order,
+    guint16    *remaining_bits,
+    guint16    *input_bits,
+    guint      *input_address,
+    guint16     length,
+    guint16    *result_code,
+    guint       msg_end)
+{
+    guint16     input_bit_order;
+    guint16     bits_still_required   = length;
+    guint16     value                 = 0;
+    guint8      octet;
+    gint        extra_bytes_available = msg_end - *input_address;
+    gint        p_bit;
+    gint        prev_p_bit            = *old_input_bit_order & 0x0001;
+    gint        bits_to_use           = 0;
+
+
+    input_bit_order = buff[68] << 8;
+    input_bit_order = input_bit_order | buff[69];
+    *result_code = 0;
+    p_bit = (input_bit_order & 0x0001) != 0;
+
+    /*
+     * Discard any spare bits.
+     * Note: We take care to avoid remaining_bits having the value of 8.
+     */
+    if (prev_p_bit != p_bit)
+    {
+        *remaining_bits = 0;
+        *old_input_bit_order = input_bit_order;
+    }
+
+    /*
+     * Check we can suppy the required number of bits now, before we alter
+     * the input buffer's state.
+     */
+    if (*remaining_bits + extra_bytes_available * 8 < length)
+    {
+        *result_code = 11;
+        return 0xfbad;
+    }
+
+    /* Note: This is never called with length > 16, so the following loop
+     *       never loops more than three time. */
+    while (bits_still_required > 0)
+    {
+        /*
+         * We only put anything into input_bits if we know we will remove
+         * at least one bit. That ensures we can simply discard the spare
+         * bits if the P-bit changes.
+         */
+        if (*remaining_bits == 0)
+        {
+            octet = tvb_get_guint8(message_tvb, *input_address);
+            if (print_level_1 ) {
+                proto_tree_add_text(udvm_tree, message_tvb, *input_address , 1,
+                                    "               Getting value: %u (0x%x) From Addr: %u", octet, octet, *input_address);
+            }
+            *input_address = *input_address + 1;
+
+            if (p_bit != 0)
+            {
+                octet = reverse[octet];
+            }
+            *input_bits = octet;
+            *remaining_bits = 8;
+        }
+
+        /* Add some more bits to the accumulated value. */
+        bits_to_use = bits_still_required < *remaining_bits ? bits_still_required : *remaining_bits;
+        bits_still_required -= bits_to_use;
+
+        *input_bits <<= bits_to_use;           /* Shift bits into MSByte */
+        value = (value << bits_to_use)         /* Then add to the accumulated value */
+            | ((*input_bits >> 8) & 0xFF);
+        *remaining_bits -= bits_to_use;
+        *input_bits &= 0x00FF;                 /* Leave just the remaining bits */
+    }
+
+    if (bit_order != 0)
+    {
+        /* Bit reverse the entire word. */
+        guint16 lsb = reverse[(value >> 8) & 0xFF];
+        guint16 msb = reverse[value & 0xFF];
+
+        value = ((msb << 8) | lsb) >> (16 - length);
+    }
+
+    return value;
+}
+
+static tvbuff_t*
+decompress_sigcomp_message(tvbuff_t *bytecode_tvb, tvbuff_t *message_tvb, packet_info *pinfo,
+                           proto_tree *udvm_tree, gint udvm_mem_dest,
+                           gint print_flags, gint hf_id,
+                           gint header_len,
+                           gint byte_code_state_len, gint byte_code_id_len,
+                           gint udvm_start_ip)
+{
+    tvbuff_t      *decomp_tvb;
+    /* UDVM memory must be initialised to zero */
+    guint8        *buff                       = (guint8 *)wmem_alloc0(wmem_packet_scope(), UDVM_MEMORY_SIZE);
+    char           string[2];
+    guint8        *out_buff;    /* Largest allowed size for a message is UDVM_MEMORY_SIZE = 65536 */
+    guint32        i                          = 0;
+    guint16        n                          = 0;
+    guint16        m                          = 0;
+    guint16        x;
+    guint          k                          = 0;
+    guint16        H;
+    guint16        oldH;
+    guint          offset                     = 0;
+    guint          result_dest;
+    guint          code_length                = 0;
+    guint8         current_instruction;
+    guint          current_address;
+    guint          operand_address;
+    guint          input_address;
+    guint16        output_address             = 0;
+    guint          next_operand_address;
+    guint8         octet;
+    guint8         msb;
+    guint8         lsb;
+    guint16        byte_copy_right;
+    guint16        byte_copy_left;
+    guint16        input_bit_order;
+    guint16        stack_location;
+    guint16        stack_fill;
+    guint16        result;
+    guint          msg_end                    = tvb_reported_length_remaining(message_tvb, 0);
+    guint16        result_code                = 0;
+    guint16        old_input_bit_order        = 0;
+    guint16        remaining_bits             = 0;
+    guint16        input_bits                 = 0;
+    guint8         bit_order                  = 0;
+    gboolean       outside_huffman_boundaries = TRUE;
+    gboolean       print_in_loop              = FALSE;
+    guint16        instruction_address;
+    guint8         no_of_state_create         = 0;
+    guint16        state_length_buff[5];
+    guint16        state_address_buff[5];
+    guint16        state_instruction_buff[5];
+    guint16        state_minimum_access_length_buff[5];
+    /* guint16        state_state_retention_priority_buff[5]; */
+    guint32        used_udvm_cycles           = 0;
+    guint          cycles_per_bit;
+    guint          maximum_UDVM_cycles;
+    guint8        *sha1buff;
+    unsigned char  sha1_digest_buf[STATE_BUFFER_SIZE];
+    sha1_context   ctx;
+
+
+    /* UDVM operand variables */
+    guint16 length;
+    guint16 at_address;
+    guint16 destination;
+    guint16 addr;
+    guint16 value;
+    guint16 p_id_start;
+    guint16 p_id_length;
+    guint16 state_begin;
+    guint16 state_length;
+    guint16 state_address;
+    guint16 state_instruction;
+    guint16 operand_1;
+    guint16 operand_2;
+    guint16 value_1;
+    guint16 value_2;
+    guint16 at_address_1;
+    guint16 at_address_2;
+    guint16 at_address_3;
+    guint16 j;
+    guint16 bits_n;
+    guint16 lower_bound_n;
+    guint16 upper_bound_n;
+    guint16 uncompressed_n;
+    guint16 position;
+    guint16 ref_destination; /* could I have used $destination ? */
+    guint16 multy_offset;
+    guint16 output_start;
+    guint16 output_length;
+    guint16 minimum_access_length;
+    guint16 state_retention_priority;
+    guint16 requested_feedback_location;
+    guint16 returned_parameters_location;
+    guint16 start_value;
+
+
+    /* Set print parameters */
+    print_level_1 = FALSE;
+    print_level_2 = FALSE;
+    print_level_3 = FALSE;
+    show_instr_detail_level = 0;
+
+
+
+    switch ( print_flags ) {
+    case 0:
+        break;
+
+    case 1:
+        print_level_1 = TRUE;
+        show_instr_detail_level = 1;
+        break;
+    case 2:
+        print_level_1 = TRUE;
+        print_level_2 = TRUE;
+        show_instr_detail_level = 1;
+        break;
+    case 3:
+        print_level_1 = TRUE;
+        print_level_2 = TRUE;
+        print_level_3 = TRUE;
+        show_instr_detail_level = 2;
+        break;
+    default:
+        print_level_1 = TRUE;
+        show_instr_detail_level = 1;
+        break;
+    }
+
+    /* Set initial UDVM data
+     *  The first 32 bytes of UDVM memory are then initialized to special
+     *  values as illustrated in Figure 5.
+     *
+     *                      0             7 8            15
+     *                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+     *                     |       UDVM_memory_size        |  0 - 1
+     *                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+     *                     |        cycles_per_bit         |  2 - 3
+     *                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+     *                     |        SigComp_version        |  4 - 5
+     *                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+     *                     |    partial_state_ID_length    |  6 - 7
+     *                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+     *                     |         state_length          |  8 - 9
+     *                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+     *                     |                               |
+     *                     :           reserved            :  10 - 31
+     *                     |                               |
+     *                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+     *
+     *            Figure 5: Initializing Useful Values in UDVM memory
+     */
+    /* UDVM_memory_size  */
+    buff[0] = (UDVM_MEMORY_SIZE >> 8) & 0x00FF;
+    buff[1] = UDVM_MEMORY_SIZE & 0x00FF;
+    /* cycles_per_bit */
+    buff[2] = 0;
+    buff[3] = 16;
+    /* SigComp_version */
+    buff[4] = 0;
+    buff[5] = 1;
+    /* partial_state_ID_length */
+    buff[6] = (byte_code_id_len >> 8) & 0x00FF;
+    buff[7] = byte_code_id_len & 0x00FF;
+    /* state_length  */
+    buff[8] = (byte_code_state_len >> 8) & 0x00FF;
+    buff[9] = byte_code_state_len & 0x00FF;
+
+    code_length = tvb_reported_length_remaining(bytecode_tvb, 0);
+
+    cycles_per_bit = buff[2] << 8;
+    cycles_per_bit = cycles_per_bit | buff[3];
+    /*
+     * maximum_UDVM_cycles = (8 * n + 1000) * cycles_per_bit
+     */
+    maximum_UDVM_cycles = (( 8 * (header_len + msg_end) ) + 1000) * cycles_per_bit;
+
+    proto_tree_add_text(udvm_tree, bytecode_tvb, offset, 1,"maximum_UDVM_cycles(%u) = (( 8 * msg_end(%u) ) + 1000) * cycles_per_bit(%u)",maximum_UDVM_cycles,msg_end,cycles_per_bit);
+    proto_tree_add_text(udvm_tree, bytecode_tvb, offset, 1,"Message Length: %u,Byte code length: %u, Maximum UDVM cycles: %u",msg_end,code_length,maximum_UDVM_cycles);
+
+    /* Load bytecode into UDVM starting at "udvm_mem_dest" */
+    i = udvm_mem_dest;
+    if ( print_level_3 )
+        proto_tree_add_text(udvm_tree, bytecode_tvb, offset, 1,"Load bytecode into UDVM starting at %u",i);
+    while ( code_length > offset && i < UDVM_MEMORY_SIZE ) {
+        buff[i] = tvb_get_guint8(bytecode_tvb, offset);
+        if ( print_level_3 )
+            proto_tree_add_text(udvm_tree, bytecode_tvb, offset, 1,
+                                "              Addr: %u Instruction code(0x%0x) ", i, buff[i]);
+
+        i++;
+        offset++;
+
+    }
+    /* Start executing code */
+    current_address = udvm_start_ip;
+    input_address = 0;
+
+    proto_tree_add_text(udvm_tree, bytecode_tvb, offset, 1,"UDVM EXECUTION STARTED at Address: %u Message size %u",
+                        current_address, msg_end);
+
+    /* Largest allowed size for a message is UDVM_MEMORY_SIZE = 65536  */
+    out_buff = (guint8 *)g_malloc(UDVM_MEMORY_SIZE);
+
+execute_next_instruction:
+
+    if ( used_udvm_cycles > maximum_UDVM_cycles ) {
+        result_code = 15;
+        goto decompression_failure;
+    }
+    used_udvm_cycles++;
+    current_instruction = buff[current_address & 0xffff];
+
+    switch ( current_instruction ) {
+    case SIGCOMP_INSTR_DECOMPRESSION_FAILURE:
+        if ( result_code == 0 )
+            result_code = 9;
+        proto_tree_add_text(udvm_tree, NULL, 0, 0,
+                            "Addr: %u ## DECOMPRESSION-FAILURE(0)",
+                            current_address);
+        proto_tree_add_text(udvm_tree, NULL, 0, 0,"Wireshark UDVM diagnostic: %s.",
+                            val_to_str(result_code, result_code_vals,"Unknown (%u)"));
+        if ( output_address > 0 ) {
+            /* At least something got decompressed, show it */
+            decomp_tvb = tvb_new_child_real_data(message_tvb, out_buff,output_address,output_address);
+            /* Arrange that the allocated packet data copy be freed when the
+             * tvbuff is freed.
+             */
+            tvb_set_free_cb( decomp_tvb, g_free );
+            /* Add the tvbuff to the list of tvbuffs to which the tvbuff we
+             * were handed refers, so it'll get cleaned up when that tvbuff
+             * is cleaned up.
+             */
+            add_new_data_source(pinfo, decomp_tvb, "Decompressed SigComp message(Incomplete)");
+            proto_tree_add_text(udvm_tree, decomp_tvb, 0, -1,"SigComp message Decompression failure");
+            return decomp_tvb;
+        }
+        g_free(out_buff);
+        return NULL;
+        break;
+
+    case SIGCOMP_INSTR_AND: /* 1 AND ($operand_1, %operand_2) */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## AND(1) (operand_1, operand_2)",
+                                current_address);
+        }
+        /* $operand_1*/
+        operand_address = current_address + 1;
+        next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
+                                operand_address, operand_1);
+        }
+        operand_address = next_operand_address;
+        /* %operand_2*/
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_2 %u",
+                                operand_address, operand_2);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## AND (operand_1=%u, operand_2=%u)",
+                                current_address, operand_1, operand_2);
+        }
+        /* execute the instruction */
+        result = operand_1 & operand_2;
+        lsb = result & 0xff;
+        msb = result >> 8;
+        buff[result_dest] = msb;
+        buff[(result_dest+1) & 0xffff] = lsb;
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"     Loading result %u at %u",
+                                result, result_dest);
+        }
+        current_address = next_operand_address;
+        goto execute_next_instruction;
+
+        break;
+
+    case SIGCOMP_INSTR_OR: /* 2 OR ($operand_1, %operand_2) */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## OR(2) (operand_1, operand_2)",
+                                current_address);
+        }
+        /* $operand_1*/
+        operand_address = current_address + 1;
+        next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
+                                operand_address, operand_1);
+        }
+        operand_address = next_operand_address;
+        /* %operand_2*/
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_2 %u",
+                                operand_address, operand_2);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## OR (operand_1=%u, operand_2=%u)",
+                                current_address, operand_1, operand_2);
+        }
+        /* execute the instruction */
+        result = operand_1 | operand_2;
+        lsb = result & 0xff;
+        msb = result >> 8;
+        buff[result_dest] = msb;
+        buff[(result_dest+1) & 0xffff] = lsb;
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"     Loading result %u at %u",
+                                result, result_dest);
+        }
+        current_address = next_operand_address;
+        goto execute_next_instruction;
+
+        break;
+
+    case SIGCOMP_INSTR_NOT: /* 3 NOT ($operand_1) */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## NOT(3) ($operand_1)",
+                                current_address);
+        }
+        /* $operand_1*/
+        operand_address = current_address + 1;
+        next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
+                                operand_address, operand_1);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## NOT (operand_1=%u)",
+                                current_address, operand_1);
+        }
+        /* execute the instruction */
+        result = operand_1 ^ 0xffff;
+        lsb = result & 0xff;
+        msb = result >> 8;
+        buff[result_dest] = msb;
+        buff[(result_dest+1) & 0xffff] = lsb;
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"     Loading result %u at %u",
+                                result, result_dest);
+        }
+        current_address = next_operand_address;
+        goto execute_next_instruction;
+        break;
+
+    case SIGCOMP_INSTR_LSHIFT: /* 4 LSHIFT ($operand_1, %operand_2) */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## LSHIFT(4) ($operand_1, operand_2)",
+                                current_address);
+        }
+        /* $operand_1*/
+        operand_address = current_address + 1;
+        next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
+                                operand_address, operand_1);
+        }
+        operand_address = next_operand_address;
+        /* %operand_2*/
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_2 %u",
+                                operand_address, operand_2);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## LSHIFT (operand_1=%u, operand_2=%u)",
+                                current_address, operand_1, operand_2);
+        }
+        /* execute the instruction */
+        result = operand_1 << operand_2;
+        lsb = result & 0xff;
+        msb = result >> 8;
+        buff[result_dest] = msb;
+        buff[(result_dest+1) & 0xffff] = lsb;
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"     Loading result %u at %u",
+                                result, result_dest);
+        }
+        current_address = next_operand_address;
+        goto execute_next_instruction;
+
+        break;
+    case SIGCOMP_INSTR_RSHIFT: /* 5 RSHIFT ($operand_1, %operand_2) */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## RSHIFT(5) (operand_1, operand_2)",
+                                current_address);
+        }
+        /* $operand_1*/
+        operand_address = current_address + 1;
+        next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
+                                operand_address, operand_1);
+        }
+        operand_address = next_operand_address;
+        /* %operand_2*/
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_2 %u",
+                                operand_address, operand_2);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## RSHIFT (operand_1=%u, operand_2=%u)",
+                                current_address, operand_1, operand_2);
+        }
+        /* execute the instruction */
+        result = operand_1 >> operand_2;
+        lsb = result & 0xff;
+        msb = result >> 8;
+        buff[result_dest] = msb;
+        buff[(result_dest+1) & 0xffff] = lsb;
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"     Loading result %u at %u",
+                                result, result_dest);
+        }
+        current_address = next_operand_address;
+        goto execute_next_instruction;
+        break;
+    case SIGCOMP_INSTR_ADD: /* 6 ADD ($operand_1, %operand_2) */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## ADD(6) (operand_1, operand_2)",
+                                current_address);
+        }
+        /* $operand_1*/
+        operand_address = current_address + 1;
+        next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
+                                operand_address, operand_1);
+        }
+        operand_address = next_operand_address;
+        /* %operand_2*/
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_2 %u",
+                                operand_address, operand_2);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## ADD (operand_1=%u, operand_2=%u)",
+                                current_address, operand_1, operand_2);
+        }
+        /* execute the instruction */
+        result = operand_1 + operand_2;
+        lsb = result & 0xff;
+        msb = result >> 8;
+        buff[result_dest] = msb;
+        buff[(result_dest+1) & 0xffff] = lsb;
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"               Loading result %u at %u",
+                                result, result_dest);
+        }
+        current_address = next_operand_address;
+        goto execute_next_instruction;
+
+    case SIGCOMP_INSTR_SUBTRACT: /* 7 SUBTRACT ($operand_1, %operand_2) */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## SUBTRACT(7) (operand_1, operand_2)",
+                                current_address);
+        }
+        /* $operand_1*/
+        operand_address = current_address + 1;
+        next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
+                                operand_address, operand_1);
+        }
+        operand_address = next_operand_address;
+        /* %operand_2*/
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_2 %u",
+                                operand_address, operand_2);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## SUBTRACT (operand_1=%u, operand_2=%u)",
+                                current_address, operand_1, operand_2);
+        }
+        /* execute the instruction */
+        result = operand_1 - operand_2;
+        lsb = result & 0xff;
+        msb = result >> 8;
+        buff[result_dest] = msb;
+        buff[(result_dest+1) & 0xffff] = lsb;
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"               Loading result %u at %u",
+                                result, result_dest);
+        }
+        current_address = next_operand_address;
+        goto execute_next_instruction;
+        break;
+
+    case SIGCOMP_INSTR_MULTIPLY: /* 8 MULTIPLY ($operand_1, %operand_2) */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ##MULTIPLY(8) (operand_1, operand_2)",
+                                current_address);
+        }
+        /* $operand_1*/
+        operand_address = current_address + 1;
+        next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
+                                operand_address, operand_1);
+        }
+        operand_address = next_operand_address;
+        /* %operand_2*/
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_2 %u",
+                                operand_address, operand_2);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## MULTIPLY (operand_1=%u, operand_2=%u)",
+                                current_address, operand_1, operand_2);
+        }
+        /*
+         * execute the instruction
+         * MULTIPLY (m, n)  := m * n (modulo 2^16)
+         */
+        if ( operand_2 == 0) {
+            result_code = 4;
+            goto decompression_failure;
+        }
+        result = operand_1 * operand_2;
+        lsb = result & 0xff;
+        msb = result >> 8;
+        buff[result_dest] = msb;
+        buff[(result_dest+1) & 0xffff] = lsb;
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"     Loading result %u at %u",
+                                result, result_dest);
+        }
+        current_address = next_operand_address;
+        goto execute_next_instruction;
+        break;
+
+    case SIGCOMP_INSTR_DIVIDE: /* 9 DIVIDE ($operand_1, %operand_2) */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## DIVIDE(9) (operand_1, operand_2)",
+                                current_address);
+        }
+        /* $operand_1*/
+        operand_address = current_address + 1;
+        next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
+                                operand_address, operand_1);
+        }
+        operand_address = next_operand_address;
+        /* %operand_2*/
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_2 %u",
+                                operand_address, operand_2);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## DIVIDE (operand_1=%u, operand_2=%u)",
+                                current_address, operand_1, operand_2);
+        }
+        /*
+         * execute the instruction
+         * DIVIDE (m, n)    := floor(m / n)
+         * Decompression failure occurs if a DIVIDE or REMAINDER instruction
+         * encounters an operand_2 that is zero.
+         */
+        if ( operand_2 == 0) {
+            result_code = 4;
+            goto decompression_failure;
+        }
+        result = operand_1 / operand_2;
+        lsb = result & 0xff;
+        msb = result >> 8;
+        buff[result_dest] = msb;
+        buff[(result_dest+1) & 0xffff] = lsb;
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"     Loading result %u at %u",
+                                result, result_dest);
+        }
+        current_address = next_operand_address;
+        goto execute_next_instruction;
+        break;
+
+    case SIGCOMP_INSTR_REMAINDER: /* 10 REMAINDER ($operand_1, %operand_2) */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## REMAINDER(10) (operand_1, operand_2)",
+                                current_address);
+        }
+        /* $operand_1*/
+        operand_address = current_address + 1;
+        next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
+                                operand_address, operand_1);
+        }
+        operand_address = next_operand_address;
+        /* %operand_2*/
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_2 %u",
+                                operand_address, operand_2);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## REMAINDER (operand_1=%u, operand_2=%u)",
+                                current_address, operand_1, operand_2);
+        }
+        /*
+         * execute the instruction
+         * REMAINDER (m, n) := m - n * floor(m / n)
+         * Decompression failure occurs if a DIVIDE or REMAINDER instruction
+         * encounters an operand_2 that is zero.
+         */
+        if ( operand_2 == 0) {
+            result_code = 4;
+            goto decompression_failure;
+        }
+        result = operand_1 - operand_2 * (operand_1 / operand_2);
+        lsb = result & 0xff;
+        msb = result >> 8;
+        buff[result_dest] = msb;
+        buff[(result_dest+1) & 0xffff] = lsb;
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"     Loading result %u at %u",
+                                result, result_dest);
+        }
+        current_address = next_operand_address;
+        goto execute_next_instruction;
+        break;
+    case SIGCOMP_INSTR_SORT_ASCENDING: /* 11 SORT-ASCENDING (%start, %n, %k) */
+        /*
+         *      used_udvm_cycles =  1 + k * (ceiling(log2(k)) + n)
+         */
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## SORT-ASCENDING(11) (start, n, k))",
+                                current_address);
+        }
+        proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Execution of this instruction is NOT implemented");
+        /*
+         *      used_udvm_cycles =  1 + k * (ceiling(log2(k)) + n)
+         */
+        break;
+
+    case SIGCOMP_INSTR_SORT_DESCENDING: /* 12 SORT-DESCENDING (%start, %n, %k) */
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## SORT-DESCENDING(12) (start, n, k))",
+                                current_address);
+        }
+        proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Execution of this instruction is NOT implemented");
+        /*
+         *      used_udvm_cycles =  1 + k * (ceiling(log2(k)) + n)
+         */
+        break;
+    case SIGCOMP_INSTR_SHA_1: /* 13 SHA-1 (%position, %length, %destination) */
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## SHA-1(13) (position, length, destination)",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+        /* %position */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &position);
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      position %u",
+                                operand_address, position);
+        }
+        operand_address = next_operand_address;
+
+        /* %length */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Length %u",
+                                operand_address, length);
+        }
+        operand_address = next_operand_address;
+
+        /* $destination */
+        next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &ref_destination, &result_dest);
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      $destination %u",
+                                operand_address, ref_destination);
+        }
+        used_udvm_cycles = used_udvm_cycles + length;
+
+        n = 0;
+        k = position;
+        byte_copy_right = buff[66] << 8;
+        byte_copy_right = byte_copy_right | buff[67];
+        byte_copy_left = buff[64] << 8;
+        byte_copy_left = byte_copy_left | buff[65];
+
+        if (print_level_2 ) {
+            proto_tree_add_text(udvm_tree, message_tvb, 0, -1,
+                                "byte_copy_right = %u", byte_copy_right);
+        }
+
+        sha1_starts( &ctx );
+
+        while (n<length) {
+            guint16 handle_now = length;
+
+            if ( k < byte_copy_right && byte_copy_right <= k + (length-n) ) {
+                handle_now = byte_copy_right - position;
+            }
+
+            if (k + handle_now >= UDVM_MEMORY_SIZE)
+                goto decompression_failure;
+            sha1_update( &ctx, &buff[k], handle_now );
+
+            k = ( k + handle_now ) & 0xffff;
+            n = ( n + handle_now ) & 0xffff;
+
+            if ( k >= byte_copy_right ) {
+                k = byte_copy_left;
+            }
+        }
+
+        sha1_finish( &ctx, sha1_digest_buf );
+
+        k = ref_destination;
+
+        for ( n=0; n< STATE_BUFFER_SIZE; n++ ) {
+
+            buff[k] = sha1_digest_buf[n];
+
+            k = ( k + 1 ) & 0xffff;
+            n++;
+
+            if ( k == byte_copy_right ) {
+                k = byte_copy_left;
+            }
+        }
+
+        if (print_level_2 ) {
+            proto_tree_add_text(udvm_tree, message_tvb, 0, -1,
+                                "Calculated SHA-1: %s",
+                                bytes_to_str(wmem_packet_scope(), sha1_digest_buf, STATE_BUFFER_SIZE));
+        }
+
+        current_address = next_operand_address;
+        goto execute_next_instruction;
+        break;
+
+    case SIGCOMP_INSTR_LOAD: /* 14 LOAD (%address, %value) */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## LOAD(14) (%%address, %%value)",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+        /* %address */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &addr);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Address %u",
+                                operand_address, addr);
+        }
+        operand_address = next_operand_address;
+        /* %value */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value);
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## LOAD (%%address=%u, %%value=%u)",
+                                current_address, addr, value);
+        }
+        lsb = value & 0xff;
+        msb = value >> 8;
+
+        buff[addr] = msb;
+        buff[(addr + 1) & 0xffff] = lsb;
+
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Value %u",
+                                operand_address, value);
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"     Loading bytes at %u Value %u 0x%x",
+                                addr, value, value);
+        }
+        current_address = next_operand_address;
+        goto execute_next_instruction;
+        break;
+
+    case SIGCOMP_INSTR_MULTILOAD: /* 15 MULTILOAD (%address, #n, %value_0, ..., %value_n-1) */
+        /* RFC 3320:
+         * The MULTILOAD instruction sets a contiguous block of 2-byte words in
+         * the UDVM memory to specified values.
+         * Hmm what if the value to load only takes one byte ? Chose to always load two bytes.
+         */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## MULTILOAD(15) (%%address, #n, value_0, ..., value_n-1)",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+        /* %address */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &addr);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Address %u",
+                                operand_address, addr);
+        }
+        operand_address = next_operand_address;
+
+        /* #n */
+        next_operand_address = decode_udvm_literal_operand(buff,operand_address, &n);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      n %u",
+                                operand_address, n);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## MULTILOAD (%%address=%u, #n=%u, value_0, ..., value_%d)",
+                                current_address, addr, n, n-1);
+        }
+        operand_address = next_operand_address;
+        used_udvm_cycles = used_udvm_cycles + n;
+        while ( n > 0) {
+            n = n - 1;
+            /* %value */
+            next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value);
+            lsb = value & 0xff;
+            msb = value >> 8;
+
+            if (addr >= UDVM_MEMORY_SIZE - 1)
+                goto decompression_failure;
+
+            buff[addr] = msb;
+            buff[(addr + 1) & 0xffff] = lsb;
+            /* debug
+             */
+            length = next_operand_address - operand_address;
+
+            if (print_level_1 ) {
+                proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1, "Addr: %u      Value %5u      - Loading bytes at %5u Value %5u 0x%x",
+                                    operand_address, value, addr, value, value);
+            }
+            addr = addr + 2;
+            operand_address = next_operand_address;
+        }
+        current_address = next_operand_address;
+        goto execute_next_instruction;
+
+        break;
+
+    case SIGCOMP_INSTR_PUSH: /* 16 PUSH (%value) */
+        if (show_instr_detail_level == 2) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## PUSH(16) (value)",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+        /* %value */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value);
+        if (show_instr_detail_level == 2) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Value %u",
+                                operand_address, value);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## PUSH (value=%u)",
+                                current_address, value);
+        }
+        current_address = next_operand_address;
+
+        /* Push the value address onto the stack */
+        stack_location = (buff[70] << 8) | buff[71];
+        stack_fill = (buff[stack_location] << 8)
+            | buff[(stack_location+1) & 0xFFFF];
+        addr = (stack_location + stack_fill * 2 + 2) & 0xFFFF;
+
+        if (addr >= UDVM_MEMORY_SIZE - 1)
+            goto decompression_failure;
+
+        buff[addr] = (value >> 8) & 0x00FF;
+        buff[(addr+1) & 0xFFFF] = value & 0x00FF;
+
+        if (stack_location >= UDVM_MEMORY_SIZE - 1)
+            goto decompression_failure;
+
+        stack_fill = (stack_fill + 1) & 0xFFFF;
+        buff[stack_location] = (stack_fill >> 8) & 0x00FF;
+        buff[(stack_location+1) & 0xFFFF] = stack_fill & 0x00FF;
+
+        goto execute_next_instruction;
+
+        break;
+
+    case SIGCOMP_INSTR_POP: /* 17 POP (%address) */
+        if (show_instr_detail_level == 2) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## POP(16) (value)",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+        /* %value */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);
+        if (show_instr_detail_level == 2) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Value %u",
+                                operand_address, destination);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## POP (address=%u)",
+                                current_address, destination);
+        }
+        current_address = next_operand_address;
+
+        /* Pop value from the top of the stack */
+        stack_location = (buff[70] << 8) | buff[71];
+        stack_fill = (buff[stack_location] << 8)
+            | buff[(stack_location+1) & 0xFFFF];
+        if (stack_fill == 0)
+        {
+            result_code = 16;
+            goto decompression_failure;
+        }
+
+        if (stack_location >= UDVM_MEMORY_SIZE - 1)
+            goto decompression_failure;
+
+        stack_fill = (stack_fill - 1) & 0xFFFF;
+        buff[stack_location] = (stack_fill >> 8) & 0x00FF;
+        buff[(stack_location+1) & 0xFFFF] = stack_fill & 0x00FF;
+
+        addr = (stack_location + stack_fill * 2 + 2) & 0xFFFF;
+
+        if (addr >= UDVM_MEMORY_SIZE - 1)
+            goto decompression_failure;
+
+        value = (buff[addr] << 8)
+            | buff[(addr+1) & 0xFFFF];
+
+        /* ... and store the popped value. */
+        if (destination >= UDVM_MEMORY_SIZE - 1)
+            goto decompression_failure;
+        buff[destination] = (value >> 8) & 0x00FF;
+        buff[(destination+1) & 0xFFFF] = value & 0x00FF;
+
+        goto execute_next_instruction;
+
+        break;
+
+    case SIGCOMP_INSTR_COPY: /* 18 COPY (%position, %length, %destination) */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## COPY(18) (position, length, destination)",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+        /* %position */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &position);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      position %u",
+                                operand_address, position);
+        }
+        operand_address = next_operand_address;
+
+        /* %length */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Length %u",
+                                operand_address, length);
+        }
+        operand_address = next_operand_address;
+
+        /* %destination */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Destination %u",
+                                operand_address, destination);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## COPY (position=%u, length=%u, destination=%u)",
+                                current_address, position, length, destination);
+        }
+        current_address = next_operand_address;
+        /*
+         * 8.4.  Byte copying
+         * :
+         * The string of bytes is copied in ascending order of memory address,
+         * respecting the bounds set by byte_copy_left and byte_copy_right.
+         * More precisely, if a byte is copied from/to Address m then the next
+         * byte is copied from/to Address n where n is calculated as follows:
+         *
+         * Set k := m + 1 (modulo 2^16)
+         * If k = byte_copy_right then set n := byte_copy_left, else set n := k
+         *
+         */
+
+        n = 0;
+        k = destination;
+        byte_copy_right = buff[66] << 8;
+        byte_copy_right = byte_copy_right | buff[67];
+        byte_copy_left = buff[64] << 8;
+        byte_copy_left = byte_copy_left | buff[65];
+        if (print_level_2 ) {
+            proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
+                                "               byte_copy_right = %u", byte_copy_right);
+        }
+
+        while ( n < length ) {
+            buff[k] = buff[position];
+            if (print_level_2 ) {
+                proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
+                                    "               Copying value: %u (0x%x) to Addr: %u",
+                                    buff[position], buff[position], k);
+            }
+            position = ( position + 1 ) & 0xffff;
+            k = ( k + 1 ) & 0xffff;
+            n++;
+
+            /*
+             * Check for circular buffer wrapping after the positions are
+             * incremented. If either started at BCR then they should continue
+             * to increment beyond BCR.
+             */
+            if ( k == byte_copy_right ) {
+                k = byte_copy_left;
+            }
+            if ( position == byte_copy_right ) {
+                position = byte_copy_left;
+            }
+        }
+        used_udvm_cycles = used_udvm_cycles + length;
+        goto execute_next_instruction;
+        break;
+
+    case SIGCOMP_INSTR_COPY_LITERAL: /* 19 COPY-LITERAL (%position, %length, $destination) */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## COPY-LITERAL(19) (position, length, $destination)",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+        /* %position */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &position);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      position %u",
+                                operand_address, position);
+        }
+        operand_address = next_operand_address;
+
+        /* %length */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Length %u",
+                                operand_address, length);
+        }
+        operand_address = next_operand_address;
+
+
+        /* $destination */
+        next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &ref_destination, &result_dest);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      destination %u",
+                                operand_address, ref_destination);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## COPY-LITERAL (position=%u, length=%u, $destination=%u)",
+                                current_address, position, length, ref_destination);
+        }
+        current_address = next_operand_address;
+
+
+        /*
+         * 8.4.  Byte copying
+         * :
+         * The string of bytes is copied in ascending order of memory address,
+         * respecting the bounds set by byte_copy_left and byte_copy_right.
+         * More precisely, if a byte is copied from/to Address m then the next
+         * byte is copied from/to Address n where n is calculated as follows:
+         *
+         * Set k := m + 1 (modulo 2^16)
+         * If k = byte_copy_right then set n := byte_copy_left, else set n := k
+         *
+         */
+
+        n = 0;
+        k = ref_destination;
+        byte_copy_right = buff[66] << 8;
+        byte_copy_right = byte_copy_right | buff[67];
+        byte_copy_left = buff[64] << 8;
+        byte_copy_left = byte_copy_left | buff[65];
+        if (print_level_2 ) {
+            proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
+                                "               byte_copy_right = %u", byte_copy_right);
+        }
+        while ( n < length ) {
+
+            buff[k] = buff[position];
+            if (print_level_2 ) {
+                proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
+                                    "               Copying value: %u (0x%x) to Addr: %u",
+                                    buff[position], buff[position], k);
+            }
+            position = ( position + 1 ) & 0xffff;
+            k = ( k + 1 ) & 0xffff;
+            n++;
+
+            /*
+             * Check for circular buffer wrapping after the positions are
+             * incremented. It is important that k cannot be left set
+             * to BCR. Also, if either started at BCR then they should continue
+             * to increment beyond BCR.
+             */
+            if ( k == byte_copy_right ) {
+                k = byte_copy_left;
+            }
+            if ( position == byte_copy_right ) {
+                position = byte_copy_left;
+            }
+        }
+        buff[result_dest] = k >> 8;
+        buff[(result_dest + 1) & 0xffff] = k & 0x00ff;
+
+        used_udvm_cycles = used_udvm_cycles + length;
+        goto execute_next_instruction;
+        break;
+
+    case SIGCOMP_INSTR_COPY_OFFSET: /* 20 COPY-OFFSET (%offset, %length, $destination) */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## COPY-OFFSET(20) (offset, length, $destination)",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+        /* %offset */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &multy_offset);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      offset %u",
+                                operand_address, multy_offset);
+        }
+        operand_address = next_operand_address;
+
+        /* %length */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Length %u",
+                                operand_address, length);
+        }
+        operand_address = next_operand_address;
+
+
+        /* $destination */
+        next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &ref_destination, &result_dest);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      $destination %u",
+                                operand_address, ref_destination);
+        }
+
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## COPY-OFFSET (offset=%u, length=%u, $destination=%u)",
+                                current_address, multy_offset, length, result_dest);
+        }
+        current_address = next_operand_address;
+
+        /* Execute the instruction:
+         * To derive the value of the position operand, starting at the memory
+         * address specified by destination, the UDVM counts backwards a total
+         * of offset memory addresses.
+         *
+         * If the memory address specified in byte_copy_left is reached, the
+         * next memory address is taken to be (byte_copy_right - 1) modulo 2^16.
+         */
+        byte_copy_left = buff[64] << 8;
+        byte_copy_left = byte_copy_left | buff[65];
+        byte_copy_right = buff[66] << 8;
+        byte_copy_right = byte_copy_right | buff[67];
+
+        /*
+         * In order to work out the position, simple arithmetic is tricky
+         * to apply because there some nasty corner cases. A simple loop
+         * is inefficient but the logic is simple.
+         *
+         * FUTURE: This could be optimised.
+         */
+        for (position = ref_destination, i = 0; i < multy_offset; i++)
+        {
+            if ( position == byte_copy_left )
+            {
+                position = (byte_copy_right - 1) & 0xffff;
+            }
+            else
+            {
+                position = (position - 1) & 0xffff;
+            }
+        }
+
+        if (print_level_2 ) {
+            proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
+                                "               byte_copy_left = %u byte_copy_right = %u position= %u",
+                                byte_copy_left, byte_copy_right, position);
+        }
+        /* The COPY-OFFSET instruction then behaves as a COPY-LITERAL
+         * instruction, taking the value of the position operand to be the last
+         * memory address reached in the above step.
+         */
+
+        /*
+         * 8.4.  Byte copying
+         * :
+         * The string of bytes is copied in ascending order of memory address,
+         * respecting the bounds set by byte_copy_left and byte_copy_right.
+         * More precisely, if a byte is copied from/to Address m then the next
+         * byte is copied from/to Address n where n is calculated as follows:
+         *
+         * Set k := m + 1 (modulo 2^16)
+         * If k = byte_copy_right then set n := byte_copy_left, else set n := k
+         *
+         */
+
+        n = 0;
+        k = ref_destination;
+        if (print_level_2 ) {
+            proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
+                                "               byte_copy_left = %u byte_copy_right = %u", byte_copy_left, byte_copy_right);
+        }
+        while ( n < length ) {
+            buff[k] = buff[position];
+            if (print_level_2 ) {
+                proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
+                                    "               Copying value: %5u (0x%x) from Addr: %u to Addr: %u",
+                                    buff[position], buff[position],(position), k);
+            }
+            n++;
+            k = ( k + 1 ) & 0xffff;
+            position = ( position + 1 ) & 0xffff;
+
+            /*
+             * Check for circular buffer wrapping after the positions are
+             * incremented. It is important that k cannot be left set
+             * to BCR. Also, if either started at BCR then they should continue
+             * to increment beyond BCR.
+             */
+            if ( k == byte_copy_right ) {
+                k = byte_copy_left;
+            }
+            if ( position == byte_copy_right ) {
+                position = byte_copy_left;
+            }
+        }
+        buff[result_dest] = k >> 8;
+        buff[result_dest + 1] = k & 0x00ff;
+        used_udvm_cycles = used_udvm_cycles + length;
+        goto execute_next_instruction;
+
+        break;
+    case SIGCOMP_INSTR_MEMSET: /* 21 MEMSET (%address, %length, %start_value, %offset) */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## MEMSET(21) (address, length, start_value, offset)",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+
+        /* %address */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &addr);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Address %u",
+                                operand_address, addr);
+        }
+        operand_address = next_operand_address;
+
+        /*  %length, */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Length %u",
+                                operand_address, length);
+        }
+        operand_address = next_operand_address;
+        /* %start_value */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &start_value);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      start_value %u",
+                                operand_address, start_value);
+        }
+        operand_address = next_operand_address;
+
+        /* %offset */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &multy_offset);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      offset %u",
+                                operand_address, multy_offset);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## MEMSET (address=%u, length=%u, start_value=%u, offset=%u)",
+                                current_address, addr, length, start_value, multy_offset);
+        }
+        current_address = next_operand_address;
+        /* exetute the instruction
+         * The sequence of values used by the MEMSET instruction is specified by
+         * the following formula:
+         *
+         * Seq[n] := (start_value + n * offset) modulo 256
+         */
+        n = 0;
+        k = addr;
+        byte_copy_right = buff[66] << 8;
+        byte_copy_right = byte_copy_right | buff[67];
+        byte_copy_left = buff[64] << 8;
+        byte_copy_left = byte_copy_left | buff[65];
+        if (print_level_2 ) {
+            proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
+                                "               byte_copy_left = %u byte_copy_right = %u", byte_copy_left, byte_copy_right);
+        }
+        while ( n < length ) {
+            if ( k == byte_copy_right ) {
+                k = byte_copy_left;
+            }
+            buff[k] = (start_value + ( n * multy_offset)) & 0xff;
+            if (print_level_2 ) {
+                proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
+                                    "     Storing value: %u (0x%x) at Addr: %u",
+                                    buff[k], buff[k], k);
+            }
+            k = ( k + 1 ) & 0xffff;
+            n++;
+        }/* end while */
+        used_udvm_cycles = used_udvm_cycles + length;
+        goto execute_next_instruction;
+        break;
+
+
+    case SIGCOMP_INSTR_JUMP: /* 22 JUMP (@address) */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## JUMP(22) (@address)",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+        /* @address */
+        /* operand_value = (memory_address_of_instruction + D) modulo 2^16 */
+        /*next_operand_address = */decode_udvm_address_operand(buff,operand_address, &at_address, current_address);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
+                                operand_address, at_address);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## JUMP (@address=%u)",
+                                current_address, at_address);
+        }
+        current_address = at_address;
+        goto execute_next_instruction;
+        break;
+
+    case SIGCOMP_INSTR_COMPARE: /* 23 */
+        /* COMPARE (%value_1, %value_2, @address_1, @address_2, @address_3)
+         */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## COMPARE(23) (value_1, value_2, @address_1, @address_2, @address_3)",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+
+        /* %value_1 */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value_1);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Value %u",
+                                operand_address, value_1);
+        }
+        operand_address = next_operand_address;
+
+        /* %value_2 */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value_2);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Value %u",
+                                operand_address, value_2);
+        }
+        operand_address = next_operand_address;
+
+        /* @address_1 */
+        /* operand_value = (memory_address_of_instruction + D) modulo 2^16 */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address_1);
+        at_address_1 = ( current_address + at_address_1) & 0xffff;
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
+                                operand_address, at_address_1);
+        }
+        operand_address = next_operand_address;
+
+
+        /* @address_2 */
+        /* operand_value = (memory_address_of_instruction + D) modulo 2^16 */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address_2);
+        at_address_2 = ( current_address + at_address_2) & 0xffff;
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
+                                operand_address, at_address_2);
+        }
+        operand_address = next_operand_address;
+
+        /* @address_3 */
+        /* operand_value = (memory_address_of_instruction + D) modulo 2^16 */
+        /*next_operand_address = */decode_udvm_multitype_operand(buff, operand_address, &at_address_3);
+        at_address_3 = ( current_address + at_address_3) & 0xffff;
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
+                                operand_address, at_address_3);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## COMPARE (value_1=%u, value_2=%u, @address_1=%u, @address_2=%u, @address_3=%u)",
+                                current_address, value_1, value_2, at_address_1, at_address_2, at_address_3);
+        }
+        /* execute the instruction
+         * If value_1 < value_2 then the UDVM continues instruction execution at
+         * the memory address specified by address 1. If value_1 = value_2 then
+         * it jumps to the address specified by address_2. If value_1 > value_2
+         * then it jumps to the address specified by address_3.
+         */
+        if ( value_1 < value_2 )
+            current_address = at_address_1;
+        if ( value_1 == value_2 )
+            current_address = at_address_2;
+        if ( value_1 > value_2 )
+            current_address = at_address_3;
+        goto execute_next_instruction;
+        break;
+
+    case SIGCOMP_INSTR_CALL: /* 24 CALL (@address) (PUSH addr )*/
+        if (show_instr_detail_level == 2) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## CALL(24) (@address) (PUSH addr )",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+        /* @address */
+        next_operand_address = decode_udvm_address_operand(buff,operand_address, &at_address, current_address);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
+                                operand_address, at_address);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## CALL (@address=%u)",
+                                current_address, at_address);
+        }
+        current_address = next_operand_address;
+
+        /* Push the current address onto the stack */
+        stack_location = (buff[70] << 8) | buff[71];
+        stack_fill = (buff[stack_location] << 8)
+            | buff[(stack_location+1) & 0xFFFF];
+        addr = (stack_location + stack_fill * 2 + 2) & 0xFFFF;
+        if (addr >= UDVM_MEMORY_SIZE - 1)
+            goto decompression_failure;
+        buff[addr] = (current_address >> 8) & 0x00FF;
+        buff[(addr+1) & 0xFFFF] = current_address & 0x00FF;
+
+        stack_fill = (stack_fill + 1) & 0xFFFF;
+        if (stack_location >= UDVM_MEMORY_SIZE - 1)
+            goto decompression_failure;
+        buff[stack_location] = (stack_fill >> 8) & 0x00FF;
+        buff[(stack_location+1) & 0xFFFF] = stack_fill & 0x00FF;
+
+        /* ... and jump to the destination address */
+        current_address = at_address;
+
+        goto execute_next_instruction;
+
+        break;
+
+    case SIGCOMP_INSTR_RETURN: /* 25 POP and return */
+        if (print_level_1 || show_instr_detail_level == 1) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## POP(25) and return",
+                                current_address);
+        }
+
+        /* Pop value from the top of the stack */
+        stack_location = (buff[70] << 8) | buff[71];
+        stack_fill = (buff[stack_location] << 8)
+            | buff[(stack_location+1) & 0xFFFF];
+        if (stack_fill == 0)
+        {
+            result_code = 16;
+            goto decompression_failure;
+        }
+
+        stack_fill = (stack_fill - 1) & 0xFFFF;
+        if (stack_location >= UDVM_MEMORY_SIZE - 1)
+            goto decompression_failure;
+        buff[stack_location] = (stack_fill >> 8) & 0x00FF;
+        buff[(stack_location+1) & 0xFFFF] = stack_fill & 0x00FF;
+
+        addr = (stack_location + stack_fill * 2 + 2) & 0xFFFF;
+        at_address = (buff[addr] << 8)
+            | buff[(addr+1) & 0xFFFF];
+
+        /* ... and set the PC to the popped value */
+        current_address = at_address;
+
+        goto execute_next_instruction;
+
+        break;
+
+    case SIGCOMP_INSTR_SWITCH: /* 26 SWITCH (#n, %j, @address_0, @address_1, ... , @address_n-1) */
+        /*
+         * When a SWITCH instruction is encountered the UDVM reads the value of
+         * j. It then continues instruction execution at the address specified
+         * by address j.
+         *
+         * Decompression failure occurs if j specifies a value of n or more, or
+         * if the address lies beyond the overall UDVM memory size.
+         */
+        instruction_address = current_address;
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## SWITCH (#n, j, @address_0, @address_1, ... , @address_n-1))",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+        /* #n
+         * Number of addresses in the instruction
+         */
+        next_operand_address = decode_udvm_literal_operand(buff,operand_address, &n);
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      n %u",
+                                operand_address, n);
+        }
+        operand_address = next_operand_address;
+        /* %j */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &j);
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      j %u",
+                                operand_address, j);
+        }
+        operand_address = next_operand_address;
+        m = 0;
+        while ( m < n ) {
+            /* @address_n-1 */
+            /* operand_value = (memory_address_of_instruction + D) modulo 2^16 */
+            next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address_1);
+            at_address_1 = ( instruction_address + at_address_1) & 0xffff;
+            if (print_level_1 ) {
+                proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
+                                    operand_address, at_address_1);
+            }
+            if ( j == m ) {
+                current_address = at_address_1;
+            }
+            operand_address = next_operand_address;
+            m++;
+        }
+        /* Check decompression failure */
+        if ( ( j == n ) || ( j > n )) {
+            result_code = 5;
+            goto decompression_failure;
+        }
+        if ( current_address > UDVM_MEMORY_SIZE ) {
+            result_code = 6;
+            goto decompression_failure;
+        }
+        used_udvm_cycles = used_udvm_cycles + n;
+
+        goto execute_next_instruction;
+
+        break;
+    case SIGCOMP_INSTR_CRC: /* 27 CRC (%value, %position, %length, @address) */
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## CRC (value, position, length, @address)",
+                                current_address);
+        }
+
+        operand_address = current_address + 1;
+
+        /* %value */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value);
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Value %u",
+                                operand_address, value);
+        }
+        operand_address = next_operand_address;
+
+        /* %position */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &position);
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      position %u",
+                                operand_address, position);
+        }
+        operand_address = next_operand_address;
+
+        /* %length */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Length %u",
+                                operand_address, length);
+        }
+        operand_address = next_operand_address;
+
+        /* @address */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address);
+        at_address = ( current_address + at_address) & 0xffff;
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
+                                operand_address, at_address);
+        }
+        /* operand_value = (memory_address_of_instruction + D) modulo 2^16 */
+        used_udvm_cycles = used_udvm_cycles + length;
+
+        n = 0;
+        k = position;
+        byte_copy_right = buff[66] << 8;
+        byte_copy_right = byte_copy_right | buff[67];
+        byte_copy_left = buff[64] << 8;
+        byte_copy_left = byte_copy_left | buff[65];
+        result = 0;
+
+        if (print_level_2 ) {
+            proto_tree_add_text(udvm_tree, message_tvb, 0, -1,
+                                "byte_copy_right = %u", byte_copy_right);
+        }
+
+        while (n<length) {
+
+            guint16 handle_now = length - n;
+
+            if ( k < byte_copy_right && byte_copy_right <= k + (length-n) ) {
+                handle_now = byte_copy_right - k;
+            }
+
+            if (k + handle_now >= UDVM_MEMORY_SIZE)
+                goto decompression_failure;
+            result = crc16_ccitt_seed(&buff[k], handle_now, (guint16) (result ^ 0xffff));
+
+            k = ( k + handle_now ) & 0xffff;
+            n = ( n + handle_now ) & 0xffff;
+
+            if ( k >= byte_copy_right ) {
+                k = byte_copy_left;
+            }
+        }
+
+        result = result ^ 0xffff;
+
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1, "Calculated CRC %u", result);
+        }
+        if (result != value) {
+            current_address = at_address;
+        }
+        else {
+            current_address = next_operand_address;
+        }
+        goto execute_next_instruction;
+        break;
+
+
+    case SIGCOMP_INSTR_INPUT_BYTES: /* 28 INPUT-BYTES (%length, %destination, @address) */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## INPUT-BYTES(28) length, destination, @address)",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+        /* %length */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Length %u",
+                                operand_address, length);
+        }
+        operand_address = next_operand_address;
+
+        /* %destination */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Destination %u",
+                                operand_address, destination);
+        }
+        operand_address = next_operand_address;
+
+        /* @address */
+        /* operand_value = (memory_address_of_instruction + D) modulo 2^16 */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address);
+        at_address = ( current_address + at_address) & 0xffff;
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
+                                operand_address, at_address);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## INPUT-BYTES length=%u, destination=%u, @address=%u)",
+                                current_address, length, destination, at_address);
+        }
+        /* execute the instruction TODO insert checks
+         * RFC 3320 :
+         *
+         *    0             7 8            15
+         *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         *   |        byte_copy_left         |  64 - 65
+         *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         *   |        byte_copy_right        |  66 - 67
+         *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         *   |        input_bit_order        |  68 - 69
+         *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         *   |        stack_location         |  70 - 71
+         *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         *
+         * Figure 7: Memory addresses of the UDVM registers
+         * :
+         * 8.4.  Byte copying
+         * :
+         * The string of bytes is copied in ascending order of memory address,
+         * respecting the bounds set by byte_copy_left and byte_copy_right.
+         * More precisely, if a byte is copied from/to Address m then the next
+         * byte is copied from/to Address n where n is calculated as follows:
+         *
+         * Set k := m + 1 (modulo 2^16)
+         * If k = byte_copy_right then set n := byte_copy_left, else set n := k
+         *
+         */
+
+        n = 0;
+        k = destination;
+        byte_copy_right = buff[66] << 8;
+        byte_copy_right = byte_copy_right | buff[67];
+        byte_copy_left = buff[64] << 8;
+        byte_copy_left = byte_copy_left | buff[65];
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
+                                "               byte_copy_right = %u", byte_copy_right);
+        }
+        /* clear out remaining bits if any */
+        remaining_bits = 0;
+        input_bits=0;
+        /* operand_address used as dummy */
+        while ( n < length ) {
+            if (input_address > ( msg_end - 1)) {
+                current_address = at_address;
+                result_code = 14;
+                goto execute_next_instruction;
+            }
+
+            if ( k == byte_copy_right ) {
+                k = byte_copy_left;
+            }
+            octet = tvb_get_guint8(message_tvb, input_address);
+            buff[k] = octet;
+            if (print_level_1 ) {
+                proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
+                                    "               Loading value: %u (0x%x) at Addr: %u", octet, octet, k);
+            }
+            input_address++;
+            /*
+             * If the instruction requests data that lies beyond the end of the
+             * SigComp message, no data is returned.  Instead the UDVM moves program
+             * execution to the address specified by the address operand.
+             */
+
+
+            k = ( k + 1 ) & 0xffff;
+            n++;
+        }
+        used_udvm_cycles = used_udvm_cycles + length;
+        current_address = next_operand_address;
+        goto execute_next_instruction;
+        break;
+    case SIGCOMP_INSTR_INPUT_BITS:/* 29   INPUT-BITS (%length, %destination, @address) */
+        /*
+         * The length operand indicates the requested number of bits.
+         * Decompression failure occurs if this operand does not lie between 0
+         * and 16 inclusive.
+         *
+         * The destination operand specifies the memory address to which the
+         * compressed data should be copied.  Note that the requested bits are
+         * interpreted as a 2-byte integer ranging from 0 to 2^length - 1, as
+         * explained in Section 8.2.
+         *
+         * If the instruction requests data that lies beyond the end of the
+         * SigComp message, no data is returned.  Instead the UDVM moves program
+         * execution to the address specified by the address operand.
+         */
+
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## INPUT-BITS(29) (length, destination, @address)",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+
+        /* %length */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      length %u",
+                                operand_address, length);
+        }
+        operand_address = next_operand_address;
+        /* %destination */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Destination %u",
+                                operand_address, destination);
+        }
+        operand_address = next_operand_address;
+
+        /* @address */
+        /* operand_value = (memory_address_of_instruction + D) modulo 2^16 */
+        next_operand_address = decode_udvm_address_operand(buff,operand_address, &at_address, current_address);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
+                                operand_address, at_address);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## INPUT-BITS length=%u, destination=%u, @address=%u)",
+                                current_address, length, destination, at_address);
+        }
+        current_address = next_operand_address;
+
+        /*
+         * Execute actual instr.
+         * The input_bit_order register contains the following three flags:
+         *
+         *            0             7 8            15
+         *           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         *           |         reserved        |F|H|P|  68 - 69
+         *           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         */
+        input_bit_order = buff[68] << 8;
+        input_bit_order = input_bit_order | buff[69];
+        /*
+         * If the instruction requests data that lies beyond the end of the
+         * SigComp message, no data is returned.  Instead the UDVM moves program
+         * execution to the address specified by the address operand.
+         */
+
+        if ( length > 16 ) {
+            result_code = 7;
+            goto decompression_failure;
+        }
+        if ( input_bit_order > 7 ) {
+            result_code = 8;
+            goto decompression_failure;
+        }
+
+        /*
+         * Transfer F bit to bit_order to tell decomp dispatcher which bit order to use
+         */
+        bit_order = ( input_bit_order & 0x0004 ) >> 2;
+        value = decomp_dispatch_get_bits( message_tvb, udvm_tree, bit_order,
+                                          buff, &old_input_bit_order, &remaining_bits,
+                                          &input_bits, &input_address, length, &result_code, msg_end);
+        if ( result_code == 11 ) {
+            current_address = at_address;
+            goto execute_next_instruction;
+        }
+        msb = value >> 8;
+        lsb = value & 0x00ff;
+        if (destination >= UDVM_MEMORY_SIZE - 1)
+            goto decompression_failure;
+        buff[destination] = msb;
+        buff[(destination + 1) & 0xffff]=lsb;
+        if (print_level_1 ) {
+            proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
+                                "               Loading value: %u (0x%x) at Addr: %u, remaining_bits: %u", value, value, destination, remaining_bits);
+        }
+
+        goto execute_next_instruction;
+        break;
+    case SIGCOMP_INSTR_INPUT_HUFFMAN: /* 30 */
+        /*
+         * INPUT-HUFFMAN (%destination, @address, #n, %bits_1, %lower_bound_1,
+         *  %upper_bound_1, %uncompressed_1, ... , %bits_n, %lower_bound_n,
+         *  %upper_bound_n, %uncompressed_n)
+         */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## INPUT-HUFFMAN (destination, @address, #n, bits_1, lower_bound_1,upper_bound_1, uncompressed_1, ... , bits_n, lower_bound_n,upper_bound_n, uncompressed_n)",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+
+        /* %destination */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Destination %u",
+                                operand_address, destination);
+        }
+        operand_address = next_operand_address;
+
+        /* @address */
+        /* operand_value = (memory_address_of_instruction + D) modulo 2^16 */
+        next_operand_address = decode_udvm_address_operand(buff,operand_address, &at_address, current_address);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
+                                operand_address, at_address);
+        }
+        operand_address = next_operand_address;
+
+        /* #n */
+        next_operand_address = decode_udvm_literal_operand(buff,operand_address, &n);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      n %u",
+                                operand_address, n);
+        }
+        operand_address = next_operand_address;
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## INPUT-HUFFMAN (destination=%u, @address=%u, #n=%u, bits_1, lower_1,upper_1, unc_1, ... , bits_%d, lower_%d,upper_%d, unc_%d)",
+                                current_address, destination, at_address, n, n, n, n, n);
+        }
+
+        used_udvm_cycles = used_udvm_cycles + n;
+
+        /*
+         * Note that if n = 0 then the INPUT-HUFFMAN instruction is ignored and
+         * program execution resumes at the following instruction.
+         * Decompression failure occurs if (bits_1 + ... + bits_n) > 16.
+         *
+         * In all other cases, the behavior of the INPUT-HUFFMAN instruction is
+         * defined below:
+         *
+         * 1. Set j := 1 and set H := 0.
+         *
+         * 2. Request bits_j compressed bits.  Interpret the returned bits as an
+         * integer k from 0 to 2^bits_j - 1, as explained in Section 8.2.
+         *
+         * 3. Set H := H * 2^bits_j + k.
+         *
+         * 4. If data is requested that lies beyond the end of the SigComp
+         * message, terminate the INPUT-HUFFMAN instruction and move program
+         * execution to the memory address specified by the address operand.
+         *
+         * 5. If (H < lower_bound_j) or (H > upper_bound_j) then set j := j + 1.
+         * Then go back to Step 2, unless j > n in which case decompression
+         * failure occurs.
+         *
+         * 6. Copy (H + uncompressed_j - lower_bound_j) modulo 2^16 to the
+         * memory address specified by the destination operand.
+         *
+         */
+        /*
+         * The input_bit_order register contains the following three flags:
+         *
+         *            0             7 8            15
+         *           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         *           |         reserved        |F|H|P|  68 - 69
+         *           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         *
+         * Transfer H bit to bit_order to tell decomp dispatcher which bit order to use
+         */
+        input_bit_order = buff[68] << 8;
+        input_bit_order = input_bit_order | buff[69];
+        bit_order = ( input_bit_order & 0x0002 ) >> 1;
+
+        j = 1;
+        H = 0;
+        m = n;
+        outside_huffman_boundaries = TRUE;
+        print_in_loop = print_level_3;
+        while ( m > 0 ) {
+            /* %bits_n */
+            next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &bits_n);
+            if (print_in_loop ) {
+                proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      bits_n %u",
+                                    operand_address, bits_n);
+            }
+            operand_address = next_operand_address;
+
+            /* %lower_bound_n */
+            next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &lower_bound_n);
+            if (print_in_loop ) {
+                proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      lower_bound_n %u",
+                                    operand_address, lower_bound_n);
+            }
+            operand_address = next_operand_address;
+            /* %upper_bound_n */
+            next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &upper_bound_n);
+            if (print_in_loop ) {
+                proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      upper_bound_n %u",
+                                    operand_address, upper_bound_n);
+            }
+            operand_address = next_operand_address;
+            /* %uncompressed_n */
+            next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &uncompressed_n);
+            if (print_in_loop ) {
+                proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      uncompressed_n %u",
+                                    operand_address, uncompressed_n);
+            }
+            operand_address = next_operand_address;
+            /* execute instruction */
+            if ( outside_huffman_boundaries ) {
+                /*
+                 * 2. Request bits_j compressed bits.  Interpret the returned bits as an
+                 *    integer k from 0 to 2^bits_j - 1, as explained in Section 8.2.
+                 */
+                k = decomp_dispatch_get_bits( message_tvb, udvm_tree, bit_order,
+                                              buff, &old_input_bit_order, &remaining_bits,
+                                              &input_bits, &input_address, bits_n, &result_code, msg_end);
+                if ( result_code == 11 ) {
+                    /*
+                     * 4. If data is requested that lies beyond the end of the SigComp
+                     * message, terminate the INPUT-HUFFMAN instruction and move program
+                     * execution to the memory address specified by the address operand.
+                     */
+                    current_address = at_address;
+                    goto execute_next_instruction;
+                }
+
+                /*
+                 * 3. Set H := H * 2^bits_j + k.
+                 * [In practice is a shift+OR operation.]
+                 */
+                oldH = H;
+                H = (H << bits_n) | k;
+                if (print_level_3 ) {
+                    proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"               Set H(%u) := H(%u) * 2^bits_j(%u) + k(%u)",
+                                        H ,oldH, 1<<bits_n,k);
+                }
+
+                /*
+                 * 5. If (H < lower_bound_j) or (H > upper_bound_j) then set j := j + 1.
+                 * Then go back to Step 2, unless j > n in which case decompression
+                 * failure occurs.
+                 */
+                if ((H < lower_bound_n) || (H > upper_bound_n)) {
+                    outside_huffman_boundaries = TRUE;
+                } else {
+                    outside_huffman_boundaries = FALSE;
+                    print_in_loop = FALSE;
+                    /*
+                     * 6. Copy (H + uncompressed_j - lower_bound_j) modulo 2^16 to the
+                     * memory address specified by the destination operand.
+                     */
+                    if (print_level_2 ) {
+                        proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                            "               H(%u) = H(%u) + uncompressed_n(%u) - lower_bound_n(%u)",
+                                            (H + uncompressed_n - lower_bound_n ),H, uncompressed_n, lower_bound_n);
+                    }
+                    H = H + uncompressed_n - lower_bound_n;
+                    msb = H >> 8;
+                    lsb = H & 0x00ff;
+                    if (destination >= UDVM_MEMORY_SIZE - 1)
+                        goto decompression_failure;
+                    buff[destination] = msb;
+                    buff[(destination + 1) & 0xffff]=lsb;
+                    if (print_level_1 ) {
+                        proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
+                                            "               Loading H: %u (0x%x) at Addr: %u,j = %u remaining_bits: %u",
+                                            H, H, destination,( n - m + 1 ), remaining_bits);
+                    }
+
+                }
+
+
+            }
+            m = m - 1;
+        }
+        if ( outside_huffman_boundaries ) {
+            result_code = 10;
+            goto decompression_failure;
+        }
+
+        current_address = next_operand_address;
+        goto execute_next_instruction;
+        break;
+
+    case SIGCOMP_INSTR_STATE_ACCESS: /* 31 */
+        /*   STATE-ACCESS (%partial_identifier_start, %partial_identifier_length,
+         * %state_begin, %state_length, %state_address, %state_instruction)
+         */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## STATE-ACCESS(31) (partial_identifier_start, partial_identifier_length,state_begin, state_length, state_address, state_instruction)",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+
+        /*
+         * %partial_identifier_start
+         */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &p_id_start);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       partial_identifier_start %u",
+                                operand_address, p_id_start);
+        }
+
+        /*
+         * %partial_identifier_length
+         */
+        operand_address = next_operand_address;
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &p_id_length);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       partial_identifier_length %u",
+                                operand_address, p_id_length);
+        }
+        /*
+         * %state_begin
+         */
+        operand_address = next_operand_address;
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_begin);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       state_begin %u",
+                                operand_address, state_begin);
+        }
+        /*
+         * %state_length
+         */
+        operand_address = next_operand_address;
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_length);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       state_length %u",
+                                operand_address, state_length);
+        }
+        /*
+         * %state_address
+         */
+        operand_address = next_operand_address;
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_address);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       state_address %u",
+                                operand_address, state_address);
+        }
+        /*
+         * %state_instruction
+         */
+        operand_address = next_operand_address;
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_instruction);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       state_instruction %u",
+                                operand_address, state_instruction);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## STATE-ACCESS(31) (partial_identifier_start=%u, partial_identifier_length=%u,state_begin=%u, state_length=%u, state_address=%u, state_instruction=%u)",
+                                current_address, p_id_start, p_id_length, state_begin, state_length, state_address, state_instruction);
+        }
+        current_address = next_operand_address;
+        byte_copy_right = buff[66] << 8;
+        byte_copy_right = byte_copy_right | buff[67];
+        byte_copy_left = buff[64] << 8;
+        byte_copy_left = byte_copy_left | buff[65];
+        if (print_level_2 ) {
+            proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
+                                "               byte_copy_right = %u, byte_copy_left = %u", byte_copy_right,byte_copy_left);
+        }
+
+        result_code = udvm_state_access(message_tvb, udvm_tree, buff, p_id_start, p_id_length, state_begin, &state_length,
+                                        &state_address, &state_instruction, hf_id);
+        if ( result_code != 0 ) {
+            goto decompression_failure;
+        }
+        used_udvm_cycles = used_udvm_cycles + state_length;
+        goto execute_next_instruction;
+        break;
+    case SIGCOMP_INSTR_STATE_CREATE: /* 32 */
+        /*
+         * STATE-CREATE (%state_length, %state_address, %state_instruction,
+         * %minimum_access_length, %state_retention_priority)
+         */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## STATE-CREATE(32) (state_length, state_address, state_instruction,minimum_access_length, state_retention_priority)",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+
+        /*
+         * %state_length
+         */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_length);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       state_length %u",
+                                operand_address, state_length);
+        }
+        /*
+         * %state_address
+         */
+        operand_address = next_operand_address;
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_address);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       state_address %u",
+                                operand_address, state_address);
+        }
+        /*
+         * %state_instruction
+         */
+        operand_address = next_operand_address;
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_instruction);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       state_instruction %u",
+                                operand_address, state_instruction);
+        }
+        /*
+         * %minimum_access_length
+         */
+        operand_address = next_operand_address;
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &minimum_access_length);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       minimum_access_length %u",
+                                operand_address, minimum_access_length);
+        }
+        /*
+         * %state_retention_priority
+         */
+        operand_address = next_operand_address;
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_retention_priority);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       state_retention_priority %u",
+                                operand_address, state_retention_priority);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## STATE-CREATE(32) (state_length=%u, state_address=%u, state_instruction=%u,minimum_access_length=%u, state_retention_priority=%u)",
+                                current_address, state_length, state_address, state_instruction,minimum_access_length, state_retention_priority);
+        }
+        current_address = next_operand_address;
+        /* Execute the instruction
+         * TODO Implement the instruction
+         * RFC3320:
+         *    Note that the new state item cannot be created until a valid
+         *    compartment identifier has been returned by the application.
+         *    Consequently, when a STATE-CREATE instruction is encountered the UDVM
+         *    simply buffers the five supplied operands until the END-MESSAGE
+         *    instruction is reached.  The steps taken at this point are described
+         *    in Section 9.4.9.
+         *
+         *   Decompression failure MUST occur if more than four state creation
+         *   requests are made before the END-MESSAGE instruction is encountered.
+         *   Decompression failure also occurs if the minimum_access_length does
+         *   not lie between 6 and 20 inclusive, or if the
+         *   state_retention_priority is 65535.
+         */
+        no_of_state_create++;
+        if ( no_of_state_create > 4 ) {
+            result_code = 12;
+            goto decompression_failure;
+        }
+        if (( minimum_access_length < 6 ) || ( minimum_access_length > STATE_BUFFER_SIZE )) {
+            result_code = 1;
+            goto decompression_failure;
+        }
+        if ( state_retention_priority == 65535 ) {
+            result_code = 13;
+            goto decompression_failure;
+        }
+        state_length_buff[no_of_state_create] = state_length;
+        state_address_buff[no_of_state_create] = state_address;
+        state_instruction_buff[no_of_state_create] = state_instruction;
+        state_minimum_access_length_buff[no_of_state_create] = minimum_access_length;
+        /* state_state_retention_priority_buff[no_of_state_create] = state_retention_priority; */
+        used_udvm_cycles = used_udvm_cycles + state_length;
+        /* Debug */
+        byte_copy_right = buff[66] << 8;
+        byte_copy_right = byte_copy_right | buff[67];
+        byte_copy_left = buff[64] << 8;
+        byte_copy_left = byte_copy_left | buff[65];
+        n = 0;
+        k = state_address;
+        while ( n < state_length ) {
+            if ( k == byte_copy_right ) {
+                k = byte_copy_left;
+            }
+            string[0]= buff[k];
+            string[1]= '\0';
+            if (print_level_3 ) {
+                proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                    "               Addr: %5u State value: %u (0x%x) ASCII(%s)",
+                                    k,buff[k],buff[k],format_text(string, 1));
+            }
+            k = ( k + 1 ) & 0xffff;
+            n++;
+        }
+        /* End debug */
+
+        goto execute_next_instruction;
+        break;
+    case SIGCOMP_INSTR_STATE_FREE: /* 33 */
+        /*
+         * STATE-FREE (%partial_identifier_start, %partial_identifier_length)
+         */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## STATE-FREE (partial_identifier_start, partial_identifier_length)",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+        /*
+         * %partial_identifier_start
+         */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &p_id_start);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       partial_identifier_start %u",
+                                operand_address, p_id_start);
+        }
+        operand_address = next_operand_address;
 
- /*  The simplest operand type is the literal (#), which encodes a
-  * constant integer from 0 to 65535 inclusive.  A literal operand may
-  * require between 1 and 3 bytes depending on its value.
-  * Bytecode:                       Operand value:      Range:
-  * 0nnnnnnn                        N                   0 - 127
-  * 10nnnnnn nnnnnnnn               N                   0 - 16383
-  * 11000000 nnnnnnnn nnnnnnnn      N                   0 - 65535
-  *
-  *            Figure 8: Bytecode for a literal (#) operand
-  *
-  */
-static int
-decode_udvm_literal_operand(guint8 *buff,guint operand_address, guint16 *value)
-{
-	guint	bytecode;
-	guint16 operand;
-	guint	test_bits;
-	guint	offset = operand_address;
-	guint8	temp_data;
-
-	bytecode = buff[operand_address];
-	test_bits = bytecode >> 7;
-	if (test_bits == 1){
-		test_bits = bytecode >> 6;
-		if (test_bits == 2){
-			/*
-			 * 10nnnnnn nnnnnnnn               N                   0 - 16383
-			 */
-			temp_data = buff[operand_address] & 0x1f;
-			operand = temp_data << 8;
-			temp_data = buff[(operand_address + 1) & 0xffff];
-			operand = operand | temp_data;
-			*value = operand;
-			offset = offset + 2;
-
-		}else{
-			/*
-			 * 111000000 nnnnnnnn nnnnnnnn      N                   0 - 65535
-			 */
-			offset ++;
-			temp_data = buff[operand_address] & 0x1f;
-			operand = temp_data << 8;
-			temp_data = buff[(operand_address + 1) & 0xffff];
-			operand = operand | temp_data;
-			*value = operand;
-			offset = offset + 2;
-
-		}
-	}else{
-		/*
-		 * 0nnnnnnn                        N                   0 - 127
-		 */
-		operand = ( bytecode & 0x7f);
-		*value = operand;
-		offset ++;
-	}
-
-	return offset;
+        /*
+         * %partial_identifier_length
+         */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &p_id_length);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       partial_identifier_length %u",
+                                operand_address, p_id_length);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## STATE-FREE (partial_identifier_start=%u, partial_identifier_length=%u)",
+                                current_address, p_id_start, p_id_length);
+        }
+        current_address = next_operand_address;
 
-}
+        /* Execute the instruction:
+         * TODO implement it
+         */
+        udvm_state_free(buff,p_id_start,p_id_length);
 
-/*
- * The second operand type is the reference ($), which is always used to
- * access a 2-byte value located elsewhere in the UDVM memory.  The
- * bytecode for a reference operand is decoded to be a constant integer
- * from 0 to 65535 inclusive, which is interpreted as the memory address
- * containing the actual value of the operand.
- * Bytecode:                       Operand value:      Range:
- *
- * 0nnnnnnn                        memory[2 * N]       0 - 65535
- * 10nnnnnn nnnnnnnn               memory[2 * N]       0 - 65535
- * 11000000 nnnnnnnn nnnnnnnn      memory[N]           0 - 65535
- *
- *            Figure 9: Bytecode for a reference ($) operand
- */
-static int
-dissect_udvm_reference_operand_memory(guint8 *buff,guint operand_address, guint16 *value,guint *result_dest)
-{
-	guint bytecode;
-	guint16 operand;
-	guint	offset = operand_address;
-	guint test_bits;
-	guint8	temp_data;
-	guint16 temp_data16;
-
-	bytecode = buff[operand_address];
-	test_bits = bytecode >> 7;
-	if (test_bits == 1){
-		test_bits = bytecode >> 6;
-		if (test_bits == 2){
-			/*
-			 * 10nnnnnn nnnnnnnn               memory[2 * N]       0 - 65535
-			 */
-			temp_data = buff[operand_address] & 0x3f;
-			operand = temp_data << 8;
-			temp_data = buff[(operand_address + 1) & 0xffff];
-			operand = operand | temp_data;
-			operand = (operand * 2);
-			*result_dest = operand;
-			temp_data16 = buff[operand] << 8;
-			temp_data16 = temp_data16 | buff[(operand+1) & 0xffff];
-			*value = temp_data16;
-			offset = offset + 2;
-
-		}else{
-			/*
-			 * 11000000 nnnnnnnn nnnnnnnn      memory[N]           0 - 65535
-			 */
-			operand_address++;
-			operand = buff[operand_address] << 8;
-			operand = operand | buff[(operand_address + 1) & 0xffff];
-			*result_dest = operand;
-			temp_data16 = buff[operand] << 8;
-			temp_data16 = temp_data16 | buff[(operand+1) & 0xffff];
-			*value = temp_data16;
-			offset = offset + 3;
-
-		}
-	}else{
-		/*
-		 * 0nnnnnnn                        memory[2 * N]       0 - 65535
-		 */
-		operand = ( bytecode & 0x7f);
-		operand = (operand * 2);
-		*result_dest = operand;
-		temp_data16 = buff[operand] << 8;
-		temp_data16 = temp_data16 | buff[(operand+1) & 0xffff];
-		*value = temp_data16;
-		offset ++;
-	}
-
-	if (offset >= UDVM_MEMORY_SIZE || *result_dest >= UDVM_MEMORY_SIZE - 1 )
-		THROW(ReportedBoundsError);
-
-	return offset;
-}
+        goto execute_next_instruction;
+        break;
+    case SIGCOMP_INSTR_OUTPUT: /* 34 OUTPUT (%output_start, %output_length) */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## OUTPUT(34) (output_start, output_length)",
+                                current_address);
+        }
+        operand_address = current_address + 1;
+        /*
+         * %output_start
+         */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &output_start);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      output_start %u",
+                                operand_address, output_start);
+        }
+        operand_address = next_operand_address;
+        /*
+         * %output_length
+         */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &output_length);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      output_length %u",
+                                operand_address, output_length);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## OUTPUT (output_start=%u, output_length=%u)",
+                                current_address, output_start, output_length);
+        }
+        current_address = next_operand_address;
 
-	/* RFC3320
-	 * Figure 10: Bytecode for a multitype (%) operand
-	 * Bytecode:                       Operand value:      Range:               HEX val
-	 * 00nnnnnn                        N                   0 - 63				0x00
-	 * 01nnnnnn                        memory[2 * N]       0 - 65535			0x40
-	 * 1000011n                        2 ^ (N + 6)        64 , 128				0x86
-	 * 10001nnn                        2 ^ (N + 8)    256 , ... , 32768			0x88
-	 * 111nnnnn                        N + 65504       65504 - 65535			0xe0
-	 * 1001nnnn nnnnnnnn               N + 61440       61440 - 65535			0x90
-	 * 101nnnnn nnnnnnnn               N                   0 - 8191				0xa0
-	 * 110nnnnn nnnnnnnn               memory[N]           0 - 65535			0xc0
-	 * 10000000 nnnnnnnn nnnnnnnn      N                   0 - 65535			0x80
-	 * 10000001 nnnnnnnn nnnnnnnn      memory[N]           0 - 65535			0x81
-	 */
-static int
-decode_udvm_multitype_operand(guint8 *buff,guint operand_address, guint16 *value)
-{
-	guint test_bits;
-	guint bytecode;
-	guint offset = operand_address;
-	guint16 operand;
-	guint32 result;
-	guint8 temp_data;
-	guint16 temp_data16;
-	guint16 memmory_addr = 0;
-
-	*value = 0;
-
-	bytecode = buff[operand_address];
-	test_bits = ( bytecode & 0xc0 ) >> 6;
-	switch (test_bits ){
-	case 0:
-		/*
-		 * 00nnnnnn                        N                   0 - 63
-		 */
-		operand =  buff[operand_address];
-		/* debug
-		 *g_warning("Reading 0x%x From address %u",operand,offset);
-		 */
-		*value = operand;
-		offset ++;
-		break;
-	case 1:
-		/*
-		 * 01nnnnnn                        memory[2 * N]       0 - 65535
-		 */
-		memmory_addr = ( bytecode & 0x3f) * 2;
-		temp_data16 = buff[memmory_addr] << 8;
-		temp_data16 = temp_data16 | buff[(memmory_addr+1) & 0xffff];
-		*value = temp_data16;
-		offset ++;
-		break;
-	case 2:
-		/* Check tree most significant bits */
-		test_bits = ( bytecode & 0xe0 ) >> 5;
-		if ( test_bits == 5 ){
-		/*
-		 * 101nnnnn nnnnnnnn               N                   0 - 8191
-		 */
-			temp_data = buff[operand_address] & 0x1f;
-			operand = temp_data << 8;
-			temp_data = buff[(operand_address + 1) & 0xffff];
-			operand = operand | temp_data;
-			*value = operand;
-			offset = offset + 2;
-		}else{
-			test_bits = ( bytecode & 0xf0 ) >> 4;
-			if ( test_bits == 9 ){
-		/*
-		 * 1001nnnn nnnnnnnn               N + 61440       61440 - 65535
-		 */
-				temp_data = buff[operand_address] & 0x0f;
-				operand = temp_data << 8;
-				temp_data = buff[(operand_address + 1) & 0xffff];
-				operand = operand | temp_data;
-				operand = operand + 61440;
-				*value = operand;
-				offset = offset + 2;
-			}else{
-				test_bits = ( bytecode & 0x08 ) >> 3;
-				if ( test_bits == 1){
-		/*
-		 * 10001nnn                        2 ^ (N + 8)    256 , ... , 32768
-		 */
-
-					result = 1 << ((buff[operand_address] & 0x07) + 8);
-					operand = result & 0xffff;
-					*value = operand;
-					offset ++;
-				}else{
-					test_bits = ( bytecode & 0x0e ) >> 1;
-					if ( test_bits == 3 ){
-						/*
-						 * 1000 011n                        2 ^ (N + 6)        64 , 128
-						 */
-						result = 1 << ((buff[operand_address] & 0x01) + 6);
-						operand = result & 0xffff;
-						*value = operand;
-						offset ++;
-					}else{
-					/*
-					 * 1000 0000 nnnnnnnn nnnnnnnn      N                   0 - 65535
-					 * 1000 0001 nnnnnnnn nnnnnnnn      memory[N]           0 - 65535
-					 */
-						offset ++;
-						temp_data16 = buff[(operand_address + 1) & 0xffff] << 8;
-						temp_data16 = temp_data16 | buff[(operand_address + 2) & 0xffff];
-						/*  debug
-						 * g_warning("Reading 0x%x From address %u",temp_data16,operand_address);
-						 */
-						if ( (bytecode & 0x01) == 1 ){
-							memmory_addr = temp_data16;
-							temp_data16 = buff[memmory_addr] << 8;
-							temp_data16 = temp_data16 | buff[(memmory_addr+1) & 0xffff];
-						}
-						*value = temp_data16;
-						offset = offset +2;
-					}
-
-
-				}
-			}
-		}
-		break;
-
-	case 3:
-		test_bits = ( bytecode & 0x20 ) >> 5;
-		if ( test_bits == 1 ){
-		/*
-		 * 111nnnnn                        N + 65504       65504 - 65535
-		 */
-			operand = ( buff[operand_address] & 0x1f) + 65504;
-			*value = operand;
-			offset ++;
-		}else{
-		/*
-		 * 110nnnnn nnnnnnnn               memory[N]           0 - 65535
-		 */
-			memmory_addr = buff[operand_address] & 0x1f;
-			memmory_addr = memmory_addr << 8;
-			memmory_addr = memmory_addr | buff[(operand_address + 1) & 0xffff];
-			temp_data16 = buff[memmory_addr] << 8;
-			temp_data16 = temp_data16 | buff[(memmory_addr+1) & 0xffff];
-			*value = temp_data16;
-			/*  debug
-			 * g_warning("Reading 0x%x From address %u",temp_data16,memmory_addr);
-			 */
-			offset = offset +2;
-		}
-
-	default :
-		break;
-	}
-	return offset;
-}
-	/*
-	 *
-	 * The fourth operand type is the address (@).  This operand is decoded
-	 * as a multitype operand followed by a further step: the memory address
-	 * of the UDVM instruction containing the address operand is added to
-	 * obtain the correct operand value.  So if the operand value from
-	 * Figure 10 is D then the actual operand value of an address is
-	 * calculated as follows:
-	 *
-	 * operand_value = (memory_address_of_instruction + D) modulo 2^16
-	 *
-	 * Address operands are always used in instructions that control program
-	 * flow, because they ensure that the UDVM bytecode is position-
-	 * independent code (i.e., it will run independently of where it is
-	 * placed in the UDVM memory).
-	 */
-static int
-decode_udvm_address_operand(guint8 *buff,guint operand_address, guint16 *value,guint current_address)
-{
-	guint32 result;
-	guint16 value1;
-	guint next_opreand_address;
-
-	next_opreand_address = decode_udvm_multitype_operand(buff, operand_address, &value1);
-	result = value1 & 0xffff;
-	result = result + current_address;
-	*value = result & 0xffff;
-	return next_opreand_address;
-}
+        /*
+         * Execute instruction
+         * 8.4.  Byte copying
+         * :
+         * The string of bytes is copied in ascending order of memory address,
+         * respecting the bounds set by byte_copy_left and byte_copy_right.
+         * More precisely, if a byte is copied from/to Address m then the next
+         * byte is copied from/to Address n where n is calculated as follows:
+         *
+         * Set k := m + 1 (modulo 2^16)
+         * If k = byte_copy_right then set n := byte_copy_left, else set n := k
+         *
+         */
 
+        n = 0;
+        k = output_start;
+        byte_copy_right = buff[66] << 8;
+        byte_copy_right = byte_copy_right | buff[67];
+        byte_copy_left = buff[64] << 8;
+        byte_copy_left = byte_copy_left | buff[65];
+        if (print_level_3 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "               byte_copy_right = %u", byte_copy_right);
+        }
+        while ( n < output_length ) {
 
-/*
- * This is a lookup table used to reverse the bits in a byte.
- */
-static guint8 reverse [] = {
-    0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
-    0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
-    0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
-    0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
-    0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
-    0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
-    0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
-    0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
-    0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
-    0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
-    0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
-    0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
-    0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
-    0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
-    0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
-    0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
-    0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
-    0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
-    0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
-    0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
-    0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
-    0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
-    0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
-    0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
-    0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
-    0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
-    0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
-    0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
-    0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
-    0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
-    0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
-    0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
-};
+            if ( k == byte_copy_right ) {
+                k = byte_copy_left;
+            }
+            out_buff[output_address] = buff[k];
+            string[0]= buff[k];
+            string[1]= '\0';
+            if (print_level_3 ) {
+                proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                    "               Output value: %u (0x%x) ASCII(%s) from Addr: %u ,output to dispatcher position %u",
+                                    buff[k],buff[k],format_text(string,1), k,output_address);
+            }
+            k = ( k + 1 ) & 0xffff;
+            output_address ++;
+            n++;
+        }
+        used_udvm_cycles = used_udvm_cycles + output_length;
+        goto execute_next_instruction;
+        break;
+    case SIGCOMP_INSTR_END_MESSAGE: /* 35 */
+        /*
+         * END-MESSAGE (%requested_feedback_location,
+         * %returned_parameters_location, %state_length, %state_address,
+         * %state_instruction, %minimum_access_length,
+         * %state_retention_priority)
+         */
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## END-MESSAGE (requested_feedback_location,state_instruction, minimum_access_length,state_retention_priority)",
+                                current_address);
+        }
+        operand_address = current_address + 1;
 
+        /* %requested_feedback_location */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &requested_feedback_location);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      requested_feedback_location %u",
+                                operand_address, requested_feedback_location);
+        }
+        operand_address = next_operand_address;
+        /* returned_parameters_location */
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &returned_parameters_location);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      returned_parameters_location %u",
+                                operand_address, returned_parameters_location);
+        }
+        /*
+         * %state_length
+         */
+        operand_address = next_operand_address;
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_length);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      state_length %u",
+                                operand_address, state_length);
+        }
+        /*
+         * %state_address
+         */
+        operand_address = next_operand_address;
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_address);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      state_address %u",
+                                operand_address, state_address);
+        }
+        /*
+         * %state_instruction
+         */
+        operand_address = next_operand_address;
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_instruction);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      state_instruction %u",
+                                operand_address, state_instruction);
+        }
 
-static int
-decomp_dispatch_get_bits(
-		tvbuff_t *message_tvb,
-		proto_tree *udvm_tree,
-		guint8 bit_order,
-		guint8 *buff,
-		guint16 *old_input_bit_order,
-		guint16 *remaining_bits,
-		guint16	*input_bits,
-		guint *input_address,
-		guint16 length,
-		guint16 *result_code,
-		guint msg_end)
-{
-	guint16 input_bit_order;
-	guint16 bits_still_required = length;
-	guint16 value = 0;
-	guint8  octet;
-	gint    extra_bytes_available = msg_end - *input_address;
-	gint    p_bit;
-	gint    prev_p_bit = *old_input_bit_order & 0x0001;
-	gint    bits_to_use = 0;
-
-
-	input_bit_order = buff[68] << 8;
-	input_bit_order = input_bit_order | buff[69];
-	*result_code = 0;
-	p_bit = (input_bit_order & 0x0001) != 0;
-
-	/*
-	 * Discard any spare bits.
-	 * Note: We take care to avoid remaining_bits having the value of 8.
-	 */
-	if (prev_p_bit != p_bit)
-	{
-		*remaining_bits = 0;
-		*old_input_bit_order = input_bit_order;
-	}
-
-	/*
-	 * Check we can suppy the required number of bits now, before we alter
-	 * the input buffer's state.
-	 */
-	if (*remaining_bits + extra_bytes_available * 8 < length)
-	{
-		*result_code = 11;
-		return 0xfbad;
-	}
-
-	/* Note: This is never called with length > 16, so the following loop
-	*       never loops more than three time. */
-	while (bits_still_required > 0)
-	{
-		/*
-		 * We only put anything into input_bits if we know we will remove
-		 * at least one bit. That ensures we can simply discard the spare
-		 * bits if the P-bit changes.
-		 */
-		if (*remaining_bits == 0)
-		{
-			octet = tvb_get_guint8(message_tvb, *input_address);
-			if (print_level_1 ){
-				proto_tree_add_text(udvm_tree, message_tvb, *input_address , 1,
-						"               Getting value: %u (0x%x) From Addr: %u", octet, octet, *input_address);
-			}
-			*input_address = *input_address + 1;
-
-			if (p_bit != 0)
-			{
-				octet = reverse[octet];
-			}
-			*input_bits = octet;
-			*remaining_bits = 8;
-		}
-
-		/* Add some more bits to the accumulated value. */
-		bits_to_use = bits_still_required < *remaining_bits ? bits_still_required : *remaining_bits;
-		bits_still_required -= bits_to_use;
-
-		*input_bits <<= bits_to_use;           /* Shift bits into MSByte */
-		value = (value << bits_to_use)         /* Then add to the accumulated value */
-			| ((*input_bits >> 8) & 0xFF);
-		*remaining_bits -= bits_to_use;
-		*input_bits &= 0x00FF;                 /* Leave just the remaining bits */
-	}
-
-	if (bit_order != 0)
-	{
-		/* Bit reverse the entire word. */
-		guint16 lsb = reverse[(value >> 8) & 0xFF];
-		guint16 msb = reverse[value & 0xFF];
-
-		value = ((msb << 8) | lsb) >> (16 - length);
-	}
-
-	return value;
-}
+        /*
+         * %minimum_access_length
+         */
+        operand_address = next_operand_address;
+        next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &minimum_access_length);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      minimum_access_length %u",
+                                operand_address, minimum_access_length);
+        }
 
-static tvbuff_t*
-decompress_sigcomp_message(tvbuff_t *bytecode_tvb, tvbuff_t *message_tvb, packet_info *pinfo,
-						   proto_tree *udvm_tree, gint udvm_mem_dest,
-						   gint print_flags, gint hf_id,
-						   gint header_len,
-						   gint byte_code_state_len, gint byte_code_id_len,
-						   gint udvm_start_ip)
-{
-	tvbuff_t	*decomp_tvb;
-	/* UDVM memory must be initialised to zero */
-	guint8		*buff = (guint8 *)wmem_alloc0(wmem_packet_scope(), UDVM_MEMORY_SIZE);
-	char		string[2];
-	guint8		*out_buff;		/* Largest allowed size for a message is UDVM_MEMORY_SIZE = 65536 */
-	guint32		i = 0;
-	guint16		n = 0;
-	guint16		m = 0;
-	guint16		x;
-	guint		k = 0;
-	guint16		H;
-	guint16		oldH;
-	guint		offset = 0;
-	guint		result_dest;
-	guint		code_length =0;
-	guint8		current_instruction;
-	guint		current_address;
-	guint		operand_address;
-	guint		input_address;
-	guint16		output_address = 0;
-	guint		next_operand_address;
-	guint8		octet;
-	guint8		msb;
-	guint8		lsb;
-	guint16		byte_copy_right;
-	guint16		byte_copy_left;
-	guint16		input_bit_order;
-	guint16		stack_location;
-	guint16		stack_fill;
-	guint16		result;
-	guint 		msg_end = tvb_reported_length_remaining(message_tvb, 0);
-	guint16		result_code = 0;
-	guint16		old_input_bit_order = 0;
-	guint16		remaining_bits = 0;
-	guint16		input_bits = 0;
-	guint8		bit_order = 0;
-	gboolean	outside_huffman_boundaries = TRUE;
-	gboolean	print_in_loop = FALSE;
-	guint16		instruction_address;
-	guint8		no_of_state_create = 0;
-	guint16		state_length_buff[5];
-	guint16		state_address_buff[5];
-	guint16		state_instruction_buff[5];
-	guint16		state_minimum_access_length_buff[5];
-	/* guint16		state_state_retention_priority_buff[5]; */
-	guint32		used_udvm_cycles = 0;
-	guint		cycles_per_bit;
-	guint		maximum_UDVM_cycles;
-	guint8		*sha1buff;
-	unsigned char sha1_digest_buf[STATE_BUFFER_SIZE];
-	sha1_context ctx;
-
-
-	/* UDVM operand variables */
-	guint16 length;
-	guint16 at_address;
-	guint16 destination;
-	guint16 addr;
-	guint16 value;
-	guint16 p_id_start;
-	guint16 p_id_length;
-	guint16 state_begin;
-	guint16 state_length;
-	guint16 state_address;
-	guint16 state_instruction;
-	guint16 operand_1;
-	guint16 operand_2;
-	guint16 value_1;
-	guint16 value_2;
-	guint16 at_address_1;
-	guint16 at_address_2;
-	guint16 at_address_3;
-	guint16 j;
-	guint16 bits_n;
-	guint16 lower_bound_n;
-	guint16 upper_bound_n;
-	guint16 uncompressed_n;
-	guint16 position;
-	guint16 ref_destination; /* could I have used $destination ? */
-	guint16 multy_offset;
-	guint16 output_start;
-	guint16 output_length;
-	guint16 minimum_access_length;
-	guint16 state_retention_priority;
-	guint16 requested_feedback_location;
-	guint16 returned_parameters_location;
-	guint16 start_value;
-
-
-	/* Set print parameters */
-	print_level_1 = FALSE;
-	print_level_2 = FALSE;
-	print_level_3 = FALSE;
-	show_instr_detail_level = 0;
-
-
-
-	switch( print_flags ) {
-		case 0:
-			break;
-
-		case 1:
-			print_level_1 = TRUE;
-			show_instr_detail_level = 1;
-			break;
-		case 2:
-			print_level_1 = TRUE;
-			print_level_2 = TRUE;
-			show_instr_detail_level = 1;
-			break;
-		case 3:
-			print_level_1 = TRUE;
-			print_level_2 = TRUE;
-			print_level_3 = TRUE;
-			show_instr_detail_level = 2;
-			break;
-		default:
-			print_level_1 = TRUE;
-			show_instr_detail_level = 1;
-			break;
-	}
-
-	/* Set initial UDVM data
-	 *  The first 32 bytes of UDVM memory are then initialized to special
-	 *  values as illustrated in Figure 5.
-	 *
-	 *                      0             7 8            15
-	 *                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-	 *                     |       UDVM_memory_size        |  0 - 1
-	 *                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-	 *                     |        cycles_per_bit         |  2 - 3
-	 *                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-	 *                     |        SigComp_version        |  4 - 5
-	 *                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-	 *                     |    partial_state_ID_length    |  6 - 7
-	 *                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-	 *                     |         state_length          |  8 - 9
-	 *                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-	 *                     |                               |
-	 *                     :           reserved            :  10 - 31
-	 *                     |                               |
-	 *                     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-	 *
-	 *            Figure 5: Initializing Useful Values in UDVM memory
-	 */
-	/* UDVM_memory_size  */
-	buff[0] = (UDVM_MEMORY_SIZE >> 8) & 0x00FF;
-	buff[1] = UDVM_MEMORY_SIZE & 0x00FF;
-	/* cycles_per_bit */
-	buff[2] = 0;
-	buff[3] = 16;
-	/* SigComp_version */
-	buff[4] = 0;
-	buff[5] = 1;
-	/* partial_state_ID_length */
-	buff[6] = (byte_code_id_len >> 8) & 0x00FF;
-	buff[7] = byte_code_id_len & 0x00FF;
-	/* state_length  */
-	buff[8] = (byte_code_state_len >> 8) & 0x00FF;
-	buff[9] = byte_code_state_len & 0x00FF;
-
-	code_length = tvb_reported_length_remaining(bytecode_tvb, 0);
-
-	cycles_per_bit = buff[2] << 8;
-	cycles_per_bit = cycles_per_bit | buff[3];
-	/*
-	 * maximum_UDVM_cycles = (8 * n + 1000) * cycles_per_bit
-	 */
-	maximum_UDVM_cycles = (( 8 * (header_len + msg_end) ) + 1000) * cycles_per_bit;
-
-	proto_tree_add_text(udvm_tree, bytecode_tvb, offset, 1,"maximum_UDVM_cycles(%u) = (( 8 * msg_end(%u) ) + 1000) * cycles_per_bit(%u)",maximum_UDVM_cycles,msg_end,cycles_per_bit);
-	proto_tree_add_text(udvm_tree, bytecode_tvb, offset, 1,"Message Length: %u,Byte code length: %u, Maximum UDVM cycles: %u",msg_end,code_length,maximum_UDVM_cycles);
-
-	/* Load bytecode into UDVM starting at "udvm_mem_dest" */
-	i = udvm_mem_dest;
-	if ( print_level_3 )
-		proto_tree_add_text(udvm_tree, bytecode_tvb, offset, 1,"Load bytecode into UDVM starting at %u",i);
-	while ( code_length > offset && i < UDVM_MEMORY_SIZE ) {
-		buff[i] = tvb_get_guint8(bytecode_tvb, offset);
-		if ( print_level_3 )
-			proto_tree_add_text(udvm_tree, bytecode_tvb, offset, 1,
-						"              Addr: %u Instruction code(0x%0x) ", i, buff[i]);
-
-		i++;
-		offset++;
-
-	}
-	/* Start executing code */
-	current_address = udvm_start_ip;
-	input_address = 0;
-
-	proto_tree_add_text(udvm_tree, bytecode_tvb, offset, 1,"UDVM EXECUTION STARTED at Address: %u Message size %u",
-		current_address, msg_end);
-
-	/* Largest allowed size for a message is UDVM_MEMORY_SIZE = 65536  */
-	out_buff = (guint8 *)g_malloc(UDVM_MEMORY_SIZE);
+        /*
+         * %state_retention_priority
+         */
+        operand_address = next_operand_address;
+        /*next_operand_address =*/ decode_udvm_multitype_operand(buff, operand_address, &state_retention_priority);
+        if (show_instr_detail_level == 2 ) {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      state_retention_priority %u",
+                                operand_address, state_retention_priority);
+        }
+        if (show_instr_detail_level == 1)
+        {
+            proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
+                                "Addr: %u ## END-MESSAGE (requested_feedback_location=%u, returned_parameters_location=%u, state_length=%u, state_address=%u, state_instruction=%u, minimum_access_length=%u, state_retention_priority=%u)",
+                                current_address, requested_feedback_location, returned_parameters_location, state_length, state_address, state_instruction, minimum_access_length,state_retention_priority);
+        }
+        /* TODO: This isn't currently totaly correct as END_INSTRUCTION might not create state */
+        no_of_state_create++;
+        if ( no_of_state_create > 4 ) {
+            result_code = 12;
+            goto decompression_failure;
+        }
+        state_length_buff[no_of_state_create] = state_length;
+        state_address_buff[no_of_state_create] = state_address;
+        state_instruction_buff[no_of_state_create] = state_instruction;
+        /* Not used ? */
+        state_minimum_access_length_buff[no_of_state_create] = minimum_access_length;
+        /* state_state_retention_priority_buff[no_of_state_create] = state_retention_priority; */
+
+        /* Execute the instruction
+         */
+        proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"no_of_state_create %u",no_of_state_create);
+        if ( no_of_state_create != 0 ) {
+            memset(sha1_digest_buf, 0, STATE_BUFFER_SIZE);
+            n = 1;
+            byte_copy_right = buff[66] << 8;
+            byte_copy_right = byte_copy_right | buff[67];
+            byte_copy_left = buff[64] << 8;
+            byte_copy_left = byte_copy_left | buff[65];
+            while ( n < no_of_state_create + 1 ) {
+                sha1buff = (guint8 *)g_malloc(state_length_buff[n]+8);
+                sha1buff[0] = state_length_buff[n] >> 8;
+                sha1buff[1] = state_length_buff[n] & 0xff;
+                sha1buff[2] = state_address_buff[n] >> 8;
+                sha1buff[3] = state_address_buff[n] & 0xff;
+                sha1buff[4] = state_instruction_buff[n] >> 8;
+                sha1buff[5] = state_instruction_buff[n] & 0xff;
+                sha1buff[6] = state_minimum_access_length_buff[n] >> 8;
+                sha1buff[7] = state_minimum_access_length_buff[n] & 0xff;
+                if (print_level_3 ) {
+                    for ( x=0; x < 8; x++) {
+                        proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"sha1buff %u 0x%x",
+                                            x,sha1buff[x]);
+                    }
+                }
+                k = state_address_buff[n];
+                for ( x=0; x < state_length_buff[n]; x++)
+                {
+                    if ( k == byte_copy_right ) {
+                        k = byte_copy_left;
+                    }
+                    sha1buff[8+x] = buff[k];
+                    k = ( k + 1 ) & 0xffff;
+                }
 
-execute_next_instruction:
+                sha1_starts( &ctx );
+                sha1_update( &ctx, (guint8 *) sha1buff, state_length_buff[n] + 8);
+                sha1_finish( &ctx, sha1_digest_buf );
+                if (print_level_3 ) {
+                    proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"SHA1 digest %s", bytes_to_str(wmem_packet_scope(), sha1_digest_buf, STATE_BUFFER_SIZE));
 
-	if ( used_udvm_cycles > maximum_UDVM_cycles ){
-		result_code = 15;
-		goto decompression_failure;
-	}
-	used_udvm_cycles++;
-	current_instruction = buff[current_address & 0xffff];
-
-	switch ( current_instruction ) {
-	case SIGCOMP_INSTR_DECOMPRESSION_FAILURE:
-		if ( result_code == 0 )
-			result_code = 9;
-		proto_tree_add_text(udvm_tree, NULL, 0, 0,
-			"Addr: %u ## DECOMPRESSION-FAILURE(0)",
-			current_address);
-		proto_tree_add_text(udvm_tree, NULL, 0, 0,"Wireshark UDVM diagnostic: %s.",
-				    val_to_str(result_code, result_code_vals,"Unknown (%u)"));
-		if ( output_address > 0 ){
-			/* At least something got decompressed, show it */
-			decomp_tvb = tvb_new_child_real_data(message_tvb, out_buff,output_address,output_address);
-			/* Arrange that the allocated packet data copy be freed when the
-			 * tvbuff is freed.
-			 */
-			tvb_set_free_cb( decomp_tvb, g_free );
-			/* Add the tvbuff to the list of tvbuffs to which the tvbuff we
-			 * were handed refers, so it'll get cleaned up when that tvbuff
-			 * is cleaned up.
-			 */
-			add_new_data_source(pinfo, decomp_tvb, "Decompressed SigComp message(Incomplete)");
-			proto_tree_add_text(udvm_tree, decomp_tvb, 0, -1,"SigComp message Decompression failure");
-		return decomp_tvb;
-		}
-		g_free(out_buff);
-		return NULL;
-		break;
-
-	case SIGCOMP_INSTR_AND: /* 1 AND ($operand_1, %operand_2) */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## AND(1) (operand_1, operand_2)",
-				current_address);
-		}
-		/* $operand_1*/
-		operand_address = current_address + 1;
-		next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
-				operand_address, operand_1);
-		}
-		operand_address = next_operand_address;
-		/* %operand_2*/
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_2 %u",
-				operand_address, operand_2);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## AND (operand_1=%u, operand_2=%u)",
-				current_address, operand_1, operand_2);
-		}
-		/* execute the instruction */
-		result = operand_1 & operand_2;
-		lsb = result & 0xff;
-		msb = result >> 8;
-		buff[result_dest] = msb;
-		buff[(result_dest+1) & 0xffff] = lsb;
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"     Loading result %u at %u",
-				result, result_dest);
-		}
-		current_address = next_operand_address;
-		goto execute_next_instruction;
-
-		break;
-
-	case SIGCOMP_INSTR_OR: /* 2 OR ($operand_1, %operand_2) */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## OR(2) (operand_1, operand_2)",
-				current_address);
-		}
-		/* $operand_1*/
-		operand_address = current_address + 1;
-		next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
-				operand_address, operand_1);
-		}
-		operand_address = next_operand_address;
-		/* %operand_2*/
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_2 %u",
-				operand_address, operand_2);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## OR (operand_1=%u, operand_2=%u)",
-				current_address, operand_1, operand_2);
-		}
-		/* execute the instruction */
-		result = operand_1 | operand_2;
-		lsb = result & 0xff;
-		msb = result >> 8;
-		buff[result_dest] = msb;
-		buff[(result_dest+1) & 0xffff] = lsb;
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"     Loading result %u at %u",
-				result, result_dest);
-		}
-		current_address = next_operand_address;
-		goto execute_next_instruction;
-
-		break;
-
-	case SIGCOMP_INSTR_NOT: /* 3 NOT ($operand_1) */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## NOT(3) ($operand_1)",
-				current_address);
-		}
-		/* $operand_1*/
-		operand_address = current_address + 1;
-		next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
-				operand_address, operand_1);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## NOT (operand_1=%u)",
-				current_address, operand_1);
-		}
-		/* execute the instruction */
-		result = operand_1 ^ 0xffff;
-		lsb = result & 0xff;
-		msb = result >> 8;
-		buff[result_dest] = msb;
-		buff[(result_dest+1) & 0xffff] = lsb;
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"     Loading result %u at %u",
-				result, result_dest);
-		}
-		current_address = next_operand_address;
-		goto execute_next_instruction;
-		break;
-
-	case SIGCOMP_INSTR_LSHIFT: /* 4 LSHIFT ($operand_1, %operand_2) */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## LSHIFT(4) ($operand_1, operand_2)",
-				current_address);
-		}
-		/* $operand_1*/
-		operand_address = current_address + 1;
-		next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
-				operand_address, operand_1);
-		}
-		operand_address = next_operand_address;
-		/* %operand_2*/
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_2 %u",
-				operand_address, operand_2);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## LSHIFT (operand_1=%u, operand_2=%u)",
-				current_address, operand_1, operand_2);
-		}
-		/* execute the instruction */
-		result = operand_1 << operand_2;
-		lsb = result & 0xff;
-		msb = result >> 8;
-		buff[result_dest] = msb;
-		buff[(result_dest+1) & 0xffff] = lsb;
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"     Loading result %u at %u",
-				result, result_dest);
-		}
-		current_address = next_operand_address;
-		goto execute_next_instruction;
-
-		break;
-	case SIGCOMP_INSTR_RSHIFT: /* 5 RSHIFT ($operand_1, %operand_2) */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## RSHIFT(5) (operand_1, operand_2)",
-				current_address);
-		}
-		/* $operand_1*/
-		operand_address = current_address + 1;
-		next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
-				operand_address, operand_1);
-		}
-		operand_address = next_operand_address;
-		/* %operand_2*/
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_2 %u",
-				operand_address, operand_2);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## RSHIFT (operand_1=%u, operand_2=%u)",
-				current_address, operand_1, operand_2);
-		}
-		/* execute the instruction */
-		result = operand_1 >> operand_2;
-		lsb = result & 0xff;
-		msb = result >> 8;
-		buff[result_dest] = msb;
-		buff[(result_dest+1) & 0xffff] = lsb;
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"     Loading result %u at %u",
-				result, result_dest);
-		}
-		current_address = next_operand_address;
-		goto execute_next_instruction;
-		break;
-	case SIGCOMP_INSTR_ADD: /* 6 ADD ($operand_1, %operand_2) */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## ADD(6) (operand_1, operand_2)",
-				current_address);
-		}
-		/* $operand_1*/
-		operand_address = current_address + 1;
-		next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
-				operand_address, operand_1);
-		}
-		operand_address = next_operand_address;
-		/* %operand_2*/
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_2 %u",
-				operand_address, operand_2);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## ADD (operand_1=%u, operand_2=%u)",
-				current_address, operand_1, operand_2);
-		}
-		/* execute the instruction */
-		result = operand_1 + operand_2;
-		lsb = result & 0xff;
-		msb = result >> 8;
-		buff[result_dest] = msb;
-		buff[(result_dest+1) & 0xffff] = lsb;
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"               Loading result %u at %u",
-				result, result_dest);
-		}
-		current_address = next_operand_address;
-		goto execute_next_instruction;
-
-	case SIGCOMP_INSTR_SUBTRACT: /* 7 SUBTRACT ($operand_1, %operand_2) */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## SUBTRACT(7) (operand_1, operand_2)",
-				current_address);
-		}
-		/* $operand_1*/
-		operand_address = current_address + 1;
-		next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
-				operand_address, operand_1);
-		}
-		operand_address = next_operand_address;
-		/* %operand_2*/
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_2 %u",
-				operand_address, operand_2);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## SUBTRACT (operand_1=%u, operand_2=%u)",
-				current_address, operand_1, operand_2);
-		}
-		/* execute the instruction */
-		result = operand_1 - operand_2;
-		lsb = result & 0xff;
-		msb = result >> 8;
-		buff[result_dest] = msb;
-		buff[(result_dest+1) & 0xffff] = lsb;
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"               Loading result %u at %u",
-				result, result_dest);
-		}
-		current_address = next_operand_address;
-		goto execute_next_instruction;
-		break;
-
-	case SIGCOMP_INSTR_MULTIPLY: /* 8 MULTIPLY ($operand_1, %operand_2) */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ##MULTIPLY(8) (operand_1, operand_2)",
-				current_address);
-		}
-		/* $operand_1*/
-		operand_address = current_address + 1;
-		next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
-				operand_address, operand_1);
-		}
-		operand_address = next_operand_address;
-		/* %operand_2*/
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_2 %u",
-				operand_address, operand_2);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## MULTIPLY (operand_1=%u, operand_2=%u)",
-				current_address, operand_1, operand_2);
-		}
-		/*
-		 * execute the instruction
-		 * MULTIPLY (m, n)  := m * n (modulo 2^16)
-		 */
-		if ( operand_2 == 0){
-			result_code = 4;
-			goto decompression_failure;
-		}
-		result = operand_1 * operand_2;
-		lsb = result & 0xff;
-		msb = result >> 8;
-		buff[result_dest] = msb;
-		buff[(result_dest+1) & 0xffff] = lsb;
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"     Loading result %u at %u",
-				result, result_dest);
-		}
-		current_address = next_operand_address;
-		goto execute_next_instruction;
-		break;
-
-	case SIGCOMP_INSTR_DIVIDE: /* 9 DIVIDE ($operand_1, %operand_2) */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## DIVIDE(9) (operand_1, operand_2)",
-				current_address);
-		}
-		/* $operand_1*/
-		operand_address = current_address + 1;
-		next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
-				operand_address, operand_1);
-		}
-		operand_address = next_operand_address;
-		/* %operand_2*/
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_2 %u",
-				operand_address, operand_2);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## DIVIDE (operand_1=%u, operand_2=%u)",
-				current_address, operand_1, operand_2);
-		}
-		/*
-		 * execute the instruction
-		 * DIVIDE (m, n)    := floor(m / n)
-		 * Decompression failure occurs if a DIVIDE or REMAINDER instruction
-		 * encounters an operand_2 that is zero.
-		 */
-		if ( operand_2 == 0){
-			result_code = 4;
-			goto decompression_failure;
-		}
-		result = operand_1 / operand_2;
-		lsb = result & 0xff;
-		msb = result >> 8;
-		buff[result_dest] = msb;
-		buff[(result_dest+1) & 0xffff] = lsb;
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"     Loading result %u at %u",
-				result, result_dest);
-		}
-		current_address = next_operand_address;
-		goto execute_next_instruction;
-		break;
-
-	case SIGCOMP_INSTR_REMAINDER: /* 10 REMAINDER ($operand_1, %operand_2) */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## REMAINDER(10) (operand_1, operand_2)",
-				current_address);
-		}
-		/* $operand_1*/
-		operand_address = current_address + 1;
-		next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_1 %u",
-				operand_address, operand_1);
-		}
-		operand_address = next_operand_address;
-		/* %operand_2*/
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      operand_2 %u",
-				operand_address, operand_2);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## REMAINDER (operand_1=%u, operand_2=%u)",
-				current_address, operand_1, operand_2);
-		}
-		/*
-		 * execute the instruction
-		 * REMAINDER (m, n) := m - n * floor(m / n)
-		 * Decompression failure occurs if a DIVIDE or REMAINDER instruction
-		 * encounters an operand_2 that is zero.
-		 */
-		if ( operand_2 == 0){
-			result_code = 4;
-			goto decompression_failure;
-		}
-		result = operand_1 - operand_2 * (operand_1 / operand_2);
-		lsb = result & 0xff;
-		msb = result >> 8;
-		buff[result_dest] = msb;
-		buff[(result_dest+1) & 0xffff] = lsb;
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"     Loading result %u at %u",
-				result, result_dest);
-		}
-		current_address = next_operand_address;
-		goto execute_next_instruction;
-		break;
-	case SIGCOMP_INSTR_SORT_ASCENDING: /* 11 SORT-ASCENDING (%start, %n, %k) */
-		/*
-		 * 	used_udvm_cycles =  1 + k * (ceiling(log2(k)) + n)
-		 */
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## SORT-ASCENDING(11) (start, n, k))",
-				current_address);
-		}
-		proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Execution of this instruction is NOT implemented");
-		/*
-		 * 	used_udvm_cycles =  1 + k * (ceiling(log2(k)) + n)
-		 */
-		break;
-
-	case SIGCOMP_INSTR_SORT_DESCENDING: /* 12 SORT-DESCENDING (%start, %n, %k) */
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## SORT-DESCENDING(12) (start, n, k))",
-				current_address);
-		}
-		proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Execution of this instruction is NOT implemented");
-		/*
-		 * 	used_udvm_cycles =  1 + k * (ceiling(log2(k)) + n)
-		 */
-		break;
-	case SIGCOMP_INSTR_SHA_1: /* 13 SHA-1 (%position, %length, %destination) */
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## SHA-1(13) (position, length, destination)",
-				current_address);
-		}
-		operand_address = current_address + 1;
-		/* %position */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &position);
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      position %u",
-				operand_address, position);
-		}
-		operand_address = next_operand_address;
-
-		/* %length */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Length %u",
-				operand_address, length);
-		}
-		operand_address = next_operand_address;
-
-		/* $destination */
-		next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &ref_destination, &result_dest);
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      $destination %u",
-				operand_address, ref_destination);
-		}
-		used_udvm_cycles = used_udvm_cycles + length;
-
-		n = 0;
-		k = position;
-		byte_copy_right = buff[66] << 8;
-		byte_copy_right = byte_copy_right | buff[67];
-		byte_copy_left = buff[64] << 8;
-		byte_copy_left = byte_copy_left | buff[65];
-
-		if (print_level_2 ){
-			proto_tree_add_text(udvm_tree, message_tvb, 0, -1,
-					"byte_copy_right = %u", byte_copy_right);
-		}
-
-		sha1_starts( &ctx );
-
-		while (n<length) {
-			guint16 handle_now = length;
-
-			if ( k < byte_copy_right && byte_copy_right <= k + (length-n) ){
-				handle_now = byte_copy_right - position;
-			}
-
-			if (k + handle_now >= UDVM_MEMORY_SIZE)
-				goto decompression_failure;
-			sha1_update( &ctx, &buff[k], handle_now );
-
-			k = ( k + handle_now ) & 0xffff;
-			n = ( n + handle_now ) & 0xffff;
-
-			if ( k >= byte_copy_right ) {
-				k = byte_copy_left;
-			}
-		}
-
-		sha1_finish( &ctx, sha1_digest_buf );
-
-		k = ref_destination;
-
-		for ( n=0; n< STATE_BUFFER_SIZE; n++ ) {
-
-			buff[k] = sha1_digest_buf[n];
-
-			k = ( k + 1 ) & 0xffff;
-			n++;
-
-			if ( k == byte_copy_right ){
-				k = byte_copy_left;
-			}
-		}
-
-		if (print_level_2 ){
-			proto_tree_add_text(udvm_tree, message_tvb, 0, -1,
-					"Calculated SHA-1: %s",
-					bytes_to_str(wmem_packet_scope(), sha1_digest_buf, STATE_BUFFER_SIZE));
-		}
-
-		current_address = next_operand_address;
-		goto execute_next_instruction;
-		break;
-
-	case SIGCOMP_INSTR_LOAD: /* 14 LOAD (%address, %value) */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## LOAD(14) (%%address, %%value)",
-				current_address);
-		}
-		operand_address = current_address + 1;
-		/* %address */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &addr);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Address %u",
-				operand_address, addr);
-		}
-		operand_address = next_operand_address;
-		/* %value */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value);
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## LOAD (%%address=%u, %%value=%u)",
-				current_address, addr, value);
-		}
-		lsb = value & 0xff;
-		msb = value >> 8;
-
-		buff[addr] = msb;
-		buff[(addr + 1) & 0xffff] = lsb;
-
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Value %u",
-				operand_address, value);
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"     Loading bytes at %u Value %u 0x%x",
-					addr, value, value);
-		}
-		current_address = next_operand_address;
-		goto execute_next_instruction;
-		break;
-
-	case SIGCOMP_INSTR_MULTILOAD: /* 15 MULTILOAD (%address, #n, %value_0, ..., %value_n-1) */
-		/* RFC 3320:
-		 * The MULTILOAD instruction sets a contiguous block of 2-byte words in
-		 * the UDVM memory to specified values.
-		 * Hmm what if the value to load only takes one byte ? Chose to always load two bytes.
-		 */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## MULTILOAD(15) (%%address, #n, value_0, ..., value_n-1)",
-				current_address);
-		}
-		operand_address = current_address + 1;
-		/* %address */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &addr);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Address %u",
-				operand_address, addr);
-		}
-		operand_address = next_operand_address;
-
-		/* #n */
-		next_operand_address = decode_udvm_literal_operand(buff,operand_address, &n);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      n %u",
-				operand_address, n);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## MULTILOAD (%%address=%u, #n=%u, value_0, ..., value_%d)",
-				current_address, addr, n, n-1);
-		}
-		operand_address = next_operand_address;
-		used_udvm_cycles = used_udvm_cycles + n;
-		while ( n > 0) {
-			n = n - 1;
-			/* %value */
-			next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value);
-			lsb = value & 0xff;
-			msb = value >> 8;
-
-			if (addr >= UDVM_MEMORY_SIZE - 1)
-				goto decompression_failure;
-
-			buff[addr] = msb;
-			buff[(addr + 1) & 0xffff] = lsb;
-			/* debug
-			*/
-			length = next_operand_address - operand_address;
-
-			if (print_level_1 ){
-				proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1, "Addr: %u      Value %5u      - Loading bytes at %5u Value %5u 0x%x",
-				operand_address, value, addr, value, value);
-			}
-			addr = addr + 2;
-			operand_address = next_operand_address;
-		}
-		current_address = next_operand_address;
-		goto execute_next_instruction;
-
-		break;
-
-	case SIGCOMP_INSTR_PUSH: /* 16 PUSH (%value) */
-		if (show_instr_detail_level == 2){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## PUSH(16) (value)",
-				current_address);
-		}
-		operand_address = current_address + 1;
-		/* %value */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value);
-		if (show_instr_detail_level == 2){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Value %u",
-				operand_address, value);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## PUSH (value=%u)",
-				current_address, value);
-		}
-		current_address = next_operand_address;
-
-		/* Push the value address onto the stack */
-		stack_location = (buff[70] << 8) | buff[71];
-		stack_fill = (buff[stack_location] << 8)
-			   | buff[(stack_location+1) & 0xFFFF];
-		addr = (stack_location + stack_fill * 2 + 2) & 0xFFFF;
-
-		if (addr >= UDVM_MEMORY_SIZE - 1)
-			goto decompression_failure;
-
-		buff[addr] = (value >> 8) & 0x00FF;
-		buff[(addr+1) & 0xFFFF] = value & 0x00FF;
-
-		if (stack_location >= UDVM_MEMORY_SIZE - 1)
-			goto decompression_failure;
-
-		stack_fill = (stack_fill + 1) & 0xFFFF;
-		buff[stack_location] = (stack_fill >> 8) & 0x00FF;
-		buff[(stack_location+1) & 0xFFFF] = stack_fill & 0x00FF;
-
-		goto execute_next_instruction;
-
-		break;
-
-	case SIGCOMP_INSTR_POP: /* 17 POP (%address) */
-		if (show_instr_detail_level == 2){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## POP(16) (value)",
-				current_address);
-		}
-		operand_address = current_address + 1;
-		/* %value */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);
-		if (show_instr_detail_level == 2){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Value %u",
-				operand_address, destination);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## POP (address=%u)",
-				current_address, destination);
-		}
-		current_address = next_operand_address;
-
-		/* Pop value from the top of the stack */
-		stack_location = (buff[70] << 8) | buff[71];
-		stack_fill = (buff[stack_location] << 8)
-			   | buff[(stack_location+1) & 0xFFFF];
-		if (stack_fill == 0)
-		{
-		    result_code = 16;
-		    goto decompression_failure;
-		}
-
-		if (stack_location >= UDVM_MEMORY_SIZE - 1)
-			goto decompression_failure;
-
-		stack_fill = (stack_fill - 1) & 0xFFFF;
-		buff[stack_location] = (stack_fill >> 8) & 0x00FF;
-		buff[(stack_location+1) & 0xFFFF] = stack_fill & 0x00FF;
-
-		addr = (stack_location + stack_fill * 2 + 2) & 0xFFFF;
-
-		if (addr >= UDVM_MEMORY_SIZE - 1)
-			goto decompression_failure;
-
-		value = (buff[addr] << 8)
-			   | buff[(addr+1) & 0xFFFF];
-
-		/* ... and store the popped value. */
-		if (destination >= UDVM_MEMORY_SIZE - 1)
-			goto decompression_failure;
-		buff[destination] = (value >> 8) & 0x00FF;
-		buff[(destination+1) & 0xFFFF] = value & 0x00FF;
-
-		goto execute_next_instruction;
-
-		break;
-
-	case SIGCOMP_INSTR_COPY: /* 18 COPY (%position, %length, %destination) */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## COPY(18) (position, length, destination)",
-				current_address);
-		}
-		operand_address = current_address + 1;
-		/* %position */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &position);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      position %u",
-				operand_address, position);
-		}
-		operand_address = next_operand_address;
-
-		/* %length */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Length %u",
-				operand_address, length);
-		}
-		operand_address = next_operand_address;
-
-		/* %destination */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Destination %u",
-				operand_address, destination);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## COPY (position=%u, length=%u, destination=%u)",
-				current_address, position, length, destination);
-		}
-		current_address = next_operand_address;
-		/*
-		 * 8.4.  Byte copying
-		 * :
-		 * The string of bytes is copied in ascending order of memory address,
-		 * respecting the bounds set by byte_copy_left and byte_copy_right.
-		 * More precisely, if a byte is copied from/to Address m then the next
-		 * byte is copied from/to Address n where n is calculated as follows:
-		 *
-		 * Set k := m + 1 (modulo 2^16)
-		 * If k = byte_copy_right then set n := byte_copy_left, else set n := k
-		 *
-		 */
-
-		n = 0;
-		k = destination;
-		byte_copy_right = buff[66] << 8;
-		byte_copy_right = byte_copy_right | buff[67];
-		byte_copy_left = buff[64] << 8;
-		byte_copy_left = byte_copy_left | buff[65];
-		if (print_level_2 ){
-			proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
-						"               byte_copy_right = %u", byte_copy_right);
-		}
-
-		while ( n < length ){
-			buff[k] = buff[position];
-			if (print_level_2 ){
-				proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
-					"               Copying value: %u (0x%x) to Addr: %u",
-					buff[position], buff[position], k);
-			}
-			position = ( position + 1 ) & 0xffff;
-			k = ( k + 1 ) & 0xffff;
-			n++;
-
-			/*
-			 * Check for circular buffer wrapping after the positions are
-			 * incremented. If either started at BCR then they should continue
-			 * to increment beyond BCR.
-			 */
-			if ( k == byte_copy_right ){
-				k = byte_copy_left;
-			}
-			if ( position == byte_copy_right ){
-				position = byte_copy_left;
-			}
-		}
-		used_udvm_cycles = used_udvm_cycles + length;
-		goto execute_next_instruction;
-		break;
-
-	case SIGCOMP_INSTR_COPY_LITERAL: /* 19 COPY-LITERAL (%position, %length, $destination) */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## COPY-LITERAL(19) (position, length, $destination)",
-				current_address);
-		}
-		operand_address = current_address + 1;
-		/* %position */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &position);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      position %u",
-				operand_address, position);
-		}
-		operand_address = next_operand_address;
-
-		/* %length */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Length %u",
-				operand_address, length);
-		}
-		operand_address = next_operand_address;
-
-
-		/* $destination */
-		next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &ref_destination, &result_dest);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      destination %u",
-				operand_address, ref_destination);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## COPY-LITERAL (position=%u, length=%u, $destination=%u)",
-				current_address, position, length, ref_destination);
-		}
-		current_address = next_operand_address;
-
-
-		/*
-		 * 8.4.  Byte copying
-		 * :
-		 * The string of bytes is copied in ascending order of memory address,
-		 * respecting the bounds set by byte_copy_left and byte_copy_right.
-		 * More precisely, if a byte is copied from/to Address m then the next
-		 * byte is copied from/to Address n where n is calculated as follows:
-		 *
-		 * Set k := m + 1 (modulo 2^16)
-		 * If k = byte_copy_right then set n := byte_copy_left, else set n := k
-		 *
-		 */
-
-		n = 0;
-		k = ref_destination;
-		byte_copy_right = buff[66] << 8;
-		byte_copy_right = byte_copy_right | buff[67];
-		byte_copy_left = buff[64] << 8;
-		byte_copy_left = byte_copy_left | buff[65];
-		if (print_level_2 ){
-			proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
-					"               byte_copy_right = %u", byte_copy_right);
-		}
-		while ( n < length ){
-
-			buff[k] = buff[position];
-			if (print_level_2 ){
-				proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
-					"               Copying value: %u (0x%x) to Addr: %u",
-					buff[position], buff[position], k);
-			}
-			position = ( position + 1 ) & 0xffff;
-			k = ( k + 1 ) & 0xffff;
-			n++;
-
-			/*
-			 * Check for circular buffer wrapping after the positions are
-			 * incremented. It is important that k cannot be left set
-			 * to BCR. Also, if either started at BCR then they should continue
-			 * to increment beyond BCR.
-			 */
-			if ( k == byte_copy_right ){
-				k = byte_copy_left;
-			}
-			if ( position == byte_copy_right ){
-				position = byte_copy_left;
-			}
-		}
-		buff[result_dest] = k >> 8;
-		buff[(result_dest + 1) & 0xffff] = k & 0x00ff;
-
-		used_udvm_cycles = used_udvm_cycles + length;
-		goto execute_next_instruction;
-		break;
-
-	case SIGCOMP_INSTR_COPY_OFFSET: /* 20 COPY-OFFSET (%offset, %length, $destination) */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## COPY-OFFSET(20) (offset, length, $destination)",
-				current_address);
-		}
-		operand_address = current_address + 1;
-		/* %offset */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &multy_offset);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      offset %u",
-				operand_address, multy_offset);
-		}
-		operand_address = next_operand_address;
-
-		/* %length */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Length %u",
-				operand_address, length);
-		}
-		operand_address = next_operand_address;
-
-
-		/* $destination */
-		next_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &ref_destination, &result_dest);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      $destination %u",
-				operand_address, ref_destination);
-		}
-
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## COPY-OFFSET (offset=%u, length=%u, $destination=%u)",
-				current_address, multy_offset, length, result_dest);
-		}
-		current_address = next_operand_address;
-
-		/* Execute the instruction:
-		 * To derive the value of the position operand, starting at the memory
-		 * address specified by destination, the UDVM counts backwards a total
-		 * of offset memory addresses.
-		 *
-		 * If the memory address specified in byte_copy_left is reached, the
-		 * next memory address is taken to be (byte_copy_right - 1) modulo 2^16.
-		 */
-		byte_copy_left = buff[64] << 8;
-		byte_copy_left = byte_copy_left | buff[65];
-		byte_copy_right = buff[66] << 8;
-		byte_copy_right = byte_copy_right | buff[67];
-
-		/*
-		 * In order to work out the position, simple arithmetic is tricky
-		 * to apply because there some nasty corner cases. A simple loop
-		 * is inefficient but the logic is simple.
-		 *
-		 * FUTURE: This could be optimised.
-		 */
-		for (position = ref_destination, i = 0; i < multy_offset; i++)
-		{
-			if ( position == byte_copy_left )
-			{
-				position = (byte_copy_right - 1) & 0xffff;
-			}
-			else
-			{
-				position = (position - 1) & 0xffff;
-			}
-		}
-
-		if (print_level_2 ){
-			proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
-					"               byte_copy_left = %u byte_copy_right = %u position= %u",
-					byte_copy_left, byte_copy_right, position);
-			}
-		/* The COPY-OFFSET instruction then behaves as a COPY-LITERAL
-		 * instruction, taking the value of the position operand to be the last
-		 * memory address reached in the above step.
-		 */
-
-		/*
-		 * 8.4.  Byte copying
-		 * :
-		 * The string of bytes is copied in ascending order of memory address,
-		 * respecting the bounds set by byte_copy_left and byte_copy_right.
-		 * More precisely, if a byte is copied from/to Address m then the next
-		 * byte is copied from/to Address n where n is calculated as follows:
-		 *
-		 * Set k := m + 1 (modulo 2^16)
-		 * If k = byte_copy_right then set n := byte_copy_left, else set n := k
-		 *
-		 */
-
-		n = 0;
-		k = ref_destination;
-		if (print_level_2 ){
-			proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
-					"               byte_copy_left = %u byte_copy_right = %u", byte_copy_left, byte_copy_right);
-		}
-		while ( n < length ){
-			buff[k] = buff[position];
-			if (print_level_2 ){
-				proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
-					"               Copying value: %5u (0x%x) from Addr: %u to Addr: %u",
-					buff[position], buff[position],(position), k);
-			}
-			n++;
-			k = ( k + 1 ) & 0xffff;
-			position = ( position + 1 ) & 0xffff;
-
-			/*
-			 * Check for circular buffer wrapping after the positions are
-			 * incremented. It is important that k cannot be left set
-			 * to BCR. Also, if either started at BCR then they should continue
-			 * to increment beyond BCR.
-			 */
-			if ( k == byte_copy_right ){
-				k = byte_copy_left;
-			}
-			if ( position == byte_copy_right ){
-				position = byte_copy_left;
-			}
-		}
-		buff[result_dest] = k >> 8;
-		buff[result_dest + 1] = k & 0x00ff;
-		used_udvm_cycles = used_udvm_cycles + length;
-		goto execute_next_instruction;
-
-		break;
-	case SIGCOMP_INSTR_MEMSET: /* 21 MEMSET (%address, %length, %start_value, %offset) */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## MEMSET(21) (address, length, start_value, offset)",
-				current_address);
-		}
-		operand_address = current_address + 1;
-
-		/* %address */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &addr);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Address %u",
-				operand_address, addr);
-		}
-		operand_address = next_operand_address;
-
-		/*  %length, */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Length %u",
-				operand_address, length);
-		}
-		operand_address = next_operand_address;
-		/* %start_value */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &start_value);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      start_value %u",
-				operand_address, start_value);
-		}
-		operand_address = next_operand_address;
-
-		/* %offset */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &multy_offset);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      offset %u",
-				operand_address, multy_offset);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## MEMSET (address=%u, length=%u, start_value=%u, offset=%u)",
-				current_address, addr, length, start_value, multy_offset);
-		}
-		current_address = next_operand_address;
-		/* exetute the instruction
-		 * The sequence of values used by the MEMSET instruction is specified by
-		 * the following formula:
-		 *
-		 * Seq[n] := (start_value + n * offset) modulo 256
-		 */
-		n = 0;
-		k = addr;
-		byte_copy_right = buff[66] << 8;
-		byte_copy_right = byte_copy_right | buff[67];
-		byte_copy_left = buff[64] << 8;
-		byte_copy_left = byte_copy_left | buff[65];
-		if (print_level_2 ){
-			proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
-					"               byte_copy_left = %u byte_copy_right = %u", byte_copy_left, byte_copy_right);
-		}
-		while ( n < length ){
-			if ( k == byte_copy_right ){
-				k = byte_copy_left;
-			}
-			buff[k] = (start_value + ( n * multy_offset)) & 0xff;
-			if (print_level_2 ){
-				proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
-					"     Storing value: %u (0x%x) at Addr: %u",
-					buff[k], buff[k], k);
-			}
-			k = ( k + 1 ) & 0xffff;
-			n++;
-		}/* end while */
-		used_udvm_cycles = used_udvm_cycles + length;
-		goto execute_next_instruction;
-		break;
-
-
-	case SIGCOMP_INSTR_JUMP: /* 22 JUMP (@address) */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## JUMP(22) (@address)",
-				current_address);
-		}
-		operand_address = current_address + 1;
-		/* @address */
-		 /* operand_value = (memory_address_of_instruction + D) modulo 2^16 */
-		/*next_operand_address = */decode_udvm_address_operand(buff,operand_address, &at_address, current_address);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
-				operand_address, at_address);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## JUMP (@address=%u)",
-				current_address, at_address);
-		}
-		current_address = at_address;
-		goto execute_next_instruction;
-		break;
-
-	case SIGCOMP_INSTR_COMPARE: /* 23 */
-		/* COMPARE (%value_1, %value_2, @address_1, @address_2, @address_3)
-		 */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## COMPARE(23) (value_1, value_2, @address_1, @address_2, @address_3)",
-				current_address);
-		}
-		operand_address = current_address + 1;
-
-		/* %value_1 */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value_1);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Value %u",
-					operand_address, value_1);
-		}
-		operand_address = next_operand_address;
-
-		/* %value_2 */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value_2);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Value %u",
-					operand_address, value_2);
-		}
-		operand_address = next_operand_address;
-
-		/* @address_1 */
-		 /* operand_value = (memory_address_of_instruction + D) modulo 2^16 */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address_1);
-		at_address_1 = ( current_address + at_address_1) & 0xffff;
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
-				operand_address, at_address_1);
-		}
-		operand_address = next_operand_address;
-
-
-		/* @address_2 */
-		 /* operand_value = (memory_address_of_instruction + D) modulo 2^16 */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address_2);
-		at_address_2 = ( current_address + at_address_2) & 0xffff;
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
-				operand_address, at_address_2);
-		}
-		operand_address = next_operand_address;
-
-		/* @address_3 */
-		 /* operand_value = (memory_address_of_instruction + D) modulo 2^16 */
-		/*next_operand_address = */decode_udvm_multitype_operand(buff, operand_address, &at_address_3);
-		at_address_3 = ( current_address + at_address_3) & 0xffff;
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
-				operand_address, at_address_3);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## COMPARE (value_1=%u, value_2=%u, @address_1=%u, @address_2=%u, @address_3=%u)",
-				current_address, value_1, value_2, at_address_1, at_address_2, at_address_3);
-		}
-		/* execute the instruction
-		 * If value_1 < value_2 then the UDVM continues instruction execution at
-		 * the memory address specified by address 1. If value_1 = value_2 then
-		 * it jumps to the address specified by address_2. If value_1 > value_2
-		 * then it jumps to the address specified by address_3.
-		 */
-		if ( value_1 < value_2 )
-			current_address = at_address_1;
-		if ( value_1 == value_2 )
-			current_address = at_address_2;
-		if ( value_1 > value_2 )
-			current_address = at_address_3;
-		goto execute_next_instruction;
-		break;
-
-	case SIGCOMP_INSTR_CALL: /* 24 CALL (@address) (PUSH addr )*/
-		if (show_instr_detail_level == 2){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## CALL(24) (@address) (PUSH addr )",
-				current_address);
-		}
-		operand_address = current_address + 1;
-		/* @address */
-		next_operand_address = decode_udvm_address_operand(buff,operand_address, &at_address, current_address);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
-				operand_address, at_address);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## CALL (@address=%u)",
-				current_address, at_address);
-		}
-		current_address = next_operand_address;
-
-		/* Push the current address onto the stack */
-		stack_location = (buff[70] << 8) | buff[71];
-		stack_fill = (buff[stack_location] << 8)
-			   | buff[(stack_location+1) & 0xFFFF];
-		addr = (stack_location + stack_fill * 2 + 2) & 0xFFFF;
-		if (addr >= UDVM_MEMORY_SIZE - 1)
-			goto decompression_failure;
-		buff[addr] = (current_address >> 8) & 0x00FF;
-		buff[(addr+1) & 0xFFFF] = current_address & 0x00FF;
-
-		stack_fill = (stack_fill + 1) & 0xFFFF;
-		if (stack_location >= UDVM_MEMORY_SIZE - 1)
-			goto decompression_failure;
-		buff[stack_location] = (stack_fill >> 8) & 0x00FF;
-		buff[(stack_location+1) & 0xFFFF] = stack_fill & 0x00FF;
-
-		/* ... and jump to the destination address */
-		current_address = at_address;
-
-		goto execute_next_instruction;
-
-		break;
-
-	case SIGCOMP_INSTR_RETURN: /* 25 POP and return */
-		if (print_level_1 || show_instr_detail_level == 1){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## POP(25) and return",
-				current_address);
-		}
-
-		/* Pop value from the top of the stack */
-		stack_location = (buff[70] << 8) | buff[71];
-		stack_fill = (buff[stack_location] << 8)
-			   | buff[(stack_location+1) & 0xFFFF];
-		if (stack_fill == 0)
-		{
-		    result_code = 16;
-		    goto decompression_failure;
-		}
-
-		stack_fill = (stack_fill - 1) & 0xFFFF;
-		if (stack_location >= UDVM_MEMORY_SIZE - 1)
-			goto decompression_failure;
-		buff[stack_location] = (stack_fill >> 8) & 0x00FF;
-		buff[(stack_location+1) & 0xFFFF] = stack_fill & 0x00FF;
-
-		addr = (stack_location + stack_fill * 2 + 2) & 0xFFFF;
-		at_address = (buff[addr] << 8)
-			   | buff[(addr+1) & 0xFFFF];
-
-		/* ... and set the PC to the popped value */
-		current_address = at_address;
-
-		goto execute_next_instruction;
-
-		break;
-
-	case SIGCOMP_INSTR_SWITCH: /* 26 SWITCH (#n, %j, @address_0, @address_1, ... , @address_n-1) */
-		/*
-		 * When a SWITCH instruction is encountered the UDVM reads the value of
-		 * j. It then continues instruction execution at the address specified
-		 * by address j.
-		 *
-		 * Decompression failure occurs if j specifies a value of n or more, or
-		 * if the address lies beyond the overall UDVM memory size.
-		 */
-		instruction_address = current_address;
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## SWITCH (#n, j, @address_0, @address_1, ... , @address_n-1))",
-				current_address);
-		}
-		operand_address = current_address + 1;
-		/* #n
-		 * Number of addresses in the instruction
-		 */
-		next_operand_address = decode_udvm_literal_operand(buff,operand_address, &n);
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      n %u",
-				operand_address, n);
-		}
-		operand_address = next_operand_address;
-		/* %j */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &j);
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      j %u",
-					operand_address, j);
-		}
-		operand_address = next_operand_address;
-		m = 0;
-		while ( m < n ){
-			/* @address_n-1 */
-			/* operand_value = (memory_address_of_instruction + D) modulo 2^16 */
-			next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address_1);
-			at_address_1 = ( instruction_address + at_address_1) & 0xffff;
-			if (print_level_1 ){
-				proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
-					operand_address, at_address_1);
-			}
-			if ( j == m ){
-				current_address = at_address_1;
-			}
-			operand_address = next_operand_address;
-			m++;
-		}
-		/* Check decompression failure */
-		if ( ( j == n ) || ( j > n )){
-			result_code = 5;
-			goto decompression_failure;
-		}
-		if ( current_address > UDVM_MEMORY_SIZE ){
-			result_code = 6;
-			goto decompression_failure;
-		}
-		used_udvm_cycles = used_udvm_cycles + n;
-
-		goto execute_next_instruction;
-
-		break;
-	case SIGCOMP_INSTR_CRC: /* 27 CRC (%value, %position, %length, @address) */
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## CRC (value, position, length, @address)",
-				current_address);
-		}
-
-		operand_address = current_address + 1;
-
-		/* %value */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value);
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Value %u",
-				operand_address, value);
-		}
-		operand_address = next_operand_address;
-
-		/* %position */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &position);
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      position %u",
-				operand_address, position);
-		}
-		operand_address = next_operand_address;
-
-		/* %length */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Length %u",
-				operand_address, length);
-		}
-		operand_address = next_operand_address;
-
-		/* @address */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address);
-		at_address = ( current_address + at_address) & 0xffff;
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
-				operand_address, at_address);
-		}
-		 /* operand_value = (memory_address_of_instruction + D) modulo 2^16 */
-		used_udvm_cycles = used_udvm_cycles + length;
-
-		n = 0;
-		k = position;
-		byte_copy_right = buff[66] << 8;
-		byte_copy_right = byte_copy_right | buff[67];
-		byte_copy_left = buff[64] << 8;
-		byte_copy_left = byte_copy_left | buff[65];
-		result = 0;
-
-		if (print_level_2 ){
-			proto_tree_add_text(udvm_tree, message_tvb, 0, -1,
-					"byte_copy_right = %u", byte_copy_right);
-		}
-
-		while (n<length) {
-
-			guint16 handle_now = length - n;
-
-			if ( k < byte_copy_right && byte_copy_right <= k + (length-n) ){
-				handle_now = byte_copy_right - k;
-			}
-
-			if (k + handle_now >= UDVM_MEMORY_SIZE)
-				goto decompression_failure;
-			result = crc16_ccitt_seed(&buff[k], handle_now, (guint16) (result ^ 0xffff));
-
-			k = ( k + handle_now ) & 0xffff;
-			n = ( n + handle_now ) & 0xffff;
-
-			if ( k >= byte_copy_right ) {
-				k = byte_copy_left;
-			}
-		}
-
-		result = result ^ 0xffff;
-
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1, "Calculated CRC %u", result);
-		}
-		if (result != value){
-			current_address = at_address;
-		}
-		else {
-			current_address = next_operand_address;
-		}
-		goto execute_next_instruction;
-		break;
-
-
-	case SIGCOMP_INSTR_INPUT_BYTES: /* 28 INPUT-BYTES (%length, %destination, @address) */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## INPUT-BYTES(28) length, destination, @address)",
-				current_address);
-		}
-		operand_address = current_address + 1;
-		/* %length */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Length %u",
-				operand_address, length);
-		}
-		operand_address = next_operand_address;
-
-		/* %destination */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Destination %u",
-				operand_address, destination);
-		}
-		operand_address = next_operand_address;
-
-		/* @address */
-		 /* operand_value = (memory_address_of_instruction + D) modulo 2^16 */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address);
-		at_address = ( current_address + at_address) & 0xffff;
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
-				operand_address, at_address);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## INPUT-BYTES length=%u, destination=%u, @address=%u)",
-				current_address, length, destination, at_address);
-		}
-		/* execute the instruction TODO insert checks
-		 * RFC 3320 :
-		 *
-		 *    0             7 8            15
-		 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-		 *   |        byte_copy_left         |  64 - 65
-		 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-		 *   |        byte_copy_right        |  66 - 67
-		 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-		 *   |        input_bit_order        |  68 - 69
-		 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-		 *   |        stack_location         |  70 - 71
-		 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-		 *
-		 * Figure 7: Memory addresses of the UDVM registers
-		 * :
-		 * 8.4.  Byte copying
-		 * :
-		 * The string of bytes is copied in ascending order of memory address,
-		 * respecting the bounds set by byte_copy_left and byte_copy_right.
-		 * More precisely, if a byte is copied from/to Address m then the next
-		 * byte is copied from/to Address n where n is calculated as follows:
-		 *
-		 * Set k := m + 1 (modulo 2^16)
-		 * If k = byte_copy_right then set n := byte_copy_left, else set n := k
-		 *
-		 */
-
-		n = 0;
-		k = destination;
-		byte_copy_right = buff[66] << 8;
-		byte_copy_right = byte_copy_right | buff[67];
-		byte_copy_left = buff[64] << 8;
-		byte_copy_left = byte_copy_left | buff[65];
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
-					"               byte_copy_right = %u", byte_copy_right);
-		}
-		/* clear out remaining bits if any */
-		remaining_bits = 0;
-		input_bits=0;
-		/* operand_address used as dummy */
-		while ( n < length ){
-			if (input_address > ( msg_end - 1)){
-				current_address = at_address;
-				result_code = 14;
-				goto execute_next_instruction;
-			}
-
-			if ( k == byte_copy_right ){
-				k = byte_copy_left;
-			}
-			octet = tvb_get_guint8(message_tvb, input_address);
-			buff[k] = octet;
-			if (print_level_1 ){
-				proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
-					"               Loading value: %u (0x%x) at Addr: %u", octet, octet, k);
-			}
-			input_address++;
-			/*
-			 * If the instruction requests data that lies beyond the end of the
-			 * SigComp message, no data is returned.  Instead the UDVM moves program
-			 * execution to the address specified by the address operand.
-			 */
-
-
-			k = ( k + 1 ) & 0xffff;
-			n++;
-		}
-		used_udvm_cycles = used_udvm_cycles + length;
-		current_address = next_operand_address;
-		goto execute_next_instruction;
-		break;
-	case SIGCOMP_INSTR_INPUT_BITS:/* 29   INPUT-BITS (%length, %destination, @address) */
-		/*
-		 * The length operand indicates the requested number of bits.
-		 * Decompression failure occurs if this operand does not lie between 0
-		 * and 16 inclusive.
-		 *
-		 * The destination operand specifies the memory address to which the
-		 * compressed data should be copied.  Note that the requested bits are
-		 * interpreted as a 2-byte integer ranging from 0 to 2^length - 1, as
-		 * explained in Section 8.2.
-		 *
-		 * If the instruction requests data that lies beyond the end of the
-		 * SigComp message, no data is returned.  Instead the UDVM moves program
-		 * execution to the address specified by the address operand.
-		 */
-
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## INPUT-BITS(29) (length, destination, @address)",
-				current_address);
-		}
-		operand_address = current_address + 1;
-
-		/* %length */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      length %u",
-				operand_address, length);
-		}
-		operand_address = next_operand_address;
-		/* %destination */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Destination %u",
-				operand_address, destination);
-		}
-		operand_address = next_operand_address;
-
-		/* @address */
-		 /* operand_value = (memory_address_of_instruction + D) modulo 2^16 */
-		next_operand_address = decode_udvm_address_operand(buff,operand_address, &at_address, current_address);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
-				operand_address, at_address);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## INPUT-BITS length=%u, destination=%u, @address=%u)",
-				current_address, length, destination, at_address);
-		}
-		current_address = next_operand_address;
-
-		/*
-		 * Execute actual instr.
-		 * The input_bit_order register contains the following three flags:
-		 *
-		 *            0             7 8            15
-		 *           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-		 *           |         reserved        |F|H|P|  68 - 69
-		 *           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-		 */
-		input_bit_order = buff[68] << 8;
-		input_bit_order = input_bit_order | buff[69];
-		/*
-		 * If the instruction requests data that lies beyond the end of the
-		 * SigComp message, no data is returned.  Instead the UDVM moves program
-		 * execution to the address specified by the address operand.
-		 */
-
-		if ( length > 16 ){
-			result_code = 7;
-			goto decompression_failure;
-		}
-		if ( input_bit_order > 7 ){
-			result_code = 8;
-			goto decompression_failure;
-		}
-
-		/*
-		 * Transfer F bit to bit_order to tell decomp dispatcher which bit order to use
-		 */
-		bit_order = ( input_bit_order & 0x0004 ) >> 2;
-		value = decomp_dispatch_get_bits( message_tvb, udvm_tree, bit_order,
-				buff, &old_input_bit_order, &remaining_bits,
-				&input_bits, &input_address, length, &result_code, msg_end);
-		if ( result_code == 11 ){
-			current_address = at_address;
-			goto execute_next_instruction;
-		}
-		msb = value >> 8;
-		lsb = value & 0x00ff;
-		if (destination >= UDVM_MEMORY_SIZE - 1)
-			goto decompression_failure;
-		buff[destination] = msb;
-		buff[(destination + 1) & 0xffff]=lsb;
-		if (print_level_1 ){
-			proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
-			"               Loading value: %u (0x%x) at Addr: %u, remaining_bits: %u", value, value, destination, remaining_bits);
-		}
-
-		goto execute_next_instruction;
-		break;
-	case SIGCOMP_INSTR_INPUT_HUFFMAN: /* 30 */
-		/*
-		 * INPUT-HUFFMAN (%destination, @address, #n, %bits_1, %lower_bound_1,
-		 *  %upper_bound_1, %uncompressed_1, ... , %bits_n, %lower_bound_n,
-		 *  %upper_bound_n, %uncompressed_n)
-		 */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## INPUT-HUFFMAN (destination, @address, #n, bits_1, lower_bound_1,upper_bound_1, uncompressed_1, ... , bits_n, lower_bound_n,upper_bound_n, uncompressed_n)",
-				current_address);
-		}
-		operand_address = current_address + 1;
-
-		/* %destination */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      Destination %u",
-				operand_address, destination);
-		}
-		operand_address = next_operand_address;
-
-		/* @address */
-		 /* operand_value = (memory_address_of_instruction + D) modulo 2^16 */
-		next_operand_address = decode_udvm_address_operand(buff,operand_address, &at_address, current_address);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      @Address %u",
-				operand_address, at_address);
-		}
-		operand_address = next_operand_address;
-
-		/* #n */
-		next_operand_address = decode_udvm_literal_operand(buff,operand_address, &n);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      n %u",
-				operand_address, n);
-		}
-		operand_address = next_operand_address;
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## INPUT-HUFFMAN (destination=%u, @address=%u, #n=%u, bits_1, lower_1,upper_1, unc_1, ... , bits_%d, lower_%d,upper_%d, unc_%d)",
-				current_address, destination, at_address, n, n, n, n, n);
-		}
-
-		used_udvm_cycles = used_udvm_cycles + n;
-
-		/*
-		 * Note that if n = 0 then the INPUT-HUFFMAN instruction is ignored and
-		 * program execution resumes at the following instruction.
-		 * Decompression failure occurs if (bits_1 + ... + bits_n) > 16.
-		 *
-		 * In all other cases, the behavior of the INPUT-HUFFMAN instruction is
-		 * defined below:
-		 *
-		 * 1. Set j := 1 and set H := 0.
-		 *
-		 * 2. Request bits_j compressed bits.  Interpret the returned bits as an
-		 * integer k from 0 to 2^bits_j - 1, as explained in Section 8.2.
-		 *
-		 * 3. Set H := H * 2^bits_j + k.
-		 *
-		 * 4. If data is requested that lies beyond the end of the SigComp
-		 * message, terminate the INPUT-HUFFMAN instruction and move program
-		 * execution to the memory address specified by the address operand.
-		 *
-		 * 5. If (H < lower_bound_j) or (H > upper_bound_j) then set j := j + 1.
-		 * Then go back to Step 2, unless j > n in which case decompression
-		 * failure occurs.
-		 *
-		 * 6. Copy (H + uncompressed_j - lower_bound_j) modulo 2^16 to the
-		 * memory address specified by the destination operand.
-		 *
-		 */
-		/*
-		 * The input_bit_order register contains the following three flags:
-		 *
-		 *            0             7 8            15
-		 *           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-		 *           |         reserved        |F|H|P|  68 - 69
-		 *           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-		 *
-		 * Transfer H bit to bit_order to tell decomp dispatcher which bit order to use
-		 */
-		input_bit_order = buff[68] << 8;
-		input_bit_order = input_bit_order | buff[69];
-		bit_order = ( input_bit_order & 0x0002 ) >> 1;
-
-		j = 1;
-		H = 0;
-		m = n;
-		outside_huffman_boundaries = TRUE;
-		print_in_loop = print_level_3;
-		while ( m > 0 ){
-			/* %bits_n */
-			next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &bits_n);
-			if (print_in_loop ){
-				proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      bits_n %u",
-					operand_address, bits_n);
-			}
-			operand_address = next_operand_address;
-
-			/* %lower_bound_n */
-			next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &lower_bound_n);
-			if (print_in_loop ){
-				proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      lower_bound_n %u",
-					operand_address, lower_bound_n);
-			}
-			operand_address = next_operand_address;
-			/* %upper_bound_n */
-			next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &upper_bound_n);
-			if (print_in_loop ){
-				proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      upper_bound_n %u",
-					operand_address, upper_bound_n);
-			}
-			operand_address = next_operand_address;
-			/* %uncompressed_n */
-			next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &uncompressed_n);
-			if (print_in_loop ){
-				proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      uncompressed_n %u",
-					operand_address, uncompressed_n);
-			}
-			operand_address = next_operand_address;
-			/* execute instruction */
-			if ( outside_huffman_boundaries ) {
-				/*
-				 * 2. Request bits_j compressed bits.  Interpret the returned bits as an
-				 *    integer k from 0 to 2^bits_j - 1, as explained in Section 8.2.
-				 */
-				k = decomp_dispatch_get_bits( message_tvb, udvm_tree, bit_order,
-						buff, &old_input_bit_order, &remaining_bits,
-						&input_bits, &input_address, bits_n, &result_code, msg_end);
-				if ( result_code == 11 ){
-					/*
-					* 4. If data is requested that lies beyond the end of the SigComp
-					* message, terminate the INPUT-HUFFMAN instruction and move program
-					* execution to the memory address specified by the address operand.
-					*/
-					current_address = at_address;
-					goto execute_next_instruction;
-				}
-
-				/*
-				 * 3. Set H := H * 2^bits_j + k.
-				 * [In practice is a shift+OR operation.]
-				 */
-				oldH = H;
-				H = (H << bits_n) | k;
-				if (print_level_3 ){
-					proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"               Set H(%u) := H(%u) * 2^bits_j(%u) + k(%u)",
-						 H ,oldH, 1<<bits_n,k);
-				}
-
-				/*
-				 * 5. If (H < lower_bound_j) or (H > upper_bound_j) then set j := j + 1.
-				 * Then go back to Step 2, unless j > n in which case decompression
-				 * failure occurs.
-				 */
-				if ((H < lower_bound_n) || (H > upper_bound_n)){
-					outside_huffman_boundaries = TRUE;
-				}else{
-					outside_huffman_boundaries = FALSE;
-					print_in_loop = FALSE;
-					/*
-					 * 6. Copy (H + uncompressed_j - lower_bound_j) modulo 2^16 to the
-					 * memory address specified by the destination operand.
-					 */
-					if (print_level_2 ){
-						proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-							"               H(%u) = H(%u) + uncompressed_n(%u) - lower_bound_n(%u)",
-						(H + uncompressed_n - lower_bound_n ),H, uncompressed_n, lower_bound_n);
-					}
-					H = H + uncompressed_n - lower_bound_n;
-					msb = H >> 8;
-					lsb = H & 0x00ff;
-					if (destination >= UDVM_MEMORY_SIZE - 1)
-						goto decompression_failure;
-					buff[destination] = msb;
-					buff[(destination + 1) & 0xffff]=lsb;
-					if (print_level_1 ){
-						proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
-					"               Loading H: %u (0x%x) at Addr: %u,j = %u remaining_bits: %u",
-						H, H, destination,( n - m + 1 ), remaining_bits);
-					}
-
-				}
-
-
-			}
-			m = m - 1;
-		}
-		if ( outside_huffman_boundaries ) {
-			result_code = 10;
-			goto decompression_failure;
-		}
-
-		current_address = next_operand_address;
-		goto execute_next_instruction;
-		break;
-
-	case SIGCOMP_INSTR_STATE_ACCESS: /* 31 */
-		/*   STATE-ACCESS (%partial_identifier_start, %partial_identifier_length,
-		 * %state_begin, %state_length, %state_address, %state_instruction)
-		 */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## STATE-ACCESS(31) (partial_identifier_start, partial_identifier_length,state_begin, state_length, state_address, state_instruction)",
-				current_address);
-		}
-		operand_address = current_address + 1;
-
-		/*
-		 * %partial_identifier_start
-		 */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &p_id_start);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       partial_identifier_start %u",
-				operand_address, p_id_start);
-		}
-
-		/*
-		 * %partial_identifier_length
-		 */
-		operand_address = next_operand_address;
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &p_id_length);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       partial_identifier_length %u",
-				operand_address, p_id_length);
-		}
-		/*
-		 * %state_begin
-		 */
-		operand_address = next_operand_address;
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_begin);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       state_begin %u",
-				operand_address, state_begin);
-		}
-		/*
-		 * %state_length
-		 */
-		operand_address = next_operand_address;
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_length);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       state_length %u",
-				operand_address, state_length);
-		}
-		/*
-		 * %state_address
-		 */
-		operand_address = next_operand_address;
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_address);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       state_address %u",
-				operand_address, state_address);
-		}
-		/*
-		 * %state_instruction
-		 */
-		operand_address = next_operand_address;
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_instruction);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       state_instruction %u",
-				operand_address, state_instruction);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## STATE-ACCESS(31) (partial_identifier_start=%u, partial_identifier_length=%u,state_begin=%u, state_length=%u, state_address=%u, state_instruction=%u)",
-				current_address, p_id_start, p_id_length, state_begin, state_length, state_address, state_instruction);
-		}
-		current_address = next_operand_address;
-		byte_copy_right = buff[66] << 8;
-		byte_copy_right = byte_copy_right | buff[67];
-		byte_copy_left = buff[64] << 8;
-		byte_copy_left = byte_copy_left | buff[65];
-		if (print_level_2 ){
-			proto_tree_add_text(udvm_tree, message_tvb, input_address, 1,
-					"               byte_copy_right = %u, byte_copy_left = %u", byte_copy_right,byte_copy_left);
-		}
-
-		result_code = udvm_state_access(message_tvb, udvm_tree, buff, p_id_start, p_id_length, state_begin, &state_length,
-			&state_address, &state_instruction, hf_id);
-		if ( result_code != 0 ){
-			goto decompression_failure;
-		}
-		used_udvm_cycles = used_udvm_cycles + state_length;
-		goto execute_next_instruction;
-		break;
-	case SIGCOMP_INSTR_STATE_CREATE: /* 32 */
-		/*
-		 * STATE-CREATE (%state_length, %state_address, %state_instruction,
-		 * %minimum_access_length, %state_retention_priority)
-		 */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## STATE-CREATE(32) (state_length, state_address, state_instruction,minimum_access_length, state_retention_priority)",
-				current_address);
-		}
-		operand_address = current_address + 1;
-
-		/*
-		 * %state_length
-		 */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_length);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       state_length %u",
-				operand_address, state_length);
-		}
-		/*
-		 * %state_address
-		 */
-		operand_address = next_operand_address;
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_address);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       state_address %u",
-				operand_address, state_address);
-		}
-		/*
-		 * %state_instruction
-		 */
-		operand_address = next_operand_address;
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_instruction);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       state_instruction %u",
-				operand_address, state_instruction);
-		}
-		/*
-		 * %minimum_access_length
-		 */
-		operand_address = next_operand_address;
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &minimum_access_length);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       minimum_access_length %u",
-				operand_address, minimum_access_length);
-		}
-		/*
-		 * %state_retention_priority
-		 */
-		operand_address = next_operand_address;
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_retention_priority);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       state_retention_priority %u",
-				operand_address, state_retention_priority);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## STATE-CREATE(32) (state_length=%u, state_address=%u, state_instruction=%u,minimum_access_length=%u, state_retention_priority=%u)",
-				current_address, state_length, state_address, state_instruction,minimum_access_length, state_retention_priority);
-		}
-		current_address = next_operand_address;
-		/* Execute the instruction
-		 * TODO Implement the instruction
-		 * RFC3320:
-		 *    Note that the new state item cannot be created until a valid
-		 *    compartment identifier has been returned by the application.
-		 *    Consequently, when a STATE-CREATE instruction is encountered the UDVM
-		 *    simply buffers the five supplied operands until the END-MESSAGE
-		 *    instruction is reached.  The steps taken at this point are described
-		 *    in Section 9.4.9.
-		 *
-		 *   Decompression failure MUST occur if more than four state creation
-		 *   requests are made before the END-MESSAGE instruction is encountered.
-		 *   Decompression failure also occurs if the minimum_access_length does
-		 *   not lie between 6 and 20 inclusive, or if the
-		 *   state_retention_priority is 65535.
-		 */
-		no_of_state_create++;
-		if ( no_of_state_create > 4 ){
-			result_code = 12;
-			goto decompression_failure;
-		}
-		if (( minimum_access_length < 6 ) || ( minimum_access_length > STATE_BUFFER_SIZE )){
-			result_code = 1;
-			goto decompression_failure;
-		}
-		if ( state_retention_priority == 65535 ){
-			result_code = 13;
-			goto decompression_failure;
-		}
-		state_length_buff[no_of_state_create] = state_length;
-		state_address_buff[no_of_state_create] = state_address;
-		state_instruction_buff[no_of_state_create] = state_instruction;
-		state_minimum_access_length_buff[no_of_state_create] = minimum_access_length;
-		/* state_state_retention_priority_buff[no_of_state_create] = state_retention_priority; */
-		used_udvm_cycles = used_udvm_cycles + state_length;
-		/* Debug */
-		byte_copy_right = buff[66] << 8;
-		byte_copy_right = byte_copy_right | buff[67];
-		byte_copy_left = buff[64] << 8;
-		byte_copy_left = byte_copy_left | buff[65];
-		n = 0;
-		k = state_address;
-		while ( n < state_length ){
-			if ( k == byte_copy_right ){
-				k = byte_copy_left;
-			}
-			string[0]= buff[k];
-			string[1]= '\0';
-			if (print_level_3 ){
-				proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-					"               Addr: %5u State value: %u (0x%x) ASCII(%s)",
-					k,buff[k],buff[k],format_text(string, 1));
-			}
-			k = ( k + 1 ) & 0xffff;
-			n++;
-		}
-		/* End debug */
-
-		goto execute_next_instruction;
-		break;
-	case SIGCOMP_INSTR_STATE_FREE: /* 33 */
-		/*
-		 * STATE-FREE (%partial_identifier_start, %partial_identifier_length)
-		 */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## STATE-FREE (partial_identifier_start, partial_identifier_length)",
-				current_address);
-		}
-		operand_address = current_address + 1;
-		/*
-		 * %partial_identifier_start
-		 */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &p_id_start);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       partial_identifier_start %u",
-				operand_address, p_id_start);
-		}
-		operand_address = next_operand_address;
-
-		/*
-		 * %partial_identifier_length
-		 */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &p_id_length);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u       partial_identifier_length %u",
-				operand_address, p_id_length);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## STATE-FREE (partial_identifier_start=%u, partial_identifier_length=%u)",
-				current_address, p_id_start, p_id_length);
-		}
-		current_address = next_operand_address;
-
-		/* Execute the instruction:
-		 * TODO implement it
-		 */
-		udvm_state_free(buff,p_id_start,p_id_length);
-
-		goto execute_next_instruction;
-		break;
-	case SIGCOMP_INSTR_OUTPUT: /* 34 OUTPUT (%output_start, %output_length) */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## OUTPUT(34) (output_start, output_length)",
-				current_address);
-		}
-		operand_address = current_address + 1;
-		/*
-		 * %output_start
-		 */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &output_start);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      output_start %u",
-				operand_address, output_start);
-		}
-		operand_address = next_operand_address;
-		/*
-		 * %output_length
-		 */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &output_length);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      output_length %u",
-				operand_address, output_length);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## OUTPUT (output_start=%u, output_length=%u)",
-				current_address, output_start, output_length);
-		}
-		current_address = next_operand_address;
-
-		/*
-		 * Execute instruction
-		 * 8.4.  Byte copying
-		 * :
-		 * The string of bytes is copied in ascending order of memory address,
-		 * respecting the bounds set by byte_copy_left and byte_copy_right.
-		 * More precisely, if a byte is copied from/to Address m then the next
-		 * byte is copied from/to Address n where n is calculated as follows:
-		 *
-		 * Set k := m + 1 (modulo 2^16)
-		 * If k = byte_copy_right then set n := byte_copy_left, else set n := k
-		 *
-		 */
-
-		n = 0;
-		k = output_start;
-		byte_copy_right = buff[66] << 8;
-		byte_copy_right = byte_copy_right | buff[67];
-		byte_copy_left = buff[64] << 8;
-		byte_copy_left = byte_copy_left | buff[65];
-		if (print_level_3 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-					"               byte_copy_right = %u", byte_copy_right);
-		}
-		while ( n < output_length ){
-
-			if ( k == byte_copy_right ){
-				k = byte_copy_left;
-			}
-			out_buff[output_address] = buff[k];
-			string[0]= buff[k];
-			string[1]= '\0';
-			if (print_level_3 ){
-				proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-					"               Output value: %u (0x%x) ASCII(%s) from Addr: %u ,output to dispatcher position %u",
-					buff[k],buff[k],format_text(string,1), k,output_address);
-			}
-			k = ( k + 1 ) & 0xffff;
-			output_address ++;
-			n++;
-		}
-		used_udvm_cycles = used_udvm_cycles + output_length;
-		goto execute_next_instruction;
-		break;
-	case SIGCOMP_INSTR_END_MESSAGE: /* 35 */
-		/*
-		 * END-MESSAGE (%requested_feedback_location,
-		 * %returned_parameters_location, %state_length, %state_address,
-		 * %state_instruction, %minimum_access_length,
-		 * %state_retention_priority)
-		 */
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## END-MESSAGE (requested_feedback_location,state_instruction, minimum_access_length,state_retention_priority)",
-				current_address);
-		}
-		operand_address = current_address + 1;
-
-		/* %requested_feedback_location */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &requested_feedback_location);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      requested_feedback_location %u",
-				operand_address, requested_feedback_location);
-		}
-		operand_address = next_operand_address;
-		/* returned_parameters_location */
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &returned_parameters_location);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      returned_parameters_location %u",
-				operand_address, returned_parameters_location);
-		}
-		/*
-		 * %state_length
-		 */
-		operand_address = next_operand_address;
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_length);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      state_length %u",
-				operand_address, state_length);
-		}
-		/*
-		 * %state_address
-		 */
-		operand_address = next_operand_address;
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_address);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      state_address %u",
-				operand_address, state_address);
-		}
-		/*
-		 * %state_instruction
-		 */
-		operand_address = next_operand_address;
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_instruction);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      state_instruction %u",
-				operand_address, state_instruction);
-		}
-
-		/*
-		 * %minimum_access_length
-		 */
-		operand_address = next_operand_address;
-		next_operand_address = decode_udvm_multitype_operand(buff, operand_address, &minimum_access_length);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      minimum_access_length %u",
-				operand_address, minimum_access_length);
-		}
-
-		/*
-		 * %state_retention_priority
-		 */
-		operand_address = next_operand_address;
-		/*next_operand_address =*/ decode_udvm_multitype_operand(buff, operand_address, &state_retention_priority);
-		if (show_instr_detail_level == 2 ){
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u      state_retention_priority %u",
-				operand_address, state_retention_priority);
-		}
-		if (show_instr_detail_level == 1)
-		{
-			proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,
-				"Addr: %u ## END-MESSAGE (requested_feedback_location=%u, returned_parameters_location=%u, state_length=%u, state_address=%u, state_instruction=%u, minimum_access_length=%u, state_retention_priority=%u)",
-				current_address, requested_feedback_location, returned_parameters_location, state_length, state_address, state_instruction, minimum_access_length,state_retention_priority);
-		}
-		/* TODO: This isn't currently totaly correct as END_INSTRUCTION might not create state */
-		no_of_state_create++;
-		if ( no_of_state_create > 4 ){
-			result_code = 12;
-			goto decompression_failure;
-		}
-		state_length_buff[no_of_state_create] = state_length;
-		state_address_buff[no_of_state_create] = state_address;
-		state_instruction_buff[no_of_state_create] = state_instruction;
-		/* Not used ? */
-		state_minimum_access_length_buff[no_of_state_create] = minimum_access_length;
-		/* state_state_retention_priority_buff[no_of_state_create] = state_retention_priority; */
-
-		/* Execute the instruction
-		 */
-		proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"no_of_state_create %u",no_of_state_create);
-		if ( no_of_state_create != 0 ){
-			memset(sha1_digest_buf, 0, STATE_BUFFER_SIZE);
-			n = 1;
-			byte_copy_right = buff[66] << 8;
-			byte_copy_right = byte_copy_right | buff[67];
-			byte_copy_left = buff[64] << 8;
-			byte_copy_left = byte_copy_left | buff[65];
-			while ( n < no_of_state_create + 1 ){
-				sha1buff = (guint8 *)g_malloc(state_length_buff[n]+8);
-				sha1buff[0] = state_length_buff[n] >> 8;
-				sha1buff[1] = state_length_buff[n] & 0xff;
-				sha1buff[2] = state_address_buff[n] >> 8;
-				sha1buff[3] = state_address_buff[n] & 0xff;
-				sha1buff[4] = state_instruction_buff[n] >> 8;
-				sha1buff[5] = state_instruction_buff[n] & 0xff;
-				sha1buff[6] = state_minimum_access_length_buff[n] >> 8;
-				sha1buff[7] = state_minimum_access_length_buff[n] & 0xff;
-				if (print_level_3 ){
-					for( x=0; x < 8; x++){
-						proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"sha1buff %u 0x%x",
-							x,sha1buff[x]);
-					}
-				}
-				k = state_address_buff[n];
-				for( x=0; x < state_length_buff[n]; x++)
-					{
-					if ( k == byte_copy_right ){
-						k = byte_copy_left;
-					}
-					sha1buff[8+x] = buff[k];
-					k = ( k + 1 ) & 0xffff;
-					}
-
-				sha1_starts( &ctx );
-				sha1_update( &ctx, (guint8 *) sha1buff, state_length_buff[n] + 8);
-				sha1_finish( &ctx, sha1_digest_buf );
-				if (print_level_3 ){
-					proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"SHA1 digest %s", bytes_to_str(wmem_packet_scope(), sha1_digest_buf, STATE_BUFFER_SIZE));
-
-				}
+                }
 /* begin partial state-id change cco@iptel.org */
 #if 0
-				udvm_state_create(sha1buff, sha1_digest_buf, state_minimum_access_length_buff[n]);
+                udvm_state_create(sha1buff, sha1_digest_buf, state_minimum_access_length_buff[n]);
 #endif
-				udvm_state_create(sha1buff, sha1_digest_buf, STATE_MIN_ACCESS_LEN);
+                udvm_state_create(sha1buff, sha1_digest_buf, STATE_MIN_ACCESS_LEN);
 /* end partial state-id change cco@iptel.org */
-				proto_tree_add_text(udvm_tree,bytecode_tvb, 0, -1,"### Creating state ###");
-				proto_tree_add_string(udvm_tree,hf_id, bytecode_tvb, 0, 0, bytes_to_str(wmem_packet_scope(), sha1_digest_buf, STATE_MIN_ACCESS_LEN));
-
-				n++;
-
-			}
-		}
-
-
-
-		/* At least something got decompressed, show it */
-		decomp_tvb = tvb_new_child_real_data(message_tvb, out_buff,output_address,output_address);
-		/* Arrange that the allocated packet data copy be freed when the
-		 * tvbuff is freed.
-		 */
-		tvb_set_free_cb( decomp_tvb, g_free );
-
-		add_new_data_source(pinfo, decomp_tvb, "Decompressed SigComp message");
-		/*
-		proto_tree_add_text(udvm_tree, decomp_tvb, 0, -1,"SigComp message Decompressed");
-		*/
-		used_udvm_cycles = used_udvm_cycles + state_length;
-		proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"maximum_UDVM_cycles %u used_udvm_cycles %u",
-			maximum_UDVM_cycles, used_udvm_cycles);
-		return decomp_tvb;
-		break;
-
-	default:
-	    proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1," ### Addr %u Invalid instruction: %u (0x%x)",
-			current_address,current_instruction,current_instruction);
-		break;
-		}
-		g_free(out_buff);
-		return NULL;
+                proto_tree_add_text(udvm_tree,bytecode_tvb, 0, -1,"### Creating state ###");
+                proto_tree_add_string(udvm_tree,hf_id, bytecode_tvb, 0, 0, bytes_to_str(wmem_packet_scope(), sha1_digest_buf, STATE_MIN_ACCESS_LEN));
+
+                n++;
+
+            }
+        }
+
+
+
+        /* At least something got decompressed, show it */
+        decomp_tvb = tvb_new_child_real_data(message_tvb, out_buff,output_address,output_address);
+        /* Arrange that the allocated packet data copy be freed when the
+         * tvbuff is freed.
+         */
+        tvb_set_free_cb( decomp_tvb, g_free );
+
+        add_new_data_source(pinfo, decomp_tvb, "Decompressed SigComp message");
+        /*
+          proto_tree_add_text(udvm_tree, decomp_tvb, 0, -1,"SigComp message Decompressed");
+        */
+        used_udvm_cycles = used_udvm_cycles + state_length;
+        proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"maximum_UDVM_cycles %u used_udvm_cycles %u",
+                            maximum_UDVM_cycles, used_udvm_cycles);
+        return decomp_tvb;
+        break;
+
+    default:
+        proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1," ### Addr %u Invalid instruction: %u (0x%x)",
+                            current_address,current_instruction,current_instruction);
+        break;
+    }
+    g_free(out_buff);
+    return NULL;
 decompression_failure:
 
-		proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"DECOMPRESSION FAILURE: %s",
-				    val_to_str(result_code, result_code_vals,"Unknown (%u)"));
-		g_free(out_buff);
-		THROW(ReportedBoundsError);
-		return NULL;
+    proto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"DECOMPRESSION FAILURE: %s",
+                        val_to_str(result_code, result_code_vals,"Unknown (%u)"));
+    g_free(out_buff);
+    THROW(ReportedBoundsError);
+    return NULL;
 
 }
 
@@ -4359,11 +4359,11 @@ decompression_failure:
 static int
 dissect_sigcomp_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *_data _U_)
 {
-    proto_item  *ti;
-    proto_tree  *sigcomp_tree;
-    tvbuff_t    *unescaped_tvb;
+    proto_item *ti;
+    proto_tree *sigcomp_tree;
+    tvbuff_t   *unescaped_tvb;
 
-    guint8      *buff;
+    guint8     *buff;
     int         offset = 0;
     int         length;
     guint8      octet;
@@ -4376,11 +4376,11 @@ dissect_sigcomp_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *_
 
     /* Is this SIGCOMP ? */
     data = tvb_get_ntohs(tvb, offset);
-    if(data == 0xffff){
+    if (data == 0xffff) {
         /* delimiter */
         offset = offset + 2;
         octet = tvb_get_guint8(tvb,offset);
-    }else{
+    } else {
         octet = tvb_get_guint8(tvb,offset);
     }
     if ((octet  & 0xf8) != 0xf8)
@@ -4388,16 +4388,16 @@ dissect_sigcomp_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *_
 
     /* Search for delimiter 0xffff in the remain tvb buffer */
     length = tvb_ensure_length_remaining(tvb, offset);
-    for(i=0; i<(length-1); ++i){
+    for (i=0; i<(length-1); ++i) {
         /* Loop end criteria is (length-1) because we take 2 bytes each loop */
         data = tvb_get_ntohs(tvb, offset+i);
         if (0xffff == data) break;
     }
-    if (i >= (length-1)){
+    if (i >= (length-1)) {
         /* SIGCOMP may be subdissector of SIP, so we use
          * pinfo->saved_can_desegment to determine whether do desegment
          * as well as pinfo->can_desegment */
-        if (pinfo->can_desegment || pinfo->saved_can_desegment){
+        if (pinfo->can_desegment || pinfo->saved_can_desegment) {
             /* Delimiter oxffff was not found, not a complete SIGCOMP PDU */
             pinfo->desegment_offset = offset;
             pinfo->desegment_len=DESEGMENT_ONE_MORE_SEGMENT;
@@ -4421,10 +4421,10 @@ try_again:
     buff = (guint8 *)wmem_alloc(pinfo->pool, length-offset);
     if (udvm_print_detail_level>2)
         proto_tree_add_text(sigcomp_tree, tvb, offset, -1,"Starting to remove escape digits");
-    while ((offset < length) && (end_off_message == FALSE)){
+    while ((offset < length) && (end_off_message == FALSE)) {
         octet = tvb_get_guint8(tvb,offset);
-        if ( octet == 0xff ){
-            if ( offset +1 >= length ){
+        if ( octet == 0xff ) {
+            if ( offset +1 >= length ) {
                 /* if the tvb is short don't check for the second escape digit */
                 offset++;
                 continue;
@@ -4433,20 +4433,20 @@ try_again:
                 proto_tree_add_text(sigcomp_tree, tvb, offset, 2,
                     "              Escape digit found (0xFF)");
             octet = tvb_get_guint8(tvb, offset+1);
-            if ( octet == 0){
+            if ( octet == 0) {
                 buff[i] = 0xff;
                 offset = offset +2;
                 i++;
                 continue;
             }
-            if ((octet > 0x7f) && (octet < 0xff )){
+            if ((octet > 0x7f) && (octet < 0xff )) {
                 if (udvm_print_detail_level>2)
                     proto_tree_add_text(sigcomp_tree, tvb, offset, 2,
                         "              Illegal escape code");
                 offset = offset + tvb_length_remaining(tvb,offset);
                 return offset;
             }
-            if ( octet == 0xff){
+            if ( octet == 0xff) {
                 if (udvm_print_detail_level>2)
                     proto_tree_add_text(sigcomp_tree, tvb, offset, 2,
                         "              End of SigComp message indication found (0xFFFF)");
@@ -4463,10 +4463,10 @@ try_again:
             if (udvm_print_detail_level>2)
             proto_tree_add_text(sigcomp_tree, tvb, offset, octet,
                         "              Copying %u bytes literally",octet);
-            if( offset+octet >= length)
+            if ( offset+octet >= length)
                 /* if the tvb is short don't copy further than the end */
                 octet = length - offset;
-            for ( n=0; n < octet; n++ ){
+            for ( n=0; n < octet; n++ ) {
                 buff[i] = tvb_get_guint8(tvb, offset);
                 if (udvm_print_detail_level>2)
                     proto_tree_add_text(sigcomp_tree, tvb, offset, 1,
@@ -4489,12 +4489,12 @@ try_again:
     add_new_data_source(pinfo, unescaped_tvb, "Unescaped Data handed to the SigComp dissector");
 
     proto_tree_add_text(sigcomp_tree, unescaped_tvb, 0, -1,"Data handed to the Sigcomp dissector");
-    if (end_off_message == TRUE){
+    if (end_off_message == TRUE) {
         dissect_sigcomp_common(unescaped_tvb, pinfo, sigcomp_tree);
-    }else{
+    } else {
         proto_tree_add_text(sigcomp_tree, unescaped_tvb, 0, -1,"TCP Fragment, no end mark found");
     }
-    if ( offset < length){
+    if ( offset < length) {
         goto try_again;
     }
 
@@ -4504,8 +4504,8 @@ try_again:
 static int
 dissect_sigcomp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)
 {
-    proto_item  *ti;
-    proto_tree  *sigcomp_tree;
+    proto_item *ti;
+    proto_tree *sigcomp_tree;
     gint        offset = 0;
     gint8       octet;
 
@@ -4537,22 +4537,22 @@ dissect_sigcomp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sigcomp_tr
 {
 
 /* Set up structures needed to add the protocol subtree and manage it */
-    tvbuff_t    *udvm_tvb, *msg_tvb, *udvm2_tvb;
-    tvbuff_t    *decomp_tvb = NULL;
-    proto_item  *udvm_bytecode_item, *udvm_exe_item;
-    proto_tree  *sigcomp_udvm_tree, *sigcomp_udvm_exe_tree;
-    gint        offset = 0;
+    tvbuff_t   *udvm_tvb, *msg_tvb, *udvm2_tvb;
+    tvbuff_t   *decomp_tvb   = NULL;
+    proto_item *udvm_bytecode_item, *udvm_exe_item;
+    proto_tree *sigcomp_udvm_tree, *sigcomp_udvm_exe_tree;
+    gint        offset       = 0;
     gint        bytecode_offset;
     guint16     partial_state_len;
     guint       octet;
     guint8      returned_feedback_field[128];
     guint8      partial_state[12];
     guint       tbit;
-    guint16     len = 0;
+    guint16     len          = 0;
     guint16     bytecode_len = 0;
     guint       destination;
-    gint        msg_len = 0;
-    guint8      *buff;
+    gint        msg_len      = 0;
+    guint8     *buff;
     guint16     p_id_start;
     guint8      i;
     guint16     state_begin;
@@ -4560,7 +4560,7 @@ dissect_sigcomp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sigcomp_tr
     guint16     state_address;
     guint16     state_instruction;
     guint16     result_code;
-    gchar       *partial_state_str;
+    gchar      *partial_state_str;
     guint8      nack_version;
 
 
@@ -4634,7 +4634,7 @@ dissect_sigcomp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sigcomp_tr
     tbit = ( octet & 0x04)>>2;
     partial_state_len = octet & 0x03;
     offset ++;
-    if ( partial_state_len != 0 ){
+    if ( partial_state_len != 0 ) {
         /*
          * The len field encodes the number of transmitted bytes as follows:
          *
@@ -4669,7 +4669,7 @@ dissect_sigcomp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sigcomp_tr
              * Figure 4: Format of returned feedback item
              */
 
-            if ( (octet & 0x80) != 0 ){
+            if ( (octet & 0x80) != 0 ) {
                 len = octet & 0x7f;
                 proto_tree_add_item(sigcomp_tree,hf_sigcomp_returned_feedback_item_len,
                                     tvb, offset, 1, ENC_BIG_ENDIAN);
@@ -4689,7 +4689,7 @@ dissect_sigcomp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sigcomp_tr
         offset = offset + partial_state_len;
         msg_len = tvb_reported_length_remaining(tvb, offset);
 
-        if(msg_len>0){
+        if (msg_len>0) {
             proto_item *ti;
             ti = proto_tree_add_uint(sigcomp_tree, hf_sigcomp_remaining_message_bytes, tvb,
                                      offset, 0, msg_len);
@@ -4723,7 +4723,7 @@ dissect_sigcomp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sigcomp_tr
             state_instruction =0;
 
             i = 0;
-            while ( i < partial_state_len ){
+            while ( i < partial_state_len ) {
                 buff[i] = partial_state[i];
                 i++;
             }
@@ -4737,7 +4737,7 @@ dissect_sigcomp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sigcomp_tr
                 &state_address, &state_instruction, hf_sigcomp_partial_state);
 
 /* end partial state-id change cco@iptel.org */
-            if ( result_code != 0 ){
+            if ( result_code != 0 ) {
                 proto_item *ti;
                 ti = proto_tree_add_text(sigcomp_tree, tvb, 0, -1,"Failed to Access state Wireshark UDVM diagnostic: %s.",
                                          val_to_str(result_code, result_code_vals,"Unknown (%u)"));
@@ -4760,7 +4760,7 @@ dissect_sigcomp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sigcomp_tr
                            offset, state_length, partial_state_len, state_instruction);
 
 
-            if ( decomp_tvb ){
+            if ( decomp_tvb ) {
                 proto_item *ti;
                 guint32 compression_ratio =
                     (guint32)(((float)tvb_length(decomp_tvb) / (float)tvb_length(tvb)) * 100);
@@ -4792,7 +4792,7 @@ dissect_sigcomp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sigcomp_tr
              */
             len = 1;
             octet = tvb_get_guint8(tvb, offset);
-            if ( (octet & 0x80) != 0 ){
+            if ( (octet & 0x80) != 0 ) {
                 len = octet & 0x7f;
                 proto_tree_add_item(sigcomp_tree,hf_sigcomp_returned_feedback_item_len,
                                     tvb, offset, 1, ENC_BIG_ENDIAN);
@@ -4805,7 +4805,7 @@ dissect_sigcomp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sigcomp_tr
         }
         len = tvb_get_ntohs(tvb, offset) >> 4;
         nack_version = tvb_get_guint8(tvb, offset+1) & 0x0f;
-        if ((len == 0) && (nack_version == 1)){
+        if ((len == 0) && (nack_version == 1)) {
             /* NACK MESSAGE */
             proto_item *reason_ti;
             guint8 opcode;
@@ -4835,7 +4835,7 @@ dissect_sigcomp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sigcomp_tr
                             val_to_str_ext_const(octet, &sigcomp_nack_reason_code_vals_ext, "Unknown"),
                             val_to_str_ext_const(opcode, &udvm_instruction_code_vals_ext, "Unknown"));
 
-            switch ( octet){
+            switch ( octet) {
             case SIGCOMP_NACK_STATE_NOT_FOUND:
             case SIGCOMP_NACK_ID_NOT_UNIQUE:
             case SIGCOMP_NACK_STATE_TOO_SHORT:
@@ -4853,7 +4853,7 @@ dissect_sigcomp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sigcomp_tr
             default:
                 break;
             }
-        }else{
+        } else {
             octet = tvb_get_guint8(tvb, (offset + 1));
             destination = (octet & 0x0f);
             if ( destination != 0 )
@@ -4882,7 +4882,7 @@ dissect_sigcomp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sigcomp_tr
                                                      tvb_reported_length_remaining(tvb, offset));
                 PROTO_ITEM_SET_GENERATED(ti);
             }
-            if ( decompress ){
+            if ( decompress ) {
 
                 msg_tvb = tvb_new_subset_length(tvb, offset, msg_len);
 
@@ -4894,7 +4894,7 @@ dissect_sigcomp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sigcomp_tr
                            sigcomp_udvm_exe_tree, destination,
                            udvm_print_detail_level, hf_sigcomp_partial_state,
                            offset, 0, 0, destination);
-                if ( decomp_tvb ){
+                if ( decomp_tvb ) {
                     proto_item *ti;
                     guint32 compression_ratio =
                         (guint32)(((float)tvb_length(decomp_tvb) / (float)tvb_length(tvb)) * 100);
@@ -4961,17 +4961,17 @@ dissect_sigcomp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sigcomp_tr
 static void
 dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint start_address)
 {
-    guint instruction;
-    gint offset = 0;
-    gint start_offset = 0;
-    gint len;
-    gint n;
-    guint instruction_no = 0;
-    guint16 value = 0;
+    guint       instruction;
+    gint        offset         = 0;
+    gint        start_offset   = 0;
+    gint        len;
+    gint        n;
+    guint       instruction_no = 0;
+    guint16     value          = 0;
     proto_item *item, *item2;
-    guint UDVM_address = start_address;
-    gboolean is_memory_address;
-    guint16 msg_length = tvb_reported_length_remaining(udvm_tvb, offset);
+    guint       UDVM_address   = start_address;
+    gboolean    is_memory_address;
+    guint16     msg_length     = tvb_reported_length_remaining(udvm_tvb, offset);
 
 
     while (msg_length > offset) {
@@ -4997,10 +4997,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %operand_2*/
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2_addr,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5015,10 +5015,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %operand_2*/
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2_addr,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5041,10 +5041,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %operand_2*/
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2_addr,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5059,10 +5059,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %operand_2*/
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2_addr,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5077,10 +5077,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %operand_2*/
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2_addr,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5095,10 +5095,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %operand_2*/
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2_addr,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5113,10 +5113,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %operand_2*/
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2_addr,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5131,10 +5131,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %operand_2*/
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2_addr,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5149,10 +5149,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %operand_2*/
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2_addr,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5175,10 +5175,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /*  %length, */
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_length,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_length,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5199,10 +5199,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %value */
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_value,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_value,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5225,10 +5225,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
                 /* %value */
                 offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
                 len = offset - start_offset;
-                if ( is_memory_address ){
+                if ( is_memory_address ) {
                     proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_value,
                         udvm_tvb, start_offset, len, value);
-                }else{
+                } else {
                     proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_value,
                         udvm_tvb, start_offset, len, value);
                 }
@@ -5239,10 +5239,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %value */
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_value,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_value,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5267,10 +5267,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /*  %length, */
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_length,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_length,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5292,10 +5292,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /*  %length, */
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_length,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_length,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5311,10 +5311,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %offset */
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_offset,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_offset,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5322,10 +5322,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /*  %length, */
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_length,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_length,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5347,10 +5347,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /*  %length, */
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE, &start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_length,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_length,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5385,10 +5385,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %value_1 */
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_value,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_value,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5396,10 +5396,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %value_2 */
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_value,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_value,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5454,10 +5454,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %j */
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_j,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_j,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5477,10 +5477,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %value */
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_value,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_value,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5494,10 +5494,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %length */
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_length,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_length,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5516,10 +5516,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %length */
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_length,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_length,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5527,10 +5527,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %destination */
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_destination,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_destination,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5547,10 +5547,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %length */
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_length,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_length,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5558,10 +5558,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %destination */
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_destination,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_destination,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5583,10 +5583,10 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /* %destination */
             offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);
             len = offset - start_offset;
-            if ( is_memory_address ){
+            if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_destination,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_destination,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5664,7 +5664,7 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_length_addr,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_length,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5676,7 +5676,7 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_address_addr,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_address,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5702,7 +5702,7 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_length_addr,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_length,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5714,7 +5714,7 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_address_addr,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_address,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5770,7 +5770,7 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_output_start,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_output_start,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5782,7 +5782,7 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_output_length_addr,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_output_length,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5795,7 +5795,7 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
              * %state_retention_priority)
              */
             /* %requested_feedback_location */
-            if ((msg_length-1) < offset){
+            if ((msg_length-1) < offset) {
                 item2 = proto_tree_add_text(sigcomp_udvm_tree, udvm_tvb, 0, -1,
                         "All remaining parameters = 0(Not in the uploaded code as UDVM buffer initialized to Zero");
                 PROTO_ITEM_SET_GENERATED(item2);
@@ -5806,7 +5806,7 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_req_feedback_loc,
                 udvm_tvb, start_offset, len, value);
             /* returned_parameters_location */
-            if ((msg_length-1) < offset){
+            if ((msg_length-1) < offset) {
                 item2 = proto_tree_add_text(sigcomp_udvm_tree, udvm_tvb, offset-1, -1,
                         "All remaining parameters = 0(Not in the uploaded code as UDVM buffer initialized to Zero");
                 PROTO_ITEM_SET_GENERATED(item2);
@@ -5824,7 +5824,7 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_length_addr,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_length,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5836,7 +5836,7 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             if ( is_memory_address ) {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_address_addr,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_address,
                     udvm_tvb, start_offset, len, value);
             }
@@ -5857,17 +5857,17 @@ dissect_udvm_bytecode(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,guint st
             /*
              * %state_retention_priority
              */
-            if ( tvb_reported_length_remaining(udvm_tvb, offset) != 0 ){
+            if ( tvb_reported_length_remaining(udvm_tvb, offset) != 0 ) {
                 offset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);
                 len = offset - start_offset;
                 proto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_ret_pri,
                     udvm_tvb, start_offset, len, value);
-            }else{
+            } else {
                 item2 = proto_tree_add_text(sigcomp_udvm_tree, udvm_tvb, offset, 1,
                         "state_retention_priority = 0(Not in the uploaded code as UDVM buffer initialized to Zero");
                 PROTO_ITEM_SET_GENERATED(item2);
             }
-            if ( tvb_reported_length_remaining(udvm_tvb, offset) != 0 ){
+            if ( tvb_reported_length_remaining(udvm_tvb, offset) != 0 ) {
                 len = tvb_reported_length_remaining(udvm_tvb, offset);
                 UDVM_address = start_address + offset;
                 proto_tree_add_text(sigcomp_udvm_tree, udvm_tvb, offset, len,
@@ -5900,16 +5900,16 @@ static int
 dissect_udvm_literal_operand(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,
                                gint offset, gint *start_offset, guint16 *value)
 {
-    guint bytecode;
+    guint   bytecode;
     guint16 operand;
-    guint test_bits;
-    guint display_bytecode;
+    guint   test_bits;
+    guint   display_bytecode;
 
     bytecode = tvb_get_guint8(udvm_tvb, offset);
     test_bits = bytecode >> 7;
-    if (test_bits == 1){
+    if (test_bits == 1) {
         test_bits = bytecode >> 6;
-        if (test_bits == 2){
+        if (test_bits == 2) {
             /*
              * 10nnnnnn nnnnnnnn               N                   0 - 16383
              */
@@ -5922,7 +5922,7 @@ dissect_udvm_literal_operand(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,
             *start_offset = offset;
             offset = offset + 2;
 
-        }else{
+        } else {
             /*
              * 111000000 nnnnnnnn nnnnnnnn      N                   0 - 65535
              */
@@ -5937,7 +5937,7 @@ dissect_udvm_literal_operand(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,
             offset = offset + 2;
 
         }
-    }else{
+    } else {
         /*
          * 0nnnnnnn                        N                   0 - 127
          */
@@ -5972,16 +5972,16 @@ static int
 dissect_udvm_reference_operand(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,
                                gint offset, gint *start_offset, guint16 *value)
 {
-    guint bytecode;
+    guint   bytecode;
     guint16 operand;
-    guint test_bits;
-    guint display_bytecode;
+    guint   test_bits;
+    guint   display_bytecode;
 
     bytecode = tvb_get_guint8(udvm_tvb, offset);
     test_bits = bytecode >> 7;
-    if (test_bits == 1){
+    if (test_bits == 1) {
         test_bits = bytecode >> 6;
-        if (test_bits == 2){
+        if (test_bits == 2) {
             /*
              * 10nnnnnn nnnnnnnn               memory[2 * N]       0 - 65535
              */
@@ -5994,7 +5994,7 @@ dissect_udvm_reference_operand(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree
             *start_offset = offset;
             offset = offset + 2;
 
-        }else{
+        } else {
             /*
              * 11000000 nnnnnnnn nnnnnnnn      memory[N]           0 - 65535
              */
@@ -6009,7 +6009,7 @@ dissect_udvm_reference_operand(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree
             offset = offset + 2;
 
         }
-    }else{
+    } else {
         /*
          * 0nnnnnnn                        memory[2 * N]       0 - 65535
          */
@@ -6063,7 +6063,7 @@ dissect_udvm_multitype_operand(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree
     *is_memory_address = FALSE;
     bytecode = tvb_get_guint8(udvm_tvb, offset);
     test_bits = ( bytecode & 0xc0 ) >> 6;
-    switch (test_bits ){
+    switch (test_bits ) {
     case 0:
         /*
          * 00nnnnnn                        N                   0 - 63
@@ -6094,7 +6094,7 @@ dissect_udvm_multitype_operand(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree
     case 2:
         /* Check tree most significant bits */
         test_bits = ( bytecode & 0xe0 ) >> 5;
-        if ( test_bits == 5 ){
+        if ( test_bits == 5 ) {
         /*
          * 101nnnnn nnnnnnnn               N                   0 - 8191
          */
@@ -6106,9 +6106,9 @@ dissect_udvm_multitype_operand(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree
             *value = operand;
             *start_offset = offset;
             offset = offset + 2;
-        }else{
+        } else {
             test_bits = ( bytecode & 0xf0 ) >> 4;
-            if ( test_bits == 9 ){
+            if ( test_bits == 9 ) {
         /*
          * 1001nnnn nnnnnnnn               N + 61440       61440 - 65535
          */
@@ -6120,9 +6120,9 @@ dissect_udvm_multitype_operand(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree
                 *start_offset = offset;
                 *value = operand;
                 offset = offset + 2;
-            }else{
+            } else {
                 test_bits = ( bytecode & 0x08 ) >> 3;
-                if ( test_bits == 1){
+                if ( test_bits == 1) {
         /*
          * 10001nnn                        2 ^ (N + 8)    256 , ... , 32768
          */
@@ -6135,9 +6135,9 @@ dissect_udvm_multitype_operand(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree
                     *start_offset = offset;
                     *value = operand;
                     offset ++;
-                }else{
+                } else {
                     test_bits = ( bytecode & 0x0e ) >> 1;
-                    if ( test_bits == 3 ){
+                    if ( test_bits == 3 ) {
                         /*
                          * 1000 011n                        2 ^ (N + 6)        64 , 128
                          */
@@ -6150,7 +6150,7 @@ dissect_udvm_multitype_operand(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree
                         *start_offset = offset;
                         *value = operand;
                         offset ++;
-                    }else{
+                    } else {
                     /*
                      * 1000 0000 nnnnnnnn nnnnnnnn      N                   0 - 65535
                      * 1000 0001 nnnnnnnn nnnnnnnn      memory[N]           0 - 65535
@@ -6176,7 +6176,7 @@ dissect_udvm_multitype_operand(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree
 
     case 3:
         test_bits = ( bytecode & 0x20 ) >> 5;
-        if ( test_bits == 1 ){
+        if ( test_bits == 1 ) {
         /*
          * 111nnnnn                        N + 65504       65504 - 65535
          */
@@ -6188,7 +6188,7 @@ dissect_udvm_multitype_operand(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree
             *start_offset = offset;
             *value = operand;
             offset ++;
-        }else{
+        } else {
         /*
          * 110nnnnn nnnnnnnn               memory[N]           0 - 65535
          */
@@ -6216,7 +6216,7 @@ tvb_raw_text_add(tvbuff_t *tvb, proto_tree *tree)
     proto_item *ti = NULL;
     int offset, next_offset, linelen;
 
-    if(tree) {
+    if (tree) {
         ti = proto_tree_add_item(tree, proto_raw_sigcomp, tvb, 0, -1, ENC_NA);
         raw_tree = proto_item_add_subtree(ti, ett_raw_text);
     }
@@ -6662,7 +6662,7 @@ proto_reg_handoff_sigcomp(void)
 {
     static dissector_handle_t sigcomp_handle;
     static dissector_handle_t sigcomp_tcp_handle;
-    static gboolean Initialized=FALSE;
+    static gboolean Initialized = FALSE;
     static guint udp_port1;
     static guint udp_port2;
     static guint tcp_port1;
@@ -6673,7 +6673,7 @@ proto_reg_handoff_sigcomp(void)
         sigcomp_tcp_handle = new_create_dissector_handle(dissect_sigcomp_tcp,proto_sigcomp);
         sip_handle = find_dissector("sip");
         Initialized=TRUE;
-    }else{
+    } else {
         dissector_delete_uint("udp.port", udp_port1, sigcomp_handle);
         dissector_delete_uint("udp.port", udp_port2, sigcomp_handle);
         dissector_delete_uint("tcp.port", tcp_port1, sigcomp_tcp_handle);
diff --git a/epan/dissectors/packet-srvloc.c b/epan/dissectors/packet-srvloc.c
index f3b1c3d1eb..9cdb9503ee 100644
--- a/epan/dissectors/packet-srvloc.c
+++ b/epan/dissectors/packet-srvloc.c
@@ -367,7 +367,7 @@ dissect_authblk(tvbuff_t *tvb, int offset, proto_tree *tree)
 {
     guint16     length;
 
-	proto_tree_add_item(tree, hf_srvloc_timestamp, tvb, offset, 8, ENC_TIME_NTP|ENC_BIG_ENDIAN);
+    proto_tree_add_item(tree, hf_srvloc_timestamp, tvb, offset, 8, ENC_TIME_NTP|ENC_BIG_ENDIAN);
     proto_tree_add_item(tree, hf_srvloc_block_structure_descriptor, tvb, offset + 8, 2, ENC_BIG_ENDIAN);
     length = tvb_get_ntohs(tvb, offset + 10);
     proto_tree_add_item(tree, hf_srvloc_authenticator_length, tvb, offset + 10, 2, ENC_BIG_ENDIAN);
diff --git a/epan/jsmn/jsmn.c b/epan/jsmn/jsmn.c
index acdd2c8b44..30014239ea 100644
--- a/epan/jsmn/jsmn.c
+++ b/epan/jsmn/jsmn.c
@@ -28,18 +28,18 @@
  * Allocates a fresh unused token from the token pull.
  */
 static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser,
-		jsmntok_t *tokens, size_t num_tokens) {
-	jsmntok_t *tok;
-	if (parser->toknext >= num_tokens) {
-		return NULL;
-	}
-	tok = &tokens[parser->toknext++];
-	tok->start = tok->end = -1;
-	tok->size = 0;
+                                   jsmntok_t *tokens, size_t num_tokens) {
+    jsmntok_t *tok;
+    if (parser->toknext >= num_tokens) {
+        return NULL;
+    }
+    tok = &tokens[parser->toknext++];
+    tok->start = tok->end = -1;
+    tok->size = 0;
 #ifdef JSMN_PARENT_LINKS
-	tok->parent = -1;
+    tok->parent = -1;
 #endif
-	return tok;
+    return tok;
 }
 
 /**
@@ -47,278 +47,278 @@ static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser,
  */
 static void jsmn_fill_token(jsmntok_t *token, jsmntype_t type,
                             int start, int end) {
-	token->type = type;
-	token->start = start;
-	token->end = end;
-	token->size = 0;
+    token->type = type;
+    token->start = start;
+    token->end = end;
+    token->size = 0;
 }
 
 /**
  * Fills next available token with JSON primitive.
  */
 static int jsmn_parse_primitive(jsmn_parser *parser, const char *js,
-		size_t len, jsmntok_t *tokens, size_t num_tokens) {
-	jsmntok_t *token;
-	int start;
+        size_t len, jsmntok_t *tokens, size_t num_tokens) {
+    jsmntok_t *token;
+    int start;
 
-	start = parser->pos;
+    start = parser->pos;
 
-	for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
-		switch (js[parser->pos]) {
+    for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
+        switch (js[parser->pos]) {
 #ifndef JSMN_STRICT
-			/* In strict mode primitive must be followed by "," or "}" or "]" */
-			case ':':
+            /* In strict mode primitive must be followed by "," or "}" or "]" */
+            case ':':
 #endif
-			case '\t' : case '\r' : case '\n' : case ' ' :
-			case ','  : case ']'  : case '}' :
-				goto found;
-		}
-		if (js[parser->pos] < 32 || js[parser->pos] >= 127) {
-			parser->pos = start;
-			return JSMN_ERROR_INVAL;
-		}
-	}
+            case '\t' : case '\r' : case '\n' : case ' ' :
+            case ','  : case ']'  : case '}' :
+                goto found;
+        }
+        if (js[parser->pos] < 32 || js[parser->pos] >= 127) {
+            parser->pos = start;
+            return JSMN_ERROR_INVAL;
+        }
+    }
 #ifdef JSMN_STRICT
-	/* In strict mode primitive must be followed by a comma/object/array */
-	parser->pos = start;
-	return JSMN_ERROR_PART;
+    /* In strict mode primitive must be followed by a comma/object/array */
+    parser->pos = start;
+    return JSMN_ERROR_PART;
 #endif
 
 found:
-	if (tokens == NULL) {
-		parser->pos--;
-		return 0;
-	}
-	token = jsmn_alloc_token(parser, tokens, num_tokens);
-	if (token == NULL) {
-		parser->pos = start;
-		return JSMN_ERROR_NOMEM;
-	}
-	jsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);
+    if (tokens == NULL) {
+        parser->pos--;
+        return 0;
+    }
+    token = jsmn_alloc_token(parser, tokens, num_tokens);
+    if (token == NULL) {
+        parser->pos = start;
+        return JSMN_ERROR_NOMEM;
+    }
+    jsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);
 #ifdef JSMN_PARENT_LINKS
-	token->parent = parser->toksuper;
+    token->parent = parser->toksuper;
 #endif
-	parser->pos--;
-	return 0;
+    parser->pos--;
+    return 0;
 }
 
 /**
  * Filsl next token with JSON string.
  */
 static int jsmn_parse_string(jsmn_parser *parser, const char *js,
-		size_t len, jsmntok_t *tokens, size_t num_tokens) {
-	jsmntok_t *token;
+        size_t len, jsmntok_t *tokens, size_t num_tokens) {
+    jsmntok_t *token;
 
-	int start = parser->pos;
+    int start = parser->pos;
 
-	parser->pos++;
+    parser->pos++;
 
-	/* Skip starting quote */
-	for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
-		char c = js[parser->pos];
+    /* Skip starting quote */
+    for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
+        char c = js[parser->pos];
 
-		/* Quote: end of string */
-		if (c == '\"') {
-			if (tokens == NULL) {
-				return 0;
-			}
-			token = jsmn_alloc_token(parser, tokens, num_tokens);
-			if (token == NULL) {
-				parser->pos = start;
-				return JSMN_ERROR_NOMEM;
-			}
-			jsmn_fill_token(token, JSMN_STRING, start+1, parser->pos);
+        /* Quote: end of string */
+        if (c == '\"') {
+            if (tokens == NULL) {
+                return 0;
+            }
+            token = jsmn_alloc_token(parser, tokens, num_tokens);
+            if (token == NULL) {
+                parser->pos = start;
+                return JSMN_ERROR_NOMEM;
+            }
+            jsmn_fill_token(token, JSMN_STRING, start+1, parser->pos);
 #ifdef JSMN_PARENT_LINKS
-			token->parent = parser->toksuper;
+            token->parent = parser->toksuper;
 #endif
-			return 0;
-		}
+            return 0;
+        }
 
-		/* Backslash: Quoted symbol expected */
-		if (c == '\\' && parser->pos + 1 < len) {
-			int i;
-			parser->pos++;
-			switch (js[parser->pos]) {
-				/* Allowed escaped symbols */
-				case '\"': case '/' : case '\\' : case 'b' :
-				case 'f' : case 'r' : case 'n'  : case 't' :
-					break;
-				/* Allows escaped symbol \uXXXX */
-				case 'u':
-					parser->pos++;
-					for(i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\0'; i++) {
-						/* If it isn't a hex character we have an error */
-						if(!((js[parser->pos] >= 48 && js[parser->pos] <= 57) || /* 0-9 */
-									(js[parser->pos] >= 65 && js[parser->pos] <= 70) || /* A-F */
-									(js[parser->pos] >= 97 && js[parser->pos] <= 102))) { /* a-f */
-							parser->pos = start;
-							return JSMN_ERROR_INVAL;
-						}
-						parser->pos++;
-					}
-					parser->pos--;
-					break;
-				/* Unexpected symbol */
-				default:
-					parser->pos = start;
-					return JSMN_ERROR_INVAL;
-			}
-		}
-	}
-	parser->pos = start;
-	return JSMN_ERROR_PART;
+        /* Backslash: Quoted symbol expected */
+        if (c == '\\' && parser->pos + 1 < len) {
+            int i;
+            parser->pos++;
+            switch (js[parser->pos]) {
+                /* Allowed escaped symbols */
+                case '\"': case '/' : case '\\' : case 'b' :
+                case 'f' : case 'r' : case 'n'  : case 't' :
+                    break;
+                /* Allows escaped symbol \uXXXX */
+                case 'u':
+                    parser->pos++;
+                    for(i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\0'; i++) {
+                        /* If it isn't a hex character we have an error */
+                        if(!((js[parser->pos] >= 48 && js[parser->pos] <= 57) || /* 0-9 */
+                                    (js[parser->pos] >= 65 && js[parser->pos] <= 70) || /* A-F */
+                                    (js[parser->pos] >= 97 && js[parser->pos] <= 102))) { /* a-f */
+                            parser->pos = start;
+                            return JSMN_ERROR_INVAL;
+                        }
+                        parser->pos++;
+                    }
+                    parser->pos--;
+                    break;
+                /* Unexpected symbol */
+                default:
+                    parser->pos = start;
+                    return JSMN_ERROR_INVAL;
+            }
+        }
+    }
+    parser->pos = start;
+    return JSMN_ERROR_PART;
 }
 
 /**
  * Parse JSON string and fill tokens.
  */
 int jsmn_parse(jsmn_parser *parser, const char *js, size_t len,
-		jsmntok_t *tokens, unsigned int num_tokens) {
-	int r;
-	int i;
-	jsmntok_t *token;
-	int count = 0;
+        jsmntok_t *tokens, unsigned int num_tokens) {
+    int r;
+    int i;
+    jsmntok_t *token;
+    int count = 0;
 
-	for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
-		char c;
-		jsmntype_t type;
+    for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
+        char c;
+        jsmntype_t type;
 
-		c = js[parser->pos];
-		switch (c) {
-			case '{': case '[':
-				count++;
-				if (tokens == NULL) {
-					break;
-				}
-				token = jsmn_alloc_token(parser, tokens, num_tokens);
-				if (token == NULL)
-					return JSMN_ERROR_NOMEM;
-				if (parser->toksuper != -1) {
-					tokens[parser->toksuper].size++;
+        c = js[parser->pos];
+        switch (c) {
+            case '{': case '[':
+                count++;
+                if (tokens == NULL) {
+                    break;
+                }
+                token = jsmn_alloc_token(parser, tokens, num_tokens);
+                if (token == NULL)
+                    return JSMN_ERROR_NOMEM;
+                if (parser->toksuper != -1) {
+                    tokens[parser->toksuper].size++;
 #ifdef JSMN_PARENT_LINKS
-					token->parent = parser->toksuper;
+                    token->parent = parser->toksuper;
 #endif
-				}
-				token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);
-				token->start = parser->pos;
-				parser->toksuper = parser->toknext - 1;
-				break;
-			case '}': case ']':
-				if (tokens == NULL)
-					break;
-				type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
+                }
+                token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);
+                token->start = parser->pos;
+                parser->toksuper = parser->toknext - 1;
+                break;
+            case '}': case ']':
+                if (tokens == NULL)
+                    break;
+                type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
 #ifdef JSMN_PARENT_LINKS
-				if (parser->toknext < 1) {
-					return JSMN_ERROR_INVAL;
-				}
-				token = &tokens[parser->toknext - 1];
-				for (;;) {
-					if (token->start != -1 && token->end == -1) {
-						if (token->type != type) {
-							return JSMN_ERROR_INVAL;
-						}
-						token->end = parser->pos + 1;
-						parser->toksuper = token->parent;
-						break;
-					}
-					if (token->parent == -1) {
-						break;
-					}
-					token = &tokens[token->parent];
-				}
+                if (parser->toknext < 1) {
+                    return JSMN_ERROR_INVAL;
+                }
+                token = &tokens[parser->toknext - 1];
+                for (;;) {
+                    if (token->start != -1 && token->end == -1) {
+                        if (token->type != type) {
+                            return JSMN_ERROR_INVAL;
+                        }
+                        token->end = parser->pos + 1;
+                        parser->toksuper = token->parent;
+                        break;
+                    }
+                    if (token->parent == -1) {
+                        break;
+                    }
+                    token = &tokens[token->parent];
+                }
 #else
-				for (i = parser->toknext - 1; i >= 0; i--) {
-					token = &tokens[i];
-					if (token->start != -1 && token->end == -1) {
-						if (token->type != type) {
-							return JSMN_ERROR_INVAL;
-						}
-						parser->toksuper = -1;
-						token->end = parser->pos + 1;
-						break;
-					}
-				}
-				/* Error if unmatched closing bracket */
-				if (i == -1) return JSMN_ERROR_INVAL;
-				for (; i >= 0; i--) {
-					token = &tokens[i];
-					if (token->start != -1 && token->end == -1) {
-						parser->toksuper = i;
-						break;
-					}
-				}
+                for (i = parser->toknext - 1; i >= 0; i--) {
+                    token = &tokens[i];
+                    if (token->start != -1 && token->end == -1) {
+                        if (token->type != type) {
+                            return JSMN_ERROR_INVAL;
+                        }
+                        parser->toksuper = -1;
+                        token->end = parser->pos + 1;
+                        break;
+                    }
+                }
+                /* Error if unmatched closing bracket */
+                if (i == -1) return JSMN_ERROR_INVAL;
+                for (; i >= 0; i--) {
+                    token = &tokens[i];
+                    if (token->start != -1 && token->end == -1) {
+                        parser->toksuper = i;
+                        break;
+                    }
+                }
 #endif
-				break;
-			case '\"':
-				r = jsmn_parse_string(parser, js, len, tokens, num_tokens);
-				if (r < 0) return r;
-				count++;
-				if (parser->toksuper != -1 && tokens != NULL)
-					tokens[parser->toksuper].size++;
-				break;
-			case '\t' : case '\r' : case '\n' : case ' ':
-				break;
-			case ':':
-				parser->toksuper = parser->toknext - 1;
-				break;
-			case ',':
-				if (tokens != NULL && parser->toksuper != -1 &&
-						tokens[parser->toksuper].type != JSMN_ARRAY &&
-						tokens[parser->toksuper].type != JSMN_OBJECT) {
+                break;
+            case '\"':
+                r = jsmn_parse_string(parser, js, len, tokens, num_tokens);
+                if (r < 0) return r;
+                count++;
+                if (parser->toksuper != -1 && tokens != NULL)
+                    tokens[parser->toksuper].size++;
+                break;
+            case '\t' : case '\r' : case '\n' : case ' ':
+                break;
+            case ':':
+                parser->toksuper = parser->toknext - 1;
+                break;
+            case ',':
+                if (tokens != NULL && parser->toksuper != -1 &&
+                        tokens[parser->toksuper].type != JSMN_ARRAY &&
+                        tokens[parser->toksuper].type != JSMN_OBJECT) {
 #ifdef JSMN_PARENT_LINKS
-					parser->toksuper = tokens[parser->toksuper].parent;
+                    parser->toksuper = tokens[parser->toksuper].parent;
 #else
-					for (i = parser->toknext - 1; i >= 0; i--) {
-						if (tokens[i].type == JSMN_ARRAY || tokens[i].type == JSMN_OBJECT) {
-							if (tokens[i].start != -1 && tokens[i].end == -1) {
-								parser->toksuper = i;
-								break;
-							}
-						}
-					}
+                    for (i = parser->toknext - 1; i >= 0; i--) {
+                        if (tokens[i].type == JSMN_ARRAY || tokens[i].type == JSMN_OBJECT) {
+                            if (tokens[i].start != -1 && tokens[i].end == -1) {
+                                parser->toksuper = i;
+                                break;
+                            }
+                        }
+                    }
 #endif
-				}
-				break;
+                }
+                break;
 #ifdef JSMN_STRICT
-			/* In strict mode primitives are: numbers and booleans */
-			case '-': case '0': case '1' : case '2': case '3' : case '4':
-			case '5': case '6': case '7' : case '8': case '9':
-			case 't': case 'f': case 'n' :
-				/* And they must not be keys of the object */
-				if (tokens != NULL && parser->toksuper != -1) {
-					jsmntok_t *t = &tokens[parser->toksuper];
-					if (t->type == JSMN_OBJECT ||
-							(t->type == JSMN_STRING && t->size != 0)) {
-						return JSMN_ERROR_INVAL;
-					}
-				}
+            /* In strict mode primitives are: numbers and booleans */
+            case '-': case '0': case '1' : case '2': case '3' : case '4':
+            case '5': case '6': case '7' : case '8': case '9':
+            case 't': case 'f': case 'n' :
+                /* And they must not be keys of the object */
+                if (tokens != NULL && parser->toksuper != -1) {
+                    jsmntok_t *t = &tokens[parser->toksuper];
+                    if (t->type == JSMN_OBJECT ||
+                            (t->type == JSMN_STRING && t->size != 0)) {
+                        return JSMN_ERROR_INVAL;
+                    }
+                }
 #else
-			/* In non-strict mode every unquoted value is a primitive */
-			default:
+            /* In non-strict mode every unquoted value is a primitive */
+            default:
 #endif
-				r = jsmn_parse_primitive(parser, js, len, tokens, num_tokens);
-				if (r < 0) return r;
-				count++;
-				if (parser->toksuper != -1 && tokens != NULL)
-					tokens[parser->toksuper].size++;
-				break;
+                r = jsmn_parse_primitive(parser, js, len, tokens, num_tokens);
+                if (r < 0) return r;
+                count++;
+                if (parser->toksuper != -1 && tokens != NULL)
+                    tokens[parser->toksuper].size++;
+                break;
 
 #ifdef JSMN_STRICT
-			/* Unexpected char in strict mode */
-			default:
-				return JSMN_ERROR_INVAL;
+            /* Unexpected char in strict mode */
+            default:
+                return JSMN_ERROR_INVAL;
 #endif
-		}
-	}
+        }
+    }
 
-	for (i = parser->toknext - 1; i >= 0; i--) {
-		/* Unmatched opened object or array */
-		if (tokens[i].start != -1 && tokens[i].end == -1) {
-			return JSMN_ERROR_PART;
-		}
-	}
+    for (i = parser->toknext - 1; i >= 0; i--) {
+        /* Unmatched opened object or array */
+        if (tokens[i].start != -1 && tokens[i].end == -1) {
+            return JSMN_ERROR_PART;
+        }
+    }
 
-	return count;
+    return count;
 }
 
 /**
@@ -326,9 +326,9 @@ int jsmn_parse(jsmn_parser *parser, const char *js, size_t len,
  * available.
  */
 void jsmn_init(jsmn_parser *parser) {
-	parser->pos = 0;
-	parser->toknext = 0;
-	parser->toksuper = -1;
+    parser->pos = 0;
+    parser->toknext = 0;
+    parser->toksuper = -1;
 }
 
 /*
@@ -336,10 +336,10 @@ void jsmn_init(jsmn_parser *parser) {
  *
  * Local variables:
  * c-basic-offset: 4
- * tab-width: 4
+ * tab-width: 8
  * indent-tabs-mode: nil
  * End:
  *
- * vi: set shiftwidth=4 tabstop=4 expandtab:
- * :indentSize=4:tabSize=4:noTabs=true:
+ * vi: set shiftwidth=4 tabstop=8 expandtab:
+ * :indentSize=4:tabSize=8:noTabs=true:
  */
diff --git a/epan/jsmn/jsmn.h b/epan/jsmn/jsmn.h
index 9644f42380..458e7d447b 100644
--- a/epan/jsmn/jsmn.h
+++ b/epan/jsmn/jsmn.h
@@ -31,25 +31,25 @@ extern "C" {
 
 /**
  * JSON type identifier. Basic types are:
- * 	o Object
- * 	o Array
- * 	o String
- * 	o Other primitive: number, boolean (true/false) or null
+ *  o Object
+ *  o Array
+ *  o String
+ *  o Other primitive: number, boolean (true/false) or null
  */
 typedef enum {
-	JSMN_PRIMITIVE = 0,
-	JSMN_OBJECT = 1,
-	JSMN_ARRAY = 2,
-	JSMN_STRING = 3
+    JSMN_PRIMITIVE = 0,
+    JSMN_OBJECT = 1,
+    JSMN_ARRAY = 2,
+    JSMN_STRING = 3
 } jsmntype_t;
 
 typedef enum {
-	/* Not enough tokens were provided */
-	JSMN_ERROR_NOMEM = -1,
-	/* Invalid character inside JSON string */
-	JSMN_ERROR_INVAL = -2,
-	/* The string is not a full JSON packet, more bytes expected */
-	JSMN_ERROR_PART = -3
+    /* Not enough tokens were provided */
+    JSMN_ERROR_NOMEM = -1,
+    /* Invalid character inside JSON string */
+    JSMN_ERROR_INVAL = -2,
+    /* The string is not a full JSON packet, more bytes expected */
+    JSMN_ERROR_PART = -3
 } jsmnerr_t;
 
 /**
@@ -60,12 +60,12 @@ typedef enum {
  * size  the size of the token
  */
 typedef struct {
-	jsmntype_t type;
-	int start;
-	int end;
-	int size;
+    jsmntype_t type;
+    int start;
+    int end;
+    int size;
 #ifdef JSMN_PARENT_LINKS
-	int parent;
+    int parent;
 #endif
 } jsmntok_t;
 
@@ -74,9 +74,9 @@ typedef struct {
  * the string being parsed now and current position in that string
  */
 typedef struct {
-	unsigned int pos; /* offset in the JSON string */
-	unsigned int toknext; /* next token to allocate */
-	int toksuper; /* superior token node, e.g parent object or array */
+    unsigned int pos;           /* offset in the JSON string */
+    unsigned int toknext;       /* next token to allocate */
+    int          toksuper;      /* superior token node, e.g parent object or array */
 } jsmn_parser;
 
 /**
@@ -89,7 +89,7 @@ void jsmn_init(jsmn_parser *parser);
  * a single JSON object.
  */
 int jsmn_parse(jsmn_parser *parser, const char *js, size_t len,
-		jsmntok_t *tokens, unsigned int num_tokens);
+               jsmntok_t *tokens, unsigned int num_tokens);
 
 #ifdef __cplusplus
 }
@@ -102,10 +102,10 @@ int jsmn_parse(jsmn_parser *parser, const char *js, size_t len,
  *
  * Local variables:
  * c-basic-offset: 4
- * tab-width: 4
+ * tab-width: 8
  * indent-tabs-mode: nil
  * End:
  *
- * vi: set shiftwidth=4 tabstop=4 expandtab:
- * :indentSize=4:tabSize=4:noTabs=true:
+ * vi: set shiftwidth=4 tabstop=8 expandtab:
+ * :indentSize=4:tabSize=9:noTabs=true:
  */
diff --git a/epan/rtp_pt.h b/epan/rtp_pt.h
index ebf30586ef..c10c344c16 100644
--- a/epan/rtp_pt.h
+++ b/epan/rtp_pt.h
@@ -35,71 +35,71 @@ extern "C" {
  * Table B.2 / H.225.0
  * Also RFC 3551, and
  *
- *	http://www.iana.org/assignments/rtp-parameters
+ *  http://www.iana.org/assignments/rtp-parameters
  */
-#define PT_PCMU			0	/* RFC 3551 */
-#define PT_1016			1	/* RFC 1890 (reserved in RFC 3551) */
-#define PT_G721			2	/* RFC 1890 (reserved in RFC 3551) */
-#define PT_GSM			3	/* RFC 3551 */
-#define PT_G723			4	/* From Vineet Kumar of Intel; see the Web page */
-#define PT_DVI4_8000	5	/* RFC 3551 */
-#define PT_DVI4_16000	6	/* RFC 3551 */
-#define PT_LPC			7	/* RFC 3551 */
-#define PT_PCMA			8	/* RFC 3551 */
-#define PT_G722			9	/* RFC 3551 */
-#define PT_L16_STEREO	10	/* RFC 3551 */
-#define PT_L16_MONO		11	/* RFC 3551 */
-#define PT_QCELP		12	/* Qualcomm Code Excited Linear Predictive coding? */
-#define PT_CN			13	/* RFC 3389 */
-#define PT_MPA			14	/* RFC 3551, RFC 2250 */
-#define PT_G728			15	/* RFC 3551 */
-#define PT_DVI4_11025	16	/* from Joseph Di Pol of Sun; see the Web page */
-#define PT_DVI4_22050	17	/* from Joseph Di Pol of Sun; see the Web page */
-#define PT_G729			18
-#define PT_CN_OLD		19	/* Payload type reserved (old version Comfort Noise) */
-#define PT_CELB			25	/* RFC 2029 */
-#define PT_JPEG			26	/* RFC 2435 */
-#define PT_NV			28	/* RFC 1890 */
-#define PT_H261			31	/* RFC 2032 */
-#define PT_MPV			32	/* RFC 2250 */
-#define PT_MP2T			33	/* RFC 2250 */
-#define PT_H263			34	/* from Chunrong Zhu of Intel; see the Web page */
+#define PT_PCMU           0  /* RFC 3551 */
+#define PT_1016           1  /* RFC 1890 (reserved in RFC 3551) */
+#define PT_G721           2  /* RFC 1890 (reserved in RFC 3551) */
+#define PT_GSM            3  /* RFC 3551 */
+#define PT_G723           4  /* From Vineet Kumar of Intel; see the Web page */
+#define PT_DVI4_8000      5  /* RFC 3551 */
+#define PT_DVI4_16000     6  /* RFC 3551 */
+#define PT_LPC            7  /* RFC 3551 */
+#define PT_PCMA           8  /* RFC 3551 */
+#define PT_G722           9  /* RFC 3551 */
+#define PT_L16_STEREO    10  /* RFC 3551 */
+#define PT_L16_MONO      11  /* RFC 3551 */
+#define PT_QCELP         12  /* Qualcomm Code Excited Linear Predictive coding? */
+#define PT_CN            13  /* RFC 3389 */
+#define PT_MPA           14  /* RFC 3551, RFC 2250 */
+#define PT_G728          15  /* RFC 3551 */
+#define PT_DVI4_11025    16  /* from Joseph Di Pol of Sun; see the Web page */
+#define PT_DVI4_22050    17  /* from Joseph Di Pol of Sun; see the Web page */
+#define PT_G729          18
+#define PT_CN_OLD        19  /* Payload type reserved (old version Comfort Noise) */
+#define PT_CELB          25  /* RFC 2029 */
+#define PT_JPEG          26  /* RFC 2435 */
+#define PT_NV            28  /* RFC 1890 */
+#define PT_H261          31  /* RFC 2032 */
+#define PT_MPV           32  /* RFC 2250 */
+#define PT_MP2T          33  /* RFC 2250 */
+#define PT_H263          34  /* from Chunrong Zhu of Intel; see the Web page */
 
 /* Added to by Alex Lindberg to cover port ranges 96-127 - Dynamic RTP
    Some of these ports are used by Avaya for Modem and FAX support */
 
-#define PT_UNDF_96		96  /* RFC 3551 */
-#define PT_UNDF_97		97
-#define PT_UNDF_98		98
-#define PT_UNDF_99		99
-#define PT_UNDF_100		100
-#define PT_UNDF_101		101
-#define PT_UNDF_102		102
-#define PT_UNDF_103		103
-#define PT_UNDF_104		104
-#define PT_UNDF_105		105
-#define PT_UNDF_106		106
-#define PT_UNDF_107		107
-#define PT_UNDF_108		108
-#define PT_UNDF_109		109
-#define PT_UNDF_110		110
-#define PT_UNDF_111		111
-#define PT_UNDF_112		112
-#define PT_UNDF_113		113
-#define PT_UNDF_114		114
-#define PT_UNDF_115		115
-#define PT_UNDF_116		116
-#define PT_UNDF_117		117
-#define PT_UNDF_118		118
-#define PT_UNDF_119		119
-#define PT_UNDF_120		120
-#define PT_UNDF_121		121
-#define PT_UNDF_122		122
-#define PT_UNDF_123		123
-#define PT_UNDF_124		124
-#define PT_UNDF_125		125
-#define PT_UNDF_126		126
-#define PT_UNDF_127		127
+#define PT_UNDF_96       96  /* RFC 3551 */
+#define PT_UNDF_97       97
+#define PT_UNDF_98       98
+#define PT_UNDF_99       99
+#define PT_UNDF_100     100
+#define PT_UNDF_101     101
+#define PT_UNDF_102     102
+#define PT_UNDF_103     103
+#define PT_UNDF_104     104
+#define PT_UNDF_105     105
+#define PT_UNDF_106     106
+#define PT_UNDF_107     107
+#define PT_UNDF_108     108
+#define PT_UNDF_109     109
+#define PT_UNDF_110     110
+#define PT_UNDF_111     111
+#define PT_UNDF_112     112
+#define PT_UNDF_113     113
+#define PT_UNDF_114     114
+#define PT_UNDF_115     115
+#define PT_UNDF_116     116
+#define PT_UNDF_117     117
+#define PT_UNDF_118     118
+#define PT_UNDF_119     119
+#define PT_UNDF_120     120
+#define PT_UNDF_121     121
+#define PT_UNDF_122     122
+#define PT_UNDF_123     123
+#define PT_UNDF_124     124
+#define PT_UNDF_125     125
+#define PT_UNDF_126     126
+#define PT_UNDF_127     127
 
 WS_DLL_PUBLIC value_string_ext rtp_payload_type_vals_ext;
 WS_DLL_PUBLIC value_string_ext rtp_payload_type_short_vals_ext;
diff --git a/epan/stat_tap_ui.h b/epan/stat_tap_ui.h
index 3fee0fd6a5..359cf4bf9a 100644
--- a/epan/stat_tap_ui.h
+++ b/epan/stat_tap_ui.h
@@ -37,32 +37,32 @@ extern "C" {
 #include <epan/stat_groups.h>
 
 typedef enum {
-	PARAM_UINT,
-	PARAM_STRING,
-	PARAM_ENUM,
-	PARAM_UUID,
-	PARAM_FILTER
+    PARAM_UINT,
+    PARAM_STRING,
+    PARAM_ENUM,
+    PARAM_UUID,
+    PARAM_FILTER
 } param_type;
 
 typedef struct _tap_param {
-	param_type type;		/* type of parameter */
-	const char *name;		/* name to use in error messages */
-	const char *title;		/* title to use in GUI widgets */
-	const enum_val_t *enum_vals;	/* values for PARAM_ENUM */
-	gboolean optional;		/* TRUE if the parameter is optional */
+    param_type        type;      /* type of parameter */
+    const char       *name;      /* name to use in error messages */
+    const char       *title;     /* title to use in GUI widgets */
+    const enum_val_t *enum_vals; /* values for PARAM_ENUM */
+    gboolean          optional;  /* TRUE if the parameter is optional */
 } tap_param;
 
 /*
  * UI information for a tap.
  */
 typedef struct _stat_tap_ui {
-	register_stat_group_t group;	/* group to which statistic belongs */
-	const char *title;		/* title of statistic */
-	const char *cli_string;		/* initial part of the "-z" argument for statistic */
-	void (* tap_init_cb)(const char *,void*);	/* callback to init function of the tap */
-	gint index;			/* initiate this value always with "-1" */
-	size_t nparams;			/* number of parameters */
-	tap_param *params;		/* pointer to table of parameter info */
+    register_stat_group_t  group;      /* group to which statistic belongs */
+    const char            *title;      /* title of statistic */
+    const char            *cli_string; /* initial part of the "-z" argument for statistic */
+    void (* tap_init_cb)(const char *, void*); /* callback to init function of the tap */
+    gint                   index;      /* initiate this value always with "-1" */
+    size_t                 nparams;    /* number of parameters */
+    tap_param             *params;     /* pointer to table of parameter info */
 } stat_tap_ui;
 
 /** Register UI information for a tap.
diff --git a/epan/wslua/wslua_util.c b/epan/wslua/wslua_util.c
index ec0a4e3784..2b53d9f91e 100644
--- a/epan/wslua/wslua_util.c
+++ b/epan/wslua/wslua_util.c
@@ -271,7 +271,7 @@ WSLUA_FUNCTION wslua_register_stat_cmd_arg(lua_State* L) {
     sc->func_ref = luaL_ref(L, LUA_REGISTRYINDEX);
     lua_remove(L,1);
 
-    ui_info.group = REGISTER_STAT_GROUP_UNSORTED;	/* XXX - need group for CLI-only? */
+    ui_info.group = REGISTER_STAT_GROUP_UNSORTED;  /* XXX - need group for CLI-only? */
     ui_info.title = NULL;
     ui_info.cli_string = arg;
     ui_info.tap_init_cb = statcmd_init;
diff --git a/log.h b/log.h
index d79239cd40..b2b7e349d0 100644
--- a/log.h
+++ b/log.h
@@ -27,10 +27,10 @@
 #define LOG_DOMAIN_CAPTURE          "Capture"
 
 /* capture child domain (the capture child might also contain file domain messages!) */
-#define LOG_DOMAIN_CAPTURE_CHILD 	"CaptureChild"
+#define LOG_DOMAIN_CAPTURE_CHILD  "CaptureChild"
 
 /* main domain */
-#define LOG_DOMAIN_MAIN				"Main"
+#define LOG_DOMAIN_MAIN           "Main"
 
 /* enable very verbose capture log debug output */
 /* (might slightly degrade performance) */
diff --git a/sync_pipe.h b/sync_pipe.h
index 2cef98ec8c..455b2b4bd6 100644
--- a/sync_pipe.h
+++ b/sync_pipe.h
@@ -38,7 +38,7 @@
  * Expression, as the error message for an incorrect filter expression
  * is a bit larger than the filter expression.
  */
-#define SP_MAX_MSG_LEN	4096
+#define SP_MAX_MSG_LEN  4096
 
 
 /* Size of buffer to hold decimal representation of
diff --git a/ui/filters.c b/ui/filters.c
index 699b0c194a..6ed94c5a89 100644
--- a/ui/filters.c
+++ b/ui/filters.c
@@ -40,17 +40,17 @@
 /*
  * Old filter file name.
  */
-#define FILTER_FILE_NAME	"filters"
+#define FILTER_FILE_NAME      "filters"
 
 /*
  * Capture filter file name.
  */
-#define CFILTER_FILE_NAME	"cfilters"
+#define CFILTER_FILE_NAME     "cfilters"
 
 /*
  * Display filter file name.
  */
-#define DFILTER_FILE_NAME	"dfilters"
+#define DFILTER_FILE_NAME     "dfilters"
 
 /*
  * List of capture filters - saved.
@@ -81,7 +81,7 @@ static GList *display_edited_filters = NULL;
  * and "*errno_return" is set to the error.
  */
 
-#define INIT_BUF_SIZE	128
+#define INIT_BUF_SIZE  128
 
 static GList *
 add_filter_entry(GList *fl, const char *filt_name, const char *filt_expr)
@@ -150,7 +150,7 @@ read_filter_list(filter_list_type_t list_type, char **pref_path_return,
   int         filt_name_index, filt_expr_index;
   int         line = 1;
 
-  *pref_path_return = NULL;	/* assume no error */
+  *pref_path_return = NULL;   /* assume no error */
 
   switch (list_type) {
 
@@ -198,14 +198,14 @@ read_filter_list(filter_list_type_t list_type, char **pref_path_return,
       /*
        * Did that fail because the file didn't exist?
        */
-	if (errno != ENOENT) {
-	/*
-	 * No.  Just give up.
-	 */
-	  *pref_path_return = ff_path;
-	  *errno_return = errno;
-	  return;
-	}
+        if (errno != ENOENT) {
+        /*
+         * No.  Just give up.
+         */
+          *pref_path_return = ff_path;
+          *errno_return = errno;
+          return;
+        }
 
       /*
        * Try to open the global "cfilters/dfilters" file */
@@ -213,17 +213,17 @@ read_filter_list(filter_list_type_t list_type, char **pref_path_return,
       ff_path = get_datafile_path(ff_name);
       if ((ff = ws_fopen(ff_path, "r")) == NULL) {
 
-	/*
-	 * Well, that didn't work, either.  Just give up.
-	 * Return an error if the file existed but we couldn't open it.
-	 */
-	if (errno != ENOENT) {
-	  *pref_path_return = ff_path;
-	  *errno_return = errno;
-	} else {
-	  g_free(ff_path);
-	}
-	return;
+        /*
+         * Well, that didn't work, either.  Just give up.
+         * Return an error if the file existed but we couldn't open it.
+         */
+        if (errno != ENOENT) {
+          *pref_path_return = ff_path;
+          *errno_return = errno;
+        } else {
+          g_free(ff_path);
+        }
+        return;
       }
     }
   }
@@ -243,7 +243,7 @@ read_filter_list(filter_list_type_t list_type, char **pref_path_return,
   for (line = 1; ; line++) {
     /* Lines in a filter file are of the form
 
-	"name" expression
+        "name" expression
 
        where "name" is a name, in quotes - backslashes in the name
        escape the next character, so quotes and backslashes can appear
@@ -254,7 +254,7 @@ read_filter_list(filter_list_type_t list_type, char **pref_path_return,
     c = skip_whitespace(ff);
 
     if (c == EOF)
-      break;	/* Nothing more to read */
+      break;    /* Nothing more to read */
     if (c == '\n')
       continue; /* Blank line. */
 
@@ -262,9 +262,9 @@ read_filter_list(filter_list_type_t list_type, char **pref_path_return,
        If it's not a quote, it's an error. */
     if (c != '"') {
       g_warning("'%s' line %d doesn't have a quoted filter name.", ff_path,
-		line);
+                line);
       while (c != '\n')
-	c = getc(ff);	/* skip to the end of the line */
+        c = getc(ff);   /* skip to the end of the line */
       continue;
     }
 
@@ -273,28 +273,28 @@ read_filter_list(filter_list_type_t list_type, char **pref_path_return,
     for (;;) {
       c = getc_crlf(ff);
       if (c == EOF || c == '\n')
-	break;	/* End of line - or end of file */
+        break;  /* End of line - or end of file */
       if (c == '"') {
-	/* Closing quote. */
-	if (filt_name_index >= filt_name_len) {
-	  /* Filter name buffer isn't long enough; double its length. */
-	  filt_name_len *= 2;
-	  filt_name = (char *)g_realloc(filt_name, filt_name_len + 1);
-	}
-	filt_name[filt_name_index] = '\0';
-	break;
+        /* Closing quote. */
+        if (filt_name_index >= filt_name_len) {
+          /* Filter name buffer isn't long enough; double its length. */
+          filt_name_len *= 2;
+          filt_name = (char *)g_realloc(filt_name, filt_name_len + 1);
+        }
+        filt_name[filt_name_index] = '\0';
+        break;
       }
       if (c == '\\') {
-	/* Next character is escaped */
-	c = getc_crlf(ff);
-	if (c == EOF || c == '\n')
-	  break;	/* End of line - or end of file */
+        /* Next character is escaped */
+        c = getc_crlf(ff);
+        if (c == EOF || c == '\n')
+          break;        /* End of line - or end of file */
       }
       /* Add this character to the filter name string. */
       if (filt_name_index >= filt_name_len) {
-	/* Filter name buffer isn't long enough; double its length. */
-	filt_name_len *= 2;
-	filt_name = (char *)g_realloc(filt_name, filt_name_len + 1);
+        /* Filter name buffer isn't long enough; double its length. */
+        filt_name_len *= 2;
+        filt_name = (char *)g_realloc(filt_name, filt_name_len + 1);
       }
       filt_name[filt_name_index] = c;
       filt_name_index++;
@@ -302,17 +302,17 @@ read_filter_list(filter_list_type_t list_type, char **pref_path_return,
 
     if (c == EOF) {
       if (!ferror(ff)) {
-	/* EOF, not error; no newline seen before EOF */
-	g_warning("'%s' line %d doesn't have a newline.", ff_path,
-		  line);
+        /* EOF, not error; no newline seen before EOF */
+        g_warning("'%s' line %d doesn't have a newline.", ff_path,
+                  line);
       }
-      break;	/* nothing more to read */
+      break;    /* nothing more to read */
     }
 
     if (c != '"') {
       /* No newline seen before end-of-line */
       g_warning("'%s' line %d doesn't have a closing quote.", ff_path,
-		line);
+                line);
       continue;
     }
 
@@ -321,17 +321,17 @@ read_filter_list(filter_list_type_t list_type, char **pref_path_return,
 
     if (c == EOF) {
       if (!ferror(ff)) {
-	/* EOF, not error; no newline seen before EOF */
-	g_warning("'%s' line %d doesn't have a newline.", ff_path,
-		  line);
+        /* EOF, not error; no newline seen before EOF */
+        g_warning("'%s' line %d doesn't have a newline.", ff_path,
+                  line);
       }
-      break;	/* nothing more to read */
+      break;    /* nothing more to read */
     }
 
     if (c == '\n') {
       /* No filter expression */
       g_warning("'%s' line %d doesn't have a filter expression.", ff_path,
-		line);
+                line);
       continue;
     }
 
@@ -341,9 +341,9 @@ read_filter_list(filter_list_type_t list_type, char **pref_path_return,
     for (;;) {
       /* Add this character to the filter expression string. */
       if (filt_expr_index >= filt_expr_len) {
-	/* Filter expressioin buffer isn't long enough; double its length. */
-	filt_expr_len *= 2;
-	filt_expr = (char *)g_realloc(filt_expr, filt_expr_len + 1);
+        /* Filter expressioin buffer isn't long enough; double its length. */
+        filt_expr_len *= 2;
+        filt_expr = (char *)g_realloc(filt_expr, filt_expr_len + 1);
       }
       filt_expr[filt_expr_index] = c;
       filt_expr_index++;
@@ -351,16 +351,16 @@ read_filter_list(filter_list_type_t list_type, char **pref_path_return,
       /* Get the next character. */
       c = getc_crlf(ff);
       if (c == EOF || c == '\n')
-	break;
+        break;
     }
 
     if (c == EOF) {
       if (!ferror(ff)) {
-	/* EOF, not error; no newline seen before EOF */
-	g_warning("'%s' line %d doesn't have a newline.", ff_path,
-		  line);
+        /* EOF, not error; no newline seen before EOF */
+        g_warning("'%s' line %d doesn't have a newline.", ff_path,
+                  line);
       }
-      break;	/* nothing more to read */
+      break;    /* nothing more to read */
     }
 
     /* We saw the ending newline; terminate the filter expression string */
@@ -452,7 +452,7 @@ add_to_filter_list(filter_list_type_t list_type, const char *name,
 {
   GList      **flpp;
 
-  flpp = get_filter_list(list_type);
+  flpp  = get_filter_list(list_type);
   *flpp = add_filter_entry(*flpp, name, expression);
 
   return g_list_last(*flpp);
@@ -466,7 +466,7 @@ remove_from_filter_list(filter_list_type_t list_type, GList *fl_entry)
 {
   GList      **flpp;
 
-  flpp = get_filter_list(list_type);
+  flpp  = get_filter_list(list_type);
   *flpp = remove_filter_entry(*flpp, fl_entry);
 }
 
@@ -483,14 +483,14 @@ save_filter_list(filter_list_type_t list_type, char **pref_path_return,
     int *errno_return)
 {
   const gchar *ff_name;
-  gchar      *ff_path, *ff_path_new;
-  GList      *fl;
-  GList      *flpp;
-  filter_def *filt;
-  FILE       *ff;
-  guchar     *p, c;
-
-  *pref_path_return = NULL;	/* assume no error */
+  gchar       *ff_path, *ff_path_new;
+  GList       *fl;
+  GList       *flpp;
+  filter_def  *filt;
+  FILE        *ff;
+  guchar      *p, c;
+
+  *pref_path_return = NULL;   /* assume no error */
 
   switch (list_type) {
 
diff --git a/ui/gtk/conversations_table.c b/ui/gtk/conversations_table.c
index bc20bec0d5..ee51e4dddc 100644
--- a/ui/gtk/conversations_table.c
+++ b/ui/gtk/conversations_table.c
@@ -1594,7 +1594,7 @@ draw_ct_table_addresses(conversations_table *ct)
 
     while (iter_valid) {
         conv_item_t *conv_item;
-		char *src_addr, *dst_addr, *src_port, *dst_port;
+        char *src_addr, *dst_addr, *src_port, *dst_port;
 
         gtk_tree_model_get(GTK_TREE_MODEL(store), &iter, CONV_INDEX_COLUMN, &idx, -1);
         conv_item = &g_array_index(ct->hash.conv_array, conv_item_t, idx);
diff --git a/ui/preference_utils.h b/ui/preference_utils.h
index c60b32c13a..074b974844 100644
--- a/ui/preference_utils.h
+++ b/ui/preference_utils.h
@@ -88,8 +88,8 @@ extern void prefs_main_write(void);
  * @param custom_occurrence custom occurrence
  */
 void column_prefs_add_custom(gint fmt, const gchar *title,
-			     const gchar *custom_field,
-			     gint custom_occurrence);
+                             const gchar *custom_field,
+                             gint custom_occurrence);
 
 /** Remove a column.
  *
diff --git a/ui/voip_calls.c b/ui/voip_calls.c
index b4bb6d3669..911d760049 100644
--- a/ui/voip_calls.c
+++ b/ui/voip_calls.c
@@ -23,12 +23,12 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation,	Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
 #include "config.h"
@@ -140,8 +140,8 @@ typedef struct {
 #define H245_MAX 6
 
 typedef struct _h245_labels {
-    guint32	frame_num;
-    gint8 labels_count;
+    guint32   frame_num;
+    gint8     labels_count;
     graph_str labels[H245_MAX];
 } h245_labels_t;
 
@@ -401,7 +401,7 @@ static guint change_call_num_graph(voip_calls_tapinfo_t *tapinfo _U_, guint16 ca
 {
     seq_analysis_item_t *gai;
     GList *list;
-    guint items_changed;
+    guint  items_changed;
 
     items_changed = 0;
     if(tapinfo->graph_analysis){
@@ -424,10 +424,10 @@ static guint change_call_num_graph(voip_calls_tapinfo_t *tapinfo _U_, guint16 ca
 static void insert_to_graph_t38(voip_calls_tapinfo_t *tapinfo, packet_info *pinfo, epan_dissect_t *edt, const gchar *frame_label, const gchar *comment, guint16 call_num, address *src_addr, address *dst_addr, guint16 line_style, guint32 frame_num)
 {
     seq_analysis_item_t *gai, *new_gai;
-    GList *list;
-    guint item_num;
-    gboolean inserted;
-    gchar time_str[COL_MAX_LEN];
+    GList    *list;
+    guint     item_num;
+    gboolean  inserted;
+    gchar     time_str[COL_MAX_LEN];
 
     new_gai = (seq_analysis_item_t *)g_malloc(sizeof(seq_analysis_item_t));
     new_gai->fd = packet_list_get_row_data(frame_num);
@@ -486,8 +486,8 @@ static void insert_to_graph_t38(voip_calls_tapinfo_t *tapinfo, packet_info *pinf
 static int
 rtp_event_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt _U_, const void *rtp_event_info)
 {
-    voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_rtp_event_);
-    const struct _rtp_event_info *pi = (const struct _rtp_event_info *)rtp_event_info;
+    voip_calls_tapinfo_t         *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_rtp_event_);
+    const struct _rtp_event_info *pi      = (const struct _rtp_event_info *)rtp_event_info;
 
     /* do not consider RTP events packets without a setup frame */
     if (pi->info_setup_frame_num == 0) {
@@ -527,7 +527,7 @@ rtp_event_init_tap(voip_calls_tapinfo_t *tap_id_base)
 void
 remove_tap_listener_rtp_event(voip_calls_tapinfo_t *tap_id_base)
 {
-	remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_rtp_event_));
+    remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_rtp_event_));
 }
 
 /****************************************************************************/
@@ -566,9 +566,9 @@ static gboolean
 rtp_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, void const *rtp_info_ptr)
 {
     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_rtp_);
-    rtp_stream_info_t *tmp_listinfo;
-    rtp_stream_info_t *strinfo = NULL;
-    GList *list;
+    rtp_stream_info_t    *tmp_listinfo;
+    rtp_stream_info_t    *strinfo = NULL;
+    GList                *list;
     struct _rtp_conversation_info *p_conv_data = NULL;
 
     const struct _rtp_info *rtp_info = (const struct _rtp_info *)rtp_info_ptr;
@@ -661,14 +661,14 @@ static void
 rtp_draw(void *tap_offset_ptr)
 {
     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_rtp_);
-    GList *rtp_streams_list;
-    rtp_stream_info_t *rtp_listinfo;
+    GList                *rtp_streams_list;
+    rtp_stream_info_t    *rtp_listinfo;
     /* GList *voip_calls_graph_list; */
-    seq_analysis_item_t *gai = NULL;
-    seq_analysis_item_t *new_gai;
-    guint16 conv_num;
-    guint32 duration;
-    gchar time_str[COL_MAX_LEN];
+    seq_analysis_item_t  *gai     = NULL;
+    seq_analysis_item_t  *new_gai;
+    guint16               conv_num;
+    guint32               duration;
+    gchar                 time_str[COL_MAX_LEN];
 
     /* add each rtp stream to the graph */
     rtp_streams_list = g_list_first(tapinfo->rtp_stream_list);
@@ -729,83 +729,83 @@ rtp_draw(void *tap_offset_ptr)
 static void
 rtp_packet_draw(void *tap_offset_ptr)
 {
-	voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_rtp_);
-	GList *rtp_streams_list;
-    rtp_stream_info_t *rtp_listinfo;
-	GList *voip_calls_graph_list;
-	guint item;
-	seq_analysis_item_t *gai;
-	seq_analysis_item_t *new_gai;
-	guint16 conv_num;
-	guint32 duration;
-	gchar time_str[COL_MAX_LEN];
-
-	/* add each rtp stream to the graph */
+    voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_rtp_);
+    GList                *rtp_streams_list;
+    rtp_stream_info_t    *rtp_listinfo;
+    GList                *voip_calls_graph_list;
+    guint                 item;
+    seq_analysis_item_t  *gai;
+    seq_analysis_item_t  *new_gai;
+    guint16               conv_num;
+    guint32               duration;
+    gchar                 time_str[COL_MAX_LEN];
+
+    /* add each rtp stream to the graph */
     rtp_streams_list = g_list_first(tapinfo->stream_list);
-	while (rtp_streams_list)
-	{
-		rtp_listinfo = rtp_streams_list->data;
-
-		/* using the setup frame number of the RTP stream, we get the call number that it belongs to*/
-		voip_calls_graph_list = g_list_first(tapinfo->graph_analysis->list);
-		while (voip_calls_graph_list)
-		{
-			gai = voip_calls_graph_list->data;
-			conv_num = gai->conv_num;
-			/* if we get the setup frame number, then get the time position to graph the RTP arrow */
-			if (rtp_listinfo->setup_frame_number == gai->fd->num) {
-				/* look again from the beginning because there are cases where the Setup frame is after the RTP */
-				voip_calls_graph_list = g_list_first(tapinfo->graph_analysis->list);
-				item = 0;
-				while(voip_calls_graph_list) {
-					gai = voip_calls_graph_list->data;
-					/* if RTP was already in the Graph, just update the comment information */
-					if (rtp_listinfo->start_fd->num == gai->fd->num) {
-						duration = (guint32)(nstime_to_msec(&rtp_listinfo->stop_fd->rel_ts) - nstime_to_msec(&rtp_listinfo->start_fd->rel_ts));
-						g_free(gai->comment);
-						gai->comment = g_strdup_printf("%s Num packets:%u  Duration:%u.%03us SSRC:0x%X",
-														(rtp_listinfo->is_srtp)?"SRTP":"RTP", rtp_listinfo->npackets,
-														duration/1000,(duration%1000), rtp_listinfo->ssrc);
-						break;
-					}
-
-					/* we increment the list here to be able to check if it is the last item in this calls, which means the RTP is after so we have to draw it */
-					voip_calls_graph_list = g_list_next(voip_calls_graph_list);
-					if (!voip_calls_graph_list) item++;
-
-					/* add the RTP item to the graph if was not there*/
-					if (rtp_listinfo->start_fd->num<gai->fd->num || !voip_calls_graph_list) {
-						new_gai = g_malloc(sizeof(seq_analysis_item_t));
-						new_gai->fd = rtp_listinfo->start_fd;
-						COPY_ADDRESS(&(new_gai->src_addr),&(rtp_listinfo->src_addr));
-						COPY_ADDRESS(&(new_gai->dst_addr),&(rtp_listinfo->dest_addr));
-						new_gai->port_src = rtp_listinfo->src_port;
-						new_gai->port_dst = rtp_listinfo->dest_port;
-						duration = (guint32)(nstime_to_msec(&rtp_listinfo->stop_fd->rel_ts) - nstime_to_msec(&rtp_listinfo->start_fd->rel_ts));
-						new_gai->frame_label = g_strdup_printf("%s (%s) %s",
-										       (rtp_listinfo->is_srtp)?"SRTP":"RTP",
-                                               rtp_listinfo->payload_type_str,
-										       (rtp_listinfo->rtp_event == -1)?
-										         "":val_to_str_ext_const(rtp_listinfo->rtp_event, &rtp_event_type_values_ext, "Unknown RTP Event"));
-						new_gai->comment = g_strdup_printf("%s Num packets:%u  Duration:%u.%03us SSRC:0x%X",
-															(rtp_listinfo->is_srtp)?"SRTP":"RTP", rtp_listinfo->npackets,
-															duration/1000,(duration%1000), rtp_listinfo->ssrc);
-						new_gai->conv_num = conv_num;
-						set_fd_time(cfile.epan, new_gai->fd, time_str);
-						new_gai->time_str = g_strdup(time_str);
-						new_gai->display=FALSE;
-						new_gai->line_style = 2;  /* the arrow line will be 2 pixels width */
-						tapinfo->graph_analysis->list = g_list_insert(tapinfo->graph_analysis->list, new_gai, item);
-						break;
-					}
-					if (voip_calls_graph_list) item++;
-				}
-				break;
-			}
-			voip_calls_graph_list = g_list_next(voip_calls_graph_list);
-		}
-		rtp_streams_list = g_list_next(rtp_streams_list);
-	}
+    while (rtp_streams_list)
+    {
+        rtp_listinfo = rtp_streams_list->data;
+
+        /* using the setup frame number of the RTP stream, we get the call number that it belongs to*/
+        voip_calls_graph_list = g_list_first(tapinfo->graph_analysis->list);
+        while (voip_calls_graph_list)
+        {
+            gai = voip_calls_graph_list->data;
+            conv_num = gai->conv_num;
+            /* if we get the setup frame number, then get the time position to graph the RTP arrow */
+            if (rtp_listinfo->setup_frame_number == gai->fd->num) {
+                /* look again from the beginning because there are cases where the Setup frame is after the RTP */
+                voip_calls_graph_list = g_list_first(tapinfo->graph_analysis->list);
+                item = 0;
+                while(voip_calls_graph_list) {
+                    gai = voip_calls_graph_list->data;
+                    /* if RTP was already in the Graph, just update the comment information */
+                    if (rtp_listinfo->start_fd->num == gai->fd->num) {
+                        duration = (guint32)(nstime_to_msec(&rtp_listinfo->stop_fd->rel_ts) - nstime_to_msec(&rtp_listinfo->start_fd->rel_ts));
+                        g_free(gai->comment);
+                        gai->comment = g_strdup_printf("%s Num packets:%u  Duration:%u.%03us SSRC:0x%X",
+                                                       (rtp_listinfo->is_srtp)?"SRTP":"RTP", rtp_listinfo->npackets,
+                                                       duration/1000,(duration%1000), rtp_listinfo->ssrc);
+                        break;
+                    }
+
+                    /* we increment the list here to be able to check if it is the last item in this calls, which means the RTP is after so we have to draw it */
+                    voip_calls_graph_list = g_list_next(voip_calls_graph_list);
+                    if (!voip_calls_graph_list) item++;
+
+                    /* add the RTP item to the graph if was not there*/
+                    if (rtp_listinfo->start_fd->num<gai->fd->num || !voip_calls_graph_list) {
+                        new_gai = g_malloc(sizeof(seq_analysis_item_t));
+                        new_gai->fd = rtp_listinfo->start_fd;
+                        COPY_ADDRESS(&(new_gai->src_addr),&(rtp_listinfo->src_addr));
+                        COPY_ADDRESS(&(new_gai->dst_addr),&(rtp_listinfo->dest_addr));
+                        new_gai->port_src = rtp_listinfo->src_port;
+                        new_gai->port_dst = rtp_listinfo->dest_port;
+                        duration = (guint32)(nstime_to_msec(&rtp_listinfo->stop_fd->rel_ts) - nstime_to_msec(&rtp_listinfo->start_fd->rel_ts));
+                        new_gai->frame_label = g_strdup_printf("%s (%s) %s",
+                                                               (rtp_listinfo->is_srtp)?"SRTP":"RTP",
+                                                               rtp_listinfo->payload_type_str,
+                                                               (rtp_listinfo->rtp_event == -1)?
+                                                               "":val_to_str_ext_const(rtp_listinfo->rtp_event, &rtp_event_type_values_ext, "Unknown RTP Event"));
+                        new_gai->comment = g_strdup_printf("%s Num packets:%u  Duration:%u.%03us SSRC:0x%X",
+                                                           (rtp_listinfo->is_srtp)?"SRTP":"RTP", rtp_listinfo->npackets,
+                                                           duration/1000,(duration%1000), rtp_listinfo->ssrc);
+                        new_gai->conv_num = conv_num;
+                        set_fd_time(cfile.epan, new_gai->fd, time_str);
+                        new_gai->time_str = g_strdup(time_str);
+                        new_gai->display=FALSE;
+                        new_gai->line_style = 2;  /* the arrow line will be 2 pixels width */
+                        tapinfo->graph_analysis->list = g_list_insert(tapinfo->graph_analysis->list, new_gai, item);
+                        break;
+                    }
+                    if (voip_calls_graph_list) item++;
+                }
+                break;
+            }
+            voip_calls_graph_list = g_list_next(voip_calls_graph_list);
+        }
+        rtp_streams_list = g_list_next(rtp_streams_list);
+    }
 }
 #endif
 
@@ -844,19 +844,19 @@ remove_tap_listener_rtp(voip_calls_tapinfo_t *tap_id_base)
 static gboolean
 t38_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *t38_info_ptr)
 {
-    voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_t38_);
+    voip_calls_tapinfo_t *tapinfo               = tap_id_to_base(tap_offset_ptr, tap_id_offset_t38_);
 
-    voip_calls_info_t *callsinfo = NULL;
-    voip_calls_info_t *tmp_listinfo;
-    GList *voip_calls_graph_list = NULL;
-    GList *list;
-    gchar *frame_label = NULL;
-    gchar *comment = NULL;
-    seq_analysis_item_t *tmp_gai, *gai = NULL;
-    gchar *tmp_str1, *tmp_str2;
-    guint16 line_style = 2;
-    double duration;
-    int conv_num = -1;
+    voip_calls_info_t    *callsinfo             = NULL;
+    voip_calls_info_t    *tmp_listinfo;
+    GList                *voip_calls_graph_list = NULL;
+    GList                *list;
+    gchar                *frame_label           = NULL;
+    gchar                *comment               = NULL;
+    seq_analysis_item_t  *tmp_gai, *gai         = NULL;
+    gchar                *tmp_str1, *tmp_str2;
+    guint16               line_style            = 2;
+    double                duration;
+    int                   conv_num              = -1;
 
     const t38_packet_info *t38_info = (const t38_packet_info *)t38_info_ptr;
 
@@ -934,7 +934,7 @@ t38_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const
         comment = g_strdup_printf("t38:t30 Ind:%s", tmp_str1);
         wmem_free(NULL, tmp_str1);
         line_style = 1;
-    } else if (t38_info->type_msg == 1) {	/* 1=data */
+    } else if (t38_info->type_msg == 1) {  /* 1=data */
         switch(t38_info->Data_Field_field_type_value) {
             case 0: /* hdlc-data */
                 break;
@@ -1037,17 +1037,17 @@ free_sip_info(gpointer p) {
 static gboolean
 sip_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt , const void *SIPinfo)
 {
-    voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_sip_);
+    voip_calls_tapinfo_t *tapinfo     = tap_id_to_base(tap_offset_ptr, tap_id_offset_sip_);
     /* we just take note of the ISUP data here; when we receive the MTP3 part everything will
        be compared with existing calls */
 
-    voip_calls_info_t *callsinfo = NULL;
-    sip_calls_info_t *tmp_sipinfo = NULL;
-    address tmp_src, tmp_dst;
-    gchar *frame_label = NULL;
-    gchar *comment = NULL;
-    gchar *old_comment = NULL;
-    gchar *key=NULL;
+    voip_calls_info_t    *callsinfo   = NULL;
+    sip_calls_info_t     *tmp_sipinfo = NULL;
+    address               tmp_src, tmp_dst;
+    gchar                *frame_label = NULL;
+    gchar                *comment     = NULL;
+    gchar                *old_comment = NULL;
+    gchar                *key         = NULL;
 
     const sip_info_value_t *pi = (const sip_info_value_t *)SIPinfo;
 
@@ -1247,16 +1247,16 @@ remove_tap_listener_sip_calls(voip_calls_tapinfo_t *tap_id_base)
 static gboolean
 isup_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *isup_info)
 {
-    voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_isup_);
-    voip_calls_info_t *tmp_listinfo;
-    voip_calls_info_t *callsinfo = NULL;
-    isup_calls_info_t *tmp_isupinfo;
-    gboolean found = FALSE;
-    gboolean forward = FALSE;
-    gboolean right_pair;
-    GList *list;
-    gchar *frame_label = NULL;
-    gchar *comment = NULL;
+    voip_calls_tapinfo_t *tapinfo     = tap_id_to_base(tap_offset_ptr, tap_id_offset_isup_);
+    voip_calls_info_t    *tmp_listinfo;
+    voip_calls_info_t    *callsinfo   = NULL;
+    isup_calls_info_t    *tmp_isupinfo;
+    gboolean              found       = FALSE;
+    gboolean              forward     = FALSE;
+    gboolean              right_pair;
+    GList                *list;
+    gchar                *frame_label = NULL;
+    gchar                *comment     = NULL;
 
     const isup_tap_rec_t *pi = (const isup_tap_rec_t *)isup_info;
 
@@ -1443,7 +1443,7 @@ static gboolean
 mtp3_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt _U_, const void *mtp3_info)
 {
     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_mtp3_);
-    const mtp3_tap_rec_t *pi = (const mtp3_tap_rec_t *)mtp3_info;
+    const mtp3_tap_rec_t *pi      = (const mtp3_tap_rec_t *)mtp3_info;
 
     /* keep the data in memory to use when the ISUP information arrives */
 
@@ -1513,14 +1513,14 @@ static const e_guid_t guid_allzero = {0, 0, 0, { 0, 0, 0, 0, 0, 0, 0, 0 } };
 static gboolean
 q931_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *q931_info)
 {
-    GList *list,*list2;
-    voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_q931_);
-    h323_calls_info_t *tmp_h323info,*tmp2_h323info;
+    GList                     *list,*list2;
+    voip_calls_tapinfo_t      *tapinfo   = tap_id_to_base(tap_offset_ptr, tap_id_offset_q931_);
+    h323_calls_info_t         *tmp_h323info,*tmp2_h323info;
     actrace_isdn_calls_info_t *tmp_actrace_isdn_info;
-    voip_calls_info_t *tmp_listinfo;
-    voip_calls_info_t *callsinfo = NULL;
-    h245_address_t *h245_add = NULL;
-    gchar *comment, *tmp_str;
+    voip_calls_info_t         *tmp_listinfo;
+    voip_calls_info_t         *callsinfo = NULL;
+    h245_address_t            *h245_add  = NULL;
+    gchar                     *comment, *tmp_str;
 
     const q931_packet_info *pi = (const q931_packet_info *)q931_info;
 
@@ -1733,7 +1733,7 @@ q931_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt,
                     if (ADDRESSES_EQUAL(&(callsinfo->initial_speaker), tapinfo->actrace_direction?&pstn_add:&(pinfo->src) )) {  /* forward direction */
                         callsinfo->call_state=VOIP_CANCELLED;
                     }
-                    else {												/* reverse */
+                    else { /* reverse */
                         callsinfo->call_state=VOIP_REJECTED;
                         tapinfo->rejected_calls++;
                     }
@@ -1838,14 +1838,14 @@ free_h225_info(gpointer p) {
 static gboolean
 h225_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *H225info)
 {
-    voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_h225_);
-    voip_calls_info_t *tmp_listinfo;
-    voip_calls_info_t *callsinfo = NULL;
-    h323_calls_info_t *tmp_h323info = NULL;
-    gchar *frame_label;
-    gchar *comment;
-    GList *list;
-    h245_address_t *h245_add = NULL;
+    voip_calls_tapinfo_t *tapinfo      = tap_id_to_base(tap_offset_ptr, tap_id_offset_h225_);
+    voip_calls_info_t    *tmp_listinfo;
+    voip_calls_info_t    *callsinfo    = NULL;
+    h323_calls_info_t    *tmp_h323info = NULL;
+    gchar                *frame_label;
+    gchar                *comment;
+    GList                *list;
+    h245_address_t       *h245_add     = NULL;
 
     const h225_packet_info *pi = (const h225_packet_info *)H225info;
 
@@ -1987,7 +1987,7 @@ h225_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt,
                     if (ADDRESSES_EQUAL(&(tmp_h323info->h225SetupAddr),&(pinfo->src))) {  /* forward direction */
                         callsinfo->call_state=VOIP_CANCELLED;
                     }
-                    else {	/* reverse */
+                    else { /* reverse */
                         callsinfo->call_state=VOIP_REJECTED;
                         tapinfo->rejected_calls++;
                     }
@@ -2140,13 +2140,13 @@ h245_add_label(voip_calls_tapinfo_t *tapinfo, guint32 new_frame_num, const gchar
 static gboolean
 h245dg_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *H245info)
 {
-    voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_h245dg_);
-    voip_calls_info_t *tmp_listinfo;
-    voip_calls_info_t *callsinfo = NULL;
-    h323_calls_info_t *tmp_h323info;
-    GList *list;
-    GList *list2;
-    h245_address_t *h245_add = NULL;
+    voip_calls_tapinfo_t *tapinfo   = tap_id_to_base(tap_offset_ptr, tap_id_offset_h245dg_);
+    voip_calls_info_t    *tmp_listinfo;
+    voip_calls_info_t    *callsinfo = NULL;
+    h323_calls_info_t    *tmp_h323info;
+    GList                *list;
+    GList                *list2;
+    h245_address_t       *h245_add  = NULL;
 
     const h245_packet_info *pi = (const h245_packet_info *)H245info;
 
@@ -2239,8 +2239,8 @@ remove_tap_listener_h245dg_calls(voip_calls_tapinfo_t *tap_id_base)
 static gboolean
 sdp_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt _U_, const void *SDPinfo)
 {
-    voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_sdp_);
-    const sdp_packet_info *pi = (const sdp_packet_info *)SDPinfo;
+    voip_calls_tapinfo_t  *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_sdp_);
+    const sdp_packet_info *pi      = (const sdp_packet_info *)SDPinfo;
 
     /* There are protocols like MGCP/SIP where the SDP is called before the tap for the
        MGCP/SIP packet, in those cases we assign the SPD summary to global lastSDPsummary
@@ -2298,7 +2298,7 @@ remove_tap_listener_sdp_calls(voip_calls_tapinfo_t *tap_id_base)
 static gboolean
 is_mgcp_signal(const gchar *signal_str_p, const gchar *signalStr)
 {
-    gint i;
+    gint    i;
     gchar **resultArray;
 
     /* if there is no signalStr, just return false */
@@ -2352,7 +2352,7 @@ mgcp_dialed_digits(gchar *signalStr, gchar **dialedDigits)
 {
     gchar *tmpStr;
     gchar *resultStr;
-    gint i,j;
+    gint   i,j;
 
     /* start with 1 for the null-terminator */
     guint resultStrLen = 1;
@@ -2403,19 +2403,18 @@ mgcp_dialed_digits(gchar *signalStr, gchar **dialedDigits)
 static gboolean
 mgcp_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *MGCPinfo)
 {
-    voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_mgcp_);
-
-    voip_calls_info_t *tmp_listinfo;
-    voip_calls_info_t *callsinfo = NULL;
-    mgcp_calls_info_t *tmp_mgcpinfo = NULL;
-    GList *list;
-    GList *listGraph = NULL;
-    gchar *frame_label = NULL;
-    gchar *comment = NULL;
-    seq_analysis_item_t *gai = NULL;
-    gboolean newcall = FALSE;
-    gboolean fromEndpoint = FALSE; /* true for calls originated in Endpoints, false for calls from MGC */
-    gdouble diff_time;
+    voip_calls_tapinfo_t *tapinfo      = tap_id_to_base(tap_offset_ptr, tap_id_offset_mgcp_);
+    voip_calls_info_t    *tmp_listinfo;
+    voip_calls_info_t    *callsinfo    = NULL;
+    mgcp_calls_info_t    *tmp_mgcpinfo = NULL;
+    GList                *list;
+    GList                *listGraph    = NULL;
+    gchar                *frame_label  = NULL;
+    gchar                *comment      = NULL;
+    seq_analysis_item_t  *gai          = NULL;
+    gboolean              newcall      = FALSE;
+    gboolean              fromEndpoint = FALSE; /* true for calls originated in Endpoints, false for calls from MGC */
+    gdouble               diff_time;
 
     const mgcp_info_t *pi = (const mgcp_info_t *)MGCPinfo;
 
@@ -2666,12 +2665,12 @@ remove_tap_listener_mgcp_calls(voip_calls_tapinfo_t *tap_id_base)
 static gboolean
 actrace_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *ACTRACEinfo)
 {
-    voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_actrace_);
-    const actrace_info_t *pi = (const actrace_info_t *)ACTRACEinfo;
-    GList *list;
+    voip_calls_tapinfo_t     *tapinfo   = tap_id_to_base(tap_offset_ptr, tap_id_offset_actrace_);
+    const actrace_info_t     *pi        = (const actrace_info_t *)ACTRACEinfo;
+    GList                    *list;
     actrace_cas_calls_info_t *tmp_actrace_cas_info;
-    voip_calls_info_t *tmp_listinfo;
-    voip_calls_info_t *callsinfo = NULL;
+    voip_calls_info_t        *tmp_listinfo;
+    voip_calls_info_t        *callsinfo = NULL;
 
     tapinfo->actrace_frame_num = pinfo->fd->num;
     tapinfo->actrace_trunk = pi->trunk;
@@ -2779,19 +2778,19 @@ remove_tap_listener_actrace_calls(voip_calls_tapinfo_t *tap_id_base)
 /****************************************************************************/
 
 #define gcp_is_req(type) ( type == GCP_CMD_ADD_REQ || type == GCP_CMD_MOVE_REQ || type == GCP_CMD_MOD_REQ || \
-							type == GCP_CMD_SUB_REQ || type == GCP_CMD_AUDITCAP_REQ || type == GCP_CMD_AUDITVAL_REQ || \
-							type == GCP_CMD_NOTIFY_REQ || type == GCP_CMD_SVCCHG_REQ || type == GCP_CMD_TOPOLOGY_REQ || \
-							type == GCP_CMD_CTX_ATTR_AUDIT_REQ )
+                           type == GCP_CMD_SUB_REQ || type == GCP_CMD_AUDITCAP_REQ || type == GCP_CMD_AUDITVAL_REQ || \
+                           type == GCP_CMD_NOTIFY_REQ || type == GCP_CMD_SVCCHG_REQ || type == GCP_CMD_TOPOLOGY_REQ || \
+                           type == GCP_CMD_CTX_ATTR_AUDIT_REQ )
 
 static gboolean
 h248_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *prot_info) {
-    voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_h248_);
-    const gcp_cmd_t *cmd = (const gcp_cmd_t *)prot_info;
-    GList *list;
-    voip_calls_info_t *callsinfo = NULL;
-    address *mgw;
-    address *mgc;
-    gchar mgw_addr[128];
+    voip_calls_tapinfo_t *tapinfo   = tap_id_to_base(tap_offset_ptr, tap_id_offset_h248_);
+    const gcp_cmd_t      *cmd       = (const gcp_cmd_t *)prot_info;
+    GList                *list;
+    voip_calls_info_t    *callsinfo = NULL;
+    address              *mgw;
+    address              *mgc;
+    gchar                 mgw_addr[128];
 
     if (cmd->ctx->id == NULL_CONTEXT || cmd->ctx->id == ALL_CONTEXTS ) {
         return FALSE;
@@ -2936,12 +2935,12 @@ const value_string* sccp_payload_values;
 
 static gboolean
 sccp_calls(voip_calls_tapinfo_t *tapinfo, packet_info *pinfo, epan_dissect_t *edt, const void *prot_info) {
-    const sccp_msg_info_t* msg = (const sccp_msg_info_t *)prot_info;
-    sccp_assoc_info_t* assoc = msg->data.co.assoc;
-    GList *list;
-    voip_calls_info_t *callsinfo = NULL;
-    gchar *label = NULL;
-    const gchar *comment = NULL;
+    const sccp_msg_info_t*  msg       = (const sccp_msg_info_t *)prot_info;
+    sccp_assoc_info_t*      assoc     = msg->data.co.assoc;
+    GList                  *list;
+    voip_calls_info_t      *callsinfo = NULL;
+    gchar                  *label     = NULL;
+    const gchar            *comment   = NULL;
     /* check whether we already have this assoc in the list */
 
     for(list = g_queue_peek_nth_link(tapinfo->callsinfos, 0) ; list ; list = g_list_next (list) ) {
@@ -3101,14 +3100,14 @@ remove_tap_listener_sccp_calls(voip_calls_tapinfo_t *tap_id_base)
 static gboolean
 unistim_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *unistim_info)
 {
-    voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_unistim_);
-    voip_calls_info_t *tmp_listinfo;
-    voip_calls_info_t *callsinfo = NULL;
-    unistim_info_t *tmp_unistim_info = NULL;
-    GList *list = NULL;
-    GString *g_tmp = NULL;
-    const gchar *frame_label = NULL;
-    gchar *comment = NULL;
+    voip_calls_tapinfo_t *tapinfo          = tap_id_to_base(tap_offset_ptr, tap_id_offset_unistim_);
+    voip_calls_info_t    *tmp_listinfo;
+    voip_calls_info_t    *callsinfo        = NULL;
+    unistim_info_t       *tmp_unistim_info = NULL;
+    GList                *list             = NULL;
+    GString              *g_tmp            = NULL;
+    const gchar          *frame_label      = NULL;
+    gchar                *comment          = NULL;
 
     /* Fetch specific packet infos */
     const unistim_info_t *pi = (const unistim_info_t *)unistim_info;
@@ -3762,12 +3761,12 @@ static void free_iax2_info(gpointer p) {
 static gboolean
 iax2_calls_packet( void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *iax2_info)
 {
-    voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_iax2_);
-    GList* list;
-    voip_calls_info_t *callsinfo = NULL;
-    address* phone;
-    const iax2_info_t *ii = (const iax2_info_t *)iax2_info;
-    iax2_info_t *tmp_iax2info;
+    voip_calls_tapinfo_t *tapinfo   = tap_id_to_base(tap_offset_ptr, tap_id_offset_iax2_);
+    GList*                list;
+    voip_calls_info_t    *callsinfo = NULL;
+    address              *phone;
+    const iax2_info_t    *ii        = (const iax2_info_t *)iax2_info;
+    iax2_info_t          *tmp_iax2info;
 
     if (ii == NULL || ii->ptype != IAX2_FULL_PACKET || (ii->scallno == 0 && ii->dcallno == 0))
         return FALSE;
@@ -3883,8 +3882,8 @@ static gboolean
 voip_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt, const void *VoIPinfo)
 {
     voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_voip_);
-    voip_calls_info_t *callsinfo = NULL;
-    voip_calls_info_t *tmp_listinfo;
+    voip_calls_info_t    *callsinfo = NULL;
+    voip_calls_info_t    *tmp_listinfo;
     GList *list = NULL;
     const voip_packet_info_t *pi = (const voip_packet_info_t *)VoIPinfo;
 
@@ -3980,55 +3979,56 @@ remove_tap_listener_voip_calls(voip_calls_tapinfo_t *tap_id_base)
 
 /****************************************************************************/
 /* whenever a prot_ packet is seen by the tap listener */
-/*
+#if 0
 static gboolean
 prot_calls_packet(void *tap_offset_ptr, packet_info *pinfo, epan_dissect_t *edt _U_, const void *prot_info _U_)
 {
-	voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_prot_);
-	if (callsinfo!=NULL) {
-		callsinfo->stop_abs = pinfo->fd->abs_ts;
-		callsinfo->stop_rel = pinfo->rel_ts;
-		callsinfo->last_frame_num=pinfo->fd->num;
-		++(callsinfo->npackets);
-		++(tapinfo->npackets);
-	}
+    voip_calls_tapinfo_t *tapinfo = tap_id_to_base(tap_offset_ptr, tap_id_offset_prot_);
+    if (callsinfo!=NULL) {
+        callsinfo->stop_abs = pinfo->fd->abs_ts;
+        callsinfo->stop_rel = pinfo->rel_ts;
+        callsinfo->last_frame_num=pinfo->fd->num;
+        ++(callsinfo->npackets);
+        ++(tapinfo->npackets);
+    }
 
-	tapinfo->redraw = TRUE;
+    tapinfo->redraw = TRUE;
 
     return TRUE;
 }
-*/
-/****************************************************************************/
-/*
+#endif
 
+/****************************************************************************/
+#if 0
 void
 prot_calls_init_tap(voip_calls_tapinfo_t *tap_id_base)
 {
-	GString *error_string;
+    GString *error_string;
 
-	error_string = register_tap_listener("prot_", tap_base_to_id(tap_id_base, tap_id_offset_prot_),
-		NULL,
-		0,
-        NULL,
-        prot__calls_packet,
-        NULL
-		);
+    error_string = register_tap_listener("prot_", tap_base_to_id(tap_id_base, tap_id_offset_prot_),
+                                         NULL,
+                                         0,
+                                         NULL,
+                                         prot__calls_packet,
+                                         NULL
+        );
 
-	if (error_string != NULL) {
-		simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,
-			      "%s", error_string->str);
-		g_string_free(error_string, TRUE);
-	}
+    if (error_string != NULL) {
+        simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,
+                      "%s", error_string->str);
+        g_string_free(error_string, TRUE);
+    }
 }
-*/
+#endif
+
 /****************************************************************************/
-/*
+#if 0
 void
 remove_tap_listener_prot__calls(voip_calls_tapinfo_t *tap_id_base)
 {
-	remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_prot_));
+    remove_tap_listener(tap_base_to_id(tap_id_base, tap_id_offset_prot_));
 }
-*/
+#endif
 
 /*
  * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
diff --git a/ui/voip_calls.h b/ui/voip_calls.h
index 91308e6ab5..dbc26d0515 100644
--- a/ui/voip_calls.h
+++ b/ui/voip_calls.h
@@ -103,9 +103,9 @@ typedef struct _sip_calls_info {
 
 /** defines specific ISUP data */
 typedef struct _isup_calls_info {
-    guint16			cic;
-    guint32			opc, dpc;
-    guint8			ni;
+    guint16 cic;
+    guint32 opc, dpc;
+    guint8  ni;
 } isup_calls_info_t;
 
 /* defines specific H245 data */
@@ -116,16 +116,16 @@ typedef struct _h245_address {
 
 /** defines specific H323 data */
 typedef struct _h323_calls_info {
-    e_guid_t *guid;	/* Call ID to identify a H225 */
-    GList*  h245_list;				/**< list of H245 Address and ports for tunneling off calls*/
-    address h225SetupAddr;			/**< we use the SETUP H225 IP to determine if packets are forward or reverse */
-    gboolean is_h245;
-    gboolean is_faststart_Setup;	/**< if faststart field is included in Setup*/
-    gboolean is_faststart_Proc;		/**< if faststart field is included in Proce, Alerting, Progress or Connect*/
-    gboolean is_h245Tunneling;
-    gint32 q931_crv;
-    gint32 q931_crv2;
-    guint requestSeqNum;
+    e_guid_t *guid;               /* Call ID to identify a H225 */
+    GList*    h245_list;          /**< list of H245 Address and ports for tunneling off calls*/
+    address   h225SetupAddr;      /**< we use the SETUP H225 IP to determine if packets are forward or reverse */
+    gboolean  is_h245;
+    gboolean  is_faststart_Setup; /**< if faststart field is included in Setup*/
+    gboolean  is_faststart_Proc;  /**< if faststart field is included in Proce, Alerting, Progress or Connect*/
+    gboolean  is_h245Tunneling;
+    gint32    q931_crv;
+    gint32    q931_crv2;
+    guint     requestSeqNum;
 } h323_calls_info_t;
 
 /**< defines specific MGCP data */
@@ -153,25 +153,25 @@ typedef struct _skinny_calls_info {
 
 /** defines a voip call */
 typedef struct _voip_calls_info {
-    voip_call_state call_state;
-    voip_call_active_state call_active_state;
-    gchar *call_id;
-    gchar *from_identity;
-    gchar *to_identity;
-    gpointer prot_info;
-    void(*free_prot_info)(gpointer);
-    address initial_speaker;
-    guint32 npackets;
-    voip_protocol protocol;
-    gchar *protocol_name;
-    gchar *call_comment;
-    guint16 call_num;
+    voip_call_state         call_state;
+    voip_call_active_state  call_active_state;
+    gchar                  *call_id;
+    gchar                  *from_identity;
+    gchar                  *to_identity;
+    gpointer                prot_info;
+    void (*free_prot_info)(gpointer);
+    address                 initial_speaker;
+    guint32                 npackets;
+    voip_protocol           protocol;
+    gchar                  *protocol_name;
+    gchar                  *call_comment;
+    guint16                 call_num;
     /**> The frame_data struct holds the frame number and timing information needed. */
-    frame_data *start_fd;
-    nstime_t start_rel_ts;
-    frame_data *stop_fd;
-    nstime_t stop_rel_ts;
-    gboolean selected; /* GTK+ only */
+    frame_data             *start_fd;
+    nstime_t                start_rel_ts;
+    frame_data             *stop_fd;
+    nstime_t                stop_rel_ts;
+    gboolean                selected; /* GTK+ only */
 
 } voip_calls_info_t;
 
@@ -184,46 +184,46 @@ typedef struct _voip_calls_info {
  */
 struct _h245_labels;
 typedef struct _voip_calls_tapinfo {
-    tap_reset_cb tap_reset;                 /**< tap reset callback */
-    tap_packet_cb tap_packet;               /**< tap per-packet callback */
-    tap_draw_cb tap_draw;                   /**< tap draw callback */
-    void *tap_data;                         /**< data for tap callbacks */
-    int ncalls;                             /**< number of call */
-    GQueue* callsinfos;                     /**< queue with all calls */
-    GHashTable* callsinfo_hashtable[1];     /**< array of hashes per voip protocol; currently only the one for SIP is used */
-    int npackets;                           /**< total number of packets of all calls */
-    voip_calls_info_t* filter_calls_fwd;    /**< used as filter in some tap modes */
-    int start_packets;
-    int completed_calls;
-    int rejected_calls;
-    seq_analysis_info_t* graph_analysis;
-    epan_t *session;                        /**< epan session */
-    int nrtp_streams;                       /**< number of rtp streams */
-    GList* rtp_stream_list;                 /**< list of rtp_stream_info_t */
-    guint32 rtp_evt_frame_num;
-    guint8 rtp_evt;
-    gboolean rtp_evt_end;
-    gchar *sdp_summary;
-    guint32 sdp_frame_num;
-    guint32 mtp3_opc;
-    guint32 mtp3_dpc;
-    guint8 mtp3_ni;
-    guint32 mtp3_frame_num;
-    struct _h245_labels *h245_labels;       /**< H.245 labels */
-    gchar *q931_calling_number;
-    gchar *q931_called_number;
-    guint8 q931_cause_value;
-    gint32 q931_crv;
-    guint32 q931_frame_num;
-    guint32 h225_frame_num;
-    guint16 h225_call_num;
-    int h225_cstype;                        /* XXX actually an enum */
-    gboolean h225_is_faststart;
-    guint32 actrace_frame_num;
-    gint32 actrace_trunk;
-    gint32 actrace_direction;
-    flow_show_options fs_option;
-    gboolean redraw;
+    tap_reset_cb          tap_reset; /**< tap reset callback */
+    tap_packet_cb         tap_packet; /**< tap per-packet callback */
+    tap_draw_cb           tap_draw; /**< tap draw callback */
+    void                 *tap_data; /**< data for tap callbacks */
+    int                   ncalls; /**< number of call */
+    GQueue*               callsinfos; /**< queue with all calls */
+    GHashTable*           callsinfo_hashtable[1]; /**< array of hashes per voip protocol; currently only the one for SIP is used */
+    int                   npackets; /**< total number of packets of all calls */
+    voip_calls_info_t    *filter_calls_fwd; /**< used as filter in some tap modes */
+    int                   start_packets;
+    int                   completed_calls;
+    int                   rejected_calls;
+    seq_analysis_info_t  *graph_analysis;
+    epan_t               *session; /**< epan session */
+    int                   nrtp_streams; /**< number of rtp streams */
+    GList*                rtp_stream_list; /**< list of rtp_stream_info_t */
+    guint32               rtp_evt_frame_num;
+    guint8                rtp_evt;
+    gboolean              rtp_evt_end;
+    gchar                *sdp_summary;
+    guint32               sdp_frame_num;
+    guint32               mtp3_opc;
+    guint32               mtp3_dpc;
+    guint8                mtp3_ni;
+    guint32               mtp3_frame_num;
+    struct _h245_labels  *h245_labels; /**< H.245 labels */
+    gchar                *q931_calling_number;
+    gchar                *q931_called_number;
+    guint8                q931_cause_value;
+    gint32                q931_crv;
+    guint32               q931_frame_num;
+    guint32               h225_frame_num;
+    guint16               h225_call_num;
+    int                   h225_cstype; /* XXX actually an enum */
+    gboolean              h225_is_faststart;
+    guint32               actrace_frame_num;
+    gint32                actrace_trunk;
+    gint32                actrace_direction;
+    flow_show_options     fs_option;
+    gboolean              redraw;
 } voip_calls_tapinfo_t;
 
 /****************************************************************************/
diff --git a/wiretap/csids.c b/wiretap/csids.c
index a6848b40d2..387f54dfa5 100644
--- a/wiretap/csids.c
+++ b/wiretap/csids.c
@@ -43,11 +43,11 @@ typedef struct {
 } csids_t;
 
 static gboolean csids_read(wtap *wth, int *err, gchar **err_info,
-	gint64 *data_offset);
+        gint64 *data_offset);
 static gboolean csids_seek_read(wtap *wth, gint64 seek_off,
-	struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info);
+        struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info);
 static gboolean csids_read_packet(FILE_T fh, csids_t *csids,
-	struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info);
+        struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info);
 
 struct csids_header {
   guint32 seconds; /* seconds since epoch */
diff --git a/wiretap/lanalyzer.c b/wiretap/lanalyzer.c
index 5b8bf365ba..499f1bfc14 100644
--- a/wiretap/lanalyzer.c
+++ b/wiretap/lanalyzer.c
@@ -28,14 +28,14 @@
 /* The LANalyzer format is documented (at least in part) in Novell document
    TID022037, which can be found at, among other places:
 
-	http://www.windowsecurity.com/whitepapers/Description_of_the_LANalysers_output_file.html
+     http://www.windowsecurity.com/whitepapers/Description_of_the_LANalysers_output_file.html
  */
 
 /*    Record header format */
 
 typedef struct {
-      guint8	record_type[2];
-      guint8	record_length[2];
+      guint8    record_type[2];
+      guint8    record_length[2];
 } LA_RecordHeader;
 
 #define LA_RecordHeaderSize 4
@@ -121,8 +121,8 @@ typedef guint16 TimeStamp[3];  /* 0.5 microseconds since start of trace */
 
 /* LANalyzer board types (which indicate the type of network on which
    the capture was done). */
-#define BOARD_325		226	/* LANalyzer 325 (Ethernet) */
-#define BOARD_325TR		227	/* LANalyzer 325TR (Token-ring) */
+#define BOARD_325               226     /* LANalyzer 325 (Ethernet) */
+#define BOARD_325TR             227     /* LANalyzer 325TR (Token-ring) */
 
 
 /*
@@ -266,7 +266,7 @@ static const guint8 z64[64] = {
       };
 
 typedef struct {
-	time_t	start;
+      time_t  start;
 } lanalyzer_t;
 
 static gboolean lanalyzer_read(wtap *wth, int *err, gchar **err_info,
@@ -405,7 +405,7 @@ wtap_open_return_val lanalyzer_open(wtap *wth, int *err, gchar **err_info)
                   default:
                         *err = WTAP_ERR_UNSUPPORTED;
                         *err_info = g_strdup_printf("lanalyzer: board type %u unknown",
-						    board_type);
+                                                    board_type);
                         return WTAP_OPEN_ERROR;
                   }
                   break;
@@ -428,21 +428,21 @@ wtap_open_return_val lanalyzer_open(wtap *wth, int *err, gchar **err_info)
       }
 }
 
-#define DESCRIPTOR_LEN	32
+#define DESCRIPTOR_LEN  32
 
 static gboolean lanalyzer_read_trace_record(wtap *wth, FILE_T fh,
                                             struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)
 {
-      char		LE_record_type[2];
-      char		LE_record_length[2];
-      guint16		record_type, record_length;
-      int		record_data_size;
-      int		packet_size;
-      gchar		descriptor[DESCRIPTOR_LEN];
-      lanalyzer_t	*lanalyzer;
-      guint16		time_low, time_med, time_high, true_size;
-      guint64		t;
-      time_t		tsecs;
+      char         LE_record_type[2];
+      char         LE_record_length[2];
+      guint16      record_type, record_length;
+      int          record_data_size;
+      int          packet_size;
+      gchar        descriptor[DESCRIPTOR_LEN];
+      lanalyzer_t *lanalyzer;
+      guint16      time_low, time_med, time_high, true_size;
+      guint64      t;
+      time_t       tsecs;
 
       /* read the record type and length. */
       if (!wtap_read_bytes_or_eof(fh, LE_record_type, 2, err, err_info))
@@ -502,7 +502,7 @@ static gboolean lanalyzer_read_trace_record(wtap *wth, FILE_T fh,
       time_med = pletoh16(&descriptor[10]);
       time_high = pletoh16(&descriptor[12]);
       t = (((guint64)time_low) << 0) + (((guint64)time_med) << 16) +
-	    (((guint64)time_high) << 32);
+            (((guint64)time_high) << 32);
       tsecs = (time_t) (t/2000000);
       lanalyzer = (lanalyzer_t *)wth->priv;
       phdr->ts.secs = tsecs + lanalyzer->start;
@@ -623,8 +623,8 @@ static void my_timersub(const struct timeval *a,
  * Returns TRUE on success, FALSE on failure.
  *---------------------------------------------------*/
 static gboolean lanalyzer_dump(wtap_dumper *wdh,
-	const struct wtap_pkthdr *phdr,
-	const guint8 *pd, int *err, gchar **err_info _U_)
+        const struct wtap_pkthdr *phdr,
+        const guint8 *pd, int *err, gchar **err_info _U_)
 {
       double x;
       int    i;
@@ -667,7 +667,7 @@ static gboolean lanalyzer_dump(wtap_dumper *wdh,
             /* collect some information for the
              * finally written header
              */
-		    /* XXX - this conversion could probably improved, if the start uses ns */
+            /* XXX - this conversion could probably improved, if the start uses ns */
             itmp->start   = tv;
             itmp->pkts    = 0;
             itmp->init    = TRUE;
@@ -743,8 +743,8 @@ gboolean lanalyzer_dump_open(wtap_dumper *wdh, int *err)
 
       tmp = g_malloc(sizeof(LA_TmpInfo));
       if (!tmp) {
-	      *err = errno;
-	      return FALSE;
+            *err = errno;
+            return FALSE;
             }
 
       ((LA_TmpInfo*)tmp)->init = FALSE;
@@ -768,7 +768,7 @@ gboolean lanalyzer_dump_open(wtap_dumper *wdh, int *err)
            + LA_IndexRecordSize;
 
       if (wtap_dump_file_seek(wdh, jump, SEEK_SET, err) == -1)
-	      return FALSE;
+            return FALSE;
 
       wdh->bytes_dumped = jump;
       return TRUE;
@@ -798,26 +798,26 @@ static gboolean lanalyzer_dump_header(wtap_dumper *wdh, int *err)
             return FALSE;
 
       if (wtap_dump_file_seek(wdh, 0, SEEK_SET, err) == -1)
-	    return FALSE;
+            return FALSE;
 
       if (!wtap_dump_file_write(wdh, &LA_HeaderRegularFake,
                                 sizeof LA_HeaderRegularFake, err))
-		return FALSE;
+            return FALSE;
       if (!wtap_dump_file_write(wdh, &LA_RxChannelNameFake,
                                 sizeof LA_RxChannelNameFake, err))
-		return FALSE;
+            return FALSE;
       if (!wtap_dump_file_write(wdh, &LA_TxChannelNameFake,
                                 sizeof LA_TxChannelNameFake, err))
-		return FALSE;
+            return FALSE;
       if (!wtap_dump_file_write(wdh, &LA_RxTemplateNameFake,
                                 sizeof LA_RxTemplateNameFake, err))
-		return FALSE;
+            return FALSE;
       if (!wtap_dump_file_write(wdh, &LA_TxTemplateNameFake,
                                 sizeof LA_TxTemplateNameFake, err))
-		return FALSE;
+            return FALSE;
       if (!wtap_dump_file_write(wdh, &LA_DisplayOptionsFake,
                                 sizeof LA_DisplayOptionsFake, err))
-		return FALSE;
+            return FALSE;
       /*-----------------------------------------------------------------*/
       if (!s16write(wdh, GUINT16_TO_LE(RT_Summary), err))         /* rid */
             return FALSE;
diff --git a/wiretap/wtap.h b/wiretap/wtap.h
index e27ee772b0..348d3a9495 100644
--- a/wiretap/wtap.h
+++ b/wiretap/wtap.h
@@ -1317,9 +1317,9 @@ struct file_extension_info {
  * and will likely just overwrite the pointer.
  */
 typedef enum {
-	WTAP_OPEN_NOT_MINE = 0,
-	WTAP_OPEN_MINE = 1,
-	WTAP_OPEN_ERROR = -1
+    WTAP_OPEN_NOT_MINE = 0,
+    WTAP_OPEN_MINE = 1,
+    WTAP_OPEN_ERROR = -1
 } wtap_open_return_val;
 
 typedef wtap_open_return_val (*wtap_open_routine_t)(struct wtap*, int *,
@@ -1345,8 +1345,8 @@ typedef wtap_open_return_val (*wtap_open_routine_t)(struct wtap*, int *,
  */
 
 typedef enum {
-	OPEN_INFO_MAGIC = 0,
-	OPEN_INFO_HEURISTIC = 1
+    OPEN_INFO_MAGIC = 0,
+    OPEN_INFO_HEURISTIC = 1
 } wtap_open_type;
 
 WS_DLL_PUBLIC void init_open_routines(void);
diff --git a/wsutil/strptime.c b/wsutil/strptime.c
index c711d7ebdb..0a9128488b 100644
--- a/wsutil/strptime.c
+++ b/wsutil/strptime.c
@@ -27,7 +27,7 @@
 #include "config.h"
 
 #include <ctype.h>
-#include <string.h>		
+#include <string.h>
 #include <glib.h>
 
 #ifdef _LIBC

