commit 6f56e9cf581c6cedcaea3eb69444b169867ccf3d
Author: Dean Nelson <dnelson@redhat.com>
Date:   Thu Aug 20 11:16:32 2015 -0400

    tools lib traceevent: Add checks for returned EVENT_ERROR type
    
    Running the following perf-stat command on an arm64 system produces the
    following result...
    
      [root@aarch64 ~]# perf stat -e kmem:mm_page_alloc -a sleep 1
        Warning: [kmem:mm_page_alloc] function sizeof not defined
        Warning: Error: expected type 4 but read 0
      Segmentation fault
      [root@aarch64 ~]#
    
    The second warning was a result of the first warning not stopping
    processing after it detected the issue.
    
    That is, code that found the issue reported the first problem, but
    because it did not exit out of the functions smoothly, it caused the
    other warning to appear and not only that, it later caused the SIGSEGV.
    
    Signed-off-by: Dean Nelson <dnelson@redhat.com>
    Reviewed-by: Steven Rostedt <rostedt@goodmis.org>
    Acked-by: Namhyung Kim <namhyung@kernel.org>
    Cc: Jiri Olsa <jolsa@kernel.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/20150820151632.13927.13791.email-sent-by-dnelson@teal
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/lib/traceevent/event-parse.c b/tools/lib/traceevent/event-parse.c
index fcd8a9e3d2e1..5c1867a13ef2 100644
--- a/tools/lib/traceevent/event-parse.c
+++ b/tools/lib/traceevent/event-parse.c
@@ -1745,6 +1745,9 @@ process_cond(struct event_format *event, struct print_arg *top, char **tok)
 	type = process_arg(event, left, &token);
 
  again:
+	if (type == EVENT_ERROR)
+		goto out_free;
+
 	/* Handle other operations in the arguments */
 	if (type == EVENT_OP && strcmp(token, ":") != 0) {
 		type = process_op(event, left, &token);
@@ -2004,6 +2007,12 @@ process_op(struct event_format *event, struct print_arg *arg, char **tok)
 			goto out_warn_free;
 
 		type = process_arg_token(event, right, tok, type);
+		if (type == EVENT_ERROR) {
+			free_arg(right);
+			/* token was freed in process_arg_token() via *tok */
+			token = NULL;
+			goto out_free;
+		}
 
 		if (right->type == PRINT_OP &&
 		    get_op_prio(arg->op.op) < get_op_prio(right->op.op)) {

