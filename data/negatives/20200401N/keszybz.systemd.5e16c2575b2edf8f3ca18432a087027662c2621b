commit 5e16c2575b2edf8f3ca18432a087027662c2621b
Author: Kay Sievers <kay@vrfy.org>
Date:   Fri Dec 6 20:19:20 2013 +0100

    bus: catch up with latest kdbus changes

diff --git a/src/libsystemd-bus/bus-kernel.c b/src/libsystemd-bus/bus-kernel.c
index f23489188..495d7e57d 100644
--- a/src/libsystemd-bus/bus-kernel.c
+++ b/src/libsystemd-bus/bus-kernel.c
@@ -1063,7 +1063,7 @@ int bus_kernel_create_bus(const char *name, char **s) {
         n = make->items;
         sprintf(n->str, "%lu-%s", (unsigned long) getuid(), name);
         n->size = offsetof(struct kdbus_item, str) + strlen(n->str) + 1;
-        n->type = KDBUS_MAKE_NAME;
+        n->type = KDBUS_ITEM_MAKE_NAME;
 
         make->size = ALIGN8(offsetof(struct kdbus_cmd_bus_make, items) + n->size);
         make->flags = KDBUS_MAKE_POLICY_OPEN;
@@ -1166,7 +1166,7 @@ int bus_kernel_create_namespace(const char *name, char **s) {
         n = make->items;
         strcpy(n->str, name);
         n->size = offsetof(struct kdbus_item, str) + strlen(n->str) + 1;
-        n->type = KDBUS_MAKE_NAME;
+        n->type = KDBUS_ITEM_MAKE_NAME;
 
         make->size = ALIGN8(offsetof(struct kdbus_cmd_ns_make, items) + n->size);
         make->flags = KDBUS_MAKE_POLICY_OPEN | KDBUS_MAKE_ACCESS_WORLD;
diff --git a/src/libsystemd-bus/kdbus.h b/src/libsystemd-bus/kdbus.h
index 6775789fe..d89f8c088 100644
--- a/src/libsystemd-bus/kdbus.h
+++ b/src/libsystemd-bus/kdbus.h
@@ -33,13 +33,13 @@
  * @flags:		flags from KDBUS_NAME_*
  * @name:		Well-known name
  *
- * Data attached to:
+ * Sent from kernel to userspace when the owner or starter of
+ * a well-known name changes.
+ *
+ * Attached to:
  *   KDBUS_ITEM_NAME_ADD
  *   KDBUS_ITEM_NAME_REMOVE
  *   KDBUS_ITEM_NAME_CHANGE
- *
- * Sent from kernel to userspace when the owner or starter of
- * a well-known name changes.
  */
 struct kdbus_notify_name_change {
 	__u64 old_id;
@@ -53,12 +53,12 @@ struct kdbus_notify_name_change {
  * @id:			New or former owner of the name
  * @flags:		flags field from KDBUS_HELLO_*
  *
- * Data attached to:
- *   KDBUS_ITEM_ID_ADD
- *   KDBUS_ITEM_ID_REMOVE
- *
  * Sent from kernel to userspace when the owner or starter of
  * a well-known name changes.
+ *
+ * Attached to:
+ *   KDBUS_ITEM_ID_ADD
+ *   KDBUS_ITEM_ID_REMOVE
  */
 struct kdbus_notify_id_change {
 	__u64 id;
@@ -77,6 +77,9 @@ struct kdbus_notify_id_change {
  * from the client side. i.e. if you use the PID to look something up in
  * /proc/$PID/ you can afterwards check the starttime field of it, to ensure
  * you didn't run into a PID overrun.
+ *
+ * Attached to:
+ *   KDBUS_ITEM_CREDS
  */
 struct kdbus_creds {
 	__u64 uid;
@@ -90,6 +93,9 @@ struct kdbus_creds {
  * struct kdbus_audit - audit information
  * @sessionid:		The audit session ID
  * @loginuid:		The audit login uid
+ *
+ * Attached to:
+ *   KDBUS_ITEM_AUDIT
  */
 struct kdbus_audit {
 	__u64 sessionid;
@@ -100,6 +106,9 @@ struct kdbus_audit {
  * struct kdbus_timestamp
  * @monotonic_ns:	Monotonic timestamp, in nanoseconds
  * @realtime_ns:	Realtime timestamp, in nanoseconds
+ *
+ * Attached to:
+ *   KDBUS_ITEM_TIMESTAMP
  */
 struct kdbus_timestamp {
 	__u64 monotonic_ns;
@@ -111,6 +120,9 @@ struct kdbus_timestamp {
  * @size:		The size of the vector
  * @address:		Memory address for memory addresses
  * @offset:		Offset in the in-message payload memory
+ *
+ * Attached to:
+ *   KDBUS_ITEM_PAYLOAD_VEC
  */
 struct kdbus_vec {
 	__u64 size;
@@ -125,6 +137,9 @@ struct kdbus_vec {
  * @size:		The memfd's size
  * @fd:			The file descriptor number
  * @__pad:		Padding to make the struct aligned
+ *
+ * Attached to:
+ *   KDBUS_ITEM_PAYLOAD_MEMFD
  */
 struct kdbus_memfd {
 	__u64 size;
@@ -136,6 +151,9 @@ struct kdbus_memfd {
  * struct kdbus_name - a registered well-known name with its flags
  * @flags:		flags from KDBUS_NAME_*
  * @name:		well-known name
+ *
+ * Attached to:
+ *   KDBUS_ITEM_NAME
  */
 struct kdbus_name {
 	__u64 flags;
@@ -148,6 +166,9 @@ struct kdbus_name {
  * @bits:		Access to grant. One of KDBUS_POLICY_*
  * @id:			For KDBUS_POLICY_ACCESS_USER, the uid
  * 			For KDBUS_POLICY_ACCESS_GROUP, the gid
+ *
+ * Embedded in:
+ *   struct kdbus_policy
  */
 struct kdbus_policy_access {
 	__u64 type;	/* USER, GROUP, WORLD */
@@ -155,14 +176,14 @@ struct kdbus_policy_access {
 	__u64 id;	/* uid, gid, 0 */
 };
 
-/*
- * struct kdbus_policy - a policy to upload
- * @size:		The total size of the structure
- * @type:		KDBUS_POLICY_NAME or KDBUS_POLICY_ACCESS
- * @name:		The well-known name to grant access to,
- * 			if @type is KDBUS_POLICY_NAME
- * @access:		The policy access details,
- * 			if @type is KDBUS_POLICY_ACCESS
+/**
+ * struct kdbus_policy - a policy item
+ * @access:		Policy access details
+ * @name:		Well-known name to grant access to
+ *
+ * Attached to:
+ *   KDBUS_POLICY_ACCESS
+ *   KDBUS_ITEM_POLICY_NAME
  */
 struct kdbus_policy {
 	union {
@@ -171,78 +192,86 @@ struct kdbus_policy {
 	};
 };
 
-/* Message Item Types */
-enum {
+/* item types to chain data in lists of items */
+enum kdbus_item_type {
 	_KDBUS_ITEM_NULL,
-
-	/* Filled in by userspace */
 	_KDBUS_ITEM_USER_BASE,
-	KDBUS_ITEM_PAYLOAD_VEC	= _KDBUS_ITEM_USER_BASE,
-	KDBUS_ITEM_PAYLOAD_OFF,		/* .data_vec, reference to memory area */
-	KDBUS_ITEM_PAYLOAD_MEMFD,	/* file descriptor of a special data file */
-	KDBUS_ITEM_FDS,			/* .data_fds of file descriptors */
-	KDBUS_ITEM_BLOOM,		/* for broadcasts, carries bloom filter blob in .data */
-	KDBUS_ITEM_DST_NAME,		/* destination's well-known name, in .str */
+	KDBUS_ITEM_PAYLOAD_VEC	= _KDBUS_ITEM_USER_BASE, /* .data_vec */
+	KDBUS_ITEM_PAYLOAD_OFF,		/* data at returned offset in the pool */
+	KDBUS_ITEM_PAYLOAD_MEMFD,	/* data as sealed memfd */
+	KDBUS_ITEM_FDS,			/* attached file descriptors */
+	KDBUS_ITEM_BLOOM,		/* for broadcasts, carries bloom filter */
+	KDBUS_ITEM_DST_NAME,		/* destination's well-known name */
 	KDBUS_ITEM_PRIORITY,		/* queue priority for message */
+	KDBUS_ITEM_MAKE_NAME,
 
 	_KDBUS_ITEM_POLICY_BASE	= 0x400,
 	KDBUS_ITEM_POLICY_NAME = _KDBUS_ITEM_POLICY_BASE,
 	KDBUS_ITEM_POLICY_ACCESS,
 
-	/* Filled in by kernelspace */
 	_KDBUS_ITEM_ATTACH_BASE	= 0x600,
 	KDBUS_ITEM_NAME		= _KDBUS_ITEM_ATTACH_BASE,
-	KDBUS_ITEM_STARTER_NAME,	/* Only used in HELLO for starter connection */
-	KDBUS_ITEM_TIMESTAMP,		/* .timestamp */
-	KDBUS_ITEM_CREDS,		/* .creds */
-	KDBUS_ITEM_PID_COMM,		/* optional, in .str */
-	KDBUS_ITEM_TID_COMM,		/* optional, in .str */
-	KDBUS_ITEM_EXE,			/* optional, in .str */
-	KDBUS_ITEM_CMDLINE,		/* optional, in .str (a chain of NUL str) */
-	KDBUS_ITEM_CGROUP,		/* optional, in .str */
-	KDBUS_ITEM_CAPS,		/* caps data blob, in .data */
-	KDBUS_ITEM_SECLABEL,		/* NUL terminated string, in .str */
-	KDBUS_ITEM_AUDIT,		/* .audit */
-
-	/* Special messages from kernel, consisting of one and only one of these data blocks */
+	KDBUS_ITEM_STARTER_NAME,
+	KDBUS_ITEM_TIMESTAMP,
+	KDBUS_ITEM_CREDS,
+	KDBUS_ITEM_PID_COMM,
+	KDBUS_ITEM_TID_COMM,
+	KDBUS_ITEM_EXE,
+	KDBUS_ITEM_CMDLINE,
+	KDBUS_ITEM_CGROUP,
+	KDBUS_ITEM_CAPS,
+	KDBUS_ITEM_SECLABEL,
+	KDBUS_ITEM_AUDIT,
+
+	/* Special messages from kernel */
 	_KDBUS_ITEM_KERNEL_BASE	= 0x800,
 	KDBUS_ITEM_NAME_ADD	= _KDBUS_ITEM_KERNEL_BASE,
 	KDBUS_ITEM_NAME_REMOVE,		/* .name_change */
 	KDBUS_ITEM_NAME_CHANGE,		/* .name_change */
 	KDBUS_ITEM_ID_ADD,		/* .id_change */
 	KDBUS_ITEM_ID_REMOVE,		/* .id_change */
-	KDBUS_ITEM_REPLY_TIMEOUT,	/* empty, but .reply_cookie in .kdbus_msg is filled in */
+	KDBUS_ITEM_REPLY_TIMEOUT,	/* empty, reply_cookie is filled in */
 	KDBUS_ITEM_REPLY_DEAD,		/* dito */
 };
 
-/*
+/**
  * struct kdbus_item - chain of data blocks
- * @size:	:	overall data record size
- * @type:		kdbus_item type of data
+ * @size:		Overall data record size
+ * @type:		Kdbus_item type of data
+ * @data:		Generic bytes
+ * @data32:		Generic 32 bit array
+ * @data64:		Generic 64 bit array
+ * @str:		Generic string
+ * @id:			Connection ID
+ * @vec:		KDBUS_ITEM_PAYLOAD_VEC
+ * @creds:		KDBUS_ITEM_CREDS
+ * @audit:		KDBUS_ITEM_AUDIT
+ * @timestamp:		KDBUS_ITEM_TIMESTAMP
+ * @name:		KDBUS_ITEM_NAME
+ * @memfd:		KDBUS_ITEM_PAYLOAD_MEMFD
+ * @name_change:	KDBUS_ITEM_NAME_ADD
+ * 			KDBUS_ITEM_NAME_REMOVE
+ * 			KDBUS_ITEM_NAME_CHANGE
+ * @id_change:		KDBUS_ITEM_ID_ADD
+ * 			KDBUS_ITEM_ID_REMOVE
+ * @policy:		KDBUS_ITEM_POLICY_NAME
+ * 			KDBUS_ITEM_POLICY_ACCESS
  */
 struct kdbus_item {
 	__u64 size;
 	__u64 type;
 	union {
-		/* inline data */
 		__u8 data[0];
 		__u32 data32[0];
 		__u64 data64[0];
 		char str[0];
 
-		/* connection */
 		__u64 id;
-
-		/* data vector */
 		struct kdbus_vec vec;
-
-		/* process credentials and properties*/
 		struct kdbus_creds creds;
 		struct kdbus_audit audit;
 		struct kdbus_timestamp timestamp;
 		struct kdbus_name name;
-
-		/* specific fields */
 		struct kdbus_memfd memfd;
 		int fds[0];
 		struct kdbus_notify_name_change name_change;
@@ -251,12 +280,26 @@ struct kdbus_item {
 	};
 };
 
-enum {
+/**
+ * enum kdbus_msg_flags - type of message
+ * @KDBUS_MSG_FLAGS_EXPECT_REPLY:	Expect a reply message, used for method
+ * 					calls. The cookie identifies the
+ * 					message and the respective reply
+ * @KDBUS_MSG_FLAGS_NO_AUTO_START:	Do not start a service, if the addressed
+ * 					name is not currently active
+ */
+enum kdbus_msg_flags {
 	KDBUS_MSG_FLAGS_EXPECT_REPLY	= 1 << 0,
 	KDBUS_MSG_FLAGS_NO_AUTO_START	= 1 << 1,
 };
 
-enum {
+/**
+ * enum kdbus_payload_type - type of payload carried by message
+ * @KDBUS_PAYLOAD_KERNEL:	Kernel-generated simple message
+ * @KDBUS_PAYLOAD_DBUS1:	Legacy D-Bus version 1 marshalling
+ * @KDBUS_PAYLOAD_GVARIANT:	GVariant marshalling
+ */
+enum kdbus_payload_type {
 	KDBUS_PAYLOAD_KERNEL,
 	KDBUS_PAYLOAD_DBUS1	= 0x4442757356657231ULL, /* 'DBusVer1' */
 	KDBUS_PAYLOAD_GVARIANT	= 0x4756617269616e74ULL, /* 'GVariant' */
@@ -290,14 +333,26 @@ struct kdbus_msg {
 	struct kdbus_item items[0];
 };
 
-enum {
+/**
+ * enum kdbus_policy_access_type - permissions of a policy record
+ * @KDBUS_POLICY_ACCESS_USER:	Grant access to a uid
+ * @KDBUS_POLICY_ACCESS_GROUP:	Grant acces to gid
+ * @KDBUS_POLICY_ACCESS_WORLD:	World-accessible
+ */
+enum kdbus_policy_access_type {
 	_KDBUS_POLICY_ACCESS_NULL,
 	KDBUS_POLICY_ACCESS_USER,
 	KDBUS_POLICY_ACCESS_GROUP,
 	KDBUS_POLICY_ACCESS_WORLD,
 };
 
-enum {
+/**
+ * enum kdbus_policy_access_flags - mode flags
+ * @KDBUS_POLICY_RECV:		Allow receive
+ * @KDBUS_POLICY_SEND:		Allow send
+ * @KDBUS_POLICY_OWN:		Allow to own a well-known name
+ */
+enum kdbus_policy_type {
 	KDBUS_POLICY_RECV		= 1 <<  2,
 	KDBUS_POLICY_SEND		= 1 <<  1,
 	KDBUS_POLICY_OWN		= 1 <<  0,
@@ -317,14 +372,32 @@ struct kdbus_cmd_policy {
 	struct kdbus_item policies[0];
 };
 
-/* Flags for struct kdbus_cmd_hello */
-enum {
+/**
+ * enum kdbus_hello_flags - flags for struct kdbus_cmd_hello
+ * @KDBUS_HELLO_STARTER:		The connection registers a name for activation
+ * 				by well-know name
+ * @KDBUS_HELLO_ACCEPT_FD:	The connection allows the receiving of
+ * 				any passed file descriptors
+ */
+enum kdbus_hello_flags {
 	KDBUS_HELLO_STARTER		=  1 <<  0,
 	KDBUS_HELLO_ACCEPT_FD		=  1 <<  1,
 };
 
-/* Flags for message attachments */
-enum {
+/**
+ * enum kdbus_attach_flags - flags for metadata attachments
+ * @KDBUS_ATTACH_TIMESTAMP:	Timestamp
+ * @KDBUS_ATTACH_CREDS:		Credentials
+ * @KDBUS_ATTACH_NAMES:		Well-known names
+ * @KDBUS_ATTACH_COMM:		The "comm" process identifier
+ * @KDBUS_ATTACH_EXE:		The path of the executable
+ * @KDBUS_ATTACH_CMDLINE:	The process command line
+ * @KDBUS_ATTACH_CGROUP:	The croup membership
+ * @KDBUS_ATTACH_CAPS:		The process capabilities
+ * @KDBUS_ATTACH_SECLABEL:	The security label
+ * @KDBUS_ATTACH_AUDIT:		The audit IDs
+ */
+enum kdbus_attach_flags {
 	KDBUS_ATTACH_TIMESTAMP		=  1 <<  0,
 	KDBUS_ATTACH_CREDS		=  1 <<  1,
 	KDBUS_ATTACH_NAMES		=  1 <<  2,
@@ -376,18 +449,12 @@ struct kdbus_cmd_hello {
 };
 
 /* Flags for KDBUS_CMD_{BUS,EP,NS}_MAKE */
-enum {
+enum kdbus_make_flags {
 	KDBUS_MAKE_ACCESS_GROUP		= 1 <<  0,
 	KDBUS_MAKE_ACCESS_WORLD		= 1 <<  1,
 	KDBUS_MAKE_POLICY_OPEN		= 1 <<  2,
 };
 
-/* Items to append to KDBUS_CMD_{BUS,EP,NS}_MAKE */
-enum {
-	_KDBUS_MAKE_NULL,
-	KDBUS_MAKE_NAME,
-};
-
 /**
  * struct kdbus_cmd_bus_make - struct to make a bus
  * @size:		The total size of the struct
@@ -437,7 +504,7 @@ struct kdbus_cmd_ns_make {
 	struct kdbus_item items[0];
 };
 
-enum {
+enum kdbus_name_flags {
 	/* userspace → kernel */
 	KDBUS_NAME_REPLACE_EXISTING		= 1 <<  0,
 	KDBUS_NAME_QUEUE			= 1 <<  1,
@@ -467,7 +534,7 @@ struct kdbus_cmd_name {
 	char name[0];
 };
 
-enum {
+enum kdbus_name_list_flags {
 	KDBUS_NAME_LIST_UNIQUE		= 1 <<  0,
 	KDBUS_NAME_LIST_NAMES		= 1 <<  1,
 	KDBUS_NAME_LIST_STARTERS	= 1 <<  2,
@@ -543,27 +610,37 @@ struct kdbus_conn_info {
 	struct kdbus_item items[0];
 };
 
-enum {
+/**
+ * enum kdbus_match_type - type of match record
+ * @KDBUS_MATCH_BLOOM:		Matches against KDBUS_MSG_BLOOM
+ * @KDBUS_MATCH_SRC_NAME:	Matches a name string
+ * @KDBUS_MATCH_NAME_ADD:	Matches a name string
+ * @KDBUS_MATCH_NAME_REMOVE:	Matches a name string
+ * @KDBUS_MATCH_NAME_CHANGE:	Matches a name string
+ * @KDBUS_MATCH_ID_ADD:		Matches an ID
+ * @KDBUS_MATCH_ID_REMOVE:	Matches an ID
+ */
+enum kdbus_match_type {
 	_KDBUS_MATCH_NULL,
-	KDBUS_MATCH_BLOOM,		/* Matches a mask blob against KDBUS_MSG_BLOOM */
-	KDBUS_MATCH_SRC_NAME,		/* Matches a name string against KDBUS_ITEM_NAME */
-	KDBUS_MATCH_NAME_ADD,		/* Matches a name string against KDBUS_ITEM_NAME_ADD */
-	KDBUS_MATCH_NAME_REMOVE,	/* Matches a name string against KDBUS_ITEM_NAME_REMOVE */
-	KDBUS_MATCH_NAME_CHANGE,	/* Matches a name string against KDBUS_ITEM_NAME_CHANGE */
-	KDBUS_MATCH_ID_ADD,		/* Matches an ID against KDBUS_MSG_ID_ADD */
-	KDBUS_MATCH_ID_REMOVE,		/* Matches an ID against KDBUS_MSG_ID_REMOVE */
+	KDBUS_MATCH_BLOOM,
+	KDBUS_MATCH_SRC_NAME,
+	KDBUS_MATCH_NAME_ADD,
+	KDBUS_MATCH_NAME_REMOVE,
+	KDBUS_MATCH_NAME_CHANGE,
+	KDBUS_MATCH_ID_ADD,
+	KDBUS_MATCH_ID_REMOVE,
 };
 
 /**
  * struct kdbus_cmd_match - struct to add or remove matches
  * @size:		The total size of the struct
- * @id:			Priviledged users may (de)register matches on behalf
- * 			of other peers.
- * 			In other cases, set to 0.
- * @cookie:		Userspace supplied cookie. When removing, the cookie is
- * 			suffices as information
- * @src_id:		The source ID to match against. Use KDBUS_MATCH_SRC_ID_ANY or
- * 			any other value for a unique match.
+ * @id:			Privileged users may (de)register matches on behalf
+ * 			of other peers. In other cases, set to 0.
+ * @cookie:		Userspace supplied cookie. When removing, the cookie
+ * 			identifies the match to remove.
+ * @src_id:		The source ID to match against. Use
+ * 			KDBUS_MATCH_SRC_ID_ANY or any other value for a unique
+ * 			match.
  * @items:		A list of items for additional information
  *
  * This structure is used with the KDBUS_CMD_ADD_MATCH and
@@ -578,7 +655,7 @@ struct kdbus_cmd_match {
 	struct kdbus_item items[0];
 };
 
-enum {
+enum kdbus_monitor_flags {
 	KDBUS_MONITOR_ENABLE		= 1 <<  0,
 };
 
@@ -596,38 +673,161 @@ struct kdbus_cmd_monitor {
 	__u64 flags;
 };
 
-enum {
-	/* kdbus control node commands: require unset state */
-	KDBUS_CMD_BUS_MAKE =		_IOW(KDBUS_IOC_MAGIC, 0x00, struct kdbus_cmd_bus_make),
-	KDBUS_CMD_NS_MAKE =		_IOR(KDBUS_IOC_MAGIC, 0x10, struct kdbus_cmd_ns_make),
+/**
+ * enum kdbus_ioctl_type - Ioctl API
+ * @KDBUS_CMD_BUS_MAKE:		After opening the "control" device node, this
+ * 				command creates a new bus with the specified
+ * 				name. The bus is immediately shut down and
+ * 				cleaned up when the opened "control" device node
+ * 				is closed.
+ * @KDBUS_CMD_NS_MAKE:		Similar to KDBUS_CMD_BUS_MAKE, but it creates a
+ * 				new kdbus namespace.
+ * @KDBUS_CMD_EP_MAKE:		Creates a new named special endpoint to talk to
+ * 				the bus. Such endpoints usually carry a more
+ * 				restrictive policy and grant restricted access
+ * 				to specific applications.
+ * @KDBUS_CMD_HELLO:		By opening the bus device node a connection is
+ * 				created. After a HELLO the opened connection
+ * 				becomes an active peer on the bus.
+ * @KDBUS_CMD_MSG_SEND:		Send a message and pass data from userspace to
+ * 				the kernel.
+ * @KDBUS_CMD_MSG_RECV:		Receive a message from the kernel which is
+ * 				placed in the receiver's pool.
+ * @KDBUS_CMD_FREE:		Release the allocated memory in the receiver's
+ * 				pool.
+ * @KDBUS_CMD_NAME_ACQUIRE:	Request a well-known bus name to associate with
+ * 				the connection. Well-known names are used to
+ * 				address a peer on the bus.
+ * @KDBUS_CMD_NAME_RELEASE:	Release a well-known name the connection
+ * 				currently owns.
+ * @KDBUS_CMD_NAME_LIST:	Retrieve the list of all currently registered
+ * 				well-known and unique names.
+ * @KDBUS_CMD_CONN_INFO:	Retrieve credentials and properties of the
+ * 				initial creator of the connection. The data was
+ * 				stored at registration time and does not
+ * 				neccessarily represent the connected process or
+ * 				the actual state of the process.
+ * @KDBUS_CMD_MATCH_ADD:	Install a match which broadcast messages should
+ * 				be delivered to the connection.
+ * @KDBUS_CMD_MATCH_REMOVE:	Remove a current match for broadcast messages.
+ * @KDBUS_CMD_MONITOR:		Monitor the bus and receive all transmitted
+ * 				messages. Privileges are required for this
+ * 				operation.
+ * @KDBUS_CMD_EP_POLICY_SET:	Set the policy of an endpoint. It is used to
+ * 				restrict the access for endpoints created with
+ * 				KDBUS_CMD_EP_MAKE.
+ * @KDBUS_CMD_MEMFD_NEW:	Return a new file descriptor which provides an
+ * 				anonymous shared memory file and which can be
+ * 				used to pass around larger chunks of data.
+ * 				Kdbus memfd files can be sealed, which allows
+ * 				the receiver to trust the data it has received.
+ * 				Kdbus memfd files expose only very limited
+ * 				operations, they can be mmap()ed, seek()ed,
+ * 				(p)read(v)() and (p)write(v)(); most other
+ * 				common file operations are not implemented.
+ * 				Special caution needs to be taken with
+ * 				read(v)()/write(v)() on a shared file; the
+ * 				underlying file position is always shared
+ * 				between all users of the file and race against
+ * 				each other, pread(v)()/pwrite(v)() avoid these
+ * 				issues.
+ * @KDBUS_CMD_MEMFD_SIZE_GET:	Return the size of the underlying file, which
+ * 				changes with write().
+ * @KDBUS_CMD_MEMFD_SIZE_SET:	Truncate the underlying file to the specified
+ * 				size.
+ * @KDBUS_CMD_MEMFD_SEAL_GET:	Return the state of the file sealing.
+ * @KDBUS_CMD_MEMFD_SEAL_SET:	Seal or break a seal of the file. Only files
+ * 				which are not shared with other processes and
+ * 				which are currently not mapped can be sealed.
+ * 				The current process needs to be the one and
+ * 				single owner of the file, the sealing cannot
+ * 				be changed as long as the file is shared.
+ */
+enum kdbus_ioctl_type {
+	KDBUS_CMD_BUS_MAKE =		_IOW (KDBUS_IOC_MAGIC, 0x00, struct kdbus_cmd_bus_make),
+	KDBUS_CMD_NS_MAKE =		_IOR (KDBUS_IOC_MAGIC, 0x10, struct kdbus_cmd_ns_make),
 
-	/* kdbus ep node commands: require unset state */
-	KDBUS_CMD_EP_MAKE =		_IOW(KDBUS_IOC_MAGIC, 0x20, struct kdbus_cmd_ep_make),
+	KDBUS_CMD_EP_MAKE =		_IOW (KDBUS_IOC_MAGIC, 0x20, struct kdbus_cmd_ep_make),
 	KDBUS_CMD_HELLO =		_IOWR(KDBUS_IOC_MAGIC, 0x30, struct kdbus_cmd_hello),
 
-	/* kdbus ep node commands: require connected state */
-	KDBUS_CMD_MSG_SEND =		_IOW(KDBUS_IOC_MAGIC, 0x40, struct kdbus_msg),
-	KDBUS_CMD_MSG_RECV =		_IOR(KDBUS_IOC_MAGIC, 0x41, __u64 *),
-	KDBUS_CMD_FREE =		_IOW(KDBUS_IOC_MAGIC, 0x42, __u64 *),
+	KDBUS_CMD_MSG_SEND =		_IOW (KDBUS_IOC_MAGIC, 0x40, struct kdbus_msg),
+	KDBUS_CMD_MSG_RECV =		_IOR (KDBUS_IOC_MAGIC, 0x41, __u64 *),
+	KDBUS_CMD_FREE =		_IOW (KDBUS_IOC_MAGIC, 0x42, __u64 *),
 
 	KDBUS_CMD_NAME_ACQUIRE =	_IOWR(KDBUS_IOC_MAGIC, 0x50, struct kdbus_cmd_name),
-	KDBUS_CMD_NAME_RELEASE =	_IOW(KDBUS_IOC_MAGIC, 0x51, struct kdbus_cmd_name),
+	KDBUS_CMD_NAME_RELEASE =	_IOW (KDBUS_IOC_MAGIC, 0x51, struct kdbus_cmd_name),
 	KDBUS_CMD_NAME_LIST =		_IOWR(KDBUS_IOC_MAGIC, 0x52, struct kdbus_cmd_name_list),
 
 	KDBUS_CMD_CONN_INFO =		_IOWR(KDBUS_IOC_MAGIC, 0x60, struct kdbus_cmd_conn_info),
 
-	KDBUS_CMD_MATCH_ADD =		_IOW(KDBUS_IOC_MAGIC, 0x70, struct kdbus_cmd_match),
-	KDBUS_CMD_MATCH_REMOVE =	_IOW(KDBUS_IOC_MAGIC, 0x71, struct kdbus_cmd_match),
-	KDBUS_CMD_MONITOR =		_IOW(KDBUS_IOC_MAGIC, 0x72, struct kdbus_cmd_monitor),
+	KDBUS_CMD_MATCH_ADD =		_IOW (KDBUS_IOC_MAGIC, 0x70, struct kdbus_cmd_match),
+	KDBUS_CMD_MATCH_REMOVE =	_IOW (KDBUS_IOC_MAGIC, 0x71, struct kdbus_cmd_match),
+	KDBUS_CMD_MONITOR =		_IOW (KDBUS_IOC_MAGIC, 0x72, struct kdbus_cmd_monitor),
 
-	/* kdbus ep node commands: require ep owner state */
-	KDBUS_CMD_EP_POLICY_SET =	_IOW(KDBUS_IOC_MAGIC, 0x80, struct kdbus_cmd_policy),
+	KDBUS_CMD_EP_POLICY_SET =	_IOW (KDBUS_IOC_MAGIC, 0x80, struct kdbus_cmd_policy),
 
-	/* kdbus memfd commands: */
-	KDBUS_CMD_MEMFD_NEW =		_IOR(KDBUS_IOC_MAGIC, 0x90, int *),
-	KDBUS_CMD_MEMFD_SIZE_GET =	_IOR(KDBUS_IOC_MAGIC, 0x91, __u64 *),
-	KDBUS_CMD_MEMFD_SIZE_SET =	_IOW(KDBUS_IOC_MAGIC, 0x92, __u64 *),
-	KDBUS_CMD_MEMFD_SEAL_GET =	_IOR(KDBUS_IOC_MAGIC, 0x93, int *),
-	KDBUS_CMD_MEMFD_SEAL_SET =	_IO(KDBUS_IOC_MAGIC, 0x94),
+	KDBUS_CMD_MEMFD_NEW =		_IOR (KDBUS_IOC_MAGIC, 0x90, int *),
+	KDBUS_CMD_MEMFD_SIZE_GET =	_IOR (KDBUS_IOC_MAGIC, 0x91, __u64 *),
+	KDBUS_CMD_MEMFD_SIZE_SET =	_IOW (KDBUS_IOC_MAGIC, 0x92, __u64 *),
+	KDBUS_CMD_MEMFD_SEAL_GET =	_IOR (KDBUS_IOC_MAGIC, 0x93, int *),
+	KDBUS_CMD_MEMFD_SEAL_SET =	_IO  (KDBUS_IOC_MAGIC, 0x94),
 };
+
+/*
+ * errno - api error codes
+ * @E2BIG:		A message contains too many records or items.
+ * @EADDRNOTAVAIL:	A message flagged not to activate a service, addressed
+ * 			a service which is not currently running.
+ * @EAGAIN:		No messages are queued at the moment.
+ * @EBADF:		File descriptors passed with the message are not valid.
+ * @EBADFD:		A bus connection is in a corrupted state.
+ * @EBADMSG:		Passed data contains a combination of conflicting or
+ * 			inconsistent types.
+ * @EBUSY:		A well-known bus name is already taken by another
+ * 			connection.
+ * @ECOMM:		A peer does not accept the file descriptors addressed
+ * 			to it.
+ * @EDESTADDRREQ:	The well-known bus name is required but missing.
+ * @EDOM:		The size of data does not match the expectations. Used
+ * 			for the size of the bloom filter bit field.
+ * @EEXIST:		A requested namespace, bus or endpoint with the same
+ * 			name already exists.  A specific data type, which is
+ * 			only expected once, is provided multiple times.
+ * @EFAULT:		The supplied memory could not be accessed, or the data
+ * 			is not properly aligned.
+ * @EINVAL:		The provided data does not match its type or other
+ * 			expectations, like a string which is not NUL terminated,
+ * 			or a string length that points behind the first
+ * 			\0-byte in the string.
+ * @EMEDIUMTYPE:	A file descriptor which is not a kdbus memfd was
+ * 			refused to send as KDBUS_MSG_PAYLOAD_MEMFD.
+ * @EMFILE:		Too many file descriptors have been supplied with a
+ * 			message.
+ * @EMSGSIZE:		The supplied data is larger than the allowed maximum
+ * 			size.
+ * @ENAMETOOLONG:	The requested name is larger than the allowed maximum
+ * 			size.
+ * @ENOBUFS:		There is no space left for the submitted data to fit
+ * 			into the receiver's pool.
+ * @ENOMEM:		Out of memory.
+ * @ENOSYS:		The requested functionality is not available.
+ * @ENOTCONN:		The addressed peer is not an active connection.
+ * @ENOTSUPP:		The feature negotiation failed, a not supported feature
+ * 			was requested.
+ * @ENOTTY:		An unknown ioctl command was received.
+ * @ENOTUNIQ:		A specific data type was addressed to a broadcast
+ * 			address, but only direct addresses support this kind of
+ * 			data.
+ * @ENXIO:		A unique address does not exist.
+ * @EPERM:		The policy prevented an operation. The requested
+ * 			resource is owned by another entity.
+ * @ESHUTDOWN:		The connection is currently shutting down, no further
+ * 			operations are possible.
+ * @ESRCH:		A requested well-known bus name is not found.
+ * @ETXTBSY:		A kdbus memfd file cannot be sealed or the seal removed,
+ * 			because it is shared with other processes or still
+ * 			mmap()ed.
+ * @EXFULL:		The size limits in the pool are reached, no data of
+ * 			the size tried to submit can be queued.
+ */
 #endif

