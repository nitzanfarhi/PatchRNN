commit 2254abe7ed08d461d5e9e0840c3d41739749fd61
Author: Anca Vamanu <anca@voice-system.ro>
Date:   Wed Sep 5 15:33:21 2007 +0000

    - exported subs table handling functions
    
    
    git-svn-id: https://openser.svn.sourceforge.net/svnroot/openser/trunk@2716 689a6050-402a-0410-94f2-e92a70836424

diff --git a/modules_k/presence/bind_presence.c b/modules_k/presence/bind_presence.c
index 4bcd34b8f..581fa7f50 100644
--- a/modules_k/presence/bind_presence.c
+++ b/modules_k/presence/bind_presence.c
@@ -44,6 +44,12 @@ int bind_presence(presence_api_t* api)
 	api->contains_event= contains_event;
 	api->get_event_list= get_event_list;
 	api->update_watchers_status= update_watchers_status;
+	api->new_shtable= new_shtable;
+    api->destroy_shtable= destroy_shtable;
+    api->insert_shtable= insert_shtable;
+    api->search_shtable= search_shtable;
+    api->delete_shtable= delete_shtable;
+    api->update_shtable= update_shtable;
 	return 0;
 }
 
diff --git a/modules_k/presence/bind_presence.h b/modules_k/presence/bind_presence.h
index dc2204594..bcbbdbb85 100644
--- a/modules_k/presence/bind_presence.h
+++ b/modules_k/presence/bind_presence.h
@@ -30,6 +30,7 @@
 #define _PRES_BIND_H_
 
 #include "event_list.h"
+#include "hash.h"
 
 typedef int (*update_watchers_t)(str pres_uri, pres_ev_t* ev, str* rules_doc);
 
@@ -38,6 +39,13 @@ typedef struct presence_api {
 	contains_event_t contains_event;
 	get_event_list_t get_event_list;
 	update_watchers_t update_watchers_status;
+	/* subs hash table functions */
+	new_shtable_t new_shtable;
+	destroy_shtable_t destroy_shtable;
+	insert_shtable_t insert_shtable;
+	search_shtable_t search_shtable;
+	delete_shtable_t delete_shtable;
+	update_shtable_t update_shtable;
 } presence_api_t;
 
 int bind_presence(presence_api_t* api);
diff --git a/modules_k/presence/hash.c b/modules_k/presence/hash.c
index c820bb9d7..b74c130bd 100644
--- a/modules_k/presence/hash.c
+++ b/modules_k/presence/hash.c
@@ -36,18 +36,18 @@
 #include "hash.h"
 #include "notify.h"
 
-shtable_t new_shtable(void)
+shtable_t new_shtable(int hash_size)
 {
 	shtable_t htable= NULL;
 	int i, j;
 
-	htable= (subs_entry_t*)shm_malloc(shtable_size* sizeof(subs_entry_t));
+	htable= (subs_entry_t*)shm_malloc(hash_size* sizeof(subs_entry_t));
 	if(htable== NULL)
 	{
 		ERR_MEM(SHARE_MEM);
 	}
-	memset(htable, 0, shtable_size* sizeof(subs_entry_t));
-	for(i= 0; i< shtable_size; i++)
+	memset(htable, 0, hash_size* sizeof(subs_entry_t));
+	for(i= 0; i< hash_size; i++)
 	{
 		if(lock_init(&htable[i].lock)== 0)
 		{
@@ -82,27 +82,28 @@ error:
 
 }
 
-void destroy_shtable(void)
+void destroy_shtable(shtable_t htable, int hash_size)
 {
 	int i;
 
-	if(subs_htable== NULL)
+	if(htable== NULL)
 		return;
 
-	for(i= 0; i< shtable_size; i++)
+	for(i= 0; i< hash_size; i++)
 	{
-		lock_destroy(&subs_htable[i].lock);
-		free_subs_list(subs_htable[i].entries, SHM_MEM_TYPE);
+		lock_destroy(&htable[i].lock);
+		free_subs_list(htable[i].entries, SHM_MEM_TYPE);
 	}
-	shm_free(subs_htable);
-	subs_htable= NULL;
+	shm_free(htable);
+	htable= NULL;
 }
 
-subs_t* search_shtable(str callid,str to_tag,str from_tag,unsigned int hash_code)
+subs_t* search_shtable(shtable_t htable,str callid,str to_tag,
+		str from_tag,unsigned int hash_code)
 {
 	subs_t* s;
 
-	s= subs_htable[hash_code].entries->next;
+	s= htable[hash_code].entries->next;
 
 	while(s)
 	{
@@ -181,10 +182,9 @@ error:
 	return NULL;
 }
 
-int insert_shtable(subs_t* subs)
+int insert_shtable(shtable_t htable,unsigned int hash_code, subs_t* subs)
 {
 	subs_t* new_rec= NULL;
-	unsigned int hash_code;
 		
 	new_rec= mem_copy_subs(subs, SHM_MEM_TYPE);
 	if(new_rec== NULL)
@@ -196,15 +196,13 @@ int insert_shtable(subs_t* subs)
 	new_rec->expires+= (int)time(NULL);
 	new_rec->db_flag= INSERTDB_FLAG;
 
-	hash_code=core_hash(&subs->pres_uri,&subs->event->name,shtable_size);
-
-	lock_get(&subs_htable[hash_code].lock);
+	lock_get(&htable[hash_code].lock);
 	
-	new_rec->next= subs_htable[hash_code].entries->next;
+	new_rec->next= htable[hash_code].entries->next;
 	
-	subs_htable[hash_code].entries->next= new_rec;
+	htable[hash_code].entries->next= new_rec;
 	
-	lock_release(&subs_htable[hash_code].lock);
+	lock_release(&htable[hash_code].lock);
 	
 	return 0;
 
@@ -214,16 +212,15 @@ error:
 	return -1;
 }
 
-int delete_shtable(str pres_uri, str ev_stored_name, str to_tag)
+int delete_shtable(shtable_t htable,unsigned int hash_code, 
+		str pres_uri, str ev_stored_name, str to_tag)
 {
-	unsigned int hash_code;
 	subs_t* s= NULL, *ps= NULL;
 	int found= -1;
 
-	hash_code= core_hash(&pres_uri, &ev_stored_name, shtable_size);
-	lock_get(&subs_htable[hash_code].lock);
+	lock_get(&htable[hash_code].lock);
 	
-	ps= subs_htable[hash_code].entries;
+	ps= htable[hash_code].entries;
 	s= ps->next;
 		
 	while(s)
@@ -239,7 +236,7 @@ int delete_shtable(str pres_uri, str ev_stored_name, str to_tag)
 		ps= s;
 		s= s->next;
 	}
-	lock_release(&subs_htable[hash_code].lock);
+	lock_release(&htable[hash_code].lock);
 	return found;
 }
 
@@ -259,19 +256,19 @@ void free_subs_list(subs_t* s_array, int mem_type)
 	
 }
 
-int update_shtable(subs_t* subs, int type)
+int update_shtable(shtable_t htable,unsigned int hash_code, 
+		subs_t* subs, int type)
 {
-	unsigned int hash_code;
 	subs_t* s;
 
-	hash_code= core_hash(&subs->pres_uri, &subs->event->name, shtable_size);
-	lock_get(&subs_htable[hash_code].lock);
+	lock_get(&htable[hash_code].lock);
 
-	s= search_shtable(subs->callid, subs->to_tag, subs->from_tag, hash_code);
+	s= search_shtable(htable,subs->callid, subs->to_tag, subs->from_tag,
+			hash_code);
 	if(s== NULL)
 	{
 		LM_DBG("record not found in hash table\n");
-		lock_release(&subs_htable[hash_code].lock);
+		lock_release(&htable[hash_code].lock);
 		return -1;
 	}
 
@@ -293,7 +290,7 @@ int update_shtable(subs_t* subs, int type)
 	if(s->db_flag & NO_UPDATEDB_FLAG)
 		s->db_flag= UPDATEDB_FLAG;
 
-	lock_release(&subs_htable[hash_code].lock);
+	lock_release(&htable[hash_code].lock);
 	
 	return 0;
 }
@@ -350,7 +347,7 @@ void destroy_phtable(void)
 	int i;
 	pres_entry_t* p, *prev_p;
 
-	if(subs_htable== NULL)
+	if(pres_htable== NULL)
 		return;
 
 	for(i= 0; i< phtable_size; i++)
diff --git a/modules_k/presence/hash.h b/modules_k/presence/hash.h
index a9251f2e1..b347abaae 100644
--- a/modules_k/presence/hash.h
+++ b/modules_k/presence/hash.h
@@ -61,22 +61,43 @@ typedef struct subs_entry
 
 typedef subs_entry_t* shtable_t;
 
-shtable_t new_shtable(void);
+shtable_t new_shtable(int hash_size);
 
-subs_t* search_shtable(str callid,str to_tag,str from_tag,
+subs_t* search_shtable(shtable_t htable, str callid,str to_tag,str from_tag,
 		unsigned int hash_code);
 
-int insert_shtable(subs_t* subs);
+int insert_shtable(shtable_t htable, unsigned int hash_code, subs_t* subs);
 
-int delete_shtable(str pres_uri, str ev_stored_name, str to_tag);
+int delete_shtable(shtable_t htable, unsigned int hash_code, str pres_uri,
+		str ev_stored_name, str to_tag);
 
-int update_shtable(subs_t* subs, int type);
+int update_shtable(shtable_t htable, unsigned int hash_code, subs_t* subs,
+		int type);
 
 subs_t* mem_copy_subs(subs_t* s, int mem_type);
 
 void free_subs_list(subs_t* s_array, int mem_type);
 
-void destroy_shtable(void);
+void destroy_shtable(shtable_t htable, int hash_size);
+
+/* subs htable functions type definitions */
+typedef shtable_t (*new_shtable_t)(int hash_size);
+
+typedef subs_t* (*search_shtable_t)(shtable_t htable, str callid,str to_tag,
+		str from_tag, unsigned int hash_code);
+
+typedef int (*insert_shtable_t)(shtable_t htable, unsigned int hash_code,
+		subs_t* subs);
+
+typedef int (*delete_shtable_t)(shtable_t htable, unsigned int hash_code,
+		str pres_uri, str ev_stored_name, str to_tag);
+
+typedef int (*update_shtable_t)(shtable_t htable, unsigned int hash_code,
+		subs_t* subs, int type);
+
+typedef void (*destroy_shtable_t)(shtable_t htable, int hash_size);
+
+
 
 /* presentity hash table */
 typedef struct pres_entry
diff --git a/modules_k/presence/notify.c b/modules_k/presence/notify.c
index e5dcaef31..107f01cf0 100644
--- a/modules_k/presence/notify.c
+++ b/modules_k/presence/notify.c
@@ -1486,7 +1486,10 @@ int notify(subs_t* subs, subs_t * watcher_subs,str* n_body,int force_null_body)
 	/* update first in hash table and the send Notify */
 	if(subs->expires!= 0)
 	{
-		if(update_shtable(subs, LOCAL_TYPE)< 0)
+		unsigned int hash_code;
+		hash_code= core_hash(&subs->pres_uri, &subs->event->name, shtable_size);
+
+		if(update_shtable(subs_htable, hash_code, subs, LOCAL_TYPE)< 0)
 		{
 			if(subs->db_flag!= INSERTDB_FLAG && fallback2db)
 			{
@@ -1532,9 +1535,13 @@ void p_tm_callback( struct cell *t, int type, struct tmcb_params *ps)
 
 	if(ps->code >= 300)
 	{
+		unsigned int hash_code;
+
 		c_back_param*  cb= (c_back_param*)(*ps->param);
-		
-		delete_shtable(cb->pres_uri, cb->ev_name, cb->to_tag);
+
+		hash_code= core_hash(&cb->pres_uri, &cb->ev_name, shtable_size);
+		delete_shtable(subs_htable, hash_code,cb->pres_uri, cb->ev_name,
+				cb->to_tag);
 
 		delete_db_subs(cb->pres_uri, cb->ev_name, cb->to_tag);
 
diff --git a/modules_k/presence/presence.c b/modules_k/presence/presence.c
index 6b8efe122..ae0e8f721 100644
--- a/modules_k/presence/presence.c
+++ b/modules_k/presence/presence.c
@@ -290,7 +290,7 @@ static int mod_init(void)
 	else
 		shtable_size= 1<< shtable_size;
 
-	subs_htable= new_shtable();
+	subs_htable= new_shtable(shtable_size);
 	if(subs_htable== NULL)
 	{
 		LM_ERR(" initializing subscribe hash table\n");
@@ -429,7 +429,7 @@ void destroy(void)
 		timer_db_update(0, 0);
 
 	if(subs_htable)
-		destroy_shtable();
+		destroy_shtable(subs_htable, shtable_size);
 	
 	if(pres_htable)
 		destroy_phtable();
diff --git a/modules_k/presence/subscribe.c b/modules_k/presence/subscribe.c
index 84c1f3f2c..cee1dd38e 100644
--- a/modules_k/presence/subscribe.c
+++ b/modules_k/presence/subscribe.c
@@ -291,9 +291,12 @@ int update_subs_db(subs_t* subs, int type)
 int update_subscription(struct sip_msg* msg, subs_t* subs, str *rtag,
 		int to_tag_gen)
 {	
+	unsigned int hash_code;
 
 	printf_subs(subs);	
 	
+	hash_code= core_hash(&subs->pres_uri, &subs->event->name, shtable_size);
+
 	if( to_tag_gen ==0) /*if a SUBSCRIBE within a dialog */
 	{
 		if(subs->expires == 0)
@@ -308,8 +311,8 @@ int update_subscription(struct sip_msg* msg, subs_t* subs, str *rtag,
 			}
 			/* delete record from hash table also */
 
-			subs->local_cseq= delete_shtable(subs->pres_uri,
-					subs->event->name, subs->to_tag);
+			subs->local_cseq= delete_shtable(subs_htable,hash_code,
+					subs->pres_uri, subs->event->name, subs->to_tag);
 		
 			if(subs->event->type & PUBL_TYPE)
 			{	
@@ -350,7 +353,7 @@ int update_subscription(struct sip_msg* msg, subs_t* subs, str *rtag,
 			return 1;
 		}
 
-		if(update_shtable(subs, REMOTE_TYPE)< 0)
+		if(update_shtable(subs_htable, hash_code, subs, REMOTE_TYPE)< 0)
 		{
 			if(fallback2db)
 			{
@@ -372,7 +375,7 @@ int update_subscription(struct sip_msg* msg, subs_t* subs, str *rtag,
 	{
 		if(subs->expires!= 0)
 		{	
-			if(insert_shtable(subs)< 0)
+			if(insert_shtable(subs_htable,hash_code,subs)< 0)
 			{
 				LM_ERR("inserting new record in subs_htable\n");
 				goto error;
@@ -491,8 +494,6 @@ void msg_watchers_clean(unsigned int ticks,void *param)
 
 int handle_subscribe(struct sip_msg* msg, char* str1, char* str2)
 {
-	struct sip_uri to_uri;
-	struct sip_uri from_uri;
 	struct to_body *pto, *pfrom = NULL, TO;
 	int lexpire;
 	int  to_tag_gen = 0;
@@ -509,10 +510,10 @@ int handle_subscribe(struct sip_msg* msg, char* str1, char* str2)
 	int found;
 	str reason= {0, 0};
 	struct sip_uri uri;
+	contact_body_t *b;
 
 	/* ??? rename to avoid collisions with other symbols */
 	counter ++;
-	contact_body_t *b;
 
 	memset(&subs, 0, sizeof(subs_t));
 
@@ -608,22 +609,24 @@ int handle_subscribe(struct sip_msg* msg, char* str1, char* str2)
 		}
 		pto = &TO;
 	}
-	
-	if(parse_uri(pto->uri.s, pto->uri.len, &to_uri)!=0)
+
+	if( pto->parsed_uri.user.s && pto->parsed_uri.host.s &&
+		pto->parsed_uri.user.len && pto->parsed_uri.host.len)
 	{
-		LM_ERR("bad R-URI!\n");
-		goto error;
+		subs.to_user = pto->parsed_uri.user;
+		subs.to_domain = pto->parsed_uri.host;
 	}
-
-	if(to_uri.user.len<=0 || to_uri.user.s==NULL || to_uri.host.len<=0 ||
-			to_uri.host.s==NULL)
+	else
 	{
-		LM_ERR("bad URI in To header!\n");
-		goto error;
+		if(parse_uri(pto->uri.s, pto->uri.len, &uri)< 0)
+		{
+			LM_ERR("while parsing uri\n");
+			goto error;
+		}
+		subs.to_user = uri.user;
+		subs.to_domain = uri.host;
 	}
-	subs.to_user = to_uri.user;
-	subs.to_domain = to_uri.host;
-	
+
 	/* examine the from header */
 	if (!msg->from || !msg->from->body.s)
 	{
@@ -641,22 +644,24 @@ int handle_subscribe(struct sip_msg* msg, char* str1, char* str2)
 		}
 	}
 	pfrom = (struct to_body*)msg->from->parsed;
-
-	if(parse_uri(pfrom->uri.s, pfrom->uri.len, &from_uri)!=0)
+	
+	if( pfrom->parsed_uri.user.s && pfrom->parsed_uri.host.s && 
+		pfrom->parsed_uri.user.len && pfrom->parsed_uri.host.len)
 	{
-		LM_ERR("bad R-URI!\n");
-		goto error;
+		subs.from_user = pfrom->parsed_uri.user;
+		subs.from_domain = pfrom->parsed_uri.host;
 	}
-
-	if(from_uri.user.len<=0 || from_uri.user.s==NULL || from_uri.host.len<=0 ||
-			from_uri.host.s==NULL)
+	else
 	{
-		LM_ERR("bad URI in To header!\n");
-		goto error;
+		if(parse_uri(pfrom->uri.s, pfrom->uri.len, &uri)< 0)
+		{
+			LM_ERR("while parsing uri\n");
+			goto error;
+		}
+		subs.from_user = uri.user;
+		subs.from_domain = uri.host;
 	}
-	
-	subs.from_user = from_uri.user;
-	subs.from_domain = from_uri.host;
+
 
 	/*generate to_tag if the message does not have a to_tag*/
 	if (pto->tag_value.s==NULL || pto->tag_value.len==0 )
@@ -942,7 +947,8 @@ int get_stored_info(struct sip_msg* msg, subs_t* subs, int* error_ret)
 	hash_code= core_hash(&pres_uri, &subs->event->name, shtable_size);
 	lock_get(&subs_htable[hash_code].lock);
 	i= hash_code;
-	s= search_shtable(subs->callid, subs->to_tag, subs->from_tag, hash_code);
+	s= search_shtable(subs_htable, subs->callid, subs->to_tag,
+			subs->from_tag, hash_code);
 	if(s)
 	{
 		goto found_rec;
@@ -956,7 +962,7 @@ int get_stored_info(struct sip_msg* msg, subs_t* subs, int* error_ret)
 	for(i= 0; i< shtable_size; i++)
 	{
 		lock_get(&subs_htable[i].lock);
-		s= search_shtable(subs->callid,subs->to_tag,subs->from_tag, i);
+		s= search_shtable(subs_htable, subs->callid,subs->to_tag,subs->from_tag, i);
 		if(s)
 		{
 			pres_uri.s= (char*)pkg_malloc(s->pres_uri.len* sizeof(char));
@@ -1527,6 +1533,7 @@ int restore_db_subs(void)
 	pres_ev_t* event= NULL;
 	event_t parsed_event;
 	unsigned int expires;
+	unsigned int hash_code;
 
 	result_cols[pres_uri_col=n_result_cols++]	="pres_uri";		
 	result_cols[expires_col=n_result_cols++]="expires";
@@ -1681,7 +1688,8 @@ int restore_db_subs(void)
 		s.sockinfo_str.s=(char*)row_vals[sockinfo_col].val.string_val;
 		s.sockinfo_str.len= strlen(s.sockinfo_str.s);
 
-		if(insert_shtable(&s)< 0)
+		hash_code= core_hash(&s.pres_uri, &s.event->name, shtable_size);
+		if(insert_shtable(subs_htable, hash_code, &s)< 0)
 		{
 			LM_ERR("adding new record in hash table\n");
 			goto error;

