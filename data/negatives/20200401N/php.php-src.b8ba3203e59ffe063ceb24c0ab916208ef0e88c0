commit b8ba3203e59ffe063ceb24c0ab916208ef0e88c0
Author: Dmitry Stogov <dmitry@zend.com>
Date:   Tue Apr 7 14:19:12 2015 +0300

    Cleanup

diff --git a/ext/hash/hash.c b/ext/hash/hash.c
index d9c3a892d9..3a15fc6fcc 100644
--- a/ext/hash/hash.c
+++ b/ext/hash/hash.c
@@ -531,14 +531,6 @@ PHP_FUNCTION(hash_final)
 	digest->val[digest_len] = 0;
 	efree(hash->context);
 	hash->context = NULL;
-
-	//???
-	//??? /* zend_list_REAL_delete() */
-	//??? if (zend_hash_index_find(&EG(regular_list), Z_RESVAL_P(zhash), (void *) &le)==SUCCESS) {
-	//??? 	/* This is a hack to avoid letting the resource hide elsewhere (like in separated vars)
-	//??? 		FETCH_RESOURCE is intelligent enough to handle dealing with any issues this causes */
-	//??? 	le->refcount = 1;
-	//??? } /* FAILURE is not an option */
 	zend_list_close(Z_RES_P(zhash));
 
 	if (raw_output) {
diff --git a/ext/ldap/ldap.c b/ext/ldap/ldap.c
index 6ad3a93600..c64b13bab5 100644
--- a/ext/ldap/ldap.c
+++ b/ext/ldap/ldap.c
@@ -1975,7 +1975,8 @@ PHP_FUNCTION(ldap_sort)
 		RETURN_FALSE;
 	}
 
-	if ((le = zend_hash_index_find_ptr(&EG(regular_list), Z_RES_HANDLE_P(result))) == NULL || le->type != le_result) {
+	le = Z_RES_P(result);
+	if (le->type != le_result) {
 		php_error_docref(NULL, E_WARNING, "Supplied resource is not a valid ldap result resource");
 		RETURN_FALSE;
 	}
diff --git a/main/streams/streams.c b/main/streams/streams.c
index 0e95544fc1..886fc1da28 100644
--- a/main/streams/streams.c
+++ b/main/streams/streams.c
@@ -65,15 +65,6 @@ PHPAPI HashTable *php_stream_get_url_stream_wrappers_hash_global(void)
 	return &url_stream_wrappers_hash;
 }
 
-static int _php_stream_release_context(zval *zv, void *pContext)
-{
-	zend_resource *le = Z_RES_P(zv);
-	if (le->ptr == pContext) {
-		return --GC_REFCOUNT(le) == 0;
-	}
-	return 0;
-}
-
 static int forget_persistent_resource_id_numbers(zval *el)
 {
 	php_stream *stream;
@@ -91,11 +82,8 @@ fprintf(stderr, "forget_persistent: %s:%p\n", stream->ops->label, stream);
 
 	stream->res = NULL;
 
-	if (PHP_STREAM_CONTEXT(stream)) {
-		zend_hash_apply_with_argument(&EG(regular_list),
-				_php_stream_release_context,
-				PHP_STREAM_CONTEXT(stream));
-		stream->ctx = NULL;
+	if (stream->ctx) {
+		zend_list_delete(stream->ctx);
 	}
 
 	return 0;
@@ -336,7 +324,7 @@ fprintf(stderr, "stream_alloc: %s:%p persistent=%s\n", ops->label, ret, persiste
 
 PHPAPI int _php_stream_free_enclosed(php_stream *stream_enclosed, int close_options) /* {{{ */
 {
-	return _php_stream_free(stream_enclosed,
+	return php_stream_free(stream_enclosed,
 		close_options | PHP_STREAM_FREE_IGNORE_ENCLOSING);
 }
 /* }}} */
@@ -418,7 +406,7 @@ PHPAPI int _php_stream_free(php_stream *stream, int close_options) /* {{{ */
 		/* we force PHP_STREAM_CALL_DTOR because that's from where the
 		 * enclosing stream can free this stream. We remove rsrc_dtor because
 		 * we want the enclosing stream to be deleted from the resource list */
-		return _php_stream_free(enclosing_stream,
+		return php_stream_free(enclosing_stream,
 			(close_options | PHP_STREAM_FREE_CALL_DTOR) & ~PHP_STREAM_FREE_RSRC_DTOR);
 	}
 

