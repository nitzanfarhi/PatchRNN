commit d468e19a061da518d99c068527a537b90a5f3abd
Author: Tom Lane <tgl@sss.pgh.pa.us>
Date:   Thu May 5 00:19:47 2005 +0000

    Allow implicit cast from any named composite type to RECORD.  At the
    moment this has no particular use except to allow table rows to be
    passed to record_out(), but that case seems to be useful in itself
    per recent example from Elein.  Further down the road we could look
    at letting PL functions be declared to accept RECORD parameters.

diff --git a/src/backend/parser/parse_coerce.c b/src/backend/parser/parse_coerce.c
index 32455785a4..287e496570 100644
--- a/src/backend/parser/parse_coerce.c
+++ b/src/backend/parser/parse_coerce.c
@@ -8,7 +8,7 @@
  *
  *
  * IDENTIFICATION
- *	  $PostgreSQL: pgsql/src/backend/parser/parse_coerce.c,v 2.127 2005/03/29 00:17:04 tgl Exp $
+ *	  $PostgreSQL: pgsql/src/backend/parser/parse_coerce.c,v 2.128 2005/05/05 00:19:47 tgl Exp $
  *
  *-------------------------------------------------------------------------
  */
@@ -318,6 +318,13 @@ coerce_type(ParseState *pstate, Node *node,
 		return coerce_record_to_complex(pstate, node, targetTypeId,
 										ccontext, cformat);
 	}
+	if (targetTypeId == RECORDOID &&
+		ISCOMPLEX(inputTypeId))
+	{
+		/* Coerce a specific complex type to RECORD */
+		/* NB: we do NOT want a RelabelType here */
+		return node;
+	}
 	if (typeInheritsFrom(inputTypeId, targetTypeId))
 	{
 		/*
@@ -405,6 +412,13 @@ can_coerce_type(int nargs, Oid *input_typeids, Oid *target_typeids,
 			ISCOMPLEX(targetTypeId))
 			continue;
 
+		/*
+		 * If input is a composite type and target is RECORD, accept
+		 */
+		if (targetTypeId == RECORDOID &&
+			ISCOMPLEX(inputTypeId))
+			continue;
+
 		/*
 		 * If input is a class type that inherits from target, accept
 		 */

