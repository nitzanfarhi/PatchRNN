commit 4dacdedbe747d6b09c294c4fb46e7fbefb5b6e1c
Author: Bill Meier <wmeier@newsguy.com>
Date:   Sun Nov 25 21:07:07 2012 +0000

     Fix several [-Wshadow] warnings;
     Also: Do some minor whitespace and formatting changes.
    
    svn path=/trunk/; revision=46185

diff --git a/ui/gtk/bytes_view.c b/ui/gtk/bytes_view.c
index 693dbb393f..73bb59169e 100644
--- a/ui/gtk/bytes_view.c
+++ b/ui/gtk/bytes_view.c
@@ -98,7 +98,7 @@ typedef struct _BytesViewClass
 static void bytes_view_set_scroll_adjustments(BytesView *, GtkAdjustment *, GtkAdjustment *);
 static void bytes_view_adjustment_set(BytesView *);
 
-static void 
+static void
 bytes_view_init(BytesView *bv)
 {
 	bv->context = NULL;
@@ -142,7 +142,7 @@ bytes_view_destroy(BytesView *bv)
 }
 
 #if GTK_CHECK_VERSION(3, 0, 0)
-static void 
+static void
 bytes_view_destroy_widget(GtkWidget *widget)
 {
 	bytes_view_destroy(BYTES_VIEW(widget));
@@ -188,7 +188,7 @@ bytes_view_ensure_layout(BytesView *bv)
 	}
 }
 
-static void 
+static void
 bytes_view_realize(GtkWidget *widget)
 {
 	BytesView *bv;
@@ -243,7 +243,7 @@ bytes_view_realize(GtkWidget *widget)
 	bytes_view_ensure_layout(bv);
 }
 
-static void 
+static void
 bytes_view_unrealize(GtkWidget *widget)
 {
 	BytesView *bv = BYTES_VIEW(widget);
@@ -279,7 +279,7 @@ bytes_view_ensure_hadj(BytesView *bv)
 	return bv->hadj;
 }
 
-static gboolean 
+static gboolean
 bytes_view_scroll(GtkWidget *widget, GdkEventScroll *event)
 {
 	BytesView *bv = BYTES_VIEW(widget);
@@ -305,7 +305,7 @@ bytes_view_scroll(GtkWidget *widget, GdkEventScroll *event)
 	return FALSE;
 }
 
-static void 
+static void
 bytes_view_allocate(GtkWidget *widget, GtkAllocation *allocation)
 {
 	gtk_widget_set_allocation(widget, allocation);
@@ -333,7 +333,7 @@ bytes_view_get_preferred_height(GtkWidget *widget _U_, gint *minimum, gint *natu
 
 #else
 
-static void 
+static void
 bytes_view_size_request(GtkWidget *widget _U_, GtkRequisition *requisition)
 {
 	requisition->width = 200;
@@ -542,7 +542,7 @@ bytes_view_flush_pos(BytesView *bv, void *data, int x, int search_x, const char
 	if (x <= search_x && x + line_width > search_x) {
 		int off_x = search_x - x;
 		int pos_run;
-		
+
 		if ((pos_run = _pango_runs_find_index(line_runs, off_x, str)) != -1)
 			*pos_x = (-*pos_x) + pos_run;
 
@@ -561,7 +561,7 @@ bytes_view_render_state(BytesView *bv, int state)
 	g_assert(state == GTK_STATE_NORMAL || state == GTK_STATE_SELECTED);
 
 	if (bv->bold_highlight) {
-		pango_font_description_set_weight(bv->font, 
+		pango_font_description_set_weight(bv->font,
 				(state == GTK_STATE_SELECTED) ? PANGO_WEIGHT_BOLD : PANGO_WEIGHT_NORMAL);
 		bv->state = GTK_STATE_NORMAL;
 	} else
@@ -612,7 +612,7 @@ _bytes_view_line_common(BytesView *bv, void *data, const int org_off, int xx, in
 
 	/* Print the hex bit */
 	for (byten = 0, off = org_off; byten < bv->per_line; byten++) {
-		gboolean byte_highlighted = 
+		gboolean byte_highlighted =
 			(off >= bv->start[0] && off < bv->end[0]) ||
 			(off >= bv->start[1] && off < bv->end[1]);
 		int state_cur = (off < len && byte_highlighted) ?
@@ -688,7 +688,7 @@ _bytes_view_line_common(BytesView *bv, void *data, const int org_off, int xx, in
 
 	/* Print the ASCII bit */
 	for (byten = 0, off = org_off; byten < bv->per_line; byten++) {
-		gboolean byte_highlighted = 
+		gboolean byte_highlighted =
 			(off >= bv->start[0] && off < bv->end[0]) ||
 			(off >= bv->start[1] && off < bv->end[1]);
 		int state_cur = (off < len && byte_highlighted) ?
@@ -721,7 +721,7 @@ _bytes_view_line_common(BytesView *bv, void *data, const int org_off, int xx, in
 		}
 
 		if (off < len) {
-			c = (bv->encoding == PACKET_CHAR_ENC_CHAR_EBCDIC) ? 
+			c = (bv->encoding == PACKET_CHAR_ENC_CHAR_EBCDIC) ?
 				EBCDIC_to_ASCII1(pd[off]) :
 				pd[off];
 
@@ -878,7 +878,7 @@ bytes_view_draw(GtkWidget *widget, cairo_t *cr)
 
 #else
 
-static gboolean 
+static gboolean
 bytes_view_expose(GtkWidget *widget, GdkEventExpose *event)
 {
 	BytesView *bv = BYTES_VIEW(widget);
@@ -930,7 +930,7 @@ _gtk_adjustment_configure(GtkAdjustment *adj,
 #endif
 
 
-static void 
+static void
 bytes_view_adjustment_set(BytesView *bv)
 {
 	GtkAllocation allocation;
@@ -988,7 +988,7 @@ bytes_view_adjustment_set(BytesView *bv)
 	}
 }
 
-static gint 
+static gint
 bytes_view_adjustment_timeout(BytesView *bv)
 {
 	bv->adj_tag = 0;
@@ -996,7 +996,7 @@ bytes_view_adjustment_timeout(BytesView *bv)
 	return 0;
 }
 
-static void 
+static void
 bytes_view_adjustment_changed(GtkAdjustment *adj, BytesView *bv)
 {
 	/*  delay rendering when scrolling (10ms) */
@@ -1154,7 +1154,7 @@ bv_VOID__OBJECT_OBJECT(GClosure *closure, GValue *return_value _U_, guint n_para
 
 #endif
 
-static void 
+static void
 bytes_view_class_init(BytesViewClass *klass)
 {
 #if !GTK_CHECK_VERSION(3, 0, 0)
@@ -1210,7 +1210,7 @@ bytes_view_class_init(BytesViewClass *klass)
 #else
 	klass->set_scroll_adjustments = bytes_view_set_scroll_adjustments;
 
-	widget_class->set_scroll_adjustments_signal = 
+	widget_class->set_scroll_adjustments_signal =
 		g_signal_new(g_intern_static_string("set-scroll-adjustments"),
 			G_OBJECT_CLASS_TYPE(object_class),
 			G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
@@ -1223,12 +1223,12 @@ bytes_view_class_init(BytesViewClass *klass)
 #endif
 }
 
-GType 
+GType
 bytes_view_get_type(void)
 {
-	static GType bytes_view_type = 0;
-	
-	if (!bytes_view_type) {
+	static GType bytes_view_gtype = 0;
+
+	if (!bytes_view_gtype) {
 		static const GTypeInfo bytes_view_info = {
 			sizeof (BytesViewClass),
 			NULL, /* base_init */
@@ -1250,25 +1250,25 @@ bytes_view_get_type(void)
 		};
 #endif
 
-		bytes_view_type = g_type_register_static(GTK_TYPE_WIDGET,
-							"BytesView",
-							&bytes_view_info,
-							(GTypeFlags)0);	
+		bytes_view_gtype = g_type_register_static(GTK_TYPE_WIDGET,
+							  "BytesView",
+							  &bytes_view_info,
+							  (GTypeFlags)0);
 
 #if GTK_CHECK_VERSION(3, 0, 0)
-		g_type_add_interface_static(bytes_view_type,
-						GTK_TYPE_SCROLLABLE,
-						&scrollable_info);
+		g_type_add_interface_static(bytes_view_gtype,
+					    GTK_TYPE_SCROLLABLE,
+					    &scrollable_info);
 #endif
 	}
-	return bytes_view_type;
+	return bytes_view_gtype;
 }
 
-int 
+int
 bytes_view_byte_from_xy(BytesView *bv, int x, int y)
 {
 	/* hex_pos_byte array generated with hex_view_get_byte(0, 0, 0...70) */
-	static const int hex_pos_byte[70] = { 
+	static const int hex_pos_byte[70] = {
 		-1, -1,
 		0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3,
 		4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7,
@@ -1326,7 +1326,7 @@ bytes_view_byte_from_xy(BytesView *bv, int x, int y)
 	return off_y + off_x;
 }
 
-void 
+void
 bytes_view_scroll_to_byte(BytesView *bv, int byte)
 {
 	int line;
@@ -1368,7 +1368,7 @@ bytes_view_set_font(BytesView *bv, PangoFontDescription *font)
 	}
 }
 
-void 
+void
 bytes_view_set_data(BytesView *bv, const guint8 *data, int len)
 {
 	g_free(bv->pd);
@@ -1396,7 +1396,7 @@ bytes_view_set_data(BytesView *bv, const guint8 *data, int len)
 	bytes_view_adjustment_set(bv);
 }
 
-void 
+void
 bytes_view_set_encoding(BytesView *bv, int enc)
 {
 	g_assert(enc == PACKET_CHAR_ENC_CHAR_ASCII || enc == PACKET_CHAR_ENC_CHAR_EBCDIC);
@@ -1404,7 +1404,7 @@ bytes_view_set_encoding(BytesView *bv, int enc)
 	bv->encoding = enc;
 }
 
-void 
+void
 bytes_view_set_format(BytesView *bv, int format)
 {
 	g_assert(format == BYTES_HEX || format == BYTES_BITS);
@@ -1428,21 +1428,21 @@ bytes_view_set_highlight_style(BytesView *bv, gboolean inverse)
 	bv->bold_highlight = !inverse;
 }
 
-void 
+void
 bytes_view_set_highlight(BytesView *bv, int start, int end, guint32 mask _U_, int maskle _U_)
 {
 	bv->start[0] = start;
 	bv->end[0] = end;
 }
 
-void 
+void
 bytes_view_set_highlight_appendix(BytesView *bv, int start, int end)
 {
 	bv->start[1] = start;
 	bv->end[1] = end;
 }
 
-void 
+void
 bytes_view_refresh(BytesView *bv)
 {
 	/* bytes_view_render_full(bv); */
diff --git a/ui/gtk/capture_dlg.c b/ui/gtk/capture_dlg.c
index 5e593c1cae..7a6459d06b 100644
--- a/ui/gtk/capture_dlg.c
+++ b/ui/gtk/capture_dlg.c
@@ -108,7 +108,7 @@ enum
   INAME
 };
 
-#ifdef _WIN32      
+#ifdef _WIN32
         #define LOCAL_OFFSET 1
 #else
         #define LOCAL_OFFSET 0
@@ -346,10 +346,10 @@ set_capture_column_visible(gchar *col, gboolean visible _U_)
 static void
 toggle_visible_column_cb (GtkWidget *w _U_, gpointer data)
 {
-  GtkTreeView *view;
+  GtkTreeView       *view;
   GtkTreeViewColumn *col;
-  gchar *col_name;
-  gint col_id;
+  gchar             *col_name;
+  gint               col_id;
 
   col_id = GPOINTER_TO_INT(data);
   view = (GtkTreeView *)g_object_get_data(G_OBJECT(cap_open_w), E_CAP_IFACE_KEY);
@@ -364,9 +364,9 @@ static void
 set_all_columns_visible (void)
 {
   GtkTreeViewColumn *col;
-  int col_id;
-  GtkTreeView *view;
-  gchar *name;
+  int                col_id;
+  GtkTreeView       *view;
+  gchar             *name;
 
   view = (GtkTreeView *)g_object_get_data(G_OBJECT(cap_open_w), E_CAP_IFACE_KEY);
   for (col_id = 2; col_id < NUM_COLUMNS; col_id++) {
@@ -394,7 +394,7 @@ void
 update_visible_tree_view_columns(void)
 {
   GtkTreeView       *view;
-  gint              col_id;
+  gint               col_id;
   GtkTreeViewColumn *col;
 
   view = (GtkTreeView *)g_object_get_data(G_OBJECT(cap_open_w), E_CAP_IFACE_KEY);
@@ -415,7 +415,7 @@ update_visible_columns_menu (void)
 
   menu_columns = gtk_ui_manager_get_widget(ui_manager_columns, "/ColumnsPopup/DisplayedColumns");
   /* Debug */
-  if(! menu_columns){
+  if (! menu_columns){
     fprintf (stderr, "Warning: couldn't find menu_columns path=/ColumnsPopup/DisplayedColumns");
   }
 
@@ -450,10 +450,10 @@ columns_pref_cb(GtkAction *action _U_, gpointer user_data)
 static void
 columns_hide_col_cb(GtkAction *action _U_, gpointer user_data _U_)
 {
-  GtkTreeView *view;
+  GtkTreeView       *view;
   GtkTreeViewColumn *col;
-  gint num;
-  gchar *name;
+  gint               num;
+  gchar             *name;
 
   view = (GtkTreeView *)g_object_get_data(G_OBJECT(cap_open_w), E_CAP_IFACE_KEY);
   col = (GtkTreeViewColumn *)g_object_get_data(G_OBJECT(view), E_MCAPTURE_COLUMNS_COLUMN_KEY);
@@ -496,7 +496,7 @@ void
 init_columns_menu(void)
 {
   GtkActionGroup *columns_action_group;
-  GError *error = NULL;
+  GError         *error = NULL;
 
   columns_menu_object = gtk_menu_new();
   /* columns pop-up menu */
@@ -558,10 +558,10 @@ enum cfc_state_t {
 };
 
 typedef struct capture_filter_check {
-  enum cfc_state_t state;
-  gchar *filter_text;
-  GtkWidget *filter_te;
-  int dlt;
+  enum cfc_state_t  state;
+  gchar            *filter_text;
+  GtkWidget        *filter_te;
+  int               dlt;
 } capture_filter_check_t;
 
 /* Valid states:
@@ -590,7 +590,7 @@ static GMutex *cfc_data_mtx;
 static void *
 check_capture_filter_syntax(void *data _U_) {
   struct bpf_program fcode;
-  int pc_err;
+  int                pc_err;
 
   while (1) {
     g_mutex_lock(cfc_data_mtx);
@@ -658,7 +658,7 @@ update_capture_filter_te(gpointer data _U_) {
  */
 void capture_filter_init(void) {
   cfc_data.filter_text = NULL;
-  cfc_data.filter_te = NULL;
+  cfc_data.filter_te   = NULL;
   cfc_data.state = CFC_PENDING;
 
 #if GLIB_CHECK_VERSION(2,31,0)
@@ -682,10 +682,10 @@ void capture_filter_init(void) {
 static void
 update_filter_string(gchar *name, gchar *text)
 {
-  GtkTreeIter  iter;
+  GtkTreeIter   iter;
   GtkTreeView  *if_cb;
   GtkTreeModel *model;
-  gchar *name_str;
+  gchar        *name_str;
 
   if_cb      = (GtkTreeView *) g_object_get_data(G_OBJECT(cap_open_w), E_CAP_IFACE_KEY);
   model = gtk_tree_view_get_model(if_cb);
@@ -703,8 +703,8 @@ static void
 capture_all_filter_check_syntax_cb(GtkWidget *w _U_, gpointer user_data _U_)
 {
   GtkWidget *filter_cm, *filter_te;
-  gchar *filter_text = NULL;
-  guint i;
+  gchar     *filter_text = NULL;
+  guint      i;
 
   filter_cm = (GtkWidget *)g_object_get_data(G_OBJECT(cap_open_w), E_ALL_CFILTER_CM_KEY);
 
@@ -762,8 +762,8 @@ static void
 capture_filter_check_syntax_cb(GtkWidget *w _U_, gpointer user_data _U_)
 {
   GtkWidget *filter_cm, *filter_te, *linktype_combo_box;
-  gchar *filter_text;
-  gpointer dlt_ptr;
+  gchar     *filter_text;
+  gpointer   dlt_ptr;
 
   filter_cm = (GtkWidget *)g_object_get_data(G_OBJECT(opt_edit_w), E_CFILTER_CM_KEY);
   if (!filter_cm)
@@ -848,23 +848,24 @@ static const char *time_unit_name[MAX_TIME_UNITS] = {
 /* (and select the matching unit depending on the given value) */
 static GtkWidget *time_unit_combo_box_new(guint32 value) {
   GtkWidget *unit_combo_box;
-  int i;
+  int        i;
+
   unit_combo_box = gtk_combo_box_text_new ();
-  for(i = 0; i < MAX_TIME_UNITS; i++) {
+  for (i = 0; i < MAX_TIME_UNITS; i++) {
     gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (unit_combo_box), time_unit_name[i]);
   }
   /* the selected combo_box item can't be changed, once the combo_box
      is created, so set the matching combo_box item now */
   /* days */
-  if(value >= 60 * 60 * 24) {
+  if (value >= 60 * 60 * 24) {
     gtk_combo_box_set_active(GTK_COMBO_BOX(unit_combo_box), TIME_UNIT_DAY);
   } else {
     /* hours */
-    if(value >= 60 * 60) {
+    if (value >= 60 * 60) {
       gtk_combo_box_set_active(GTK_COMBO_BOX(unit_combo_box), TIME_UNIT_HOUR);
     } else {
       /* minutes */
-      if(value >= 60) {
+      if (value >= 60) {
         gtk_combo_box_set_active(GTK_COMBO_BOX(unit_combo_box), TIME_UNIT_MINUTE);
       } else {
         /* seconds */
@@ -880,17 +881,17 @@ static guint32 time_unit_combo_box_convert_value(
 guint32 value)
 {
   /* days */
-  if(value >= 60 * 60 * 24) {
+  if (value >= 60 * 60 * 24) {
     return value / (60 * 60 * 24);
   }
 
   /* hours */
-  if(value >= 60 * 60) {
+  if (value >= 60 * 60) {
     return value / (60 * 60);
   }
 
   /* minutes */
-  if(value >= 60) {
+  if (value >= 60) {
     return value / 60;
   }
 
@@ -937,19 +938,20 @@ static const char *size_unit_name[MAX_SIZE_UNITS] = {
 /* (and select the matching unit depending on the given value) */
 static GtkWidget *size_unit_combo_box_new(guint32 value) {
   GtkWidget *unit_combo_box;
-  int i;
+  int        i;
+
   unit_combo_box=gtk_combo_box_text_new();
-  for(i=0;i<MAX_SIZE_UNITS;i++){
+  for (i=0; i<MAX_SIZE_UNITS; i++){
     gtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT (unit_combo_box), size_unit_name[i]);
   }
   /* the selected combo_box item can't be changed, once the combo_box
      is created, so set the matching combo_box item now */
   /* gigabytes */
-  if(value >= 1024 * 1024) {
+  if (value >= 1024 * 1024) {
     gtk_combo_box_set_active(GTK_COMBO_BOX(unit_combo_box), SIZE_UNIT_GIGABYTES);
   } else {
     /* megabytes */
-    if(value >= 1024) {
+    if (value >= 1024) {
       gtk_combo_box_set_active(GTK_COMBO_BOX(unit_combo_box), SIZE_UNIT_MEGABYTES);
     } else {
       /* kilobytes */
@@ -964,12 +966,12 @@ static guint32 size_unit_combo_box_set_value(
 guint32 value)
 {
   /* gigabytes */
-  if(value >= 1024 * 1024) {
+  if (value >= 1024 * 1024) {
     return value / (1024 * 1024);
   }
 
   /* megabytes */
-  if(value >= 1024) {
+  if (value >= 1024) {
     return value / (1024);
   }
 
@@ -979,7 +981,7 @@ guint32 value)
 
 /* get raw value from unit and value fields */
 static guint32 size_unit_combo_box_convert_value(
-GtkWidget *unit_combo_box,
+  GtkWidget *unit_combo_box,
 guint32 value)
 {
   int unit;
@@ -990,13 +992,13 @@ guint32 value)
   case(SIZE_UNIT_KILOBYTES):
     return value;
   case(SIZE_UNIT_MEGABYTES):
-    if(value > G_MAXINT / 1024) {
+    if (value > G_MAXINT / 1024) {
       return 0;
     } else {
       return value * 1024;
     }
   case(SIZE_UNIT_GIGABYTES):
-    if(value > G_MAXINT / (1024 * 1024)) {
+    if (value > G_MAXINT / (1024 * 1024)) {
       return 0;
     } else {
       return value * 1024 * 1024;
@@ -1016,7 +1018,7 @@ options_airpcap_advanced_cb(GtkWidget *w, gpointer d)
 {
   int *from_widget;
 
-  from_widget = (gint*)g_malloc(sizeof(gint));
+  from_widget  = (gint*)g_malloc(sizeof(gint));
   *from_widget = AIRPCAP_ADVANCED_FROM_OPTIONS;
   g_object_set_data(G_OBJECT(wireless_tb),AIRPCAP_ADVANCED_FROM_KEY,from_widget);
 
@@ -1053,11 +1055,11 @@ static void
 iftype_combo_box_add (GtkWidget *iftype_cbx, interface_t *device)
 {
   GtkTreeModel *model;
-  GtkTreeIter iter;
+  GtkTreeIter   iter;
+  gboolean      create_new = FALSE;
+  gchar        *string;
+  guint         i, pos     = REMOTE_HOST_START;
   struct remote_host_info *rh;
-  gboolean create_new = FALSE;
-  gchar *string;
-  guint i, pos = REMOTE_HOST_START;
 
   rh = g_hash_table_lookup (remote_host_list, device->remote_opts.remote_host_opts.remote_host);
   if (!rh) {
@@ -1146,8 +1148,8 @@ iftype_combo_box_new(void)
 static gboolean
 iftype_combo_is_separator (GtkTreeModel *model, GtkTreeIter *iter, gpointer data _U_)
 {
-  gboolean result = FALSE;
-  gchar *string;
+  gboolean  result = FALSE;
+  gchar    *string;
 
   gtk_tree_model_get(model, iter, 0, &string, -1);
   if (string) {
@@ -1170,27 +1172,27 @@ error_list_remote_interface_cb (gpointer dialog _U_, gint btn _U_, gpointer data
 static void
 insert_new_rows(GList *list)
 {
-  interface_t device;
-  GtkTreeIter iter;
-  GList *if_entry;
-  if_info_t *if_info;
-  char *if_string=NULL, *temp=NULL, *snaplen_string;
-  gchar *descr;
+  interface_t        device;
+  GtkTreeIter        iter;
+  GList             *if_entry;
+  if_info_t         *if_info;
+  char              *if_string = NULL, *temp = NULL, *snaplen_string;
+  gchar             *descr;
   if_capabilities_t *caps;
-  gint linktype_count;
-  gboolean monitor_mode;
-  GSList *curr_addr;
-  int ips = 0;
-  guint i;
-  if_addr_t *addr;
-  GList *lt_entry;
-  data_link_info_t *data_link_info;
-  gchar *str = NULL, *link_type_name = NULL;
-  gboolean found = FALSE;
-  GString *ip_str;
-  GtkTreeView  *if_cb;
-  GtkTreeModel *model;
-  link_row *link = NULL;
+  gint               linktype_count;
+  gboolean           monitor_mode;
+  GSList            *curr_addr;
+  int                ips       = 0;
+  guint              i;
+  if_addr_t         *addr;
+  GList             *lt_entry;
+  data_link_info_t  *data_link_info;
+  gchar             *str       = NULL, *link_type_name = NULL;
+  gboolean           found     = FALSE;
+  GString           *ip_str;
+  GtkTreeView       *if_cb;
+  GtkTreeModel      *model;
+  link_row          *link      = NULL;
 
   if_cb = (GtkTreeView *) g_object_get_data(G_OBJECT(cap_open_w), E_CAP_IFACE_KEY);
   model = gtk_tree_view_get_model(if_cb);
@@ -1403,7 +1405,7 @@ capture_remote_adjust_sensitivity(GtkWidget *tb _U_, gpointer parent_w)
   GtkWidget *auth_passwd_rb,
             *username_lb, *username_te,
             *passwd_lb, *passwd_te;
-  gboolean  state;
+  gboolean   state;
 
   auth_passwd_rb = (GtkWidget *)g_object_get_data(G_OBJECT(parent_w),
                                                   E_REMOTE_AUTH_PASSWD_KEY);
@@ -1433,7 +1435,7 @@ static void
 capture_remote_ok_cb(GtkWidget *win _U_, GtkWidget *remote_w)
 {
   GtkWidget *host_te, *port_te, *username_te, *passwd_te, *auth_passwd_rb;
-  gchar *hostname;
+  gchar     *hostname;
 
   if (remote_w == NULL) {
     return;
@@ -1489,7 +1491,7 @@ free_remote_host (gpointer key _U_, gpointer value, gpointer user _U_)
 static void
 select_if_type_cb(GtkComboBox *iftype_cbx, gpointer data _U_)
 {
-  gchar *string;
+  gchar     *string;
   GtkWidget *port_te, *auth_rb, *user_te, *pass_te;
   GtkWidget *remote_w;
   struct remote_host *rh;
@@ -1532,15 +1534,15 @@ select_if_type_cb(GtkComboBox *iftype_cbx, gpointer data _U_)
 static void
 capture_remote_cb(GtkWidget *w, gboolean focus_username)
 {
-  GtkWidget   *remote_w,
-              *main_vb, *host_tb,
-              *host_lb, *host_te, *port_lb, *port_te,
-              *auth_fr, *auth_vb,
-              *auth_null_rb, *auth_passwd_rb, *auth_passwd_tb,
-              *user_lb, *user_te, *passwd_lb, *passwd_te,
-              *bbox, *ok_but, *cancel_bt;
-  gchar       *title;
-  GSList      *auth_group;
+  GtkWidget *remote_w,
+            *main_vb, *host_tb,
+            *host_lb, *host_te, *port_lb, *port_te,
+            *auth_fr, *auth_vb,
+            *auth_null_rb, *auth_passwd_rb, *auth_passwd_tb,
+            *user_lb, *user_te, *passwd_lb, *passwd_te,
+            *bbox, *ok_but, *cancel_bt;
+  gchar     *title;
+  GSList    *auth_group;
 
   title = create_user_window_title("Wireshark: Remote Interface");
   remote_w = dlg_window_new(title);
@@ -1678,12 +1680,12 @@ options_remote_destroy_cb(GtkWidget *win, gpointer user_data _U_)
 static void
 options_remote_ok_cb(GtkWidget *win _U_, GtkWidget *parent_w)
 {
-  GtkWidget *datatx_udp_cb, *nocap_rpcap_cb;
+  GtkWidget   *datatx_udp_cb, *nocap_rpcap_cb;
 #ifdef HAVE_PCAP_SETSAMPLING
-  GtkWidget *samp_none_rb, *samp_count_rb, *samp_timer_rb,
-            *samp_count_sb, *samp_timer_sb;
+  GtkWidget   *samp_none_rb, *samp_count_rb, *samp_timer_rb,
+              *samp_count_sb, *samp_timer_sb;
 #endif
-  interface_t device;
+  interface_t  device;
 
   if (parent_w == NULL)
     return;
@@ -1746,8 +1748,8 @@ options_prep_adjust_sensitivity(GtkWidget *tb _U_, gpointer parent_w)
 static void
 options_remote_cb(GtkWidget *w _U_, gpointer d _U_)
 {
-  GtkWidget *opt_remote_w, *main_vb;
-  GtkWidget   *caller, *bbox, *ok_but, *cancel_bt;
+  GtkWidget     *opt_remote_w, *main_vb;
+  GtkWidget     *caller, *bbox, *ok_but, *cancel_bt;
   GtkWidget     *capture_fr, *capture_vb;
   GtkWidget     *nocap_rpcap_cb, *datatx_udp_cb;
 #ifdef HAVE_PCAP_SETSAMPLING
@@ -1757,7 +1759,7 @@ options_remote_cb(GtkWidget *w _U_, gpointer d _U_)
   GtkAdjustment *samp_count_adj, *samp_timer_adj;
   GSList        *samp_group;
 #endif
-  interface_t device;
+  interface_t    device;
 
   caller = gtk_widget_get_toplevel(w);
   opt_remote_w = g_object_get_data(G_OBJECT(caller), E_OPT_REMOTE_DIALOG_PTR_KEY);
@@ -1917,9 +1919,9 @@ capture_remote_combo_add_recent(gchar *s)
 {
   GList *vals = prefs_get_string_list (s);
   GList *valp = vals;
+  gint   auth_type;
+  char  *p;
   struct remote_host_info *rh;
-  gint auth_type;
-  char *p;
 
   if (valp == NULL)
     return FALSE;
@@ -1985,7 +1987,7 @@ select_first_entry(void)
 {
   GtkWidget        *view;
   GtkTreeModel     *model;
-  GtkTreeIter      iter;
+  GtkTreeIter       iter;
   GtkTreeSelection *selection;
 
   view = g_object_get_data(G_OBJECT(compile_bpf_w), E_COMPILE_TREE_VIEW_INTERFACES);
@@ -1998,9 +2000,9 @@ select_first_entry(void)
 static void
 add_page(gchar *name, gchar *text, gboolean error)
 {
-  GtkWidget        *view, *icon;
-  GtkTreeModel     *model;
-  GtkTreeIter      iter;
+  GtkWidget    *view, *icon;
+  GtkTreeModel *model;
+  GtkTreeIter   iter;
 
   view = g_object_get_data(G_OBJECT(compile_bpf_w), E_COMPILE_TREE_VIEW_INTERFACES);
   model = gtk_tree_view_get_model(GTK_TREE_VIEW(view));
@@ -2018,12 +2020,12 @@ add_page(gchar *name, gchar *text, gboolean error)
 static void
 compile_tree_select_cb(GtkTreeSelection *sel, gpointer dummy _U_)
 {
-  gchar *name,  *text;
+  gchar         *name,  *text;
   GtkTreeModel  *model;
-  GtkTreeIter   iter;
+  GtkTreeIter    iter;
   GtkWidget     *textview;
   GtkTextBuffer *buffer;
-  guint         error;
+  guint          error;
 
   if (gtk_tree_selection_get_selected(sel, &model, &iter))
   {
@@ -2044,12 +2046,12 @@ compile_tree_select_cb(GtkTreeSelection *sel, gpointer dummy _U_)
 static void
 compile_results_prep(GtkWidget *w _U_, gpointer data _U_)
 {
-  GtkWidget         *main_box, *main_vb, *bbox, *ok_btn, *top_hb, *ct_sb;
-  GtkListStore      *store;
-  GtkWidget         *view, *scrolled_win, *textview;
-  GtkTreeSelection  *selection;
-  GtkCellRenderer   *renderer;
-  GtkTreeViewColumn *column;
+  GtkWidget            *main_box, *main_vb, *bbox, *ok_btn, *top_hb, *ct_sb;
+  GtkListStore         *store;
+  GtkWidget            *view, *scrolled_win, *textview;
+  GtkTreeSelection     *selection;
+  GtkCellRenderer      *renderer;
+  GtkTreeViewColumn    *column;
   PangoFontDescription *font;
 
   if (compile_bpf_w != NULL) {
@@ -2154,13 +2156,13 @@ compile_results_prep(GtkWidget *w _U_, gpointer data _U_)
 static void
 capture_all_filter_compile_cb(GtkWidget *w _U_, gpointer user_data _U_)
 {
-  pcap_t *pd;
+  pcap_t    *pd;
   struct bpf_program fcode;
 
   GtkWidget *filter_cm;
   gchar     *filter_text;
-  guint     i;
-  gboolean  set = FALSE;
+  guint      i;
+  gboolean   set = FALSE;
 
   filter_cm = (GtkWidget *)g_object_get_data(G_OBJECT(cap_open_w), E_ALL_CFILTER_CM_KEY);
 
@@ -2187,20 +2189,21 @@ capture_all_filter_compile_cb(GtkWidget *w _U_, gpointer user_data _U_)
       filter_text = gtk_combo_box_text_get_active_text (GTK_COMBO_BOX_TEXT(filter_cm));
       g_mutex_lock(pcap_compile_mtx);
 #ifdef PCAP_NETMASK_UNKNOWN
-      if (pcap_compile(pd, &fcode, filter_text, 1 /* Do optimize */, PCAP_NETMASK_UNKNOWN) < 0) {
+      if (pcap_compile(pd, &fcode, filter_text, 1 /* Do optimize */, PCAP_NETMASK_UNKNOWN) < 0)
 #else
-      if (pcap_compile(pd, &fcode, filter_text, 1 /* Do optimize */, 0) < 0) {
+      if (pcap_compile(pd, &fcode, filter_text, 1 /* Do optimize */, 0) < 0)
 #endif
-        g_mutex_unlock(pcap_compile_mtx);
-        add_page(device.name, g_strdup(pcap_geterr(pd)), TRUE);
+      {
+          g_mutex_unlock(pcap_compile_mtx);
+          add_page(device.name, g_strdup(pcap_geterr(pd)), TRUE);
       } else {
-        GString *bpf_code_dump = g_string_new("");
-        struct bpf_insn *insn = fcode.bf_insns;
-        int i, n = fcode.bf_len;
-        gchar *bpf_code_str;
+        GString         *bpf_code_dump = g_string_new("");
+        struct bpf_insn *insn          = fcode.bf_insns;
+        int              ii, n         = fcode.bf_len;
+        gchar           *bpf_code_str;
 
-        for (i = 0; i < n; ++insn, ++i) {
-            g_string_append(bpf_code_dump, bpf_image(insn, i));
+        for (ii = 0; ii < n; ++insn, ++ii) {
+            g_string_append(bpf_code_dump, bpf_image(insn, ii));
             g_string_append(bpf_code_dump, "\n");
         }
         bpf_code_str = g_string_free(bpf_code_dump, FALSE);
@@ -2221,10 +2224,10 @@ capture_all_filter_compile_cb(GtkWidget *w _U_, gpointer user_data _U_)
 static void
 compile_results_win(gchar *text, gboolean error)
 {
-  GtkWidget         *main_box, *bbox, *ok_btn, *results_w;
-  GtkWidget         *scrolled_win, *textview;
+  GtkWidget            *main_box, *bbox, *ok_btn, *results_w;
+  GtkWidget            *scrolled_win, *textview;
   PangoFontDescription *font;
-  GtkTextBuffer     *buffer;
+  GtkTextBuffer        *buffer;
 
   results_w = dlg_window_new("Compile results");
   /* set the initial position (must be done, before show is called!) */
@@ -2276,13 +2279,13 @@ compile_results_win(gchar *text, gboolean error)
 static void
 capture_filter_compile_cb(GtkWidget *w _U_, gpointer user_data _U_)
 {
-  pcap_t *pd;
-  struct bpf_program fcode;
+  pcap_t             *pd;
+  struct bpf_program  fcode;
 
   GtkWidget *filter_cm;
   gchar     *filter_text;
-  gpointer  ptr;
-  int       dlt;
+  gpointer   ptr;
+  int        dlt;
   GtkWidget *linktype_combo_box = (GtkWidget *) g_object_get_data(G_OBJECT(opt_edit_w), E_CAP_LT_CBX_KEY);
 
   if (! ws_combo_box_get_active_pointer(GTK_COMBO_BOX(linktype_combo_box), &ptr)) {
@@ -2303,9 +2306,9 @@ capture_filter_compile_cb(GtkWidget *w _U_, gpointer user_data _U_)
     g_mutex_unlock(pcap_compile_mtx);
     compile_results_win(g_strdup(pcap_geterr(pd)), 1);
   } else {
-    GString *bpf_code_dump = g_string_new("");
-    struct bpf_insn *insn = fcode.bf_insns;
-    int i, n = fcode.bf_len;
+    GString         *bpf_code_dump = g_string_new("");
+    struct bpf_insn *insn          = fcode.bf_insns;
+    int              i, n          = fcode.bf_len;
 
     gchar *bpf_code_str;
 
@@ -2339,15 +2342,15 @@ options_edit_destroy_cb(GtkWidget *win, gpointer user_data _U_)
 static void
 update_options_table(gint index)
 {
-  interface_t  device;
+  interface_t   device;
   GtkTreePath  *path;
   GtkTreeView  *if_cb;
   GtkTreeModel *model;
-  GtkTreeIter  iter;
-  gchar *temp, *path_str, *snaplen_string, *linkname="";
-  GList *list;
-  link_row *link = NULL;
-  gboolean enabled;
+  GtkTreeIter   iter;
+  gchar        *temp, *path_str, *snaplen_string, *linkname = "";
+  GList        *list;
+  link_row     *link = NULL;
+  gboolean      enabled;
 
   device = g_array_index(global_capture_opts.all_ifaces, interface_t, marked_interface);
 
@@ -2427,9 +2430,9 @@ save_options_cb(GtkWidget *win _U_, gpointer user_data _U_)
 #endif
 
   interface_t device;
-  gpointer  ptr = NULL;
-  int       dlt = -1;
-  gchar    *filter_text;
+  gpointer   ptr = NULL;
+  int        dlt = -1;
+  gchar     *filter_text;
 
   device = g_array_index(global_capture_opts.all_ifaces, interface_t, marked_interface);
   global_capture_opts.all_ifaces = g_array_remove_index(global_capture_opts.all_ifaces, marked_interface);
@@ -2488,8 +2491,8 @@ save_options_cb(GtkWidget *win _U_, gpointer user_data _U_)
 static void
 adjust_snap_sensitivity(GtkWidget *tb _U_, gpointer parent_w _U_)
 {
-  GtkWidget *snap_cb, *snap_sb;
-  interface_t device;
+  GtkWidget   *snap_cb, *snap_sb;
+  interface_t  device;
 
   device = g_array_index(global_capture_opts.all_ifaces, interface_t, marked_interface);
   global_capture_opts.all_ifaces = g_array_remove_index(global_capture_opts.all_ifaces, marked_interface);
@@ -2507,47 +2510,47 @@ adjust_snap_sensitivity(GtkWidget *tb _U_, gpointer parent_w _U_)
 
 void options_interface_cb(GtkTreeView *view, GtkTreePath *path, GtkTreeViewColumn *column _U_, gpointer userdata)
 {
-  GtkWidget     *caller, *window, *swindow=NULL, *if_view,
-                *main_vb, *if_hb, *if_lb, *if_lb_name,
-                *main_hb, *left_vb,
+  GtkWidget       *caller, *window, *swindow = NULL, *if_view,
+                  *main_vb, *if_hb, *if_lb, *if_lb_name,
+                  *main_hb, *left_vb,
 #if defined (HAVE_AIRPCAP) || defined (HAVE_PCAP_REMOTE) || defined (HAVE_PCAP_CREATE)
-                *right_vb,
+                  *right_vb,
 #endif
-                *capture_fr, *capture_vb,
-                *if_ip_hb, *if_ip_lb = NULL, *if_ip_name,
-                *if_vb_left, *if_vb_right,
-                *linktype_hb, *linktype_lb, *linktype_combo_box,
-                *snap_hb, *snap_cb, *snap_sb, *snap_lb,
-                *promisc_cb,
+                  *capture_fr, *capture_vb,
+                  *if_ip_hb, *if_ip_lb         = NULL, *if_ip_name,
+                  *if_vb_left, *if_vb_right,
+                  *linktype_hb, *linktype_lb, *linktype_combo_box,
+                  *snap_hb, *snap_cb, *snap_sb, *snap_lb,
+                  *promisc_cb,
 #ifdef HAVE_PCAP_CREATE
-                *monitor_cb,
+                  *monitor_cb,
 #endif
-                *filter_hb, *filter_bt, *filter_te, *filter_cm,
+                  *filter_hb, *filter_bt, *filter_te, *filter_cm,
 #if defined(HAVE_PCAP_OPEN_DEAD) && defined(HAVE_BPF_IMAGE)
-                *compile_bt,
+                  *compile_bt,
 #endif
-                *bbox, *ok_but, *cancel_bt,
-                *help_bt;
-  GList         *cf_entry, *list, *cfilter_list;
-  GtkAdjustment *snap_adj;
+                  *bbox, *ok_but, *cancel_bt,
+                  *help_bt;
+  GList           *cf_entry, *list, *cfilter_list;
+  GtkAdjustment   *snap_adj;
 #if defined(_WIN32) || defined(HAVE_PCAP_CREATE)
-  GtkAdjustment *buffer_size_adj;
-  GtkWidget     *buffer_size_lb, *buffer_size_sb, *buffer_size_hb;
+  GtkAdjustment   *buffer_size_adj;
+  GtkWidget       *buffer_size_lb, *buffer_size_sb, *buffer_size_hb;
 #endif
 #ifdef HAVE_PCAP_REMOTE
-  GtkWidget     *remote_bt;
+  GtkWidget       *remote_bt;
 #endif
  #ifdef HAVE_AIRPCAP
-  GtkWidget     *advanced_bt;
+  GtkWidget       *advanced_bt;
 #endif
-  interface_t   device;
-  GtkTreeModel  *model;
-  GtkTreeIter   iter;
-  link_row      *temp;
-  gboolean      found = FALSE;
-  gint          num_link_types, num_supported_link_types, first_supported_index;
-  guint         i;
-  gchar         *tok, *name;
+  interface_t      device;
+  GtkTreeModel    *model;
+  GtkTreeIter      iter;
+  link_row        *temp;
+  gboolean         found                     = FALSE;
+  gint             num_link_types, num_supported_link_types, first_supported_index;
+  guint            i;
+  gchar           *tok, *name;
   GtkCellRenderer *renderer;
   GtkListStore    *store;
 
@@ -2965,16 +2968,16 @@ static void toggle_callback(GtkCellRendererToggle *cell _U_,
                gpointer data _U_)
 {
   /* get the treemodel from somewhere */
-  GtkTreeIter  iter;
+  GtkTreeIter   iter;
   GtkTreeView  *if_cb;
   GtkTreeModel *model;
-  GtkTreePath *path = gtk_tree_path_new_from_string (path_str);
-  gboolean enabled;
-  GtkWidget *pcap_ng_cb, *filter_cm;
-  interface_t device;
-  gchar *name;
-  gint index = -1;
-  guint i;
+  GtkTreePath  *path  = gtk_tree_path_new_from_string (path_str);
+  gboolean      enabled;
+  GtkWidget    *pcap_ng_cb, *filter_cm;
+  interface_t   device;
+  gchar        *name;
+  gint          index = -1;
+  guint         i;
 
   if_cb = (GtkTreeView *) g_object_get_data(G_OBJECT(cap_open_w), E_CAP_IFACE_KEY);
   model = gtk_tree_view_get_model(if_cb);
@@ -3043,10 +3046,10 @@ static void toggle_callback(GtkCellRendererToggle *cell _U_,
 
 void enable_selected_interface(gchar *name, gboolean selected)
 {
-  GtkTreeIter  iter;
+  GtkTreeIter   iter;
   GtkTreeView  *if_cb;
   GtkTreeModel *model;
-  gchar *name_str;
+  gchar        *name_str;
 
   if_cb      = (GtkTreeView *) g_object_get_data(G_OBJECT(cap_open_w), E_CAP_IFACE_KEY);
   model = gtk_tree_view_get_model(if_cb);
@@ -3075,11 +3078,11 @@ void enable_selected_interface(gchar *name, gboolean selected)
 
 static void capture_all_cb(GtkToggleButton *button, gpointer d _U_)
 {
-  GtkTreeIter  iter;
+  GtkTreeIter   iter;
   GtkTreeView  *if_cb;
   GtkTreeModel *model;
-  GtkWidget *pcap_ng_cb;
-  gboolean enabled = FALSE, capture_set = FALSE;
+  GtkWidget    *pcap_ng_cb;
+  gboolean      enabled = FALSE, capture_set = FALSE;
 
   if (gtk_toggle_button_get_active(button))
     enabled = TRUE;
@@ -3125,13 +3128,13 @@ static void capture_all_cb(GtkToggleButton *button, gpointer d _U_)
 
 static void promisc_mode_callback(GtkToggleButton *button, gpointer d _U_)
 {
-  GtkTreeIter  iter;
-  GtkTreeView  *if_cb;
-  GtkTreeModel *model;
-  gboolean enabled = FALSE;
-  interface_t device;
-  interface_options interface_opts;
-  guint i;
+  GtkTreeIter        iter;
+  GtkTreeView       *if_cb;
+  GtkTreeModel      *model;
+  gboolean           enabled = FALSE;
+  interface_t        device;
+  interface_options  interface_opts;
+  guint              i;
 
   if (gtk_toggle_button_get_active(button))
     enabled = TRUE;
@@ -3187,7 +3190,7 @@ show_remote_dialog(GtkWidget *w)
 
 static void change_pipe_name_cb(gpointer dialog _U_, gint btn, gpointer data)
 {
-  guint i;
+  guint         i;
   interface_t   device;
   gchar        *temp, *optname, *snaplen_string/*, *oldname = ""*/;
   GtkTreeView  *if_cb;
@@ -3298,17 +3301,17 @@ static void change_pipe_name_cb(gpointer dialog _U_, gint btn, gpointer data)
 static void
 add_pipe_cb(gpointer w _U_)
 {
-  interface_t  device;
-  gint         index;
+  interface_t   device;
+  gint          index;
   GtkTreeView  *if_cb;
   GtkTreeModel *model;
-  GtkTreeIter  iter;
+  GtkTreeIter   iter;
   gchar        *temp, *path_str, *snaplen_string;
   GtkWidget    *pipe_te;
   const gchar  *g_save_file;
   gchar        *name;
-  guint        i;
-  gpointer     dialog;
+  guint         i;
+  gpointer      dialog;
 
   pipe_te = (GtkWidget *) g_object_get_data(G_OBJECT(interface_management_w), E_CAP_PIPE_TE_KEY);
   g_save_file = gtk_entry_get_text(GTK_ENTRY(pipe_te));
@@ -3409,7 +3412,7 @@ static void
 pipe_new_bt_clicked_cb(GtkWidget *w _U_, gpointer data _U_)
 {
   GtkWidget    *name_te = g_object_get_data(G_OBJECT(interface_management_w), E_CAP_PIPE_TE_KEY);
-  GtkTreeView  *pipe_l = GTK_TREE_VIEW(g_object_get_data(G_OBJECT(interface_management_w), E_CAP_PIPE_L_KEY));
+  GtkTreeView  *pipe_l  = GTK_TREE_VIEW(g_object_get_data(G_OBJECT(interface_management_w), E_CAP_PIPE_L_KEY));
   GtkListStore *store;
   GtkTreeIter   iter;
 
@@ -3432,13 +3435,13 @@ pipe_new_bt_clicked_cb(GtkWidget *w _U_, gpointer data _U_)
 static void
 pipe_del_bt_clicked_cb(GtkWidget *w _U_, gpointer data _U_)
 {
-  GtkWidget        *pipe_l = g_object_get_data(G_OBJECT(interface_management_w), E_CAP_PIPE_L_KEY);
+  GtkWidget        *pipe_l  = g_object_get_data(G_OBJECT(interface_management_w), E_CAP_PIPE_L_KEY);
   GtkWidget        *name_te = g_object_get_data(G_OBJECT(interface_management_w), E_CAP_PIPE_TE_KEY);
   GtkTreeSelection *sel;
   GtkTreeModel     *model, *optmodel;
   GtkTreeIter       iter, optiter;
   GtkTreeView      *if_cb;
-  gchar            *name, *optname="";
+  gchar            *name, *optname = "";
   guint             i;
 
   sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(pipe_l));
@@ -3486,12 +3489,12 @@ pipe_del_bt_clicked_cb(GtkWidget *w _U_, gpointer data _U_)
 static void
 pipe_name_te_changed_cb(GtkWidget *w _U_, gpointer data _U_)
 {
-  GtkWidget   *name_te = g_object_get_data(G_OBJECT(interface_management_w), E_CAP_PIPE_TE_KEY);
-  GtkWidget   *pipe_l = g_object_get_data(G_OBJECT(interface_management_w), E_CAP_PIPE_L_KEY);
-  const gchar *name = "";
-  GtkTreeSelection  *sel;
-  GtkTreeModel      *model;
-  GtkTreeIter        iter;
+  GtkWidget        *name_te = g_object_get_data(G_OBJECT(interface_management_w), E_CAP_PIPE_TE_KEY);
+  GtkWidget        *pipe_l  = g_object_get_data(G_OBJECT(interface_management_w), E_CAP_PIPE_L_KEY);
+  const gchar      *name    = "";
+  GtkTreeSelection *sel;
+  GtkTreeModel     *model;
+  GtkTreeIter       iter;
 
   sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(pipe_l));
   name   = gtk_entry_get_text(GTK_ENTRY(name_te));
@@ -3505,11 +3508,11 @@ pipe_name_te_changed_cb(GtkWidget *w _U_, gpointer data _U_)
 static void
 fill_pipe_list(void)
 {
-  guint          i;
-  interface_t    device;
-  GtkTreeIter    iter;
-  GtkTreeView   *pipe_l = GTK_TREE_VIEW(g_object_get_data(G_OBJECT(interface_management_w), E_CAP_PIPE_L_KEY));
-  GtkListStore  *store  = GTK_LIST_STORE(gtk_tree_view_get_model(pipe_l));
+  guint         i;
+  interface_t   device;
+  GtkTreeIter   iter;
+  GtkTreeView  *pipe_l = GTK_TREE_VIEW(g_object_get_data(G_OBJECT(interface_management_w), E_CAP_PIPE_L_KEY));
+  GtkListStore *store  = GTK_LIST_STORE(gtk_tree_view_get_model(pipe_l));
 
   for (i = 0; i < global_capture_opts.all_ifaces->len; i++) {
     device = g_array_index(global_capture_opts.all_ifaces, interface_t, i);
@@ -3528,9 +3531,9 @@ pipe_sel_list_cb(GtkTreeSelection *sel, gpointer data _U_)
  /* GtkWidget    *pipe_l   = GTK_WIDGET(gtk_tree_selection_get_tree_view(sel));*/
   GtkTreeModel *model;
   GtkTreeIter   iter;
-  GtkWidget    *name_te     = g_object_get_data(G_OBJECT(interface_management_w), E_CAP_PIPE_TE_KEY);
-  GtkWidget    *del_bt      = g_object_get_data(G_OBJECT(interface_management_w), E_CAP_PIPE_DEL_KEY);
-  gchar        *name        = NULL;
+  GtkWidget    *name_te = g_object_get_data(G_OBJECT(interface_management_w), E_CAP_PIPE_TE_KEY);
+  GtkWidget    *del_bt  = g_object_get_data(G_OBJECT(interface_management_w), E_CAP_PIPE_DEL_KEY);
+  gchar        *name    = NULL;
 
   if (gtk_tree_selection_get_selected(sel, &model, &iter)) {
     gtk_tree_model_get(model, &iter, 0, &name, -1);
@@ -3558,12 +3561,12 @@ cancel_pipe_cb (gpointer w _U_)
 static void
 fill_local_list(void)
 {
-  guint          i;
-  interface_t    device;
-  GtkTreeIter    iter;
-  GtkListStore  *store;
-  GtkTreeView   *local_l = GTK_TREE_VIEW(g_object_get_data(G_OBJECT(interface_management_w), E_CAP_LOCAL_L_KEY));
-  
+  guint         i;
+  interface_t   device;
+  GtkTreeIter   iter;
+  GtkListStore *store;
+  GtkTreeView  *local_l = GTK_TREE_VIEW(g_object_get_data(G_OBJECT(interface_management_w), E_CAP_LOCAL_L_KEY));
+
 #ifdef _WIN32
   store = gtk_list_store_new (3, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_BOOLEAN);
 #else
@@ -3574,8 +3577,8 @@ fill_local_list(void)
     device = g_array_index(global_capture_opts.all_ifaces, interface_t, i);
     if (device.local && device.type != IF_PIPE && device.type != IF_STDIN) {
       gtk_list_store_append(store, &iter);
-      
-#ifdef _WIN32      
+
+#ifdef _WIN32
       gtk_list_store_set(store, &iter, 0, device.friendly_name, 1, device.name,  2, device.hidden, -1);
 #else
       gtk_list_store_set(store, &iter, 0, device.name, 1, device.hidden, -1);
@@ -3591,12 +3594,12 @@ static void local_hide_cb(GtkCellRendererToggle *cell _U_,
                           gchar *path_str,
                           gpointer data _U_)
 {
-  gboolean hide, hide_enabled = TRUE;
-  gchar *name;
-  GtkTreeModel  *model;
-  GtkTreeIter    iter;
-  GtkTreePath   *path = gtk_tree_path_new_from_string (path_str);
-  GtkTreeView   *local_l = GTK_TREE_VIEW(g_object_get_data(G_OBJECT(interface_management_w), E_CAP_LOCAL_L_KEY));
+  gboolean      hide, hide_enabled = TRUE;
+  gchar        *name;
+  GtkTreeModel *model;
+  GtkTreeIter   iter;
+  GtkTreePath  *path    = gtk_tree_path_new_from_string (path_str);
+  GtkTreeView  *local_l = GTK_TREE_VIEW(g_object_get_data(G_OBJECT(interface_management_w), E_CAP_LOCAL_L_KEY));
 
   model = gtk_tree_view_get_model(local_l);
   gtk_tree_model_get_iter (model, &iter, path);
@@ -3631,12 +3634,12 @@ static void local_hide_cb(GtkCellRendererToggle *cell _U_,
 static void
 apply_local_cb(GtkWidget *win _U_, gpointer *data _U_)
 {
-  GtkTreeIter    iter;
-  GtkTreeModel  *model;
-  gchar         *name, *new_hide;
-  gboolean       hide;
-  gint           first_if = TRUE;
-  GtkTreeView   *local_l;
+  GtkTreeIter   iter;
+  GtkTreeModel *model;
+  gchar        *name, *new_hide;
+  gboolean      hide;
+  gint          first_if = TRUE;
+  GtkTreeView  *local_l;
 
   if (global_capture_opts.all_ifaces->len > 0) {
     local_l = GTK_TREE_VIEW(g_object_get_data(G_OBJECT(interface_management_w), E_CAP_LOCAL_L_KEY));
@@ -3663,20 +3666,20 @@ apply_local_cb(GtkWidget *win _U_, gpointer *data _U_)
     g_free(prefs.capture_devices_hide);
     prefs.capture_devices_hide = new_hide;
     hide_interface(g_strdup(new_hide));
-    
+
     /* Refresh all places that are displaying an interface list
        that includes local interfaces. */
     refresh_local_interface_lists();
-    
+
     /* save changes to the preferences file */
     if (!prefs.gui_use_pref_save) {
       prefs_main_write();
     }
-  }    
+  }
 }
 
 void
-capture_dlg_refresh_if(void)
+capture_dlg_refresh_if (void)
 {
   GtkTreeView *view;
 
@@ -3698,13 +3701,13 @@ rescan_local_cb(GtkWidget *button _U_, gpointer *data _U_)
 static void
 fill_remote_list(void)
 {
-  guint i;
-  interface_t device;
-  GtkTreeIter iter, child;
-  gchar *host = "";
-  GtkTreeView   *remote_l;
+  guint         i;
+  interface_t   device;
+  GtkTreeIter   iter, child;
+  gchar        *host = "";
+  GtkTreeView  *remote_l;
   GtkTreeStore *store;
-  GtkWidget *host_te, *remote_w;
+  GtkWidget    *host_te, *remote_w;
 
   num_selected = 0;
   gtk_widget_set_sensitive(g_object_get_data(G_OBJECT(interface_management_w), E_REMOTE_DEL_BT_KEY), FALSE);
@@ -3753,11 +3756,11 @@ static void remote_hide_cb(GtkCellRendererToggle *cell _U_,
                            gchar *path_str,
                            gpointer data _U_)
 {
-  gboolean hide;
-  GtkTreeModel  *model;
-  GtkTreeIter    iter;
-  GtkTreePath   *path = gtk_tree_path_new_from_string (path_str);
-  GtkTreeView   *remote_l = GTK_TREE_VIEW(g_object_get_data(G_OBJECT(interface_management_w), E_CAP_REMOTE_L_KEY));
+  gboolean      hide;
+  GtkTreeModel *model;
+  GtkTreeIter   iter;
+  GtkTreePath  *path     = gtk_tree_path_new_from_string (path_str);
+  GtkTreeView  *remote_l = GTK_TREE_VIEW(g_object_get_data(G_OBJECT(interface_management_w), E_CAP_REMOTE_L_KEY));
 
   model = gtk_tree_view_get_model(remote_l);
   gtk_tree_model_get_iter (model, &iter, path);
@@ -3773,11 +3776,11 @@ static void remote_hide_cb(GtkCellRendererToggle *cell _U_,
 static void
 ok_remote_cb(GtkWidget *win _U_, gpointer *data _U_)
 {
-  GtkTreeIter    iter, child;
-  GtkTreeModel  *model;
-  gchar         *name, *new_hide;
-  gboolean       hide;
-  gint           first_if = TRUE;
+  GtkTreeIter   iter, child;
+  GtkTreeModel *model;
+  gchar        *name, *new_hide;
+  gboolean      hide;
+  gint          first_if = TRUE;
 
   GtkTreeView   *remote_l = GTK_TREE_VIEW(g_object_get_data(G_OBJECT(interface_management_w), E_CAP_REMOTE_L_KEY));
   model = gtk_tree_view_get_model(remote_l);
@@ -3834,12 +3837,12 @@ select_host_cb(GtkTreeSelection *selection _U_,
 static void
 remove_remote_host(GtkWidget *w _U_, gpointer data _U_)
 {
-  GtkTreeIter iter, child;
-  GtkTreeModel *model;
-  gchar *host;
-  gint num_children, i;
-  interface_t device;
-  GtkTreeView   *remote_l = GTK_TREE_VIEW(g_object_get_data(G_OBJECT(interface_management_w), E_CAP_REMOTE_L_KEY));
+  GtkTreeIter       iter, child;
+  GtkTreeModel     *model;
+  gchar            *host;
+  gint              num_children, i;
+  interface_t       device;
+  GtkTreeView      *remote_l  = GTK_TREE_VIEW(g_object_get_data(G_OBJECT(interface_management_w), E_CAP_REMOTE_L_KEY));
   GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(remote_l));
 
   model = gtk_tree_view_get_model(remote_l);
@@ -3878,24 +3881,25 @@ remove_remote_host(GtkWidget *w _U_, gpointer data _U_)
 static void
 show_add_interfaces_dialog(void)
 {
-  GtkWidget      *vbox, *top_hb;
-  GtkWidget      *hbox, *bbox, *list_bb, *edit_fr, *pipe_fr, *pipe_sc, *pipe_l, *props_fr, *props_vb;
-  GtkWidget      *main_nb;
-  GtkWidget      *temp_page, *tmp;
-  GtkWidget      *pipe_hb, *pipe_bt, *pipe_lb, *pipe_te, *pipe_vb;
-  GtkWidget      *add_bt, *cancel_bt, *new_bt, *del_bt, *middle_hb;
-  GtkWidget      *local_fr, *local_l, *local_sc, *local_vb;
-  GtkWidget      *apply_bt, *refresh_bt;
-  GtkCellRenderer *renderer, *toggle_renderer;
+  GtkWidget         *vbox, *top_hb;
+  GtkWidget         *hbox, *bbox, *list_bb, *edit_fr, *pipe_fr, *pipe_sc, *pipe_l, *props_fr, *props_vb;
+  GtkWidget         *main_nb;
+  GtkWidget         *temp_page, *tmp;
+  GtkWidget         *pipe_hb, *pipe_bt, *pipe_lb, *pipe_te, *pipe_vb;
+  GtkWidget         *add_bt, *cancel_bt, *new_bt, *del_bt, *middle_hb;
+  GtkWidget         *local_fr, *local_l, *local_sc, *local_vb;
+  GtkWidget         *apply_bt, *refresh_bt;
+  GtkCellRenderer   *renderer, *toggle_renderer;
   GtkTreeViewColumn *column;
-  GtkTreeSelection *sel;
-  GtkListStore   *store;
+  GtkTreeSelection  *sel;
+  GtkListStore      *store;
 #if defined(HAVE_PCAP_REMOTE)
-  GtkWidget      *remote_fr, *remote_l, *remote_sc, *remote_vb;
-  GtkWidget      *delete_bt, *add_but, *ok_but;
-  GtkWidget      *button_hbox, *help_hbox;
-  GtkTreeSelection *selection;
+  GtkWidget         *remote_fr, *remote_l, *remote_sc, *remote_vb;
+  GtkWidget         *delete_bt, *add_but, *ok_but;
+  GtkWidget         *button_hbox, *help_hbox;
+  GtkTreeSelection  *selection;
 #endif
+
   interface_management_w = dlg_window_new("Interface Management");  /* transient_for top_level */
   gtk_window_set_destroy_with_parent (GTK_WINDOW(interface_management_w), TRUE);
   gtk_window_set_default_size(GTK_WINDOW(interface_management_w), 600, 200);
@@ -4076,7 +4080,7 @@ show_add_interfaces_dialog(void)
   gtk_tree_view_column_set_expand(column, TRUE);
   gtk_tree_view_column_set_sort_column_id(column, 0+LOCAL_OFFSET);
   gtk_tree_view_append_column(GTK_TREE_VIEW(local_l), column);
-  
+
   toggle_renderer = gtk_cell_renderer_toggle_new();
   column = gtk_tree_view_column_new_with_attributes("Hide", GTK_CELL_RENDERER(toggle_renderer), "active", 1+LOCAL_OFFSET, NULL);
   g_signal_connect (G_OBJECT(toggle_renderer), "toggled", G_CALLBACK (local_hide_cb), NULL);
@@ -4254,16 +4258,16 @@ show_add_interfaces_dialog(void)
 static gboolean
 columns_menu_handler(GtkWidget *widget, GdkEvent *event, gpointer data)
 {
-  GtkWidget *menu = (GtkWidget *)data;
+  GtkWidget      *menu         = (GtkWidget *)data;
   GdkEventButton *event_button = NULL;
 
   /* context menu handler */
-  if(event->type == GDK_BUTTON_PRESS) {
+  if (event->type == GDK_BUTTON_PRESS) {
     event_button = (GdkEventButton *) event;
 
     /* To quote the "Gdk Event Structures" doc:
      * "Normally button 1 is the left mouse button, 2 is the middle button, and 3 is the right button" */
-    if(event_button->button == 3) {
+    if (event_button->button == 3) {
       gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, widget,
                      event_button->button,
                      event_button->time);
@@ -4277,9 +4281,10 @@ columns_menu_handler(GtkWidget *widget, GdkEvent *event, gpointer data)
 static gboolean
 column_button_pressed_cb (GtkWidget *widget, GdkEvent *event, gpointer data)
 {
-  GtkWidget *col = (GtkWidget *) data;
+  GtkWidget   *col  = (GtkWidget *) data;
   GtkTreeView *view;
-  GtkWidget *menu = g_object_get_data(G_OBJECT(columns_menu_object), PM_COLUMNS_KEY);
+  GtkWidget   *menu = g_object_get_data(G_OBJECT(columns_menu_object), PM_COLUMNS_KEY);
+
   view = (GtkTreeView *)g_object_get_data(G_OBJECT(cap_open_w), E_CAP_IFACE_KEY);
   g_object_set_data(G_OBJECT(view), E_MCAPTURE_COLUMNS_COLUMN_KEY, col);
   return columns_menu_handler (widget, event, menu);
@@ -4289,50 +4294,50 @@ column_button_pressed_cb (GtkWidget *widget, GdkEvent *event, gpointer data)
 void
 capture_prep_cb(GtkWidget *w _U_, gpointer d _U_)
 {
-  GtkWidget     *main_vb,
-                *main_hb, *left_vb, *right_vb,
-                *capture_fr, *capture_vb,
-                *all_hb, *all_cb,
-                *promisc_cb, *pcap_ng_cb,
-                *file_fr, *file_vb,
-                *file_hb, *file_bt, *file_lb, *file_te,
-                *multi_tb, *multi_files_on_cb,
-                *ring_filesize_cb, *ring_filesize_sb, *ring_filesize_cbx,
-                *file_duration_cb, *file_duration_sb, *file_duration_cbx,
-                *ringbuffer_nbf_cb, *ringbuffer_nbf_sb, *ringbuffer_nbf_lb,
-                *stop_files_cb, *stop_files_sb, *stop_files_lb,
-                *limit_fr, *limit_vb, *limit_tb,
-                *stop_packets_cb, *stop_packets_sb, *stop_packets_lb,
-                *stop_filesize_cb, *stop_filesize_sb, *stop_filesize_cbx,
-                *stop_duration_cb, *stop_duration_sb, *stop_duration_cbx,
-                *display_fr, *display_vb,
-                *sync_cb, *auto_scroll_cb, *hide_info_cb,
-                *resolv_fr, *resolv_vb,
-                *m_resolv_cb, *n_resolv_cb, *t_resolv_cb, *e_resolv_cb,
-                *bbox, *close_bt,
-                *all_filter_cm, *all_filter_te, *all_filter_bt, *all_filter_hb,
-                *all_vb,
-                *help_bt;
+  GtkWidget         *main_vb,
+                    *main_hb, *left_vb, *right_vb,
+                    *capture_fr, *capture_vb,
+                    *all_hb, *all_cb,
+                    *promisc_cb, *pcap_ng_cb,
+                    *file_fr, *file_vb,
+                    *file_hb, *file_bt, *file_lb, *file_te,
+                    *multi_tb, *multi_files_on_cb,
+                    *ring_filesize_cb, *ring_filesize_sb, *ring_filesize_cbx,
+                    *file_duration_cb, *file_duration_sb, *file_duration_cbx,
+                    *ringbuffer_nbf_cb, *ringbuffer_nbf_sb, *ringbuffer_nbf_lb,
+                    *stop_files_cb, *stop_files_sb, *stop_files_lb,
+                    *limit_fr, *limit_vb, *limit_tb,
+                    *stop_packets_cb, *stop_packets_sb, *stop_packets_lb,
+                    *stop_filesize_cb, *stop_filesize_sb, *stop_filesize_cbx,
+                    *stop_duration_cb, *stop_duration_sb, *stop_duration_cbx,
+                    *display_fr, *display_vb,
+                    *sync_cb, *auto_scroll_cb, *hide_info_cb,
+                    *resolv_fr, *resolv_vb,
+                    *m_resolv_cb, *n_resolv_cb, *t_resolv_cb, *e_resolv_cb,
+                    *bbox, *close_bt,
+                    *all_filter_cm, *all_filter_te, *all_filter_bt, *all_filter_hb,
+                    *all_vb,
+                    *help_bt;
 #ifdef HAVE_AIRPCAP
-  GtkWidget     *decryption_cb;
-  int           err;
-  gchar         *err_str;
+  GtkWidget         *decryption_cb;
+  int                err;
+  gchar             *err_str;
 #endif
-  GtkWidget     *iftype_cbx;
-
-  GtkAdjustment *ringbuffer_nbf_adj,
-                *stop_packets_adj, *stop_filesize_adj, *stop_duration_adj, *stop_files_adj,
-                *ring_filesize_adj, *file_duration_adj;
-  int              row;
-  guint32          value;
-  gchar            *cap_title;
-  GtkWidget        *view;
-  GtkWidget        *swindow;
-  GtkCellRenderer  *renderer;
-  GtkCellRenderer  *toggle_renderer;
+  GtkWidget         *iftype_cbx;
+
+  GtkAdjustment     *ringbuffer_nbf_adj,
+                    *stop_packets_adj, *stop_filesize_adj, *stop_duration_adj, *stop_files_adj,
+                    *ring_filesize_adj, *file_duration_adj;
+  int                row;
+  guint32            value;
+  gchar             *cap_title;
+  GtkWidget         *view;
+  GtkWidget         *swindow;
+  GtkCellRenderer   *renderer;
+  GtkCellRenderer   *toggle_renderer;
   GtkTreeSelection  *selection;
   GtkTreeViewColumn *column;
-  gboolean          if_present = TRUE;
+  gboolean           if_present = TRUE;
   GList             *all_cfilter_list, *cf_entry;
 
   if (interfaces_dialog_window_present()) {
@@ -5041,10 +5046,10 @@ static void
 capture_start_confirmed(void)
 {
   interface_options interface_opts;
-  guint i;
+  guint             i;
 
   /* did the user ever select a capture interface before? */
-  if(global_capture_opts.num_selected == 0 &&
+  if (global_capture_opts.num_selected == 0 &&
       ((prefs.capture_device == NULL) || (*prefs.capture_device != '\0'))) {
     simple_dialog(ESD_TYPE_CONFIRMATION,
                   ESD_BTN_OK,
@@ -5126,8 +5131,8 @@ capture_start_cb(GtkWidget *w _U_, gpointer d _U_)
 static void
 select_link_type_cb(GtkWidget *linktype_combo_box, gpointer data _U_)
 {
-  gpointer  ptr;
-  int       dlt;
+  gpointer    ptr;
+  int         dlt;
   interface_t device;
 
   device = g_array_index(global_capture_opts.all_ifaces, interface_t, marked_interface);
@@ -5161,20 +5166,20 @@ capture_prep_pipe_cb(GtkWidget *pipe_bt, GtkWidget *pipe_te)
 /* convert dialog settings into capture_opts values */
 static gboolean
 capture_dlg_prep(gpointer parent_w) {
-  GtkWidget *pcap_ng_cb,
-            *file_te, *multi_files_on_cb, *ringbuffer_nbf_sb, *ringbuffer_nbf_cb,
-            *sync_cb, *auto_scroll_cb, *hide_info_cb,
-            *stop_packets_cb, *stop_packets_sb,
-            *stop_filesize_cb, *stop_filesize_sb, *stop_filesize_cbx,
-            *stop_duration_cb, *stop_duration_sb, *stop_duration_cbx,
-            *ring_filesize_cb, *ring_filesize_sb, *ring_filesize_cbx,
-            *file_duration_cb, *file_duration_sb, *file_duration_cbx,
-            *stop_files_cb, *stop_files_sb,
-            *m_resolv_cb, *n_resolv_cb, *t_resolv_cb, *e_resolv_cb;
+  GtkWidget   *pcap_ng_cb,
+              *file_te, *multi_files_on_cb, *ringbuffer_nbf_sb, *ringbuffer_nbf_cb,
+              *sync_cb, *auto_scroll_cb, *hide_info_cb,
+              *stop_packets_cb, *stop_packets_sb,
+              *stop_filesize_cb, *stop_filesize_sb, *stop_filesize_cbx,
+              *stop_duration_cb, *stop_duration_sb, *stop_duration_cbx,
+              *ring_filesize_cb, *ring_filesize_sb, *ring_filesize_cbx,
+              *file_duration_cb, *file_duration_sb, *file_duration_cbx,
+              *stop_files_cb, *stop_files_sb,
+              *m_resolv_cb, *n_resolv_cb, *t_resolv_cb, *e_resolv_cb;
   const gchar *g_save_file;
-  gchar *cf_name;
-  gchar *dirname;
-  gint32 tmp;
+  gchar       *cf_name;
+  gchar       *dirname;
+  gint32       tmp;
 
   pcap_ng_cb = (GtkWidget *) g_object_get_data(G_OBJECT(parent_w), E_CAP_PCAP_NG_KEY);
   file_te    = (GtkWidget *) g_object_get_data(G_OBJECT(parent_w), E_CAP_FILE_TE_KEY);
@@ -5305,7 +5310,7 @@ capture_dlg_prep(gpointer parent_w) {
     if (global_capture_opts.has_autostop_filesize) {
       tmp = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(ring_filesize_sb));
       tmp = size_unit_combo_box_convert_value(ring_filesize_cbx, tmp);
-      if(tmp != 0) {
+      if (tmp != 0) {
         global_capture_opts.autostop_filesize = tmp;
       } else {
         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,
@@ -5339,7 +5344,7 @@ capture_dlg_prep(gpointer parent_w) {
     if (global_capture_opts.has_autostop_filesize) {
       tmp = gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(stop_filesize_sb));
       tmp = size_unit_combo_box_convert_value(stop_filesize_cbx, tmp);
-      if(tmp != 0) {
+      if (tmp != 0) {
         global_capture_opts.autostop_filesize = tmp;
       } else {
         simple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,
@@ -5357,12 +5362,12 @@ static GtkTreeModel *
 create_and_fill_model(GtkTreeView *view)
 {
   GtkListStore *store;
-  GtkTreeIter iter;
-  GList *list;
-  char *temp="", *snaplen_string, *linkname="";
-  guint i;
-  link_row *link = NULL;
-  interface_t device;
+  GtkTreeIter   iter;
+  GList        *list;
+  char         *temp = "", *snaplen_string, *linkname="";
+  guint         i;
+  link_row     *link = NULL;
+  interface_t   device;
 
 #if defined(HAVE_PCAP_CREATE)
   store = gtk_list_store_new (9, G_TYPE_BOOLEAN, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_STRING, G_TYPE_STRING);
@@ -5414,18 +5419,18 @@ query_tooltip_tree_view_cb (GtkWidget  *widget,
                             GtkTooltip *tooltip,
                             gpointer    data _U_)
 {
-  GtkTreeIter iter;
-  GtkTreeView *tree_view = GTK_TREE_VIEW (widget);
-  GtkTreeModel *model = gtk_tree_view_get_model (tree_view);
-  GtkTreePath *path = NULL;
-  gchar *tmp;
-  gchar *pathstring;
+  GtkTreeIter        iter;
+  GtkTreeView       *tree_view = GTK_TREE_VIEW (widget);
+  GtkTreeModel      *model     = gtk_tree_view_get_model (tree_view);
+  GtkTreePath       *path      = NULL;
+  gchar             *tmp;
+  gchar             *pathstring;
   GtkTreeViewColumn *column;
-  int col;
-  GtkCellRenderer* renderer=NULL;
-  GList *renderer_list;
+  int                col;
+  GtkCellRenderer*   renderer  = NULL;
+  GList             *renderer_list;
 
-  char buffer[512];
+  char               buffer[512];
 
    if (!gtk_tree_view_get_tooltip_context (tree_view, &x, &y, keyboard_tip, &model, &path, &iter))
     return FALSE;
@@ -5487,13 +5492,13 @@ static void
 activate_monitor(GtkTreeViewColumn *tree_column _U_, GtkCellRenderer *renderer,
                  GtkTreeModel *tree_model, GtkTreeIter *iter, gpointer data _U_)
 {
-  interface_t device;
-  GtkTreePath *path = gtk_tree_model_get_path(tree_model, iter);
-  int index = atoi(gtk_tree_path_to_string(path));
+  interface_t  device;
+  GtkTreePath *path  = gtk_tree_model_get_path(tree_model, iter);
+  int          index = atoi(gtk_tree_path_to_string(path));
 
   device = g_array_index(global_capture_opts.all_ifaces, interface_t, index);
 
-  if (device.monitor_mode_supported==TRUE) {
+  if (device.monitor_mode_supported == TRUE) {
     g_object_set(G_OBJECT(renderer), "mode", GTK_CELL_RENDERER_MODE_ACTIVATABLE, NULL);
   } else {
     g_object_set(G_OBJECT(renderer), "mode", GTK_CELL_RENDERER_MODE_INERT, NULL);
@@ -5549,16 +5554,16 @@ capture_prep_destroy_cb(GtkWidget *win _U_, gpointer user_data _U_)
 static void
 capture_prep_monitor_changed_cb(GtkWidget *monitor, gpointer argp _U_)
 {
-  GList *lt_entry;
-  gchar *if_string="";
-  gboolean monitor_mode;
-  if_capabilities_t *caps=NULL;
-  gint linktype_count = 0, i;
-  data_link_info_t *data_link_info;
-  interface_t device;
-  link_row *link;
-  GtkWidget *linktype_combo_box = (GtkWidget *) g_object_get_data(G_OBJECT(opt_edit_w), E_CAP_LT_CBX_KEY);
-  GtkWidget *linktype_lb = (GtkWidget *)g_object_get_data(G_OBJECT(linktype_combo_box), E_CAP_LT_CBX_LABEL_KEY);
+  GList             *lt_entry;
+  gchar             *if_string          = "";
+  gboolean           monitor_mode;
+  if_capabilities_t *caps               = NULL;
+  gint               linktype_count     = 0, i;
+  data_link_info_t  *data_link_info;
+  interface_t        device;
+  link_row          *link;
+  GtkWidget         *linktype_combo_box = (GtkWidget *) g_object_get_data(G_OBJECT(opt_edit_w), E_CAP_LT_CBX_KEY);
+  GtkWidget         *linktype_lb        = (GtkWidget *)g_object_get_data(G_OBJECT(linktype_combo_box), E_CAP_LT_CBX_LABEL_KEY);
 
   device = g_array_index(global_capture_opts.all_ifaces, interface_t, marked_interface);
   global_capture_opts.all_ifaces = g_array_remove_index(global_capture_opts.all_ifaces, marked_interface);
@@ -5696,8 +5701,8 @@ capture_prep_adjust_sensitivity(GtkWidget *tb _U_, gpointer parent_w)
     /* Ring buffer mode enabled. */
 
     /* Force at least one of the "file switch" conditions (we need at least one) */
-    if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(ring_filesize_cb)) == FALSE &&
-        gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(file_duration_cb)) == FALSE) {
+      if ((gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(ring_filesize_cb)) == FALSE) &&
+          (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(file_duration_cb)) == FALSE)) {
       if (tb == ring_filesize_cb)
         gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(file_duration_cb), TRUE);
       else
diff --git a/ui/gtk/capture_if_dlg.c b/ui/gtk/capture_if_dlg.c
index e22b54ae64..7f92c5f3b3 100644
--- a/ui/gtk/capture_if_dlg.c
+++ b/ui/gtk/capture_if_dlg.c
@@ -98,36 +98,36 @@
  * already a "Capture Interfaces" window up, we just pop up the existing
  * one, rather than creating a new one.
  */
-static GtkWidget *cap_if_w;
+static GtkWidget       *cap_if_w;
 
-static guint     timer_id;
+static guint            timer_id;
 
-static GtkWidget *close_bt, *stop_bt, *capture_bt, *options_bt;
+static GtkWidget       *close_bt, *stop_bt, *capture_bt, *options_bt;
 
-static GArray    *if_array;
+static GArray          *if_array;
 
-static if_stat_cache_t   *sc;
-static GtkWidget *cap_if_top_vb, *cap_if_sw;
+static if_stat_cache_t *sc;
+static GtkWidget       *cap_if_top_vb, *cap_if_sw;
 
 /*
  * Timeout, in milliseconds, for reads from the stream of captured packets.
  */
-#define	CAP_READ_TIMEOUT	250
+#define CAP_READ_TIMEOUT 250
 
 
 /* the "runtime" data of one interface */
 typedef struct if_dlg_data_s {
-    gchar       *device;
-    GtkWidget   *device_lb;
-    GtkWidget   *descr_lb;
-    GtkWidget   *ip_lb;
-    GtkWidget   *curr_lb;
-    GtkWidget   *last_lb;
-    GtkWidget   *choose_bt;
+    gchar     *device;
+    GtkWidget *device_lb;
+    GtkWidget *descr_lb;
+    GtkWidget *ip_lb;
+    GtkWidget *curr_lb;
+    GtkWidget *last_lb;
+    GtkWidget *choose_bt;
 #ifdef _WIN32
-    GtkWidget   *details_bt;
+    GtkWidget *details_bt;
 #endif
-    gboolean    hidden;
+    gboolean   hidden;
 } if_dlg_data_t;
 
 static gboolean gbl_capture_in_progress = FALSE;
@@ -138,7 +138,7 @@ add_interface(void)
 {
   if_dlg_data_t data;
 
-  data.device_lb = NULL;
+  data.device_lb  = NULL;
   data.descr_lb   = NULL;
   data.ip_lb      = NULL;
   data.curr_lb    = NULL;
@@ -156,8 +156,8 @@ add_interface(void)
 void
 update_selected_interface(gchar *name)
 {
-  guint i;
-  interface_t device;
+  guint         i;
+  interface_t   device;
   if_dlg_data_t data;
 
   for (i = 0; i < global_capture_opts.all_ifaces->len; i++) {
@@ -174,7 +174,7 @@ static void
 store_selected(GtkWidget *choose_bt, gpointer name)
 {
   interface_t device;
-  guint i;
+  guint       i;
 
   for (i = 0; i < global_capture_opts.all_ifaces->len; i++) {
     device = g_array_index(global_capture_opts.all_ifaces, interface_t, i);
@@ -208,10 +208,10 @@ store_selected(GtkWidget *choose_bt, gpointer name)
 
 /* start capture button was pressed */
 static void
-capture_do_cb(GtkWidget *capture_bt _U_, gpointer if_data _U_)
+capture_do_cb(GtkWidget *capture_bt_arg _U_, gpointer if_data _U_)
 {
   if_dlg_data_t data;
-  guint ifs;
+  guint         ifs;
 
   for (ifs = 0; ifs < if_array->len; ifs++) {
     data = g_array_index(if_array, if_dlg_data_t, ifs);
@@ -267,14 +267,14 @@ capture_details_cb(GtkWidget *details_bt _U_, gpointer name)
 
 /* update a single interface */
 static void
-update_if(gchar *name, if_stat_cache_t *sc)
+update_if(gchar *name, if_stat_cache_t *sc_p)
 {
-  struct pcap_stat stats;
-  gchar *str;
-  guint diff, ifs, data_ifs;
-  interface_t  device;
-  if_dlg_data_t data;
-  gboolean  found = FALSE;
+  struct pcap_stat  stats;
+  gchar            *str;
+  guint             diff, ifs, data_ifs;
+  interface_t       device;
+  if_dlg_data_t     data;
+  gboolean          found = FALSE;
 
 
   /*
@@ -288,7 +288,7 @@ update_if(gchar *name, if_stat_cache_t *sc)
   device.last_packets = 0;
   data.curr_lb = NULL;
   data.last_lb = NULL;
-  if (sc) {
+  if (sc_p) {
     for (ifs = 0, data_ifs = 0; ifs < global_capture_opts.all_ifaces->len; ifs++) {
       device = g_array_index(global_capture_opts.all_ifaces, interface_t, ifs);
       if (device.type != IF_PIPE) {
@@ -300,7 +300,7 @@ update_if(gchar *name, if_stat_cache_t *sc)
       }
     }
     if (found) {
-      if (capture_stats(sc, name, &stats)) {
+      if (capture_stats(sc_p, name, &stats)) {
         if ((int)(stats.ps_recv - device.last_packets) < 0) {
           diff = 0;
         } else {
@@ -333,9 +333,9 @@ update_if(gchar *name, if_stat_cache_t *sc)
 static gboolean
 update_all(gpointer data)
 {
-  interface_t device;
-  guint ifs;
-  if_stat_cache_t *sc = data;
+  interface_t      device;
+  guint            ifs;
+  if_stat_cache_t *sc_p = data;
 
   if (!cap_if_w) {
     return FALSE;
@@ -343,7 +343,7 @@ update_all(gpointer data)
 
   for (ifs = 0; ifs < global_capture_opts.all_ifaces->len; ifs++) {
     device = g_array_index(global_capture_opts.all_ifaces, interface_t, ifs);
-    update_if(device.name, sc);
+    update_if(device.name, sc_p);
   }
 
   return TRUE;
@@ -432,9 +432,9 @@ GtkWidget * capture_get_if_icon(interface_t *device)
 static int
 get_ip_addr_count(GSList *addr_list)
 {
-  GSList *curr_addr;
+  GSList    *curr_addr;
   if_addr_t *addr;
-  int count;
+  int        count;
 
   count = 0;
   for (curr_addr = addr_list; curr_addr != NULL;
@@ -458,8 +458,8 @@ get_ip_addr_count(GSList *addr_list)
 static const gchar *
 set_ip_addr_label(GSList *addr_list, GtkWidget *ip_lb, guint selected_ip_addr)
 {
-  GSList *curr_addr;
-  if_addr_t *addr;
+  GSList      *curr_addr;
+  if_addr_t   *addr;
   const gchar *addr_str = NULL;
 
   curr_addr = g_slist_nth(addr_list, selected_ip_addr);
@@ -513,11 +513,11 @@ ip_label_leave_cb(GtkWidget *eb, GdkEvent *event _U_, gpointer user_data _U_)
 static gboolean
 ip_label_press_cb(GtkWidget *widget, GdkEvent *event _U_, gpointer data)
 {
-  GtkWidget *ip_lb = (GtkWidget *)g_object_get_data(G_OBJECT(widget), CAPTURE_IF_IP_ADDR_LABEL);
-  GSList *addr_list = (GSList *)data;
-  GSList *curr_addr, *start_addr;
+  GtkWidget *ip_lb            = (GtkWidget *)g_object_get_data(G_OBJECT(widget), CAPTURE_IF_IP_ADDR_LABEL);
+  GSList    *addr_list        = (GSList *)data;
+  GSList    *curr_addr, *start_addr;
   if_addr_t *addr;
-  guint selected_ip_addr = GPOINTER_TO_UINT(g_object_get_data(G_OBJECT(ip_lb), CAPTURE_IF_SELECTED_IP_ADDR));
+  guint      selected_ip_addr = GPOINTER_TO_UINT(g_object_get_data(G_OBJECT(ip_lb), CAPTURE_IF_SELECTED_IP_ADDR));
 
   /* Select next IP address */
   start_addr = g_slist_nth(addr_list, selected_ip_addr);
@@ -555,7 +555,7 @@ found:
 static void
 capture_if_stop_cb(GtkWidget *w _U_, gpointer d _U_)
 {
-  guint ifs;
+  guint         ifs;
   if_dlg_data_t data;
 
   for (ifs = 0; ifs < if_array->len; ifs++) {
@@ -629,15 +629,15 @@ can_capture(void)
 static void
 capture_if_refresh_if_list(void)
 {
-  GtkWidget         *if_vb, *if_tb, *icon, *if_lb, *eb;
-  GString           *if_tool_str = g_string_new("");
-  GtkRequisition    requisition;
-  int               row = 0, height = 0, curr_height, curr_width;
-  guint             ifs;
-  interface_t       device;
-  const gchar       *addr_str;
-  gchar             *user_descr;
-  if_dlg_data_t     data;
+  GtkWidget      *if_vb, *if_tb, *icon, *if_lb, *eb;
+  GString        *if_tool_str = g_string_new("");
+  GtkRequisition  requisition;
+  int             row = 0, height = 0, curr_height, curr_width;
+  guint           ifs;
+  interface_t     device;
+  const gchar    *addr_str;
+  gchar          *user_descr;
+  if_dlg_data_t   data;
 
   if (!can_capture()) {
     /* No interfaces or, on Windows, no WinPcap; we've already popped
@@ -686,7 +686,7 @@ capture_if_refresh_if_list(void)
   gtk_table_attach_defaults(GTK_TABLE(if_tb), if_lb, 5, 6, row, row+1);
 
   if_lb = gtk_label_new("Packets");
-  gtk_table_attach_defaults(GTK_TABLE(if_tb), if_lb, 6, 7, row, row+1);                            
+  gtk_table_attach_defaults(GTK_TABLE(if_tb), if_lb, 6, 7, row, row+1);
 
   if_lb = gtk_label_new(" Packets/s ");
   gtk_table_attach_defaults(GTK_TABLE(if_tb), if_lb, 7, 8, row, row+1);
@@ -807,12 +807,12 @@ capture_if_refresh_if_list(void)
     row++;
     if (row <= 20) {
         /* Lets add up 20 rows of interfaces, otherwise the window may become too high */
-#ifdef _WIN32        
+#ifdef _WIN32
       gtk_widget_get_preferred_size(GTK_WIDGET(data.details_bt), &requisition, NULL);
 #else
       gtk_widget_get_preferred_size(GTK_WIDGET(data.choose_bt), &requisition, NULL);
-#endif      
-      height += requisition.height;        
+#endif
+      height += requisition.height;
     }
   }
 
@@ -825,8 +825,8 @@ capture_if_refresh_if_list(void)
 #ifndef _WIN32
     if (curr_height < height)
         /* On windows, resetting the size regardless works around what appears to be a windows gtk bug
-         * with multiple nic's where the resulting dialog box is much smaller than it should be. 
-         * note: the actual height calculation is not correct on Windows with varying 
+         * with multiple nic's where the resulting dialog box is much smaller than it should be.
+         * note: the actual height calculation is not correct on Windows with varying
          * number of interfaces but fine at this point in time. */
 #endif
        gtk_window_resize(GTK_WINDOW(cap_if_w), curr_width, height);
@@ -845,10 +845,10 @@ capture_if_refresh_if_list(void)
 void
 capture_if_cb(GtkWidget *w _U_, gpointer d _U_)
 {
-  GtkWidget         *bbox,
-                    *help_bt;
+  GtkWidget *bbox,
+            *help_bt;
 #ifdef HAVE_AIRPCAP
-  GtkWidget         *decryption_cb;
+  GtkWidget *decryption_cb;
 #endif
 
   if (cap_if_w != NULL) {
@@ -934,7 +934,7 @@ void refresh_if_window(void)
 
 void select_all_interfaces(gboolean enable _U_)
 {
-  guint ifs;
+  guint       ifs;
   interface_t device;
 
   for (ifs = 0; ifs < global_capture_opts.all_ifaces->len; ifs++) {
@@ -957,3 +957,16 @@ set_capture_if_dialog_for_capture_in_progress(gboolean capture_in_progress _U_)
 }
 
 #endif /* HAVE_LIBPCAP */
+
+/*
+ * Editor modelines
+ *
+ * Local Variables:
+ * c-basic-offset: 2
+ * tab-width: 8
+ * indent-tabs-mode: nil
+ * End:
+ *
+ * ex: set shiftwidth=2 tabstop=8 expandtab:
+ * :indentSize=2:tabSize=8:noTabs=true:
+ */

