commit 12ef7d448613ead2babd41c3ebfa1fe03c20edef
Author: Steven Rostedt <rostedt@goodmis.org>
Date:   Wed Nov 12 17:52:38 2008 -0500

    ftrace: CPU buffer start annotation clean ups
    
    Impact: better handling of CPU buffer start annotation
    
    Because of the confusion with the per CPU buffers wrapping where
    one CPU might be more active at the end of the trace than the other
    CPUs causing that one CPU to have a shorter history. Kernel
    developers were confused by the "missing" data of that one CPU
    at the beginning of the trace output. An annotation was added to
    the trace output to show that the buffer had started:
    
     # tracer: function
     #
     #           TASK-PID    CPU#    TIMESTAMP  FUNCTION
     #              | |       |          |         |
     ##### CPU 3 buffer started ####
              <idle>-0     [003]   158.192959: smp_apic_timer_interrupt
     [...]
               <idle>-0     [003]   161.556520: default_idle
     ##### CPU 1 buffer started ####
               <idle>-0     [001]   161.592494: hrtimer_force_reprogram
     [etc]
    
    But this annotation gets a bit messy when tracers do not fill the
    buffers. This patch does a couple of things:
    
     One) it adds a flag to trace_options to disable these annotations
    
     Two) it does not annotate if the tracer did not overflow its buffer.
    
    This makes the output much cleaner.
    
    Signed-off-by: Steven Rostedt <srostedt@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index 240423a9d1af..4a904623e05d 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -205,7 +205,8 @@ static DEFINE_MUTEX(trace_types_lock);
 static DECLARE_WAIT_QUEUE_HEAD(trace_wait);
 
 /* trace_flags holds trace_options default values */
-unsigned long trace_flags = TRACE_ITER_PRINT_PARENT | TRACE_ITER_PRINTK;
+unsigned long trace_flags = TRACE_ITER_PRINT_PARENT | TRACE_ITER_PRINTK |
+	TRACE_ITER_ANNOTATE;
 
 /**
  * trace_wake_up - wake up tasks waiting for trace input
@@ -261,6 +262,7 @@ static const char *trace_options[] = {
 #ifdef CONFIG_BRANCH_TRACER
 	"branch",
 #endif
+	"annotate",
 	NULL
 };
 
@@ -1113,6 +1115,7 @@ void tracing_stop_function_trace(void)
 
 enum trace_file_type {
 	TRACE_FILE_LAT_FMT	= 1,
+	TRACE_FILE_ANNOTATE	= 2,
 };
 
 static void trace_iterator_increment(struct trace_iterator *iter, int cpu)
@@ -1532,6 +1535,12 @@ static void test_cpu_buff_start(struct trace_iterator *iter)
 {
 	struct trace_seq *s = &iter->seq;
 
+	if (!(trace_flags & TRACE_ITER_ANNOTATE))
+		return;
+
+	if (!(iter->iter_flags & TRACE_FILE_ANNOTATE))
+		return;
+
 	if (cpu_isset(iter->cpu, iter->started))
 		return;
 
@@ -2132,6 +2141,11 @@ __tracing_open(struct inode *inode, struct file *file, int *ret)
 	iter->trace = current_trace;
 	iter->pos = -1;
 
+	/* Annotate start of buffers if we had overruns */
+	if (ring_buffer_overruns(iter->tr->buffer))
+		iter->iter_flags |= TRACE_FILE_ANNOTATE;
+
+
 	for_each_tracing_cpu(cpu) {
 
 		iter->buffer_iter[cpu] =
diff --git a/kernel/trace/trace.h b/kernel/trace/trace.h
index 9e015f5bea1d..790ea8c0e1f3 100644
--- a/kernel/trace/trace.h
+++ b/kernel/trace/trace.h
@@ -473,6 +473,7 @@ enum trace_iterator_flags {
 #ifdef CONFIG_BRANCH_TRACER
 	TRACE_ITER_BRANCH		= 0x1000,
 #endif
+	TRACE_ITER_ANNOTATE		= 0x2000,
 };
 
 /*

