commit f3830d92941d2a99561fedf096d1b97d24159dba
Author: damien <damien@openbsd.org>
Date:   Sat Jun 10 20:28:11 2006 +0000

    - fix checking of WEP flag
    - move default MAC/BBP/RF settings from if_ral.c to if_ralreg.h

diff --git a/sys/dev/usb/if_ral.c b/sys/dev/usb/if_ral.c
index ddb7f385887..416596e4418 100644
--- a/sys/dev/usb/if_ral.c
+++ b/sys/dev/usb/if_ral.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: if_ral.c,v 1.67 2006/03/25 22:41:47 djm Exp $  */
+/*	$OpenBSD: if_ral.c,v 1.68 2006/06/10 20:28:11 damien Exp $  */
 
 /*-
  * Copyright (c) 2005, 2006
@@ -186,166 +186,34 @@ static const struct ieee80211_rateset ural_rateset_11b =
 static const struct ieee80211_rateset ural_rateset_11g =
 	{ 12, { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 } };
 
-/*
- * Default values for MAC registers; values taken from the reference driver.
- */
 static const struct {
 	uint16_t	reg;
 	uint16_t	val;
 } ural_def_mac[] = {
-	{ RAL_TXRX_CSR5,  0x8c8d },
-	{ RAL_TXRX_CSR6,  0x8b8a },
-	{ RAL_TXRX_CSR7,  0x8687 },
-	{ RAL_TXRX_CSR8,  0x0085 },
-	{ RAL_MAC_CSR13,  0x1111 },
-	{ RAL_MAC_CSR14,  0x1e11 },
-	{ RAL_TXRX_CSR21, 0xe78f },
-	{ RAL_MAC_CSR9,   0xff1d },
-	{ RAL_MAC_CSR11,  0x0002 },
-	{ RAL_MAC_CSR22,  0x0053 },
-	{ RAL_MAC_CSR15,  0x0000 },
-	{ RAL_MAC_CSR8,   0x0780 },
-	{ RAL_TXRX_CSR19, 0x0000 },
-	{ RAL_TXRX_CSR18, 0x005a },
-	{ RAL_PHY_CSR2,   0x0000 },
-	{ RAL_TXRX_CSR0,  0x1ec0 },
-	{ RAL_PHY_CSR4,   0x000f }
+	RAL_DEF_MAC
 };
 
-/*
- * Default values for BBP registers; values taken from the reference driver.
- */
 static const struct {
 	uint8_t	reg;
 	uint8_t	val;
 } ural_def_bbp[] = {
-	{  3, 0x02 },
-	{  4, 0x19 },
-	{ 14, 0x1c },
-	{ 15, 0x30 },
-	{ 16, 0xac },
-	{ 17, 0x48 },
-	{ 18, 0x18 },
-	{ 19, 0xff },
-	{ 20, 0x1e },
-	{ 21, 0x08 },
-	{ 22, 0x08 },
-	{ 23, 0x08 },
-	{ 24, 0x80 },
-	{ 25, 0x50 },
-	{ 26, 0x08 },
-	{ 27, 0x23 },
-	{ 30, 0x10 },
-	{ 31, 0x2b },
-	{ 32, 0xb9 },
-	{ 34, 0x12 },
-	{ 35, 0x50 },
-	{ 39, 0xc4 },
-	{ 40, 0x02 },
-	{ 41, 0x60 },
-	{ 53, 0x10 },
-	{ 54, 0x18 },
-	{ 56, 0x08 },
-	{ 57, 0x10 },
-	{ 58, 0x08 },
-	{ 61, 0x60 },
-	{ 62, 0x10 },
-	{ 75, 0xff }
-};
-
-/*
- * Default values for RF register R2 indexed by channel numbers.
- */
-static const uint32_t ural_rf2522_r2[] = {
-	0x307f6, 0x307fb, 0x30800, 0x30805, 0x3080a, 0x3080f, 0x30814,
-	0x30819, 0x3081e, 0x30823, 0x30828, 0x3082d, 0x30832, 0x3083e
-};
-
-static const uint32_t ural_rf2523_r2[] = {
-	0x00327, 0x00328, 0x00329, 0x0032a, 0x0032b, 0x0032c, 0x0032d,
-	0x0032e, 0x0032f, 0x00340, 0x00341, 0x00342, 0x00343, 0x00346
-};
-
-static const uint32_t ural_rf2524_r2[] = {
-	0x00327, 0x00328, 0x00329, 0x0032a, 0x0032b, 0x0032c, 0x0032d,
-	0x0032e, 0x0032f, 0x00340, 0x00341, 0x00342, 0x00343, 0x00346
-};
-
-static const uint32_t ural_rf2525_r2[] = {
-	0x20327, 0x20328, 0x20329, 0x2032a, 0x2032b, 0x2032c, 0x2032d,
-	0x2032e, 0x2032f, 0x20340, 0x20341, 0x20342, 0x20343, 0x20346
+	RAL_DEF_BBP
 };
 
-static const uint32_t ural_rf2525_hi_r2[] = {
-	0x2032f, 0x20340, 0x20341, 0x20342, 0x20343, 0x20344, 0x20345,
-	0x20346, 0x20347, 0x20348, 0x20349, 0x2034a, 0x2034b, 0x2034e
-};
-
-static const uint32_t ural_rf2525e_r2[] = {
-	0x2044d, 0x2044e, 0x2044f, 0x20460, 0x20461, 0x20462, 0x20463,
-	0x20464, 0x20465, 0x20466, 0x20467, 0x20468, 0x20469, 0x2046b
-};
-
-static const uint32_t ural_rf2526_hi_r2[] = {
-	0x0022a, 0x0022b, 0x0022b, 0x0022c, 0x0022c, 0x0022d, 0x0022d,
-	0x0022e, 0x0022e, 0x0022f, 0x0022d, 0x00240, 0x00240, 0x00241
-};
-
-static const uint32_t ural_rf2526_r2[] = {
-	0x00226, 0x00227, 0x00227, 0x00228, 0x00228, 0x00229, 0x00229,
-	0x0022a, 0x0022a, 0x0022b, 0x0022b, 0x0022c, 0x0022c, 0x0022d
-};
+static const uint32_t ural_rf2522_r2[] =    RAL_RF2522_R2;
+static const uint32_t ural_rf2523_r2[] =    RAL_RF2523_R2;
+static const uint32_t ural_rf2524_r2[] =    RAL_RF2524_R2;
+static const uint32_t ural_rf2525_r2[] =    RAL_RF2525_R2;
+static const uint32_t ural_rf2525_hi_r2[] = RAL_RF2525_HI_R2;
+static const uint32_t ural_rf2525e_r2[] =   RAL_RF2525E_R2;
+static const uint32_t ural_rf2526_hi_r2[] = RAL_RF2526_HI_R2;
+static const uint32_t ural_rf2526_r2[] =    RAL_RF2526_R2;
 
-/*
- * For dual-band RF, RF registers R1 and R4 also depend on channel number;
- * values taken from the reference driver.
- */
 static const struct {
 	uint8_t		chan;
-	uint32_t	r1;
-	uint32_t	r2;
-	uint32_t	r4;
+	uint32_t	r1, r2, r4;
 } ural_rf5222[] = {
-	{   1, 0x08808, 0x0044d, 0x00282 },
-	{   2, 0x08808, 0x0044e, 0x00282 },
-	{   3, 0x08808, 0x0044f, 0x00282 },
-	{   4, 0x08808, 0x00460, 0x00282 },
-	{   5, 0x08808, 0x00461, 0x00282 },
-	{   6, 0x08808, 0x00462, 0x00282 },
-	{   7, 0x08808, 0x00463, 0x00282 },
-	{   8, 0x08808, 0x00464, 0x00282 },
-	{   9, 0x08808, 0x00465, 0x00282 },
-	{  10, 0x08808, 0x00466, 0x00282 },
-	{  11, 0x08808, 0x00467, 0x00282 },
-	{  12, 0x08808, 0x00468, 0x00282 },
-	{  13, 0x08808, 0x00469, 0x00282 },
-	{  14, 0x08808, 0x0046b, 0x00286 },
-
-	{  36, 0x08804, 0x06225, 0x00287 },
-	{  40, 0x08804, 0x06226, 0x00287 },
-	{  44, 0x08804, 0x06227, 0x00287 },
-	{  48, 0x08804, 0x06228, 0x00287 },
-	{  52, 0x08804, 0x06229, 0x00287 },
-	{  56, 0x08804, 0x0622a, 0x00287 },
-	{  60, 0x08804, 0x0622b, 0x00287 },
-	{  64, 0x08804, 0x0622c, 0x00287 },
-
-	{ 100, 0x08804, 0x02200, 0x00283 },
-	{ 104, 0x08804, 0x02201, 0x00283 },
-	{ 108, 0x08804, 0x02202, 0x00283 },
-	{ 112, 0x08804, 0x02203, 0x00283 },
-	{ 116, 0x08804, 0x02204, 0x00283 },
-	{ 120, 0x08804, 0x02205, 0x00283 },
-	{ 124, 0x08804, 0x02206, 0x00283 },
-	{ 128, 0x08804, 0x02207, 0x00283 },
-	{ 132, 0x08804, 0x02208, 0x00283 },
-	{ 136, 0x08804, 0x02209, 0x00283 },
-	{ 140, 0x08804, 0x0220a, 0x00283 },
-
-	{ 149, 0x08808, 0x02429, 0x00281 },
-	{ 153, 0x08808, 0x0242b, 0x00281 },
-	{ 157, 0x08808, 0x0242d, 0x00281 },
-	{ 161, 0x08808, 0x0242f, 0x00281 }
+	RAL_RF5222
 };
 
 USB_DECLARE_DRIVER_CLASS(ural, DV_IFNET);
@@ -1319,10 +1187,15 @@ ural_tx_data(struct ural_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)
 	}
 	rate &= IEEE80211_RATE_VAL;
 
-	if (ic->ic_flags & IEEE80211_F_WEPON) {
+	wh = mtod(m0, struct ieee80211_frame *);
+
+	if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
 		m0 = ieee80211_wep_crypt(ifp, m0, 1);
 		if (m0 == NULL)
 			return ENOBUFS;
+
+		/* packet header may have moved, reset our local pointer */
+		wh = mtod(m0, struct ieee80211_frame *);
 	}
 
 	data = &sc->tx_data[0];
@@ -1331,8 +1204,6 @@ ural_tx_data(struct ural_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)
 	data->m = m0;
 	data->ni = ni;
 
-	wh = mtod(m0, struct ieee80211_frame *);
-
 	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
 		flags |= RAL_TX_ACK;
 		flags |= RAL_TX_RETRY(7);
diff --git a/sys/dev/usb/if_ralreg.h b/sys/dev/usb/if_ralreg.h
index 6ae5fbc3d4b..ad464e8f85b 100644
--- a/sys/dev/usb/if_ralreg.h
+++ b/sys/dev/usb/if_ralreg.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: if_ralreg.h,v 1.9 2006/03/21 11:19:22 pedro Exp $  */
+/*	$OpenBSD: if_ralreg.h,v 1.10 2006/06/10 20:28:11 damien Exp $  */
 
 /*-
  * Copyright (c) 2005, 2006
@@ -205,3 +205,159 @@ struct ural_rx_desc {
 #define RAL_EEPROM_TXPOWER	0x003c
 #define RAL_EEPROM_CONFIG0	0x0016
 #define RAL_EEPROM_BBP_BASE	0x001c
+
+/*
+ * Default values for MAC registers; values taken from the reference driver.
+ */
+#define RAL_DEF_MAC			\
+	{ RAL_TXRX_CSR5,  0x8c8d },	\
+	{ RAL_TXRX_CSR6,  0x8b8a },	\
+	{ RAL_TXRX_CSR7,  0x8687 },	\
+	{ RAL_TXRX_CSR8,  0x0085 },	\
+	{ RAL_MAC_CSR13,  0x1111 },	\
+	{ RAL_MAC_CSR14,  0x1e11 },	\
+	{ RAL_TXRX_CSR21, 0xe78f },	\
+	{ RAL_MAC_CSR9,   0xff1d },	\
+	{ RAL_MAC_CSR11,  0x0002 },	\
+	{ RAL_MAC_CSR22,  0x0053 },	\
+	{ RAL_MAC_CSR15,  0x0000 },	\
+	{ RAL_MAC_CSR8,   0x0780 },	\
+	{ RAL_TXRX_CSR19, 0x0000 },	\
+	{ RAL_TXRX_CSR18, 0x005a },	\
+	{ RAL_PHY_CSR2,   0x0000 },	\
+	{ RAL_TXRX_CSR0,  0x1ec0 },	\
+	{ RAL_PHY_CSR4,   0x000f }
+
+/*
+ * Default values for BBP registers; values taken from the reference driver.
+ */
+#define RAL_DEF_BBP	\
+	{  3, 0x02 },	\
+	{  4, 0x19 },	\
+	{ 14, 0x1c },	\
+	{ 15, 0x30 },	\
+	{ 16, 0xac },	\
+	{ 17, 0x48 },	\
+	{ 18, 0x18 },	\
+	{ 19, 0xff },	\
+	{ 20, 0x1e },	\
+	{ 21, 0x08 },	\
+	{ 22, 0x08 },	\
+	{ 23, 0x08 },	\
+	{ 24, 0x80 },	\
+	{ 25, 0x50 },	\
+	{ 26, 0x08 },	\
+	{ 27, 0x23 },	\
+	{ 30, 0x10 },	\
+	{ 31, 0x2b },	\
+	{ 32, 0xb9 },	\
+	{ 34, 0x12 },	\
+	{ 35, 0x50 },	\
+	{ 39, 0xc4 },	\
+	{ 40, 0x02 },	\
+	{ 41, 0x60 },	\
+	{ 53, 0x10 },	\
+	{ 54, 0x18 },	\
+	{ 56, 0x08 },	\
+	{ 57, 0x10 },	\
+	{ 58, 0x08 },	\
+	{ 61, 0x60 },	\
+	{ 62, 0x10 },	\
+	{ 75, 0xff }
+
+/*
+ * Default values for RF register R2 indexed by channel numbers.
+ */
+#define RAL_RF2522_R2							\
+{									\
+	0x307f6, 0x307fb, 0x30800, 0x30805, 0x3080a, 0x3080f, 0x30814,	\
+	0x30819, 0x3081e, 0x30823, 0x30828, 0x3082d, 0x30832, 0x3083e	\
+}
+
+#define RAL_RF2523_R2							\
+{									\
+	0x00327, 0x00328, 0x00329, 0x0032a, 0x0032b, 0x0032c, 0x0032d,	\
+	0x0032e, 0x0032f, 0x00340, 0x00341, 0x00342, 0x00343, 0x00346	\
+}
+
+#define RAL_RF2524_R2							\
+{									\
+	0x00327, 0x00328, 0x00329, 0x0032a, 0x0032b, 0x0032c, 0x0032d,	\
+	0x0032e, 0x0032f, 0x00340, 0x00341, 0x00342, 0x00343, 0x00346	\
+}
+
+#define RAL_RF2525_R2							\
+{									\
+	0x20327, 0x20328, 0x20329, 0x2032a, 0x2032b, 0x2032c, 0x2032d,	\
+	0x2032e, 0x2032f, 0x20340, 0x20341, 0x20342, 0x20343, 0x20346	\
+}
+
+#define RAL_RF2525_HI_R2						\
+{									\
+	0x2032f, 0x20340, 0x20341, 0x20342, 0x20343, 0x20344, 0x20345,	\
+	0x20346, 0x20347, 0x20348, 0x20349, 0x2034a, 0x2034b, 0x2034e	\
+}
+
+#define RAL_RF2525E_R2							\
+{									\
+	0x2044d, 0x2044e, 0x2044f, 0x20460, 0x20461, 0x20462, 0x20463,	\
+	0x20464, 0x20465, 0x20466, 0x20467, 0x20468, 0x20469, 0x2046b	\
+}
+
+#define RAL_RF2526_HI_R2						\
+{									\
+	0x0022a, 0x0022b, 0x0022b, 0x0022c, 0x0022c, 0x0022d, 0x0022d,	\
+	0x0022e, 0x0022e, 0x0022f, 0x0022d, 0x00240, 0x00240, 0x00241	\
+}
+
+#define RAL_RF2526_R2							\
+{									\
+	0x00226, 0x00227, 0x00227, 0x00228, 0x00228, 0x00229, 0x00229,	\
+	0x0022a, 0x0022a, 0x0022b, 0x0022b, 0x0022c, 0x0022c, 0x0022d	\
+}
+
+/*
+ * For dual-band RF, RF registers R1 and R4 also depend on channel number;
+ * values taken from the reference driver.
+ */
+#define RAL_RF5222				\
+	{   1, 0x08808, 0x0044d, 0x00282 },	\
+	{   2, 0x08808, 0x0044e, 0x00282 },	\
+	{   3, 0x08808, 0x0044f, 0x00282 },	\
+	{   4, 0x08808, 0x00460, 0x00282 },	\
+	{   5, 0x08808, 0x00461, 0x00282 },	\
+	{   6, 0x08808, 0x00462, 0x00282 },	\
+	{   7, 0x08808, 0x00463, 0x00282 },	\
+	{   8, 0x08808, 0x00464, 0x00282 },	\
+	{   9, 0x08808, 0x00465, 0x00282 },	\
+	{  10, 0x08808, 0x00466, 0x00282 },	\
+	{  11, 0x08808, 0x00467, 0x00282 },	\
+	{  12, 0x08808, 0x00468, 0x00282 },	\
+	{  13, 0x08808, 0x00469, 0x00282 },	\
+	{  14, 0x08808, 0x0046b, 0x00286 },	\
+						\
+	{  36, 0x08804, 0x06225, 0x00287 },	\
+	{  40, 0x08804, 0x06226, 0x00287 },	\
+	{  44, 0x08804, 0x06227, 0x00287 },	\
+	{  48, 0x08804, 0x06228, 0x00287 },	\
+	{  52, 0x08804, 0x06229, 0x00287 },	\
+	{  56, 0x08804, 0x0622a, 0x00287 },	\
+	{  60, 0x08804, 0x0622b, 0x00287 },	\
+	{  64, 0x08804, 0x0622c, 0x00287 },	\
+						\
+	{ 100, 0x08804, 0x02200, 0x00283 },	\
+	{ 104, 0x08804, 0x02201, 0x00283 },	\
+	{ 108, 0x08804, 0x02202, 0x00283 },	\
+	{ 112, 0x08804, 0x02203, 0x00283 },	\
+	{ 116, 0x08804, 0x02204, 0x00283 },	\
+	{ 120, 0x08804, 0x02205, 0x00283 },	\
+	{ 124, 0x08804, 0x02206, 0x00283 },	\
+	{ 128, 0x08804, 0x02207, 0x00283 },	\
+	{ 132, 0x08804, 0x02208, 0x00283 },	\
+	{ 136, 0x08804, 0x02209, 0x00283 },	\
+	{ 140, 0x08804, 0x0220a, 0x00283 },	\
+						\
+	{ 149, 0x08808, 0x02429, 0x00281 },	\
+	{ 153, 0x08808, 0x0242b, 0x00281 },	\
+	{ 157, 0x08808, 0x0242d, 0x00281 },	\
+	{ 161, 0x08808, 0x0242f, 0x00281 }

