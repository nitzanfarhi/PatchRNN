commit 4beb0dc6a3d6fdbcac1b2b17e08162c4eab9d9f4
Author: pancake <pancake@nopcode.org>
Date:   Tue Aug 11 14:15:13 2015 +0200

    Add support for 'mov byte [reg], imm' for x86.nz

diff --git a/libr/asm/p/asm_x86_nz.c b/libr/asm/p/asm_x86_nz.c
index 08dff2c90..6865fd8ee 100644
--- a/libr/asm/p/asm_x86_nz.c
+++ b/libr/asm/p/asm_x86_nz.c
@@ -103,15 +103,8 @@ static int isnum(RAsm *a, const char *str) {
 	return str && (*str == '-' || (*str >= '0' && *str <= '9'));
 }
 
-static int assemble(RAsm *a, RAsmOp *ao, const char *str) {
-	ut64 offset = a->pc;
-	ut8 t, *data = ao->buf;
-	char *arg, op[128];
-	int l = 0;
-
-	strncpy (op, str, sizeof (op)-1);
-	op[sizeof (op)-1] = '\0';
-	arg = strstr (op, "dword ptr");
+static int hasDword (char *op) {
+	char *arg = strstr (op, "dword ptr");
 	if (arg) {
 		const int dword_len = strlen ("dword ptr");
 		memmove (arg, arg+dword_len, strlen (arg+dword_len)+1);
@@ -121,6 +114,37 @@ static int assemble(RAsm *a, RAsmOp *ao, const char *str) {
 		const int dword_len = strlen ("dword ");
 		memmove (arg, arg+dword_len, strlen (arg+dword_len)+1);
 	}
+	return 0;
+}
+
+static int hasByte (char *op) {
+	char *arg = strstr (op, "byte ptr");
+	if (arg) {
+		const int dword_len = strlen ("byte ptr");
+		memmove (arg, arg+dword_len, strlen (arg+dword_len)+1);
+		return 1;
+	}
+	arg = strstr (op, "byte ");
+	if (arg) {
+		const int dword_len = strlen ("byte ");
+		memmove (arg, arg+dword_len, strlen (arg+dword_len)+1);
+		return 1;
+	}
+	return 0;
+}
+
+static int assemble(RAsm *a, RAsmOp *ao, const char *str) {
+	int wordsize = 0;
+	ut64 offset = a->pc;
+	ut8 t, *data = ao->buf;
+	char *arg, op[128];
+	int l = 0;
+
+	strncpy (op, str, sizeof (op)-1);
+	op[sizeof (op)-1] = '\0';
+
+	if (hasDword (op)) wordsize = 4;
+	if (hasByte (op)) wordsize = 1;
 
 	if (!memcmp (op, "ret ", 4) || !memcmp (op, "retn ", 5)) {
 		int n = getnum (a, op+4);
@@ -1079,14 +1103,22 @@ SETNP/SETPO - Set if No Parity / Set if Parity Odd (386+)
 				} else {
 					if (argk) {
 						int r = getreg (arg);
-						data[l++] = 0xc7;
-						if (r==4) { //ESP
-							data[l++] = 0x04;
-							data[l++] = 0x24;
-						} else if (r==5) { // EBP
-							data[l++] = 0x75;
-							data[l++] = 0;
-						} else  data[l++] = r;
+						if (wordsize == 1) {
+							// byte ptr
+							data[l++] = 0xc6;
+							data[l++] = r;
+							data[l++] = getnum (a, arg2);
+							return l;
+						} else {
+							data[l++] = 0xc7;
+							if (r==4) { //ESP
+								data[l++] = 0x04;
+								data[l++] = 0x24;
+							} else if (r==5) { // EBP
+								data[l++] = 0x75;
+								data[l++] = 0;
+							} else  data[l++] = r;
+						}
 #define is16reg(x) (x[1]=='l'||x[1]=='h')
 					} else {
 						if (is16reg (arg)) {

