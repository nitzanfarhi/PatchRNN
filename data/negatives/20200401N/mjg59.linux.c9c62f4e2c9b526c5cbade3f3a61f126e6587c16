commit c9c62f4e2c9b526c5cbade3f3a61f126e6587c16
Author: Xenofon Foukas <foukas.xenofon@gmail.com>
Date:   Wed Dec 15 19:44:20 2010 +0200

    Staging: comedi: Fix checkpatch.pl issues in file s526.c
    
    This patch fixes the following issues in s526.c:
    
    WARNING: printk() should include KERN_ facility level
    WARNING: line over 80 characters
    ERROR: do not use C99 // comments
    WARNING: space prohibited between function name and open parenthesis '('
    WARNING: braces {} are not necessary for any arm of this statement
    WARNING: suspect code indent for conditional statements (16, 16)
    
    Signed-off-by: Xenofon Foukas <foukas.xenofon@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/comedi/drivers/s526.c b/drivers/staging/comedi/drivers/s526.c
index 3607aaee4af6..2b34daedc3d7 100644
--- a/drivers/staging/comedi/drivers/s526.c
+++ b/drivers/staging/comedi/drivers/s526.c
@@ -114,7 +114,7 @@ static const int s526_ports[] = {
 };
 
 struct counter_mode_register_t {
-#if defined (__LITTLE_ENDIAN_BITFIELD)
+#if defined(__LITTLE_ENDIAN_BITFIELD)
 	unsigned short coutSource:1;
 	unsigned short coutPolarity:1;
 	unsigned short autoLoadResetRcap:3;
@@ -207,7 +207,9 @@ static const struct s526_board s526_boards[] = {
 
 /* this structure is for data unique to this hardware driver.  If
    several hardware drivers keep similar information in this structure,
-   feel free to suggest moving the variable to the struct comedi_device struct.  */
+   feel free to suggest moving the variable to the struct comedi_device
+   struct.
+*/
 struct s526_private {
 
 	int data;
@@ -304,7 +306,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 /* int subdev_channel = 0; */
 	union cmReg cmReg;
 
-	printk("comedi%d: s526: ", dev->minor);
+	printk(KERN_INFO "comedi%d: s526: ", dev->minor);
 
 	iobase = it->options[0];
 	if (!iobase || !request_region(iobase, S526_IOSIZE, thisboard->name)) {
@@ -317,7 +319,8 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/*** make it a little quieter, exw, 8/29/06
 	for (i = 0; i < S526_NUM_PORTS; i++) {
-		printk("0x%02x: 0x%04x\n", ADDR_REG(s526_ports[i]), inw(ADDR_REG(s526_ports[i])));
+		printk("0x%02x: 0x%04x\n", ADDR_REG(s526_ports[i]),
+				inw(ADDR_REG(s526_ports[i])));
 	}
 	***/
 
@@ -402,7 +405,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s->type = COMEDI_SUBD_UNUSED;
 	}
 
-	printk("attached\n");
+	printk(KERN_INFO "attached\n");
 
 	return 1;
 
@@ -411,7 +414,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	/* One-shot (software trigger) */
 	cmReg.reg.coutSource = 0;	/*  out RCAP */
 	cmReg.reg.coutPolarity = 1;	/*  Polarity inverted */
-	cmReg.reg.autoLoadResetRcap = 1;	/*  Auto load 0:disabled, 1:enabled */
+	cmReg.reg.autoLoadResetRcap = 1;/*  Auto load 0:disabled, 1:enabled */
 	cmReg.reg.hwCtEnableSource = 3;	/*  NOT RCAP */
 	cmReg.reg.ctEnableCtrl = 2;	/*  Hardware */
 	cmReg.reg.clockSource = 2;	/*  Internal */
@@ -426,10 +429,12 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	outw(0x0001, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 	outw(0x3C68, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
-	outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset the counter */
-	outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Load the counter from PR0 */
-
-	outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset RCAP (fires one-shot) */
+	/*  Reset the counter */
+	outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+	/*  Load the counter from PR0 */
+	outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+	/*  Reset RCAP (fires one-shot) */
+	outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 
 #else
 
@@ -447,11 +452,12 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	cmReg.reg.reserved = 0;
 
 	n = 0;
-	printk("Mode reg=0x%04x, 0x%04lx\n", cmReg.value, ADDR_CHAN_REG(REG_C0M,
-									n));
+	printk(KERN_INFO "Mode reg=0x%04x, 0x%04lx\n",
+		cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
 	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
 	udelay(1000);
-	printk("Read back mode reg=0x%04x\n", inw(ADDR_CHAN_REG(REG_C0M, n)));
+	printk(KERN_INFO "Read back mode reg=0x%04x\n",
+		inw(ADDR_CHAN_REG(REG_C0M, n)));
 
 	/*  Load the pre-load register high word */
 /* value = (short) (0x55); */
@@ -466,20 +472,23 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 
 	/*  Reset the counter if it is software preload */
 	if (cmReg.reg.autoLoadResetRcap == 0) {
-		outw(0x8000, ADDR_CHAN_REG(REG_C0C, n));	/*  Reset the counter */
-		outw(0x4000, ADDR_CHAN_REG(REG_C0C, n));	/*  Load the counter from PR0 */
+		/*  Reset the counter */
+		outw(0x8000, ADDR_CHAN_REG(REG_C0C, n));
+		/*  Load the counter from PR0 */
+		outw(0x4000, ADDR_CHAN_REG(REG_C0C, n));
 	}
 
 	outw(cmReg.value, ADDR_CHAN_REG(REG_C0M, n));
 	udelay(1000);
-	printk("Read back mode reg=0x%04x\n", inw(ADDR_CHAN_REG(REG_C0M, n)));
+	printk(KERN_INFO "Read back mode reg=0x%04x\n",
+			inw(ADDR_CHAN_REG(REG_C0M, n)));
 
 #endif
-	printk("Current registres:\n");
+	printk(KERN_INFO "Current registres:\n");
 
 	for (i = 0; i < S526_NUM_PORTS; i++) {
-		printk("0x%02lx: 0x%04x\n", ADDR_REG(s526_ports[i]),
-		       inw(ADDR_REG(s526_ports[i])));
+		printk(KERN_INFO "0x%02lx: 0x%04x\n",
+			ADDR_REG(s526_ports[i]), inw(ADDR_REG(s526_ports[i])));
 	}
 	return 1;
 }
@@ -494,7 +503,7 @@ static int s526_attach(struct comedi_device *dev, struct comedi_devconfig *it)
  */
 static int s526_detach(struct comedi_device *dev)
 {
-	printk("comedi%d: s526: remove\n", dev->minor);
+	printk(KERN_INFO "comedi%d: s526: remove\n", dev->minor);
 
 	if (dev->iobase > 0)
 		release_region(dev->iobase, S526_IOSIZE);
@@ -513,7 +522,7 @@ static int s526_gpct_rinsn(struct comedi_device *dev,
 
 	/*  Check if (n > 0) */
 	if (insn->n <= 0) {
-		printk("s526: INSN_READ: n should be > 0\n");
+		printk(KERN_ERR "s526: INSN_READ: n should be > 0\n");
 		return -EINVAL;
 	}
 	/*  Read the low word first */
@@ -522,7 +531,8 @@ static int s526_gpct_rinsn(struct comedi_device *dev,
 		datahigh = inw(ADDR_CHAN_REG(REG_C0H, counter_channel));
 		data[i] = (int)(datahigh & 0x00FF);
 		data[i] = (data[i] << 16) | (datalow & 0xFFFF);
-/* printk("s526 GPCT[%d]: %x(0x%04x, 0x%04x)\n", counter_channel, data[i], datahigh, datalow); */
+		/* printk("s526 GPCT[%d]: %x(0x%04x, 0x%04x)\n",
+		   counter_channel, data[i], datahigh, datalow); */
 	}
 	return i;
 }
@@ -536,7 +546,8 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 	short value;
 	union cmReg cmReg;
 
-/* printk("s526: GPCT_INSN_CONFIG: Configuring Channel %d\n", subdev_channel); */
+	/* printk("s526: GPCT_INSN_CONFIG: Configuring Channel %d\n",
+						subdev_channel); */
 
 	for (i = 0; i < MAX_GPCT_CONFIG_DATA; i++) {
 		devpriv->s526_gpct_config[subdev_channel].data[i] =
@@ -554,7 +565,7 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		   data[2]: Pre-load Register Value
 		   data[3]: Conter Control Register
 		 */
-		printk("s526: GPCT_INSN_CONFIG: Configuring Encoder\n");
+		printk(KERN_INFO "s526: GPCT_INSN_CONFIG: Configuring Encoder\n");
 		devpriv->s526_gpct_config[subdev_channel].app =
 		    PositionMeasurement;
 
@@ -563,7 +574,7 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		/* One-shot (software trigger) */
 		cmReg.reg.coutSource = 0;	/*  out RCAP */
 		cmReg.reg.coutPolarity = 1;	/*  Polarity inverted */
-		cmReg.reg.autoLoadResetRcap = 0;	/*  Auto load disabled */
+		cmReg.reg.autoLoadResetRcap = 0;/*  Auto load disabled */
 		cmReg.reg.hwCtEnableSource = 3;	/*  NOT RCAP */
 		cmReg.reg.ctEnableCtrl = 2;	/*  Hardware */
 		cmReg.reg.clockSource = 2;	/*  Internal */
@@ -578,10 +589,13 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		outw(0x0001, ADDR_CHAN_REG(REG_C0H, subdev_channel));
 		outw(0x3C68, ADDR_CHAN_REG(REG_C0L, subdev_channel));
 
-		outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset the counter */
-		outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Load the counter from PR0 */
+		/*  Reset the counter */
+		outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+		/*  Load the counter from PR0 */
+		outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 
-		outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset RCAP (fires one-shot) */
+		/*  Reset RCAP (fires one-shot) */
+		outw(0x0008, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 
 #endif
 
@@ -594,30 +608,34 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 
 		/*  Reset the counter if it is software preload */
 		if (cmReg.reg.autoLoadResetRcap == 0) {
-			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset the counter */
-/* outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));    Load the counter from PR0 */
+			/*  Reset the counter */
+			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+			/* Load the counter from PR0
+			 * outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+			 */
 		}
 #else
-		cmReg.reg.countDirCtrl = 0;	/*  0 quadrature, 1 software control */
+		/*  0 quadrature, 1 software control */
+		cmReg.reg.countDirCtrl = 0;
 
 		/*  data[1] contains GPCT_X1, GPCT_X2 or GPCT_X4 */
-		if (insn->data[1] == GPCT_X2) {
+		if (insn->data[1] == GPCT_X2)
 			cmReg.reg.clockSource = 1;
-		} else if (insn->data[1] == GPCT_X4) {
+		else if (insn->data[1] == GPCT_X4)
 			cmReg.reg.clockSource = 2;
-		} else {
+		else
 			cmReg.reg.clockSource = 0;
-		}
 
 		/*  When to take into account the indexpulse: */
-		if (insn->data[2] == GPCT_IndexPhaseLowLow) {
+		/*if (insn->data[2] == GPCT_IndexPhaseLowLow) {
 		} else if (insn->data[2] == GPCT_IndexPhaseLowHigh) {
 		} else if (insn->data[2] == GPCT_IndexPhaseHighLow) {
 		} else if (insn->data[2] == GPCT_IndexPhaseHighHigh) {
-		}
+		}*/
 		/*  Take into account the index pulse? */
 		if (insn->data[3] == GPCT_RESET_COUNTER_ON_INDEX)
-			cmReg.reg.autoLoadResetRcap = 4;	/*  Auto load with INDEX^ */
+			/*  Auto load with INDEX^ */
+			cmReg.reg.autoLoadResetRcap = 4;
 
 		/*  Set Counter Mode Register */
 		cmReg.value = (short)(insn->data[1] & 0xFFFF);
@@ -638,8 +656,10 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		}
 		/*  Reset the counter if it is software preload */
 		if (cmReg.reg.autoLoadResetRcap == 0) {
-			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Reset the counter */
-			outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));	/*  Load the counter from PR0 */
+			/*  Reset the counter */
+			outw(0x8000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
+			/*  Load the counter from PR0 */
+			outw(0x4000, ADDR_CHAN_REG(REG_C0C, subdev_channel));
 		}
 #endif
 		break;
@@ -652,7 +672,7 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		   data[3]: Pre-load Register 1 Value
 		   data[4]: Conter Control Register
 		 */
-		printk("s526: GPCT_INSN_CONFIG: Configuring SPG\n");
+		printk(KERN_INFO "s526: GPCT_INSN_CONFIG: Configuring SPG\n");
 		devpriv->s526_gpct_config[subdev_channel].app =
 		    SinglePulseGeneration;
 
@@ -697,7 +717,7 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		   data[3]: Pre-load Register 1 Value
 		   data[4]: Conter Control Register
 		 */
-		printk("s526: GPCT_INSN_CONFIG: Configuring PTG\n");
+		printk(KERN_INFO "s526: GPCT_INSN_CONFIG: Configuring PTG\n");
 		devpriv->s526_gpct_config[subdev_channel].app =
 		    PulseTrainGeneration;
 
@@ -735,7 +755,7 @@ static int s526_gpct_insn_config(struct comedi_device *dev,
 		break;
 
 	default:
-		printk("s526: unsupported GPCT_insn_config\n");
+		printk(KERN_ERR "s526: unsupported GPCT_insn_config\n");
 		return -EINVAL;
 		break;
 	}
@@ -751,20 +771,21 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 	short value;
 	union cmReg cmReg;
 
-	printk("s526: GPCT_INSN_WRITE on channel %d\n", subdev_channel);
+	printk(KERN_INFO "s526: GPCT_INSN_WRITE on channel %d\n",
+					subdev_channel);
 	cmReg.value = inw(ADDR_CHAN_REG(REG_C0M, subdev_channel));
-	printk("s526: Counter Mode Register: %x\n", cmReg.value);
+	printk(KERN_INFO "s526: Counter Mode Register: %x\n", cmReg.value);
 	/*  Check what Application of Counter this channel is configured for */
 	switch (devpriv->s526_gpct_config[subdev_channel].app) {
 	case PositionMeasurement:
-		printk("S526: INSN_WRITE: PM\n");
+		printk(KERN_INFO "S526: INSN_WRITE: PM\n");
 		outw(0xFFFF & ((*data) >> 16), ADDR_CHAN_REG(REG_C0H,
 							     subdev_channel));
 		outw(0xFFFF & (*data), ADDR_CHAN_REG(REG_C0L, subdev_channel));
 		break;
 
 	case SinglePulseGeneration:
-		printk("S526: INSN_WRITE: SPG\n");
+		printk(KERN_INFO "S526: INSN_WRITE: SPG\n");
 		outw(0xFFFF & ((*data) >> 16), ADDR_CHAN_REG(REG_C0H,
 							     subdev_channel));
 		outw(0xFFFF & (*data), ADDR_CHAN_REG(REG_C0L, subdev_channel));
@@ -777,14 +798,14 @@ static int s526_gpct_winsn(struct comedi_device *dev,
 		   The above periods must be expressed as a multiple of the
 		   pulse frequency on the selected source
 		 */
-		printk("S526: INSN_WRITE: PTG\n");
+		printk(KERN_INFO "S526: INSN_WRITE: PTG\n");
 		if ((insn->data[1] > insn->data[0]) && (insn->data[0] > 0)) {
 			(devpriv->s526_gpct_config[subdev_channel]).data[0] =
 			    insn->data[0];
 			(devpriv->s526_gpct_config[subdev_channel]).data[1] =
 			    insn->data[1];
 		} else {
-			printk("s526: INSN_WRITE: PTG: Problem with Pulse params -> %d %d\n",
+			printk(KERN_ERR "s526: INSN_WRITE: PTG: Problem with Pulse params -> %d %d\n",
 				insn->data[0], insn->data[1]);
 			return -EINVAL;
 		}
@@ -873,7 +894,7 @@ static int s526_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,
 		if (i == TIMEOUT) {
 			/* printk() should be used instead of printk()
 			 * whenever the code can be called from real-time. */
-			printk("s526: ADC(0x%04x) timeout\n",
+			printk(KERN_ERR "s526: ADC(0x%04x) timeout\n",
 			       inw(ADDR_REG(REG_ISR)));
 			return -ETIMEDOUT;
 		}
@@ -906,11 +927,14 @@ static int s526_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,
 	 * very useful, but that's how the interface is defined. */
 	for (i = 0; i < insn->n; i++) {
 		/* a typical programming sequence */
-/* outw(data[i], dev->iobase + REG_ADD);    write the data to preload register */
-		outw(data[i], ADDR_REG(REG_ADD));	/*  write the data to preload register */
+		/* write the data to preload register
+		 * outw(data[i], dev->iobase + REG_ADD);
+		 */
+		/* write the data to preload register */
+		outw(data[i], ADDR_REG(REG_ADD));
 		devpriv->ao_readback[chan] = data[i];
 /* outw(val + 1, dev->iobase + REG_DAC);  starts the D/A conversion. */
-		outw(val + 1, ADDR_REG(REG_DAC));	/*  starts the D/A conversion. */
+		outw(val + 1, ADDR_REG(REG_DAC)); /*starts the D/A conversion.*/
 	}
 
 	/* return the number of samples read/written */
@@ -954,7 +978,7 @@ static int s526_dio_insn_bits(struct comedi_device *dev,
 
 	/* on return, data[1] contains the value of the digital
 	 * input and output lines. */
-	data[1] = inw(ADDR_REG(REG_DIO)) & 0xFF;	/*  low 8 bits are the data */
+	data[1] = inw(ADDR_REG(REG_DIO)) & 0xFF; /* low 8 bits are the data */
 	/* or we could just return the software copy of the output values if
 	 * it was a purely digital output subdevice */
 	/* data[1]=s->state & 0xFF; */
@@ -969,7 +993,7 @@ static int s526_dio_insn_config(struct comedi_device *dev,
 	int chan = CR_CHAN(insn->chanspec);
 	int group, mask;
 
-	printk("S526 DIO insn_config\n");
+	printk(KERN_INFO "S526 DIO insn_config\n");
 
 	/* The input or output configuration of each digital line is
 	 * configured by a special insn_config instruction.  chanspec
@@ -980,11 +1004,12 @@ static int s526_dio_insn_config(struct comedi_device *dev,
 	mask = 0xF << (group << 2);
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
-		s->state |= 1 << (group + 10);  // bit 10/11 set the group 1/2's mode
+		/* bit 10/11 set the group 1/2's mode */
+		s->state |= 1 << (group + 10);
 		s->io_bits |= mask;
 		break;
 	case INSN_CONFIG_DIO_INPUT:
-		s->state &= ~(1 << (group + 10));// 1 is output, 0 is input.
+		s->state &= ~(1 << (group + 10)); /* 1 is output, 0 is input. */
 		s->io_bits &= ~mask;
 		break;
 	case INSN_CONFIG_DIO_QUERY:

