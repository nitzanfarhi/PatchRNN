commit 7e07ce4701138151cd35265a2affefee54b2e1c4
Author: marko <>
Date:   Thu Feb 11 11:09:48 2010 +0000

    branches/zip: Relax a debug assertion about a missing BLOB. (Issue #452)
    When rolling back an incomplete transaction in purge, tolerate missing
    BLOBs also in update undo, when undoing an INSERT by updating a delete-marked
    record, and the delete-marked record is no longer needed.
    Previously, we only tolerated missing BLOBs in insert undo.
    This merely fixes a debug assertion; the code performed correctly
    without UNIV_DEBUG.
    
    rb://249 approved by Sunny Bains.

diff --git a/btr/btr0cur.c b/btr/btr0cur.c
index df21b8d4440..88827d33c61 100644
--- a/btr/btr0cur.c
+++ b/btr/btr0cur.c
@@ -4260,7 +4260,7 @@ btr_free_externally_stored_field(
 		/* In the rollback of uncommitted transactions, we may
 		encounter a clustered index record whose BLOBs have
 		not been written.  There is nothing to free then. */
-		ut_a(rb_ctx == RB_RECOVERY);
+		ut_a(rb_ctx == RB_RECOVERY || rb_ctx == RB_RECOVERY_PURGE_REC);
 		return;
 	}
 
@@ -4306,7 +4306,7 @@ btr_free_externally_stored_field(
 		    || (mach_read_from_1(field_ref + BTR_EXTERN_LEN)
 			& BTR_EXTERN_OWNER_FLAG)
 		    /* Rollback and inherited field */
-		    || (rb_ctx != RB_NONE
+		    || ((rb_ctx == RB_NORMAL || rb_ctx == RB_RECOVERY)
 			&& (mach_read_from_1(field_ref + BTR_EXTERN_LEN)
 			    & BTR_EXTERN_INHERITED_FLAG))) {
 
diff --git a/include/trx0types.h b/include/trx0types.h
index 24cf57d53d5..ae4451636cd 100644
--- a/include/trx0types.h
+++ b/include/trx0types.h
@@ -70,6 +70,13 @@ typedef struct trx_named_savept_struct trx_named_savept_t;
 enum trx_rb_ctx {
 	RB_NONE = 0,	/*!< no rollback */
 	RB_NORMAL,	/*!< normal rollback */
+	RB_RECOVERY_PURGE_REC,
+			/*!< rolling back an incomplete transaction,
+			in crash recovery, rolling back an
+			INSERT that was performed by updating a
+			delete-marked record; if the delete-marked record
+			no longer exists in an active read view, it will
+			be purged */
 	RB_RECOVERY	/*!< rolling back an incomplete transaction,
 			in crash recovery */
 };
diff --git a/row/row0umod.c b/row/row0umod.c
index 674f0fbe09a..3adcee0a7ff 100644
--- a/row/row0umod.c
+++ b/row/row0umod.c
@@ -154,7 +154,7 @@ ulint
 row_undo_mod_remove_clust_low(
 /*==========================*/
 	undo_node_t*	node,	/*!< in: row undo node */
-	que_thr_t*	thr __attribute__((unused)), /*!< in: query thread */
+	que_thr_t*	thr,	/*!< in: query thread */
 	mtr_t*		mtr,	/*!< in: mtr */
 	ulint		mode)	/*!< in: BTR_MODIFY_LEAF or BTR_MODIFY_TREE */
 {
@@ -195,11 +195,13 @@ row_undo_mod_remove_clust_low(
 	} else {
 		ut_ad(mode == BTR_MODIFY_TREE);
 
-		/* Note that since this operation is analogous to purge,
-		we can free also inherited externally stored fields:
-		hence the RB_NONE in the call below */
+		/* This operation is analogous to purge, we can free also
+		inherited externally stored fields */
 
-		btr_cur_pessimistic_delete(&err, FALSE, btr_cur, RB_NONE, mtr);
+		btr_cur_pessimistic_delete(&err, FALSE, btr_cur,
+					   thr_is_recv(thr)
+					   ? RB_RECOVERY_PURGE_REC
+					   : RB_NONE, mtr);
 
 		/* The delete operation may fail if we have little
 		file space left: TODO: easiest to crash the database
@@ -376,10 +378,11 @@ row_undo_mod_del_mark_or_remove_sec_low(
 		} else {
 			ut_ad(mode == BTR_MODIFY_TREE);
 
-			/* No need to distinguish RB_RECOVERY here, because we
-			are deleting a secondary index record: the distinction
-			between RB_NORMAL and RB_RECOVERY only matters when
-			deleting a record that contains externally stored
+			/* No need to distinguish RB_RECOVERY_PURGE here,
+			because we are deleting a secondary index record:
+			the distinction between RB_NORMAL and
+			RB_RECOVERY_PURGE only matters when deleting a
+			record that contains externally stored
 			columns. */
 			ut_ad(!dict_index_is_clust(index));
 			btr_cur_pessimistic_delete(&err, FALSE, btr_cur,

