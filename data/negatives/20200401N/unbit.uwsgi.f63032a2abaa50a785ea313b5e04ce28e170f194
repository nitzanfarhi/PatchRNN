commit f63032a2abaa50a785ea313b5e04ce28e170f194
Author: Riccardo Magliocchetti <riccardo.magliocchetti@gmail.com>
Date:   Sat Oct 3 16:40:31 2015 +0200

    Extend internal uwsgi timer api for handling ns value
    
    We add to struct_timer a long field to store a value in ns. This
    does not replace the int field for storing values with seconds
    resolution.
    The facing api is not changed so plugins and configuration to add
    timers still works only with second resolution values.
    A new high resolution version (*_hr suffix) is provided for both
    uwsgi_add_timer and event_queue_add_timer.

diff --git a/core/event.c b/core/event.c
index 36751a62..56b3ef10 100644
--- a/core/event.c
+++ b/core/event.c
@@ -1252,7 +1252,7 @@ static int timerfd_settime(int __ufd, int __flags, __const struct itimerspec *__
 }
 #endif
 
-int event_queue_add_timer(int eq, int *id, int sec) {
+int event_queue_add_timer_hr(int eq, int *id, int sec, long nsec) {
 
 	struct itimerspec it;
 	int tfd = timerfd_create(CLOCK_REALTIME, TFD_CLOEXEC);
@@ -1263,10 +1263,10 @@ int event_queue_add_timer(int eq, int *id, int sec) {
 	}
 
 	it.it_value.tv_sec = sec;
-	it.it_value.tv_nsec = 0;
+	it.it_value.tv_nsec = nsec;
 
 	it.it_interval.tv_sec = sec;
-	it.it_interval.tv_nsec = 0;
+	it.it_interval.tv_nsec = nsec;
 
 	if (timerfd_settime(tfd, 0, &it, NULL)) {
 		uwsgi_error("timerfd_settime()");
@@ -1307,7 +1307,7 @@ struct uwsgi_timer *event_queue_ack_timer(int id) {
 #endif
 
 #ifdef UWSGI_EVENT_TIMER_USE_NONE
-int event_queue_add_timer(int eq, int *id, int sec) {
+int event_queue_add_timer_hr(int eq, int *id, int sec, long nsec) {
 	return -1;
 }
 struct uwsgi_timer *event_queue_ack_timer(int id) {
@@ -1316,7 +1316,7 @@ struct uwsgi_timer *event_queue_ack_timer(int id) {
 #endif
 
 #ifdef UWSGI_EVENT_TIMER_USE_PORT
-int event_queue_add_timer(int eq, int *id, int sec) {
+int event_queue_add_timer_hr(int eq, int *id, int sec, long nsec) {
 
 	static int timer_id = 0xffffff00;
 	port_notify_t pnotif;
@@ -1339,10 +1339,10 @@ int event_queue_add_timer(int eq, int *id, int sec) {
 
 
 	it.it_value.tv_sec = sec;
-	it.it_value.tv_nsec = 0;
+	it.it_value.tv_nsec = nsec;
 
 	it.it_interval.tv_sec = sec;
-	it.it_interval.tv_nsec = 0;
+	it.it_interval.tv_nsec = nsec;
 
 	if (timer_settime(tid, 0, &it, NULL) < 0) {
 		uwsgi_error("timer_settime()");
@@ -1374,15 +1374,16 @@ struct uwsgi_timer *event_queue_ack_timer(int id) {
 
 
 #ifdef UWSGI_EVENT_TIMER_USE_KQUEUE
-int event_queue_add_timer(int eq, int *id, int sec) {
+int event_queue_add_timer_hr(int eq, int *id, int sec, long nsec) {
 
 	static int timer_id = 0xffffff00;
 	struct kevent kev;
+	int timeout_ms = sec * 1000 + (int)(nsec / 1000000);
 
 	*id = timer_id;
 	timer_id++;
 
-	EV_SET(&kev, *id, EVFILT_TIMER, EV_ADD, 0, sec * 1000, 0);
+	EV_SET(&kev, *id, EVFILT_TIMER, EV_ADD, 0, timeout_ms, 0);
 	if (kevent(eq, &kev, 1, NULL, 0, NULL) < 0) {
 		uwsgi_error("kevent()");
 		return -1;
@@ -1409,6 +1410,10 @@ struct uwsgi_timer *event_queue_ack_timer(int id) {
 }
 #endif
 
+int event_queue_add_timer(int eq, int *id, int sec) {
+	return event_queue_add_timer_hr(eq, id, sec, 0);
+}
+
 int event_queue_read() {
 	return UWSGI_EVENT_IN;
 }
diff --git a/core/master.c b/core/master.c
index ad474287..adcefd4c 100644
--- a/core/master.c
+++ b/core/master.c
@@ -720,7 +720,7 @@ int master_loop(char **argv, char **environ) {
 			// locking is not needed as timers can only increase
 			for (i = 0; i < ushared->timers_cnt; i++) {
 				if (!ushared->timers[i].registered) {
-					ushared->timers[i].fd = event_queue_add_timer(uwsgi.master_queue, &ushared->timers[i].id, ushared->timers[i].value);
+					ushared->timers[i].fd = event_queue_add_timer_hr(uwsgi.master_queue, &ushared->timers[i].id, ushared->timers[i].value, ushared->timers[i].nsvalue);
 					ushared->timers[i].registered = 1;
 				}
 			}
diff --git a/core/signal.c b/core/signal.c
index 1e660a5e..bc9f272f 100644
--- a/core/signal.c
+++ b/core/signal.c
@@ -180,7 +180,7 @@ int uwsgi_add_file_monitor(uint8_t sig, char *filename) {
 
 }
 
-int uwsgi_add_timer(uint8_t sig, int secs) {
+int uwsgi_add_timer_hr(uint8_t sig, int secs, long nsecs) {
 
 	if (!uwsgi.master_process) return -1;
 
@@ -192,6 +192,7 @@ int uwsgi_add_timer(uint8_t sig, int secs) {
 		ushared->timers[ushared->timers_cnt].value = secs;
 		ushared->timers[ushared->timers_cnt].registered = 0;
 		ushared->timers[ushared->timers_cnt].sig = sig;
+		ushared->timers[ushared->timers_cnt].nsvalue = nsecs;
 		ushared->timers_cnt++;
 	}
 	else {
@@ -206,6 +207,10 @@ int uwsgi_add_timer(uint8_t sig, int secs) {
 
 }
 
+int uwsgi_add_timer(uint8_t sig, int secs) {
+	return uwsgi_add_timer_hr(sig, secs, 0);
+}
+
 int uwsgi_signal_add_rb_timer(uint8_t sig, int secs, int iterations) {
 
 	if (!uwsgi.master_process)
diff --git a/uwsgi.h b/uwsgi.h
index e4c62693..ba81f8e3 100755
--- a/uwsgi.h
+++ b/uwsgi.h
@@ -1609,6 +1609,7 @@ struct uwsgi_timer {
 	int id;
 	int registered;
 	uint8_t sig;
+	long nsvalue;
 };
 
 struct uwsgi_signal_rb_timer {
@@ -3318,6 +3319,7 @@ int event_queue_interesting_fd_is_read(void *, int);
 int event_queue_interesting_fd_is_write(void *, int);
 
 int event_queue_add_timer(int, int *, int);
+int event_queue_add_timer_hr(int, int *, int, long);
 struct uwsgi_timer *event_queue_ack_timer(int);
 
 int event_queue_add_file_monitor(int, char *, int *);
@@ -3327,6 +3329,7 @@ struct uwsgi_fmon *event_queue_ack_file_monitor(int, int);
 int uwsgi_register_signal(uint8_t, char *, void *, uint8_t);
 int uwsgi_add_file_monitor(uint8_t, char *);
 int uwsgi_add_timer(uint8_t, int);
+int uwsgi_add_timer_hr(uint8_t, int, long);
 int uwsgi_signal_add_rb_timer(uint8_t, int, int);
 int uwsgi_signal_handler(struct wsgi_request *, uint8_t);
 

