commit 261875b92463085dd7db66a90828830b35b5577b
Author: Chris Maynard <Christopher.Maynard@GTECH.COM>
Date:   Tue May 10 14:22:17 2011 +0000

    Allow both PPP and ISO/IEC 13818-1 over USB to be dissected using heuristics.
    Resolves bug 4814.
    
    svn path=/trunk/; revision=37039

diff --git a/epan/dissectors/packet-mp2t.c b/epan/dissectors/packet-mp2t.c
index 3119108c56..9092b61fa0 100644
--- a/epan/dissectors/packet-mp2t.c
+++ b/epan/dissectors/packet-mp2t.c
@@ -1361,6 +1361,7 @@ proto_reg_handoff_mp2t(void)
 	mp2t_handle = create_dissector_handle(dissect_mp2t, proto_mp2t);
 	dissector_add_uint("rtp.pt", PT_MP2T, mp2t_handle);
 	dissector_add_handle("udp.port", mp2t_handle);  /* for decode-as */
+	heur_dissector_add("usb.bulk", heur_dissect_mp2t, proto_mp2t);
 
 	pes_handle = find_dissector("mpeg-pes");
 	docsis_handle = find_dissector("docsis");
diff --git a/epan/dissectors/packet-ppp.c b/epan/dissectors/packet-ppp.c
index 1d30f2b45e..ad2cd95b8f 100644
--- a/epan/dissectors/packet-ppp.c
+++ b/epan/dissectors/packet-ppp.c
@@ -4380,7 +4380,7 @@ dissect_ppp_raw_hdlc( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree )
  *
  * NOTE: I don't know if these heuristics are sufficient.  Time will tell ...
  */
-static void
+static gboolean
 dissect_ppp_usb( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree )
 {
   /* In some cases, the 0x03 normally in byte 3 is escaped so we must look for
@@ -4421,6 +4421,9 @@ dissect_ppp_usb( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree )
     next_tvb = tvb_new_subset_remaining(tvb, 1);
     dissect_ppp_hdlc_common(next_tvb, pinfo, tree);
   }
+  else
+    return (FALSE);
+  return (TRUE);
 }
 
 void
@@ -4438,16 +4441,12 @@ void
 proto_reg_handoff_ppp_raw_hdlc(void)
 {
   dissector_handle_t ppp_raw_hdlc_handle;
-  dissector_handle_t ppp_usb_handle;
 
   ppp_raw_hdlc_handle = create_dissector_handle(dissect_ppp_raw_hdlc, proto_ppp);
   dissector_add_uint("gre.proto", ETHERTYPE_CDMA2000_A10_UBS, ppp_raw_hdlc_handle);
   dissector_add_uint("gre.proto", ETHERTYPE_3GPP2, ppp_raw_hdlc_handle);
 
-  ppp_usb_handle = create_dissector_handle(dissect_ppp_usb, proto_ppp);
-  dissector_add_uint("usb.bulk", IF_CLASS_UNKNOWN, ppp_usb_handle);
-  dissector_add_uint("usb.bulk", IF_CLASS_VENDOR_SPECIFIC, ppp_usb_handle);
-  dissector_add_uint("usb.bulk", IF_CLASS_CDC_DATA, ppp_usb_handle);
+  heur_dissector_add("usb.bulk", dissect_ppp_usb, proto_ppp);
 }
 
 /*
diff --git a/epan/dissectors/packet-usb.c b/epan/dissectors/packet-usb.c
index 5b0e900a92..2b981e25b7 100644
--- a/epan/dissectors/packet-usb.c
+++ b/epan/dissectors/packet-usb.c
@@ -40,6 +40,7 @@
 #include <epan/tap.h>
 #include <epan/conversation.h>
 #include <epan/expert.h>
+#include <epan/prefs.h>
 #include "packet-usb.h"
 #include "packet-usb-hid.h"
 
@@ -151,9 +152,11 @@ static const int *usb_endpoint_fields[] = {
 };
 
 static int usb_tap = -1;
+static gboolean try_heuristics = TRUE;
 
 static dissector_table_t usb_bulk_dissector_table;
 static dissector_table_t usb_control_dissector_table;
+static heur_dissector_list_t heur_subdissector_list;
 
 /* http://www.usb.org/developers/docs/USB_LANGIDs.pdf */
 static const value_string usb_langid_vals[] = {
@@ -2006,7 +2009,10 @@ dissect_linux_usb_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent,
 
             pinfo->usb_conv_info=usb_conv_info;
             next_tvb=tvb_new_subset_remaining(tvb, offset);
-            if(dissector_try_uint(usb_bulk_dissector_table, usb_conv_info->interfaceClass, next_tvb, pinfo, parent)){
+            if (try_heuristics && dissector_try_heuristic(heur_subdissector_list, next_tvb, pinfo, parent)) {
+                return;
+            }
+            else if(dissector_try_uint(usb_bulk_dissector_table, usb_conv_info->interfaceClass, next_tvb, pinfo, parent)){
                 return;
             }
         }
@@ -2356,6 +2362,7 @@ dissect_linux_usb_mmapped(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent)
 void
 proto_register_usb(void)
 {
+    module_t *usb_module;
     static hf_register_info hf[] = {
 
     /* USB packet pseudoheader members */
@@ -2730,10 +2737,17 @@ proto_register_usb(void)
 
     usb_bulk_dissector_table = register_dissector_table("usb.bulk",
         "USB bulk endpoint", FT_UINT8, BASE_DEC);
-
+    register_heur_dissector_list("usb.bulk", &heur_subdissector_list);
     usb_control_dissector_table = register_dissector_table("usb.control",
         "USB control endpoint", FT_UINT8, BASE_DEC);
 
+    usb_module = prefs_register_protocol(proto_usb, NULL);
+    prefs_register_bool_preference(usb_module, "try_heuristics",
+        "Try heuristic sub-dissectors",
+        "Try to decode a packet using a heuristic sub-dissector before "
+        "attempting to dissect the packet using the \"usb.bulk\" dissector "
+        "table.", &try_heuristics);
+
     usb_tap=register_tap("usb");
 }
 

