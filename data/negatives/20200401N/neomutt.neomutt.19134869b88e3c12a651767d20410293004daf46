commit 19134869b88e3c12a651767d20410293004daf46
Author: Richard Russon <rich@flatcap.org>
Date:   Mon Aug 6 19:40:49 2018 +0100

    boolify functions, params, variables
    
    - add_folder()
    - body_to_data_object()
    - browse_add_list_result()
    - check_certificate_file()
    - crypt_id_is_strong()
    - imap_check()
    - imap_check_mailbox()
    - imap_exec_msgset()
    - imap_mailbox_check()
    - imap_status()
    - imap_sync_mailbox()
    - index_format_str()
    - init_menu()
    - interactive_check_cert()
    - msg_search()
    - mutt_enter_string_full()
    - mutt_get_field_full()
    - mutt_num_postponed()
    - mutt_sort_headers()
    - pgp_check_traditional_one_body()
    - print_ref()
    - set_copy_flags()
    - set_noconv_flags()

diff --git a/browser.c b/browser.c
index e4abb3b85..838cdfe54 100644
--- a/browser.c
+++ b/browser.c
@@ -1165,13 +1165,13 @@ static void init_menu(struct BrowserState *state, struct Menu *menu,
   {
     if (mailbox)
     {
-      menu->is_mailbox_list = 1;
+      menu->is_mailbox_list = true;
       snprintf(title, titlelen, _("Mailboxes [%d]"), mutt_mailbox_check(0));
     }
     else
     {
       char path[PATH_MAX];
-      menu->is_mailbox_list = 0;
+      menu->is_mailbox_list = false;
       mutt_str_strfcpy(path, LastDir, sizeof(path));
       mutt_pretty_mailbox(path, sizeof(path));
       snprintf(title, titlelen, _("Directory [%s], File mask: %s"), path,
diff --git a/commands.c b/commands.c
index 3cc63a968..e9b486993 100644
--- a/commands.c
+++ b/commands.c
@@ -781,7 +781,7 @@ void mutt_display_address(struct Envelope *env)
  * @param[out] cmflags Copy message flags, e.g. MUTT_CM_DECODE
  * @param[out] chflags Copy header flags, e.g. CH_DECODE
  */
-static void set_copy_flags(struct Header *hdr, int decode, int decrypt,
+static void set_copy_flags(struct Header *hdr, bool decode, bool decrypt,
                            int *cmflags, int *chflags)
 {
   *cmflags = 0;
diff --git a/conn/ssl.c b/conn/ssl.c
index 7f272efc8..a3d94e7a4 100644
--- a/conn/ssl.c
+++ b/conn/ssl.c
@@ -747,28 +747,28 @@ static bool check_certificate_cache(X509 *peercert)
 /**
  * check_certificate_file - Read and check a certificate file
  * @param peercert Certificate
- * @retval 1 Certificate is valid
- * @retval 0 Error, or certificate is invalid
+ * @retval true  Certificate is valid
+ * @retval false Error, or certificate is invalid
  */
-static int check_certificate_file(X509 *peercert)
+static bool check_certificate_file(X509 *peercert)
 {
   unsigned char peermd[EVP_MAX_MD_SIZE];
   unsigned int peermdlen;
   X509 *cert = NULL;
-  int pass = 0;
+  int pass = false;
   FILE *fp = NULL;
 
   if (!CertificateFile)
-    return 0;
+    return false;
 
   fp = fopen(CertificateFile, "rt");
   if (!fp)
-    return 0;
+    return false;
 
   if (!X509_digest(peercert, EVP_sha256(), peermd, &peermdlen))
   {
     mutt_file_fclose(&fp);
-    return 0;
+    return false;
   }
 
   while (PEM_read_X509(fp, &cert, NULL, NULL) != NULL)
@@ -776,7 +776,7 @@ static int check_certificate_file(X509 *peercert)
     if (compare_certificates(cert, peercert, peermd, peermdlen) &&
         check_certificate_expiration(cert, true))
     {
-      pass = 1;
+      pass = true;
       break;
     }
   }
@@ -937,7 +937,7 @@ static int ssl_cache_trusted_cert(X509 *c)
  * @retval true  User selected 'skip'
  * @retval false Otherwise
  */
-static int interactive_check_cert(X509 *cert, int idx, size_t len, SSL *ssl, int allow_always)
+static int interactive_check_cert(X509 *cert, int idx, size_t len, SSL *ssl, bool allow_always)
 {
   static const int part[] = {
     NID_commonName,             /* CN */
@@ -1194,7 +1194,7 @@ static int ssl_verify_callback(int preverify_ok, X509_STORE_CTX *ctx)
       mutt_error(_("Certificate host check failed: %s"), buf);
       /* we disallow (a)ccept always in the prompt, because it will have no effect
        * for hostname mismatches. */
-      return interactive_check_cert(cert, pos, len, ssl, 0);
+      return interactive_check_cert(cert, pos, len, ssl, false);
     }
     mutt_debug(2, "hostname check passed\n");
   }
@@ -1215,7 +1215,7 @@ static int ssl_verify_callback(int preverify_ok, X509_STORE_CTX *ctx)
     mutt_debug(2, "X509_verify_cert: %s\n", buf);
 
     /* prompt user */
-    return interactive_check_cert(cert, pos, len, ssl, 1);
+    return interactive_check_cert(cert, pos, len, ssl, true);
   }
 
   return 1;
diff --git a/curs_lib.c b/curs_lib.c
index 1c03b3473..3e9273fa3 100644
--- a/curs_lib.c
+++ b/curs_lib.c
@@ -197,7 +197,7 @@ struct Event mutt_getch(void)
  * @retval -1 Aborted
  */
 int mutt_get_field_full(const char *field, char *buf, size_t buflen,
-                        int complete, int multiple, char ***files, int *numfiles)
+                        int complete, bool multiple, char ***files, int *numfiles)
 {
   int ret;
   int x;
diff --git a/curs_lib.h b/curs_lib.h
index e60e7f10b..bff73ff56 100644
--- a/curs_lib.h
+++ b/curs_lib.h
@@ -54,7 +54,7 @@ void         mutt_flush_unget_to_endcond(void);
 void         mutt_format_s(char *buf, size_t buflen, const char *prec, const char *s);
 void         mutt_format_s_tree(char *buf, size_t buflen, const char *prec, const char *s);
 struct Event mutt_getch(void);
-int          mutt_get_field_full(const char *field, char *buf, size_t buflen, int complete, int multiple, char ***files, int *numfiles);
+int          mutt_get_field_full(const char *field, char *buf, size_t buflen, int complete, bool multiple, char ***files, int *numfiles);
 int          mutt_get_field_unbuffered(char *msg, char *buf, size_t buflen, int flags);
 int          mutt_multi_choice(char *prompt, char *letters);
 void         mutt_need_hard_redraw(void);
@@ -73,7 +73,7 @@ int          mutt_yesorno(const char *msg, int def);
 
 #define mutt_enter_fname(A, B, C, D)   mutt_enter_fname_full(A, B, C, D, false, NULL, NULL, 0)
 #define mutt_enter_vfolder(A, B, C, D) mutt_enter_fname_full(A, B, C, D, false, NULL, NULL, MUTT_SEL_VFOLDER)
-#define mutt_get_field(A, B, C, D)     mutt_get_field_full(A, B, C, D, 0, NULL, NULL)
+#define mutt_get_field(A, B, C, D)     mutt_get_field_full(A, B, C, D, false, NULL, NULL)
 #define mutt_get_password(A, B, C)     mutt_get_field_unbuffered(A, B, C, MUTT_PASS)
 
 #endif /* MUTT_CURS_LIB_H */
diff --git a/curs_main.c b/curs_main.c
index 1cf653256..448a9132e 100644
--- a/curs_main.c
+++ b/curs_main.c
@@ -342,7 +342,7 @@ static void resort_index(struct Menu *menu)
   struct Header *current = CURHDR;
 
   menu->current = -1;
-  mutt_sort_headers(Context, 0);
+  mutt_sort_headers(Context, false);
   /* Restore the current message */
 
   for (int i = 0; i < Context->vcount; i++)
@@ -1291,7 +1291,7 @@ int mutt_index_menu(void)
             if (rc2 == 0)
             {
               hdr = Context->hdrs[Context->msgcount - 1];
-              mutt_sort_headers(Context, 0);
+              mutt_sort_headers(Context, false);
               menu->current = hdr->virtual;
               menu->redraw = REDRAW_FULL;
             }
@@ -1725,7 +1725,7 @@ int mutt_index_menu(void)
 #ifdef USE_IMAP
       case OP_MAIN_IMAP_FETCH:
         if (Context && Context->magic == MUTT_IMAP)
-          imap_check_mailbox(Context, 1);
+          imap_check_mailbox(Context, true);
         break;
 
       case OP_MAIN_IMAP_LOGOUT_ALL:
@@ -1854,7 +1854,7 @@ int mutt_index_menu(void)
           struct Header *oldcur = CURHDR;
 
           if ((Sort & SORT_MASK) == SORT_THREADS)
-            mutt_sort_headers(Context, 0);
+            mutt_sort_headers(Context, false);
           menu->current = oldcur->virtual;
           menu->redraw = REDRAW_STATUS | REDRAW_INDEX;
 
@@ -2256,7 +2256,7 @@ int mutt_index_menu(void)
             struct Header *oldcur = CURHDR;
 
             mutt_break_thread(CURHDR);
-            mutt_sort_headers(Context, 1);
+            mutt_sort_headers(Context, true);
             menu->current = oldcur->virtual;
           }
 
@@ -2299,7 +2299,7 @@ int mutt_index_menu(void)
 
           if (mutt_link_threads(CURHDR, tag ? NULL : Context->last_tag, Context))
           {
-            mutt_sort_headers(Context, 1);
+            mutt_sort_headers(Context, true);
             menu->current = oldcur->virtual;
 
             Context->changed = true;
diff --git a/doc/makedoc.c b/doc/makedoc.c
index 96a4b3d53..bebe02d97 100644
--- a/doc/makedoc.c
+++ b/doc/makedoc.c
@@ -791,7 +791,7 @@ static int sgml_id_fputs(const char *s, FILE *out)
   return 0;
 }
 
-void print_ref(FILE *out, int output_dollar, const char *ref)
+void print_ref(FILE *out, bool output_dollar, const char *ref)
 {
   switch (OutputFormat)
   {
diff --git a/enter.c b/enter.c
index 065b02f91..f7e36d700 100644
--- a/enter.c
+++ b/enter.c
@@ -153,7 +153,7 @@ int mutt_enter_string(char *buf, size_t buflen, int col, int flags)
       mutt_resize_screen();
       clearok(stdscr, TRUE);
     }
-    rc = mutt_enter_string_full(buf, buflen, col, flags, 0, NULL, NULL, es);
+    rc = mutt_enter_string_full(buf, buflen, col, flags, false, NULL, NULL, es);
   } while (rc == 1);
   mutt_enter_state_free(&es);
   return rc;
@@ -173,7 +173,7 @@ int mutt_enter_string(char *buf, size_t buflen, int col, int flags)
  * @retval 0  Selection made
  * @retval -1 Aborted
  */
-int mutt_enter_string_full(char *buf, size_t buflen, int col, int flags, int multiple,
+int mutt_enter_string_full(char *buf, size_t buflen, int col, int flags, bool multiple,
                            char ***files, int *numfiles, struct EnterState *state)
 {
   int width = MuttMessageWindow->cols - col - 1;
diff --git a/hdrline.c b/hdrline.c
index 9f5e5cd5a..2a29be002 100644
--- a/hdrline.c
+++ b/hdrline.c
@@ -737,14 +737,14 @@ static const char *index_format_str(char *buf, size_t buflen, size_t col, int co
         p = buf;
 
         cp = (op == 'd' || op == 'D') ? (NONULL(DateFormat)) : src;
-        int do_locales;
+        bool do_locales;
         if (*cp == '!')
         {
-          do_locales = 0;
+          do_locales = false;
           cp++;
         }
         else
-          do_locales = 1;
+          do_locales = true;
 
         size_t len = buflen - 1;
         while (len > 0 && (((op == 'd' || op == 'D') && *cp) ||
diff --git a/imap/browse.c b/imap/browse.c
index 188882139..02fb179c1 100644
--- a/imap/browse.c
+++ b/imap/browse.c
@@ -58,8 +58,8 @@
  * The folder parameter should already be 'unmunged' via
  * imap_unmunge_mbox_name().
  */
-static void add_folder(char delim, char *folder, int noselect, int noinferiors,
-                       struct BrowserState *state, short isparent)
+static void add_folder(char delim, char *folder, bool noselect, bool noinferiors,
+                       struct BrowserState *state, bool isparent)
 {
   char tmp[PATH_MAX];
   char relpath[PATH_MAX];
@@ -148,7 +148,7 @@ static void add_folder(char delim, char *folder, int noselect, int noinferiors,
  * @retval -1 Failure
  */
 static int browse_add_list_result(struct ImapData *idata, const char *cmd,
-                                  struct BrowserState *state, short isparent)
+                                  struct BrowserState *state, bool isparent)
 {
   struct ImapList list;
   struct ImapMbox mx;
@@ -290,7 +290,7 @@ int imap_browse(char *path, struct BrowserState *state)
       if (showparents)
       {
         mutt_debug(3, "adding parent %s\n", mbox);
-        add_folder(list.delim, mbox, 1, 0, state, 1);
+        add_folder(list.delim, mbox, true, false, state, true);
       }
 
       /* if our target isn't a folder, we are in our superior */
@@ -312,7 +312,7 @@ int imap_browse(char *path, struct BrowserState *state)
       /* folder may be "/" */
       snprintf(relpath, sizeof(relpath), "%c", n < 0 ? '\0' : idata->delim);
       if (showparents)
-        add_folder(idata->delim, relpath, 1, 0, state, 1);
+        add_folder(idata->delim, relpath, true, false, state, true);
       if (!state->folder)
       {
         imap_qualify_path(buf, sizeof(buf), &mx, relpath);
@@ -333,7 +333,7 @@ int imap_browse(char *path, struct BrowserState *state)
   imap_munge_mbox_name(idata, munged_mbox, sizeof(munged_mbox), buf);
   mutt_debug(3, "%s\n", munged_mbox);
   snprintf(buf, sizeof(buf), "%s \"\" %s", list_cmd, munged_mbox);
-  if (browse_add_list_result(idata, buf, state, 0))
+  if (browse_add_list_result(idata, buf, state, false))
     goto fail;
 
   if (state->entrylen == 0)
diff --git a/imap/imap.c b/imap/imap.c
index 2c7563ce4..4602c7725 100644
--- a/imap/imap.c
+++ b/imap/imap.c
@@ -307,13 +307,13 @@ static int sync_helper(struct ImapData *idata, int right, int flag, const char *
     return 0;
 
   snprintf(buf, sizeof(buf), "+FLAGS.SILENT (%s)", name);
-  rc = imap_exec_msgset(idata, "UID STORE", buf, flag, 1, 0);
+  rc = imap_exec_msgset(idata, "UID STORE", buf, flag, true, false);
   if (rc < 0)
     return rc;
   count += rc;
 
   buf[0] = '-';
-  rc = imap_exec_msgset(idata, "UID STORE", buf, flag, 1, 1);
+  rc = imap_exec_msgset(idata, "UID STORE", buf, flag, true, true);
   if (rc < 0)
     return rc;
   count += rc;
@@ -841,7 +841,7 @@ void imap_expunge_mailbox(struct ImapData *idata)
 
   old_sort = Sort;
   Sort = SORT_ORDER;
-  mutt_sort_headers(idata->ctx, 0);
+  mutt_sort_headers(idata->ctx, false);
 
   for (int i = 0; i < idata->ctx->msgcount; i++)
   {
@@ -903,7 +903,7 @@ void imap_expunge_mailbox(struct ImapData *idata)
    * to always know to rethread */
   mx_update_tables(idata->ctx, false);
   Sort = old_sort;
-  mutt_sort_headers(idata->ctx, 1);
+  mutt_sort_headers(idata->ctx, true);
 }
 
 /**
@@ -1170,7 +1170,7 @@ bool imap_has_flag(struct ListHead *flag_list, const char *flag)
  * (must be flushed with imap_exec)
  */
 int imap_exec_msgset(struct ImapData *idata, const char *pre, const char *post,
-                     int flag, int changed, int invert)
+                     int flag, bool changed, bool invert)
 {
   struct Header **hdrs = NULL;
   short oldsort;
@@ -1348,7 +1348,7 @@ int imap_sync_message_for_copy(struct ImapData *idata, struct Header *hdr,
  * @retval 0               no change
  * @retval -1              error
  */
-int imap_check_mailbox(struct Context *ctx, int force)
+int imap_check_mailbox(struct Context *ctx, bool force)
 {
   return imap_check(ctx->data, force);
 }
@@ -1360,7 +1360,7 @@ int imap_check_mailbox(struct Context *ctx, int force)
  * @retval >0 Success, e.g. #MUTT_REOPENED
  * @retval -1 Failure
  */
-int imap_check(struct ImapData *idata, int force)
+int imap_check(struct ImapData *idata, bool force)
 {
   /* overload keyboard timeout to avoid many mailbox checks in a row.
    * Most users don't like having to wait exactly when they press a key. */
@@ -1421,7 +1421,7 @@ int imap_check(struct ImapData *idata, int force)
  * Given a list of mailboxes rather than called once for each so that it can
  * batch the commands and save on round trips.
  */
-int imap_mailbox_check(int check_stats)
+int imap_mailbox_check(bool check_stats)
 {
   struct ImapData *idata = NULL;
   struct ImapData *lastdata = NULL;
@@ -1524,7 +1524,7 @@ int imap_mailbox_check(int check_stats)
  * If queue is true, the command will be sent now and be expected to have been
  * run on the next call (for pipelining the postponed count).
  */
-int imap_status(char *path, int queue)
+int imap_status(char *path, bool queue)
 {
   static int queued = 0;
 
@@ -1917,7 +1917,7 @@ int imap_fast_trash(struct Context *ctx, char *dest)
   /* loop in case of TRYCREATE */
   do
   {
-    rc = imap_exec_msgset(idata, "UID COPY", mmbox, MUTT_TRASH, 0, 0);
+    rc = imap_exec_msgset(idata, "UID COPY", mmbox, MUTT_TRASH, false, false);
     if (!rc)
     {
       mutt_debug(1, "No messages to trash\n");
@@ -2051,7 +2051,7 @@ static int imap_mbox_open(struct Context *ctx)
   if (mx_is_imap(Postponed) && !imap_parse_path(Postponed, &pmx) &&
       mutt_account_match(&pmx.account, &mx.account))
   {
-    imap_status(Postponed, 1);
+    imap_status(Postponed, true);
   }
   FREE(&pmx.mbox);
 
@@ -2342,7 +2342,7 @@ static int imap_mbox_check(struct Context *ctx, int *index_hint)
   (void) index_hint;
 
   imap_allow_reopen(ctx);
-  rc = imap_check(ctx->data, 0);
+  rc = imap_check(ctx->data, false);
   imap_disallow_reopen(ctx);
 
   return rc;
@@ -2351,11 +2351,11 @@ static int imap_mbox_check(struct Context *ctx, int *index_hint)
 /**
  * imap_sync_mailbox - Sync all the changes to the server
  * @param ctx     Context
- * @param expunge 0 or 1 - do expunge?
+ * @param expunge if true do expunge
  * @retval  0 Success
  * @retval -1 Error
  */
-int imap_sync_mailbox(struct Context *ctx, int expunge)
+int imap_sync_mailbox(struct Context *ctx, bool expunge)
 {
   struct Context *appendctx = NULL;
   struct Header *h = NULL;
@@ -2375,7 +2375,7 @@ int imap_sync_mailbox(struct Context *ctx, int expunge)
    * to be changed. */
   imap_allow_reopen(ctx);
 
-  rc = imap_check(idata, 0);
+  rc = imap_check(idata, false);
   if (rc != 0)
     return rc;
 
@@ -2383,7 +2383,7 @@ int imap_sync_mailbox(struct Context *ctx, int expunge)
   if (expunge && mutt_bit_isset(ctx->rights, MUTT_ACL_DELETE))
   {
     rc = imap_exec_msgset(idata, "UID STORE", "+FLAGS.SILENT (\\Deleted)",
-                          MUTT_DELETED, 1, 0);
+                          MUTT_DELETED, true, false);
     if (rc < 0)
     {
       mutt_error(_("Expunge failed"));
diff --git a/imap/imap.h b/imap/imap.h
index d9fd94690..6adf913b8 100644
--- a/imap/imap.h
+++ b/imap/imap.h
@@ -84,11 +84,11 @@ struct ImapMbox
 
 /* imap.c */
 int imap_access(const char *path);
-int imap_check_mailbox(struct Context *ctx, int force);
+int imap_check_mailbox(struct Context *ctx, bool force);
 int imap_delete_mailbox(struct Context *ctx, struct ImapMbox *mx);
-int imap_sync_mailbox(struct Context *ctx, int expunge);
-int imap_mailbox_check(int check_stats);
-int imap_status(char *path, int queue);
+int imap_sync_mailbox(struct Context *ctx, bool expunge);
+int imap_mailbox_check(bool check_stats);
+int imap_status(char *path, bool queue);
 int imap_search(struct Context *ctx, const struct Pattern *pat);
 int imap_subscribe(char *path, bool subscribe);
 int imap_complete(char *buf, size_t buflen, char *path);
diff --git a/imap/imap_private.h b/imap/imap_private.h
index 2d9d1b520..7d33f2834 100644
--- a/imap/imap_private.h
+++ b/imap/imap_private.h
@@ -267,13 +267,13 @@ struct ImapData
 
 /* -- private IMAP functions -- */
 /* imap.c */
-int imap_check(struct ImapData *idata, int force);
+int imap_check(struct ImapData *idata, bool force);
 int imap_create_mailbox(struct ImapData *idata, char *mailbox);
 int imap_rename_mailbox(struct ImapData *idata, struct ImapMbox *mx, const char *newname);
 struct ImapStatus *imap_mboxcache_get(struct ImapData *idata, const char *mbox, bool create);
 void imap_mboxcache_free(struct ImapData *idata);
 int imap_exec_msgset(struct ImapData *idata, const char *pre, const char *post,
-                     int flag, int changed, int invert);
+                     int flag, bool changed, bool invert);
 int imap_open_connection(struct ImapData *idata);
 void imap_close_connection(struct ImapData *idata);
 struct ImapData *imap_conn_find(const struct Account *account, int flags);
diff --git a/imap/message.c b/imap/message.c
index 1021235c7..1e48f6adc 100644
--- a/imap/message.c
+++ b/imap/message.c
@@ -1436,7 +1436,7 @@ int imap_copy_messages(struct Context *ctx, struct Header *h, char *dest, bool d
         }
       }
 
-      rc = imap_exec_msgset(idata, "UID COPY", mmbox, MUTT_TAG, 0, 0);
+      rc = imap_exec_msgset(idata, "UID COPY", mmbox, MUTT_TAG, false, false);
       if (!rc)
       {
         mutt_debug(1, "No messages tagged\n");
diff --git a/imap/util.c b/imap/util.c
index 400fd5bab..8257b3c40 100644
--- a/imap/util.c
+++ b/imap/util.c
@@ -924,7 +924,7 @@ void imap_keepalive(void)
       idata = conn->data;
       if (idata->state >= IMAP_AUTHENTICATED && now >= idata->lastread + ImapKeepalive)
       {
-        imap_check(idata, 1);
+        imap_check(idata, true);
       }
     }
   }
diff --git a/maildir/mh.c b/maildir/mh.c
index 6e6fdad03..dac484bcf 100644
--- a/maildir/mh.c
+++ b/maildir/mh.c
@@ -2282,7 +2282,7 @@ static void maildir_update_tables(struct Context *ctx, int *index_hint)
   {
     const short old_sort = Sort;
     Sort = SORT_ORDER;
-    mutt_sort_headers(ctx, 1);
+    mutt_sort_headers(ctx, true);
     Sort = old_sort;
   }
 
diff --git a/mbox/mbox.c b/mbox/mbox.c
index 6c0fb706b..b2cff39da 100644
--- a/mbox/mbox.c
+++ b/mbox/mbox.c
@@ -633,7 +633,7 @@ static int reopen_mailbox(struct Context *ctx, int *index_hint)
 
     old_sort = Sort;
     Sort = SORT_ORDER;
-    mutt_sort_headers(ctx, 1);
+    mutt_sort_headers(ctx, true);
     Sort = old_sort;
   }
 
@@ -975,7 +975,7 @@ static int mbox_mbox_sync(struct Context *ctx, int *index_hint)
   {
     save_sort = Sort;
     Sort = SORT_ORDER;
-    mutt_sort_headers(ctx, 0);
+    mutt_sort_headers(ctx, false);
     Sort = save_sort;
     need_sort = 1;
   }
diff --git a/mx.c b/mx.c
index 0cd38f770..9a406ab02 100644
--- a/mx.c
+++ b/mx.c
@@ -513,7 +513,7 @@ struct Context *mx_mbox_open(const char *path, int flags, struct Context *pctx)
          to begin with */
       OptSortSubthreads = false;
       OptNeedRescore = false;
-      mutt_sort_headers(ctx, 1);
+      mutt_sort_headers(ctx, true);
     }
     if (!ctx->quiet)
       mutt_clear_error();
@@ -887,7 +887,7 @@ int mx_mbox_close(struct Context *ctx, int *index_hint)
   /* allow IMAP to preserve the deleted flag across sessions */
   if (ctx->magic == MUTT_IMAP)
   {
-    int check = imap_sync_mailbox(ctx, purge);
+    int check = imap_sync_mailbox(ctx, (purge != MUTT_NO));
     if (check != 0)
     {
       ctx->closing = false;
@@ -1167,7 +1167,7 @@ int mx_mbox_sync(struct Context *ctx, int *index_hint)
       if (ctx->magic != MUTT_IMAP)
       {
         mx_update_tables(ctx, true);
-        mutt_sort_headers(ctx, 1); /* rethread from scratch */
+        mutt_sort_headers(ctx, true); /* rethread from scratch */
       }
     }
   }
diff --git a/ncrypt/crypt_gpgme.c b/ncrypt/crypt_gpgme.c
index 5ad399902..ea3e4a0a0 100644
--- a/ncrypt/crypt_gpgme.c
+++ b/ncrypt/crypt_gpgme.c
@@ -407,15 +407,15 @@ static bool crypt_key_is_valid(struct CryptKeyInfo *k)
  * @param key Key to test
  * @retval true Validity of key is sufficient
  */
-static int crypt_id_is_strong(struct CryptKeyInfo *key)
+static bool crypt_id_is_strong(struct CryptKeyInfo *key)
 {
   if (!key)
-    return 0;
+    return false;
 
-  unsigned int is_strong = 0;
+  bool is_strong = false;
 
   if ((key->flags & KEYFLAG_ISX509))
-    return 1;
+    return true;
 
   switch (key->validity)
   {
@@ -423,12 +423,12 @@ static int crypt_id_is_strong(struct CryptKeyInfo *key)
     case GPGME_VALIDITY_NEVER:
     case GPGME_VALIDITY_UNDEFINED:
     case GPGME_VALIDITY_UNKNOWN:
-      is_strong = 0;
+      is_strong = false;
       break;
 
     case GPGME_VALIDITY_FULL:
     case GPGME_VALIDITY_ULTIMATE:
-      is_strong = 1;
+      is_strong = true;
       break;
   }
 
@@ -544,10 +544,10 @@ static gpgme_data_t create_gpgme_data(void)
 /**
  * body_to_data_object - Create GPGME object from the mail body
  * @param a       Body to use
- * @param convert If trye, lines are converted to CR-LF if required
+ * @param convert If true, lines are converted to CR-LF if required
  * @retval ptr Newly created GPGME data object
  */
-static gpgme_data_t body_to_data_object(struct Body *a, int convert)
+static gpgme_data_t body_to_data_object(struct Body *a, bool convert)
 {
   char tempfile[PATH_MAX];
   int err = 0;
@@ -1036,7 +1036,7 @@ static struct Body *sign_message(struct Body *a, bool use_smime)
 
   crypt_convert_to_7bit(a); /* Signed data _must_ be in 7-bit format. */
 
-  message = body_to_data_object(a, 1);
+  message = body_to_data_object(a, true);
   if (!message)
     return NULL;
   signature = create_gpgme_data();
@@ -1170,7 +1170,7 @@ struct Body *pgp_gpgme_encrypt_message(struct Body *a, char *keylist, bool sign)
 
   if (sign)
     crypt_convert_to_7bit(a);
-  gpgme_data_t plaintext = body_to_data_object(a, 0);
+  gpgme_data_t plaintext = body_to_data_object(a, false);
   if (!plaintext)
   {
     free_recipient_set(&rset);
@@ -1225,7 +1225,7 @@ struct Body *smime_gpgme_build_smime_entity(struct Body *a, char *keylist)
    * clients depend on this for signed+encrypted messages: they do not
    * convert line endings between decrypting and checking the
    * signature.  See #3904. */
-  gpgme_data_t plaintext = body_to_data_object(a, 1);
+  gpgme_data_t plaintext = body_to_data_object(a, true);
   if (!plaintext)
   {
     free_recipient_set(&rset);
@@ -2353,8 +2353,8 @@ static int pgp_check_traditional_one_body(FILE *fp, struct Body *b)
   char buf[HUGE_STRING];
   FILE *tfp = NULL;
 
-  short sgn = 0;
-  short enc = 0;
+  bool sgn = false;
+  bool enc = false;
 
   if (b->type != TYPE_TEXT)
     return 0;
@@ -2379,12 +2379,12 @@ static int pgp_check_traditional_one_body(FILE *fp, struct Body *b)
     {
       if (MESSAGE(buf + 15))
       {
-        enc = 1;
+        enc = true;
         break;
       }
       else if (SIGNED_MESSAGE(buf + 15))
       {
-        sgn = 1;
+        sgn = true;
         break;
       }
     }
diff --git a/ncrypt/pgp.c b/ncrypt/pgp.c
index 27c704426..29244a4f4 100644
--- a/ncrypt/pgp.c
+++ b/ncrypt/pgp.c
@@ -781,9 +781,9 @@ static int pgp_check_traditional_one_body(FILE *fp, struct Body *b)
   char buf[HUGE_STRING];
   FILE *tfp = NULL;
 
-  short sgn = 0;
-  short enc = 0;
-  short key = 0;
+  bool sgn = false;
+  bool enc = false;
+  bool key = false;
 
   if (b->type != TYPE_TEXT)
     return 0;
@@ -807,11 +807,11 @@ static int pgp_check_traditional_one_body(FILE *fp, struct Body *b)
     if (mutt_str_strncmp("-----BEGIN PGP ", buf, 15) == 0)
     {
       if (mutt_str_strcmp("MESSAGE-----\n", buf + 15) == 0)
-        enc = 1;
+        enc = true;
       else if (mutt_str_strcmp("SIGNED MESSAGE-----\n", buf + 15) == 0)
-        sgn = 1;
+        sgn = true;
       else if (mutt_str_strcmp("PUBLIC KEY BLOCK-----\n", buf + 15) == 0)
-        key = 1;
+        key = true;
     }
   }
   mutt_file_fclose(&tfp);
diff --git a/nntp/newsrc.c b/nntp/newsrc.c
index 85e599159..93bf564f0 100644
--- a/nntp/newsrc.c
+++ b/nntp/newsrc.c
@@ -332,7 +332,7 @@ void nntp_newsrc_gen_entries(struct Context *ctx)
   {
     save_sort = Sort;
     Sort = SORT_ORDER;
-    mutt_sort_headers(ctx, 0);
+    mutt_sort_headers(ctx, false);
   }
 
   entries = nntp_data->newsrc_len;
@@ -397,7 +397,7 @@ void nntp_newsrc_gen_entries(struct Context *ctx)
   if (save_sort != Sort)
   {
     Sort = save_sort;
-    mutt_sort_headers(ctx, 0);
+    mutt_sort_headers(ctx, false);
   }
 }
 
diff --git a/pattern.c b/pattern.c
index 7265e939a..e312d57c4 100644
--- a/pattern.c
+++ b/pattern.c
@@ -957,12 +957,12 @@ static int patmatch(const struct Pattern *pat, const char *buf)
  * @param ctx   Mailbox
  * @param pat   Pattern to find
  * @param msgno Message to search
- * @retval 1 Pattern found
- * @retval 0 Error or pattern not found
+ * @retval true Pattern found
+ * @retval false Error or pattern not found
  */
-static int msg_search(struct Context *ctx, struct Pattern *pat, int msgno)
+static bool msg_search(struct Context *ctx, struct Pattern *pat, int msgno)
 {
-  int match = 0;
+  bool match = false;
   struct Message *msg = mx_msg_open(ctx, msgno);
   if (!msg)
   {
@@ -990,14 +990,14 @@ static int msg_search(struct Context *ctx, struct Pattern *pat, int msgno)
     if (!s.fpout)
     {
       mutt_perror(_("Error opening 'memory stream'"));
-      return 0;
+      return false;
     }
 #else
     s.fpout = mutt_file_mkstemp();
     if (!s.fpout)
     {
       mutt_perror(_("Can't create temporary file"));
-      return 0;
+      return false;
     }
 #endif
 
@@ -1018,7 +1018,7 @@ static int msg_search(struct Context *ctx, struct Pattern *pat, int msgno)
           FREE(&temp);
 #endif
         }
-        return 0;
+        return false;
       }
 
       fseeko(msg->fp, h->offset, SEEK_SET);
@@ -1035,7 +1035,7 @@ static int msg_search(struct Context *ctx, struct Pattern *pat, int msgno)
       if (!fp)
       {
         mutt_perror(_("Error re-opening 'memory stream'"));
-        return 0;
+        return false;
       }
     }
     else
@@ -1044,7 +1044,7 @@ static int msg_search(struct Context *ctx, struct Pattern *pat, int msgno)
       if (!fp)
       {
         mutt_perror(_("Error opening /dev/null"));
-        return 0;
+        return false;
       }
     }
 #else
@@ -1088,7 +1088,7 @@ static int msg_search(struct Context *ctx, struct Pattern *pat, int msgno)
       break; /* don't loop forever */
     if (patmatch(pat, buf) == 0)
     {
-      match = 1;
+      match = true;
       break;
     }
     lng -= mutt_str_strlen(buf);
diff --git a/postpone.c b/postpone.c
index 9420373ab..d68e5568a 100644
--- a/postpone.c
+++ b/postpone.c
@@ -77,11 +77,11 @@ static short UpdateNumPostponed = 0;
 /**
  * mutt_num_postponed - Return the number of postponed messages
  * @param force
- * * 0 Use a cached value if costly to get a fresh count (IMAP)
- * * 1 Force check
+ * * false Use a cached value if costly to get a fresh count (IMAP)
+ * * true Force check
  * @retval num Postponed messages
  */
-int mutt_num_postponed(int force)
+int mutt_num_postponed(bool force)
 {
   struct stat st;
   struct Context ctx;
@@ -92,7 +92,7 @@ int mutt_num_postponed(int force)
   if (UpdateNumPostponed)
   {
     UpdateNumPostponed = 0;
-    force = 1;
+    force = true;
   }
 
   if (mutt_str_strcmp(Postponed, OldPostponed) != 0)
@@ -100,7 +100,7 @@ int mutt_num_postponed(int force)
     FREE(&OldPostponed);
     OldPostponed = mutt_str_strdup(Postponed);
     LastModify = 0;
-    force = 1;
+    force = true;
   }
 
   if (!Postponed)
@@ -114,7 +114,7 @@ int mutt_num_postponed(int force)
     {
       short newpc;
 
-      newpc = imap_status(Postponed, 0);
+      newpc = imap_status(Postponed, false);
       if (newpc >= 0)
       {
         PostCount = newpc;
diff --git a/protos.h b/protos.h
index 5b4aa6df2..dcff4cb86 100644
--- a/protos.h
+++ b/protos.h
@@ -60,11 +60,11 @@ int mutt_edit_message(struct Context *ctx, struct Header *hdr);
 int mutt_view_message(struct Context *ctx, struct Header *hdr);
 int mutt_prepare_template(FILE *fp, struct Context *ctx, struct Header *newhdr, struct Header *hdr, bool resend);
 int mutt_enter_string(char *buf, size_t buflen, int col, int flags);
-int mutt_enter_string_full(char *buf, size_t buflen, int col, int flags, int multiple,
+int mutt_enter_string_full(char *buf, size_t buflen, int col, int flags, bool multiple,
                        char ***files, int *numfiles, struct EnterState *state);
 int mutt_get_postponed(struct Context *ctx, struct Header *hdr, struct Header **cur, char *fcc, size_t fcclen);
 int mutt_parse_crypt_hdr(const char *p, int set_empty_signas, int crypt_app);
-int mutt_num_postponed(int force);
+int mutt_num_postponed(bool force);
 int mutt_thread_set_flag(struct Header *hdr, int flag, int bf, int subthread);
 void mutt_update_num_postponed(void);
 int url_parse_mailto(struct Envelope *e, char **body, const char *src);
diff --git a/send.c b/send.c
index 0032499c1..17e81d616 100644
--- a/send.c
+++ b/send.c
@@ -1554,7 +1554,7 @@ int ci_send_message(int flags, struct Header *msg, char *tempfile,
     OptNewsSend = false;
 #endif
 
-  if (!flags && !msg && Recall != MUTT_NO && mutt_num_postponed(1))
+  if (!flags && !msg && Recall != MUTT_NO && mutt_num_postponed(true))
   {
     /* If the user is composing a new message, check to see if there
      * are any postponed messages first.
diff --git a/sendlib.c b/sendlib.c
index 29d2d0126..c1b81d761 100644
--- a/sendlib.c
+++ b/sendlib.c
@@ -3129,7 +3129,7 @@ struct Address *mutt_remove_duplicates(struct Address *addr)
  * @param b    Body of email
  * @param flag If true, set the flag, otherwise remove it
  */
-static void set_noconv_flags(struct Body *b, short flag)
+static void set_noconv_flags(struct Body *b, bool flag)
 {
   for (; b; b = b->next)
   {
@@ -3217,7 +3217,7 @@ int mutt_write_fcc(const char *path, struct Header *hdr, const char *msgid,
   int onm_flags;
 
   if (post)
-    set_noconv_flags(hdr->content, 1);
+    set_noconv_flags(hdr->content, true);
 
 #ifdef RECORD_FOLDER_HOOK
   mutt_folder_hook(path);
@@ -3409,7 +3409,7 @@ int mutt_write_fcc(const char *path, struct Header *hdr, const char *msgid,
     mutt_mailbox_cleanup(path, &st);
 
   if (post)
-    set_noconv_flags(hdr->content, 0);
+    set_noconv_flags(hdr->content, false);
 
 done:
 #ifdef RECORD_FOLDER_HOOK
diff --git a/sort.c b/sort.c
index e279ce07d..4d4eb42ab 100644
--- a/sort.c
+++ b/sort.c
@@ -351,7 +351,7 @@ sort_t *mutt_get_sort_func(int method)
  * @param ctx  Mailbox
  * @param init If true, rebuild the thread
  */
-void mutt_sort_headers(struct Context *ctx, int init)
+void mutt_sort_headers(struct Context *ctx, bool init)
 {
   struct Header *h = NULL;
   struct MuttThread *thread = NULL, *top = NULL;
@@ -386,7 +386,7 @@ void mutt_sort_headers(struct Context *ctx, int init)
   if (OptResortInit)
   {
     OptResortInit = false;
-    init = 1;
+    init = true;
   }
 
   if (init && ctx->tree)
diff --git a/sort.h b/sort.h
index e6edd7b88..20aa8a8bc 100644
--- a/sort.h
+++ b/sort.h
@@ -48,7 +48,7 @@ typedef int sort_t(const void *a, const void *b);
 
 sort_t *mutt_get_sort_func(int method);
 
-void mutt_sort_headers(struct Context *ctx, int init);
+void mutt_sort_headers(struct Context *ctx, bool init);
 int perform_auxsort(int retval, const void *a, const void *b);
 
 extern const struct Mapping SortMethods[];
diff --git a/status.c b/status.c
index de2473931..ca69d04d3 100644
--- a/status.c
+++ b/status.c
@@ -230,7 +230,7 @@ static const char *status_format_str(char *buf, size_t buflen, size_t col, int c
       break;
 
     case 'p':
-      count = mutt_num_postponed(0);
+      count = mutt_num_postponed(false);
       if (!optional)
       {
         snprintf(fmt, sizeof(fmt), "%%%sd", prec);

