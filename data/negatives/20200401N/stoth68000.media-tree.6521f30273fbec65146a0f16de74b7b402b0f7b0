commit 6521f30273fbec65146a0f16de74b7b402b0f7b0
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Sun Aug 6 20:28:44 2006 +1000

    [CRYPTO] api: Add crypto_alg reference counting
    
    Up until now we've relied on module reference counting to ensure that the
    crypto_alg structures don't disappear from under us.  This was good enough
    as long as each crypto_alg came from exactly one module.
    
    However, with parameterised crypto algorithms a crypto_alg object may need
    two or more modules to operate.  This means that we need to count the
    references to the crypto_alg object directly.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/crypto/api.c b/crypto/api.c
index 8c2743a05f90..5994a58ef954 100644
--- a/crypto/api.c
+++ b/crypto/api.c
@@ -29,13 +29,26 @@
 LIST_HEAD(crypto_alg_list);
 DECLARE_RWSEM(crypto_alg_sem);
 
-static inline int crypto_mod_get(struct crypto_alg *alg)
+static inline struct crypto_alg *crypto_alg_get(struct crypto_alg *alg)
 {
-	return try_module_get(alg->cra_module);
+	atomic_inc(&alg->cra_refcnt);
+	return alg;
+}
+
+static inline void crypto_alg_put(struct crypto_alg *alg)
+{
+	if (atomic_dec_and_test(&alg->cra_refcnt) && alg->cra_destroy)
+		alg->cra_destroy(alg);
+}
+
+static struct crypto_alg *crypto_mod_get(struct crypto_alg *alg)
+{
+	return try_module_get(alg->cra_module) ? crypto_alg_get(alg) : NULL;
 }
 
-static inline void crypto_mod_put(struct crypto_alg *alg)
+static void crypto_mod_put(struct crypto_alg *alg)
 {
+	crypto_alg_put(alg);
 	module_put(alg->cra_module);
 }
 
@@ -274,6 +287,7 @@ int crypto_register_alg(struct crypto_alg *alg)
 	}
 	
 	list_add(&alg->cra_list, &crypto_alg_list);
+	atomic_set(&alg->cra_refcnt, 1);
 out:	
 	up_write(&crypto_alg_sem);
 	return ret;
@@ -284,8 +298,6 @@ int crypto_unregister_alg(struct crypto_alg *alg)
 	int ret = -ENOENT;
 	struct crypto_alg *q;
 	
-	BUG_ON(!alg->cra_module);
-	
 	down_write(&crypto_alg_sem);
 	list_for_each_entry(q, &crypto_alg_list, cra_list) {
 		if (alg == q) {
@@ -296,7 +308,15 @@ int crypto_unregister_alg(struct crypto_alg *alg)
 	}
 out:	
 	up_write(&crypto_alg_sem);
-	return ret;
+
+	if (ret)
+		return ret;
+
+	BUG_ON(atomic_read(&alg->cra_refcnt) != 1);
+	if (alg->cra_destroy)
+		alg->cra_destroy(alg);
+
+	return 0;
 }
 
 int crypto_alg_available(const char *name, u32 flags)
diff --git a/crypto/proc.c b/crypto/proc.c
index c0a5dd7ce2cc..8543b7a157d6 100644
--- a/crypto/proc.c
+++ b/crypto/proc.c
@@ -12,6 +12,8 @@
  * any later version.
  *
  */
+
+#include <asm/atomic.h>
 #include <linux/init.h>
 #include <linux/crypto.h>
 #include <linux/rwsem.h>
@@ -54,6 +56,7 @@ static int c_show(struct seq_file *m, void *p)
 	seq_printf(m, "driver       : %s\n", alg->cra_driver_name);
 	seq_printf(m, "module       : %s\n", module_name(alg->cra_module));
 	seq_printf(m, "priority     : %d\n", alg->cra_priority);
+	seq_printf(m, "refcnt       : %d\n", atomic_read(&alg->cra_refcnt));
 	
 	switch (alg->cra_flags & CRYPTO_ALG_TYPE_MASK) {
 	case CRYPTO_ALG_TYPE_CIPHER:
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
index cb1e6631b132..7f57ff8ec975 100644
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -17,6 +17,7 @@
 #ifndef _LINUX_CRYPTO_H
 #define _LINUX_CRYPTO_H
 
+#include <asm/atomic.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
@@ -148,6 +149,7 @@ struct crypto_alg {
 	unsigned int cra_alignmask;
 
 	int cra_priority;
+	atomic_t cra_refcnt;
 
 	char cra_name[CRYPTO_MAX_ALG_NAME];
 	char cra_driver_name[CRYPTO_MAX_ALG_NAME];
@@ -160,6 +162,7 @@ struct crypto_alg {
 
 	int (*cra_init)(struct crypto_tfm *tfm);
 	void (*cra_exit)(struct crypto_tfm *tfm);
+	void (*cra_destroy)(struct crypto_alg *alg);
 	
 	struct module *cra_module;
 };

