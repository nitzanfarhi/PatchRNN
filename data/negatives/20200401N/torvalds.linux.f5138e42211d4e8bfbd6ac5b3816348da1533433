commit f5138e42211d4e8bfbd6ac5b3816348da1533433
Author: Michael Holzheu <holzheu@linux.vnet.ibm.com>
Date:   Thu Jan 12 17:20:23 2012 -0800

    kdump: add udev events for memory online/offline
    
    Currently no udev events for memory hotplug "online" and "offline" are
    generated:
    
      # udevadm monitor
      # echo offline > /sys/devices/system/memory/memory4/state
      ==> No event
    
    When kdump is loaded, kexec detects the current memory configuration and
    stores it in the pre-allocated ELF core header.  Therefore, for kdump it
    is necessary to reload the kdump kernel with kexec when the memory
    configuration changes (e.g.  for online/offline hotplug memory).
    
    In order to do this automatically, udev rules should be used.  This kernel
    patch adds udev events for "online" and "offline".  Together with this
    kernel patch, the following udev rules for online/offline have to be added
    to "/etc/udev/rules.d/98-kexec.rules":
    
      SUBSYSTEM=="memory", ACTION=="online", PROGRAM="/etc/init.d/kdump restart"
      SUBSYSTEM=="memory", ACTION=="offline", PROGRAM="/etc/init.d/kdump restart"
    
    [sfr@canb.auug.org.au: fixups for class to subsystem conversion]
    Signed-off-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Vivek Goyal <vgoyal@redhat.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Dave Hansen <haveblue@us.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/base/memory.c b/drivers/base/memory.c
index f17e3ea041c0..ed5de58c340f 100644
--- a/drivers/base/memory.c
+++ b/drivers/base/memory.c
@@ -295,11 +295,22 @@ static int memory_block_change_state(struct memory_block *mem,
 
 	ret = memory_block_action(mem->start_section_nr, to_state);
 
-	if (ret)
+	if (ret) {
 		mem->state = from_state_req;
-	else
-		mem->state = to_state;
+		goto out;
+	}
 
+	mem->state = to_state;
+	switch (mem->state) {
+	case MEM_OFFLINE:
+		kobject_uevent(&mem->dev.kobj, KOBJ_OFFLINE);
+		break;
+	case MEM_ONLINE:
+		kobject_uevent(&mem->dev.kobj, KOBJ_ONLINE);
+		break;
+	default:
+		break;
+	}
 out:
 	mutex_unlock(&mem->state_mutex);
 	return ret;

