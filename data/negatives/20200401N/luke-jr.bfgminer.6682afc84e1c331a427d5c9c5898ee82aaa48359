commit 6682afc84e1c331a427d5c9c5898ee82aaa48359
Author: Luke Dashjr <luke-jr+git@utopios.org>
Date:   Sat Nov 2 21:36:14 2013 +0000

    bitfury: Clean up by making private functions static, and naming public ones with [lib]bitfury_ prefix

diff --git a/driver-bfsb.c b/driver-bfsb.c
index f6c38d2c..737c3921 100644
--- a/driver-bfsb.c
+++ b/driver-bfsb.c
@@ -146,7 +146,7 @@ bool bfsb_init(struct thr_info *thr)
 		bitfury->spi->cgpu = proc;
 		bitfury_init_chip(proc);
 		bitfury->osc6_bits = 53;
-		send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
+		bitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
 		bitfury_init_freq_stat(&bitfury->chip_stat, 52, 56);
 		
 		if (proc->proc_id == proc->procs - 1)
@@ -165,7 +165,7 @@ void bfsb_disable(struct thr_info * const thr)
 	struct bitfury_device * const bitfury = proc->device_data;
 	
 	applog(LOG_DEBUG, "%"PRIpreprv": Shutting down chip (disable)", proc->proc_repr);
-	send_shutdown(bitfury->spi, bitfury->slot, bitfury->fasync);
+	bitfury_send_shutdown(bitfury->spi, bitfury->slot, bitfury->fasync);
 }
 
 static
@@ -175,7 +175,7 @@ void bfsb_enable(struct thr_info * const thr)
 	struct bitfury_device * const bitfury = proc->device_data;
 	
 	applog(LOG_DEBUG, "%"PRIpreprv": Reinitialising chip (enable)", proc->proc_repr);
-	send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
+	bitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
 	bitfury_init_chip(proc);
 }
 
diff --git a/driver-bitfury.c b/driver-bitfury.c
index 87c35ae0..80e71cee 100644
--- a/driver-bitfury.c
+++ b/driver-bitfury.c
@@ -173,7 +173,7 @@ bool bitfury_init_chip(struct cgpu_info * const proc)
 		.ntime = 0xb6c24563,
 		.nbits = 0x6dfa4352,
 	};
-	payload_to_atrvec(bitfury->atrvec, &payload);
+	bitfury_payload_to_atrvec(bitfury->atrvec, &payload);
 	return bitfury_init_oldbuf(proc, NULL);
 }
 
@@ -192,7 +192,7 @@ bool bitfury_init(struct thr_info *thr)
 		};
 		bitfury_init_chip(proc);
 		bitfury->osc6_bits = 50;
-		send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
+		bitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
 	}
 	
 	timer_set_now(&thr->tv_poll);
@@ -208,7 +208,7 @@ void bitfury_shutdown(struct thr_info *thr) {
 	for (proc = cgpu; proc; proc = proc->next_proc)
 	{
 		bitfury = proc->device_data;
-		send_shutdown(bitfury->spi, bitfury->slot, bitfury->fasync);
+		bitfury_send_shutdown(bitfury->spi, bitfury->slot, bitfury->fasync);
 	}
 }
 
@@ -224,8 +224,8 @@ bool bitfury_job_prepare(struct thr_info *thr, struct work *work, __maybe_unused
 		applog(LOG_DEBUG, "%"PRIpreprv": Preparing work %s",
 		       proc->proc_repr, hex);
 	}
-	work_to_payload(&bitfury->payload, work);
-	payload_to_atrvec(bitfury->atrvec, &bitfury->payload);
+	work_to_bitfury_payload(&bitfury->payload, work);
+	bitfury_payload_to_atrvec(bitfury->atrvec, &bitfury->payload);
 	
 	work->blk.nonce = 0xffffffff;
 	return true;
@@ -277,7 +277,8 @@ void bitfury_clean_freq_stat(struct freq_stat * const c)
 
 typedef uint32_t bitfury_inp_t[0x11];
 
-int select_freq(struct bitfury_device *bitfury, struct cgpu_info *proc) {
+static
+int bitfury_select_freq(struct bitfury_device *bitfury, struct cgpu_info *proc) {
 	int freq;
 	int random;
 	int i;
@@ -319,7 +320,7 @@ int select_freq(struct bitfury_device *bitfury, struct cgpu_info *proc) {
 	applog(LOG_DEBUG, "%"PRIpreprv": Changing osc6_bits to %d",
 	       proc->proc_repr, freq);
 	bitfury->osc6_bits = freq;
-	send_freq(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
+	bitfury_send_freq(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
 	return 0;
 }
 
@@ -446,7 +447,7 @@ void bitfury_do_io(struct thr_info * const master_thr)
 				inc_hw_errors2(thr, NULL, NULL);
 				applog(LOG_DEBUG, "%"PRIpreprv": Full result match, reinitialising",
 				       proc->proc_repr);
-				send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
+				bitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
 				bitfury->desync_counter = 99;
 				goto out;
 			}
@@ -511,7 +512,7 @@ void bitfury_do_io(struct thr_info * const master_thr)
 				
 				// Change freq;
 				if (!c->best_done) {
-					select_freq(bitfury, proc);
+					bitfury_select_freq(bitfury, proc);
 				} else {
 					applog(LOG_DEBUG, "%"PRIpreprv": Stable freq, osc6_bits: %d",
 					       proc->proc_repr, bitfury->osc6_bits);
@@ -551,7 +552,7 @@ void bitfury_do_io(struct thr_info * const master_thr)
 					{
 						applog(LOG_WARNING, "%"PRIpreprv": %d of the last %d results were bad, reinitialising",
 						       proc->proc_repr, bitfury->sample_hwe, bitfury->sample_tot);
-						send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
+						bitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
 						bitfury->desync_counter = 99;
 					}
 					bitfury->sample_tot = bitfury->sample_hwe = 0;
@@ -569,7 +570,7 @@ out:
 		{
 			applog(LOG_DEBUG, "%"PRIpreprv": Forcing reinitialisation",
 			       proc->proc_repr);
-			send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
+			bitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
 			bitfury->desync_counter = 99;
 			bitfury->force_reinit = false;
 		}
diff --git a/driver-littlefury.c b/driver-littlefury.c
index 6b5770fa..22099eac 100644
--- a/driver-littlefury.c
+++ b/driver-littlefury.c
@@ -361,7 +361,7 @@ void littlefury_disable(struct thr_info * const thr)
 	struct bitfury_device * const bitfury = proc->device_data;
 	struct cgpu_info * const dev = proc->device;
 	
-	send_shutdown(bitfury->spi, 0, bitfury->fasync);
+	bitfury_send_shutdown(bitfury->spi, 0, bitfury->fasync);
 	
 	// If all chips disabled, kill power and close device
 	bool any_running = false;
@@ -438,7 +438,7 @@ void littlefury_poll(struct thr_info * const master_thr)
 		for (proc = dev; proc; proc = proc->next_proc)
 		{
 			struct bitfury_device * const bitfury = proc->device_data;
-			send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
+			bitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
 			bitfury_init_chip(proc);
 		}
 	}
diff --git a/driver-metabank.c b/driver-metabank.c
index 0e255377..15df4fca 100644
--- a/driver-metabank.c
+++ b/driver-metabank.c
@@ -160,7 +160,7 @@ bool metabank_init(struct thr_info *thr)
 		bitfury->spi->cgpu = proc;
 		bitfury_init_chip(proc);
 		bitfury->osc6_bits = 53;
-		send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
+		bitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
 		bitfury_init_freq_stat(&bitfury->chip_stat, 52, 56);
 		
 		if (proc->proc_id == proc->procs - 1)
diff --git a/driver-nanofury.c b/driver-nanofury.c
index 38799747..ee3f7677 100644
--- a/driver-nanofury.c
+++ b/driver-nanofury.c
@@ -274,7 +274,7 @@ bool nanofury_init(struct thr_info * const thr)
 	};
 	cgpu->device_data = bitfury;
 	bitfury->osc6_bits = 50;
-	send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
+	bitfury_send_reinit(bitfury->spi, bitfury->slot, bitfury->fasync, bitfury->osc6_bits);
 	bitfury_init_chip(cgpu);
 	
 	timer_set_now(&thr->tv_poll);
diff --git a/libbitfury.c b/libbitfury.c
index 8cc481b2..5fe3ce4a 100644
--- a/libbitfury.c
+++ b/libbitfury.c
@@ -45,7 +45,8 @@
 unsigned bitfury_decnonce(unsigned in);
 
 /* Configuration registers - control oscillators and such stuff. PROGRAMMED when magic number is matches, UNPROGRAMMED (default) otherwise */
-void config_reg(struct spi_port *port, int cfgreg, int ena)
+static
+void bitfury_config_reg(struct spi_port *port, int cfgreg, int ena)
 {
 	static const uint8_t enaconf[4] = { 0xc1, 0x6a, 0x59, 0xe3 };
 	static const uint8_t disconf[4] = { 0, 0, 0, 0 };
@@ -56,7 +57,8 @@ void config_reg(struct spi_port *port, int cfgreg, int ena)
 
 #define FIRST_BASE 61
 #define SECOND_BASE 4
-const int8_t counters[16] = { 64, 64,
+static
+const int8_t bitfury_counters[16] = { 64, 64,
 	SECOND_BASE, SECOND_BASE+4, SECOND_BASE+2, SECOND_BASE+2+16, SECOND_BASE, SECOND_BASE+1,
 	(FIRST_BASE)%65,  (FIRST_BASE+1)%65,  (FIRST_BASE+3)%65, (FIRST_BASE+3+16)%65, (FIRST_BASE+4)%65, (FIRST_BASE+4+4)%65, (FIRST_BASE+3+3)%65, (FIRST_BASE+3+1+3)%65};
 
@@ -89,7 +91,8 @@ static const unsigned SHA_K[64] = {
 
 
 
-void ms3_compute(unsigned *p)
+static
+void libbitfury_ms3_compute(unsigned *p)
 {
 	unsigned a,b,c,d,e,f,g,h, ne, na,  i;
 
@@ -105,18 +108,20 @@ void ms3_compute(unsigned *p)
 	p[15] = a; p[14] = b; p[13] = c; p[12] = d; p[11] = e; p[10] = f; p[9] = g; p[8] = h;
 }
 
-void send_conf(struct spi_port *port) {
+static
+void bitfury_send_conf(struct spi_port *port) {
 	int i;
 	for (i = 7; i <= 11; ++i)
-		config_reg(port, i, 0);
-	config_reg(port, 6, 0); /* disable OUTSLK */
-	config_reg(port, 4, 1); /* Enable slow oscillator */
+		bitfury_config_reg(port, i, 0);
+	bitfury_config_reg(port, 6, 0); /* disable OUTSLK */
+	bitfury_config_reg(port, 4, 1); /* Enable slow oscillator */
 	for (i = 1; i <= 3; ++i)
-		config_reg(port, i, 0);
-	spi_emit_data(port, 0x0100, counters, 16); /* Program counters correctly for rounds processing, here baby should start consuming power */
+		bitfury_config_reg(port, i, 0);
+	spi_emit_data(port, 0x0100, bitfury_counters, 16); /* Program counters correctly for rounds processing, here baby should start consuming power */
 }
 
-void send_init(struct spi_port *port) {
+static
+void bitfury_send_init(struct spi_port *port) {
 	/* Prepare internal buffers */
 	/* PREPARE BUFFERS (INITIAL PROGRAMMING) */
 	unsigned w[16];
@@ -126,7 +131,7 @@ void send_init(struct spi_port *port) {
 		0x8a0bb7b7, 0x33af304f, 0x0b290c1a, 0xf0c4e61f, /* WDATA: hashMerleRoot[7], nTime, nBits, nNonce */
 	};
 
-	ms3_compute(&atrvec[0]);
+	libbitfury_ms3_compute(&atrvec[0]);
 	memset(&w, 0, sizeof(w)); w[3] = 0xffffffff; w[4] = 0x80000000; w[15] = 0x00000280;
 	spi_emit_data(port, 0x1000, w, 16*4);
 	spi_emit_data(port, 0x1400, w,  8*4);
@@ -135,47 +140,50 @@ void send_init(struct spi_port *port) {
 	spi_emit_data(port, 0x3000, &atrvec[0], 19*4);
 }
 
-void set_freq(struct spi_port *port, int bits) {
+static
+void bitfury_set_freq(struct spi_port *port, int bits) {
 	uint64_t freq;
 	const uint8_t *
 	osc6 = (unsigned char *)&freq;
 	freq = (1ULL << bits) - 1ULL;
 
 	spi_emit_data(port, 0x6000, osc6, 8); /* Program internal on-die slow oscillator frequency */
-	config_reg(port, 4, 1); /* Enable slow oscillator */
+	bitfury_config_reg(port, 4, 1); /* Enable slow oscillator */
 }
 
-void send_reinit(struct spi_port *port, int slot, int chip_n, int n) {
+void bitfury_send_reinit(struct spi_port *port, int slot, int chip_n, int n) {
 	spi_clear_buf(port);
 	spi_emit_break(port);
 	spi_emit_fasync(port, chip_n);
-	set_freq(port, n);
-	send_conf(port);
-	send_init(port);
+	bitfury_set_freq(port, n);
+	bitfury_send_conf(port);
+	bitfury_send_init(port);
 	spi_txrx(port);
 }
 
-void send_shutdown(struct spi_port *port, int slot, int chip_n) {
+void bitfury_send_shutdown(struct spi_port *port, int slot, int chip_n) {
 	spi_clear_buf(port);
 	spi_emit_break(port);
 	spi_emit_fasync(port, chip_n);
-	config_reg(port, 4, 0); /* Disable slow oscillator */
+	bitfury_config_reg(port, 4, 0); /* Disable slow oscillator */
 	spi_txrx(port);
 }
 
-void send_freq(struct spi_port *port, int slot, int chip_n, int bits) {
+void bitfury_send_freq(struct spi_port *port, int slot, int chip_n, int bits) {
 	spi_clear_buf(port);
 	spi_emit_break(port);
 	spi_emit_fasync(port, chip_n);
-	set_freq(port, bits);
+	bitfury_set_freq(port, bits);
 	spi_txrx(port);
 }
 
-unsigned int c_diff(unsigned ocounter, unsigned counter) {
+static
+unsigned int libbitfury_c_diff(unsigned ocounter, unsigned counter) {
 	return counter >  ocounter ? counter - ocounter : (0x003FFFFF - ocounter) + counter;
 }
 
-int get_counter(unsigned int *newbuf, unsigned int *oldbuf) {
+static
+int libbitfury_get_counter(unsigned int *newbuf, unsigned int *oldbuf) {
 	int j;
 	for(j = 0; j < 16; j++) {
 		if (newbuf[j] != oldbuf[j]) {
@@ -189,7 +197,8 @@ int get_counter(unsigned int *newbuf, unsigned int *oldbuf) {
 	return 0;
 }
 
-int detect_chip(struct spi_port *port, int chip_n) {
+static
+int libbitfury_detect_chip(struct spi_port *port, int chip_n) {
 	/* Test vectors to calculate (using address-translated loads) */
 	unsigned atrvec[] = {
 		0xb0e72d8e, 0x1dc5b862, 0xe9e7c4a6, 0x3050f1f5, 0x8a1a6b7e, 0x7ec384e8, 0x42c1c3fc, 0x8ed158a1, /* MIDSTATE */
@@ -220,17 +229,17 @@ int detect_chip(struct spi_port *port, int chip_n) {
 	memset(newbuf, 0, 17 * 4);
 	memset(oldbuf, 0, 17 * 4);
 
-	ms3_compute(&atrvec[0]);
-	ms3_compute(&atrvec[20]);
-	ms3_compute(&atrvec[40]);
+	libbitfury_ms3_compute(&atrvec[0]);
+	libbitfury_ms3_compute(&atrvec[20]);
+	libbitfury_ms3_compute(&atrvec[40]);
 
 
 	spi_clear_buf(port);
 	spi_emit_break(port); /* First we want to break chain! Otherwise we'll get all of traffic bounced to output */
 	spi_emit_fasync(port, chip_n);
-	set_freq(port, 52);  //54 - 3F, 53 - 1F
-	send_conf(port);
-	send_init(port);
+	bitfury_set_freq(port, 52);  //54 - 3F, 53 - 1F
+	bitfury_send_conf(port);
+	bitfury_send_init(port);
 	spi_txrx(port);
 
 	ocounter = 0;
@@ -244,9 +253,9 @@ int detect_chip(struct spi_port *port, int chip_n) {
 		spi_txrx(port);
 		memcpy(newbuf, spi_getrxbuf(port) + 4 + chip_n, 17*4);
 
-		counter = get_counter(newbuf, oldbuf);
+		counter = libbitfury_get_counter(newbuf, oldbuf);
 		if (ocounter) {
-			unsigned int cdiff = c_diff(ocounter, counter);
+			unsigned int cdiff = libbitfury_c_diff(ocounter, counter);
 
 			if (cdiff > 5000 && cdiff < 100000 && odiff > 5000 && odiff < 100000)
 				return 1;
@@ -264,7 +273,7 @@ int detect_chip(struct spi_port *port, int chip_n) {
 
 int libbitfury_detectChips1(struct spi_port *port) {
 	int n;
-	for (n = 0; detect_chip(port, n); ++n)
+	for (n = 0; libbitfury_detect_chip(port, n); ++n)
 	{}
 	return n;
 }
@@ -293,7 +302,8 @@ unsigned bitfury_decnonce(unsigned in)
 	return out;
 }
 
-int rehash(const void *midstate, const uint32_t m7, const uint32_t ntime, const uint32_t nbits, uint32_t nnonce) {
+static
+int libbitfury_rehash(const void *midstate, const uint32_t m7, const uint32_t ntime, const uint32_t nbits, uint32_t nnonce) {
 	unsigned char in[16];
 	unsigned int *in32 = (unsigned int *)in;
 	unsigned int *mid32 = (unsigned int *)midstate;
@@ -343,7 +353,7 @@ bool bitfury_fudge_nonce(const void *midstate, const uint32_t m7, const uint32_t
 	for (i = 0; i < 6; ++i)
 	{
 		nonce = *nonce_p + offsets[i];
-		if (rehash(midstate, m7, ntime, nbits, nonce))
+		if (libbitfury_rehash(midstate, m7, ntime, nbits, nonce))
 		{
 			*nonce_p = nonce;
 			return true;
@@ -352,7 +362,7 @@ bool bitfury_fudge_nonce(const void *midstate, const uint32_t m7, const uint32_t
 	return false;
 }
 
-void work_to_payload(struct bitfury_payload *p, struct work *w) {
+void work_to_bitfury_payload(struct bitfury_payload *p, struct work *w) {
 	unsigned char flipped_data[80];
 
 	memset(p, 0, sizeof(struct bitfury_payload));
@@ -364,9 +374,9 @@ void work_to_payload(struct bitfury_payload *p, struct work *w) {
 	p->nbits = bswap_32(*(unsigned *)(flipped_data + 72));
 }
 
-void payload_to_atrvec(uint32_t *atrvec, struct bitfury_payload *p)
+void bitfury_payload_to_atrvec(uint32_t *atrvec, struct bitfury_payload *p)
 {
 	/* Programming next value */
 	memcpy(atrvec, p, 20*4);
-	ms3_compute(atrvec);
+	libbitfury_ms3_compute(atrvec);
 }
diff --git a/libbitfury.h b/libbitfury.h
index fb571740..177684bb 100644
--- a/libbitfury.h
+++ b/libbitfury.h
@@ -54,11 +54,11 @@ struct bitfury_device {
 	int sample_tot;
 };
 
-void work_to_payload(struct bitfury_payload *p, struct work *w);
-extern void payload_to_atrvec(uint32_t *atrvec, struct bitfury_payload *);
-extern void send_reinit(struct spi_port *, int slot, int chip_n, int n);
-extern void send_shutdown(struct spi_port *, int slot, int chip_n);
-extern void send_freq(struct spi_port *, int slot, int chip_n, int bits);
+extern void work_to_bitfury_payload(struct bitfury_payload *, struct work *);
+extern void bitfury_payload_to_atrvec(uint32_t *atrvec, struct bitfury_payload *);
+extern void bitfury_send_reinit(struct spi_port *, int slot, int chip_n, int n);
+extern void bitfury_send_shutdown(struct spi_port *, int slot, int chip_n);
+extern void bitfury_send_freq(struct spi_port *, int slot, int chip_n, int bits);
 extern int libbitfury_detectChips1(struct spi_port *);
 extern unsigned bitfury_decnonce(unsigned);
 extern bool bitfury_fudge_nonce(const void *midstate, const uint32_t m7, const uint32_t ntime, const uint32_t nbits, uint32_t *nonce_p);

