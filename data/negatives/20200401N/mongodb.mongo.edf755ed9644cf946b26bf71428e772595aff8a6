commit edf755ed9644cf946b26bf71428e772595aff8a6
Author: Eliot Horowitz <eliot@10gen.com>
Date:   Mon May 16 16:53:05 2011 -0400

    clear writeback queue if a mongos is gone for an hour SERVER-3106

diff --git a/s/d_writeback.cpp b/s/d_writeback.cpp
index 401e0aa163..70b0987d72 100644
--- a/s/d_writeback.cpp
+++ b/s/d_writeback.cpp
@@ -20,6 +20,7 @@
 
 #include "../db/commands.h"
 #include "../util/queue.h"
+#include "../util/message.h"
 
 #include "d_writeback.h"
 
@@ -33,34 +34,89 @@ namespace mongo {
     WriteBackManager writeBackManager;
 
     WriteBackManager::WriteBackManager() : _writebackQueueLock("sharding:writebackQueueLock") {
+        _cleaner.go();
     }
 
     WriteBackManager::~WriteBackManager() {
     }
 
     void WriteBackManager::queueWriteBack( const string& remote , const BSONObj& o ) {
-        getWritebackQueue( remote )->push( o );
+        getWritebackQueue( remote )->queue.push( o );
     }
 
-    BlockingQueue<BSONObj>* WriteBackManager::getWritebackQueue( const string& remote ) {
+    shared_ptr<WriteBackManager::QueueInfo> WriteBackManager::getWritebackQueue( const string& remote ) {
         scoped_lock lk ( _writebackQueueLock );
-        BlockingQueue<BSONObj>*& q = _writebackQueues[remote];
+        shared_ptr<QueueInfo>& q = _writebackQueues[remote];
         if ( ! q )
-            q = new BlockingQueue<BSONObj>();
+            q.reset( new QueueInfo() );
+        q->lastCall = Listener::getElapsedTimeMillis();
         return q;
     }
 
     bool WriteBackManager::queuesEmpty() const {
         scoped_lock lk( _writebackQueueLock );
         for ( WriteBackQueuesMap::const_iterator it = _writebackQueues.begin(); it != _writebackQueues.end(); ++it ) {
-            const BlockingQueue<BSONObj>* queue = it->second;
-            if (! queue->empty() ) {
+            const shared_ptr<QueueInfo> queue = it->second;
+            if (! queue->queue.empty() ) {
                 return false;
             }
         }
         return true;
     }
 
+    void WriteBackManager::appendStats( BSONObjBuilder& b ) const {
+        BSONObjBuilder sub;
+        long long totalQueued = 0;
+        long long now = Listener::getElapsedTimeMillis();
+        {
+            scoped_lock lk( _writebackQueueLock );
+            for ( WriteBackQueuesMap::const_iterator it = _writebackQueues.begin(); it != _writebackQueues.end(); ++it ) {
+                const shared_ptr<QueueInfo> queue = it->second;
+                
+                BSONObjBuilder t( sub.subobjStart( it->first ) );
+                t.appendNumber( "n" , queue->queue.size() );
+                t.appendNumber( "minutesSinceLastCall" , ( now - queue->lastCall ) / ( 1000 * 60 ) );
+                t.done();
+
+                totalQueued += queue->queue.size();
+            }
+        }
+        
+        b.appendBool( "hasOpsQueued" , totalQueued > 0 );
+        b.appendNumber( "totalOpsQueued" , totalQueued );
+        b.append( "queues" , sub.obj() );
+    }
+
+    bool WriteBackManager::cleanupOldQueues() {
+        long long now = Listener::getElapsedTimeMillis();
+
+        scoped_lock lk( _writebackQueueLock );
+        for ( WriteBackQueuesMap::iterator it = _writebackQueues.begin(); it != _writebackQueues.end(); ++it ) {
+            const shared_ptr<QueueInfo> queue = it->second;
+            long long sinceMinutes = ( now - queue->lastCall ) / ( 1000 * 60 );
+
+            if ( sinceMinutes < 60 ) // minutes of inactivity.  
+                continue;
+            
+            log() << "deleting queue from: " << it->first 
+                  << " of size: " << queue->queue.size() 
+                  << " after " << sinceMinutes << " inactivity" 
+                  << " (normal if any mongos has restarted)" 
+                  << endl;
+
+            _writebackQueues.erase( it );
+            return true;
+        }
+        return false;
+    }
+
+    void WriteBackManager::Cleaner::run() { 
+        while ( ! inShutdown() ) { 
+            sleepsecs( 60 );
+            while ( writeBackManager.cleanupOldQueues() );
+        }
+    }
+
     // ---------- admin commands ----------
 
     // Note, this command will block until there is something to WriteBack
@@ -88,7 +144,7 @@ namespace mongo {
             // the command issuer is blocked awaiting a response
             // we want to do return at least at every 5 minutes so sockets don't timeout
             BSONObj z;
-            if ( writeBackManager.getWritebackQueue(id.str())->blockingPop( z, 5 * 60 /* 5 minutes */ ) ) {
+            if ( writeBackManager.getWritebackQueue(id.str())->queue.blockingPop( z, 5 * 60 /* 5 minutes */ ) ) {
                 log(1) << "WriteBackCommand got : " << z << endl;
                 result.append( "data" , z );
             }
@@ -114,10 +170,11 @@ namespace mongo {
         }
 
         bool run(const string& , BSONObj& cmdObj, string& errmsg, BSONObjBuilder& result, bool) {
-            result.appendBool( "hasOpsQueued" , ! writeBackManager.queuesEmpty() );
+            writeBackManager.appendStats( result );
             return true;
         }
 
     } writeBacksQueuedCommand;
+    
 
 }  // namespace mongo
diff --git a/s/d_writeback.h b/s/d_writeback.h
index 32f5b1ca7d..0f47ee7e78 100644
--- a/s/d_writeback.h
+++ b/s/d_writeback.h
@@ -21,6 +21,7 @@
 #include "../pch.h"
 
 #include "../util/queue.h"
+#include "../util/background.h"
 
 namespace mongo {
 
@@ -32,6 +33,21 @@ namespace mongo {
      * The class is thread safe.
      */
     class WriteBackManager {
+    public:
+
+        class QueueInfo : boost::noncopyable {
+        public:
+            QueueInfo(){}
+
+            BlockingQueue<BSONObj> queue;
+            long long lastCall;   // this is ellapsed millis since startup
+        };
+
+        // a map from mongos's serverIDs to queues of "rejected" operations
+        // an operation is rejected if it targets data that does not live on this shard anymore
+        typedef map<string,shared_ptr<QueueInfo> > WriteBackQueuesMap;
+
+
     public:
         WriteBackManager();
         ~WriteBackManager();
@@ -51,22 +67,45 @@ namespace mongo {
          *
          * Gets access to server 'remote's queue, which is synchronized.
          */
-        BlockingQueue<BSONObj>* getWritebackQueue( const string& remote );
+        shared_ptr<QueueInfo> getWritebackQueue( const string& remote );
 
         /*
          * @return true if there is no operation queued for write back
          */
         bool queuesEmpty() const;
 
+        /** 
+         * appends a number of statistics
+         */
+        void appendStats( BSONObjBuilder& b ) const;
+        
+        /**
+         * removes queues that have been idle
+         * @return if something was removed
+         */
+        bool cleanupOldQueues();
+        
     private:
-        // a map from mongos's serverIDs to queues of "rejected" operations
-        // an operation is rejected if it targets data that does not live on this shard anymore
-        typedef map< string , BlockingQueue<BSONObj>* > WriteBackQueuesMap;
-
+        
         // '_writebackQueueLock' protects only the map itself, since each queue is syncrhonized.
         mutable mongo::mutex _writebackQueueLock;
         WriteBackQueuesMap _writebackQueues;
+        
+        /**
+         * this background job cleans out writeback queues that have been dead 
+         * for a long time
+         */
+        class Cleaner : public BackgroundJob {
+        public:
+            Cleaner(){}
+            virtual ~Cleaner(){}
+
+            virtual string name() const { return "WriteBackManager::cleaner"; }
+
+            virtual void run();
+        };
 
+        Cleaner _cleaner;
     };
 
     // TODO collect global state in a central place and init during startup

