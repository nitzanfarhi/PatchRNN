commit e548cf4e803b9758053bb1fbd856d075320aa4fb
Author: Con Kolivas <kernel@kolivas.org>
Date:   Sat Jan 25 17:12:53 2014 +1100

    Reset hfa device if no valid hashes are seen for 1 minute from the last work.

diff --git a/driver-hashfast.c b/driver-hashfast.c
index 846d26a7..a95ef3aa 100644
--- a/driver-hashfast.c
+++ b/driver-hashfast.c
@@ -274,6 +274,8 @@ static bool hfa_reset(struct cgpu_info *hashfast, struct hashfast_info *info)
 	uint8_t hcrc;
 	bool ret;
 
+	info->resets++;
+
 	/* Hash clock rate in Mhz */
 	info->hash_clock_rate = opt_hfa_hash_clock;
 	info->group_ntime_roll = opt_hfa_ntime_roll;
@@ -880,6 +882,8 @@ static bool hfa_prepare(struct thr_info *thr)
 
 	cgtime(&now);
 	get_datestamp(hashfast->init, sizeof(hashfast->init), &now);
+	hashfast->last_device_valid_work = time(NULL);
+	info->resets = 0;
 
 	return true;
 }
@@ -913,6 +917,17 @@ static int64_t hfa_scanwork(struct thr_info *thr)
 		return -1;
 	}
 
+	if (unlikely(last_getwork - hashfast->last_device_valid_work > 60)) {
+		applog(LOG_WARNING, "HFA %d: No valid hashes for over 1 minute, attempting to reset",
+		       hashfast->device_id);
+		ret = hfa_reset(hashfast, info);
+		if (unlikely(!ret)) {
+			applog(LOG_ERR, "HFA %d: Failed to reset after hash failure, disabling",
+			hashfast->device_id);
+			return -1;
+		}
+	}
+
 	if (unlikely(thr->work_restart)) {
 restart:
 		thr->work_restart = false;
@@ -1069,6 +1084,7 @@ static struct api_data *hfa_api_stats(struct cgpu_info *cgpu)
 
 	root = api_add_uint64(root, "raw hashcount", &info->raw_hashes, false);
 	root = api_add_uint64(root, "calc hashcount", &info->calc_hashes, false);
+	root = api_add_int(root, "resets", &info->resets, false);
 
 	return root;
 }
diff --git a/driver-hashfast.h b/driver-hashfast.h
index 9e634b68..76a86606 100644
--- a/driver-hashfast.h
+++ b/driver-hashfast.h
@@ -98,6 +98,7 @@ struct hashfast_info {
 	uint64_t calc_hashes;
 	uint16_t shed_count;                        // Dynamic copy of #cores device has shed for thermal control
 	int no_matching_work;
+	int resets;
 
 	pthread_t read_thr;
 };

