commit 7f49e7a38b77a7538acf48762c22ccbd05d9535c
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Thu Dec 10 10:25:24 2015 -0800

    net: Flush local routes when device changes vrf association
    
    The VRF driver cycles netdevs when an interface is enslaved or released:
    the down event is used to flush neighbor and route tables and the up
    event (if the interface was already up) effectively moves local and
    connected routes to the proper table.
    
    As of 4f823defdd5b the local route is left hanging around after a link
    down, so when a netdev is moved from one VRF to another (or released
    from a VRF altogether) local routes are left in the wrong table.
    
    Fix by handling the NETDEV_CHANGEUPPER event. When the upper dev is
    an L3mdev then call fib_disable_ip to flush all routes, local ones
    to.
    
    Fixes: 4f823defdd5b ("ipv4: fix to not remove local route on link down")
    Cc: Julian Anastasov <ja@ssi.bg>
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ipv4/fib_frontend.c b/net/ipv4/fib_frontend.c
index cc8f3e506cde..473447593060 100644
--- a/net/ipv4/fib_frontend.c
+++ b/net/ipv4/fib_frontend.c
@@ -1155,6 +1155,7 @@ static int fib_inetaddr_event(struct notifier_block *this, unsigned long event,
 static int fib_netdev_event(struct notifier_block *this, unsigned long event, void *ptr)
 {
 	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
+	struct netdev_notifier_changeupper_info *info;
 	struct in_device *in_dev;
 	struct net *net = dev_net(dev);
 	unsigned int flags;
@@ -1193,6 +1194,14 @@ static int fib_netdev_event(struct notifier_block *this, unsigned long event, vo
 	case NETDEV_CHANGEMTU:
 		rt_cache_flush(net);
 		break;
+	case NETDEV_CHANGEUPPER:
+		info = ptr;
+		/* flush all routes if dev is linked to or unlinked from
+		 * an L3 master device (e.g., VRF)
+		 */
+		if (info->upper_dev && netif_is_l3_master(info->upper_dev))
+			fib_disable_ip(dev, NETDEV_DOWN, true);
+		break;
 	}
 	return NOTIFY_DONE;
 }

