commit 5632af28493339bba47804241c906b0be2f86933
Author: damien <damien@openbsd.org>
Date:   Sat Jan 8 15:05:24 2011 +0000

    fix LEDs handling.
    do not read back the LED GPIO pin since it is configured in output
    only mode.
    makes the link LED blink on the WiFiStation EXT when scanning (the
    LEDs indicating the signal strength are not working yet).

diff --git a/sys/dev/ic/athn.c b/sys/dev/ic/athn.c
index 9924bd88b50..c626c6b5bfa 100644
--- a/sys/dev/ic/athn.c
+++ b/sys/dev/ic/athn.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: athn.c,v 1.70 2011/01/08 10:42:18 damien Exp $	*/
+/*	$OpenBSD: athn.c,v 1.71 2011/01/08 15:05:24 damien Exp $	*/
 
 /*-
  * Copyright (c) 2009 Damien Bergamini <damien.bergamini@free.fr>
@@ -72,6 +72,7 @@ void		athn_get_chanlist(struct athn_softc *);
 const char *	athn_get_mac_name(struct athn_softc *);
 const char *	athn_get_rf_name(struct athn_softc *);
 void		athn_led_init(struct athn_softc *);
+void		athn_set_led(struct athn_softc *, int);
 void		athn_btcoex_init(struct athn_softc *);
 void		athn_btcoex_enable(struct athn_softc *);
 void		athn_btcoex_disable(struct athn_softc *);
@@ -876,8 +877,8 @@ athn_switch_chan(struct athn_softc *sc, struct ieee80211_channel *c,
 		goto reset;
 
 #ifdef notyet
-	/* AR9280 (but not AR9280+AR7010) needs a full reset. */
-	if (AR_SREV_9280(sc) && !(sc->flags & ATHN_FLAG_USB))
+	/* AR9280 needs a full reset. */
+	if (AR_SREV_9280(sc))
 #endif
 		goto reset;
 
@@ -1061,7 +1062,16 @@ athn_led_init(struct athn_softc *sc)
 
 	ops->gpio_config_output(sc, sc->led_pin, AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
 	/* LED off, active low. */
-	ops->gpio_write(sc, sc->led_pin, 1);
+	athn_set_led(sc, 0);
+}
+
+void
+athn_set_led(struct athn_softc *sc, int on)
+{
+	struct athn_ops *ops = &sc->ops;
+
+	sc->led_state = on;
+	ops->gpio_write(sc, sc->led_pin, !sc->led_state);
 }
 
 #ifdef ATHN_BT_COEXISTENCE
@@ -2358,27 +2368,25 @@ athn_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
 {
 	struct ifnet *ifp = &ic->ic_if;
 	struct athn_softc *sc = ifp->if_softc;
-	struct athn_ops *ops = &sc->ops;
 	uint32_t reg;
 	int error;
 
 	timeout_del(&sc->calib_to);
-	if (nstate != IEEE80211_S_SCAN)
-		ops->gpio_write(sc, sc->led_pin, 1);
 
 	switch (nstate) {
 	case IEEE80211_S_INIT:
+		athn_set_led(sc, 0);
 		break;
 	case IEEE80211_S_SCAN:
 		/* Make the LED blink while scanning. */
-		ops->gpio_write(sc, sc->led_pin,
-		    !ops->gpio_read(sc, sc->led_pin));
+		athn_set_led(sc, !sc->led_state);
 		error = athn_switch_chan(sc, ic->ic_bss->ni_chan, NULL);
 		if (error != 0)
 			return (error);
 		timeout_add_msec(&sc->scan_to, 200);
 		break;
 	case IEEE80211_S_AUTH:
+		athn_set_led(sc, 0);
 		error = athn_switch_chan(sc, ic->ic_bss->ni_chan, NULL);
 		if (error != 0)
 			return (error);
@@ -2386,7 +2394,7 @@ athn_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
 	case IEEE80211_S_ASSOC:
 		break;
 	case IEEE80211_S_RUN:
-		ops->gpio_write(sc, sc->led_pin, 0);
+		athn_set_led(sc, 1);
 
 		if (ic->ic_opmode == IEEE80211_M_MONITOR)
 			break;
diff --git a/sys/dev/ic/athnvar.h b/sys/dev/ic/athnvar.h
index 239245c10f0..cda406c96a9 100644
--- a/sys/dev/ic/athnvar.h
+++ b/sys/dev/ic/athnvar.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: athnvar.h,v 1.29 2011/01/06 07:27:15 damien Exp $	*/
+/*	$OpenBSD: athnvar.h,v 1.30 2011/01/08 15:05:24 damien Exp $	*/
 
 /*-
  * Copyright (c) 2009 Damien Bergamini <damien.bergamini@free.fr>
@@ -455,6 +455,7 @@ struct athn_softc {
 	uint8_t				ngpiopins;
 	int				led_pin;
 	int				rfsilent_pin;
+	int				led_state;
 	uint32_t			isync;
 	uint32_t			imask;
 
diff --git a/sys/dev/usb/if_athn_usb.c b/sys/dev/usb/if_athn_usb.c
index bea40b85c02..7d48cb21173 100644
--- a/sys/dev/usb/if_athn_usb.c
+++ b/sys/dev/usb/if_athn_usb.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: if_athn_usb.c,v 1.4 2011/01/06 19:20:54 damien Exp $	*/
+/*	$OpenBSD: if_athn_usb.c,v 1.5 2011/01/08 15:05:24 damien Exp $	*/
 
 /*-
  * Copyright (c) 2011 Damien Bergamini <damien.bergamini@free.fr>
@@ -189,6 +189,7 @@ void		ar9271_load_ani(struct athn_softc *);
 
 /* Extern functions. */
 void		athn_led_init(struct athn_softc *);
+void		athn_set_led(struct athn_softc *, int);
 void		athn_btcoex_init(struct athn_softc *);
 void		athn_set_rxfilter(struct athn_softc *, uint32_t);
 int		athn_reset(struct athn_softc *, int);
@@ -1007,7 +1008,6 @@ athn_usb_newstate_cb(struct athn_usb_softc *usc, void *arg)
 {
 	struct athn_usb_cmd_newstate *cmd = arg;
 	struct athn_softc *sc = &usc->sc_sc;
-	struct athn_ops *ops = &sc->ops;
 	struct ieee80211com *ic = &sc->sc_ic;
 	enum ieee80211_state ostate;
 	uint32_t reg, imask;
@@ -1027,23 +1027,22 @@ athn_usb_newstate_cb(struct athn_usb_softc *usc, void *arg)
 	}
 	switch (cmd->state) {
 	case IEEE80211_S_INIT:
-		ops->gpio_write(sc, sc->led_pin, 1);
+		athn_set_led(sc, 0);
 		break;
 	case IEEE80211_S_SCAN:
 		/* Make the LED blink while scanning. */
-		ops->gpio_write(sc, sc->led_pin,
-		    !ops->gpio_read(sc, sc->led_pin));
+		athn_set_led(sc, !sc->led_state);
 		(void)athn_usb_switch_chan(sc, ic->ic_bss->ni_chan, NULL);
 		timeout_add_msec(&sc->scan_to, 200);
 		break;
 	case IEEE80211_S_AUTH:
-		ops->gpio_write(sc, sc->led_pin, 1);
+		athn_set_led(sc, 0);
 		error = athn_usb_switch_chan(sc, ic->ic_bss->ni_chan, NULL);
 		break;
 	case IEEE80211_S_ASSOC:
 		break;
 	case IEEE80211_S_RUN:
-		ops->gpio_write(sc, sc->led_pin, 0);
+		athn_set_led(sc, 1);
 
 		if (ic->ic_opmode == IEEE80211_M_MONITOR)
 			break;

