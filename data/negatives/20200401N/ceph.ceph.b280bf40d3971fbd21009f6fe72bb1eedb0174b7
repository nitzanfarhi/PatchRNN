commit b280bf40d3971fbd21009f6fe72bb1eedb0174b7
Author: Adam C. Emerson <aemerson@redhat.com>
Date:   Tue Dec 5 21:56:19 2017 -0500

    common: Remove backported max and make_unique
    
    Signed-off-by: Adam C. Emerson <aemerson@redhat.com>

diff --git a/src/common/backport14.h b/src/common/backport14.h
index 1d059d8e79..6e96711ba4 100644
--- a/src/common/backport14.h
+++ b/src/common/backport14.h
@@ -134,44 +134,6 @@ template<class Base, class Derived> constexpr bool is_base_of_v =
   std::is_base_of<Base, Derived>::value;
 template<class From, class To> constexpr bool is_convertible_v =
   std::is_convertible<From, To>::value;
-
-namespace _backport14 {
-template<typename T>
-struct uniquity {
-  using datum = std::unique_ptr<T>;
-};
-
-template<typename T>
-struct uniquity<T[]> {
-  using array = std::unique_ptr<T[]>;
-};
-
-template<typename T, std::size_t N>
-struct uniquity<T[N]> {
-  using verboten = void;
-};
-
-template<typename T, typename... Args>
-inline typename uniquity<T>::datum make_unique(Args&&... args) {
-  return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
-}
-
-template<typename T>
-inline typename uniquity<T>::array make_unique(std::size_t n) {
-  return std::unique_ptr<T>(new std::remove_extent_t<T>[n]());
-}
-
-template<typename T, class... Args>
-typename uniquity<T>::verboten
-make_unique(Args&&...) = delete;
-
-// The constexpr variant of std::max().
-template<class T>
-constexpr const T& max(const T& a, const T& b) {
-  return a < b ? b : a;
-}
-} // namespace _backport14
-
 namespace _backport17 {
 template <class C>
 constexpr auto size(const C& c) -> decltype(c.size()) {
@@ -294,9 +256,7 @@ make_ostream_joiner(std::basic_ostream<CharT, Traits>& os,
 
 } // namespace _backport_ts
 
-using _backport14::make_unique;
 using _backport17::size;
-using _backport14::max;
 using _backport17::not_fn;
 using _backport17::in_place_t;
 using _backport17::in_place;
diff --git a/src/mds/Locker.cc b/src/mds/Locker.cc
index e0791dd6cb..749d392697 100644
--- a/src/mds/Locker.cc
+++ b/src/mds/Locker.cc
@@ -2361,7 +2361,7 @@ bool Locker::check_inode_max_size(CInode *in, bool force_wrlock,
       update_size = false;
   }
 
-  calc_new_client_ranges(in, ceph::max(new_max_size, size), &new_ranges, &max_increased);
+  calc_new_client_ranges(in, std::max(new_max_size, size), &new_ranges, &max_increased);
 
   if (max_increased || latest->client_ranges != new_ranges)
     update_max = true;
diff --git a/src/mds/MDSDaemon.cc b/src/mds/MDSDaemon.cc
index 5179f937d8..d184d68cce 100644
--- a/src/mds/MDSDaemon.cc
+++ b/src/mds/MDSDaemon.cc
@@ -732,7 +732,7 @@ int MDSDaemon::_handle_command(
 
   if (prefix == "get_command_descriptions") {
     int cmdnum = 0;
-    std::unique_ptr<JSONFormatter> f(ceph::make_unique<JSONFormatter>());
+    std::unique_ptr<JSONFormatter> f(std::make_unique<JSONFormatter>());
     f->open_object_section("command_descriptions");
     for (MDSCommand *cp = mds_commands;
 	 cp < &mds_commands[ARRAY_SIZE(mds_commands)]; cp++) {
diff --git a/src/mds/PurgeQueue.cc b/src/mds/PurgeQueue.cc
index a3dea1107a..0c853d793c 100644
--- a/src/mds/PurgeQueue.cc
+++ b/src/mds/PurgeQueue.cc
@@ -620,7 +620,7 @@ bool PurgeQueue::drain(
     max_purge_ops = 0xffff;
   }
 
-  drain_initial = ceph::max(bytes_remaining, drain_initial);
+  drain_initial = std::max(bytes_remaining, drain_initial);
 
   *progress = drain_initial - bytes_remaining;
   *progress_total = drain_initial;
diff --git a/src/mgr/PyModuleRegistry.cc b/src/mgr/PyModuleRegistry.cc
index ed32cf7604..a70e622be3 100644
--- a/src/mgr/PyModuleRegistry.cc
+++ b/src/mgr/PyModuleRegistry.cc
@@ -162,7 +162,7 @@ int PyModuleRegistry::init(const MgrMap &map)
   // Load python code
   for (const auto& module_name : mgr_map.modules) {
     dout(1) << "Loading python module '" << module_name << "'" << dendl;
-    auto mod = ceph::make_unique<PyModule>(module_name);
+    auto mod = std::make_unique<PyModule>(module_name);
     int r = mod->load(pMainThreadState);
     if (r != 0) {
       // Don't use handle_pyerror() here; we don't have the GIL
diff --git a/src/msg/QueueStrategy.cc b/src/msg/QueueStrategy.cc
index e41ab79fde..21cdb725b8 100644
--- a/src/msg/QueueStrategy.cc
+++ b/src/msg/QueueStrategy.cc
@@ -107,7 +107,7 @@ void QueueStrategy::start()
   for (int ix = 0; ix < n_threads; ++ix) {
     string thread_name = "ms_xio_qs_";
     thread_name.append(std::to_string(ix));
-    auto thrd = ceph::make_unique<QSThread>(this);
+    auto thrd = std::make_unique<QSThread>(this);
     thrd->create(thread_name.c_str());
     threads.emplace_back(std::move(thrd));
   }
diff --git a/src/os/bluestore/BlueStore.cc b/src/os/bluestore/BlueStore.cc
index 657bf7917c..b4a2b0ed43 100644
--- a/src/os/bluestore/BlueStore.cc
+++ b/src/os/bluestore/BlueStore.cc
@@ -731,7 +731,7 @@ int64_t BlueStore::GarbageCollector::estimate(
 
       // update gc_start_offset/gc_end_offset if needed
       gc_start_offset = min(gc_start_offset, (uint64_t)it->e.blob_start());
-      gc_end_offset = ceph::max(gc_end_offset, (uint64_t)it->e.blob_end());
+      gc_end_offset = std::max(gc_end_offset, (uint64_t)it->e.blob_end());
 
       auto o = it->e.logical_offset;
       auto l = it->e.length;
diff --git a/src/osd/OSD.h b/src/osd/OSD.h
index 094c8a7c84..ce20ec2ef8 100644
--- a/src/osd/OSD.h
+++ b/src/osd/OSD.h
@@ -1677,17 +1677,17 @@ private:
 	  sdata_op_ordering_lock(ordering_lock.c_str(), false, true,
 				 false, cct) {
 	if (opqueue == io_queue::weightedpriority) {
-	  pqueue = ceph::make_unique<
+	  pqueue = std::make_unique<
 	    WeightedPriorityQueue<OpQueueItem,uint64_t>>(
 	        max_tok_per_prio, min_cost);
 	} else if (opqueue == io_queue::prioritized) {
-	  pqueue = ceph::make_unique<
+	  pqueue = std::make_unique<
 	    PrioritizedQueue<OpQueueItem,uint64_t>>(
 		max_tok_per_prio, min_cost);
 	} else if (opqueue == io_queue::mclock_opclass) {
-	  pqueue = ceph::make_unique<ceph::mClockOpClassQueue>(cct);
+	  pqueue = std::make_unique<ceph::mClockOpClassQueue>(cct);
 	} else if (opqueue == io_queue::mclock_client) {
-	  pqueue = ceph::make_unique<ceph::mClockClientQueue>(cct);
+	  pqueue = std::make_unique<ceph::mClockClientQueue>(cct);
 	}
       }
     }; // struct ShardData
diff --git a/src/osdc/Objecter.cc b/src/osdc/Objecter.cc
index 57fac67fc3..531a36c162 100644
--- a/src/osdc/Objecter.cc
+++ b/src/osdc/Objecter.cc
@@ -238,7 +238,7 @@ void Objecter::update_mclock_service_tracker()
 {
   unique_lock wl(rwlock);
   if (cct->_conf->objecter_mclock_service_tracker && (!mclock_service_tracker)) {
-    qos_trk = ceph::make_unique<dmc::ServiceTracker<int>>();
+    qos_trk = std::make_unique<dmc::ServiceTracker<int>>();
   } else if (!cct->_conf->objecter_mclock_service_tracker) {
     qos_trk.reset();
   }
diff --git a/src/osdc/Objecter.h b/src/osdc/Objecter.h
index de225dc865..3765c4d4a8 100644
--- a/src/osdc/Objecter.h
+++ b/src/osdc/Objecter.h
@@ -2046,7 +2046,7 @@ private:
     retry_writes_after_first_reply(cct->_conf->objecter_retry_writes_after_first_reply)
   {
     if (cct->_conf->objecter_mclock_service_tracker) {
-      qos_trk = ceph::make_unique<dmc::ServiceTracker<int>>();
+      qos_trk = std::make_unique<dmc::ServiceTracker<int>>();
     }
   }
   ~Objecter() override;
diff --git a/src/rgw/rgw_bucket.cc b/src/rgw/rgw_bucket.cc
index 3d1d106438..61fb6c9f08 100644
--- a/src/rgw/rgw_bucket.cc
+++ b/src/rgw/rgw_bucket.cc
@@ -2162,7 +2162,7 @@ public:
   }
 
   int list_keys_init(RGWRados *store, const string& marker, void **phandle) override {
-    auto info = ceph::make_unique<list_keys_info>();
+    auto info = std::make_unique<list_keys_info>();
 
     info->store = store;
 
@@ -2361,7 +2361,7 @@ public:
   }
 
   int list_keys_init(RGWRados *store, const string& marker, void **phandle) override {
-    auto info = ceph::make_unique<list_keys_info>();
+    auto info = std::make_unique<list_keys_info>();
 
     info->store = store;
 
diff --git a/src/rgw/rgw_formats.cc b/src/rgw/rgw_formats.cc
index ee651e1371..96c709789a 100644
--- a/src/rgw/rgw_formats.cc
+++ b/src/rgw/rgw_formats.cc
@@ -218,7 +218,7 @@ void RGWFormatter_Plain::write_data(const char *fmt, ...)
 done:
 #define LARGE_ENOUGH_BUF 4096
   if (!buf) {
-    max_len = ceph::max(LARGE_ENOUGH_BUF, size);
+    max_len = std::max(LARGE_ENOUGH_BUF, size);
     buf = (char *)malloc(max_len);
     if (!buf) {
       cerr << "ERROR: RGWFormatter_Plain::write_data: failed allocating " << max_len << " bytes" << std::endl;
diff --git a/src/rgw/rgw_op.cc b/src/rgw/rgw_op.cc
index dad7a59ce5..5431b0630c 100644
--- a/src/rgw/rgw_op.cc
+++ b/src/rgw/rgw_op.cc
@@ -399,17 +399,17 @@ int rgw_build_bucket_policies(RGWRados* store, struct req_state* s)
   }
 
   if(s->dialect.compare("s3") == 0) {
-    s->bucket_acl = ceph::make_unique<RGWAccessControlPolicy_S3>(s->cct);
+    s->bucket_acl = std::make_unique<RGWAccessControlPolicy_S3>(s->cct);
   } else if(s->dialect.compare("swift")  == 0) {
     /* We aren't allocating the account policy for those operations using
      * the Swift's infrastructure that don't really need req_state::user.
      * Typical example here is the implementation of /info. */
     if (!s->user->user_id.empty()) {
-      s->user_acl = ceph::make_unique<RGWAccessControlPolicy_SWIFTAcct>(s->cct);
+      s->user_acl = std::make_unique<RGWAccessControlPolicy_SWIFTAcct>(s->cct);
     }
-    s->bucket_acl = ceph::make_unique<RGWAccessControlPolicy_SWIFT>(s->cct);
+    s->bucket_acl = std::make_unique<RGWAccessControlPolicy_SWIFT>(s->cct);
   } else {
-    s->bucket_acl = ceph::make_unique<RGWAccessControlPolicy>(s->cct);
+    s->bucket_acl = std::make_unique<RGWAccessControlPolicy>(s->cct);
   }
 
   /* check if copy source is within the current domain */
@@ -565,8 +565,7 @@ int rgw_build_object_policies(RGWRados *store, struct req_state *s,
     if (!s->bucket_exists) {
       return -ERR_NO_SUCH_BUCKET;
     }
-    s->object_acl = ceph::make_unique<RGWAccessControlPolicy>(s->cct);
-
+    s->object_acl = std::make_unique<RGWAccessControlPolicy>(s->cct);
     rgw_obj obj(s->bucket, s->object);
       
     store->set_atomic(s->obj_ctx, obj);
diff --git a/src/rgw/rgw_rest_s3.cc b/src/rgw/rgw_rest_s3.cc
index 080c1180d9..ccc3cabedf 100644
--- a/src/rgw/rgw_rest_s3.cc
+++ b/src/rgw/rgw_rest_s3.cc
@@ -1327,7 +1327,7 @@ int RGWPutObj_ObjStore_S3::get_params()
   /* handle object tagging */
   auto tag_str = s->info.env->get("HTTP_X_AMZ_TAGGING");
   if (tag_str){
-    obj_tags = ceph::make_unique<RGWObjTags>();
+    obj_tags = std::make_unique<RGWObjTags>();
     ret = obj_tags->set_from_string(tag_str);
     if (ret < 0){
       ldout(s->cct,0) << "setting obj tags failed with " << ret << dendl;
diff --git a/src/rgw/rgw_rest_s3.h b/src/rgw/rgw_rest_s3.h
index 48130d6fce..dea68a93d1 100644
--- a/src/rgw/rgw_rest_s3.h
+++ b/src/rgw/rgw_rest_s3.h
@@ -698,7 +698,7 @@ public:
      * avoid dynamic allocations. The multiplier comes from representing digest
      * in the base64-encoded form. */
     static constexpr size_t SIGNATURE_MAX_SIZE = \
-      ceph::max(DIGEST_SIZE_V2, DIGEST_SIZE_V4) * 2 + sizeof('\0');
+      std::max(DIGEST_SIZE_V2, DIGEST_SIZE_V4) * 2 + sizeof('\0');
 
   public:
     virtual ~VersionAbstractor() {};
diff --git a/src/rgw/rgw_user.cc b/src/rgw/rgw_user.cc
index 19cfe8fa25..ce998d1380 100644
--- a/src/rgw/rgw_user.cc
+++ b/src/rgw/rgw_user.cc
@@ -2762,7 +2762,7 @@ public:
 
   int list_keys_init(RGWRados *store, const string& marker, void **phandle) override
   {
-    auto info = ceph::make_unique<list_keys_info>();
+    auto info = std::make_unique<list_keys_info>();
 
     info->store = store;
 
diff --git a/src/test/libradosstriper/striping.cc b/src/test/libradosstriper/striping.cc
index 37a8922788..6bb58df614 100644
--- a/src/test/libradosstriper/striping.cc
+++ b/src/test/libradosstriper/striping.cc
@@ -171,7 +171,7 @@ TEST_P(StriperTestRT, StripedRoundtrip) {
   bufferlist bl1;
   {
     SCOPED_TRACE("Writing initial object"); 
-    buf1 = ceph::make_unique<char[]>(testData.size);
+    buf1 = std::make_unique<char[]>(testData.size);
     for (unsigned int i = 0; i < testData.size; i++) buf1[i] = 13*((unsigned char)i);
     bl1.append(buf1.get(), testData.size);
     ASSERT_EQ(0, striper.write(soid, bl1, testData.size, 0));
@@ -185,7 +185,7 @@ TEST_P(StriperTestRT, StripedRoundtrip) {
   bufferlist bl2;
   {
     SCOPED_TRACE("Testing append");
-    buf2 = ceph::make_unique<char[]>(testData.size);
+    buf2 = std::make_unique<char[]>(testData.size);
     for (unsigned int i = 0; i < testData.size; i++) buf2[i] = 17*((unsigned char)i);
     bl2.append(buf2.get(), testData.size);
     ASSERT_EQ(0, striper.append(soid, bl2, testData.size));
diff --git a/src/test/librgw_file_nfsns.cc b/src/test/librgw_file_nfsns.cc
index 92a0a6815e..a09c21c3d9 100644
--- a/src/test/librgw_file_nfsns.cc
+++ b/src/test/librgw_file_nfsns.cc
@@ -738,7 +738,7 @@ TEST(LibRGW, READF_DIRS1) {
       ofstream of;
       of.open(readf_out_name, ios::out|ios::app|ios::binary);
       int bufsz = 1024 * 1024 * sizeof(char);
-      auto buffer = ceph::make_unique<char[]>(bufsz);
+      auto buffer = std::make_unique<char[]>(bufsz);
 
       uint64_t offset = 0;
       uint64_t length = bufsz;
diff --git a/src/test/rgw/test_rgw_manifest.cc b/src/test/rgw/test_rgw_manifest.cc
index 0efce05628..8a64efe62a 100644
--- a/src/test/rgw/test_rgw_manifest.cc
+++ b/src/test/rgw/test_rgw_manifest.cc
@@ -82,7 +82,7 @@ public:
 
   void append(uint64_t ofs, const OldObjManifestPart& part) {
     objs[ofs] = part;
-    obj_size = ceph::max(obj_size, ofs + part.size);
+    obj_size = std::max(obj_size, ofs + part.size);
   }
 
   void encode(bufferlist& bl) const {
diff --git a/src/tools/rebuild_mondb.cc b/src/tools/rebuild_mondb.cc
index 11b34b5390..e9d96cfe0d 100644
--- a/src/tools/rebuild_mondb.cc
+++ b/src/tools/rebuild_mondb.cc
@@ -241,7 +241,7 @@ int update_osdmap(ObjectStore& fs, OSDSuperblock& sb, MonitorDBStore& ms)
   unsigned nadded = 0;
 
   OSDMap osdmap;
-  for (auto e = ceph::max(last_committed+1, sb.oldest_map);
+  for (auto e = std::max(last_committed+1, sb.oldest_map);
        e <= sb.newest_map; e++) {
     bool have_crc = false;
     uint32_t crc = -1;

