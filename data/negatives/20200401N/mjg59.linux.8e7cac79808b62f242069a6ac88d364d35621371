commit 8e7cac79808b62f242069a6ac88d364d35621371
Author: Avi Kivity <avi@redhat.com>
Date:   Sun Nov 29 16:34:48 2009 +0200

    core: Fix user return notifier on fork()
    
    fork() clones all thread_info flags, including
    TIF_USER_RETURN_NOTIFY; if the new task is first scheduled on a cpu
    which doesn't have user return notifiers set, this causes user
    return notifiers to trigger without any way of clearing itself.
    
    This is easy to trigger with a forky workload on the host in
    parallel with kvm, resulting in a cpu in an endless loop on the
    verge of returning to userspace.
    
    Fix by dropping the TIF_USER_RETURN_NOTIFY immediately after fork.
    
    Signed-off-by: Avi Kivity <avi@redhat.com>
    LKML-Reference: <1259505288-16559-1-git-send-email-avi@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/include/linux/user-return-notifier.h b/include/linux/user-return-notifier.h
index b6ac056291d7..9c4a445bb43c 100644
--- a/include/linux/user-return-notifier.h
+++ b/include/linux/user-return-notifier.h
@@ -26,6 +26,11 @@ static inline void propagate_user_return_notify(struct task_struct *prev,
 
 void fire_user_return_notifiers(void);
 
+static inline void clear_user_return_notifier(struct task_struct *p)
+{
+	clear_tsk_thread_flag(p, TIF_USER_RETURN_NOTIFY);
+}
+
 #else
 
 struct user_return_notifier {};
@@ -37,6 +42,8 @@ static inline void propagate_user_return_notify(struct task_struct *prev,
 
 static inline void fire_user_return_notifiers(void) {}
 
+static inline void clear_user_return_notifier(struct task_struct *p) {}
+
 #endif
 
 #endif
diff --git a/kernel/fork.c b/kernel/fork.c
index 266c6af6ef1b..1b7512d5a64a 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -64,6 +64,7 @@
 #include <linux/magic.h>
 #include <linux/perf_event.h>
 #include <linux/posix-timers.h>
+#include <linux/user-return-notifier.h>
 
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
@@ -249,6 +250,7 @@ static struct task_struct *dup_task_struct(struct task_struct *orig)
 		goto out;
 
 	setup_thread_stack(tsk, orig);
+	clear_user_return_notifier(tsk);
 	stackend = end_of_stack(tsk);
 	*stackend = STACK_END_MAGIC;	/* for overflow detection */
 

