commit 311a0b106dcd4c748ce1291952d36d2711d413c6
Author: Kevin Lin <klin@sourcefire.com>
Date:   Fri Mar 6 15:14:15 2015 -0500

    updated PCRE subsig check on no PCRE support for ldb and yara
    fixed an issue where partial yara rules could be loaded
    reason: segfaults are bad

diff --git a/libclamav/readdb.c b/libclamav/readdb.c
index 9f10bea49..38758427f 100644
--- a/libclamav/readdb.c
+++ b/libclamav/readdb.c
@@ -1577,7 +1577,8 @@ static int load_oneldb(char *buffer, int chkpua, struct cl_engine *engine, unsig
 #if !HAVE_PCRE
     /* Regex Usage and Support Check */
     for (i = 0; i < subsigs; ++i) {
-        if (strchr(tokens[i+3], '/')) {
+        char *slash = strchr(tokens[i+3], '/');
+        if (slash && strchr(slash+1, '/')) {
             cli_warnmsg("cli_loadldb: logical signature for %s uses PCREs but support is disabled, skipping\n", virname);
             (*sigs)--;
             return CL_SUCCESS;
@@ -3174,6 +3175,12 @@ static int load_oneyara(YR_RULE *rule, struct cl_engine *engine, unsigned int op
             *skip = 1;
         return CL_SUCCESS;
     }
+
+    if(engine->cb_sigload && engine->cb_sigload("yara", virname, ~options & CL_DB_OFFICIAL, engine->cb_sigload_ctx)) {
+        cli_dbgmsg("cli_loadyara: skipping %s due to callback\n", virname);
+        (*sigs)--;
+        return CL_SUCCESS;
+    }
     */
 
     /*** rule specific checks ***/
@@ -3264,6 +3271,7 @@ static int load_oneyara(YR_RULE *rule, struct cl_engine *engine, unsigned int op
             free(substr);
         } else if (STRING_IS_REGEXP(string)) {
             /* TODO - rewrite to NOT use PCRE_BYPASS */
+#if HAVE_PCRE
             size_t length = strlen(PCRE_BYPASS) + string->length + 3;
 
             substr = cli_calloc(length, sizeof(char));
@@ -3280,6 +3288,12 @@ static int load_oneyara(YR_RULE *rule, struct cl_engine *engine, unsigned int op
 
             ytable_add_string(&ytable, substr);
             free(substr);
+#else
+            cli_warnmsg("cli_loadyara: %s uses PCREs but support is disabled\n", rule->identifier);
+            str_error++;
+            ret = CL_SUCCESS;
+            break;
+#endif
         } else {
             /* TODO - extract the string length to handle NULL hex-escaped characters
              * For now, we'll just use the strlen we get which crudely finds the length
@@ -3578,7 +3592,6 @@ static int cli_loadyara(FILE *fs, struct cl_engine *engine, unsigned int *signo,
     if (rc > 0) { /* rc = number of errors */
         /* TODO - handle the various errors? */
         cli_errmsg("cli_loadyara: failed to parse rules file %s, error count %i\n", dbname, rc);
-#ifdef YARA_FINISHED
         yr_hash_table_destroy(compiler.rules_table, NULL);
         yr_hash_table_destroy(compiler.objects_table, NULL);
         yr_arena_destroy(compiler.sz_arena);
@@ -3586,7 +3599,10 @@ static int cli_loadyara(FILE *fs, struct cl_engine *engine, unsigned int *signo,
         yr_arena_destroy(compiler.code_arena);
         yr_arena_destroy(compiler.strings_arena);
         yr_arena_destroy(compiler.metas_arena);
+#ifdef YARA_FINISHED
         return CL_EMALFDB;
+#else
+        return CL_SUCCESS;
 #endif
     }
 
@@ -3601,9 +3617,7 @@ static int cli_loadyara(FILE *fs, struct cl_engine *engine, unsigned int *signo,
         rc = load_oneyara(rule, engine, options, &sigs);
         if (rc != CL_SUCCESS) {
             cli_warnmsg("cli_loadyara: problem parsing yara file %s, yara rule %s\n", dbname, rule->identifier);
-#ifdef YARA_FINISHED
             break;
-#endif
         }
     }
 
@@ -3615,18 +3629,15 @@ static int cli_loadyara(FILE *fs, struct cl_engine *engine, unsigned int *signo,
     yr_arena_destroy(compiler.strings_arena);
     yr_arena_destroy(compiler.metas_arena);
 
-#ifdef YARA_FINISHED
     if(rc)
         return rc;
 
+#ifdef YARA_FINISHED
     if(!rules) {
         cli_errmsg("cli_loadyara: empty database file\n");
         return CL_EMALFDB;
     }
 #else
-    if(rc)
-        return CL_SUCCESS;
-
     if(!rules) {
         cli_warnmsg("cli_loadyara: empty database file\n");
         yara_empty++;

