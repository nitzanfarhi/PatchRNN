commit 1b45c46cf75d9c48eb611d5cc41607ac1f046606
Author: Trond Myklebust <Trond.Myklebust@netapp.com>
Date:   Tue Jul 3 13:04:56 2007 -0400

    NFSv4: Fix atomic open for execute...
    
    Currently we do not check for the FMODE_EXEC flag as we should. For that
    particular case, we need to perform an ACCESS call to the server in order
    to check that the file is executable.
    
    Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>

diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index 1840ebc78fd3..69aab8db4947 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -769,6 +769,8 @@ static int _nfs4_do_access(struct inode *inode, struct rpc_cred *cred, int openf
 		mask |= MAY_READ;
 	if (openflags & FMODE_WRITE)
 		mask |= MAY_WRITE;
+	if (openflags & FMODE_EXEC)
+		mask |= MAY_EXEC;
 	status = nfs_access_get_cached(inode, cred, &cache);
 	if (status == 0)
 		goto out;
@@ -1269,7 +1271,16 @@ int nfs4_do_close(struct path *path, struct nfs4_state *state)
 static int nfs4_intent_set_file(struct nameidata *nd, struct path *path, struct nfs4_state *state)
 {
 	struct file *filp;
+	int ret;
 
+	/* If the open_intent is for execute, we have an extra check to make */
+	if (nd->intent.open.flags & FMODE_EXEC) {
+		ret = _nfs4_do_access(state->inode,
+				state->owner->so_cred,
+				nd->intent.open.flags);
+		if (ret < 0)
+			goto out_close;
+	}
 	filp = lookup_instantiate_filp(nd, path->dentry, NULL);
 	if (!IS_ERR(filp)) {
 		struct nfs_open_context *ctx;
@@ -1277,8 +1288,10 @@ static int nfs4_intent_set_file(struct nameidata *nd, struct path *path, struct
 		ctx->state = state;
 		return 0;
 	}
+	ret = PTR_ERR(filp);
+out_close:
 	nfs4_close_state(path, state, nd->intent.open.flags);
-	return PTR_ERR(filp);
+	return ret;
 }
 
 struct dentry *

