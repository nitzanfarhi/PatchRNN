commit ee2e11d9a364677a5d495bf1252e87dcc5f0fb6c
Author: Eliot Horowitz <eliot@10gen.com>
Date:   Mon Mar 3 17:39:34 2014 -0500

    SERVER-11643: remove many nsdetails calls

diff --git a/src/mongo/db/catalog/index_catalog.cpp b/src/mongo/db/catalog/index_catalog.cpp
index 51bc8a03b1..241c811e78 100644
--- a/src/mongo/db/catalog/index_catalog.cpp
+++ b/src/mongo/db/catalog/index_catalog.cpp
@@ -1094,9 +1094,13 @@ namespace mongo {
     }
 
     const IndexAccessMethod* IndexCatalog::getIndex( const IndexDescriptor* desc ) const {
+        return getEntry( desc )->accessMethod();
+    }
+
+    const IndexCatalogEntry* IndexCatalog::getEntry( const IndexDescriptor* desc ) const {
         const IndexCatalogEntry* entry = _entries.find( desc );
         massert( 17357, "cannot find index entry", entry );
-        return entry->accessMethod();
+        return entry;
     }
 
     IndexAccessMethod* IndexCatalog::_createAccessMethod( const IndexDescriptor* desc,
diff --git a/src/mongo/db/catalog/index_catalog.h b/src/mongo/db/catalog/index_catalog.h
index d1852b13a7..5deb5ff65d 100644
--- a/src/mongo/db/catalog/index_catalog.h
+++ b/src/mongo/db/catalog/index_catalog.h
@@ -103,6 +103,8 @@ namespace mongo {
                               bool includeUnfinishedIndexes = false ) const;
 
         // never returns NULL
+        const IndexCatalogEntry* getEntry( const IndexDescriptor* desc ) const;
+
         IndexAccessMethod* getIndex( const IndexDescriptor* desc );
         const IndexAccessMethod* getIndex( const IndexDescriptor* desc ) const;
 
diff --git a/src/mongo/db/commands/index_stats.cpp b/src/mongo/db/commands/index_stats.cpp
index de1bd4bf83..b203cab2e9 100644
--- a/src/mongo/db/commands/index_stats.cpp
+++ b/src/mongo/db/commands/index_stats.cpp
@@ -30,13 +30,14 @@
 #include "mongo/db/auth/action_set.h"
 #include "mongo/db/auth/action_type.h"
 #include "mongo/db/auth/privilege.h"
-#include "mongo/db/structure/btree/btree.h"
+#include "mongo/db/catalog/index_catalog.h"
+#include "mongo/db/catalog/index_catalog_entry.h"
 #include "mongo/db/commands.h"
 #include "mongo/db/db.h"
-#include "mongo/db/structure/catalog/index_details.h"
 #include "mongo/db/jsobj.h"
+#include "mongo/db/index/index_descriptor.h"
 #include "mongo/db/kill_current_op.h"
-#include "mongo/db/structure/catalog/namespace_details.h"
+#include "mongo/db/structure/btree/btree.h"
 #include "mongo/util/descriptive_stats.h"
 
 namespace mongo {
@@ -353,41 +354,35 @@ namespace mongo {
      *
      * @return true on success, false otherwise
      */
-    bool runInternal(const NamespaceDetails* nsd, IndexStatsParams params, string& errmsg,
+    bool runInternal(const Collection* collection, IndexStatsParams params, string& errmsg,
                      BSONObjBuilder& result) {
 
-        const IndexDetails* details = NULL;
+        const IndexCatalog* indexCatalog = collection->getIndexCatalog();
 
-        // casting away const, we are not going to modify NamespaceDetails
-        // but ii() is not marked const, see SERVER-7619
-        for (NamespaceDetails::IndexIterator it = const_cast<NamespaceDetails*>(nsd)->ii();
-             it.more();) {
-            IndexDetails& cur = it.next();
-            if (cur.indexName() == params.indexName) details = &cur;
-        }
+        IndexDescriptor* descriptor = indexCatalog->findIndexByName( params.indexName );
 
-        if (details == NULL) {
+        if (descriptor == NULL) {
             errmsg = "the requested index does not exist";
             return false;
         }
 
-        result << "index" << details->indexName()
-               << "version" << details->version()
-               << "isIdIndex" << details->isIdIndex()
-               << "keyPattern" << details->keyPattern()
-               << "storageNs" << details->indexNamespace();
+        result << "index" << descriptor->indexName()
+               << "version" << descriptor->version()
+               << "isIdIndex" << descriptor->isIdIndex()
+               << "keyPattern" << descriptor->keyPattern()
+               << "storageNs" << descriptor->indexNamespace();
 
         scoped_ptr<BtreeInspector> inspector(NULL);
-        switch (details->version()) {
+        switch (descriptor->version()) {
           case 1: inspector.reset(new BtreeInspectorV1(params.expandNodes)); break;
           case 0: inspector.reset(new BtreeInspectorV0(params.expandNodes)); break;
           default:
-            errmsg = str::stream() << "index version " << details->version() << " is "
+            errmsg = str::stream() << "index version " << descriptor->version() << " is "
                                    << "not supported";
             return false;
         }
 
-        inspector->inspect(details->head);
+        inspector->inspect( indexCatalog->getEntry( descriptor )->head() );
 
         inspector->stats().appendTo(result);
 
@@ -498,12 +493,13 @@ namespace mongo {
         bool run(const string& dbname, BSONObj& cmdObj, int, string& errmsg,
                  BSONObjBuilder& result, bool fromRepl) {
 
-            string ns = dbname + "." + cmdObj.firstElement().valuestrsafe();
-            const NamespaceDetails* nsd = nsdetails(ns);
+            NamespaceString nss( dbname, cmdObj.firstElement().valuestrsafe() );
             if (!serverGlobalParams.quiet) {
-                MONGO_TLOG(0) << "CMD: indexStats " << ns << endl;
+                MONGO_TLOG(0) << "CMD: indexStats " << nss;
             }
-            if (!nsd) {
+
+            const Collection* collection = cc().database()->getCollection( nss.ns() );
+            if (!collection) {
                 errmsg = "ns not found";
                 return false;
             }
@@ -535,7 +531,7 @@ namespace mongo {
             }
 
             BSONObjBuilder resultBuilder;
-            if (!runInternal(nsd, params, errmsg, resultBuilder))
+            if (!runInternal(collection, params, errmsg, resultBuilder))
                 return false;
             result.appendElements(resultBuilder.obj());
             return true;
diff --git a/src/mongo/db/commands/rename_collection.cpp b/src/mongo/db/commands/rename_collection.cpp
index 8aaf005294..8d63c743a0 100644
--- a/src/mongo/db/commands/rename_collection.cpp
+++ b/src/mongo/db/commands/rename_collection.cpp
@@ -162,12 +162,12 @@ namespace mongo {
                 }
 
                 {
-                    const NamespaceDetails *nsd = nsdetails( source );
+
                     indexesInProg = stopIndexBuilds( srcCtx.db(), cmdObj );
-                    capped = nsd->isCapped();
-                    if ( capped )
-                        for( DiskLoc i = nsd->firstExtent(); !i.isNull(); i = i.ext()->xnext )
-                            size += i.ext()->length;
+                    capped = sourceColl->isCapped();
+                    if ( capped ) {
+                        size = sourceColl->storageSize();
+                    }
                 }
             }
 
diff --git a/src/mongo/db/commands/test_commands.cpp b/src/mongo/db/commands/test_commands.cpp
index 4667f6b7ec..3561238137 100644
--- a/src/mongo/db/commands/test_commands.cpp
+++ b/src/mongo/db/commands/test_commands.cpp
@@ -129,7 +129,7 @@ namespace mongo {
     public:
         CapTrunc() : Command( "captrunc" ) {}
         virtual bool slaveOk() const { return false; }
-        virtual LockType locktype() const { return WRITE; }
+        virtual LockType locktype() const { return NONE; }
         // No auth needed because it only works when enabled via command line.
         virtual void addRequiredPrivileges(const std::string& dbname,
                                            const BSONObj& cmdObj,
@@ -137,22 +137,23 @@ namespace mongo {
         virtual bool run(const string& dbname , BSONObj& cmdObj, int, string& errmsg, BSONObjBuilder& result, bool) {
             string coll = cmdObj[ "captrunc" ].valuestrsafe();
             uassert( 13416, "captrunc must specify a collection", !coll.empty() );
-            string ns = dbname + "." + coll;
+            NamespaceString nss( dbname, coll );
             int n = cmdObj.getIntField( "n" );
+            bool inc = cmdObj.getBoolField( "inc" ); // inclusive range?
 
-            // inclusive range?
-            bool inc = cmdObj.getBoolField( "inc" );
-            NamespaceDetails *nsd = nsdetails( ns );
-            massert( 13417, "captrunc collection not found or empty", nsd);
+            Client::WriteContext ctx( nss.ns() );
+            Collection* collection = ctx.ctx().db()->getCollection( nss.ns() );
+            massert( 13417, "captrunc collection not found or empty", collection);
 
-            boost::scoped_ptr<Runner> runner(InternalPlanner::collectionScan(ns, InternalPlanner::BACKWARD));
+            boost::scoped_ptr<Runner> runner(InternalPlanner::collectionScan(nss.ns(),
+                                                                             InternalPlanner::BACKWARD));
             DiskLoc end;
             // We remove 'n' elements so the start is one past that
             for( int i = 0; i < n + 1; ++i ) {
                 Runner::RunnerState state = runner->getNext(NULL, &end);
                 massert( 13418, "captrunc invalid n", Runner::RUNNER_ADVANCED == state);
             }
-            nsd->cappedTruncateAfter( ns.c_str(), end, inc );
+            collection->details()->cappedTruncateAfter( nss.ns().c_str(), end, inc );
             return true;
         }
     };
@@ -162,7 +163,7 @@ namespace mongo {
     public:
         EmptyCapped() : Command( "emptycapped" ) {}
         virtual bool slaveOk() const { return false; }
-        virtual LockType locktype() const { return WRITE; }
+        virtual LockType locktype() const { return NONE; }
         virtual bool logTheOp() { return true; }
         // No auth needed because it only works when enabled via command line.
         virtual void addRequiredPrivileges(const std::string& dbname,
@@ -182,13 +183,15 @@ namespace mongo {
         virtual bool run(const string& dbname , BSONObj& cmdObj, int, string& errmsg, BSONObjBuilder& result, bool) {
             string coll = cmdObj[ "emptycapped" ].valuestrsafe();
             uassert( 13428, "emptycapped must specify a collection", !coll.empty() );
-            string ns = dbname + "." + coll;
-            NamespaceDetails *nsd = nsdetails( ns );
-            massert( 13429, "emptycapped no such collection", nsd );
+            NamespaceString nss( dbname, coll );
+
+            Client::WriteContext ctx( nss.ns() );
+            Collection* collection = ctx.ctx().db()->getCollection( nss.ns() );
+            massert( 13429, "emptycapped no such collection", collection );
 
             std::vector<BSONObj> indexes = stopIndexBuilds(cc().database(), cmdObj);
 
-            nsd->emptyCappedCollection( ns.c_str() );
+            collection->details()->emptyCappedCollection( nss.ns().c_str() );
 
             IndexBuilder::restoreIndexes(indexes);
 
diff --git a/src/mongo/db/commands/touch.cpp b/src/mongo/db/commands/touch.cpp
index 4e22c72d6f..bf85a14697 100644
--- a/src/mongo/db/commands/touch.cpp
+++ b/src/mongo/db/commands/touch.cpp
@@ -35,19 +35,18 @@
 #include <string>
 #include <vector>
 
-#include "mongo/db/kill_current_op.h"
 #include "mongo/db/auth/action_set.h"
 #include "mongo/db/auth/action_type.h"
 #include "mongo/db/auth/authorization_manager.h"
 #include "mongo/db/auth/privilege.h"
+#include "mongo/db/catalog/collection.h"
 #include "mongo/db/commands.h"
-#include "mongo/db/d_concurrency.h"
 #include "mongo/db/curop-inl.h"
-#include "mongo/db/structure/catalog/namespace_details.h"
-#include "mongo/db/structure/catalog/index_details.h"
+#include "mongo/db/d_concurrency.h"
+#include "mongo/db/index/index_descriptor.h"
 #include "mongo/db/jsobj.h"
+#include "mongo/db/kill_current_op.h"
 #include "mongo/db/pdfile.h"
-#include "mongo/db/catalog/collection.h"
 #include "mongo/util/timer.h"
 #include "mongo/util/touch_pages.h"
 
@@ -169,13 +168,15 @@ namespace mongo {
                 std::vector< std::string > indexes;
                 {
                     Client::ReadContext ctx(ns);
-                    NamespaceDetails *nsd = nsdetails(ns);
-                    massert( 16153, "namespace does not exist", nsd );
+                    Collection* collection = ctx.ctx().db()->getCollection( ns );
+                    massert( 16153, "namespace does not exist", collection );
+
+                    IndexCatalog::IndexIterator ii =
+                        collection->getIndexCatalog()->getIndexIterator( false );
 
-                    NamespaceDetails::IndexIterator ii = nsd->ii(); 
                     while ( ii.more() ) {
-                        IndexDetails& idx = ii.next();
-                        indexes.push_back( idx.indexNamespace() );
+                        IndexDescriptor* desc = ii.next();
+                        indexes.push_back( desc->indexNamespace() );
                     }
                 }
 
diff --git a/src/mongo/db/exec/collection_scan.h b/src/mongo/db/exec/collection_scan.h
index e0d4eb945f..fbe1d935c0 100644
--- a/src/mongo/db/exec/collection_scan.h
+++ b/src/mongo/db/exec/collection_scan.h
@@ -75,7 +75,7 @@ namespace mongo {
 
         CollectionScanParams _params;
 
-        // True if nsdetails(_ns) == NULL on our first call to work.
+        // True if Database::getCollection(_ns) == NULL on our first call to work.
         bool _nsDropped;
 
         // If we want to return a DiskLoc and it points at something that's not in memory, we return
diff --git a/src/mongo/db/exec/oplogstart.cpp b/src/mongo/db/exec/oplogstart.cpp
index 5e94e058d7..8003b541a1 100644
--- a/src/mongo/db/exec/oplogstart.cpp
+++ b/src/mongo/db/exec/oplogstart.cpp
@@ -28,8 +28,12 @@
 
 #include "mongo/db/exec/oplogstart.h"
 
-#include "mongo/db/pdfile.h"
+#include "mongo/db/catalog/collection.h"
+#include "mongo/db/catalog/database.h"
+#include "mongo/db/client.h"
 #include "mongo/db/storage/extent.h"
+#include "mongo/db/storage/record.h"
+#include "mongo/db/structure/catalog/namespace_details.h"
 
 namespace mongo {
 
@@ -52,7 +56,8 @@ namespace mongo {
             params.ns = _ns;
             params.direction = CollectionScanParams::BACKWARD;
             _cs.reset(new CollectionScan(params, _workingSet, NULL));
-            _nsd = nsdetails(_ns.c_str());
+            Collection* collection = cc().database()->getCollection( _ns );
+            _nsd = collection->details();
             _needInit = false;
             _backwardsScanning = true;
             _timer.reset();
diff --git a/src/mongo/db/structure/catalog/cap.cpp b/src/mongo/db/structure/catalog/cap.cpp
index d403e6078e..2707055313 100644
--- a/src/mongo/db/structure/catalog/cap.cpp
+++ b/src/mongo/db/structure/catalog/cap.cpp
@@ -330,7 +330,6 @@ namespace mongo {
     }
 
     void NamespaceDetails::cappedTruncateAfter(const char *ns, DiskLoc end, bool inclusive) {
-        DEV verify( this == nsdetails(ns) );
         verify( cappedLastDelRecLastExtent().isValid() );
 
         // We iteratively remove the newest document until the newest document
@@ -425,7 +424,6 @@ namespace mongo {
     }
 
     void NamespaceDetails::emptyCappedCollection( const char *ns ) {
-        DEV verify( this == nsdetails(ns) );
         massert( 13424, "collection must be capped", isCapped() );
         massert( 13425, "background index build in progress", !_indexBuildsInProgress );
 

