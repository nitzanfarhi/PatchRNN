commit 373d25a2f31a841db3ccd7bd0a8102efeb2df54f
Author: Roger A. Faulkner <Roger.Faulkner@Sun.COM>
Date:   Mon Sep 22 17:41:13 2008 -0700

    6751103 thr_create() and pthread_create() should fail and not dump core when given an inaccessible stack

diff --git a/usr/src/lib/libc/amd64/threads/machdep.c b/usr/src/lib/libc/amd64/threads/machdep.c
index 844490fabb..2e8b9edc2c 100644
--- a/usr/src/lib/libc/amd64/threads/machdep.c
+++ b/usr/src/lib/libc/amd64/threads/machdep.c
@@ -24,8 +24,6 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include "lint.h"
 #include "thr_uberdata.h"
 #include <procfs.h>
@@ -35,6 +33,38 @@
 extern int getlwpstatus(thread_t, lwpstatus_t *);
 extern int putlwpregs(thread_t, prgregset_t);
 
+/* ARGSUSED2 */
+void *
+setup_top_frame(void *stk, size_t stksize, ulwp_t *ulwp)
+{
+	uint64_t *stack;
+	struct {
+		uint64_t	rpc;
+		uint64_t	fp;
+		uint64_t	pc;
+	} frame;
+
+	/*
+	 * Top-of-stack must be rounded down to STACK_ALIGN and
+	 * there must be a minimum frame.
+	 */
+	stack = (uint64_t *)(((uintptr_t)stk + stksize) & ~(STACK_ALIGN-1));
+
+	/*
+	 * This will return NULL if the kernel cannot allocate
+	 * a page for the top page of the stack.  This will cause
+	 * thr_create(), pthread_create() or pthread_attr_setstack()
+	 * to fail, passing the problem up to the application.
+	 */
+	stack -= 3;
+	frame.pc = 0;
+	frame.fp = 0;
+	frame.rpc = (uint64_t)_lwp_start;
+	if (uucopy(&frame, stack, sizeof (frame)) == 0)
+		return (stack);
+	return (NULL);
+}
+
 int
 setup_context(ucontext_t *ucp, void *(*func)(ulwp_t *),
 	ulwp_t *ulwp, caddr_t stk, size_t stksize)
@@ -51,20 +81,19 @@ setup_context(ucontext_t *ucp, void *(*func)(ulwp_t *),
 	/* all contexts should have a valid data segment descriptor for %ss */
 	ucp->uc_mcontext.gregs[REG_SS] = UDS_SEL;
 
-	/* top-of-stack must be rounded down to STACK_ALIGN */
-	stack = (uint64_t *)(((uintptr_t)stk + stksize) & ~(STACK_ALIGN-1));
-
-	/* set up top stack frame */
-	*--stack = 0;
-	*--stack = 0;
-	*--stack = (uint64_t)_lwp_start;
+	/*
+	 * Setup the top stack frame.
+	 * If this fails, pass the problem up to the application.
+	 */
+	if ((stack = setup_top_frame(stk, stksize, ulwp)) == NULL)
+		return (ENOMEM);
 
 	/* fill in registers of interest */
 	ucp->uc_flags |= UC_CPU;
 	ucp->uc_mcontext.gregs[REG_RDI] = (greg_t)ulwp;
 	ucp->uc_mcontext.gregs[REG_RIP] = (greg_t)func;
 	ucp->uc_mcontext.gregs[REG_RSP] = (greg_t)stack;
-	ucp->uc_mcontext.gregs[REG_RBP] = (greg_t)(stack+1);
+	ucp->uc_mcontext.gregs[REG_RBP] = (greg_t)(stack + 1);
 
 	return (0);
 }
diff --git a/usr/src/lib/libc/i386/threads/machdep.c b/usr/src/lib/libc/i386/threads/machdep.c
index d1c8d34437..ac09369604 100644
--- a/usr/src/lib/libc/i386/threads/machdep.c
+++ b/usr/src/lib/libc/i386/threads/machdep.c
@@ -24,8 +24,6 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include "thr_uberdata.h"
 #include <procfs.h>
 #include <ucontext.h>
@@ -34,6 +32,39 @@
 extern int getlwpstatus(thread_t, lwpstatus_t *);
 extern int putlwpregs(thread_t, prgregset_t);
 
+void *
+setup_top_frame(void *stk, size_t stksize, ulwp_t *ulwp)
+{
+	uint32_t *stack;
+	struct {
+		uint32_t	rpc;
+		uint32_t	arg;
+		uint32_t	fp;
+		uint32_t	pc;
+	} frame;
+
+	/*
+	 * Top-of-stack must be rounded down to STACK_ALIGN and
+	 * there must be a minimum frame.
+	 */
+	stack = (uint32_t *)(((uintptr_t)stk + stksize) & ~(STACK_ALIGN-1));
+
+	/*
+	 * This will return NULL if the kernel cannot allocate
+	 * a page for the top page of the stack.  This will cause
+	 * thr_create(), pthread_create() or pthread_attr_setstack()
+	 * to fail, passing the problem up to the application.
+	 */
+	stack -= 4;
+	frame.pc = 0;
+	frame.fp = 0;
+	frame.arg = (uint32_t)ulwp;
+	frame.rpc = (uint32_t)_lwp_start;
+	if (uucopy(&frame, (void *)stack, sizeof (frame)) == 0)
+		return (stack);
+	return (NULL);
+}
+
 int
 setup_context(ucontext_t *ucp, void *(*func)(ulwp_t *),
 	ulwp_t *ulwp, caddr_t stk, size_t stksize)
@@ -76,20 +107,18 @@ setup_context(ucontext_t *ucp, void *(*func)(ulwp_t *),
 	ucp->uc_mcontext.gregs[ESP] = (greg_t)ulwp;
 	ucp->uc_mcontext.gregs[GS] = (greg_t)LWPGS_SEL;
 
-	/* top-of-stack must be rounded down to STACK_ALIGN */
-	stack = (uint32_t *)(((uintptr_t)stk + stksize) & ~(STACK_ALIGN-1));
-
-	/* set up top stack frame */
-	*--stack = 0;
-	*--stack = 0;
-	*--stack = (uint32_t)ulwp;
-	*--stack = (uint32_t)_lwp_start;
+	/*
+	 * Setup the top stack frame.
+	 * If this fails, pass the problem up to the application.
+	 */
+	if ((stack = setup_top_frame(stk, stksize, ulwp)) == NULL)
+		return (ENOMEM);
 
 	/* fill in registers of interest */
 	ucp->uc_flags |= UC_CPU;
 	ucp->uc_mcontext.gregs[EIP] = (greg_t)func;
 	ucp->uc_mcontext.gregs[UESP] = (greg_t)stack;
-	ucp->uc_mcontext.gregs[EBP] = (greg_t)(stack+2);
+	ucp->uc_mcontext.gregs[EBP] = (greg_t)(stack + 2);
 
 	return (0);
 }
diff --git a/usr/src/lib/libc/inc/thr_uberdata.h b/usr/src/lib/libc/inc/thr_uberdata.h
index 3d36215f9d..745547208c 100644
--- a/usr/src/lib/libc/inc/thr_uberdata.h
+++ b/usr/src/lib/libc/inc/thr_uberdata.h
@@ -27,8 +27,6 @@
 #ifndef _THR_UBERDATA_H
 #define	_THR_UBERDATA_H
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include <stdlib.h>
 #include <unistd.h>
 #include <sys/types.h>
@@ -1188,6 +1186,7 @@ extern	void	signal_init(void);
 extern	int	sigequalset(const sigset_t *, const sigset_t *);
 extern	void	mutex_setup(void);
 extern	void	take_deferred_signal(int);
+extern	void	*setup_top_frame(void *, size_t, ulwp_t *);
 extern	int	setup_context(ucontext_t *, void *(*func)(ulwp_t *),
 			ulwp_t *ulwp, caddr_t stk, size_t stksize);
 extern	volatile sc_shared_t *setup_schedctl(void);
diff --git a/usr/src/lib/libc/port/threads/pthr_attr.c b/usr/src/lib/libc/port/threads/pthr_attr.c
index 3bbd1c0f1a..51d08b4a5d 100644
--- a/usr/src/lib/libc/port/threads/pthr_attr.c
+++ b/usr/src/lib/libc/port/threads/pthr_attr.c
@@ -24,8 +24,6 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include "lint.h"
 #include "thr_uberdata.h"
 #include <sched.h>
@@ -447,6 +445,9 @@ pthread_attr_setstack(pthread_attr_t *attr,
 	    stacksize >= MINSTACK) {
 		ap->stkaddr = stackaddr;
 		ap->stksize = stacksize;
+		if (stackaddr != NULL &&
+		    setup_top_frame(stackaddr, stacksize, NULL) == NULL)
+			return (EACCES);
 		return (0);
 	}
 	return (EINVAL);
diff --git a/usr/src/lib/libc/port/threads/thr.c b/usr/src/lib/libc/port/threads/thr.c
index 58c5c839e3..18d641d699 100644
--- a/usr/src/lib/libc/port/threads/thr.c
+++ b/usr/src/lib/libc/port/threads/thr.c
@@ -24,8 +24,6 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include "lint.h"
 #include "thr_uberdata.h"
 #include <pthread.h>
@@ -562,7 +560,7 @@ _thrp_create(void *stk, size_t stksize, void *(*func)(void *), void *arg,
 	ucontext_t uc;
 	uint_t lwp_flags;
 	thread_t tid;
-	int error = 0;
+	int error;
 	ulwp_t *ulwp;
 
 	/*
@@ -652,9 +650,10 @@ _thrp_create(void *stk, size_t stksize, void *(*func)(void *), void *arg,
 	 */
 	ulwp->ul_sigdefer = 1;
 
-	if (setup_context(&uc, _thrp_setup, ulwp,
-	    (caddr_t)ulwp->ul_stk + ulwp->ul_guardsize, stksize) != 0)
-		error = EAGAIN;
+	error = setup_context(&uc, _thrp_setup, ulwp,
+	    (caddr_t)ulwp->ul_stk + ulwp->ul_guardsize, stksize);
+	if (error != 0 && stk != NULL)	/* inaccessible stack */
+		error = EFAULT;
 
 	/*
 	 * Call enter_critical() to avoid being suspended until we
diff --git a/usr/src/lib/libc/sparc/threads/machdep.c b/usr/src/lib/libc/sparc/threads/machdep.c
index a1704c0418..32ad502710 100644
--- a/usr/src/lib/libc/sparc/threads/machdep.c
+++ b/usr/src/lib/libc/sparc/threads/machdep.c
@@ -24,8 +24,6 @@
  * Use is subject to license terms.
  */
 
-#pragma ident	"%Z%%M%	%I%	%E% SMI"
-
 #include "lint.h"
 #include "thr_uberdata.h"
 #include <procfs.h>
@@ -36,20 +34,47 @@
 extern int getlwpstatus(thread_t, lwpstatus_t *);
 extern int putlwpregs(thread_t, prgregset_t);
 
-int
-setup_context(ucontext_t *ucp, void *(*func)(ulwp_t *),
-	ulwp_t *ulwp, caddr_t stk, size_t stksize)
+/* ARGSUSED2 */
+void *
+setup_top_frame(void *stk, size_t stksize, ulwp_t *ulwp)
 {
+	uintptr_t stack;
+	char frame[SA(MINFRAME)];
+
 	/*
 	 * Top-of-stack must be rounded down to STACK_ALIGN and
 	 * there must be a minimum frame for the register window.
 	 */
-	uintptr_t stack = (((uintptr_t)stk + stksize) & ~(STACK_ALIGN - 1)) -
+	stack = (((uintptr_t)stk + stksize) & ~(STACK_ALIGN - 1)) -
 	    SA(MINFRAME);
 
-	/* clear the context and the top stack frame */
+	/*
+	 * This will return NULL if the kernel cannot allocate
+	 * a page for the top page of the stack.  This will cause
+	 * thr_create(), pthread_create() or pthread_attr_setstack()
+	 * to fail, passing the problem up to the application.
+	 */
+	(void) memset(frame, 0, sizeof (frame));
+	if (uucopy(frame, (void *)stack, sizeof (frame)) == 0)
+		return ((void *)stack);
+	return (NULL);
+}
+
+int
+setup_context(ucontext_t *ucp, void *(*func)(ulwp_t *),
+	ulwp_t *ulwp, caddr_t stk, size_t stksize)
+{
+	uintptr_t stack;
+
+	/* clear the context */
 	(void) memset(ucp, 0, sizeof (*ucp));
-	(void) memset((void *)stack, 0, SA(MINFRAME));
+
+	/*
+	 * Clear the top stack frame.
+	 * If this fails, pass the problem up to the application.
+	 */
+	if ((stack = (uintptr_t)setup_top_frame(stk, stksize, ulwp)) == NULL)
+		return (ENOMEM);
 
 	/* fill in registers of interest */
 	ucp->uc_flags |= UC_CPU;

