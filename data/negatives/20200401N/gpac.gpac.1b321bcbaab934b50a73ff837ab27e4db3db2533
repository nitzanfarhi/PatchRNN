commit 1b321bcbaab934b50a73ff837ab27e4db3db2533
Author: Jean Le Feuvre <jeanlf@users.sourceforge.net>
Date:   Wed Apr 17 16:21:57 2013 +0000

    Fixed bugs from last commit
    
    git-svn-id: http://svn.code.sf.net/p/gpac/code/trunk/gpac@4469 63c20433-aa62-49bd-875c-5a186b69a8fb

diff --git a/applications/GPAX/GPAXPlugin.cpp b/applications/GPAX/GPAXPlugin.cpp
index 4b7f6c2ff..b58cc7619 100644
--- a/applications/GPAX/GPAXPlugin.cpp
+++ b/applications/GPAX/GPAXPlugin.cpp
@@ -190,9 +190,9 @@ Bool CGPAXPlugin::ReadParamString(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog,
 //            USES_CONVERSION;
 //            lstrcpyn(buf,OLE2T(v.bstrVal),bufsize);
 			const u16 *srcp = (const u16 *) v.bstrVal;
-			u32 len = gf_utf8_wcstombs(buf, bufsize, &srcp);
+			size_t len = gf_utf8_wcstombs(buf, bufsize, &srcp);
 			if (len>=0) {
-				buf[len] = 0;
+				buf[(u32) len] = 0;
 				retval = GF_TRUE;
 			}
         }
@@ -251,8 +251,8 @@ void CGPAXPlugin::LoadDATAUrl()
 		BSTR data = NULL;
 		if ((pObjectElem->get_data(&data) == S_OK) && data) {
 			const u16 *srcp = (const u16 *) data;
-			u32 len = gf_utf8_wcstombs(m_url, MAXLEN_URL, &srcp);
-			if (len>=0) m_url[len] = 0;
+			size_t len = gf_utf8_wcstombs(m_url, MAXLEN_URL, &srcp);
+			if (len>=0) m_url[(u32) len] = 0;
 		}
 		SysFreeString(data);
 		break;
@@ -514,7 +514,7 @@ STDMETHODIMP CGPAXPlugin::Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fS
     V_VT(&value) = VT_BSTR;
 
 	sptr = (const char *)m_url;
-	len = gf_utf8_mbstowcs(wurl, MAXLEN_URL, &sptr);
+	len = (u16) gf_utf8_mbstowcs(wurl, MAXLEN_URL, &sptr);
     V_BSTR(&value) = SysAllocStringLen(NULL, len+1);
 	memcpy(V_BSTR(&value) , wurl, len*sizeof(u16));
 	V_BSTR(&value) [len] = 0;
@@ -578,11 +578,11 @@ STDMETHODIMP CGPAXPlugin::SetURL(BSTR _url)
 		char *url;
 
 		srcp = (u16 *)_url;
-		len = gf_utf8_wcstombs(NULL, 0, (const u16 **)&srcp);
+		len = (u32) gf_utf8_wcstombs(NULL, 0, (const u16 **)&srcp);
 		if (len) {
 			url = (char *) gf_malloc(sizeof(char) * (len+1));
 			srcp = (u16 *)_url;
-			len = gf_utf8_wcstombs(url, len, (const u16 **)&srcp);
+			len = (u32) gf_utf8_wcstombs(url, len, (const u16 **)&srcp);
 			url[len] = 0;
 			strcpy(m_url, url);
 			gf_term_connect(m_term, url);     
@@ -600,15 +600,15 @@ STDMETHODIMP CGPAXPlugin::Update(BSTR _mtype, BSTR _updates)
 		char mtype[1024], *updates;
 
 		srcp = (u16 *) _mtype;
-		len = gf_utf8_wcstombs(mtype, 1024, (const u16 **)&srcp);
+		len = (u32) gf_utf8_wcstombs(mtype, 1024, (const u16 **)&srcp);
 		mtype[len] = 0;
 
 		srcp = (u16 *)_updates;
-		len = gf_utf8_wcstombs(NULL, 0, (const u16 **)&srcp);
+		len = (u32) gf_utf8_wcstombs(NULL, 0, (const u16 **)&srcp);
 		if (len) {
 			updates = (char *) gf_malloc(sizeof(char) * (len+1));
 			srcp = (u16 *)_updates;
-			len = gf_utf8_wcstombs(updates, len, (const u16 **)&srcp);
+			len = (u32) gf_utf8_wcstombs(updates, len, (const u16 **)&srcp);
 			updates[len] = 0;
 			gf_term_scene_update(m_term, mtype, updates);
 			gf_free(updates);
@@ -625,7 +625,7 @@ STDMETHODIMP CGPAXPlugin::get_src(BSTR *url)
     if (url==NULL) return E_POINTER;
 
 	sptr = (const char *)m_url;
-	len = gf_utf8_mbstowcs(wurl, MAXLEN_URL, &sptr);
+	len = (u32) gf_utf8_mbstowcs(wurl, MAXLEN_URL, &sptr);
     *url = SysAllocStringLen(NULL, len+1);
 	memcpy(*url, wurl, len*sizeof(u16));
 	*url[len] = 0;
@@ -634,7 +634,7 @@ STDMETHODIMP CGPAXPlugin::get_src(BSTR *url)
 STDMETHODIMP CGPAXPlugin::put_src(BSTR url)
 {
 	const u16 *srcp = (const u16 *)url;
-	u32 len = gf_utf8_wcstombs(m_url, MAXLEN_URL, &srcp);
+	u32 len = (u32) gf_utf8_wcstombs(m_url, MAXLEN_URL, &srcp);
 	m_url[len] = 0;
 	UpdateURL();
     return S_OK;
diff --git a/include/gpac/map.h b/include/gpac/map.h
index e821c4687..03569aac1 100644
--- a/include/gpac/map.h
+++ b/include/gpac/map.h
@@ -108,7 +108,7 @@ void gf_map_del(GF_Map *ptr);
  *	\param it the resulting iterator
  *	\return GF_OK if iterator has been properly generated, otherwiise a GF_Err
  */
-GF_Err gf_it_map_new(GF_Map* map, GF_It_Map** it);
+GF_Err gf_map_iter_new(GF_Map* map, GF_It_Map** it);
 
 /*!
  *	\brief map iterator destructor
@@ -116,7 +116,7 @@ GF_Err gf_it_map_new(GF_Map* map, GF_It_Map** it);
  *	Destructs a map iterator object
  *	\param ptr map iterator object to destruct
  */
-void gf_map_it_del(GF_It_Map *ptr);
+void gf_map_iter_del(GF_It_Map *ptr);
 
 /*!
  *	\brief return the next value in the map
@@ -125,7 +125,7 @@ void gf_map_it_del(GF_It_Map *ptr);
  *	\param it  the map iterator object
  *  \return the next value of the map if exists, otherwise NULL
  */
-void* gf_map_it_has_next(GF_It_Map* it);
+void* gf_map_iter_has_next(GF_It_Map* it);
 
 /*!
  *	\brief Reset the iterator in the map
@@ -134,7 +134,7 @@ void* gf_map_it_has_next(GF_It_Map* it);
  *	\param it  the map iterator object
  *  \return GF_OK if the iterator has been correctly reinitialize, otherwise a GF_Err
  */
-GF_Err gf_map_it_reset(GF_It_Map* it);
+GF_Err gf_map_iter_reset(GF_It_Map* it);
 
 /*!
  *	\brief get count
diff --git a/src/export.cpp b/src/export.cpp
index d3f004133..c253600ac 100644
--- a/src/export.cpp
+++ b/src/export.cpp
@@ -150,10 +150,10 @@
 #pragma comment (linker, EXPORT_SYMBOL(gf_map_rem) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_map_count) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_map_has_key) )
-#pragma comment (linker, EXPORT_SYMBOL(gf_it_map_new) )
-#pragma comment (linker, EXPORT_SYMBOL(gf_it_map_del) )
-#pragma comment (linker, EXPORT_SYMBOL(gf_it_map_has_next) )
-#pragma comment (linker, EXPORT_SYMBOL(gf_it_map_reset) )
+#pragma comment (linker, EXPORT_SYMBOL(gf_map_iter_new) )
+#pragma comment (linker, EXPORT_SYMBOL(gf_map_iter_del) )
+#pragma comment (linker, EXPORT_SYMBOL(gf_map_iter_has_next) )
+#pragma comment (linker, EXPORT_SYMBOL(gf_map_iter_reset) )
 #endif
 
 /* Bitstream */
diff --git a/src/media_tools/text_import.c b/src/media_tools/text_import.c
index c3835979f..55a0350f4 100644
--- a/src/media_tools/text_import.c
+++ b/src/media_tools/text_import.c
@@ -1283,7 +1283,7 @@ static GF_Err gf_text_import_ttxt(GF_MediaImporter *import)
 				else if (!strcmp(att->name, "text")) {
 					u32 len;
 					char *str = ttxt_parse_string(import, att->value, GF_TRUE);
-					len = strlen(str);
+					len = (u32) strlen(str);
 					gf_isom_text_add_text(samp, str, len);
 					last_sample_empty = len ? GF_FALSE : GF_TRUE;
 					has_text = GF_TRUE;
@@ -1299,7 +1299,7 @@ static GF_Err gf_text_import_ttxt(GF_MediaImporter *import)
 				if (!has_text && (ext->type==GF_XML_TEXT_TYPE)) {
 					u32 len;
 					char *str = ttxt_parse_string(import, ext->name, GF_FALSE);
-					len = strlen(str);
+					len = (u32) strlen(str);
 					gf_isom_text_add_text(samp, str, len);
 					last_sample_empty = len ? GF_FALSE : GF_TRUE;
 					has_text = GF_TRUE;
diff --git a/src/media_tools/webvtt.c b/src/media_tools/webvtt.c
index 9900ac800..73342adff 100644
--- a/src/media_tools/webvtt.c
+++ b/src/media_tools/webvtt.c
@@ -675,7 +675,7 @@ static GF_Err gf_webvtt_cue_add_property(GF_WebVTTCue *cue, GF_WebVTTCueProperty
         break;
     }
     if (*prop) {
-        len = strlen(*prop);
+        len = (u32) strlen(*prop);
         *prop = (char*)gf_realloc(*prop, sizeof(char) * (len + text_len + 1) );
         strcpy(*prop + len, text_data);
     } else {
@@ -966,7 +966,7 @@ static GF_Err gf_webvtt_add_cue_to_samples(GF_WebVTTParser *parser, GF_List *sam
 }
 
 #define REM_TRAIL_MARKS(__str, __sep) while (1) {	\
-		u32 _len = strlen(__str);		\
+		u32 _len = (u32) strlen(__str);		\
 		if (!_len) break;	\
 		_len--;				\
 		if (strchr(__sep, __str[_len])) { \
@@ -988,7 +988,7 @@ GF_Err gf_webvtt_parse_timestamp(GF_WebVTTParser *parser, GF_WebVTTTimestamp *ts
     u32     value4;
     Bool    is_hour = GF_FALSE;
     if (!ts || !line) return GF_BAD_PARAM;
-    len = strlen(line);
+    len = (u32) strlen(line);
     if (!len) return GF_BAD_PARAM;
     pos = 0;
     if (!(line[pos] >= '0' && line[pos] <= '9')) return GF_BAD_PARAM;
@@ -1115,7 +1115,7 @@ GF_Err gf_webvtt_parser_parse_timings_settings(GF_WebVTTParser *parser, GF_WebVT
         SKIP_WHITESPACE
         if (pos < len) {
             char *settings = line + pos;
-            e = gf_webvtt_cue_add_property(cue, WEBVTT_SETTINGS, settings, strlen(settings));
+            e = gf_webvtt_cue_add_property(cue, WEBVTT_SETTINGS, settings, (u32) strlen(settings));
         }
     }
     return e;
@@ -1143,7 +1143,7 @@ GF_Err gf_webvtt_parser_parse(GF_WebVTTParser *parser, u32 duration)
     while (do_parse) {
         sOK = gf_text_get_utf8_line(szLine, 2048, parser->vtt_in, parser->unicode_type);
         REM_TRAIL_MARKS(szLine, "\r\n")
-        len = strlen(szLine);
+        len = (u32) strlen(szLine);
         switch (parser->state) {
         case WEBVTT_PARSER_STATE_WAITING_SIGNATURE:
             if (!sOK || len < 6 || strnicmp(szLine, "WEBVTT", 6) || (len > 6 && szLine[6] != ' ' && szLine[6] != '\t')) {
@@ -1159,7 +1159,7 @@ GF_Err gf_webvtt_parser_parse(GF_WebVTTParser *parser, u32 duration)
             break; /* proceed to next line */
         case WEBVTT_PARSER_STATE_WAITING_HEADER:
             if (prevLine) {
-                u32 prev_len = strlen(prevLine);
+                u32 prev_len = (u32) strlen(prevLine);
                 header = (char *)gf_realloc(header, header_len + prev_len + 1);
                 strcpy(header+header_len,prevLine); 
                 header_len += prev_len;
@@ -1228,7 +1228,7 @@ GF_Err gf_webvtt_parser_parse(GF_WebVTTParser *parser, u32 duration)
                     cue   = gf_webvtt_cue_new();
                 }
                 if (prevLine) {
-                    gf_webvtt_cue_add_property(cue, WEBVTT_ID, prevLine, strlen(prevLine));
+                    gf_webvtt_cue_add_property(cue, WEBVTT_ID, prevLine, (u32) strlen(prevLine));
                     gf_free(prevLine);
                     prevLine = NULL;
                 }
@@ -1358,13 +1358,13 @@ GF_List *gf_webvtt_parse_iso_cues(GF_ISOSample *iso_sample, u64 start)
             gf_list_add(cues, cue);
             gf_webvtt_timestamp_set(&cue->start, start);
             if (cuebox->id) {
-                gf_webvtt_cue_add_property(cue, WEBVTT_ID, cuebox->id->string, strlen(cuebox->id->string));
+                gf_webvtt_cue_add_property(cue, WEBVTT_ID, cuebox->id->string, (u32) strlen(cuebox->id->string));
             }
             if (cuebox->settings) {
-                gf_webvtt_cue_add_property(cue, WEBVTT_SETTINGS, cuebox->settings->string, strlen(cuebox->settings->string));
+                gf_webvtt_cue_add_property(cue, WEBVTT_SETTINGS, cuebox->settings->string, (u32) strlen(cuebox->settings->string));
             }
             if (cuebox->payload) {
-                gf_webvtt_cue_add_property(cue, WEBVTT_PAYLOAD, cuebox->payload->string, strlen(cuebox->payload->string));
+                gf_webvtt_cue_add_property(cue, WEBVTT_PAYLOAD, cuebox->payload->string, (u32) strlen(cuebox->payload->string));
             }
         }
         gf_isom_box_del(box);
diff --git a/src/utils/map.c b/src/utils/map.c
index e49afda3b..73d74b6e4 100644
--- a/src/utils/map.c
+++ b/src/utils/map.c
@@ -47,7 +47,7 @@ struct _it_map
 };
 
 GF_EXPORT
-GF_Err gf_it_map_new(GF_Map* map, GF_It_Map** it){
+GF_Err gf_map_iter_new(GF_Map* map, GF_It_Map** it){
 	GF_It_Map* new_it;
 
 	/* Iterator must be associated to a map */
@@ -67,13 +67,13 @@ GF_Err gf_it_map_new(GF_Map* map, GF_It_Map** it){
 }
 
 GF_EXPORT
-void gf_it_map_del(GF_It_Map* it){
+void gf_map_iter_del(GF_It_Map* it){
 	if (!it) return;
 	gf_free(it);
 }
 
 GF_EXPORT
-void* gf_it_map_has_next(GF_It_Map* it){
+void* gf_map_iter_has_next(GF_It_Map* it){
 	GF_Pair* next_pair = NULL;
 
 	/* No iterator or iterator out of map */
@@ -90,11 +90,11 @@ void* gf_it_map_has_next(GF_It_Map* it){
 	/* Take the next hash */
 	it->hash++;
 	it->ilist = 0;
-	return gf_map_it_has_next(it);
+	return gf_map_iter_has_next(it);
 }
 
 GF_EXPORT
-GF_Err gf_it_map_reset(GF_It_Map* it){
+GF_Err gf_map_iter_reset(GF_It_Map* it){
 	if (!it) return GF_BAD_PARAM;
 
 	it->hash = 0;

