commit 7b9d8c3c4cfa0dc21f630c17c5f20e524dab487c
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Thu Sep 8 04:36:06 2011 -0300

    [media] V4L: soc-camera: call subdevice .s_power() method, when powering up or down
    
    Currently soc-camera can use power regulators and platform specific
    methods to power clients up and down. Additionally, client drivers can
    provide their own subdevice .s_power() methods, acting directly on the
    device. This patch adds calls to this method, when external power
    supplies are on.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/media/video/soc_camera.c b/drivers/media/video/soc_camera.c
index d3eeb08be321..9a62ed08d86a 100644
--- a/drivers/media/video/soc_camera.c
+++ b/drivers/media/video/soc_camera.c
@@ -53,10 +53,9 @@ static DEFINE_MUTEX(list_lock);		/* Protects the list of hosts */
 static int soc_camera_power_on(struct soc_camera_device *icd,
 			       struct soc_camera_link *icl)
 {
-	int ret;
-
-	ret = regulator_bulk_enable(icl->num_regulators,
-				    icl->regulators);
+	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
+	int ret = regulator_bulk_enable(icl->num_regulators,
+					icl->regulators);
 	if (ret < 0) {
 		dev_err(icd->pdev, "Cannot enable regulators\n");
 		return ret;
@@ -67,19 +66,33 @@ static int soc_camera_power_on(struct soc_camera_device *icd,
 		if (ret < 0) {
 			dev_err(icd->pdev,
 				"Platform failed to power-on the camera.\n");
-
-			regulator_bulk_disable(icl->num_regulators,
-					       icl->regulators);
+			goto elinkpwr;
 		}
 	}
 
+	ret = v4l2_subdev_call(sd, core, s_power, 1);
+	if (ret < 0 && ret != -ENOIOCTLCMD && ret != -ENODEV)
+		goto esdpwr;
+
+	return 0;
+
+esdpwr:
+	if (icl->power)
+		icl->power(icd->pdev, 0);
+elinkpwr:
+	regulator_bulk_disable(icl->num_regulators,
+			       icl->regulators);
 	return ret;
 }
 
 static int soc_camera_power_off(struct soc_camera_device *icd,
 				struct soc_camera_link *icl)
 {
-	int ret;
+	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
+	int ret = v4l2_subdev_call(sd, core, s_power, 0);
+
+	if (ret < 0 && ret != -ENOIOCTLCMD && ret != -ENODEV)
+		return ret;
 
 	if (icl->power) {
 		ret = icl->power(icd->pdev, 0);
@@ -1029,6 +1042,12 @@ static int soc_camera_probe(struct soc_camera_device *icd)
 	if (ret < 0)
 		goto ereg;
 
+	/*
+	 * This will not yet call v4l2_subdev_core_ops::s_power(1), because the
+	 * subdevice has not been initialised yet. We'll have to call it once
+	 * again after initialisation, even though it shouldn't be needed, we
+	 * don't do any IO here.
+	 */
 	ret = soc_camera_power_on(icd, icl);
 	if (ret < 0)
 		goto epower;
@@ -1099,6 +1118,10 @@ static int soc_camera_probe(struct soc_camera_device *icd)
 	if (ret < 0)
 		goto evidstart;
 
+	ret = v4l2_subdev_call(sd, core, s_power, 1);
+	if (ret < 0 && ret != -ENOIOCTLCMD)
+		goto esdpwr;
+
 	/* Try to improve our guess of a reasonable window format */
 	if (!v4l2_subdev_call(sd, video, g_mbus_fmt, &mf)) {
 		icd->user_width		= mf.width;
@@ -1115,6 +1138,8 @@ static int soc_camera_probe(struct soc_camera_device *icd)
 
 	return 0;
 
+esdpwr:
+	video_unregister_device(icd->vdev);
 evidstart:
 	mutex_unlock(&icd->video_lock);
 	soc_camera_free_user_formats(icd);
@@ -1129,6 +1154,7 @@ static int soc_camera_probe(struct soc_camera_device *icd)
 enodrv:
 eadddev:
 	video_device_release(icd->vdev);
+	icd->vdev = NULL;
 evdc:
 	ici->ops->remove(icd);
 eadd:

