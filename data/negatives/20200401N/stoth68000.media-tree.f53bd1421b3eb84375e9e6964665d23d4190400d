commit f53bd1421b3eb84375e9e6964665d23d4190400d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Jun 18 20:17:32 2015 -0400

    __ufs_truncate_blocks(): avoid excessive dirtying of indirect blocks
    
    There's a case when an indirect block gets dirtied for no good
    reason - when there's a hole starting in the middle of area
    covered by it and spanning past its end, and truncate() is done
    precisely to the beginning of the hole.
    
    The block is obviously not modified at all - all removals happen
    beyond it.  However, existing code ends up dirtying it just in
    case.  It's trivial to fix and while it's not a real bug by any
    stretch of imagination, it makes the damn thing harder to follow.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c
index 424949f459c8..86cc1eea0fb2 100644
--- a/fs/ufs/inode.c
+++ b/fs/ufs/inode.c
@@ -1251,10 +1251,8 @@ static void __ufs_truncate_blocks(struct inode *inode)
 			}
 			p = ubh_get_data_ptr(uspi, ubh[i], offsets[i + 1]);
 		}
-		while (i--) {
-			ubh_mark_buffer_dirty(ubh[i]);
+		while (i--)
 			free_branch_tail(inode, offsets[i + 1], ubh[i], depth - i - 1);
-		}
 	}
 	for (i = offsets[0]; i <= UFS_TIND_BLOCK; i++) {
 		p = ufs_get_direct_data_ptr(uspi, ufsi, i);

