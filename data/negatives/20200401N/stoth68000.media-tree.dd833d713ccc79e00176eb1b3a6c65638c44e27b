commit dd833d713ccc79e00176eb1b3a6c65638c44e27b
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Tue Jun 1 00:43:07 2010 +0200

    perf: Do the comm inheritance per thread in event__process_task
    
    event__process_task() doesn't propagate the comm copy on clone,
    but only on process fork. So we loose all the tid:comm resolution
    for tasks that aren't a main process thread.
    
    Progragate the per thread granularity to event__process_task for
    pid resolution.
    
    This fixes various unresolved pids in perf sched, especially when
    we trace multithread processes. The problem is quickly reproducible
    with the messaging benchmark using the multithread mode "-t" :
    
            perf sched record perf bench sched messaging -t
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Tom Zanussi <tzanussi@gmail.com>
    Cc: Stephane Eranian <eranian@google.com>

diff --git a/tools/perf/util/event.c b/tools/perf/util/event.c
index d28d80968f36..1f08f008d289 100644
--- a/tools/perf/util/event.c
+++ b/tools/perf/util/event.c
@@ -532,16 +532,11 @@ int event__process_mmap(event_t *self, struct perf_session *session)
 
 int event__process_task(event_t *self, struct perf_session *session)
 {
-	struct thread *thread = perf_session__findnew(session, self->fork.pid);
-	struct thread *parent = perf_session__findnew(session, self->fork.ppid);
+	struct thread *thread = perf_session__findnew(session, self->fork.tid);
+	struct thread *parent = perf_session__findnew(session, self->fork.ptid);
 
 	dump_printf("(%d:%d):(%d:%d)\n", self->fork.pid, self->fork.tid,
 		    self->fork.ppid, self->fork.ptid);
-	/*
-	 * A thread clone will have the same PID for both parent and child.
-	 */
-	if (thread == parent)
-		return 0;
 
 	if (self->header.type == PERF_RECORD_EXIT)
 		return 0;

