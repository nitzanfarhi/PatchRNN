commit d872818dbbeed1bccf58c7f8c7db432154c802f9
Author: Suresh Siddha <suresh.b.siddha@intel.com>
Date:   Mon Jun 25 13:38:29 2012 -0700

    x86/apic/x2apic: Use multiple cluster members for the irq destination only with the explicit affinity
    
    During boot or driver load etc, interrupt destination is setup
    using default target cpu's. Later the user (irqbalance etc) or
    the driver (irq_set_affinity/ irq_set_affinity_hint) can request
    the interrupt to be migrated to some specific set of cpu's.
    
    In the x2apic cluster routing, for the default scenario use
    single cpu as the interrupt destination and when there is an
    explicit interrupt affinity request, route the interrupt to
    multiple members of a x2apic cluster specified in the cpumask of
    the migration request.
    
    This will minmize the vector pressure when there are lot of
    interrupt sources and relatively few x2apic clusters (for
    example a single socket server). This will allow the performance
    critical interrupts to be routed to multiple cpu's in the x2apic
    cluster (irqbalance for example uses the cache siblings etc
    while specifying the interrupt destination) and allow
    non-critical interrupts to be serviced by a single logical cpu.
    
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Alexander Gordeev <agordeev@redhat.com>
    Acked-by: Cyrill Gorcunov <gorcunov@openvz.org>
    Link: http://lkml.kernel.org/r/1340656709-11423-4-git-send-email-suresh.b.siddha@intel.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/x86/kernel/apic/x2apic_cluster.c b/arch/x86/kernel/apic/x2apic_cluster.c
index bde78d0098a4..c88baa4ff0e5 100644
--- a/arch/x86/kernel/apic/x2apic_cluster.c
+++ b/arch/x86/kernel/apic/x2apic_cluster.c
@@ -209,13 +209,30 @@ static int x2apic_cluster_probe(void)
 		return 0;
 }
 
+static const struct cpumask *x2apic_cluster_target_cpus(void)
+{
+	return cpu_all_mask;
+}
+
 /*
  * Each x2apic cluster is an allocation domain.
  */
 static void cluster_vector_allocation_domain(int cpu, struct cpumask *retmask,
 					     const struct cpumask *mask)
 {
-	cpumask_and(retmask, mask, per_cpu(cpus_in_cluster, cpu));
+	/*
+	 * To minimize vector pressure, default case of boot, device bringup
+	 * etc will use a single cpu for the interrupt destination.
+	 *
+	 * On explicit migration requests coming from irqbalance etc,
+	 * interrupts will be routed to the x2apic cluster (cluster-id
+	 * derived from the first cpu in the mask) members specified
+	 * in the mask.
+	 */
+	if (mask == x2apic_cluster_target_cpus())
+		cpumask_copy(retmask, cpumask_of(cpu));
+	else
+		cpumask_and(retmask, mask, per_cpu(cpus_in_cluster, cpu));
 }
 
 static struct apic apic_x2apic_cluster = {
@@ -229,7 +246,7 @@ static struct apic apic_x2apic_cluster = {
 	.irq_delivery_mode		= dest_LowestPrio,
 	.irq_dest_mode			= 1, /* logical */
 
-	.target_cpus			= online_target_cpus,
+	.target_cpus			= x2apic_cluster_target_cpus,
 	.disable_esr			= 0,
 	.dest_logical			= APIC_DEST_LOGICAL,
 	.check_apicid_used		= NULL,

