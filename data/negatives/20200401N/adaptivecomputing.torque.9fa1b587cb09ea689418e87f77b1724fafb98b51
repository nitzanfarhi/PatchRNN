commit 9fa1b587cb09ea689418e87f77b1724fafb98b51
Author: bdaw <bdaw@adaptivecomputing.com>
Date:   Thu Aug 15 14:24:24 2013 -0600

    TRQ-2101 Added the resources used item back into  messages mailed out by pbs_server.

diff --git a/src/include/pbs_job.h b/src/include/pbs_job.h
index cf719d177..9487d73cd 100644
--- a/src/include/pbs_job.h
+++ b/src/include/pbs_job.h
@@ -1124,6 +1124,7 @@ int initialize_ruserok_mutex();
 extern int   svr_enquejob(job *, int, int, bool);
 extern void  svr_evaljobstate(job *, int *, int *, int);
 extern void  svr_mailowner(job *, int, int, const char *);
+extern void  svr_mailowner_with_message(job *, int, int, const char *, const char *);
 extern void  set_resc_deflt(job *, pbs_attribute *, int);
 extern void  set_statechar(job *);
 extern int   svr_setjobstate(job *, int, int, int);
diff --git a/src/server/req_jobobit.c b/src/server/req_jobobit.c
index 51592f83c..53c43c6f0 100644
--- a/src/server/req_jobobit.c
+++ b/src/server/req_jobobit.c
@@ -2523,7 +2523,8 @@ void wait_for_send(
 
 int setrerun(
 
-  job *pjob)
+  job *pjob,
+  const char *text)
 
   {
   if (pjob->ji_wattr[JOB_ATR_rerunable].at_val.at_long)
@@ -2539,7 +2540,7 @@ int setrerun(
 
   /* FAILURE */
 
-  svr_mailowner(pjob, MAIL_ABORT, MAIL_FORCE, msg_init_abt);
+  svr_mailowner_with_message(pjob, MAIL_ABORT, MAIL_FORCE, msg_init_abt,text);
 
   return(1);
   }  /* END setrerun() */
@@ -3033,7 +3034,8 @@ int handle_terminating_job(
 int update_substate_from_exit_status(
 
   job *pjob,
-  int *alreadymailed)
+  int *alreadymailed,
+  const char *text)
 
   {
   long  automatic_requeue = -1000;
@@ -3060,7 +3062,7 @@ int update_substate_from_exit_status(
       case JOB_EXEC_OVERLIMIT_MEM:
 
         /* the job exceeded a memory resource limit */
-        svr_mailowner(pjob, MAIL_ABORT, MAIL_FORCE, msg_momjobovermemlimit);
+        svr_mailowner_with_message(pjob, MAIL_ABORT, MAIL_FORCE, msg_momjobovermemlimit,text);
         *alreadymailed = 1;
 
         break;
@@ -3068,7 +3070,7 @@ int update_substate_from_exit_status(
       case JOB_EXEC_OVERLIMIT_WT:
 
         /* the job exceeded its  walltime limit */
-        svr_mailowner(pjob, MAIL_ABORT, MAIL_FORCE, msg_momjoboverwalltimelimit);
+        svr_mailowner_with_message(pjob, MAIL_ABORT, MAIL_FORCE, msg_momjoboverwalltimelimit,text);
         *alreadymailed = 1;
 
         break;
@@ -3076,7 +3078,7 @@ int update_substate_from_exit_status(
       case JOB_EXEC_OVERLIMIT_CPUT:
 
         /* the job exceeded its cpu time limit */
-        svr_mailowner(pjob, MAIL_ABORT, MAIL_FORCE, msg_momjobovercputlimit);
+        svr_mailowner_with_message(pjob, MAIL_ABORT, MAIL_FORCE, msg_momjobovercputlimit,text);
         *alreadymailed = 1;
 
         break;
@@ -3086,7 +3088,7 @@ int update_substate_from_exit_status(
       default:
 
         /* MOM rejected job with fatal error, abort job */
-        svr_mailowner(pjob, MAIL_ABORT, MAIL_FORCE, msg_momnoexec1);
+        svr_mailowner_with_message(pjob, MAIL_ABORT, MAIL_FORCE, msg_momnoexec1,text);
 
         *alreadymailed = 1;
 
@@ -3095,7 +3097,7 @@ int update_substate_from_exit_status(
       case JOB_EXEC_FAIL2:
 
         /* MOM reject job after files setup, abort job */
-        svr_mailowner(pjob, MAIL_ABORT, MAIL_FORCE, msg_momnoexec2);
+        svr_mailowner_with_message(pjob, MAIL_ABORT, MAIL_FORCE, msg_momnoexec2,text);
 
         *alreadymailed = 1;
 
@@ -3104,7 +3106,7 @@ int update_substate_from_exit_status(
       case JOB_EXEC_INITABT:
 
         /* MOM aborted job on her initialization */
-        *alreadymailed = setrerun(pjob);
+        *alreadymailed = setrerun(pjob,text);
 
         pjob->ji_qs.ji_svrflags |= JOB_SVFLG_HASRUN;
 
@@ -3117,7 +3119,7 @@ int update_substate_from_exit_status(
         if (pjob->ji_qs.ji_svrflags & JOB_SVFLG_HASRUN)
           {
           /* has run before, treat this as another rerun */
-          *alreadymailed = setrerun(pjob);
+          *alreadymailed = setrerun(pjob,text);
           }
         else
           {
@@ -3131,7 +3133,7 @@ int update_substate_from_exit_status(
       case JOB_EXEC_BADRESRT:
 
         /* MOM could not restart job, setup for rerun */
-        *alreadymailed = setrerun(pjob);
+        *alreadymailed = setrerun(pjob,text);
         pjob->ji_qs.ji_svrflags &= ~JOB_SVFLG_CHECKPOINT_FILE;
 
         break;
@@ -3170,7 +3172,7 @@ int update_substate_from_exit_status(
 
         /* MOM abort job on init, job has migratable checkpoint */
         /* Must recover output and checkpoint file, do eoj      */
-        *alreadymailed = setrerun(pjob);
+        *alreadymailed = setrerun(pjob,text);
 
         pjob->ji_qs.ji_svrflags |= JOB_SVFLG_HASRUN | JOB_SVFLG_CHECKPOINT_MIGRATEABLE;
 
@@ -3373,14 +3375,14 @@ int req_jobobit(
 
   sprintf(acctbuf, msg_job_end_stat, pjob->ji_qs.ji_un.ji_exect.ji_exitstat);
 
-  if (exitstatus < 10000)
+  if (exitstatus >= 10000)
     {
-    snprintf(mailbuf, sizeof(mailbuf), "%s", acctbuf);
+    sprintf(mailbuf, msg_job_end_sig,
+            exitstatus - 10000);
     }
   else
     {
-    sprintf(mailbuf, msg_job_end_sig,
-            exitstatus - 10000);
+    mailbuf[0] = '\0';
     }
 
   accttail = strlen(acctbuf);
@@ -3432,14 +3434,14 @@ int req_jobobit(
      }
 #endif    /* USESAVEDRESOURCES */
 
-  safe_strncat(mailbuf, (acctbuf + strlen(acctbuf)), sizeof(mailbuf) - strlen(mailbuf) - 1);
+  safe_strncat(mailbuf, acctbuf, sizeof(mailbuf) - strlen(mailbuf) - 1);
 
   reply_ack(preq);
 
   /* clear suspended flag if it was set */
   pjob->ji_qs.ji_svrflags &= ~JOB_SVFLG_Suspend;
 
-  if ((rc = update_substate_from_exit_status(pjob, &alreadymailed)) != PBSE_NONE)
+  if ((rc = update_substate_from_exit_status(pjob, &alreadymailed,mailbuf)) != PBSE_NONE)
     return(rc);
 
   /* What do we now do with the job... */
diff --git a/src/server/svr_mail.c b/src/server/svr_mail.c
index 4902599c9..c61ee10f4 100644
--- a/src/server/svr_mail.c
+++ b/src/server/svr_mail.c
@@ -357,7 +357,33 @@ int add_fileinfo(
   return 0;
   }
 
+void svr_mailowner_with_message(
 
+  job   *pjob,      /* I */
+  int    mailpoint, /* note, single character  */
+  int    force,     /* if set to MAIL_FORCE, force mail delivery */
+  const char  *text, /* text to mail. */
+  const char *msg)   /* Optional extra message */
+  {
+  if((text == NULL)||(*text == '\0'))
+    {
+    return;
+    }
+  if((msg == NULL)||(*msg == '\0'))
+    {
+    return svr_mailowner(pjob,mailpoint,force,text);
+    }
+  char *newMsg = (char *)malloc(strlen(text) + strlen(msg) + 2);
+  if(newMsg == NULL)
+    {
+    return;
+    }
+  strcpy(newMsg,text);
+  strcat(newMsg,"\n");
+  strcat(newMsg,msg);
+  svr_mailowner(pjob,mailpoint,force,newMsg);
+  free(newMsg);
+  }
 
 void svr_mailowner(
 
diff --git a/src/server/test/req_jobobit/scaffolding.c b/src/server/test/req_jobobit/scaffolding.c
index e14befa03..410857ec5 100644
--- a/src/server/test/req_jobobit/scaffolding.c
+++ b/src/server/test/req_jobobit/scaffolding.c
@@ -82,6 +82,8 @@ int svr_job_purge(job *pjob)
   return(0);
   }
 
+void svr_mailowner_with_message(job *pjob, int mailpoint, int force, const char *text,const char *msg) {}
+
 void svr_mailowner(job *pjob, int mailpoint, int force, const char *text) {}
 
 pbs_net_t get_hostaddr(int *local_errno, char *hostname)
diff --git a/src/server/test/req_jobobit/test_uut.c b/src/server/test/req_jobobit/test_uut.c
index 4d9caaedd..a0c0c49f7 100644
--- a/src/server/test/req_jobobit/test_uut.c
+++ b/src/server/test/req_jobobit/test_uut.c
@@ -18,7 +18,7 @@ int   is_joined(job *pjob, enum job_atr ati);
 batch_request *return_stdfile(batch_request *preq, job *pjob, enum job_atr ati);
 void rel_resc(job *pjob);
 int handle_exiting_or_abort_substate(job *pjob);
-int setrerun(job *pjob);
+int setrerun(job *pjob,const char *text);
 batch_request *setup_cpyfiles(batch_request *preq, job *pjob, char *from, char *to, int direction, int tflag);
 int handle_returnstd(job *pjob, batch_request *preq, int type);
 int mom_comm(job *pjob, void *(*func)(struct work_task *vp));
@@ -30,7 +30,7 @@ int add_comment_to_parent(job *parent_job, int cray_subjob_exited_nonzero, int e
 int end_of_job_accounting(job *pjob, char *acctbuf, int accttail);
 int handle_terminating_array_subjob(job *pjob);
 int handle_terminating_job(job *pjob, int alreadymailed, const char *mailbuf);
-int update_substate_from_exit_status(job *pjob, int *alreadymailed);
+int update_substate_from_exit_status(job *pjob, int *alreadymailed, const char *text);
 
 
 extern pthread_mutex_t *svr_do_schedule_mutex;
@@ -162,9 +162,9 @@ START_TEST(setrerun_test)
 
   memset(&pjob, 0, sizeof(pjob));
 
-  fail_unless(setrerun(&pjob) != PBSE_NONE);
+  fail_unless(setrerun(&pjob,NULL) != PBSE_NONE);
   pjob.ji_wattr[JOB_ATR_rerunable].at_val.at_long = 1;
-  fail_unless(setrerun(&pjob) == PBSE_NONE);
+  fail_unless(setrerun(&pjob,"rerunner") == PBSE_NONE);
   fail_unless(pjob.ji_qs.ji_substate == JOB_SUBSTATE_RERUN);
   }
 END_TEST
@@ -439,51 +439,51 @@ START_TEST(update_substate_from_exit_status_test)
   pjob->ji_qs.ji_un.ji_exect.ji_exitstat = -1000;
   cray_enabled = 0;
   usage = 0;
-  fail_unless(update_substate_from_exit_status(pjob, &alreadymailed) == PBSE_NONE);
+  fail_unless(update_substate_from_exit_status(pjob, &alreadymailed,"Some random message") == PBSE_NONE);
   fail_unless(pjob->ji_qs.ji_substate == JOB_SUBSTATE_RERUN1);
   fail_unless(alreadymailed == 0);
 
   pjob->ji_qs.ji_substate = JOB_SUBSTATE_RUNNING;
   pjob->ji_qs.ji_un.ji_exect.ji_exitstat = JOB_EXEC_OVERLIMIT_MEM;
-  fail_unless(update_substate_from_exit_status(pjob, &alreadymailed) == PBSE_NONE);
+  fail_unless(update_substate_from_exit_status(pjob, &alreadymailed,"Some random message") == PBSE_NONE);
   fail_unless(pjob->ji_qs.ji_substate == JOB_SUBSTATE_RUNNING);
   fail_unless(alreadymailed == 1);
 
   alreadymailed = 0;
   pjob->ji_qs.ji_substate = JOB_SUBSTATE_RUNNING;
   pjob->ji_qs.ji_un.ji_exect.ji_exitstat = JOB_EXEC_FAIL1;
-  fail_unless(update_substate_from_exit_status(pjob, &alreadymailed) == PBSE_NONE);
+  fail_unless(update_substate_from_exit_status(pjob, &alreadymailed,NULL) == PBSE_NONE);
   fail_unless(pjob->ji_qs.ji_substate == JOB_SUBSTATE_RUNNING);
   fail_unless(alreadymailed == 1);
 
   alreadymailed = 0;
   pjob->ji_qs.ji_substate = JOB_SUBSTATE_RUNNING;
   pjob->ji_qs.ji_un.ji_exect.ji_exitstat = JOB_EXEC_INITABT;
-  fail_unless(update_substate_from_exit_status(pjob, &alreadymailed) == PBSE_NONE);
+  fail_unless(update_substate_from_exit_status(pjob, &alreadymailed,"Some random message") == PBSE_NONE);
   fail_unless(pjob->ji_qs.ji_substate == JOB_SUBSTATE_RERUN);
   fail_unless((pjob->ji_qs.ji_svrflags & JOB_SVFLG_HASRUN) != 0);
 
   alreadymailed = 0;
   pjob->ji_qs.ji_substate = JOB_SUBSTATE_RUNNING;
   pjob->ji_qs.ji_un.ji_exect.ji_exitstat = JOB_EXEC_RETRY;
-  fail_unless(update_substate_from_exit_status(pjob, &alreadymailed) == PBSE_NONE);
+  fail_unless(update_substate_from_exit_status(pjob, &alreadymailed,"\n\n\n\n\n\n\n\n\n") == PBSE_NONE);
   fail_unless(pjob->ji_qs.ji_substate == JOB_SUBSTATE_RERUN);
   pjob->ji_qs.ji_svrflags = 0;
-  fail_unless(update_substate_from_exit_status(pjob, &alreadymailed) == PBSE_NONE);
+  fail_unless(update_substate_from_exit_status(pjob, &alreadymailed,"Some random message") == PBSE_NONE);
   fail_unless(pjob->ji_qs.ji_substate == JOB_SUBSTATE_RERUN1);
 
   alreadymailed = 0;
   pjob->ji_qs.ji_substate = JOB_SUBSTATE_RUNNING;
   pjob->ji_qs.ji_un.ji_exect.ji_exitstat = JOB_EXEC_BADRESRT;
   pjob->ji_qs.ji_svrflags = JOB_SVFLG_CHECKPOINT_FILE;
-  fail_unless(update_substate_from_exit_status(pjob, &alreadymailed) == PBSE_NONE);
+  fail_unless(update_substate_from_exit_status(pjob, &alreadymailed,"Some random message") == PBSE_NONE);
   fail_unless(pjob->ji_qs.ji_substate == JOB_SUBSTATE_RERUN);
   fail_unless((pjob->ji_qs.ji_svrflags & JOB_SVFLG_CHECKPOINT_FILE) == 0);
 
   alreadymailed = 0;
   pjob->ji_qs.ji_substate = JOB_SUBSTATE_RUNNING;
   pjob->ji_qs.ji_un.ji_exect.ji_exitstat = JOB_EXEC_INITRST;
-  fail_unless(update_substate_from_exit_status(pjob, &alreadymailed) == PBSE_SYSTEM);
+  fail_unless(update_substate_from_exit_status(pjob, &alreadymailed,"Some random message") == PBSE_SYSTEM);
   fail_unless(pjob->ji_momhandle == -1);
   fail_unless((pjob->ji_qs.ji_svrflags & JOB_SVFLG_HASRUN) != 0);
   fail_unless((pjob->ji_qs.ji_svrflags & JOB_SVFLG_CHECKPOINT_FILE) != 0);
@@ -491,7 +491,7 @@ START_TEST(update_substate_from_exit_status_test)
   alreadymailed = 0;
   pjob->ji_qs.ji_substate = JOB_SUBSTATE_RUNNING;
   pjob->ji_qs.ji_un.ji_exect.ji_exitstat = JOB_EXEC_INITRMG;
-  fail_unless(update_substate_from_exit_status(pjob, &alreadymailed) == PBSE_NONE);
+  fail_unless(update_substate_from_exit_status(pjob, &alreadymailed,"Some random message") == PBSE_NONE);
   fail_unless((pjob->ji_qs.ji_svrflags & JOB_SVFLG_HASRUN) != 0);
   fail_unless((pjob->ji_qs.ji_svrflags & JOB_SVFLG_CHECKPOINT_MIGRATEABLE) != 0);
 
diff --git a/src/server/test/svr_mail/test_svr_mail.c b/src/server/test/svr_mail/test_svr_mail.c
index 8a03b5b01..80a6ad455 100644
--- a/src/server/test/svr_mail/test_svr_mail.c
+++ b/src/server/test/svr_mail/test_svr_mail.c
@@ -19,6 +19,7 @@ const char jobname[] = "testJob";
 const char errpath[] = "xyz_host.ac:/home/echan/work/dev/torque/trunk/STDIN.e123";
 const char outpath[] = "xyz_host.ac:/home/echan/work/dev/torque/trunk/STDIN.o123";
 const char mailbuf[] = "Exit_status=271";
+const char msgbuf[]  = "Resources Used: One gallon of diesel; One bag Doritos; 2 liters Pepsi.";
 const char complete[] = "e";
 
 void init_server()
@@ -54,6 +55,7 @@ START_TEST(test_with_default_files_when_complete)
   FILE *fp = NULL;
   bool errFile_found = false;
   bool outFile_found = false;
+  bool msg_found = false;
   char buf[512];
   char correct_outfilepath[512];
   char correct_errfilepath[512];
@@ -81,6 +83,30 @@ START_TEST(test_with_default_files_when_complete)
     fclose(fp);
     remove_old_mail("/tmp/mail.out");
     }
+
+  errFile_found = false;
+  outFile_found = false;
+
+  svr_mailowner_with_message(&pjob, MAIL_END, MAIL_NORMAL, mailbuf,msgbuf);
+  fp = fopen("/tmp/mail.out", "r");
+  /* if fp is null, no email program was set hence no test */
+  if (fp)
+    {
+    while (fgets(buf, sizeof(buf), fp) != NULL)
+      {
+      if (strstr(buf, correct_errfilepath))
+        errFile_found = true;
+      else if (strstr(buf, correct_outfilepath))
+        outFile_found = true;
+      else if (strstr(buf,msgbuf))
+        msg_found = true;
+      }
+    fail_unless(errFile_found, "No error file path was found in the mail");
+    fail_unless(outFile_found, "No output file path was found in the mail");
+    fail_unless(msg_found,"The additional message was not found in the mail.");
+    fclose(fp);
+    remove_old_mail("/tmp/mail.out");
+    }
   }
 END_TEST
 
@@ -90,6 +116,7 @@ START_TEST(test_with_oe_when_complete)
   FILE *fp = NULL;
   bool errFile_found = false;
   bool outFile_found = false;
+  bool msg_found = false;
   char buf[512];
   char correct_outfilepath[512];
   char correct_errfilepath[512];
@@ -121,6 +148,31 @@ START_TEST(test_with_oe_when_complete)
     fclose(fp);
     remove_old_mail("/tmp/mail.out");
     }
+
+  errFile_found = false;
+  outFile_found = false;
+
+  svr_mailowner_with_message(&pjob, MAIL_END, MAIL_NORMAL, mailbuf,msgbuf);
+  fp = fopen("/tmp/mail.out", "r");
+  /* if fp is null, no email program was set hence no test */
+  if (fp)
+    {
+    while (fgets(buf, sizeof(buf), fp) != NULL)
+      {
+      if (strstr(buf, correct_errfilepath))
+        errFile_found = true;
+      else if (strstr(buf, correct_outfilepath))
+        outFile_found = true;
+      else if (strstr(buf,msgbuf))
+        msg_found = true;
+      }
+    fail_unless(errFile_found, "No error file path was found in the mail");
+    fail_unless(outFile_found, "No output file path was found in the mail");
+    fail_unless(msg_found,"The additional message was not found in the mail.");
+    fclose(fp);
+    remove_old_mail("/tmp/mail.out");
+    }
+
   }
 END_TEST
 
@@ -130,6 +182,7 @@ START_TEST(test_with_eo_when_complete)
   FILE *fp = NULL;
   bool errFile_found = false;
   bool outFile_found = false;
+  bool msg_found = false;
   char buf[512];
   char correct_outfilepath[512];
   char correct_errfilepath[512];
@@ -161,6 +214,31 @@ START_TEST(test_with_eo_when_complete)
     fclose(fp);
     remove_old_mail("/tmp/mail.out");
     }
+
+  errFile_found = false;
+  outFile_found = false;
+
+  svr_mailowner_with_message(&pjob, MAIL_END, MAIL_NORMAL, mailbuf,msgbuf);
+  fp = fopen("/tmp/mail.out", "r");
+  /* if fp is null, no email program was set hence no test */
+  if (fp)
+    {
+    while (fgets(buf, sizeof(buf), fp) != NULL)
+      {
+      if (strstr(buf, correct_errfilepath))
+        errFile_found = true;
+      else if (strstr(buf, correct_outfilepath))
+        outFile_found = true;
+      else if (strstr(buf,msgbuf))
+        msg_found = true;
+      }
+    fail_unless(errFile_found, "No error file path was found in the mail");
+    fail_unless(outFile_found, "No output file path was found in the mail");
+    fail_unless(msg_found,"The additional message was not found in the mail.");
+    fclose(fp);
+    remove_old_mail("/tmp/mail.out");
+    }
+
   }
 END_TEST
 

