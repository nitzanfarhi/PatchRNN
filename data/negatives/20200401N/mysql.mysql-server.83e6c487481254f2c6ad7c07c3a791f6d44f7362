commit 83e6c487481254f2c6ad7c07c3a791f6d44f7362
Author: Tor Didriksen <tor.didriksen@oracle.com>
Date:   Thu Apr 30 13:28:59 2015 +0200

    Bug#20988128 USE PREALLOCED_ARRAY RATHER THAN RAW C ARRAY FOR HTON2PLUGIN[]
    
    In handler.cc
    Use Prealloced_array rather than raw C arrays for
    hton2plugin[] and builtin_htons[]
    
    In handler.h
    Hide static array of htons, add access functions instead.
    
    In opt_costconstants
    Use Prealloced_array rather than raw C array for m_engines.
    
    In sql_class
    Use Prealloced_array rather than raw C array for
    Transaction_state::m_ha_data and THD::ha_data.
    
    Extensions to Prealloced_array
    - Add Prealloced_array::initial_capacity
    
    - Use Prealloced_array similar to raw C array:
      Add Prealloced_array(PSI_memory_key psi_key, size_t initial_size)
    
    - Assign a value to an arbitrary element:
      Prealloced_array::assign_at.

diff --git a/include/prealloced_array.h b/include/prealloced_array.h
index fc754bdbd56..0d93ff064ef 100644
--- a/include/prealloced_array.h
+++ b/include/prealloced_array.h
@@ -67,6 +67,9 @@ class Prealloced_array
   }
 public:
 
+  /// Initial capacity of the array.
+  static const size_t initial_capacity= Prealloc;
+
   /// Standard typedefs.
   typedef Element_type value_type;
   typedef size_t       size_type;
@@ -83,6 +86,34 @@ public:
     compile_time_assert(Prealloc != 0);
   }
 
+  /**
+    Initializes (parts of) the array with default values.
+    Using 'Prealloc' for initial_size makes this similar to a raw C array.
+  */
+  Prealloced_array(PSI_memory_key psi_key, size_t initial_size)
+    : m_size(0), m_capacity(Prealloc), m_array_ptr(cast_rawbuff()),
+      m_psi_key(psi_key)
+  {
+    // We do not want a zero-size array.
+    compile_time_assert(Prealloc != 0);
+
+    if (initial_size > Prealloc)
+    {
+      // We avoid using reserve() since it requires Element_type to be copyable.
+      void *mem=
+        my_malloc(m_psi_key, initial_size * element_size(), MYF(MY_WME));
+      if (!mem)
+        return;
+      m_array_ptr= static_cast<Element_type*>(mem);
+      m_capacity= initial_size;
+    }
+    for (size_t ix= 0; ix < initial_size; ++ix)
+    {
+      Element_type *p= &m_array_ptr[m_size++];
+      ::new (p) Element_type();
+    }
+  }
+
   /**
     An object instance "owns" its array, so we do deep copy here.
    */
@@ -177,6 +208,24 @@ public:
   const_iterator begin() const { return m_array_ptr; }
   const_iterator end()   const { return m_array_ptr + size(); }
 
+  /**
+    Assigns a value to an arbitrary element, even where n >= size().
+    The array is extended with default values if necessary.
+    @retval true if out-of-memory, false otherwise.
+  */
+  bool assign_at(size_t n, const value_type &val)
+  {
+    if (n < size())
+    {
+      at(n)= val;
+      return false;
+    }
+    if (reserve(n + 1))
+      return true;
+    resize(n);
+    return push_back(val);
+  }
+
   /**
     Reserves space for array elements.
     Copies over existing elements, in case we are re-expanding the array.
diff --git a/sql/handler.cc b/sql/handler.cc
index add3c57ee55..fdf323aa80c 100644
--- a/sql/handler.cc
+++ b/sql/handler.cc
@@ -183,22 +183,51 @@ inline double log2(double x)
 }
 #endif
 
-/*
+/**
   While we have legacy_db_type, we have this array to
   check for dups and to find handlerton from legacy_db_type.
   Remove when legacy_db_type is finally gone
 */
-st_plugin_int *hton2plugin[MAX_HA];
+static
+Prealloced_array<st_plugin_int*, PREALLOC_NUM_HA, true>
+se_plugin_array(PSI_NOT_INSTRUMENTED);
 
 /**
   Array allowing to check if handlerton is builtin without
   acquiring LOCK_plugin.
 */
-static bool builtin_htons[MAX_HA];
+static
+Prealloced_array<bool, PREALLOC_NUM_HA, true>
+builtin_htons(PSI_NOT_INSTRUMENTED);
+
+st_plugin_int *hton2plugin(uint slot)
+{
+  return se_plugin_array[slot];
+}
+
+size_t num_hton2plugins()
+{
+  return se_plugin_array.size();
+}
+
+st_plugin_int *insert_hton2plugin(uint slot, st_plugin_int* plugin)
+{
+  if (se_plugin_array.assign_at(slot, plugin))
+    return NULL;
+  return se_plugin_array[slot];
+}
+
+st_plugin_int *remove_hton2plugin(uint slot)
+{
+  st_plugin_int *retval= se_plugin_array[slot];
+  se_plugin_array[slot]= NULL;
+  return retval;
+}
+
 
 const char *ha_resolve_storage_engine_name(const handlerton *db_type)
 {
-  return db_type == NULL ? "UNKNOWN" : hton2plugin[db_type->slot]->name.str;
+  return db_type == NULL ? "UNKNOWN" : hton2plugin(db_type->slot)->name.str;
 }
 
 static handlerton *installed_htons[128];
@@ -206,8 +235,6 @@ static handlerton *installed_htons[128];
 KEY_CREATE_INFO default_key_create_info=
   { HA_KEY_ALG_UNDEF, 0, {NullS, 0}, {NullS, 0}, true };
 
-/* number of entries in installed_htons[] */
-static ulong total_ha= 0;
 /* number of storage engines (from installed_htons[]) that support 2pc */
 ulong total_ha_2pc= 0;
 /* size of savepoint storage area (see ha_init) */
@@ -496,7 +523,7 @@ plugin_ref ha_lock_engine(THD *thd, const handlerton *hton)
 {
   if (hton)
   {
-    st_plugin_int **plugin= hton2plugin + hton->slot;
+    st_plugin_int **plugin= &se_plugin_array[hton->slot];
 
 #ifdef DBUG_OFF
     /*
@@ -737,9 +764,9 @@ int ha_finalize_handlerton(st_plugin_int *plugin)
   if (hton->slot != HA_SLOT_UNDEF)
   {
     /* Make sure we are not unpluging another plugin */
-    DBUG_ASSERT(hton2plugin[hton->slot] == plugin);
-    DBUG_ASSERT(hton->slot < MAX_HA);
-    hton2plugin[hton->slot]= NULL;
+    DBUG_ASSERT(se_plugin_array[hton->slot] == plugin);
+    DBUG_ASSERT(hton->slot < se_plugin_array.size());
+    se_plugin_array[hton->slot]= NULL;
     builtin_htons[hton->slot]= false; /* Extra correctness. */
   }
 
@@ -815,30 +842,27 @@ int ha_initialize_handlerton(st_plugin_int *plugin)
         reuse an array slot. Otherwise the number of uninstall/install
         cycles would be limited. So look for a free slot.
       */
-      DBUG_PRINT("plugin", ("total_ha: %lu", total_ha));
-      for (fslot= 0; fslot < total_ha; fslot++)
+      DBUG_PRINT("plugin", ("total_ha: %lu",
+                            static_cast<ulong>(se_plugin_array.size())));
+      for (fslot= 0; fslot < se_plugin_array.size(); fslot++)
       {
-        if (!hton2plugin[fslot])
+        if (!se_plugin_array[fslot])
           break;
       }
-      if (fslot < total_ha)
+      if (fslot < se_plugin_array.size())
         hton->slot= fslot;
       else
       {
-        if (total_ha >= MAX_HA)
-        {
-          sql_print_error("Too many plugins loaded. Limit is %lu. "
-                          "Failed on '%s'", (ulong) MAX_HA, plugin->name.str);
-          goto err_deinit;
-        }
-        hton->slot= total_ha++;
+        hton->slot= se_plugin_array.size();
       }
+      if (se_plugin_array.assign_at(hton->slot, plugin) ||
+          builtin_htons.assign_at(hton->slot, (plugin->plugin_dl == NULL)))
+        goto err_deinit;
+
       installed_htons[hton->db_type]= hton;
       tmp= hton->savepoint_offset;
       hton->savepoint_offset= savepoint_alloc_size;
       savepoint_alloc_size+= tmp;
-      hton2plugin[hton->slot]=plugin;
-      builtin_htons[hton->slot]= (plugin->plugin_dl == NULL);
       if (hton->prepare)
         total_ha_2pc++;
       break;
@@ -896,13 +920,12 @@ int ha_init()
   int error= 0;
   DBUG_ENTER("ha_init");
 
-  DBUG_ASSERT(total_ha < MAX_HA);
   /*
     Check if there is a transaction-capable storage engine besides the
-    binary log (which is considered a transaction-capable storage engine in
-    counting total_ha)
+    binary log.
   */
-  opt_using_transactions= total_ha>(ulong)opt_bin_log;
+  opt_using_transactions=
+    se_plugin_array.size() > static_cast<ulong>(opt_bin_log);
   savepoint_alloc_size+= sizeof(SAVEPOINT);
 
   /*
@@ -7271,7 +7294,7 @@ bool ha_show_status(THD *thd, handlerton *db_type, enum ha_stat_type stat)
   {
     if (db_type->state != SHOW_OPTION_YES)
     {
-      const LEX_STRING *name=&hton2plugin[db_type->slot]->name;
+      const LEX_STRING *name= &se_plugin_array[db_type->slot]->name;
       result= stat_print(thd, name->str, name->length,
                          "", 0, "DISABLED", 8) ? 1 : 0;
     }
diff --git a/sql/handler.h b/sql/handler.h
index 2a1c107f84c..d668a3f5b92 100644
--- a/sql/handler.h
+++ b/sql/handler.h
@@ -73,14 +73,25 @@ extern MYSQL_PLUGIN_IMPORT const Key_map key_map_empty;
 extern MYSQL_PLUGIN_IMPORT Key_map key_map_full; // Should be treated as const
 
 /*
-  Note: the following includes binlog and closing 0.
+  We preallocate data for several storage engine plugins.
   so: innodb + bdb + ndb + binlog + myisam + myisammrg + archive +
       example + csv + heap + blackhole + federated + 0
   (yes, the sum is deliberately inaccurate)
-  TODO remove the limit, use dynarrays
 */
-#define MAX_HA 15
-extern st_plugin_int *hton2plugin[MAX_HA];
+#define PREALLOC_NUM_HA 15
+
+/// Maps from slot to plugin. May return NULL if plugin has been unloaded.
+st_plugin_int *hton2plugin(uint slot);
+/// Returns the size of the array holding pointers to plugins.
+size_t num_hton2plugins();
+
+/**
+  For unit testing.
+  Insert plugin into arbitrary slot in array.
+  Remove plugin from arbitrary slot in array.
+*/
+st_plugin_int *insert_hton2plugin(uint slot, st_plugin_int* plugin);
+st_plugin_int *remove_hton2plugin(uint slot);
 
 extern const char *ha_row_type[];
 extern const char *tx_isolation_names[];
diff --git a/sql/opt_costconstants.cc b/sql/opt_costconstants.cc
index b85934238c0..5f341fadbd8 100644
--- a/sql/opt_costconstants.cc
+++ b/sql/opt_costconstants.cc
@@ -235,20 +235,21 @@ Cost_model_se_info::~Cost_model_se_info()
 
 
 Cost_model_constants::Cost_model_constants()
-  : m_ref_counter(0)
+  : m_engines(PSI_NOT_INSTRUMENTED, num_hton2plugins()),
+    m_ref_counter(0)
 {
   /**
     Create default cost constants for each storage engine.
   */
-  for (uint engine= 0; engine < MAX_HA; ++engine)
+  for (size_t engine= 0; engine < m_engines.size(); ++engine)
   {
     const handlerton *ht= NULL;
 
     // Check if the storage engine has been installed
-    if (hton2plugin[engine])
+    if (hton2plugin(engine))
     {
       // Find the handlerton for the storage engine
-      ht= static_cast<handlerton*>(hton2plugin[engine]->data);
+      ht= static_cast<handlerton*>(hton2plugin(engine)->data);
     }
 
     for (uint storage= 0; storage < MAX_STORAGE_CLASSES; ++storage)
@@ -288,8 +289,16 @@ const SE_cost_constants
   DBUG_ASSERT(table->file != NULL);
   DBUG_ASSERT(table->file->ht != NULL);
 
+  static SE_cost_constants default_cost;
+
+  /*
+    We do not see data for new htons loaded by the current session,
+    use default statistics.
+  */
+  const uint slot= table->file->ht->slot;
   const SE_cost_constants *se_cc=
-    m_engines[table->file->ht->slot].get_cost_constants(DEFAULT_STORAGE_CLASS);
+    slot < m_engines.size() ?
+    m_engines[slot].get_cost_constants(DEFAULT_STORAGE_CLASS) : &default_cost;
   DBUG_ASSERT(se_cc != NULL);
 
   return se_cc;
@@ -382,7 +391,7 @@ Cost_model_constants::update_engine_default_cost(const LEX_CSTRING &name,
   /*
     Update all constants for engines that have their own cost constants
   */
-  for (size_t i= 0; i < MAX_HA; ++i)
+  for (size_t i= 0; i < m_engines.size(); ++i)
   {
     SE_cost_constants *se_cc= m_engines[i].get_cost_constants(storage_category);
     if (se_cc)
diff --git a/sql/opt_costconstants.h b/sql/opt_costconstants.h
index 4291c1dfabe..287d30927db 100644
--- a/sql/opt_costconstants.h
+++ b/sql/opt_costconstants.h
@@ -18,8 +18,8 @@
    51 Franklin Street, Suite 500, Boston, MA 02110-1335 USA */
 
 #include "my_global.h"
-#include "handler.h"                            // MAX_HA
 #include "m_string.h"                           // LEX_CSTRING
+#include "prealloced_array.h"
 
 class THD;
 struct TABLE;
@@ -550,8 +550,11 @@ private:
   /// Cost constants for server operations
   Server_cost_constants m_server_constants;
 
-  /// Cost constants for storage engines
-  Cost_model_se_info m_engines[MAX_HA];
+  /**
+    Cost constants for storage engines
+    15 should be enough for most use cases, see PREALLOC_NUM_HA.
+  */
+  Prealloced_array<Cost_model_se_info, 15, false> m_engines;
 
   /// Reference counter for this set of cost constants.
   unsigned int m_ref_counter;
diff --git a/sql/sql_class.cc b/sql/sql_class.cc
index 4fcaceb8c02..2753a30def0 100644
--- a/sql/sql_class.cc
+++ b/sql/sql_class.cc
@@ -90,6 +90,10 @@ const char * const THD::DEFAULT_WHERE= "field list";
 
 struct Transaction_state
 {
+  Transaction_state()
+    : m_ha_data(PSI_NOT_INSTRUMENTED, m_ha_data.initial_capacity)
+  {}
+
   void backup(THD *thd);
   void restore(THD *thd);
 
@@ -108,7 +112,7 @@ struct Transaction_state
   enum_tx_isolation m_tx_isolation;
 
   /// Ha_data array.
-  Ha_data m_ha_data[MAX_HA];
+  Prealloced_array<Ha_data, PREALLOC_NUM_HA> m_ha_data;
 
   /// Transaction_ctx instance.
   Transaction_ctx *m_trx;
@@ -132,8 +136,7 @@ void Transaction_state::backup(THD *thd)
   this->m_sql_command= thd->lex->sql_command;
   this->m_trx= thd->get_transaction();
 
-  for (int i= 0; i < MAX_HA; ++i)
-    this->m_ha_data[i]= thd->ha_data[i];
+  this->m_ha_data= thd->ha_data;
 
   this->m_tx_isolation= thd->tx_isolation;
   this->m_tx_read_only= thd->tx_read_only;
@@ -148,8 +151,7 @@ void Transaction_state::restore(THD *thd)
 {
   thd->set_transaction(this->m_trx);
 
-  for (int i= 0; i < MAX_HA; ++i)
-    thd->ha_data[i]= this->m_ha_data[i];
+  thd->ha_data= this->m_ha_data;
 
   thd->tx_isolation= this->m_tx_isolation;
   thd->variables.sql_mode= this->m_sql_mode;
@@ -220,8 +222,8 @@ THD::Attachable_trx::Attachable_trx(THD *thd)
 
   // Prepare for a new attachable transaction for read-only DD-transaction.
 
-  for (int i= 0; i < MAX_HA; ++i)
-    m_thd->ha_data[i]= Ha_data();
+  m_thd->ha_data.clear();
+  m_thd->ha_data.resize(m_thd->ha_data.capacity());
 
   // The attachable transaction must used READ COMMITTED isolation level.
 
@@ -441,6 +443,7 @@ THD::THD(bool enable_plugins)
    in_sub_stmt(0),
    fill_status_recursion_level(0),
    fill_variables_recursion_level(0),
+   ha_data(PSI_NOT_INSTRUMENTED, ha_data.initial_capacity),
    binlog_row_event_extra_data(NULL),
    binlog_unsafe_warning_flags(0),
    binlog_table_maps(0),
@@ -533,7 +536,6 @@ THD::THD(bool enable_plugins)
   query_id= 0;
   query_name_consts= 0;
   db_charset= global_system_variables.collation_database;
-  memset(ha_data, 0, sizeof(ha_data));
   mysys_var=0;
   binlog_evt_union.do_union= FALSE;
   enable_slow_log= 0;
diff --git a/sql/sql_class.h b/sql/sql_class.h
index b5e48b9a2ad..d0597ad4f82 100644
--- a/sql/sql_class.h
+++ b/sql/sql_class.h
@@ -1185,7 +1185,7 @@ public:
   uint fill_variables_recursion_level;
 
   /* container for handler's private per-connection data */
-  Ha_data ha_data[MAX_HA];
+  Prealloced_array<Ha_data, PREALLOC_NUM_HA> ha_data;
 
   /*
     Position of first event in Binlog
diff --git a/unittest/gunit/opt_costconstants-t.cc b/unittest/gunit/opt_costconstants-t.cc
index 03a8c09b373..66f0a47d402 100644
--- a/unittest/gunit/opt_costconstants-t.cc
+++ b/unittest/gunit/opt_costconstants-t.cc
@@ -65,17 +65,28 @@ protected:
   {
     initializer.SetUp();
 
-    // Initilize one storage engine
-    LEX_STRING engine_name= {C_STRING_WITH_LEN("InnoDB")};
-    hton2plugin[0]= new st_plugin_int();
-    hton2plugin[0]->name= engine_name;
+    // Initilize some storage engines
+    LEX_STRING engine_name0= { C_STRING_WITH_LEN("InnoDB0") };
+    LEX_STRING engine_name1= { C_STRING_WITH_LEN("InnoDB1") };
+    LEX_STRING engine_name2= { C_STRING_WITH_LEN("InnoDB2") };
+    LEX_STRING engine_name4= { C_STRING_WITH_LEN("InnoDB4") };
+    LEX_STRING engine_name7= { C_STRING_WITH_LEN("InnoDB7") };
+
+    insert_hton2plugin(0, new st_plugin_int())->name= engine_name0;
+    insert_hton2plugin(1, new st_plugin_int())->name= engine_name1;
+    insert_hton2plugin(2, new st_plugin_int())->name= engine_name2;
+    insert_hton2plugin(4, new st_plugin_int())->name= engine_name4;
+    insert_hton2plugin(7, new st_plugin_int())->name= engine_name7;
   }
 
   virtual void TearDown()
   {
     initializer.TearDown();
-    delete hton2plugin[0];
-    hton2plugin[0]= NULL;
+    delete remove_hton2plugin(0);
+    delete remove_hton2plugin(1);
+    delete remove_hton2plugin(2);
+    delete remove_hton2plugin(4);
+    delete remove_hton2plugin(7);
   }
 
   THD *thd() { return initializer.thd(); }
diff --git a/unittest/gunit/opt_costmodel-t.cc b/unittest/gunit/opt_costmodel-t.cc
index c956005903d..131d0dea6ba 100644
--- a/unittest/gunit/opt_costmodel-t.cc
+++ b/unittest/gunit/opt_costmodel-t.cc
@@ -38,16 +38,13 @@ protected:
     // for the storage engine
     LEX_STRING engine_name= {C_STRING_WITH_LEN("InnoDB")};
 
-    hton2plugin[0]= new st_plugin_int();
-    hton2plugin[0]->name= engine_name;
-
+    insert_hton2plugin(0, new st_plugin_int())->name= engine_name;
     initializer.SetUp();
   }
   virtual void TearDown()
   {
     initializer.TearDown();
-    delete hton2plugin[0];
-    hton2plugin[0]= NULL;
+    delete remove_hton2plugin(0);
   }
 
   THD *thd() { return initializer.thd(); }
@@ -65,7 +62,7 @@ void test_tmptable_cost(const Cost_model_server *cm,
   const uint rows= 3;
 
   // Cost of inserting and reading data in a temporary table
-  EXPECT_EQ(cm->tmptable_readwrite_cost(tmp_table_type, rows, rows), 
+  EXPECT_EQ(cm->tmptable_readwrite_cost(tmp_table_type, rows, rows),
             rows * cm->tmptable_readwrite_cost(tmp_table_type, 1.0, 1.0));
 }
 
diff --git a/unittest/gunit/prealloced_array-t.cc b/unittest/gunit/prealloced_array-t.cc
index 9a52f854db9..b5b8f81d717 100644
--- a/unittest/gunit/prealloced_array-t.cc
+++ b/unittest/gunit/prealloced_array-t.cc
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2013, 2015, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -303,6 +303,52 @@ private:
   To verify that there are no leaks, do:
   valgrind ./prealloced_array-t --gtest_filter="-*DeathTest*"
 */
+TEST_F(PreallocedArrayTest, NoMemLeaksAssignAt)
+{
+  Prealloced_array<IntWrap, 10, false>
+    array(PSI_NOT_INSTRUMENTED, 0);
+  EXPECT_EQ(0U, array.size());
+  
+  array.assign_at(3, IntWrap(3));
+  EXPECT_EQ(4U, array.size());
+  EXPECT_EQ(3, array[3].getval());
+  EXPECT_EQ(0, array[0].getval());
+
+  array.assign_at(0, IntWrap(42));
+  EXPECT_EQ(4U, array.size());
+  EXPECT_EQ(42, array[0].getval());
+  
+  array.assign_at(4, IntWrap(4));
+  EXPECT_EQ(5U, array.size());
+  EXPECT_EQ(4, array[4].getval());
+
+  array.assign_at(42, IntWrap(42));
+  EXPECT_EQ(43U, array.size());
+  EXPECT_EQ(42, array[42].getval());
+
+  array.assign_at(0, IntWrap(0));
+  EXPECT_EQ(0, array[0].getval());
+}
+
+TEST_F(PreallocedArrayTest, NoMemLeaksInitializing)
+{
+  Prealloced_array<IntWrap, 10, false>
+    array1(PSI_NOT_INSTRUMENTED, 0);
+  EXPECT_EQ(0U, array1.size());
+
+  Prealloced_array<IntWrap, 10, false>
+    array2(PSI_NOT_INSTRUMENTED, 5);
+  EXPECT_EQ(5U, array2.size());
+
+  Prealloced_array<IntWrap, 10, false>
+    array3(PSI_NOT_INSTRUMENTED, array3.initial_capacity);
+  EXPECT_EQ(10U, array3.size());
+
+  Prealloced_array<IntWrap, 10, false>
+    array4(PSI_NOT_INSTRUMENTED, 2 * array4.initial_capacity);
+  EXPECT_EQ(20U, array4.size());
+}
+
 TEST_F(PreallocedArrayTest, NoMemLeaksPushing)
 {
   Prealloced_array<IntWrap, 1, false> array(PSI_NOT_INSTRUMENTED);

