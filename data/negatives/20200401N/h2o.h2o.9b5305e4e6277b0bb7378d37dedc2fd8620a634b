commit 9b5305e4e6277b0bb7378d37dedc2fd8620a634b
Author: Kazuho Oku <kazuhooku@gmail.com>
Date:   Fri Sep 9 10:17:17 2016 +0900

    refactor

diff --git a/lib/core/request.c b/lib/core/request.c
index 77e1b301..0d127158 100644
--- a/lib/core/request.c
+++ b/lib/core/request.c
@@ -19,10 +19,16 @@
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  * IN THE SOFTWARE.
  */
+#include <limits.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <sys/uio.h>
 #include "h2o.h"
 
+#ifndef IOV_MAX
+#define IOV_MAX UIO_MAXIOV
+#endif
+
 #define INITIAL_INBUFSZ 8192
 
 struct st_delegate_request_deferred_t {
@@ -502,27 +508,45 @@ DECL_SEND_ERROR_DEFERRED(502)
 
 void h2o_req_log_error(h2o_req_t *req, const char *module, const char *fmt, ...)
 {
-#define PREFIX "[%s] in request:%.32s:"
-    char *fmt_prefixed = alloca(sizeof("[] in request::\n") + 32 + strlen(module) + strlen(fmt)), *p = fmt_prefixed;
-
-    p += sprintf(fmt_prefixed, "[%s] in request:", module);
-    if (req->path.len < 32) {
-        memcpy(p, req->path.base, req->path.len);
-        p += req->path.len;
-    } else {
-        memcpy(p, req->path.base, 29);
-        p += 29;
-        memcpy(p, "...", 3);
-        p += 3;
-    }
-    *p++ = ':';
-    strcpy(p, fmt);
-    strcat(p, "\n");
+#define INITIAL_BUF_SIZE 256
 
+    char *errbuf = h2o_mem_alloc_pool(&req->pool, INITIAL_BUF_SIZE);
+    int errlen;
     va_list args;
+
     va_start(args, fmt);
-    vfprintf(stderr, fmt_prefixed, args);
+    errlen = vsnprintf(errbuf, INITIAL_BUF_SIZE, fmt, args);
     va_end(args);
+
+    if (errlen >= INITIAL_BUF_SIZE) {
+        errbuf = h2o_mem_alloc_pool(&req->pool, errlen + 1);
+        va_start(args, fmt);
+        errlen = vsnprintf(errbuf, errlen + 1, fmt, args);
+        va_end(args);
+    }
+
+#undef INITIAL_BUF_SIZE
+
+    /* we may want to disable logging to STDERR */
+    if (1) {
+        /* build prefix */
+        char *prefix = alloca(sizeof("[] in request::") + 32 + strlen(module)), *p = prefix;
+        p += sprintf(p, "[%s] in request:", module);
+        if (req->path.len < 32) {
+            memcpy(p, req->path.base, req->path.len);
+            p += req->path.len;
+        } else {
+            memcpy(p, req->path.base, 29);
+            p += 29;
+            memcpy(p, "...", 3);
+            p += 3;
+        }
+        *p++ = ':';
+        /* use writev(2) to emit error atomically */
+        struct iovec vecs[] = {{prefix, p - prefix}, {errbuf, errlen}};
+        H2O_BUILD_ASSERT(sizeof(vecs) / sizeof(vecs[0]) < IOV_MAX);
+        writev(2, vecs, sizeof(vecs) / sizeof(vecs[0]));
+    }
 }
 
 void h2o_send_redirect(h2o_req_t *req, int status, const char *reason, const char *url, size_t url_len)

