commit 8fec35fd3225893aaa0f06092405e83e730b7b2d
Author: Mark Williams <mwilliams@fb.com>
Date:   Thu Jul 5 20:33:39 2018 -0700

    Add subtypeOf(trep) and couldBe(trep)
    
    Summary:
    subtypeOf(T<x>) (and couldBe) can be determined solely by looking at
    the trep of T<x>, but in practice the compiler generates code to load
    the trep, and then check the tag to make sure it doesn't have data
    associated with it. Although we've streamlined this, its still much
    better to just pass the trep in directly.
    
    This also means that we can often do `subtypeOf(BX | BY)` rather than
    `subtypeOf(BX) || subtypeOf(BY)` (even when BX | BY isn't a
    "predefined" type).
    
    In addition, add a `subtypeOrNull(bits)` method which is equivalent to
    `subtypeOf(bits | BInitNull)`; this will be changed to BNull in later
    diffs when we add support for BUninit in optional types (and avoids
    the need to add named types for all the new nullish types that will
    arise).
    
    Reviewed By: ricklavoie
    
    Differential Revision: D8714389
    
    fbshipit-source-id: 83f548f8afbcbeddb4f51384e0d0c9948ea3082c

diff --git a/hphp/hhbbc/analyze.cpp b/hphp/hhbbc/analyze.cpp
index e296a6a59f..16496ee335 100644
--- a/hphp/hhbbc/analyze.cpp
+++ b/hphp/hhbbc/analyze.cpp
@@ -427,7 +427,7 @@ FuncAnalysis do_analyze_collect(const Index& index,
    * In this case, we leave the return type as TBottom, to indicate
    * the same to callers.
    */
-  assert(ai.inferredReturn.subtypeOf(TGen));
+  assert(ai.inferredReturn.subtypeOf(BGen));
 
   // For debugging, print the final input states for each block.
   FTRACE(2, "{}", [&] {
@@ -640,7 +640,7 @@ ClassAnalysis analyze_class(const Index& index, Context const ctx) {
 
     if (!(prop.attrs & AttrStatic)) {
       auto t = (prop.attrs & AttrNoSerialize) ? cellTy : loosen_all(cellTy);
-      if (!is_closure(*ctx.cls) && t.subtypeOf(TUninit)) {
+      if (!is_closure(*ctx.cls) && t.subtypeOf(BUninit)) {
         /*
          * For non-closure classes, a property of type KindOfUninit
          * means that it has non-scalar initializer which will be set
@@ -662,7 +662,7 @@ ClassAnalysis analyze_class(const Index& index, Context const ctx) {
       // though---we use instance properties for the closure
       // 86static_* properties.
       auto t = cellTy;
-      if (t.subtypeOf(TUninit)) {
+      if (t.subtypeOf(BUninit)) {
         t = TBottom;
       }
       clsAnalysis.privateStatics[prop.name] = t;
@@ -715,9 +715,9 @@ ClassAnalysis analyze_class(const Index& index, Context const ctx) {
   for (auto& prop : ctx.cls->properties) {
     if (!(prop.attrs & AttrPrivate)) continue;
     if (prop.attrs & AttrStatic) {
-      assert(!clsAnalysis.privateStatics[prop.name].subtypeOf(TBottom));
+      assert(!clsAnalysis.privateStatics[prop.name].subtypeOf(BBottom));
     } else {
-      assert(!clsAnalysis.privateProperties[prop.name].subtypeOf(TBottom));
+      assert(!clsAnalysis.privateProperties[prop.name].subtypeOf(BBottom));
     }
   }
 
diff --git a/hphp/hhbbc/dce.cpp b/hphp/hhbbc/dce.cpp
index 38471caea7..1b39bed20e 100644
--- a/hphp/hhbbc/dce.cpp
+++ b/hphp/hhbbc/dce.cpp
@@ -189,13 +189,13 @@ uint32_t numPush(const Bytecode& bc) {
 // a Ref).
 bool setCouldHaveSideEffects(const Type& t) {
   return
-    t.couldBe(TRef) ||
+    t.couldBe(BRef) ||
     could_run_destructor(t);
 }
 
 // Some reads could raise warnings and run arbitrary code.
 bool readCouldHaveSideEffects(const Type& t) {
-  return t.couldBe(TUninit);
+  return t.couldBe(BUninit);
 }
 
 //////////////////////////////////////////////////////////////////////
@@ -577,7 +577,7 @@ Type topT(Env& env, uint32_t idx = 0) {
 
 Type topC(Env& env, uint32_t idx = 0) {
   auto const t = topT(env, idx);
-  assert(t.subtypeOf(TInitCell));
+  assert(t.subtypeOf(BInitCell));
   return t;
 }
 
@@ -1128,7 +1128,7 @@ void dce(Env& env, const bc::ClsRefName& op) {
 }
 
 bool clsRefGetHelper(Env& env, const Type& ty, ClsRefSlotId slot) {
-  if (!ty.subtypeOf(TObj)) {
+  if (!ty.subtypeOf(BObj)) {
     if (!ty.strictSubtypeOf(TStr)) return false;
     auto v = tv(ty);
     if (!v) return false;
@@ -1420,10 +1420,10 @@ void dce(Env& env, const bc::AddElemC& /*op*/) {
         if (allUnusedIfNotLastRef(ui)) return PushFlags::MarkUnused;
         auto v = tv(arrPost);
         CompactVector<Bytecode> bcs;
-        if (arrPost.subtypeOf(TArrN)) {
+        if (arrPost.subtypeOf(BArrN)) {
           bcs.emplace_back(bc::Array { v->m_data.parr });
         } else {
-          assert(arrPost.subtypeOf(TDictN));
+          assert(arrPost.subtypeOf(BDictN));
           bcs.emplace_back(bc::Dict { v->m_data.parr });
         }
         env.dceState.replaceMap.emplace(env.id, std::move(bcs));
@@ -1437,20 +1437,20 @@ void dce(Env& env, const bc::AddElemC& /*op*/) {
         CompactVector<Bytecode> bcs;
         if (cat.cat == Type::ArrayCat::Struct &&
             *postSize <= ArrayData::MaxElemsOnStack) {
-          if (arrPost.subtypeOf(TPArrN)) {
+          if (arrPost.subtypeOf(BPArrN)) {
             bcs.emplace_back(bc::NewStructArray { get_string_keys(arrPost) });
-          } else if (arrPost.subtypeOf(TDArrN)) {
+          } else if (arrPost.subtypeOf(BDArrN)) {
             bcs.emplace_back(bc::NewStructDArray { get_string_keys(arrPost) });
           } else {
             return PushFlags::MarkLive;
           }
         } else if (cat.cat == Type::ArrayCat::Packed &&
                    *postSize <= ArrayData::MaxElemsOnStack) {
-          if (arrPost.subtypeOf(TPArrN)) {
+          if (arrPost.subtypeOf(BPArrN)) {
             bcs.emplace_back(
               bc::NewPackedArray { static_cast<uint32_t>(*postSize) }
             );
-          } else if (arrPost.subtypeOf(TVArrN)) {
+          } else if (arrPost.subtypeOf(BVArrN)) {
             bcs.emplace_back(
               bc::NewVArray { static_cast<uint32_t>(*postSize) }
             );
@@ -1482,7 +1482,7 @@ void dce(Env& env, const bc::AddElemC& /*op*/) {
 void dce(Env& env, const bc::PopL& op) {
   auto const effects = setLocCouldHaveSideEffects(env, op.loc1);
   if (!isLocLive(env, op.loc1) && !effects) {
-    assert(!locRaw(env, op.loc1).couldBe(TRef) ||
+    assert(!locRaw(env, op.loc1).couldBe(BRef) ||
            env.stateBefore.localStaticBindings[op.loc1] ==
            LocalStaticBinding::Bound);
     discardNonDtors(env);
@@ -1490,7 +1490,7 @@ void dce(Env& env, const bc::PopL& op) {
     return;
   }
   pop(env);
-  if (effects || locRaw(env, op.loc1).couldBe(TRef)) {
+  if (effects || locRaw(env, op.loc1).couldBe(BRef)) {
     addLocGen(env, op.loc1);
   } else {
     addLocKill(env, op.loc1);
@@ -1506,7 +1506,7 @@ void dce(Env& env, const bc::InitThisLoc& op) {
 void dce(Env& env, const bc::SetL& op) {
   auto const effects = setLocCouldHaveSideEffects(env, op.loc1);
   if (!isLocLive(env, op.loc1) && !effects) {
-    assert(!locRaw(env, op.loc1).couldBe(TRef) ||
+    assert(!locRaw(env, op.loc1).couldBe(BRef) ||
            env.stateBefore.localStaticBindings[op.loc1] ==
            LocalStaticBinding::Bound);
     return markDead(env);
@@ -1520,7 +1520,7 @@ void dce(Env& env, const bc::SetL& op) {
     ui.actions[env.id] = DceAction::Replace;
     return PushFlags::MarkDead;
   });
-  if (effects || locRaw(env, op.loc1).couldBe(TRef)) {
+  if (effects || locRaw(env, op.loc1).couldBe(BRef)) {
     addLocGen(env, op.loc1);
   } else {
     addLocKill(env, op.loc1);
@@ -1529,7 +1529,7 @@ void dce(Env& env, const bc::SetL& op) {
 
 void dce(Env& env, const bc::UnsetL& op) {
   auto const oldTy   = locRaw(env, op.loc1);
-  if (oldTy.subtypeOf(TUninit)) return markDead(env);
+  if (oldTy.subtypeOf(BUninit)) return markDead(env);
 
   // Unsetting a local bound to a static never has side effects
   // because the static itself has a reference to the value.
@@ -1589,7 +1589,7 @@ bool setOpLSideEffects(const bc::SetOpL& op, const Type& lhs, const Type& rhs) {
     case SetOpOp::SlEqual:
     case SetOpOp::SrEqual:
       return RuntimeOption::EnableHipHopSyntax &&
-        (lhs.subtypeOf(TStr) || rhs.subtypeOf(TStr));
+        (lhs.subtypeOf(BStr) || rhs.subtypeOf(BStr));
   }
   not_reached();
 }
diff --git a/hphp/hhbbc/debug.cpp b/hphp/hhbbc/debug.cpp
index 02f8af7141..9b6a875d83 100644
--- a/hphp/hhbbc/debug.cpp
+++ b/hphp/hhbbc/debug.cpp
@@ -115,7 +115,7 @@ void dump_class_state(std::ostream& out,
     if (constant.val) {
       auto const ty = from_cell(*constant.val);
       out << c->name->data() << "::" << constant.name->data() << " :: "
-          << (ty.subtypeOf(TUninit) ? "<dynamic>" : show(ty)) << '\n';
+          << (ty.subtypeOf(BUninit) ? "<dynamic>" : show(ty)) << '\n';
     }
   }
 }
@@ -134,7 +134,7 @@ void dump_func_state(std::ostream& out,
 
   auto const localStatics = index.lookup_local_static_types(f);
   for (auto i = size_t{0}; i < localStatics.size(); ++i) {
-    if (localStatics[i].subtypeOf(TBottom)) continue;
+    if (localStatics[i].subtypeOf(BBottom)) continue;
     out << name << "::" << local_string(*f, i)
         << " :: " << show(localStatics[i]) << '\n';
   }
diff --git a/hphp/hhbbc/emit.cpp b/hphp/hhbbc/emit.cpp
index b7e77b7fda..163fe04390 100644
--- a/hphp/hhbbc/emit.cpp
+++ b/hphp/hhbbc/emit.cpp
@@ -430,7 +430,7 @@ EmitBcInfo emit_bytecode(EmitUnitState& euState,
         return;
 
       case Op::DefCns: {
-        if (ue.m_returnSeen || tos.subtypeOf(TBottom)) break;
+        if (ue.m_returnSeen || tos.subtypeOf(BBottom)) break;
         auto top = tv(tos);
         assertx(top);
         auto val = euState.index.lookup_persistent_constant(bc.DefCns.str1);
@@ -461,7 +461,7 @@ EmitBcInfo emit_bytecode(EmitUnitState& euState,
         tos = TBottom;
         return;
       case Op::RetC: {
-        if (ue.m_returnSeen || tos.subtypeOf(TBottom)) break;
+        if (ue.m_returnSeen || tos.subtypeOf(BBottom)) break;
         auto top = tv(tos);
         assertx(top);
         ue.m_returnSeen = true;
@@ -1312,7 +1312,7 @@ void emit_finish_func(EmitUnitState& state,
   fe.isMemoizeWrapper = func.isMemoizeWrapper;
 
   auto const retTy = state.index.lookup_return_type_and_clear(&func);
-  if (!retTy.subtypeOf(TBottom)) {
+  if (!retTy.subtypeOf(BBottom)) {
     auto const rat = make_repo_type(*state.index.array_table_builder(), retTy);
     merge_repo_auth_type(fe.ue(), rat);
     fe.repoReturnType = rat;
@@ -1320,7 +1320,7 @@ void emit_finish_func(EmitUnitState& state,
 
   if (is_specialized_wait_handle(retTy)) {
     auto const awaitedTy = wait_handle_inner(retTy);
-    if (!awaitedTy.subtypeOf(TBottom)) {
+    if (!awaitedTy.subtypeOf(BBottom)) {
       auto const rat = make_repo_type(
         *state.index.array_table_builder(),
         awaitedTy
@@ -1469,7 +1469,7 @@ void emit_class(EmitUnitState& state,
   auto const privateStatics = state.index.lookup_private_statics(&cls, true);
   for (auto& prop : cls.properties) {
     auto const makeRat = [&] (const Type& ty) -> RepoAuthType {
-      if (ty.couldBe(TCls)) {
+      if (ty.couldBe(BCls)) {
         return RepoAuthType{};
       }
       auto const rat = make_repo_type(*state.index.array_table_builder(), ty);
diff --git a/hphp/hhbbc/index.cpp b/hphp/hhbbc/index.cpp
index 89816b6a6e..ebb957b33c 100644
--- a/hphp/hhbbc/index.cpp
+++ b/hphp/hhbbc/index.cpp
@@ -1807,7 +1807,7 @@ bool build_cls_info(IndexData& index, borrowed_ptr<ClassInfo> cinfo) {
      * we union things in we'll have inferred nothing much.
      */
     auto const tyRaw = from_cell(prop.val);
-    auto const ty = tyRaw.subtypeOf(TUninit) ? TBottom : tyRaw;
+    auto const ty = tyRaw.subtypeOf(BUninit) ? TBottom : tyRaw;
     cinfo->publicStaticProps[prop.name] = PublicSPropEntry { ty, ty, false };
   }
 
@@ -3102,7 +3102,7 @@ Type context_sensitive_return_type(const Index& index,
   }
 
   auto maybe_loosen_staticness = [&] (const Type& ty) {
-    return returnType.subtypeOf(TUnc) ? ty : loosen_staticness(ty);
+    return returnType.subtypeOf(BUnc) ? ty : loosen_staticness(ty);
   };
 
   if (index.frozen()) {
@@ -3266,7 +3266,7 @@ PublicSPropEntry lookup_public_static_impl(
   }
 
   always_assert_flog(
-    !knownClsPart->inferredType.subtypeOf(TBottom),
+    !knownClsPart->inferredType.subtypeOf(BBottom),
     "A public static property had type TBottom; probably "
     "was marked uninit but didn't show up in the class 86sinit."
   );
@@ -3659,28 +3659,28 @@ folly::Optional<Type> Index::resolve_class_or_type_alias(
 
   auto const res = resolve_type_name(name);
 
-  if (res.nullable && candidate.subtypeOf(TInitNull)) return TInitNull;
+  if (res.nullable && candidate.subtypeOf(BInitNull)) return TInitNull;
 
   if (res.type == AnnotType::Object) {
     auto resolve = [&] (const res::Class& rcls) -> folly::Optional<Type> {
       if (!interface_supports_non_objects(rcls.name()) ||
-          candidate.subtypeOf(TObj)) {
+          candidate.subtypeOrNull(BObj)) {
         return subObj(rcls);
       }
 
-      if (candidate.subtypeOf(TOptArr)) {
+      if (candidate.subtypeOrNull(BArr)) {
         if (interface_supports_array(rcls.name())) return TArr;
-      } else if (candidate.subtypeOf(TOptVec)) {
+      } else if (candidate.subtypeOrNull(BVec)) {
         if (interface_supports_vec(rcls.name())) return TVec;
-      } else if (candidate.subtypeOf(TOptDict)) {
+      } else if (candidate.subtypeOrNull(BDict)) {
         if (interface_supports_dict(rcls.name())) return TDict;
-      } else if (candidate.subtypeOf(TOptKeyset)) {
+      } else if (candidate.subtypeOrNull(BKeyset)) {
         if (interface_supports_keyset(rcls.name())) return TKeyset;
-      } else if (candidate.subtypeOf(TOptStr)) {
+      } else if (candidate.subtypeOrNull(BStr)) {
         if (interface_supports_string(rcls.name())) return TStr;
-      } else if (candidate.subtypeOf(TOptInt)) {
+      } else if (candidate.subtypeOrNull(BInt)) {
         if (interface_supports_int(rcls.name())) return TInt;
-      } else if (candidate.subtypeOf(TOptDbl)) {
+      } else if (candidate.subtypeOrNull(BDbl)) {
         if (interface_supports_double(rcls.name())) return TDbl;
       }
       return folly::none;
@@ -4064,7 +4064,7 @@ folly::Optional<Type> Index::get_type_for_annotated_type(
   Context ctx, AnnotType annot, bool nullable,
   SString name, const Type& candidate) const {
 
-  if (candidate.subtypeOf(TInitNull) && nullable) {
+  if (candidate.subtypeOf(BInitNull) && nullable) {
     return TInitNull;
   }
   auto const mainType = [&]() -> const folly::Optional<Type> {
@@ -4105,8 +4105,8 @@ folly::Optional<Type> Index::get_type_for_annotated_type(
        */
       return TGen;
     case AnnotMetaType::Nonnull:
-      if (candidate.subtypeOf(TInitNull)) return TBottom;
-      if (!candidate.couldBe(TInitNull))  return candidate;
+      if (candidate.subtypeOf(BInitNull)) return TBottom;
+      if (!candidate.couldBe(BInitNull))  return candidate;
       if (is_opt(candidate))              return unopt(candidate);
       return folly::none;
     case AnnotMetaType::This:
@@ -4123,8 +4123,8 @@ folly::Optional<Type> Index::get_type_for_annotated_type(
     case AnnotMetaType::Number:
       return TNum;
     case AnnotMetaType::ArrayKey:
-      if (candidate.subtypeOf(TInt)) return TInt;
-      if (candidate.subtypeOf(TStr)) return TStr;
+      if (candidate.subtypeOf(BInt)) return TInt;
+      if (candidate.subtypeOf(BStr)) return TStr;
       return TArrKey;
     case AnnotMetaType::VArray:
       assertx(!RuntimeOption::EvalHackArrDVArrs);
@@ -4136,22 +4136,22 @@ folly::Optional<Type> Index::get_type_for_annotated_type(
       assertx(!RuntimeOption::EvalHackArrDVArrs);
       return TArr;
     case AnnotMetaType::VecOrDict:
-      if (candidate.subtypeOf(TVec)) return TVec;
-      if (candidate.subtypeOf(TDict)) return TDict;
+      if (candidate.subtypeOf(BVec)) return TVec;
+      if (candidate.subtypeOf(BDict)) return TDict;
       break;
     case AnnotMetaType::ArrayLike:
-      if (candidate.subtypeOf(TVArr)) return TVArr;
-      if (candidate.subtypeOf(TDArr)) return TDArr;
-      if (candidate.subtypeOf(TArr)) return TArr;
-      if (candidate.subtypeOf(TVec)) return TVec;
-      if (candidate.subtypeOf(TDict)) return TDict;
-      if (candidate.subtypeOf(TKeyset)) return TKeyset;
+      if (candidate.subtypeOf(BVArr)) return TVArr;
+      if (candidate.subtypeOf(BDArr)) return TDArr;
+      if (candidate.subtypeOf(BArr)) return TArr;
+      if (candidate.subtypeOf(BVec)) return TVec;
+      if (candidate.subtypeOf(BDict)) return TDict;
+      if (candidate.subtypeOf(BKeyset)) return TKeyset;
       break;
     }
     return folly::none;
   }();
 
-  if (!mainType || !nullable || mainType->couldBe(TInitNull)) return mainType;
+  if (!mainType || !nullable || mainType->couldBe(BInitNull)) return mainType;
   return opt(*mainType);
 }
 
@@ -4169,11 +4169,11 @@ bool Index::satisfies_constraint(Context ctx, const Type& t,
     // optimize away the type-check (because we'll raise a notice on a d/varray
     // mismatch), so do some additional checking here to rule that out.
     if (!RuntimeOption::EvalHackArrCompatTypeHintNotices) return true;
-    if (!tcType.subtypeOf(TOptArr) || tcType.subtypeOf(TNull)) return true;
-    assertx(t.subtypeOf(TOptArr));
-    if (tcType.subtypeOf(TOptVArr)) return t.subtypeOf(TOptVArr);
-    if (tcType.subtypeOf(TOptDArr)) return t.subtypeOf(TOptDArr);
-    if (tcType.subtypeOf(TOptPArr)) return t.subtypeOf(TOptPArr);
+    if (!tcType.subtypeOrNull(BArr) || tcType.subtypeOf(BNull)) return true;
+    assertx(t.subtypeOrNull(BArr));
+    if (tcType.subtypeOrNull(BVArr)) return t.subtypeOrNull(BVArr);
+    if (tcType.subtypeOrNull(BDArr)) return t.subtypeOrNull(BDArr);
+    if (tcType.subtypeOrNull(BPArr)) return t.subtypeOrNull(BPArr);
   }
   return false;
 }
@@ -4786,7 +4786,7 @@ void Index::init_return_type(const php::Func* func) {
     tcT = vec(std::move(types));
   }
 
-  if (!tcT.subtypeOf(TCell)) {
+  if (!tcT.subtypeOf(BCell)) {
     tcT = TInitCell;
   } else {
     tcT = remove_uninit(std::move(tcT));
diff --git a/hphp/hhbbc/index.h b/hphp/hhbbc/index.h
index 4250d28fba..d3f0823c8d 100644
--- a/hphp/hhbbc/index.h
+++ b/hphp/hhbbc/index.h
@@ -556,7 +556,7 @@ struct Index {
    * Try to resolve a class method named `name' with a given Context
    * and class type.
    *
-   * Pre: clsType.subtypeOf(TCls)
+   * Pre: clsType.subtypeOf(BCls)
    */
   res::Func resolve_method(Context, Type clsType, SString name) const;
 
diff --git a/hphp/hhbbc/interp-builtin.cpp b/hphp/hhbbc/interp-builtin.cpp
index f1672f09f0..bf933a0c8c 100644
--- a/hphp/hhbbc/interp-builtin.cpp
+++ b/hphp/hhbbc/interp-builtin.cpp
@@ -43,7 +43,7 @@ bool builtin_get_class(ISS& env, const bc::FCallBuiltin& op) {
     // trait in the program (this is after any trait flattening has
     // taken place).
     if (!env.ctx.cls || !(env.ctx.cls->attrs & AttrNoOverride)) return false;
-    assertx(ty.subtypeOf(TUninit));
+    assertx(ty.subtypeOf(BUninit));
     reduce(env,
            bc::PopU {},
            bc::String { env.ctx.cls->name },
@@ -51,7 +51,7 @@ bool builtin_get_class(ISS& env, const bc::FCallBuiltin& op) {
     return true;
   }
 
-  if (!ty.subtypeOf(TObj)) return false;
+  if (!ty.subtypeOf(BObj)) return false;
 
   auto unknown_class = [&] {
     popT(env);
@@ -75,8 +75,8 @@ bool builtin_get_class(ISS& env, const bc::FCallBuiltin& op) {
 bool builtin_abs(ISS& env, const bc::FCallBuiltin& op) {
   if (op.arg1 != 1) return false;
   auto const ty = popC(env);
-  push(env, ty.subtypeOf(TInt) ? TInt :
-            ty.subtypeOf(TDbl) ? TDbl :
+  push(env, ty.subtypeOf(BInt) ? TInt :
+            ty.subtypeOf(BDbl) ? TDbl :
             TInitUnc);
   return true;
 }
@@ -89,7 +89,7 @@ bool builtin_abs(ISS& env, const bc::FCallBuiltin& op) {
 bool floatIfNumeric(ISS& env, const bc::FCallBuiltin& op) {
   if (op.arg1 != 1) return false;
   auto const ty = popC(env);
-  push(env, ty.subtypeOf(TNum) ? TDbl : TInitUnc);
+  push(env, ty.subtypeOf(BNum) ? TDbl : TInitUnc);
   return true;
 }
 bool builtin_ceil(ISS& env, const bc::FCallBuiltin& op) {
@@ -114,10 +114,10 @@ bool builtin_mt_rand(ISS& env, const bc::FCallBuiltin& op) {
   case 0:
     return success();
   case 1:
-    return topT(env, 0).subtypeOf(TNum) ? success() : false;
+    return topT(env, 0).subtypeOf(BNum) ? success() : false;
   case 2:
-    if (topT(env, 0).subtypeOf(TNum) &&
-        topT(env, 1).subtypeOf(TNum)) {
+    if (topT(env, 0).subtypeOf(BNum) &&
+        topT(env, 1).subtypeOf(BNum)) {
       return success();
     }
     break;
@@ -138,7 +138,7 @@ bool minmax2(ISS& env, const bc::FCallBuiltin& op) {
 
   auto const t0 = topT(env, 0);
   auto const t1 = topT(env, 1);
-  if (!t0.subtypeOf(TNum) || !t1.subtypeOf(TNum)) return false;
+  if (!t0.subtypeOf(BNum) || !t1.subtypeOf(BNum)) return false;
   popC(env);
   popC(env);
   push(env, t0 == t1 ? t0 : TNum);
@@ -181,8 +181,8 @@ bool handle_oodecl_exists(ISS& env,
                           OODeclExistsOp subop) {
   if (op.arg1 != 2) return false;
   auto const& name = topT(env, 1);
-  if (name.subtypeOf(TStr)) {
-    if (!topT(env).subtypeOf(TBool)) {
+  if (name.subtypeOf(BStr)) {
+    if (!topT(env).subtypeOf(BBool)) {
       reduce(env,
              bc::CastBool {},
              bc::OODeclExists { subop },
@@ -244,21 +244,21 @@ bool builtin_array_key_cast(ISS& env, const bc::FCallBuiltin& op) {
   if (op.arg1 != 1) return false;
   auto const ty = topC(env);
 
-  if (ty.subtypeOf(TNum) || ty.subtypeOf(TBool) || ty.subtypeOf(TRes)) {
+  if (ty.subtypeOf(BNum) || ty.subtypeOf(BBool) || ty.subtypeOf(BRes)) {
     reduce(env, bc::CastInt {}, bc::RGetCNop {});
     return true;
   }
 
   auto retTy = TBottom;
-  if (ty.couldBe(TNull)) {
+  if (ty.couldBe(BNull)) {
     retTy |= sval(staticEmptyString());
   }
-  if (ty.couldBe(TNum) || ty.couldBe(TBool) || ty.couldBe(TRes)) {
+  if (ty.couldBe(BNum | BBool | BRes)) {
     retTy |= TInt;
   }
-  if (ty.couldBe(TStr)) {
+  if (ty.couldBe(BStr)) {
     retTy |= [&] {
-      if (ty.subtypeOf(TSStr)) {
+      if (ty.subtypeOf(BSStr)) {
         auto const v = tv(ty);
         if (v) {
           int64_t i;
@@ -273,9 +273,7 @@ bool builtin_array_key_cast(ISS& env, const bc::FCallBuiltin& op) {
     }();
   }
 
-  if (!ty.couldBe(TObj) && !ty.couldBe(TArr) &&
-      !ty.couldBe(TVec) && !ty.couldBe(TDict) &&
-      !ty.couldBe(TKeyset)) {
+  if (!ty.couldBe(BObj | BArr | BVec | BDict | BKeyset)) {
     constprop(env);
     nothrow(env);
   }
diff --git a/hphp/hhbbc/interp-internal.h b/hphp/hhbbc/interp-internal.h
index e04676f3f3..d238ad2984 100644
--- a/hphp/hhbbc/interp-internal.h
+++ b/hphp/hhbbc/interp-internal.h
@@ -190,7 +190,7 @@ void modifyLocalStatic(ISS& env, LocalId id, const Type& t) {
     if (is_volatile_local(env.ctx.func, lid)) return;
     if (env.state.localStaticBindings.size() <= lid) return;
     if (env.state.localStaticBindings[lid] == LocalStaticBinding::None) return;
-    if (t.subtypeOf(TUninit) && !t.subtypeOf(TBottom)) {
+    if (t.subtypeOf(BUninit) && !t.subtypeOf(BBottom)) {
       // Uninit means we are unbinding.
       env.state.localStaticBindings[lid] = id == NoLocalId ?
         LocalStaticBinding::None : LocalStaticBinding::Maybe;
@@ -199,7 +199,7 @@ void modifyLocalStatic(ISS& env, LocalId id, const Type& t) {
     if (lid >= env.collect.localStaticTypes.size()) {
       env.collect.localStaticTypes.resize(lid + 1, TBottom);
     }
-    env.collect.localStaticTypes[lid] = t.subtypeOf(TCell) ?
+    env.collect.localStaticTypes[lid] = t.subtypeOf(BCell) ?
       union_of(std::move(env.collect.localStaticTypes[lid]), t) :
       TGen;
   };
@@ -261,32 +261,32 @@ Type popT(ISS& env) {
   assert(!env.state.stack.empty());
   auto const ret = std::move(env.state.stack.back().type);
   FTRACE(2, "    pop:  {}\n", show(ret));
-  assert(ret.subtypeOf(TGen));
+  assert(ret.subtypeOf(BGen));
   env.state.stack.pop_back();
   return ret;
 }
 
 Type popC(ISS& env) {
   auto const v = popT(env);
-  assert(v.subtypeOf(TInitCell));
+  assert(v.subtypeOf(BInitCell));
   return v;
 }
 
 Type popV(ISS& env) {
   auto const v = popT(env);
-  assert(v.subtypeOf(TRef));
+  assert(v.subtypeOf(BRef));
   return v;
 }
 
 Type popU(ISS& env) {
   auto const v = popT(env);
-  assert(v.subtypeOf(TUninit));
+  assert(v.subtypeOf(BUninit));
   return v;
 }
 
 Type popCU(ISS& env) {
   auto const v = popT(env);
-  assert(v.subtypeOf(TCell));
+  assert(v.subtypeOf(BCell));
   return v;
 }
 
@@ -306,14 +306,14 @@ Type& topT(ISS& env, uint32_t idx = 0) {
 }
 
 Type& topC(ISS& env, uint32_t i = 0) {
-  assert(topT(env, i).subtypeOf(TInitCell));
+  assert(topT(env, i).subtypeOf(BInitCell));
   return topT(env, i);
 }
 
 Type& topR(ISS& env, uint32_t i = 0) { return topT(env, i); }
 
 Type& topV(ISS& env, uint32_t i = 0) {
-  assert(topT(env, i).subtypeOf(TRef));
+  assert(topT(env, i).subtypeOf(BRef));
   return topT(env, i);
 }
 
@@ -324,7 +324,7 @@ void push(ISS& env, Type t) {
 
 void push(ISS& env, Type t, LocalId l) {
   if (l != StackDupId) {
-    if (l == NoLocalId || peekLocRaw(env, l).couldBe(TRef)) {
+    if (l == NoLocalId || peekLocRaw(env, l).couldBe(BRef)) {
       return push(env, t);
     }
     assertx(!is_volatile_local(env.ctx.func, l)); // volatiles are TGen
@@ -509,7 +509,7 @@ void killAllLocEquiv(ISS& env) {
 void addLocEquiv(ISS& env,
                  LocalId from,
                  LocalId to) {
-  always_assert(peekLocRaw(env, from).subtypeOf(TCell));
+  always_assert(peekLocRaw(env, from).subtypeOf(BCell));
   always_assert(!is_volatile_local(env.ctx.func, to));
   always_assert(from != to && findLocEquiv(env, from) == NoLocalId);
 
@@ -545,7 +545,7 @@ LocalId topStkEquiv(ISS& env, uint32_t idx = 0) {
 
 void setStkLocal(ISS& env, LocalId loc, uint32_t idx = 0) {
   assertx(loc <= MaxLocalId);
-  always_assert(peekLocRaw(env, loc).subtypeOf(TCell));
+  always_assert(peekLocRaw(env, loc).subtypeOf(BCell));
   while (true) {
     auto equiv = topStkEquiv(env, idx);
     if (equiv != StackDupId) {
@@ -660,7 +660,7 @@ folly::Optional<Type> staticLocType(ISS& env, LocalId l, const Type& super) {
     auto t = env.collect.localStaticTypes[l];
     if (t.subtypeOf(super)) {
       useLocalStatic(env, l);
-      if (t.subtypeOf(TBottom)) t = TInitNull;
+      if (t.subtypeOf(BBottom)) t = TInitNull;
       return std::move(t);
     }
   }
@@ -675,8 +675,8 @@ Type locAsCell(ISS& env, LocalId l) {
     return std::move(*s);
   }
   auto t = locRaw(env, l);
-  return !t.subtypeOf(TCell) ? TInitCell :
-          t.subtypeOf(TUninit) ? TInitNull :
+  return !t.subtypeOf(BCell) ? TInitCell :
+          t.subtypeOf(BUninit) ? TInitNull :
           remove_uninit(std::move(t));
 }
 
@@ -687,16 +687,16 @@ Type derefLoc(ISS& env, LocalId l) {
     return std::move(*s);
   }
   auto v = locRaw(env, l);
-  if (v.subtypeOf(TCell)) return v;
-  return v.couldBe(TUninit) ? TCell : TInitCell;
+  if (v.subtypeOf(BCell)) return v;
+  return v.couldBe(BUninit) ? TCell : TInitCell;
 }
 
 bool locCouldBeUninit(ISS& env, LocalId l) {
-  return locRaw(env, l).couldBe(TUninit);
+  return locRaw(env, l).couldBe(BUninit);
 }
 
 bool locCouldBeRef(ISS& env, LocalId l) {
-  return locRaw(env, l).couldBe(TRef);
+  return locRaw(env, l).couldBe(BRef);
 }
 
 /*
@@ -706,24 +706,24 @@ bool locCouldBeRef(ISS& env, LocalId l) {
  */
 void refineLocHelper(ISS& env, LocalId l, Type t) {
   auto v = peekLocRaw(env, l);
-  if (v.subtypeOf(TCell)) env.state.locals[l] = std::move(t);
+  if (v.subtypeOf(BCell)) env.state.locals[l] = std::move(t);
 }
 
 template<typename F>
 bool refineLocation(ISS& env, LocalId l, F fun) {
   bool ok = true;
   auto refine = [&] (Type t) {
-    always_assert(t.subtypeOf(TCell));
+    always_assert(t.subtypeOf(BCell));
     auto r1 = fun(t);
     auto r2 = intersection_of(r1, t);
     // In unusual edge cases (mainly intersection of two unrelated
     // interfaces) the intersection may not be a subtype of its inputs.
     // In that case, always choose fun's type.
     if (r2.subtypeOf(r1)) {
-      if (r2.subtypeOf(TBottom)) ok = false;
+      if (r2.subtypeOf(BBottom)) ok = false;
       return r2;
     }
-    if (r1.subtypeOf(TBottom)) ok = false;
+    if (r1.subtypeOf(BBottom)) ok = false;
     return r1;
   };
   if (l == StackDupId) {
@@ -794,7 +794,7 @@ void loseNonRefLocalTypes(ISS& env) {
   readUnknownLocals(env);
   FTRACE(2, "    loseNonRefLocalTypes\n");
   for (auto& l : env.state.locals) {
-    if (l.subtypeOf(TCell)) l = TCell;
+    if (l.subtypeOf(BCell)) l = TCell;
   }
   killAllLocEquiv(env);
   killAllStkEquiv(env);
@@ -807,7 +807,7 @@ void boxUnknownLocal(ISS& env) {
   readUnknownLocals(env);
   FTRACE(2, "   boxUnknownLocal\n");
   for (auto& l : env.state.locals) {
-    if (!l.subtypeOf(TRef)) l = TGen;
+    if (!l.subtypeOf(BRef)) l = TGen;
   }
   killAllLocEquiv(env);
   killAllStkEquiv(env);
@@ -944,7 +944,7 @@ void specialFunctionEffects(ISS& env, ActRec ar) {
 // Read the specified class-ref slot without discarding the stored value.
 const Type& peekClsRefSlot(ISS& env, ClsRefSlotId slot) {
   assert(slot != NoClsRefSlotId);
-  always_assert_flog(env.state.clsRefSlots[slot].subtypeOf(TCls),
+  always_assert_flog(env.state.clsRefSlots[slot].subtypeOf(BCls),
                      "class-ref slot contained non-TCls");
   return env.state.clsRefSlots[slot];
 }
@@ -954,14 +954,14 @@ Type takeClsRefSlot(ISS& env, ClsRefSlotId slot) {
   assert(slot != NoClsRefSlotId);
   auto ret = std::move(env.state.clsRefSlots[slot]);
   FTRACE(2, "    read class-ref: {} -> {}\n", slot, show(ret));
-  always_assert_flog(ret.subtypeOf(TCls), "class-ref slot contained non-TCls");
+  always_assert_flog(ret.subtypeOf(BCls), "class-ref slot contained non-TCls");
   env.state.clsRefSlots[slot] = TCls;
   return ret;
 }
 
 void putClsRefSlot(ISS& env, ClsRefSlotId slot, Type ty) {
   assert(slot != NoClsRefSlotId);
-  always_assert_flog(ty.subtypeOf(TCls),
+  always_assert_flog(ty.subtypeOf(BCls),
                      "attempted to set class-ref slot to non-TCls");
   FTRACE(2, "    write class-ref: {} -> {}\n", slot, show(ty));
   env.state.clsRefSlots[slot] = std::move(ty);
@@ -1079,14 +1079,14 @@ void killThisProps(ISS& env) {
 folly::Optional<Type> thisPropAsCell(ISS& env, SString name) {
   auto const t = thisPropRaw(env, name);
   if (!t) return folly::none;
-  if (t->couldBe(TUninit)) {
+  if (t->couldBe(BUninit)) {
     auto const rthis = thisType(env);
     if (!rthis || dobj_of(*rthis).cls.couldHaveMagicGet()) {
       return TInitCell;
     }
   }
-  return !t->subtypeOf(TCell) ? TInitCell :
-          t->subtypeOf(TUninit) ? TInitNull :
+  return !t->subtypeOf(BCell) ? TInitCell :
+          t->subtypeOf(BUninit) ? TInitNull :
           remove_uninit(*t);
 }
 
@@ -1145,7 +1145,7 @@ void boxThisProp(ISS& env, SString name) {
 void loseNonRefThisPropTypes(ISS& env) {
   FTRACE(2, "    loseNonRefThisPropTypes\n");
   for (auto& kv : env.collect.props.privateProperties()) {
-    if (kv.second.subtypeOf(TCell)) kv.second = TCell;
+    if (kv.second.subtypeOf(BCell)) kv.second = TCell;
   }
 }
 
@@ -1181,8 +1181,8 @@ void killSelfProp(ISS& env, SString name) {
 folly::Optional<Type> selfPropAsCell(ISS& env, SString name) {
   auto const t = selfPropRaw(env, name);
   if (!t) return folly::none;
-  return !t->subtypeOf(TCell) ? TInitCell :
-          t->subtypeOf(TUninit) ? TInitNull :
+  return !t->subtypeOf(BCell) ? TInitCell :
+          t->subtypeOf(BUninit) ? TInitNull :
           remove_uninit(*t);
 }
 
@@ -1223,7 +1223,7 @@ void boxSelfProp(ISS& env, SString name) {
 void loseNonRefSelfPropTypes(ISS& env) {
   FTRACE(2, "    loseNonRefSelfPropTypes\n");
   for (auto& kv : env.collect.props.privateStatics()) {
-    if (kv.second.subtypeOf(TInitCell)) kv.second = TCell;
+    if (kv.second.subtypeOf(BInitCell)) kv.second = TCell;
   }
 }
 
diff --git a/hphp/hhbbc/interp-minstr.cpp b/hphp/hhbbc/interp-minstr.cpp
index 586460b664..ef8f4fdb50 100644
--- a/hphp/hhbbc/interp-minstr.cpp
+++ b/hphp/hhbbc/interp-minstr.cpp
@@ -52,15 +52,11 @@ const StaticString s_stdClass("stdClass");
  */
 
 bool couldBeEmptyish(const Type& ty) {
-  return ty.couldBe(TNull) ||
-         ty.couldBe(sempty()) ||
-         ty.couldBe(TFalse);
+  return ty.couldBe(BNull | BFalse) || ty.couldBe(sempty());
 }
 
 bool mustBeEmptyish(const Type& ty) {
-  return ty.subtypeOf(TNull) ||
-         ty.subtypeOf(sempty()) ||
-         ty.subtypeOf(TFalse);
+  return ty.subtypeOf(BNull | BFalse) || ty.subtypeOf(sempty());
 }
 
 bool elemCouldPromoteToArr(const Type& ty) { return couldBeEmptyish(ty); }
@@ -75,13 +71,11 @@ bool propMustPromoteToObj(const Type& ty)  {
 }
 
 bool keyCouldBeWeird(const Type& key) {
-  return key.couldBe(TObj) || key.couldBe(TArr) || key.couldBe(TVec) ||
-    key.couldBe(TDict) || key.couldBe(TKeyset);
+  return key.couldBe(BObj | BArr | BVec | BDict | BKeyset);
 }
 
 bool mustBeArrLike(const Type& ty) {
-  return ty.subtypeOf(TArr)  || ty.subtypeOf(TVec) ||
-         ty.subtypeOf(TDict) || ty.subtypeOf(TKeyset);
+  return ty.subtypeOf(BArr | BVec | BDict | BKeyset);
 }
 
 //////////////////////////////////////////////////////////////////////
@@ -214,10 +208,10 @@ bool isDimBaseLoc(BaseLoc loc) {
 bool array_do_set(ISS& env, const Type& key, const Type& value) {
   auto& base = env.state.mInstrState.base.type;
   auto res = [&] () -> folly::Optional<std::pair<Type,ThrowMode>> {
-    if (base.subtypeOf(TArr))    return  array_set(std::move(base), key, value);
-    if (base.subtypeOf(TVec))    return    vec_set(std::move(base), key, value);
-    if (base.subtypeOf(TDict))   return   dict_set(std::move(base), key, value);
-    if (base.subtypeOf(TKeyset)) return keyset_set(std::move(base), key, value);
+    if (base.subtypeOf(BArr))    return  array_set(std::move(base), key, value);
+    if (base.subtypeOf(BVec))    return    vec_set(std::move(base), key, value);
+    if (base.subtypeOf(BDict))   return   dict_set(std::move(base), key, value);
+    if (base.subtypeOf(BKeyset)) return keyset_set(std::move(base), key, value);
     return folly::none;
   }();
   if (!res) return false;
@@ -250,10 +244,10 @@ folly::Optional<Type> array_do_elem(ISS& env,
                                     const Type& key) {
   auto const& base = env.state.mInstrState.base.type;
   auto res = [&] () -> folly::Optional<std::pair<Type,ThrowMode>> {
-    if (base.subtypeOf(TArr))    return  array_elem(base, key);
-    if (base.subtypeOf(TVec))    return    vec_elem(base, key);
-    if (base.subtypeOf(TDict))   return   dict_elem(base, key);
-    if (base.subtypeOf(TKeyset)) return keyset_elem(base, key);
+    if (base.subtypeOf(BArr))    return  array_elem(base, key);
+    if (base.subtypeOf(BVec))    return    vec_elem(base, key);
+    if (base.subtypeOf(BDict))   return   dict_elem(base, key);
+    if (base.subtypeOf(BKeyset)) return keyset_elem(base, key);
     return folly::none;
   }();
   if (!res) return folly::none;
@@ -292,10 +286,10 @@ folly::Optional<Type> array_do_elem(ISS& env,
 folly::Optional<Type> array_do_newelem(ISS& env, const Type& value) {
   auto& base = env.state.mInstrState.base.type;
   auto res = [&] () -> folly::Optional<std::pair<Type,Type>> {
-    if (base.subtypeOf(TArr))    return  array_newelem(std::move(base), value);
-    if (base.subtypeOf(TVec))    return    vec_newelem(std::move(base), value);
-    if (base.subtypeOf(TDict))   return   dict_newelem(std::move(base), value);
-    if (base.subtypeOf(TKeyset)) return keyset_newelem(std::move(base), value);
+    if (base.subtypeOf(BArr))    return  array_newelem(std::move(base), value);
+    if (base.subtypeOf(BVec))    return    vec_newelem(std::move(base), value);
+    if (base.subtypeOf(BDict))   return   dict_newelem(std::move(base), value);
+    if (base.subtypeOf(BKeyset)) return keyset_newelem(std::move(base), value);
     return folly::none;
   }();
   if (!res) return folly::none;
@@ -343,7 +337,7 @@ void setStackForBase(ISS& env, Type ty) {
   assert(locSlot < env.state.stack.size());
 
   auto const& oldTy = env.state.stack[locSlot].type;
-  if (oldTy.subtypeOf(TInitCell)) {
+  if (oldTy.subtypeOf(BInitCell)) {
     env.state.stack[locSlot] = StackElem {std::move(ty)};
   }
 }
@@ -359,7 +353,7 @@ void setPrivateStaticForBase(ISS& env, Type ty) {
   FTRACE(4, "      self::* |= {}\n", show(ty));
   mergeEachSelfPropRaw(
     env,
-    [&](const Type& old){ return old.subtypeOf(TInitCell) ? ty : TBottom; }
+    [&](const Type& old){ return old.subtypeOf(BInitCell) ? ty : TBottom; }
   );
 }
 
@@ -374,7 +368,7 @@ void setPropForBase(ISS& env, Type ty) {
   FTRACE(4, "      $this->* |= {}\n", show(ty));
   mergeEachThisPropRaw(
     env,
-    [&] (const Type& old) { return old.couldBe(TInitCell) ? ty : TBottom; }
+    [&] (const Type& old) { return old.couldBe(BInitCell) ? ty : TBottom; }
   );
 }
 
@@ -385,16 +379,16 @@ Type currentChainType(ISS& env, Type val) {
   auto it = env.state.mInstrState.arrayChain.end();
   while (it != env.state.mInstrState.arrayChain.begin()) {
     --it;
-    if (it->base.subtypeOf(TArr)) {
+    if (it->base.subtypeOf(BArr)) {
       val = array_set(it->base, it->key, val).first;
-    } else if (it->base.subtypeOf(TVec)) {
+    } else if (it->base.subtypeOf(BVec)) {
       val = vec_set(it->base, it->key, val).first;
       if (val == TBottom) val = TVec;
-    } else if (it->base.subtypeOf(TDict)) {
+    } else if (it->base.subtypeOf(BDict)) {
       val = dict_set(it->base, it->key, val).first;
       if (val == TBottom) val = TDict;
     } else {
-      assert(it->base.subtypeOf(TKeyset));
+      assert(it->base.subtypeOf(BKeyset));
       val = keyset_set(it->base, it->key, val).first;
       if (val == TBottom) val = TKeyset;
     }
@@ -411,17 +405,17 @@ Type resolveArrayChain(ISS& env, Type val) {
     env.state.mInstrState.arrayChain.pop_back();
     FTRACE(5, "{}  | {} := {} in {}\n", prefix,
       show(key), show(val), show(arr));
-    if (arr.subtypeOf(TVec)) {
+    if (arr.subtypeOf(BVec)) {
       val = vec_set(std::move(arr), key, val).first;
       if (val == TBottom) val = TVec;
-    } else if (arr.subtypeOf(TDict)) {
+    } else if (arr.subtypeOf(BDict)) {
       val = dict_set(std::move(arr), key, val).first;
       if (val == TBottom) val = TDict;
-    } else if (arr.subtypeOf(TKeyset)) {
+    } else if (arr.subtypeOf(BKeyset)) {
       val = keyset_set(std::move(arr), key, val).first;
       if (val == TBottom) val = TKeyset;
     } else {
-      assert(arr.subtypeOf(TArr));
+      assert(arr.subtypeOf(BArr));
       val = array_set(std::move(arr), key, val).first;
     }
   } while (!env.state.mInstrState.arrayChain.empty());
@@ -558,7 +552,7 @@ void promoteBasePropD(ISS& env, bool isNullsafe) {
   auto& ty = env.state.mInstrState.base.type;
 
   // NullSafe (Q) props do not promote an emptyish base to stdClass instance.
-  if (isNullsafe || ty.subtypeOf(TObj)) return;
+  if (isNullsafe || ty.subtypeOf(BObj)) return;
 
   if (propMustPromoteToObj(ty)) {
     ty = objExact(env.index.builtin_class(s_stdClass.get()));
@@ -585,7 +579,7 @@ void promoteBaseElemD(ISS& env) {
   // Intermediate ElemD operations on strings fatal, unless the string is empty,
   // which promotes to array. So for any string here we can assume it promoted
   // to an empty array.
-  if (ty.subtypeOf(TStr)) {
+  if (ty.subtypeOf(BStr)) {
     ty = some_aempty();
     return;
   }
@@ -796,7 +790,7 @@ Base miBaseSProp(ISS& env, Type cls, const Type& tprop) {
     }
   }
   auto indexTy = env.index.lookup_public_static(cls, tprop);
-  if (!indexTy.subtypeOf(TInitCell)) indexTy = TInitCell;
+  if (!indexTy.subtypeOf(BInitCell)) indexTy = TInitCell;
   return Base { std::move(indexTy),
                 BaseLoc::StaticProp,
                 std::move(cls),
@@ -831,12 +825,12 @@ void miProp(ISS& env, bool isNullsafe, MOpMode mode, Type key) {
   if (isUnset && couldBeThisObj(env, env.state.mInstrState.base)) {
     if (name) {
       auto const ty = thisPropRaw(env, name);
-      if (ty && ty->couldBe(TUninit)) {
+      if (ty && ty->couldBe(BUninit)) {
         mergeThisProp(env, name, TInitNull);
       }
     } else {
       mergeEachThisPropRaw(env, [&] (const Type& ty) {
-        return ty.couldBe(TUninit) ? TInitNull : TBottom;
+        return ty.couldBe(BUninit) ? TInitNull : TBottom;
       });
     }
   }
@@ -867,7 +861,7 @@ void miProp(ISS& env, bool isNullsafe, MOpMode mode, Type key) {
   }
 
   // We know for sure we're going to be in an object property.
-  if (env.state.mInstrState.base.type.subtypeOf(TObj)) {
+  if (env.state.mInstrState.base.type.subtypeOf(BObj)) {
     moveBase(env,
              Base { TInitCell,
                     BaseLoc::Prop,
@@ -930,7 +924,7 @@ void miElem(ISS& env, MOpMode mode, Type key, LocalId keyLoc) {
     return;
   }
 
-  if (env.state.mInstrState.base.type.subtypeOf(TStr)) {
+  if (env.state.mInstrState.base.type.subtypeOf(BStr)) {
     moveBase(env, Base { TStr, BaseLoc::Elem }, update);
     return;
   }
@@ -969,8 +963,8 @@ void miFinalIssetProp(ISS& env, int32_t nDiscard, const Type& key) {
   discard(env, nDiscard);
   if (name && mustBeThisObj(env, env.state.mInstrState.base)) {
     if (auto const pt = thisPropAsCell(env, name)) {
-      if (pt->subtypeOf(TNull))  return push(env, TFalse);
-      if (!pt->couldBe(TNull))   return push(env, TTrue);
+      if (pt->subtypeOf(BNull))  return push(env, TFalse);
+      if (!pt->couldBe(BNull))   return push(env, TTrue);
     }
   }
   push(env, TBool);
@@ -1024,7 +1018,7 @@ void miFinalSetProp(ISS& env, int32_t nDiscard, const Type& key) {
       mergeEachThisPropRaw(
         env,
         [&] (Type propTy) {
-          return propTy.couldBe(TInitCell) ? t1 : TBottom;
+          return propTy.couldBe(BInitCell) ? t1 : TBottom;
         }
       );
     } else {
@@ -1032,7 +1026,7 @@ void miFinalSetProp(ISS& env, int32_t nDiscard, const Type& key) {
     }
   }
 
-  if (env.state.mInstrState.base.type.subtypeOf(TObj)) {
+  if (env.state.mInstrState.base.type.subtypeOf(BObj)) {
     moveBase(
       env,
       Base { t1, BaseLoc::Prop, env.state.mInstrState.base.type, name }
@@ -1185,9 +1179,9 @@ void miFinalVGetElem(ISS& env, int32_t nDiscard, const Type& key) {
   };
 
   auto const& baseTy = env.state.mInstrState.base.type;
-  if (baseTy.subtypeOf(TVec) ||
-      baseTy.subtypeOf(TDict) ||
-      baseTy.subtypeOf(TKeyset)) {
+  if (baseTy.subtypeOf(BVec) ||
+      baseTy.subtypeOf(BDict) ||
+      baseTy.subtypeOf(BKeyset)) {
     unreachable(env);
     return finish(TBottom);
   }
@@ -1216,7 +1210,7 @@ void miFinalSetElem(ISS& env,
     env.state.mInstrState.base.type = some_aempty();
   } else {
     auto& ty = env.state.mInstrState.base.type;
-    if (ty.couldBe(TStr)) {
+    if (ty.couldBe(BStr)) {
       // Note here that a string type stays a string (with a changed character,
       // and loss of staticness), unless it was the empty string, where it
       // becomes an array.  Do it conservatively for now:
@@ -1225,7 +1219,7 @@ void miFinalSetElem(ISS& env,
         some_aempty()
       );
     }
-    if (!ty.subtypeOf(TStr)) promoteBaseElemD(env);
+    if (!ty.subtypeOf(BStr)) promoteBaseElemD(env);
   }
 
   /*
@@ -1247,7 +1241,7 @@ void miFinalSetElem(ISS& env,
   if (array_do_set(env, key, t1)) {
     if (env.state.unreachable) return finish(TBottom);
     auto const maybeWeird =
-      env.state.mInstrState.base.type.subtypeOf(TArr) && keyCouldBeWeird(key);
+      env.state.mInstrState.base.type.subtypeOf(BArr) && keyCouldBeWeird(key);
     return finish(maybeWeird ? union_of(t1, TInitNull) : t1);
   }
 
@@ -1258,7 +1252,7 @@ void miFinalSetElem(ISS& env,
   auto const isWeird =
     keyCouldBeWeird(key) ||
     (!mustBeEmptyish(env.state.mInstrState.base.type) &&
-     !env.state.mInstrState.base.type.subtypeOf(TObj));
+     !env.state.mInstrState.base.type.subtypeOf(BObj));
   finish(isWeird ? TInitCell : t1);
 }
 
@@ -1272,7 +1266,7 @@ void miFinalSetOpElem(ISS& env, int32_t nDiscard,
   auto const lhsTy = [&] {
     if (auto ty = array_do_elem(env, false, key)) {
       if (env.state.unreachable) return TBottom;
-      assertx(!ty->subtypeOf(TBottom));
+      assertx(!ty->subtypeOf(BBottom));
       return std::move(*ty);
     }
     return TInitCell;
@@ -1293,7 +1287,7 @@ void miFinalIncDecElem(ISS& env, int32_t nDiscard,
   auto const postTy = [&] {
     if (auto ty = array_do_elem(env, false, key)) {
       if (env.state.unreachable) return TBottom;
-      assertx(!ty->subtypeOf(TBottom));
+      assertx(!ty->subtypeOf(BBottom));
       return std::move(*ty);
     }
     return TInitCell;
@@ -1319,9 +1313,9 @@ void miFinalBindElem(ISS& env, int32_t nDiscard, const Type& key) {
   };
 
   auto const& baseTy = env.state.mInstrState.base.type;
-  if (baseTy.subtypeOf(TVec) ||
-      baseTy.subtypeOf(TDict) ||
-      baseTy.subtypeOf(TKeyset)) {
+  if (baseTy.subtypeOf(BVec) ||
+      baseTy.subtypeOf(BDict) ||
+      baseTy.subtypeOf(BKeyset)) {
     unreachable(env);
     return finish(TBottom);
   }
@@ -1363,9 +1357,9 @@ void miFinalVGetNewElem(ISS& env, int32_t nDiscard) {
   };
 
   auto const& baseTy = env.state.mInstrState.base.type;
-  if (baseTy.subtypeOf(TVec) ||
-      baseTy.subtypeOf(TDict) ||
-      baseTy.subtypeOf(TKeyset)) {
+  if (baseTy.subtypeOf(BVec) ||
+      baseTy.subtypeOf(BDict) ||
+      baseTy.subtypeOf(BKeyset)) {
     unreachable(env);
     return finish(TBottom);
   }
@@ -1433,9 +1427,9 @@ void miFinalBindNewElem(ISS& env, int32_t nDiscard) {
   };
 
   auto const& baseTy = env.state.mInstrState.base.type;
-  if (baseTy.subtypeOf(TVec)||
-      baseTy.subtypeOf(TDict) ||
-      baseTy.subtypeOf(TKeyset)) {
+  if (baseTy.subtypeOf(BVec)||
+      baseTy.subtypeOf(BDict) ||
+      baseTy.subtypeOf(BKeyset)) {
     unreachable(env);
     return finish(TBottom);
   }
@@ -1444,9 +1438,9 @@ void miFinalBindNewElem(ISS& env, int32_t nDiscard) {
 
 void miFinalSetWithRef(ISS& env) {
   auto const& baseTy = env.state.mInstrState.base.type;
-  auto const isvec = baseTy.subtypeOf(TVec);
-  auto const isdict = baseTy.subtypeOf(TDict);
-  auto const iskeyset = baseTy.subtypeOf(TKeyset);
+  auto const isvec = baseTy.subtypeOf(BVec);
+  auto const isdict = baseTy.subtypeOf(BDict);
+  auto const iskeyset = baseTy.subtypeOf(BKeyset);
   endBase(env);
   if (!isvec && !isdict && !iskeyset) {
     killLocals(env);
@@ -1542,7 +1536,7 @@ void in(ISS& env, const bc::BaseR& op) {
   startBase(
     env,
     Base {
-      ty.subtypeOf(TInitCell) ? std::move(ty) : TInitCell,
+      ty.subtypeOf(BInitCell) ? std::move(ty) : TInitCell,
       BaseLoc::Stack,
       TBottom,
       SString{},
@@ -1614,8 +1608,8 @@ void in(ISS& env, const bc::QueryM& op) {
       case QueryMOp::Isset:
         miFinalCGetElem(env, nDiscard, *key, true,
                         [](Type t) {
-                          return t.subtypeOf(TInitNull) ? TFalse :
-                            !t.couldBe(TInitNull) ? TTrue : TBool;
+                          return t.subtypeOf(BInitNull) ? TFalse :
+                            !t.couldBe(BInitNull) ? TTrue : TBool;
                         });
         break;
       case QueryMOp::Empty:
diff --git a/hphp/hhbbc/interp-state.cpp b/hphp/hhbbc/interp-state.cpp
index 6b776e4e5b..22d42e660f 100644
--- a/hphp/hhbbc/interp-state.cpp
+++ b/hphp/hhbbc/interp-state.cpp
@@ -353,7 +353,7 @@ bool merge_impl(State& dst, const State& src, JoinOp join) {
 
   for (auto i = size_t{0}; i < dst.clsRefSlots.size(); ++i) {
     auto newT = join(dst.clsRefSlots[i], src.clsRefSlots[i]);
-    assert(newT.subtypeOf(TCls));
+    assert(newT.subtypeOf(BCls));
     if (!equivalently_refined(dst.clsRefSlots[i], newT)) {
       changed = true;
       dst.clsRefSlots[i] = std::move(newT);
diff --git a/hphp/hhbbc/interp.cpp b/hphp/hhbbc/interp.cpp
index cae270906c..2c75c4f3e7 100644
--- a/hphp/hhbbc/interp.cpp
+++ b/hphp/hhbbc/interp.cpp
@@ -205,7 +205,7 @@ void in(ISS& env, const bc::PopU&) { effect_free(env); popU(env); }
 void in(ISS& env, const bc::PopV&) { nothrow(env); popV(env); }
 void in(ISS& env, const bc::PopR&) {
   auto t = topT(env, 0);
-  if (t.subtypeOf(TCell)) {
+  if (t.subtypeOf(BCell)) {
     return reduce(env, bc::UnboxRNop {}, bc::PopC {});
   }
   nothrow(env);
@@ -241,7 +241,7 @@ void in(ISS& env, const bc::Box&) {
 
 void in(ISS& env, const bc::BoxR&) {
   effect_free(env);
-  if (topR(env).subtypeOf(TRef)) {
+  if (topR(env).subtypeOf(BRef)) {
     return reduce(env, bc::BoxRNop {});
   }
   popR(env);
@@ -256,7 +256,7 @@ void in(ISS& env, const bc::Unbox&) {
 
 void in(ISS& env, const bc::UnboxR&) {
   auto const t = topR(env);
-  if (t.subtypeOf(TInitCell)) return reduce(env, bc::UnboxRNop {});
+  if (t.subtypeOf(BInitCell)) return reduce(env, bc::UnboxRNop {});
   nothrow(env);
   popT(env);
   push(env, TInitCell);
@@ -280,14 +280,14 @@ void in(ISS& env, const bc::UnboxRNop&) {
   effect_free(env);
   constprop(env);
   auto t = popR(env);
-  if (!t.subtypeOf(TInitCell)) t = TInitCell;
+  if (!t.subtypeOf(BInitCell)) t = TInitCell;
   push(env, std::move(t));
 }
 
 void in(ISS& env, const bc::BoxRNop&) {
   effect_free(env);
   auto t = popR(env);
-  if (!t.subtypeOf(TRef)) t = TRef;
+  if (!t.subtypeOf(BRef)) t = TRef;
   push(env, std::move(t));
 }
 
@@ -477,10 +477,10 @@ void in(ISS& env, const bc::AddElemC& /*op*/) {
 
   auto const outTy = [&] (Type ty) ->
     folly::Optional<std::pair<Type,ThrowMode>> {
-    if (ty.subtypeOf(TArr)) {
+    if (ty.subtypeOf(BArr)) {
       return array_set(std::move(ty), k, v);
     }
-    if (ty.subtypeOf(TDict)) {
+    if (ty.subtypeOf(BDict)) {
       return dict_set(std::move(ty), k, v);
     }
     return folly::none;
@@ -490,7 +490,7 @@ void in(ISS& env, const bc::AddElemC& /*op*/) {
     return push(env, union_of(TArr, TDict));
   }
 
-  if (outTy->first.subtypeOf(TBottom)) {
+  if (outTy->first.subtypeOf(BBottom)) {
     unreachable(env);
   } else if (outTy->second == ThrowMode::None) {
     nothrow(env);
@@ -505,8 +505,8 @@ void in(ISS& env, const bc::AddElemV& /*op*/) {
   popV(env); popC(env);
   auto const ty = popC(env);
   auto const outTy =
-    ty.subtypeOf(TArr) ? TArr
-    : ty.subtypeOf(TDict) ? TDict
+    ty.subtypeOf(BArr) ? TArr
+    : ty.subtypeOf(BDict) ? TDict
     : union_of(TArr, TDict);
   push(env, outTy);
 }
@@ -515,13 +515,13 @@ void in(ISS& env, const bc::AddNewElemC&) {
   auto v = popC(env);
 
   auto const outTy = [&] (Type ty) -> folly::Optional<Type> {
-    if (ty.subtypeOf(TArr)) {
+    if (ty.subtypeOf(BArr)) {
       return array_newelem(std::move(ty), std::move(v)).first;
     }
-    if (ty.subtypeOf(TVec)) {
+    if (ty.subtypeOf(BVec)) {
       return vec_newelem(std::move(ty), std::move(v)).first;
     }
-    if (ty.subtypeOf(TKeyset)) {
+    if (ty.subtypeOf(BKeyset)) {
       return keyset_newelem(std::move(ty), std::move(v)).first;
     }
     return folly::none;
@@ -531,7 +531,7 @@ void in(ISS& env, const bc::AddNewElemC&) {
     return push(env, TInitCell);
   }
 
-  if (outTy->subtypeOf(TBottom)) {
+  if (outTy->subtypeOf(BBottom)) {
     unreachable(env);
   } else {
     if (any(env.collect.opts & CollectionOpts::TrackConstantArrays)) {
@@ -712,7 +712,7 @@ void in(ISS& env, const bc::BitNot& /*op*/) {
 namespace {
 
 bool couldBeHackArr(Type t) {
-  return t.couldBe(TVec) || t.couldBe(TDict) || t.couldBe(TKeyset);
+  return t.couldBe(BVec | BDict | BKeyset);
 }
 
 template<bool NSame>
@@ -726,14 +726,14 @@ std::pair<Type,bool> resolveSame(ISS& env) {
     // EvalHackArrCompatNotices will notice on === and !== between PHP arrays
     // and Hack arrays.
     if (RuntimeOption::EvalHackArrCompatNotices) {
-      if (t1.couldBe(TArr) && couldBeHackArr(t2)) return true;
-      if (couldBeHackArr(t1) && t2.couldBe(TArr)) return true;
+      if (t1.couldBe(BArr) && couldBeHackArr(t2)) return true;
+      if (couldBeHackArr(t1) && t2.couldBe(BArr)) return true;
     }
     if (RuntimeOption::EvalHackArrCompatDVCmpNotices) {
-      if (!t1.couldBe(TArr) || !t2.couldBe(TArr)) return false;
-      if (t1.subtypeOf(TPArr) && t2.subtypeOf(TPArr)) return false;
-      if (t1.subtypeOf(TVArr) && t2.subtypeOf(TVArr)) return false;
-      if (t1.subtypeOf(TDArr) && t2.subtypeOf(TDArr)) return false;
+      if (!t1.couldBe(BArr) || !t2.couldBe(BArr)) return false;
+      if (t1.subtypeOf(BPArr) && t2.subtypeOf(BPArr)) return false;
+      if (t1.subtypeOf(BVArr) && t2.subtypeOf(BVArr)) return false;
+      if (t1.subtypeOf(BDArr) && t2.subtypeOf(BDArr)) return false;
       return true;
     }
     return false;
@@ -746,7 +746,7 @@ std::pair<Type,bool> resolveSame(ISS& env) {
     if (l1 == StackDupId ||
         (l1 <= MaxLocalId && l2 <= MaxLocalId &&
          (l1 == l2 || locsAreEquiv(env, l1, l2)))) {
-      if (!t1.couldBe(TDbl) || !t2.couldBe(TDbl) ||
+      if (!t1.couldBe(BDbl) || !t2.couldBe(BDbl) ||
           (v1 && (v1->m_type != KindOfDouble || !std::isnan(v1->m_data.dbl))) ||
           (v2 && (v2->m_type != KindOfDouble || !std::isnan(v2->m_data.dbl)))) {
         return NSame ? TFalse : TTrue;
@@ -818,7 +818,7 @@ void sameJmpImpl(ISS& env, const Same& same, const JmpOp& jmp) {
     if (loc0 <= MaxLocalId && loc1 <= MaxLocalId &&
         (ty0.subtypeOfAny(TOptObj, TOptRes) ||
          ty1.subtypeOfAny(TOptObj, TOptRes) ||
-         (ty0.subtypeOf(TUnc) && ty1.subtypeOf(TUnc)))) {
+         (ty0.subtypeOf(BUnc) && ty1.subtypeOf(BUnc)))) {
       if (loc1 == StackDupId) {
         setStkLocal(env, loc0);
       } else {
@@ -835,13 +835,13 @@ void sameJmpImpl(ISS& env, const Same& same, const JmpOp& jmp) {
       }
     }
     return refineLocation(env, loc1 != NoLocalId ? loc1 : loc0, [&] (Type ty) {
-      if (!ty.couldBe(TUninit) || !isect.couldBe(TNull)) {
+      if (!ty.couldBe(BUninit) || !isect.couldBe(BNull)) {
         auto ret = intersection_of(std::move(ty), isect);
-        return ty.subtypeOf(TUnc) ? ret : loosen_staticness(ret);
+        return ty.subtypeOf(BUnc) ? ret : loosen_staticness(ret);
       }
 
-      if (isect.subtypeOf(TNull)) {
-        return ty.couldBe(TInitNull) ? TNull : TUninit;
+      if (isect.subtypeOf(BNull)) {
+        return ty.couldBe(BInitNull) ? TNull : TUninit;
       }
 
       return ty;
@@ -849,13 +849,13 @@ void sameJmpImpl(ISS& env, const Same& same, const JmpOp& jmp) {
   };
 
   auto handle_differ_side = [&] (LocalId location, const Type& ty) {
-    if (!ty.subtypeOf(TInitNull) && !ty.strictSubtypeOf(TBool)) return true;
+    if (!ty.subtypeOf(BInitNull) && !ty.strictSubtypeOf(TBool)) return true;
     return refineLocation(env, location, [&] (Type t) {
-      if (ty.subtypeOf(TNull)) {
+      if (ty.subtypeOf(BNull)) {
         t = remove_uninit(std::move(t));
         if (is_opt(t)) t = unopt(std::move(t));
         return t;
-      } else if (ty.strictSubtypeOf(TBool) && t.subtypeOf(TBool)) {
+      } else if (ty.strictSubtypeOf(TBool) && t.subtypeOf(BBool)) {
         return ty == TFalse ? TTrue : TFalse;
       }
       return t;
@@ -992,17 +992,17 @@ void in(ISS& env, const bc::Not&) {
 
 void in(ISS& env, const bc::CastBool&) {
   auto const t = topC(env);
-  if (t.subtypeOf(TBool)) return reduce(env, bc::Nop {});
+  if (t.subtypeOf(BBool)) return reduce(env, bc::Nop {});
   castBoolImpl(env, popC(env), false);
 }
 
 void in(ISS& env, const bc::CastInt&) {
   constprop(env);
   auto const t = topC(env);
-  if (t.subtypeOf(TInt)) return reduce(env, bc::Nop {});
+  if (t.subtypeOf(BInt)) return reduce(env, bc::Nop {});
   popC(env);
   // Objects can raise a warning about converting to int.
-  if (!t.couldBe(TObj)) nothrow(env);
+  if (!t.couldBe(BObj)) nothrow(env);
   if (auto const v = tv(t)) {
     auto cell = eval_cell([&] {
       return make_tv<KindOfInt64>(cellToInt(*v));
@@ -1072,7 +1072,7 @@ void in(ISS& env, const bc::DblAsBits&) {
   constprop(env);
 
   auto const ty = popC(env);
-  if (!ty.couldBe(TDbl)) return push(env, ival(0));
+  if (!ty.couldBe(BDbl)) return push(env, ival(0));
 
   if (auto val = tv(ty)) {
     assertx(isDoubleType(val->m_type));
@@ -1091,7 +1091,7 @@ void in(ISS& env, const bc::Print& /*op*/) {
 
 void in(ISS& env, const bc::Clone& /*op*/) {
   auto val = popC(env);
-  if (!val.subtypeOf(TObj)) {
+  if (!val.subtypeOf(BObj)) {
     val = is_opt(val) ? unopt(std::move(val)) : TObj;
   }
   push(env, std::move(val));
@@ -1133,7 +1133,7 @@ void jmpImpl(ISS& env, const JmpOp& op) {
   if (location == NoLocalId) return env.propagate(op.target, &env.state);
 
   auto val = peekLocation(env, location);
-  assertx(!val.couldBe(TRef)); // we shouldn't have an equivLoc if it was
+  assertx(!val.couldBe(BRef)); // we shouldn't have an equivLoc if it was
 
   refineLocation(env, location,
                  Negate ? assert_nonemptiness : assert_emptiness,
@@ -1181,7 +1181,7 @@ void isTypeHelper(ISS& env,
   auto const val = istype.op == Op::IsTypeC ?
     topT(env) : locRaw(env, location);
   auto const testTy = type_of_istype(typeOp);
-  if (!val.subtypeOf(TCell) || val.subtypeOf(testTy) || !val.couldBe(testTy)) {
+  if (!val.subtypeOf(BCell) || val.subtypeOf(testTy) || !val.couldBe(testTy)) {
     return impl(env, istype, jmp);
   }
 
@@ -1195,17 +1195,17 @@ void isTypeHelper(ISS& env,
 
   auto const negate = jmp.op == Op::JmpNZ;
   auto const was_true = [&] (Type t) {
-    if (testTy.subtypeOf(TNull)) return intersection_of(t, TNull);
-    assertx(!testTy.couldBe(TNull));
+    if (testTy.subtypeOf(BNull)) return intersection_of(t, TNull);
+    assertx(!testTy.couldBe(BNull));
     return intersection_of(t, testTy);
   };
   auto const was_false = [&] (Type t) {
     auto tinit = remove_uninit(t);
-    if (testTy.subtypeOf(TNull)) {
+    if (testTy.subtypeOf(BNull)) {
       return is_opt(tinit) ? unopt(tinit) : tinit;
     }
     if (is_opt(tinit)) {
-      assertx(!testTy.couldBe(TNull));
+      assertx(!testTy.couldBe(BNull));
       if (unopt(tinit).subtypeOf(testTy)) return TNull;
     }
     return t;
@@ -1291,7 +1291,7 @@ std::pair<Type, bool> memoizeImplRetType(ISS& env) {
   auto const effectFree = env.index.is_effect_free(memo_impl_func);
   // Regardless of anything we know the return type will be an InitCell (this is
   // a requirement of memoize functions).
-  if (!retTy.subtypeOf(TInitCell)) return { TInitCell, effectFree };
+  if (!retTy.subtypeOf(BInitCell)) return { TInitCell, effectFree };
   return { retTy, effectFree };
 }
 
@@ -1308,7 +1308,7 @@ void typeTestPropagate(ISS& env, Type valTy, Type testTy,
   nothrow(env);
   auto const takenOnSuccess = jmp.op == Op::JmpNZ;
 
-  if (valTy.subtypeOf(testTy) || failTy.subtypeOf(TBottom)) {
+  if (valTy.subtypeOf(testTy) || failTy.subtypeOf(BBottom)) {
     push(env, std::move(valTy));
     if (takenOnSuccess) {
       jmp_setdest(env, jmp.target);
@@ -1349,7 +1349,7 @@ void staticLocCheckJmpImpl(ISS& env,
   }
 
   if (env.collect.localStaticTypes.size() > slc.loc1 &&
-      env.collect.localStaticTypes[slc.loc1].subtypeOf(TBottom)) {
+      env.collect.localStaticTypes[slc.loc1].subtypeOf(BBottom)) {
     if (takenOnInit) {
       env.state = std::move(save);
       jmp_nevertaken(env);
@@ -1484,9 +1484,9 @@ void isTypeStructJmpImpl(ISS& env,
     if (!pass) {
       auto tinit = remove_uninit(t);
       if (tinit.subtypeOf(*ts_type)) return TBottom;
-      if (t.couldBe(TNull)) {
+      if (t.couldBe(BNull)) {
         auto tnonnull = is_opt(tinit) ? unopt(tinit) : tinit;
-        if (ts_type->couldBe(TNull)) {
+        if (ts_type->couldBe(BNull)) {
           return tnonnull;
         }
         if (tnonnull.subtypeOf(*ts_type)) {
@@ -1496,7 +1496,7 @@ void isTypeStructJmpImpl(ISS& env,
 
       return t;
     }
-    if (t.couldBe(TUninit) && ts_type->couldBe(TNull)) {
+    if (t.couldBe(BUninit) && ts_type->couldBe(BNull)) {
       return union_of(intersection_of(std::move(t),
                                       std::move(ts_type.value())),
                       TUninit);
@@ -1661,12 +1661,12 @@ void in(ISS& env, const bc::CGetQuietL& op) {
 
 void in(ISS& env, const bc::CUGetL& op) {
   auto ty = locRaw(env, op.loc1);
-  if (ty.subtypeOf(TUninit)) {
+  if (ty.subtypeOf(BUninit)) {
     return reduce(env, bc::NullUninit {});
   }
   nothrow(env);
-  if (!ty.couldBe(TUninit)) constprop(env);
-  if (!ty.subtypeOf(TCell)) ty = TCell;
+  if (!ty.couldBe(BUninit)) constprop(env);
+  if (!ty.subtypeOf(BCell)) ty = TCell;
   push(env, std::move(ty), op.loc1);
 }
 
@@ -1740,7 +1740,7 @@ void in(ISS& env, const bc::CGetS& op) {
   }
 
   auto indexTy = env.index.lookup_public_static(tcls, tname);
-  if (indexTy.subtypeOf(TInitCell)) {
+  if (indexTy.subtypeOf(BInitCell)) {
     /*
      * Constant propagation here can change when we invoke autoload, so it's
      * considered HardConstProp.  It's safe not to check anything about private
@@ -1804,7 +1804,7 @@ void in(ISS& env, const bc::VGetS& op) {
 
 void clsRefGetImpl(ISS& env, Type t1, ClsRefSlotId slot) {
   auto cls = [&]{
-    if (t1.subtypeOf(TObj)) {
+    if (t1.subtypeOf(BObj)) {
       nothrow(env);
       return objcls(t1);
     }
@@ -1841,7 +1841,7 @@ void in(ISS& env, const bc::AKExists& /*op*/) {
       return t1.subtypeOfAny(TObj, TArr) &&
         RuntimeOption::EvalHackArrCompatNotices;
     }
-    if (t2.subtypeOf(TInt)) return false;
+    if (t2.subtypeOf(BInt)) return false;
     return true;
   }();
 
@@ -1893,26 +1893,26 @@ void in(ISS& env, const bc::GetMemoKeyL& op) {
   switch (mkc) {
     case MK::Int:
       // Always an int, so the key is always an identity mapping
-      if (inTy.subtypeOf(TInt)) return reduce(env, bc::CGetL { op.loc1 });
+      if (inTy.subtypeOf(BInt)) return reduce(env, bc::CGetL { op.loc1 });
       break;
     case MK::Bool:
       // Always a bool, so the key is the bool cast to an int
-      if (inTy.subtypeOf(TBool)) {
+      if (inTy.subtypeOf(BBool)) {
         return reduce(env, bc::CGetL { op.loc1 }, bc::CastInt {});
       }
       break;
     case MK::Str:
       // Always a string, so the key is always an identity mapping
-      if (inTy.subtypeOf(TStr)) return reduce(env, bc::CGetL { op.loc1 });
+      if (inTy.subtypeOf(BStr)) return reduce(env, bc::CGetL { op.loc1 });
       break;
     case MK::IntOrStr:
       // Either an int or string, so the key can be an identity mapping
-      if (inTy.subtypeOf(TArrKey)) return reduce(env, bc::CGetL { op.loc1 });
+      if (inTy.subtypeOf(BArrKey)) return reduce(env, bc::CGetL { op.loc1 });
       break;
     case MK::StrOrNull:
       // A nullable string. The key will either be the string or the integer
       // zero.
-      if (inTy.subtypeOf(TOptStr)) {
+      if (inTy.subtypeOrNull(BStr)) {
         return reduce(
           env,
           bc::CGetL { op.loc1 },
@@ -1925,7 +1925,7 @@ void in(ISS& env, const bc::GetMemoKeyL& op) {
     case MK::IntOrNull:
       // A nullable int. The key will either be the integer, or the static empty
       // string.
-      if (inTy.subtypeOf(TOptInt)) {
+      if (inTy.subtypeOrNull(BInt)) {
         return reduce(
           env,
           bc::CGetL { op.loc1 },
@@ -1937,7 +1937,7 @@ void in(ISS& env, const bc::GetMemoKeyL& op) {
       break;
     case MK::BoolOrNull:
       // A nullable bool. The key will either be 0, 1, or 2.
-      if (inTy.subtypeOf(TOptBool)) {
+      if (inTy.subtypeOrNull(BBool)) {
         return reduce(
           env,
           bc::CGetL { op.loc1 },
@@ -1950,14 +1950,14 @@ void in(ISS& env, const bc::GetMemoKeyL& op) {
       break;
     case MK::Dbl:
       // The double will be converted (losslessly) to an integer.
-      if (inTy.subtypeOf(TDbl)) {
+      if (inTy.subtypeOf(BDbl)) {
         return reduce(env, bc::CGetL { op.loc1 }, bc::DblAsBits {});
       }
       break;
     case MK::DblOrNull:
       // A nullable double. The key will be an integer, or the static empty
       // string.
-      if (inTy.subtypeOf(TOptDbl)) {
+      if (inTy.subtypeOrNull(BDbl)) {
         return reduce(
           env,
           bc::CGetL { op.loc1 },
@@ -2033,8 +2033,8 @@ void in(ISS& env, const bc::GetMemoKeyL& op) {
   }
 
   // Integer keys are always mapped to themselves
-  if (inTy.subtypeOf(TInt)) return reduce(env, bc::CGetL { op.loc1 });
-  if (inTy.subtypeOf(TOptInt)) {
+  if (inTy.subtypeOf(BInt)) return reduce(env, bc::CGetL { op.loc1 });
+  if (inTy.subtypeOrNull(BInt)) {
     return reduce(
       env,
       bc::CGetL { op.loc1 },
@@ -2043,7 +2043,7 @@ void in(ISS& env, const bc::GetMemoKeyL& op) {
       bc::Select {}
     );
   }
-  if (inTy.subtypeOf(TBool)) {
+  if (inTy.subtypeOf(BBool)) {
     return reduce(
       env,
       bc::String { s_falseMemoKey.get() },
@@ -2056,8 +2056,8 @@ void in(ISS& env, const bc::GetMemoKeyL& op) {
   // A memo key can be an integer if the input might be an integer, and is a
   // string otherwise. Booleans and nulls are always static strings.
   auto keyTy = [&]{
-    if (inTy.subtypeOf(TOptBool)) return TSStr;
-    if (inTy.couldBe(TInt))       return union_of(TInt, TStr);
+    if (inTy.subtypeOrNull(BBool)) return TSStr;
+    if (inTy.couldBe(BInt))        return union_of(TInt, TStr);
     return TStr;
   }();
   push(env, std::move(keyTy));
@@ -2073,8 +2073,8 @@ void in(ISS& env, const bc::IssetL& op) {
   nothrow(env);
   constprop(env);
   auto const loc = locAsCell(env, op.loc1);
-  if (loc.subtypeOf(TNull))  return push(env, TFalse);
-  if (!loc.couldBe(TNull))   return push(env, TTrue);
+  if (loc.subtypeOf(BNull))  return push(env, TFalse);
+  if (!loc.couldBe(BNull))   return push(env, TTrue);
   push(env, TBool);
 }
 
@@ -2099,17 +2099,17 @@ void in(ISS& env, const bc::IssetS& op) {
   if (self && tcls.subtypeOf(*self) &&
       vname && vname->m_type == KindOfPersistentString) {
     if (auto const t = selfPropAsCell(env, vname->m_data.pstr)) {
-      if (t->subtypeOf(TNull))  { constprop(env); return push(env, TFalse); }
-      if (!t->couldBe(TNull))   { constprop(env); return push(env, TTrue); }
+      if (t->subtypeOf(BNull))  { constprop(env); return push(env, TFalse); }
+      if (!t->couldBe(BNull))   { constprop(env); return push(env, TTrue); }
     }
   }
 
   auto const indexTy = env.index.lookup_public_static(tcls, tname);
-  if (indexTy.subtypeOf(TInitCell)) {
+  if (indexTy.subtypeOf(BInitCell)) {
     // See the comments in CGetS about constprop for public statics.
     if (options.HardConstProp) constprop(env);
-    if (indexTy.subtypeOf(TNull))  { return push(env, TFalse); }
-    if (!indexTy.couldBe(TNull))   { return push(env, TTrue); }
+    if (indexTy.subtypeOf(BNull))  { return push(env, TFalse); }
+    if (!indexTy.couldBe(BNull))   { return push(env, TTrue); }
   }
 
   push(env, TBool);
@@ -2146,8 +2146,8 @@ void isTypeImpl(ISS& env, const Type& locOrCell, const Type& test) {
 }
 
 void isTypeObj(ISS& env, const Type& ty) {
-  if (!ty.couldBe(TObj)) return push(env, TFalse);
-  if (ty.subtypeOf(TObj)) {
+  if (!ty.couldBe(BObj)) return push(env, TFalse);
+  if (ty.subtypeOf(BObj)) {
     auto const incompl = objExact(
       env.index.builtin_class(s_PHP_Incomplete_Class.get()));
     if (!ty.couldBe(incompl))  return push(env, TTrue);
@@ -2225,7 +2225,7 @@ void in(ISS& env, const bc::InstanceOf& /*op*/) {
                        bc::InstanceOfD { v1->m_data.pstr });
   }
 
-  if (t1.subtypeOf(TObj) && is_specialized_obj(t1)) {
+  if (t1.subtypeOf(BObj) && is_specialized_obj(t1)) {
     auto const dobj = dobj_of(t1);
     switch (dobj.type) {
     case DObj::Sub:
@@ -2280,12 +2280,12 @@ void isAsTypeStructImpl(ISS& env, SArray ts) {
       constprop(env);
       return push(env, out);
     }
-    if (out.subtypeOf(TTrue)) {
+    if (out.subtypeOf(BTrue)) {
       constprop(env);
       push(env, t);
       return reduce(env, bc::Nop {});
     }
-    if (out.subtypeOf(TFalse)) {
+    if (out.subtypeOf(BFalse)) {
       push(env, t);
       return unreachable(env);
     }
@@ -2295,7 +2295,7 @@ void isAsTypeStructImpl(ISS& env, SArray ts) {
     auto const newT = intersection_of(*test, t);
     if (newT == TBottom || !refineLocation(env, location, [&] (Type t) {
           auto ret = intersection_of(*test, t);
-          if (test->couldBe(TInitNull) && t.couldBe(TUninit)) {
+          if (test->couldBe(BInitNull) && t.couldBe(BUninit)) {
             ret |= TUninit;
           }
           return ret;
@@ -2323,8 +2323,8 @@ void isAsTypeStructImpl(ISS& env, SArray ts) {
   };
 
   auto const is_nullable_ts = is_ts_nullable(ts);
-  auto const is_definitely_null = t.subtypeOf(TNull);
-  auto const is_definitely_not_null = !t.couldBe(TNull);
+  auto const is_definitely_null = t.subtypeOf(BNull);
+  auto const is_definitely_not_null = !t.couldBe(BNull);
 
   if (is_nullable_ts && is_definitely_null) return result(TTrue);
 
@@ -2551,11 +2551,11 @@ void in(ISS& env, const bc::SetOpL& op) {
     // We may have inferred a TSStr or TSArr with a value here, but
     // at runtime it will not be static.  For now just throw that
     // away.  TODO(#3696042): should be able to loosen_staticness here.
-    if (resultTy->subtypeOf(TStr)) resultTy = TStr;
-    else if (resultTy->subtypeOf(TArr)) resultTy = TArr;
-    else if (resultTy->subtypeOf(TVec)) resultTy = TVec;
-    else if (resultTy->subtypeOf(TDict)) resultTy = TDict;
-    else if (resultTy->subtypeOf(TKeyset)) resultTy = TKeyset;
+    if (resultTy->subtypeOf(BStr)) resultTy = TStr;
+    else if (resultTy->subtypeOf(BArr)) resultTy = TArr;
+    else if (resultTy->subtypeOf(BVec)) resultTy = TVec;
+    else if (resultTy->subtypeOf(BDict)) resultTy = TDict;
+    else if (resultTy->subtypeOf(BKeyset)) resultTy = TKeyset;
 
     setLoc(env, op.loc1, *resultTy);
     push(env, *resultTy);
@@ -2609,7 +2609,7 @@ void in(ISS& env, const bc::IncDecL& op) {
 
   // If it's a non-numeric string, this may cause it to exceed the max length.
   if (!locCouldBeUninit(env, op.loc1) &&
-      !loc.couldBe(TStr)) {
+      !loc.couldBe(BStr)) {
     nothrow(env);
   }
 
@@ -2732,14 +2732,14 @@ void in(ISS& env, const bc::UnsetN& /*op*/) {
     }
   }
   popC(env);
-  if (!t1.couldBe(TObj) && !t1.couldBe(TRes)) nothrow(env);
+  if (!t1.couldBe(BObj | BRes)) nothrow(env);
   unsetUnknownLocal(env);
   mayUseVV(env);
 }
 
 void in(ISS& env, const bc::UnsetG& /*op*/) {
   auto const t1 = popC(env);
-  if (!t1.couldBe(TObj) && !t1.couldBe(TRes)) nothrow(env);
+  if (!t1.couldBe(BObj | BRes)) nothrow(env);
 }
 
 void in(ISS& env, const bc::FPushFuncD& op) {
@@ -2781,13 +2781,13 @@ void in(ISS& env, const bc::FPushFunc& op) {
     }
   }
   popC(env);
-  if (t1.subtypeOf(TObj)) {
+  if (t1.subtypeOf(BObj)) {
     return fpiPushNoFold(env, ActRec { FPIKind::ObjInvoke, t1 });
   }
-  if (t1.subtypeOf(TArr)) {
+  if (t1.subtypeOf(BArr)) {
     return fpiPushNoFold(env, ActRec { FPIKind::CallableArr, TTop });
   }
-  if (t1.subtypeOf(TStr)) {
+  if (t1.subtypeOf(BStr)) {
     fpiPush(
       env,
       ActRec { FPIKind::Func, TTop, folly::none, rfunc },
@@ -2824,8 +2824,8 @@ const StaticString s_nullFunc { "__SystemLib\\__86null" };
 void in(ISS& env, const bc::FPushObjMethodD& op) {
   auto const nullThrows = op.subop3 == ObjMethodOp::NullThrows;
   auto const input = topC(env);
-  auto const mayCallMethod = input.couldBe(TObj);
-  auto const mayCallNullsafe = !nullThrows && input.couldBe(TNull);
+  auto const mayCallMethod = input.couldBe(BObj);
+  auto const mayCallNullsafe = !nullThrows && input.couldBe(BNull);
   auto const mayThrowNonObj = !input.subtypeOf(nullThrows ? TObj : TOptObj);
 
   if (!mayCallMethod && !mayCallNullsafe) {
@@ -2874,8 +2874,8 @@ void in(ISS& env, const bc::FPushObjMethodD& op) {
   if (location != NoLocalId) {
     if (!refineLocation(env, location, [&] (Type t) {
       if (nullThrows) return intersection_of(t, TObj);
-      if (!t.couldBe(TUninit)) return intersection_of(t, TOptObj);
-      if (!t.couldBe(TObj)) return intersection_of(t, TNull);
+      if (!t.couldBe(BUninit)) return intersection_of(t, TOptObj);
+      if (!t.couldBe(BObj)) return intersection_of(t, TNull);
       return t;
     })) {
       unreachable(env);
@@ -4098,7 +4098,7 @@ void in(ISS& env, const bc::VerifyParamType& op) {
     if (constraint.isThis() && couldBeMocked(t)) {
       t = unctx(std::move(t));
     }
-    if (t.subtypeOf(TBottom)) unreachable(env);
+    if (t.subtypeOf(BBottom)) unreachable(env);
     FTRACE(2, "     {} ({})\n", constraint.fullName(), show(t));
     setLoc(env, op.loc1, std::move(t));
   }
@@ -4159,7 +4159,7 @@ void verifyRetImpl(ISS& env, TypeConstraint& constraint, bool reduce_this) {
   }
 
   auto retT = intersection_of(std::move(tcT), std::move(stackT));
-  if (retT.subtypeOf(TBottom)) {
+  if (retT.subtypeOf(BBottom)) {
     unreachable(env);
     return;
   }
@@ -4186,12 +4186,12 @@ void in(ISS& env, const bc::VerifyRetNonNullC& /*op*/) {
 
   auto stackT = topC(env);
 
-  if (!stackT.couldBe(TInitNull)) {
+  if (!stackT.couldBe(BInitNull)) {
     reduce(env, bc::Nop {});
     return;
   }
 
-  if (stackT.subtypeOf(TNull)) return unreachable(env);
+  if (stackT.subtypeOf(BNull)) return unreachable(env);
 
   auto const equiv = topStkEquiv(env);
 
@@ -4283,7 +4283,7 @@ void in(ISS& env, const bc::ContCurrent&) { push(env, TInitCell); }
 void in(ISS& env, const bc::ContGetReturn&) { push(env, TInitCell); }
 
 void pushTypeFromWH(ISS& env, Type t) {
-  if (!t.couldBe(TObj)) {
+  if (!t.couldBe(BObj)) {
     // These opcodes require an object descending from WaitHandle.
     // Exceptions will be thrown for any non-object.
     push(env, TBottom);
@@ -4301,7 +4301,7 @@ void pushTypeFromWH(ISS& env, Type t) {
   }
 
   auto inner = wait_handle_inner(t);
-  if (inner.subtypeOf(TBottom)) {
+  if (inner.subtypeOf(BBottom)) {
     // If it's a WaitH<Bottom>, we know it's going to throw an exception, and
     // the fallthrough code is not reachable.
     push(env, TBottom);
@@ -4420,7 +4420,7 @@ void in(ISS& env, const bc::MemoGet& op) {
   // and $this isn't available.
   auto allArrKey = true;
   for (uint32_t i = 0; i < op.locrange.count; ++i) {
-    allArrKey &= locRaw(env, op.locrange.first + i).subtypeOf(TArrKey);
+    allArrKey &= locRaw(env, op.locrange.first + i).subtypeOf(BArrKey);
   }
   if (allArrKey &&
       (!env.ctx.func->cls ||
@@ -4452,7 +4452,7 @@ void in(ISS& env, const bc::MemoSet& op) {
   // and $this isn't available.
   auto allArrKey = true;
   for (uint32_t i = 0; i < op.locrange.count; ++i) {
-    allArrKey &= locRaw(env, op.locrange.first + i).subtypeOf(TArrKey);
+    allArrKey &= locRaw(env, op.locrange.first + i).subtypeOf(BArrKey);
   }
   if (allArrKey &&
       (!env.ctx.func->cls ||
diff --git a/hphp/hhbbc/optimize.cpp b/hphp/hhbbc/optimize.cpp
index 3c2e232279..6de9571057 100644
--- a/hphp/hhbbc/optimize.cpp
+++ b/hphp/hhbbc/optimize.cpp
@@ -130,7 +130,7 @@ void insert_assertions_step(ArrayTypeTable::Builder& arrTable,
     auto const realT = state.stack[state.stack.size() - idx - 1].type;
     auto const flav  = stack_flav(realT);
 
-    assert(!realT.subtypeOf(TCls));
+    assert(!realT.subtypeOf(BCls));
     if (options.FilterAssertions && !realT.strictSubtypeOf(flav)) {
       return;
     }
@@ -192,7 +192,7 @@ bool hasObviousStackOutput(const Bytecode& op, const Interp& interp) {
   // Generally consider CGetL obvious because if we knew the type of the local,
   // we'll assert that right before the CGetL.
   auto cgetlObvious = [&] (LocalId l, int idx) {
-    return !interp.state.locals[l].couldBe(TRef) ||
+    return !interp.state.locals[l].couldBe(BRef) ||
       !interp.state.stack[interp.state.stack.size() - idx - 1].
          type.strictSubtypeOf(TInitCell);
   };
@@ -565,7 +565,7 @@ void first_pass(const Index& index,
     SCOPE_EXIT {
       if (op.op == Op::CGetL2) {
         srcStack.emplace(srcStack.end() - 1,
-                         op.op, (state.stack.end() - 2)->type.subtypeOf(TStr));
+                         op.op, (state.stack.end() - 2)->type.subtypeOf(BStr));
       } else {
         FTRACE(2, "   srcStack: pop {} push {}\n", op.numPop(), op.numPush());
         for (int i = 0; i < op.numPop(); i++) {
@@ -573,7 +573,7 @@ void first_pass(const Index& index,
         }
         for (int i = 0; i < op.numPush(); i++) {
           srcStack.emplace_back(
-            op.op, state.stack[srcStack.size()].type.subtypeOf(TStr));
+            op.op, state.stack[srcStack.size()].type.subtypeOf(BStr));
         }
       }
     };
@@ -1192,21 +1192,21 @@ void do_optimize(const Index& index, FuncAnalysis&& ainfo, bool isFinal) {
     };
 
     assertx(!RuntimeOption::EvalHackArrDVArrs ||
-            (!t.subtypeOf(TVArr) && !t.subtypeOf(TDArr)));
-
-    if (t.subtypeOf(TInitNull)) return retype(AnnotType::Null);
-    if (t.subtypeOf(TBool))     return retype(AnnotType::Bool);
-    if (t.subtypeOf(TInt))      return retype(AnnotType::Int);
-    if (t.subtypeOf(TDbl))      return retype(AnnotType::Float);
-    if (t.subtypeOf(TStr))      return retype(AnnotType::String);
-    if (t.subtypeOf(TPArr))     return retype(AnnotType::Array);
-    if (t.subtypeOf(TVArr))     return retype(AnnotType::VArray);
-    if (t.subtypeOf(TDArr))     return retype(AnnotType::DArray);
-    // if (t.subtypeOf(TObj))   return retype(AnnotType::Object);
-    if (t.subtypeOf(TRes))      return retype(AnnotType::Resource);
-    if (t.subtypeOf(TDict))     return retype(AnnotType::Dict);
-    if (t.subtypeOf(TVec))      return retype(AnnotType::Vec);
-    if (t.subtypeOf(TKeyset))   return retype(AnnotType::Keyset);
+            (!t.subtypeOf(BVArr) && !t.subtypeOf(BDArr)));
+
+    if (t.subtypeOf(BInitNull)) return retype(AnnotType::Null);
+    if (t.subtypeOf(BBool))     return retype(AnnotType::Bool);
+    if (t.subtypeOf(BInt))      return retype(AnnotType::Int);
+    if (t.subtypeOf(BDbl))      return retype(AnnotType::Float);
+    if (t.subtypeOf(BStr))      return retype(AnnotType::String);
+    if (t.subtypeOf(BPArr))     return retype(AnnotType::Array);
+    if (t.subtypeOf(BVArr))     return retype(AnnotType::VArray);
+    if (t.subtypeOf(BDArr))     return retype(AnnotType::DArray);
+    // if (t.subtypeOf(BObj))   return retype(AnnotType::Object);
+    if (t.subtypeOf(BRes))      return retype(AnnotType::Resource);
+    if (t.subtypeOf(BDict))     return retype(AnnotType::Dict);
+    if (t.subtypeOf(BVec))      return retype(AnnotType::Vec);
+    if (t.subtypeOf(BKeyset))   return retype(AnnotType::Keyset);
   };
 
   if (RuntimeOption::EvalHardTypeHints) {
diff --git a/hphp/hhbbc/show.cpp b/hphp/hhbbc/show.cpp
index b57b9526ad..6ead8b883d 100644
--- a/hphp/hhbbc/show.cpp
+++ b/hphp/hhbbc/show.cpp
@@ -497,7 +497,7 @@ std::string show(const Type& t) {
   }
 
   auto showElem = [&] (const Type& key, const Type& val) -> std::string {
-    if (t.subtypeOf(TOptKeyset)) return show(key);
+    if (t.subtypeOrNull(BKeyset)) return show(key);
     return show(key) + ":" + show(val);
   };
 
diff --git a/hphp/hhbbc/test/type-system.cpp b/hphp/hhbbc/test/type-system.cpp
index b0305da3dc..159fc8258d 100644
--- a/hphp/hhbbc/test/type-system.cpp
+++ b/hphp/hhbbc/test/type-system.cpp
@@ -426,8 +426,8 @@ TEST(Type, Top) {
   // Everything is a subtype of Top, couldBe Top, and the union of Top
   // with anything is Top.
   for (auto& t : all_with_waithandles(index)) {
-    EXPECT_TRUE(t.subtypeOf(TTop));
-    EXPECT_TRUE(t.couldBe(TTop));
+    EXPECT_TRUE(t.subtypeOf(BTop));
+    EXPECT_TRUE(t.couldBe(BTop));
     EXPECT_TRUE(union_of(t, TTop) == TTop);
     EXPECT_TRUE(union_of(TTop, t) == TTop);
   }
@@ -604,11 +604,11 @@ TEST(Type, CouldBeValues) {
 }
 
 TEST(Type, Unc) {
-  EXPECT_TRUE(TInt.subtypeOf(TInitUnc));
-  EXPECT_TRUE(TInt.subtypeOf(TUnc));
-  EXPECT_TRUE(TDbl.subtypeOf(TInitUnc));
-  EXPECT_TRUE(TDbl.subtypeOf(TUnc));
-  EXPECT_TRUE(dval(3.0).subtypeOf(TInitUnc));
+  EXPECT_TRUE(TInt.subtypeOf(BInitUnc));
+  EXPECT_TRUE(TInt.subtypeOf(BUnc));
+  EXPECT_TRUE(TDbl.subtypeOf(BInitUnc));
+  EXPECT_TRUE(TDbl.subtypeOf(BUnc));
+  EXPECT_TRUE(dval(3.0).subtypeOf(BInitUnc));
 
   const std::initializer_list<std::pair<Type, Type>> pairs{
     { TUnc, TInitUnc },
@@ -641,62 +641,62 @@ TEST(Type, Option) {
   auto const program = make_program();
   Index index { borrow(program) };
 
-  EXPECT_TRUE(TTrue.subtypeOf(TOptTrue));
-  EXPECT_TRUE(TInitNull.subtypeOf(TOptTrue));
-  EXPECT_TRUE(!TUninit.subtypeOf(TOptTrue));
-
-  EXPECT_TRUE(TFalse.subtypeOf(TOptFalse));
-  EXPECT_TRUE(TInitNull.subtypeOf(TOptFalse));
-  EXPECT_TRUE(!TUninit.subtypeOf(TOptFalse));
-
-  EXPECT_TRUE(TFalse.subtypeOf(TOptBool));
-  EXPECT_TRUE(TTrue.subtypeOf(TOptBool));
-  EXPECT_TRUE(TInitNull.subtypeOf(TOptBool));
-  EXPECT_TRUE(!TUninit.subtypeOf(TOptBool));
-
-  EXPECT_TRUE(ival(3).subtypeOf(TOptInt));
-  EXPECT_TRUE(TInt.subtypeOf(TOptInt));
-  EXPECT_TRUE(TInitNull.subtypeOf(TOptInt));
-  EXPECT_TRUE(!TUninit.subtypeOf(TOptInt));
-
-  EXPECT_TRUE(TDbl.subtypeOf(TOptDbl));
-  EXPECT_TRUE(TInitNull.subtypeOf(TOptDbl));
-  EXPECT_TRUE(!TUninit.subtypeOf(TOptDbl));
-  EXPECT_TRUE(dval(3.0).subtypeOf(TOptDbl));
-
-  EXPECT_TRUE(sval(s_test.get()).subtypeOf(TOptSStr));
-  EXPECT_TRUE(TSStr.subtypeOf(TOptSStr));
-  EXPECT_TRUE(TInitNull.subtypeOf(TOptSStr));
-  EXPECT_TRUE(!TUninit.subtypeOf(TOptSStr));
-  EXPECT_TRUE(!TStr.subtypeOf(TOptSStr));
-  EXPECT_TRUE(TStr.couldBe(TOptSStr));
-
-  EXPECT_TRUE(TStr.subtypeOf(TOptStr));
-  EXPECT_TRUE(TSStr.subtypeOf(TOptStr));
-  EXPECT_TRUE(sval(s_test.get()).subtypeOf(TOptStr));
-  EXPECT_TRUE(TInitNull.subtypeOf(TOptStr));
-  EXPECT_TRUE(!TUninit.subtypeOf(TOptStr));
-
-  EXPECT_TRUE(TSArr.subtypeOf(TOptSArr));
-  EXPECT_TRUE(!TArr.subtypeOf(TOptSArr));
-  EXPECT_TRUE(TInitNull.subtypeOf(TOptSArr));
-  EXPECT_TRUE(!TUninit.subtypeOf(TOptSArr));
-
-  EXPECT_TRUE(TArr.subtypeOf(TOptArr));
-  EXPECT_TRUE(TInitNull.subtypeOf(TOptArr));
-  EXPECT_TRUE(!TUninit.subtypeOf(TOptArr));
-
-  EXPECT_TRUE(TObj.subtypeOf(TOptObj));
-  EXPECT_TRUE(TInitNull.subtypeOf(TOptObj));
-  EXPECT_TRUE(!TUninit.subtypeOf(TOptObj));
-
-  EXPECT_TRUE(TRes.subtypeOf(TOptRes));
-  EXPECT_TRUE(TInitNull.subtypeOf(TOptRes));
-  EXPECT_TRUE(!TUninit.subtypeOf(TOptRes));
-
-  EXPECT_TRUE(TArrKey.subtypeOf(TOptArrKey));
-  EXPECT_TRUE(TInitNull.subtypeOf(TOptArrKey));
-  EXPECT_TRUE(!TUninit.subtypeOf(TOptArrKey));
+  EXPECT_TRUE(TTrue.subtypeOrNull(BTrue));
+  EXPECT_TRUE(TInitNull.subtypeOrNull(BTrue));
+  EXPECT_TRUE(!TUninit.subtypeOrNull(BTrue));
+
+  EXPECT_TRUE(TFalse.subtypeOrNull(BFalse));
+  EXPECT_TRUE(TInitNull.subtypeOrNull(BFalse));
+  EXPECT_TRUE(!TUninit.subtypeOrNull(BFalse));
+
+  EXPECT_TRUE(TFalse.subtypeOrNull(BBool));
+  EXPECT_TRUE(TTrue.subtypeOrNull(BBool));
+  EXPECT_TRUE(TInitNull.subtypeOrNull(BBool));
+  EXPECT_TRUE(!TUninit.subtypeOrNull(BBool));
+
+  EXPECT_TRUE(ival(3).subtypeOrNull(BInt));
+  EXPECT_TRUE(TInt.subtypeOrNull(BInt));
+  EXPECT_TRUE(TInitNull.subtypeOrNull(BInt));
+  EXPECT_TRUE(!TUninit.subtypeOrNull(BInt));
+
+  EXPECT_TRUE(TDbl.subtypeOrNull(BDbl));
+  EXPECT_TRUE(TInitNull.subtypeOrNull(BDbl));
+  EXPECT_TRUE(!TUninit.subtypeOrNull(BDbl));
+  EXPECT_TRUE(dval(3.0).subtypeOrNull(BDbl));
+
+  EXPECT_TRUE(sval(s_test.get()).subtypeOrNull(BSStr));
+  EXPECT_TRUE(TSStr.subtypeOrNull(BSStr));
+  EXPECT_TRUE(TInitNull.subtypeOrNull(BSStr));
+  EXPECT_TRUE(!TUninit.subtypeOrNull(BSStr));
+  EXPECT_TRUE(!TStr.subtypeOrNull(BSStr));
+  EXPECT_TRUE(TStr.couldBe(BOptSStr));
+
+  EXPECT_TRUE(TStr.subtypeOrNull(BStr));
+  EXPECT_TRUE(TSStr.subtypeOrNull(BStr));
+  EXPECT_TRUE(sval(s_test.get()).subtypeOrNull(BStr));
+  EXPECT_TRUE(TInitNull.subtypeOrNull(BStr));
+  EXPECT_TRUE(!TUninit.subtypeOrNull(BStr));
+
+  EXPECT_TRUE(TSArr.subtypeOrNull(BSArr));
+  EXPECT_TRUE(!TArr.subtypeOrNull(BSArr));
+  EXPECT_TRUE(TInitNull.subtypeOrNull(BSArr));
+  EXPECT_TRUE(!TUninit.subtypeOrNull(BSArr));
+
+  EXPECT_TRUE(TArr.subtypeOrNull(BArr));
+  EXPECT_TRUE(TInitNull.subtypeOrNull(BArr));
+  EXPECT_TRUE(!TUninit.subtypeOrNull(BArr));
+
+  EXPECT_TRUE(TObj.subtypeOrNull(BObj));
+  EXPECT_TRUE(TInitNull.subtypeOrNull(BObj));
+  EXPECT_TRUE(!TUninit.subtypeOrNull(BObj));
+
+  EXPECT_TRUE(TRes.subtypeOrNull(BRes));
+  EXPECT_TRUE(TInitNull.subtypeOrNull(BRes));
+  EXPECT_TRUE(!TUninit.subtypeOrNull(BRes));
+
+  EXPECT_TRUE(TArrKey.subtypeOrNull(BArrKey));
+  EXPECT_TRUE(TInitNull.subtypeOrNull(BArrKey));
+  EXPECT_TRUE(!TUninit.subtypeOrNull(BArrKey));
 
   for (auto& t : optionals()) EXPECT_EQ(t, opt(unopt(t)));
   for (auto& t : optionals()) EXPECT_TRUE(is_opt(t));
@@ -846,8 +846,8 @@ TEST(Type, OptCouldBe) {
 
   for (auto& x : optionals()) {
     EXPECT_TRUE(x.couldBe(unopt(x)));
-    EXPECT_TRUE(x.couldBe(TInitNull));
-    EXPECT_TRUE(!x.couldBe(TUninit));
+    EXPECT_TRUE(x.couldBe(BInitNull));
+    EXPECT_TRUE(!x.couldBe(BUninit));
     for (auto& y : optionals()) {
       EXPECT_TRUE(x.couldBe(y));
     }
@@ -861,12 +861,12 @@ TEST(Type, Ref) {
   EXPECT_TRUE(ref_to(TInt) != ref_to(TOptInt));
 
   EXPECT_TRUE(TRef.couldBe(ref_to(TInt)));
-  EXPECT_TRUE(ref_to(TInt).couldBe(TRef));
+  EXPECT_TRUE(ref_to(TInt).couldBe(BRef));
   EXPECT_TRUE(!ref_to(TInt).couldBe(ref_to(TObj)));
   EXPECT_TRUE(ref_to(TOptInt).couldBe(ref_to(TInt)));
 
   EXPECT_TRUE(!TRef.subtypeOf(ref_to(TInt)));
-  EXPECT_TRUE(ref_to(TInt).subtypeOf(TRef));
+  EXPECT_TRUE(ref_to(TInt).subtypeOf(BRef));
   EXPECT_TRUE(ref_to(TInt).subtypeOf(ref_to(TOptInt)));
   EXPECT_TRUE(!ref_to(TOptInt).subtypeOf(ref_to(TInt)));
   EXPECT_TRUE(!ref_to(TObj).subtypeOf(ref_to(TInt)));
@@ -883,25 +883,25 @@ TEST(Type, SpecificExamples) {
   EXPECT_TRUE(!TInt.subtypeOf(ival(1)));
 
   EXPECT_TRUE(TInitCell.couldBe(ival(1)));
-  EXPECT_TRUE(TInitCell.subtypeOf(TGen));
-  EXPECT_TRUE(ival(2).subtypeOf(TInt));
-  EXPECT_TRUE(!ival(2).subtypeOf(TBool));
-  EXPECT_TRUE(ival(3).subtypeOf(TOptInt));
-  EXPECT_TRUE(TInt.subtypeOf(TOptInt));
-  EXPECT_TRUE(!TBool.subtypeOf(TOptInt));
-  EXPECT_TRUE(TInitNull.subtypeOf(TOptInt));
-  EXPECT_TRUE(!TNull.subtypeOf(TOptInt));
-  EXPECT_TRUE(TNull.couldBe(TOptInt));
-  EXPECT_TRUE(TNull.couldBe(TOptBool));
-
-  EXPECT_TRUE(TInitNull.subtypeOf(TInitCell));
-  EXPECT_TRUE(TInitNull.subtypeOf(TCell));
-  EXPECT_TRUE(!TUninit.subtypeOf(TInitNull));
-
-  EXPECT_TRUE(ival(3).subtypeOf(TOptInt));
+  EXPECT_TRUE(TInitCell.subtypeOf(BGen));
+  EXPECT_TRUE(ival(2).subtypeOf(BInt));
+  EXPECT_TRUE(!ival(2).subtypeOf(BBool));
+  EXPECT_TRUE(ival(3).subtypeOrNull(BInt));
+  EXPECT_TRUE(TInt.subtypeOrNull(BInt));
+  EXPECT_TRUE(!TBool.subtypeOrNull(BInt));
+  EXPECT_TRUE(TInitNull.subtypeOrNull(BInt));
+  EXPECT_TRUE(!TNull.subtypeOrNull(BInt));
+  EXPECT_TRUE(TNull.couldBe(BOptInt));
+  EXPECT_TRUE(TNull.couldBe(BOptBool));
+
+  EXPECT_TRUE(TInitNull.subtypeOf(BInitCell));
+  EXPECT_TRUE(TInitNull.subtypeOf(BCell));
+  EXPECT_TRUE(!TUninit.subtypeOf(BInitNull));
+
+  EXPECT_TRUE(ival(3).subtypeOrNull(BInt));
   EXPECT_TRUE(ival(3).subtypeOf(opt(ival(3))));
   EXPECT_TRUE(ival(3).couldBe(opt(ival(3))));
-  EXPECT_TRUE(ival(3).couldBe(TInt));
+  EXPECT_TRUE(ival(3).couldBe(BInt));
   EXPECT_TRUE(TInitNull.couldBe(opt(ival(3))));
   EXPECT_TRUE(TNull.couldBe(opt(ival(3))));
   EXPECT_TRUE(TInitNull.subtypeOf(opt(ival(3))));
@@ -954,28 +954,28 @@ TEST(Type, IndexBased) {
   EXPECT_TRUE(subClsTy.couldBe(clsExactTy));
 
   // Foo= and Foo<= are both subtypes of Foo, and couldBe Foo.
-  EXPECT_TRUE(objExactTy.subtypeOf(TObj));
-  EXPECT_TRUE(subObjTy.subtypeOf(TObj));
-  EXPECT_TRUE(objExactTy.couldBe(TObj));
-  EXPECT_TRUE(subObjTy.couldBe(TObj));
+  EXPECT_TRUE(objExactTy.subtypeOf(BObj));
+  EXPECT_TRUE(subObjTy.subtypeOf(BObj));
+  EXPECT_TRUE(objExactTy.couldBe(BObj));
+  EXPECT_TRUE(subObjTy.couldBe(BObj));
   EXPECT_TRUE(TObj.couldBe(objExactTy));
   EXPECT_TRUE(TObj.couldBe(subObjTy));
-  EXPECT_TRUE(clsExactTy.subtypeOf(TCls));
-  EXPECT_TRUE(subClsTy.subtypeOf(TCls));
-  EXPECT_TRUE(clsExactTy.couldBe(TCls));
-  EXPECT_TRUE(subClsTy.couldBe(TCls));
+  EXPECT_TRUE(clsExactTy.subtypeOf(BCls));
+  EXPECT_TRUE(subClsTy.subtypeOf(BCls));
+  EXPECT_TRUE(clsExactTy.couldBe(BCls));
+  EXPECT_TRUE(subClsTy.couldBe(BCls));
   EXPECT_TRUE(TCls.couldBe(clsExactTy));
   EXPECT_TRUE(TCls.couldBe(subClsTy));
 
   // Obj= and Obj<= both couldBe ?Obj, and vice versa.
-  EXPECT_TRUE(objExactTy.couldBe(TOptObj));
-  EXPECT_TRUE(subObjTy.couldBe(TOptObj));
+  EXPECT_TRUE(objExactTy.couldBe(BOptObj));
+  EXPECT_TRUE(subObjTy.couldBe(BOptObj));
   EXPECT_TRUE(TOptObj.couldBe(objExactTy));
   EXPECT_TRUE(TOptObj.couldBe(subObjTy));
 
   // Obj= and Obj<= are subtypes of ?Obj.
-  EXPECT_TRUE(objExactTy.subtypeOf(TOptObj));
-  EXPECT_TRUE(subObjTy.subtypeOf(TOptObj));
+  EXPECT_TRUE(objExactTy.subtypeOrNull(BObj));
+  EXPECT_TRUE(subObjTy.subtypeOrNull(BObj));
 
   // Obj= is a subtype of ?Obj=, and also ?Obj<=.
   EXPECT_TRUE(objExactTy.subtypeOf(opt(objExactTy)));
@@ -1509,7 +1509,7 @@ TEST(Type, WaitH) {
   auto const optWH = opt(wait_handle(index, ival(2)));
   EXPECT_TRUE(is_opt(optWH));
   EXPECT_TRUE(TInitNull.subtypeOf(optWH));
-  EXPECT_TRUE(optWH.subtypeOf(TOptObj));
+  EXPECT_TRUE(optWH.subtypeOrNull(BObj));
   EXPECT_TRUE(optWH.subtypeOf(opt(twhobj)));
   EXPECT_TRUE(wait_handle(index, ival(2)).subtypeOf(optWH));
   EXPECT_FALSE(optWH.subtypeOf(wait_handle(index, ival(2))));
@@ -1583,18 +1583,18 @@ TEST(Type, ArrPacked1) {
   auto const s2 = sarr_packed({TInt,    TStr,  TInitCell});
 
   for (auto& a : { a1, s1, a2, s2 }) {
-    EXPECT_TRUE(a.subtypeOf(TArr));
+    EXPECT_TRUE(a.subtypeOf(BArr));
     EXPECT_TRUE(a.subtypeOf(a));
     EXPECT_EQ(a, a);
   }
 
   // Subtype stuff.
 
-  EXPECT_TRUE(a1.subtypeOf(TArr));
-  EXPECT_FALSE(a1.subtypeOf(TSArr));
+  EXPECT_TRUE(a1.subtypeOf(BArr));
+  EXPECT_FALSE(a1.subtypeOf(BSArr));
 
-  EXPECT_TRUE(s1.subtypeOf(TArr));
-  EXPECT_TRUE(s1.subtypeOf(TSArr));
+  EXPECT_TRUE(s1.subtypeOf(BArr));
+  EXPECT_TRUE(s1.subtypeOf(BSArr));
 
   EXPECT_TRUE(a1.subtypeOf(a2));
   EXPECT_TRUE(s1.subtypeOf(s2));
@@ -1621,18 +1621,18 @@ TEST(Type, OptArrPacked1) {
   auto const s2 = opt(sarr_packed({TInt,    TStr,  TInitCell}));
 
   for (auto& a : { a1, s1, a2, s2 }) {
-    EXPECT_TRUE(a.subtypeOf(TOptArr));
+    EXPECT_TRUE(a.subtypeOrNull(BArr));
     EXPECT_TRUE(a.subtypeOf(a));
     EXPECT_EQ(a, a);
   }
 
   // Subtype stuff.
 
-  EXPECT_TRUE(a1.subtypeOf(TOptArr));
-  EXPECT_FALSE(a1.subtypeOf(TOptSArr));
+  EXPECT_TRUE(a1.subtypeOrNull(BArr));
+  EXPECT_FALSE(a1.subtypeOrNull(BSArr));
 
-  EXPECT_TRUE(s1.subtypeOf(TOptArr));
-  EXPECT_TRUE(s1.subtypeOf(TOptSArr));
+  EXPECT_TRUE(s1.subtypeOrNull(BArr));
+  EXPECT_TRUE(s1.subtypeOrNull(BSArr));
 
   EXPECT_TRUE(a1.subtypeOf(a2));
   EXPECT_TRUE(s1.subtypeOf(s2));
@@ -1805,9 +1805,9 @@ TEST(Type, ArrStruct) {
   EXPECT_FALSE(tc.couldBe(ta));
   EXPECT_FALSE(tc.couldBe(tb));
 
-  EXPECT_TRUE(ta.subtypeOf(TArr));
-  EXPECT_TRUE(tb.subtypeOf(TArr));
-  EXPECT_TRUE(tc.subtypeOf(TArr));
+  EXPECT_TRUE(ta.subtypeOf(BArr));
+  EXPECT_TRUE(tb.subtypeOf(BArr));
+  EXPECT_TRUE(tc.subtypeOf(BArr));
 
   auto const sa = sarr_map(test_map_a);
   auto const sb = sarr_map(test_map_b);
@@ -1822,9 +1822,9 @@ TEST(Type, ArrStruct) {
   EXPECT_FALSE(sc.couldBe(sa));
   EXPECT_FALSE(sc.couldBe(sb));
 
-  EXPECT_TRUE(sa.subtypeOf(TSArr));
-  EXPECT_TRUE(sb.subtypeOf(TSArr));
-  EXPECT_TRUE(sc.subtypeOf(TSArr));
+  EXPECT_TRUE(sa.subtypeOf(BSArr));
+  EXPECT_TRUE(sb.subtypeOf(BSArr));
+  EXPECT_TRUE(sc.subtypeOf(BSArr));
 
   auto test_map_d          = MapElems{};
   test_map_d[tv(s_A)]      = sval(s_B.get());
@@ -2012,19 +2012,19 @@ TEST(Type, EmptyArray) {
     EXPECT_TRUE(estat.couldBe(aempty()));
     EXPECT_TRUE(estat.couldBe(sarr_packedn(TInt)));
     EXPECT_FALSE(estat.subtypeOf(sarr_packedn(TInt)));
-    EXPECT_FALSE(estat.subtypeOf(TSArrE));
-    EXPECT_TRUE(estat.couldBe(TSArrE));
+    EXPECT_FALSE(estat.subtypeOf(BSArrE));
+    EXPECT_TRUE(estat.couldBe(BSArrE));
   }
 
   EXPECT_EQ(array_newelem(aempty(), ival(142)).first, arr_packed({ival(142)}));
 }
 
 TEST(Type, BasicArrays) {
-  EXPECT_TRUE(TSArr.subtypeOf(TArr));
-  EXPECT_TRUE(TArrE.subtypeOf(TArr));
-  EXPECT_TRUE(TArrN.subtypeOf(TArr));
-  EXPECT_TRUE(TSArrE.subtypeOf(TArr));
-  EXPECT_TRUE(TSArrN.subtypeOf(TArr));
+  EXPECT_TRUE(TSArr.subtypeOf(BArr));
+  EXPECT_TRUE(TArrE.subtypeOf(BArr));
+  EXPECT_TRUE(TArrN.subtypeOf(BArr));
+  EXPECT_TRUE(TSArrE.subtypeOf(BArr));
+  EXPECT_TRUE(TSArrN.subtypeOf(BArr));
 
   EXPECT_EQ(union_of(TArrN, TArrE), TArr);
 
@@ -2081,53 +2081,53 @@ TEST(Type, BasicArrays) {
  */
 TEST(Type, ArrBitCombos) {
   auto const u1 = union_of(sarr_packedn(TInt), TArrE);
-  EXPECT_TRUE(u1.couldBe(TArrE));
-  EXPECT_TRUE(u1.couldBe(TSArrE));
+  EXPECT_TRUE(u1.couldBe(BArrE));
+  EXPECT_TRUE(u1.couldBe(BSArrE));
   EXPECT_TRUE(u1.couldBe(sarr_packedn(TInt)));
   EXPECT_EQ(array_elem(u1, ival(0)).first, TOptInt);
 
   auto const u2 = union_of(TSArrE, arr_packedn(TInt));
-  EXPECT_TRUE(u2.couldBe(TArrE));
-  EXPECT_TRUE(u2.couldBe(TSArrE));
+  EXPECT_TRUE(u2.couldBe(BArrE));
+  EXPECT_TRUE(u2.couldBe(BSArrE));
   EXPECT_TRUE(u2.couldBe(arr_packedn(TInt)));
   EXPECT_EQ(array_elem(u2, ival(0)).first, TOptInt);
 }
 
 TEST(Type, ArrKey) {
-  EXPECT_TRUE(TInt.subtypeOf(TArrKey));
-  EXPECT_TRUE(TStr.subtypeOf(TArrKey));
-  EXPECT_TRUE(ival(0).subtypeOf(TArrKey));
-  EXPECT_TRUE(sval(s_test.get()).subtypeOf(TArrKey));
-
-  EXPECT_TRUE(TInt.subtypeOf(TOptArrKey));
-  EXPECT_TRUE(TStr.subtypeOf(TOptArrKey));
-  EXPECT_TRUE(ival(0).subtypeOf(TOptArrKey));
-  EXPECT_TRUE(sval(s_test.get()).subtypeOf(TOptArrKey));
-  EXPECT_TRUE(TInitNull.subtypeOf(TOptArrKey));
-
-  EXPECT_TRUE(TInt.subtypeOf(TUncArrKey));
-  EXPECT_TRUE(TSStr.subtypeOf(TUncArrKey));
-  EXPECT_TRUE(ival(0).subtypeOf(TUncArrKey));
-  EXPECT_TRUE(sval(s_test.get()).subtypeOf(TUncArrKey));
-
-  EXPECT_TRUE(TInt.subtypeOf(TOptUncArrKey));
-  EXPECT_TRUE(TSStr.subtypeOf(TOptUncArrKey));
-  EXPECT_TRUE(ival(0).subtypeOf(TOptUncArrKey));
-  EXPECT_TRUE(sval(s_test.get()).subtypeOf(TOptUncArrKey));
-  EXPECT_TRUE(TInitNull.subtypeOf(TOptUncArrKey));
-
-  EXPECT_TRUE(TArrKey.subtypeOf(TOptArrKey));
-  EXPECT_TRUE(TUncArrKey.subtypeOf(TOptUncArrKey));
-  EXPECT_TRUE(TUncArrKey.subtypeOf(TArrKey));
-  EXPECT_TRUE(TOptUncArrKey.subtypeOf(TOptArrKey));
-
-  EXPECT_TRUE(TArrKey.subtypeOf(TInitCell));
-  EXPECT_TRUE(TUncArrKey.subtypeOf(TInitCell));
-  EXPECT_TRUE(TOptArrKey.subtypeOf(TInitCell));
-  EXPECT_TRUE(TOptUncArrKey.subtypeOf(TInitCell));
-
-  EXPECT_TRUE(TUncArrKey.subtypeOf(TInitUnc));
-  EXPECT_TRUE(TOptUncArrKey.subtypeOf(TInitUnc));
+  EXPECT_TRUE(TInt.subtypeOf(BArrKey));
+  EXPECT_TRUE(TStr.subtypeOf(BArrKey));
+  EXPECT_TRUE(ival(0).subtypeOf(BArrKey));
+  EXPECT_TRUE(sval(s_test.get()).subtypeOf(BArrKey));
+
+  EXPECT_TRUE(TInt.subtypeOrNull(BArrKey));
+  EXPECT_TRUE(TStr.subtypeOrNull(BArrKey));
+  EXPECT_TRUE(ival(0).subtypeOrNull(BArrKey));
+  EXPECT_TRUE(sval(s_test.get()).subtypeOrNull(BArrKey));
+  EXPECT_TRUE(TInitNull.subtypeOrNull(BArrKey));
+
+  EXPECT_TRUE(TInt.subtypeOf(BUncArrKey));
+  EXPECT_TRUE(TSStr.subtypeOf(BUncArrKey));
+  EXPECT_TRUE(ival(0).subtypeOf(BUncArrKey));
+  EXPECT_TRUE(sval(s_test.get()).subtypeOf(BUncArrKey));
+
+  EXPECT_TRUE(TInt.subtypeOrNull(BUncArrKey));
+  EXPECT_TRUE(TSStr.subtypeOrNull(BUncArrKey));
+  EXPECT_TRUE(ival(0).subtypeOrNull(BUncArrKey));
+  EXPECT_TRUE(sval(s_test.get()).subtypeOrNull(BUncArrKey));
+  EXPECT_TRUE(TInitNull.subtypeOrNull(BUncArrKey));
+
+  EXPECT_TRUE(TArrKey.subtypeOrNull(BArrKey));
+  EXPECT_TRUE(TUncArrKey.subtypeOrNull(BUncArrKey));
+  EXPECT_TRUE(TUncArrKey.subtypeOf(BArrKey));
+  EXPECT_TRUE(TOptUncArrKey.subtypeOrNull(BArrKey));
+
+  EXPECT_TRUE(TArrKey.subtypeOf(BInitCell));
+  EXPECT_TRUE(TUncArrKey.subtypeOf(BInitCell));
+  EXPECT_TRUE(TOptArrKey.subtypeOf(BInitCell));
+  EXPECT_TRUE(TOptUncArrKey.subtypeOf(BInitCell));
+
+  EXPECT_TRUE(TUncArrKey.subtypeOf(BInitUnc));
+  EXPECT_TRUE(TOptUncArrKey.subtypeOf(BInitUnc));
 
   EXPECT_TRUE(union_of(TInt, TStr) == TArrKey);
   EXPECT_TRUE(union_of(TInt, TSStr) == TUncArrKey);
@@ -2295,7 +2295,7 @@ TEST(Type, LoosenValues) {
   };
   for (auto const& p : tests) {
     EXPECT_EQ(loosen_values(p.first), p.second);
-    if (p.first.subtypeOf(TRef)) continue;
+    if (p.first.subtypeOf(BRef)) continue;
     EXPECT_EQ(loosen_values(opt(p.first)), opt(p.second));
   }
 
diff --git a/hphp/hhbbc/type-builtins.cpp b/hphp/hhbbc/type-builtins.cpp
index 7df26c7c4d..4b4c7e38b4 100644
--- a/hphp/hhbbc/type-builtins.cpp
+++ b/hphp/hhbbc/type-builtins.cpp
@@ -90,7 +90,7 @@ Type native_function_return_type(borrowed_ptr<const php::Func> f,
     auto const hni = f->nativeInfo->returnType;
     return hni ? from_DataType(*hni) : TInitCell;
   }();
-  if (t.subtypeOf(TArr)) {
+  if (t.subtypeOf(BArr)) {
     if (f->retTypeConstraint.isVArray()) {
       assertx(!RuntimeOption::EvalHackArrDVArrs);
       t = TVArr;
diff --git a/hphp/hhbbc/type-ops.cpp b/hphp/hhbbc/type-ops.cpp
index 40232c4d53..4d9e8fb2a4 100644
--- a/hphp/hhbbc/type-ops.cpp
+++ b/hphp/hhbbc/type-ops.cpp
@@ -36,11 +36,11 @@ folly::Optional<Type> usual_arith_conversions(Type t1, Type t2) {
    * value here (rather than bundling everything into the
    * interpreter).
    */
-  if (t1.subtypeOf(TInt) && t2.subtypeOf(TInt)) return TInt;
-  if (t1.subtypeOf(TInt) && t2.subtypeOf(TDbl)) return TDbl;
-  if (t1.subtypeOf(TDbl) && t2.subtypeOf(TInt)) return TDbl;
-  if (t1.subtypeOf(TDbl) && t2.subtypeOf(TDbl)) return TDbl;
-  if (t1.subtypeOf(TNum) && t2.subtypeOf(TNum)) return TNum;
+  if (t1.subtypeOf(BInt) && t2.subtypeOf(BInt)) return TInt;
+  if (t1.subtypeOf(BInt) && t2.subtypeOf(BDbl)) return TDbl;
+  if (t1.subtypeOf(BDbl) && t2.subtypeOf(BInt)) return TDbl;
+  if (t1.subtypeOf(BDbl) && t2.subtypeOf(BDbl)) return TDbl;
+  if (t1.subtypeOf(BNum) && t2.subtypeOf(BNum)) return TNum;
   return folly::none;
 }
 
@@ -55,8 +55,8 @@ folly::Optional<Type> eval_const(Type t1, Type t2, Fun fun) {
 template<class Fun>
 Type bitwise_impl(Type t1, Type t2, Fun op) {
   if (auto t = eval_const(t1, t2, op))          return *t;
-  if (t1.subtypeOf(TStr) && t2.subtypeOf(TStr)) return TStr;
-  if (!t1.couldBe(TStr) || !t2.couldBe(TStr))   return TInt;
+  if (t1.subtypeOf(BStr) && t2.subtypeOf(BStr)) return TStr;
+  if (!t1.couldBe(BStr) || !t2.couldBe(BStr))   return TInt;
   return TInitCell;
 }
 
@@ -74,7 +74,7 @@ Type shift_impl(Type t1, Type t2, Fun op) {
 
 Type typeToInt(Type ty) {
   if (auto const v = tv(ty)) return ival(cellToInt(*v));
-  if (ty.subtypeOf(TNull))   return ival(0);
+  if (ty.subtypeOf(BNull))   return ival(0);
   return TInt;
 }
 
@@ -83,21 +83,21 @@ Type typeToInt(Type ty) {
 Type typeAdd(Type t1, Type t2) {
   if (auto t = eval_const(t1, t2, cellAdd))           return *t;
   if (auto t = usual_arith_conversions(t1, t2))       return *t;
-  if (t1.subtypeOf(TArr) && t2.subtypeOf(TArr))       return TArr;
-  if (t1.subtypeOf(TVec) && t2.subtypeOf(TVec))       return TVec;
-  if (t1.subtypeOf(TDict) && t2.subtypeOf(TDict))     return TDict;
-  if (t1.subtypeOf(TKeyset) && t2.subtypeOf(TKeyset)) return TKeyset;
+  if (t1.subtypeOf(BArr) && t2.subtypeOf(BArr))       return TArr;
+  if (t1.subtypeOf(BVec) && t2.subtypeOf(BVec))       return TVec;
+  if (t1.subtypeOf(BDict) && t2.subtypeOf(BDict))     return TDict;
+  if (t1.subtypeOf(BKeyset) && t2.subtypeOf(BKeyset)) return TKeyset;
   return TInitCell;
 }
 
 Type typeAddO(Type t1, Type t2) {
   if (auto t = eval_const(t1, t2, cellAddO))          return *t;
-  if (t1.subtypeOf(TInt) && t2.subtypeOf(TInt))       return TNum;
+  if (t1.subtypeOf(BInt) && t2.subtypeOf(BInt))       return TNum;
   if (auto t = usual_arith_conversions(t1, t2))       return *t;
-  if (t1.subtypeOf(TArr) && t2.subtypeOf(TArr))       return TArr;
-  if (t1.subtypeOf(TVec) && t2.subtypeOf(TVec))       return TVec;
-  if (t1.subtypeOf(TDict) && t2.subtypeOf(TDict))     return TDict;
-  if (t1.subtypeOf(TKeyset) && t2.subtypeOf(TKeyset)) return TKeyset;
+  if (t1.subtypeOf(BArr) && t2.subtypeOf(BArr))       return TArr;
+  if (t1.subtypeOf(BVec) && t2.subtypeOf(BVec))       return TVec;
+  if (t1.subtypeOf(BDict) && t2.subtypeOf(BDict))     return TDict;
+  if (t1.subtypeOf(BKeyset) && t2.subtypeOf(BKeyset)) return TKeyset;
   return TInitCell;
 }
 
@@ -111,7 +111,7 @@ Type typeSubMulImpl(Type t1, Type t2, CellOp op) {
 template <class CellOp>
 Type typeSubMulImplO(Type t1, Type t2, CellOp op) {
   if (auto t = eval_const(t1, t2, op))          return *t;
-  if (t1.subtypeOf(TInt) && t2.subtypeOf(TInt)) return TNum;
+  if (t1.subtypeOf(BInt) && t2.subtypeOf(BInt)) return TNum;
   if (auto t = usual_arith_conversions(t1, t2)) return *t;
   return TInitPrim;
 }
@@ -154,15 +154,15 @@ Type typeIncDec(IncDecOp op, Type t) {
 
   if (!val) {
     // Doubles always stay doubles
-    if (t.subtypeOf(TDbl)) return TDbl;
+    if (t.subtypeOf(BDbl)) return TDbl;
 
     // Ints stay ints unless they can overflow to doubles
-    if (t.subtypeOf(TInt)) {
+    if (t.subtypeOf(BInt)) {
       return overflowToDbl ? TNum : TInt;
     }
 
     // Null goes to 1 on ++, stays null on --. Uninit is folded to init.
-    if (t.subtypeOf(TNull)) {
+    if (t.subtypeOf(BNull)) {
       return isInc(op) ? ival(1) : TInitNull;
     }
 
@@ -231,9 +231,9 @@ Type typeSame(const Type& a, const Type& b) {
 
 Type typeNSame(const Type& a, const Type& b) {
   auto const ty = typeSame(a, b);
-  assert(ty.subtypeOf(TBool));
-  return ty.subtypeOf(TFalse) ? TTrue :
-         ty.subtypeOf(TTrue) ? TFalse :
+  assert(ty.subtypeOf(BBool));
+  return ty.subtypeOf(BFalse) ? TTrue :
+         ty.subtypeOf(BTrue) ? TFalse :
          TBool;
 }
 
diff --git a/hphp/hhbbc/type-system.cpp b/hphp/hhbbc/type-system.cpp
index 41db48eb75..6863b73edb 100644
--- a/hphp/hhbbc/type-system.cpp
+++ b/hphp/hhbbc/type-system.cpp
@@ -866,7 +866,7 @@ struct DualDispatchIntersectionImpl {
     for (auto it = map.begin(); it != map.end(); it++) {
       auto other = next();
       if (it->first.m_type == KindOfInt64 ?
-          !other.first.couldBe(TInt) : !other.first.couldBe(TStr)) {
+          !other.first.couldBe(BInt) : !other.first.couldBe(BStr)) {
         return TBottom;
       }
       auto val = intersection_of(it->second, other.second);
@@ -903,7 +903,7 @@ struct DualDispatchIntersectionImpl {
     return intersect_packed(a.elems, [&] { return b.type; });
   }
   Type operator()(const DArrLikePacked& a, const DArrLikeMapN& b) const {
-    if (b.key.couldBe(TInt)) {
+    if (b.key.couldBe(BInt)) {
       return intersect_packed(a.elems, [&] { return b.val; });
     }
     return TBottom;
@@ -919,7 +919,7 @@ struct DualDispatchIntersectionImpl {
     return packedn_impl(bits, isect);
   }
   Type operator()(const DArrLikePackedN& a, const DArrLikeMapN& b) const {
-    if (b.key.couldBe(TInt)) {
+    if (b.key.couldBe(BInt)) {
       auto val = intersection_of(b.val, a.type);
       if (val != TBottom) return packedn_impl(bits, std::move(val));
     }
@@ -1125,11 +1125,11 @@ struct DualDispatchSubtype {
   }
 
   bool operator()(const DArrLikePackedN& a, const DArrLikeMapN& b) const {
-    return b.key.couldBe(TInt) && a.type.subtypeOfImpl<contextSensitive>(b.val);
+    return b.key.couldBe(BInt) && a.type.subtypeOfImpl<contextSensitive>(b.val);
   }
 
   bool operator()(const DArrLikePacked& a, const DArrLikeMapN& b) const {
-    if (!b.key.couldBe(TInt)) return false;
+    if (!b.key.couldBe(BInt)) return false;
     for (auto const& v : a.elems) {
       if (!v.subtypeOfImpl<contextSensitive>(b.val)) return false;
     }
@@ -1899,7 +1899,7 @@ bool Type::checkInvariants() const {
   case DataTag::Dbl:    break;
   case DataTag::Int:    break;
   case DataTag::RefInner:
-    assert(!m_data.inner->couldBe(TRef));
+    assert(!m_data.inner->couldBe(BRef));
     break;
   case DataTag::Cls:    break;
   case DataTag::Obj:    break;
@@ -2129,13 +2129,13 @@ Type keyset_empty()         { return Type { BSKeysetE }; }
 Type some_keyset_empty()    { return Type { BKeysetE }; }
 
 Type keyset_n(Type kv) {
-  assert(kv.subtypeOf(TArrKey));
+  assert(kv.subtypeOf(BArrKey));
   auto v = kv;
   return mapn_impl(BKeysetN, std::move(kv), std::move(v));
 }
 
 Type skeyset_n(Type kv) {
-  assert(kv.subtypeOf(TUncArrKey));
+  assert(kv.subtypeOf(BUncArrKey));
   auto v = kv;
   return mapn_impl(BSKeysetN, std::move(kv), std::move(v));
 }
@@ -2174,7 +2174,7 @@ Type clsExact(res::Class val) {
 
 
 Type ref_to(Type t) {
-  assert(t.subtypeOf(TInitCell));
+  assert(t.subtypeOf(BInitCell));
   auto r = Type{BRef};
   construct_inner(r.m_data.inner, std::move(t));
   r.m_dataTag = DataTag::RefInner;
@@ -2206,19 +2206,19 @@ bool is_specialized_array_like(const Type& t) {
 }
 
 bool is_specialized_array(const Type& t) {
-  return t.subtypeOf(TOptArr) && is_specialized_array_like(t);
+  return t.subtypeOrNull(BArr) && is_specialized_array_like(t);
 }
 
 bool is_specialized_vec(const Type& t) {
-  return t.subtypeOf(TOptVec) && is_specialized_array_like(t);
+  return t.subtypeOrNull(BVec) && is_specialized_array_like(t);
 }
 
 bool is_specialized_dict(const Type& t) {
-  return t.subtypeOf(TOptDict) && is_specialized_array_like(t);
+  return t.subtypeOrNull(BDict) && is_specialized_array_like(t);
 }
 
 bool is_specialized_keyset(const Type& t) {
-  return t.subtypeOf(TOptKeyset) && is_specialized_array_like(t);
+  return t.subtypeOrNull(BKeyset) && is_specialized_array_like(t);
 }
 
 Type set_trep(Type& a, trep bits) {
@@ -2227,9 +2227,9 @@ Type set_trep(Type& a, trep bits) {
   // Packed or Map type. We cannot have a ArrLikeVal if the type isn't
   // specifically a subtype of TOptParr, TOptVArr, or TOptDArr.
   if (a.m_dataTag == DataTag::ArrLikeVal &&
-      ((a.subtypeOf(TOptPArr) && ((bits & BOptPArr) != bits)) ||
-       (a.subtypeOf(TOptVArr) && ((bits & BOptVArr) != bits)) ||
-       (a.subtypeOf(TOptDArr) && ((bits & BOptDArr) != bits)))) {
+      ((a.subtypeOrNull(BPArr) && ((bits & BOptPArr) != bits)) ||
+       (a.subtypeOrNull(BVArr) && ((bits & BOptVArr) != bits)) ||
+       (a.subtypeOrNull(BDArr) && ((bits & BOptDArr) != bits)))) {
     if (auto p = toDArrLikePacked(a.m_data.aval)) {
       return packed_impl(bits, std::move(p->elems));
     }
@@ -2330,7 +2330,7 @@ Type sarr_map(MapElems m) {
 }
 
 Type mapn_impl(trep bits, Type k, Type v) {
-  assert(k.subtypeOf(TArrKey));
+  assert(k.subtypeOf(BArrKey));
 
   // A MapN cannot have a constant key (because that can actually make it be a
   // subtype of Map sometimes), so if it does, make it a Map instead.
@@ -2374,13 +2374,13 @@ Type unopt(Type t) {
 
 bool is_opt(const Type& t) {
   if (t.m_bits == BInitNull) return false;
-  if (!t.couldBe(TInitNull)) return false;
+  if (!t.couldBe(BInitNull)) return false;
   auto const nonNullBits = t.m_bits & ~BInitNull;
   return isPredefined(nonNullBits) && canBeOptional(nonNullBits);
 }
 
 Type return_with_context(Type t, Type context) {
-  assertx(t.subtypeOf(TGen));
+  assertx(t.subtypeOf(BGen));
   // We don't assert the context is a TCls of TObj because sometimes we set it
   // to TTop when handling dynamic calls.
   if (((is_specialized_obj(t) && t.m_data.dobj.isCtx) ||
@@ -2428,11 +2428,11 @@ bool is_specialized_cls(const Type& t) {
 }
 
 Type toobj(const Type& t) {
-  if (t.subtypeOf(TCls) && is_specialized_cls(t)) {
+  if (t.subtypeOf(BCls) && is_specialized_cls(t)) {
     auto const d = dcls_of(t);
     return setctx(d.type == DCls::Exact ? objExact(d.cls) : subObj(d.cls),
                   d.isCtx);
-  } else if (t.subtypeOf(TObj)) {
+  } else if (t.subtypeOf(BObj)) {
     return t;
   }
   always_assert(t == TCls);
@@ -2440,7 +2440,7 @@ Type toobj(const Type& t) {
 }
 
 Type objcls(const Type& t) {
-  if (t.subtypeOf(TObj)) {
+  if (t.subtypeOf(BObj)) {
     if (is_specialized_obj(t)) {
       auto const d = dobj_of(t);
       return setctx(d.type == DObj::Exact ? clsExact(d.cls) : subCls(d.cls),
@@ -2801,22 +2801,22 @@ Type type_of_istype(IsTypeOp op) {
 }
 
 folly::Optional<IsTypeOp> type_to_istypeop(const Type& t) {
-  if (t.subtypeOf(TNull))   return IsTypeOp::Null;
-  if (t.subtypeOf(TBool))   return IsTypeOp::Bool;
-  if (t.subtypeOf(TInt))    return IsTypeOp::Int;
-  if (t.subtypeOf(TDbl))    return IsTypeOp::Dbl;
-  if (t.subtypeOf(TStr))    return IsTypeOp::Str;
-  if (t.subtypeOf(TArr))    return IsTypeOp::Arr;
-  if (t.subtypeOf(TVec))    return IsTypeOp::Vec;
-  if (t.subtypeOf(TDict))   return IsTypeOp::Dict;
-  if (t.subtypeOf(TRes))    return IsTypeOp::Res;
-  if (t.subtypeOf(TKeyset)) return IsTypeOp::Keyset;
-  if (t.subtypeOf(TObj))    return IsTypeOp::Obj;
-  if (t.subtypeOf(TVArr)) {
+  if (t.subtypeOf(BNull))   return IsTypeOp::Null;
+  if (t.subtypeOf(BBool))   return IsTypeOp::Bool;
+  if (t.subtypeOf(BInt))    return IsTypeOp::Int;
+  if (t.subtypeOf(BDbl))    return IsTypeOp::Dbl;
+  if (t.subtypeOf(BStr))    return IsTypeOp::Str;
+  if (t.subtypeOf(BArr))    return IsTypeOp::Arr;
+  if (t.subtypeOf(BVec))    return IsTypeOp::Vec;
+  if (t.subtypeOf(BDict))   return IsTypeOp::Dict;
+  if (t.subtypeOf(BRes))    return IsTypeOp::Res;
+  if (t.subtypeOf(BKeyset)) return IsTypeOp::Keyset;
+  if (t.subtypeOf(BObj))    return IsTypeOp::Obj;
+  if (t.subtypeOf(BVArr)) {
     assertx(!RuntimeOption::EvalHackArrDVArrs);
     return IsTypeOp::VArray;
   }
-  if (t.subtypeOf(TDArr)) {
+  if (t.subtypeOf(BDArr)) {
     assertx(!RuntimeOption::EvalHackArrDVArrs);
     return IsTypeOp::DArray;
   }
@@ -3396,7 +3396,7 @@ Type promote_emptyish(Type a, Type b) {
 }
 
 bool could_have_magic_bool_conversion(const Type& t) {
-  if (!t.couldBe(TObj)) return false;
+  if (!t.couldBe(BObj)) return false;
 
   if (t.strictSubtypeOf(TObj) ||
       (is_opt(t) && unopt(t).strictSubtypeOf(TObj))) {
@@ -3501,10 +3501,10 @@ Type widening_union(const Type& a, const Type& b) {
 }
 
 Type stack_flav(Type a) {
-  if (a.subtypeOf(TUninit))   return TUninit;
-  if (a.subtypeOf(TInitCell)) return TInitCell;
-  if (a.subtypeOf(TRef))      return TRef;
-  if (a.subtypeOf(TGen))      return TGen;
+  if (a.subtypeOf(BUninit))   return TUninit;
+  if (a.subtypeOf(BInitCell)) return TInitCell;
+  if (a.subtypeOf(BRef))      return TRef;
+  if (a.subtypeOf(BGen))      return TGen;
   always_assert(0 && "stack_flav passed invalid type");
 }
 
@@ -3514,7 +3514,7 @@ Type loosen_staticness(Type t) {
   };
   // Need to remove any constant value from a string because a TStr cannot have
   // one.
-  if (t.couldBe(TStr)) t |= TStr;
+  if (t.couldBe(BStr)) t |= TStr;
   check(BPArrE);
   check(BPArrN);
   check(BVArrE);
@@ -3534,7 +3534,7 @@ Type loosen_dvarrayness(Type t) {
   auto const check = [&] (trep a) {
     if (t.m_bits & a) t.m_bits |= a;
   };
-  if (t.couldBe(TArr) && t.m_dataTag == DataTag::ArrLikeVal) {
+  if (t.couldBe(BArr) && t.m_dataTag == DataTag::ArrLikeVal) {
     // We need to drop any static array from the type because TArr unions cannot
     // have one. Turn it into the equivalent Packed or Map data.
     if (auto p = toDArrLikePacked(t.m_data.aval)) {
@@ -3552,10 +3552,10 @@ Type loosen_dvarrayness(Type t) {
 }
 
 Type loosen_arrays(Type a) {
-  if (a.couldBe(TArr))    a |= TArr;
-  if (a.couldBe(TVec))    a |= TVec;
-  if (a.couldBe(TDict))   a |= TDict;
-  if (a.couldBe(TKeyset)) a |= TKeyset;
+  if (a.couldBe(BArr))    a |= TArr;
+  if (a.couldBe(BVec))    a |= TVec;
+  if (a.couldBe(BDict))   a |= TDict;
+  if (a.couldBe(BKeyset)) a |= TKeyset;
   return a;
 }
 
@@ -3579,7 +3579,7 @@ Type loosen_values(Type a) {
     }
     not_reached();
   }();
-  if (t.couldBe(TFalse) || t.couldBe(TTrue)) t |= TBool;
+  if (t.couldBe(BFalse) || t.couldBe(BTrue)) t |= TBool;
   return t;
 }
 
@@ -3632,12 +3632,12 @@ Type add_nonemptiness(Type t) {
 }
 
 Type remove_uninit(Type t) {
-  assert(t.subtypeOf(TCell));
-  if (!t.couldBe(TUninit))  return t;
-  if (t.subtypeOf(TUninit)) return TBottom;
-  if (t.subtypeOf(TNull))   return TInitNull;
-  if (t.subtypeOf(TPrim))   return TInitPrim;
-  if (t.subtypeOf(TUnc))    return TInitUnc;
+  assert(t.subtypeOf(BCell));
+  if (!t.couldBe(BUninit))  return t;
+  if (t.subtypeOf(BUninit)) return TBottom;
+  if (t.subtypeOf(BNull))   return TInitNull;
+  if (t.subtypeOf(BPrim))   return TInitPrim;
+  if (t.subtypeOf(BUnc))    return TInitUnc;
   return TInitCell;
 }
 
@@ -3645,7 +3645,7 @@ Type assert_emptiness(Type t) {
   if (t.subtypeOfAny(TTrue, TArrN, TVecN, TDictN, TKeysetN)) {
     return TBottom;
   }
-  if (!could_have_magic_bool_conversion(t) && t.subtypeOf(TOptObj)) {
+  if (!could_have_magic_bool_conversion(t) && t.subtypeOrNull(BObj)) {
     return TInitNull;
   }
 
@@ -3667,15 +3667,15 @@ Type assert_emptiness(Type t) {
     return t;
   }
 
-  if (t.subtypeOf(TInt))     return ival(0);
-  if (t.subtypeOf(TBool))    return TFalse;
-  if (t.subtypeOf(TDbl))     return dval(0);
-  if (t.subtypeOf(TSStr))    return sempty();
+  if (t.subtypeOf(BInt))     return ival(0);
+  if (t.subtypeOf(BBool))    return TFalse;
+  if (t.subtypeOf(BDbl))     return dval(0);
+  if (t.subtypeOf(BSStr))    return sempty();
 
-  if (t.subtypeOf(TOptInt))  return opt(ival(0));
-  if (t.subtypeOf(TOptBool)) return opt(TFalse);
-  if (t.subtypeOf(TOptDbl))  return opt(dval(0));
-  if (t.subtypeOf(TOptSStr)) return opt(sempty());
+  if (t.subtypeOrNull(BInt))  return opt(ival(0));
+  if (t.subtypeOrNull(BBool)) return opt(TFalse);
+  if (t.subtypeOrNull(BDbl))  return opt(dval(0));
+  if (t.subtypeOrNull(BSStr)) return opt(sempty());
 
   return t;
 }
@@ -3685,7 +3685,7 @@ Type assert_nonemptiness(Type t) {
   if (t.subtypeOfAny(TNull, TFalse, TArrE, TVecE, TDictE, TKeysetE)) {
     return TBottom;
   }
-  if (t.subtypeOf(TBool)) return TTrue;
+  if (t.subtypeOf(BBool)) return TTrue;
 
   auto remove = [&] (trep m, trep e) {
     if ((t.m_bits & m) == t.m_bits) {
@@ -3725,8 +3725,8 @@ Type assert_nonemptiness(Type t) {
 ArrKey disect_array_key(const Type& keyTy) {
   auto ret = ArrKey{};
 
-  if (keyTy.subtypeOf(TOptInt)) {
-    if (keyTy.subtypeOf(TInt)) {
+  if (keyTy.subtypeOf(BOptInt)) {
+    if (keyTy.subtypeOf(BInt)) {
       if (keyTy.strictSubtypeOf(TInt)) {
         ret.i = keyTy.m_data.ival;
         ret.type = ival(*ret.i);
@@ -3742,8 +3742,8 @@ ArrKey disect_array_key(const Type& keyTy) {
     return ret;
   }
 
-  if (keyTy.subtypeOf(TOptStr)) {
-    if (keyTy.subtypeOf(TStr)) {
+  if (keyTy.subtypeOf(BOptStr)) {
+    if (keyTy.subtypeOf(BStr)) {
       if (keyTy.strictSubtypeOf(TStr) && keyTy.m_dataTag == DataTag::Str) {
         int64_t i;
         if (keyTy.m_data.sval->isStrictlyInteger(i)) {
@@ -3758,7 +3758,7 @@ ArrKey disect_array_key(const Type& keyTy) {
       }
       // Might stay a string or become an integer. The effective type is
       // uncounted if the string is static.
-      ret.type = keyTy.subtypeOf(TSStr) ? TUncArrKey : TArrKey;
+      ret.type = keyTy.subtypeOf(BSStr) ? TUncArrKey : TArrKey;
       ret.mayThrow = RuntimeOption::EvalHackArrCompatNotices;
       return ret;
     }
@@ -3779,12 +3779,12 @@ ArrKey disect_array_key(const Type& keyTy) {
     // An optional string is fine because a null will just become the empty
     // string. So, if the string is static, the effective type is uncounted
     // still. The effective type is ArrKey because it might become an integer.
-    ret.type = keyTy.subtypeOf(TOptSStr) ? TUncArrKey : TArrKey;
+    ret.type = keyTy.subtypeOf(BOptSStr) ? TUncArrKey : TArrKey;
     ret.mayThrow = RuntimeOption::EvalHackArrCompatNotices;
     return ret;
   }
 
-  if (keyTy.subtypeOf(TOptArrKey)) {
+  if (keyTy.subtypeOf(BOptArrKey)) {
     // The key is an integer, string, or null. The effective type is int or
     // string because null will become the empty string.
     ret.type = is_opt(keyTy) ? unopt(keyTy) : keyTy;
@@ -3797,40 +3797,40 @@ ArrKey disect_array_key(const Type& keyTy) {
     ret.mayThrow = RuntimeOption::EvalHackArrCompatNotices;
     return ret;
   }
-  if (keyTy.subtypeOf(TNum)) {
+  if (keyTy.subtypeOf(BNum)) {
     ret.type = TInt;
     ret.mayThrow = RuntimeOption::EvalHackArrCompatNotices;
     return ret;
   }
-  if (keyTy.subtypeOf(TNull)) {
+  if (keyTy.subtypeOf(BNull)) {
     ret.s = s_empty.get();
     ret.type = sempty();
     ret.mayThrow = RuntimeOption::EvalHackArrCompatNotices;
     return ret;
   }
-  if (keyTy.subtypeOf(TRes)) {
+  if (keyTy.subtypeOf(BRes)) {
     ret.type = TInt;
     ret.mayThrow = RuntimeOption::EvalHackArrCompatNotices;
     return ret;
   }
-  if (keyTy.subtypeOf(TTrue)) {
+  if (keyTy.subtypeOf(BTrue)) {
     ret.i = 1;
     ret.type = ival(1);
     ret.mayThrow = RuntimeOption::EvalHackArrCompatNotices;
     return ret;
   }
-  if (keyTy.subtypeOf(TFalse)) {
+  if (keyTy.subtypeOf(BFalse)) {
     ret.i = 0;
     ret.type = ival(0);
     ret.mayThrow = RuntimeOption::EvalHackArrCompatNotices;
     return ret;
   }
-  if (keyTy.subtypeOf(TBool)) {
+  if (keyTy.subtypeOf(BBool)) {
     ret.type = TInt;
     ret.mayThrow = RuntimeOption::EvalHackArrCompatNotices;
     return ret;
   }
-  if (keyTy.subtypeOf(TPrim)) {
+  if (keyTy.subtypeOf(BPrim)) {
     ret.type = TUncArrKey;
     ret.mayThrow = RuntimeOption::EvalHackArrCompatNotices;
     return ret;
@@ -3840,7 +3840,7 @@ ArrKey disect_array_key(const Type& keyTy) {
   // raise warnings, so always assume it may throw. Keep the type as-is so that
   // we can detect this case at the point of the set.
 
-  if (!keyTy.subtypeOf(TInitCell)) {
+  if (!keyTy.subtypeOf(BInitCell)) {
     ret.type = TInitCell;
     ret.mayThrow = true;
     return ret;
@@ -3860,7 +3860,7 @@ ArrKey disect_array_key(const Type& keyTy) {
 std::pair<Type,bool> arr_val_elem(const Type& aval, const ArrKey& key) {
   assert(aval.m_dataTag == DataTag::ArrLikeVal);
   auto ad = aval.m_data.aval;
-  auto const isPhpArray = aval.subtypeOf(TOptArr);
+  auto const isPhpArray = aval.subtypeOrNull(BArr);
   if (key.i) {
     if (auto const r = ad->rval(*key.i)) {
       return { from_cell(r.tv()), true };
@@ -3873,8 +3873,8 @@ std::pair<Type,bool> arr_val_elem(const Type& aval, const ArrKey& key) {
     return { isPhpArray ? TInitNull : TBottom, false };
   }
 
-  auto const couldBeInt = key.type.couldBe(TInt);
-  auto const couldBeStr = key.type.couldBe(TStr);
+  auto const couldBeInt = key.type.couldBe(BInt);
+  auto const couldBeStr = key.type.couldBe(BStr);
   auto ty = isPhpArray ? TInitNull : TBottom;
   IterateKV(ad, [&] (Cell k, TypedValue v) {
       if (isStringType(k.m_type) ? couldBeStr : couldBeInt) {
@@ -3894,14 +3894,14 @@ std::pair<Type,bool> arr_val_elem(const Type& aval, const ArrKey& key) {
  */
 std::pair<Type,bool> arr_map_elem(const Type& map, const ArrKey& key) {
   assert(map.m_dataTag == DataTag::ArrLikeMap);
-  auto const isPhpArray = map.subtypeOf(TOptArr);
+  auto const isPhpArray = map.subtypeOrNull(BArr);
   if (auto const k = key.tv()) {
     auto r = map.m_data.map->map.find(*k);
     if (r != map.m_data.map->map.end()) return { r->second, true };
     return { isPhpArray ? TInitNull : TBottom, false };
   }
-  auto couldBeInt = key.type.couldBe(TInt);
-  auto couldBeStr = key.type.couldBe(TStr);
+  auto couldBeInt = key.type.couldBe(BInt);
+  auto couldBeStr = key.type.couldBe(BStr);
   auto ty = isPhpArray ? TInitNull : TBottom;
   for (auto const& kv : map.m_data.map->map) {
     if (isStringType(kv.first.m_type) ? couldBeStr : couldBeInt) {
@@ -3921,13 +3921,13 @@ std::pair<Type,bool> arr_map_elem(const Type& map, const ArrKey& key) {
  */
 std::pair<Type,bool> arr_packed_elem(const Type& pack, const ArrKey& key) {
   assert(pack.m_dataTag == DataTag::ArrLikePacked);
-  auto const isPhpArray = pack.subtypeOf(TOptArr);
+  auto const isPhpArray = pack.subtypeOrNull(BArr);
   if (key.i) {
     if (*key.i >= 0 && *key.i < pack.m_data.packed->elems.size()) {
       return { pack.m_data.packed->elems[*key.i], true };
     }
     return { isPhpArray ? TInitNull : TBottom, false };
-  } else if (!key.type.couldBe(TInt)) {
+  } else if (!key.type.couldBe(BInt)) {
     return { isPhpArray ? TInitNull : TBottom, false };
   }
   auto ret = packed_values(*pack.m_data.packed);
@@ -3943,7 +3943,7 @@ std::pair<Type,bool> arr_packed_elem(const Type& pack, const ArrKey& key) {
 std::pair<Type,bool> arr_packedn_elem(const Type& pack, const ArrKey& key) {
   assert(pack.m_dataTag == DataTag::ArrLikePackedN);
   auto const isPhpArray = (pack.m_bits & BOptArr) == pack.m_bits;
-  if (key.s || !key.type.couldBe(TInt) || (key.i && *key.i < 0)) {
+  if (key.s || !key.type.couldBe(BInt) || (key.i && *key.i < 0)) {
     return {isPhpArray ? TInitNull : TBottom, false};
   }
 
@@ -3965,7 +3965,7 @@ bool arr_packedn_set(Type& pack,
                      const Type& val,
                      bool maybeEmpty) {
   assert(pack.m_dataTag == DataTag::ArrLikePackedN);
-  assert(key.type.subtypeOf(TArrKey));
+  assert(key.type.subtypeOf(BArrKey));
 
   auto const isPhpArray = (pack.m_bits & BOptArr) == pack.m_bits;
   auto const isVecArray = (pack.m_bits & BOptVec) == pack.m_bits;
@@ -3984,7 +3984,7 @@ bool arr_packedn_set(Type& pack,
       ? promote_varray(pack.m_bits)
       : maybe_promote_varray(pack.m_bits);
   } else {
-    pack.m_bits = key.type.subtypeOf(TStr)
+    pack.m_bits = key.type.subtypeOf(BStr)
       ? promote_varray(pack.m_bits)
       : maybe_promote_varray(pack.m_bits);
   }
@@ -4006,14 +4006,14 @@ bool arr_map_set(Type& map,
                  const ArrKey& key,
                  const Type& val) {
   assert(map.m_dataTag == DataTag::ArrLikeMap);
-  assert(key.type.subtypeOf(TArrKey));
-  assert(!map.subtypeOf(TVArr));
+  assert(key.type.subtypeOf(BArrKey));
+  assert(!map.subtypeOf(BVArr));
 
   if (auto const k = key.tv()) {
     auto r = map.m_data.map.mutate()->map.emplace_back(*k, val);
     // if the element existed, and was a ref, its still a ref after
     // assigning to it
-    if (!r.second && r.first->second.subtypeOf(TInitCell)) {
+    if (!r.second && r.first->second.subtypeOf(BInitCell)) {
       map.m_data.map.mutate()->map.update(r.first, val);
     }
     return true;
@@ -4035,15 +4035,15 @@ bool arr_packed_set(Type& pack,
                     const ArrKey& key,
                     const Type& val) {
   assert(pack.m_dataTag == DataTag::ArrLikePacked);
-  assert(key.type.subtypeOf(TArrKey));
+  assert(key.type.subtypeOf(BArrKey));
 
-  auto const isVecArray = pack.subtypeOf(TOptVec);
+  auto const isVecArray = pack.subtypeOrNull(BVec);
   if (key.i) {
     if (*key.i >= 0) {
       if (*key.i < pack.m_data.packed->elems.size()) {
         auto& current = pack.m_data.packed.mutate()->elems[*key.i];
         // if the element was a ref, its still a ref after assigning to it
-        if (current.subtypeOf(TInitCell)) {
+        if (current.subtypeOf(BInitCell)) {
           current = val;
         }
         return true;
@@ -4059,7 +4059,7 @@ bool arr_packed_set(Type& pack,
     }
     pack.m_bits = promote_varray(pack.m_bits);
   } else {
-    pack.m_bits = key.type.subtypeOf(TStr)
+    pack.m_bits = key.type.subtypeOf(BStr)
       ? promote_varray(pack.m_bits)
       : maybe_promote_varray(pack.m_bits);
   }
@@ -4091,8 +4091,8 @@ bool arr_mapn_set(Type& map,
                   const ArrKey& key,
                   const Type& val) {
   assert(map.m_dataTag == DataTag::ArrLikeMapN);
-  assert(key.type.subtypeOf(TArrKey));
-  assert(!map.subtypeOf(TVArr));
+  assert(key.type.subtypeOf(BArrKey));
+  assert(!map.subtypeOf(BVArr));
   auto& mapn = *map.m_data.mapn.mutate();
   mapn.val |= val;
   mapn.key |= key.type;
@@ -4122,7 +4122,7 @@ std::pair<Type, ThrowMode> array_like_elem(const Type& arr, const ArrKey& key) {
   const bool maybeEmpty = arr.m_bits & BArrLikeE;
   const bool mustBeStatic = (arr.m_bits & BSArrLike) == arr.m_bits;
 
-  auto const isPhpArray = arr.subtypeOf(TOptArr);
+  auto const isPhpArray = arr.subtypeOrNull(BArr);
   if (!(arr.m_bits & BArrLikeN)) {
     assert(maybeEmpty);
     return { isPhpArray ? TInitNull : TBottom, ThrowMode::MissingElement };
@@ -4168,7 +4168,7 @@ std::pair<Type, ThrowMode> array_like_elem(const Type& arr, const ArrKey& key) {
     pair.second ? ThrowMode::None : ThrowMode::MaybeMissingElement
   };
 
-  if (!ret.first.subtypeOf(TInitCell)) {
+  if (!ret.first.subtypeOf(BInitCell)) {
     ret.first = TInitCell;
   }
 
@@ -4184,7 +4184,7 @@ std::pair<Type, ThrowMode> array_like_elem(const Type& arr, const ArrKey& key) {
 
 std::pair<Type,ThrowMode>
 array_elem(const Type& arr, const Type& undisectedKey) {
-  assert(arr.subtypeOf(TArr));
+  assert(arr.subtypeOf(BArr));
   auto const key = disect_array_key(undisectedKey);
   return array_like_elem(arr, key);
 }
@@ -4216,7 +4216,7 @@ std::pair<Type,ThrowMode> array_like_set(Type arr,
   trep bits = combine_dv_arr_like_bits(arr.m_bits, BArrLikeN);
   if (validKey) bits &= ~BArrLikeE;
 
-  auto const fixRef  = !isPhpArray && valIn.couldBe(TRef);
+  auto const fixRef  = !isPhpArray && valIn.couldBe(BRef);
   auto const throwMode = !fixRef && validKey && !key.mayThrow ?
     ThrowMode::None : ThrowMode::BadOperation;
   auto const& val    = fixRef ? TInitCell : valIn;
@@ -4237,7 +4237,7 @@ std::pair<Type,ThrowMode> array_like_set(Type arr,
       }
       bits = promote_varray(bits);
     } else {
-      bits = fixedKey.type.subtypeOf(TStr)
+      bits = fixedKey.type.subtypeOf(BStr)
         ? promote_varray(bits)
         : maybe_promote_varray(bits);
     }
@@ -4251,7 +4251,7 @@ std::pair<Type,ThrowMode> array_like_set(Type arr,
 
   auto emptyHelper = [&] (const Type& inKey,
                           const Type& inVal) -> std::pair<Type,ThrowMode> {
-    bits = fixedKey.type.subtypeOf(TStr)
+    bits = fixedKey.type.subtypeOf(BStr)
       ? promote_varray(bits)
       : maybe_promote_varray(bits);
     return { mapn_impl(bits,
@@ -4271,7 +4271,7 @@ std::pair<Type,ThrowMode> array_like_set(Type arr,
     not_reached();
 
   case DataTag::None:
-    arr.m_bits = fixedKey.type.subtypeOf(TStr)
+    arr.m_bits = fixedKey.type.subtypeOf(BStr)
       ? promote_varray(arr.m_bits)
       : maybe_promote_varray(arr.m_bits);
     return { std::move(arr), ThrowMode::BadOperation };
@@ -4342,12 +4342,12 @@ std::pair<Type,ThrowMode> array_like_set(Type arr,
 std::pair<Type, ThrowMode> array_set(Type arr,
                                      const Type& undisectedKey,
                                      const Type& val) {
-  assert(arr.subtypeOf(TArr));
+  assert(arr.subtypeOf(BArr));
 
   // Unless you know an array can't cow, you don't know if the TRef
   // will stay a TRef or turn back into a TInitCell.  Generally you
   // want a TInitGen.
-  always_assert((val == TBottom || !val.subtypeOf(TRef)) &&
+  always_assert((val == TBottom || !val.subtypeOf(BRef)) &&
                 "You probably don't want to put Ref types into arrays ...");
 
   auto const key = disect_array_key(undisectedKey);
@@ -4378,7 +4378,7 @@ std::pair<Type,Type> array_like_newelem(Type arr, const Type& val) {
   auto emptyHelper = [&] (const Type& inKey,
                           const Type& inVal) -> std::pair<Type,Type> {
     if (isVector || isVArray) {
-      assert(inKey.subtypeOf(TInt));
+      assert(inKey.subtypeOf(BInt));
       return { packedn_impl(bits, union_of(inVal, val)), TInt };
     }
 
@@ -4463,12 +4463,12 @@ std::pair<Type,Type> array_like_newelem(Type arr, const Type& val) {
 }
 
 std::pair<Type,Type> array_newelem(Type arr, const Type& val) {
-  assert(arr.subtypeOf(TArr));
+  assert(arr.subtypeOf(BArr));
 
   // Unless you know an array can't cow, you don't know if the TRef
   // will stay a TRef or turn back into a TInitCell.  Generally you
   // want a TInitGen.
-  always_assert((val == TBottom || !val.subtypeOf(TRef)) &&
+  always_assert((val == TBottom || !val.subtypeOf(BRef)) &&
          "You probably don't want to put Ref types into arrays ...");
 
   return array_like_newelem(std::move(arr), val);
@@ -4489,7 +4489,7 @@ IterTypes iter_types(const Type& iterable) {
       TInitCell,
       IterTypes::Count::Any,
       true,
-      iterable.couldBe(TObj)
+      iterable.couldBe(BObj)
     };
   }
 
@@ -4519,17 +4519,17 @@ IterTypes iter_types(const Type& iterable) {
 
   if (!is_specialized_array_like(iterable)) {
     auto kv = [&]() -> std::pair<Type, Type> {
-      if (iterable.subtypeOf(TOptSVec))    return { TInt, TInitUnc };
-      if (iterable.subtypeOf(TOptSDict))   return { TUncArrKey, TInitUnc };
-      if (iterable.subtypeOf(TOptSKeyset)) return { TUncArrKey, TUncArrKey };
-      if (iterable.subtypeOf(TOptSVArr))   return { TInt, TInitUnc };
-      if (iterable.subtypeOf(TOptSArr))    return { TUncArrKey, TInitUnc };
-
-      if (iterable.subtypeOf(TOptVec))     return { TInt, TInitCell };
-      if (iterable.subtypeOf(TOptDict))    return { TArrKey, TInitCell };
-      if (iterable.subtypeOf(TOptKeyset))  return { TArrKey, TArrKey };
-      if (iterable.subtypeOf(TOptVArr))    return { TInt, TInitCell };
-      if (iterable.subtypeOf(TOptArr))     return { TArrKey, TInitCell };
+      if (iterable.subtypeOrNull(BSVec))    return { TInt, TInitUnc };
+      if (iterable.subtypeOrNull(BSDict))   return { TUncArrKey, TInitUnc };
+      if (iterable.subtypeOrNull(BSKeyset)) return { TUncArrKey, TUncArrKey };
+      if (iterable.subtypeOrNull(BSVArr))   return { TInt, TInitUnc };
+      if (iterable.subtypeOrNull(BSArr))    return { TUncArrKey, TInitUnc };
+
+      if (iterable.subtypeOrNull(BVec))     return { TInt, TInitCell };
+      if (iterable.subtypeOrNull(BDict))    return { TArrKey, TInitCell };
+      if (iterable.subtypeOrNull(BKeyset))  return { TArrKey, TArrKey };
+      if (iterable.subtypeOrNull(BVArr))    return { TInt, TInitCell };
+      if (iterable.subtypeOrNull(BArr))     return { TArrKey, TInitCell };
 
       always_assert(false);
     }();
@@ -4602,12 +4602,12 @@ IterTypes iter_types(const Type& iterable) {
 }
 
 bool could_contain_objects(const Type& t) {
-  if (t.couldBe(TObj)) return true;
+  if (t.couldBe(BObj)) return true;
 
   auto const couldBeArrWithDestructors =
     t.m_bits & (BCArrN | BCVecN | BCDictN);
 
-  if (t.couldBe(TRef)) {
+  if (t.couldBe(BRef)) {
     if (!couldBeArrWithDestructors && is_ref_with_inner(t)) {
       return could_contain_objects(*t.m_data.inner);
     }
@@ -4657,13 +4657,12 @@ bool could_copy_on_write(const Type& t) {
 bool is_type_might_raise(const Type& testTy, const Type& valTy) {
   if (!RuntimeOption::EvalHackArrCompatIsArrayNotices) return false;
   if (is_opt(testTy)) return is_type_might_raise(unopt(testTy), valTy);
-  if (testTy.subtypeOf(TVArr)) return valTy.couldBe(TVec);
-  if (testTy.subtypeOf(TDArr)) return valTy.couldBe(TDict);
-  if (testTy.subtypeOf(TArr))  return valTy.couldBeAny(TVArr, TDArr,
-                                                       TVec, TDict,
-                                                       TKeyset);
-  if (testTy.subtypeOf(TVec))  return valTy.couldBe(TVArr);
-  if (testTy.subtypeOf(TDict)) return valTy.couldBe(TDArr);
+  if (testTy.subtypeOf(BVArr)) return valTy.couldBe(BVec);
+  if (testTy.subtypeOf(BDArr)) return valTy.couldBe(BDict);
+  if (testTy.subtypeOf(BArr))  return valTy.couldBe(BVArr | BDArr | BVec |
+                                                    BDict | BKeyset);
+  if (testTy.subtypeOf(BVec))  return valTy.couldBe(BVArr);
+  if (testTy.subtypeOf(BDict)) return valTy.couldBe(BDArr);
   return false;
 }
 
@@ -4672,7 +4671,7 @@ bool is_type_might_raise(const Type& testTy, const Type& valTy) {
 ArrKey disect_vec_key(const Type& keyTy) {
   auto ret = ArrKey{};
 
-  if (!keyTy.couldBe(TInt)) {
+  if (!keyTy.couldBe(BInt)) {
     ret.type = TBottom;
     ret.mayThrow = true;
     return ret;
@@ -4682,14 +4681,14 @@ ArrKey disect_vec_key(const Type& keyTy) {
   // type (and mark it as potentially throwing). We check for this explicitly
   // here rather than falling through so we can take advantage of something like
   // ?Int=123.
-  if (keyTy.subtypeOf(TOptInt)) {
+  if (keyTy.subtypeOf(BOptInt)) {
     if (keyTy.m_dataTag == DataTag::Int) {
       ret.i = keyTy.m_data.ival;
       ret.type = ival(*ret.i);
     } else {
       ret.type = TInt;
     }
-    ret.mayThrow = !keyTy.subtypeOf(TInt);
+    ret.mayThrow = !keyTy.subtypeOf(BInt);
     return ret;
   }
 
@@ -4709,7 +4708,7 @@ vec_elem(const Type& vec, const Type& undisectedKey) {
 
 std::pair<Type, ThrowMode>
 vec_set(Type vec, const Type& undisectedKey, const Type& val) {
-  if (!val.couldBe(TInitCell)) return {TBottom, ThrowMode::BadOperation};
+  if (!val.couldBe(BInitCell)) return {TBottom, ThrowMode::BadOperation};
 
   auto const key = disect_vec_key(undisectedKey);
   if (key.type == TBottom) return {TBottom, ThrowMode::BadOperation};
@@ -4719,7 +4718,7 @@ vec_set(Type vec, const Type& undisectedKey, const Type& val) {
 
 std::pair<Type,Type> vec_newelem(Type vec, const Type& val) {
   return array_like_newelem(std::move(vec),
-                            val.subtypeOf(TInitCell) ? val : TInitCell);
+                            val.subtypeOf(BInitCell) ? val : TInitCell);
 }
 
 //////////////////////////////////////////////////////////////////////
@@ -4727,7 +4726,7 @@ std::pair<Type,Type> vec_newelem(Type vec, const Type& val) {
 ArrKey disect_strict_key(const Type& keyTy) {
   auto ret = ArrKey{};
 
-  if (!keyTy.couldBe(TArrKey)) {
+  if (!keyTy.couldBe(BArrKey)) {
     ret.type = TBottom;
     ret.mayThrow = true;
     return ret;
@@ -4735,14 +4734,14 @@ ArrKey disect_strict_key(const Type& keyTy) {
 
   // If the key is null, we'll throw, so we can assume its not for the effective
   // type (but mark it as potentially throwing).
-  if (keyTy.subtypeOf(TOptArrKey)) {
+  if (keyTy.subtypeOf(BOptArrKey)) {
     if (keyTy.m_dataTag == DataTag::Int) {
       ret.i = keyTy.m_data.ival;
     } else if (keyTy.m_dataTag == DataTag::Str) {
       ret.s = keyTy.m_data.sval;
     }
     ret.type = is_opt(keyTy) ? unopt(keyTy) : keyTy;
-    ret.mayThrow = !keyTy.subtypeOf(TArrKey);
+    ret.mayThrow = !keyTy.subtypeOf(BArrKey);
     return ret;
   }
 
@@ -4762,7 +4761,7 @@ dict_elem(const Type& dict, const Type& undisectedKey) {
 
 std::pair<Type, ThrowMode>
 dict_set(Type dict, const Type& undisectedKey, const Type& val) {
-  if (!val.couldBe(TInitCell)) return {TBottom, ThrowMode::BadOperation};
+  if (!val.couldBe(BInitCell)) return {TBottom, ThrowMode::BadOperation};
 
   auto const key = disect_strict_key(undisectedKey);
   if (key.type == TBottom) return {TBottom, ThrowMode::BadOperation};
@@ -4772,7 +4771,7 @@ dict_set(Type dict, const Type& undisectedKey, const Type& val) {
 
 std::pair<Type,Type> dict_newelem(Type dict, const Type& val) {
   return array_like_newelem(std::move(dict),
-                            val.subtypeOf(TInitCell) ? val : TInitCell);
+                            val.subtypeOf(BInitCell) ? val : TInitCell);
 }
 
 //////////////////////////////////////////////////////////////////////
@@ -4837,33 +4836,33 @@ RepoAuthType make_repo_type_arr(ArrayTypeTable::Builder& arrTable,
   }();
 
   auto const tag = [&]() -> RepoAuthType::Tag {
-    if (t.subtypeOf(TSVArr))    return RepoAuthType::Tag::SVArr;
-    if (t.subtypeOf(TVArr))     return RepoAuthType::Tag::VArr;
-    if (t.subtypeOf(TOptSVArr)) return RepoAuthType::Tag::OptSVArr;
-    if (t.subtypeOf(TOptVArr))  return RepoAuthType::Tag::OptVArr;
-    if (t.subtypeOf(TSDArr))    return RepoAuthType::Tag::SDArr;
-    if (t.subtypeOf(TDArr))     return RepoAuthType::Tag::DArr;
-    if (t.subtypeOf(TOptSDArr)) return RepoAuthType::Tag::OptSDArr;
-    if (t.subtypeOf(TOptDArr))  return RepoAuthType::Tag::OptDArr;
-    if (t.subtypeOf(TSArr))     return RepoAuthType::Tag::SArr;
-    if (t.subtypeOf(TArr))      return RepoAuthType::Tag::Arr;
-    if (t.subtypeOf(TOptSArr))  return RepoAuthType::Tag::OptSArr;
-    if (t.subtypeOf(TOptArr))   return RepoAuthType::Tag::OptArr;
-
-    if (t.subtypeOf(TSVec))     return RepoAuthType::Tag::SVec;
-    if (t.subtypeOf(TVec))      return RepoAuthType::Tag::Vec;
-    if (t.subtypeOf(TOptSVec))  return RepoAuthType::Tag::OptSVec;
-    if (t.subtypeOf(TOptVec))   return RepoAuthType::Tag::OptVec;
-
-    if (t.subtypeOf(TSDict))    return RepoAuthType::Tag::SDict;
-    if (t.subtypeOf(TDict))     return RepoAuthType::Tag::Dict;
-    if (t.subtypeOf(TOptSDict)) return RepoAuthType::Tag::OptSDict;
-    if (t.subtypeOf(TOptDict))  return RepoAuthType::Tag::OptDict;
-
-    if (t.subtypeOf(TSKeyset))    return RepoAuthType::Tag::SKeyset;
-    if (t.subtypeOf(TKeyset))     return RepoAuthType::Tag::Keyset;
-    if (t.subtypeOf(TOptSKeyset)) return RepoAuthType::Tag::OptSKeyset;
-    if (t.subtypeOf(TOptKeyset))  return RepoAuthType::Tag::OptKeyset;
+    if (t.subtypeOf(BSVArr))    return RepoAuthType::Tag::SVArr;
+    if (t.subtypeOf(BVArr))     return RepoAuthType::Tag::VArr;
+    if (t.subtypeOf(BOptSVArr)) return RepoAuthType::Tag::OptSVArr;
+    if (t.subtypeOf(BOptVArr))  return RepoAuthType::Tag::OptVArr;
+    if (t.subtypeOf(BSDArr))    return RepoAuthType::Tag::SDArr;
+    if (t.subtypeOf(BDArr))     return RepoAuthType::Tag::DArr;
+    if (t.subtypeOf(BOptSDArr)) return RepoAuthType::Tag::OptSDArr;
+    if (t.subtypeOf(BOptDArr))  return RepoAuthType::Tag::OptDArr;
+    if (t.subtypeOf(BSArr))     return RepoAuthType::Tag::SArr;
+    if (t.subtypeOf(BArr))      return RepoAuthType::Tag::Arr;
+    if (t.subtypeOf(BOptSArr))  return RepoAuthType::Tag::OptSArr;
+    if (t.subtypeOf(BOptArr))   return RepoAuthType::Tag::OptArr;
+
+    if (t.subtypeOf(BSVec))     return RepoAuthType::Tag::SVec;
+    if (t.subtypeOf(BVec))      return RepoAuthType::Tag::Vec;
+    if (t.subtypeOf(BOptSVec))  return RepoAuthType::Tag::OptSVec;
+    if (t.subtypeOf(BOptVec))   return RepoAuthType::Tag::OptVec;
+
+    if (t.subtypeOf(BSDict))    return RepoAuthType::Tag::SDict;
+    if (t.subtypeOf(BDict))     return RepoAuthType::Tag::Dict;
+    if (t.subtypeOf(BOptSDict)) return RepoAuthType::Tag::OptSDict;
+    if (t.subtypeOf(BOptDict))  return RepoAuthType::Tag::OptDict;
+
+    if (t.subtypeOf(BSKeyset))    return RepoAuthType::Tag::SKeyset;
+    if (t.subtypeOf(BKeyset))     return RepoAuthType::Tag::Keyset;
+    if (t.subtypeOf(BOptSKeyset)) return RepoAuthType::Tag::OptSKeyset;
+    if (t.subtypeOf(BOptKeyset))  return RepoAuthType::Tag::OptKeyset;
 
     not_reached();
   }();
@@ -4872,8 +4871,8 @@ RepoAuthType make_repo_type_arr(ArrayTypeTable::Builder& arrTable,
 }
 
 RepoAuthType make_repo_type(ArrayTypeTable::Builder& arrTable, const Type& t) {
-  assert(!t.couldBe(TCls));
-  assert(!t.subtypeOf(TBottom));
+  assert(!t.couldBe(BCls));
+  assert(!t.subtypeOf(BBottom));
   using T = RepoAuthType::Tag;
 
   if (t.strictSubtypeOf(TObj) || (is_opt(t) && t.strictSubtypeOf(TOptObj))) {
@@ -4890,7 +4889,7 @@ RepoAuthType make_repo_type(ArrayTypeTable::Builder& arrTable, const Type& t) {
     return make_repo_type_arr(arrTable, t);
   }
 
-#define X(x) if (t.subtypeOf(T##x)) return RepoAuthType{T::x};
+#define X(x) if (t.subtypeOf(B##x)) return RepoAuthType{T::x};
   X(Uninit)
   X(InitNull)
   X(Null)
diff --git a/hphp/hhbbc/type-system.h b/hphp/hhbbc/type-system.h
index 8ea5aa133a..f9fe77e3af 100644
--- a/hphp/hhbbc/type-system.h
+++ b/hphp/hhbbc/type-system.h
@@ -537,6 +537,8 @@ struct Type {
    */
   bool subtypeOf(const Type& o) const;
   bool strictSubtypeOf(const Type& o) const;
+  bool subtypeOf(trep bits) const { return (m_bits & bits) == m_bits; }
+  bool subtypeOrNull(trep bits) const { return subtypeOf(bits | BInitNull); }
 
   /*
    * Subtype of any of the list of types.
@@ -563,6 +565,7 @@ struct Type {
    * precise when returning false.
    */
   bool couldBe(const Type& o) const;
+  bool couldBe(trep bits) const { return m_bits & bits; }
 
   /*
    * Could-be any of the list of types.
@@ -1373,7 +1376,7 @@ Type loosen_all(Type t);
  * at least everything t contains, but doesn't contain TUninit.  Note
  * that this function will return TBottom for TUninit.
  *
- * Pre: t.subtypeOf(TCell)
+ * Pre: t.subtypeOf(BCell)
  */
 Type remove_uninit(Type t);
 
@@ -1472,8 +1475,8 @@ IterTypes iter_types(const Type&);
  * SStrings for class names.  The emit code needs to handle making
  * sure these things are merged into the appropriate unit or repo.
  *
- * Pre: !t.couldBe(TCls)
- *      !t.subtypeOf(TBottom)
+ * Pre: !t.couldBe(BCls)
+ *      !t.subtypeOf(BBottom)
  */
 RepoAuthType make_repo_type(ArrayTypeTable::Builder&, const Type& t);
 

