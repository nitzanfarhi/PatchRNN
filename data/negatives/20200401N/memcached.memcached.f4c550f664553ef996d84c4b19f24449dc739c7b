commit f4c550f664553ef996d84c4b19f24449dc739c7b
Author: dormando <dormando@rydia.net>
Date:   Sat Dec 31 00:33:37 2016 -0800

    allow skipping thread-local cache locks
    
    suffix cache was using a generic cache system, which uses a mutex lock. the
    pools are per-thread however.

diff --git a/cache.c b/cache.c
index 07a2ae0..0ccda9c 100644
--- a/cache.c
+++ b/cache.c
@@ -70,8 +70,15 @@ void cache_destroy(cache_t *cache) {
 
 void* cache_alloc(cache_t *cache) {
     void *ret;
-    void *object;
     pthread_mutex_lock(&cache->mutex);
+    ret = do_cache_alloc(cache);
+    pthread_mutex_unlock(&cache->mutex);
+    return ret;
+}
+
+void* do_cache_alloc(cache_t *cache) {
+    void *ret;
+    void *object;
     if (cache->freecurr > 0) {
         ret = cache->ptr[--cache->freecurr];
         object = get_object(ret);
@@ -87,7 +94,6 @@ void* cache_alloc(cache_t *cache) {
             }
         }
     }
-    pthread_mutex_unlock(&cache->mutex);
 
 #ifndef NDEBUG
     if (object != NULL) {
@@ -105,14 +111,17 @@ void* cache_alloc(cache_t *cache) {
 
 void cache_free(cache_t *cache, void *ptr) {
     pthread_mutex_lock(&cache->mutex);
+    do_cache_free(cache, ptr);
+    pthread_mutex_unlock(&cache->mutex);
+}
 
+void do_cache_free(cache_t *cache, void *ptr) {
 #ifndef NDEBUG
     /* validate redzone... */
     if (memcmp(((char*)ptr) + cache->bufsize - (2 * sizeof(redzone_pattern)),
                &redzone_pattern, sizeof(redzone_pattern)) != 0) {
         raise(SIGABRT);
         cache_error = 1;
-        pthread_mutex_unlock(&cache->mutex);
         return;
     }
     uint64_t *pre = ptr;
@@ -120,7 +129,6 @@ void cache_free(cache_t *cache, void *ptr) {
     if (*pre != redzone_pattern) {
         raise(SIGABRT);
         cache_error = -1;
-        pthread_mutex_unlock(&cache->mutex);
         return;
     }
     ptr = pre;
@@ -143,6 +151,5 @@ void cache_free(cache_t *cache, void *ptr) {
 
         }
     }
-    pthread_mutex_unlock(&cache->mutex);
 }
 
diff --git a/cache.h b/cache.h
index c9ebdd8..27d98bf 100644
--- a/cache.h
+++ b/cache.h
@@ -101,6 +101,7 @@ void cache_destroy(cache_t* handle);
  *         the allocation cannot be satisfied.
  */
 void* cache_alloc(cache_t* handle);
+void* do_cache_alloc(cache_t* handle);
 /**
  * Return an object back to the cache.
  *
@@ -111,6 +112,7 @@ void* cache_alloc(cache_t* handle);
  * @param ptr pointer to the object to return.
  */
 void cache_free(cache_t* handle, void* ptr);
+void do_cache_free(cache_t* handle, void* ptr);
 #endif
 
 #endif
diff --git a/memcached.c b/memcached.c
index 43c5c46..2b0a332 100644
--- a/memcached.c
+++ b/memcached.c
@@ -622,7 +622,7 @@ static void conn_release_items(conn *c) {
 
     if (c->suffixleft != 0) {
         for (; c->suffixleft > 0; c->suffixleft--, c->suffixcurr++) {
-            cache_free(c->thread->suffix_cache, *(c->suffixcurr));
+            do_cache_free(c->thread->suffix_cache, *(c->suffixcurr));
         }
     }
 
@@ -3275,7 +3275,7 @@ static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens,
                     }
                   }
 
-                  suffix = cache_alloc(c->thread->suffix_cache);
+                  suffix = do_cache_alloc(c->thread->suffix_cache);
                   if (suffix == NULL) {
                       STATS_LOCK();
                       stats.malloc_fails++;

