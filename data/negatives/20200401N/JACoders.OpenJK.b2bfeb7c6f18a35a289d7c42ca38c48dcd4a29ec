commit b2bfeb7c6f18a35a289d7c42ca38c48dcd4a29ec
Author: Xycaleth <alex@acslo.com>
Date:   Sun Jun 14 21:44:22 2015 +0100

    MP: Do gamma correction in ARB shaders (#637)
    
    This commit adds changes to perform gamma correction using ARB shaders.
    The benefit of this is so that only the window is affected by r_gamma,
    instead of the whole window.
    
    This commit also gets rid of some qglGetError() calls in release builds.

diff --git a/codemp/rd-vanilla/qgl.h b/codemp/rd-vanilla/qgl.h
index db78b522..fd920f2f 100644
--- a/codemp/rd-vanilla/qgl.h
+++ b/codemp/rd-vanilla/qgl.h
@@ -389,6 +389,8 @@ along with this program; if not, see <http://www.gnu.org/licenses/>.
 extern PFNGLACTIVETEXTUREARBPROC qglActiveTextureARB;
 extern PFNGLCLIENTACTIVETEXTUREARBPROC qglClientActiveTextureARB;
 extern PFNGLMULTITEXCOORD2FARBPROC qglMultiTexCoord2fARB;
+extern PFNGLTEXIMAGE3DPROC qglTexImage3D;
+extern PFNGLTEXSUBIMAGE3DPROC qglTexSubImage3D;
 
 extern PFNGLCOMBINERPARAMETERFVNVPROC qglCombinerParameterfvNV;
 extern PFNGLCOMBINERPARAMETERIVNVPROC qglCombinerParameterivNV;
diff --git a/codemp/rd-vanilla/tr_arb.cpp b/codemp/rd-vanilla/tr_arb.cpp
index d6f5ccf0..5f12c099 100644
--- a/codemp/rd-vanilla/tr_arb.cpp
+++ b/codemp/rd-vanilla/tr_arb.cpp
@@ -107,25 +107,40 @@ const unsigned char g_strGlowPShaderARB[] =
 	\
 	END"
 };
+
+static const char *gammaCorrectVtxShader =
+"!!ARBvp1.0\
+MOV result.position, vertex.position;\
+MOV result.texcoord[0], vertex.texcoord[0];\
+END";
+
+static const char *gammaCorrectPxShader =
+"!!ARBfp1.0\
+TEMP r0;\
+TEX r0, fragment.texcoord[0], texture[0], RECT;\
+TEX result.color, r0, texture[1], 3D;\
+END";
 /***********************************************************************************************************/
 
 #define GL_PROGRAM_ERROR_STRING_ARB						0x8874
 #define GL_PROGRAM_ERROR_POSITION_ARB					0x864B
 
-void ARB_InitGlowShaders(void) {
-	// Allocate and Load the global 'Glow' Vertex Program. - AReis
-	if ( qglGenProgramsARB )
+void ARB_InitGPUShaders(void) {
+	if ( !qglGenProgramsARB )
 	{
-		qglGenProgramsARB( 1, &tr.glowVShader );
-		qglBindProgramARB( GL_VERTEX_PROGRAM_ARB, tr.glowVShader );
-		qglProgramStringARB( GL_VERTEX_PROGRAM_ARB, GL_PROGRAM_FORMAT_ASCII_ARB, ( GLsizei ) strlen( ( char * ) g_strGlowVShaderARB ), g_strGlowVShaderARB );
-
-//		const GLubyte *strErr = qglGetString( GL_PROGRAM_ERROR_STRING_ARB );
-		int iErrPos = 0;
-		qglGetIntegerv( GL_PROGRAM_ERROR_POSITION_ARB, &iErrPos );
-		assert( iErrPos == -1 );
+		return;
 	}
 
+	// Allocate and Load the global 'Glow' Vertex Program. - AReis
+	qglGenProgramsARB( 1, &tr.glowVShader );
+	qglBindProgramARB( GL_VERTEX_PROGRAM_ARB, tr.glowVShader );
+	qglProgramStringARB( GL_VERTEX_PROGRAM_ARB, GL_PROGRAM_FORMAT_ASCII_ARB, ( GLsizei ) strlen( ( char * ) g_strGlowVShaderARB ), g_strGlowVShaderARB );
+
+//	const GLubyte *strErr = qglGetString( GL_PROGRAM_ERROR_STRING_ARB );
+	int iErrPos = 0;
+	qglGetIntegerv( GL_PROGRAM_ERROR_POSITION_ARB, &iErrPos );
+	assert( iErrPos == -1 );
+
 	// NOTE: I make an assumption here. If you have (current) nvidia hardware, you obviously support register combiners instead of fragment
 	// programs, so use those. The problem with this is that nv30 WILL support fragment shaders, breaking this logic. The good thing is that
 	// if you always ask for regcoms before fragment shaders, you'll always just use regcoms (problem solved... for now). - AReis
@@ -178,7 +193,7 @@ void ARB_InitGlowShaders(void) {
 			qglFinalCombinerInputNV( GL_VARIABLE_D_NV, GL_SPARE1_NV,	GL_UNSIGNED_IDENTITY_NV, GL_RGB );
 		qglEndList();
 	}
-	else if ( qglGenProgramsARB )
+	else
 	{
 		qglGenProgramsARB( 1, &tr.glowPShader );
 		qglBindProgramARB( GL_FRAGMENT_PROGRAM_ARB, tr.glowPShader );
@@ -189,4 +204,29 @@ void ARB_InitGlowShaders(void) {
 		qglGetIntegerv( GL_PROGRAM_ERROR_POSITION_ARB, &iErrPos );
 		assert( iErrPos == -1 );
 	}
+
+	qglGenProgramsARB(1, &tr.gammaCorrectVtxShader);
+	qglBindProgramARB(GL_VERTEX_PROGRAM_ARB, tr.gammaCorrectVtxShader);
+	qglProgramStringARB(GL_VERTEX_PROGRAM_ARB, GL_PROGRAM_FORMAT_ASCII_ARB, strlen(gammaCorrectVtxShader), gammaCorrectVtxShader);
+
+	int errorChar;
+	qglGetIntegerv(GL_PROGRAM_ERROR_POSITION_ARB, &errorChar);
+	if ( errorChar != -1 )
+	{
+		Com_Printf(S_COLOR_RED "ERROR: Failed to compile gamma correction vertex shader. Error at character %d\n", errorChar);
+		glConfigExt.doGammaCorrectionWithShaders = qfalse;
+	}
+	else
+	{
+		qglGenProgramsARB(1, &tr.gammaCorrectPxShader);
+		qglBindProgramARB(GL_FRAGMENT_PROGRAM_ARB, tr.gammaCorrectPxShader);
+		qglProgramStringARB(GL_FRAGMENT_PROGRAM_ARB, GL_PROGRAM_FORMAT_ASCII_ARB, strlen(gammaCorrectPxShader), gammaCorrectPxShader);
+
+		qglGetIntegerv(GL_PROGRAM_ERROR_POSITION_ARB, &errorChar);
+		if ( errorChar != -1 )
+		{
+			Com_Printf(S_COLOR_RED "Failed to compile gamma correction pixel shader. Error at character %d\n", errorChar);
+			glConfigExt.doGammaCorrectionWithShaders = qfalse;
+		}
+	}
 }
diff --git a/codemp/rd-vanilla/tr_backend.cpp b/codemp/rd-vanilla/tr_backend.cpp
index 7d18f2c4..eb6ee3f8 100644
--- a/codemp/rd-vanilla/tr_backend.cpp
+++ b/codemp/rd-vanilla/tr_backend.cpp
@@ -1823,6 +1823,51 @@ void RB_ShowImages( void ) {
 //	ri->Printf( PRINT_ALL, "%i msec to draw all images\n", end - start );
 }
 
+static void RB_GammaCorrectRender()
+{
+	qglPushAttrib(GL_CLIENT_ALL_ATTRIB_BITS);
+
+	RB_SetGL2D();
+
+	// All this fixed-function texture type enabling/disabling is ludicrous :(
+	qglEnable(GL_TEXTURE_RECTANGLE_ARB);
+	GL_SelectTexture(0);
+	qglBindTexture(GL_TEXTURE_RECTANGLE_ARB, tr.sceneImage);
+	qglCopyTexImage2D(GL_TEXTURE_RECTANGLE_ARB, 0, GL_RGBA, 0, 0, glConfig.vidWidth, glConfig.vidHeight, 0);
+
+	qglEnable(GL_TEXTURE_3D);
+	GL_SelectTexture(1);
+	qglBindTexture(GL_TEXTURE_3D, tr.gammaCorrectLUTImage);
+
+	qglBindProgramARB(GL_VERTEX_PROGRAM_ARB, tr.gammaCorrectVtxShader);
+	qglBindProgramARB(GL_FRAGMENT_PROGRAM_ARB, tr.gammaCorrectPxShader);
+
+	qglEnable(GL_VERTEX_PROGRAM_ARB);
+	qglEnable(GL_FRAGMENT_PROGRAM_ARB);
+
+	qglBegin(GL_QUADS);
+		qglTexCoord2f(0.0f, 0.0f);
+		qglVertex2f(-1.0f, -1.0f);
+
+		qglTexCoord2f(0.0f, (float)glConfig.vidHeight);
+		qglVertex2f(-1.0f,  1.0f);
+
+		qglTexCoord2f((float)glConfig.vidWidth, (float)glConfig.vidHeight);
+		qglVertex2f( 1.0f,  1.0f);
+
+		qglTexCoord2f((float)glConfig.vidWidth, 0.0f);
+		qglVertex2f( 1.0f, -1.0f);
+	qglEnd();
+
+	qglDisable(GL_VERTEX_PROGRAM_ARB);
+	qglDisable(GL_FRAGMENT_PROGRAM_ARB);
+
+	qglDisable(GL_TEXTURE_3D);
+	GL_SelectTexture(0);
+
+	qglPopAttrib();
+}
+
 
 /*
 =============
@@ -1838,6 +1883,11 @@ const void	*RB_SwapBuffers( const void *data ) {
 		RB_EndSurface();
 	}
 
+	if ( glConfigExt.doGammaCorrectionWithShaders )
+	{
+		RB_GammaCorrectRender();
+	}
+
 	// texture swapping test
 	if ( r_showImages->integer ) {
 		RB_ShowImages();
diff --git a/codemp/rd-vanilla/tr_cmds.cpp b/codemp/rd-vanilla/tr_cmds.cpp
index 40d8907b..3757d33c 100644
--- a/codemp/rd-vanilla/tr_cmds.cpp
+++ b/codemp/rd-vanilla/tr_cmds.cpp
@@ -385,6 +385,7 @@ void RE_BeginFrame( stereoFrame_t stereoFrame ) {
 
 		R_IssuePendingRenderCommands();
 		R_SetColorMappings();
+		R_SetGammaCorrectionLUT();
 	}
 
     // check for errors
@@ -392,9 +393,11 @@ void RE_BeginFrame( stereoFrame_t stereoFrame ) {
         int	err;
 
 		R_IssuePendingRenderCommands();
+#if defined(_DEBUG)
         if ( ( err = qglGetError() ) != GL_NO_ERROR ) {
             Com_Error( ERR_FATAL, "RE_BeginFrame() - glGetError() failed (0x%x)!\n", err );
         }
+#endif
     }
 
 	//
diff --git a/codemp/rd-vanilla/tr_image.cpp b/codemp/rd-vanilla/tr_image.cpp
index cfc9504f..884a91ed 100644
--- a/codemp/rd-vanilla/tr_image.cpp
+++ b/codemp/rd-vanilla/tr_image.cpp
@@ -318,7 +318,7 @@ void R_LightScaleTexture (unsigned *in, int inwidth, int inheight, qboolean only
 {
 	if ( only_gamma )
 	{
-		if ( !glConfig.deviceSupportsGamma )
+		if ( !glConfig.deviceSupportsGamma && !glConfigExt.doGammaCorrectionWithShaders )
 		{
 			int		i, c;
 			byte	*p;
@@ -343,7 +343,7 @@ void R_LightScaleTexture (unsigned *in, int inwidth, int inheight, qboolean only
 
 		c = inwidth*inheight;
 
-		if ( glConfig.deviceSupportsGamma )
+		if ( glConfig.deviceSupportsGamma || glConfigExt.doGammaCorrectionWithShaders )
 		{
 			for (i=0 ; i<c ; i++, p+=4)
 			{
@@ -1356,8 +1356,18 @@ void R_CreateBuiltinImages( void ) {
 	qglTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_S, GL_CLAMP );
 	qglTexParameteri( GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_T, GL_CLAMP );
 	qglDisable( GL_TEXTURE_RECTANGLE_ARB );
-	qglEnable( GL_TEXTURE_2D );
-
+	qglEnable( GL_TEXTURE_3D );
+
+	tr.gammaCorrectLUTImage = 1024 + giTextureBindNum++;
+	qglBindTexture(GL_TEXTURE_3D, tr.gammaCorrectLUTImage);
+	qglTexImage3D(GL_TEXTURE_3D, 0, GL_RGBA8, 64, 64, 64, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
+	qglTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+	qglTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+	qglTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+	qglTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
+	qglTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+	qglDisable(GL_TEXTURE_3D);
+	qglEnable(GL_TEXTURE_2D);
 
 	// with overbright bits active, we need an image which is some fraction of full color,
 	// for default lightmaps, etc
@@ -1396,7 +1406,7 @@ void R_SetColorMappings( void ) {
 
 	// setup the overbright lighting
 	tr.overbrightBits = r_overBrightBits->integer;
-	if ( !glConfig.deviceSupportsGamma ) {
+	if ( !glConfig.deviceSupportsGamma && !glConfigExt.doGammaCorrectionWithShaders ) {
 		tr.overbrightBits = 0;		// need hardware gamma for overbright
 	}
 
@@ -1432,20 +1442,28 @@ void R_SetColorMappings( void ) {
 
 	shift = tr.overbrightBits;
 
-	for ( i = 0; i < 256; i++ ) {
-		if ( g == 1 ) {
-			inf = i;
-		} else {
-			inf = 255 * pow ( i/255.0f, 1.0f / g ) + 0.5f;
-		}
-		inf <<= shift;
-		if (inf < 0) {
-			inf = 0;
+	if ( !glConfigExt.doGammaCorrectionWithShaders )
+	{
+		for ( i = 0; i < 256; i++ ) {
+			if ( g == 1 ) {
+				inf = i;
+			} else {
+				inf = 255 * pow ( i/255.0f, 1.0f / g ) + 0.5f;
+			}
+			inf <<= shift;
+			if (inf < 0) {
+				inf = 0;
+			}
+			if (inf > 255) {
+				inf = 255;
+			}
+			s_gammatable[i] = inf;
 		}
-		if (inf > 255) {
-			inf = 255;
+
+		if ( glConfig.deviceSupportsGamma )
+		{
+			ri->WIN_SetGamma( &glConfig, s_gammatable, s_gammatable, s_gammatable );
 		}
-		s_gammatable[i] = inf;
 	}
 
 	for (i=0 ; i<256 ; i++) {
@@ -1455,10 +1473,51 @@ void R_SetColorMappings( void ) {
 		}
 		s_intensitytable[i] = j;
 	}
+}
 
-	if ( glConfig.deviceSupportsGamma )
+void R_SetGammaCorrectionLUT()
+{
+	if ( glConfigExt.doGammaCorrectionWithShaders )
 	{
-		ri->WIN_SetGamma( &glConfig, s_gammatable, s_gammatable, s_gammatable );
+		int inf;
+		int shift = tr.overbrightBits;
+		float g = r_gamma->value;
+		byte gammaCorrected[64];
+
+		for ( int i = 0; i < 64; i++ )
+		{
+			if ( g == 1.0f )
+			{
+				inf = (int)(((float)i / 63.0f) * 255.0f + 0.5f);
+			}
+			else
+			{
+				inf = (int)(255.0f * pow((float)i / 63.0f, 1.0f / g) + 0.5f);
+			}
+
+			gammaCorrected[i] = Com_Clampi(0, 255, inf << shift);
+		}
+
+		byte *lutTable = (byte *)ri->Hunk_AllocateTempMemory(64 * 64 * 64 * 3);
+		byte *write = lutTable;
+		for ( int z = 0; z < 64; z++ )
+		{
+			for ( int y = 0; y < 64; y++ )
+			{
+				for ( int x = 0; x < 64; x++ )
+				{
+					*write++ = gammaCorrected[x];
+					*write++ = gammaCorrected[y];
+					*write++ = gammaCorrected[z];
+				}
+			}
+		}
+
+		qglBindTexture(GL_TEXTURE_3D, tr.gammaCorrectLUTImage);
+		qglPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+		qglTexSubImage3D(GL_TEXTURE_3D, 0, 0, 0, 0, 64, 64, 64, GL_RGB, GL_UNSIGNED_BYTE, lutTable);
+
+		ri->Hunk_FreeTempMemory(lutTable);
 	}
 }
 
@@ -1474,6 +1533,8 @@ void	R_InitImages( void ) {
 
 	// create default texture and white texture
 	R_CreateBuiltinImages();
+
+	R_SetGammaCorrectionLUT();
 }
 
 /*
diff --git a/codemp/rd-vanilla/tr_init.cpp b/codemp/rd-vanilla/tr_init.cpp
index e213b1b2..a60b0479 100644
--- a/codemp/rd-vanilla/tr_init.cpp
+++ b/codemp/rd-vanilla/tr_init.cpp
@@ -217,6 +217,8 @@ cvar_t *r_screenshotJpegQuality;
 PFNGLACTIVETEXTUREARBPROC qglActiveTextureARB;
 PFNGLCLIENTACTIVETEXTUREARBPROC qglClientActiveTextureARB;
 PFNGLMULTITEXCOORD2FARBPROC qglMultiTexCoord2fARB;
+PFNGLTEXIMAGE3DPROC qglTexImage3D;
+PFNGLTEXSUBIMAGE3DPROC qglTexSubImage3D;
 
 PFNGLCOMBINERPARAMETERFVNVPROC qglCombinerParameterfvNV;
 PFNGLCOMBINERPARAMETERIVNVPROC qglCombinerParameterivNV;
@@ -433,6 +435,7 @@ GLimp_InitExtensions
 ===============
 */
 extern bool g_bDynamicGlowSupported;
+extern bool g_bARBShadersAvailable;
 static void GLimp_InitExtensions( void )
 {
 	if ( !r_allowExtensions->integer )
@@ -699,6 +702,17 @@ static void GLimp_InitExtensions( void )
 	if(bNVRegisterCombiners)
 		qglGetIntegerv( GL_MAX_GENERAL_COMBINERS_NV, &iNumGeneralCombiners );
 
+	glConfigExt.doGammaCorrectionWithShaders = qfalse;
+	if ( bTexRectSupported && bARBVertexProgram && bARBFragmentProgram )
+	{
+		qglTexImage3D = (PFNGLTEXIMAGE3DPROC)ri->GL_GetProcAddress("glTexImage3D");
+		qglTexSubImage3D = (PFNGLTEXSUBIMAGE3DPROC)ri->GL_GetProcAddress("glTexSubImage3D");
+		if ( qglTexImage3D && qglTexSubImage3D )
+		{
+			glConfigExt.doGammaCorrectionWithShaders = qtrue;
+		}
+	}
+	
 	// Only allow dynamic glows/flares if they have the hardware
 	if ( bTexRectSupported && bARBVertexProgram && qglActiveTextureARB && glConfig.maxActiveTextures >= 4 &&
 		( ( bNVRegisterCombiners && iNumGeneralCombiners >= 2 ) || bARBFragmentProgram ) )
@@ -768,6 +782,7 @@ static void InitOpenGL( void )
 	{
 		windowDesc_t windowDesc = { GRAPHICS_API_OPENGL };
 		memset(&glConfig, 0, sizeof(glConfig));
+		memset(&glConfigExt, 0, sizeof(glConfigExt));
 
 		window = ri->WIN_Init(&windowDesc, &glConfig);
 
@@ -811,6 +826,7 @@ void GL_CheckErrors( void ) {
     int		err;
     char	s[64];
 
+#if defined(_DEBUG)
     err = qglGetError();
     if ( err == GL_NO_ERROR ) {
         return;
@@ -843,6 +859,7 @@ void GL_CheckErrors( void ) {
     }
 
     Com_Error( ERR_FATAL, "GL_CheckErrors: %s", s );
+#endif
 }
 
 /*
@@ -946,7 +963,7 @@ void R_TakeScreenshot( int x, int y, int width, int height, char *fileName ) {
 	memcount = linelen * height;
 
 	// gamma correct
-	if(glConfig.deviceSupportsGamma)
+	if(glConfig.deviceSupportsGamma && !glConfigExt.doGammaCorrectionWithShaders)
 		R_GammaCorrect(allbuf + offset, memcount);
 
 	ri->FS_WriteFile(fileName, buffer, memcount + 18);
@@ -983,7 +1000,7 @@ void R_TakeScreenshotJPEG( int x, int y, int width, int height, char *fileName )
 	memcount = (width * 3 + padlen) * height;
 
 	// gamma correct
-	if(glConfig.deviceSupportsGamma)
+	if(glConfig.deviceSupportsGamma && !glConfigExt.doGammaCorrectionWithShaders)
 		R_GammaCorrect(buffer + offset, memcount);
 
 	RE_SaveJPG(fileName, r_screenshotJpegQuality->integer, width, height, buffer + offset, padlen);
@@ -1062,7 +1079,7 @@ static void R_LevelShot( void ) {
 	}
 
 	// gamma correct
-	if ( ( tr.overbrightBits > 0 ) && glConfig.deviceSupportsGamma ) {
+	if ( ( tr.overbrightBits > 0 ) && glConfig.deviceSupportsGamma && !glConfigExt.doGammaCorrectionWithShaders ) {
 		R_GammaCorrect( buffer + 18, LEVELSHOTSIZE * LEVELSHOTSIZE * 3 );
 	}
 
@@ -1227,7 +1244,7 @@ const void *RB_TakeVideoFrameCmd( const void *data )
 	memcount = padwidth * cmd->height;
 
 	// gamma correct
-	if(glConfig.deviceSupportsGamma)
+	if(glConfig.deviceSupportsGamma && !glConfigExt.doGammaCorrectionWithShaders)
 		R_GammaCorrect(cBuf, memcount);
 
 	if(cmd->motionJpeg)
@@ -1394,7 +1411,7 @@ void GfxInfo_f( void )
 	{
 		ri->Printf( PRINT_ALL, "N/A\n" );
 	}
-	if ( glConfig.deviceSupportsGamma )
+	if ( glConfig.deviceSupportsGamma && !glConfigExt.doGammaCorrectionWithShaders )
 	{
 		ri->Printf( PRINT_ALL, "GAMMA: hardware w/ %d overbright bits\n", tr.overbrightBits );
 	}
@@ -1745,9 +1762,11 @@ void R_Init( void ) {
 
 	R_InitWorldEffects();
 
+#if defined(_DEBUG)
 	int	err = qglGetError();
 	if ( err != GL_NO_ERROR )
 		ri->Printf( PRINT_ALL,  "glGetError() = 0x%x\n", err);
+#endif
 
 	RestoreGhoul2InfoArray();
 	// print info
@@ -1791,12 +1810,24 @@ void RE_Shutdown( qboolean destroyWindow, qboolean restarting ) {
 			}
 		}
 
+		if ( tr.gammaCorrectVtxShader )
+		{
+			qglDeleteProgramsARB(1, &tr.gammaCorrectVtxShader);
+		}
+
+		if ( tr.gammaCorrectPxShader )
+		{
+			qglDeleteProgramsARB(1, &tr.gammaCorrectPxShader);
+		}
+
 		// Release the scene glow texture.
 		qglDeleteTextures( 1, &tr.screenGlow );
 
 		// Release the scene texture.
 		qglDeleteTextures( 1, &tr.sceneImage );
 
+		qglDeleteTextures(1, &tr.gammaCorrectLUTImage);
+
 		// Release the blur texture.
 		qglDeleteTextures( 1, &tr.blurImage );
 	}
diff --git a/codemp/rd-vanilla/tr_local.h b/codemp/rd-vanilla/tr_local.h
index 9f0db610..6c47877d 100644
--- a/codemp/rd-vanilla/tr_local.h
+++ b/codemp/rd-vanilla/tr_local.h
@@ -986,6 +986,11 @@ typedef struct trGlobals_s {
 	// Image used to downsample and blur scene to.	- AReis
 	GLuint					blurImage;
 
+	// Gamma correction using vertex/pixel programs
+	GLuint					gammaCorrectLUTImage;
+	GLuint					gammaCorrectVtxShader;
+	GLuint					gammaCorrectPxShader;
+
 	shader_t				*defaultShader;
 	shader_t				*shadowShader;
 	shader_t				*distortionShader;
@@ -1057,6 +1062,7 @@ struct glconfigExt_t
 {
 	glconfig_t *glConfig;
 
+	qboolean doGammaCorrectionWithShaders;
 	const char *originalExtensionString;
 };
 
@@ -1349,6 +1355,7 @@ image_t		*R_CreateImage( const char *name, const byte *pic, int width, int heigh
 qboolean	R_GetModeInfo( int *width, int *height, int mode );
 
 void		R_SetColorMappings( void );
+void		R_SetGammaCorrectionLUT();
 void		R_GammaCorrect( byte *buffer, int bufSize );
 
 void	R_ImageList_f( void );
@@ -1392,7 +1399,7 @@ void    R_RemapShader(const char *oldShader, const char *newShader, const char *
 //
 // tr_arb.c
 //
-void ARB_InitGlowShaders( void );
+void ARB_InitGPUShaders( void );
 
 
 /*
diff --git a/codemp/rd-vanilla/tr_shader.cpp b/codemp/rd-vanilla/tr_shader.cpp
index 8a921c6d..ddf2deec 100644
--- a/codemp/rd-vanilla/tr_shader.cpp
+++ b/codemp/rd-vanilla/tr_shader.cpp
@@ -4150,7 +4150,7 @@ static void CreateInternalShaders( void ) {
 	tr.distortionShader = FinishShader();
 	shader.defaultShader = qtrue;
 
-	ARB_InitGlowShaders();
+	ARB_InitGPUShaders();
 }
 
 static void CreateExternalShaders( void ) {

