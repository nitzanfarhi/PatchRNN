commit a1f012d0dcd261d574e26c9b053677d944753800
Author: JÃ¶rn Heusipp <manxorist@users.sourceforge.net>
Date:   Thu Aug 29 11:43:14 2013 +0000

    [Fix] DSM loader: Support loading .dsm files that start with a slightly different header. (See http://forum.openmpt.org/index.php?topic=5091 ).
    
    git-svn-id: https://source.openmpt.org/svn/openmpt/trunk/OpenMPT@2619 56274372-70c3-4bfc-bfc3-4c3a0b034d27

diff --git a/soundlib/Load_dsm.cpp b/soundlib/Load_dsm.cpp
index 912d2abd3..e564c81ab 100644
--- a/soundlib/Load_dsm.cpp
+++ b/soundlib/Load_dsm.cpp
@@ -63,6 +63,19 @@ typedef struct PACKED DSMFILEHEADER
 STATIC_ASSERT(sizeof(DSMFILEHEADER) == 20);
 
 
+typedef struct PACKED DSMFILEHEADERNORIFF
+{
+	DWORD id_DSMF;	// "DSMF"
+	DWORD unknown1;
+	DWORD data_len;
+	DWORD unknown2;
+	DWORD id_SONG;	// "SONG"
+	DWORD song_len;
+} DSMFILEHEADERNORIFF;
+
+STATIC_ASSERT(sizeof(DSMFILEHEADERNORIFF) == 24);
+
+
 typedef struct PACKED DSMSONG
 {
 	char songname[28];
@@ -103,24 +116,45 @@ STATIC_ASSERT(sizeof(DSMPATT) == 10);
 bool CSoundFile::ReadDSM(const LPCBYTE lpStream, const DWORD dwMemLength, ModLoadingFlags loadFlags)
 //--------------------------------------------------------------------------------------------------
 {
-	DSMFILEHEADER *pfh = (DSMFILEHEADER *)lpStream;
 	DSMSONG *psong;
 	DWORD dwMemPos;
 	UINT nSmp;
 	PATTERNINDEX nPat;
 
-	if ((!lpStream) || (dwMemLength < 1024) || (pfh->id_RIFF != DSMID_RIFF)
-	 || (pfh->riff_len + 8 > dwMemLength) || (pfh->riff_len < 1024)
-	 || (pfh->id_DSMF != DSMID_DSMF) || (pfh->id_SONG != DSMID_SONG)
-	 || (pfh->song_len > dwMemLength))
+	if(!lpStream || (dwMemLength < 1024))
 	{
 		return false;
-	} else if(loadFlags == onlyVerifyHeader)
+	}
+
+	DSMFILEHEADER *pfh = (DSMFILEHEADER *)lpStream;
+	if(pfh->id_RIFF == DSMID_RIFF)
 	{
-		return true;
+		if((pfh->riff_len + 8 > dwMemLength) || (pfh->riff_len < 1024)
+			|| (pfh->id_DSMF != DSMID_DSMF) || (pfh->id_SONG != DSMID_SONG)
+			|| (pfh->song_len > dwMemLength))
+		{
+			return false;
+		} else if(loadFlags == onlyVerifyHeader)
+		{
+			return true;
+		}
+		psong = (DSMSONG *)(lpStream + sizeof(DSMFILEHEADER));
+		dwMemPos = sizeof(DSMFILEHEADER) + pfh->song_len;
+	} else
+	{
+		// without "RIFF"
+		DSMFILEHEADERNORIFF *pfh2 = (DSMFILEHEADERNORIFF *)lpStream;
+		if((pfh2->id_DSMF != DSMID_DSMF) || (pfh2->id_SONG != DSMID_SONG)
+			|| (pfh2->song_len > dwMemLength))
+		{
+			return false;
+		} else if(loadFlags == onlyVerifyHeader)
+		{
+			return true;
+		}
+		psong = (DSMSONG *)(lpStream + sizeof(DSMFILEHEADERNORIFF));
+		dwMemPos = sizeof(DSMFILEHEADERNORIFF) + pfh2->song_len;
 	}
-	psong = (DSMSONG *)(lpStream + sizeof(DSMFILEHEADER));
-	dwMemPos = sizeof(DSMFILEHEADER) + pfh->song_len;
 
 	InitializeGlobals();
 	m_nType = MOD_TYPE_DSM;
@@ -133,7 +167,13 @@ bool CSoundFile::ReadDSM(const LPCBYTE lpStream, const DWORD dwMemLength, ModLoa
 	m_nDefaultTempo = psong->bpm;
 	m_nDefaultGlobalVolume = psong->globalvol << 2;
 	if ((!m_nDefaultGlobalVolume) || (m_nDefaultGlobalVolume > MAX_GLOBAL_VOLUME)) m_nDefaultGlobalVolume = MAX_GLOBAL_VOLUME;
-	m_nSamplePreAmp = psong->mastervol & 0x7F;
+	if(psong->mastervol == 0x80)
+	{
+		m_nSamplePreAmp = 256 / m_nChannels;
+	} else
+	{
+		m_nSamplePreAmp = psong->mastervol & 0x7F;
+	}
 	Order.ReadFromArray(psong->orders, psong->numord);
 
 	for (UINT iPan=0; iPan<16; iPan++)

