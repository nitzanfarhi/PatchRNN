commit 8e7913535d969d73769347d00da18187c8930f9c
Author: Embedthis Software <dev@embedthis.com>
Date:   Mon Jul 30 12:54:09 2012 -0700

    Detab

diff --git a/CE/main.c b/CE/main.c
index 8bd8e22b..69670425 100644
--- a/CE/main.c
+++ b/CE/main.c
@@ -10,384 +10,384 @@
 /******************************** Description *********************************/
 
 /*
- *	Main program for the GoAhead WebServer. This is a demonstration
- *	program to initialize and configure the web server.
+ *  Main program for the GoAhead WebServer. This is a demonstration
+ *  program to initialize and configure the web server.
  */
 
 /********************************* Includes ***********************************/
 
-#include	<windows.h>
-#include	<winsock.h>
+#include    <windows.h>
+#include    <winsock.h>
 
-#include	"../wsIntrn.h"
+#include    "../wsIntrn.h"
 
 #ifdef WEBS_SSL_SUPPORT
-#include	"../websSSL.h"
+#include    "../websSSL.h"
 #endif
 
 #ifdef USER_MANAGEMENT_SUPPORT
-#include	"../um.h"
-void		formDefineUserMgmt(void);
+#include    "../um.h"
+void        formDefineUserMgmt(void);
 #endif
 
 /*********************************** Locals ***********************************/
 /*
- *	Change configuration here
- */
-static HWND			hwnd;							/* Window handle */
-static int			sockServiceTime = 1000;			/* milliseconds */
-static char_t		*title = T("GoAhead WebServer");/* Window title */
-static char_t		*name = T("gowebs");			/* Window name */
-static char_t		*rootWeb = T("/www");			/* Root web directory */
-static char_t		*demoWeb = T("/wwwdemo");		/* Root web directory */
-static char_t		*password = T("");				/* Security password */
-static int			port = 80;						/* Server port */
-static int			retries = 5;					/* Server port retries */
-static int			finished;						/* Finished flag */
+ *  Change configuration here
+ */
+static HWND         hwnd;                           /* Window handle */
+static int          sockServiceTime = 1000;         /* milliseconds */
+static char_t       *title = T("GoAhead WebServer");/* Window title */
+static char_t       *name = T("gowebs");            /* Window name */
+static char_t       *rootWeb = T("/www");           /* Root web directory */
+static char_t       *demoWeb = T("/wwwdemo");       /* Root web directory */
+static char_t       *password = T("");              /* Security password */
+static int          port = 80;                      /* Server port */
+static int          retries = 5;                    /* Server port retries */
+static int          finished;                       /* Finished flag */
 
 /****************************** Forward Declarations **************************/
 
-static int 	initWebs(int demo);
-static long	CALLBACK websWindProc(HWND hwnd, unsigned int msg, 
-				unsigned int wp, long lp);
-static int	aspTest(int eid, webs_t wp, int argc, char_t **argv);
+static int  initWebs(int demo);
+static long CALLBACK websWindProc(HWND hwnd, unsigned int msg, 
+                unsigned int wp, long lp);
+static int  aspTest(int eid, webs_t wp, int argc, char_t **argv);
 static void formTest(webs_t wp, char_t *path, char_t *query);
-static int	windowsInit(HINSTANCE hinstance);
+static int  windowsInit(HINSTANCE hinstance);
 static int  websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
-			int arg, char_t *url, char_t *path, char_t *query);
+            int arg, char_t *url, char_t *path, char_t *query);
 static void printMemStats(int handle, char_t *fmt, ...);
 static void memLeaks();
 
 /*********************************** Code *************************************/
 /*
- *	WinMain -- entry point from Windows
+ *  WinMain -- entry point from Windows
  */
 
 int WINAPI WinMain(HINSTANCE hinstance, HINSTANCE hprevinstance,
-					LPTSTR args, int cmd_show)
+                    LPTSTR args, int cmd_show)
 {
-	int i, demo = 0;
+    int i, demo = 0;
 
-	for (i = 1; i < argc; i++) {
-		if (strcmp(argv[i], "-demo") == 0) {
-			demo++;
-		}
-	}
+    for (i = 1; i < argc; i++) {
+        if (strcmp(argv[i], "-demo") == 0) {
+            demo++;
+        }
+    }
 
 /*
- *	Initialize the memory allocator. Allow use of malloc and start 
- *	with a 60K heap.  For each page request approx 8KB is allocated.
- *	60KB allows for several concurrent page requests.  If more space
- *	is required, malloc will be used for the overflow.
+ *  Initialize the memory allocator. Allow use of malloc and start 
+ *  with a 60K heap.  For each page request approx 8KB is allocated.
+ *  60KB allows for several concurrent page requests.  If more space
+ *  is required, malloc will be used for the overflow.
  */
-	bopen(NULL, (60 * 1024), B_USE_MALLOC);
+    bopen(NULL, (60 * 1024), B_USE_MALLOC);
 
 /* 
- *	Store the instance handle (used in socket.c)
+ *  Store the instance handle (used in socket.c)
  */
-	if (windowsInit(hinstance) < 0) {
-		return FALSE;
-	}
+    if (windowsInit(hinstance) < 0) {
+        return FALSE;
+    }
 
 /*
- *	Initialize the web server
+ *  Initialize the web server
  */
-	if (initWebs(demo) < 0) {
-		return FALSE;
-	}
+    if (initWebs(demo) < 0) {
+        return FALSE;
+    }
 
 #ifdef WEBS_SSL_SUPPORT
-	websSSLOpen();
+    websSSLOpen();
 #endif
 
 /*
- *	Basic event loop. SocketReady returns true when a socket is ready for
- *	service. SocketSelect will block until an event occurs. SocketProcess
- *	will actually do the servicing.
- */
-	while (!finished) {
-		if (socketReady(-1) || socketSelect(-1, sockServiceTime)) {
-			socketProcess(-1);
-		}
-		emfSchedProcess();
-		websCgiCleanup();
-	}
+ *  Basic event loop. SocketReady returns true when a socket is ready for
+ *  service. SocketSelect will block until an event occurs. SocketProcess
+ *  will actually do the servicing.
+ */
+    while (!finished) {
+        if (socketReady(-1) || socketSelect(-1, sockServiceTime)) {
+            socketProcess(-1);
+        }
+        emfSchedProcess();
+        websCgiCleanup();
+    }
 
 #ifdef WEBS_SSL_SUPPORT
-	websSSLClose();
+    websSSLClose();
 #endif
 
 /*
- *	Close the User Management database
+ *  Close the User Management database
  */
 #ifdef USER_MANAGEMENT_SUPPORT
-	umClose();
+    umClose();
 #endif
 
 /*
- *	Close the socket module, report memory leaks and close the memory allocator
+ *  Close the socket module, report memory leaks and close the memory allocator
  */
-	websCloseServer();
-	socketClose();
+    websCloseServer();
+    socketClose();
 #ifdef B_STATS
-	memLeaks();
+    memLeaks();
 #endif
-	bclose();
-	return 0;
+    bclose();
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Initialize the web server.
+ *  Initialize the web server.
  */
 
 static int initWebs(int demo)
 {
-	struct hostent *hp;
-	struct in_addr	intaddr;
-	char_t			wbuf[128];
-	char			host[64];
-	char			*cp;
+    struct hostent *hp;
+    struct in_addr  intaddr;
+    char_t          wbuf[128];
+    char            host[64];
+    char            *cp;
 
 /*
- *	Initialize the socket subsystem
+ *  Initialize the socket subsystem
  */
-	socketOpen();
+    socketOpen();
 
 /*
- *	Initialize the User Management database
+ *  Initialize the User Management database
  */
 #ifdef USER_MANAGEMENT_SUPPORT
-	umOpen();
-	umRestore(T("umconfig.txt"));
+    umOpen();
+    umRestore(T("umconfig.txt"));
 #endif
 
 /*
- *	Define the local Ip address, host name, default home page and the 
- *	root web directory.
- */
-	if (gethostname(host, sizeof(host)) < 0) {
-		error(E_L, E_LOG, T("Can't get hostname"));
-		return -1;
-	}
-	if ((hp = gethostbyname(host)) == NULL) {
-		error(E_L, E_LOG, T("Can't get host address"));
-		return -1;
-	}
-	memcpy((void*) &intaddr, (void*) hp->h_addr_list[0],
-		(size_t) hp->h_length);
+ *  Define the local Ip address, host name, default home page and the 
+ *  root web directory.
+ */
+    if (gethostname(host, sizeof(host)) < 0) {
+        error(E_L, E_LOG, T("Can't get hostname"));
+        return -1;
+    }
+    if ((hp = gethostbyname(host)) == NULL) {
+        error(E_L, E_LOG, T("Can't get host address"));
+        return -1;
+    }
+    memcpy((void*) &intaddr, (void*) hp->h_addr_list[0],
+        (size_t) hp->h_length);
 
 /*
- *	Set /web as the root web. Modify this to suit your needs
+ *  Set /web as the root web. Modify this to suit your needs
  */
-	if (demo) {
-		websSetDefaultDir(demoWeb);
-	} else {
-		websSetDefaultDir(rootWeb);
-	}
+    if (demo) {
+        websSetDefaultDir(demoWeb);
+    } else {
+        websSetDefaultDir(rootWeb);
+    }
 
 /*
- *	Set the IP address and host name.
+ *  Set the IP address and host name.
  */
-	cp = inet_ntoa(intaddr);
-	ascToUni(wbuf, cp, min(strlen(cp) + 1, sizeof(wbuf)));
-	websSetIpaddr(wbuf);
-	ascToUni(wbuf, hp->h_name, min(strlen(hp->h_name) + 1, sizeof(wbuf)));
-	websSetHost(wbuf);
+    cp = inet_ntoa(intaddr);
+    ascToUni(wbuf, cp, min(strlen(cp) + 1, sizeof(wbuf)));
+    websSetIpaddr(wbuf);
+    ascToUni(wbuf, hp->h_name, min(strlen(hp->h_name) + 1, sizeof(wbuf)));
+    websSetHost(wbuf);
 
 /*
- *	Configure the web server options before opening the web server
+ *  Configure the web server options before opening the web server
  */
-	websSetDefaultPage(T("default.asp"));
-	websSetPassword(password);
+    websSetDefaultPage(T("default.asp"));
+    websSetPassword(password);
 
 /* 
- *	Open the web server on the given port. If that port is taken, try
- *	the next sequential port for up to "retries" attempts.
+ *  Open the web server on the given port. If that port is taken, try
+ *  the next sequential port for up to "retries" attempts.
  */
-	websOpenServer(port, retries);
+    websOpenServer(port, retries);
 
 /*
- * 	First create the URL handlers. Note: handlers are called in sorted order
- *	with the longest path handler examined first. Here we define the security 
- *	handler, forms handler and the default web page handler.
+ *  First create the URL handlers. Note: handlers are called in sorted order
+ *  with the longest path handler examined first. Here we define the security 
+ *  handler, forms handler and the default web page handler.
  */
-	websUrlHandlerDefine(T(""), NULL, 0, websSecurityHandler, 
-						WEBS_HANDLER_FIRST);
-	websUrlHandlerDefine(T("/goform"), NULL, 0, websFormHandler, 0);
-	websUrlHandlerDefine(T("/cgi-bin"), NULL, 0, websCgiHandler, 0);
-	websUrlHandlerDefine(T(""), NULL, 0, websDefaultHandler, 
-						WEBS_HANDLER_LAST); 
+    websUrlHandlerDefine(T(""), NULL, 0, websSecurityHandler, 
+                        WEBS_HANDLER_FIRST);
+    websUrlHandlerDefine(T("/goform"), NULL, 0, websFormHandler, 0);
+    websUrlHandlerDefine(T("/cgi-bin"), NULL, 0, websCgiHandler, 0);
+    websUrlHandlerDefine(T(""), NULL, 0, websDefaultHandler, 
+                        WEBS_HANDLER_LAST); 
 
 /*
- *	Now define two test procedures. Replace these with your application
- *	relevant ASP script procedures and form functions.
+ *  Now define two test procedures. Replace these with your application
+ *  relevant ASP script procedures and form functions.
  */
-	websAspDefine(T("aspTest"), aspTest);
-	websFormDefine(T("formTest"), formTest);
+    websAspDefine(T("aspTest"), aspTest);
+    websFormDefine(T("formTest"), formTest);
 
 /*
- *	Create the Form handlers for the User Management pages
+ *  Create the Form handlers for the User Management pages
  */
 #ifdef USER_MANAGEMENT_SUPPORT
-	formDefineUserMgmt();
+    formDefineUserMgmt();
 #endif
 
 /*
- *	Create a handler for the default home page
+ *  Create a handler for the default home page
  */
-	websUrlHandlerDefine(T("/"), NULL, 0, websHomePageHandler, 0); 
-	return 0;
+    websUrlHandlerDefine(T("/"), NULL, 0, websHomePageHandler, 0); 
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Create a taskbar entry. Register the window class and create a window
+ *  Create a taskbar entry. Register the window class and create a window
  */
 
 static int windowsInit(HINSTANCE hinstance)
 {
 /*
- *	Restore this code if you want to call Create Window
+ *  Restore this code if you want to call Create Window
  */
 #if 0
-	WNDCLASS  		wc;						/* Window class */
-
-	emfInstSet((int) hinstance);
-
-	wc.style		 = 0;
-	wc.hbrBackground = NULL;
-	wc.hCursor		 = NULL;
-	wc.cbClsExtra	 = 0;
-	wc.cbWndExtra	 = 0;
-	wc.hInstance	 = hinstance;
-	wc.hIcon		 = NULL;
-	wc.lpfnWndProc	 = (WNDPROC) websWindProc;
-	wc.lpszMenuName	 = NULL;
-	wc.lpszClassName = name;
-	if (! RegisterClass(&wc)) {
-		return -1;
-	}
+    WNDCLASS        wc;                     /* Window class */
+
+    emfInstSet((int) hinstance);
+
+    wc.style         = 0;
+    wc.hbrBackground = NULL;
+    wc.hCursor       = NULL;
+    wc.cbClsExtra    = 0;
+    wc.cbWndExtra    = 0;
+    wc.hInstance     = hinstance;
+    wc.hIcon         = NULL;
+    wc.lpfnWndProc   = (WNDPROC) websWindProc;
+    wc.lpszMenuName  = NULL;
+    wc.lpszClassName = name;
+    if (! RegisterClass(&wc)) {
+        return -1;
+    }
 
 /*
- *	Create a window just so we can have a taskbar to close this web server
+ *  Create a window just so we can have a taskbar to close this web server
  */
-	hwnd = CreateWindow(name, title, WS_VISIBLE,
-		CW_USEDEFAULT, 0, 0, 0, NULL, NULL, hinstance, NULL);
-	if (hwnd == NULL) {
-		return -1;
-	}
-	ShowWindow(hwnd, SW_MINIMIZE);
-	UpdateWindow(hwnd);
+    hwnd = CreateWindow(name, title, WS_VISIBLE,
+        CW_USEDEFAULT, 0, 0, 0, NULL, NULL, hinstance, NULL);
+    if (hwnd == NULL) {
+        return -1;
+    }
+    ShowWindow(hwnd, SW_MINIMIZE);
+    UpdateWindow(hwnd);
 
 #endif
-	return 0;
+    return 0;
 }
 
 /*
- *	Restore websWindProc if you want to use windowsInit and call CreateWindow
+ *  Restore websWindProc if you want to use windowsInit and call CreateWindow
  */
 #if 0
 /******************************************************************************/
 /*
- *	Windows message handler. Just process the window destroy event.
+ *  Windows message handler. Just process the window destroy event.
  */
 
 static long CALLBACK websWindProc(HWND hwnd, unsigned int msg, 
-	unsigned int wp, long lp)
+    unsigned int wp, long lp)
 {
-	switch (msg) {
-		case WM_DESTROY:
-			PostQuitMessage(0);
-			finished++;
-			return 0;
-	}
-	return DefWindowProc(hwnd, msg, wp, lp);
+    switch (msg) {
+        case WM_DESTROY:
+            PostQuitMessage(0);
+            finished++;
+            return 0;
+    }
+    return DefWindowProc(hwnd, msg, wp, lp);
 }
 #endif /* #if 0 */
 
 /******************************************************************************/
 /*
- *	Test Javascript binding for ASP. This will be invoked when "aspTest" is
- *	embedded in an ASP page. See web/asp.asp for usage. Set browser to 
- *	"localhost/asp.asp" to test.
+ *  Test Javascript binding for ASP. This will be invoked when "aspTest" is
+ *  embedded in an ASP page. See web/asp.asp for usage. Set browser to 
+ *  "localhost/asp.asp" to test.
  */
 
 static int aspTest(int eid, webs_t wp, int argc, char_t **argv)
 {
-	char_t	*name, *address;
+    char_t  *name, *address;
 
-	if (ejArgs(argc, argv, T("%s %s"), &name, &address) < 2) {
-		websError(wp, 400, T("Insufficient args\n"));
-		return -1;
-	}
-	return websWrite(wp, T("Name: %s, Address %s"), name, address);
+    if (ejArgs(argc, argv, T("%s %s"), &name, &address) < 2) {
+        websError(wp, 400, T("Insufficient args\n"));
+        return -1;
+    }
+    return websWrite(wp, T("Name: %s, Address %s"), name, address);
 }
 
 /******************************************************************************/
 /*
- *	Test form for posted data (in-memory CGI). This will be called when the
- *	form in web/forms.asp is invoked. Set browser to "localhost/forms.asp" to test.
+ *  Test form for posted data (in-memory CGI). This will be called when the
+ *  form in web/forms.asp is invoked. Set browser to "localhost/forms.asp" to test.
  */
 
 static void formTest(webs_t wp, char_t *path, char_t *query)
 {
-	char_t	*name, *address;
+    char_t  *name, *address;
 
-	name = websGetVar(wp, T("name"), T("Joe Smith")); 
-	address = websGetVar(wp, T("address"), T("1212 Milky Way Ave.")); 
+    name = websGetVar(wp, T("name"), T("Joe Smith")); 
+    address = websGetVar(wp, T("address"), T("1212 Milky Way Ave.")); 
 
-	websHeader(wp);
-	websWrite(wp, T("<body><h2>Name: %s, Address: %s</h2>\n"), name, address);
-	websFooter(wp);
-	websDone(wp, 200);
+    websHeader(wp);
+    websWrite(wp, T("<body><h2>Name: %s, Address: %s</h2>\n"), name, address);
+    websFooter(wp);
+    websDone(wp, 200);
 }
 
 /******************************************************************************/
 /*
- *	Home page handler
+ *  Home page handler
  */
 
 static int websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
-							int arg, char_t *url, char_t *path, char_t *query)
+                            int arg, char_t *url, char_t *path, char_t *query)
 {
 /*
- *	If the empty or "/" URL is invoked, redirect default URLs to the home page
+ *  If the empty or "/" URL is invoked, redirect default URLs to the home page
  */
-	if (*url == '\0' || gstrcmp(url, T("/")) == 0) {
-		websRedirect(wp, T("home.asp"));
-		return 1;
-	}
-	return 0;
+    if (*url == '\0' || gstrcmp(url, T("/")) == 0) {
+        websRedirect(wp, T("home.asp"));
+        return 1;
+    }
+    return 0;
 }
 
 /******************************************************************************/
 #ifdef B_STATS
 static void memLeaks() 
 {
-	int		fd;
+    int     fd;
 
-	if ((fd = gopen(T("leak.txt"), O_CREAT | O_TRUNC | O_WRONLY)) >= 0) {
-		bstats(fd, printMemStats);
-		close(fd);
-	}
+    if ((fd = gopen(T("leak.txt"), O_CREAT | O_TRUNC | O_WRONLY)) >= 0) {
+        bstats(fd, printMemStats);
+        close(fd);
+    }
 }
 
 /******************************************************************************/
 /*
- *	Print memory usage / leaks  
+ *  Print memory usage / leaks  
  */
 
 static void printMemStats(int handle, char_t *fmt, ...)
 {
-	va_list		args;
-	char_t		buf[256];
+    va_list     args;
+    char_t      buf[256];
 
-	va_start(args, fmt);
-	vsprintf(buf, fmt, args);
-	va_end(args);
-	write(handle, buf, strlen(buf));
+    va_start(args, fmt);
+    vsprintf(buf, fmt, args);
+    va_end(args);
+    write(handle, buf, strlen(buf));
 }
-#endif	/* B_STATS */
+#endif  /* B_STATS */
 
 /******************************************************************************/
diff --git a/CE/wincompat.c b/CE/wincompat.c
index fe5eba88..d844088f 100644
--- a/CE/wincompat.c
+++ b/CE/wincompat.c
@@ -1,81 +1,81 @@
 /*
- *	wincompat.c -- UNIX compatibility module for windows CE.
+ *  wincompat.c -- UNIX compatibility module for windows CE.
  *
- *	Copyright (c) GoAhead Software Inc., 1995-2010. All Rights Reserved.
+ *  Copyright (c) GoAhead Software Inc., 1995-2010. All Rights Reserved.
  *
- *	See the file "license.txt" for usage and redistribution license requirements
+ *  See the file "license.txt" for usage and redistribution license requirements
  *
  */
 
 /******************************** Description *********************************/
 /*
- *	This module provides a basic functions which provide compatibility between
- *	CE and other operating systems.
+ *  This module provides a basic functions which provide compatibility between
+ *  CE and other operating systems.
  */
 
 /********************************* Includes ***********************************/
 
-#define		IN_GETOPT
+#define     IN_GETOPT
 
-#include	<windows.h>
+#include    <windows.h>
 
 #ifdef UEMF
-	#include "../uemf.h"
+    #include "../uemf.h"
 #else /* not UEMF */
-	#include	"basic/basicInternal.h"
-	#include	<direct.h>
-	#include	<fcntl.h>
-	#include	<getopt.h>
-	#include	<io.h>
-	#include	<pwd.h>
-	#include	<stat.h>
-	#include	<stdio.h>
-	#include	<string.h>
-	#include	<time.h>
-	#include	<timeb.h>
-	#include	<types.h>
-	#include	<unistd.h>
-	#include	<ulimit.h>
+    #include    "basic/basicInternal.h"
+    #include    <direct.h>
+    #include    <fcntl.h>
+    #include    <getopt.h>
+    #include    <io.h>
+    #include    <pwd.h>
+    #include    <stat.h>
+    #include    <stdio.h>
+    #include    <string.h>
+    #include    <time.h>
+    #include    <timeb.h>
+    #include    <types.h>
+    #include    <unistd.h>
+    #include    <ulimit.h>
 #endif /* UEMF */
 
 /************************************* Defines ********************************/
 
 typedef struct {
-	HANDLE	hand;
+    HANDLE  hand;
 } fh_t;
 
 /********************************** Global Data *******************************/
 
-int								errno;
-__declspec(dllexport) int		opterr = 1;
-__declspec(dllexport) int		optind = 1;
-__declspec(dllexport) int		optopt;
-__declspec(dllexport) char_t*	optarg;
+int                             errno;
+__declspec(dllexport) int       opterr = 1;
+__declspec(dllexport) int       optind = 1;
+__declspec(dllexport) int       optopt;
+__declspec(dllexport) char_t*   optarg;
 
 /************************************* Locals *********************************/
 
-static char	optswi = '-';
+static char optswi = '-';
 
-static fh_t			**f;			/* Array of all open files */
-static int			fMax;			/* Maximum size of f array */
+static fh_t         **f;            /* Array of all open files */
+static int          fMax;           /* Maximum size of f array */
 
 /*
- *	tm structure to be returned by localtime(). This is not thread safe.
+ *  tm structure to be returned by localtime(). This is not thread safe.
  */
 static struct tm localtm;
 
 /*
- *	String returned by _wctime(). This is not thread safe.
+ *  String returned by _wctime(). This is not thread safe.
  */
 static char_t localctime[32];
 
 static char_t *months[] = {
-	T("Jan"), T("Feb"), T("Mar"), T("Apr"), T("May"), T("Jun"), T("Jul"),
-	T("Aug"), T("Sep"), T("Oct"), T("Nov"), T("Dec")
+    T("Jan"), T("Feb"), T("Mar"), T("Apr"), T("May"), T("Jun"), T("Jul"),
+    T("Aug"), T("Sep"), T("Oct"), T("Nov"), T("Dec")
 };
 
 static char_t *days[] = {
-	T("Sun"), T("Mon"), T("Tue"), T("Wed"), T("Thu"), T("Fri"), T("Sat")
+    T("Sun"), T("Mon"), T("Tue"), T("Wed"), T("Thu"), T("Fri"), T("Sat")
 };
 
 static char_t ceCwd[LF_PATHSIZE];
@@ -87,56 +87,56 @@ int _wchdir(unsigned short *path);
 
 uid_t geteuid(void)
 {
-	return 0;
-}
-
-/******************************************************************************/
-
-int	getopt(int argc, char_t* const * argv, const char_t* opts)
-{
-	char_t		*cp;
-	char_t		noswitch[3];
-	static int	sp = 1;
-	int			c;
-
-	gstrnset(noswitch, optswi, 2);
-	noswitch[2]=0;
-	if (sp == 1) {
-		if (optind >= argc ||
-			argv[optind][0] != optswi || argv[optind][1] == '\0') {
-			return(EOF);
-		}
-		else if (gstrcmp(argv[optind], noswitch) == 0) {
-			optind++;
-			return(EOF);
-		}
-	}
-	optopt = c = argv[optind][sp];
-	if (c == ':' || (cp = gstrchr(opts, (char_t) c)) == NULL) {
-		if (argv[optind][++sp] == '\0') {
-			optind++;
-			sp = 1;
-		}
-		return('?');
-	}
-	if (*++cp == ':') {
-		if (argv[optind][sp+1] != '\0') {
-			optarg = &argv[optind++][sp+1];
-		} else if (++optind >= argc) {
-			sp = 1;
-			return('?');
-		} else {
-			optarg = argv[optind++];
-		}
-		sp = 1;
-	} else {
-		if (argv[optind][++sp] == '\0') {
-			sp = 1;
-			optind++;
-		}
-		optarg = NULL;
-	}
-	return(c);
+    return 0;
+}
+
+/******************************************************************************/
+
+int getopt(int argc, char_t* const * argv, const char_t* opts)
+{
+    char_t      *cp;
+    char_t      noswitch[3];
+    static int  sp = 1;
+    int         c;
+
+    gstrnset(noswitch, optswi, 2);
+    noswitch[2]=0;
+    if (sp == 1) {
+        if (optind >= argc ||
+            argv[optind][0] != optswi || argv[optind][1] == '\0') {
+            return(EOF);
+        }
+        else if (gstrcmp(argv[optind], noswitch) == 0) {
+            optind++;
+            return(EOF);
+        }
+    }
+    optopt = c = argv[optind][sp];
+    if (c == ':' || (cp = gstrchr(opts, (char_t) c)) == NULL) {
+        if (argv[optind][++sp] == '\0') {
+            optind++;
+            sp = 1;
+        }
+        return('?');
+    }
+    if (*++cp == ':') {
+        if (argv[optind][sp+1] != '\0') {
+            optarg = &argv[optind++][sp+1];
+        } else if (++optind >= argc) {
+            sp = 1;
+            return('?');
+        } else {
+            optarg = argv[optind++];
+        }
+        sp = 1;
+    } else {
+        if (argv[optind][++sp] == '\0') {
+            sp = 1;
+            optind++;
+        }
+        optarg = NULL;
+    }
+    return(c);
 }
 
 /******************************************************************************/
@@ -146,8 +146,8 @@ int	getopt(int argc, char_t* const * argv, const char_t* opts)
 
 unsigned sleep(unsigned s)
 {
-	Sleep(s * 1000);
-	return 0;
+    Sleep(s * 1000);
+    return 0;
 }
 
 /******************************************************************************/
@@ -157,586 +157,586 @@ unsigned sleep(unsigned s)
 
 long nap(long ms)
 {
-	Sleep(ms);
-	return 0;
+    Sleep(ms);
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Return the elapsed time in milli-seconds
+ *  Return the elapsed time in milli-seconds
  */
 
 time_t timeMsec()
 {
-	struct timeb	tbnow;
-	time_t			sec;
-	int				msec;
-	static time_t	start = 0;
-	static time_t	start_msec;
+    struct timeb    tbnow;
+    time_t          sec;
+    int             msec;
+    static time_t   start = 0;
+    static time_t   start_msec;
 
-	ftime(&tbnow);
-	if (start == 0) {
-		start = tbnow.time;
-		start_msec = tbnow.millitm;
-	}
-	sec = tbnow.time - start;
-	msec = tbnow.millitm - start_msec;
-	if (msec < 0) {
-		msec += 1000;
-		sec -= 1;
-	}
-	return sec * 1000 + msec;
+    ftime(&tbnow);
+    if (start == 0) {
+        start = tbnow.time;
+        start_msec = tbnow.millitm;
+    }
+    sec = tbnow.time - start;
+    msec = tbnow.millitm - start_msec;
+    if (msec < 0) {
+        msec += 1000;
+        sec -= 1;
+    }
+    return sec * 1000 + msec;
 }
 
 /******************************************************************************/
 /*
- *	We want the time in seconds since the start of the UNIX epoch (1970). We
- *	can get the number of 100-nanoseconds since 1601 (FILETIME). We simply
- *	convert this to seconds and subtract the number of seconds between 1601
- *	and 1970!
+ *  We want the time in seconds since the start of the UNIX epoch (1970). We
+ *  can get the number of 100-nanoseconds since 1601 (FILETIME). We simply
+ *  convert this to seconds and subtract the number of seconds between 1601
+ *  and 1970!
  */
 
-#define	SECS_BETWEEN_1601_AND_1970	3054510208
+#define SECS_BETWEEN_1601_AND_1970  3054510208
 
 static time_t fileTimeToUnixEpochTime(FILETIME f)
 {
-	ULARGE_INTEGER	uli;
+    ULARGE_INTEGER  uli;
 
-	uli.LowPart = f.dwLowDateTime;
-	uli.HighPart = f.dwHighDateTime;
-	uli.QuadPart /= 10000000;
+    uli.LowPart = f.dwLowDateTime;
+    uli.HighPart = f.dwHighDateTime;
+    uli.QuadPart /= 10000000;
 
-	return((time_t) uli.QuadPart - SECS_BETWEEN_1601_AND_1970);
+    return((time_t) uli.QuadPart - SECS_BETWEEN_1601_AND_1970);
 }
 
 /******************************************************************************/
 /*
- *	Mock the UNIX time() call!
+ *  Mock the UNIX time() call!
  */
 
 time_t time(time_t *timer)
 {
-	SYSTEMTIME		stime;
-	FILETIME		ftime;
-	time_t			tmp;
+    SYSTEMTIME      stime;
+    FILETIME        ftime;
+    time_t          tmp;
 
-	GetLocalTime(&stime);
-	SystemTimeToFileTime(&stime, &ftime);
-	tmp = fileTimeToUnixEpochTime(ftime);
-	if (timer != NULL) {
-		*timer = tmp;
-	}
-	return tmp;
+    GetLocalTime(&stime);
+    SystemTimeToFileTime(&stime, &ftime);
+    tmp = fileTimeToUnixEpochTime(ftime);
+    if (timer != NULL) {
+        *timer = tmp;
+    }
+    return tmp;
 }
 
 /******************************************************************************/
 /*
- *	Mock the UNIX localtime() call.
+ *  Mock the UNIX localtime() call.
  */
 
 struct tm* localtime(const time_t *timer)
 {
-	SYSTEMTIME		stime;
-	GetLocalTime(&stime);
-	
-	localtm.tm_sec = stime.wSecond;
-	localtm.tm_min = stime.wMinute;
-	localtm.tm_hour = stime.wHour;
-	localtm.tm_mday = stime.wDay;
-	localtm.tm_wday = stime.wDayOfWeek;
-	localtm.tm_mon = stime.wMonth - 1;
-	localtm.tm_year = stime.wYear - 1900;
+    SYSTEMTIME      stime;
+    GetLocalTime(&stime);
+    
+    localtm.tm_sec = stime.wSecond;
+    localtm.tm_min = stime.wMinute;
+    localtm.tm_hour = stime.wHour;
+    localtm.tm_mday = stime.wDay;
+    localtm.tm_wday = stime.wDayOfWeek;
+    localtm.tm_mon = stime.wMonth - 1;
+    localtm.tm_year = stime.wYear - 1900;
 /*
- *	The following values are not supported yet, but the hardcoded assignments
- *	should suffice.
+ *  The following values are not supported yet, but the hardcoded assignments
+ *  should suffice.
  */
-	localtm.tm_yday = -1;
-	localtm.tm_isdst = -1;
-	localtm.tm_tzadj = -1;
-	localtm.tm_name[0] = 0;
-	return &localtm;
+    localtm.tm_yday = -1;
+    localtm.tm_isdst = -1;
+    localtm.tm_tzadj = -1;
+    localtm.tm_name[0] = 0;
+    return &localtm;
 }
 
 #ifndef LITTLEFOOT
 /******************************************************************************/
 /*
- *	Mock the UNIX ctime() call.
+ *  Mock the UNIX ctime() call.
  */
 
 char_t* _wctime(const time_t *timer)
 {
-	SYSTEMTIME		stime;
-	FILETIME		ftime;
-	ULARGE_INTEGER	uli;
+    SYSTEMTIME      stime;
+    FILETIME        ftime;
+    ULARGE_INTEGER  uli;
 
-	uli.QuadPart = *timer * 10000000;
-	ftime.dwLowDateTime = uli.LowPart;
-	ftime.dwHighDateTime = uli.HighPart;
+    uli.QuadPart = *timer * 10000000;
+    ftime.dwLowDateTime = uli.LowPart;
+    ftime.dwHighDateTime = uli.HighPart;
 
-	if (FileTimeToSystemTime(&ftime, &stime) == 0) {
-		return NULL;
-	}
+    if (FileTimeToSystemTime(&ftime, &stime) == 0) {
+        return NULL;
+    }
 
-	wsprintf(localctime, T("%s %s %02d %02d:%02d:%02d %04d\n"),
-		days[stime.wDayOfWeek], months[stime.wMonth - 1], stime.wDay,
-		stime.wHour, stime.wMinute, stime.wSecond, stime.wYear);
-	return localctime;
+    wsprintf(localctime, T("%s %s %02d %02d:%02d:%02d %04d\n"),
+        days[stime.wDayOfWeek], months[stime.wMonth - 1], stime.wDay,
+        stime.wHour, stime.wMinute, stime.wSecond, stime.wYear);
+    return localctime;
 }
 
 /******************************************************************************/
 /*
- *	Our implementation of _wasctime.
+ *  Our implementation of _wasctime.
  */
 
 char_t *_wasctime(const struct tm *timeptr)
 {
-	static char_t	strTime[52];
+    static char_t   strTime[52];
 
-	wsprintf(strTime, T("%s %s %02d %02d:%02d:%02d %04d\n"),
-		days[timeptr->tm_wday], months[timeptr->tm_mon], timeptr->tm_mday,
-		timeptr->tm_hour, timeptr->tm_min, timeptr->tm_sec, 
-		(timeptr->tm_year + 1900));
+    wsprintf(strTime, T("%s %s %02d %02d:%02d:%02d %04d\n"),
+        days[timeptr->tm_wday], months[timeptr->tm_mon], timeptr->tm_mday,
+        timeptr->tm_hour, timeptr->tm_min, timeptr->tm_sec, 
+        (timeptr->tm_year + 1900));
 
-	return &strTime[0];
+    return &strTime[0];
 }
-#endif	/* !LITTLEFOOT */
+#endif  /* !LITTLEFOOT */
 
 /******************************************************************************/
 /*
- *	Mock the UNIX ftime() call.
+ *  Mock the UNIX ftime() call.
  */
 
 void ftime(struct timeb *tp)
 {
-	tp->time = time(NULL);
-	tp->millitm = 0;
-	return;
+    tp->time = time(NULL);
+    tp->millitm = 0;
+    return;
 #ifdef UNSUPPORTED
-	short timezone;			/* timezone, minutes west of GMT */
-	short dstflag;			/* daylight savings */
+    short timezone;         /* timezone, minutes west of GMT */
+    short dstflag;          /* daylight savings */
 #endif /* UNSUPPORTED */
 }
 
 /******************************************************************************/
 /*
- *	Open a file.
+ *  Open a file.
  */
 
 int _wopen(const char_t *path, int oflag, ...)
 {
-	HANDLE	hFile;
-	DWORD	dwDesiredAccess, dwShareMode, dwCreationDisposition;
-	fh_t	*fp;
-	int		fid;
-	char_t	*cwd, *filepath;
-
-	filepath = balloc(B_L, LF_PATHSIZE * sizeof(char_t));
-	cwd = balloc(B_L, LF_PATHSIZE * sizeof(char_t));
-
-	if ((*path != '/') && (*path != '\\')) {
-		cwd = _wgetcwd(cwd, LF_PATHSIZE);
-		if (cwd == NULL) {
-			return -1;
-		}
-		fmtAlloc(&filepath, LF_PATHSIZE, T("%s/%s"), cwd, path);
-	} else {
-		wcscpy(filepath, path);
-	}
-	
-	dwDesiredAccess = 0;
-	if (((oflag & 0xF) == O_RDONLY) || (oflag & O_RDWR)) {
-		dwDesiredAccess |= GENERIC_READ;
-	}
-	if (oflag & O_WRONLY || oflag & O_RDWR) {
-		dwDesiredAccess |= GENERIC_WRITE;
-	}
-	dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
-	if (oflag & O_CREAT) {
-		dwCreationDisposition = OPEN_ALWAYS;
-	} else {
-		dwCreationDisposition = OPEN_EXISTING;
-	}
-
-	if ((hFile = CreateFile(filepath, dwDesiredAccess, dwShareMode, NULL,
-			dwCreationDisposition, FILE_ATTRIBUTE_NORMAL, 
-			NULL)) == INVALID_HANDLE_VALUE) {
-		bfree(B_L, filepath);
-		bfree(B_L, cwd);
-		return -1;
-	}
-
-/*
- *	Get a file number to associate with the handle.
- */
-	if ((fid = hAllocEntry((void***) &f, &fMax, sizeof(fh_t))) < 0) {
-		bfree(B_L, filepath);
-		bfree(B_L, cwd);
-		return -1;
-	}
-	fp = f[fid];
-	fp->hand = hFile;
-	bfree(B_L, filepath);
-	bfree(B_L, cwd);
-
-	return fid;
-}
-
-/******************************************************************************/
-/*
- *	Close a file.
+    HANDLE  hFile;
+    DWORD   dwDesiredAccess, dwShareMode, dwCreationDisposition;
+    fh_t    *fp;
+    int     fid;
+    char_t  *cwd, *filepath;
+
+    filepath = balloc(B_L, LF_PATHSIZE * sizeof(char_t));
+    cwd = balloc(B_L, LF_PATHSIZE * sizeof(char_t));
+
+    if ((*path != '/') && (*path != '\\')) {
+        cwd = _wgetcwd(cwd, LF_PATHSIZE);
+        if (cwd == NULL) {
+            return -1;
+        }
+        fmtAlloc(&filepath, LF_PATHSIZE, T("%s/%s"), cwd, path);
+    } else {
+        wcscpy(filepath, path);
+    }
+    
+    dwDesiredAccess = 0;
+    if (((oflag & 0xF) == O_RDONLY) || (oflag & O_RDWR)) {
+        dwDesiredAccess |= GENERIC_READ;
+    }
+    if (oflag & O_WRONLY || oflag & O_RDWR) {
+        dwDesiredAccess |= GENERIC_WRITE;
+    }
+    dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
+    if (oflag & O_CREAT) {
+        dwCreationDisposition = OPEN_ALWAYS;
+    } else {
+        dwCreationDisposition = OPEN_EXISTING;
+    }
+
+    if ((hFile = CreateFile(filepath, dwDesiredAccess, dwShareMode, NULL,
+            dwCreationDisposition, FILE_ATTRIBUTE_NORMAL, 
+            NULL)) == INVALID_HANDLE_VALUE) {
+        bfree(B_L, filepath);
+        bfree(B_L, cwd);
+        return -1;
+    }
+
+/*
+ *  Get a file number to associate with the handle.
+ */
+    if ((fid = hAllocEntry((void***) &f, &fMax, sizeof(fh_t))) < 0) {
+        bfree(B_L, filepath);
+        bfree(B_L, cwd);
+        return -1;
+    }
+    fp = f[fid];
+    fp->hand = hFile;
+    bfree(B_L, filepath);
+    bfree(B_L, cwd);
+
+    return fid;
+}
+
+/******************************************************************************/
+/*
+ *  Close a file.
  */
 
 int close(int fid)
 {
-	fh_t	*fp;
+    fh_t    *fp;
 
-	a_assert(0 <= fid && fid < fMax);
-	fp = f[fid];
-	if (fp == NULL) {
-		return -1;
-	}
-	CloseHandle(fp->hand);
-	fMax = hFree((void***) &f, fid);
-	bfreeSafe(B_L, fp);
+    a_assert(0 <= fid && fid < fMax);
+    fp = f[fid];
+    if (fp == NULL) {
+        return -1;
+    }
+    CloseHandle(fp->hand);
+    fMax = hFree((void***) &f, fid);
+    bfreeSafe(B_L, fp);
 
-	return 0;
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Read bytes from a file.
+ *  Read bytes from a file.
  */
 
 int read(int fid, void *buf, unsigned int len)
 {
-	fh_t	*fp;
-	long	bytesRead;
+    fh_t    *fp;
+    long    bytesRead;
 
-	a_assert(0 <= fid && fid < fMax);
-	fp = f[fid];
-	if (fp == NULL) {
-		return -1;
-	}
+    a_assert(0 <= fid && fid < fMax);
+    fp = f[fid];
+    if (fp == NULL) {
+        return -1;
+    }
 
-	if (ReadFile(fp->hand, buf, len, &bytesRead, NULL) == 0) {
-		return -1;
-	}
-	return bytesRead;
+    if (ReadFile(fp->hand, buf, len, &bytesRead, NULL) == 0) {
+        return -1;
+    }
+    return bytesRead;
 }
 
 /******************************************************************************/
 /*
- *	Read from a file into a buffer, converting from Ascii to Unicode.
+ *  Read from a file into a buffer, converting from Ascii to Unicode.
  */
 
 int readAscToUni(int fid, void **buf, unsigned int len)
 {
-	fh_t	*fp;
-	long	bytesRead;
-	char_t	*uniBuf;
+    fh_t    *fp;
+    long    bytesRead;
+    char_t  *uniBuf;
 
-	a_assert(0 <= fid && fid < fMax);
-	fp = f[fid];
-	if (fp == NULL) {
-		return -1;
-	}
+    a_assert(0 <= fid && fid < fMax);
+    fp = f[fid];
+    if (fp == NULL) {
+        return -1;
+    }
 
-	if (ReadFile(fp->hand, *buf, len, &bytesRead, NULL) == 0) {
-		return -1;
-	}
+    if (ReadFile(fp->hand, *buf, len, &bytesRead, NULL) == 0) {
+        return -1;
+    }
 
-	uniBuf =  ballocAscToUni(*buf, len);
-	bfree(B_L, *buf);
-	*buf = uniBuf;
+    uniBuf =  ballocAscToUni(*buf, len);
+    bfree(B_L, *buf);
+    *buf = uniBuf;
 
-	return bytesRead;
+    return bytesRead;
 }
 
 /******************************************************************************/
 /*
- *	Write to a file.
+ *  Write to a file.
  */
 
 int write(int fid, void *buf, unsigned int len)
 {
-	fh_t	*fp;
-	long	bytesWritten;
+    fh_t    *fp;
+    long    bytesWritten;
 
-	a_assert(0 <= fid && fid < fMax);
-	fp = f[fid];
-	if (fp == NULL) {
-		return -1;
-	}
+    a_assert(0 <= fid && fid < fMax);
+    fp = f[fid];
+    if (fp == NULL) {
+        return -1;
+    }
 
-	if (WriteFile(fp->hand, buf, len, &bytesWritten, NULL) == 0) {
-		return -1;
-	}
-	return bytesWritten;
+    if (WriteFile(fp->hand, buf, len, &bytesWritten, NULL) == 0) {
+        return -1;
+    }
+    return bytesWritten;
 }
 
 /******************************************************************************/
 /*
- *	Write to a file, first converting from Unicode to Ascii.
+ *  Write to a file, first converting from Unicode to Ascii.
  */
 
 int writeUniToAsc(int fid, void *buf, unsigned int len)
 {
-	fh_t	*fp;
-	long	bytesWritten;
-	char	*asciiBuf;
+    fh_t    *fp;
+    long    bytesWritten;
+    char    *asciiBuf;
 
-	a_assert(0 <= fid && fid < fMax);
-	fp = f[fid];
-	if (fp == NULL) {
-		return -1;
-	}
+    a_assert(0 <= fid && fid < fMax);
+    fp = f[fid];
+    if (fp == NULL) {
+        return -1;
+    }
 
-	asciiBuf =  ballocUniToAsc(buf, len);
+    asciiBuf =  ballocUniToAsc(buf, len);
 
-	if (WriteFile(fp->hand, asciiBuf, len, &bytesWritten, NULL) == 0) {
-		bfree(B_L, asciiBuf);
-		return -1;
-	}
-	bfree(B_L, asciiBuf);
-	return bytesWritten;
+    if (WriteFile(fp->hand, asciiBuf, len, &bytesWritten, NULL) == 0) {
+        bfree(B_L, asciiBuf);
+        return -1;
+    }
+    bfree(B_L, asciiBuf);
+    return bytesWritten;
 }
 
 /******************************************************************************/
 /*
- *	Delete a file.
+ *  Delete a file.
  */
 
 int _wunlink(char_t *file)
 {
-	char_t	*cwd, *cwdFile;
+    char_t  *cwd, *cwdFile;
 
-	cwdFile = NULL;
-	if ((*file != '/') && (*file != '\\')) {
-		cwd = balloc(B_L, LF_PATHSIZE);
-		ggetcwd(cwd, LF_PATHSIZE / sizeof(char_t));
-		fmtAlloc(&cwdFile, LF_PATHSIZE / sizeof(char_t), T("%s/%s"), cwd, file);
-		bfree(B_L, cwd);
-		file = cwdFile;
-	}
+    cwdFile = NULL;
+    if ((*file != '/') && (*file != '\\')) {
+        cwd = balloc(B_L, LF_PATHSIZE);
+        ggetcwd(cwd, LF_PATHSIZE / sizeof(char_t));
+        fmtAlloc(&cwdFile, LF_PATHSIZE / sizeof(char_t), T("%s/%s"), cwd, file);
+        bfree(B_L, cwd);
+        file = cwdFile;
+    }
 
-	if (DeleteFile(file) != TRUE) {
-		bfreeSafe(B_L, cwdFile);
-		return -1;
-	}
-	bfreeSafe(B_L, cwdFile);
-	return 0;
+    if (DeleteFile(file) != TRUE) {
+        bfreeSafe(B_L, cwdFile);
+        return -1;
+    }
+    bfreeSafe(B_L, cwdFile);
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Create a new directory
+ *  Create a new directory
  */
 
 int _wmkdir(const char_t *path)
 {
-	char_t	*cwd, *cwdPath;
+    char_t  *cwd, *cwdPath;
 
-	cwdPath = NULL;
-	if ((*path != '/') && (*path != '\\')) {
-		cwd = balloc(B_L, LF_PATHSIZE);
-		ggetcwd(cwd, LF_PATHSIZE / sizeof(char_t));
-		fmtAlloc(&cwdPath, LF_PATHSIZE, T("%s/%s"), cwd, path);
-		bfree(B_L, cwd);
-		path = cwdPath;
-	}
+    cwdPath = NULL;
+    if ((*path != '/') && (*path != '\\')) {
+        cwd = balloc(B_L, LF_PATHSIZE);
+        ggetcwd(cwd, LF_PATHSIZE / sizeof(char_t));
+        fmtAlloc(&cwdPath, LF_PATHSIZE, T("%s/%s"), cwd, path);
+        bfree(B_L, cwd);
+        path = cwdPath;
+    }
 
-	if (CreateDirectory(path, NULL) == 0) {
-		bfreeSafe(B_L, cwdPath);
-		return -1;
-	}
-	bfreeSafe(B_L, cwdPath);
-	return 0;
+    if (CreateDirectory(path, NULL) == 0) {
+        bfreeSafe(B_L, cwdPath);
+        return -1;
+    }
+    bfreeSafe(B_L, cwdPath);
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Remove a directory
+ *  Remove a directory
  */
 
 int _wrmdir(const char_t *path)
 {
-	char_t	*cwd, *cwdPath;
+    char_t  *cwd, *cwdPath;
 
-	cwdPath = NULL;
-	if ((*path != '/') && (*path != '\\')) {
-		cwd = balloc(B_L, LF_PATHSIZE);
-		ggetcwd(cwd, LF_PATHSIZE / sizeof(char_t));
-		fmtAlloc(&cwdPath, LF_PATHSIZE, T("%s/%s"), cwd, path);
-		bfree(B_L, cwd);
-		path = cwdPath;
-	}
+    cwdPath = NULL;
+    if ((*path != '/') && (*path != '\\')) {
+        cwd = balloc(B_L, LF_PATHSIZE);
+        ggetcwd(cwd, LF_PATHSIZE / sizeof(char_t));
+        fmtAlloc(&cwdPath, LF_PATHSIZE, T("%s/%s"), cwd, path);
+        bfree(B_L, cwd);
+        path = cwdPath;
+    }
 
-	if (RemoveDirectory(path) == 0) {
-		bfreeSafe(B_L, cwdPath);
-		return -1;
-	}
-	bfreeSafe(B_L, cwdPath);
-	return 0;
+    if (RemoveDirectory(path) == 0) {
+        bfreeSafe(B_L, cwdPath);
+        return -1;
+    }
+    bfreeSafe(B_L, cwdPath);
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Get file information about an open file.
+ *  Get file information about an open file.
  */
 
 int fstat(int fid, struct _stat *sbuf)
 {
-	BY_HANDLE_FILE_INFORMATION	info;
-	long						size;
-	fh_t						*fp;
+    BY_HANDLE_FILE_INFORMATION  info;
+    long                        size;
+    fh_t                        *fp;
 
-	a_assert(0 <= fid && fid < fMax);
-	fp = f[fid];
-	if (fp == NULL || fp->hand == INVALID_HANDLE_VALUE) {
-		return -1;
-	}
+    a_assert(0 <= fid && fid < fMax);
+    fp = f[fid];
+    if (fp == NULL || fp->hand == INVALID_HANDLE_VALUE) {
+        return -1;
+    }
 
-	size = GetFileSize(fp->hand, NULL);
-	if (size == 0xFFFFFFFF) {
-		return -1;
-	}
-	sbuf->st_size = (int) size;
+    size = GetFileSize(fp->hand, NULL);
+    if (size == 0xFFFFFFFF) {
+        return -1;
+    }
+    sbuf->st_size = (int) size;
 
-	if (GetFileInformationByHandle(fp->hand, &info)) {
-		if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
-			sbuf->st_mode = S_IFDIR;
-		} else {
-			sbuf->st_mode = S_IFREG;
-		}
-		sbuf->st_mtime = fileTimeToUnixEpochTime(info.ftLastWriteTime);
-		return 0;
-	}
+    if (GetFileInformationByHandle(fp->hand, &info)) {
+        if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
+            sbuf->st_mode = S_IFDIR;
+        } else {
+            sbuf->st_mode = S_IFREG;
+        }
+        sbuf->st_mtime = fileTimeToUnixEpochTime(info.ftLastWriteTime);
+        return 0;
+    }
 
-	return -1;
+    return -1;
 }
 
 /******************************************************************************/
 /*
- *	Our implementation of wide character stat: get file information.
+ *  Our implementation of wide character stat: get file information.
  */
 
 int _wstat(char_t *filename, struct _stat *sbuf)
 {
-	DWORD	dwAttributes;
-	int		fid, rc;
+    DWORD   dwAttributes;
+    int     fid, rc;
 
-	memset(sbuf, 0, sizeof(struct _stat));
-	dwAttributes = GetFileAttributes(filename);
-	if (dwAttributes != 0xFFFFFFFF && dwAttributes & FILE_ATTRIBUTE_DIRECTORY) {
-		sbuf->st_mode = S_IFDIR;
-		return 0;
-	}
-	sbuf->st_mode = S_IFREG;
+    memset(sbuf, 0, sizeof(struct _stat));
+    dwAttributes = GetFileAttributes(filename);
+    if (dwAttributes != 0xFFFFFFFF && dwAttributes & FILE_ATTRIBUTE_DIRECTORY) {
+        sbuf->st_mode = S_IFDIR;
+        return 0;
+    }
+    sbuf->st_mode = S_IFREG;
 
-	if ((fid = _wopen(filename, 0, 0)) < 0) {
-		return -1;
-	}
+    if ((fid = _wopen(filename, 0, 0)) < 0) {
+        return -1;
+    }
 
-	rc = fstat(fid, sbuf);
-	close(fid);
+    rc = fstat(fid, sbuf);
+    close(fid);
 
-	return rc;		 
+    return rc;       
 }
 
 /******************************************************************************/
 /*
- *	Our implementation of wide character rename: change the name of a file.
+ *  Our implementation of wide character rename: change the name of a file.
  */
 
 int _wrename(const char_t *oldname, const char_t *newname)
 {
-	char_t	*cwd, *cwdOldname, *cwdNewname;
+    char_t  *cwd, *cwdOldname, *cwdNewname;
 
-	cwdOldname = cwd = NULL;
-	if ((*oldname != '/') && (*oldname != '\\')) {
-		cwd = balloc(B_L, LF_PATHSIZE);
-		ggetcwd(cwd, LF_PATHSIZE / sizeof(char_t));
-		fmtAlloc(&cwdOldname, LF_PATHSIZE, T("%s/%s"), cwd, oldname);
-		oldname = cwdOldname;
-	}
-	
-	cwdNewname = NULL;
-	if ((*newname != '/') && (*newname != '\\')) {
-		if (cwd != NULL) {
-			cwd = balloc(B_L, LF_PATHSIZE);
-			ggetcwd(cwd, LF_PATHSIZE / sizeof(char_t));
-		}
-		fmtAlloc(&cwdNewname, LF_PATHSIZE, T("%s/%s"), cwd, newname);
-		newname = cwdNewname;
-	}
+    cwdOldname = cwd = NULL;
+    if ((*oldname != '/') && (*oldname != '\\')) {
+        cwd = balloc(B_L, LF_PATHSIZE);
+        ggetcwd(cwd, LF_PATHSIZE / sizeof(char_t));
+        fmtAlloc(&cwdOldname, LF_PATHSIZE, T("%s/%s"), cwd, oldname);
+        oldname = cwdOldname;
+    }
+    
+    cwdNewname = NULL;
+    if ((*newname != '/') && (*newname != '\\')) {
+        if (cwd != NULL) {
+            cwd = balloc(B_L, LF_PATHSIZE);
+            ggetcwd(cwd, LF_PATHSIZE / sizeof(char_t));
+        }
+        fmtAlloc(&cwdNewname, LF_PATHSIZE, T("%s/%s"), cwd, newname);
+        newname = cwdNewname;
+    }
 
-	if (MoveFile(oldname, newname) == 0) {
-		bfreeSafe(B_L, cwdOldname);
-		bfreeSafe(B_L, cwdNewname);
-		bfreeSafe(B_L, cwd);
-		return 1;
-	} else {
-		bfreeSafe(B_L, cwdOldname);
-		bfreeSafe(B_L, cwdNewname);
-		bfreeSafe(B_L, cwd);
-		return 0;
-	}
+    if (MoveFile(oldname, newname) == 0) {
+        bfreeSafe(B_L, cwdOldname);
+        bfreeSafe(B_L, cwdNewname);
+        bfreeSafe(B_L, cwd);
+        return 1;
+    } else {
+        bfreeSafe(B_L, cwdOldname);
+        bfreeSafe(B_L, cwdNewname);
+        bfreeSafe(B_L, cwd);
+        return 0;
+    }
 }
 
 /******************************************************************************/
 /*
- *	Our implementation of wide character access: get file access permission.
+ *  Our implementation of wide character access: get file access permission.
  */
 
 int _waccess(const unsigned short *path, int mode)
 {
-	int	fid, omode;
+    int fid, omode;
 
-	if (mode == R_OK) {
-		omode = O_RDONLY;
-	} else if (mode == W_OK) {
-		omode = O_RDWR;
-	} else {
-		a_assert(0);
-	}
-	if ((fid = _wopen(path, omode)) < 0) {
-		return -1;
-	}
-	close(fid);
-	return 0;
+    if (mode == R_OK) {
+        omode = O_RDONLY;
+    } else if (mode == W_OK) {
+        omode = O_RDWR;
+    } else {
+        a_assert(0);
+    }
+    if ((fid = _wopen(path, omode)) < 0) {
+        return -1;
+    }
+    close(fid);
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Support for stream I/O. The only way we supply a FILE* is via fdopen. In
- *	this case we return the real file handle.
+ *  Support for stream I/O. The only way we supply a FILE* is via fdopen. In
+ *  this case we return the real file handle.
  */
 
 FILE* fdopen(int handle, const unsigned short *mode)
 {
-	return (FILE*) handle;
+    return (FILE*) handle;
 }
 
 #if 0
 int fclose(FILE *stream)
 {
-	fh_t	*fp;
-	int		fid;
+    fh_t    *fp;
+    int     fid;
 
-	for (fid = 0; fid > fMax; fid++) {
-		if ((fp = f[fid]) != NULL) {
-			if (fp->hand == stream) {
-				close(fid);
-				return 0;
-			}
-		}
-	}
-	return EOF;
+    for (fid = 0; fid > fMax; fid++) {
+        if ((fp = f[fid]) != NULL) {
+            if (fp->hand == stream) {
+                close(fid);
+                return 0;
+            }
+        }
+    }
+    return EOF;
 }
 
 int fflush(FILE* stream)
 {
-	return 0;
+    return 0;
 }
 #endif /* 0 */
 
@@ -746,20 +746,20 @@ int fflush(FILE* stream)
  */
 long lseek(int handle, long offset, int origin)
 {
-	fh_t	*fp;
+    fh_t    *fp;
 
-	fp = f[handle];
-	return SetFilePointer(fp->hand, offset, NULL, origin);
+    fp = f[handle];
+    return SetFilePointer(fp->hand, offset, NULL, origin);
 }
 
 /******************************************************************************/
 /*
- *	A bunch of ASCII character routines.
+ *  A bunch of ASCII character routines.
  */
 
 /******************************************************************************/
 /*
- *	Our implementation of isupper.
+ *  Our implementation of isupper.
  */
 #if 0
 /* 10 Apr 03 BgP -- CE.NET work. The following functions are now directly supported by CE, 
@@ -767,77 +767,77 @@ long lseek(int handle, long offset, int origin)
 */
 int isupper(int c)
 {
-	if (c >= 'A' && c <= 'Z') {
-		return 1;
-	}
-	return 0;
+    if (c >= 'A' && c <= 'Z') {
+        return 1;
+    }
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Our implementation of islower.
+ *  Our implementation of islower.
  */
 
 int islower(int c)
 {
-	if (c >= 'a' && c <= 'z') {
-		return 1;
-	}
-	return 0;
+    if (c >= 'a' && c <= 'z') {
+        return 1;
+    }
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Our implementation of isdigit.
+ *  Our implementation of isdigit.
  */
 
 int isdigit(int c)
 {
-	if (c >= '0' && c <= '9') {
-		return 1;
-	}
-	return 0;
+    if (c >= '0' && c <= '9') {
+        return 1;
+    }
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Our implementation of isspace.
+ *  Our implementation of isspace.
  */
 
 int isspace(int c)
 {
-	if (c >= 0x9 && c <= 0xd || c == 0x20) {
-		return 1;
-	}
-	return 0;
+    if (c >= 0x9 && c <= 0xd || c == 0x20) {
+        return 1;
+    }
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Our implementation of isprint.
+ *  Our implementation of isprint.
  */
 
 int isprint(int c)
 {
-	if (c >= 0x20 && c <= 0x7e) {
-		return 1;
-	}
-	return 0;
+    if (c >= 0x20 && c <= 0x7e) {
+        return 1;
+    }
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Our implementation of isxdigit.
+ *  Our implementation of isxdigit.
  */
 
 int isxdigit(int c)
 {
-	if ((c >= '0' && c <= '9') ||
-		(c >= 'a' && c <= 'f') ||
-		(c >= 'A' && c <= 'F')) {
-		return 1;
-	}
-	return 0;
+    if ((c >= '0' && c <= '9') ||
+        (c >= 'a' && c <= 'f') ||
+        (c >= 'A' && c <= 'F')) {
+        return 1;
+    }
+    return 0;
 }
 
 #endif
@@ -846,7 +846,7 @@ int isxdigit(int c)
 #ifndef LITTLEFOOT
 int umask(int mode)
 {
-	return 0;
+    return 0;
 }
 #endif
 
@@ -857,145 +857,145 @@ int umask(int mode)
 #if 0
 int wprintf(const char_t *fmt, ...)
 {
-	return 0;
+    return 0;
 }
 #endif
 
 #if 0
 int fwprintf(FILE *stream, const char_t *fmt, ...)
 {
-	return 0;
+    return 0;
 }
 
 int fputws(const char_t *fmt, FILE *stream)
 {
-	return 0;
+    return 0;
 }
 #endif /* 0 */
 
 #ifndef LITTLEFOOT
 int _wexecvp(char_t *path, char_t** argv)
 {
-	return -1;
+    return -1;
 }
 #endif
 
 /******************************************************************************/
 /*
- *	Return the current working directory
+ *  Return the current working directory
  */
 
 char_t *_wgetcwd(char_t *dir, int len)
 {
-	if (len > LF_PATHSIZE) {
-		return NULL;
-	} else {
-		return wcscpy(dir, ceCwd);
-	}
+    if (len > LF_PATHSIZE) {
+        return NULL;
+    } else {
+        return wcscpy(dir, ceCwd);
+    }
 }
 
 /******************************************************************************/
 /*
- *	Change the current working directory
+ *  Change the current working directory
  */
 
 int _wchdir(unsigned short *path)
 {
-	char_t	*p;
-	char_t	buf[LF_PATHSIZE];
-	int		len;
-	gstat_t	statDir;
-
-/*
- *	Ignore leading spaces
- */
-	while(*path == ' ') {
-		path++;
-	}
-
-	if (path == NULL || *path == '\0') {
-		return -1;
-	} else if ((*path == '/') || (*path == '\\')) {
-		 wcscpy(ceCwd, path);
-	} else {
-/*
- *		Otherwise, it's a relative path.  Combine with current path.
- *		Append a '/' if the last character is not already a '/'.
- *		Check for leading "./" or "../" and back up the cwd accordingly.
- */
-
-		for (p = path; *p; p++) {
-			if (*p == '\\') {
-				*p = '/';
-			}
-		}
-
-		gstrcpy(buf, ceCwd);
-		for (p = buf; *p; p++) {
-			if (*p == '\\') {
-				*p = '/';
-			}
-		}
-
-		if (*path == '.' && *(path+1) == '/') {
-			path++;
-			while (*path == '/') {
-				path++;
-			}
-		}
-		while (*path == '.' && *(path+1) == '.') {
-			path += 2;
-			if ((p = wcsrchr(buf, '/')) == NULL) {
-				return -1;
-			}
-			*p = '\0';
-			if (*path == '\0') {
-				break;
-			}
-			if (*path != '/') {
-				return -1;
-			}
-			while (*path == '/') {
-				path++;
-			}
-		}
-/*
- *		Ignore leading spaces and dots
- */
-		while(*path == '.' || *path == ' ') {
-			path++;
-		}
-
-/*
- *		Append to cwd.
- */
-		len = wcslen(buf);
-		if (*(buf + len - 1) != '/') {
-			*(buf + len) = '/';
-			*(buf + len + 1) = '\0';
-			len++;
-		}
-		if ((len + gstrlen(path) + 1) > LF_PATHSIZE ) {
-			return -1;
-		}
-		gstrcpy(buf+len, path);
-
-		if (_wstat(buf, &statDir) == -1) {
-			return -1;
-		}
-		gstrcpy(ceCwd, buf);
-	}
-	return 0;
-}
-
-/******************************************************************************/
-/*
- *	Change the file-permission settings
+    char_t  *p;
+    char_t  buf[LF_PATHSIZE];
+    int     len;
+    gstat_t statDir;
+
+/*
+ *  Ignore leading spaces
+ */
+    while(*path == ' ') {
+        path++;
+    }
+
+    if (path == NULL || *path == '\0') {
+        return -1;
+    } else if ((*path == '/') || (*path == '\\')) {
+         wcscpy(ceCwd, path);
+    } else {
+/*
+ *      Otherwise, it's a relative path.  Combine with current path.
+ *      Append a '/' if the last character is not already a '/'.
+ *      Check for leading "./" or "../" and back up the cwd accordingly.
+ */
+
+        for (p = path; *p; p++) {
+            if (*p == '\\') {
+                *p = '/';
+            }
+        }
+
+        gstrcpy(buf, ceCwd);
+        for (p = buf; *p; p++) {
+            if (*p == '\\') {
+                *p = '/';
+            }
+        }
+
+        if (*path == '.' && *(path+1) == '/') {
+            path++;
+            while (*path == '/') {
+                path++;
+            }
+        }
+        while (*path == '.' && *(path+1) == '.') {
+            path += 2;
+            if ((p = wcsrchr(buf, '/')) == NULL) {
+                return -1;
+            }
+            *p = '\0';
+            if (*path == '\0') {
+                break;
+            }
+            if (*path != '/') {
+                return -1;
+            }
+            while (*path == '/') {
+                path++;
+            }
+        }
+/*
+ *      Ignore leading spaces and dots
+ */
+        while(*path == '.' || *path == ' ') {
+            path++;
+        }
+
+/*
+ *      Append to cwd.
+ */
+        len = wcslen(buf);
+        if (*(buf + len - 1) != '/') {
+            *(buf + len) = '/';
+            *(buf + len + 1) = '\0';
+            len++;
+        }
+        if ((len + gstrlen(path) + 1) > LF_PATHSIZE ) {
+            return -1;
+        }
+        gstrcpy(buf+len, path);
+
+        if (_wstat(buf, &statDir) == -1) {
+            return -1;
+        }
+        gstrcpy(ceCwd, buf);
+    }
+    return 0;
+}
+
+/******************************************************************************/
+/*
+ *  Change the file-permission settings
  */
 
 int _wchmod(const char_t *filename, int pmode)
 {
-	return 0;
+    return 0;
 }
 
 /******************************************************************************/
diff --git a/CE/wincompat.h b/CE/wincompat.h
index 7f03ed4a..4da8696e 100644
--- a/CE/wincompat.h
+++ b/CE/wincompat.h
@@ -1,7 +1,7 @@
 /*
- *	wincompat.h -- GoAhead compatibility header for CE
+ *  wincompat.h -- GoAhead compatibility header for CE
  *
- *	Copyright (c) Go Ahead Software, Inc., 1995-2010
+ *  Copyright (c) Go Ahead Software, Inc., 1995-2010
  *
  */
 
@@ -13,11 +13,11 @@
  */
 typedef void FILE;
 
-#define		BUFSIZ		1024
-#define		PATHSIZE	1024
+#define     BUFSIZ      1024
+#define     PATHSIZE    1024
 
 /*
- *	Declarations for the CE compatability functions we are providing.
+ *  Declarations for the CE compatability functions we are providing.
  */
 void exit(int status);
 int _wmkdir(const unsigned short *path);
@@ -33,17 +33,17 @@ extern long lseek(int handle, long offset, int origin);
 /*
  * the following replaces fcntl.h
  */
-#define O_RDONLY	0x0
-#define O_WRONLY	0x1
-#define O_RDWR		0x2
-#define O_ACCMODE	0x3		/* Mask for O_RDONLY | O_WRONLY | O_RDWR */
-#define O_NDELAY	0x4		/* Non-blocking I/O */
-#define O_APPEND	0x8		/* append (writes guaranteed at the end) */
-#define O_NONBLOCK	0x10	/* Non-blocking I/0, but different effect */
-#define O_BINARY	0x20
-#define O_CREAT		0x40
-#define O_TRUNC		0x80
-#define O_NOCTTY	0x100
+#define O_RDONLY    0x0
+#define O_WRONLY    0x1
+#define O_RDWR      0x2
+#define O_ACCMODE   0x3     /* Mask for O_RDONLY | O_WRONLY | O_RDWR */
+#define O_NDELAY    0x4     /* Non-blocking I/O */
+#define O_APPEND    0x8     /* append (writes guaranteed at the end) */
+#define O_NONBLOCK  0x10    /* Non-blocking I/0, but different effect */
+#define O_BINARY    0x20
+#define O_CREAT     0x40
+#define O_TRUNC     0x80
+#define O_NOCTTY    0x100
 
 extern int _wopen(const unsigned short* filename, int oflag, ...);
 extern int read(int handle, void* buffer, unsigned int count);
@@ -55,13 +55,13 @@ extern FILE* fdopen(int handle, const unsigned short* mode);
 /*
  * The following replaces getopt.h
  */
-extern int	getopt(int, unsigned short * const *, const unsigned short *);
+extern int  getopt(int, unsigned short * const *, const unsigned short *);
 
 /*
  * the following replaces io.h and types.h
  */
-#undef	u_long
-#undef	u_short
+#undef  u_long
+#undef  u_short
 
 typedef unsigned short mode_t;
 typedef unsigned char u_char;
@@ -92,11 +92,11 @@ int umask(int mode);
 /* 10 Apr 03 BgP -- CE.NET work. The following functions are now directly supported by CE, 
    so we do not need these compatibility versions.
 */
-int	isupper(int c);
-int	islower(int c);
-int	isdigit(int c);
-int	isspace(int c);
-int	isprint(int c);
+int isupper(int c);
+int islower(int c);
+int isdigit(int c);
+int isspace(int c);
+int isprint(int c);
 int isxdigit(int c);
 #endif
 /*
@@ -104,16 +104,16 @@ int isxdigit(int c);
  */
 struct _stat {
 #if 0
-	unsigned long st_size;	/* file size in bytes				*/
-	unsigned long st_mode;
+    unsigned long st_size;  /* file size in bytes               */
+    unsigned long st_mode;
 #else
    /* 11 Apr 03 BgP -- fixing an unsigned/signed comparison error */
-	long st_size;	/* file size in bytes				*/
-	long st_mode;
+    long st_size;   /* file size in bytes               */
+    long st_mode;
 #endif
-	time_t st_atime;		/* time of last access				*/
-	time_t st_mtime;		/* time of last data modification	*/
-	time_t st_ctime;		/* time of last file status change	*/
+    time_t st_atime;        /* time of last access              */
+    time_t st_mtime;        /* time of last data modification   */
+    time_t st_ctime;        /* time of last file status change  */
 };
 
 #define         S_IFREG 0100000
@@ -123,14 +123,14 @@ extern int _wstat(unsigned short* path, struct _stat* buffer);
 extern int fstat(int filenumber, struct _stat* buffer);
 
 /*
- *	The following replaces errno.h
+ *  The following replaces errno.h
  */
 
-#define EINTR		4
-#define ENXIO		6
-#define EBADF		9
-#define EAGAIN		11
-#define EINVAL		22
+#define EINTR       4
+#define ENXIO       6
+#define EBADF       9
+#define EAGAIN      11
+#define EINVAL      22
 
 extern int errno;
 
@@ -139,18 +139,18 @@ extern int errno;
  */
 struct tm
 {
-	int tm_sec;
-	int tm_min;
-	int tm_hour;
-	int tm_mday;
-	int tm_mon;
-	int tm_year;
-	int tm_wday;
-	int tm_yday;
-	int tm_isdst;
+    int tm_sec;
+    int tm_min;
+    int tm_hour;
+    int tm_mday;
+    int tm_mon;
+    int tm_year;
+    int tm_wday;
+    int tm_yday;
+    int tm_isdst;
 #define LTZNMAX 50
-	long tm_tzadj;
-	char tm_name[LTZNMAX];	/* name of timezone	*/
+    long tm_tzadj;
+    char tm_name[LTZNMAX];  /* name of timezone */
 };
 
 
@@ -164,10 +164,10 @@ extern unsigned short *_wasctime(const struct tm *timeptr);
  */
 struct timeb {
 
-	time_t time;			/* time, seconds since the epoch */
-	unsigned short millitm;	/* 1000 msec of additional accuracy */
-	short timezone;			/* timezone, minutes west of GMT */
-	short dstflag;			/* daylight savings */
+    time_t time;            /* time, seconds since the epoch */
+    unsigned short millitm; /* 1000 msec of additional accuracy */
+    short timezone;         /* timezone, minutes west of GMT */
+    short dstflag;          /* daylight savings */
 };
 
 extern void ftime(struct timeb* tp);
@@ -179,10 +179,10 @@ extern long nap(long);
 extern unsigned int sleep(unsigned int secs);
 extern uid_t geteuid(void);
 
-#define R_OK	4
-#define W_OK	2
-#define X_OK	1
-#define F_OK	0
+#define R_OK    4
+#define W_OK    2
+#define X_OK    1
+#define F_OK    0
 
 extern char* strdup(const char *s);
 
diff --git a/ECOS/main.c b/ECOS/main.c
index ee1ce40f..c81fcb99 100644
--- a/ECOS/main.c
+++ b/ECOS/main.c
@@ -10,8 +10,8 @@
 /******************************** Description *********************************/
 
 /*
- *	Main program for for the GoAhead WebServer. This is a demonstration
- *	main program to initialize and configure the web server.
+ *  Main program for for the GoAhead WebServer. This is a demonstration
+ *  main program to initialize and configure the web server.
  */
 
 /********************************* Includes ***********************************/
@@ -23,21 +23,21 @@
 
 /*********************************** Locals ***********************************/
 /*
- *	Change configuration here
+ *  Change configuration here
  */
 
-static char_t	*password = T("");	/* Security password */
-static int		port = 80;			/* Server port */
-static int		retries = 5;		/* Server port retries */
-static int		finished;			/* Finished flag */
+static char_t   *password = T("");  /* Security password */
+static int      port = 80;          /* Server port */
+static int      retries = 5;        /* Server port retries */
+static int      finished;           /* Finished flag */
 
 /****************************** Forward Declarations **************************/
 
-static int 	initWebs();
-static int	aspTest(int eid, webs_t wp, int argc, char_t **argv);
+static int  initWebs();
+static int  aspTest(int eid, webs_t wp, int argc, char_t **argv);
 static void formTest(webs_t wp, char_t *path, char_t *query);
 static int  websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
-				int arg, char_t* url, char_t* path, char_t* query);
+                int arg, char_t* url, char_t* path, char_t* query);
 
 #ifdef B_STATS
 #error WARNING:  B_STATS directive is not supported in this OS!
@@ -45,175 +45,175 @@ static int  websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
 
 /*********************************** Code *************************************/
 /*
- *	Main -- entry point from eCos
+ *  Main -- entry point from eCos
  */
 
 int main(int argc, char** argv)
 {
 /*
- *	Initialize the memory allocator. Allow use of malloc and start 
- *	with a 60K heap.  For each page request approx 8KB is allocated.
- *	60KB allows for several concurrent page requests.  If more space
- *	is required, malloc will be used for the overflow.
+ *  Initialize the memory allocator. Allow use of malloc and start 
+ *  with a 60K heap.  For each page request approx 8KB is allocated.
+ *  60KB allows for several concurrent page requests.  If more space
+ *  is required, malloc will be used for the overflow.
  */
-	bopen(NULL, (60 * 1024), B_USE_MALLOC);
+    bopen(NULL, (60 * 1024), B_USE_MALLOC);
 
 /*
- *	Initialize the web server
+ *  Initialize the web server
  */
-	if (initWebs() < 0) {
-		return -1;
-	}
+    if (initWebs() < 0) {
+        return -1;
+    }
 
 /*
- *	Basic event loop. SocketReady returns true when a socket is ready for
- *	service. SocketSelect will block until an event occurs. SocketProcess
- *	will actually do the servicing.
+ *  Basic event loop. SocketReady returns true when a socket is ready for
+ *  service. SocketSelect will block until an event occurs. SocketProcess
+ *  will actually do the servicing.
  */
-	while (!finished) {
-		if (socketReady(-1) || socketSelect(-1, 2000)) {
-			socketProcess(-1);
-		}
-		emfSchedProcess();
-	}
+    while (!finished) {
+        if (socketReady(-1) || socketSelect(-1, 2000)) {
+            socketProcess(-1);
+        }
+        emfSchedProcess();
+    }
 
 /*
- *	Close the socket module, report memory leaks and close the memory allocator
+ *  Close the socket module, report memory leaks and close the memory allocator
  */
-	websCloseServer();
-	socketClose();
-	bclose();
-	return 0;
+    websCloseServer();
+    socketClose();
+    bclose();
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Initialize the web server.
+ *  Initialize the web server.
  */
 
 static int initWebs()
 {
-	char		host[128];
-	char		*cp;
-	char_t		wbuf[128];
+    char        host[128];
+    char        *cp;
+    char_t      wbuf[128];
 
 /*
- *	Initialize networking.
+ *  Initialize networking.
  */
 
-	init_all_network_interfaces();
+    init_all_network_interfaces();
 
 /*
- *	Initialize the socket subsystem
+ *  Initialize the socket subsystem
  */
-	socketOpen();
+    socketOpen();
 
 /*
- *	Configure the web server options before opening the web server
+ *  Configure the web server options before opening the web server
  */
-	websSetDefaultDir("/www");
-	cp = inet_ntoa(eth0_bootp_data.bp_yiaddr);
-	ascToUni(wbuf, cp, min(strlen(cp) + 1, sizeof(wbuf)));
-	websSetIpaddr(wbuf);
-	ascToUni(wbuf, host, min(strlen(host) + 1, sizeof(wbuf)));
-	websSetHost(wbuf);
+    websSetDefaultDir("/www");
+    cp = inet_ntoa(eth0_bootp_data.bp_yiaddr);
+    ascToUni(wbuf, cp, min(strlen(cp) + 1, sizeof(wbuf)));
+    websSetIpaddr(wbuf);
+    ascToUni(wbuf, host, min(strlen(host) + 1, sizeof(wbuf)));
+    websSetHost(wbuf);
 
 /*
- *	Configure the web server options before opening the web server
+ *  Configure the web server options before opening the web server
  */
-	websSetDefaultPage(T("home.htm"));
-	websSetPassword(password);
+    websSetDefaultPage(T("home.htm"));
+    websSetPassword(password);
 
 /* 
- *	Open the web server on the given port. If that port is taken, try
- *	the next sequential port for up to "retries" attempts.
+ *  Open the web server on the given port. If that port is taken, try
+ *  the next sequential port for up to "retries" attempts.
  */
-	websOpenServer(port, retries);
+    websOpenServer(port, retries);
 
 /*
- * 	First create the URL handlers. Note: handlers are called in sorted order
- *	with the longest path handler examined first. Here we define the security 
- *	handler, forms handler and the default web page handler.
+ *  First create the URL handlers. Note: handlers are called in sorted order
+ *  with the longest path handler examined first. Here we define the security 
+ *  handler, forms handler and the default web page handler.
  */
-	websUrlHandlerDefine(T(""), NULL, 0, websSecurityHandler, 
-		WEBS_HANDLER_FIRST);
-	websUrlHandlerDefine(T("/goform"), NULL, 0, websFormHandler, 0);
-	websUrlHandlerDefine(T(""), NULL, 0, websDefaultHandler, 
-		WEBS_HANDLER_LAST); 
+    websUrlHandlerDefine(T(""), NULL, 0, websSecurityHandler, 
+        WEBS_HANDLER_FIRST);
+    websUrlHandlerDefine(T("/goform"), NULL, 0, websFormHandler, 0);
+    websUrlHandlerDefine(T(""), NULL, 0, websDefaultHandler, 
+        WEBS_HANDLER_LAST); 
 
 /*
- *	Now define two test procedures. Replace these with your application
- *	relevant ASP script procedures and form functions.
+ *  Now define two test procedures. Replace these with your application
+ *  relevant ASP script procedures and form functions.
  */
-	websAspDefine(T("aspTest"), aspTest);
-	websFormDefine(T("formTest"), formTest);
+    websAspDefine(T("aspTest"), aspTest);
+    websFormDefine(T("formTest"), formTest);
 
 /*
- *	Create a handler for the default home page
+ *  Create a handler for the default home page
  */
-	websUrlHandlerDefine(T("/"), NULL, 0, websHomePageHandler, 0); 
-	return 0;
+    websUrlHandlerDefine(T("/"), NULL, 0, websHomePageHandler, 0); 
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Test Javascript binding for ASP. This will be invoked when "aspTest" is
- *	embedded in an ASP page. See web/asp.asp for usage. Set browser to 
- *	"localhost/asp.asp" to test.
+ *  Test Javascript binding for ASP. This will be invoked when "aspTest" is
+ *  embedded in an ASP page. See web/asp.asp for usage. Set browser to 
+ *  "localhost/asp.asp" to test.
  */
 
 static int aspTest(int eid, webs_t wp, int argc, char_t **argv)
 {
-	char_t	*name, *address;
+    char_t  *name, *address;
 
-	if (ejArgs(argc, argv, T("%s %s"), &name, &address) < 2) {
-		websError(wp, 400, T("Insufficient args\n"));
-		return -1;
-	}
+    if (ejArgs(argc, argv, T("%s %s"), &name, &address) < 2) {
+        websError(wp, 400, T("Insufficient args\n"));
+        return -1;
+    }
 
-	return websWrite(wp, T("Name: %s, Address %s"), name, address);
+    return websWrite(wp, T("Name: %s, Address %s"), name, address);
 }
 
 /******************************************************************************/
 /*
- *	Test form for posted data (in-memory CGI). This will be called when the
- *	form in web/forms.asp is invoked. Set browser to "localhost/forms.asp" to test.
+ *  Test form for posted data (in-memory CGI). This will be called when the
+ *  form in web/forms.asp is invoked. Set browser to "localhost/forms.asp" to test.
  */
 
 static void formTest(webs_t wp, char_t *path, char_t *query)
 {
-	char_t	*name, *address;
+    char_t  *name, *address;
 
-	name = websGetVar(wp, T("name"), T("Joe Smith")); 
-	address = websGetVar(wp, T("address"), T("1212 Milky Way Ave.")); 
+    name = websGetVar(wp, T("name"), T("Joe Smith")); 
+    address = websGetVar(wp, T("address"), T("1212 Milky Way Ave.")); 
 
-	websHeader(wp);
-	websWrite(wp, T("<body><h2>Name: %s, Address: %s</h2>\n"), name, address);
-	websFooter(wp);
-	websDone(wp, 200);
+    websHeader(wp);
+    websWrite(wp, T("<body><h2>Name: %s, Address: %s</h2>\n"), name, address);
+    websFooter(wp);
+    websDone(wp, 200);
 }
 
 /******************************************************************************/
 /*
- *	Home page handler
+ *  Home page handler
  */
 
 static int websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
-	int arg, char_t* url, char_t* path, char_t* query)
+    int arg, char_t* url, char_t* path, char_t* query)
 {
 /*
- *	If the empty or "/" URL is invoked, redirect default URLs to the home page
+ *  If the empty or "/" URL is invoked, redirect default URLs to the home page
  */
-	if (*url == '\0' || gstrcmp(url, T("/")) == 0) {
-		websRedirect(wp, T("home.asp"));
-		return 1;
-	}
-	return 0;
+    if (*url == '\0' || gstrcmp(url, T("/")) == 0) {
+        websRedirect(wp, T("home.asp"));
+        return 1;
+    }
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Wrappers for depreciated socket I/O functions
+ *  Wrappers for depreciated socket I/O functions
  */
 
 int send(int s, const void *buf, size_t len, int flags)
diff --git a/LINUX/main.c b/LINUX/main.c
index 5f4623c9..9a85a539 100644
--- a/LINUX/main.c
+++ b/LINUX/main.c
@@ -10,47 +10,47 @@
 /******************************** Description *********************************/
 
 /*
- *	Main program for for the GoAhead WebServer.
+ *  Main program for for the GoAhead WebServer.
  */
 
 /********************************* Includes ***********************************/
 
-#include	"../uemf.h"
-#include	"../wsIntrn.h"
-#include	<signal.h>
-#include	<unistd.h> 
-#include	<sys/types.h>
+#include    "../uemf.h"
+#include    "../wsIntrn.h"
+#include    <signal.h>
+#include    <unistd.h> 
+#include    <sys/types.h>
 
 #ifdef WEBS_SSL_SUPPORT
-#include	"../websSSL.h"
+#include    "../websSSL.h"
 #endif
 
 #ifdef USER_MANAGEMENT_SUPPORT
-#include	"../um.h"
-void	formDefineUserMgmt(void);
+#include    "../um.h"
+void    formDefineUserMgmt(void);
 #endif
 
 
 /*********************************** Locals ***********************************/
 /*
- *	Change configuration here
+ *  Change configuration here
  */
 
-static char_t		*rootWeb = T("www");			/* Root web directory */
-static char_t		*demoWeb = T("wwwdemo");		/* Root web directory */
-static char_t		*password = T("");				/* Security password */
-static int			port = WEBS_DEFAULT_PORT;		/* Server port */
-static int			retries = 5;					/* Server port retries */
-static int			finished = 0;					/* Finished flag */
+static char_t       *rootWeb = T("www");            /* Root web directory */
+static char_t       *demoWeb = T("wwwdemo");        /* Root web directory */
+static char_t       *password = T("");              /* Security password */
+static int          port = WEBS_DEFAULT_PORT;       /* Server port */
+static int          retries = 5;                    /* Server port retries */
+static int          finished = 0;                   /* Finished flag */
 
 /****************************** Forward Declarations **************************/
 
-static int 	initWebs(int demo);
-static int	aspTest(int eid, webs_t wp, int argc, char_t **argv);
+static int  initWebs(int demo);
+static int  aspTest(int eid, webs_t wp, int argc, char_t **argv);
 static void formTest(webs_t wp, char_t *path, char_t *query);
 static int  websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
-				int arg, char_t *url, char_t *path, char_t *query);
-static void	sigintHandler(int);
+                int arg, char_t *url, char_t *path, char_t *query);
+static void sigintHandler(int);
 #ifdef B_STATS
 static void printMemStats(int handle, char_t *fmt, ...);
 static void memLeaks();
@@ -58,247 +58,247 @@ static void memLeaks();
 
 /*********************************** Code *************************************/
 /*
- *	Main -- entry point from LINUX
+ *  Main -- entry point from LINUX
  */
 
 int main(int argc, char** argv)
 {
-	int i, demo = 0;
+    int i, demo = 0;
 
-	for (i = 1; i < argc; i++) {
-		if (strcmp(argv[i], "-demo") == 0) {
-			demo++;
-		}
-	}
+    for (i = 1; i < argc; i++) {
+        if (strcmp(argv[i], "-demo") == 0) {
+            demo++;
+        }
+    }
 
 /*
- *	Initialize the memory allocator. Allow use of malloc and start 
- *	with a 60K heap.  For each page request approx 8KB is allocated.
- *	60KB allows for several concurrent page requests.  If more space
- *	is required, malloc will be used for the overflow.
+ *  Initialize the memory allocator. Allow use of malloc and start 
+ *  with a 60K heap.  For each page request approx 8KB is allocated.
+ *  60KB allows for several concurrent page requests.  If more space
+ *  is required, malloc will be used for the overflow.
  */
-	bopen(NULL, (60 * 1024), B_USE_MALLOC);
-	signal(SIGPIPE, SIG_IGN);
-	signal(SIGINT, sigintHandler);
-	signal(SIGTERM, sigintHandler);
+    bopen(NULL, (60 * 1024), B_USE_MALLOC);
+    signal(SIGPIPE, SIG_IGN);
+    signal(SIGINT, sigintHandler);
+    signal(SIGTERM, sigintHandler);
 
 /*
- *	Initialize the web server
+ *  Initialize the web server
  */
-	if (initWebs(demo) < 0) {
-		return -1;
-	}
+    if (initWebs(demo) < 0) {
+        return -1;
+    }
 
 #ifdef WEBS_SSL_SUPPORT
-	websSSLOpen();
-/*	websRequireSSL("/"); */	/* Require all files be served via https */
+    websSSLOpen();
+/*  websRequireSSL("/"); */ /* Require all files be served via https */
 #endif
 
 /*
- *	Basic event loop. SocketReady returns true when a socket is ready for
- *	service. SocketSelect will block until an event occurs. SocketProcess
- *	will actually do the servicing.
+ *  Basic event loop. SocketReady returns true when a socket is ready for
+ *  service. SocketSelect will block until an event occurs. SocketProcess
+ *  will actually do the servicing.
  */
-	finished = 0;
-	while (!finished) {
-		if (socketReady(-1) || socketSelect(-1, 1000)) {
-			socketProcess(-1);
-		}
-		websCgiCleanup();
-		emfSchedProcess();
-	}
+    finished = 0;
+    while (!finished) {
+        if (socketReady(-1) || socketSelect(-1, 1000)) {
+            socketProcess(-1);
+        }
+        websCgiCleanup();
+        emfSchedProcess();
+    }
 
 #ifdef WEBS_SSL_SUPPORT
-	websSSLClose();
+    websSSLClose();
 #endif
 
 #ifdef USER_MANAGEMENT_SUPPORT
-	umClose();
+    umClose();
 #endif
 
 /*
- *	Close the socket module, report memory leaks and close the memory allocator
+ *  Close the socket module, report memory leaks and close the memory allocator
  */
-	websCloseServer();
-	socketClose();
+    websCloseServer();
+    socketClose();
 #ifdef B_STATS
-	memLeaks();
+    memLeaks();
 #endif
-	bclose();
-	return 0;
+    bclose();
+    return 0;
 }
 
 /*
- *	Exit cleanly on interrupt
+ *  Exit cleanly on interrupt
  */
 static void sigintHandler(int unused)
 {
-	finished = 1;
+    finished = 1;
 }
 
 /******************************************************************************/
 /*
- *	Initialize the web server.
+ *  Initialize the web server.
  */
 
 static int initWebs(int demo)
 {
-	struct hostent	*hp;
-	struct in_addr	intaddr;
-	char			host[128], dir[128], webdir[128];
-	char			*cp;
-	char_t			wbuf[128];
+    struct hostent  *hp;
+    struct in_addr  intaddr;
+    char            host[128], dir[128], webdir[128];
+    char            *cp;
+    char_t          wbuf[128];
 
 /*
- *	Initialize the socket subsystem
+ *  Initialize the socket subsystem
  */
-	socketOpen();
+    socketOpen();
 
 #ifdef USER_MANAGEMENT_SUPPORT
 /*
- *	Initialize the User Management database
+ *  Initialize the User Management database
  */
-	umOpen();
-	umRestore(T("umconfig.txt"));
+    umOpen();
+    umRestore(T("umconfig.txt"));
 #endif
 
 /*
- *	Define the local Ip address, host name, default home page and the 
- *	root web directory.
+ *  Define the local Ip address, host name, default home page and the 
+ *  root web directory.
  */
-	if (gethostname(host, sizeof(host)) < 0) {
-		error(E_L, E_LOG, T("Can't get hostname"));
-		return -1;
-	}
-	if ((hp = gethostbyname(host)) == NULL) {
-		error(E_L, E_LOG, T("Can't get host address"));
-		return -1;
-	}
-	memcpy((char *) &intaddr, (char *) hp->h_addr_list[0],
-		(size_t) hp->h_length);
+    if (gethostname(host, sizeof(host)) < 0) {
+        error(E_L, E_LOG, T("Can't get hostname"));
+        return -1;
+    }
+    if ((hp = gethostbyname(host)) == NULL) {
+        error(E_L, E_LOG, T("Can't get host address"));
+        return -1;
+    }
+    memcpy((char *) &intaddr, (char *) hp->h_addr_list[0],
+        (size_t) hp->h_length);
 
 /*
- *	Set ../web as the root web. Modify this to suit your needs
- *	A "-demo" option to the command line will set a webdemo root
+ *  Set ../web as the root web. Modify this to suit your needs
+ *  A "-demo" option to the command line will set a webdemo root
  */
-	getcwd(dir, sizeof(dir)); 
-	if ((cp = strrchr(dir, '/'))) {
-		*cp = '\0';
-	}
-	if (demo) {
-		sprintf(webdir, "%s/%s", dir, demoWeb);
-	} else {
-		sprintf(webdir, "%s/%s", dir, rootWeb);
-	}
+    getcwd(dir, sizeof(dir)); 
+    if ((cp = strrchr(dir, '/'))) {
+        *cp = '\0';
+    }
+    if (demo) {
+        sprintf(webdir, "%s/%s", dir, demoWeb);
+    } else {
+        sprintf(webdir, "%s/%s", dir, rootWeb);
+    }
 
 /*
- *	Configure the web server options before opening the web server
+ *  Configure the web server options before opening the web server
  */
-	websSetDefaultDir(webdir);
-	cp = inet_ntoa(intaddr);
-	ascToUni(wbuf, cp, min(strlen(cp) + 1, sizeof(wbuf)));
-	websSetIpaddr(wbuf);
-	ascToUni(wbuf, host, min(strlen(host) + 1, sizeof(wbuf)));
-	websSetHost(wbuf);
+    websSetDefaultDir(webdir);
+    cp = inet_ntoa(intaddr);
+    ascToUni(wbuf, cp, min(strlen(cp) + 1, sizeof(wbuf)));
+    websSetIpaddr(wbuf);
+    ascToUni(wbuf, host, min(strlen(host) + 1, sizeof(wbuf)));
+    websSetHost(wbuf);
 
 /*
- *	Configure the web server options before opening the web server
+ *  Configure the web server options before opening the web server
  */
-	websSetDefaultPage(T("default.asp"));
-	websSetPassword(password);
+    websSetDefaultPage(T("default.asp"));
+    websSetPassword(password);
 
 /* 
- *	Open the web server on the given port. If that port is taken, try
- *	the next sequential port for up to "retries" attempts.
+ *  Open the web server on the given port. If that port is taken, try
+ *  the next sequential port for up to "retries" attempts.
  */
-	websOpenServer(port, retries);
+    websOpenServer(port, retries);
 
 /*
- * 	First create the URL handlers. Note: handlers are called in sorted order
- *	with the longest path handler examined first. Here we define the security 
- *	handler, forms handler and the default web page handler.
+ *  First create the URL handlers. Note: handlers are called in sorted order
+ *  with the longest path handler examined first. Here we define the security 
+ *  handler, forms handler and the default web page handler.
  */
-	websUrlHandlerDefine(T(""), NULL, 0, websSecurityHandler, 
-		WEBS_HANDLER_FIRST);
-	websUrlHandlerDefine(T("/goform"), NULL, 0, websFormHandler, 0);
-	websUrlHandlerDefine(T("/cgi-bin"), NULL, 0, websCgiHandler, 0);
-	websUrlHandlerDefine(T(""), NULL, 0, websDefaultHandler, 
-		WEBS_HANDLER_LAST); 
+    websUrlHandlerDefine(T(""), NULL, 0, websSecurityHandler, 
+        WEBS_HANDLER_FIRST);
+    websUrlHandlerDefine(T("/goform"), NULL, 0, websFormHandler, 0);
+    websUrlHandlerDefine(T("/cgi-bin"), NULL, 0, websCgiHandler, 0);
+    websUrlHandlerDefine(T(""), NULL, 0, websDefaultHandler, 
+        WEBS_HANDLER_LAST); 
 
 /*
- *	Now define two test procedures. Replace these with your application
- *	relevant ASP script procedures and form functions.
+ *  Now define two test procedures. Replace these with your application
+ *  relevant ASP script procedures and form functions.
  */
-	websAspDefine(T("aspTest"), aspTest);
-	websFormDefine(T("formTest"), formTest);
+    websAspDefine(T("aspTest"), aspTest);
+    websFormDefine(T("formTest"), formTest);
 
 /*
- *	Create the Form handlers for the User Management pages
+ *  Create the Form handlers for the User Management pages
  */
 #ifdef USER_MANAGEMENT_SUPPORT
-	formDefineUserMgmt();
+    formDefineUserMgmt();
 #endif
 
 /*
- *	Create a handler for the default home page
+ *  Create a handler for the default home page
  */
-	websUrlHandlerDefine(T("/"), NULL, 0, websHomePageHandler, 0); 
-	return 0;
+    websUrlHandlerDefine(T("/"), NULL, 0, websHomePageHandler, 0); 
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Test Javascript binding for ASP. This will be invoked when "aspTest" is
- *	embedded in an ASP page. See web/asp.asp for usage. Set browser to 
- *	"localhost/asp.asp" to test.
+ *  Test Javascript binding for ASP. This will be invoked when "aspTest" is
+ *  embedded in an ASP page. See web/asp.asp for usage. Set browser to 
+ *  "localhost/asp.asp" to test.
  */
 
 static int aspTest(int eid, webs_t wp, int argc, char_t **argv)
 {
-	char_t	*name, *address;
+    char_t  *name, *address;
 
-	if (ejArgs(argc, argv, T("%s %s"), &name, &address) < 2) {
-		websError(wp, 400, T("Insufficient args\n"));
-		return -1;
-	}
-	return websWrite(wp, T("Name: %s, Address %s"), name, address);
+    if (ejArgs(argc, argv, T("%s %s"), &name, &address) < 2) {
+        websError(wp, 400, T("Insufficient args\n"));
+        return -1;
+    }
+    return websWrite(wp, T("Name: %s, Address %s"), name, address);
 }
 
 /******************************************************************************/
 /*
- *	Test form for posted data (in-memory CGI). This will be called when the
- *	form in web/forms.asp is invoked. Set browser to "localhost/forms.asp" to test.
+ *  Test form for posted data (in-memory CGI). This will be called when the
+ *  form in web/forms.asp is invoked. Set browser to "localhost/forms.asp" to test.
  */
 
 static void formTest(webs_t wp, char_t *path, char_t *query)
 {
-	char_t	*name, *address;
+    char_t  *name, *address;
 
-	name = websGetVar(wp, T("name"), T("Joe Smith")); 
-	address = websGetVar(wp, T("address"), T("1212 Milky Way Ave.")); 
+    name = websGetVar(wp, T("name"), T("Joe Smith")); 
+    address = websGetVar(wp, T("address"), T("1212 Milky Way Ave.")); 
 
-	websHeader(wp);
-	websWrite(wp, T("<body><h2>Name: %s, Address: %s</h2>\n"), name, address);
-	websFooter(wp);
-	websDone(wp, 200);
+    websHeader(wp);
+    websWrite(wp, T("<body><h2>Name: %s, Address: %s</h2>\n"), name, address);
+    websFooter(wp);
+    websDone(wp, 200);
 }
 
 /******************************************************************************/
 /*
- *	Home page handler
+ *  Home page handler
  */
 
 static int websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
-	int arg, char_t *url, char_t *path, char_t *query)
+    int arg, char_t *url, char_t *path, char_t *query)
 {
 /*
- *	If the empty or "/" URL is invoked, redirect default URLs to the home page
+ *  If the empty or "/" URL is invoked, redirect default URLs to the home page
  */
-	if (*url == '\0' || gstrcmp(url, T("/")) == 0) {
-		websRedirect(wp, WEBS_DEFAULT_HOME);
-		return 1;
-	}
-	return 0;
+    if (*url == '\0' || gstrcmp(url, T("/")) == 0) {
+        websRedirect(wp, WEBS_DEFAULT_HOME);
+        return 1;
+    }
+    return 0;
 }
 
 /******************************************************************************/
@@ -306,28 +306,28 @@ static int websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
 #ifdef B_STATS
 static void memLeaks() 
 {
-	int		fd;
+    int     fd;
 
-	if ((fd = gopen(T("leak.txt"), O_CREAT | O_TRUNC | O_WRONLY, 0666)) >= 0) {
-		bstats(fd, printMemStats);
-		close(fd);
-	}
+    if ((fd = gopen(T("leak.txt"), O_CREAT | O_TRUNC | O_WRONLY, 0666)) >= 0) {
+        bstats(fd, printMemStats);
+        close(fd);
+    }
 }
 
 /******************************************************************************/
 /*
- *	Print memory usage / leaks
+ *  Print memory usage / leaks
  */
 
 static void printMemStats(int handle, char_t *fmt, ...)
 {
-	va_list		args;
-	char_t		buf[256];
+    va_list     args;
+    char_t      buf[256];
 
-	va_start(args, fmt);
-	vsprintf(buf, fmt, args);
-	va_end(args);
-	write(handle, buf, strlen(buf));
+    va_start(args, fmt);
+    vsprintf(buf, fmt, args);
+    va_end(args);
+    write(handle, buf, strlen(buf));
 }
 #endif
 
diff --git a/LYNX/main.c b/LYNX/main.c
index 6c537a3d..df2b8867 100644
--- a/LYNX/main.c
+++ b/LYNX/main.c
@@ -1,56 +1,56 @@
 /*
- *	main.c -- Main program for the GoAhead WebServer (LynOS version)
+ *  main.c -- Main program for the GoAhead WebServer (LynOS version)
  *
- *	Copyright (c) GoAhead Software Inc., 1995-2010. All Rights Reserved.
+ *  Copyright (c) GoAhead Software Inc., 1995-2010. All Rights Reserved.
  *
- *	See the file "license.txt" for usage and redistribution license requirements
+ *  See the file "license.txt" for usage and redistribution license requirements
  *
  */
 
 /******************************** Description *********************************/
 
 /*
- *	Main program for for the GoAhead WebServer. This is a demonstration
- *	main program to initialize and configure the web server.
+ *  Main program for for the GoAhead WebServer. This is a demonstration
+ *  main program to initialize and configure the web server.
  */
 
 /********************************* Includes ***********************************/
 
-#include	"../uemf.h"
-#include	"../wsIntrn.h"
-#include	<signal.h>
-#include	<unistd.h> 
-#include	<sys/types.h>
+#include    "../uemf.h"
+#include    "../wsIntrn.h"
+#include    <signal.h>
+#include    <unistd.h> 
+#include    <sys/types.h>
 
 #ifdef WEBS_SSL_SUPPORT
-#include	"../websSSL.h"
+#include    "../websSSL.h"
 #endif
 
 #ifdef USER_MANAGEMENT_SUPPORT
-#include	"../um.h"
-void	formDefineUserMgmt(void);
+#include    "../um.h"
+void    formDefineUserMgmt(void);
 #endif
 
 
 /*********************************** Locals ***********************************/
 /*
- *	Change configuration here
+ *  Change configuration here
  */
 
-static char_t		*rootWeb = T("www");			/* Root web directory */
-static char_t		*demoWeb = T("wwwdemo");		/* Root web directory */
-static char_t		*password = T("");				/* Security password */
-static int			port = 80;						/* Server port */
-static int			retries = 5;					/* Server port retries */
-static int			finished;						/* Finished flag */
+static char_t       *rootWeb = T("www");            /* Root web directory */
+static char_t       *demoWeb = T("wwwdemo");        /* Root web directory */
+static char_t       *password = T("");              /* Security password */
+static int          port = 80;                      /* Server port */
+static int          retries = 5;                    /* Server port retries */
+static int          finished;                       /* Finished flag */
 
 /****************************** Forward Declarations **************************/
 
-static int 	initWebs(int demo);
-static int	aspTest(int eid, webs_t wp, int argc, char_t **argv);
+static int  initWebs(int demo);
+static int  aspTest(int eid, webs_t wp, int argc, char_t **argv);
 static void formTest(webs_t wp, char_t *path, char_t *query);
 static int  websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
-				int arg, char_t *url, char_t *path, char_t *query);
+                int arg, char_t *url, char_t *path, char_t *query);
 #ifdef B_STATS
 static void printMemStats(int handle, char_t *fmt, ...);
 static void memLeaks();
@@ -58,233 +58,233 @@ static void memLeaks();
 
 /*********************************** Code *************************************/
 /*
- *	Main -- entry point from LynxOS
+ *  Main -- entry point from LynxOS
  */
 
 int main(int argc, char **argv)
 {
-	int i, demo = 0;
+    int i, demo = 0;
 
-	for (i = 1; i < argc; i++) {
-		if (strcmp(argv[i], "-demo") == 0) {
-			demo++;
-		}
-	}
+    for (i = 1; i < argc; i++) {
+        if (strcmp(argv[i], "-demo") == 0) {
+            demo++;
+        }
+    }
 
 /*
- *	Initialize the memory allocator. Allow use of malloc and start 
- *	with a 60K heap.  For each page request approx 8KB is allocated.
- *	60KB allows for several concurrent page requests.  If more space
- *	is required, malloc will be used for the overflow.
+ *  Initialize the memory allocator. Allow use of malloc and start 
+ *  with a 60K heap.  For each page request approx 8KB is allocated.
+ *  60KB allows for several concurrent page requests.  If more space
+ *  is required, malloc will be used for the overflow.
  */
-	bopen(NULL, (60 * 1024), B_USE_MALLOC);
-	signal(SIGPIPE, SIG_IGN);
+    bopen(NULL, (60 * 1024), B_USE_MALLOC);
+    signal(SIGPIPE, SIG_IGN);
 
 /*
- *	Initialize the web server
+ *  Initialize the web server
  */
-	if (initWebs(demo) < 0) {
-		return -1;
-	}
+    if (initWebs(demo) < 0) {
+        return -1;
+    }
 
 #ifdef WEBS_SSL_SUPPORT
-	websSSLOpen();
+    websSSLOpen();
 #endif
 
 /*
- *	Basic event loop. SocketReady returns true when a socket is ready for
- *	service. SocketSelect will block until an event occurs. SocketProcess
- *	will actually do the servicing.
+ *  Basic event loop. SocketReady returns true when a socket is ready for
+ *  service. SocketSelect will block until an event occurs. SocketProcess
+ *  will actually do the servicing.
  */
-	while (!finished) {
-		if (socketReady(-1) || socketSelect(-1, 1000)) {
-			socketProcess(-1);
-		}
-		websCgiCleanup();
-		emfSchedProcess();
-	}
+    while (!finished) {
+        if (socketReady(-1) || socketSelect(-1, 1000)) {
+            socketProcess(-1);
+        }
+        websCgiCleanup();
+        emfSchedProcess();
+    }
 
 #ifdef WEBS_SSL_SUPPORT
-	websSSLClose();
+    websSSLClose();
 #endif
 
 #ifdef USER_MANAGEMENT_SUPPORT
-	umClose();
+    umClose();
 #endif
 
 /*
- *	Close the socket module, report memory leaks and close the memory allocator
+ *  Close the socket module, report memory leaks and close the memory allocator
  */
-	websCloseServer();
-	socketClose();
+    websCloseServer();
+    socketClose();
 #ifdef B_STATS
-	memLeaks();
+    memLeaks();
 #endif
-	bclose();
-	return 0;
+    bclose();
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Initialize the web server.
+ *  Initialize the web server.
  */
 
 static int initWebs(int demo)
 {
-	struct hostent  *hp;
-	struct in_addr	intaddr;
-	char			host[128], dir[128], webdir[128];
-	char			*cp;
-	char_t			wbuf[128];
+    struct hostent  *hp;
+    struct in_addr  intaddr;
+    char            host[128], dir[128], webdir[128];
+    char            *cp;
+    char_t          wbuf[128];
 
 /*
- *	Initialize the socket subsystem
+ *  Initialize the socket subsystem
  */
-	socketOpen();
+    socketOpen();
 
 #ifdef USER_MANAGEMENT_SUPPORT
 /*
- *	Initialize the User Management database
+ *  Initialize the User Management database
  */
-	umOpen();
-	umRestore(T("umconfig.txt"));
+    umOpen();
+    umRestore(T("umconfig.txt"));
 #endif
 
 /*
- *	Define the local Ip address, host name, default home page and the 
- *	root web directory.
+ *  Define the local Ip address, host name, default home page and the 
+ *  root web directory.
  */
-	if (gethostname(host, sizeof(host)) < 0) {
-		error(E_L, E_LOG, T("Can't get hostname"));
-		return -1;
-	}
-	if ((hp = gethostbyname(host)) == NULL) {
-		error(E_L, E_LOG, T("Can't get host address"));
-		return -1;
-	}
-	memcpy((char *) &intaddr, (char *) hp->h_addr_list[0],
-		(size_t) hp->h_length);
+    if (gethostname(host, sizeof(host)) < 0) {
+        error(E_L, E_LOG, T("Can't get hostname"));
+        return -1;
+    }
+    if ((hp = gethostbyname(host)) == NULL) {
+        error(E_L, E_LOG, T("Can't get host address"));
+        return -1;
+    }
+    memcpy((char *) &intaddr, (char *) hp->h_addr_list[0],
+        (size_t) hp->h_length);
 
 /*
- *	Set ../web as the root web. Modify this to suit your needs
+ *  Set ../web as the root web. Modify this to suit your needs
  */
-	getcwd(dir, sizeof(dir)); 
-	if ((cp = strrchr(dir, '/'))) {
-		*cp = '\0';
-	}
-	if (demo) {
-		sprintf(webdir, "%s/%s", dir, demoWeb);
-	} else {
-		sprintf(webdir, "%s/%s", dir, rootWeb);
-	}	
+    getcwd(dir, sizeof(dir)); 
+    if ((cp = strrchr(dir, '/'))) {
+        *cp = '\0';
+    }
+    if (demo) {
+        sprintf(webdir, "%s/%s", dir, demoWeb);
+    } else {
+        sprintf(webdir, "%s/%s", dir, rootWeb);
+    }   
 
 /*
- *	Configure the web server options before opening the web server
+ *  Configure the web server options before opening the web server
  */
-	websSetDefaultDir(webdir);
-	cp = inet_ntoa(intaddr);
-	ascToUni(wbuf, cp, min(strlen(cp) + 1, sizeof(wbuf)));
-	websSetIpaddr(wbuf);
-	ascToUni(wbuf, host, min(strlen(host) + 1, sizeof(wbuf)));
-	websSetHost(wbuf);
+    websSetDefaultDir(webdir);
+    cp = inet_ntoa(intaddr);
+    ascToUni(wbuf, cp, min(strlen(cp) + 1, sizeof(wbuf)));
+    websSetIpaddr(wbuf);
+    ascToUni(wbuf, host, min(strlen(host) + 1, sizeof(wbuf)));
+    websSetHost(wbuf);
 
 /*
- *	Configure the web server options before opening the web server
+ *  Configure the web server options before opening the web server
  */
-	websSetDefaultPage(T("default.asp"));
-	websSetPassword(password);
+    websSetDefaultPage(T("default.asp"));
+    websSetPassword(password);
 
 /* 
- *	Open the web server on the given port. If that port is taken, try
- *	the next sequential port for up to "retries" attempts.
+ *  Open the web server on the given port. If that port is taken, try
+ *  the next sequential port for up to "retries" attempts.
  */
-	websOpenServer(port, retries);
+    websOpenServer(port, retries);
 
 /*
- * 	First create the URL handlers. Note: handlers are called in sorted order
- *	with the longest path handler examined first. Here we define the security 
- *	handler, forms handler and the default web page handler.
+ *  First create the URL handlers. Note: handlers are called in sorted order
+ *  with the longest path handler examined first. Here we define the security 
+ *  handler, forms handler and the default web page handler.
  */
-	websUrlHandlerDefine(T(""), NULL, 0, websSecurityHandler, 
-		WEBS_HANDLER_FIRST);
-	websUrlHandlerDefine(T("/goform"), NULL, 0, websFormHandler, 0);
-	websUrlHandlerDefine(T("/cgi-bin"), NULL, 0, websCgiHandler, 0);
-	websUrlHandlerDefine(T(""), NULL, 0, websDefaultHandler, 
-		WEBS_HANDLER_LAST); 
+    websUrlHandlerDefine(T(""), NULL, 0, websSecurityHandler, 
+        WEBS_HANDLER_FIRST);
+    websUrlHandlerDefine(T("/goform"), NULL, 0, websFormHandler, 0);
+    websUrlHandlerDefine(T("/cgi-bin"), NULL, 0, websCgiHandler, 0);
+    websUrlHandlerDefine(T(""), NULL, 0, websDefaultHandler, 
+        WEBS_HANDLER_LAST); 
 
 /*
- *	Now define two test procedures. Replace these with your application
- *	relevant ASP script procedures and form functions.
+ *  Now define two test procedures. Replace these with your application
+ *  relevant ASP script procedures and form functions.
  */
-	websAspDefine(T("aspTest"), aspTest);
-	websFormDefine(T("formTest"), formTest);
+    websAspDefine(T("aspTest"), aspTest);
+    websFormDefine(T("formTest"), formTest);
 
 /*
- *	Create the Form handlers for the User Management pages
+ *  Create the Form handlers for the User Management pages
  */
 #ifdef USER_MANAGEMENT_SUPPORT
-	formDefineUserMgmt();
+    formDefineUserMgmt();
 #endif
 
 /*
- *	Create a handler for the default home page
+ *  Create a handler for the default home page
  */
-	websUrlHandlerDefine(T("/"), NULL, 0, websHomePageHandler, 0); 
-	return 0;
+    websUrlHandlerDefine(T("/"), NULL, 0, websHomePageHandler, 0); 
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Test Javascript binding for ASP. This will be invoked when "aspTest" is
- *	embedded in an ASP page. See web/asp.asp for usage. Set browser to 
- *	"localhost/asp.asp" to test.
+ *  Test Javascript binding for ASP. This will be invoked when "aspTest" is
+ *  embedded in an ASP page. See web/asp.asp for usage. Set browser to 
+ *  "localhost/asp.asp" to test.
  */
 
 static int aspTest(int eid, webs_t wp, int argc, char_t **argv)
 {
-	char_t	*name, *address;
+    char_t  *name, *address;
 
-	if (ejArgs(argc, argv, T("%s %s"), &name, &address) < 2) {
-		websError(wp, 400, T("Insufficient args\n"));
-		return -1;
-	}
-	return websWrite(wp, T("Name: %s, Address %s"), name, address);
+    if (ejArgs(argc, argv, T("%s %s"), &name, &address) < 2) {
+        websError(wp, 400, T("Insufficient args\n"));
+        return -1;
+    }
+    return websWrite(wp, T("Name: %s, Address %s"), name, address);
 }
 /******************************************************************************/
 /*
- *	Test form for posted data (in-memory CGI). This will be called when the
- *	form in web/forms.asp is invoked. Set browser to "localhost/forms.asp" to test.
+ *  Test form for posted data (in-memory CGI). This will be called when the
+ *  form in web/forms.asp is invoked. Set browser to "localhost/forms.asp" to test.
  */
 
 static void formTest(webs_t wp, char_t *path, char_t *query)
 {
-	char_t	*name, *address;
+    char_t  *name, *address;
 
-	name = websGetVar(wp, T("name"), T("Joe Smith")); 
-	address = websGetVar(wp, T("address"), T("1212 Milky Way Ave.")); 
+    name = websGetVar(wp, T("name"), T("Joe Smith")); 
+    address = websGetVar(wp, T("address"), T("1212 Milky Way Ave.")); 
 
-	websHeader(wp);
-	websWrite(wp, T("<body><h2>Name: %s, Address: %s</h2>\n"), name, address);
-	websFooter(wp);
-	websDone(wp, 200);
+    websHeader(wp);
+    websWrite(wp, T("<body><h2>Name: %s, Address: %s</h2>\n"), name, address);
+    websFooter(wp);
+    websDone(wp, 200);
 }
 
 /******************************************************************************/
 /*
- *	Home page handler
+ *  Home page handler
  */
 
 static int websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
-	int arg, char_t *url, char_t *path, char_t *query)
+    int arg, char_t *url, char_t *path, char_t *query)
 {
 /*
- *	If the empty or "/" URL is invoked, redirect default URLs to the home page
+ *  If the empty or "/" URL is invoked, redirect default URLs to the home page
  */
-	if (*url == '\0' || gstrcmp(url, T("/")) == 0) {
-		websRedirect(wp, T("home.asp"));
-		return 1;
-	}
-	return 0;
+    if (*url == '\0' || gstrcmp(url, T("/")) == 0) {
+        websRedirect(wp, T("home.asp"));
+        return 1;
+    }
+    return 0;
 }
 
 /******************************************************************************/
@@ -292,28 +292,28 @@ static int websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
 #ifdef B_STATS
 static void memLeaks() 
 {
-	int		fd;
+    int     fd;
 
-	if ((fd = gopen(T("leak.txt"), O_CREAT | O_TRUNC | O_WRONLY)) >= 0) {
-		bstats(fd, printMemStats);
-		close(fd);
-	}
+    if ((fd = gopen(T("leak.txt"), O_CREAT | O_TRUNC | O_WRONLY)) >= 0) {
+        bstats(fd, printMemStats);
+        close(fd);
+    }
 }
 
 /******************************************************************************/
 /*
- *	Print memory usage / leaks
+ *  Print memory usage / leaks
  */
 
 static void printMemStats(int handle, char_t *fmt, ...)
 {
-	va_list		args;
-	char_t		buf[256];
+    va_list     args;
+    char_t      buf[256];
 
-	va_start(args, fmt);
-	vsprintf(buf, fmt, args);
-	va_end(args);
-	write(handle, buf, strlen(buf));
+    va_start(args, fmt);
+    vsprintf(buf, fmt, args);
+    va_end(args);
+    write(handle, buf, strlen(buf));
 }
 #endif
 
diff --git a/MACOSX/main.c b/MACOSX/main.c
index fd0eb1a0..de12fe33 100644
--- a/MACOSX/main.c
+++ b/MACOSX/main.c
@@ -10,44 +10,44 @@
 /******************************** Description *********************************/
 
 /*
- *	Main program for for the GoAhead WebServer. This is a demonstration
- *	main program to initialize and configure the web server.
+ *  Main program for for the GoAhead WebServer. This is a demonstration
+ *  main program to initialize and configure the web server.
  */
 
 /********************************* Includes ***********************************/
 
-#include	"../uemf.h"
-#include	"../wsIntrn.h"
-#include	<signal.h>
-#include	<unistd.h> 
-#include	<sys/types.h>
+#include    "../uemf.h"
+#include    "../wsIntrn.h"
+#include    <signal.h>
+#include    <unistd.h> 
+#include    <sys/types.h>
 
 #ifdef WEBS_SSL_SUPPORT
-#include	"../websSSL.h"
+#include    "../websSSL.h"
 #endif
 
 #ifdef USER_MANAGEMENT_SUPPORT
-#include	"../um.h"
-void	formDefineUserMgmt(void);
+#include    "../um.h"
+void    formDefineUserMgmt(void);
 #endif
 
 
 /*********************************** Locals ***********************************/
-static char_t		*rootWeb = T("www");			/* Root web directory */
-static char_t		*demoWeb = T("wwwdemo");		/* Root web directory */
-static char_t		*password = T("");				/* Security password */
-static int			port = WEBS_DEFAULT_PORT;		/* Server port */
+static char_t       *rootWeb = T("www");            /* Root web directory */
+static char_t       *demoWeb = T("wwwdemo");        /* Root web directory */
+static char_t       *password = T("");              /* Security password */
+static int          port = WEBS_DEFAULT_PORT;       /* Server port */
 
-static int			retries = 5;					/* Server port retries */
-static int			finished = 0;					/* Finished flag */
+static int          retries = 5;                    /* Server port retries */
+static int          finished = 0;                   /* Finished flag */
 
 /****************************** Forward Declarations **************************/
 
-static int 	initWebs(int demo);
-static int	aspTest(int eid, webs_t wp, int argc, char_t **argv);
+static int  initWebs(int demo);
+static int  aspTest(int eid, webs_t wp, int argc, char_t **argv);
 static void formTest(webs_t wp, char_t *path, char_t *query);
 static int  websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
-				int arg, char_t *url, char_t *path, char_t *query);
+                int arg, char_t *url, char_t *path, char_t *query);
 static void sigintHandler(int);
 #ifdef B_STATS
 static void printMemStats(int handle, char_t *fmt, ...);
@@ -56,247 +56,247 @@ static void memLeaks();
 
 /*********************************** Code *************************************/
 /*
- *	Main -- entry point from Mac OS X
+ *  Main -- entry point from Mac OS X
  */
 
 int main(int argc, char** argv)
 {
-	int i, demo = 0;
+    int i, demo = 0;
 
-	for (i = 1; i < argc; i++) {
-		if (strcmp(argv[i], "-demo") == 0) {
-			demo++;
-		}
-	}
+    for (i = 1; i < argc; i++) {
+        if (strcmp(argv[i], "-demo") == 0) {
+            demo++;
+        }
+    }
 
 /*
- *	Initialize the memory allocator. Allow use of malloc and start 
- *	with a 60K heap.  For each page request approx 8KB is allocated.
- *	60KB allows for several concurrent page requests.  If more space
- *	is required, malloc will be used for the overflow.
+ *  Initialize the memory allocator. Allow use of malloc and start 
+ *  with a 60K heap.  For each page request approx 8KB is allocated.
+ *  60KB allows for several concurrent page requests.  If more space
+ *  is required, malloc will be used for the overflow.
  */
-	bopen(NULL, (60 * 1024), B_USE_MALLOC);
-	signal(SIGPIPE, SIG_IGN);
-	signal(SIGINT, sigintHandler);
-	signal(SIGTERM, sigintHandler);
+    bopen(NULL, (60 * 1024), B_USE_MALLOC);
+    signal(SIGPIPE, SIG_IGN);
+    signal(SIGINT, sigintHandler);
+    signal(SIGTERM, sigintHandler);
 
 /*
- *	Initialize the web server
+ *  Initialize the web server
  */
-	if (initWebs(demo) < 0) {
-		return -1;
-	}
+    if (initWebs(demo) < 0) {
+        return -1;
+    }
 
 #ifdef WEBS_SSL_SUPPORT
-	websSSLOpen();
-/*	websRequireSSL("/"); */ /* Require all files be served via https */
+    websSSLOpen();
+/*  websRequireSSL("/"); */ /* Require all files be served via https */
 #endif
 
 /*
- *	Basic event loop. SocketReady returns true when a socket is ready for
- *	service. SocketSelect will block until an event occurs. SocketProcess
- *	will actually do the servicing.
+ *  Basic event loop. SocketReady returns true when a socket is ready for
+ *  service. SocketSelect will block until an event occurs. SocketProcess
+ *  will actually do the servicing.
  */
-	finished = 0;
-	while (!finished) {
-		if (socketReady(-1) || socketSelect(-1, 1000)) {
-			socketProcess(-1);
-		}
-		websCgiCleanup();
-		emfSchedProcess();
-	}
+    finished = 0;
+    while (!finished) {
+        if (socketReady(-1) || socketSelect(-1, 1000)) {
+            socketProcess(-1);
+        }
+        websCgiCleanup();
+        emfSchedProcess();
+    }
 
 #ifdef WEBS_SSL_SUPPORT
-	websSSLClose();
+    websSSLClose();
 #endif
 
 #ifdef USER_MANAGEMENT_SUPPORT
-	umClose();
+    umClose();
 #endif
 
 /*
- *	Close the socket module, report memory leaks and close the memory allocator
+ *  Close the socket module, report memory leaks and close the memory allocator
  */
-	websCloseServer();
-	socketClose();
+    websCloseServer();
+    socketClose();
 #ifdef B_STATS
-	memLeaks();
+    memLeaks();
 #endif
-	bclose();
-	return 0;
+    bclose();
+    return 0;
 }
 
 /*
- *	Exit cleanly on ctrl-c
+ *  Exit cleanly on ctrl-c
  */
 static void sigintHandler(int unused)
 {
-	finished = 1;
+    finished = 1;
 }
 
 /******************************************************************************/
 /*
- *	Initialize the web server.
+ *  Initialize the web server.
  */
 static int initWebs(int demo)
 {
-	struct hostent	*hp;
-	struct in_addr	intaddr;
-	char			host[128], dir[128], webdir[128];
-	char			*cp;
-	char_t			wbuf[128];
+    struct hostent  *hp;
+    struct in_addr  intaddr;
+    char            host[128], dir[128], webdir[128];
+    char            *cp;
+    char_t          wbuf[128];
 
 /*
- *	Initialize the socket subsystem
+ *  Initialize the socket subsystem
  */
-	socketOpen();
+    socketOpen();
 
 #ifdef USER_MANAGEMENT_SUPPORT
 /*
- *	Initialize the User Management database
+ *  Initialize the User Management database
  */
-	umOpen();
-	umRestore(T("umconfig.txt"));
+    umOpen();
+    umRestore(T("umconfig.txt"));
 #endif
 
 /*
- *	Define the local Ip address, host name, default home page and the 
- *	root web directory.
+ *  Define the local Ip address, host name, default home page and the 
+ *  root web directory.
  */
-	if (gethostname(host, sizeof(host)) < 0) {
-		error(E_L, E_LOG, T("Can't get hostname"));
-		return -1;
-	}
-	if ((hp = gethostbyname(host)) == NULL) {
-		error(E_L, E_LOG, T("Can't get host address"));
-		return -1;
-	}
-	memcpy((char *) &intaddr, (char *) hp->h_addr_list[0],
-		(size_t) hp->h_length);
+    if (gethostname(host, sizeof(host)) < 0) {
+        error(E_L, E_LOG, T("Can't get hostname"));
+        return -1;
+    }
+    if ((hp = gethostbyname(host)) == NULL) {
+        error(E_L, E_LOG, T("Can't get host address"));
+        return -1;
+    }
+    memcpy((char *) &intaddr, (char *) hp->h_addr_list[0],
+        (size_t) hp->h_length);
 
 /*
- *	Set ../web as the root web. Modify this to suit your needs
- *	A "-demo" option to the command line will set a webdemo root
+ *  Set ../web as the root web. Modify this to suit your needs
+ *  A "-demo" option to the command line will set a webdemo root
  */
-	getcwd(dir, sizeof(dir)); 
-	if ((cp = strrchr(dir, '/'))) {
-		*cp = '\0';
-	}
+    getcwd(dir, sizeof(dir)); 
+    if ((cp = strrchr(dir, '/'))) {
+        *cp = '\0';
+    }
 
-	if (demo) {
-		sprintf(webdir, "%s/%s", dir, demoWeb);
-	} else {
-		sprintf(webdir, "%s/%s", dir, rootWeb);
-	}
+    if (demo) {
+        sprintf(webdir, "%s/%s", dir, demoWeb);
+    } else {
+        sprintf(webdir, "%s/%s", dir, rootWeb);
+    }
 
 /*
- *	Configure the web server options before opening the web server
+ *  Configure the web server options before opening the web server
  */
-	websSetDefaultDir(webdir);
-	cp = inet_ntoa(intaddr);
-	ascToUni(wbuf, cp, min(strlen(cp) + 1, sizeof(wbuf)));
-	websSetIpaddr(wbuf);
-	ascToUni(wbuf, host, min(strlen(host) + 1, sizeof(wbuf)));
-	websSetHost(wbuf);
+    websSetDefaultDir(webdir);
+    cp = inet_ntoa(intaddr);
+    ascToUni(wbuf, cp, min(strlen(cp) + 1, sizeof(wbuf)));
+    websSetIpaddr(wbuf);
+    ascToUni(wbuf, host, min(strlen(host) + 1, sizeof(wbuf)));
+    websSetHost(wbuf);
 
 /*
- *	Configure the web server options before opening the web server
+ *  Configure the web server options before opening the web server
  */
-	websSetDefaultPage(T("default.asp"));
-	websSetPassword(password);
+    websSetDefaultPage(T("default.asp"));
+    websSetPassword(password);
 
 /* 
- *	Open the web server on the given port. If that port is taken, try
- *	the next sequential port for up to "retries" attempts.
+ *  Open the web server on the given port. If that port is taken, try
+ *  the next sequential port for up to "retries" attempts.
  */
-	websOpenServer(port, retries);
+    websOpenServer(port, retries);
 
 /*
- * 	First create the URL handlers. Note: handlers are called in sorted order
- *	with the longest path handler examined first. Here we define the security 
- *	handler, forms handler and the default web page handler.
+ *  First create the URL handlers. Note: handlers are called in sorted order
+ *  with the longest path handler examined first. Here we define the security 
+ *  handler, forms handler and the default web page handler.
  */
-	websUrlHandlerDefine(T(""), NULL, 0, websSecurityHandler, 
-		WEBS_HANDLER_FIRST);
-	websUrlHandlerDefine(T("/goform"), NULL, 0, websFormHandler, 0);
-	websUrlHandlerDefine(T("/cgi-bin"), NULL, 0, websCgiHandler, 0);
-	websUrlHandlerDefine(T(""), NULL, 0, websDefaultHandler, 
-		WEBS_HANDLER_LAST); 
+    websUrlHandlerDefine(T(""), NULL, 0, websSecurityHandler, 
+        WEBS_HANDLER_FIRST);
+    websUrlHandlerDefine(T("/goform"), NULL, 0, websFormHandler, 0);
+    websUrlHandlerDefine(T("/cgi-bin"), NULL, 0, websCgiHandler, 0);
+    websUrlHandlerDefine(T(""), NULL, 0, websDefaultHandler, 
+        WEBS_HANDLER_LAST); 
 
 /*
- *	Now define two test procedures. Replace these with your application
- *	relevant ASP script procedures and form functions.
+ *  Now define two test procedures. Replace these with your application
+ *  relevant ASP script procedures and form functions.
  */
-	websAspDefine(T("aspTest"), aspTest);
-	websFormDefine(T("formTest"), formTest);
+    websAspDefine(T("aspTest"), aspTest);
+    websFormDefine(T("formTest"), formTest);
 
 /*
- *	Create the Form handlers for the User Management pages
+ *  Create the Form handlers for the User Management pages
  */
 #ifdef USER_MANAGEMENT_SUPPORT
-	formDefineUserMgmt();
+    formDefineUserMgmt();
 #endif
 
 /*
- *	Create a handler for the default home page
+ *  Create a handler for the default home page
  */
-	websUrlHandlerDefine(T("/"), NULL, 0, websHomePageHandler, 0); 
-	return 0;
+    websUrlHandlerDefine(T("/"), NULL, 0, websHomePageHandler, 0); 
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Test Javascript binding for ASP. This will be invoked when "aspTest" is
- *	embedded in an ASP page. See web/asp.asp for usage. Set browser to 
- *	"localhost/asp.asp" to test.
+ *  Test Javascript binding for ASP. This will be invoked when "aspTest" is
+ *  embedded in an ASP page. See web/asp.asp for usage. Set browser to 
+ *  "localhost/asp.asp" to test.
  */
 
 static int aspTest(int eid, webs_t wp, int argc, char_t **argv)
 {
-	char_t	*name, *address;
+    char_t  *name, *address;
 
-	if (ejArgs(argc, argv, T("%s %s"), &name, &address) < 2) {
-		websError(wp, 400, T("Insufficient args\n"));
-		return -1;
-	}
-	return websWrite(wp, T("Name: %s, Address %s"), name, address);
+    if (ejArgs(argc, argv, T("%s %s"), &name, &address) < 2) {
+        websError(wp, 400, T("Insufficient args\n"));
+        return -1;
+    }
+    return websWrite(wp, T("Name: %s, Address %s"), name, address);
 }
 
 /******************************************************************************/
 /*
- *	Test form for posted data (in-memory CGI). This will be called when the
- *	form in web/forms.asp is invoked. Set browser to "localhost/forms.asp" to test.
+ *  Test form for posted data (in-memory CGI). This will be called when the
+ *  form in web/forms.asp is invoked. Set browser to "localhost/forms.asp" to test.
  */
 
 static void formTest(webs_t wp, char_t *path, char_t *query)
 {
-	char_t	*name, *address;
+    char_t  *name, *address;
 
-	name = websGetVar(wp, T("name"), T("Joe Smith")); 
-	address = websGetVar(wp, T("address"), T("1212 Milky Way Ave.")); 
+    name = websGetVar(wp, T("name"), T("Joe Smith")); 
+    address = websGetVar(wp, T("address"), T("1212 Milky Way Ave.")); 
 
-	websHeader(wp);
-	websWrite(wp, T("<body><h2>Name: %s, Address: %s</h2>\n"), name, address);
-	websFooter(wp);
-	websDone(wp, 200);
+    websHeader(wp);
+    websWrite(wp, T("<body><h2>Name: %s, Address: %s</h2>\n"), name, address);
+    websFooter(wp);
+    websDone(wp, 200);
 }
 
 /******************************************************************************/
 /*
- *	Home page handler
+ *  Home page handler
  */
 
 static int websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
-	int arg, char_t *url, char_t *path, char_t *query)
+    int arg, char_t *url, char_t *path, char_t *query)
 {
 /*
- *	If the empty or "/" URL is invoked, redirect default URLs to the home page
+ *  If the empty or "/" URL is invoked, redirect default URLs to the home page
  */
-	if (*url == '\0' || gstrcmp(url, T("/")) == 0) {
-		websRedirect(wp, WEBS_DEFAULT_HOME);
-		return 1;
-	}
-	return 0;
+    if (*url == '\0' || gstrcmp(url, T("/")) == 0) {
+        websRedirect(wp, WEBS_DEFAULT_HOME);
+        return 1;
+    }
+    return 0;
 }
 
 /******************************************************************************/
@@ -304,28 +304,28 @@ static int websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
 #ifdef B_STATS
 static void memLeaks() 
 {
-	int		fd;
+    int     fd;
 
-	if ((fd = gopen(T("leak.txt"), O_CREAT | O_TRUNC | O_WRONLY)) >= 0) {
-		bstats(fd, printMemStats);
-		close(fd);
-	}
+    if ((fd = gopen(T("leak.txt"), O_CREAT | O_TRUNC | O_WRONLY)) >= 0) {
+        bstats(fd, printMemStats);
+        close(fd);
+    }
 }
 
 /******************************************************************************/
 /*
- *	Print memory usage / leaks
+ *  Print memory usage / leaks
  */
 
 static void printMemStats(int handle, char_t *fmt, ...)
 {
-	va_list		args;
-	char_t		buf[256];
+    va_list     args;
+    char_t      buf[256];
 
-	va_start(args, fmt);
-	vsprintf(buf, fmt, args);
-	va_end(args);
-	write(handle, buf, strlen(buf));
+    va_start(args, fmt);
+    vsprintf(buf, fmt, args);
+    va_end(args);
+    write(handle, buf, strlen(buf));
 }
 #endif
 
diff --git a/NW/main.c b/NW/main.c
index 7b40386e..f1eebe42 100644
--- a/NW/main.c
+++ b/NW/main.c
@@ -83,16 +83,16 @@ void NLMcleanup( void );
 
 int main(int argc, char** argv)
 {
-	int i, demo = 0;
+    int i, demo = 0;
 
-	for (i = 1; i < argc; i++) {
-		if (strcmp(argv[i], "-demo") == 0) {
-			demo++;
-		}
-	}
+    for (i = 1; i < argc; i++) {
+        if (strcmp(argv[i], "-demo") == 0) {
+            demo++;
+        }
+    }
 
 /*
- *	Hook the unload routine in
+ *  Hook the unload routine in
  */
    signal( SIGTERM, SigTermSignalHandler ) ;
 
@@ -107,8 +107,8 @@ int main(int argc, char** argv)
    P( 1 ) ;
 
 /*
- *	Switch to LONG name-space. If LONG is not loaded, WEBS will default
- *	to 8.3
+ *  Switch to LONG name-space. If LONG is not loaded, WEBS will default
+ *  to 8.3
  */
    SetCurrentNameSpace( 4 ) ;
 
@@ -208,11 +208,11 @@ static int initWebs(int demo)
 
    Ps( 6, cp ) ;
 
-	if (demo) {
-	   sprintf(webdir, "%s/%s", cp, demoWeb);
-	} else {
-	   sprintf(webdir, "%s/%s", cp, rootWeb);
-	}
+    if (demo) {
+       sprintf(webdir, "%s/%s", cp, demoWeb);
+    } else {
+       sprintf(webdir, "%s/%s", cp, rootWeb);
+    }
 
    Ps( 6, webdir ) ;
 
@@ -245,9 +245,9 @@ static int initWebs(int demo)
    P( 9 ) ;
 
 /*
- *	First create the URL handlers. Note: handlers are called in sorted order
- *	with the longest path handler examined first. Here we define the security 
- *	handler, forms handler and the default web page handler.
+ *  First create the URL handlers. Note: handlers are called in sorted order
+ *  with the longest path handler examined first. Here we define the security 
+ *  handler, forms handler and the default web page handler.
  */
    websUrlHandlerDefine(T(""), NULL, 0, websSecurityHandler, 
       WEBS_HANDLER_FIRST);
@@ -321,8 +321,8 @@ void NLMcleanup( void )
 
 /******************************************************************************/
 /*
- *	Routine to handle the UNLOAD command gracefully
- *	Note:	sigtype is not used
+ *  Routine to handle the UNLOAD command gracefully
+ *  Note:   sigtype is not used
  */
 
 #pragma off(unreferenced)
diff --git a/QNX4/main.c b/QNX4/main.c
index 3ca17ea1..e306b06a 100644
--- a/QNX4/main.c
+++ b/QNX4/main.c
@@ -14,44 +14,44 @@
 /******************************** Description *********************************/
 
 /*
- *	Main program for for the GoAhead WebServer. This is a demonstration
- *	main program to initialize and configure the web server.
+ *  Main program for for the GoAhead WebServer. This is a demonstration
+ *  main program to initialize and configure the web server.
  */
 
 /********************************* Includes ***********************************/
 
-#include	"../uemf.h"
-#include	"../wsIntrn.h"
-#include	 <signal.h>
+#include    "../uemf.h"
+#include    "../wsIntrn.h"
+#include     <signal.h>
 
 #ifdef WEBS_SSL_SUPPORT
-#include	"../websSSL.h"
+#include    "../websSSL.h"
 #endif
 
 #ifdef USER_MANAGEMENT_SUPPORT
-#include	"../um.h"
-void	formDefineUserMgmt(void);
+#include    "../um.h"
+void    formDefineUserMgmt(void);
 #endif
 
 /*********************************** Locals ***********************************/
 /*
- *	Change configuration here
+ *  Change configuration here
  */
 
-static char_t		*rootWeb = T("www");			/* Root web directory */
-static char_t		*demoWeb = T("wwwdemo");		/* Root web directory */
-static char_t		*password = T("");				/* Security password */
-static int			port = 80;						/* Server port */
-static int			retries = 5;					/* Server port retries */
-static int			finished;						/* Finished flag */
+static char_t       *rootWeb = T("www");            /* Root web directory */
+static char_t       *demoWeb = T("wwwdemo");        /* Root web directory */
+static char_t       *password = T("");              /* Security password */
+static int          port = 80;                      /* Server port */
+static int          retries = 5;                    /* Server port retries */
+static int          finished;                       /* Finished flag */
 
 /****************************** Forward Declarations **************************/
 
-static int 	initWebs(int demo);
-static int	aspTest(int eid, webs_t wp, int argc, char_t **argv);
+static int  initWebs(int demo);
+static int  aspTest(int eid, webs_t wp, int argc, char_t **argv);
 static void formTest(webs_t wp, char_t *path, char_t *query);
 static int  websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
-				int arg, char_t *url, char_t *path, char_t *query);
+                int arg, char_t *url, char_t *path, char_t *query);
 #ifdef B_STATS
 static void printMemStats(int handle, char_t *fmt, ...);
 static void memLeaks();
@@ -59,233 +59,233 @@ static void memLeaks();
 
 /*********************************** Code *************************************/
 /*
- *	Main -- entry point from QNX
+ *  Main -- entry point from QNX
  */
 
 int main(int argc, char **argv)
 {
-	int i, demo = 0;
+    int i, demo = 0;
 
-	for (i = 1; i < argc; i++) {
-		if (strcmp(argv[i], "-demo") == 0) {
-			demo++;
-		}
-	}
+    for (i = 1; i < argc; i++) {
+        if (strcmp(argv[i], "-demo") == 0) {
+            demo++;
+        }
+    }
 
 /*
- *	Initialize the memory allocator. Allow use of malloc and start 
- *	with a 60K heap.  For each page request approx 8KB is allocated.
- *	60KB allows for several concurrent page requests.  If more space
- *	is required, malloc will be used for the overflow.
+ *  Initialize the memory allocator. Allow use of malloc and start 
+ *  with a 60K heap.  For each page request approx 8KB is allocated.
+ *  60KB allows for several concurrent page requests.  If more space
+ *  is required, malloc will be used for the overflow.
  */
-	bopen(NULL, (60 * 1024), B_USE_MALLOC);
-	signal (SIGPIPE, SIG_IGN);
+    bopen(NULL, (60 * 1024), B_USE_MALLOC);
+    signal (SIGPIPE, SIG_IGN);
 
 /*
- *	Initialize the web server
+ *  Initialize the web server
  */
-	if (initWebs(demo) < 0) {
-		return -1;
-	}
+    if (initWebs(demo) < 0) {
+        return -1;
+    }
 
 #ifdef WEBS_SSL_SUPPORT
-	websSSLOpen();
+    websSSLOpen();
 #endif
 
 /*
- *	Basic event loop. SocketReady returns true when a socket is ready for
- *	service. SocketSelect will block until an event occurs. SocketProcess
- *	will actually do the servicing.
+ *  Basic event loop. SocketReady returns true when a socket is ready for
+ *  service. SocketSelect will block until an event occurs. SocketProcess
+ *  will actually do the servicing.
  */
-	while (!finished) {
-		if (socketReady(-1) || socketSelect(-1, 1000)) {
-			socketProcess(-1);
-		}
-		websCgiCleanup();
-		emfSchedProcess();
-	}
+    while (!finished) {
+        if (socketReady(-1) || socketSelect(-1, 1000)) {
+            socketProcess(-1);
+        }
+        websCgiCleanup();
+        emfSchedProcess();
+    }
 
 #ifdef WEBS_SSL_SUPPORT
-	websSSLClose();
+    websSSLClose();
 #endif
 
 #ifdef USER_MANAGEMENT_SUPPORT
-	umClose();
+    umClose();
 #endif
 
 /*
- *	Close the socket module, report memory leaks and close the memory allocator
+ *  Close the socket module, report memory leaks and close the memory allocator
  */
-	websCloseServer();
-	socketClose();
+    websCloseServer();
+    socketClose();
 #ifdef B_STATS
-	memLeaks();
+    memLeaks();
 #endif
-	bclose();
-	return 0;
+    bclose();
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Initialize the web server.
+ *  Initialize the web server.
  */
 
 static int initWebs(int demo)
 {
-	struct hostent	*hp;
-	struct in_addr	intaddr;
-	char			host[128], dir[128], webdir[128];
-	char			*cp;
-	char_t			wbuf[128];
+    struct hostent  *hp;
+    struct in_addr  intaddr;
+    char            host[128], dir[128], webdir[128];
+    char            *cp;
+    char_t          wbuf[128];
 
 /*
- *	Initialize the socket subsystem
+ *  Initialize the socket subsystem
  */
-	socketOpen();
+    socketOpen();
 
 #ifdef USER_MANAGEMENT_SUPPORT
 /*
- *	Initialize the User Management database
+ *  Initialize the User Management database
  */
-	umOpen();
-	umRestore(T("umconfig.txt"));
+    umOpen();
+    umRestore(T("umconfig.txt"));
 #endif
 
 /*
- *	Define the local Ip address, host name, default home page and the 
- *	root web directory.
+ *  Define the local Ip address, host name, default home page and the 
+ *  root web directory.
  */
-	if (gethostname(host, sizeof(host)) < 0) {
-		error(E_L, E_LOG, T("Can't get hostname"));
-		return -1;
-	}
-	if ((hp = gethostbyname(host)) == NULL) {
-		error(E_L, E_LOG, T("Can't get host address"));
-		return -1;
-	}
-	memcpy((char *) &intaddr, (char *) hp->h_addr_list[0],
-		(size_t) hp->h_length);
+    if (gethostname(host, sizeof(host)) < 0) {
+        error(E_L, E_LOG, T("Can't get hostname"));
+        return -1;
+    }
+    if ((hp = gethostbyname(host)) == NULL) {
+        error(E_L, E_LOG, T("Can't get host address"));
+        return -1;
+    }
+    memcpy((char *) &intaddr, (char *) hp->h_addr_list[0],
+        (size_t) hp->h_length);
 
 /*
- *	Set ../web as the root web. Modify this to suit your needs
+ *  Set ../web as the root web. Modify this to suit your needs
  */
-	getcwd(dir, sizeof(dir)); 
-	if ((cp = strrchr(dir, '/'))) {
-		*cp = '\0';
-	}
-	if (demo) {
-		sprintf(webdir, "%s/%s", dir, demoWeb);
-	} else {
-		sprintf(webdir, "%s/%s", dir, rootWeb);
-	}
+    getcwd(dir, sizeof(dir)); 
+    if ((cp = strrchr(dir, '/'))) {
+        *cp = '\0';
+    }
+    if (demo) {
+        sprintf(webdir, "%s/%s", dir, demoWeb);
+    } else {
+        sprintf(webdir, "%s/%s", dir, rootWeb);
+    }
 
 /*
- *	Configure the web server options before opening the web server
+ *  Configure the web server options before opening the web server
  */
-	websSetDefaultDir(webdir);
-	cp = inet_ntoa(intaddr);
-	ascToUni(wbuf, cp, min(strlen(cp) + 1, sizeof(wbuf)));
-	websSetIpaddr(wbuf);
-	ascToUni(wbuf, host, min(strlen(host) + 1, sizeof(wbuf)));
-	websSetHost(wbuf);
+    websSetDefaultDir(webdir);
+    cp = inet_ntoa(intaddr);
+    ascToUni(wbuf, cp, min(strlen(cp) + 1, sizeof(wbuf)));
+    websSetIpaddr(wbuf);
+    ascToUni(wbuf, host, min(strlen(host) + 1, sizeof(wbuf)));
+    websSetHost(wbuf);
 
 /*
- *	Configure the web server options before opening the web server
+ *  Configure the web server options before opening the web server
  */
-	websSetDefaultPage(T("default.asp"));
-	websSetPassword(password);
+    websSetDefaultPage(T("default.asp"));
+    websSetPassword(password);
 
 /* 
- *	Open the web server on the given port. If that port is taken, try
- *	the next sequential port for up to "retries" attempts.
+ *  Open the web server on the given port. If that port is taken, try
+ *  the next sequential port for up to "retries" attempts.
  */
-	websOpenServer(port, retries);
+    websOpenServer(port, retries);
 
 /*
- * 	First create the URL handlers. Note: handlers are called in sorted order
- *	with the longest path handler examined first. Here we define the security 
- *	handler, forms handler and the default web page handler.
+ *  First create the URL handlers. Note: handlers are called in sorted order
+ *  with the longest path handler examined first. Here we define the security 
+ *  handler, forms handler and the default web page handler.
  */
-	websUrlHandlerDefine(T(""), NULL, 0, websSecurityHandler, 
-		WEBS_HANDLER_FIRST);
-	websUrlHandlerDefine(T("/goform"), NULL, 0, websFormHandler, 0);
-	websUrlHandlerDefine(T("/cgi-bin"), NULL, 0, websCgiHandler, 0);
-	websUrlHandlerDefine(T(""), NULL, 0, websDefaultHandler, 
-		WEBS_HANDLER_LAST); 
+    websUrlHandlerDefine(T(""), NULL, 0, websSecurityHandler, 
+        WEBS_HANDLER_FIRST);
+    websUrlHandlerDefine(T("/goform"), NULL, 0, websFormHandler, 0);
+    websUrlHandlerDefine(T("/cgi-bin"), NULL, 0, websCgiHandler, 0);
+    websUrlHandlerDefine(T(""), NULL, 0, websDefaultHandler, 
+        WEBS_HANDLER_LAST); 
 
 /*
- *	Now define two test procedures. Replace these with your application
- *	relevant ASP script procedures and form functions.
+ *  Now define two test procedures. Replace these with your application
+ *  relevant ASP script procedures and form functions.
  */
-	websAspDefine(T("aspTest"), aspTest);
-	websFormDefine(T("formTest"), formTest);
+    websAspDefine(T("aspTest"), aspTest);
+    websFormDefine(T("formTest"), formTest);
 
 /*
- *	Create the Form handlers for the User Management pages
+ *  Create the Form handlers for the User Management pages
  */
 #ifdef USER_MANAGEMENT_SUPPORT
-	formDefineUserMgmt();
+    formDefineUserMgmt();
 #endif
 
 /*
- *	Create a handler for the default home page
+ *  Create a handler for the default home page
  */
-	websUrlHandlerDefine(T("/"), NULL, 0, websHomePageHandler, 0); 
-	return 0;
+    websUrlHandlerDefine(T("/"), NULL, 0, websHomePageHandler, 0); 
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Test Javascript binding for ASP. This will be invoked when "aspTest" is
- *	embedded in an ASP page. See web/asp.asp for usage. Set browser to 
- *	"localhost/asp.asp" to test.
+ *  Test Javascript binding for ASP. This will be invoked when "aspTest" is
+ *  embedded in an ASP page. See web/asp.asp for usage. Set browser to 
+ *  "localhost/asp.asp" to test.
  */
 
 static int aspTest(int eid, webs_t wp, int argc, char_t **argv)
 {
-	char_t	*name, *address;
+    char_t  *name, *address;
 
-	if (ejArgs(argc, argv, T("%s %s"), &name, &address) < 2) {
-		websError(wp, 400, T("Insufficient args\n"));
-		return -1;
-	}
-	return websWrite(wp, T("Name: %s, Address %s"), name, address);
+    if (ejArgs(argc, argv, T("%s %s"), &name, &address) < 2) {
+        websError(wp, 400, T("Insufficient args\n"));
+        return -1;
+    }
+    return websWrite(wp, T("Name: %s, Address %s"), name, address);
 }
 /******************************************************************************/
 /*
- *	Test form for posted data (in-memory CGI). This will be called when the
- *	form in web/forms.asp is invoked. Set browser to "localhost/forms.asp" to test.
+ *  Test form for posted data (in-memory CGI). This will be called when the
+ *  form in web/forms.asp is invoked. Set browser to "localhost/forms.asp" to test.
  */
 
 static void formTest(webs_t wp, char_t *path, char_t *query)
 {
-	char_t	*name, *address;
+    char_t  *name, *address;
 
-	name = websGetVar(wp, T("name"), T("Joe Smith")); 
-	address = websGetVar(wp, T("address"), T("1212 Milky Way Ave.")); 
+    name = websGetVar(wp, T("name"), T("Joe Smith")); 
+    address = websGetVar(wp, T("address"), T("1212 Milky Way Ave.")); 
 
-	websHeader(wp);
-	websWrite(wp, T("<body><h2>Name: %s, Address: %s</h2>\n"), name, address);
-	websFooter(wp);
-	websDone(wp, 200);
+    websHeader(wp);
+    websWrite(wp, T("<body><h2>Name: %s, Address: %s</h2>\n"), name, address);
+    websFooter(wp);
+    websDone(wp, 200);
 }
 
 /******************************************************************************/
 /*
- *	Home page handler
+ *  Home page handler
  */
 
 static int websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
-	int arg, char_t *url, char_t *path, char_t *query)
+    int arg, char_t *url, char_t *path, char_t *query)
 {
 /*
- *	If the empty or "/" URL is invoked, redirect default URLs to the home page
+ *  If the empty or "/" URL is invoked, redirect default URLs to the home page
  */
-	if (*url == '\0' || gstrcmp(url, T("/")) == 0) {
-		websRedirect(wp, T("home.asp"));
-		return 1;
-	}
-	return 0;
+    if (*url == '\0' || gstrcmp(url, T("/")) == 0) {
+        websRedirect(wp, T("home.asp"));
+        return 1;
+    }
+    return 0;
 }
 
 /******************************************************************************/
@@ -293,28 +293,28 @@ static int websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
 #ifdef B_STATS
 static void memLeaks() 
 {
-	int		fd;
+    int     fd;
 
-	if ((fd = gopen(T("leak.txt"), O_CREAT | O_TRUNC | O_WRONLY)) >= 0) {
-		bstats(fd, printMemStats);
-		close(fd);
-	}
+    if ((fd = gopen(T("leak.txt"), O_CREAT | O_TRUNC | O_WRONLY)) >= 0) {
+        bstats(fd, printMemStats);
+        close(fd);
+    }
 }
 
 /******************************************************************************/
 /*
- *	Print memory usage / leaks
+ *  Print memory usage / leaks
  */
 
 static void printMemStats(int handle, char_t *fmt, ...)
 {
-	va_list		args;
-	char_t		buf[256];
+    va_list     args;
+    char_t      buf[256];
 
-	va_start(args, fmt);
-	vsprintf(buf, fmt, args);
-	va_end(args);
-	write(handle, buf, strlen(buf));
+    va_start(args, fmt);
+    vsprintf(buf, fmt, args);
+    va_end(args);
+    write(handle, buf, strlen(buf));
 }
 #endif
 
diff --git a/VXWORKS/main.c b/VXWORKS/main.c
index 6cb65218..7840c57a 100644
--- a/VXWORKS/main.c
+++ b/VXWORKS/main.c
@@ -10,52 +10,52 @@
 /******************************** Description *********************************/
 
 /*
- *	Main program for for the GoAhead WebServer. This is a demonstration
- *	main program to initialize and configure the web server.
+ *  Main program for for the GoAhead WebServer. This is a demonstration
+ *  main program to initialize and configure the web server.
  */
 
 /********************************* Includes ***********************************/
 
-#include	<envLib.h>
-#include	<hostLib.h>
-#include	<iosLib.h>
-#include	<loadLib.h>
-#include	<sigLib.h>
-#include	<sysSymTbl.h>
-#include	<unldLib.h>
+#include    <envLib.h>
+#include    <hostLib.h>
+#include    <iosLib.h>
+#include    <loadLib.h>
+#include    <sigLib.h>
+#include    <sysSymTbl.h>
+#include    <unldLib.h>
 
-#include	"../uemf.h"
-#include	"../wsIntrn.h"
+#include    "../uemf.h"
+#include    "../wsIntrn.h"
 
 #ifdef WEBS_SSL_SUPPORT
-#include	"../websSSL.h"
+#include    "../websSSL.h"
 #endif
 
 #ifdef USER_MANAGEMENT_SUPPORT
-#include	"../um.h"
-void	formDefineUserMgmt(void);
+#include    "../um.h"
+void    formDefineUserMgmt(void);
 #endif
 
 /*********************************** Locals ***********************************/
 /*
- *	Change configuration here
+ *  Change configuration here
  */
-#define				ROOT_DIR		T("/ata0/webs")
+#define             ROOT_DIR        T("/ata0/webs")
 
-static char_t		*rootWeb = T("www");			/* Root web directory */
-static char_t		*demoWeb = T("wwwdemo");		/* Root web directory */
-static char_t		*password = T("");				/* Security password */
-static int			port = 80;						/* Server port */
-static int			retries = 5;					/* Server port retries */
-static int			finished;						/* Finished flag */
+static char_t       *rootWeb = T("www");            /* Root web directory */
+static char_t       *demoWeb = T("wwwdemo");        /* Root web directory */
+static char_t       *password = T("");              /* Security password */
+static int          port = 80;                      /* Server port */
+static int          retries = 5;                    /* Server port retries */
+static int          finished;                       /* Finished flag */
 
 /****************************** Forward Declarations **************************/
 
-static int 	initWebs(int demo);
-static int	aspTest(int eid, webs_t wp, int argc, char_t **argv);
+static int  initWebs(int demo);
+static int  aspTest(int eid, webs_t wp, int argc, char_t **argv);
 static void formTest(webs_t wp, char_t *path, char_t *query);
 static int  websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
-				int arg, char_t *url, char_t *path, char_t *query);
+                int arg, char_t *url, char_t *path, char_t *query);
 static void websTermSigHandler(int signo);
 #ifdef B_STATS
 static void printMemStats(int handle, char_t *fmt, ...);
@@ -64,347 +64,347 @@ static void memLeaks();
 
 /*********************************** Code *************************************/
 /*
- *	Main -- entry point from VXWORKS
+ *  Main -- entry point from VXWORKS
  */
 
 int websvxmain(int argc, char **argv)
 {
-	int i, demo = 0;
+    int i, demo = 0;
 
-	for (i = 1; i < argc; i++) {
-		if (strcmp(argv[i], "-demo") == 0) {
-			demo++;
-		}
-	}
+    for (i = 1; i < argc; i++) {
+        if (strcmp(argv[i], "-demo") == 0) {
+            demo++;
+        }
+    }
 
 /*
- *	Initialize the memory allocator. Allow use of malloc and start 
- *	with a 60K heap.  For each page request approx 8KB is allocated.
- *	60KB allows for several concurrent page requests.  If more space
- *	is required, malloc will be used for the overflow.
+ *  Initialize the memory allocator. Allow use of malloc and start 
+ *  with a 60K heap.  For each page request approx 8KB is allocated.
+ *  60KB allows for several concurrent page requests.  If more space
+ *  is required, malloc will be used for the overflow.
  */
-	bopen(NULL, (60 * 1024), B_USE_MALLOC);
+    bopen(NULL, (60 * 1024), B_USE_MALLOC);
 
 /*
- *	Initialize the web server
+ *  Initialize the web server
  */
-	finished = 0;
-	if (initWebs(demo) < 0) {
-		return -1;
-	}
+    finished = 0;
+    if (initWebs(demo) < 0) {
+        return -1;
+    }
 
 #ifdef WEBS_SSL_SUPPORT
-	websSSLOpen();
+    websSSLOpen();
 #endif
 
 /*
- *	Basic event loop. SocketReady returns true when a socket is ready for
- *	service. SocketSelect will block for two seconds or until an event
- *	occurs. SocketProcess will actually do the servicing.
- */
-	while (!finished) {
-		if (socketReady(-1) || socketSelect(-1, 2000)) {
-			socketProcess(-1);
-		}
-		websCgiCleanup();
-		emfSchedProcess();
-	}
+ *  Basic event loop. SocketReady returns true when a socket is ready for
+ *  service. SocketSelect will block for two seconds or until an event
+ *  occurs. SocketProcess will actually do the servicing.
+ */
+    while (!finished) {
+        if (socketReady(-1) || socketSelect(-1, 2000)) {
+            socketProcess(-1);
+        }
+        websCgiCleanup();
+        emfSchedProcess();
+    }
 
 #ifdef WEBS_SSL_SUPPORT
-	websSSLClose();
+    websSSLClose();
 #endif
 
 #ifdef USER_MANAGEMENT_SUPPORT
-	umClose();
+    umClose();
 #endif
 
 /*
- *	Close the socket module, report memory leaks and close the memory allocator
+ *  Close the socket module, report memory leaks and close the memory allocator
  */
-	websCloseServer();
-	socketClose();
-	symSubClose();
+    websCloseServer();
+    socketClose();
+    symSubClose();
 #ifdef B_STATS
-	memLeaks();
+    memLeaks();
 #endif
-	bclose();
-	return 0;
+    bclose();
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Initialize the web server.
+ *  Initialize the web server.
  */
 
 static int initWebs(int demo)
 {
-	struct in_addr	intaddr;
-	char			*pString;
-	char			host[64], webdir[128];
-	char_t			wbuf[128];
+    struct in_addr  intaddr;
+    char            *pString;
+    char            host[64], webdir[128];
+    char_t          wbuf[128];
 
 /*
- *	Initialize the socket and sym subsystems
+ *  Initialize the socket and sym subsystems
  */
-	socketOpen();
-	symSubOpen();
+    socketOpen();
+    symSubOpen();
 
 #ifdef USER_MANAGEMENT_SUPPORT
 /*
- *	Initialize the User Management database
+ *  Initialize the User Management database
  */
-	umOpen();
-	umRestore(T("umconfig.txt"));
+    umOpen();
+    umRestore(T("umconfig.txt"));
 #endif
 
 /*
- *	Define the local Ip address, host name, default home page and the 
- *	root web directory.
+ *  Define the local Ip address, host name, default home page and the 
+ *  root web directory.
  */
-	if (gethostname(host, sizeof(host)) < 0) {
-		error(E_L, E_LOG, T("Can't get hostname"));
-		return -1;
-	}
-	intaddr.s_addr = (unsigned long) hostGetByName(host);
+    if (gethostname(host, sizeof(host)) < 0) {
+        error(E_L, E_LOG, T("Can't get hostname"));
+        return -1;
+    }
+    intaddr.s_addr = (unsigned long) hostGetByName(host);
 
 
 /*
- *	Set ../web as the root web. Modify this to suit your needs
+ *  Set ../web as the root web. Modify this to suit your needs
  */
-	if (demo) {
-		sprintf(webdir, "%s/%s", ROOT_DIR, demoWeb);
-	} else {
-		sprintf(webdir, "%s/%s", ROOT_DIR, rootWeb);
-	}
+    if (demo) {
+        sprintf(webdir, "%s/%s", ROOT_DIR, demoWeb);
+    } else {
+        sprintf(webdir, "%s/%s", ROOT_DIR, rootWeb);
+    }
 
 /*
- *	Configure the web server options before opening the web server
+ *  Configure the web server options before opening the web server
  */
-	websSetDefaultDir(webdir);
-	pString = inet_ntoa(intaddr);
-	ascToUni(wbuf, pString, min(strlen(pString) + 1, sizeof(wbuf)));
-	free(pString);
-	websSetIpaddr(wbuf);
-	ascToUni(wbuf, host, min(strlen(host) + 1, sizeof(wbuf)));
-	websSetHost(wbuf);
+    websSetDefaultDir(webdir);
+    pString = inet_ntoa(intaddr);
+    ascToUni(wbuf, pString, min(strlen(pString) + 1, sizeof(wbuf)));
+    free(pString);
+    websSetIpaddr(wbuf);
+    ascToUni(wbuf, host, min(strlen(host) + 1, sizeof(wbuf)));
+    websSetHost(wbuf);
 
 /*
- *	Configure the web server options before opening the web server
+ *  Configure the web server options before opening the web server
  */
-	websSetDefaultPage(T("default.asp"));
-	websSetPassword(password);
+    websSetDefaultPage(T("default.asp"));
+    websSetPassword(password);
 
 /* 
- *	Open the web server on the given port. If that port is taken, try
- *	the next sequential port for up to "retries" attempts.
+ *  Open the web server on the given port. If that port is taken, try
+ *  the next sequential port for up to "retries" attempts.
  */
-	websOpenServer(port, retries);
+    websOpenServer(port, retries);
 
 /*
- * 	First create the URL handlers. Note: handlers are called in sorted order
- *	with the longest path handler examined first. Here we define the security 
- *	handler, forms handler and the default web page handler.
+ *  First create the URL handlers. Note: handlers are called in sorted order
+ *  with the longest path handler examined first. Here we define the security 
+ *  handler, forms handler and the default web page handler.
  */
-	websUrlHandlerDefine(T(""), NULL, 0, websSecurityHandler, 
-		WEBS_HANDLER_FIRST);
-	websUrlHandlerDefine(T("/goform"), NULL, 0, websFormHandler, 0);
-	websUrlHandlerDefine(T("/cgi-bin"), NULL, 0, websCgiHandler, 0);
-	websUrlHandlerDefine(T(""), NULL, 0, websDefaultHandler, 
-		WEBS_HANDLER_LAST); 
+    websUrlHandlerDefine(T(""), NULL, 0, websSecurityHandler, 
+        WEBS_HANDLER_FIRST);
+    websUrlHandlerDefine(T("/goform"), NULL, 0, websFormHandler, 0);
+    websUrlHandlerDefine(T("/cgi-bin"), NULL, 0, websCgiHandler, 0);
+    websUrlHandlerDefine(T(""), NULL, 0, websDefaultHandler, 
+        WEBS_HANDLER_LAST); 
 
 /*
- *	Now define two test procedures. Replace these with your application
- *	relevant ASP script procedures and form functions.
+ *  Now define two test procedures. Replace these with your application
+ *  relevant ASP script procedures and form functions.
  */
-	websAspDefine(T("aspTest"), aspTest);
-	websFormDefine(T("formTest"), formTest);
+    websAspDefine(T("aspTest"), aspTest);
+    websFormDefine(T("formTest"), formTest);
 
 /*
- *	Create the Form handlers for the User Management pages
+ *  Create the Form handlers for the User Management pages
  */
 #ifdef USER_MANAGEMENT_SUPPORT
-	formDefineUserMgmt();
+    formDefineUserMgmt();
 #endif
 
 /*
- *	Create a handler for the default home page
+ *  Create a handler for the default home page
  */
-	websUrlHandlerDefine(T("/"), NULL, 0, websHomePageHandler, 0); 
+    websUrlHandlerDefine(T("/"), NULL, 0, websHomePageHandler, 0); 
 
 /*
- *	Provide signal for clean up on termination.
+ *  Provide signal for clean up on termination.
  */
-	signal(SIGTERM,	websTermSigHandler);
-	signal(SIGKILL,	websTermSigHandler);
+    signal(SIGTERM, websTermSigHandler);
+    signal(SIGKILL, websTermSigHandler);
 
-	return 0;
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Test Javascript binding for ASP. This will be invoked when "aspTest" is
- *	embedded in an ASP page. See web/asp.asp for usage. Set browser to 
- *	"localhost/asp.asp" to test.
+ *  Test Javascript binding for ASP. This will be invoked when "aspTest" is
+ *  embedded in an ASP page. See web/asp.asp for usage. Set browser to 
+ *  "localhost/asp.asp" to test.
  */
 
 static int aspTest(int eid, webs_t wp, int argc, char_t **argv)
 {
-	char_t	*name, *address;
+    char_t  *name, *address;
 
-	if (ejArgs(argc, argv, T("%s %s"), &name, &address) < 2) {
-		websError(wp, 400, T("Insufficient args\n"));
-		return -1;
-	}
-	return websWrite(wp, T("Name: %s, Address %s"), name, address);
+    if (ejArgs(argc, argv, T("%s %s"), &name, &address) < 2) {
+        websError(wp, 400, T("Insufficient args\n"));
+        return -1;
+    }
+    return websWrite(wp, T("Name: %s, Address %s"), name, address);
 }
 /******************************************************************************/
 /*
- *	Test form for posted data (in-memory CGI). This will be called when the
- *	form in web/forms.asp is invoked. Set browser to "localhost/forms.asp" to test.
+ *  Test form for posted data (in-memory CGI). This will be called when the
+ *  form in web/forms.asp is invoked. Set browser to "localhost/forms.asp" to test.
  */
 
 static void formTest(webs_t wp, char_t *path, char_t *query)
 {
-	char_t	*name, *address;
+    char_t  *name, *address;
 
-	name = websGetVar(wp, T("name"), T("Joe Smith")); 
-	address = websGetVar(wp, T("address"), T("1212 Milky Way Ave.")); 
+    name = websGetVar(wp, T("name"), T("Joe Smith")); 
+    address = websGetVar(wp, T("address"), T("1212 Milky Way Ave.")); 
 
-	websHeader(wp);
-	websWrite(wp, T("<body><h2>Name: %s, Address: %s</h2>\n"), name, address);
-	websFooter(wp);
-	websDone(wp, 200);
+    websHeader(wp);
+    websWrite(wp, T("<body><h2>Name: %s, Address: %s</h2>\n"), name, address);
+    websFooter(wp);
+    websDone(wp, 200);
 }
 
 /******************************************************************************/
 /*
- *	Home page handler
+ *  Home page handler
  */
 
 static int websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
-	int arg, char_t *url, char_t *path, char_t *query)
+    int arg, char_t *url, char_t *path, char_t *query)
 {
 /*
- *	If the empty or "/" URL is invoked, redirect default URLs to the home page
+ *  If the empty or "/" URL is invoked, redirect default URLs to the home page
  */
-	if (*url == '\0' || gstrcmp(url, T("/")) == 0) {
-		websRedirect(wp, T("home.asp"));
-		return 1;
-	}
-	return 0;
+    if (*url == '\0' || gstrcmp(url, T("/")) == 0) {
+        websRedirect(wp, T("home.asp"));
+        return 1;
+    }
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Signal handler.  Process the terminate signals SIGTERM and SIGKILL.
- *	If the signal is SIGTERM, just set the flag so the next time
- *	through the event loop, the webserver will terminate itself cleanly.
- *	If the signal is SIGKILL, release the resources and exit immediately.
+ *  Signal handler.  Process the terminate signals SIGTERM and SIGKILL.
+ *  If the signal is SIGTERM, just set the flag so the next time
+ *  through the event loop, the webserver will terminate itself cleanly.
+ *  If the signal is SIGKILL, release the resources and exit immediately.
  */
 
 static void websTermSigHandler(int signo)
 {
-	if (signo == SIGTERM) {
-		finished = 1;
-	} else if (signo == SIGKILL) {
+    if (signo == SIGTERM) {
+        finished = 1;
+    } else if (signo == SIGKILL) {
 #ifdef WEBS_SSL_SUPPORT
-		websSSLClose();
+        websSSLClose();
 #endif
 
 #ifdef USER_MANAGEMENT_SUPPORT
-		umClose();
+        umClose();
 #endif
-		websCloseServer();
-		socketClose();
-		symSubClose();
+        websCloseServer();
+        socketClose();
+        symSubClose();
 #ifdef B_STATS
-		memLeaks();
+        memLeaks();
 #endif
-		bclose();
-		exit(1);
-	}
+        bclose();
+        exit(1);
+    }
 }
 
 /******************************************************************************/
 /*
- *	Get absolute path.  In VxWorks, functions like chdir, ioctl for mkdir
- *	and ioctl for rmdir, require an absolute path.  This function will
- *	take the path argument and convert it to an absolute path.  It is the
- *	caller's responsibility to deallocate the returned string. 
+ *  Get absolute path.  In VxWorks, functions like chdir, ioctl for mkdir
+ *  and ioctl for rmdir, require an absolute path.  This function will
+ *  take the path argument and convert it to an absolute path.  It is the
+ *  caller's responsibility to deallocate the returned string. 
  */
 
 static char_t *getAbsolutePath(char_t *path)
 {
-	char_t	*tail;
-	char_t	*dev;
+    char_t  *tail;
+    char_t  *dev;
 
 /*
- *	Determine if path is relative or absolute.  If relative, prepend
- *	the current working directory to the name.  Otherwise, use it.
- *	Note the getcwd call below must not be ggetcwd or else we go into
- *	an infinite loop
- */
-	if (iosDevFind(path, &tail) != NULL && path != tail) {
-		return bstrdup(B_L, path);
-	}
-	dev = balloc(B_L, LF_PATHSIZE);
-	getcwd(dev, LF_PATHSIZE);
-	strcat(dev, "/");
-	strcat(dev, path);
-	return dev;
+ *  Determine if path is relative or absolute.  If relative, prepend
+ *  the current working directory to the name.  Otherwise, use it.
+ *  Note the getcwd call below must not be ggetcwd or else we go into
+ *  an infinite loop
+ */
+    if (iosDevFind(path, &tail) != NULL && path != tail) {
+        return bstrdup(B_L, path);
+    }
+    dev = balloc(B_L, LF_PATHSIZE);
+    getcwd(dev, LF_PATHSIZE);
+    strcat(dev, "/");
+    strcat(dev, path);
+    return dev;
 }
 
 /******************************************************************************/
 /*
- *	Change default working directory.
+ *  Change default working directory.
  */
 
 int vxchdir(char_t *dirname)
 {
-	int		rc;
-	char_t	*path;
+    int     rc;
+    char_t  *path;
 
 /*
- *	Get an absolute path name for the directory.
+ *  Get an absolute path name for the directory.
  */
-	path = getAbsolutePath(dirname);
+    path = getAbsolutePath(dirname);
 
 /*
- *	Now change the default working directory.  The chdir call
- *	below must not be replaced with gchdir or else an infinite
- *	loop will occur.
+ *  Now change the default working directory.  The chdir call
+ *  below must not be replaced with gchdir or else an infinite
+ *  loop will occur.
  */
-	rc = chdir(path);
-	bfree(B_L, path);
-	return rc;
+    rc = chdir(path);
+    bfree(B_L, path);
+    return rc;
 }
 
 /******************************************************************************/
 #ifdef B_STATS
 static void memLeaks() 
 {
-	int		fd;
+    int     fd;
 
-	if ((fd = gopen(T("leak.txt"), O_CREAT | O_TRUNC | O_WRONLY, 0644)) >= 0) {
-		bstats(fd, printMemStats);
-		close(fd);
-	}
+    if ((fd = gopen(T("leak.txt"), O_CREAT | O_TRUNC | O_WRONLY, 0644)) >= 0) {
+        bstats(fd, printMemStats);
+        close(fd);
+    }
 }
 
 /******************************************************************************/
 /*
- *	Print memory usage / leaks
+ *  Print memory usage / leaks
  */
 
 static void printMemStats(int handle, char_t *fmt, ...)
 {
-	va_list		args;
-	char_t		buf[256];
+    va_list     args;
+    char_t      buf[256];
 
-	va_start(args, fmt);
-	vsprintf(buf, fmt, args);
-	va_end(args);
-	write(handle, buf, strlen(buf));
+    va_start(args, fmt);
+    vsprintf(buf, fmt, args);
+    va_end(args);
+    write(handle, buf, strlen(buf));
 }
 #endif
 
diff --git a/VXWORKS/vxcgitst.c b/VXWORKS/vxcgitst.c
index 7842c0db..75d6af05 100644
--- a/VXWORKS/vxcgitst.c
+++ b/VXWORKS/vxcgitst.c
@@ -1,5 +1,5 @@
-#include	<envLib.h>
-#include	<stdio.h>
+#include    <envLib.h>
+#include    <stdio.h>
 
 void vxcgitst_cgientry(int argc, char **argv)
 {
diff --git a/WIN/main.c b/WIN/main.c
index f302524a..bbfd3fd7 100644
--- a/WIN/main.c
+++ b/WIN/main.c
@@ -10,471 +10,471 @@
 /******************************** Description *********************************/
 
 /*
- *	Main program for the GoAhead WebServer. This is a demonstration
- *	program to initialize and configure the web server.
+ *  Main program for the GoAhead WebServer. This is a demonstration
+ *  program to initialize and configure the web server.
  */
 
 /********************************* Includes ***********************************/
 
-#include	<direct.h>
-#include	<windows.h>
-#include	<winuser.h>
-#include	<process.h>
+#include    <direct.h>
+#include    <windows.h>
+#include    <winuser.h>
+#include    <process.h>
 
-#include	"../wsIntrn.h"
+#include    "../wsIntrn.h"
 
 #ifdef WEBS_SSL_SUPPORT
-#include	"../websSSL.h"
+#include    "../websSSL.h"
 #endif
 
 #ifdef USER_MANAGEMENT_SUPPORT
-#include	"../um.h"
-void		formDefineUserMgmt(void);
+#include    "../um.h"
+void        formDefineUserMgmt(void);
 #endif
 
 /********************************** Defines ***********************************/
 /*
-	Enable USE_DEMO_MODE to run Webs with the documentation tree and examples 
+    Enable USE_DEMO_MODE to run Webs with the documentation tree and examples 
 */
-/* #define USE_DEMO_MODE		1 */
+/* #define USE_DEMO_MODE        1 */
 
-#define	IDM_ABOUTBOX		0xF200
-#define	IDS_ABOUTBOX		"AboutBox"
-#define	IDC_VERSION			101
-#define	IDC_BUILDDATE		102
-#define	IDC_DISMISS			103
-#define	SOCK_DFT_SVC_TIME	20
+#define IDM_ABOUTBOX        0xF200
+#define IDS_ABOUTBOX        "AboutBox"
+#define IDC_VERSION         101
+#define IDC_BUILDDATE       102
+#define IDC_DISMISS         103
+#define SOCK_DFT_SVC_TIME   20
 
 /*********************************** Globals **********************************/
 /*
- *	User configurable globals	
+ *  User configurable globals   
  */
-static char_t	*rootWeb = T("www");			/* Root web directory */
-static char_t	*demoWeb = T("wwwdemo");		/* Root web directory */
-static char_t	*password = T("");				/* Security password */
+static char_t   *rootWeb = T("www");            /* Root web directory */
+static char_t   *demoWeb = T("wwwdemo");        /* Root web directory */
+static char_t   *password = T("");              /* Security password */
 
 /* Globals */
-static int		port = WEBS_DEFAULT_PORT;		/* Server port */
-static char_t	*title = T("GoAhead WebServer");/* Window title */
-static char_t	*name = T("gowebs");			/* Window name */
-static HWND		hwnd;							/* Main Window handle */
-static HWND		hwndAbout;						/* About Window handle */
-static int		retries = 5;					/* Server port retries */
-static int		finished;						/* Finished flag */
-static int		sockServiceTime;				/* in milliseconds */
+static int      port = WEBS_DEFAULT_PORT;       /* Server port */
+static char_t   *title = T("GoAhead WebServer");/* Window title */
+static char_t   *name = T("gowebs");            /* Window name */
+static HWND     hwnd;                           /* Main Window handle */
+static HWND     hwndAbout;                      /* About Window handle */
+static int      retries = 5;                    /* Server port retries */
+static int      finished;                       /* Finished flag */
+static int      sockServiceTime;                /* in milliseconds */
 
 /****************************** Forward Declarations **************************/
 
-static int		initWebs(int demo);
-static long		CALLBACK websWindProc(HWND hwnd, unsigned int msg, 
-				unsigned int wp, long lp);
-static long		CALLBACK websAboutProc(HWND hwnd, unsigned int msg, 
-				unsigned int wp, long lp);
-static int		registerAboutBox(HINSTANCE hInstance);
-static int		createAboutBox(HINSTANCE hInstance, HWND hwnd);
-static int		aspTest(int eid, webs_t wp, int argc, char_t **argv);
-static WPARAM	checkWindowsMsgLoop();
-static void		formTest(webs_t wp, char_t *path, char_t *query);
-static int		windowsInit(HINSTANCE hinstance);
-static int		windowsClose(HINSTANCE hinstance);
-static int		websHomePageHandler(webs_t wp, char_t *urlPrefix,
-					char_t *webDir, int arg, char_t *url, char_t *path,
-					char_t *query);
-static void		printMemStats(int handle, char_t *fmt, ...);
-static void		memLeaks();
-
-static LPWORD	lpwAlign(LPWORD);
-static int		nCopyAnsiToWideChar(LPWORD, LPSTR);
-static void		centerWindowOnDisplay(HWND hwndCenter);
+static int      initWebs(int demo);
+static long     CALLBACK websWindProc(HWND hwnd, unsigned int msg, 
+                unsigned int wp, long lp);
+static long     CALLBACK websAboutProc(HWND hwnd, unsigned int msg, 
+                unsigned int wp, long lp);
+static int      registerAboutBox(HINSTANCE hInstance);
+static int      createAboutBox(HINSTANCE hInstance, HWND hwnd);
+static int      aspTest(int eid, webs_t wp, int argc, char_t **argv);
+static WPARAM   checkWindowsMsgLoop();
+static void     formTest(webs_t wp, char_t *path, char_t *query);
+static int      windowsInit(HINSTANCE hinstance);
+static int      windowsClose(HINSTANCE hinstance);
+static int      websHomePageHandler(webs_t wp, char_t *urlPrefix,
+                    char_t *webDir, int arg, char_t *url, char_t *path,
+                    char_t *query);
+static void     printMemStats(int handle, char_t *fmt, ...);
+static void     memLeaks();
+
+static LPWORD   lpwAlign(LPWORD);
+static int      nCopyAnsiToWideChar(LPWORD, LPSTR);
+static void     centerWindowOnDisplay(HWND hwndCenter);
 
 /*********************************** Code *************************************/
 /*
- *	WinMain -- entry point from Windows
+ *  WinMain -- entry point from Windows
  */
 int APIENTRY WinMain(HINSTANCE hinstance, HINSTANCE hprevinstance,
-						char *args, int cmd_show)
+                        char *args, int cmd_show)
 {
-	WPARAM	rc;
+    WPARAM  rc;
 #ifdef USE_DEMO_MODE
-	int demo = 1;
+    int demo = 1;
 #else
-	int demo = 0;
+    int demo = 0;
 #endif /* USE_DEMO_MODE */
 
 /*
- *	Initialize the memory allocator. Allow use of malloc and start 
- *	with a 60K heap.  For each page request approx 8KB is allocated.
- *	60KB allows for several concurrent page requests.  If more space
- *	is required, malloc will be used for the overflow.
+ *  Initialize the memory allocator. Allow use of malloc and start 
+ *  with a 60K heap.  For each page request approx 8KB is allocated.
+ *  60KB allows for several concurrent page requests.  If more space
+ *  is required, malloc will be used for the overflow.
  */
-	bopen(NULL, (60 * 1024), B_USE_MALLOC);
+    bopen(NULL, (60 * 1024), B_USE_MALLOC);
 
 /* 
- *	Store the instance handle (used in socket.c)
+ *  Store the instance handle (used in socket.c)
  */
 
-	if (windowsInit(hinstance) < 0) {
-		return FALSE;
-	}
+    if (windowsInit(hinstance) < 0) {
+        return FALSE;
+    }
 
 /*
- *	Initialize the web server
+ *  Initialize the web server
  */
-	if (initWebs(demo) < 0) {
-		return FALSE;
-	}
+    if (initWebs(demo) < 0) {
+        return FALSE;
+    }
 
 #ifdef WEBS_SSL_SUPPORT
-	websSSLOpen();
-/*	websRequireSSL("/"); */ /* Require all files be served via https */
+    websSSLOpen();
+/*  websRequireSSL("/"); */ /* Require all files be served via https */
 #endif
 
 /*
- *	Basic event loop. SocketReady returns true when a socket is ready for
- *	service. SocketSelect will block until an event occurs. SocketProcess
- *	will actually do the servicing.
+ *  Basic event loop. SocketReady returns true when a socket is ready for
+ *  service. SocketSelect will block until an event occurs. SocketProcess
+ *  will actually do the servicing.
  */
-	while (!finished) {
-		if (socketReady(-1) || socketSelect(-1, sockServiceTime)) {
-			socketProcess(-1);
-		}
-		emfSchedProcess();
-		websCgiCleanup();
-		if ((rc = checkWindowsMsgLoop()) != 0) {
-			break;
-		}
-	}
+    while (!finished) {
+        if (socketReady(-1) || socketSelect(-1, sockServiceTime)) {
+            socketProcess(-1);
+        }
+        emfSchedProcess();
+        websCgiCleanup();
+        if ((rc = checkWindowsMsgLoop()) != 0) {
+            break;
+        }
+    }
 
 #ifdef WEBS_SSL_SUPPORT
-	websSSLClose();
+    websSSLClose();
 #endif
 
 /*
- *	Close the User Management database
+ *  Close the User Management database
  */
 #ifdef USER_MANAGEMENT_SUPPORT
-	umClose();
+    umClose();
 #endif
 
 /*
- *	Close the socket module, report memory leaks and close the memory allocator
+ *  Close the socket module, report memory leaks and close the memory allocator
  */
-	websCloseServer();
-	socketClose();
+    websCloseServer();
+    socketClose();
 
 /*
- *	Free up Windows resources
+ *  Free up Windows resources
  */
-	windowsClose(hinstance);
+    windowsClose(hinstance);
 
 #ifdef B_STATS
-	memLeaks();
+    memLeaks();
 #endif
-	bclose();
-	return rc;
+    bclose();
+    return rc;
 }
 
 /******************************************************************************/
 /*
- *	Initialize the web server.
+ *  Initialize the web server.
  */
 
 static int initWebs(int demo)
 {
-	struct hostent	*hp;
-	struct in_addr	intaddr;
-	char			*cp;
-	char			host[64], dir[128];
-	char_t			dir_t[128];
-	char_t			wbuf[256];
+    struct hostent  *hp;
+    struct in_addr  intaddr;
+    char            *cp;
+    char            host[64], dir[128];
+    char_t          dir_t[128];
+    char_t          wbuf[256];
 
 /*
- *	Initialize the socket subsystem
+ *  Initialize the socket subsystem
  */
-	socketOpen();
+    socketOpen();
 
 /*
- *	Initialize the User Management database
+ *  Initialize the User Management database
  */
 #ifdef USER_MANAGEMENT_SUPPORT
-	umOpen();
-	umRestore(T("umconfig.txt"));
+    umOpen();
+    umRestore(T("umconfig.txt"));
 #endif
 
 /*
- *	Define the local Ip address, host name, default home page and the 
- *	root web directory.
+ *  Define the local Ip address, host name, default home page and the 
+ *  root web directory.
  */
-	if (gethostname(host, sizeof(host)) < 0) {
-		error(E_L, E_LOG, T("Can't get hostname"));
-		return -1;
-	}
-	if ((hp = gethostbyname(host)) == NULL) {
-		error(E_L, E_LOG, T("Can't get host address"));
-		return -1;
-	}
-	memcpy((void *) &intaddr, (void *) hp->h_addr_list[0],
-		(size_t) hp->h_length);
+    if (gethostname(host, sizeof(host)) < 0) {
+        error(E_L, E_LOG, T("Can't get hostname"));
+        return -1;
+    }
+    if ((hp = gethostbyname(host)) == NULL) {
+        error(E_L, E_LOG, T("Can't get host address"));
+        return -1;
+    }
+    memcpy((void *) &intaddr, (void *) hp->h_addr_list[0],
+        (size_t) hp->h_length);
 
 /*
- *	Set ../web as the root web. Modify this to suit your needs
+ *  Set ../web as the root web. Modify this to suit your needs
  */
-	getcwd(dir, sizeof(dir)); 
-	for (cp = dir; *cp; cp++) {
-		if (*cp == '\\')
-			*cp = '/';
-	}
-	if (cp = strrchr(dir, '/')) {
-		*cp = '\0';
-	}
-	ascToUni(dir_t, dir, sizeof(dir_t));
+    getcwd(dir, sizeof(dir)); 
+    for (cp = dir; *cp; cp++) {
+        if (*cp == '\\')
+            *cp = '/';
+    }
+    if (cp = strrchr(dir, '/')) {
+        *cp = '\0';
+    }
+    ascToUni(dir_t, dir, sizeof(dir_t));
 
-	if (demo) {
-		gsprintf(wbuf, T("%s/%s"), dir_t, demoWeb);
-	} else {
-		gsprintf(wbuf, T("%s/%s"), dir_t, rootWeb);
-	}
-	websSetDefaultDir(wbuf);
-	cp = inet_ntoa(intaddr);
-	ascToUni(wbuf, cp, min(strlen(cp) + 1, sizeof(wbuf)));
-	websSetIpaddr(wbuf);
-	ascToUni(wbuf, hp->h_name, min(strlen(hp->h_name) + 1, sizeof(wbuf)));
-	websSetHost(wbuf);
+    if (demo) {
+        gsprintf(wbuf, T("%s/%s"), dir_t, demoWeb);
+    } else {
+        gsprintf(wbuf, T("%s/%s"), dir_t, rootWeb);
+    }
+    websSetDefaultDir(wbuf);
+    cp = inet_ntoa(intaddr);
+    ascToUni(wbuf, cp, min(strlen(cp) + 1, sizeof(wbuf)));
+    websSetIpaddr(wbuf);
+    ascToUni(wbuf, hp->h_name, min(strlen(hp->h_name) + 1, sizeof(wbuf)));
+    websSetHost(wbuf);
 
 /*
- *	Configure the web server options before opening the web server
+ *  Configure the web server options before opening the web server
  */
-	websSetDefaultPage(T("default.asp"));
-	websSetPassword(password);
+    websSetDefaultPage(T("default.asp"));
+    websSetPassword(password);
 
 /* 
- *	Open the web server on the given port. If that port is taken, try
- *	the next sequential port for up to "retries" attempts.
+ *  Open the web server on the given port. If that port is taken, try
+ *  the next sequential port for up to "retries" attempts.
  */
-	websOpenServer(port, retries);
+    websOpenServer(port, retries);
 
 /*
- * 	First create the URL handlers. Note: handlers are called in sorted order
- *	with the longest path handler examined first. Here we define the security 
- *	handler, forms handler and the default web page handler.
+ *  First create the URL handlers. Note: handlers are called in sorted order
+ *  with the longest path handler examined first. Here we define the security 
+ *  handler, forms handler and the default web page handler.
  */
-	websUrlHandlerDefine(T(""), NULL, 0, websSecurityHandler, 
-		WEBS_HANDLER_FIRST);
-	websUrlHandlerDefine(T("/goform"), NULL, 0, websFormHandler, 0);
-	websUrlHandlerDefine(T("/cgi-bin"), NULL, 0, websCgiHandler, 0);
-	websUrlHandlerDefine(T(""), NULL, 0, websDefaultHandler, 
-		WEBS_HANDLER_LAST); 
+    websUrlHandlerDefine(T(""), NULL, 0, websSecurityHandler, 
+        WEBS_HANDLER_FIRST);
+    websUrlHandlerDefine(T("/goform"), NULL, 0, websFormHandler, 0);
+    websUrlHandlerDefine(T("/cgi-bin"), NULL, 0, websCgiHandler, 0);
+    websUrlHandlerDefine(T(""), NULL, 0, websDefaultHandler, 
+        WEBS_HANDLER_LAST); 
 
 /*
- *	Now define two test procedures. Replace these with your application
- *	relevant ASP script procedures and form functions.
+ *  Now define two test procedures. Replace these with your application
+ *  relevant ASP script procedures and form functions.
  */
-	websAspDefine(T("aspTest"), aspTest);
-	websFormDefine(T("formTest"), formTest);
+    websAspDefine(T("aspTest"), aspTest);
+    websFormDefine(T("formTest"), formTest);
 /*
- *	Create the Form handlers for the User Management pages
+ *  Create the Form handlers for the User Management pages
  */
 #ifdef USER_MANAGEMENT_SUPPORT
-	formDefineUserMgmt();
+    formDefineUserMgmt();
 #endif
 
 /*
- *	Create a handler for the default home page
+ *  Create a handler for the default home page
  */
-	websUrlHandlerDefine(T("/"), NULL, 0, websHomePageHandler, 0); 
+    websUrlHandlerDefine(T("/"), NULL, 0, websHomePageHandler, 0); 
 
 /* 
- *	Set the socket service timeout to the default
+ *  Set the socket service timeout to the default
  */
-	sockServiceTime = SOCK_DFT_SVC_TIME;				
+    sockServiceTime = SOCK_DFT_SVC_TIME;                
 
-	return 0;
+    return 0;
 }
 
 
 /******************************************************************************/
 /*
- *	Create a taskbar entry. Register the window class and create a window
+ *  Create a taskbar entry. Register the window class and create a window
  */
 
 static int windowsInit(HINSTANCE hinstance)
 {
-	WNDCLASS  		wc;						/* Window class */
-	HMENU			hSysMenu;
+    WNDCLASS        wc;                     /* Window class */
+    HMENU           hSysMenu;
 
-	emfInstSet((int) hinstance);
+    emfInstSet((int) hinstance);
 
-	wc.style		 = CS_HREDRAW | CS_VREDRAW;
-	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
-	wc.hCursor		 = LoadCursor(NULL, IDC_ARROW);
-	wc.cbClsExtra	 = 0;
-	wc.cbWndExtra	 = 0;
-	wc.hInstance	 = hinstance;
-	wc.hIcon		 = NULL;
-	wc.lpfnWndProc	 = (WNDPROC) websWindProc;
-	wc.lpszMenuName	 = wc.lpszClassName = name;
-	if (! RegisterClass(&wc)) {
-		return -1;
-	}
+    wc.style         = CS_HREDRAW | CS_VREDRAW;
+    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
+    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
+    wc.cbClsExtra    = 0;
+    wc.cbWndExtra    = 0;
+    wc.hInstance     = hinstance;
+    wc.hIcon         = NULL;
+    wc.lpfnWndProc   = (WNDPROC) websWindProc;
+    wc.lpszMenuName  = wc.lpszClassName = name;
+    if (! RegisterClass(&wc)) {
+        return -1;
+    }
 
 /*
- *	Create a window just so we can have a taskbar to close this web server
+ *  Create a window just so we can have a taskbar to close this web server
  */
-	hwnd = CreateWindow(name, title, WS_MINIMIZE | WS_POPUPWINDOW,
-		CW_USEDEFAULT, 0, 0, 0, NULL, NULL, hinstance, NULL);
-	if (hwnd == NULL) {
-		return -1;
-	}
+    hwnd = CreateWindow(name, title, WS_MINIMIZE | WS_POPUPWINDOW,
+        CW_USEDEFAULT, 0, 0, 0, NULL, NULL, hinstance, NULL);
+    if (hwnd == NULL) {
+        return -1;
+    }
 
 /*
- *	Add the about box menu item to the system menu
- *	a_assert: IDM_ABOUTBOX must be in the system command range.
+ *  Add the about box menu item to the system menu
+ *  a_assert: IDM_ABOUTBOX must be in the system command range.
  */
-	hSysMenu = GetSystemMenu(hwnd, FALSE);
-	if (hSysMenu != NULL)
-	{
-		AppendMenu(hSysMenu, MF_SEPARATOR, 0, NULL);
-		AppendMenu(hSysMenu, MF_STRING, IDM_ABOUTBOX, T("About WebServer"));
-	}
+    hSysMenu = GetSystemMenu(hwnd, FALSE);
+    if (hSysMenu != NULL)
+    {
+        AppendMenu(hSysMenu, MF_SEPARATOR, 0, NULL);
+        AppendMenu(hSysMenu, MF_STRING, IDM_ABOUTBOX, T("About WebServer"));
+    }
 
-	ShowWindow(hwnd, SW_SHOWNORMAL);
-	UpdateWindow(hwnd);
+    ShowWindow(hwnd, SW_SHOWNORMAL);
+    UpdateWindow(hwnd);
 
-	hwndAbout = NULL;
-	return 0;
+    hwndAbout = NULL;
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Close windows resources
+ *  Close windows resources
  */
 
 static int windowsClose(HINSTANCE hInstance)
 {
-	int nReturn;
+    int nReturn;
 
-	nReturn = UnregisterClass(name, hInstance);
+    nReturn = UnregisterClass(name, hInstance);
 
-	if (hwndAbout) {
-		DestroyWindow(hwndAbout);
-	}
+    if (hwndAbout) {
+        DestroyWindow(hwndAbout);
+    }
 
-	return nReturn;
+    return nReturn;
 }
 
 /******************************************************************************/
 /*
- *	Main menu window message handler.
+ *  Main menu window message handler.
  */
 
 static long CALLBACK websWindProc(HWND hwnd, unsigned int msg, 
-									unsigned int wp, long lp)
+                                    unsigned int wp, long lp)
 {
-	switch (msg) {
-		case WM_DESTROY:
-			PostQuitMessage(0);
-			finished++;
-			return 0;
-
-		case WM_SYSCOMMAND:
-			if (wp == IDM_ABOUTBOX) {
-				if (!hwndAbout) {
-					createAboutBox((HINSTANCE) emfInstGet(), hwnd);
-				}
-				if (hwndAbout) {
-					ShowWindow(hwndAbout, SW_SHOWNORMAL);
-				}
-			}
-			break;
-	}
-
-	return DefWindowProc(hwnd, msg, wp, lp);
+    switch (msg) {
+        case WM_DESTROY:
+            PostQuitMessage(0);
+            finished++;
+            return 0;
+
+        case WM_SYSCOMMAND:
+            if (wp == IDM_ABOUTBOX) {
+                if (!hwndAbout) {
+                    createAboutBox((HINSTANCE) emfInstGet(), hwnd);
+                }
+                if (hwndAbout) {
+                    ShowWindow(hwndAbout, SW_SHOWNORMAL);
+                }
+            }
+            break;
+    }
+
+    return DefWindowProc(hwnd, msg, wp, lp);
 }
 
 /******************************************************************************/
 /*
- *	Check for Windows Messages
+ *  Check for Windows Messages
  */
 
 WPARAM checkWindowsMsgLoop()
 {
-	MSG		msg;					/* Message block */
+    MSG     msg;                    /* Message block */
 
-	if (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE)) {
-		if (!GetMessage(&msg, NULL, 0, 0) || msg.message == WM_QUIT) {
-			return msg.wParam;
-		}
+    if (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE)) {
+        if (!GetMessage(&msg, NULL, 0, 0) || msg.message == WM_QUIT) {
+            return msg.wParam;
+        }
 
-		TranslateMessage(&msg);
-		DispatchMessage(&msg);
-	}
+        TranslateMessage(&msg);
+        DispatchMessage(&msg);
+    }
 
-	return 0;
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Windows message handler for the About Box
+ *  Windows message handler for the About Box
  */
 
 static long CALLBACK websAboutProc(HWND hwndDlg, unsigned int msg, 
-									unsigned int wp, long lp)
+                                    unsigned int wp, long lp)
 {
-	long lResult;
-	HWND hwnd;
+    long lResult;
+    HWND hwnd;
 
-	lResult = DefWindowProc(hwndDlg, msg, wp, lp);
+    lResult = DefWindowProc(hwndDlg, msg, wp, lp);
 
-	switch (msg) {
-		case WM_CREATE:
-			hwndAbout = hwndDlg;
-			break;
+    switch (msg) {
+        case WM_CREATE:
+            hwndAbout = hwndDlg;
+            break;
 
-		case WM_DESTROY:
-			hwndAbout = NULL;
-			break;
+        case WM_DESTROY:
+            hwndAbout = NULL;
+            break;
 
-		case WM_COMMAND:
-			if (wp == IDOK) {
-				EndDialog(hwndDlg, 0);
-				PostMessage(hwndDlg, WM_CLOSE, 0, 0);
-			}
-			break;
+        case WM_COMMAND:
+            if (wp == IDOK) {
+                EndDialog(hwndDlg, 0);
+                PostMessage(hwndDlg, WM_CLOSE, 0, 0);
+            }
+            break;
 
-		case WM_INITDIALOG:
+        case WM_INITDIALOG:
 /*
- *			Set the version and build date values
+ *          Set the version and build date values
  */
-			hwnd = GetDlgItem(hwndDlg, IDC_VERSION);
-			if (hwnd) {
-				SetWindowText(hwnd, WEBS_VERSION);
-			}
+            hwnd = GetDlgItem(hwndDlg, IDC_VERSION);
+            if (hwnd) {
+                SetWindowText(hwnd, WEBS_VERSION);
+            }
 
-			hwnd = GetDlgItem(hwndDlg, IDC_BUILDDATE);
-			if (hwnd) {
-				SetWindowText(hwnd, __DATE__);
-			}
+            hwnd = GetDlgItem(hwndDlg, IDC_BUILDDATE);
+            if (hwnd) {
+                SetWindowText(hwnd, __DATE__);
+            }
 
-			SetWindowText(hwndDlg, T("GoAhead WebServer"));
-			centerWindowOnDisplay(hwndDlg);
+            SetWindowText(hwndDlg, T("GoAhead WebServer"));
+            centerWindowOnDisplay(hwndDlg);
 
-			hwndAbout = hwndDlg;
+            hwndAbout = hwndDlg;
 
-			lResult = FALSE;
-			break;
-	}
+            lResult = FALSE;
+            break;
+    }
 
-	return lResult;
+    return lResult;
 }
 
 /******************************************************************************/
 /*
- *	Registers the About Box class
+ *  Registers the About Box class
  */
 
 static int registerAboutBox(HINSTANCE hInstance)
 {
-	WNDCLASS  wc;
+    WNDCLASS  wc;
 
     wc.style = 0;
     wc.lpfnWndProc = (WNDPROC)websAboutProc;
@@ -489,10 +489,10 @@ static int registerAboutBox(HINSTANCE hInstance)
     wc.lpszClassName = IDS_ABOUTBOX;
 
     if (!RegisterClass(&wc)) {
-		return 0;
-	}
+        return 0;
+    }
 
- 	return 1;
+    return 1;
 }
 
 /******************************************************************************/
@@ -503,13 +503,13 @@ static int registerAboutBox(HINSTANCE hInstance)
 
 static LPWORD lpwAlign(LPWORD lpIn)
 {
-	ULONG ul;
+    ULONG ul;
 
-	ul = (ULONG) lpIn;
-	ul +=3;
-	ul >>=2;
-	ul <<=2;
-	return (LPWORD) ul;
+    ul = (ULONG) lpIn;
+    ul +=3;
+    ul >>=2;
+    ul <<=2;
+    return (LPWORD) ul;
 }
 
 /******************************************************************************/
@@ -522,298 +522,298 @@ static LPWORD lpwAlign(LPWORD lpIn)
 
 static int nCopyAnsiToWideChar(LPWORD lpWCStr, LPSTR lpAnsiIn)
 {
-	int cchAnsi = lstrlen(lpAnsiIn);
+    int cchAnsi = lstrlen(lpAnsiIn);
 
-	return MultiByteToWideChar(GetACP(), 
-		MB_PRECOMPOSED, lpAnsiIn, cchAnsi, lpWCStr, cchAnsi) + 1;
+    return MultiByteToWideChar(GetACP(), 
+        MB_PRECOMPOSED, lpAnsiIn, cchAnsi, lpWCStr, cchAnsi) + 1;
 }
 
 /******************************************************************************/
 /*
- *	Creates an About Box Window
+ *  Creates an About Box Window
  */
 
 static int createAboutBox(HINSTANCE hInstance, HWND hwnd)
 {
-	WORD	*p, *pdlgtemplate;
-	int		nchar;
-	DWORD	lStyle;
-	HWND	hwndReturn;
+    WORD    *p, *pdlgtemplate;
+    int     nchar;
+    DWORD   lStyle;
+    HWND    hwndReturn;
 
 /* 
- *	Allocate some memory to play with  
+ *  Allocate some memory to play with  
  */
-	pdlgtemplate = p = (PWORD) LocalAlloc(LPTR, 1000);
+    pdlgtemplate = p = (PWORD) LocalAlloc(LPTR, 1000);
 
 /*
- *	Start to fill in the dlgtemplate information.  addressing by WORDs 
+ *  Start to fill in the dlgtemplate information.  addressing by WORDs 
  */
 
-	lStyle = WS_DLGFRAME | WS_POPUP | WS_VISIBLE | WS_CLIPCHILDREN | DS_SETFONT;
-	*p++ = LOWORD(lStyle);
-	*p++ = HIWORD(lStyle);
-	*p++ = 0;          /* LOWORD (lExtendedStyle) */
-	*p++ = 0;          /* HIWORD (lExtendedStyle) */
-	*p++ = 7;          /* Number Of Items	*/
-	*p++ = 210;        /* x */
-	*p++ = 10;         /* y */
-	*p++ = 200;        /* cx */
-	*p++ = 100;        /* cy */
-	*p++ = 0;          /* Menu */
-	*p++ = 0;          /* Class */
+    lStyle = WS_DLGFRAME | WS_POPUP | WS_VISIBLE | WS_CLIPCHILDREN | DS_SETFONT;
+    *p++ = LOWORD(lStyle);
+    *p++ = HIWORD(lStyle);
+    *p++ = 0;          /* LOWORD (lExtendedStyle) */
+    *p++ = 0;          /* HIWORD (lExtendedStyle) */
+    *p++ = 7;          /* Number Of Items   */
+    *p++ = 210;        /* x */
+    *p++ = 10;         /* y */
+    *p++ = 200;        /* cx */
+    *p++ = 100;        /* cy */
+    *p++ = 0;          /* Menu */
+    *p++ = 0;          /* Class */
 
 /* 
- *	Copy the title of the dialog 
+ *  Copy the title of the dialog 
  */
-	nchar = nCopyAnsiToWideChar(p, WEBS_NAME);
-	p += nchar;
+    nchar = nCopyAnsiToWideChar(p, WEBS_NAME);
+    p += nchar;
 
-/*	
- *	Font information because of DS_SETFONT
+/*  
+ *  Font information because of DS_SETFONT
  */
-	*p++ = 11;     /* point size */
-	nchar = nCopyAnsiToWideChar(p, T("Arial Bold"));
-	p += nchar;
+    *p++ = 11;     /* point size */
+    nchar = nCopyAnsiToWideChar(p, T("Arial Bold"));
+    p += nchar;
 
 /*
- *	Make sure the first item starts on a DWORD boundary
+ *  Make sure the first item starts on a DWORD boundary
  */
-	p = lpwAlign(p);
+    p = lpwAlign(p);
 
 /*
- *	Now start with the first item (Product Identifier)
+ *  Now start with the first item (Product Identifier)
  */
-	lStyle = SS_CENTER | WS_VISIBLE | WS_CHILD | WS_TABSTOP;
-	*p++ = LOWORD(lStyle);
-	*p++ = HIWORD(lStyle);
-	*p++ = 0;			/* LOWORD (lExtendedStyle) */
-	*p++ = 0;			/* HIWORD (lExtendedStyle) */
-	*p++ = 10;			/* x */
-	*p++ = 10;			/* y  */
-	*p++ = 180;			/* cx */
-	*p++ = 15;			/* cy */
-	*p++ = 1;			/* ID */
+    lStyle = SS_CENTER | WS_VISIBLE | WS_CHILD | WS_TABSTOP;
+    *p++ = LOWORD(lStyle);
+    *p++ = HIWORD(lStyle);
+    *p++ = 0;           /* LOWORD (lExtendedStyle) */
+    *p++ = 0;           /* HIWORD (lExtendedStyle) */
+    *p++ = 10;          /* x */
+    *p++ = 10;          /* y  */
+    *p++ = 180;         /* cx */
+    *p++ = 15;          /* cy */
+    *p++ = 1;           /* ID */
 
 /*
- *	Fill in class i.d., this time by name
+ *  Fill in class i.d., this time by name
  */
-	nchar = nCopyAnsiToWideChar(p, TEXT("STATIC"));
-	p += nchar;
+    nchar = nCopyAnsiToWideChar(p, TEXT("STATIC"));
+    p += nchar;
 
 /*
- *	Copy the text of the first item
+ *  Copy the text of the first item
  */
-	nchar = nCopyAnsiToWideChar(p, 
-		TEXT("GoAhead WebServer ") WEBS_VERSION);
-	p += nchar;
+    nchar = nCopyAnsiToWideChar(p, 
+        TEXT("GoAhead WebServer ") WEBS_VERSION);
+    p += nchar;
 #ifdef WEBS_SSL_SUPPORT
-	p -= sizeof(char_t);
-	nchar = nCopyAnsiToWideChar(p, 
-		TEXT("\n") SSL_NAME TEXT(" ") SSL_VERSION);
-	p += nchar;
+    p -= sizeof(char_t);
+    nchar = nCopyAnsiToWideChar(p, 
+        TEXT("\n") SSL_NAME TEXT(" ") SSL_VERSION);
+    p += nchar;
 #endif
 /*
- *	Advance pointer over nExtraStuff WORD
+ *  Advance pointer over nExtraStuff WORD
  */
-	*p++ = 0;  
+    *p++ = 0;  
 
 /*
- *	Make sure the next item starts on a DWORD boundary
+ *  Make sure the next item starts on a DWORD boundary
  */
-	p = lpwAlign(p);
+    p = lpwAlign(p);
 
 /*
- *	Next, the Copyright Notice.
+ *  Next, the Copyright Notice.
  */
-	lStyle = SS_CENTER | WS_VISIBLE | WS_CHILD | WS_TABSTOP;
-	*p++ = LOWORD(lStyle);
-	*p++ = HIWORD(lStyle);
-	*p++ = 0;			/* LOWORD (lExtendedStyle) */
-	*p++ = 0;			/* HIWORD (lExtendedStyle) */
-	*p++ = 10;			/* x */
-	*p++ = 30;			/* y  */
-	*p++ = 180;			/* cx */
-	*p++ = 15;			/* cy */
-	*p++ = 1;			/* ID */
+    lStyle = SS_CENTER | WS_VISIBLE | WS_CHILD | WS_TABSTOP;
+    *p++ = LOWORD(lStyle);
+    *p++ = HIWORD(lStyle);
+    *p++ = 0;           /* LOWORD (lExtendedStyle) */
+    *p++ = 0;           /* HIWORD (lExtendedStyle) */
+    *p++ = 10;          /* x */
+    *p++ = 30;          /* y  */
+    *p++ = 180;         /* cx */
+    *p++ = 15;          /* cy */
+    *p++ = 1;           /* ID */
 
 /*
- *	Fill in class i.d. by name
+ *  Fill in class i.d. by name
  */
-	nchar = nCopyAnsiToWideChar(p, TEXT("STATIC"));
-	p += nchar;
-
-/*
- *	Copy the text of the item
- */
-	nchar = nCopyAnsiToWideChar(p, GOAHEAD_COPYRIGHT);
-	p += nchar;
-
-/*
- *	Advance pointer over nExtraStuff WORD
- */
-	*p++ = 0;  
-/*
- *	Make sure the next item starts on a DWORD boundary
- */
-	p = lpwAlign(p);
-
-/*
- *	Add third item ("Version:")
- */
-	lStyle = SS_RIGHT | WS_VISIBLE | WS_CHILD | WS_TABSTOP;
-	*p++ = LOWORD(lStyle);
-	*p++ = HIWORD(lStyle);
-	*p++ = 0;          
-	*p++ = 0;
-	*p++ = 28;
-	*p++ = 50;
-	*p++ = 70;
-	*p++ = 10;
-	*p++ = 1;
-	nchar = nCopyAnsiToWideChar(p, T("STATIC"));
-	p += nchar;
-	nchar = nCopyAnsiToWideChar(p, T("Version:"));
-	p += nchar;
-	*p++ = 0;
-
-/*
- *	Add fourth Item (IDC_VERSION)
- */
-	p = lpwAlign(p);
-	lStyle = SS_LEFT | WS_VISIBLE | WS_CHILD | WS_TABSTOP;
-	*p++ = LOWORD(lStyle);
-	*p++ = HIWORD(lStyle);
-	*p++ = 0;          
-	*p++ = 0;
-	*p++ = 102;
-	*p++ = 50;
-	*p++ = 70;
-	*p++ = 10;
-	*p++ = IDC_VERSION;
-	nchar = nCopyAnsiToWideChar(p, T("STATIC"));
-	p += nchar;
-	nchar = nCopyAnsiToWideChar(p, T("version"));
-	p += nchar;
-	*p++ = 0;
-/*
- *	Add fifth item ("Build Date:")
- */
-	p = lpwAlign(p);
-	lStyle = SS_RIGHT | WS_VISIBLE | WS_CHILD | WS_TABSTOP;
-	*p++ = LOWORD(lStyle);
-	*p++ = HIWORD(lStyle);
-	*p++ = 0;          
-	*p++ = 0;
-	*p++ = 28;
-	*p++ = 65;
-	*p++ = 70;
-	*p++ = 10;
-	*p++ = 1;
-	nchar = nCopyAnsiToWideChar(p, T("STATIC"));
-	p += nchar;
-	nchar = nCopyAnsiToWideChar(p, T("Build Date:"));
-	p += nchar;
-	*p++ = 0;
-/*
- *	Add sixth item (IDC_BUILDDATE)
- */
-	p = lpwAlign(p);
-	lStyle = SS_LEFT | WS_VISIBLE | WS_CHILD | WS_TABSTOP;
-	*p++ = LOWORD(lStyle);
-	*p++ = HIWORD(lStyle);
-	*p++ = 0;          
-	*p++ = 0;
-	*p++ = 102;
-	*p++ = 65;
-	*p++ = 70;
-	*p++ = 10;
-	*p++ = IDC_BUILDDATE;
-	nchar = nCopyAnsiToWideChar(p, T("STATIC"));
-	p += nchar;
-	nchar = nCopyAnsiToWideChar(p, T("Build Date"));
-	p += nchar;
-	*p++ = 0;
-/*
- *	Add seventh item (IDOK)
- */
-	p = lpwAlign(p);
-	lStyle = BS_PUSHBUTTON | WS_VISIBLE | WS_CHILD | WS_TABSTOP;
-	*p++ = LOWORD(lStyle);
-	*p++ = HIWORD(lStyle);
-	*p++ = 0;          
-	*p++ = 0;
-	*p++ = 80;
-	*p++ = 80;
-	*p++ = 40;
-	*p++ = 10;
-	*p++ = IDOK;
-	nchar = nCopyAnsiToWideChar(p, T("BUTTON"));
-	p += nchar;
-	nchar = nCopyAnsiToWideChar(p, T("OK"));
-	p += nchar;
-	*p++ = 0;
-
-	hwndReturn = CreateDialogIndirect(hInstance, 
-		(LPDLGTEMPLATE) pdlgtemplate, hwnd, (DLGPROC) websAboutProc);
-
-	LocalFree(LocalHandle(pdlgtemplate));
-
-	return 0;
+    nchar = nCopyAnsiToWideChar(p, TEXT("STATIC"));
+    p += nchar;
+
+/*
+ *  Copy the text of the item
+ */
+    nchar = nCopyAnsiToWideChar(p, GOAHEAD_COPYRIGHT);
+    p += nchar;
+
+/*
+ *  Advance pointer over nExtraStuff WORD
+ */
+    *p++ = 0;  
+/*
+ *  Make sure the next item starts on a DWORD boundary
+ */
+    p = lpwAlign(p);
+
+/*
+ *  Add third item ("Version:")
+ */
+    lStyle = SS_RIGHT | WS_VISIBLE | WS_CHILD | WS_TABSTOP;
+    *p++ = LOWORD(lStyle);
+    *p++ = HIWORD(lStyle);
+    *p++ = 0;          
+    *p++ = 0;
+    *p++ = 28;
+    *p++ = 50;
+    *p++ = 70;
+    *p++ = 10;
+    *p++ = 1;
+    nchar = nCopyAnsiToWideChar(p, T("STATIC"));
+    p += nchar;
+    nchar = nCopyAnsiToWideChar(p, T("Version:"));
+    p += nchar;
+    *p++ = 0;
+
+/*
+ *  Add fourth Item (IDC_VERSION)
+ */
+    p = lpwAlign(p);
+    lStyle = SS_LEFT | WS_VISIBLE | WS_CHILD | WS_TABSTOP;
+    *p++ = LOWORD(lStyle);
+    *p++ = HIWORD(lStyle);
+    *p++ = 0;          
+    *p++ = 0;
+    *p++ = 102;
+    *p++ = 50;
+    *p++ = 70;
+    *p++ = 10;
+    *p++ = IDC_VERSION;
+    nchar = nCopyAnsiToWideChar(p, T("STATIC"));
+    p += nchar;
+    nchar = nCopyAnsiToWideChar(p, T("version"));
+    p += nchar;
+    *p++ = 0;
+/*
+ *  Add fifth item ("Build Date:")
+ */
+    p = lpwAlign(p);
+    lStyle = SS_RIGHT | WS_VISIBLE | WS_CHILD | WS_TABSTOP;
+    *p++ = LOWORD(lStyle);
+    *p++ = HIWORD(lStyle);
+    *p++ = 0;          
+    *p++ = 0;
+    *p++ = 28;
+    *p++ = 65;
+    *p++ = 70;
+    *p++ = 10;
+    *p++ = 1;
+    nchar = nCopyAnsiToWideChar(p, T("STATIC"));
+    p += nchar;
+    nchar = nCopyAnsiToWideChar(p, T("Build Date:"));
+    p += nchar;
+    *p++ = 0;
+/*
+ *  Add sixth item (IDC_BUILDDATE)
+ */
+    p = lpwAlign(p);
+    lStyle = SS_LEFT | WS_VISIBLE | WS_CHILD | WS_TABSTOP;
+    *p++ = LOWORD(lStyle);
+    *p++ = HIWORD(lStyle);
+    *p++ = 0;          
+    *p++ = 0;
+    *p++ = 102;
+    *p++ = 65;
+    *p++ = 70;
+    *p++ = 10;
+    *p++ = IDC_BUILDDATE;
+    nchar = nCopyAnsiToWideChar(p, T("STATIC"));
+    p += nchar;
+    nchar = nCopyAnsiToWideChar(p, T("Build Date"));
+    p += nchar;
+    *p++ = 0;
+/*
+ *  Add seventh item (IDOK)
+ */
+    p = lpwAlign(p);
+    lStyle = BS_PUSHBUTTON | WS_VISIBLE | WS_CHILD | WS_TABSTOP;
+    *p++ = LOWORD(lStyle);
+    *p++ = HIWORD(lStyle);
+    *p++ = 0;          
+    *p++ = 0;
+    *p++ = 80;
+    *p++ = 80;
+    *p++ = 40;
+    *p++ = 10;
+    *p++ = IDOK;
+    nchar = nCopyAnsiToWideChar(p, T("BUTTON"));
+    p += nchar;
+    nchar = nCopyAnsiToWideChar(p, T("OK"));
+    p += nchar;
+    *p++ = 0;
+
+    hwndReturn = CreateDialogIndirect(hInstance, 
+        (LPDLGTEMPLATE) pdlgtemplate, hwnd, (DLGPROC) websAboutProc);
+
+    LocalFree(LocalHandle(pdlgtemplate));
+
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Test Javascript binding for ASP. This will be invoked when "aspTest" is
- *	embedded in an ASP page. See web/asp.asp for usage. Set browser to 
- *	"localhost/asp.asp" to test.
+ *  Test Javascript binding for ASP. This will be invoked when "aspTest" is
+ *  embedded in an ASP page. See web/asp.asp for usage. Set browser to 
+ *  "localhost/asp.asp" to test.
  */
 
 static int aspTest(int eid, webs_t wp, int argc, char_t **argv)
 {
-	char_t	*name, *address;
+    char_t  *name, *address;
 
-	if (ejArgs(argc, argv, T("%s %s"), &name, &address) < 2) {
-		websError(wp, 400, T("Insufficient args\n"));
-		return -1;
-	}
-	return websWrite(wp, T("Name: %s, Address %s"), name, address);
+    if (ejArgs(argc, argv, T("%s %s"), &name, &address) < 2) {
+        websError(wp, 400, T("Insufficient args\n"));
+        return -1;
+    }
+    return websWrite(wp, T("Name: %s, Address %s"), name, address);
 }
 
 /******************************************************************************/
 /*
- *	Test form for posted data (in-memory CGI). This will be called when the
- *	form in web/forms.asp is invoked. Set browser to "localhost/forms.asp" to test.
+ *  Test form for posted data (in-memory CGI). This will be called when the
+ *  form in web/forms.asp is invoked. Set browser to "localhost/forms.asp" to test.
  */
 
 static void formTest(webs_t wp, char_t *path, char_t *query)
 {
-	char_t	*name, *address;
+    char_t  *name, *address;
 
-	name = websGetVar(wp, T("name"), T("Joe Smith")); 
-	address = websGetVar(wp, T("address"), T("1212 Milky Way Ave.")); 
+    name = websGetVar(wp, T("name"), T("Joe Smith")); 
+    address = websGetVar(wp, T("address"), T("1212 Milky Way Ave.")); 
 
-	websHeader(wp);
-	websWrite(wp, T("<body><h2>Name: %s, Address: %s</h2>\n"), name, address);
-	websFooter(wp);
-	websDone(wp, 200);
+    websHeader(wp);
+    websWrite(wp, T("<body><h2>Name: %s, Address: %s</h2>\n"), name, address);
+    websFooter(wp);
+    websDone(wp, 200);
 }
 
 /******************************************************************************/
 /*
- *	Home page handler
+ *  Home page handler
  */
 
 static int websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
-							int arg, char_t *url, char_t *path, char_t *query)
+                            int arg, char_t *url, char_t *path, char_t *query)
 {
 /*
- *	If the empty or "/" URL is invoked, redirect default URLs to the home page
+ *  If the empty or "/" URL is invoked, redirect default URLs to the home page
  */
-	if (*url == '\0' || gstrcmp(url, T("/")) == 0) {
-		websRedirect(wp, WEBS_DEFAULT_HOME);
-		return 1;
-	}
-	return 0;
+    if (*url == '\0' || gstrcmp(url, T("/")) == 0) {
+        websRedirect(wp, WEBS_DEFAULT_HOME);
+        return 1;
+    }
+    return 0;
 }
 
 /******************************************************************************/
@@ -821,34 +821,34 @@ static int websHomePageHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
 #ifdef B_STATS
 static void memLeaks() 
 {
-	int		fd;
+    int     fd;
 
-	if ((fd = gopen(T("leak.txt"), O_CREAT | O_TRUNC | O_WRONLY)) >= 0) {
-		bstats(fd, printMemStats);
-		close(fd);
-	}
+    if ((fd = gopen(T("leak.txt"), O_CREAT | O_TRUNC | O_WRONLY)) >= 0) {
+        bstats(fd, printMemStats);
+        close(fd);
+    }
 }
 
 /******************************************************************************/
 /*
- *	Print memory usage / leaks  
+ *  Print memory usage / leaks  
  */
 
 static void printMemStats(int handle, char_t *fmt, ...)
 {
-	va_list		args;
-	char_t		buf[256];
+    va_list     args;
+    char_t      buf[256];
 
-	va_start(args, fmt);
-	vsprintf(buf, fmt, args);
-	va_end(args);
-	write(handle, buf, strlen(buf));
+    va_start(args, fmt);
+    vsprintf(buf, fmt, args);
+    va_end(args);
+    write(handle, buf, strlen(buf));
 }
 #endif
 
 /******************************************************************************/
 /*
- *	Center window on screen
+ *  Center window on screen
  */
 
 #define RCWIDTH(rc) ((rc).right - (rc).left)
@@ -856,48 +856,48 @@ static void printMemStats(int handle, char_t *fmt, ...)
 
 static void centerWindowOnDisplay(HWND hwndCenter)
 {
-	int			xLeft, yTop, cxDisp, cyDisp;
-	RECT		rcDlg;
+    int         xLeft, yTop, cxDisp, cyDisp;
+    RECT        rcDlg;
 
-	a_assert(IsWindow(hwndCenter));
+    a_assert(IsWindow(hwndCenter));
 
 /*
- *	Get Window Size
+ *  Get Window Size
  */
-	GetWindowRect(hwndCenter, &rcDlg);
+    GetWindowRect(hwndCenter, &rcDlg);
 
 /*
- *	Get monitor width and height
+ *  Get monitor width and height
  */
-	cxDisp = GetSystemMetrics(SM_CXFULLSCREEN);
-	cyDisp = GetSystemMetrics(SM_CYFULLSCREEN);
+    cxDisp = GetSystemMetrics(SM_CXFULLSCREEN);
+    cyDisp = GetSystemMetrics(SM_CYFULLSCREEN);
 
 /*
- *	Find dialog's upper left based on screen size
+ *  Find dialog's upper left based on screen size
  */
-	xLeft = cxDisp / 2 - RCWIDTH(rcDlg) / 2;
-	yTop = cyDisp / 2 - RCHEIGHT(rcDlg) / 2;
+    xLeft = cxDisp / 2 - RCWIDTH(rcDlg) / 2;
+    yTop = cyDisp / 2 - RCHEIGHT(rcDlg) / 2;
 
 /*
- *	If the dialog is outside the screen, move it inside
+ *  If the dialog is outside the screen, move it inside
  */
-	if (xLeft < 0) {
-		xLeft = 0;
-	} else if (xLeft + RCWIDTH(rcDlg) > cxDisp) {
-		xLeft = cxDisp - RCWIDTH(rcDlg);
-	}
+    if (xLeft < 0) {
+        xLeft = 0;
+    } else if (xLeft + RCWIDTH(rcDlg) > cxDisp) {
+        xLeft = cxDisp - RCWIDTH(rcDlg);
+    }
 
-	if (yTop < 0) {
-		yTop = 0;
-	} else if (yTop + RCHEIGHT(rcDlg) > cyDisp) {
-		yTop = cyDisp - RCHEIGHT(rcDlg);
-	}
+    if (yTop < 0) {
+        yTop = 0;
+    } else if (yTop + RCHEIGHT(rcDlg) > cyDisp) {
+        yTop = cyDisp - RCHEIGHT(rcDlg);
+    }
 
 /*
- *	Move the window
+ *  Move the window
  */
-	SetWindowPos(hwndCenter, HWND_TOP, xLeft, yTop, -1, -1,
-		SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
+    SetWindowPos(hwndCenter, HWND_TOP, xLeft, yTop, -1, -1,
+        SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
 }
 
 /******************************************************************************/
diff --git a/asp.c b/asp.c
index 9f0a946d..be65b86e 100644
--- a/asp.c
+++ b/asp.c
@@ -7,47 +7,47 @@
 
 /********************************* Includes ***********************************/
 
-#include	"wsIntrn.h"
+#include    "wsIntrn.h"
 
 /********************************** Locals ************************************/
 
-static sym_fd_t	websAspFunctions = -1;	/* Symbol table of functions */
-static int		aspOpenCount = 0;		/* count of apps using this module */
+static sym_fd_t websAspFunctions = -1;  /* Symbol table of functions */
+static int      aspOpenCount = 0;       /* count of apps using this module */
 
 /***************************** Forward Declarations ***************************/
 
-static char_t	*strtokcmp(char_t *s1, char_t *s2);
-static char_t	*skipWhite(char_t *s);
+static char_t   *strtokcmp(char_t *s1, char_t *s2);
+static char_t   *skipWhite(char_t *s);
 
 /************************************* Code ***********************************/
 /*
-  	Create script spaces and commands
+    Create script spaces and commands
  */
 
 int websAspOpen()
 {
-	if (++aspOpenCount == 1) {
+    if (++aspOpenCount == 1) {
         /*
-          	Create the table for ASP functions
+            Create the table for ASP functions
          */
-		websAspFunctions = symOpen(WEBS_SYM_INIT * 2);
+        websAspFunctions = symOpen(WEBS_SYM_INIT * 2);
 
         /*
-          	Create standard ASP commands
+            Create standard ASP commands
          */
-		websAspDefine(T("write"), websAspWrite);
-	}
-	return 0;
+        websAspDefine(T("write"), websAspWrite);
+    }
+    return 0;
 }
 
 void websAspClose()
 {
-	if (--aspOpenCount <= 0) {
-		if (websAspFunctions != -1) {
-			symClose(websAspFunctions);
-			websAspFunctions = -1;
-		}
-	}
+    if (--aspOpenCount <= 0) {
+        if (websAspFunctions != -1) {
+            symClose(websAspFunctions);
+            websAspFunctions = -1;
+        }
+    }
 }
 
 
@@ -57,164 +57,164 @@ void websAspClose()
  */
 int websAspRequest(webs_t wp, char_t *lpath)
 {
-	websStatType	sbuf;
-	char			*rbuf;
-	char_t			*token, *lang, *result, *path, *ep, *cp, *buf, *nextp;
-	char_t			*last;
-	int				rc, engine, len, ejid;
-
-	a_assert(websValid(wp));
-	a_assert(lpath && *lpath);
-
-	rc = -1;
-	buf = NULL;
-	rbuf = NULL;
-	engine = EMF_SCRIPT_EJSCRIPT;
-	wp->flags |= WEBS_HEADER_DONE;
-	path = websGetRequestPath(wp);
+    websStatType    sbuf;
+    char            *rbuf;
+    char_t          *token, *lang, *result, *path, *ep, *cp, *buf, *nextp;
+    char_t          *last;
+    int             rc, engine, len, ejid;
+
+    a_assert(websValid(wp));
+    a_assert(lpath && *lpath);
+
+    rc = -1;
+    buf = NULL;
+    rbuf = NULL;
+    engine = EMF_SCRIPT_EJSCRIPT;
+    wp->flags |= WEBS_HEADER_DONE;
+    path = websGetRequestPath(wp);
 
     /*
-      	Create Ejscript instance in case it is needed
+        Create Ejscript instance in case it is needed
      */
-	ejid = ejOpenEngine(wp->cgiVars, websAspFunctions);
-	if (ejid < 0) {
-		websError(wp, 200, T("Can't create Ejscript engine"));
-		goto done;
-	}
-	ejSetUserHandle(ejid, wp);
-
-	if (websPageStat(wp, lpath, path, &sbuf) < 0) {
-		websError(wp, 404, T("Can't stat %s"), lpath);
-		goto done;
-	}
+    ejid = ejOpenEngine(wp->cgiVars, websAspFunctions);
+    if (ejid < 0) {
+        websError(wp, 200, T("Can't create Ejscript engine"));
+        goto done;
+    }
+    ejSetUserHandle(ejid, wp);
+
+    if (websPageStat(wp, lpath, path, &sbuf) < 0) {
+        websError(wp, 404, T("Can't stat %s"), lpath);
+        goto done;
+    }
 
     /*
-      	Create a buffer to hold the ASP file in-memory
+        Create a buffer to hold the ASP file in-memory
      */
-	len = sbuf.size * sizeof(char);
-	if ((rbuf = balloc(B_L, len + 1)) == NULL) {
-		websError(wp, 200, T("Can't get memory"));
-		goto done;
-	}
-	rbuf[len] = '\0';
-
-	if (websPageReadData(wp, rbuf, len) != len) {
-		websError(wp, 200, T("Cant read %s"), lpath);
-		goto done;
-	}
-	websPageClose(wp);
+    len = sbuf.size * sizeof(char);
+    if ((rbuf = balloc(B_L, len + 1)) == NULL) {
+        websError(wp, 200, T("Can't get memory"));
+        goto done;
+    }
+    rbuf[len] = '\0';
+
+    if (websPageReadData(wp, rbuf, len) != len) {
+        websError(wp, 200, T("Cant read %s"), lpath);
+        goto done;
+    }
+    websPageClose(wp);
 
 /*
- *	Convert to UNICODE if necessary.
+ *  Convert to UNICODE if necessary.
  */
-	if ((buf = ballocAscToUni(rbuf, len)) == NULL) {
-		websError(wp, 200, T("Can't get memory"));
-		goto done;
-	}
+    if ((buf = ballocAscToUni(rbuf, len)) == NULL) {
+        websError(wp, 200, T("Can't get memory"));
+        goto done;
+    }
 
     /*
-      	Scan for the next "<%"
+        Scan for the next "<%"
      */
-	last = buf;
-	rc = 0;
-	while (rc == 0 && *last && ((nextp = gstrstr(last, T("<%"))) != NULL)) {
-		websWriteBlock(wp, last, (nextp - last));
-		nextp = skipWhite(nextp + 2);
+    last = buf;
+    rc = 0;
+    while (rc == 0 && *last && ((nextp = gstrstr(last, T("<%"))) != NULL)) {
+        websWriteBlock(wp, last, (nextp - last));
+        nextp = skipWhite(nextp + 2);
 
         /*
             Decode the language
          */
-		token = T("language");
+        token = T("language");
 
-		if ((lang = strtokcmp(nextp, token)) != NULL) {
-			if ((cp = strtokcmp(lang, T("=javascript"))) != NULL) {
-				engine = EMF_SCRIPT_EJSCRIPT;
-			} else {
-				cp = nextp;
-			}
-			nextp = cp;
-		}
+        if ((lang = strtokcmp(nextp, token)) != NULL) {
+            if ((cp = strtokcmp(lang, T("=javascript"))) != NULL) {
+                engine = EMF_SCRIPT_EJSCRIPT;
+            } else {
+                cp = nextp;
+            }
+            nextp = cp;
+        }
 
         /*
             Find tailing bracket and then evaluate the script
          */
-		if ((ep = gstrstr(nextp, T("%>"))) != NULL) {
+        if ((ep = gstrstr(nextp, T("%>"))) != NULL) {
 
-			*ep = '\0';
-			last = ep + 2;
-			nextp = skipWhite(nextp);
+            *ep = '\0';
+            last = ep + 2;
+            nextp = skipWhite(nextp);
             /*
                 Handle backquoted newlines
              */
-			for (cp = nextp; *cp; ) {
-				if (*cp == '\\' && (cp[1] == '\r' || cp[1] == '\n')) {
-					*cp++ = ' ';
-					while (*cp == '\r' || *cp == '\n') {
-						*cp++ = ' ';
-					}
-				} else {
-					cp++;
-				}
-			}
+            for (cp = nextp; *cp; ) {
+                if (*cp == '\\' && (cp[1] == '\r' || cp[1] == '\n')) {
+                    *cp++ = ' ';
+                    while (*cp == '\r' || *cp == '\n') {
+                        *cp++ = ' ';
+                    }
+                } else {
+                    cp++;
+                }
+            }
             /*
                 Now call the relevant script engine. Output is done directly by the ASP script procedure by calling websWrite()
              */
-			if (*nextp) {
-				result = NULL;
-				if (engine == EMF_SCRIPT_EJSCRIPT) {
-					rc = scriptEval(engine, nextp, &result, (void *) ejid);
-				} else {
-					rc = scriptEval(engine, nextp, &result, wp);
-				}
-				if (rc < 0) {
+            if (*nextp) {
+                result = NULL;
+                if (engine == EMF_SCRIPT_EJSCRIPT) {
+                    rc = scriptEval(engine, nextp, &result, (void *) ejid);
+                } else {
+                    rc = scriptEval(engine, nextp, &result, wp);
+                }
+                if (rc < 0) {
                     /*
                          On an error, discard all output accumulated so far and store the error in the result buffer. Be
                          careful if the user has called websError() already.
                      */
-					if (websValid(wp)) {
-						if (result) {
-							websWrite(wp, T("<h2><b>ASP Error: %s</b></h2>\n"), 
-								result);
-							websWrite(wp, T("<pre>%s</pre>"), nextp);
-							bfree(B_L, result);
-						} else {
-							websWrite(wp, T("<h2><b>ASP Error</b></h2>\n%s\n"),
-								nextp);
-						}
-						websWrite(wp, T("</body></html>\n"));
-						rc = 0;
-					}
-					goto done;
-				}
-			}
-
-		} else {
-			websError(wp, 200, T("Unterminated script in %s: \n"), lpath);
-			rc = -1;
-			goto done;
-		}
-	}
+                    if (websValid(wp)) {
+                        if (result) {
+                            websWrite(wp, T("<h2><b>ASP Error: %s</b></h2>\n"), 
+                                result);
+                            websWrite(wp, T("<pre>%s</pre>"), nextp);
+                            bfree(B_L, result);
+                        } else {
+                            websWrite(wp, T("<h2><b>ASP Error</b></h2>\n%s\n"),
+                                nextp);
+                        }
+                        websWrite(wp, T("</body></html>\n"));
+                        rc = 0;
+                    }
+                    goto done;
+                }
+            }
+
+        } else {
+            websError(wp, 200, T("Unterminated script in %s: \n"), lpath);
+            rc = -1;
+            goto done;
+        }
+    }
     /*
-      	Output any trailing HTML page text
+        Output any trailing HTML page text
      */
-	if (last && *last && rc == 0) {
-		websWriteBlock(wp, last, gstrlen(last));
-	}
-	rc = 0;
+    if (last && *last && rc == 0) {
+        websWriteBlock(wp, last, gstrlen(last));
+    }
+    rc = 0;
 
 /*
     Common exit and cleanup
  */
 done:
-	if (websValid(wp)) {
-		websPageClose(wp);
-		if (ejid >= 0) {
-			ejCloseEngine(ejid);
-		}
-	}
-	bfreeSafe(B_L, buf);
-	bfreeSafe(B_L, rbuf);
-	return rc;
+    if (websValid(wp)) {
+        websPageClose(wp);
+        if (ejid >= 0) {
+            ejCloseEngine(ejid);
+        }
+    }
+    bfreeSafe(B_L, buf);
+    bfreeSafe(B_L, rbuf);
+    return rc;
 }
 
 
@@ -222,10 +222,10 @@ done:
     Define an ASP Ejscript function. Bind an ASP name to a C procedure.
  */
 int websAspDefine(char_t *name, 
-	int (*fn)(int ejid, webs_t wp, int argc, char_t **argv))
+    int (*fn)(int ejid, webs_t wp, int argc, char_t **argv))
 {
-	return ejSetGlobalFunctionDirect(websAspFunctions, name, 
-		(int (*)(int, void*, int, char_t**)) fn);
+    return ejSetGlobalFunctionDirect(websAspFunctions, name, 
+        (int (*)(int, void*, int, char_t**)) fn);
 }
 
 
@@ -234,22 +234,22 @@ int websAspDefine(char_t *name,
  */
 int websAspWrite(int ejid, webs_t wp, int argc, char_t **argv)
 {
-	int		i;
-
-	a_assert(websValid(wp));
-	
-	for (i = 0; i < argc; ) {
-		a_assert(argv);
-		if (websWriteBlock(wp, argv[i], gstrlen(argv[i])) < 0) {
-			return -1;
-		}
-		if (++i < argc) {
-			if (websWriteBlock(wp, T(" "), 2) < 0) {
-				return -1;
-			}
-		}
-	}
-	return 0;
+    int     i;
+
+    a_assert(websValid(wp));
+    
+    for (i = 0; i < argc; ) {
+        a_assert(argv);
+        if (websWriteBlock(wp, argv[i], gstrlen(argv[i])) < 0) {
+            return -1;
+        }
+        if (++i < argc) {
+            if (websWriteBlock(wp, T(" "), 2) < 0) {
+                return -1;
+            }
+        }
+    }
+    return 0;
 }
 
 
@@ -258,35 +258,35 @@ int websAspWrite(int ejid, webs_t wp, int argc, char_t **argv)
  */
 static char_t *strtokcmp(char_t *s1, char_t *s2)
 {
-	int		len;
-
-	s1 = skipWhite(s1);
-	len = gstrlen(s2);
-	for (len = gstrlen(s2); len > 0 && (tolower(*s1) == tolower(*s2)); len--) {
-		if (*s2 == '\0') {
-			return s1;
-		}
-		s1++;
-		s2++;
-	}
-	if (len == 0) {
-		return s1;
-	}
-	return NULL;
+    int     len;
+
+    s1 = skipWhite(s1);
+    len = gstrlen(s2);
+    for (len = gstrlen(s2); len > 0 && (tolower(*s1) == tolower(*s2)); len--) {
+        if (*s2 == '\0') {
+            return s1;
+        }
+        s1++;
+        s2++;
+    }
+    if (len == 0) {
+        return s1;
+    }
+    return NULL;
 }
 
 
 static char_t *skipWhite(char_t *s) 
 {
-	a_assert(s);
-
-	if (s == NULL) {
-		return s;
-	}
-	while (*s && gisspace(*s)) {
-		s++;
-	}
-	return s;
+    a_assert(s);
+
+    if (s == NULL) {
+        return s;
+    }
+    while (*s && gisspace(*s)) {
+        s++;
+    }
+    return s;
 }
 
 /*
diff --git a/balloc.c b/balloc.c
index 4d71eb74..84fed314 100644
--- a/balloc.c
+++ b/balloc.c
@@ -7,97 +7,97 @@
 /******************************** Description *********************************/
 
 /*
- *	This module implements a very fast block allocation scheme suitable for
- *	ROMed environments. It maintains block class queues for rapid allocation
- *	and minimal fragmentation. This module does not coalesce blocks. The 
- *	storage space may be populated statically or via the traditional malloc 
- *	mechanisms. Large blocks greater than the maximum class size may be 
- *	allocated from the O/S or run-time system via malloc. To permit the use 
- *	of malloc, call bopen with flags set to B_USE_MALLOC (this is the default).
- *	It is recommended that bopen be called first thing in the application. 
- *	If it is not, it will be called with default values on the first call to 
- *	balloc(). Note that this code is not designed for multi-threading purposes
- *	and it depends on newly declared variables being initialized to zero.
+ *  This module implements a very fast block allocation scheme suitable for
+ *  ROMed environments. It maintains block class queues for rapid allocation
+ *  and minimal fragmentation. This module does not coalesce blocks. The 
+ *  storage space may be populated statically or via the traditional malloc 
+ *  mechanisms. Large blocks greater than the maximum class size may be 
+ *  allocated from the O/S or run-time system via malloc. To permit the use 
+ *  of malloc, call bopen with flags set to B_USE_MALLOC (this is the default).
+ *  It is recommended that bopen be called first thing in the application. 
+ *  If it is not, it will be called with default values on the first call to 
+ *  balloc(). Note that this code is not designed for multi-threading purposes
+ *  and it depends on newly declared variables being initialized to zero.
  */  
 
 /********************************* Includes ***********************************/
 
 #define IN_BALLOC
 
-#include	"uemf.h"
+#include    "uemf.h"
 
-#include	<stdarg.h>
-#include	<stdlib.h>
+#include    <stdarg.h>
+#include    <stdlib.h>
 
 #ifndef NO_BALLOC
 /********************************* Defines ************************************/
 
 /*
- *	Define B_STATS if you wish to track memory block and stack usage
+ *  Define B_STATS if you wish to track memory block and stack usage
  */
 #ifdef B_STATS
 /*
- *	Optional statistics
+ *  Optional statistics
  */
 
 typedef struct {
-	long	alloc;								/* Block allocation calls */
-	long	inuse;								/* Blocks in use */
+    long    alloc;                              /* Block allocation calls */
+    long    inuse;                              /* Blocks in use */
 } bStatsType;
 
 typedef struct {
-	char_t 	file[FNAMESIZE];
-	long	allocated;							/* Bytes currently allocated */
-	long	count;								/* Current block count */
-	long	times;								/* Count of alloc attempts */
-	long	largest;							/* largest allocated here */
-	int		q;
+    char_t  file[FNAMESIZE];
+    long    allocated;                          /* Bytes currently allocated */
+    long    count;                              /* Current block count */
+    long    times;                              /* Count of alloc attempts */
+    long    largest;                            /* largest allocated here */
+    int     q;
 } bStatsFileType;
 
 /*
- *	This one is very expensive but great stats
+ *  This one is very expensive but great stats
  */
 typedef struct {
-	void			*ptr;						/* Pointer to memory */
-	bStatsFileType	*who;						/* Who allocated the memory */
+    void            *ptr;                       /* Pointer to memory */
+    bStatsFileType  *who;                       /* Who allocated the memory */
 } bStatsBlkType;
 
-static bStatsType		bStats[B_MAX_CLASS];	/* Per class stats */
-static bStatsFileType 	bStatsFiles[B_MAX_FILES];/* Per file stats */
-static bStatsBlkType 	bStatsBlks[B_MAX_BLOCKS];/* Per block stats */
-static int			 	bStatsBlksMax = 0;		/* Max block entry */
-static int			 	bStatsFilesMax = 0;		/* Max file entry */
-static int 				bStatsMemInUse = 0;		/* Memory currently in use */
-static int 				bStatsBallocInUse = 0;	/* Memory currently balloced */
-static int 				bStatsMemMax = 0;		/* Max memory ever used */
-static int 				bStatsBallocMax = 0;	/* Max memory ever balloced */
-static void				*bStackMin = (void*) -1;/* Miniumum stack position */
-static void				*bStackStart;			/* Starting stack position */
-static int 				bStatsMemMalloc = 0;	/* Malloced memory */
+static bStatsType       bStats[B_MAX_CLASS];    /* Per class stats */
+static bStatsFileType   bStatsFiles[B_MAX_FILES];/* Per file stats */
+static bStatsBlkType    bStatsBlks[B_MAX_BLOCKS];/* Per block stats */
+static int              bStatsBlksMax = 0;      /* Max block entry */
+static int              bStatsFilesMax = 0;     /* Max file entry */
+static int              bStatsMemInUse = 0;     /* Memory currently in use */
+static int              bStatsBallocInUse = 0;  /* Memory currently balloced */
+static int              bStatsMemMax = 0;       /* Max memory ever used */
+static int              bStatsBallocMax = 0;    /* Max memory ever balloced */
+static void             *bStackMin = (void*) -1;/* Miniumum stack position */
+static void             *bStackStart;           /* Starting stack position */
+static int              bStatsMemMalloc = 0;    /* Malloced memory */
 #endif /* B_STATS */
 
 /*
- *	ROUNDUP4(size) returns the next higher integer value of size that is 
- *	divisible by 4, or the value of size if size is divisible by 4.
- *	ROUNDUP4() is used in aligning memory allocations on 4-byte boundaries.
+ *  ROUNDUP4(size) returns the next higher integer value of size that is 
+ *  divisible by 4, or the value of size if size is divisible by 4.
+ *  ROUNDUP4() is used in aligning memory allocations on 4-byte boundaries.
  *
- *	Note:  ROUNDUP4() is only required on some operating systems (IRIX).
+ *  Note:  ROUNDUP4() is only required on some operating systems (IRIX).
  */
 
 #define ROUNDUP4(size) ((size) % 4) ? (size) + (4 - ((size) % 4)) : (size)
 
 /********************************** Locals ************************************/
 /*
- *	bQhead blocks are created as the original memory allocation is freed up.
- *	See bfree.
+ *  bQhead blocks are created as the original memory allocation is freed up.
+ *  See bfree.
  */
-static bType			*bQhead[B_MAX_CLASS];	/* Per class block q head */
-static char				*bFreeBuf;				/* Pointer to free memory */
-static char				*bFreeNext;				/* Pointer to next free mem */
-static int				bFreeSize;				/* Size of free memory */
-static int				bFreeLeft;				/* Size of free left for use */
-static int				bFlags = B_USE_MALLOC;	/* Default to auto-malloc */
-static int				bopenCount = 0;			/* Num tasks using balloc */
+static bType            *bQhead[B_MAX_CLASS];   /* Per class block q head */
+static char             *bFreeBuf;              /* Pointer to free memory */
+static char             *bFreeNext;             /* Pointer to next free mem */
+static int              bFreeSize;              /* Size of free memory */
+static int              bFreeLeft;              /* Size of free left for use */
+static int              bFlags = B_USE_MALLOC;  /* Default to auto-malloc */
+static int              bopenCount = 0;         /* Num tasks using balloc */
 
 /*************************** Forward Declarations *****************************/
 
@@ -105,7 +105,7 @@ static int				bopenCount = 0;			/* Num tasks using balloc */
 static void bStatsAlloc(B_ARGS_DEC, void *ptr, int q, int size);
 static void bStatsFree(B_ARGS_DEC, void *ptr, int q, int size);
 static void bstatsWrite(int handle, char_t *fmt, ...);
-static int 	bStatsFileSort(const void *cp1, const void *cp2);
+static int  bStatsFileSort(const void *cp1, const void *cp2);
 #endif /* B_STATS */
 
 #if (defined (B_FILL) || defined (B_VERIFY_CAUSES_SEVERE_OVERHEAD))
@@ -122,691 +122,691 @@ static int ballocGetSize(int size, int *q);
 
 /********************************** Code **************************************/
 /*
- *	Initialize the balloc module. bopen should be called the very first thing
- *	after the application starts and bclose should be called the last thing 
- *	before exiting. If bopen is not called, it will be called on the first 
- *	allocation with default values. "buf" points to memory to use of size 
- *	"bufsize". If buf is NULL, memory is allocated using malloc. flags may 
- *	be set to B_USE_MALLOC if using malloc is okay. This routine will allocate
- *	an initial buffer of size bufsize for use by the application.
+ *  Initialize the balloc module. bopen should be called the very first thing
+ *  after the application starts and bclose should be called the last thing 
+ *  before exiting. If bopen is not called, it will be called on the first 
+ *  allocation with default values. "buf" points to memory to use of size 
+ *  "bufsize". If buf is NULL, memory is allocated using malloc. flags may 
+ *  be set to B_USE_MALLOC if using malloc is okay. This routine will allocate
+ *  an initial buffer of size bufsize for use by the application.
  */
 
 int bopen(void *buf, int bufsize, int flags)
 {
-	bFlags = flags;
+    bFlags = flags;
 
 #ifdef BASTARD_TESTING
-	srand(time(0L));
+    srand(time(0L));
 #endif /* BASTARD_TESTING */
 
 /*
- *	If bopen already called by a shared process, just increment the count
- *	and return;
+ *  If bopen already called by a shared process, just increment the count
+ *  and return;
  */
-	if (++bopenCount > 1) {
-		return 0;
-	}
+    if (++bopenCount > 1) {
+        return 0;
+    }
 
-	if (buf == NULL) {
-		if (bufsize == 0) {
-			bufsize = B_DEFAULT_MEM;
-		}
+    if (buf == NULL) {
+        if (bufsize == 0) {
+            bufsize = B_DEFAULT_MEM;
+        }
 #ifdef IRIX
-		bufsize = ROUNDUP4(bufsize);
+        bufsize = ROUNDUP4(bufsize);
 #endif
-		if ((buf = malloc(bufsize)) == NULL) {
+        if ((buf = malloc(bufsize)) == NULL) {
          /* resetting bopenCount lets client code decide to attempt to call
           * bopen() again with a smaller memory request, should it desire to.
           * Fix suggested by Simon Byholm.
           */
          --bopenCount;
-			return -1;
-		}
+            return -1;
+        }
 #ifdef B_STATS
-		bStatsMemMalloc += bufsize;
+        bStatsMemMalloc += bufsize;
 #endif
-	} else {
-		bFlags |= B_USER_BUF;
-	}
+    } else {
+        bFlags |= B_USER_BUF;
+    }
 
-	bFreeSize = bFreeLeft = bufsize;
-	bFreeBuf = bFreeNext = buf;
-	memset(bQhead, 0, sizeof(bQhead));
+    bFreeSize = bFreeLeft = bufsize;
+    bFreeBuf = bFreeNext = buf;
+    memset(bQhead, 0, sizeof(bQhead));
 #if (defined (B_FILL) || defined (B_VERIFY_CAUSES_SEVERE_OVERHEAD))
-	bFillBlock(buf, bufsize);
+    bFillBlock(buf, bufsize);
 #endif
 #ifdef B_STATS
-	bStackStart = &buf;
+    bStackStart = &buf;
 #endif
 #ifdef B_VERIFY_CAUSES_SEVERE_OVERHEAD
-	verifyFreeBlock(buf, bufsize);
+    verifyFreeBlock(buf, bufsize);
 #endif
-	return 0;
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Close down the balloc module and free all malloced memory.
+ *  Close down the balloc module and free all malloced memory.
  */
 
 void bclose()
 {
 #ifdef B_VERIFY_CAUSES_SEVERE_OVERHEAD
-	verifyBallocSpace();
+    verifyBallocSpace();
 #endif
-	if (--bopenCount <= 0 && !(bFlags & B_USER_BUF)) {
-		free(bFreeBuf);
-		bopenCount = 0;
-	}
+    if (--bopenCount <= 0 && !(bFlags & B_USER_BUF)) {
+        free(bFreeBuf);
+        bopenCount = 0;
+    }
 }
 
 /******************************************************************************/
 /*
- *	Allocate a block of the requested size. First check the block 
- *	queues for a suitable one.
+ *  Allocate a block of the requested size. First check the block 
+ *  queues for a suitable one.
  */
 
 void *balloc(B_ARGS_DEC, int size)
 {
-	bType	*bp;
-	int		q, memSize;
+    bType   *bp;
+    int     q, memSize;
 
 /*
- *	Call bopen with default values if the application has not yet done so
+ *  Call bopen with default values if the application has not yet done so
  */
-	if (bFreeBuf == NULL) {
-		if (bopen(NULL, B_DEFAULT_MEM, 0) < 0) {
-			return NULL;
-		}
-	}
+    if (bFreeBuf == NULL) {
+        if (bopen(NULL, B_DEFAULT_MEM, 0) < 0) {
+            return NULL;
+        }
+    }
 #ifdef B_VERIFY_CAUSES_SEVERE_OVERHEAD
-	verifyBallocSpace();
+    verifyBallocSpace();
 #endif
-	if (size < 0) {
-		return NULL;
-	}
+    if (size < 0) {
+        return NULL;
+    }
 
 #ifdef BASTARD_TESTING
-	if (rand() == 0x7fff) {
-		return NULL;
-	}
+    if (rand() == 0x7fff) {
+        return NULL;
+    }
 #endif /* BASTARD_TESTING */
 
 
-	memSize = ballocGetSize(size, &q);
+    memSize = ballocGetSize(size, &q);
 
-	if (q >= B_MAX_CLASS) {
+    if (q >= B_MAX_CLASS) {
 /*
- *		Size if bigger than the maximum class. Malloc if use has been okayed
+ *      Size if bigger than the maximum class. Malloc if use has been okayed
  */
-		if (bFlags & B_USE_MALLOC) {
+        if (bFlags & B_USE_MALLOC) {
 #ifdef B_STATS
-			bstats(0, NULL);
+            bstats(0, NULL);
 #endif
 #ifdef IRIX
-			memSize = ROUNDUP4(memSize);
+            memSize = ROUNDUP4(memSize);
 #endif
-			bp = (bType*) malloc(memSize);
-			if (bp == NULL) {
-				traceRaw(T("B: malloc failed\n"));
-				return NULL;
-			}
+            bp = (bType*) malloc(memSize);
+            if (bp == NULL) {
+                traceRaw(T("B: malloc failed\n"));
+                return NULL;
+            }
 #ifdef B_STATS
-			bStatsMemMalloc += memSize;
+            bStatsMemMalloc += memSize;
 #endif
 #if (defined (B_FILL) || defined (B_VERIFY_CAUSES_SEVERE_OVERHEAD))
-			bFillBlock(bp, memSize);
+            bFillBlock(bp, memSize);
 #endif
 
-		} else {
-			traceRaw(T("B: malloc failed\n"));
-			return NULL;
-		}
+        } else {
+            traceRaw(T("B: malloc failed\n"));
+            return NULL;
+        }
 
 /*
- *		the u.size is the actual size allocated for data
+ *      the u.size is the actual size allocated for data
  */
-		bp->u.size = memSize - sizeof(bType);
-		bp->flags = B_MALLOCED;
+        bp->u.size = memSize - sizeof(bType);
+        bp->flags = B_MALLOCED;
 
-	} else if ((bp = bQhead[q]) != NULL) {
+    } else if ((bp = bQhead[q]) != NULL) {
 /*
- *		Take first block off the relevant q if non-empty
+ *      Take first block off the relevant q if non-empty
  */
-		bQhead[q] = bp->u.next;
+        bQhead[q] = bp->u.next;
 #ifdef B_VERIFY_CAUSES_SEVERE_OVERHEAD
-		verifyFreeBlock(bp, q);
+        verifyFreeBlock(bp, q);
 #endif
 #if (defined (B_FILL) || defined (B_VERIFY_CAUSES_SEVERE_OVERHEAD))
-		bFillBlock(bp, memSize);
+        bFillBlock(bp, memSize);
 #endif
-		bp->u.size = memSize - sizeof(bType);
-		bp->flags = 0;
+        bp->u.size = memSize - sizeof(bType);
+        bp->flags = 0;
 
-	} else {
-		if (bFreeLeft > memSize) {
+    } else {
+        if (bFreeLeft > memSize) {
 /*
- *			The q was empty, and the free list has spare memory so 
- *			create a new block out of the primary free block
+ *          The q was empty, and the free list has spare memory so 
+ *          create a new block out of the primary free block
  */
-			bp = (bType*) bFreeNext;
+            bp = (bType*) bFreeNext;
 #ifdef B_VERIFY_CAUSES_SEVERE_OVERHEAD
-			verifyFreeBlock(bp, q);
+            verifyFreeBlock(bp, q);
 #endif
-			bFreeNext += memSize;
-			bFreeLeft -= memSize;
+            bFreeNext += memSize;
+            bFreeLeft -= memSize;
 #if (defined (B_FILL) || defined (B_VERIFY_CAUSES_SEVERE_OVERHEAD))
-			bFillBlock(bp, memSize);
+            bFillBlock(bp, memSize);
 #endif
-			bp->u.size = memSize - sizeof(bType);
-			bp->flags = 0;
+            bp->u.size = memSize - sizeof(bType);
+            bp->flags = 0;
 
-		} else if (bFlags & B_USE_MALLOC) {
+        } else if (bFlags & B_USE_MALLOC) {
 #ifdef B_STATS
-			static int once = 0;
-			if (once++ == 0) {
-				bstats(0, NULL);
-			}
+            static int once = 0;
+            if (once++ == 0) {
+                bstats(0, NULL);
+            }
 #endif
 /*
- *			Nothing left on the primary free list, so malloc a new block
+ *          Nothing left on the primary free list, so malloc a new block
  */
 #ifdef IRIX
-			memSize = ROUNDUP4(memSize);
+            memSize = ROUNDUP4(memSize);
 #endif
-			if ((bp = (bType*) malloc(memSize)) == NULL) {
-				traceRaw(T("B: malloc failed\n"));
-				return NULL;
-			}
+            if ((bp = (bType*) malloc(memSize)) == NULL) {
+                traceRaw(T("B: malloc failed\n"));
+                return NULL;
+            }
 #ifdef B_STATS
-			bStatsMemMalloc += memSize;
+            bStatsMemMalloc += memSize;
 #endif
 #if (defined (B_FILL) || defined (B_VERIFY_CAUSES_SEVERE_OVERHEAD))
-			bFillBlock(bp, memSize);
+            bFillBlock(bp, memSize);
 #endif
-			bp->u.size = memSize - sizeof(bType);
-			bp->flags = B_MALLOCED;
+            bp->u.size = memSize - sizeof(bType);
+            bp->flags = B_MALLOCED;
 
-		} else {
-			traceRaw(T("B: malloc failed\n"));
-			return NULL;
-		}
-	}
+        } else {
+            traceRaw(T("B: malloc failed\n"));
+            return NULL;
+        }
+    }
 
 #ifdef B_STATS
-	bStatsAlloc(B_ARGS, bp, q, memSize);
+    bStatsAlloc(B_ARGS, bp, q, memSize);
 #endif
-	bp->flags |= B_INTEGRITY;
+    bp->flags |= B_INTEGRITY;
 
 /*
- *	The following is a good place to put a breakpoint when trying to reduce
- *	determine and reduce maximum memory use.
+ *  The following is a good place to put a breakpoint when trying to reduce
+ *  determine and reduce maximum memory use.
  */
 #if 0
 #ifdef B_STATS
-	if (bStatsBallocInUse == bStatsBallocMax) {
-		bstats(0, NULL);
-	}
+    if (bStatsBallocInUse == bStatsBallocMax) {
+        bstats(0, NULL);
+    }
 #endif
 #endif
-	return (void*) ((char*) bp + sizeof(bType));
+    return (void*) ((char*) bp + sizeof(bType));
 }
 
 /******************************************************************************/
 /*
- *	Free a block back to the relevant free q. We don't free back to the O/S
- *	or run time system unless the block is greater than the maximum class size.
- *	We also do not coalesce blocks.
+ *  Free a block back to the relevant free q. We don't free back to the O/S
+ *  or run time system unless the block is greater than the maximum class size.
+ *  We also do not coalesce blocks.
  */
 
 void bfree(B_ARGS_DEC, void *mp)
 {
-	bType	*bp;
-	int		q, memSize;
+    bType   *bp;
+    int     q, memSize;
 
 #ifdef B_VERIFY_CAUSES_SEVERE_OVERHEAD
-	verifyBallocSpace();
+    verifyBallocSpace();
 #endif
-	bp = (bType*) ((char*) mp - sizeof(bType));
+    bp = (bType*) ((char*) mp - sizeof(bType));
 
-	a_assert((bp->flags & B_INTEGRITY_MASK) == B_INTEGRITY);
+    a_assert((bp->flags & B_INTEGRITY_MASK) == B_INTEGRITY);
 
-	if ((bp->flags & B_INTEGRITY_MASK) != B_INTEGRITY) {
-		return;
-	}
+    if ((bp->flags & B_INTEGRITY_MASK) != B_INTEGRITY) {
+        return;
+    }
 
-	memSize = ballocGetSize(bp->u.size, &q);
+    memSize = ballocGetSize(bp->u.size, &q);
 
 #ifdef B_VERIFY_CAUSES_SEVERE_OVERHEAD
-	verifyUsedBlock(bp,q);
+    verifyUsedBlock(bp,q);
 #endif
 #ifdef B_STATS
-	bStatsFree(B_ARGS, bp, q, bp->u.size+sizeof(bType));
+    bStatsFree(B_ARGS, bp, q, bp->u.size+sizeof(bType));
 #endif
-	if (bp->flags & B_MALLOCED) {
-		free(bp);
-		return;
-	}
-		
+    if (bp->flags & B_MALLOCED) {
+        free(bp);
+        return;
+    }
+        
 #ifdef B_VERIFY_CAUSES_SEVERE_OVERHEAD
-	bFillBlock(bp, memSize);
+    bFillBlock(bp, memSize);
 #endif
 
 /*
- *	Simply link onto the head of the relevant q
+ *  Simply link onto the head of the relevant q
  */
-	bp->u.next = bQhead[q];
-	bQhead[q] = bp;
+    bp->u.next = bQhead[q];
+    bQhead[q] = bp;
 
-	bp->flags = B_FILL_WORD;
+    bp->flags = B_FILL_WORD;
 }
 
 /******************************************************************************/
 /*
- *	Safe free
+ *  Safe free
  */
 
 void bfreeSafe(B_ARGS_DEC, void *mp)
 {
-	if (mp) {
-		bfree(B_ARGS, mp);
-	}
+    if (mp) {
+        bfree(B_ARGS, mp);
+    }
 }
 
 /******************************************************************************/
 #ifdef UNICODE
 /*
- *	Duplicate a string, allow NULL pointers and then dup an empty string.
+ *  Duplicate a string, allow NULL pointers and then dup an empty string.
  */
 
 char *bstrdupA(B_ARGS_DEC, char *s)
 {
-	char	*cp;
-	int		len;
-
-	if (s == NULL) {
-		s = "";
-	}
-	len = strlen(s) + 1;
-	if (cp = balloc(B_ARGS, len)) {
-		strcpy(cp, s);
-	}
-	return cp;
+    char    *cp;
+    int     len;
+
+    if (s == NULL) {
+        s = "";
+    }
+    len = strlen(s) + 1;
+    if (cp = balloc(B_ARGS, len)) {
+        strcpy(cp, s);
+    }
+    return cp;
 }
 
 #endif /* UNICODE */
 /******************************************************************************/
 /*
- *	Duplicate an ascii string, allow NULL pointers and then dup an empty string.
- *	If UNICODE, bstrdup above works with wide chars, so we need this routine
- *	for ascii strings. 
+ *  Duplicate an ascii string, allow NULL pointers and then dup an empty string.
+ *  If UNICODE, bstrdup above works with wide chars, so we need this routine
+ *  for ascii strings. 
  */
 
 char_t *bstrdup(B_ARGS_DEC, char_t *s)
 {
-	char_t	*cp;
-	int		len;
-
-	if (s == NULL) {
-		s = T("");
-	}
-	len = gstrlen(s) + 1;
-	if ((cp = balloc(B_ARGS, len * sizeof(char_t))) != NULL) {
-		gstrncpy(cp, s, len * sizeof(char_t));
-	}
-	return cp;
+    char_t  *cp;
+    int     len;
+
+    if (s == NULL) {
+        s = T("");
+    }
+    len = gstrlen(s) + 1;
+    if ((cp = balloc(B_ARGS, len * sizeof(char_t))) != NULL) {
+        gstrncpy(cp, s, len * sizeof(char_t));
+    }
+    return cp;
 }
 
 /******************************************************************************/
 /*
- *	Reallocate a block. Allow NULL pointers and just do a malloc.
- *	Note: if the realloc fails, we return NULL and the previous buffer is 
- *	preserved.
+ *  Reallocate a block. Allow NULL pointers and just do a malloc.
+ *  Note: if the realloc fails, we return NULL and the previous buffer is 
+ *  preserved.
  */
 
 void *brealloc(B_ARGS_DEC, void *mp, int newsize)
 {
-	bType	*bp;
-	void	*newbuf;
-
-	if (mp == NULL) {
-		return balloc(B_ARGS, newsize);
-	}
-	bp = (bType*) ((char*) mp - sizeof(bType));
-	a_assert((bp->flags & B_INTEGRITY_MASK) == B_INTEGRITY);
-
-/*
- *	If the allocated memory already has enough room just return the previously
- *	allocated address.
- */
-	if (bp->u.size >= newsize) {
-		return mp;
-	}
-	if ((newbuf = balloc(B_ARGS, newsize)) != NULL) {
-		memcpy(newbuf, mp, bp->u.size);
-		bfree(B_ARGS, mp);
-	}
-	return newbuf;
+    bType   *bp;
+    void    *newbuf;
+
+    if (mp == NULL) {
+        return balloc(B_ARGS, newsize);
+    }
+    bp = (bType*) ((char*) mp - sizeof(bType));
+    a_assert((bp->flags & B_INTEGRITY_MASK) == B_INTEGRITY);
+
+/*
+ *  If the allocated memory already has enough room just return the previously
+ *  allocated address.
+ */
+    if (bp->u.size >= newsize) {
+        return mp;
+    }
+    if ((newbuf = balloc(B_ARGS, newsize)) != NULL) {
+        memcpy(newbuf, mp, bp->u.size);
+        bfree(B_ARGS, mp);
+    }
+    return newbuf;
 }
 
 /******************************************************************************/
 /*
- *	Find the size of the block to be balloc'ed.  It takes in a size, finds the 
- *	smallest binary block it fits into, adds an overhead amount and returns.
- *	q is the binary size used to keep track of block sizes in use.  Called
- *	from both balloc and bfree.
+ *  Find the size of the block to be balloc'ed.  It takes in a size, finds the 
+ *  smallest binary block it fits into, adds an overhead amount and returns.
+ *  q is the binary size used to keep track of block sizes in use.  Called
+ *  from both balloc and bfree.
  */
 
 static int ballocGetSize(int size, int *q)
 {
-	int	mask;
+    int mask;
 
-	mask = (size == 0) ? 0 : (size-1) >> B_SHIFT;
-	for (*q = 0; mask; mask >>= 1) {
-		*q = *q + 1;
-	}
-	return ((1 << (B_SHIFT + *q)) + sizeof(bType));
+    mask = (size == 0) ? 0 : (size-1) >> B_SHIFT;
+    for (*q = 0; mask; mask >>= 1) {
+        *q = *q + 1;
+    }
+    return ((1 << (B_SHIFT + *q)) + sizeof(bType));
 }
 
 /******************************************************************************/
 #if (defined (B_FILL) || defined (B_VERIFY_CAUSES_SEVERE_OVERHEAD))
 /*
- *	Fill the block (useful during development to catch zero fill assumptions)
+ *  Fill the block (useful during development to catch zero fill assumptions)
  */
 
 static void bFillBlock(void *buf, int bufsize)
 {
-	memset(buf, B_FILL_CHAR, bufsize);
+    memset(buf, B_FILL_CHAR, bufsize);
 }
 #endif
 
 /******************************************************************************/
 #ifdef B_STATS
 /*
- *	Statistics. Do output via calling the writefn callback function with 
- *	"handle" as the output file handle. 
+ *  Statistics. Do output via calling the writefn callback function with 
+ *  "handle" as the output file handle. 
  */
 
 void bstats(int handle, void (*writefn)(int handle, char_t *fmt, ...))
 {
-	bStatsFileType	*fp, *files;
-	bStatsBlkType	*blkp;
-	bType			*bp;
-	char_t			*cp;
-	int				q, count, mem, total, len;
-	static	int 	recurseProtect = 0;
+    bStatsFileType  *fp, *files;
+    bStatsBlkType   *blkp;
+    bType           *bp;
+    char_t          *cp;
+    int             q, count, mem, total, len;
+    static  int     recurseProtect = 0;
 
-	if (recurseProtect++ > 0) {
-		recurseProtect--;
-		return;
-	}
+    if (recurseProtect++ > 0) {
+        recurseProtect--;
+        return;
+    }
 
-	if (writefn == NULL) {
-		writefn = bstatsWrite;
-	}
+    if (writefn == NULL) {
+        writefn = bstatsWrite;
+    }
 
 /*
- *	Print stats for each memory block
+ *  Print stats for each memory block
  */
-	(*writefn)(handle, T("\nMemory Stats\n"));
+    (*writefn)(handle, T("\nMemory Stats\n"));
 
 /*
- *	The following tabular format is now used for the output.
+ *  The following tabular format is now used for the output.
  *   Q  Size  Free Bytes Inuse Bytes Allocs
- *	dd ddddd   ddd ddddd  dddd ddddd   dddd
+ *  dd ddddd   ddd ddddd  dddd ddddd   dddd
  */
-	(*writefn)(handle, " Q  Size   Free  Bytes Inuse Bytes Allocs\n");
+    (*writefn)(handle, " Q  Size   Free  Bytes Inuse Bytes Allocs\n");
 
-	total = 0;
-	for (q = 0; q < B_MAX_CLASS; q++) {
-		count = 0;
-		for (bp = bQhead[q]; bp; bp = bp->u.next) {
-			count++;
-		}
-		mem = count * (1 << (q + B_SHIFT));
-		total += mem;
-		(*writefn)(handle, 
-			T("%2d %5d   %4d %6d  %4d %5d   %4d\n"),
-			q, 1 << (q + B_SHIFT), count, mem, bStats[q].inuse, 
-			bStats[q].inuse * (1 << (q + B_SHIFT)), bStats[q].alloc);
-	}
+    total = 0;
+    for (q = 0; q < B_MAX_CLASS; q++) {
+        count = 0;
+        for (bp = bQhead[q]; bp; bp = bp->u.next) {
+            count++;
+        }
+        mem = count * (1 << (q + B_SHIFT));
+        total += mem;
+        (*writefn)(handle, 
+            T("%2d %5d   %4d %6d  %4d %5d   %4d\n"),
+            q, 1 << (q + B_SHIFT), count, mem, bStats[q].inuse, 
+            bStats[q].inuse * (1 << (q + B_SHIFT)), bStats[q].alloc);
+    }
 
-	(*writefn)(handle, T("\n"));
+    (*writefn)(handle, T("\n"));
 
 /*
- *	Print summary stats
+ *  Print summary stats
  *
- *	bFreeSize			Initial memory reserved with bopen call
- *	bStatsMemMalloc		memory from calls to system MALLOC
- *	bStatsMemMax		
- *	bStatsBallocMax		largest amount of memory from balloc calls
- *	bStatsMemInUse
- *	bStatsBallocInUse	present balloced memory being used
- *	bStatsBlksMax);
- *	bStackStart
- *	bStackMin);
- *	total);
- *	bFreeLeft);
+ *  bFreeSize           Initial memory reserved with bopen call
+ *  bStatsMemMalloc     memory from calls to system MALLOC
+ *  bStatsMemMax        
+ *  bStatsBallocMax     largest amount of memory from balloc calls
+ *  bStatsMemInUse
+ *  bStatsBallocInUse   present balloced memory being used
+ *  bStatsBlksMax);
+ *  bStackStart
+ *  bStackMin);
+ *  total);
+ *  bFreeLeft);
  *
  */
-	(*writefn)(handle, T("Initial free list size    %7d\n"), bFreeSize);
-	(*writefn)(handle, T("Max memory malloced       %7d\n"), bStatsMemMalloc);
-	(*writefn)(handle, T("Max memory ever used      %7d\n"), bStatsMemMax);
-	(*writefn)(handle, T("Max memory ever balloced  %7d\n"), bStatsBallocMax);
-	(*writefn)(handle, T("Memory currently in use   %7d\n"), bStatsMemInUse);
-	(*writefn)(handle, T("Memory currently balloced %7d\n"), bStatsBallocInUse);
-	(*writefn)(handle, T("Max blocks allocated      %7d\n"), bStatsBlksMax);
-	(*writefn)(handle, T("Maximum stack used        %7d\n"), 
-		(int) bStackStart - (int) bStackMin);
-
-	(*writefn)(handle, T("Free memory on all queues %7d\n"), total);
-	(*writefn)(handle, T("Free list buffer left     %7d\n"), bFreeLeft);
-	(*writefn)(handle, T("Total free memory         %7d\n"), bFreeLeft + total);
-
-/*
- *	Print per file allocation stats. Sort the copied table.
- */
-	len = sizeof(bStatsFileType) * B_MAX_FILES;
-	files = malloc(len);
-	if (files == NULL) {
-		(*writefn)(handle, T("Can't allocate stats memory\n"));
-		recurseProtect--;
-		return;
-	}
-	memcpy(files, bStatsFiles, len);
-	qsort(files, bStatsFilesMax, sizeof(bStatsFileType), bStatsFileSort);
-	
-	(*writefn)(handle, T("\nMemory Currently Allocated\n"));
-	total = 0;
-	(*writefn)(handle, 
-		T("                      bytes, blocks in use, total times,")
-		T("largest,   q\n"));
-
-	for (fp = files; fp < &files[bStatsFilesMax]; fp++) {
-		if (fp->file[0]) {
-			(*writefn)(handle, T("%18s, %7d,         %5d,      %6d, %7d,%4d\n"),
-				fp->file, fp->allocated, fp->count, fp->times, fp->largest, 
-				fp->q);
-			total += fp->allocated;
-		}
-	}
-	(*writefn)(handle, T("\nTotal allocated %7d\n\n"), total);
-
-/*
- *	Dump the actual strings
- */
-	(*writefn)(handle, T("\nStrings\n"));
-	for (blkp = &bStatsBlks[bStatsBlksMax - 1]; blkp >= bStatsBlks; blkp--) {
-		if (blkp->ptr) {
-			cp = (char_t*) ((char*) blkp->ptr + sizeof(bType));
-			fp = blkp->who;
-			if (gisalnum(*cp)) {
-				(*writefn)(handle, T("%-50s allocated by %s\n"), cp, 
-					fp->file);
-			}
-		}
-	}
-	free(files);
-	recurseProtect--;
+    (*writefn)(handle, T("Initial free list size    %7d\n"), bFreeSize);
+    (*writefn)(handle, T("Max memory malloced       %7d\n"), bStatsMemMalloc);
+    (*writefn)(handle, T("Max memory ever used      %7d\n"), bStatsMemMax);
+    (*writefn)(handle, T("Max memory ever balloced  %7d\n"), bStatsBallocMax);
+    (*writefn)(handle, T("Memory currently in use   %7d\n"), bStatsMemInUse);
+    (*writefn)(handle, T("Memory currently balloced %7d\n"), bStatsBallocInUse);
+    (*writefn)(handle, T("Max blocks allocated      %7d\n"), bStatsBlksMax);
+    (*writefn)(handle, T("Maximum stack used        %7d\n"), 
+        (int) bStackStart - (int) bStackMin);
+
+    (*writefn)(handle, T("Free memory on all queues %7d\n"), total);
+    (*writefn)(handle, T("Free list buffer left     %7d\n"), bFreeLeft);
+    (*writefn)(handle, T("Total free memory         %7d\n"), bFreeLeft + total);
+
+/*
+ *  Print per file allocation stats. Sort the copied table.
+ */
+    len = sizeof(bStatsFileType) * B_MAX_FILES;
+    files = malloc(len);
+    if (files == NULL) {
+        (*writefn)(handle, T("Can't allocate stats memory\n"));
+        recurseProtect--;
+        return;
+    }
+    memcpy(files, bStatsFiles, len);
+    qsort(files, bStatsFilesMax, sizeof(bStatsFileType), bStatsFileSort);
+    
+    (*writefn)(handle, T("\nMemory Currently Allocated\n"));
+    total = 0;
+    (*writefn)(handle, 
+        T("                      bytes, blocks in use, total times,")
+        T("largest,   q\n"));
+
+    for (fp = files; fp < &files[bStatsFilesMax]; fp++) {
+        if (fp->file[0]) {
+            (*writefn)(handle, T("%18s, %7d,         %5d,      %6d, %7d,%4d\n"),
+                fp->file, fp->allocated, fp->count, fp->times, fp->largest, 
+                fp->q);
+            total += fp->allocated;
+        }
+    }
+    (*writefn)(handle, T("\nTotal allocated %7d\n\n"), total);
+
+/*
+ *  Dump the actual strings
+ */
+    (*writefn)(handle, T("\nStrings\n"));
+    for (blkp = &bStatsBlks[bStatsBlksMax - 1]; blkp >= bStatsBlks; blkp--) {
+        if (blkp->ptr) {
+            cp = (char_t*) ((char*) blkp->ptr + sizeof(bType));
+            fp = blkp->who;
+            if (gisalnum(*cp)) {
+                (*writefn)(handle, T("%-50s allocated by %s\n"), cp, 
+                    fp->file);
+            }
+        }
+    }
+    free(files);
+    recurseProtect--;
 }
 
 /******************************************************************************/
 /*
- *	File sort function. Used to sort per file stats
+ *  File sort function. Used to sort per file stats
  */
 
 static int bStatsFileSort(const void *cp1, const void *cp2)
 {
-	bStatsFileType	*s1, *s2;
+    bStatsFileType  *s1, *s2;
 
-	s1 = (bStatsFileType*) cp1;
-	s2 = (bStatsFileType*) cp2;
+    s1 = (bStatsFileType*) cp1;
+    s2 = (bStatsFileType*) cp2;
 
-	if (s1->allocated < s2->allocated)
-		return -1;
-	else if (s1->allocated == s2->allocated)
-		return 0;
-	return 1;
+    if (s1->allocated < s2->allocated)
+        return -1;
+    else if (s1->allocated == s2->allocated)
+        return 0;
+    return 1;
 }
 
 /******************************************************************************/
 /*
- *	Accumulate allocation statistics
+ *  Accumulate allocation statistics
  */
 
 static void bStatsAlloc(B_ARGS_DEC, void *ptr, int q, int size)
 {
-	int				memSize;
-	bStatsFileType	*fp;
-	bStatsBlkType	*bp;
-	char_t			name[FNAMESIZE + 10];
-
-	gsprintf(name, T("%s:%d"), B_ARGS);
-
-	bStats[q].alloc++;
-	bStats[q].inuse++;
-	bStatsMemInUse += size;
-	if (bStatsMemInUse > bStatsMemMax) {
-		bStatsMemMax = bStatsMemInUse;
-	}
-	memSize = (1 << (B_SHIFT + q)) + sizeof(bType);
-	bStatsBallocInUse += memSize;
-	if (bStatsBallocInUse > bStatsBallocMax) {
-		bStatsBallocMax = bStatsBallocInUse;
-	}
-
-/*
- *	Track maximum stack usage. Assumes a stack growth down. Approximate as
- *	we only measure this on block allocation.
- */
-	if ((void*) &file < bStackMin) {
-		bStackMin = (void*) &file;
-	}
-
-/*
- *	Find the file and adjust the stats for this file
- */
-	for (fp = bStatsFiles; fp < &bStatsFiles[bStatsFilesMax]; fp++) {
-		if (fp->file[0] == file[0] && gstrcmp(fp->file, name) == 0) {
-			fp->allocated += size;
-			fp->count++;
-			fp->times++;
-			if (fp->largest < size) {
-				fp->largest = size;
-				fp->q = q;
-			}
-			break;
-		}
-	}
-
-/*
- *	New entry: find the first free slot and create a new entry
- */
-	if (fp >= &bStatsFiles[bStatsFilesMax]) {
-		for (fp = bStatsFiles; fp < &bStatsFiles[B_MAX_FILES]; fp++) {
-			if (fp->file[0] == '\0') {
-				gstrncpy(fp->file, name, TSZ(fp->file));
-				fp->allocated += size;
-				fp->count++;
-				fp->times++;
-				fp->largest = size;
-				fp->q = q;
-				if ((fp - bStatsFiles) >= bStatsFilesMax) {
-					bStatsFilesMax = (fp - bStatsFiles) + 1;
-				}
-				break;
-			}
-		}
-	}
-
-/*
- *	Update the per block stats. Allocate a new slot.
- */
-	for (bp = bStatsBlks; bp < &bStatsBlks[B_MAX_BLOCKS]; bp++) {
-		if (bp->ptr == NULL) {
-			bp->ptr = ptr;
-			bp->who = fp;
-			if ((bp - bStatsBlks) >= bStatsBlksMax) {
-				bStatsBlksMax = (bp - bStatsBlks) + 1;
-			}
-			break;
-		}
-	}
+    int             memSize;
+    bStatsFileType  *fp;
+    bStatsBlkType   *bp;
+    char_t          name[FNAMESIZE + 10];
+
+    gsprintf(name, T("%s:%d"), B_ARGS);
+
+    bStats[q].alloc++;
+    bStats[q].inuse++;
+    bStatsMemInUse += size;
+    if (bStatsMemInUse > bStatsMemMax) {
+        bStatsMemMax = bStatsMemInUse;
+    }
+    memSize = (1 << (B_SHIFT + q)) + sizeof(bType);
+    bStatsBallocInUse += memSize;
+    if (bStatsBallocInUse > bStatsBallocMax) {
+        bStatsBallocMax = bStatsBallocInUse;
+    }
+
+/*
+ *  Track maximum stack usage. Assumes a stack growth down. Approximate as
+ *  we only measure this on block allocation.
+ */
+    if ((void*) &file < bStackMin) {
+        bStackMin = (void*) &file;
+    }
+
+/*
+ *  Find the file and adjust the stats for this file
+ */
+    for (fp = bStatsFiles; fp < &bStatsFiles[bStatsFilesMax]; fp++) {
+        if (fp->file[0] == file[0] && gstrcmp(fp->file, name) == 0) {
+            fp->allocated += size;
+            fp->count++;
+            fp->times++;
+            if (fp->largest < size) {
+                fp->largest = size;
+                fp->q = q;
+            }
+            break;
+        }
+    }
+
+/*
+ *  New entry: find the first free slot and create a new entry
+ */
+    if (fp >= &bStatsFiles[bStatsFilesMax]) {
+        for (fp = bStatsFiles; fp < &bStatsFiles[B_MAX_FILES]; fp++) {
+            if (fp->file[0] == '\0') {
+                gstrncpy(fp->file, name, TSZ(fp->file));
+                fp->allocated += size;
+                fp->count++;
+                fp->times++;
+                fp->largest = size;
+                fp->q = q;
+                if ((fp - bStatsFiles) >= bStatsFilesMax) {
+                    bStatsFilesMax = (fp - bStatsFiles) + 1;
+                }
+                break;
+            }
+        }
+    }
+
+/*
+ *  Update the per block stats. Allocate a new slot.
+ */
+    for (bp = bStatsBlks; bp < &bStatsBlks[B_MAX_BLOCKS]; bp++) {
+        if (bp->ptr == NULL) {
+            bp->ptr = ptr;
+            bp->who = fp;
+            if ((bp - bStatsBlks) >= bStatsBlksMax) {
+                bStatsBlksMax = (bp - bStatsBlks) + 1;
+            }
+            break;
+        }
+    }
 }
 
 /******************************************************************************/
 /*
- *	Free statistics
+ *  Free statistics
  */
 
 static void bStatsFree(B_ARGS_DEC, void *ptr, int q, int size)
 {
-	int				memSize;
-	bStatsFileType	*fp;
-	bStatsBlkType	*bp;
-
-	memSize = (1 << (B_SHIFT + q)) + sizeof(bType);
-	bStatsMemInUse -= size;
-	bStatsBallocInUse -= memSize;
-	bStats[q].inuse--;
-
-/*
- *	Update the per block stats. Try from the end first 
- */
-	for (bp = &bStatsBlks[bStatsBlksMax - 1]; bp >= bStatsBlks; bp--) {
-		if (bp->ptr == ptr) {
-			bp->ptr = NULL;
-			fp = bp->who;
-			bp->who = NULL;
-			fp->allocated -= size;
-			fp->count--;
-			return;
-		}
-	}
+    int             memSize;
+    bStatsFileType  *fp;
+    bStatsBlkType   *bp;
+
+    memSize = (1 << (B_SHIFT + q)) + sizeof(bType);
+    bStatsMemInUse -= size;
+    bStatsBallocInUse -= memSize;
+    bStats[q].inuse--;
+
+/*
+ *  Update the per block stats. Try from the end first 
+ */
+    for (bp = &bStatsBlks[bStatsBlksMax - 1]; bp >= bStatsBlks; bp--) {
+        if (bp->ptr == ptr) {
+            bp->ptr = NULL;
+            fp = bp->who;
+            bp->who = NULL;
+            fp->allocated -= size;
+            fp->count--;
+            return;
+        }
+    }
 }
 
 /******************************************************************************/
 /*
- *	Default output function. Just send to trace channel.
+ *  Default output function. Just send to trace channel.
  */
 
 #undef sprintf
 static void bstatsWrite(int handle, char_t *fmt, ...)
 {
-	va_list		args;
-	char_t		buf[BUF_MAX];
+    va_list     args;
+    char_t      buf[BUF_MAX];
 
-	va_start(args, fmt);
-	vsprintf(buf, fmt, args);
-	va_end(args);
-	traceRaw(buf);
+    va_start(args, fmt);
+    vsprintf(buf, fmt, args);
+    va_end(args);
+    traceRaw(buf);
 }
 
 
 #else /* not B_STATS */
 /******************************************************************************/
 /*
- *	Dummy bstats for external calls that aren't protected by #if B_STATS.
+ *  Dummy bstats for external calls that aren't protected by #if B_STATS.
  */
 
 void bstats(int handle, void (*writefn)(int handle, char_t *fmt, ...))
@@ -817,97 +817,97 @@ void bstats(int handle, void (*writefn)(int handle, char_t *fmt, ...))
 /******************************************************************************/
 #ifdef B_VERIFY_CAUSES_SEVERE_OVERHEAD
 /*
- *	The following routines verify the integrity of the balloc memory space.
- *	These functions use the B_FILL feature.  Corruption is defined
- *	as bad integrity flags in allocated blocks or data other than B_FILL_CHAR
- *	being found anywhere in the space which is unallocated and that is not a
- *	next pointer in the free queues. a_assert is called if any corruption is
- *	found.  CAUTION:  These functions add severe processing overhead and should
- *	only be used when searching for a tough corruption problem.
+ *  The following routines verify the integrity of the balloc memory space.
+ *  These functions use the B_FILL feature.  Corruption is defined
+ *  as bad integrity flags in allocated blocks or data other than B_FILL_CHAR
+ *  being found anywhere in the space which is unallocated and that is not a
+ *  next pointer in the free queues. a_assert is called if any corruption is
+ *  found.  CAUTION:  These functions add severe processing overhead and should
+ *  only be used when searching for a tough corruption problem.
  */
 
 /******************************************************************************/
 /*
- *	verifyUsedBlock verifies that a block which was previously allocated is
- *	still uncorrupted.  
+ *  verifyUsedBlock verifies that a block which was previously allocated is
+ *  still uncorrupted.  
  */
 
 static void verifyUsedBlock(bType *bp, int q)
 {
-	int		memSize, size;
-	char	*p;
-
-	memSize = (1 << (B_SHIFT + q)) + sizeof(bType);
-	a_assert((bp->flags & ~B_MALLOCED) == B_INTEGRITY);
-	size = bp->u.size;
-	for (p = ((char *)bp)+sizeof(bType)+size; p < ((char*)bp)+memSize; p++) {
-		a_assert(*p == B_FILL_CHAR);
-	}
+    int     memSize, size;
+    char    *p;
+
+    memSize = (1 << (B_SHIFT + q)) + sizeof(bType);
+    a_assert((bp->flags & ~B_MALLOCED) == B_INTEGRITY);
+    size = bp->u.size;
+    for (p = ((char *)bp)+sizeof(bType)+size; p < ((char*)bp)+memSize; p++) {
+        a_assert(*p == B_FILL_CHAR);
+    }
 }
 
 /******************************************************************************/
 /*
- *	verifyFreeBlock verifies that a previously free'd block in one of the queues
- *	is still uncorrupted.
+ *  verifyFreeBlock verifies that a previously free'd block in one of the queues
+ *  is still uncorrupted.
  */
 
 static void verifyFreeBlock(bType *bp, int q)
 {
-	int		memSize;
-	char	*p;
-
-	memSize = (1 << (B_SHIFT + q)) + sizeof(bType);
-	for (p = ((char *)bp)+sizeof(void*); p < ((char*)bp)+memSize; p++) {
-		a_assert(*p == B_FILL_CHAR);
-	}
-	bp = (bType *)p;
-	a_assert((bp->flags & ~B_MALLOCED) == B_INTEGRITY ||
-		bp->flags == B_FILL_WORD);
+    int     memSize;
+    char    *p;
+
+    memSize = (1 << (B_SHIFT + q)) + sizeof(bType);
+    for (p = ((char *)bp)+sizeof(void*); p < ((char*)bp)+memSize; p++) {
+        a_assert(*p == B_FILL_CHAR);
+    }
+    bp = (bType *)p;
+    a_assert((bp->flags & ~B_MALLOCED) == B_INTEGRITY ||
+        bp->flags == B_FILL_WORD);
 }
 
 /******************************************************************************/
 /*
- *	verifyBallocSpace reads through the entire balloc memory space and
- *	verifies that all allocated blocks are uncorrupted and that, with the
- *	exception of free list next pointers, all other unallocated space is
- *	filled with B_FILL_CHAR.
+ *  verifyBallocSpace reads through the entire balloc memory space and
+ *  verifies that all allocated blocks are uncorrupted and that, with the
+ *  exception of free list next pointers, all other unallocated space is
+ *  filled with B_FILL_CHAR.
  */
 
 void verifyBallocSpace()
 {
-	int		q;
-	char	*p;
-	bType	*bp;
-
-/*
- *	First verify all the free blocks.
- */
-	for (q = 0; q < B_MAX_CLASS; q++) {	
-		for (bp = bQhead[q]; bp != NULL; bp = bp->u.next) {
-			verifyFreeBlock(bp, q);
-		}
-	}
-
-/*
- *	Now verify other space
- */
-	p = bFreeBuf;
-	while (p < (bFreeBuf + bFreeSize)) {
-		bp = (bType *)p;
-		if (bp->u.size > 0xFFFFF) {
-			p += sizeof(bp->u);
-			while (p < (bFreeBuf + bFreeSize) && *p == B_FILL_CHAR) {
-				p++;
-			}
-		} else {
-			a_assert(((bp->flags & ~B_MALLOCED) == B_INTEGRITY) ||
-				bp->flags == B_FILL_WORD);
-			p += (sizeof(bType) + bp->u.size);
-			while (p < (bFreeBuf + bFreeSize) && *p == B_FILL_CHAR) {
-				p++;
-			}
-		}
-	}
+    int     q;
+    char    *p;
+    bType   *bp;
+
+/*
+ *  First verify all the free blocks.
+ */
+    for (q = 0; q < B_MAX_CLASS; q++) { 
+        for (bp = bQhead[q]; bp != NULL; bp = bp->u.next) {
+            verifyFreeBlock(bp, q);
+        }
+    }
+
+/*
+ *  Now verify other space
+ */
+    p = bFreeBuf;
+    while (p < (bFreeBuf + bFreeSize)) {
+        bp = (bType *)p;
+        if (bp->u.size > 0xFFFFF) {
+            p += sizeof(bp->u);
+            while (p < (bFreeBuf + bFreeSize) && *p == B_FILL_CHAR) {
+                p++;
+            }
+        } else {
+            a_assert(((bp->flags & ~B_MALLOCED) == B_INTEGRITY) ||
+                bp->flags == B_FILL_WORD);
+            p += (sizeof(bType) + bp->u.size);
+            while (p < (bFreeBuf + bFreeSize) && *p == B_FILL_CHAR) {
+                p++;
+            }
+        }
+    }
 }
 #endif /* B_VERIFY_CAUSES_SEVERE_OVERHEAD */
 
@@ -916,7 +916,7 @@ void verifyBallocSpace()
 #else /* NO_BALLOC */
 int bopen(void *buf, int bufsize, int flags)
 {
-	return 0;
+    return 0;
 }
 
 /******************************************************************************/
@@ -936,13 +936,13 @@ void bstats(int handle, void (*writefn)(int handle, char_t *fmt, ...))
 char_t *bstrdupNoBalloc(char_t *s)
 {
 #ifdef UNICODE
-	if (s) {
-		return wcsdup(s);
-	} else {
-		return wcsdup(T(""));
-	}
+    if (s) {
+        return wcsdup(s);
+    } else {
+        return wcsdup(T(""));
+    }
 #else
-	return bstrdupANoBalloc(s);
+    return bstrdupANoBalloc(s);
 #endif
 }
 
@@ -950,14 +950,14 @@ char_t *bstrdupNoBalloc(char_t *s)
 
 char *bstrdupANoBalloc(char *s)
 {
-	char*	buf;
-
-	if (s == NULL) {
-		s = "";
-	}
-	buf = malloc(strlen(s)+1);
-	strcpy(buf, s);
-	return buf;
+    char*   buf;
+
+    if (s == NULL) {
+        s = "";
+    }
+    buf = malloc(strlen(s)+1);
+    strcpy(buf, s);
+    return buf;
 }
 
 #endif /* NO_BALLOC */
diff --git a/cgi.c b/cgi.c
index 400850b0..4822a39f 100644
--- a/cgi.c
+++ b/cgi.c
@@ -1,128 +1,128 @@
 /*
     cgi.c -- CGI processing (for the GoAhead Web server
   
-  	This module implements the /cgi-bin handler. CGI processing differs from
-  	goforms processing in that each CGI request is executed as a separate 
-  	process, rather than within the webserver process. For each CGI request the
-  	environment of the new process must be set to include all the CGI variables
-  	and its standard input and output must be directed to the socket.  This
-  	is done using temporary files.
+    This module implements the /cgi-bin handler. CGI processing differs from
+    goforms processing in that each CGI request is executed as a separate 
+    process, rather than within the webserver process. For each CGI request the
+    environment of the new process must be set to include all the CGI variables
+    and its standard input and output must be directed to the socket.  This
+    is done using temporary files.
 
     Copyright (c) All Rights Reserved. See details at the end of the file.
  */
 
 /*********************************** Includes *********************************/
 
-#include	"wsIntrn.h"
-#include	"uemf.h"
+#include    "wsIntrn.h"
+#include    "uemf.h"
 
 
 /*********************************** Defines **********************************/
 
-typedef struct {				/* Struct for CGI tasks which have completed */
-	webs_t	wp;					/* pointer to session websRec */
-	char_t	*stdIn;				/* file desc. for task's temp input fd */
-	char_t	*stdOut;			/* file desc. for task's temp output fd */
-	char_t	*cgiPath;			/* path to executable process file */
-	char_t	**argp;				/* pointer to buf containing argv tokens */
-	char_t	**envp;				/* pointer to array of environment strings */
-	int		handle;				/* process handle of the task */
-	long	fplacemark;			/* seek location for CGI output file */
+typedef struct {                /* Struct for CGI tasks which have completed */
+    webs_t  wp;                 /* pointer to session websRec */
+    char_t  *stdIn;             /* file desc. for task's temp input fd */
+    char_t  *stdOut;            /* file desc. for task's temp output fd */
+    char_t  *cgiPath;           /* path to executable process file */
+    char_t  **argp;             /* pointer to buf containing argv tokens */
+    char_t  **envp;             /* pointer to array of environment strings */
+    int     handle;             /* process handle of the task */
+    long    fplacemark;         /* seek location for CGI output file */
 } cgiRec;
-static cgiRec	**cgiList;		/* hAlloc chain list of wp's to be closed */
-static int		cgiMax;			/* Size of hAlloc list */
+static cgiRec   **cgiList;      /* hAlloc chain list of wp's to be closed */
+static int      cgiMax;         /* Size of hAlloc list */
 
 /************************************* Code ***********************************/
 /*
-  	Process a form request. Returns 1 always to indicate it handled the URL
+    Process a form request. Returns 1 always to indicate it handled the URL
  */
 int websCgiHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t *url, char_t *path, char_t* query)
 {
-	cgiRec		*cgip;
-	sym_t		*s;
-	char_t		cgiBuf[FNAMESIZE], *stdIn, *stdOut, cwd[FNAMESIZE];
-	char_t		*cp, *cgiName, *cgiPath, **argp, **envp, **ep;
-	int			n, envpsize, argpsize, pHandle, cid, rc;
+    cgiRec      *cgip;
+    sym_t       *s;
+    char_t      cgiBuf[FNAMESIZE], *stdIn, *stdOut, cwd[FNAMESIZE];
+    char_t      *cp, *cgiName, *cgiPath, **argp, **envp, **ep;
+    int         n, envpsize, argpsize, pHandle, cid, rc;
 
-	a_assert(websValid(wp));
-	a_assert(url && *url);
-	a_assert(path && *path == '/');
+    a_assert(websValid(wp));
+    a_assert(url && *url);
+    a_assert(path && *path == '/');
 
     /*
         If the whitelist check fails, try to rebuild the list right away and try one more time. Whitelist just checks
         that the file exists under the current www root.  We will check if it is executable below.
      */
 #ifdef WEBS_WHITELIST_SUPPORT
-	if ((rc = websWhitelistCheck(wp->url)) < 0 || !(rc & WHITELIST_CGI)) {
-		websBuildWhitelist();
-		if ((rc = websWhitelistCheck(wp->url)) < 0 || !(rc & WHITELIST_CGI)) {
-			websError(wp, 500, T("Invalid CGI URL"));
-			return 1;
-		}
-	}
-	if (!(wp->flags & WEBS_SECURE) && (rc & WHITELIST_SSL)) {
-		websError(wp, 500, T("HTTPS Access Required"));
-		return 1;
-	}
+    if ((rc = websWhitelistCheck(wp->url)) < 0 || !(rc & WHITELIST_CGI)) {
+        websBuildWhitelist();
+        if ((rc = websWhitelistCheck(wp->url)) < 0 || !(rc & WHITELIST_CGI)) {
+            websError(wp, 500, T("Invalid CGI URL"));
+            return 1;
+        }
+    }
+    if (!(wp->flags & WEBS_SECURE) && (rc & WHITELIST_SSL)) {
+        websError(wp, 500, T("HTTPS Access Required"));
+        return 1;
+    }
 #endif /* WEBS_WHITELIST_SUPPORT */
 
-	websStats.cgiHits++;
+    websStats.cgiHits++;
 
     /*
-      	Extract the form name and then build the full path name.  The form name will follow the first '/' in path.
+        Extract the form name and then build the full path name.  The form name will follow the first '/' in path.
      */
-	gstrncpy(cgiBuf, path, TSZ(cgiBuf));
-	if ((cgiName = gstrchr(&cgiBuf[1], '/')) == NULL) {
-		websError(wp, 200, T("Missing CGI name"));
-		return 1;
-	}
-	cgiName++;
-	if ((cp = gstrchr(cgiName, '/')) != NULL) {
-		*cp = '\0';
-	}
-	fmtAlloc(&cgiPath, FNAMESIZE, T("%s/%s/%s"), websGetDefaultDir(),
-		CGI_BIN, cgiName);
+    gstrncpy(cgiBuf, path, TSZ(cgiBuf));
+    if ((cgiName = gstrchr(&cgiBuf[1], '/')) == NULL) {
+        websError(wp, 200, T("Missing CGI name"));
+        return 1;
+    }
+    cgiName++;
+    if ((cp = gstrchr(cgiName, '/')) != NULL) {
+        *cp = '\0';
+    }
+    fmtAlloc(&cgiPath, FNAMESIZE, T("%s/%s/%s"), websGetDefaultDir(),
+        CGI_BIN, cgiName);
 #ifndef VXWORKS
 
     /*
         See if the file exists and is executable.  If not error out.  Don't do this step for VxWorks, since the module
         may already be part of the OS image, rather than in the file system.
     */
-	{
-		gstat_t		sbuf;
-		if (gstat(cgiPath, &sbuf) != 0 || (sbuf.st_mode & S_IFREG) == 0) {
-			websError(wp, 404, T("CGI process file does not exist"));
-			bfree(B_L, cgiPath);
-			return 1;
-		}
+    {
+        gstat_t     sbuf;
+        if (gstat(cgiPath, &sbuf) != 0 || (sbuf.st_mode & S_IFREG) == 0) {
+            websError(wp, 404, T("CGI process file does not exist"));
+            bfree(B_L, cgiPath);
+            return 1;
+        }
 #if (defined (WIN) || defined (CE))
-		if (gstrstr(cgiPath, T(".exe")) == NULL &&
-			gstrstr(cgiPath, T(".bat")) == NULL) {
+        if (gstrstr(cgiPath, T(".exe")) == NULL &&
+            gstrstr(cgiPath, T(".bat")) == NULL) {
 #elif (defined (NW))
-			if (gstrstr(cgiPath, T(".nlm")) == NULL) {
+            if (gstrstr(cgiPath, T(".nlm")) == NULL) {
 #else
-		if (gaccess(cgiPath, X_OK) != 0) {
+        if (gaccess(cgiPath, X_OK) != 0) {
 #endif /* WIN || CE */
-			websError(wp, 200, T("CGI process file is not executable"));
-			bfree(B_L, cgiPath);
-			return 1;
-		}
-	}
+            websError(wp, 200, T("CGI process file is not executable"));
+            bfree(B_L, cgiPath);
+            return 1;
+        }
+    }
 #endif /* ! VXWORKS */
 
          
     /*
         Get the CWD for resetting after launching the child process CGI
      */
-	ggetcwd(cwd, FNAMESIZE);
+    ggetcwd(cwd, FNAMESIZE);
     /*
         Retrieve the directory of the child process CGI
      */
-	if ((cp = gstrrchr(cgiPath, '/')) != NULL) {
-		*cp = '\0';
-		gchdir(cgiPath);
-		*cp = '/';
-	}
+    if ((cp = gstrrchr(cgiPath, '/')) != NULL) {
+        *cp = '\0';
+        gchdir(cgiPath);
+        *cp = '/';
+    }
     /*
          Build command line arguments.  Only used if there is no non-encoded = character.  This is indicative of a ISINDEX
          query.  POST separators are & and others are +.  argp will point to a balloc'd array of pointers.  Each pointer
@@ -130,23 +130,23 @@ int websCgiHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t
          expect command line arguments to be passed.  Since we don't know ahead of time how many individual items there are
          in the query string, the for loop includes logic to grow the array size via brealloc.
      */
-	argpsize = 10;
-	argp = balloc(B_L, argpsize * sizeof(char_t *));
-	*argp = cgiPath;
-	n = 1;
-	if (gstrchr(query, '=') == NULL) {
-		websDecodeUrl(query, query, gstrlen(query));
-		for (cp = gstrtok(query, T(" ")); cp != NULL; ) {
-			*(argp+n) = cp;
-			n++;
-			if (n >= argpsize) {
-				argpsize *= 2;
-				argp = brealloc(B_L, argp, argpsize * sizeof(char_t *));
-			}
-			cp = gstrtok(NULL, T(" "));
-		}
-	}
-	*(argp+n) = NULL;
+    argpsize = 10;
+    argp = balloc(B_L, argpsize * sizeof(char_t *));
+    *argp = cgiPath;
+    n = 1;
+    if (gstrchr(query, '=') == NULL) {
+        websDecodeUrl(query, query, gstrlen(query));
+        for (cp = gstrtok(query, T(" ")); cp != NULL; ) {
+            *(argp+n) = cp;
+            n++;
+            if (n >= argpsize) {
+                argpsize *= 2;
+                argp = brealloc(B_L, argp, argpsize * sizeof(char_t *));
+            }
+            cp = gstrtok(NULL, T(" "));
+        }
+    }
+    *(argp+n) = NULL;
 
     /*
         Add all CGI variables to the environment strings to be passed to the spawned CGI process.  This includes a few
@@ -155,73 +155,73 @@ int websCgiHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t
         in the form keyword=value.  Since we don't know ahead of time how many environment strings there will be the for
         loop includes logic to grow the array size via brealloc.
      */
-	envpsize = WEBS_SYM_INIT;
-	envp = balloc(B_L, envpsize * sizeof(char_t *));
-	n = 0;
-	fmtAlloc(envp+n, FNAMESIZE, T("%s=%s"),T("PATH_TRANSLATED"), cgiPath);
-	n++;
-	fmtAlloc(envp+n, FNAMESIZE, T("%s=%s/%s"),T("SCRIPT_NAME"), CGI_BIN, cgiName);
-	n++;
-	fmtAlloc(envp+n, FNAMESIZE, T("%s=%s"),T("REMOTE_USER"), wp->userName);
-	n++;
-	fmtAlloc(envp+n, FNAMESIZE, T("%s=%s"),T("AUTH_TYPE"), wp->authType);
-	n++;
-	for (s = symFirst(wp->cgiVars); s != NULL; s = symNext(wp->cgiVars)) {
-		if (s->content.valid && s->content.type == string &&
-			gstrcmp(s->name.value.string, T("REMOTE_HOST")) != 0 &&
-			gstrcmp(s->name.value.string, T("HTTP_AUTHORIZATION")) != 0) {
-			fmtAlloc(envp+n, FNAMESIZE, T("%s=%s"), s->name.value.string, s->content.value.string);
-			n++;
-			if (n >= envpsize) {
-				envpsize *= 2;
-				envp = brealloc(B_L, envp, envpsize * sizeof(char_t *));
-			}
-		}
-	}
-	*(envp+n) = NULL;
+    envpsize = WEBS_SYM_INIT;
+    envp = balloc(B_L, envpsize * sizeof(char_t *));
+    n = 0;
+    fmtAlloc(envp+n, FNAMESIZE, T("%s=%s"),T("PATH_TRANSLATED"), cgiPath);
+    n++;
+    fmtAlloc(envp+n, FNAMESIZE, T("%s=%s/%s"),T("SCRIPT_NAME"), CGI_BIN, cgiName);
+    n++;
+    fmtAlloc(envp+n, FNAMESIZE, T("%s=%s"),T("REMOTE_USER"), wp->userName);
+    n++;
+    fmtAlloc(envp+n, FNAMESIZE, T("%s=%s"),T("AUTH_TYPE"), wp->authType);
+    n++;
+    for (s = symFirst(wp->cgiVars); s != NULL; s = symNext(wp->cgiVars)) {
+        if (s->content.valid && s->content.type == string &&
+            gstrcmp(s->name.value.string, T("REMOTE_HOST")) != 0 &&
+            gstrcmp(s->name.value.string, T("HTTP_AUTHORIZATION")) != 0) {
+            fmtAlloc(envp+n, FNAMESIZE, T("%s=%s"), s->name.value.string, s->content.value.string);
+            n++;
+            if (n >= envpsize) {
+                envpsize *= 2;
+                envp = brealloc(B_L, envp, envpsize * sizeof(char_t *));
+            }
+        }
+    }
+    *(envp+n) = NULL;
     /*
         Create temporary file name(s) for the child's stdin and stdout. For POST data the stdin temp file (and name)
         should already exist.  
      */
-	if (wp->cgiStdin == NULL) {
-		wp->cgiStdin = websGetCgiCommName();
-	} 
-	stdIn = wp->cgiStdin;
-	stdOut = websGetCgiCommName();
+    if (wp->cgiStdin == NULL) {
+        wp->cgiStdin = websGetCgiCommName();
+    } 
+    stdIn = wp->cgiStdin;
+    stdOut = websGetCgiCommName();
     /*
         Now launch the process.  If not successful, do the cleanup of resources.  If successful, the cleanup will be
         done after the process completes.  
      */
-	if ((pHandle = websLaunchCgiProc(cgiPath, argp, envp, stdIn, stdOut)) == -1) {
-		websError(wp, 200, T("failed to spawn CGI task"));
-		for (ep = envp; *ep != NULL; ep++) {
-			bfreeSafe(B_L, *ep);
-		}
-		bfreeSafe(B_L, cgiPath);
-		bfreeSafe(B_L, argp);
-		bfreeSafe(B_L, envp);
-		bfreeSafe(B_L, stdOut);
-	} else {
+    if ((pHandle = websLaunchCgiProc(cgiPath, argp, envp, stdIn, stdOut)) == -1) {
+        websError(wp, 200, T("failed to spawn CGI task"));
+        for (ep = envp; *ep != NULL; ep++) {
+            bfreeSafe(B_L, *ep);
+        }
+        bfreeSafe(B_L, cgiPath);
+        bfreeSafe(B_L, argp);
+        bfreeSafe(B_L, envp);
+        bfreeSafe(B_L, stdOut);
+    } else {
         /*
             If the spawn was successful, put this wp on a queue to be checked for completion.
          */
-		cid = hAllocEntry((void***) &cgiList, &cgiMax, sizeof(cgiRec));
-		cgip = cgiList[cid];
-		cgip->handle = pHandle;
-		cgip->stdIn = stdIn;
-		cgip->stdOut = stdOut;
-		cgip->cgiPath = cgiPath;
-		cgip->argp = argp;
-		cgip->envp = envp;
-		cgip->wp = wp;
-		cgip->fplacemark = 0;
-		websTimeoutCancel(wp);
-	}
+        cid = hAllocEntry((void***) &cgiList, &cgiMax, sizeof(cgiRec));
+        cgip = cgiList[cid];
+        cgip->handle = pHandle;
+        cgip->stdIn = stdIn;
+        cgip->stdOut = stdOut;
+        cgip->cgiPath = cgiPath;
+        cgip->argp = argp;
+        cgip->envp = envp;
+        cgip->wp = wp;
+        cgip->fplacemark = 0;
+        websTimeoutCancel(wp);
+    }
     /*
         Restore the current working directory after spawning child CGI
      */
- 	gchdir(cwd);
-	return 1;
+    gchdir(cwd);
+    return 1;
 }
 
 
@@ -230,41 +230,41 @@ int websCgiHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t
  */
 void websCgiGatherOutput (cgiRec *cgip)
 {
-	gstat_t	sbuf;
-	char_t	cgiBuf[FNAMESIZE];
+    gstat_t sbuf;
+    char_t  cgiBuf[FNAMESIZE];
 #if defined(WIN32)
-	errno_t	error;
+    errno_t error;
 #endif
 
-	if ((gstat(cgip->stdOut, &sbuf) == 0) && 
-		(sbuf.st_size > cgip->fplacemark)) {
-		int fdout;
+    if ((gstat(cgip->stdOut, &sbuf) == 0) && 
+        (sbuf.st_size > cgip->fplacemark)) {
+        int fdout;
 #if !defined(WIN32)
-		fdout = gopen(cgip->stdOut, O_RDONLY | O_BINARY, 0444 );
+        fdout = gopen(cgip->stdOut, O_RDONLY | O_BINARY, 0444 );
 #else
-		error = _sopen_s(&fdout, cgip->stdOut, O_RDONLY | O_BINARY, _SH_DENYNO, 0444);
+        error = _sopen_s(&fdout, cgip->stdOut, O_RDONLY | O_BINARY, _SH_DENYNO, 0444);
 #endif
 
-		/*
+        /*
              Check to see if any data is available in the output file and send its contents to the socket.
          */
-		if (fdout >= 0) {
-			webs_t	wp = cgip->wp;
-			int		nRead;
+        if (fdout >= 0) {
+            webs_t  wp = cgip->wp;
+            int     nRead;
             /*
                 Write the HTTP header on our first pass
              */
-			if (cgip->fplacemark == 0) {
-				websWrite(wp, T("HTTP/1.0 200 OK\r\n"));
-			}
-			glseek(fdout, cgip->fplacemark, SEEK_SET);
-			while ((nRead = gread(fdout, cgiBuf, FNAMESIZE)) > 0) {
-				websWriteBlock(wp, cgiBuf, nRead);
-				cgip->fplacemark += nRead;
-			}
-			gclose(fdout);
-		}
-	}
+            if (cgip->fplacemark == 0) {
+                websWrite(wp, T("HTTP/1.0 200 OK\r\n"));
+            }
+            glseek(fdout, cgip->fplacemark, SEEK_SET);
+            while ((nRead = gread(fdout, cgiBuf, FNAMESIZE)) > 0) {
+                websWriteBlock(wp, cgiBuf, nRead);
+                cgip->fplacemark += nRead;
+            }
+            gclose(fdout);
+        }
+    }
 }
 
 
@@ -273,66 +273,66 @@ void websCgiGatherOutput (cgiRec *cgip)
  */
 void websCgiCleanup()
 {
-	cgiRec	*cgip;
-	webs_t	wp;
-	char_t	**ep;
-	int		cid, nTries;
-	for (cid = 0; cid < cgiMax; cid++) {
-		if ((cgip = cgiList[cid]) != NULL) {
-			wp = cgip->wp;
-			websCgiGatherOutput (cgip);
-			if (websCheckCgiProc(cgip->handle) == 0) {
+    cgiRec  *cgip;
+    webs_t  wp;
+    char_t  **ep;
+    int     cid, nTries;
+    for (cid = 0; cid < cgiMax; cid++) {
+        if ((cgip = cgiList[cid]) != NULL) {
+            wp = cgip->wp;
+            websCgiGatherOutput (cgip);
+            if (websCheckCgiProc(cgip->handle) == 0) {
                 /*
                     We get here if the CGI process has terminated.  Clean up.
                  */
-				nTries = 0;
-                /*				
+                nTries = 0;
+                /*              
                      Make sure we didn't miss something during a task switch.  Maximum wait is 100 times 10 msecs (1 second).
                  */
-				while ((cgip->fplacemark == 0) && (nTries < 100)) {
-					websCgiGatherOutput(cgip);
-                    /*					
+                while ((cgip->fplacemark == 0) && (nTries < 100)) {
+                    websCgiGatherOutput(cgip);
+                    /*                  
                          There are some cases when we detect app exit before the file is ready. 
                      */
-					if (cgip->fplacemark == 0) {
+                    if (cgip->fplacemark == 0) {
 #ifdef WIN
-						Sleep(10);
+                        Sleep(10);
 #endif /* WIN*/
-					}
-					nTries++;
-				}
-				if (cgip->fplacemark == 0) {
-					websError(wp, 200, T("CGI generated no output"));
-				} else {
-					websDone(wp, 200);
-				}
+                    }
+                    nTries++;
+                }
+                if (cgip->fplacemark == 0) {
+                    websError(wp, 200, T("CGI generated no output"));
+                } else {
+                    websDone(wp, 200);
+                }
                 /*
                     Remove the temporary re-direction files
                  */
-				gunlink(cgip->stdIn);
-				gunlink(cgip->stdOut);
+                gunlink(cgip->stdIn);
+                gunlink(cgip->stdOut);
                 /*
                      Free all the memory buffers pointed to by cgip. The stdin file name (wp->cgiStdin) gets freed as
                     part of websFree().
                  */
-				cgiMax = hFree((void***) &cgiList, cid);
-				for (ep = cgip->envp; ep != NULL && *ep != NULL; ep++) {
-					bfreeSafe(B_L, *ep);
-				}
-				bfreeSafe(B_L, cgip->cgiPath);
-				bfreeSafe(B_L, cgip->argp);
-				bfreeSafe(B_L, cgip->envp);
-				bfreeSafe(B_L, cgip->stdOut);
-				bfreeSafe(B_L, cgip);
-			}
-		}
-	}
+                cgiMax = hFree((void***) &cgiList, cid);
+                for (ep = cgip->envp; ep != NULL && *ep != NULL; ep++) {
+                    bfreeSafe(B_L, *ep);
+                }
+                bfreeSafe(B_L, cgip->cgiPath);
+                bfreeSafe(B_L, cgip->argp);
+                bfreeSafe(B_L, cgip->envp);
+                bfreeSafe(B_L, cgip->stdOut);
+                bfreeSafe(B_L, cgip);
+            }
+        }
+    }
 }
 
 
-/*	
-	PLATFORM IMPLEMENTATIONS FOR CGI HELPERS
-		websGetCgiCommName, websLaunchCgiProc, websCheckCgiProc
+/*  
+    PLATFORM IMPLEMENTATIONS FOR CGI HELPERS
+        websGetCgiCommName, websLaunchCgiProc, websCheckCgiProc
 */
 
 #ifdef CE
@@ -348,14 +348,14 @@ char_t *websGetCgiCommName()
      */
     //  MOB
 #if 0  
-	char_t  *pname1, *pname2;
+    char_t  *pname1, *pname2;
 
-	pname1 = gtmpnam(NULL, T("cgi"));
-	pname2 = bstrdup(B_L, pname1);
-	free(pname1);
-	return pname2;
+    pname1 = gtmpnam(NULL, T("cgi"));
+    pname2 = bstrdup(B_L, pname1);
+    free(pname1);
+    return pname2;
 #endif
-	return NULL;
+    return NULL;
 }
 
 
@@ -365,50 +365,50 @@ char_t *websGetCgiCommName()
  */
 int websLaunchCgiProc(char_t *cgiPath, char_t **argp, char_t **envp, char_t *stdIn, char_t *stdOut)
 {
-	PROCESS_INFORMATION procinfo;       /*  Information about created proc   */
-	DWORD               dwCreateFlags;
-	char                *fulldir;
-	BOOL                bReturn;
-	int                 i, nLen;
+    PROCESS_INFORMATION procinfo;       /*  Information about created proc   */
+    DWORD               dwCreateFlags;
+    char                *fulldir;
+    BOOL                bReturn;
+    int                 i, nLen;
 
     /*
         Replace directory delimiters with Windows-friendly delimiters
      */
-	nLen = gstrlen(cgiPath);
-	for (i = 0; i < nLen; i++) {
-		if (cgiPath[i] == '/') {
-			cgiPath[i] = '\\';
-		}
-	}
+    nLen = gstrlen(cgiPath);
+    for (i = 0; i < nLen; i++) {
+        if (cgiPath[i] == '/') {
+            cgiPath[i] = '\\';
+        }
+    }
 
-	fulldir = NULL;
-	dwCreateFlags = CREATE_NEW_CONSOLE;
+    fulldir = NULL;
+    dwCreateFlags = CREATE_NEW_CONSOLE;
 
     /*
          CreateProcess returns errors sometimes, even when the process was started correctly.  The cause is not evident.
          For now: we detect an error by checking the value of procinfo.hProcess after the call.
      */
-	procinfo.hThread = NULL;
-	bReturn = CreateProcess(
-		cgiPath,            /*  Name of executable module        */
-		NULL,               /*  Command line string              */
-		NULL,               /*  Process security attributes      */
-		NULL,               /*  Thread security attributes       */
-		0,                  /*  Handle inheritance flag          */
-		dwCreateFlags,      /*  Creation flags                   */
-		NULL,               /*  New environment block            */
-		NULL,               /*  Current directory name           */
-		NULL,               /*  STARTUPINFO                      */
-		&procinfo);         /*  PROCESS_INFORMATION              */
-
-	if (bReturn == 0) {
-		DWORD dw;
-		dw = GetLastError();
-		return -1;
-	} else {
-		CloseHandle(procinfo.hThread);
-	}
-	return (int) procinfo.dwProcessId;
+    procinfo.hThread = NULL;
+    bReturn = CreateProcess(
+        cgiPath,            /*  Name of executable module        */
+        NULL,               /*  Command line string              */
+        NULL,               /*  Process security attributes      */
+        NULL,               /*  Thread security attributes       */
+        0,                  /*  Handle inheritance flag          */
+        dwCreateFlags,      /*  Creation flags                   */
+        NULL,               /*  New environment block            */
+        NULL,               /*  Current directory name           */
+        NULL,               /*  STARTUPINFO                      */
+        &procinfo);         /*  PROCESS_INFORMATION              */
+
+    if (bReturn == 0) {
+        DWORD dw;
+        dw = GetLastError();
+        return -1;
+    } else {
+        CloseHandle(procinfo.hThread);
+    }
+    return (int) procinfo.dwProcessId;
 }
 
 
@@ -417,20 +417,20 @@ int websLaunchCgiProc(char_t *cgiPath, char_t **argp, char_t **envp, char_t *std
  */
 int websCheckCgiProc(int handle)
 {
-	int     nReturn;
-	DWORD   exitCode;
+    int     nReturn;
+    DWORD   exitCode;
 
-	nReturn = GetExitCodeProcess((HANDLE)handle, &exitCode);
+    nReturn = GetExitCodeProcess((HANDLE)handle, &exitCode);
 
     /*
         We must close process handle to free up the window resource, but only when we're done with it.
      */
-	if ((nReturn == 0) || (exitCode != STILL_ACTIVE)) {
-		CloseHandle((HANDLE)handle);
-		return 0;
-	}
+    if ((nReturn == 0) || (exitCode != STILL_ACTIVE)) {
+        CloseHandle((HANDLE)handle);
+        return 0;
+    }
 
-	return 1;
+    return 1;
 }
 #endif /* CE */
 
@@ -443,12 +443,12 @@ int websCheckCgiProc(int handle)
  */
 char_t *websGetCgiCommName()
 {
-	char_t  *pname1, *pname2;
+    char_t  *pname1, *pname2;
 
-	pname1 = tempnam(NULL, T("cgi"));
-	pname2 = bstrdup(B_L, pname1);
-	free(pname1);
-	return pname2;
+    pname1 = tempnam(NULL, T("cgi"));
+    pname2 = bstrdup(B_L, pname1);
+    free(pname1);
+    return pname2;
 }
 
 
@@ -457,43 +457,43 @@ char_t *websGetCgiCommName()
  */
 int websLaunchCgiProc(char_t *cgiPath, char_t **argp, char_t **envp, char_t *stdIn, char_t *stdOut)
 {
-	int pid, fdin, fdout, hstdin, hstdout, rc;
-
-	fdin = fdout = hstdin = hstdout = rc = -1;
-	if ((fdin = open(stdIn, O_RDWR | O_CREAT, 0666)) < 0 ||
-			(fdout = open(stdOut, O_RDWR | O_CREAT, 0666)) < 0 ||
-			(hstdin = dup(0)) == -1 || (hstdout = dup(1)) == -1 ||
-			dup2(fdin, 0) == -1 || dup2(fdout, 1) == -1) {
-		goto DONE;
-	}
-	rc = pid = fork();
-	if (pid == 0) {
+    int pid, fdin, fdout, hstdin, hstdout, rc;
+
+    fdin = fdout = hstdin = hstdout = rc = -1;
+    if ((fdin = open(stdIn, O_RDWR | O_CREAT, 0666)) < 0 ||
+            (fdout = open(stdOut, O_RDWR | O_CREAT, 0666)) < 0 ||
+            (hstdin = dup(0)) == -1 || (hstdout = dup(1)) == -1 ||
+            dup2(fdin, 0) == -1 || dup2(fdout, 1) == -1) {
+        goto DONE;
+    }
+    rc = pid = fork();
+    if (pid == 0) {
         /*
             if pid == 0, then we are in the child process
          */
-		if (execve(cgiPath, argp, envp) == -1) {
-			printf("content-type: text/html\n\n"
-				"Execution of cgi process failed\n");
-		}
-		exit (0);
-	}
+        if (execve(cgiPath, argp, envp) == -1) {
+            printf("content-type: text/html\n\n"
+                "Execution of cgi process failed\n");
+        }
+        exit (0);
+    }
 
 DONE:
-	if (hstdout >= 0) {
-		dup2(hstdout, 1);
-		close(hstdout);
-	}
-	if (hstdin >= 0) {
-		dup2(hstdin, 0);
-		close(hstdin);
-	}
-	if (fdout >= 0) {
-		close(fdout);
-	}
-	if (fdin >= 0) {
-		close(fdin);
-	}
-	return rc;
+    if (hstdout >= 0) {
+        dup2(hstdout, 1);
+        close(hstdout);
+    }
+    if (hstdin >= 0) {
+        dup2(hstdin, 0);
+        close(hstdin);
+    }
+    if (fdout >= 0) {
+        close(fdout);
+    }
+    if (fdin >= 0) {
+        close(fdin);
+    }
+    return rc;
 }
 
 
@@ -505,11 +505,11 @@ int websCheckCgiProc(int handle)
     /*
         Check to see if the CGI child process has terminated or not yet.
      */
-	if (waitpid(handle, NULL, WNOHANG) == handle) {
-		return 0;
-	} else {
-		return 1;
-	}
+    if (waitpid(handle, NULL, WNOHANG) == handle) {
+        return 0;
+    } else {
+        return 1;
+    }
 }
 
 #endif /* LINUX || LYNX || MACOSX || QNX4 */
@@ -522,10 +522,10 @@ int websCheckCgiProc(int handle)
  */
 char_t *websGetCgiCommName()
 {
-	char_t   *pname;
+    char_t   *pname;
 
-	pname = bstrdup(B_L, tmpnam( NULL ) );
-	return pname;
+    pname = bstrdup(B_L, tmpnam( NULL ) );
+    return pname;
 }
 
 
@@ -534,12 +534,12 @@ char_t *websGetCgiCommName()
  */
 int websLaunchCgiProc(char_t *cgiPath, char_t **argp, char_t **envp, char_t *stdIn, char_t *stdOut)
 {
-	int   pid, fdin, fdout, hstdin, hstdout, rc;
+    int   pid, fdin, fdout, hstdin, hstdout, rc;
 
-	fdin = fdout = -1;
-	if ((fdin = open(stdIn, O_RDWR | O_CREAT, 0666)) < 0 ||
-			(fdout = open(stdOut, O_RDWR | O_CREAT, 0666)) < 0 ) {
-		goto DONE;
+    fdin = fdout = -1;
+    if ((fdin = open(stdIn, O_RDWR | O_CREAT, 0666)) < 0 ||
+            (fdout = open(stdOut, O_RDWR | O_CREAT, 0666)) < 0 ) {
+        goto DONE;
     }
 
 /*  COMMENTED BLOCK ùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùù
@@ -552,19 +552,19 @@ int websLaunchCgiProc(char_t *cgiPath, char_t **argp, char_t **envp, char_t *std
  *     printf( "]\n" ) ;
  *  END COMMENTS ùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùù
  */
-	rc = spawnvp( P_NOWAIT, cgiPath, argp ) ;
-	if (rc != 0) {
-		exit (0);
-	}
+    rc = spawnvp( P_NOWAIT, cgiPath, argp ) ;
+    if (rc != 0) {
+        exit (0);
+    }
 
 DONE:
-	if (fdout >= 0) {
-		close(fdout);
-	}
-	if (fdin >= 0) {
-		close(fdin);
-	}
-	return rc;
+    if (fdout >= 0) {
+        close(fdout);
+    }
+    if (fdin >= 0) {
+        close(fdin);
+    }
+    return rc;
 }
 
 
@@ -576,11 +576,11 @@ int websCheckCgiProc(int handle)
     /*
         Check to see if the CGI child process has terminated or not yet.
      */
-	if( handle ) {
-		return 0;
-	} else {
-		return 1;
-	}
+    if( handle ) {
+        return 0;
+    } else {
+        return 1;
+    }
 }
 
 #endif /* NW */
@@ -596,8 +596,8 @@ char_t *websGetCgiCommName()
 {
     char_t  *tname, buf[FNAMESIZE];
 
-	fmtAlloc(&tname,FNAMESIZE, T("%s/%s"), ggetcwd(buf, FNAMESIZE), tmpnam(NULL));
-	return tname;
+    fmtAlloc(&tname,FNAMESIZE, T("%s/%s"), ggetcwd(buf, FNAMESIZE), tmpnam(NULL));
+    return tname;
 }
 
 /******************************************************************************/
@@ -632,78 +632,78 @@ char_t *websGetCgiCommName()
  */
 int websLaunchCgiProc(char_t *cgiPath, char_t **argp, char_t **envp, char_t *stdIn, char_t *stdOut)
 {
-	SYM_TYPE    ptype;
-	char_t      *p, *basename, *pEntry, *pname, *entryAddr, **pp;
-	int         priority, rc, fd;
+    SYM_TYPE    ptype;
+    char_t      *p, *basename, *pEntry, *pname, *entryAddr, **pp;
+    int         priority, rc, fd;
 
     /*
      *  Determine the basename, which is without path or the extension.
      */
-	if ((int)(p = gstrrchr(cgiPath, '/') + 1) == 1) {
-		p = cgiPath;
-	}
-	basename = bstrdup(B_L, p);
-	if ((p = gstrrchr(basename, '.')) != NULL) {
-		*p = '\0';
-	}
+    if ((int)(p = gstrrchr(cgiPath, '/') + 1) == 1) {
+        p = cgiPath;
+    }
+    basename = bstrdup(B_L, p);
+    if ((p = gstrrchr(basename, '.')) != NULL) {
+        *p = '\0';
+    }
 
     /*
         Unload the module, if it is already loaded.  Get the current task priority.
      */
-	unld(cgiPath, 0);
-	taskPriorityGet(taskIdSelf(), &priority);
-	rc = fd = -1;
+    unld(cgiPath, 0);
+    taskPriorityGet(taskIdSelf(), &priority);
+    rc = fd = -1;
 
     /*
          Set the entry point symbol name as described above.  Look for an already loaded entry point; if it exists, spawn
          the task accordingly.  
      */
-	for (pp = envp, pEntry = NULL; pp != NULL && *pp != NULL; pp++) {
-		if (gstrncmp(*pp, T("cgientry="), 9) == 0) {
-			pEntry = bstrdup(B_L, *pp + 9);
-			break;
-		}
-	}
-	if (pEntry == NULL) {
-		fmtAlloc(&pEntry, LF_PATHSIZE, T("%s_%s"), basename, T("cgientry"));
-	}
-	entryAddr = 0;
-	if (symFindByName(sysSymTbl, pEntry, &entryAddr, &ptype) == -1) {
-		fmtAlloc(&pname, VALUE_MAX_STRING, T("_%s"), pEntry);
-		symFindByName(sysSymTbl, pname, &entryAddr, &ptype);
-		bfreeSafe(B_L, pname);
-	}
-	if (entryAddr != 0) {
-		rc = taskSpawn(pEntry, priority, 0, 20000, (void *)vxWebsCgiEntry, (int)entryAddr, (int)argp, 
+    for (pp = envp, pEntry = NULL; pp != NULL && *pp != NULL; pp++) {
+        if (gstrncmp(*pp, T("cgientry="), 9) == 0) {
+            pEntry = bstrdup(B_L, *pp + 9);
+            break;
+        }
+    }
+    if (pEntry == NULL) {
+        fmtAlloc(&pEntry, LF_PATHSIZE, T("%s_%s"), basename, T("cgientry"));
+    }
+    entryAddr = 0;
+    if (symFindByName(sysSymTbl, pEntry, &entryAddr, &ptype) == -1) {
+        fmtAlloc(&pname, VALUE_MAX_STRING, T("_%s"), pEntry);
+        symFindByName(sysSymTbl, pname, &entryAddr, &ptype);
+        bfreeSafe(B_L, pname);
+    }
+    if (entryAddr != 0) {
+        rc = taskSpawn(pEntry, priority, 0, 20000, (void *)vxWebsCgiEntry, (int)entryAddr, (int)argp, 
                 (int)envp, (int)stdIn, (int)stdOut, 0, 0, 0, 0, 0);
-		goto DONE;
-	}
+        goto DONE;
+    }
 
     /*
         Try to load the module.
      */
-	if ((fd = gopen(cgiPath, O_RDONLY | O_BINARY, 0666)) < 0 ||
-		loadModule(fd, LOAD_GLOBAL_SYMBOLS) == NULL) {
-		goto DONE;
-	}
-	if ((symFindByName(sysSymTbl, pEntry, &entryAddr, &ptype)) == -1) {
-		fmtAlloc(&pname, VALUE_MAX_STRING, T("_%s"), pEntry);
-		symFindByName(sysSymTbl, pname, &entryAddr, &ptype);
-		bfreeSafe(B_L, pname);
-	}
-	if (entryAddr != 0) {
-		rc = taskSpawn(pEntry, priority, 0, 20000, (void *)vxWebsCgiEntry,
-			(int)entryAddr, (int)argp, (int)envp, (int)stdIn, (int)stdOut,
-			0, 0, 0, 0, 0);
-	}
+    if ((fd = gopen(cgiPath, O_RDONLY | O_BINARY, 0666)) < 0 ||
+        loadModule(fd, LOAD_GLOBAL_SYMBOLS) == NULL) {
+        goto DONE;
+    }
+    if ((symFindByName(sysSymTbl, pEntry, &entryAddr, &ptype)) == -1) {
+        fmtAlloc(&pname, VALUE_MAX_STRING, T("_%s"), pEntry);
+        symFindByName(sysSymTbl, pname, &entryAddr, &ptype);
+        bfreeSafe(B_L, pname);
+    }
+    if (entryAddr != 0) {
+        rc = taskSpawn(pEntry, priority, 0, 20000, (void *)vxWebsCgiEntry,
+            (int)entryAddr, (int)argp, (int)envp, (int)stdIn, (int)stdOut,
+            0, 0, 0, 0, 0);
+    }
 
 DONE:
-	if (fd != -1) {
-		gclose(fd);
-	}
-	bfree(B_L, basename);
-	bfree(B_L, pEntry);
-	return rc;
+    if (fd != -1) {
+        gclose(fd);
+    }
+    bfree(B_L, basename);
+    bfree(B_L, pEntry);
+    return rc;
 }
 
 
@@ -713,62 +713,62 @@ DONE:
     will call the user entry.
  */
 static void vxWebsCgiEntry(void *entryAddr(int argc, char_t **argv),
-				char_t **argp, char_t **envp, char_t *stdIn, char_t *stdOut)
+                char_t **argp, char_t **envp, char_t *stdIn, char_t *stdOut)
 {
-	char_t  **p;
-	int     argc, taskId, fdin, fdout;
+    char_t  **p;
+    int     argc, taskId, fdin, fdout;
 
     /*
         Open the stdIn and stdOut files and redirect stdin and stdout to them.
      */
-	taskId = taskIdSelf();
-	if ((fdout = gopen(stdOut, O_RDWR | O_CREAT, 0666)) < 0 &&
-			(fdout = creat(stdOut, O_RDWR)) < 0) {
-		exit(0);
-	}
-	ioTaskStdSet(taskId, 1, fdout);
-
-	if ((fdin = gopen(stdIn, O_RDONLY | O_CREAT, 0666)) < 0 &&
-			(fdin = creat(stdIn, O_RDWR)) < 0) {
-		printf("content-type: text/html\n\n"
-				"Can not create CGI stdin to %s\n", stdIn);
-		gclose(fdout);
-		exit (0);
-	}
-	ioTaskStdSet(taskId, 0, fdin);
+    taskId = taskIdSelf();
+    if ((fdout = gopen(stdOut, O_RDWR | O_CREAT, 0666)) < 0 &&
+            (fdout = creat(stdOut, O_RDWR)) < 0) {
+        exit(0);
+    }
+    ioTaskStdSet(taskId, 1, fdout);
+
+    if ((fdin = gopen(stdIn, O_RDONLY | O_CREAT, 0666)) < 0 &&
+            (fdin = creat(stdIn, O_RDWR)) < 0) {
+        printf("content-type: text/html\n\n"
+                "Can not create CGI stdin to %s\n", stdIn);
+        gclose(fdout);
+        exit (0);
+    }
+    ioTaskStdSet(taskId, 0, fdin);
 
     /*
         Count the number of entries in argv
      */
-	for (argc = 0, p = argp; p != NULL && *p != NULL; p++, argc++) {
-	}
+    for (argc = 0, p = argp; p != NULL && *p != NULL; p++, argc++) {
+    }
 
     /*
         Create a private envirnonment and copy the envp strings to it.
      */
-	if (envPrivateCreate(taskId, -1) != OK) {
-		printf("content-type: text/html\n\n"
-			"Can not create CGI environment space\n");
-		gclose(fdin);
-		gclose(fdout);
-		exit (0);
-	}
-	for (p = envp; p != NULL && *p != NULL; p++) {
-		putenv(*p);
-	}
+    if (envPrivateCreate(taskId, -1) != OK) {
+        printf("content-type: text/html\n\n"
+            "Can not create CGI environment space\n");
+        gclose(fdin);
+        gclose(fdout);
+        exit (0);
+    }
+    for (p = envp; p != NULL && *p != NULL; p++) {
+        putenv(*p);
+    }
 
     /*
         Call the user entry.
      */
-	(*entryAddr)(argc, argp);
+    (*entryAddr)(argc, argp);
 
     /*
         The user code should return here for cleanup.
      */
-	envPrivateDestroy(taskId);
-	gclose(fdin);
-	gclose(fdout);
-	exit(0);
+    envPrivateDestroy(taskId);
+    gclose(fdin);
+    gclose(fdout);
+    exit(0);
 }
 
 
@@ -777,17 +777,17 @@ static void vxWebsCgiEntry(void *entryAddr(int argc, char_t **argv),
  */
 int websCheckCgiProc(int handle)
 {
-	STATUS stat;
+    STATUS stat;
 
     /*
         Verify the existence of a VxWorks task
      */
-	stat = taskIdVerify(handle);
-	if (stat == OK) {
-		return 1;
-	} else {
-		return 0;
-	}
+    stat = taskIdVerify(handle);
+    if (stat == OK) {
+        return 1;
+    } else {
+        return 0;
+    }
 }
 #endif /* VXWORKS */
 
@@ -799,10 +799,10 @@ int websCheckCgiProc(int handle)
  */
 static unsigned char *tableToBlock(char **table)
 {
-    unsigned char	*pBlock;		/*  Allocated block */
-    char			*pEntry;		/*  Pointer into block      */
-    size_t			sizeBlock;		/*  Size of table           */
-    int				index;			/*  Index into string table */
+    unsigned char   *pBlock;        /*  Allocated block */
+    char            *pEntry;        /*  Pointer into block      */
+    size_t          sizeBlock;      /*  Size of table           */
+    int             index;          /*  Index into string table */
 
     a_assert(table);
 
@@ -812,27 +812,27 @@ static unsigned char *tableToBlock(char **table)
     sizeBlock = 1;                    
     for (index = 0; table[index]; index++) {
         sizeBlock += strlen(table[index]) + 1;
-	}
+    }
 
     /*
         Allocate the data block and fill it with the strings                   
      */
     pBlock = balloc(B_L, sizeBlock);
 
-	if (pBlock != NULL) {
-		pEntry = (char *) pBlock;
+    if (pBlock != NULL) {
+        pEntry = (char *) pBlock;
 
         for (index = 0; table[index]; index++) {
-			strcpy(pEntry, table[index]);
-			pEntry += strlen(pEntry) + 1;
-		}
-        /*		
+            strcpy(pEntry, table[index]);
+            pEntry += strlen(pEntry) + 1;
+        }
+        /*      
             Terminate the data block with an extra null string                
          */
-		*pEntry = '\0';              
-	}
+        *pEntry = '\0';              
+    }
 
-	return pBlock;
+    return pBlock;
 }
 
 
@@ -842,12 +842,12 @@ static unsigned char *tableToBlock(char **table)
  */
 char_t *websGetCgiCommName()
 {
-	char_t  *pname1, *pname2;
+    char_t  *pname1, *pname2;
 
-	pname1 = tempnam(NULL, T("cgi"));
-	pname2 = bstrdup(B_L, pname1);
-	free(pname1);
-	return pname2;
+    pname1 = tempnam(NULL, T("cgi"));
+    pname2 = bstrdup(B_L, pname1);
+    free(pname1);
+    return pname2;
 }
 
 
@@ -857,65 +857,65 @@ char_t *websGetCgiCommName()
  */
 int websLaunchCgiProc(char_t *cgiPath, char_t **argp, char_t **envp, char_t *stdIn, char_t *stdOut)
 {
-	STARTUPINFO         newinfo;
-	SECURITY_ATTRIBUTES security;
-	PROCESS_INFORMATION procinfo;       /*  Information about created proc   */
-	DWORD               dwCreateFlags;
-	char_t              *cmdLine;
-	char_t              **pArgs;
-	BOOL                bReturn;
-	int                 i, nLen;
-	unsigned char       *pEnvData;
+    STARTUPINFO         newinfo;
+    SECURITY_ATTRIBUTES security;
+    PROCESS_INFORMATION procinfo;       /*  Information about created proc   */
+    DWORD               dwCreateFlags;
+    char_t              *cmdLine;
+    char_t              **pArgs;
+    BOOL                bReturn;
+    int                 i, nLen;
+    unsigned char       *pEnvData;
 
     /*
         Replace directory delimiters with Windows-friendly delimiters
      */
-	nLen = gstrlen(cgiPath);
-	for (i = 0; i < nLen; i++) {
-		if (cgiPath[i] == '/') {
-			cgiPath[i] = '\\';
-		}
-	}
+    nLen = gstrlen(cgiPath);
+    for (i = 0; i < nLen; i++) {
+        if (cgiPath[i] == '/') {
+            cgiPath[i] = '\\';
+        }
+    }
 
     /*
         Calculate length of command line
      */
-	nLen = 0;
-	pArgs = argp;
-	while (pArgs && *pArgs && **pArgs) {
-		nLen += gstrlen(*pArgs) + 1;
-		pArgs++;
-	}
+    nLen = 0;
+    pArgs = argp;
+    while (pArgs && *pArgs && **pArgs) {
+        nLen += gstrlen(*pArgs) + 1;
+        pArgs++;
+    }
 
     /*
         Construct command line
      */
-	cmdLine = balloc(B_L, sizeof(char_t) * nLen);
-	a_assert (cmdLine);
-	gstrcpy(cmdLine, "");
+    cmdLine = balloc(B_L, sizeof(char_t) * nLen);
+    a_assert (cmdLine);
+    gstrcpy(cmdLine, "");
 
-	pArgs = argp;
-	while (pArgs && *pArgs && **pArgs) {
-		gstrcat(cmdLine, *pArgs);
-		gstrcat(cmdLine, T(" "));
-		pArgs++;
-	}
+    pArgs = argp;
+    while (pArgs && *pArgs && **pArgs) {
+        gstrcat(cmdLine, *pArgs);
+        gstrcat(cmdLine, T(" "));
+        pArgs++;
+    }
 
     /*
         Create the process start-up information
      */
-	memset (&newinfo, 0, sizeof(newinfo));
-	newinfo.cb          = sizeof(newinfo);
-	newinfo.dwFlags     = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
-	newinfo.wShowWindow = SW_HIDE;
-	newinfo.lpTitle     = NULL;
+    memset (&newinfo, 0, sizeof(newinfo));
+    newinfo.cb          = sizeof(newinfo);
+    newinfo.dwFlags     = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
+    newinfo.wShowWindow = SW_HIDE;
+    newinfo.lpTitle     = NULL;
 
     /*
         Create file handles for the spawned processes stdin and stdout files
      */
-	security.nLength = sizeof(SECURITY_ATTRIBUTES);
-	security.lpSecurityDescriptor = NULL;
-	security.bInheritHandle = TRUE;
+    security.nLength = sizeof(SECURITY_ATTRIBUTES);
+    security.lpSecurityDescriptor = NULL;
+    security.bInheritHandle = TRUE;
 
     /*
         Stdin file should already exist.
@@ -925,53 +925,53 @@ int websLaunchCgiProc(char_t *cgiPath, char_t **argp, char_t **envp, char_t *std
     /*
         Stdout file is created and file pointer is reset to start.
      */
-	newinfo.hStdOutput = CreateFile(stdOut, GENERIC_READ | GENERIC_WRITE,
-		FILE_SHARE_READ + FILE_SHARE_WRITE, &security, OPEN_ALWAYS,
-		FILE_ATTRIBUTE_NORMAL, NULL);
-	SetFilePointer (newinfo.hStdOutput, 0, NULL, FILE_END);
+    newinfo.hStdOutput = CreateFile(stdOut, GENERIC_READ | GENERIC_WRITE,
+        FILE_SHARE_READ + FILE_SHARE_WRITE, &security, OPEN_ALWAYS,
+        FILE_ATTRIBUTE_NORMAL, NULL);
+    SetFilePointer (newinfo.hStdOutput, 0, NULL, FILE_END);
 
     /*
         Stderr file is set to Stdout.
      */
-	newinfo.hStdError = newinfo.hStdOutput;
+    newinfo.hStdError = newinfo.hStdOutput;
 
-	dwCreateFlags = CREATE_NEW_CONSOLE;
-	pEnvData = tableToBlock(envp);
+    dwCreateFlags = CREATE_NEW_CONSOLE;
+    pEnvData = tableToBlock(envp);
 
     /*
         CreateProcess returns errors sometimes, even when the process was started correctly.  The cause is not evident.
         For now: we detect an error by checking the value of procinfo.hProcess after the call.
     */
-	procinfo.hProcess = NULL;
-	bReturn = CreateProcess(
-		NULL,               /*  Name of executable module        */
-		cmdLine,            /*  Command line string              */
-		NULL,               /*  Process security attributes      */
-		NULL,               /*  Thread security attributes       */
-		TRUE,               /*  Handle inheritance flag          */
-		dwCreateFlags,      /*  Creation flags                   */
+    procinfo.hProcess = NULL;
+    bReturn = CreateProcess(
+        NULL,               /*  Name of executable module        */
+        cmdLine,            /*  Command line string              */
+        NULL,               /*  Process security attributes      */
+        NULL,               /*  Thread security attributes       */
+        TRUE,               /*  Handle inheritance flag          */
+        dwCreateFlags,      /*  Creation flags                   */
         pEnvData,           /*  New environment block            */
-		NULL,               /*  Current directory name           */
-		&newinfo,           /*  STARTUPINFO                      */
-		&procinfo);         /*  PROCESS_INFORMATION              */
-
-	if (procinfo.hThread != NULL)  {
-		CloseHandle(procinfo.hThread);
-	}
-	if (newinfo.hStdInput) {
-		CloseHandle(newinfo.hStdInput);
-	}
-	if (newinfo.hStdOutput) {
-		CloseHandle(newinfo.hStdOutput);
-	}
-	bfree(B_L, pEnvData);
-	bfree(B_L, cmdLine);
-
-	if (bReturn == 0) {
-		return -1;
-	} else {
-		return (int) procinfo.hProcess;
-	}
+        NULL,               /*  Current directory name           */
+        &newinfo,           /*  STARTUPINFO                      */
+        &procinfo);         /*  PROCESS_INFORMATION              */
+
+    if (procinfo.hThread != NULL)  {
+        CloseHandle(procinfo.hThread);
+    }
+    if (newinfo.hStdInput) {
+        CloseHandle(newinfo.hStdInput);
+    }
+    if (newinfo.hStdOutput) {
+        CloseHandle(newinfo.hStdOutput);
+    }
+    bfree(B_L, pEnvData);
+    bfree(B_L, cmdLine);
+
+    if (bReturn == 0) {
+        return -1;
+    } else {
+        return (int) procinfo.hProcess;
+    }
 }
 
 
@@ -980,20 +980,20 @@ int websLaunchCgiProc(char_t *cgiPath, char_t **argp, char_t **envp, char_t *std
  */
 int websCheckCgiProc(int handle)
 {
-	int     nReturn;
-	DWORD   exitCode;
+    int     nReturn;
+    DWORD   exitCode;
 
-	nReturn = GetExitCodeProcess((HANDLE)handle, &exitCode);
+    nReturn = GetExitCodeProcess((HANDLE)handle, &exitCode);
     /*
         We must close process handle to free up the window resource, but only
         when we're done with it.
      */
-	if ((nReturn == 0) || (exitCode != STILL_ACTIVE)) {
-		CloseHandle((HANDLE)handle);
-		return 0;
-	}
+    if ((nReturn == 0) || (exitCode != STILL_ACTIVE)) {
+        CloseHandle((HANDLE)handle);
+        return 0;
+    }
 
-	return 1;
+    return 1;
 }
 
 #endif /* WIN */
diff --git a/default.c b/default.c
index 6fc93979..d1829120 100644
--- a/default.c
+++ b/default.c
@@ -9,15 +9,15 @@
 
 /********************************* Includes ***********************************/
 
-#include	"wsIntrn.h"
+#include    "wsIntrn.h"
 
 /*********************************** Locals ***********************************/
 
-static char_t	*websDefaultPage;			/* Default page name */
-static char_t	*websDefaultDir;			/* Default Web page directory */
+static char_t   *websDefaultPage;           /* Default page name */
+static char_t   *websDefaultDir;            /* Default Web page directory */
 
 /**************************** Forward Declarations ****************************/
-#define MAX_URL_DEPTH			8	/* Max directory depth of websDefaultDir */
+#define MAX_URL_DEPTH           8   /* Max directory depth of websDefaultDir */
 
 #ifdef WEBS_WHITELIST_SUPPORT
 
@@ -26,26 +26,26 @@ static char_t	*websDefaultDir;			/* Default Web page directory */
 #endif
 
 /* Whitelist flags (more flags in wsIntrn.h) */
-#define WHITELIST_BLOCKED	0x100	/* File is in list, but inaccessible */
-#define WHITELIST_DIR		0x200	/* Node is a Directory */
+#define WHITELIST_BLOCKED   0x100   /* File is in list, but inaccessible */
+#define WHITELIST_DIR       0x200   /* Node is a Directory */
 
 #ifdef WEBS_SSL_SUPPORT
 typedef struct _sslList {
-	struct _sslList *next;
-	char			*url;
+    struct _sslList *next;
+    char            *url;
 } sslList_t;
 
-static sslList_t	*sslList;
+static sslList_t    *sslList;
 #endif /* WEBS_SSL_SUPPORT */
 
 typedef struct _fileNode {
-	struct _fileNode *next;		/* Next file/dir on same level (NULL if last) */
-	struct _fileNode *child;	/* Non-NULL if this is a directory with child */
-	char	*name;				/* path segment with trailing '/' or filename */
-	int		flags;				/* Flags pertaining to this list entry */
+    struct _fileNode *next;     /* Next file/dir on same level (NULL if last) */
+    struct _fileNode *child;    /* Non-NULL if this is a directory with child */
+    char    *name;              /* path segment with trailing '/' or filename */
+    int     flags;              /* Flags pertaining to this list entry */
 } fileNode_t;
 
-static fileNode_t	*whitelist = NULL; /* Global tree of files in list */
+static fileNode_t   *whitelist = NULL; /* Global tree of files in list */
 
 static int websBuildWhitelistRecursive(char *_path, fileNode_t *dir, int level);
 static fileNode_t* websWhitelistCheckRecursive(fileNode_t *n, char *path);
@@ -66,16 +66,16 @@ static void websDefaultWriteEvent(webs_t wp);
 
 int websDefaultHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t *url, char_t *path, char_t *query)
 {
-	websStatType	sbuf;
-	char_t			*lpath, *tmp, *date;
-	int				bytes, flags, nchars, rc;
+    websStatType    sbuf;
+    char_t          *lpath, *tmp, *date;
+    int             bytes, flags, nchars, rc;
 
-	a_assert(websValid(wp));
-	a_assert(url && *url);
-	a_assert(path);
-	a_assert(query);
+    a_assert(websValid(wp));
+    a_assert(url && *url);
+    a_assert(path);
+    a_assert(query);
 
-	flags = websGetRequestFlags(wp);
+    flags = websGetRequestFlags(wp);
 
     /*
         We do whitelist validation in addition to standard URL validation.  The whitelist should really catch anything
@@ -83,156 +83,156 @@ int websDefaultHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, ch
         secure connection, but the whitelist entry has the SSL flag set, do not serve the page.
      */
 #ifdef WEBS_WHITELIST_SUPPORT
-	if ((rc = websWhitelistCheck(wp->url)) < 0) {
-		websBuildWhitelist();
-		if ((rc = websWhitelistCheck(wp->url)) < 0) {
-			websError(wp, 404, T("Cannot open URL"));
-			return 1;
-		}
-	}
-	if (!(flags & WEBS_SECURE) && (rc & WHITELIST_SSL)) {
-		websError(wp, 500, T("HTTPS access required"));
-		return 1;
-	}
+    if ((rc = websWhitelistCheck(wp->url)) < 0) {
+        websBuildWhitelist();
+        if ((rc = websWhitelistCheck(wp->url)) < 0) {
+            websError(wp, 404, T("Cannot open URL"));
+            return 1;
+        }
+    }
+    if (!(flags & WEBS_SECURE) && (rc & WHITELIST_SSL)) {
+        websError(wp, 500, T("HTTPS access required"));
+        return 1;
+    }
 #endif /* WEBS_WHITELIST_SUPPORT */
     /*
-      	Validate the URL and ensure that ".."s don't give access to unwanted files
+        Validate the URL and ensure that ".."s don't give access to unwanted files
      */
-	if (websValidateUrl(wp, path) < 0) {
+    if (websValidateUrl(wp, path) < 0) {
         /* 
             preventing a cross-site scripting exploit -- you may restore the following line of code to revert to the
             original behavior...  websError(wp, 500, T("Invalid URL %s"), url);
         */
-		websError(wp, 500, T("Invalid URL"));
-		websBuildWhitelist();
-		return 1;
-	}
-	lpath = websGetRequestLpath(wp);
-	nchars = gstrlen(lpath) - 1;
-	if (lpath[nchars] == '/' || lpath[nchars] == '\\') {
-		lpath[nchars] = '\0';
-	}
+        websError(wp, 500, T("Invalid URL"));
+        websBuildWhitelist();
+        return 1;
+    }
+    lpath = websGetRequestLpath(wp);
+    nchars = gstrlen(lpath) - 1;
+    if (lpath[nchars] == '/' || lpath[nchars] == '\\') {
+        lpath[nchars] = '\0';
+    }
 
     /*
         If the file is a directory, redirect using the nominated default page
      */
-	if (websPageIsDirectory(lpath)) {
-		nchars = gstrlen(path);
-		if (path[nchars-1] == '/' || path[nchars-1] == '\\') {
-			path[--nchars] = '\0';
-		}
-		nchars += gstrlen(websDefaultPage) + 2;
-		fmtAlloc(&tmp, nchars, T("%s/%s"), path, websDefaultPage);
-		websRedirect(wp, tmp);
-		bfreeSafe(B_L, tmp);
-		return 1;
-	}
+    if (websPageIsDirectory(lpath)) {
+        nchars = gstrlen(path);
+        if (path[nchars-1] == '/' || path[nchars-1] == '\\') {
+            path[--nchars] = '\0';
+        }
+        nchars += gstrlen(websDefaultPage) + 2;
+        fmtAlloc(&tmp, nchars, T("%s/%s"), path, websDefaultPage);
+        websRedirect(wp, tmp);
+        bfreeSafe(B_L, tmp);
+        return 1;
+    }
 
     /*
         Open the document. Stat for later use.
      */
-	if (websPageOpen(wp, lpath, path, O_RDONLY | O_BINARY, 0666) < 0) {
-		websError(wp, 404, T("Cannot open URL"));
-		websBuildWhitelist();
-		return 1;
-	} 
-
-	if (websPageStat(wp, lpath, path, &sbuf) < 0) {
-		websError(wp, 400, T("Cannot stat page for URL"));
-		websBuildWhitelist();
-		return 1;
-	}
+    if (websPageOpen(wp, lpath, path, O_RDONLY | O_BINARY, 0666) < 0) {
+        websError(wp, 404, T("Cannot open URL"));
+        websBuildWhitelist();
+        return 1;
+    } 
+
+    if (websPageStat(wp, lpath, path, &sbuf) < 0) {
+        websError(wp, 400, T("Cannot stat page for URL"));
+        websBuildWhitelist();
+        return 1;
+    }
 
     /*
         If the page has not been modified since the user last received it and it is not dynamically generated each time
         (ASP), then optimize request by sending a 304 Use local copy response.
      */
-	websStats.localHits++;
+    websStats.localHits++;
 #ifdef WEBS_IF_MODIFIED_SUPPORT
-	if (flags & WEBS_IF_MODIFIED && !(flags & WEBS_ASP)) {
-		if (sbuf.mtime <= wp->since) {
-			websWrite(wp, T("HTTP/1.0 304 Use local copy\r\n"));
+    if (flags & WEBS_IF_MODIFIED && !(flags & WEBS_ASP)) {
+        if (sbuf.mtime <= wp->since) {
+            websWrite(wp, T("HTTP/1.0 304 Use local copy\r\n"));
             /*
                 NOTE: by license terms the following line of code must not be modified.
                 MOB: remove define
              */
-			websWrite(wp, T("Server: %s\r\n"), WEBS_NAME);
-			if (flags & WEBS_KEEP_ALIVE) {
-				websWrite(wp, T("Connection: keep-alive\r\n"));
-			}
-			websWrite(wp, T("\r\n"));
-			websSetRequestFlags(wp, flags |= WEBS_HEADER_DONE);
-			websDone(wp, 304);
-			return 1;
-		}
-	}
+            websWrite(wp, T("Server: %s\r\n"), WEBS_NAME);
+            if (flags & WEBS_KEEP_ALIVE) {
+                websWrite(wp, T("Connection: keep-alive\r\n"));
+            }
+            websWrite(wp, T("\r\n"));
+            websSetRequestFlags(wp, flags |= WEBS_HEADER_DONE);
+            websDone(wp, 304);
+            return 1;
+        }
+    }
 #endif
 
     /*
         Output the normal HTTP response header
      */
-	if ((date = websGetDateString(NULL)) != NULL) {
-		websWrite(wp, T("HTTP/1.0 200 OK\r\nDate: %s\r\n"), date);
+    if ((date = websGetDateString(NULL)) != NULL) {
+        websWrite(wp, T("HTTP/1.0 200 OK\r\nDate: %s\r\n"), date);
         /*
             The Server HTTP header below must not be modified unless explicitly allowed by licensing terms.
          */
 #ifdef WEBS_SSL_SUPPORT
-		websWrite(wp, T("Server: %s/%s %s/%s\r\n"), WEBS_NAME, WEBS_VERSION, SSL_NAME, SSL_VERSION);
+        websWrite(wp, T("Server: %s/%s %s/%s\r\n"), WEBS_NAME, WEBS_VERSION, SSL_NAME, SSL_VERSION);
 #else
-		websWrite(wp, T("Server: %s/%s\r\n"), WEBS_NAME, WEBS_VERSION);
+        websWrite(wp, T("Server: %s/%s\r\n"), WEBS_NAME, WEBS_VERSION);
 #endif
-		bfree(B_L, date);
-	}
-	flags |= WEBS_HEADER_DONE;
+        bfree(B_L, date);
+    }
+    flags |= WEBS_HEADER_DONE;
 
     /*
-      	If this is an ASP request, ensure the remote browser doesn't cache it.
+        If this is an ASP request, ensure the remote browser doesn't cache it.
         Send back both HTTP/1.0 and HTTP/1.1 cache control directives
      */
-	if (flags & WEBS_ASP) {
-		bytes = 0;
-		websWrite(wp, T("Pragma: no-cache\r\nCache-Control: no-cache\r\n"));
-
-	} else {
-		if ((date = websGetDateString(&sbuf)) != NULL) {
-			websWrite(wp, T("Last-modified: %s\r\n"), date);
-			bfree(B_L, date);
-		}
-		bytes = sbuf.size;
-	}
-	if (bytes) {
-		websWrite(wp, T("Content-length: %d\r\n"), bytes);
-		websSetRequestBytes(wp, bytes);
-	}
-	websWrite(wp, T("Content-type: %s\r\n"), websGetRequestType(wp));
-
-	if ((flags & WEBS_KEEP_ALIVE) && !(flags & WEBS_ASP)) {
-		websWrite(wp, T("Connection: keep-alive\r\n"));
-	}
-	websWrite(wp, T("\r\n"));
+    if (flags & WEBS_ASP) {
+        bytes = 0;
+        websWrite(wp, T("Pragma: no-cache\r\nCache-Control: no-cache\r\n"));
+
+    } else {
+        if ((date = websGetDateString(&sbuf)) != NULL) {
+            websWrite(wp, T("Last-modified: %s\r\n"), date);
+            bfree(B_L, date);
+        }
+        bytes = sbuf.size;
+    }
+    if (bytes) {
+        websWrite(wp, T("Content-length: %d\r\n"), bytes);
+        websSetRequestBytes(wp, bytes);
+    }
+    websWrite(wp, T("Content-type: %s\r\n"), websGetRequestType(wp));
+
+    if ((flags & WEBS_KEEP_ALIVE) && !(flags & WEBS_ASP)) {
+        websWrite(wp, T("Connection: keep-alive\r\n"));
+    }
+    websWrite(wp, T("\r\n"));
 
     /*
-      	All done if the browser did a HEAD request
+        All done if the browser did a HEAD request
      */
     if (flags & WEBS_HEAD_REQUEST) {
-		websDone(wp, 200);
-		return 1;
-	}
+        websDone(wp, 200);
+        return 1;
+    }
     /*
         Evaluate ASP requests
      */
         if (flags & WEBS_ASP) {
-		if (websAspRequest(wp, lpath) < 0) {
-			return 1;
-		}
-		websDone(wp, 200);
-		return 1;
-	}
+        if (websAspRequest(wp, lpath) < 0) {
+            return 1;
+        }
+        websDone(wp, 200);
+        return 1;
+    }
     /*
-      	Return the data via background write
+        Return the data via background write
      */
     websSetRequestSocketHandler(wp, SOCKET_WRITABLE, websDefaultWriteEvent);
-	return 1;
+    return 1;
 }
 
 
@@ -311,7 +311,7 @@ static int isBadWindowsPath(char_t** parts, int partCount)
              (badPath(parts[i], T("aux"), 3)) ||
              (badPath(parts[i], T("clock$"), 6)) ||
              (badPath(parts[i], T("config$"), 7)) ) {
-				return 1;
+                return 1;
             }
          }
       }
@@ -326,40 +326,40 @@ static int isBadWindowsPath(char_t** parts, int partCount)
 
 
 /*
-  	Validate the URL path and process ".." path segments. Return -1 if the URL is bad.
+    Validate the URL path and process ".." path segments. Return -1 if the URL is bad.
  */
 int websValidateUrl(webs_t wp, char_t *path)
 {
-	char_t	*parts[MAX_URL_DEPTH];	/* Array of ptr's to URL parts */
-	char_t	*token, *dir, *lpath; 
-	int	      i, len, npart;
+    char_t  *parts[MAX_URL_DEPTH];  /* Array of ptr's to URL parts */
+    char_t  *token, *dir, *lpath; 
+    int       i, len, npart;
 
-	a_assert(websValid(wp));
-	a_assert(path);
+    a_assert(websValid(wp));
+    a_assert(path);
 
-	dir = websGetRequestDir(wp);
-	if (dir == NULL || *dir == '\0') {
-		return -1;
-	}
+    dir = websGetRequestDir(wp);
+    if (dir == NULL || *dir == '\0') {
+        return -1;
+    }
     /*
         Copy the string so we don't destroy the original
      */
-	path = bstrdup(B_L, path);
-	websDecodeUrl(path, path, gstrlen(path));
-	len = npart = 0;
-	parts[0] = NULL;
-	token = gstrchr(path, '\\');
-	while (token != NULL) {
-		*token = '/';
-		token = gstrchr(token, '\\');
-	}
-	token = gstrtok(path, T("/"));
+    path = bstrdup(B_L, path);
+    websDecodeUrl(path, path, gstrlen(path));
+    len = npart = 0;
+    parts[0] = NULL;
+    token = gstrchr(path, '\\');
+    while (token != NULL) {
+        *token = '/';
+        token = gstrchr(token, '\\');
+    }
+    token = gstrtok(path, T("/"));
 
     /*
         Look at each directory segment and process "." and ".." segments. Don't allow the browser to pop outside the
         root web
     */
-	while (token != NULL) {
+    while (token != NULL) {
         if (npart >= MAX_URL_DEPTH) {
              /*
               * malformed URL -- too many parts for us to process.
@@ -369,15 +369,15 @@ int websValidateUrl(webs_t wp, char_t *path)
         }
         if (gstrcmp(token, T("..")) == 0) {
             if (npart > 0) {
-				npart--;
-			}
-		} else if (gstrcmp(token, T(".")) != 0) {
-			parts[npart] = token;
-			len += gstrlen(token) + 1;
-			npart++;
-		}
-		token = gstrtok(NULL, T("/"));
-	}
+                npart--;
+            }
+        } else if (gstrcmp(token, T(".")) != 0) {
+            parts[npart] = token;
+            len += gstrlen(token) + 1;
+            npart++;
+        }
+        token = gstrtok(NULL, T("/"));
+    }
 
 #ifdef WIN32
    if (isBadWindowsPath(parts, npart)) {
@@ -390,22 +390,22 @@ int websValidateUrl(webs_t wp, char_t *path)
     /*
         Create local path for document. Need extra space all "/" and null.
      */
-	if (npart || (gstrcmp(path, T("/")) == 0) || (path[0] == '\0')) {
-		lpath = balloc(B_L, (gstrlen(dir) + 1 + len + 1) * sizeof(char_t));
-		gstrcpy(lpath, dir);
-
-		for (i = 0; i < npart; i++) {
-			gstrcat(lpath, T("/"));
-			gstrcat(lpath, parts[i]);
-		}
-		websSetRequestLpath(wp, lpath);
-		bfree(B_L, path);
-		bfree(B_L, lpath);
-	} else {
-		bfree(B_L, path);
-		return -1;
-	}
-	return 0;
+    if (npart || (gstrcmp(path, T("/")) == 0) || (path[0] == '\0')) {
+        lpath = balloc(B_L, (gstrlen(dir) + 1 + len + 1) * sizeof(char_t));
+        gstrcpy(lpath, dir);
+
+        for (i = 0; i < npart; i++) {
+            gstrcat(lpath, T("/"));
+            gstrcat(lpath, parts[i]);
+        }
+        websSetRequestLpath(wp, lpath);
+        bfree(B_L, path);
+        bfree(B_L, lpath);
+    } else {
+        bfree(B_L, path);
+        return -1;
+    }
+    return 0;
 }
 
 
@@ -414,54 +414,54 @@ int websValidateUrl(webs_t wp, char_t *path)
  */
 static void websDefaultWriteEvent(webs_t wp)
 {
-	int		len, wrote, flags, bytes, written;
-	char	*buf;
+    int     len, wrote, flags, bytes, written;
+    char    *buf;
 
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
-	flags = websGetRequestFlags(wp);
-	websSetTimeMark(wp);
-	wrote = bytes = 0;
-	written = websGetRequestWritten(wp);
+    flags = websGetRequestFlags(wp);
+    websSetTimeMark(wp);
+    wrote = bytes = 0;
+    written = websGetRequestWritten(wp);
 
     /*
         We only do this for non-ASP documents
      */
-	if ( !(flags & WEBS_ASP)) {
-		bytes = websGetRequestBytes(wp);
+    if ( !(flags & WEBS_ASP)) {
+        bytes = websGetRequestBytes(wp);
         /*
             Note: websWriteDataNonBlock may return less than we wanted. It will return -1 on a socket error
          */
-		if ((buf = balloc(B_L, PAGE_READ_BUFSIZE)) == NULL) {
-			websError(wp, 200, T("Can't get memory"));
-		} else {
-			while ((len = websPageReadData(wp, buf, PAGE_READ_BUFSIZE)) > 0) {
-				if ((wrote = websWriteDataNonBlock(wp, buf, len)) < 0) {
-					break;
-				}
-				written += wrote;
-				if (wrote != len) {
-					websPageSeek(wp, - (len - wrote));
-					break;
-				}
-			}
+        if ((buf = balloc(B_L, PAGE_READ_BUFSIZE)) == NULL) {
+            websError(wp, 200, T("Can't get memory"));
+        } else {
+            while ((len = websPageReadData(wp, buf, PAGE_READ_BUFSIZE)) > 0) {
+                if ((wrote = websWriteDataNonBlock(wp, buf, len)) < 0) {
+                    break;
+                }
+                written += wrote;
+                if (wrote != len) {
+                    websPageSeek(wp, - (len - wrote));
+                    break;
+                }
+            }
             /*
                 Safety: If we are at EOF, we must be done
              */
-			if (len == 0) {
-				a_assert(written >= bytes);
-				written = bytes;
-			}
-			bfree(B_L, buf);
-		}
-	}
+            if (len == 0) {
+                a_assert(written >= bytes);
+                written = bytes;
+            }
+            bfree(B_L, buf);
+        }
+    }
     /*
         We're done if an error, or all bytes output
      */
-	websSetRequestWritten(wp, written);
-	if (wrote < 0 || written >= bytes) {
-		websDone(wp, 200);
-	}
+    websSetRequestWritten(wp, written);
+    if (wrote < 0 || written >= bytes) {
+        websDone(wp, 200);
+    }
 }
 
 
@@ -473,10 +473,10 @@ void websDefaultOpen()
 {
 #ifdef WEBS_WHITELIST_SUPPORT
 #ifdef WEBS_SSL_SUPPORT
-	sslList = NULL;
+    sslList = NULL;
 #endif
-	whitelist = NULL;
-	websBuildWhitelist();
+    whitelist = NULL;
+    websBuildWhitelist();
 #endif /* WEBS_WHITELIST_SUPPORT */
 }
 
@@ -488,24 +488,24 @@ void websDefaultClose()
 {
 #ifdef WEBS_WHITELIST_SUPPORT
 #ifdef WEBS_SSL_SUPPORT
-	sslList_t	*l;
-	while (sslList != NULL) {
-		l = sslList;
-		sslList = sslList->next;
-		bfreeSafe(B_L, l->url);
-		bfree(B_L, l);
-	}	
+    sslList_t   *l;
+    while (sslList != NULL) {
+        l = sslList;
+        sslList = sslList->next;
+        bfreeSafe(B_L, l->url);
+        bfree(B_L, l);
+    }   
 #endif
-	websDeleteWhitelist();
+    websDeleteWhitelist();
 #endif /* WEBS_WHITELIST_SUPPORT */
-	if (websDefaultPage) {
-		bfree(B_L, websDefaultPage);
-		websDefaultPage = NULL;
-	}
-	if (websDefaultDir) {
-		bfree(B_L, websDefaultDir);
-		websDefaultDir = NULL;
-	}
+    if (websDefaultPage) {
+        bfree(B_L, websDefaultPage);
+        websDefaultPage = NULL;
+    }
+    if (websDefaultDir) {
+        bfree(B_L, websDefaultDir);
+        websDefaultDir = NULL;
+    }
 }
 
 
@@ -514,13 +514,13 @@ void websDefaultClose()
  */
 char_t *websGetDefaultPage()
 {
-	return websDefaultPage;
+    return websDefaultPage;
 }
 
 
 char_t *websGetDefaultDir()
 {
-	return websDefaultDir;
+    return websDefaultDir;
 }
 
 
@@ -529,12 +529,12 @@ char_t *websGetDefaultDir()
  */
 void websSetDefaultPage(char_t *page)
 {
-	a_assert(page && *page);
+    a_assert(page && *page);
 
-	if (websDefaultPage) {
-		bfree(B_L, websDefaultPage);
-	}
-	websDefaultPage = bstrdup(B_L, page);
+    if (websDefaultPage) {
+        bfree(B_L, websDefaultPage);
+    }
+    websDefaultPage = bstrdup(B_L, page);
 }
 
 
@@ -543,11 +543,11 @@ void websSetDefaultPage(char_t *page)
  */
 void websSetDefaultDir(char_t *dir)
 {
-	a_assert(dir && *dir);
-	if (websDefaultDir) {
-		bfree(B_L, websDefaultDir);
-	}
-	websDefaultDir = bstrdup(B_L, dir);
+    a_assert(dir && *dir);
+    if (websDefaultDir) {
+        bfree(B_L, websDefaultDir);
+    }
+    websDefaultDir = bstrdup(B_L, dir);
 }
 
 #ifdef WEBS_WHITELIST_SUPPORT
@@ -559,36 +559,36 @@ void websSetDefaultDir(char_t *dir)
  */
 int websWhitelistCheck(char *url)
 {
-	fileNode_t	*n;
-	if ((n = websWhitelistCheckRecursive(whitelist, url)) == NULL) {
-		return -1;
-	}
-	return n->flags;
+    fileNode_t  *n;
+    if ((n = websWhitelistCheckRecursive(whitelist, url)) == NULL) {
+        return -1;
+    }
+    return n->flags;
 }
 
 
 static fileNode_t* websWhitelistCheckRecursive(fileNode_t *n, char *path)
 {
-	char	*c, *p;
-
-	if (n == NULL) return NULL;
-	if ((n->flags & WHITELIST_BLOCKED) != 0) {
-		return websWhitelistCheckRecursive(n->next, path);
-	}
-	if (n->name) {
-		for (c = n->name, p = path; *c != '\0' && *p != '\0'; c++, p++) {
-			if (tolower(*c) != tolower(*p)) {
-				break;	/* not a match */
-			}
-		}
-	}
-	if (*p == '\0' && (*c == '\0' || (*c == '/' && *(c+1) == '\0'))) {
-		return n;	/* We've matched to the end of the path */
-	}
-	if (*c == '\0' && (n->flags & WHITELIST_DIR)) {
-		return websWhitelistCheckRecursive(n->child, p);
-	}
-	return websWhitelistCheckRecursive(n->next, path);
+    char    *c, *p;
+
+    if (n == NULL) return NULL;
+    if ((n->flags & WHITELIST_BLOCKED) != 0) {
+        return websWhitelistCheckRecursive(n->next, path);
+    }
+    if (n->name) {
+        for (c = n->name, p = path; *c != '\0' && *p != '\0'; c++, p++) {
+            if (tolower(*c) != tolower(*p)) {
+                break;  /* not a match */
+            }
+        }
+    }
+    if (*p == '\0' && (*c == '\0' || (*c == '/' && *(c+1) == '\0'))) {
+        return n;   /* We've matched to the end of the path */
+    }
+    if (*c == '\0' && (n->flags & WHITELIST_DIR)) {
+        return websWhitelistCheckRecursive(n->child, p);
+    }
+    return websWhitelistCheckRecursive(n->next, path);
 }
 
 /*
@@ -600,25 +600,25 @@ static fileNode_t* websWhitelistCheckRecursive(fileNode_t *n, char *path)
 #ifdef WEBS_SSL_SUPPORT
 int websRequireSSL(char *url)
 {
-	sslList_t	*l;
-	int			sz;
-	
-	l = balloc(B_L, sizeof(sslList_t));
-	memset(l, 0x0, sizeof(sslList_t));
-	sz = strlen(url) + 1;
-	if (url[sz - 2] == '/') {
-		l->url = bstrdup(B_L, url);
-	} else {
-		sz++;
-		l->url = balloc(B_L, sz);
-		memcpy(l->url, url, sz - 1);
-		l->url[sz - 2] = '/';
-		l->url[sz - 1] = '\0';
-	}
-	l->next = sslList;
-	sslList = l;
-	websBuildWhitelist();
-	return 0;
+    sslList_t   *l;
+    int         sz;
+    
+    l = balloc(B_L, sizeof(sslList_t));
+    memset(l, 0x0, sizeof(sslList_t));
+    sz = strlen(url) + 1;
+    if (url[sz - 2] == '/') {
+        l->url = bstrdup(B_L, url);
+    } else {
+        sz++;
+        l->url = balloc(B_L, sz);
+        memcpy(l->url, url, sz - 1);
+        l->url[sz - 2] = '/';
+        l->url[sz - 1] = '\0';
+    }
+    l->next = sslList;
+    sslList = l;
+    websBuildWhitelist();
+    return 0;
 }
 #endif /* WEBS_SSL_SUPPORT */
 
@@ -628,25 +628,25 @@ int websRequireSSL(char *url)
  */
 void websDeleteWhitelist(void)
 {
-	websDeleteWhitelistRecursive(whitelist);
-	whitelist = NULL;
+    websDeleteWhitelistRecursive(whitelist);
+    whitelist = NULL;
 }
 
 
 static void websDeleteWhitelistRecursive(fileNode_t *dir)
 {
-	if (dir == NULL) return;
-	if (dir->child) {	/* Depth first recursion to delete leaves */
-		websDeleteWhitelistRecursive(dir->child);
-	}
-	if (dir->next) {
-		websDeleteWhitelistRecursive(dir->next);
-	}
-	if (dir->name) {
-		bfree(B_L, dir->name);
-	}
-	memset(dir, 0x0, sizeof(fileNode_t));
-	bfree(B_L, dir);
+    if (dir == NULL) return;
+    if (dir->child) {   /* Depth first recursion to delete leaves */
+        websDeleteWhitelistRecursive(dir->child);
+    }
+    if (dir->next) {
+        websDeleteWhitelistRecursive(dir->next);
+    }
+    if (dir->name) {
+        bfree(B_L, dir->name);
+    }
+    memset(dir, 0x0, sizeof(fileNode_t));
+    bfree(B_L, dir);
 }
 
 
@@ -655,15 +655,15 @@ static void websDeleteWhitelistRecursive(fileNode_t *dir)
  */
 int websBuildWhitelist(void)
 {
-	if (websDefaultDir == NULL || *websDefaultDir == '\0') {
-		return -1;
-	}
-	websDeleteWhitelistRecursive(whitelist);
-	whitelist = balloc(B_L, sizeof(fileNode_t));
-	memset(whitelist, 0x0, sizeof(fileNode_t));
-	whitelist->name = bstrdup(B_L, "/");
-	whitelist->flags |= WHITELIST_DIR;
-	return websBuildWhitelistRecursive(websDefaultDir, whitelist, 0);
+    if (websDefaultDir == NULL || *websDefaultDir == '\0') {
+        return -1;
+    }
+    websDeleteWhitelistRecursive(whitelist);
+    whitelist = balloc(B_L, sizeof(fileNode_t));
+    memset(whitelist, 0x0, sizeof(fileNode_t));
+    whitelist->name = bstrdup(B_L, "/");
+    whitelist->flags |= WHITELIST_DIR;
+    return websBuildWhitelistRecursive(websDefaultDir, whitelist, 0);
 }
 
 
@@ -673,73 +673,73 @@ int websBuildWhitelist(void)
 #ifdef WIN32
 static int websBuildWhitelistRecursive(char *_path, fileNode_t *dir, int level)
 {
-	WIN32_FIND_DATA	findData;
-	HANDLE	fh;
-	fileNode_t	*cnode, *nnode; /* current node, next node */
+    WIN32_FIND_DATA findData;
+    HANDLE  fh;
+    fileNode_t  *cnode, *nnode; /* current node, next node */
 #ifdef WEBS_SSL_SUPPORT
-	sslList_t	*l;
+    sslList_t   *l;
 #endif
-	int		rc = 0;
-	int		firstTime;
-	char	path[MAX_PATH];
-	char	tmppath[MAX_PATH];
-
-	firstTime = 1;
-	cnode = dir;
-	websMakePath(path, _path, NULL, 1);
-	fh = FindFirstFile((LPCSTR)path, &findData);
-	while (fh != INVALID_HANDLE_VALUE) {
-		if ((strcmp(findData.cFileName, ".") == 0) ||
-				(strcmp(findData.cFileName, "..") == 0) ||
-				(findData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) ||
-				(findData.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)) {
-			goto nextFile;
-		}
-		nnode = balloc(B_L, sizeof(fileNode_t));
-		memset(nnode, 0x0, sizeof(fileNode_t));
-		if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
-			fmtAlloc(&(nnode->name), MAX_PATH, "%s/", findData.cFileName);
-			nnode->flags |= WHITELIST_DIR;
-		} else {
-			nnode->name = bstrdup(B_L, findData.cFileName);
-		}
-		if (firstTime) {
-			cnode->child = nnode;
-			firstTime = 0;
-		} else {
-			cnode->next = nnode;
-		}
-		cnode = nnode;
-		if (strncmp(path + strlen(websDefaultDir), "/" CGI_BIN, 
-				strlen(CGI_BIN) + 1) == 0) {
-			cnode->flags |= WHITELIST_CGI;
-		}
+    int     rc = 0;
+    int     firstTime;
+    char    path[MAX_PATH];
+    char    tmppath[MAX_PATH];
+
+    firstTime = 1;
+    cnode = dir;
+    websMakePath(path, _path, NULL, 1);
+    fh = FindFirstFile((LPCSTR)path, &findData);
+    while (fh != INVALID_HANDLE_VALUE) {
+        if ((strcmp(findData.cFileName, ".") == 0) ||
+                (strcmp(findData.cFileName, "..") == 0) ||
+                (findData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) ||
+                (findData.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)) {
+            goto nextFile;
+        }
+        nnode = balloc(B_L, sizeof(fileNode_t));
+        memset(nnode, 0x0, sizeof(fileNode_t));
+        if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
+            fmtAlloc(&(nnode->name), MAX_PATH, "%s/", findData.cFileName);
+            nnode->flags |= WHITELIST_DIR;
+        } else {
+            nnode->name = bstrdup(B_L, findData.cFileName);
+        }
+        if (firstTime) {
+            cnode->child = nnode;
+            firstTime = 0;
+        } else {
+            cnode->next = nnode;
+        }
+        cnode = nnode;
+        if (strncmp(path + strlen(websDefaultDir), "/" CGI_BIN, 
+                strlen(CGI_BIN) + 1) == 0) {
+            cnode->flags |= WHITELIST_CGI;
+        }
 #ifdef WEBS_SSL_SUPPORT
-		for (l = sslList; l != NULL; l = l->next) {
-			if (strncmp(path + strlen(websDefaultDir), l->url, 
-					strlen(l->url)) == 0) {
-				cnode->flags |= WHITELIST_SSL;
-			}
-		}
+        for (l = sslList; l != NULL; l = l->next) {
+            if (strncmp(path + strlen(websDefaultDir), l->url, 
+                    strlen(l->url)) == 0) {
+                cnode->flags |= WHITELIST_SSL;
+            }
+        }
 #endif /* WEBS_SSL_SUPPORT */
-		if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
-			websMakePath(tmppath, path, findData.cFileName, 1);
-			if (level < MAX_URL_DEPTH) {
-				if (websBuildWhitelistRecursive(tmppath, cnode, level + 1) < 0){
-					cnode->flags |= WHITELIST_BLOCKED;
-				}
-			}
-		}
+        if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
+            websMakePath(tmppath, path, findData.cFileName, 1);
+            if (level < MAX_URL_DEPTH) {
+                if (websBuildWhitelistRecursive(tmppath, cnode, level + 1) < 0){
+                    cnode->flags |= WHITELIST_BLOCKED;
+                }
+            }
+        }
 nextFile:
-		if (FindNextFile(fh, &findData) == 0) {
-			if (GetLastError() != ERROR_NO_MORE_FILES) {
-				rc = -1;
-			}
-			break;
-		}
-	}
-	FindClose(fh);
-	return rc;
+        if (FindNextFile(fh, &findData) == 0) {
+            if (GetLastError() != ERROR_NO_MORE_FILES) {
+                rc = -1;
+            }
+            break;
+        }
+    }
+    FindClose(fh);
+    return rc;
 }
 
 
@@ -750,115 +750,115 @@ nextFile:
 #else /* !WIN */
 static int websBuildWhitelistRecursive(char *_path, fileNode_t *dir, int level)
 {
-	struct dirent	*findData, *result;
-	DIR				*fh;
-	fileNode_t		*cnode, *nnode; /* current node, next node */
-	int		firstTime;
-	char	path[PATH_MAX];
-	char	tmppath[PATH_MAX];
-
-	firstTime = 1;
-	cnode = dir;
-	/* 
+    struct dirent   *findData, *result;
+    DIR             *fh;
+    fileNode_t      *cnode, *nnode; /* current node, next node */
+    int     firstTime;
+    char    path[PATH_MAX];
+    char    tmppath[PATH_MAX];
+
+    firstTime = 1;
+    cnode = dir;
+    /* 
         On some platforms such as Solaris, struct dirent includes only one byte for d_name field, meaning we would
         overflow the field when readdir_r is called.  So we check for this here.  Another potential issue is if somehow
         a filesystem is mounted or linked in a subdirectory or file that has name longer than PATH_MAX.  We ignore that
         possibility here, and leave it to the user to ensure that the wwwroot directory does not contain this
         configuration. http://womble.decadentplace.org.uk/readdir_r-advisory.html
-	 */ 
-	if (sizeof(struct dirent) > PATH_MAX) {
-		findData = balloc(B_L, sizeof(struct dirent));
-	} else {
-		findData = balloc(B_L, sizeof(struct dirent) + PATH_MAX);
-	}
-	websMakePath(path, _path, NULL, 0);
-	if ((fh = opendir(path)) == NULL) {
-		bfree(B_L, findData);
-		return -1;	/* Likely no permission to access this directory */
-	}
-	while ((readdir_r(fh, findData, &result) == 0) && result) {
-		if ((strcmp(findData->d_name, ".") == 0) || (strcmp(findData->d_name, "..") == 0) ||
-				(findData->d_type != DT_REG && findData->d_type != DT_DIR)) {
-			continue;
-		}
-		nnode = balloc(B_L, sizeof(fileNode_t));
-		memset(nnode, 0x0, sizeof(fileNode_t));
-		if (findData->d_type == DT_DIR) {
-			fmtAlloc(&(nnode->name), PATH_MAX, "%s/", findData->d_name);
-			nnode->flags |= WHITELIST_DIR;
-		} else {
-			nnode->name = bstrdup(B_L, findData->d_name);
-		}
-		if (firstTime) {
-			cnode->child = nnode;
-			firstTime = 0;
-		} else {
-			cnode->next = nnode;
-		}
-		cnode = nnode;
-		if (strncmp(path + strlen(websDefaultDir), "/" CGI_BIN, 
-				strlen(CGI_BIN) + 1) == 0) {
-			cnode->flags |= WHITELIST_CGI;
-		}
+     */ 
+    if (sizeof(struct dirent) > PATH_MAX) {
+        findData = balloc(B_L, sizeof(struct dirent));
+    } else {
+        findData = balloc(B_L, sizeof(struct dirent) + PATH_MAX);
+    }
+    websMakePath(path, _path, NULL, 0);
+    if ((fh = opendir(path)) == NULL) {
+        bfree(B_L, findData);
+        return -1;  /* Likely no permission to access this directory */
+    }
+    while ((readdir_r(fh, findData, &result) == 0) && result) {
+        if ((strcmp(findData->d_name, ".") == 0) || (strcmp(findData->d_name, "..") == 0) ||
+                (findData->d_type != DT_REG && findData->d_type != DT_DIR)) {
+            continue;
+        }
+        nnode = balloc(B_L, sizeof(fileNode_t));
+        memset(nnode, 0x0, sizeof(fileNode_t));
+        if (findData->d_type == DT_DIR) {
+            fmtAlloc(&(nnode->name), PATH_MAX, "%s/", findData->d_name);
+            nnode->flags |= WHITELIST_DIR;
+        } else {
+            nnode->name = bstrdup(B_L, findData->d_name);
+        }
+        if (firstTime) {
+            cnode->child = nnode;
+            firstTime = 0;
+        } else {
+            cnode->next = nnode;
+        }
+        cnode = nnode;
+        if (strncmp(path + strlen(websDefaultDir), "/" CGI_BIN, 
+                strlen(CGI_BIN) + 1) == 0) {
+            cnode->flags |= WHITELIST_CGI;
+        }
 #ifdef WEBS_SSL_SUPPORT
-		sslList_t	*l;
-		for (l = sslList; l != NULL; l = l->next) {
-			if (strncmp(path + strlen(websDefaultDir), l->url, strlen(l->url)) == 0) {
-				cnode->flags |= WHITELIST_SSL;
-				break;
-			}
-		}
+        sslList_t   *l;
+        for (l = sslList; l != NULL; l = l->next) {
+            if (strncmp(path + strlen(websDefaultDir), l->url, strlen(l->url)) == 0) {
+                cnode->flags |= WHITELIST_SSL;
+                break;
+            }
+        }
 #endif /* WEBS_SSL_SUPPORT */
-		if (findData->d_type == DT_DIR) {
-			websMakePath(tmppath, path, findData->d_name, 0);
-			if (level < MAX_URL_DEPTH) {
-				if (websBuildWhitelistRecursive(tmppath, cnode, level + 1) < 0){
-					cnode->flags |= WHITELIST_BLOCKED;
-				}
-			}
-		}
-	}
-	bfree(B_L, findData);
-	closedir(fh);
-	return 0;
+        if (findData->d_type == DT_DIR) {
+            websMakePath(tmppath, path, findData->d_name, 0);
+            if (level < MAX_URL_DEPTH) {
+                if (websBuildWhitelistRecursive(tmppath, cnode, level + 1) < 0){
+                    cnode->flags |= WHITELIST_BLOCKED;
+                }
+            }
+        }
+    }
+    bfree(B_L, findData);
+    closedir(fh);
+    return 0;
 }
 #endif /* WIN, LINUX, ETC */
 
 
 /*
-	Copy src to d,
-	Append subdir, if subdir != NULL,
-	Append '/' and '*' if wildcard != 0
+    Copy src to d,
+    Append subdir, if subdir != NULL,
+    Append '/' and '*' if wildcard != 0
 */
 static void websMakePath(char *d, char *src, char *subdir, int wildcard)
 {
-	int		max;
-	char	*a;
+    int     max;
+    char    *a;
 
 #if WIN
-	max = MAX_PATH - 4 - (subdir ? strlen(subdir) : 0);
+    max = MAX_PATH - 4 - (subdir ? strlen(subdir) : 0);
 #else
-	max = PATH_MAX - 4 - (subdir ? strlen(subdir) : 0);
+    max = PATH_MAX - 4 - (subdir ? strlen(subdir) : 0);
 #endif
-	for (a = src; *a != '\0' && (int)(a - src) < max; a++, d++) {
-		*d = *a;
-	}
-	if (*(d - 1) == '*') d -= 1;
-	if (subdir) {
-		if (*(d - 1) != '/') {
-			*d = '/'; d++;
-		}
-		for (a = subdir; *a != '\0'; a++) {
-			*d = *a; d++;
-		}
-	}
-	if (*(d - 1) != '/') {
-		*d = '/'; d++;
-	}
-	if (wildcard) {
-		*d = '*'; d++;
-	}
-	*d = '\0';
+    for (a = src; *a != '\0' && (int)(a - src) < max; a++, d++) {
+        *d = *a;
+    }
+    if (*(d - 1) == '*') d -= 1;
+    if (subdir) {
+        if (*(d - 1) != '/') {
+            *d = '/'; d++;
+        }
+        for (a = subdir; *a != '\0'; a++) {
+            *d = *a; d++;
+        }
+    }
+    if (*(d - 1) != '/') {
+        *d = '/'; d++;
+    }
+    if (wildcard) {
+        *d = '*'; d++;
+    }
+    *d = '\0';
 }
 
 #endif /* WEBS_WHITELIST_SUPPORT */
diff --git a/ej.h b/ej.h
index 6f022fdb..5449698b 100644
--- a/ej.h
+++ b/ej.h
@@ -1,5 +1,5 @@
 /* 
-  	ej.h -- Ejscript header
+    ej.h -- Ejscript header
   
     Copyright (c) All Rights Reserved. See details at the end of the file.
  */
@@ -14,18 +14,18 @@
 
 /********************************* Includes ***********************************/
 
-#include	"uemf.h"
+#include    "uemf.h"
 
 /******************************** Prototypes **********************************/
 
-extern int 		ejArgs(int argc, char_t **argv, char_t *fmt, ...);
-extern void		ejSetResult(int eid, char_t *s);
-extern int		ejOpenEngine(sym_fd_t variables, sym_fd_t functions);
-extern void		ejCloseEngine(int eid);
-extern int 		ejSetGlobalFunction(int eid, char_t *name, int (*fn)(int eid, void *handle, int argc, char_t **argv));
-extern void		ejSetVar(int eid, char_t *var, char_t *value);
-extern int		ejGetVar(int eid, char_t *var, char_t **value);
-extern char_t	*ejEval(int eid, char_t *script, char_t **emsg);
+extern int      ejArgs(int argc, char_t **argv, char_t *fmt, ...);
+extern void     ejSetResult(int eid, char_t *s);
+extern int      ejOpenEngine(sym_fd_t variables, sym_fd_t functions);
+extern void     ejCloseEngine(int eid);
+extern int      ejSetGlobalFunction(int eid, char_t *name, int (*fn)(int eid, void *handle, int argc, char_t **argv));
+extern void     ejSetVar(int eid, char_t *var, char_t *value);
+extern int      ejGetVar(int eid, char_t *var, char_t **value);
+extern char_t   *ejEval(int eid, char_t *script, char_t **emsg);
 
 #endif /* _h_EJ */
 
diff --git a/ejIntrn.h b/ejIntrn.h
index 03305e19..8a471e64 100644
--- a/ejIntrn.h
+++ b/ejIntrn.h
@@ -1,5 +1,5 @@
 /* 
-  	ejIntrn.h -- Internal Ejscript header
+    ejIntrn.h -- Internal Ejscript header
 
     Copyright (c) All Rights Reserved. See details at the end of the file.
  */
@@ -9,196 +9,196 @@
 
 /********************************* Includes ***********************************/
 
-#include	<ctype.h>
-#include	<stdarg.h>
-#include	<stdlib.h>
+#include    <ctype.h>
+#include    <stdarg.h>
+#include    <stdlib.h>
 
 #ifdef WIN32
-	#include	<share.h>
+    #include    <share.h>
 #endif
 
 #ifdef LYNX
-	#include	<unistd.h>
+    #include    <unistd.h>
 #endif
 
 #ifdef QNX4
-	#include	<dirent.h>
+    #include    <dirent.h>
 #endif
 
-#include	"uemf.h"
-#include	"ej.h"
+#include    "uemf.h"
+#include    "ej.h"
 
 /********************************** Defines ***********************************/
 /*
-  	Constants
+    Constants
  */
-#define EJ_INC				110		/* Growth for tags/tokens */
-#define EJ_SCRIPT_INC		1023	/* Growth for ej scripts */
-#define EJ_OFFSET			1		/* hAlloc doesn't like 0 entries */
-#define EJ_MAX_RECURSE		100		/* Sanity for maximum recursion */
+#define EJ_INC              110     /* Growth for tags/tokens */
+#define EJ_SCRIPT_INC       1023    /* Growth for ej scripts */
+#define EJ_OFFSET           1       /* hAlloc doesn't like 0 entries */
+#define EJ_MAX_RECURSE      100     /* Sanity for maximum recursion */
 
 /*
-  	Ejscript Lexical analyser tokens
+    Ejscript Lexical analyser tokens
  */
-#define TOK_ERR				-1		/* Any error */
-#define TOK_LPAREN			1		/* ( */
-#define TOK_RPAREN			2		/* ) */
-#define TOK_IF				3		/* if */
-#define TOK_ELSE			4		/* else */
-#define TOK_LBRACE			5		/* { */
-#define TOK_RBRACE			6		/* } */
-#define TOK_LOGICAL			7		/* ||, &&, ! */
-#define TOK_EXPR			8		/* +, -, /, % */
-#define TOK_SEMI			9		/* ; */
-#define TOK_LITERAL			10		/* literal string */
-#define TOK_FUNCTION		11		/* function name */
-#define TOK_NEWLINE			12		/* newline white space */
-#define TOK_ID				13		/* function name */
-#define TOK_EOF				14		/* End of script */
-#define TOK_COMMA			15		/* Comma */
-#define TOK_VAR				16		/* var */
-#define TOK_ASSIGNMENT		17		/* = */
-#define TOK_FOR				18		/* for */
-#define TOK_INC_DEC			19		/* ++, -- */
-#define TOK_RETURN			20		/* return */
+#define TOK_ERR             -1      /* Any error */
+#define TOK_LPAREN          1       /* ( */
+#define TOK_RPAREN          2       /* ) */
+#define TOK_IF              3       /* if */
+#define TOK_ELSE            4       /* else */
+#define TOK_LBRACE          5       /* { */
+#define TOK_RBRACE          6       /* } */
+#define TOK_LOGICAL         7       /* ||, &&, ! */
+#define TOK_EXPR            8       /* +, -, /, % */
+#define TOK_SEMI            9       /* ; */
+#define TOK_LITERAL         10      /* literal string */
+#define TOK_FUNCTION        11      /* function name */
+#define TOK_NEWLINE         12      /* newline white space */
+#define TOK_ID              13      /* function name */
+#define TOK_EOF             14      /* End of script */
+#define TOK_COMMA           15      /* Comma */
+#define TOK_VAR             16      /* var */
+#define TOK_ASSIGNMENT      17      /* = */
+#define TOK_FOR             18      /* for */
+#define TOK_INC_DEC         19      /* ++, -- */
+#define TOK_RETURN          20      /* return */
 
 /*
-  	Expression operators
+    Expression operators
  */
-#define EXPR_LESS			1		/* < */
-#define EXPR_LESSEQ			2		/* <= */
-#define EXPR_GREATER		3		/* > */
-#define EXPR_GREATEREQ		4		/* >= */
-#define EXPR_EQ				5		/* == */
-#define EXPR_NOTEQ			6		/* != */
-#define EXPR_PLUS			7		/* + */
-#define EXPR_MINUS			8		/* - */
-#define EXPR_DIV			9		/* / */
-#define EXPR_MOD			10		/* % */
-#define EXPR_LSHIFT			11		/* << */
-#define EXPR_RSHIFT			12		/* >> */
-#define EXPR_MUL			13		/* * */
-#define EXPR_ASSIGNMENT		14		/* = */
-#define EXPR_INC			15		/* ++ */
-#define EXPR_DEC			16		/* -- */
-#define EXPR_BOOL_COMP		17		/* ! */
+#define EXPR_LESS           1       /* < */
+#define EXPR_LESSEQ         2       /* <= */
+#define EXPR_GREATER        3       /* > */
+#define EXPR_GREATEREQ      4       /* >= */
+#define EXPR_EQ             5       /* == */
+#define EXPR_NOTEQ          6       /* != */
+#define EXPR_PLUS           7       /* + */
+#define EXPR_MINUS          8       /* - */
+#define EXPR_DIV            9       /* / */
+#define EXPR_MOD            10      /* % */
+#define EXPR_LSHIFT         11      /* << */
+#define EXPR_RSHIFT         12      /* >> */
+#define EXPR_MUL            13      /* * */
+#define EXPR_ASSIGNMENT     14      /* = */
+#define EXPR_INC            15      /* ++ */
+#define EXPR_DEC            16      /* -- */
+#define EXPR_BOOL_COMP      17      /* ! */
 /*
-  	Conditional operators
+    Conditional operators
  */
-#define COND_AND			1		/* && */
-#define COND_OR				2		/* || */
-#define COND_NOT			3		/* ! */
+#define COND_AND            1       /* && */
+#define COND_OR             2       /* || */
+#define COND_NOT            3       /* ! */
 
 /*
-  	States
+    States
  */
-#define STATE_ERR				-1			/* Error state */
-#define STATE_EOF				1			/* End of file */
-#define STATE_COND				2			/* Parsing a "(conditional)" stmt */
-#define STATE_COND_DONE			3
-#define STATE_RELEXP			4			/* Parsing a relational expr */
-#define STATE_RELEXP_DONE		5
-#define STATE_EXPR				6			/* Parsing an expression */
-#define STATE_EXPR_DONE			7
-#define STATE_STMT				8			/* Parsing General statement */
-#define STATE_STMT_DONE			9
-#define STATE_STMT_BLOCK_DONE	10			/* End of block "}" */
-#define STATE_ARG_LIST			11			/* Function arg list */
-#define STATE_ARG_LIST_DONE		12
-#define STATE_DEC_LIST			16			/* Declaration list */
-#define STATE_DEC_LIST_DONE		17
-#define STATE_DEC				18
-#define STATE_DEC_DONE			19
-
-#define STATE_RET				20			/* Return statement */
-
-#define STATE_BEGIN				STATE_STMT
+#define STATE_ERR               -1          /* Error state */
+#define STATE_EOF               1           /* End of file */
+#define STATE_COND              2           /* Parsing a "(conditional)" stmt */
+#define STATE_COND_DONE         3
+#define STATE_RELEXP            4           /* Parsing a relational expr */
+#define STATE_RELEXP_DONE       5
+#define STATE_EXPR              6           /* Parsing an expression */
+#define STATE_EXPR_DONE         7
+#define STATE_STMT              8           /* Parsing General statement */
+#define STATE_STMT_DONE         9
+#define STATE_STMT_BLOCK_DONE   10          /* End of block "}" */
+#define STATE_ARG_LIST          11          /* Function arg list */
+#define STATE_ARG_LIST_DONE     12
+#define STATE_DEC_LIST          16          /* Declaration list */
+#define STATE_DEC_LIST_DONE     17
+#define STATE_DEC               18
+#define STATE_DEC_DONE          19
+
+#define STATE_RET               20          /* Return statement */
+
+#define STATE_BEGIN             STATE_STMT
 
 /*
-  	Flags. Used in ej_t and as parameter to parse()
+    Flags. Used in ej_t and as parameter to parse()
  */
-#define FLAGS_EXE				0x1				/* Execute statements */
-#define FLAGS_VARIABLES			0x2				/* Allocated variables store */
-#define FLAGS_FUNCTIONS			0x4				/* Allocated function store */
+#define FLAGS_EXE               0x1             /* Execute statements */
+#define FLAGS_VARIABLES         0x2             /* Allocated variables store */
+#define FLAGS_FUNCTIONS         0x4             /* Allocated function store */
 
 /*
-  	Function call structure
+    Function call structure
  */
 typedef struct {
-	char_t		*fname;							/* Function name */
-	char_t		**args;							/* Args for function (halloc) */
-	int			nArgs;							/* Number of args */
+    char_t      *fname;                         /* Function name */
+    char_t      **args;                         /* Args for function (halloc) */
+    int         nArgs;                          /* Number of args */
 } ejfunc_t;
 
 /*
-  	EJ evaluation block structure
+    EJ evaluation block structure
  */
 typedef struct ejEval {
-	ringq_t		tokbuf;							/* Current token */
-	ringq_t		script;							/* Input script for parsing */
-	char_t		*putBackToken;					/* Putback token string */
-	int			putBackTokenId;					/* Putback token ID */
-	char_t		*line;							/* Current line */
-	int			lineLength;						/* Current line length */
-	int			lineNumber;						/* Parse line number */
-	int			lineColumn;						/* Column in line */
+    ringq_t     tokbuf;                         /* Current token */
+    ringq_t     script;                         /* Input script for parsing */
+    char_t      *putBackToken;                  /* Putback token string */
+    int         putBackTokenId;                 /* Putback token ID */
+    char_t      *line;                          /* Current line */
+    int         lineLength;                     /* Current line length */
+    int         lineNumber;                     /* Parse line number */
+    int         lineColumn;                     /* Column in line */
 } ejinput_t;
 
 /*
-  	Per Ejscript session structure
+    Per Ejscript session structure
  */
 typedef struct ej {
-	ejinput_t	*input;							/* Input evaluation block */
-	sym_fd_t	functions;						/* Symbol table for functions */
-	sym_fd_t	*variables;						/* hAlloc list of variables */
-	int			variableMax;					/* Number of entries */
-	ejfunc_t	*func;							/* Current function */
-	char_t		*result;						/* Current expression result */
-	char_t		*error;							/* Error message */
-	char_t		*token;							/* Pointer to token string */
-	int			tid;							/* Current token id */
-	int			eid;							/* Halloc handle */
-	int			flags;							/* Flags */
-	void		*userHandle;					/* User defined handle */
+    ejinput_t   *input;                         /* Input evaluation block */
+    sym_fd_t    functions;                      /* Symbol table for functions */
+    sym_fd_t    *variables;                     /* hAlloc list of variables */
+    int         variableMax;                    /* Number of entries */
+    ejfunc_t    *func;                          /* Current function */
+    char_t      *result;                        /* Current expression result */
+    char_t      *error;                         /* Error message */
+    char_t      *token;                         /* Pointer to token string */
+    int         tid;                            /* Current token id */
+    int         eid;                            /* Halloc handle */
+    int         flags;                          /* Flags */
+    void        *userHandle;                    /* User defined handle */
 } ej_t;
 
 /******************************** Prototypes **********************************/
 
-extern int		ejOpenBlock(int eid);
-extern int		ejCloseBlock(int eid, int vid);
-extern char_t	*ejEvalBlock(int eid, char_t *script, char_t **emsg);
+extern int      ejOpenBlock(int eid);
+extern int      ejCloseBlock(int eid, int vid);
+extern char_t   *ejEvalBlock(int eid, char_t *script, char_t **emsg);
 
 #ifndef __NO_EJ_FILE
-extern char_t	*ejEvalFile(int eid, char_t *path, char_t **emsg);
+extern char_t   *ejEvalFile(int eid, char_t *path, char_t **emsg);
 #endif
 
-extern int		ejRemoveGlobalFunction(int eid, char_t *name);
-extern void		*ejGetGlobalFunction(int eid, char_t *name);
-extern int 		ejSetGlobalFunctionDirect(sym_fd_t functions, char_t *name, 
-					int (*fn)(int eid, void *handle, int argc, char_t **argv));
-extern void 	ejError(ej_t* ep, char_t* fmt, ...);
-extern void		ejSetUserHandle(int eid, void* handle);
-extern void		*ejGetUserHandle(int eid);
-extern int		ejGetLineNumber(int eid);
-extern char_t	*ejGetResult(int eid);
-extern void		ejSetLocalVar(int eid, char_t *var, char_t *value);
-extern void		ejSetGlobalVar(int eid, char_t *var, char_t *value);
-
-extern int 		ejLexOpen(ej_t* ep);
-extern void 	ejLexClose(ej_t* ep);
-extern int	 	ejLexOpenScript(ej_t* ep, char_t *script);
-extern void 	ejLexCloseScript(ej_t* ep);
-extern void 	ejLexSaveInputState(ej_t* ep, ejinput_t* state);
-extern void 	ejLexFreeInputState(ej_t* ep, ejinput_t* state);
-extern void 	ejLexRestoreInputState(ej_t* ep, ejinput_t* state);
-extern int		ejLexGetToken(ej_t* ep, int state);
-extern void		ejLexPutbackToken(ej_t* ep, int tid, char_t *string);
-
-extern sym_fd_t	ejGetVariableTable(int eid);
-extern sym_fd_t	ejGetFunctionTable(int eid);
-
-extern int		ejEmfOpen(int eid);
-extern void		ejEmfClose(int eid);
+extern int      ejRemoveGlobalFunction(int eid, char_t *name);
+extern void     *ejGetGlobalFunction(int eid, char_t *name);
+extern int      ejSetGlobalFunctionDirect(sym_fd_t functions, char_t *name, 
+                    int (*fn)(int eid, void *handle, int argc, char_t **argv));
+extern void     ejError(ej_t* ep, char_t* fmt, ...);
+extern void     ejSetUserHandle(int eid, void* handle);
+extern void     *ejGetUserHandle(int eid);
+extern int      ejGetLineNumber(int eid);
+extern char_t   *ejGetResult(int eid);
+extern void     ejSetLocalVar(int eid, char_t *var, char_t *value);
+extern void     ejSetGlobalVar(int eid, char_t *var, char_t *value);
+
+extern int      ejLexOpen(ej_t* ep);
+extern void     ejLexClose(ej_t* ep);
+extern int      ejLexOpenScript(ej_t* ep, char_t *script);
+extern void     ejLexCloseScript(ej_t* ep);
+extern void     ejLexSaveInputState(ej_t* ep, ejinput_t* state);
+extern void     ejLexFreeInputState(ej_t* ep, ejinput_t* state);
+extern void     ejLexRestoreInputState(ej_t* ep, ejinput_t* state);
+extern int      ejLexGetToken(ej_t* ep, int state);
+extern void     ejLexPutbackToken(ej_t* ep, int tid, char_t *string);
+
+extern sym_fd_t ejGetVariableTable(int eid);
+extern sym_fd_t ejGetFunctionTable(int eid);
+
+extern int      ejEmfOpen(int eid);
+extern void     ejEmfClose(int eid);
 
 extern int ejEmfDbRead(int eid, void *handle, int argc, char_t **argv);
 extern int ejEmfDbReadKeyed(int eid, void *handle, int argc, char_t **argv);
diff --git a/ejlex.c b/ejlex.c
index a77e2ef4..870e27cb 100644
--- a/ejlex.c
+++ b/ejlex.c
@@ -8,26 +8,26 @@
 
 /********************************** Includes **********************************/
 
-#include	"ejIntrn.h"
+#include    "ejIntrn.h"
 
 #include "uemf.h"
 
 /********************************** Defines ***********************************/
-#define		OCTAL	8
-#define		HEX		16
+#define     OCTAL   8
+#define     HEX     16
 /****************************** Forward Declarations **************************/
 
-static int 		getLexicalToken(ej_t* ep, int state);
-static int 		tokenAddChar(ej_t *ep, int c);
-static int 		inputGetc(ej_t* ep);
-static void		inputPutback(ej_t* ep, int c);
-static int		charConvert(ej_t* ep, int base, int maxDig);
+static int      getLexicalToken(ej_t* ep, int state);
+static int      tokenAddChar(ej_t *ep, int c);
+static int      inputGetc(ej_t* ep);
+static void     inputPutback(ej_t* ep, int c);
+static int      charConvert(ej_t* ep, int base, int maxDig);
 
 /************************************* Code ***********************************/
 
 int ejLexOpen(ej_t* ep)
 {
-	return 0;
+    return 0;
 }
 
 
@@ -38,568 +38,568 @@ void ejLexClose(ej_t* ep)
 
 int ejLexOpenScript(ej_t* ep, char_t *script)
 {
-	ejinput_t	*ip;
+    ejinput_t   *ip;
 
-	a_assert(ep);
-	a_assert(script);
+    a_assert(ep);
+    a_assert(script);
 
-	if ((ep->input = balloc(B_L, sizeof(ejinput_t))) == NULL) {
-		return -1;
-	}
-	ip = ep->input;
-	memset(ip, 0, sizeof(*ip));
+    if ((ep->input = balloc(B_L, sizeof(ejinput_t))) == NULL) {
+        return -1;
+    }
+    ip = ep->input;
+    memset(ip, 0, sizeof(*ip));
 
-	a_assert(ip);
-	a_assert(ip->putBackToken == NULL);
-	a_assert(ip->putBackTokenId == 0);
+    a_assert(ip);
+    a_assert(ip->putBackToken == NULL);
+    a_assert(ip->putBackTokenId == 0);
 
     /*
         Create the parse token buffer and script buffer
      */
-	if (ringqOpen(&ip->tokbuf, EJ_INC, -1) < 0) {
-		return -1;
-	}
-	if (ringqOpen(&ip->script, EJ_SCRIPT_INC, -1) < 0) {
-		return -1;
-	}
+    if (ringqOpen(&ip->tokbuf, EJ_INC, -1) < 0) {
+        return -1;
+    }
+    if (ringqOpen(&ip->script, EJ_SCRIPT_INC, -1) < 0) {
+        return -1;
+    }
     /*
         Put the Ejscript into a ring queue for easy parsing
      */
-	ringqPutStr(&ip->script, script);
+    ringqPutStr(&ip->script, script);
 
-	ip->lineNumber = 1;
-	ip->lineLength = 0;
-	ip->lineColumn = 0;
-	ip->line = NULL;
+    ip->lineNumber = 1;
+    ip->lineLength = 0;
+    ip->lineColumn = 0;
+    ip->line = NULL;
 
-	return 0;
+    return 0;
 }
 
 
 void ejLexCloseScript(ej_t* ep)
 {
-	ejinput_t	*ip;
-
-	a_assert(ep);
-
-	ip = ep->input;
-	a_assert(ip);
-
-	if (ip->putBackToken) {
-		bfree(B_L, ip->putBackToken);
-		ip->putBackToken = NULL;
-	}
-	ip->putBackTokenId = 0;
-
-	if (ip->line) {
-		bfree(B_L, ip->line);
-		ip->line = NULL;
-	}
-	ringqClose(&ip->tokbuf);
-	ringqClose(&ip->script);
-	bfree(B_L, ip);
+    ejinput_t   *ip;
+
+    a_assert(ep);
+
+    ip = ep->input;
+    a_assert(ip);
+
+    if (ip->putBackToken) {
+        bfree(B_L, ip->putBackToken);
+        ip->putBackToken = NULL;
+    }
+    ip->putBackTokenId = 0;
+
+    if (ip->line) {
+        bfree(B_L, ip->line);
+        ip->line = NULL;
+    }
+    ringqClose(&ip->tokbuf);
+    ringqClose(&ip->script);
+    bfree(B_L, ip);
 }
 
 
 void ejLexSaveInputState(ej_t* ep, ejinput_t* state)
 {
-	ejinput_t	*ip;
+    ejinput_t   *ip;
 
-	a_assert(ep);
+    a_assert(ep);
 
-	ip = ep->input;
-	a_assert(ip);
+    ip = ep->input;
+    a_assert(ip);
 
-	*state = *ip;
-	if (ip->putBackToken) {
-		state->putBackToken = bstrdup(B_L, ip->putBackToken);
-	}
+    *state = *ip;
+    if (ip->putBackToken) {
+        state->putBackToken = bstrdup(B_L, ip->putBackToken);
+    }
 }
 
 
 void ejLexRestoreInputState(ej_t* ep, ejinput_t* state)
 {
-	ejinput_t	*ip;
-
-	a_assert(ep);
-
-	ip = ep->input;
-	a_assert(ip);
-
-	ip->tokbuf = state->tokbuf;
-	ip->script = state->script;
-	ip->putBackTokenId = state->putBackTokenId;
-	if (ip->putBackToken) {
-		bfree(B_L, ip->putBackToken);
-	}
-	if (state->putBackToken) {
-		ip->putBackToken = bstrdup(B_L, state->putBackToken);
-	}
+    ejinput_t   *ip;
+
+    a_assert(ep);
+
+    ip = ep->input;
+    a_assert(ip);
+
+    ip->tokbuf = state->tokbuf;
+    ip->script = state->script;
+    ip->putBackTokenId = state->putBackTokenId;
+    if (ip->putBackToken) {
+        bfree(B_L, ip->putBackToken);
+    }
+    if (state->putBackToken) {
+        ip->putBackToken = bstrdup(B_L, state->putBackToken);
+    }
 }
 
 
 void ejLexFreeInputState(ej_t* ep, ejinput_t* state)
 {
-	if (state->putBackToken) {
-		bfree(B_L, state->putBackToken);
-		state->putBackToken = NULL;
-	}
+    if (state->putBackToken) {
+        bfree(B_L, state->putBackToken);
+        state->putBackToken = NULL;
+    }
 }
 
 
 int ejLexGetToken(ej_t* ep, int state)
 {
-	ep->tid = getLexicalToken(ep, state);
-	return ep->tid;
+    ep->tid = getLexicalToken(ep, state);
+    return ep->tid;
 }
 
 
 static int getLexicalToken(ej_t* ep, int state)
 {
-	ringq_t		*inq, *tokq;
-	ejinput_t*	ip;
-	int			done, tid, c, quote, style;
-
-	a_assert(ep);
-	ip = ep->input;
-	a_assert(ip);
-
-	inq = &ip->script;
-	tokq = &ip->tokbuf;
-	ep->tid = -1;
-	tid = -1;
-	ep->token = T("");
-	ringqFlush(tokq);
-
-	if (ip->putBackTokenId > 0) {
-		ringqPutStr(tokq, ip->putBackToken);
-		tid = ip->putBackTokenId;
-		ip->putBackTokenId = 0;
-		ep->token = (char_t*) tokq->servp;
-		return tid;
-	}
-	if ((c = inputGetc(ep)) < 0) {
-		return TOK_EOF;
-	}
-	for (done = 0; !done; ) {
-		switch (c) {
-		case -1:
-			return TOK_EOF;
-
-		case ' ':
-		case '\t':
-		case '\r':
-			do {
-				if ((c = inputGetc(ep)) < 0)
-					break;
-			} while (c == ' ' || c == '\t' || c == '\r');
-			break;
-
-		case '\n':
-			return TOK_NEWLINE;
-
-		case '(':
-			tokenAddChar(ep, c);
-			return TOK_LPAREN;
-
-		case ')':
-			tokenAddChar(ep, c);
-			return TOK_RPAREN;
-
-		case '{':
-			tokenAddChar(ep, c);
-			return TOK_LBRACE;
-
-		case '}':
-			tokenAddChar(ep, c);
-			return TOK_RBRACE;
-
-		case '+':
-			if ((c = inputGetc(ep)) < 0) {
-				ejError(ep, T("Syntax Error"));
-				return TOK_ERR;
-			}
-			if (c != '+' ) {
-				inputPutback(ep, c);
-				tokenAddChar(ep, EXPR_PLUS);
-				return TOK_EXPR;
-			}
-			tokenAddChar(ep, EXPR_INC);
-			return TOK_INC_DEC;
-
-		case '-':
-			if ((c = inputGetc(ep)) < 0) {
-				ejError(ep, T("Syntax Error"));
-				return TOK_ERR;
-			}
-			if (c != '-' ) {
-				inputPutback(ep, c);
-				tokenAddChar(ep, EXPR_MINUS);
-				return TOK_EXPR;
-			}
-			tokenAddChar(ep, EXPR_DEC);
-			return TOK_INC_DEC;
-
-		case '*':
-			tokenAddChar(ep, EXPR_MUL);
-			return TOK_EXPR;
-
-		case '%':
-			tokenAddChar(ep, EXPR_MOD);
-			return TOK_EXPR;
-
-		case '/':
+    ringq_t     *inq, *tokq;
+    ejinput_t*  ip;
+    int         done, tid, c, quote, style;
+
+    a_assert(ep);
+    ip = ep->input;
+    a_assert(ip);
+
+    inq = &ip->script;
+    tokq = &ip->tokbuf;
+    ep->tid = -1;
+    tid = -1;
+    ep->token = T("");
+    ringqFlush(tokq);
+
+    if (ip->putBackTokenId > 0) {
+        ringqPutStr(tokq, ip->putBackToken);
+        tid = ip->putBackTokenId;
+        ip->putBackTokenId = 0;
+        ep->token = (char_t*) tokq->servp;
+        return tid;
+    }
+    if ((c = inputGetc(ep)) < 0) {
+        return TOK_EOF;
+    }
+    for (done = 0; !done; ) {
+        switch (c) {
+        case -1:
+            return TOK_EOF;
+
+        case ' ':
+        case '\t':
+        case '\r':
+            do {
+                if ((c = inputGetc(ep)) < 0)
+                    break;
+            } while (c == ' ' || c == '\t' || c == '\r');
+            break;
+
+        case '\n':
+            return TOK_NEWLINE;
+
+        case '(':
+            tokenAddChar(ep, c);
+            return TOK_LPAREN;
+
+        case ')':
+            tokenAddChar(ep, c);
+            return TOK_RPAREN;
+
+        case '{':
+            tokenAddChar(ep, c);
+            return TOK_LBRACE;
+
+        case '}':
+            tokenAddChar(ep, c);
+            return TOK_RBRACE;
+
+        case '+':
+            if ((c = inputGetc(ep)) < 0) {
+                ejError(ep, T("Syntax Error"));
+                return TOK_ERR;
+            }
+            if (c != '+' ) {
+                inputPutback(ep, c);
+                tokenAddChar(ep, EXPR_PLUS);
+                return TOK_EXPR;
+            }
+            tokenAddChar(ep, EXPR_INC);
+            return TOK_INC_DEC;
+
+        case '-':
+            if ((c = inputGetc(ep)) < 0) {
+                ejError(ep, T("Syntax Error"));
+                return TOK_ERR;
+            }
+            if (c != '-' ) {
+                inputPutback(ep, c);
+                tokenAddChar(ep, EXPR_MINUS);
+                return TOK_EXPR;
+            }
+            tokenAddChar(ep, EXPR_DEC);
+            return TOK_INC_DEC;
+
+        case '*':
+            tokenAddChar(ep, EXPR_MUL);
+            return TOK_EXPR;
+
+        case '%':
+            tokenAddChar(ep, EXPR_MOD);
+            return TOK_EXPR;
+
+        case '/':
             /*
                 Handle the division operator and comments
              */
-			if ((c = inputGetc(ep)) < 0) {
-				ejError(ep, T("Syntax Error"));
-				return TOK_ERR;
-			}
-			if (c != '*' && c != '/') {
-				inputPutback(ep, c);
-				tokenAddChar(ep, EXPR_DIV);
-				return TOK_EXPR;
-			}
-			style = c;
+            if ((c = inputGetc(ep)) < 0) {
+                ejError(ep, T("Syntax Error"));
+                return TOK_ERR;
+            }
+            if (c != '*' && c != '/') {
+                inputPutback(ep, c);
+                tokenAddChar(ep, EXPR_DIV);
+                return TOK_EXPR;
+            }
+            style = c;
             /*
                 Eat comments. Both C and C++ comment styles are supported.
              */
-			while (1) {
-				if ((c = inputGetc(ep)) < 0) {
-					ejError(ep, T("Syntax Error"));
-					return TOK_ERR;
-				}
-				if (c == '\n' && style == '/') {
-					break;
-				} else if (c == '*') {
-					c = inputGetc(ep);
-					if (style == '/') {
-						if (c == '\n') {
-							break;
-						}
-					} else {
-						if (c == '/') {
-							break;
-						}
-					}
-				}
-			}
+            while (1) {
+                if ((c = inputGetc(ep)) < 0) {
+                    ejError(ep, T("Syntax Error"));
+                    return TOK_ERR;
+                }
+                if (c == '\n' && style == '/') {
+                    break;
+                } else if (c == '*') {
+                    c = inputGetc(ep);
+                    if (style == '/') {
+                        if (c == '\n') {
+                            break;
+                        }
+                    } else {
+                        if (c == '/') {
+                            break;
+                        }
+                    }
+                }
+            }
             /*
                 Continue looking for a token, so get the next character
              */
-			if ((c = inputGetc(ep)) < 0) {
-				return TOK_EOF;
-			}
-			break;
-
-		case '<':									/* < and <= */
-			if ((c = inputGetc(ep)) < 0) {
-				ejError(ep, T("Syntax Error"));
-				return TOK_ERR;
-			}
-			if (c == '<') {
-				tokenAddChar(ep, EXPR_LSHIFT);
-				return TOK_EXPR;
-			} else if (c == '=') {
-				tokenAddChar(ep, EXPR_LESSEQ);
-				return TOK_EXPR;
-			}
-			tokenAddChar(ep, EXPR_LESS);
-			inputPutback(ep, c);
-			return TOK_EXPR;
-
-		case '>':									/* > and >= */
-			if ((c = inputGetc(ep)) < 0) {
-				ejError(ep, T("Syntax Error"));
-				return TOK_ERR;
-			}
-			if (c == '>') {
-				tokenAddChar(ep, EXPR_RSHIFT);
-				return TOK_EXPR;
-			} else if (c == '=') {
-				tokenAddChar(ep, EXPR_GREATEREQ);
-				return TOK_EXPR;
-			}
-			tokenAddChar(ep, EXPR_GREATER);
-			inputPutback(ep, c);
-			return TOK_EXPR;
-
-		case '=':									/* "==" */
-			if ((c = inputGetc(ep)) < 0) {
-				ejError(ep, T("Syntax Error"));
-				return TOK_ERR;
-			}
-			if (c == '=') {
-				tokenAddChar(ep, EXPR_EQ);
-				return TOK_EXPR;
-			}
-			inputPutback(ep, c);
-			return TOK_ASSIGNMENT;
-
-		case '!':									/* "!=" or "!"*/
-			if ((c = inputGetc(ep)) < 0) {
-				ejError(ep, T("Syntax Error"));
-				return TOK_ERR;
-			}
-			if (c == '=') {
-				tokenAddChar(ep, EXPR_NOTEQ);
-				return TOK_EXPR;
-			}
-			inputPutback(ep, c);
-			tokenAddChar(ep, EXPR_BOOL_COMP);
-			return TOK_EXPR;
-
-		case ';':
-			tokenAddChar(ep, c);
-			return TOK_SEMI;
-
-		case ',':
-			tokenAddChar(ep, c);
-			return TOK_COMMA;
-
-		case '|':									/* "||" */
-			if ((c = inputGetc(ep)) < 0 || c != '|') {
-				ejError(ep, T("Syntax Error"));
-				return TOK_ERR;
-			}
-			tokenAddChar(ep, COND_OR);
-			return TOK_LOGICAL;
-
-		case '&':									/* "&&" */
-			if ((c = inputGetc(ep)) < 0 || c != '&') {
-				ejError(ep, T("Syntax Error"));
-				return TOK_ERR;
-			}
-			tokenAddChar(ep, COND_AND);
-			return TOK_LOGICAL;
-
-		case '\"':									/* String quote */
-		case '\'':
-			quote = c;
-			if ((c = inputGetc(ep)) < 0) {
-				ejError(ep, T("Syntax Error"));
-				return TOK_ERR;
-			}
-
-			while (c != quote) {
+            if ((c = inputGetc(ep)) < 0) {
+                return TOK_EOF;
+            }
+            break;
+
+        case '<':                                   /* < and <= */
+            if ((c = inputGetc(ep)) < 0) {
+                ejError(ep, T("Syntax Error"));
+                return TOK_ERR;
+            }
+            if (c == '<') {
+                tokenAddChar(ep, EXPR_LSHIFT);
+                return TOK_EXPR;
+            } else if (c == '=') {
+                tokenAddChar(ep, EXPR_LESSEQ);
+                return TOK_EXPR;
+            }
+            tokenAddChar(ep, EXPR_LESS);
+            inputPutback(ep, c);
+            return TOK_EXPR;
+
+        case '>':                                   /* > and >= */
+            if ((c = inputGetc(ep)) < 0) {
+                ejError(ep, T("Syntax Error"));
+                return TOK_ERR;
+            }
+            if (c == '>') {
+                tokenAddChar(ep, EXPR_RSHIFT);
+                return TOK_EXPR;
+            } else if (c == '=') {
+                tokenAddChar(ep, EXPR_GREATEREQ);
+                return TOK_EXPR;
+            }
+            tokenAddChar(ep, EXPR_GREATER);
+            inputPutback(ep, c);
+            return TOK_EXPR;
+
+        case '=':                                   /* "==" */
+            if ((c = inputGetc(ep)) < 0) {
+                ejError(ep, T("Syntax Error"));
+                return TOK_ERR;
+            }
+            if (c == '=') {
+                tokenAddChar(ep, EXPR_EQ);
+                return TOK_EXPR;
+            }
+            inputPutback(ep, c);
+            return TOK_ASSIGNMENT;
+
+        case '!':                                   /* "!=" or "!"*/
+            if ((c = inputGetc(ep)) < 0) {
+                ejError(ep, T("Syntax Error"));
+                return TOK_ERR;
+            }
+            if (c == '=') {
+                tokenAddChar(ep, EXPR_NOTEQ);
+                return TOK_EXPR;
+            }
+            inputPutback(ep, c);
+            tokenAddChar(ep, EXPR_BOOL_COMP);
+            return TOK_EXPR;
+
+        case ';':
+            tokenAddChar(ep, c);
+            return TOK_SEMI;
+
+        case ',':
+            tokenAddChar(ep, c);
+            return TOK_COMMA;
+
+        case '|':                                   /* "||" */
+            if ((c = inputGetc(ep)) < 0 || c != '|') {
+                ejError(ep, T("Syntax Error"));
+                return TOK_ERR;
+            }
+            tokenAddChar(ep, COND_OR);
+            return TOK_LOGICAL;
+
+        case '&':                                   /* "&&" */
+            if ((c = inputGetc(ep)) < 0 || c != '&') {
+                ejError(ep, T("Syntax Error"));
+                return TOK_ERR;
+            }
+            tokenAddChar(ep, COND_AND);
+            return TOK_LOGICAL;
+
+        case '\"':                                  /* String quote */
+        case '\'':
+            quote = c;
+            if ((c = inputGetc(ep)) < 0) {
+                ejError(ep, T("Syntax Error"));
+                return TOK_ERR;
+            }
+
+            while (c != quote) {
                 /*
                     check for escape sequence characters
                  */
-				if (c == '\\') {
-					c = inputGetc(ep);
+                if (c == '\\') {
+                    c = inputGetc(ep);
 
-					if (gisdigit(c)) {
+                    if (gisdigit(c)) {
                         /*
                             octal support, \101 maps to 65 = 'A'. put first char back so converter will work properly.
                          */
-						inputPutback(ep, c);
-						c = charConvert(ep, OCTAL, 3);
-
-					} else {
-						switch (c) {
-						case 'n':
-							c = '\n'; break;
-						case 'b':
-							c = '\b'; break;
-						case 'f':
-							c = '\f'; break;
-						case 'r':
-							c = '\r'; break;
-						case 't':
-							c = '\t'; break;
-						case 'x':
+                        inputPutback(ep, c);
+                        c = charConvert(ep, OCTAL, 3);
+
+                    } else {
+                        switch (c) {
+                        case 'n':
+                            c = '\n'; break;
+                        case 'b':
+                            c = '\b'; break;
+                        case 'f':
+                            c = '\f'; break;
+                        case 'r':
+                            c = '\r'; break;
+                        case 't':
+                            c = '\t'; break;
+                        case 'x':
                             /*
                                 hex support, \x41 maps to 65 = 'A'
                              */
-							c = charConvert(ep, HEX, 2);
-							break;
-						case 'u':
+                            c = charConvert(ep, HEX, 2);
+                            break;
+                        case 'u':
                             /*
                                 unicode support, \x0401 maps to 65 = 'A'
                              */
-							c = charConvert(ep, HEX, 2);
-							c = c*16 + charConvert(ep, HEX, 2);
-
-							break;
-						case '\'':
-						case '\"':
-						case '\\':
-							break;
-						default:
-							ejError(ep, T("Invalid Escape Sequence"));
-							return TOK_ERR;
-						}
-					}
-					if (tokenAddChar(ep, c) < 0) {
-						return TOK_ERR;
-					}
-				} else {
-					if (tokenAddChar(ep, c) < 0) {
-						return TOK_ERR;
-					}
-				}
-				if ((c = inputGetc(ep)) < 0) {
-					ejError(ep, T("Unmatched Quote"));
-					return TOK_ERR;
-				}
-			}
-			return TOK_LITERAL;
-
-		case '0': case '1': case '2': case '3': case '4': 
-		case '5': case '6': case '7': case '8': case '9':
-			do {
-				if (tokenAddChar(ep, c) < 0) {
-					return TOK_ERR;
-				}
-				if ((c = inputGetc(ep)) < 0)
-					break;
-			} while (gisdigit(c));
-			inputPutback(ep, c);
-			return TOK_LITERAL;
-
-		default:
+                            c = charConvert(ep, HEX, 2);
+                            c = c*16 + charConvert(ep, HEX, 2);
+
+                            break;
+                        case '\'':
+                        case '\"':
+                        case '\\':
+                            break;
+                        default:
+                            ejError(ep, T("Invalid Escape Sequence"));
+                            return TOK_ERR;
+                        }
+                    }
+                    if (tokenAddChar(ep, c) < 0) {
+                        return TOK_ERR;
+                    }
+                } else {
+                    if (tokenAddChar(ep, c) < 0) {
+                        return TOK_ERR;
+                    }
+                }
+                if ((c = inputGetc(ep)) < 0) {
+                    ejError(ep, T("Unmatched Quote"));
+                    return TOK_ERR;
+                }
+            }
+            return TOK_LITERAL;
+
+        case '0': case '1': case '2': case '3': case '4': 
+        case '5': case '6': case '7': case '8': case '9':
+            do {
+                if (tokenAddChar(ep, c) < 0) {
+                    return TOK_ERR;
+                }
+                if ((c = inputGetc(ep)) < 0)
+                    break;
+            } while (gisdigit(c));
+            inputPutback(ep, c);
+            return TOK_LITERAL;
+
+        default:
             /*
                 Identifiers or a function names
              */
-			while (1) {
-				if (c == '\\') {
+            while (1) {
+                if (c == '\\') {
                     /*
                         just ignore any \ characters.
                      */
-				} else if (tokenAddChar(ep, c) < 0) {
-						break;
-				}
-				if ((c = inputGetc(ep)) < 0) {
-					break;
-				}
-				if (!gisalnum(c) && c != '$' && c != '_' &&
-					c != '\\') {
-					break;
-				}
-			}
-			if (! gisalpha(*tokq->servp) && *tokq->servp != '$' && 
-					*tokq->servp != '_') {
-				ejError(ep, T("Invalid identifier %s"), tokq->servp);
-				return TOK_ERR;
-			}
+                } else if (tokenAddChar(ep, c) < 0) {
+                        break;
+                }
+                if ((c = inputGetc(ep)) < 0) {
+                    break;
+                }
+                if (!gisalnum(c) && c != '$' && c != '_' &&
+                    c != '\\') {
+                    break;
+                }
+            }
+            if (! gisalpha(*tokq->servp) && *tokq->servp != '$' && 
+                    *tokq->servp != '_') {
+                ejError(ep, T("Invalid identifier %s"), tokq->servp);
+                return TOK_ERR;
+            }
             /*
                 Check for reserved words (only "if", "else", "var", "for" and "return" at the moment)
              */
-			if (state == STATE_STMT) {
-				if (gstrcmp(ep->token, T("if")) == 0) {
-					return TOK_IF;
-				} else if (gstrcmp(ep->token, T("else")) == 0) {
-					return TOK_ELSE;
-				} else if (gstrcmp(ep->token, T("var")) == 0) {
-					return TOK_VAR;
-				} else if (gstrcmp(ep->token, T("for")) == 0) {
-					return TOK_FOR;
-				} else if (gstrcmp(ep->token, T("return")) == 0) {
-					if ((c == ';') || (c == '(')) {
-						inputPutback(ep, c);
-					}
-					return TOK_RETURN;
-				}
-			}
+            if (state == STATE_STMT) {
+                if (gstrcmp(ep->token, T("if")) == 0) {
+                    return TOK_IF;
+                } else if (gstrcmp(ep->token, T("else")) == 0) {
+                    return TOK_ELSE;
+                } else if (gstrcmp(ep->token, T("var")) == 0) {
+                    return TOK_VAR;
+                } else if (gstrcmp(ep->token, T("for")) == 0) {
+                    return TOK_FOR;
+                } else if (gstrcmp(ep->token, T("return")) == 0) {
+                    if ((c == ';') || (c == '(')) {
+                        inputPutback(ep, c);
+                    }
+                    return TOK_RETURN;
+                }
+            }
             /* 
                 Skip white space after token to find out whether this is a function or not.
              */ 
-			while (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
-				if ((c = inputGetc(ep)) < 0)
-					break;
-			}
+            while (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
+                if ((c = inputGetc(ep)) < 0)
+                    break;
+            }
 
-			tid = (c == '(') ? TOK_FUNCTION : TOK_ID;
-			done++;
-		}
-	}
+            tid = (c == '(') ? TOK_FUNCTION : TOK_ID;
+            done++;
+        }
+    }
 
     /*
         Putback the last extra character for next time
      */
-	inputPutback(ep, c);
-	return tid;
+    inputPutback(ep, c);
+    return tid;
 }
 
 
 void ejLexPutbackToken(ej_t* ep, int tid, char_t *string)
 {
-	ejinput_t*	ip;
+    ejinput_t*  ip;
 
-	a_assert(ep);
-	ip = ep->input;
-	a_assert(ip);
+    a_assert(ep);
+    ip = ep->input;
+    a_assert(ip);
 
-	if (ip->putBackToken) {
-		bfree(B_L, ip->putBackToken);
-	}
-	ip->putBackTokenId = tid;
-	ip->putBackToken = bstrdup(B_L, string);
+    if (ip->putBackToken) {
+        bfree(B_L, ip->putBackToken);
+    }
+    ip->putBackTokenId = tid;
+    ip->putBackToken = bstrdup(B_L, string);
 }
 
 
 static int tokenAddChar(ej_t *ep, int c)
 {
-	ejinput_t*	ip;
+    ejinput_t*  ip;
 
-	a_assert(ep);
-	ip = ep->input;
-	a_assert(ip);
+    a_assert(ep);
+    ip = ep->input;
+    a_assert(ip);
 
-	if (ringqPutc(&ip->tokbuf, (char_t) c) < 0) {
-		ejError(ep, T("Token too big"));
-		return -1;
-	}
-	* ((char_t*) ip->tokbuf.endp) = '\0';
-	ep->token = (char_t*) ip->tokbuf.servp;
+    if (ringqPutc(&ip->tokbuf, (char_t) c) < 0) {
+        ejError(ep, T("Token too big"));
+        return -1;
+    }
+    * ((char_t*) ip->tokbuf.endp) = '\0';
+    ep->token = (char_t*) ip->tokbuf.servp;
 
-	return 0;
+    return 0;
 }
 
 
 static int inputGetc(ej_t* ep)
 {
-	ejinput_t	*ip;
-	int			c, len;
-
-	a_assert(ep);
-	ip = ep->input;
-
-	if ((len = ringqLen(&ip->script)) == 0) {
-		return -1;
-	}
-
-	c = ringqGetc(&ip->script);
-
-	if (c == '\n') {
-		ip->lineNumber++;
-		ip->lineColumn = 0;
-	} else {
-		if ((ip->lineColumn + 2) >= ip->lineLength) {
-			ip->lineLength += EJ_INC;
-			ip->line = brealloc(B_L, ip->line, ip->lineLength * sizeof(char_t));
-		}
-		ip->line[ip->lineColumn++] = c;
-		ip->line[ip->lineColumn] = '\0';
-	}
-	return c;
+    ejinput_t   *ip;
+    int         c, len;
+
+    a_assert(ep);
+    ip = ep->input;
+
+    if ((len = ringqLen(&ip->script)) == 0) {
+        return -1;
+    }
+
+    c = ringqGetc(&ip->script);
+
+    if (c == '\n') {
+        ip->lineNumber++;
+        ip->lineColumn = 0;
+    } else {
+        if ((ip->lineColumn + 2) >= ip->lineLength) {
+            ip->lineLength += EJ_INC;
+            ip->line = brealloc(B_L, ip->line, ip->lineLength * sizeof(char_t));
+        }
+        ip->line[ip->lineColumn++] = c;
+        ip->line[ip->lineColumn] = '\0';
+    }
+    return c;
 }
 
 
 static void inputPutback(ej_t* ep, int c)
 {
-	ejinput_t	*ip;
+    ejinput_t   *ip;
 
-	a_assert(ep);
+    a_assert(ep);
 
-	ip = ep->input;
-	ringqInsertc(&ip->script, (char_t) c);
-	/* Fix by Fred Sauer, 2002/12/23 */
-	if (ip->lineColumn > 0) {
-	    ip->lineColumn-- ;
-	}
-	ip->line[ip->lineColumn] = '\0';
+    ip = ep->input;
+    ringqInsertc(&ip->script, (char_t) c);
+    /* Fix by Fred Sauer, 2002/12/23 */
+    if (ip->lineColumn > 0) {
+        ip->lineColumn-- ;
+    }
+    ip->line[ip->lineColumn] = '\0';
 }
 
 
@@ -608,34 +608,34 @@ static void inputPutback(ej_t* ep, int c)
  */
 static int charConvert(ej_t* ep, int base, int maxDig)
 {
-	int		i, c, lval, convChar;
+    int     i, c, lval, convChar;
 
-	lval = 0;
-	for (i = 0; i < maxDig; i++) {
-		if ((c = inputGetc(ep)) < 0) {
-			break;
-		}
+    lval = 0;
+    for (i = 0; i < maxDig; i++) {
+        if ((c = inputGetc(ep)) < 0) {
+            break;
+        }
         /*
             Initialize to out of range value
          */
-		convChar = base;
-		if (gisdigit(c)) {
-			convChar = c - '0';
-		} else if (c >= 'a' && c <= 'f') {
-			convChar = c - 'a' + 10;
-		} else if (c >= 'A' && c <= 'F') {
-			convChar = c - 'A' + 10;
-		}
+        convChar = base;
+        if (gisdigit(c)) {
+            convChar = c - '0';
+        } else if (c >= 'a' && c <= 'f') {
+            convChar = c - 'a' + 10;
+        } else if (c >= 'A' && c <= 'F') {
+            convChar = c - 'A' + 10;
+        }
         /*
             if unexpected character then return it to buffer.
          */
-		if (convChar >= base) {
-			inputPutback(ep, c);
-			break;
-		}
-		lval = (lval * base) + convChar;
-	}
-	return lval;
+        if (convChar >= base) {
+            inputPutback(ep, c);
+            break;
+        }
+        lval = (lval * base) + convChar;
+    }
+    return lval;
 }
 
 /******************************************************************************/
diff --git a/ejparse.c b/ejparse.c
index aa6e9d9c..73469999 100644
--- a/ejparse.c
+++ b/ejparse.c
@@ -1,185 +1,185 @@
 /*
     ejparse.c -- Ejscript(TM) Parser
 
-  	Ejscript parser. This implementes a subset of the JavaScript language.
+    Ejscript parser. This implementes a subset of the JavaScript language.
 
     Copyright (c) All Rights Reserved. See details at the end of the file.
  */
 
 /********************************** Includes **********************************/
 
-#include	"ejIntrn.h"
+#include    "ejIntrn.h"
 
 #ifdef CE
-	#include	"CE/wincompat.h"
+    #include    "CE/wincompat.h"
 #endif
 
 /********************************** Local Data ********************************/
 
-ej_t			**ejHandles;							/* List of ej handles */
-int				ejMax = -1;								/* Maximum size of	*/
+ej_t            **ejHandles;                            /* List of ej handles */
+int             ejMax = -1;                             /* Maximum size of  */
 
 /****************************** Forward Declarations **************************/
 
 #ifndef B_STATS
-#define	setString(a,b,c)	 setstring(b,c)
+#define setString(a,b,c)     setstring(b,c)
 #endif
 
-static ej_t		*ejPtr(int eid);
-static void		clearString(char_t **ptr);
-static void		setString(B_ARGS_DEC, char_t **ptr, char_t *s);
-static void		appendString(char_t **ptr, char_t *s);
-static int		parse(ej_t *ep, int state, int flags);
-static int		parseStmt(ej_t *ep, int state, int flags);
-static int		parseDeclaration(ej_t *ep, int state, int flags);
-static int		parseArgs(ej_t *ep, int state, int flags);
-static int		parseCond(ej_t *ep, int state, int flags);
-static int		parseExpr(ej_t *ep, int state, int flags);
-static int		evalExpr(ej_t *ep, char_t *lhs, int rel, char_t *rhs);
-static int		evalCond(ej_t *ep, char_t *lhs, int rel, char_t *rhs);
-static int		evalFunction(ej_t *ep);
-static void		freeFunc(ejfunc_t *func);
-static void		ejRemoveNewlines(ej_t *ep, int state);
+static ej_t     *ejPtr(int eid);
+static void     clearString(char_t **ptr);
+static void     setString(B_ARGS_DEC, char_t **ptr, char_t *s);
+static void     appendString(char_t **ptr, char_t *s);
+static int      parse(ej_t *ep, int state, int flags);
+static int      parseStmt(ej_t *ep, int state, int flags);
+static int      parseDeclaration(ej_t *ep, int state, int flags);
+static int      parseArgs(ej_t *ep, int state, int flags);
+static int      parseCond(ej_t *ep, int state, int flags);
+static int      parseExpr(ej_t *ep, int state, int flags);
+static int      evalExpr(ej_t *ep, char_t *lhs, int rel, char_t *rhs);
+static int      evalCond(ej_t *ep, char_t *lhs, int rel, char_t *rhs);
+static int      evalFunction(ej_t *ep);
+static void     freeFunc(ejfunc_t *func);
+static void     ejRemoveNewlines(ej_t *ep, int state);
 
 /************************************* Code ***********************************/
 
 int ejOpenEngine(sym_fd_t variables, sym_fd_t functions)
 {
-	ej_t	*ep;
-	int		eid, vid;
+    ej_t    *ep;
+    int     eid, vid;
 
-	if ((eid = hAllocEntry((void***) &ejHandles, &ejMax, sizeof(ej_t))) < 0) {
-		return -1;
-	}
-	ep = ejHandles[eid];
-	ep->eid = eid;
+    if ((eid = hAllocEntry((void***) &ejHandles, &ejMax, sizeof(ej_t))) < 0) {
+        return -1;
+    }
+    ep = ejHandles[eid];
+    ep->eid = eid;
 
     /*
         Create a top level symbol table if one is not provided for variables and functions. Variables may create other
         symbol tables for block level declarations so we use hAlloc to manage a list of variable tables.
      */
-	if ((vid = hAlloc((void***) &ep->variables)) < 0) {
-		ejMax = hFree((void***) &ejHandles, ep->eid);
-		return -1;
-	}
-	if (vid >= ep->variableMax) {
-		ep->variableMax = vid + 1;
-	}
-
-	if (variables == -1) {
-		ep->variables[vid] = symOpen(64) + EJ_OFFSET;
-		ep->flags |= FLAGS_VARIABLES;
-	} else {
-		ep->variables[vid] = variables + EJ_OFFSET;
-	}
-
-	if (functions == -1) {
-		ep->functions = symOpen(64);
-		ep->flags |= FLAGS_FUNCTIONS;
-	} else {
-		ep->functions = functions;
-	}
-
-	ejLexOpen(ep);
+    if ((vid = hAlloc((void***) &ep->variables)) < 0) {
+        ejMax = hFree((void***) &ejHandles, ep->eid);
+        return -1;
+    }
+    if (vid >= ep->variableMax) {
+        ep->variableMax = vid + 1;
+    }
+
+    if (variables == -1) {
+        ep->variables[vid] = symOpen(64) + EJ_OFFSET;
+        ep->flags |= FLAGS_VARIABLES;
+    } else {
+        ep->variables[vid] = variables + EJ_OFFSET;
+    }
+
+    if (functions == -1) {
+        ep->functions = symOpen(64);
+        ep->flags |= FLAGS_FUNCTIONS;
+    } else {
+        ep->functions = functions;
+    }
+
+    ejLexOpen(ep);
 
     /*
-      	Define standard constants
+        Define standard constants
      */
-	ejSetGlobalVar(ep->eid, T("null"), NULL);
-	return ep->eid;
+    ejSetGlobalVar(ep->eid, T("null"), NULL);
+    return ep->eid;
 }
 
 
 void ejCloseEngine(int eid)
 {
-	ej_t	*ep;
-	int		i;
+    ej_t    *ep;
+    int     i;
 
-	if ((ep = ejPtr(eid)) == NULL) {
-		return;
-	}
+    if ((ep = ejPtr(eid)) == NULL) {
+        return;
+    }
 
-	bfreeSafe(B_L, ep->error);
-	ep->error = NULL;
-	bfreeSafe(B_L, ep->result);
-	ep->result = NULL;
+    bfreeSafe(B_L, ep->error);
+    ep->error = NULL;
+    bfreeSafe(B_L, ep->result);
+    ep->result = NULL;
 
-	ejLexClose(ep);
+    ejLexClose(ep);
 
-	for (i = ep->variableMax - 1; i >= 0; i--) {
-		if (ep->flags & FLAGS_VARIABLES) {
-			symClose(ep->variables[i] - EJ_OFFSET);
-		}
-		ep->variableMax = hFree((void***) &ep->variables, i);
-	}
+    for (i = ep->variableMax - 1; i >= 0; i--) {
+        if (ep->flags & FLAGS_VARIABLES) {
+            symClose(ep->variables[i] - EJ_OFFSET);
+        }
+        ep->variableMax = hFree((void***) &ep->variables, i);
+    }
 
-	if (ep->flags & FLAGS_FUNCTIONS) {
-		symClose(ep->functions);
-	}
+    if (ep->flags & FLAGS_FUNCTIONS) {
+        symClose(ep->functions);
+    }
 
-	ejMax = hFree((void***) &ejHandles, ep->eid);
-	bfree(B_L, ep);
+    ejMax = hFree((void***) &ejHandles, ep->eid);
+    bfree(B_L, ep);
 }
 
 #ifndef __NO_EJ_FILE
 
 char_t *ejEvalFile(int eid, char_t *path, char_t **emsg)
 {
-	gstat_t sbuf;
-	ej_t	*ep;
-	char_t	*script, *rs;
-	char	*fileBuf;
-	int		fd;
-
-	a_assert(path && *path);
-
-	if (emsg) {
-		*emsg = NULL;
-	}
-
-	if ((ep = ejPtr(eid)) == NULL) {
-		return NULL;
-	}
-	
+    gstat_t sbuf;
+    ej_t    *ep;
+    char_t  *script, *rs;
+    char    *fileBuf;
+    int     fd;
+
+    a_assert(path && *path);
+
+    if (emsg) {
+        *emsg = NULL;
+    }
+
+    if ((ep = ejPtr(eid)) == NULL) {
+        return NULL;
+    }
+    
 #if !defined(WIN32)
-	fd = gopen(path, O_RDONLY | O_BINARY, 0666);
+    fd = gopen(path, O_RDONLY | O_BINARY, 0666);
 #else
-	_sopen_s(&fd, path, O_RDONLY | O_BINARY, _SH_DENYNO, 0666);
+    _sopen_s(&fd, path, O_RDONLY | O_BINARY, _SH_DENYNO, 0666);
 #endif
-	if (fd  < 0) {
-		ejError(ep, T("Bad handle %d"), eid);
-		return NULL;
-	}
-	if (gstat(path, &sbuf) < 0) {
-		gclose(fd);
-		ejError(ep, T("Cant stat %s"), path);
-		return NULL;
-	}
-	if ((fileBuf = balloc(B_L, sbuf.st_size + 1)) == NULL) {
-		gclose(fd);
-		ejError(ep, T("Cant malloc %d"), sbuf.st_size);
-		return NULL;
-	}
-	if (gread(fd, fileBuf, sbuf.st_size) != (int)sbuf.st_size) {
-		gclose(fd);
-		bfree(B_L, fileBuf);
-		ejError(ep, T("Error reading %s"), path);
-		return NULL;
-	}
-	fileBuf[sbuf.st_size] = '\0';
-	gclose(fd);
-
-	if ((script = ballocAscToUni(fileBuf, sbuf.st_size)) == NULL) {
-		bfree(B_L, fileBuf);
-		ejError(ep, T("Cant malloc %d"), sbuf.st_size + 1);
-		return NULL;
-	}
-	bfree(B_L, fileBuf);
-
-	rs = ejEvalBlock(eid, script, emsg);
-
-	bfree(B_L, script);
-	return rs;
+    if (fd  < 0) {
+        ejError(ep, T("Bad handle %d"), eid);
+        return NULL;
+    }
+    if (gstat(path, &sbuf) < 0) {
+        gclose(fd);
+        ejError(ep, T("Cant stat %s"), path);
+        return NULL;
+    }
+    if ((fileBuf = balloc(B_L, sbuf.st_size + 1)) == NULL) {
+        gclose(fd);
+        ejError(ep, T("Cant malloc %d"), sbuf.st_size);
+        return NULL;
+    }
+    if (gread(fd, fileBuf, sbuf.st_size) != (int)sbuf.st_size) {
+        gclose(fd);
+        bfree(B_L, fileBuf);
+        ejError(ep, T("Error reading %s"), path);
+        return NULL;
+    }
+    fileBuf[sbuf.st_size] = '\0';
+    gclose(fd);
+
+    if ((script = ballocAscToUni(fileBuf, sbuf.st_size)) == NULL) {
+        bfree(B_L, fileBuf);
+        ejError(ep, T("Cant malloc %d"), sbuf.st_size + 1);
+        return NULL;
+    }
+    bfree(B_L, fileBuf);
+
+    rs = ejEvalBlock(eid, script, emsg);
+
+    bfree(B_L, script);
+    return rs;
 }
 #endif /* __NO_EJ_FILE */
 
@@ -190,34 +190,34 @@ char_t *ejEvalFile(int eid, char_t *path, char_t **emsg)
  */
 int ejOpenBlock(int eid)
 {
-	ej_t	*ep;
-	int		vid;
-
-	if((ep = ejPtr(eid)) == NULL) {
-		return -1;
-	}
-	if ((vid = hAlloc((void***) &ep->variables)) < 0) {
-		return -1;
-	}
-	if (vid >= ep->variableMax) {
-		ep->variableMax = vid + 1;
-	}
-	ep->variables[vid] = symOpen(64) + EJ_OFFSET;
-	return vid;
+    ej_t    *ep;
+    int     vid;
+
+    if((ep = ejPtr(eid)) == NULL) {
+        return -1;
+    }
+    if ((vid = hAlloc((void***) &ep->variables)) < 0) {
+        return -1;
+    }
+    if (vid >= ep->variableMax) {
+        ep->variableMax = vid + 1;
+    }
+    ep->variables[vid] = symOpen(64) + EJ_OFFSET;
+    return vid;
 
 }
 
 
 int ejCloseBlock(int eid, int vid)
 {
-	ej_t	*ep;
+    ej_t    *ep;
 
-	if((ep = ejPtr(eid)) == NULL) {
-		return -1;
-	}
-	symClose(ep->variables[vid] - EJ_OFFSET);
-	ep->variableMax = hFree((void***) &ep->variables, vid);
-	return 0;
+    if((ep = ejPtr(eid)) == NULL) {
+        return -1;
+    }
+    symClose(ep->variables[vid] - EJ_OFFSET);
+    ep->variableMax = hFree((void***) &ep->variables, vid);
+    return 0;
 
 }
 
@@ -228,16 +228,16 @@ int ejCloseBlock(int eid, int vid)
  */
 char_t *ejEvalBlock(int eid, char_t *script, char_t **emsg)
 {
-	char_t* returnVal;
-	int		vid;
+    char_t* returnVal;
+    int     vid;
 
-	a_assert(script);
+    a_assert(script);
 
-	vid = ejOpenBlock(eid);
-	returnVal = ejEval(eid, script, emsg);
-	ejCloseBlock(eid, vid);
+    vid = ejOpenBlock(eid);
+    returnVal = ejEval(eid, script, emsg);
+    ejCloseBlock(eid, vid);
 
-	return returnVal;
+    return returnVal;
 }
 
 
@@ -247,77 +247,77 @@ char_t *ejEvalBlock(int eid, char_t *script, char_t **emsg)
  */
 char_t *ejEval(int eid, char_t *script, char_t **emsg)
 {
-	ej_t	*ep;
-	ejinput_t	*oldBlock;
-	int		state;
-	void	*endlessLoopTest;
-	int		loopCounter;
-	
-	
-	a_assert(script);
-
-	if (emsg) {
-		*emsg = NULL;
-	} 
-	if ((ep = ejPtr(eid)) == NULL) {
-		return NULL;
-	}
-	setString(B_L, &ep->result, T(""));
+    ej_t    *ep;
+    ejinput_t   *oldBlock;
+    int     state;
+    void    *endlessLoopTest;
+    int     loopCounter;
+    
+    
+    a_assert(script);
+
+    if (emsg) {
+        *emsg = NULL;
+    } 
+    if ((ep = ejPtr(eid)) == NULL) {
+        return NULL;
+    }
+    setString(B_L, &ep->result, T(""));
 
     /*
         Allocate a new evaluation block, and save the old one
      */
-	oldBlock = ep->input;
-	ejLexOpenScript(ep, script);
+    oldBlock = ep->input;
+    ejLexOpenScript(ep, script);
 
     /*
-      	Do the actual parsing and evaluation
+        Do the actual parsing and evaluation
      */
-	loopCounter = 0;
-	endlessLoopTest = NULL;
+    loopCounter = 0;
+    endlessLoopTest = NULL;
 
-	do {
-		state = parse(ep, STATE_BEGIN, FLAGS_EXE);
+    do {
+        state = parse(ep, STATE_BEGIN, FLAGS_EXE);
 
-		if (state == STATE_RET) {
-			state = STATE_EOF;
-		}
+        if (state == STATE_RET) {
+            state = STATE_EOF;
+        }
         /*
             prevent parser from going into infinite loop.  If parsing the same line 10 times then fail and report Syntax
             error.  Most normal error are caught in the parser itself.
          */
-		if (endlessLoopTest == ep->input->script.servp) {
-			if (loopCounter++ > 10) {
-				state = STATE_ERR;
-				ejError(ep, T("Syntax error"));
-			}
-		} else {
-			endlessLoopTest = ep->input->script.servp;
-			loopCounter = 0;
-		}
-	} while (state != STATE_EOF && state != STATE_ERR);
-
-	ejLexCloseScript(ep);
+        if (endlessLoopTest == ep->input->script.servp) {
+            if (loopCounter++ > 10) {
+                state = STATE_ERR;
+                ejError(ep, T("Syntax error"));
+            }
+        } else {
+            endlessLoopTest = ep->input->script.servp;
+            loopCounter = 0;
+        }
+    } while (state != STATE_EOF && state != STATE_ERR);
+
+    ejLexCloseScript(ep);
 
     /*
         Return any error string to the user
      */
-	if (state == STATE_ERR && emsg) {
-		*emsg = bstrdup(B_L, ep->error);
-	}
+    if (state == STATE_ERR && emsg) {
+        *emsg = bstrdup(B_L, ep->error);
+    }
 
     /*
         Restore the old evaluation block
      */
-	ep->input = oldBlock;
-
-	if (state == STATE_EOF) {
-		return ep->result;
-	}
-	if (state == STATE_ERR) {
-		return NULL;
-	}
-	return ep->result;
+    ep->input = oldBlock;
+
+    if (state == STATE_EOF) {
+        return ep->result;
+    }
+    if (state == STATE_ERR) {
+        return NULL;
+    }
+    return ep->result;
 }
 
 
@@ -327,528 +327,528 @@ char_t *ejEval(int eid, char_t *script, char_t **emsg)
  */
 static int parse(ej_t *ep, int state, int flags)
 {
-	a_assert(ep);
+    a_assert(ep);
 
-	switch (state) {
+    switch (state) {
     /*
         Any statement, function arguments or conditional expressions
      */
-	case STATE_STMT:
-		if ((state = parseStmt(ep, state, flags)) != STATE_STMT_DONE &&
-			state != STATE_EOF && state != STATE_STMT_BLOCK_DONE &&
-			state != STATE_RET) {
-			state = STATE_ERR;
-		}
-		break;
-
-	case STATE_DEC:
-		if ((state = parseStmt(ep, state, flags)) != STATE_DEC_DONE &&
-			state != STATE_EOF) {
-			state = STATE_ERR;
-		}
-		break;
-
-	case STATE_EXPR:
-		if ((state = parseStmt(ep, state, flags)) != STATE_EXPR_DONE &&
-			state != STATE_EOF) {
-			state = STATE_ERR;
-		}
-		break;
+    case STATE_STMT:
+        if ((state = parseStmt(ep, state, flags)) != STATE_STMT_DONE &&
+            state != STATE_EOF && state != STATE_STMT_BLOCK_DONE &&
+            state != STATE_RET) {
+            state = STATE_ERR;
+        }
+        break;
+
+    case STATE_DEC:
+        if ((state = parseStmt(ep, state, flags)) != STATE_DEC_DONE &&
+            state != STATE_EOF) {
+            state = STATE_ERR;
+        }
+        break;
+
+    case STATE_EXPR:
+        if ((state = parseStmt(ep, state, flags)) != STATE_EXPR_DONE &&
+            state != STATE_EOF) {
+            state = STATE_ERR;
+        }
+        break;
 
     /*
-      	Variable declaration list
+        Variable declaration list
      */
-	case STATE_DEC_LIST:
-		state = parseDeclaration(ep, state, flags);
-		break;
+    case STATE_DEC_LIST:
+        state = parseDeclaration(ep, state, flags);
+        break;
 
     /*
-      	Function argument string
+        Function argument string
      */
-	case STATE_ARG_LIST:
-		state = parseArgs(ep, state, flags);
-		break;
+    case STATE_ARG_LIST:
+        state = parseArgs(ep, state, flags);
+        break;
 
     /*
-      	Logical condition list (relational operations separated by &&, ||)
+        Logical condition list (relational operations separated by &&, ||)
      */
-	case STATE_COND:
-		state = parseCond(ep, state, flags);
-		break;
+    case STATE_COND:
+        state = parseCond(ep, state, flags);
+        break;
 
     /*
-     j	Expression list
+     j  Expression list
      */
-	case STATE_RELEXP:
-		state = parseExpr(ep, state, flags);
-		break;
-	}
-
-	if (state == STATE_ERR && ep->error == NULL) {
-		ejError(ep, T("Syntax error"));
-	}
-	return state;
+    case STATE_RELEXP:
+        state = parseExpr(ep, state, flags);
+        break;
+    }
+
+    if (state == STATE_ERR && ep->error == NULL) {
+        ejError(ep, T("Syntax error"));
+    }
+    return state;
 }
 
 
 /*
-  	Parse any statement including functions and simple relational operations
+    Parse any statement including functions and simple relational operations
  */
 static int parseStmt(ej_t *ep, int state, int flags)
 {
-	ejfunc_t	func;
-	ejfunc_t	*saveFunc;
-	ejinput_t	condScript, endScript, bodyScript, incrScript;
-	char_t		*value,	*identifier;
-	int			done, expectSemi, thenFlags, elseFlags, tid, cond, forFlags;
-	int			ejVarType;
+    ejfunc_t    func;
+    ejfunc_t    *saveFunc;
+    ejinput_t   condScript, endScript, bodyScript, incrScript;
+    char_t      *value, *identifier;
+    int         done, expectSemi, thenFlags, elseFlags, tid, cond, forFlags;
+    int         ejVarType;
 
-	a_assert(ep);
+    a_assert(ep);
 
     /*
-      	Set these to NULL, else we try to free them if an error occurs.
+        Set these to NULL, else we try to free them if an error occurs.
      */
-	endScript.putBackToken = NULL;
-	bodyScript.putBackToken = NULL;
-	incrScript.putBackToken = NULL;
-	condScript.putBackToken = NULL;
+    endScript.putBackToken = NULL;
+    bodyScript.putBackToken = NULL;
+    incrScript.putBackToken = NULL;
+    condScript.putBackToken = NULL;
 
-	expectSemi = 0;
-	saveFunc = NULL;
+    expectSemi = 0;
+    saveFunc = NULL;
 
-	for (done = 0; !done; ) {
-		tid = ejLexGetToken(ep, state);
+    for (done = 0; !done; ) {
+        tid = ejLexGetToken(ep, state);
 
-		switch (tid) {
-		default:
-			ejLexPutbackToken(ep, TOK_EXPR, ep->token);
-			done++;
-			break;
+        switch (tid) {
+        default:
+            ejLexPutbackToken(ep, TOK_EXPR, ep->token);
+            done++;
+            break;
 
-		case TOK_ERR:
-			state = STATE_ERR;
-			done++;
-			break;
+        case TOK_ERR:
+            state = STATE_ERR;
+            done++;
+            break;
 
-		case TOK_EOF:
-			state = STATE_EOF;
-			done++;
-			break;
+        case TOK_EOF:
+            state = STATE_EOF;
+            done++;
+            break;
 
-		case TOK_NEWLINE:
-			break;
+        case TOK_NEWLINE:
+            break;
 
-		case TOK_SEMI:
+        case TOK_SEMI:
             /*
                 This case is when we discover no statement and just a lone ';'
              */
-			if (state != STATE_STMT) {
-				ejLexPutbackToken(ep, tid, ep->token);
-			}
-			done++;
-			break;
+            if (state != STATE_STMT) {
+                ejLexPutbackToken(ep, tid, ep->token);
+            }
+            done++;
+            break;
 
-		case TOK_ID:
+        case TOK_ID:
             /*
                 This could either be a reference to a variable or an assignment
              */
-			identifier = NULL;
-			setString(B_L, &identifier, ep->token);
+            identifier = NULL;
+            setString(B_L, &identifier, ep->token);
             /*
                 Peek ahead to see if this is an assignment
              */
-			tid = ejLexGetToken(ep, state);
-			if (tid == TOK_ASSIGNMENT) {
-				if (parse(ep, STATE_RELEXP, flags) != STATE_RELEXP_DONE) {
-					clearString(&identifier);
-					goto error;
-				}
-				if (flags & FLAGS_EXE) {
-					if ( state == STATE_DEC ) {
-						ejSetLocalVar(ep->eid, identifier, ep->result);
-					} else {
-						ejVarType = ejGetVar(ep->eid, identifier, &value);
-						if (ejVarType > 0) {
-							ejSetLocalVar(ep->eid, identifier, ep->result);
-						} else {
-							ejSetGlobalVar(ep->eid, identifier, ep->result);
-						}
-					}
-				}
-
-			} else if (tid == TOK_INC_DEC ) {
-				value = NULL;
-				if (flags & FLAGS_EXE) {
-					ejVarType = ejGetVar(ep->eid, identifier, &value);
-					if (ejVarType < 0) {
-						ejError(ep, T("Undefined variable %s\n"), identifier);
-						goto error;
-					}
-					setString(B_L, &ep->result, value);
-					if (evalExpr(ep, value, (int) *ep->token, T("1")) < 0) {
-						state = STATE_ERR;
-						break;
-					}
-
-					if (ejVarType > 0) {
-						ejSetLocalVar(ep->eid, identifier, ep->result);
-					} else {
-						ejSetGlobalVar(ep->eid, identifier, ep->result);
-					}
-				}
-
-			} else {
+            tid = ejLexGetToken(ep, state);
+            if (tid == TOK_ASSIGNMENT) {
+                if (parse(ep, STATE_RELEXP, flags) != STATE_RELEXP_DONE) {
+                    clearString(&identifier);
+                    goto error;
+                }
+                if (flags & FLAGS_EXE) {
+                    if ( state == STATE_DEC ) {
+                        ejSetLocalVar(ep->eid, identifier, ep->result);
+                    } else {
+                        ejVarType = ejGetVar(ep->eid, identifier, &value);
+                        if (ejVarType > 0) {
+                            ejSetLocalVar(ep->eid, identifier, ep->result);
+                        } else {
+                            ejSetGlobalVar(ep->eid, identifier, ep->result);
+                        }
+                    }
+                }
+
+            } else if (tid == TOK_INC_DEC ) {
+                value = NULL;
+                if (flags & FLAGS_EXE) {
+                    ejVarType = ejGetVar(ep->eid, identifier, &value);
+                    if (ejVarType < 0) {
+                        ejError(ep, T("Undefined variable %s\n"), identifier);
+                        goto error;
+                    }
+                    setString(B_L, &ep->result, value);
+                    if (evalExpr(ep, value, (int) *ep->token, T("1")) < 0) {
+                        state = STATE_ERR;
+                        break;
+                    }
+
+                    if (ejVarType > 0) {
+                        ejSetLocalVar(ep->eid, identifier, ep->result);
+                    } else {
+                        ejSetGlobalVar(ep->eid, identifier, ep->result);
+                    }
+                }
+
+            } else {
                 /*
                     If we are processing a declaration, allow undefined vars
                  */
-				value = NULL;
-				if (state == STATE_DEC) {
-					if (ejGetVar(ep->eid, identifier, &value) > 0) {
-						ejError(ep, T("Variable already declared"),
-							identifier);
-						clearString(&identifier);
-						goto error;
-					}
-					ejSetLocalVar(ep->eid, identifier, NULL);
-				} else {
-					if ( flags & FLAGS_EXE ) {
-						if (ejGetVar(ep->eid, identifier, &value) < 0) {
-							ejError(ep, T("Undefined variable %s\n"),
-								identifier);
-							clearString(&identifier);
-							goto error;
-						}
-					}
-				}
-				setString(B_L, &ep->result, value);
-				ejLexPutbackToken(ep, tid, ep->token);
-			}
-			clearString(&identifier);
-
-			if (state == STATE_STMT) {
-				expectSemi++;
-			}
-			done++;
-			break;
-
-		case TOK_LITERAL:
+                value = NULL;
+                if (state == STATE_DEC) {
+                    if (ejGetVar(ep->eid, identifier, &value) > 0) {
+                        ejError(ep, T("Variable already declared"),
+                            identifier);
+                        clearString(&identifier);
+                        goto error;
+                    }
+                    ejSetLocalVar(ep->eid, identifier, NULL);
+                } else {
+                    if ( flags & FLAGS_EXE ) {
+                        if (ejGetVar(ep->eid, identifier, &value) < 0) {
+                            ejError(ep, T("Undefined variable %s\n"),
+                                identifier);
+                            clearString(&identifier);
+                            goto error;
+                        }
+                    }
+                }
+                setString(B_L, &ep->result, value);
+                ejLexPutbackToken(ep, tid, ep->token);
+            }
+            clearString(&identifier);
+
+            if (state == STATE_STMT) {
+                expectSemi++;
+            }
+            done++;
+            break;
+
+        case TOK_LITERAL:
             /*
                 Set the result to the literal (number or string constant)
              */
-			setString(B_L, &ep->result, ep->token);
-			if (state == STATE_STMT) {
-				expectSemi++;
-			}
-			done++;
-			break;
-
-		case TOK_FUNCTION:
+            setString(B_L, &ep->result, ep->token);
+            if (state == STATE_STMT) {
+                expectSemi++;
+            }
+            done++;
+            break;
+
+        case TOK_FUNCTION:
             /*
                 We must save any current ep->func value for the current stack frame
              */
-			if (ep->func) {
-				saveFunc = ep->func;
-			}
-			memset(&func, 0, sizeof(ejfunc_t));
-			setString(B_L, &func.fname, ep->token);
-			ep->func = &func;
-
-			setString(B_L, &ep->result, T(""));
-			if (ejLexGetToken(ep, state) != TOK_LPAREN) {
-				freeFunc(&func);
-				goto error;
-			}
-			if (parse(ep, STATE_ARG_LIST, flags) != STATE_ARG_LIST_DONE) {
-				freeFunc(&func);
-				ep->func = saveFunc;
-				goto error;
-			}
+            if (ep->func) {
+                saveFunc = ep->func;
+            }
+            memset(&func, 0, sizeof(ejfunc_t));
+            setString(B_L, &func.fname, ep->token);
+            ep->func = &func;
+
+            setString(B_L, &ep->result, T(""));
+            if (ejLexGetToken(ep, state) != TOK_LPAREN) {
+                freeFunc(&func);
+                goto error;
+            }
+            if (parse(ep, STATE_ARG_LIST, flags) != STATE_ARG_LIST_DONE) {
+                freeFunc(&func);
+                ep->func = saveFunc;
+                goto error;
+            }
             /*
                 Evaluate the function if required
              */
-			if (flags & FLAGS_EXE && evalFunction(ep) < 0) {
-				freeFunc(&func);
-				ep->func = saveFunc;
-				goto error;
-			}
-			freeFunc(&func);
-			ep->func = saveFunc;
-
-			if (ejLexGetToken(ep, state) != TOK_RPAREN) {
-				goto error;
-			}
-			if (state == STATE_STMT) {
-				expectSemi++;
-			}
-			done++;
-			break;
-
-		case TOK_IF:
-			if (state != STATE_STMT) {
-				goto error;
-			}
-			if (ejLexGetToken(ep, state) != TOK_LPAREN) {
-				goto error;
-			}
+            if (flags & FLAGS_EXE && evalFunction(ep) < 0) {
+                freeFunc(&func);
+                ep->func = saveFunc;
+                goto error;
+            }
+            freeFunc(&func);
+            ep->func = saveFunc;
+
+            if (ejLexGetToken(ep, state) != TOK_RPAREN) {
+                goto error;
+            }
+            if (state == STATE_STMT) {
+                expectSemi++;
+            }
+            done++;
+            break;
+
+        case TOK_IF:
+            if (state != STATE_STMT) {
+                goto error;
+            }
+            if (ejLexGetToken(ep, state) != TOK_LPAREN) {
+                goto error;
+            }
             /*
                 Evaluate the entire condition list "(condition)"
              */
-			if (parse(ep, STATE_COND, flags) != STATE_COND_DONE) {
-				goto error;
-			}
-			if (ejLexGetToken(ep, state) != TOK_RPAREN) {
-				goto error;
-			}
+            if (parse(ep, STATE_COND, flags) != STATE_COND_DONE) {
+                goto error;
+            }
+            if (ejLexGetToken(ep, state) != TOK_RPAREN) {
+                goto error;
+            }
             /*
                 This is the "then" case. We need to always parse both cases and execute only the relevant case.
              */
-			if (*ep->result == '1') {
-				thenFlags = flags;
-				elseFlags = flags & ~FLAGS_EXE;
-			} else {
-				thenFlags = flags & ~FLAGS_EXE;
-				elseFlags = flags;
-			}
+            if (*ep->result == '1') {
+                thenFlags = flags;
+                elseFlags = flags & ~FLAGS_EXE;
+            } else {
+                thenFlags = flags & ~FLAGS_EXE;
+                elseFlags = flags;
+            }
 /*
- *			Process the "then" case.  Allow for RETURN statement
+ *          Process the "then" case.  Allow for RETURN statement
  */
-			switch (parse(ep, STATE_STMT, thenFlags)) {
-			case STATE_RET:
-				return STATE_RET;
-			case STATE_STMT_DONE:
-				break;
-			default:
-				goto error;
-			}
+            switch (parse(ep, STATE_STMT, thenFlags)) {
+            case STATE_RET:
+                return STATE_RET;
+            case STATE_STMT_DONE:
+                break;
+            default:
+                goto error;
+            }
             /*
                 check to see if there is an "else" case
              */
-			ejRemoveNewlines(ep, state);
-			tid = ejLexGetToken(ep, state);
-			if (tid != TOK_ELSE) {
-				ejLexPutbackToken(ep, tid, ep->token);
-				done++;
-				break;
-			}
+            ejRemoveNewlines(ep, state);
+            tid = ejLexGetToken(ep, state);
+            if (tid != TOK_ELSE) {
+                ejLexPutbackToken(ep, tid, ep->token);
+                done++;
+                break;
+            }
             /*
                 Process the "else" case.  Allow for return.
              */
-			switch (parse(ep, STATE_STMT, elseFlags)) {
-			case STATE_RET:
-				return STATE_RET;
-			case STATE_STMT_DONE:
-				break;
-			default:
-				goto error;
-			}
-			done++;
-			break;
-
-		case TOK_FOR:
+            switch (parse(ep, STATE_STMT, elseFlags)) {
+            case STATE_RET:
+                return STATE_RET;
+            case STATE_STMT_DONE:
+                break;
+            default:
+                goto error;
+            }
+            done++;
+            break;
+
+        case TOK_FOR:
             /*
                 Format for the expression is:
                     for (initial; condition; incr) {
                         body;
                     }
              */
-			if (state != STATE_STMT) {
-				goto error;
-			}
-			if (ejLexGetToken(ep, state) != TOK_LPAREN) {
-				goto error;
-			}
+            if (state != STATE_STMT) {
+                goto error;
+            }
+            if (ejLexGetToken(ep, state) != TOK_LPAREN) {
+                goto error;
+            }
 
             /*
                 Evaluate the for loop initialization statement
              */
-			if (parse(ep, STATE_EXPR, flags) != STATE_EXPR_DONE) {
-				goto error;
-			}
-			if (ejLexGetToken(ep, state) != TOK_SEMI) {
-				goto error;
-			}
+            if (parse(ep, STATE_EXPR, flags) != STATE_EXPR_DONE) {
+                goto error;
+            }
+            if (ejLexGetToken(ep, state) != TOK_SEMI) {
+                goto error;
+            }
 
             /*
                 The first time through, we save the current input context just to each step: prior to the conditional,
                 the loop increment and the loop body.  
              */
-			ejLexSaveInputState(ep, &condScript);
-			if (parse(ep, STATE_COND, flags) != STATE_COND_DONE) {
-				goto error;
-			}
-			cond = (*ep->result != '0');
+            ejLexSaveInputState(ep, &condScript);
+            if (parse(ep, STATE_COND, flags) != STATE_COND_DONE) {
+                goto error;
+            }
+            cond = (*ep->result != '0');
 
-			if (ejLexGetToken(ep, state) != TOK_SEMI) {
-				goto error;
-			}
+            if (ejLexGetToken(ep, state) != TOK_SEMI) {
+                goto error;
+            }
 
             /*
                 Don't execute the loop increment statement or the body first time
              */
-			forFlags = flags & ~FLAGS_EXE;
-			ejLexSaveInputState(ep, &incrScript);
-			if (parse(ep, STATE_EXPR, forFlags) != STATE_EXPR_DONE) {
-				goto error;
-			}
-			if (ejLexGetToken(ep, state) != TOK_RPAREN) {
-				goto error;
-			}
+            forFlags = flags & ~FLAGS_EXE;
+            ejLexSaveInputState(ep, &incrScript);
+            if (parse(ep, STATE_EXPR, forFlags) != STATE_EXPR_DONE) {
+                goto error;
+            }
+            if (ejLexGetToken(ep, state) != TOK_RPAREN) {
+                goto error;
+            }
 
             /*
                 Parse the body and remember the end of the body script
              */
-			ejLexSaveInputState(ep, &bodyScript);
-			if (parse(ep, STATE_STMT, forFlags) != STATE_STMT_DONE) {
-				goto error;
-			}
-			ejLexSaveInputState(ep, &endScript);
+            ejLexSaveInputState(ep, &bodyScript);
+            if (parse(ep, STATE_STMT, forFlags) != STATE_STMT_DONE) {
+                goto error;
+            }
+            ejLexSaveInputState(ep, &endScript);
 
             /*
                 Now actually do the for loop. Note loop has been rotated
              */
-			while (cond && (flags & FLAGS_EXE) ) {
+            while (cond && (flags & FLAGS_EXE) ) {
                 /*
                     Evaluate the body
                  */
-				ejLexRestoreInputState(ep, &bodyScript);
-
-				switch (parse(ep, STATE_STMT, flags)) {
-				case STATE_RET:
-					return STATE_RET;
-				case STATE_STMT_DONE:
-					break;
-				default:
-					goto error;
-				}
+                ejLexRestoreInputState(ep, &bodyScript);
+
+                switch (parse(ep, STATE_STMT, flags)) {
+                case STATE_RET:
+                    return STATE_RET;
+                case STATE_STMT_DONE:
+                    break;
+                default:
+                    goto error;
+                }
                 /*
                     Evaluate the increment script
                  */
-				ejLexRestoreInputState(ep, &incrScript);
-				if (parse(ep, STATE_EXPR, flags) != STATE_EXPR_DONE) {
-					goto error;
-				}
+                ejLexRestoreInputState(ep, &incrScript);
+                if (parse(ep, STATE_EXPR, flags) != STATE_EXPR_DONE) {
+                    goto error;
+                }
                 /*
                     Evaluate the condition
                  */
-				ejLexRestoreInputState(ep, &condScript);
-				if (parse(ep, STATE_COND, flags) != STATE_COND_DONE) {
-					goto error;
-				}
-				cond = (*ep->result != '0');
-			}
-			ejLexRestoreInputState(ep, &endScript);
-			done++;
-			break;
-
-		case TOK_VAR:
-			if (parse(ep, STATE_DEC_LIST, flags) != STATE_DEC_LIST_DONE) {
-				goto error;
-			}
-			done++;
-			break;
-
-		case TOK_COMMA:
-			ejLexPutbackToken(ep, TOK_EXPR, ep->token);
-			done++;
-			break;
-
-		case TOK_LPAREN:
-			if (state == STATE_EXPR) {
-				if (parse(ep, STATE_RELEXP, flags) != STATE_RELEXP_DONE) {
-					goto error;
-				}
-				if (ejLexGetToken(ep, state) != TOK_RPAREN) {
-					goto error;
-				}
-				return STATE_EXPR_DONE;
-			}
-			done++;
-			break;
-
-		case TOK_RPAREN:
-			ejLexPutbackToken(ep, tid, ep->token);
-			return STATE_EXPR_DONE;
-
-		case TOK_LBRACE:
+                ejLexRestoreInputState(ep, &condScript);
+                if (parse(ep, STATE_COND, flags) != STATE_COND_DONE) {
+                    goto error;
+                }
+                cond = (*ep->result != '0');
+            }
+            ejLexRestoreInputState(ep, &endScript);
+            done++;
+            break;
+
+        case TOK_VAR:
+            if (parse(ep, STATE_DEC_LIST, flags) != STATE_DEC_LIST_DONE) {
+                goto error;
+            }
+            done++;
+            break;
+
+        case TOK_COMMA:
+            ejLexPutbackToken(ep, TOK_EXPR, ep->token);
+            done++;
+            break;
+
+        case TOK_LPAREN:
+            if (state == STATE_EXPR) {
+                if (parse(ep, STATE_RELEXP, flags) != STATE_RELEXP_DONE) {
+                    goto error;
+                }
+                if (ejLexGetToken(ep, state) != TOK_RPAREN) {
+                    goto error;
+                }
+                return STATE_EXPR_DONE;
+            }
+            done++;
+            break;
+
+        case TOK_RPAREN:
+            ejLexPutbackToken(ep, tid, ep->token);
+            return STATE_EXPR_DONE;
+
+        case TOK_LBRACE:
             /*
                 This handles any code in braces except "if () {} else {}"
              */
-			if (state != STATE_STMT) {
-				goto error;
-			}
+            if (state != STATE_STMT) {
+                goto error;
+            }
 
             /*
                 Parse will return STATE_STMT_BLOCK_DONE when the RBRACE is seen
              */
-			do {
-				state = parse(ep, STATE_STMT, flags);
-			} while (state == STATE_STMT_DONE);
+            do {
+                state = parse(ep, STATE_STMT, flags);
+            } while (state == STATE_STMT_DONE);
 
             /*
                 Allow return statement.
              */
-			if (state == STATE_RET) {
-				return state;
-			}
-
-			if (ejLexGetToken(ep, state) != TOK_RBRACE) {
-				goto error;
-			}
-			return STATE_STMT_DONE;
-
-		case TOK_RBRACE:
-			if (state == STATE_STMT) {
-				ejLexPutbackToken(ep, tid, ep->token);
-				return STATE_STMT_BLOCK_DONE;
-			}
-			goto error;
-
-		case TOK_RETURN:
-			if (parse(ep, STATE_RELEXP, flags) != STATE_RELEXP_DONE) {
-				goto error;
-			}
-			if (flags & FLAGS_EXE) {
-				while ( ejLexGetToken(ep, state) != TOK_EOF );
-				done++;
-				return STATE_RET;
-			}
-			break;
-		}
-	}
-
-	if (expectSemi) {
-		tid = ejLexGetToken(ep, state);
-		if (tid != TOK_SEMI && tid != TOK_NEWLINE) {
-			goto error;
-		}
+            if (state == STATE_RET) {
+                return state;
+            }
+
+            if (ejLexGetToken(ep, state) != TOK_RBRACE) {
+                goto error;
+            }
+            return STATE_STMT_DONE;
+
+        case TOK_RBRACE:
+            if (state == STATE_STMT) {
+                ejLexPutbackToken(ep, tid, ep->token);
+                return STATE_STMT_BLOCK_DONE;
+            }
+            goto error;
+
+        case TOK_RETURN:
+            if (parse(ep, STATE_RELEXP, flags) != STATE_RELEXP_DONE) {
+                goto error;
+            }
+            if (flags & FLAGS_EXE) {
+                while ( ejLexGetToken(ep, state) != TOK_EOF );
+                done++;
+                return STATE_RET;
+            }
+            break;
+        }
+    }
+
+    if (expectSemi) {
+        tid = ejLexGetToken(ep, state);
+        if (tid != TOK_SEMI && tid != TOK_NEWLINE) {
+            goto error;
+        }
         /*
             Skip newline after semi-colon
          */
-		ejRemoveNewlines(ep, state);
-	}
+        ejRemoveNewlines(ep, state);
+    }
 
 doneParse:
-	if (tid == TOK_FOR) {
-		ejLexFreeInputState(ep, &condScript);
-		ejLexFreeInputState(ep, &incrScript);
-		ejLexFreeInputState(ep, &endScript);
-		ejLexFreeInputState(ep, &bodyScript);
-	}
-	if (state == STATE_STMT) {
-		return STATE_STMT_DONE;
-	} else if (state == STATE_DEC) {
-		return STATE_DEC_DONE;
-	} else if (state == STATE_EXPR) {
-		return STATE_EXPR_DONE;
-	} else if (state == STATE_EOF) {
-		return state;
-	} else {
-		return STATE_ERR;
-	}
+    if (tid == TOK_FOR) {
+        ejLexFreeInputState(ep, &condScript);
+        ejLexFreeInputState(ep, &incrScript);
+        ejLexFreeInputState(ep, &endScript);
+        ejLexFreeInputState(ep, &bodyScript);
+    }
+    if (state == STATE_STMT) {
+        return STATE_STMT_DONE;
+    } else if (state == STATE_DEC) {
+        return STATE_DEC_DONE;
+    } else if (state == STATE_EXPR) {
+        return STATE_EXPR_DONE;
+    } else if (state == STATE_EOF) {
+        return state;
+    } else {
+        return STATE_ERR;
+    }
 
 error:
-	state = STATE_ERR;
-	goto doneParse;
+    state = STATE_ERR;
+    goto doneParse;
 }
 
 
@@ -857,46 +857,46 @@ error:
  */
 static int parseDeclaration(ej_t *ep, int state, int flags)
 {
-	int		tid;
+    int     tid;
 
-	a_assert(ep);
+    a_assert(ep);
 
     /*
-      	Declarations can be of the following forms:
-      			var x;
-      			var x, y, z;
-      			var x = 1 + 2 / 3, y = 2 + 4;
+        Declarations can be of the following forms:
+                var x;
+                var x, y, z;
+                var x = 1 + 2 / 3, y = 2 + 4;
       
-      	We set the variable to NULL if there is no associated assignment.
+        We set the variable to NULL if there is no associated assignment.
      */
-	do {
-		if ((tid = ejLexGetToken(ep, state)) != TOK_ID) {
-			return STATE_ERR;
-		}
-		ejLexPutbackToken(ep, tid, ep->token);
+    do {
+        if ((tid = ejLexGetToken(ep, state)) != TOK_ID) {
+            return STATE_ERR;
+        }
+        ejLexPutbackToken(ep, tid, ep->token);
 
         /*
             Parse the entire assignment or simple identifier declaration
          */
-		if (parse(ep, STATE_DEC, flags) != STATE_DEC_DONE) {
-			return STATE_ERR;
-		}
+        if (parse(ep, STATE_DEC, flags) != STATE_DEC_DONE) {
+            return STATE_ERR;
+        }
 
         /*
             Peek at the next token, continue if comma seen
          */
-		tid = ejLexGetToken(ep, state);
-		if (tid == TOK_SEMI) {
-			return STATE_DEC_LIST_DONE;
-		} else if (tid != TOK_COMMA) {
-			return STATE_ERR;
-		}
-	} while (tid == TOK_COMMA);
-
-	if (tid != TOK_SEMI) {
-		return STATE_ERR;
-	}
-	return STATE_DEC_LIST_DONE;
+        tid = ejLexGetToken(ep, state);
+        if (tid == TOK_SEMI) {
+            return STATE_DEC_LIST_DONE;
+        } else if (tid != TOK_COMMA) {
+            return STATE_ERR;
+        }
+    } while (tid == TOK_COMMA);
+
+    if (tid != TOK_SEMI) {
+        return STATE_ERR;
+    }
+    return STATE_DEC_LIST_DONE;
 }
 
 
@@ -905,33 +905,33 @@ static int parseDeclaration(ej_t *ep, int state, int flags)
  */
 static int parseArgs(ej_t *ep, int state, int flags)
 {
-	int		tid, aid;
-
-	a_assert(ep);
-
-	do {
-		state = parse(ep, STATE_RELEXP, flags);
-		if (state == STATE_EOF || state == STATE_ERR) {
-			return state;
-		}
-		if (state == STATE_RELEXP_DONE) {
-			aid = hAlloc((void***) &ep->func->args);
-			ep->func->args[aid] = bstrdup(B_L, ep->result);
-			ep->func->nArgs++;
-		}
+    int     tid, aid;
+
+    a_assert(ep);
+
+    do {
+        state = parse(ep, STATE_RELEXP, flags);
+        if (state == STATE_EOF || state == STATE_ERR) {
+            return state;
+        }
+        if (state == STATE_RELEXP_DONE) {
+            aid = hAlloc((void***) &ep->func->args);
+            ep->func->args[aid] = bstrdup(B_L, ep->result);
+            ep->func->nArgs++;
+        }
         /*
             Peek at the next token, continue if more args (ie. comma seen)
          */
-		tid = ejLexGetToken(ep, state);
-		if (tid != TOK_COMMA) {
-			ejLexPutbackToken(ep, tid, ep->token);
-		}
-	} while (tid == TOK_COMMA);
-
-	if (tid != TOK_RPAREN && state != STATE_RELEXP_DONE) {
-		return STATE_ERR;
-	}
-	return STATE_ARG_LIST_DONE;
+        tid = ejLexGetToken(ep, state);
+        if (tid != TOK_COMMA) {
+            ejLexPutbackToken(ep, tid, ep->token);
+        }
+    } while (tid == TOK_COMMA);
+
+    if (tid != TOK_RPAREN && state != STATE_RELEXP_DONE) {
+        return STATE_ERR;
+    }
+    return STATE_ARG_LIST_DONE;
 }
 
 
@@ -940,568 +940,568 @@ static int parseArgs(ej_t *ep, int state, int flags)
  */
 static int parseCond(ej_t *ep, int state, int flags)
 {
-	char_t	*lhs, *rhs;
-	int		tid, operator;
+    char_t  *lhs, *rhs;
+    int     tid, operator;
 
-	a_assert(ep);
+    a_assert(ep);
 
-	setString(B_L, &ep->result, T(""));
-	rhs = lhs = NULL;
-	operator = 0;
+    setString(B_L, &ep->result, T(""));
+    rhs = lhs = NULL;
+    operator = 0;
 
-	do {
+    do {
 /*
- *	Recurse to handle one side of a conditional. Accumulate the
- *	left hand side and the final result in ep->result.
+ *  Recurse to handle one side of a conditional. Accumulate the
+ *  left hand side and the final result in ep->result.
  */
-		state = parse(ep, STATE_RELEXP, flags);
-		if (state != STATE_RELEXP_DONE) {
-			state = STATE_ERR;
-			break;
-		}
-
-		if (operator > 0) {
-			setString(B_L, &rhs, ep->result);
-			if (evalCond(ep, lhs, operator, rhs) < 0) {
-				state = STATE_ERR;
-				break;
-			}
-		}
-		setString(B_L, &lhs, ep->result);
-
-		tid = ejLexGetToken(ep, state);
-		if (tid == TOK_LOGICAL) {
-			operator = (int) *ep->token;
-
-		} else if (tid == TOK_RPAREN || tid == TOK_SEMI) {
-			ejLexPutbackToken(ep, tid, ep->token);
-			state = STATE_COND_DONE;
-			break;
-
-		} else {
-			ejLexPutbackToken(ep, tid, ep->token);
-		}
-
-	} while (state == STATE_RELEXP_DONE);
-
-	if (lhs) {
-		bfree(B_L, lhs);
-	}
-
-	if (rhs) {
-		bfree(B_L, rhs);
-	}
-	return state;
+        state = parse(ep, STATE_RELEXP, flags);
+        if (state != STATE_RELEXP_DONE) {
+            state = STATE_ERR;
+            break;
+        }
+
+        if (operator > 0) {
+            setString(B_L, &rhs, ep->result);
+            if (evalCond(ep, lhs, operator, rhs) < 0) {
+                state = STATE_ERR;
+                break;
+            }
+        }
+        setString(B_L, &lhs, ep->result);
+
+        tid = ejLexGetToken(ep, state);
+        if (tid == TOK_LOGICAL) {
+            operator = (int) *ep->token;
+
+        } else if (tid == TOK_RPAREN || tid == TOK_SEMI) {
+            ejLexPutbackToken(ep, tid, ep->token);
+            state = STATE_COND_DONE;
+            break;
+
+        } else {
+            ejLexPutbackToken(ep, tid, ep->token);
+        }
+
+    } while (state == STATE_RELEXP_DONE);
+
+    if (lhs) {
+        bfree(B_L, lhs);
+    }
+
+    if (rhs) {
+        bfree(B_L, rhs);
+    }
+    return state;
 }
 
 
 /*
-  	Parse expression (leftHandSide operator rightHandSide)
+    Parse expression (leftHandSide operator rightHandSide)
  */
 static int parseExpr(ej_t *ep, int state, int flags)
 {
-	char_t	*lhs, *rhs;
-	int		rel, tid;
+    char_t  *lhs, *rhs;
+    int     rel, tid;
 
-	a_assert(ep);
+    a_assert(ep);
 
-	setString(B_L, &ep->result, T(""));
-	rhs = lhs = NULL;
-	rel = 0;
-	tid = 0;
+    setString(B_L, &ep->result, T(""));
+    rhs = lhs = NULL;
+    rel = 0;
+    tid = 0;
 
-	do {
+    do {
         /*
             This loop will handle an entire expression list. We call parse to evalutate each term which returns the
             result in ep->result.  
          */
-		if (tid == TOK_LOGICAL) {
-			if ((state = parse(ep, STATE_RELEXP, flags)) != STATE_RELEXP_DONE) {
-				state = STATE_ERR;
-				break;
-			}
-		} else {
-			if ((state = parse(ep, STATE_EXPR, flags)) != STATE_EXPR_DONE) {
-				state = STATE_ERR;
-				break;
-			}
-		}
-
-		if (rel > 0) {
-			setString(B_L, &rhs, ep->result);
-			if (tid == TOK_LOGICAL) {
-				if (evalCond(ep, lhs, rel, rhs) < 0) {
-					state = STATE_ERR;
-					break;
-				}
-			} else {
-				if (evalExpr(ep, lhs, rel, rhs) < 0) {
-					state = STATE_ERR;
-					break;
-				}
-			}
-		}
-		setString(B_L, &lhs, ep->result);
-
-		if ((tid = ejLexGetToken(ep, state)) == TOK_EXPR ||
-			 tid == TOK_INC_DEC || tid == TOK_LOGICAL) {
-			rel = (int) *ep->token;
-
-		} else {
-			ejLexPutbackToken(ep, tid, ep->token);
-			state = STATE_RELEXP_DONE;
-		}
-
-	} while (state == STATE_EXPR_DONE);
-
-	if (rhs) {
-		bfree(B_L, rhs);
-	}
-
-	if (lhs) {
-		bfree(B_L, lhs);
-	}
-
-	return state;
+        if (tid == TOK_LOGICAL) {
+            if ((state = parse(ep, STATE_RELEXP, flags)) != STATE_RELEXP_DONE) {
+                state = STATE_ERR;
+                break;
+            }
+        } else {
+            if ((state = parse(ep, STATE_EXPR, flags)) != STATE_EXPR_DONE) {
+                state = STATE_ERR;
+                break;
+            }
+        }
+
+        if (rel > 0) {
+            setString(B_L, &rhs, ep->result);
+            if (tid == TOK_LOGICAL) {
+                if (evalCond(ep, lhs, rel, rhs) < 0) {
+                    state = STATE_ERR;
+                    break;
+                }
+            } else {
+                if (evalExpr(ep, lhs, rel, rhs) < 0) {
+                    state = STATE_ERR;
+                    break;
+                }
+            }
+        }
+        setString(B_L, &lhs, ep->result);
+
+        if ((tid = ejLexGetToken(ep, state)) == TOK_EXPR ||
+             tid == TOK_INC_DEC || tid == TOK_LOGICAL) {
+            rel = (int) *ep->token;
+
+        } else {
+            ejLexPutbackToken(ep, tid, ep->token);
+            state = STATE_RELEXP_DONE;
+        }
+
+    } while (state == STATE_EXPR_DONE);
+
+    if (rhs) {
+        bfree(B_L, rhs);
+    }
+
+    if (lhs) {
+        bfree(B_L, lhs);
+    }
+
+    return state;
 }
 
 
 /*
-  	Evaluate a condition. Implements &&, ||, !
+    Evaluate a condition. Implements &&, ||, !
  */
 static int evalCond(ej_t *ep, char_t *lhs, int rel, char_t *rhs)
 {
-	char_t	buf[16];
-	int		l, r, lval;
-
-	a_assert(lhs);
-	a_assert(rhs);
-	a_assert(rel > 0);
-
-	lval = 0;
-	if (gisdigit((int)*lhs) && gisdigit((int)*rhs)) {
-		l = gatoi(lhs);
-		r = gatoi(rhs);
-		switch (rel) {
-		case COND_AND:
-			lval = l && r;
-			break;
-		case COND_OR:
-			lval = l || r;
-			break;
-		default:
-			ejError(ep, T("Bad operator %d"), rel);
-			return -1;
-		}
-	} else {
-		if (!gisdigit((int)*lhs)) {
-			ejError(ep, T("Conditional must be numeric"), lhs);
-		} else {
-			ejError(ep, T("Conditional must be numeric"), rhs);
-		}
-	}
-
-	stritoa(lval, buf, sizeof(buf));
-	setString(B_L, &ep->result, buf);
-	return 0;
+    char_t  buf[16];
+    int     l, r, lval;
+
+    a_assert(lhs);
+    a_assert(rhs);
+    a_assert(rel > 0);
+
+    lval = 0;
+    if (gisdigit((int)*lhs) && gisdigit((int)*rhs)) {
+        l = gatoi(lhs);
+        r = gatoi(rhs);
+        switch (rel) {
+        case COND_AND:
+            lval = l && r;
+            break;
+        case COND_OR:
+            lval = l || r;
+            break;
+        default:
+            ejError(ep, T("Bad operator %d"), rel);
+            return -1;
+        }
+    } else {
+        if (!gisdigit((int)*lhs)) {
+            ejError(ep, T("Conditional must be numeric"), lhs);
+        } else {
+            ejError(ep, T("Conditional must be numeric"), rhs);
+        }
+    }
+
+    stritoa(lval, buf, sizeof(buf));
+    setString(B_L, &ep->result, buf);
+    return 0;
 }
 
 
 /*
-  	Evaluate an operation
+    Evaluate an operation
  */
 static int evalExpr(ej_t *ep, char_t *lhs, int rel, char_t *rhs)
 {
-	char_t	*cp, buf[16];
-	int		numeric, l, r, lval;
+    char_t  *cp, buf[16];
+    int     numeric, l, r, lval;
 
-	a_assert(lhs);
-	a_assert(rhs);
-	a_assert(rel > 0);
+    a_assert(lhs);
+    a_assert(rhs);
+    a_assert(rel > 0);
 
     /*
-      	All of the characters in the lhs and rhs must be numeric
+        All of the characters in the lhs and rhs must be numeric
      */
-	numeric = 1;
-	for (cp = lhs; *cp; cp++) {
-		if (!gisdigit((int)*cp)) {
-			numeric = 0;
-			break;
-		}
-	}
-
-	if (numeric) {
-		for (cp = rhs; *cp; cp++) {
-			if (!gisdigit((int)*cp)) {
-				numeric = 0;
-				break;
-			}
-		}
-	}
-
-	if (numeric) {
-		l = gatoi(lhs);
-		r = gatoi(rhs);
-		switch (rel) {
-		case EXPR_PLUS:
-			lval = l + r;
-			break;
-		case EXPR_INC:
-			lval = l + 1;
-			break;
-		case EXPR_MINUS:
-			lval = l - r;
-			break;
-		case EXPR_DEC:
-			lval = l - 1;
-			break;
-		case EXPR_MUL:
-			lval = l * r;
-			break;
-		case EXPR_DIV:
-			if (r != 0) {
-				lval = l / r;
-			} else {
-				lval = 0;
-			}
-			break;
-		case EXPR_MOD:
-			if (r != 0) {
-				lval = l % r;
-			} else {
-				lval = 0;
-			}
-			break;
-		case EXPR_LSHIFT:
-			lval = l << r;
-			break;
-		case EXPR_RSHIFT:
-			lval = l >> r;
-			break;
-		case EXPR_EQ:
-			lval = l == r;
-			break;
-		case EXPR_NOTEQ:
-			lval = l != r;
-			break;
-		case EXPR_LESS:
-			lval = (l < r) ? 1 : 0;
-			break;
-		case EXPR_LESSEQ:
-			lval = (l <= r) ? 1 : 0;
-			break;
-		case EXPR_GREATER:
-			lval = (l > r) ? 1 : 0;
-			break;
-		case EXPR_GREATEREQ:
-			lval = (l >= r) ? 1 : 0;
-			break;
-		case EXPR_BOOL_COMP:
-			lval = (r == 0) ? 1 : 0;
-			break;
-		default:
-			ejError(ep, T("Bad operator %d"), rel);
-			return -1;
-		}
-
-	} else {
-		switch (rel) {
-		case EXPR_PLUS:
-			clearString(&ep->result);
-			appendString(&ep->result, lhs);
-			appendString(&ep->result, rhs);
-			return 0;
-		case EXPR_LESS:
-			lval = gstrcmp(lhs, rhs) < 0;
-			break;
-		case EXPR_LESSEQ:
-			lval = gstrcmp(lhs, rhs) <= 0;
-			break;
-		case EXPR_GREATER:
-			lval = gstrcmp(lhs, rhs) > 0;
-			break;
-		case EXPR_GREATEREQ:
-			lval = gstrcmp(lhs, rhs) >= 0;
-			break;
-		case EXPR_EQ:
-			lval = gstrcmp(lhs, rhs) == 0;
-			break;
-		case EXPR_NOTEQ:
-			lval = gstrcmp(lhs, rhs) != 0;
-			break;
-		case EXPR_INC:
-		case EXPR_DEC:
-		case EXPR_MINUS:
-		case EXPR_DIV:
-		case EXPR_MOD:
-		case EXPR_LSHIFT:
-		case EXPR_RSHIFT:
-		default:
-			ejError(ep, T("Bad operator"));
-			return -1;
-		}
-	}
-
-	stritoa(lval, buf, sizeof(buf));
-	setString(B_L, &ep->result, buf);
-	return 0;
+    numeric = 1;
+    for (cp = lhs; *cp; cp++) {
+        if (!gisdigit((int)*cp)) {
+            numeric = 0;
+            break;
+        }
+    }
+
+    if (numeric) {
+        for (cp = rhs; *cp; cp++) {
+            if (!gisdigit((int)*cp)) {
+                numeric = 0;
+                break;
+            }
+        }
+    }
+
+    if (numeric) {
+        l = gatoi(lhs);
+        r = gatoi(rhs);
+        switch (rel) {
+        case EXPR_PLUS:
+            lval = l + r;
+            break;
+        case EXPR_INC:
+            lval = l + 1;
+            break;
+        case EXPR_MINUS:
+            lval = l - r;
+            break;
+        case EXPR_DEC:
+            lval = l - 1;
+            break;
+        case EXPR_MUL:
+            lval = l * r;
+            break;
+        case EXPR_DIV:
+            if (r != 0) {
+                lval = l / r;
+            } else {
+                lval = 0;
+            }
+            break;
+        case EXPR_MOD:
+            if (r != 0) {
+                lval = l % r;
+            } else {
+                lval = 0;
+            }
+            break;
+        case EXPR_LSHIFT:
+            lval = l << r;
+            break;
+        case EXPR_RSHIFT:
+            lval = l >> r;
+            break;
+        case EXPR_EQ:
+            lval = l == r;
+            break;
+        case EXPR_NOTEQ:
+            lval = l != r;
+            break;
+        case EXPR_LESS:
+            lval = (l < r) ? 1 : 0;
+            break;
+        case EXPR_LESSEQ:
+            lval = (l <= r) ? 1 : 0;
+            break;
+        case EXPR_GREATER:
+            lval = (l > r) ? 1 : 0;
+            break;
+        case EXPR_GREATEREQ:
+            lval = (l >= r) ? 1 : 0;
+            break;
+        case EXPR_BOOL_COMP:
+            lval = (r == 0) ? 1 : 0;
+            break;
+        default:
+            ejError(ep, T("Bad operator %d"), rel);
+            return -1;
+        }
+
+    } else {
+        switch (rel) {
+        case EXPR_PLUS:
+            clearString(&ep->result);
+            appendString(&ep->result, lhs);
+            appendString(&ep->result, rhs);
+            return 0;
+        case EXPR_LESS:
+            lval = gstrcmp(lhs, rhs) < 0;
+            break;
+        case EXPR_LESSEQ:
+            lval = gstrcmp(lhs, rhs) <= 0;
+            break;
+        case EXPR_GREATER:
+            lval = gstrcmp(lhs, rhs) > 0;
+            break;
+        case EXPR_GREATEREQ:
+            lval = gstrcmp(lhs, rhs) >= 0;
+            break;
+        case EXPR_EQ:
+            lval = gstrcmp(lhs, rhs) == 0;
+            break;
+        case EXPR_NOTEQ:
+            lval = gstrcmp(lhs, rhs) != 0;
+            break;
+        case EXPR_INC:
+        case EXPR_DEC:
+        case EXPR_MINUS:
+        case EXPR_DIV:
+        case EXPR_MOD:
+        case EXPR_LSHIFT:
+        case EXPR_RSHIFT:
+        default:
+            ejError(ep, T("Bad operator"));
+            return -1;
+        }
+    }
+
+    stritoa(lval, buf, sizeof(buf));
+    setString(B_L, &ep->result, buf);
+    return 0;
 }
 
 
 /*
-  	Evaluate a function
+    Evaluate a function
  */
 static int evalFunction(ej_t *ep)
 {
-	sym_t	*sp;
-	int		(*fn)(int eid, void *handle, int argc, char_t **argv);
-
-	if ((sp = symLookup(ep->functions, ep->func->fname)) == NULL) {
-		ejError(ep, T("Undefined procedure %s"), ep->func->fname);
-		return -1;
-	}
-	fn = (int (*)(int, void*, int, char_t**)) sp->content.value.integer;
-	if (fn == NULL) {
-		ejError(ep, T("Undefined procedure %s"), ep->func->fname);
-		return -1;
-	}
-	return (*fn)(ep->eid, ep->userHandle, ep->func->nArgs, ep->func->args);
+    sym_t   *sp;
+    int     (*fn)(int eid, void *handle, int argc, char_t **argv);
+
+    if ((sp = symLookup(ep->functions, ep->func->fname)) == NULL) {
+        ejError(ep, T("Undefined procedure %s"), ep->func->fname);
+        return -1;
+    }
+    fn = (int (*)(int, void*, int, char_t**)) sp->content.value.integer;
+    if (fn == NULL) {
+        ejError(ep, T("Undefined procedure %s"), ep->func->fname);
+        return -1;
+    }
+    return (*fn)(ep->eid, ep->userHandle, ep->func->nArgs, ep->func->args);
 }
 
 
 /*
-  	Output a parse ej_error message
+    Output a parse ej_error message
  */
 void ejError(ej_t* ep, char_t* fmt, ...)
 {
-	va_list		args;
-	ejinput_t	*ip;
-	char_t		*errbuf, *msgbuf;
-
-	a_assert(ep);
-	a_assert(fmt);
-	ip = ep->input;
-
-	va_start(args, fmt);
-	msgbuf = NULL;
-	fmtValloc(&msgbuf, E_MAX_ERROR, fmt, args);
-	va_end(args);
-
-	if (ep && ip) {
-		fmtAlloc(&errbuf, E_MAX_ERROR, T("%s\n At line %d, line => \n\n%s\n"), msgbuf, ip->lineNumber, ip->line);
-		bfreeSafe(B_L, ep->error);
-		ep->error = errbuf;
-	}
-	bfreeSafe(B_L, msgbuf);
+    va_list     args;
+    ejinput_t   *ip;
+    char_t      *errbuf, *msgbuf;
+
+    a_assert(ep);
+    a_assert(fmt);
+    ip = ep->input;
+
+    va_start(args, fmt);
+    msgbuf = NULL;
+    fmtValloc(&msgbuf, E_MAX_ERROR, fmt, args);
+    va_end(args);
+
+    if (ep && ip) {
+        fmtAlloc(&errbuf, E_MAX_ERROR, T("%s\n At line %d, line => \n\n%s\n"), msgbuf, ip->lineNumber, ip->line);
+        bfreeSafe(B_L, ep->error);
+        ep->error = errbuf;
+    }
+    bfreeSafe(B_L, msgbuf);
 }
 
 
 static void clearString(char_t **ptr)
 {
-	a_assert(ptr);
+    a_assert(ptr);
 
-	if (*ptr) {
-		bfree(B_L, *ptr);
-	}
-	*ptr = NULL;
+    if (*ptr) {
+        bfree(B_L, *ptr);
+    }
+    *ptr = NULL;
 }
 
 
 static void setString(B_ARGS_DEC, char_t **ptr, char_t *s)
 {
-	a_assert(ptr);
+    a_assert(ptr);
 
-	if (*ptr) {
-		bfree(B_ARGS, *ptr);
-	}
-	*ptr = bstrdup(B_ARGS, s);
+    if (*ptr) {
+        bfree(B_ARGS, *ptr);
+    }
+    *ptr = bstrdup(B_ARGS, s);
 }
 
 
 static void appendString(char_t **ptr, char_t *s)
 {
-	int	len, oldlen, size;
+    int len, oldlen, size;
 
-	a_assert(ptr);
+    a_assert(ptr);
 
-	if (*ptr) {
-		len = gstrlen(s);
-		oldlen = gstrlen(*ptr);
-		size = (len + oldlen + 1) * sizeof(char_t);
-		*ptr = brealloc(B_L, *ptr, size);
+    if (*ptr) {
+        len = gstrlen(s);
+        oldlen = gstrlen(*ptr);
+        size = (len + oldlen + 1) * sizeof(char_t);
+        *ptr = brealloc(B_L, *ptr, size);
 #if !defined(WIN32)
-		gstrcpy(&(*ptr)[oldlen], s);
+        gstrcpy(&(*ptr)[oldlen], s);
 #else
-		strcpy_s(&(*ptr)[oldlen], size - oldlen, s);
+        strcpy_s(&(*ptr)[oldlen], size - oldlen, s);
 #endif
-	} else {
-		*ptr = bstrdup(B_L, s);
-	}
+    } else {
+        *ptr = bstrdup(B_L, s);
+    }
 }
 
 
 /*
-  	Define a function
+    Define a function
  */
 int ejSetGlobalFunction(int eid, char_t *name, int (*fn)(int eid, void *handle, int argc, char_t **argv))
 {
-	ej_t	*ep;
+    ej_t    *ep;
 
-	if ((ep = ejPtr(eid)) == NULL) {
-		return -1;
-	}
-	return ejSetGlobalFunctionDirect(ep->functions, name, fn);
+    if ((ep = ejPtr(eid)) == NULL) {
+        return -1;
+    }
+    return ejSetGlobalFunctionDirect(ep->functions, name, fn);
 }
 
 
 /*
-  	Define a function directly into the function symbol table.
+    Define a function directly into the function symbol table.
  */
 int ejSetGlobalFunctionDirect(sym_fd_t functions, char_t *name, int (*fn)(int eid, void *handle, int argc, char_t **argv))
 {
-	if (symEnter(functions, name, valueInteger((long) fn), 0) == NULL) {
-		return -1;
-	}
-	return 0;
+    if (symEnter(functions, name, valueInteger((long) fn), 0) == NULL) {
+        return -1;
+    }
+    return 0;
 }
 
 
 /*
-  	Remove ("undefine") a function
+    Remove ("undefine") a function
  */
 int ejRemoveGlobalFunction(int eid, char_t *name)
 {
-	ej_t	*ep;
+    ej_t    *ep;
 
-	if ((ep = ejPtr(eid)) == NULL) {
-		return -1;
-	}
-	return symDelete(ep->functions, name);
+    if ((ep = ejPtr(eid)) == NULL) {
+        return -1;
+    }
+    return symDelete(ep->functions, name);
 }
 
 
 void *ejGetGlobalFunction(int eid, char_t *name)
 {
-	ej_t	*ep;
-	sym_t	*sp;
-	int		(*fn)(int eid, void *handle, int argc, char_t **argv);
-
-	if ((ep = ejPtr(eid)) == NULL) {
-		return NULL;
-	}
-
-	if ((sp = symLookup(ep->functions, name)) != NULL) {
-		fn = (int (*)(int, void*, int, char_t**)) sp->content.value.integer;
-		return (void*) fn;
-	}
-	return NULL;
+    ej_t    *ep;
+    sym_t   *sp;
+    int     (*fn)(int eid, void *handle, int argc, char_t **argv);
+
+    if ((ep = ejPtr(eid)) == NULL) {
+        return NULL;
+    }
+
+    if ((sp = symLookup(ep->functions, name)) != NULL) {
+        fn = (int (*)(int, void*, int, char_t**)) sp->content.value.integer;
+        return (void*) fn;
+    }
+    return NULL;
 }
 
 
 /*
-  	Utility routine to crack Ejscript arguments. Return the number of args
-  	seen. This routine only supports %s and %d type args.
+    Utility routine to crack Ejscript arguments. Return the number of args
+    seen. This routine only supports %s and %d type args.
   
-  	Typical usage:
+    Typical usage:
   
-  		if (ejArgs(argc, argv, "%s %d", &name, &age) < 2) {
-  			error("Insufficient args\n");
-  			return -1;
-  		}
+        if (ejArgs(argc, argv, "%s %d", &name, &age) < 2) {
+            error("Insufficient args\n");
+            return -1;
+        }
  */
 int ejArgs(int argc, char_t **argv, char_t *fmt, ...)
 {
-	va_list	vargs;
-	char_t	*cp, **sp;
-	int		*ip;
-	int		argn;
-
-	va_start(vargs, fmt);
-
-	if (argv == NULL) {
-		return 0;
-	}
-	for (argn = 0, cp = fmt; cp && *cp && argv[argn]; ) {
-		if (*cp++ != '%') {
-			continue;
-		}
-		switch (*cp) {
-		case 'd':
-			ip = va_arg(vargs, int*);
-			*ip = gatoi(argv[argn]);
-			break;
-
-		case 's':
-			sp = va_arg(vargs, char_t**);
-			*sp = argv[argn];
-			break;
-
-		default:
+    va_list vargs;
+    char_t  *cp, **sp;
+    int     *ip;
+    int     argn;
+
+    va_start(vargs, fmt);
+
+    if (argv == NULL) {
+        return 0;
+    }
+    for (argn = 0, cp = fmt; cp && *cp && argv[argn]; ) {
+        if (*cp++ != '%') {
+            continue;
+        }
+        switch (*cp) {
+        case 'd':
+            ip = va_arg(vargs, int*);
+            *ip = gatoi(argv[argn]);
+            break;
+
+        case 's':
+            sp = va_arg(vargs, char_t**);
+            *sp = argv[argn];
+            break;
+
+        default:
             /*
                 Unsupported
              */
-			a_assert(0);
-		}
-		argn++;
-	}
+            a_assert(0);
+        }
+        argn++;
+    }
 
-	va_end(vargs);
-	return argn;
+    va_end(vargs);
+    return argn;
 }
 
 
 void ejSetUserHandle(int eid, void* handle)
 {
-	ej_t	*ep;
+    ej_t    *ep;
 
-	if ((ep = ejPtr(eid)) == NULL) {
-		return;
-	}
-	ep->userHandle = handle;
+    if ((ep = ejPtr(eid)) == NULL) {
+        return;
+    }
+    ep->userHandle = handle;
 }
 
 
 void* ejGetUserHandle(int eid)
 {
-	ej_t	*ep;
+    ej_t    *ep;
 
-	if ((ep = ejPtr(eid)) == NULL) {
-		return NULL;
-	}
-	return ep->userHandle;
+    if ((ep = ejPtr(eid)) == NULL) {
+        return NULL;
+    }
+    return ep->userHandle;
 }
 
 
 int ejGetLineNumber(int eid)
 {
-	ej_t	*ep;
+    ej_t    *ep;
 
-	if ((ep = ejPtr(eid)) == NULL) {
-		return -1;
-	}
-	return ep->input->lineNumber;
+    if ((ep = ejPtr(eid)) == NULL) {
+        return -1;
+    }
+    return ep->input->lineNumber;
 }
 
 
 void ejSetResult(int eid, char_t *s)
 {
-	ej_t	*ep;
+    ej_t    *ep;
 
-	if ((ep = ejPtr(eid)) == NULL) {
-		return;
-	}
-	setString(B_L, &ep->result, s);
+    if ((ep = ejPtr(eid)) == NULL) {
+        return;
+    }
+    setString(B_L, &ep->result, s);
 }
 
 
 char_t *ejGetResult(int eid)
 {
-	ej_t	*ep;
+    ej_t    *ep;
 
-	if ((ep = ejPtr(eid)) == NULL) {
-		return NULL;
-	}
-	return ep->result;
+    if ((ep = ejPtr(eid)) == NULL) {
+        return NULL;
+    }
+    return ep->result;
 }
 
 /*
@@ -1510,20 +1510,20 @@ char_t *ejGetResult(int eid)
  */
 void ejSetVar(int eid, char_t *var, char_t *value)
 {
-	ej_t	*ep;
-	value_t	v;
-
-	a_assert(var && *var);
-
-	if ((ep = ejPtr(eid)) == NULL) {
-		return;
-	}
-	if (value == NULL) {
-		v = valueString(value, 0);
-	} else {
-		v = valueString(value, VALUE_ALLOCATE);
-	}
-	symEnter(ep->variables[ep->variableMax - 1] - EJ_OFFSET, var, v, 0);
+    ej_t    *ep;
+    value_t v;
+
+    a_assert(var && *var);
+
+    if ((ep = ejPtr(eid)) == NULL) {
+        return;
+    }
+    if (value == NULL) {
+        v = valueString(value, 0);
+    } else {
+        v = valueString(value, VALUE_ALLOCATE);
+    }
+    symEnter(ep->variables[ep->variableMax - 1] - EJ_OFFSET, var, v, 0);
 }
 
 
@@ -1533,21 +1533,21 @@ void ejSetVar(int eid, char_t *var, char_t *value)
  */
 void ejSetLocalVar(int eid, char_t *var, char_t *value)
 {
-	ej_t	*ep;
-	value_t	v;
+    ej_t    *ep;
+    value_t v;
 
-	a_assert(var && *var);
+    a_assert(var && *var);
 
-	if ((ep = ejPtr(eid)) == NULL) {
-		return;
-	}
+    if ((ep = ejPtr(eid)) == NULL) {
+        return;
+    }
 
-	if (value == NULL) {
-		v = valueString(value, 0);
-	} else {
-		v = valueString(value, VALUE_ALLOCATE);
-	}
-	symEnter(ep->variables[ep->variableMax - 1] - EJ_OFFSET, var, v, 0);
+    if (value == NULL) {
+        v = valueString(value, 0);
+    } else {
+        v = valueString(value, VALUE_ALLOCATE);
+    }
+    symEnter(ep->variables[ep->variableMax - 1] - EJ_OFFSET, var, v, 0);
 }
 
 
@@ -1557,119 +1557,119 @@ void ejSetLocalVar(int eid, char_t *var, char_t *value)
  */
 void ejSetGlobalVar(int eid, char_t *var, char_t *value)
 {
-	ej_t	*ep;
-	value_t v;
-
-	a_assert(var && *var);
-
-	if ((ep = ejPtr(eid)) == NULL) {
-		return;
-	}
-	if (value == NULL) {
-		v = valueString(value, 0);
-	} else {
-		v = valueString(value, VALUE_ALLOCATE);
-	}
-	symEnter(ep->variables[0] - EJ_OFFSET, var, v, 0);
+    ej_t    *ep;
+    value_t v;
+
+    a_assert(var && *var);
+
+    if ((ep = ejPtr(eid)) == NULL) {
+        return;
+    }
+    if (value == NULL) {
+        v = valueString(value, 0);
+    } else {
+        v = valueString(value, VALUE_ALLOCATE);
+    }
+    symEnter(ep->variables[0] - EJ_OFFSET, var, v, 0);
 }
 
 
 /*
-  	Get a variable
+    Get a variable
  */
 int ejGetVar(int eid, char_t *var, char_t **value)
 {
-	ej_t	*ep;
-	sym_t	*sp;
-	int		i;
-
-	a_assert(var && *var);
-	a_assert(value);
-
-	if ((ep = ejPtr(eid)) == NULL) {
-		return -1;
-	}
-
-	i = ep->variableMax - 1;
-	if ((sp = symLookup(ep->variables[i] - EJ_OFFSET, var)) == NULL) {
-		i = 0;
-		if ((sp = symLookup(ep->variables[0] - EJ_OFFSET, var)) == NULL) {
-			return -1;
-		}
-	}
-	a_assert(sp->content.type == string);
-	*value = sp->content.value.string;
-	return i;
+    ej_t    *ep;
+    sym_t   *sp;
+    int     i;
+
+    a_assert(var && *var);
+    a_assert(value);
+
+    if ((ep = ejPtr(eid)) == NULL) {
+        return -1;
+    }
+
+    i = ep->variableMax - 1;
+    if ((sp = symLookup(ep->variables[i] - EJ_OFFSET, var)) == NULL) {
+        i = 0;
+        if ((sp = symLookup(ep->variables[0] - EJ_OFFSET, var)) == NULL) {
+            return -1;
+        }
+    }
+    a_assert(sp->content.type == string);
+    *value = sp->content.value.string;
+    return i;
 }
 
 
 sym_fd_t ejGetVariableTable(int eid)
 {
-	ej_t	*ep;
+    ej_t    *ep;
 
-	if ((ep = ejPtr(eid)) == NULL) {
-		return -1;
-	}
-	return *ep->variables;
+    if ((ep = ejPtr(eid)) == NULL) {
+        return -1;
+    }
+    return *ep->variables;
 }
 
 
 sym_fd_t ejGetFunctionTable(int eid)
 {
-	ej_t	*ep;
+    ej_t    *ep;
 
-	if ((ep = ejPtr(eid)) == NULL) {
-		return -1;
-	}
-	return ep->functions;
+    if ((ep = ejPtr(eid)) == NULL) {
+        return -1;
+    }
+    return ep->functions;
 }
 
 
 /*
-  	Free an argument list
+    Free an argument list
  */
 static void freeFunc(ejfunc_t *func)
 {
-	int	i;
+    int i;
 
-	for (i = func->nArgs - 1; i >= 0; i--) {
-		bfree(B_L, func->args[i]);
-		func->nArgs = hFree((void***) &func->args, i);
-	}
+    for (i = func->nArgs - 1; i >= 0; i--) {
+        bfree(B_L, func->args[i]);
+        func->nArgs = hFree((void***) &func->args, i);
+    }
 
-	if (func->fname) {
-		bfree(B_L, func->fname);
-		func->fname = NULL;
-	}
+    if (func->fname) {
+        bfree(B_L, func->fname);
+        func->fname = NULL;
+    }
 }
 
 
 /*
-  	Get Ejscript pointer
+    Get Ejscript pointer
  */
 static ej_t *ejPtr(int eid)
 {
-	a_assert(0 <= eid && eid < ejMax);
+    a_assert(0 <= eid && eid < ejMax);
 
-	if (eid < 0 || eid >= ejMax || ejHandles[eid] == NULL) {
-		ejError(NULL, T("Bad handle %d"), eid);
-		return NULL;
-	}
-	return ejHandles[eid];
+    if (eid < 0 || eid >= ejMax || ejHandles[eid] == NULL) {
+        ejError(NULL, T("Bad handle %d"), eid);
+        return NULL;
+    }
+    return ejHandles[eid];
 }
 
 
 /*
-  	This function removes any new lines.  Used for else	cases, etc.
+    This function removes any new lines.  Used for else cases, etc.
  */
 static void ejRemoveNewlines(ej_t *ep, int state)
 {
-	int tid;
+    int tid;
 
-	do {
-		tid = ejLexGetToken(ep, state);
-	} while (tid == TOK_NEWLINE);
-	ejLexPutbackToken(ep, tid, ep->token);
+    do {
+        tid = ejLexGetToken(ep, state);
+    } while (tid == TOK_NEWLINE);
+    ejLexPutbackToken(ep, tid, ep->token);
 }
 
 /*
diff --git a/emfdb.c b/emfdb.c
index c059d261..449eb2c0 100644
--- a/emfdb.c
+++ b/emfdb.c
@@ -6,93 +6,93 @@
 
 /********************************* Includes ***********************************/
 
-#include	"emfdb.h"
-#include	"wsIntrn.h"
+#include    "emfdb.h"
+#include    "wsIntrn.h"
 
 /********************************* Defines ************************************/
 
-#define KEYWORD_TABLE	T("TABLE")
-#define KEYWORD_ROW		T("ROW")
+#define KEYWORD_TABLE   T("TABLE")
+#define KEYWORD_ROW     T("ROW")
 
 /*
-  	Variable to support the basicSet and basicGet functions.
+    Variable to support the basicSet and basicGet functions.
  */
-static char_t	*basicProdDir = NULL;		
-static char_t	*basicDefaultDir = T("."); /* Default set to current */
+static char_t   *basicProdDir = NULL;       
+static char_t   *basicDefaultDir = T("."); /* Default set to current */
 
 /*
    hAlloc chain list of table schemas to be closed 
  */
 
-static int			dbMaxTables = 0;
-static dbTable_t	**dbListTables = NULL;
+static int          dbMaxTables = 0;
+static dbTable_t    **dbListTables = NULL;
 
 /********************************** Forwards **********************************/
 
-static int		crack(char_t *buf, char_t **key, char_t **val);
-static char_t	*trim(char_t *str);
-static int		GetColumnIndex(int tid, char_t *colName);
+static int      crack(char_t *buf, char_t **key, char_t **val);
+static char_t   *trim(char_t *str);
+static int      GetColumnIndex(int tid, char_t *colName);
 
 /******************************************************************************/
 /* 
-  	Add a schema to the module-internal schema database 
+    Add a schema to the module-internal schema database 
  */
 int dbRegisterDBSchema(dbTable_t *pTableRegister)
 {
-	dbTable_t	*pTable;
-	int			tid;
+    dbTable_t   *pTable;
+    int         tid;
 
-	a_assert(pTableRegister);
+    a_assert(pTableRegister);
 
-	trace(4, T("DB: Registering database table <%s>\n"), pTableRegister->name);
+    trace(4, T("DB: Registering database table <%s>\n"), pTableRegister->name);
 
     /*
-      	Bump up the size of the table array
+        Bump up the size of the table array
      */
-	tid = hAllocEntry((void***) &dbListTables, &dbMaxTables, sizeof(dbTable_t));	
+    tid = hAllocEntry((void***) &dbListTables, &dbMaxTables, sizeof(dbTable_t));    
 
     /*
-      	Copy the table schema to the last spot in schema array
+        Copy the table schema to the last spot in schema array
      */
-	a_assert(dbListTables);
-	pTable = dbListTables[tid];
-	a_assert(pTable);
+    a_assert(dbListTables);
+    pTable = dbListTables[tid];
+    a_assert(pTable);
 
     /*
-      	Copy the name of the table
+        Copy the name of the table
      */
-	pTable->name = bstrdup(B_L, pTableRegister->name);
+    pTable->name = bstrdup(B_L, pTableRegister->name);
 
     /*
-      	Copy the number of columns
+        Copy the number of columns
      */
-	pTable->nColumns = pTableRegister->nColumns;
+    pTable->nColumns = pTableRegister->nColumns;
 
     /*
-      	Copy the column definitions
+        Copy the column definitions
      */
-	if (pTable->nColumns > 0) {
-		int i;
-		pTable->columnNames = balloc(B_L, sizeof(char_t *) * pTable->nColumns);
-		pTable->columnTypes = balloc(B_L, sizeof(int *) * pTable->nColumns);
+    if (pTable->nColumns > 0) {
+        int i;
+        pTable->columnNames = balloc(B_L, sizeof(char_t *) * pTable->nColumns);
+        pTable->columnTypes = balloc(B_L, sizeof(int *) * pTable->nColumns);
 
-		for (i = 0; (i < pTableRegister->nColumns); i++) {
-			pTable->columnNames[i] = bstrdup(B_L, pTableRegister->columnNames[i]);
-			pTable->columnTypes[i] = pTableRegister->columnTypes[i];
-		}
+        for (i = 0; (i < pTableRegister->nColumns); i++) {
+            pTable->columnNames[i] = bstrdup(B_L, pTableRegister->columnNames[i]);
+            pTable->columnTypes[i] = pTableRegister->columnTypes[i];
+        }
 
-	} else {
-		pTable->columnNames = NULL;
-		pTable->columnTypes = NULL;
-	}
+    } else {
+        pTable->columnNames = NULL;
+        pTable->columnTypes = NULL;
+    }
 
     /*
-      	Zero out the table's data (very important!)
+        Zero out the table's data (very important!)
      */
-	pTable->nRows = 0;
-	pTable->rows = NULL;
+    pTable->nRows = 0;
+    pTable->rows = NULL;
 
-	return 0;
+    return 0;
 }
 
 
@@ -102,151 +102,151 @@ int dbRegisterDBSchema(dbTable_t *pTableRegister)
  */
 int dbOpen(char_t *tablename, char_t *filename, int (*gettime)(int did), int flags)
 {
-	basicProdDir = NULL;		
-	basicDefaultDir = T(".");
-	dbMaxTables = 0;
-	dbListTables = NULL;
-	return 0;
+    basicProdDir = NULL;        
+    basicDefaultDir = T(".");
+    dbMaxTables = 0;
+    dbListTables = NULL;
+    return 0;
 }
 
 
 /*
-  	Delete all the rows of the tables, and all of the tables
+    Delete all the rows of the tables, and all of the tables
  */
 void dbClose(int did)
 {
-	int			table, column;
-	dbTable_t	*pTable;
+    int         table, column;
+    dbTable_t   *pTable;
 
     /*
-     j	Before doing anything, delete all the contents of the database
+     j  Before doing anything, delete all the contents of the database
      */
-	dbZero(did);
+    dbZero(did);
 
     /*
-      	Now delete the tables
+        Now delete the tables
      */
-	for (table = 0; table < dbMaxTables; table++) {
-		pTable = dbListTables[table];
+    for (table = 0; table < dbMaxTables; table++) {
+        pTable = dbListTables[table];
 
-		if (pTable != NULL) {
+        if (pTable != NULL) {
             /*
                 Delete the table schema
              */
-			if (pTable->nColumns) {
-				for (column = 0; column < pTable->nColumns; column++) {
-					bfreeSafe(B_L, pTable->columnNames[column]);
-				}
-				bfreeSafe(B_L, pTable->columnNames);
-				bfreeSafe(B_L, pTable->columnTypes);
-			}
+            if (pTable->nColumns) {
+                for (column = 0; column < pTable->nColumns; column++) {
+                    bfreeSafe(B_L, pTable->columnNames[column]);
+                }
+                bfreeSafe(B_L, pTable->columnNames);
+                bfreeSafe(B_L, pTable->columnTypes);
+            }
             /*
                 Delete the table name
              */
-			bfreeSafe(B_L, pTable->name);
+            bfreeSafe(B_L, pTable->name);
             /*
                 Free the table
              */
-			bfreeSafe(B_L, pTable);
-			hFree((void ***) &dbListTables, table);
-		}
-	}
+            bfreeSafe(B_L, pTable);
+            hFree((void ***) &dbListTables, table);
+        }
+    }
 
-	if (dbListTables) {
-		bfree(B_L, dbListTables);
-	}
+    if (dbListTables) {
+        bfree(B_L, dbListTables);
+    }
 
     /*
-      	Set the global table list to a safe value
+        Set the global table list to a safe value
      */
-	dbListTables = NULL;
-	dbMaxTables = 0;
+    dbListTables = NULL;
+    dbMaxTables = 0;
 }
 
 
 /*
-  	Delete all the data records in all tables
+    Delete all the data records in all tables
  */
 void dbZero(int did)
 {
-	int			table, row, column, nRows, nColumns;
-	int			*pRow;
-	dbTable_t	*pTable;
+    int         table, row, column, nRows, nColumns;
+    int         *pRow;
+    dbTable_t   *pTable;
 
     /*
-      	Delete all data from all tables
+        Delete all data from all tables
      */
-	for (table = 0; table < dbMaxTables; table++) {
-		pTable = dbListTables[table];
+    for (table = 0; table < dbMaxTables; table++) {
+        pTable = dbListTables[table];
         /*
-          		Delete the row data contained within the schema
+                Delete the row data contained within the schema
          */
-		if (pTable) {
-			nColumns = pTable->nColumns;
-			nRows = pTable->nRows;
-			for (row = 0; row < nRows; row++) {
-				pRow = pTable->rows[row];
-				if (pRow) {
+        if (pTable) {
+            nColumns = pTable->nColumns;
+            nRows = pTable->nRows;
+            for (row = 0; row < nRows; row++) {
+                pRow = pTable->rows[row];
+                if (pRow) {
                     /*
                         Only delete the contents of rows not previously deleted!
                      */
-					for (column = 0; column < nColumns; column++) {
-						if (pTable->columnTypes[column] == T_STRING) {
-							bfreeSafe(B_L, (char_t *)(pRow[column]));
-							pRow[column] = (int)NULL;
-						}
-					}
-
-					bfreeSafe(B_L, pRow);
-					hFree((void ***) &pTable->rows, row);
-				}
-			}
-
-			pTable->rows = NULL;
-			pTable->nRows = 0;
-		}
-	}
+                    for (column = 0; column < nColumns; column++) {
+                        if (pTable->columnTypes[column] == T_STRING) {
+                            bfreeSafe(B_L, (char_t *)(pRow[column]));
+                            pRow[column] = (int)NULL;
+                        }
+                    }
+
+                    bfreeSafe(B_L, pRow);
+                    hFree((void ***) &pTable->rows, row);
+                }
+            }
+
+            pTable->rows = NULL;
+            pTable->nRows = 0;
+        }
+    }
 }
 
 
 /*
-  	Find the a row in the table with the given string in the given column
+    Find the a row in the table with the given string in the given column
  */
 int dbSearchStr(int did, char_t *tablename, char_t *colName, char_t *value, int flags)
 {
-	int			tid, nRows, nColumns, column;
+    int         tid, nRows, nColumns, column;
    int match = 0;
-	dbTable_t	*pTable;
-
-	a_assert(tablename);
-	a_assert(colName);
-	a_assert(value);
-
-	tid = dbGetTableId(0, tablename);
-	a_assert(tid >= 0);
-
-	if ((tid >= 0) && (tid < dbMaxTables) && (dbListTables[tid] != NULL)) {
-		pTable = dbListTables[tid];
-	} else {
-		return DB_ERR_TABLE_NOT_FOUND;
-	}
-	
-	nColumns = pTable->nColumns;
-	nRows = pTable->nRows;
-	column = GetColumnIndex(tid, colName);
-	a_assert (column >= 0);
-
-	if (column >= 0) {
-		char_t	*compareVal;
-		int		row, *pRow;
+    dbTable_t   *pTable;
+
+    a_assert(tablename);
+    a_assert(colName);
+    a_assert(value);
+
+    tid = dbGetTableId(0, tablename);
+    a_assert(tid >= 0);
+
+    if ((tid >= 0) && (tid < dbMaxTables) && (dbListTables[tid] != NULL)) {
+        pTable = dbListTables[tid];
+    } else {
+        return DB_ERR_TABLE_NOT_FOUND;
+    }
+    
+    nColumns = pTable->nColumns;
+    nRows = pTable->nRows;
+    column = GetColumnIndex(tid, colName);
+    a_assert (column >= 0);
+
+    if (column >= 0) {
+        char_t  *compareVal;
+        int     row, *pRow;
         /*
             Scan through rows until we find a match. Note that some of these rows may be deleted!
          */
-		row = 0;
-		while (row < nRows) {
-			pRow = pTable->rows[row];
-			if (pRow) {
-				compareVal = (char_t *)(pRow[column]); 
+        row = 0;
+        while (row < nRows) {
+            pRow = pTable->rows[row];
+            if (pRow) {
+                compareVal = (char_t *)(pRow[column]); 
                 if (NULL != compareVal) {
                     if (DB_CASE_INSENSITIVE == flags) {
                         match = gstricmp(compareVal, value);
@@ -257,17 +257,17 @@ int dbSearchStr(int did, char_t *tablename, char_t *colName, char_t *value, int
                         return row;
                     }
                 }
-			}
-			row++;
-		}
-	} else { 
+            }
+            row++;
+        }
+    } else { 
         /*
             Return -2 if search column was not found
          */
-		trace(3, T("DB: Unable to find column <%s> in table <%s>\n"), colName, tablename);
-		return DB_ERR_COL_NOT_FOUND;
-	}
-	return -1;
+        trace(3, T("DB: Unable to find column <%s> in table <%s>\n"), colName, tablename);
+        return DB_ERR_COL_NOT_FOUND;
+    }
+    return -1;
 }
 
 
@@ -276,122 +276,122 @@ int dbSearchStr(int did, char_t *tablename, char_t *colName, char_t *value, int
  */
 int dbAddRow(int did, char_t *tablename)
 {
-	int			tid, size;
-	dbTable_t	*pTable;
-
-	a_assert(tablename);
-
-	tid = dbGetTableId(0, tablename);
-	a_assert(tid >= 0);
-
-	if ((tid >= 0) && (tid < dbMaxTables) && (dbListTables[tid] != NULL)) {
-		pTable = dbListTables[tid];
-	} else {
-		return DB_ERR_TABLE_NOT_FOUND;
-	}
-	a_assert(pTable);
-
-	if (pTable) {
-		trace(5, T("DB: Adding a row to table <%s>\n"), tablename);
-		size = pTable->nColumns * max(sizeof(int), sizeof(char_t *));
-		return hAllocEntry((void***) &(pTable->rows), &(pTable->nRows), size);
-	} 
-	return -1;
+    int         tid, size;
+    dbTable_t   *pTable;
+
+    a_assert(tablename);
+
+    tid = dbGetTableId(0, tablename);
+    a_assert(tid >= 0);
+
+    if ((tid >= 0) && (tid < dbMaxTables) && (dbListTables[tid] != NULL)) {
+        pTable = dbListTables[tid];
+    } else {
+        return DB_ERR_TABLE_NOT_FOUND;
+    }
+    a_assert(pTable);
+
+    if (pTable) {
+        trace(5, T("DB: Adding a row to table <%s>\n"), tablename);
+        size = pTable->nColumns * max(sizeof(int), sizeof(char_t *));
+        return hAllocEntry((void***) &(pTable->rows), &(pTable->nRows), size);
+    } 
+    return -1;
 }
 
 
 /*
-  	Delete a row in the table.  
+    Delete a row in the table.  
  */
 int dbDeleteRow(int did, char_t *tablename, int row)
 {
-	int			tid, nColumns, nRows;
-	dbTable_t	*pTable;
-
-	a_assert(tablename);
-	tid = dbGetTableId(0, tablename);
-	a_assert(tid >= 0);
-
-	if ((tid >= 0) && (tid < dbMaxTables) && (dbListTables[tid] != NULL)) {
-		pTable = dbListTables[tid];
-	} else {
-		return DB_ERR_TABLE_NOT_FOUND;
-	}
-	nColumns = pTable->nColumns;
-	nRows = pTable->nRows;
-
-	if ((row >= 0) && (row < nRows)) {
-		int *pRow = pTable->rows[row];
-
-		if (pRow) {
-			int	column = 0;
+    int         tid, nColumns, nRows;
+    dbTable_t   *pTable;
+
+    a_assert(tablename);
+    tid = dbGetTableId(0, tablename);
+    a_assert(tid >= 0);
+
+    if ((tid >= 0) && (tid < dbMaxTables) && (dbListTables[tid] != NULL)) {
+        pTable = dbListTables[tid];
+    } else {
+        return DB_ERR_TABLE_NOT_FOUND;
+    }
+    nColumns = pTable->nColumns;
+    nRows = pTable->nRows;
+
+    if ((row >= 0) && (row < nRows)) {
+        int *pRow = pTable->rows[row];
+
+        if (pRow) {
+            int column = 0;
             /*
                 Free up any allocated strings
              */
-			while (column < nColumns) {
-				if (pRow[column] && 
-					(pTable->columnTypes[column] == T_STRING)) {
-					bfree(B_L, (char_t *)pRow[column]);
-				}
-				column++;
-			}
+            while (column < nColumns) {
+                if (pRow[column] && 
+                    (pTable->columnTypes[column] == T_STRING)) {
+                    bfree(B_L, (char_t *)pRow[column]);
+                }
+                column++;
+            }
             /*
                 Zero out the row for safety
              */
-			memset(pRow, 0, nColumns * max(sizeof(int), sizeof(char_t *)));
-
-			bfreeSafe(B_L, pRow);
-			pTable->nRows = hFree((void ***)&pTable->rows, row);
-			trace(5, T("DB: Deleted row <%d> from table <%s>\n"), row, tablename);
-		}
-		return 0;
-	} else {
-		trace(3, T("DB: Unable to delete row <%d> from table <%s>\n"), row, tablename);
-	}
-	return -1;
+            memset(pRow, 0, nColumns * max(sizeof(int), sizeof(char_t *)));
+
+            bfreeSafe(B_L, pRow);
+            pTable->nRows = hFree((void ***)&pTable->rows, row);
+            trace(5, T("DB: Deleted row <%d> from table <%s>\n"), row, tablename);
+        }
+        return 0;
+    } else {
+        trace(3, T("DB: Unable to delete row <%d> from table <%s>\n"), row, tablename);
+    }
+    return -1;
 }
 
 
 /*
-  	Grow the rows in the table to the nominated size. 
+    Grow the rows in the table to the nominated size. 
  */
 int dbSetTableNrow(int did, char_t *tablename, int nNewRows)
 {
-	int			nRet, tid, nRows, nColumns;
-	dbTable_t	*pTable;
-
-	a_assert(tablename);
-	tid = dbGetTableId(0, tablename);
-	a_assert(tid >= 0) ;
-
-	if ((tid >= 0) && (tid < dbMaxTables) && (dbListTables[tid] != NULL)) {
-		pTable = dbListTables[tid];
-	} else {
-		return DB_ERR_TABLE_NOT_FOUND;
-	}
-	nRet = -1;
-
-	a_assert(pTable);
-	if (pTable) {
-		nColumns = pTable->nColumns;
-		nRows = pTable->nRows;
-		nRet = 0;
-
-		if (nRows >= nNewRows) {
-            /*		
+    int         nRet, tid, nRows, nColumns;
+    dbTable_t   *pTable;
+
+    a_assert(tablename);
+    tid = dbGetTableId(0, tablename);
+    a_assert(tid >= 0) ;
+
+    if ((tid >= 0) && (tid < dbMaxTables) && (dbListTables[tid] != NULL)) {
+        pTable = dbListTables[tid];
+    } else {
+        return DB_ERR_TABLE_NOT_FOUND;
+    }
+    nRet = -1;
+
+    a_assert(pTable);
+    if (pTable) {
+        nColumns = pTable->nColumns;
+        nRows = pTable->nRows;
+        nRet = 0;
+
+        if (nRows >= nNewRows) {
+            /*      
                 If number of rows already allocated exceeds requested number, do nothing
              */
-			trace(4, T("DB: Ignoring row set to <%d> in table <%s>\n"), nNewRows, tablename);
-		} else {
-			trace(4, T("DB: Setting rows to <%d> in table <%s>\n"), nNewRows, tablename);
-			while (pTable->nRows < nNewRows) {
-				if (dbAddRow(did, tablename) < 0) {
-					return -1;
-				}
-			}
-		}
-	} 
-	return nRet;
+            trace(4, T("DB: Ignoring row set to <%d> in table <%s>\n"), nNewRows, tablename);
+        } else {
+            trace(4, T("DB: Setting rows to <%d> in table <%s>\n"), nNewRows, tablename);
+            while (pTable->nRows < nNewRows) {
+                if (dbAddRow(did, tablename) < 0) {
+                    return -1;
+                }
+            }
+        }
+    } 
+    return nRet;
 }
 
 
@@ -400,62 +400,62 @@ int dbSetTableNrow(int did, char_t *tablename, int nNewRows)
  */
 int dbGetTableNrow(int did, char_t *tablename)
 {
-	int tid;
-	
-	a_assert(tablename);
-	tid = dbGetTableId(did, tablename);
-
-	if ((tid >= 0) && (tid < dbMaxTables) && (dbListTables[tid] != NULL)) {
-		return (dbListTables[tid])->nRows;
-	} else {
-		return -1;
-	}
+    int tid;
+    
+    a_assert(tablename);
+    tid = dbGetTableId(did, tablename);
+
+    if ((tid >= 0) && (tid < dbMaxTables) && (dbListTables[tid] != NULL)) {
+        return (dbListTables[tid])->nRows;
+    } else {
+        return -1;
+    }
 }
 
 
 int dbReadInt(int did, char_t *table, char_t *column, int row, int *returnValue)
 {
-	int			colIndex, *pRow, tid;
-	dbTable_t	*pTable;
-	
-	a_assert(table);
-	a_assert(column);
-	a_assert(returnValue);
-
-	tid = dbGetTableId(0, table);
-	a_assert(tid >= 0);
-
-	if (tid < 0) {
-		return DB_ERR_TABLE_NOT_FOUND;
-	}
-
-	pTable = dbListTables[tid];
-	if (pTable == NULL) {
-		return DB_ERR_TABLE_DELETED;
-	}
-	a_assert(row >= 0);
-
-	if ((row >= 0) && (row < pTable->nRows)) {
-		colIndex = GetColumnIndex(tid, column);
-		a_assert(colIndex >= 0);
-
-		if (colIndex >= 0) {
-			pRow = pTable->rows[row];
-			if (pRow) {
-				*returnValue = pRow[colIndex];
-				return 0;
-			}  
-			return DB_ERR_ROW_DELETED;
-		}
-		return DB_ERR_COL_NOT_FOUND;
-	}
-	return DB_ERR_ROW_NOT_FOUND;
+    int         colIndex, *pRow, tid;
+    dbTable_t   *pTable;
+    
+    a_assert(table);
+    a_assert(column);
+    a_assert(returnValue);
+
+    tid = dbGetTableId(0, table);
+    a_assert(tid >= 0);
+
+    if (tid < 0) {
+        return DB_ERR_TABLE_NOT_FOUND;
+    }
+
+    pTable = dbListTables[tid];
+    if (pTable == NULL) {
+        return DB_ERR_TABLE_DELETED;
+    }
+    a_assert(row >= 0);
+
+    if ((row >= 0) && (row < pTable->nRows)) {
+        colIndex = GetColumnIndex(tid, column);
+        a_assert(colIndex >= 0);
+
+        if (colIndex >= 0) {
+            pRow = pTable->rows[row];
+            if (pRow) {
+                *returnValue = pRow[colIndex];
+                return 0;
+            }  
+            return DB_ERR_ROW_DELETED;
+        }
+        return DB_ERR_COL_NOT_FOUND;
+    }
+    return DB_ERR_ROW_NOT_FOUND;
 }
 
 
 int dbReadStr(int did, char_t *table, char_t *column, int row, char_t **returnValue)
 {
-	return dbReadInt(did, table, column, row, (int *)returnValue);
+    return dbReadInt(did, table, column, row, (int *)returnValue);
 }
 
 
@@ -465,48 +465,48 @@ int dbReadStr(int did, char_t *table, char_t *column, int row, char_t **returnVa
  */
 int dbWriteInt(int did, char_t *table, char_t *column, int row, int iData)
 {
-	int			tid, colIndex, *pRow;
-	dbTable_t	*pTable;
+    int         tid, colIndex, *pRow;
+    dbTable_t   *pTable;
 
-	a_assert(table);
-	a_assert(column);
+    a_assert(table);
+    a_assert(column);
 
     /*
-      	Make sure that this table exists
+        Make sure that this table exists
      */
-	tid = dbGetTableId(0, table);
-	a_assert(tid >= 0);
+    tid = dbGetTableId(0, table);
+    a_assert(tid >= 0);
 
-	if (tid < 0) {
-		return DB_ERR_TABLE_NOT_FOUND;
-	}
+    if (tid < 0) {
+        return DB_ERR_TABLE_NOT_FOUND;
+    }
 
-	pTable = dbListTables[tid];
-	
-	if (pTable) {
+    pTable = dbListTables[tid];
+    
+    if (pTable) {
         /*
             Make sure that the column exists
          */
-		colIndex = GetColumnIndex(tid, column);
-		a_assert(colIndex >= 0);
-		if (colIndex >= 0) {
+        colIndex = GetColumnIndex(tid, column);
+        a_assert(colIndex >= 0);
+        if (colIndex >= 0) {
             /*
                 Make sure that the row exists
              */
-			a_assert((row >= 0) && (row < pTable->nRows));
-			if ((row >= 0) && (row < pTable->nRows)) {
-				pRow = pTable->rows[row];
-				if (pRow) {
-					pRow[colIndex] = iData;
-					return 0;
-				}
-				return DB_ERR_ROW_DELETED;
-			}
-			return DB_ERR_ROW_NOT_FOUND;
-		}
-		return DB_ERR_COL_NOT_FOUND;
-	}
-	return DB_ERR_TABLE_DELETED;
+            a_assert((row >= 0) && (row < pTable->nRows));
+            if ((row >= 0) && (row < pTable->nRows)) {
+                pRow = pTable->rows[row];
+                if (pRow) {
+                    pRow[colIndex] = iData;
+                    return 0;
+                }
+                return DB_ERR_ROW_DELETED;
+            }
+            return DB_ERR_ROW_NOT_FOUND;
+        }
+        return DB_ERR_COL_NOT_FOUND;
+    }
+    return DB_ERR_TABLE_DELETED;
 }
 
 
@@ -517,234 +517,234 @@ int dbWriteInt(int did, char_t *table, char_t *column, int row, int iData)
  */
 int dbWriteStr(int did, char_t *table, char_t *column, int row, char_t *s)
 {
-	int			tid, colIndex;
-	int			*pRow;
-	char_t		*ptr;
-	dbTable_t	*pTable;
+    int         tid, colIndex;
+    int         *pRow;
+    char_t      *ptr;
+    dbTable_t   *pTable;
 
-	a_assert(table);
-	a_assert(column);
+    a_assert(table);
+    a_assert(column);
 
-	tid = dbGetTableId(0, table);
-	a_assert(tid >= 0);
+    tid = dbGetTableId(0, table);
+    a_assert(tid >= 0);
 
-	if (tid < 0) {
-		return DB_ERR_TABLE_NOT_FOUND;
-	}
+    if (tid < 0) {
+        return DB_ERR_TABLE_NOT_FOUND;
+    }
     /*
-      	Make sure that this table exists
+        Make sure that this table exists
      */
-	pTable = dbListTables[tid];
-	a_assert(pTable);
-	if (!pTable) {
-		return DB_ERR_TABLE_DELETED;
-	}
+    pTable = dbListTables[tid];
+    a_assert(pTable);
+    if (!pTable) {
+        return DB_ERR_TABLE_DELETED;
+    }
 
     /*
-      	Make sure that this column exists
+        Make sure that this column exists
      */
-	colIndex = GetColumnIndex(tid, column);
-	if (colIndex < 0) {
-		return DB_ERR_COL_NOT_FOUND;
-	}
+    colIndex = GetColumnIndex(tid, column);
+    if (colIndex < 0) {
+        return DB_ERR_COL_NOT_FOUND;
+    }
 
     /*
-      	Make sure that this column is a string column
+        Make sure that this column is a string column
      */
-	if (pTable->columnTypes[colIndex] != T_STRING) {
-		return DB_ERR_BAD_FORMAT;
-	}
+    if (pTable->columnTypes[colIndex] != T_STRING) {
+        return DB_ERR_BAD_FORMAT;
+    }
 
     /*
-      	Make sure that the row exists
+        Make sure that the row exists
      */
-	a_assert((row >= 0) && (row < pTable->nRows));
-	if ((row >= 0) && (row < pTable->nRows)) {
-		pRow = pTable->rows[row];
-	} else {
-		return DB_ERR_ROW_NOT_FOUND;
-	}
-	if (!pRow) {
-		return DB_ERR_ROW_DELETED;
-	}
+    a_assert((row >= 0) && (row < pTable->nRows));
+    if ((row >= 0) && (row < pTable->nRows)) {
+        pRow = pTable->rows[row];
+    } else {
+        return DB_ERR_ROW_NOT_FOUND;
+    }
+    if (!pRow) {
+        return DB_ERR_ROW_DELETED;
+    }
 
     /*
         If the column already has a value, be sure to delete it to prevent memory leaks.
      */
-	if (pRow[colIndex]) {
-		bfree(B_L, (char_t *) pRow[colIndex]);
-	}
+    if (pRow[colIndex]) {
+        bfree(B_L, (char_t *) pRow[colIndex]);
+    }
 
     /*
         Make sure we make a copy of the string to write into the column. This allocated string will be deleted when the
         row is deleted.  
      */
-	ptr = bstrdup(B_L, s);
-	pRow[colIndex] = (int)ptr;
-	return 0;
+    ptr = bstrdup(B_L, s);
+    pRow[colIndex] = (int)ptr;
+    return 0;
 }
 
 
 /*
-  	Print a key-value pair to a file
+    Print a key-value pair to a file
  */
 static int dbWriteKeyValue(int fd, char_t *key, char_t *value)
 {
-	int		rc;
-	int		len;
-	char_t	*pLineOut;
+    int     rc;
+    int     len;
+    char_t  *pLineOut;
 
-	a_assert(key && *key);
-	a_assert(value);
-	
-	fmtAlloc(&pLineOut, BUF_MAX, T("%s=%s\n"), key, value);
+    a_assert(key && *key);
+    a_assert(value);
+    
+    fmtAlloc(&pLineOut, BUF_MAX, T("%s=%s\n"), key, value);
 
-	if (pLineOut) {
-		len = gstrlen(pLineOut);
+    if (pLineOut) {
+        len = gstrlen(pLineOut);
         //MOB
 #ifdef CE
-		rc = writeUniToAsc(fd, pLineOut, len);
+        rc = writeUniToAsc(fd, pLineOut, len);
 #else
-		rc = gwrite(fd, pLineOut, len);
+        rc = gwrite(fd, pLineOut, len);
 #endif
-		bfree(B_L, pLineOut);
-	} else {
-		rc = -1;
-	}
+        bfree(B_L, pLineOut);
+    } else {
+        rc = -1;
+    }
 
-	return rc;
+    return rc;
 }
 
 
 /*
- *	Persist a database to a file
+ *  Persist a database to a file
  */
 
 int dbSave(int did, char_t *filename, int flags)
 {
-	int			row, column, nColumns, nRows, fd, rc;
-	int			*colTypes, *pRow, nRet, tid;
-	char_t		*path, *tmpFile, *tmpNum;
-	char_t		**colNames;
-	dbTable_t	*pTable;
+    int         row, column, nColumns, nRows, fd, rc;
+    int         *colTypes, *pRow, nRet, tid;
+    char_t      *path, *tmpFile, *tmpNum;
+    char_t      **colNames;
+    dbTable_t   *pTable;
 
-	trace(5, T("DB: About to save database to file\n"));
+    trace(5, T("DB: About to save database to file\n"));
 
-	a_assert(dbMaxTables > 0);
+    a_assert(dbMaxTables > 0);
 
     /*
-      	First write to a temporary file, then switch around later.
+        First write to a temporary file, then switch around later.
      */
-	fmtAlloc(&tmpFile, FNAMESIZE, T("%s/data.tmp"), basicGetProductDir());
+    fmtAlloc(&tmpFile, FNAMESIZE, T("%s/data.tmp"), basicGetProductDir());
     //  MOB
 #if !defined(WIN32)
-	fd = gopen(tmpFile, O_CREAT | O_TRUNC | O_WRONLY | O_BINARY, 0666);
+    fd = gopen(tmpFile, O_CREAT | O_TRUNC | O_WRONLY | O_BINARY, 0666);
 #else
-	_sopen_s(&fd, tmpFile, O_CREAT | O_TRUNC | O_WRONLY | O_BINARY, _SH_DENYNO, 0666);
+    _sopen_s(&fd, tmpFile, O_CREAT | O_TRUNC | O_WRONLY | O_BINARY, _SH_DENYNO, 0666);
 #endif
-	
-	if (fd < 0) {
-		trace(1, T("WARNING: Failed to open file %s\n"), tmpFile);
-		bfree(B_L, tmpFile);
-		return -1;
-	}
-
-	nRet = 0;
-	for (tid = 0; (tid < dbMaxTables) && (nRet != -1); tid++) {
-		pTable = dbListTables[tid];
-
-		if (pTable) {
+    
+    if (fd < 0) {
+        trace(1, T("WARNING: Failed to open file %s\n"), tmpFile);
+        bfree(B_L, tmpFile);
+        return -1;
+    }
+
+    nRet = 0;
+    for (tid = 0; (tid < dbMaxTables) && (nRet != -1); tid++) {
+        pTable = dbListTables[tid];
+
+        if (pTable) {
             /*
                 Print the TABLE=tableName directive to the file
              */
-			rc = dbWriteKeyValue(fd, KEYWORD_TABLE, pTable->name);
+            rc = dbWriteKeyValue(fd, KEYWORD_TABLE, pTable->name);
 
-			nColumns = pTable->nColumns;
-			nRows = pTable->nRows;
+            nColumns = pTable->nColumns;
+            nRows = pTable->nRows;
 
-			for (row = 0; (row < nRows) && (nRet == 0); row++) {
-				pRow = pTable->rows[row];
+            for (row = 0; (row < nRows) && (nRet == 0); row++) {
+                pRow = pTable->rows[row];
                 /*
                     If row is NULL, the row has been deleted, so don't write it out.
                  */
-				if ((pRow == NULL) || (pRow[0] == '\0') || 
-					(*(char_t *)(pRow[0]) == '\0')) {
-					continue;
-				}
+                if ((pRow == NULL) || (pRow[0] == '\0') || 
+                    (*(char_t *)(pRow[0]) == '\0')) {
+                    continue;
+                }
                 /*
                     Print the ROW=rowNumber directive to the file
                  */
-				fmtAlloc(&tmpNum, 20, T("%d"), row);		
-				rc = dbWriteKeyValue(fd, KEYWORD_ROW, tmpNum);
-				bfreeSafe(B_L, tmpNum);
+                fmtAlloc(&tmpNum, 20, T("%d"), row);        
+                rc = dbWriteKeyValue(fd, KEYWORD_ROW, tmpNum);
+                bfreeSafe(B_L, tmpNum);
 
-				colNames = pTable->columnNames;
-				colTypes = pTable->columnTypes;
+                colNames = pTable->columnNames;
+                colTypes = pTable->columnTypes;
                 /*
                     Print the key-value pairs (COLUMN=value) for data cells
                  */
-				for (column = 0; (column < nColumns) && (rc >= 0); 
-					column++, colNames++, colTypes++) {
-					if (*colTypes == T_STRING) {
-						rc = dbWriteKeyValue(fd, *colNames, (char_t *)(pRow[column]));
-					} else {
-						fmtAlloc(&tmpNum, 20, T("%d"), pRow[column]);		
-						rc = dbWriteKeyValue(fd, *colNames, tmpNum);
-						bfreeSafe(B_L, tmpNum);
-					}
-				}
-
-				if (rc < 0) {
-					trace(1, T("WARNING: Failed to write to file %s\n"), 
-						tmpFile);
-					nRet = -1;
-				}
-			}
-		}
-	}
-	gclose(fd);
+                for (column = 0; (column < nColumns) && (rc >= 0); 
+                    column++, colNames++, colTypes++) {
+                    if (*colTypes == T_STRING) {
+                        rc = dbWriteKeyValue(fd, *colNames, (char_t *)(pRow[column]));
+                    } else {
+                        fmtAlloc(&tmpNum, 20, T("%d"), pRow[column]);       
+                        rc = dbWriteKeyValue(fd, *colNames, tmpNum);
+                        bfreeSafe(B_L, tmpNum);
+                    }
+                }
+
+                if (rc < 0) {
+                    trace(1, T("WARNING: Failed to write to file %s\n"), 
+                        tmpFile);
+                    nRet = -1;
+                }
+            }
+        }
+    }
+    gclose(fd);
 
     /*
         Replace the existing file with the temporary file, if no errors
      */
-	if (nRet == 0) {
-		fmtAlloc(&path, FNAMESIZE, T("%s/%s"), basicGetProductDir(), filename);
-		gunlink(path);
-		if (grename(tmpFile, path) != 0) {
-			trace(1, T("WARNING: Failed to rename %s to %s\n"), tmpFile, path);
-			nRet = -1;
-		}
-		bfree(B_L, path);
-	}
-	bfree(B_L, tmpFile);
-	return nRet;
+    if (nRet == 0) {
+        fmtAlloc(&path, FNAMESIZE, T("%s/%s"), basicGetProductDir(), filename);
+        gunlink(path);
+        if (grename(tmpFile, path) != 0) {
+            trace(1, T("WARNING: Failed to rename %s to %s\n"), tmpFile, path);
+            nRet = -1;
+        }
+        bfree(B_L, path);
+    }
+    bfree(B_L, tmpFile);
+    return nRet;
 }
 
 
 /*
-  	Crack a keyword=value string into keyword and value. We can change buf.
+    Crack a keyword=value string into keyword and value. We can change buf.
  */
 static int crack(char_t *buf, char_t **key, char_t **val)
 {
-	char_t	*ptr;
+    char_t  *ptr;
 
-	if ((ptr = gstrrchr(buf, '\n')) != NULL ||
-			(ptr = gstrrchr(buf, '\r')) != NULL) {
-		*ptr = '\0';
-	}
+    if ((ptr = gstrrchr(buf, '\n')) != NULL ||
+            (ptr = gstrrchr(buf, '\r')) != NULL) {
+        *ptr = '\0';
+    }
 
     /*
-      	Find the = sign. It must exist.
+        Find the = sign. It must exist.
      */
-	if ((ptr = gstrstr(buf, T("="))) == NULL) {
-		return -1;
-	}
+    if ((ptr = gstrstr(buf, T("="))) == NULL) {
+        return -1;
+    }
 
-	*ptr++ = '\0';
-	*key = trim(buf);
-	*val = trim(ptr);
+    *ptr++ = '\0';
+    *key = trim(buf);
+    *val = trim(ptr);
 
-	return 0;
+    return 0;
 }
 
 
@@ -754,223 +754,223 @@ static int crack(char_t *buf, char_t **key, char_t **val)
  */
 int dbLoad(int did, char_t *filename, int flags)
 {
-	gstat_t		sbuf;
-	char_t		*buf, *keyword, *value, *path, *ptr;
-	char_t		*tablename;
-	int			fd, tid, row;
-	dbTable_t	*pTable;
+    gstat_t     sbuf;
+    char_t      *buf, *keyword, *value, *path, *ptr;
+    char_t      *tablename;
+    int         fd, tid, row;
+    dbTable_t   *pTable;
 
     a_assert(did >= 0);
 
-	fmtAlloc(&path, FNAMESIZE, T("%s/%s"), basicGetProductDir(), filename);
-	trace(4, T("DB: About to read data file <%s>\n"), path);
+    fmtAlloc(&path, FNAMESIZE, T("%s/%s"), basicGetProductDir(), filename);
+    trace(4, T("DB: About to read data file <%s>\n"), path);
 
-	if (gstat(path, &sbuf) < 0) {
-		trace(3, T("DB: Failed to stat persistent data file.\n"));
-		bfree(B_L, path);
-		return -1;
-	}
+    if (gstat(path, &sbuf) < 0) {
+        trace(3, T("DB: Failed to stat persistent data file.\n"));
+        bfree(B_L, path);
+        return -1;
+    }
 #if !defined(WIN32)
-	fd = gopen(path, O_RDONLY | O_BINARY, 0666);
+    fd = gopen(path, O_RDONLY | O_BINARY, 0666);
 #else
-	_sopen_s(&fd, path, O_RDONLY | O_BINARY, _SH_DENYNO, 0666);
+    _sopen_s(&fd, path, O_RDONLY | O_BINARY, _SH_DENYNO, 0666);
 #endif
-	bfree(B_L, path);
-
-	if (fd < 0) {
-		trace(3, T("DB: No persistent data file present.\n"));
-		return -1;
-	}
-	if (sbuf.st_size <= 0) {
-		trace(3, T("DB: Persistent data file is empty.\n"));
-		gclose(fd);
-		return -1;
-	}
+    bfree(B_L, path);
+
+    if (fd < 0) {
+        trace(3, T("DB: No persistent data file present.\n"));
+        return -1;
+    }
+    if (sbuf.st_size <= 0) {
+        trace(3, T("DB: Persistent data file is empty.\n"));
+        gclose(fd);
+        return -1;
+    }
     /*
-      	Read entire file into temporary buffer
+        Read entire file into temporary buffer
      */
-	buf = balloc(B_L, sbuf.st_size + 1);
+    buf = balloc(B_L, sbuf.st_size + 1);
 #ifdef CE
-	if (readAscToUni(fd, &buf, sbuf.st_size) != (int)sbuf.st_size) {
+    if (readAscToUni(fd, &buf, sbuf.st_size) != (int)sbuf.st_size) {
 #else
-	if (gread(fd, buf, sbuf.st_size) != (int)sbuf.st_size) {
+    if (gread(fd, buf, sbuf.st_size) != (int)sbuf.st_size) {
 #endif
-		trace(3, T("DB: Persistent data read failed.\n"));
-		bfree(B_L, buf);
-		gclose(fd);
-		return -1;
-	}
-	gclose(fd);
-	*(buf + sbuf.st_size) = '\0';
-
-	row = -1;
-	tid = -1;
-	pTable = NULL;
-	ptr = gstrtok(buf, T("\n"));
-	tablename = NULL;
-
-	do {
-		if (crack(ptr, &keyword, &value) < 0) {
-			trace(5, T("DB: Failed to crack line %s\n"), ptr);
-			continue;
-		}
-		a_assert(keyword && *keyword);
-
-		if (gstrcmp(keyword, KEYWORD_TABLE) == 0) {
+        trace(3, T("DB: Persistent data read failed.\n"));
+        bfree(B_L, buf);
+        gclose(fd);
+        return -1;
+    }
+    gclose(fd);
+    *(buf + sbuf.st_size) = '\0';
+
+    row = -1;
+    tid = -1;
+    pTable = NULL;
+    ptr = gstrtok(buf, T("\n"));
+    tablename = NULL;
+
+    do {
+        if (crack(ptr, &keyword, &value) < 0) {
+            trace(5, T("DB: Failed to crack line %s\n"), ptr);
+            continue;
+        }
+        a_assert(keyword && *keyword);
+
+        if (gstrcmp(keyword, KEYWORD_TABLE) == 0) {
             /*
                 Table name found, check to see if it's registered
              */
-			if (tablename) {
-				bfree(B_L, tablename);
-			}
-			tablename = bstrdup(B_L, value);
-			tid = dbGetTableId(did, tablename);
-
-			if (tid >= 0) {
-				pTable = dbListTables[tid];
-			} else {
-				pTable = NULL;
-			}
-
-		} else if (gstrcmp(keyword, KEYWORD_ROW) == 0) {
+            if (tablename) {
+                bfree(B_L, tablename);
+            }
+            tablename = bstrdup(B_L, value);
+            tid = dbGetTableId(did, tablename);
+
+            if (tid >= 0) {
+                pTable = dbListTables[tid];
+            } else {
+                pTable = NULL;
+            }
+
+        } else if (gstrcmp(keyword, KEYWORD_ROW) == 0) {
             /*
                 Row/Record indicator found, add a new row to table
              */
-			if (tid >= 0) {
-				int nRows = dbGetTableNrow(did, tablename);
+            if (tid >= 0) {
+                int nRows = dbGetTableNrow(did, tablename);
 
-				if (dbSetTableNrow(did, tablename, nRows + 1) == 0) {
-					row = nRows;
-				}
-			}
+                if (dbSetTableNrow(did, tablename, nRows + 1) == 0) {
+                    row = nRows;
+                }
+            }
 
-		} else if (row != -1) {
+        } else if (row != -1) {
             /*
                 Some other data found, assume it's a COLUMN=value
              */
-			int nColumn = GetColumnIndex(tid, keyword);
-
-			if ((nColumn >= 0) && (pTable != NULL)) {
-				int nColumnType = pTable->columnTypes[nColumn];
-				if (nColumnType == T_STRING) {
-					dbWriteStr(did, tablename, keyword, row, value);
-				} else {
-					dbWriteInt(did, tablename, keyword, row, gstrtoi(value));
-				}
-			}
-		}
-	} while ((ptr = gstrtok(NULL, T("\n"))) != NULL);
-
-	if (tablename) {
-		bfree(B_L, tablename);
-	}
-
-	bfree(B_L, buf);
-
-	return 0;
+            int nColumn = GetColumnIndex(tid, keyword);
+
+            if ((nColumn >= 0) && (pTable != NULL)) {
+                int nColumnType = pTable->columnTypes[nColumn];
+                if (nColumnType == T_STRING) {
+                    dbWriteStr(did, tablename, keyword, row, value);
+                } else {
+                    dbWriteInt(did, tablename, keyword, row, gstrtoi(value));
+                }
+            }
+        }
+    } while ((ptr = gstrtok(NULL, T("\n"))) != NULL);
+
+    if (tablename) {
+        bfree(B_L, tablename);
+    }
+
+    bfree(B_L, buf);
+
+    return 0;
 }
 
 
 /*
-  	Return a table id given the table name
+    Return a table id given the table name
  */
 int dbGetTableId(int did, char_t *tablename)
 {
-	int			tid;
-	dbTable_t	*pTable;
-
-	a_assert(tablename);
-
-	for (tid = 0; (tid < dbMaxTables); tid++) {
-		if ((pTable = dbListTables[tid]) != NULL) {
-			if (gstrcmp(tablename, pTable->name) == 0) {
-				return tid;
-			}
-		}
-	}
-	
-	return -1;
+    int         tid;
+    dbTable_t   *pTable;
+
+    a_assert(tablename);
+
+    for (tid = 0; (tid < dbMaxTables); tid++) {
+        if ((pTable = dbListTables[tid]) != NULL) {
+            if (gstrcmp(tablename, pTable->name) == 0) {
+                return tid;
+            }
+        }
+    }
+    
+    return -1;
 }
 
 
-/*	
+/*  
     Return a pointer to the table name, given its ID
  */
 char_t *dbGetTableName(int did, int tid)
 {
-	if ((tid >= 0) && (tid < dbMaxTables) && (dbListTables[tid] != NULL)) {
-		return (dbListTables[tid])->name;
-	}
-	return NULL;
+    if ((tid >= 0) && (tid < dbMaxTables) && (dbListTables[tid] != NULL)) {
+        return (dbListTables[tid])->name;
+    }
+    return NULL;
 }
 
 
 /*
-  	Trim leading white space.
+    Trim leading white space.
  */
 static char_t *trim(char_t *str)
 {
-	while (isspace((int)*str)) {
-		str++;
-	}
-	return str;
+    while (isspace((int)*str)) {
+        str++;
+    }
+    return str;
 }
 
 
 /*
-  	Return a column index given the column name
+    Return a column index given the column name
  */
 static int GetColumnIndex(int tid, char_t *colName) 
 {
-	int			column;
-	dbTable_t	*pTable;
+    int         column;
+    dbTable_t   *pTable;
 
-	a_assert(colName);
+    a_assert(colName);
 
-	if ((tid >= 0) && (tid < dbMaxTables) && (dbListTables[tid] != NULL)) {
-		pTable = dbListTables[tid];
+    if ((tid >= 0) && (tid < dbMaxTables) && (dbListTables[tid] != NULL)) {
+        pTable = dbListTables[tid];
 
-		for (column = 0; (column < pTable->nColumns); column++) {
-			if (gstrcmp(colName, pTable->columnNames[column]) == 0)
-				return column;
-		}
-	}
-	return -1;
+        for (column = 0; (column < pTable->nColumns); column++) {
+            if (gstrcmp(colName, pTable->columnNames[column]) == 0)
+                return column;
+        }
+    }
+    return -1;
 }
 
 
 /*
-  	Set the prefix-directory
+    Set the prefix-directory
  */
 void basicSetProductDir(char_t *proddir)
 {
-	int len;
+    int len;
 
-	if (basicProdDir != NULL) {	
+    if (basicProdDir != NULL) { 
       bfree(B_L, basicProdDir);
-	}
-	basicProdDir = bstrdup(B_L, proddir);
+    }
+    basicProdDir = bstrdup(B_L, proddir);
 
     /*
-      	Make sure that prefix-directory doesn't end with a '/'
+        Make sure that prefix-directory doesn't end with a '/'
      */
-	len = gstrlen(basicProdDir);
-	if ((len > 0) && *(basicProdDir + len - 1) == '/') {
-		*(basicProdDir+len-1) = '\0';
-	}
+    len = gstrlen(basicProdDir);
+    if ((len > 0) && *(basicProdDir + len - 1) == '/') {
+        *(basicProdDir+len-1) = '\0';
+    }
 }
 
 
 /*
-  	Return the prefix-directory
+    Return the prefix-directory
  */
 char_t *basicGetProductDir()
 {
-	if (basicProdDir) {
-		return basicProdDir;
-	} else {
-		return basicDefaultDir;
-	}
+    if (basicProdDir) {
+        return basicProdDir;
+    } else {
+        return basicDefaultDir;
+    }
 }
 
 /*
diff --git a/emfdb.h b/emfdb.h
index ae4c79d7..8f29695b 100644
--- a/emfdb.h
+++ b/emfdb.h
@@ -1,5 +1,5 @@
 /*
-  	emfdb.h -- EMF database compatability functions for GoAhead WebServer.
+    emfdb.h -- EMF database compatability functions for GoAhead WebServer.
 
     Copyright (c) All Rights Reserved. See details at the end of the file.
  */
@@ -9,65 +9,65 @@
 #ifndef _h_EMFDB
 #define _h_EMFDB 1
 
-#include	"uemf.h"
+#include    "uemf.h"
 
 /********************************* Defines ************************************/
 
-#define		T_INT					0
-#define		T_STRING				1
+#define     T_INT                   0
+#define     T_STRING                1
 
-#define		DB_OK					0
-#define		DB_ERR_GENERAL			-1
-#define		DB_ERR_COL_NOT_FOUND	-2
-#define		DB_ERR_COL_DELETED		-3
-#define		DB_ERR_ROW_NOT_FOUND	-4
-#define		DB_ERR_ROW_DELETED		-5
-#define		DB_ERR_TABLE_NOT_FOUND	-6
-#define		DB_ERR_TABLE_DELETED	-7
-#define		DB_ERR_BAD_FORMAT		-8
+#define     DB_OK                   0
+#define     DB_ERR_GENERAL          -1
+#define     DB_ERR_COL_NOT_FOUND    -2
+#define     DB_ERR_COL_DELETED      -3
+#define     DB_ERR_ROW_NOT_FOUND    -4
+#define     DB_ERR_ROW_DELETED      -5
+#define     DB_ERR_TABLE_NOT_FOUND  -6
+#define     DB_ERR_TABLE_DELETED    -7
+#define     DB_ERR_BAD_FORMAT       -8
 
 #define     DB_CASE_INSENSITIVE  1
 
 typedef struct dbTable_s {
-	char_t	*name;
-	int		nColumns;
-	char_t	**columnNames;
-	int		*columnTypes;
-	int		nRows;
-	int		**rows;
+    char_t  *name;
+    int     nColumns;
+    char_t  **columnNames;
+    int     *columnTypes;
+    int     nRows;
+    int     **rows;
 } dbTable_t;
 
 /********************************** Prototypes ********************************/
 /*
-  	Add a schema to the module-internal schema database
+    Add a schema to the module-internal schema database
  */
-extern int		dbRegisterDBSchema(dbTable_t *sTable);
-extern int		dbOpen(char_t *databasename, char_t *filename, int (*gettime)(int did), int flags);
-extern void		dbClose(int did);
-extern int		dbGetTableId(int did, char_t *tname);
-extern char_t	*dbGetTableName(int did, int tid);
-extern int		dbReadInt(int did, char_t *table, char_t *column, int row, int *returnValue);
-extern int		dbReadStr(int did, char_t *table, char_t *column, int row, char_t **returnValue);
-extern int		dbWriteInt(int did, char_t *table, char_t *column, int row, int idata);
-extern int		dbWriteStr(int did, char_t *table, char_t *column, int row, char_t *s);
-extern int		dbAddRow(int did, char_t *table);
-extern int		dbDeleteRow(int did, char_t *table, int rid);
-extern int		dbSetTableNrow(int did, char_t *table, int nNewRows);
-extern int		dbGetTableNrow(int did, char_t *table);
+extern int      dbRegisterDBSchema(dbTable_t *sTable);
+extern int      dbOpen(char_t *databasename, char_t *filename, int (*gettime)(int did), int flags);
+extern void     dbClose(int did);
+extern int      dbGetTableId(int did, char_t *tname);
+extern char_t   *dbGetTableName(int did, int tid);
+extern int      dbReadInt(int did, char_t *table, char_t *column, int row, int *returnValue);
+extern int      dbReadStr(int did, char_t *table, char_t *column, int row, char_t **returnValue);
+extern int      dbWriteInt(int did, char_t *table, char_t *column, int row, int idata);
+extern int      dbWriteStr(int did, char_t *table, char_t *column, int row, char_t *s);
+extern int      dbAddRow(int did, char_t *table);
+extern int      dbDeleteRow(int did, char_t *table, int rid);
+extern int      dbSetTableNrow(int did, char_t *table, int nNewRows);
+extern int      dbGetTableNrow(int did, char_t *table);
 
 /*
-  	Dump the contents of a database to file
+    Dump the contents of a database to file
  */
-extern int		dbSave(int did, char_t *filename, int flags);
+extern int      dbSave(int did, char_t *filename, int flags);
 
 /*
-  	Load the contents of a database to file
+    Load the contents of a database to file
  */
-extern int		dbLoad(int did, char_t *filename, int flags);
-extern int		dbSearchStr(int did, char_t *table, char_t *column, char_t *value, int flags);
-extern void		dbZero(int did);
-extern char_t	*basicGetProductDir();
-extern void		basicSetProductDir(char_t *proddir);
+extern int      dbLoad(int did, char_t *filename, int flags);
+extern int      dbSearchStr(int did, char_t *table, char_t *column, char_t *value, int flags);
+extern void     dbZero(int did);
+extern char_t   *basicGetProductDir();
+extern void     basicSetProductDir(char_t *proddir);
 
 #endif /* _h_EMFDB */
 
diff --git a/form.c b/form.c
index 632d0a64..d0135c1a 100644
--- a/form.c
+++ b/form.c
@@ -10,90 +10,90 @@
 
 /*********************************** Includes *********************************/
 
-#include	"wsIntrn.h"
+#include    "wsIntrn.h"
 
 /************************************ Locals **********************************/
 
-static sym_fd_t	formSymtab = -1;			/* Symbol table for form handlers */
+static sym_fd_t formSymtab = -1;            /* Symbol table for form handlers */
 
 /************************************* Code ***********************************/
 /*
-  	Process a form request. Returns 1 always to indicate it handled the URL
+    Process a form request. Returns 1 always to indicate it handled the URL
  */
 int websFormHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t *url, char_t *path, char_t *query)
 {
-	sym_t		*sp;
-	char_t		formBuf[FNAMESIZE];
-	char_t		*cp, *formName;
-	int			(*fn)(void *sock, char_t *path, char_t *args);
+    sym_t       *sp;
+    char_t      formBuf[FNAMESIZE];
+    char_t      *cp, *formName;
+    int         (*fn)(void *sock, char_t *path, char_t *args);
 
-	a_assert(websValid(wp));
-	a_assert(url && *url);
-	a_assert(path && *path == '/');
+    a_assert(websValid(wp));
+    a_assert(url && *url);
+    a_assert(path && *path == '/');
 
-	websStats.formHits++;
+    websStats.formHits++;
 
     /*
-      	Extract the form name
+        Extract the form name
      */
-	gstrncpy(formBuf, path, TSZ(formBuf));
-	if ((formName = gstrchr(&formBuf[1], '/')) == NULL) {
-		websError(wp, 200, T("Missing form name"));
-		return 1;
-	}
-	formName++;
-	if ((cp = gstrchr(formName, '/')) != NULL) {
-		*cp = '\0';
-	}
+    gstrncpy(formBuf, path, TSZ(formBuf));
+    if ((formName = gstrchr(&formBuf[1], '/')) == NULL) {
+        websError(wp, 200, T("Missing form name"));
+        return 1;
+    }
+    formName++;
+    if ((cp = gstrchr(formName, '/')) != NULL) {
+        *cp = '\0';
+    }
 
     /*
-      	Lookup the C form function first and then try tcl (no javascript support yet).
+        Lookup the C form function first and then try tcl (no javascript support yet).
      */
-	sp = symLookup(formSymtab, formName);
-	if (sp == NULL) {
-		websError(wp, 404, T("Form %s is not defined"), formName);
-	} else {
-		fn = (int (*)(void *, char_t *, char_t *)) sp->content.value.integer;
-		a_assert(fn);
-		if (fn) {
+    sp = symLookup(formSymtab, formName);
+    if (sp == NULL) {
+        websError(wp, 404, T("Form %s is not defined"), formName);
+    } else {
+        fn = (int (*)(void *, char_t *, char_t *)) sp->content.value.integer;
+        a_assert(fn);
+        if (fn) {
             /*
                 For good practice, forms must call websDone()
              */
             (*fn)((void*) wp, formName, query);
-		}
-	}
-	return 1;
+        }
+    }
+    return 1;
 }
 
 
 /*
-  	Define a form function in the "form" map space.
+    Define a form function in the "form" map space.
  */
 int websFormDefine(char_t *name, void (*fn)(webs_t wp, char_t *path, char_t *query))
 {
-	a_assert(name && *name);
-	a_assert(fn);
-
-	if (fn == NULL) {
-		return -1;
-	}
-	symEnter(formSymtab, name, valueInteger((int) fn), (int) NULL);
-	return 0;
+    a_assert(name && *name);
+    a_assert(fn);
+
+    if (fn == NULL) {
+        return -1;
+    }
+    symEnter(formSymtab, name, valueInteger((int) fn), (int) NULL);
+    return 0;
 }
 
 
 void websFormOpen()
 {
-	formSymtab = symOpen(WEBS_SYM_INIT);
+    formSymtab = symOpen(WEBS_SYM_INIT);
 }
 
 
 void websFormClose()
 {
-	if (formSymtab != -1) {
-		symClose(formSymtab);
-		formSymtab = -1;
-	}
+    if (formSymtab != -1) {
+        symClose(formSymtab);
+        formSymtab = -1;
+    }
 }
 
 
@@ -102,31 +102,31 @@ void websFormClose()
  */
 void websHeader(webs_t wp)
 {
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
-	websWrite(wp, T("HTTP/1.0 200 OK\n"));
+    websWrite(wp, T("HTTP/1.0 200 OK\n"));
 
     /*
         The Server HTTP header below must not be modified unless explicitly allowed by licensing terms.
      */
 #ifdef WEBS_SSL_SUPPORT
-	websWrite(wp, T("Server: %s/%s %s/%s\r\n"), WEBS_NAME, WEBS_VERSION, SSL_NAME, SSL_VERSION);
+    websWrite(wp, T("Server: %s/%s %s/%s\r\n"), WEBS_NAME, WEBS_VERSION, SSL_NAME, SSL_VERSION);
 #else
-	websWrite(wp, T("Server: %s/%s\r\n"), WEBS_NAME, WEBS_VERSION);
+    websWrite(wp, T("Server: %s/%s\r\n"), WEBS_NAME, WEBS_VERSION);
 #endif
-	websWrite(wp, T("Pragma: no-cache\n"));
-	websWrite(wp, T("Cache-control: no-cache\n"));
-	websWrite(wp, T("Content-Type: text/html\n"));
-	websWrite(wp, T("\n"));
-	websWrite(wp, T("<html>\n"));
+    websWrite(wp, T("Pragma: no-cache\n"));
+    websWrite(wp, T("Cache-control: no-cache\n"));
+    websWrite(wp, T("Content-Type: text/html\n"));
+    websWrite(wp, T("\n"));
+    websWrite(wp, T("<html>\n"));
 }
 
 
 void websFooter(webs_t wp)
 {
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
-	websWrite(wp, T("</html>\n"));
+    websWrite(wp, T("</html>\n"));
 }
 
 /*
diff --git a/h.c b/h.c
index 260ad280..c22444d1 100644
--- a/h.c
+++ b/h.c
@@ -9,18 +9,18 @@
 
 /********************************* Includes ***********************************/
 
-#include	"uemf.h"
+#include    "uemf.h"
 
 /********************************** Defines ***********************************/
 /*
     The handle list stores the length of the list and the number of used handles in the first two words.  These are
     hidden from the caller by returning a pointer to the third word to the caller.
  */
-#define H_LEN		0		/* First entry holds length of list */
-#define H_USED		1		/* Second entry holds number of used */
-#define H_OFFSET	2		/* Offset to real start of list */
+#define H_LEN       0       /* First entry holds length of list */
+#define H_USED      1       /* Second entry holds number of used */
+#define H_OFFSET    2       /* Offset to real start of list */
 
-#define H_INCR		16		/* Grow handle list in chunks this size */
+#define H_INCR      16      /* Grow handle list in chunks this size */
 
 /*********************************** Code *************************************/
 /*
@@ -35,101 +35,101 @@ int HALLOC(B_ARGS_DEC, void ***map)
 int hAlloc(void ***map)
 #endif
 {
-	int		*mp;
-	int		handle, len, memsize, incr;
+    int     *mp;
+    int     handle, len, memsize, incr;
 
-	a_assert(map);
+    a_assert(map);
 
-	if (*map == NULL) {
-		incr = H_INCR;
-		memsize = (incr + H_OFFSET) * sizeof(void**);
+    if (*map == NULL) {
+        incr = H_INCR;
+        memsize = (incr + H_OFFSET) * sizeof(void**);
 #ifdef B_STATS
-		if ((mp = (int*) balloc(B_ARGS, memsize)) == NULL) {
+        if ((mp = (int*) balloc(B_ARGS, memsize)) == NULL) {
 #else
-		if ((mp = (int*) balloc(B_L, memsize)) == NULL) {
+        if ((mp = (int*) balloc(B_L, memsize)) == NULL) {
 #endif
-			return -1;
-		}
-		memset(mp, 0, memsize);
-		mp[H_LEN] = incr;
-		mp[H_USED] = 0;
-		*map = (void**) &mp[H_OFFSET];
-	} else {
-		mp = &((*(int**)map)[-H_OFFSET]);
-	}
-	len = mp[H_LEN];
+            return -1;
+        }
+        memset(mp, 0, memsize);
+        mp[H_LEN] = incr;
+        mp[H_USED] = 0;
+        *map = (void**) &mp[H_OFFSET];
+    } else {
+        mp = &((*(int**)map)[-H_OFFSET]);
+    }
+    len = mp[H_LEN];
 
     /*
-      	Find the first null handle
+        Find the first null handle
      */
-	if (mp[H_USED] < mp[H_LEN]) {
-		for (handle = 0; handle < len; handle++) {
-			if (mp[handle+H_OFFSET] == 0) {
-				mp[H_USED]++;
-				return handle;
-			}
-		}
-	} else {
-		handle = len;
-	}
+    if (mp[H_USED] < mp[H_LEN]) {
+        for (handle = 0; handle < len; handle++) {
+            if (mp[handle+H_OFFSET] == 0) {
+                mp[H_USED]++;
+                return handle;
+            }
+        }
+    } else {
+        handle = len;
+    }
 
     /*
-      	No free handle so grow the handle list. Grow list in chunks of H_INCR.
+        No free handle so grow the handle list. Grow list in chunks of H_INCR.
      */
-	len += H_INCR;
-	memsize = (len + H_OFFSET) * sizeof(void**);
-	if ((mp = (int*) brealloc(B_L, (void*) mp, memsize)) == NULL) {
-		return -1;
-	}
-	*map = (void**) &mp[H_OFFSET];
-	mp[H_LEN] = len;
-	memset(&mp[H_OFFSET + len - H_INCR], 0, sizeof(int*) * H_INCR);
-	mp[H_USED]++;
-	return handle;
+    len += H_INCR;
+    memsize = (len + H_OFFSET) * sizeof(void**);
+    if ((mp = (int*) brealloc(B_L, (void*) mp, memsize)) == NULL) {
+        return -1;
+    }
+    *map = (void**) &mp[H_OFFSET];
+    mp[H_LEN] = len;
+    memset(&mp[H_OFFSET + len - H_INCR], 0, sizeof(int*) * H_INCR);
+    mp[H_USED]++;
+    return handle;
 }
 
 
 /*
-  	Free a handle.  This function returns the value of the largest handle in use plus 1, to be saved as a max value.
+    Free a handle.  This function returns the value of the largest handle in use plus 1, to be saved as a max value.
  */
 int hFree(void ***map, int handle)
 {
-	int		*mp;
-	int		len;
-
-	a_assert(map);
-	mp = &((*(int**)map)[-H_OFFSET]);
-	a_assert(mp[H_LEN] >= H_INCR);
-
-	a_assert(mp[handle + H_OFFSET]);
-	a_assert(mp[H_USED]);
-	mp[handle + H_OFFSET] = 0;
-	if (--(mp[H_USED]) == 0) {
-		bfree(B_L, (void*) mp);
-		*map = NULL;
-	}
+    int     *mp;
+    int     len;
+
+    a_assert(map);
+    mp = &((*(int**)map)[-H_OFFSET]);
+    a_assert(mp[H_LEN] >= H_INCR);
+
+    a_assert(mp[handle + H_OFFSET]);
+    a_assert(mp[H_USED]);
+    mp[handle + H_OFFSET] = 0;
+    if (--(mp[H_USED]) == 0) {
+        bfree(B_L, (void*) mp);
+        *map = NULL;
+    }
     /*
-      	Find the greatest handle number in use.
+        Find the greatest handle number in use.
      */
-	if (*map == NULL) {
-		handle = -1;
-	} else {
-		len = mp[H_LEN];
-		if (mp[H_USED] < mp[H_LEN]) {
-			for (handle = len - 1; handle >= 0; handle--) {
-				if (mp[handle + H_OFFSET])
-					break;
-			}
-		} else {
-			handle = len;
-		}
-	}
-	return handle + 1;
+    if (*map == NULL) {
+        handle = -1;
+    } else {
+        len = mp[H_LEN];
+        if (mp[H_USED] < mp[H_LEN]) {
+            for (handle = len - 1; handle >= 0; handle--) {
+                if (mp[handle + H_OFFSET])
+                    break;
+            }
+        } else {
+            handle = len;
+        }
+    }
+    return handle + 1;
 }
 
 
 /*
-  	Allocate an entry in the halloc array.
+    Allocate an entry in the halloc array.
  */
 #ifdef B_STATS
 int HALLOCENTRY(B_ARGS_DEC, void ***list, int *max, int size)
@@ -137,38 +137,38 @@ int HALLOCENTRY(B_ARGS_DEC, void ***list, int *max, int size)
 int hAllocEntry(void ***list, int *max, int size)
 #endif
 {
-	char_t	*cp;
-	int		id;
+    char_t  *cp;
+    int     id;
 
-	a_assert(list);
-	a_assert(max);
+    a_assert(list);
+    a_assert(max);
 
 #ifdef B_STATS
-	if ((id = HALLOC(B_ARGS, (void***) list)) < 0) {
+    if ((id = HALLOC(B_ARGS, (void***) list)) < 0) {
 #else
-	if ((id = hAlloc((void***) list)) < 0) {
+    if ((id = hAlloc((void***) list)) < 0) {
 #endif
-		return -1;
-	}
-	if (size > 0) {
+        return -1;
+    }
+    if (size > 0) {
 #ifdef B_STATS
-		if ((cp = balloc(B_ARGS, size)) == NULL) {
+        if ((cp = balloc(B_ARGS, size)) == NULL) {
 #else
-		if ((cp = balloc(B_L, size)) == NULL) {
+        if ((cp = balloc(B_L, size)) == NULL) {
 #endif
-			hFree(list, id);
-			return -1;
-		}
-		a_assert(cp);
-		memset(cp, 0, size);
-
-		(*list)[id] = (void*) cp;
-	}
-
-	if (id >= *max) {
-		*max = id + 1;
-	}
-	return id;
+            hFree(list, id);
+            return -1;
+        }
+        a_assert(cp);
+        memset(cp, 0, size);
+
+        (*list)[id] = (void*) cp;
+    }
+
+    if (id >= *max) {
+        *max = id + 1;
+    }
+    return id;
 }
 
 /*
diff --git a/handler.c b/handler.c
index ab51b376..92ff8dd4 100644
--- a/handler.c
+++ b/handler.c
@@ -1,57 +1,57 @@
 /*
     handler.c -- URL handler support
 
-  	This module implements a URL handler interface and API to permit the addition of user definable URL processors.
+    This module implements a URL handler interface and API to permit the addition of user definable URL processors.
 
     Copyright (c) All Rights Reserved. See details at the end of the file.
  */
 
 /********************************* Includes ***********************************/
 
-#include	"wsIntrn.h"
+#include    "wsIntrn.h"
 
 /*********************************** Locals ***********************************/
 
-static websUrlHandlerType	*websUrlHandler;			/* URL handler list */
-static int					websUrlHandlerMax;			/* Number of entries */
-static int					urlHandlerOpenCount = 0;	/* count of apps */
+static websUrlHandlerType   *websUrlHandler;            /* URL handler list */
+static int                  websUrlHandlerMax;          /* Number of entries */
+static int                  urlHandlerOpenCount = 0;    /* count of apps */
 
 /**************************** Forward Declarations ****************************/
 
-static int 		websUrlHandlerSort(const void *p1, const void *p2);
-static int 		websPublishHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, 
-				int sid, char_t *url, char_t *path, char_t *query);
-static char_t	*websCondenseMultipleChars(char_t *strToCondense, char_t cCondense);
+static int      websUrlHandlerSort(const void *p1, const void *p2);
+static int      websPublishHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, 
+                int sid, char_t *url, char_t *path, char_t *query);
+static char_t   *websCondenseMultipleChars(char_t *strToCondense, char_t cCondense);
 
 /*********************************** Code *************************************/
 
 int websUrlHandlerOpen()
 {
-	if (++urlHandlerOpenCount == 1) {
-		websAspOpen();
-		websUrlHandler = NULL;
-		websUrlHandlerMax = 0;
-	}
-	return 0;
+    if (++urlHandlerOpenCount == 1) {
+        websAspOpen();
+        websUrlHandler = NULL;
+        websUrlHandlerMax = 0;
+    }
+    return 0;
 }
 
 
 void websUrlHandlerClose()
 {
-	websUrlHandlerType *sp;
-
-	if (--urlHandlerOpenCount <= 0) {
-		websAspClose();
-		for (sp = websUrlHandler; sp < &websUrlHandler[websUrlHandlerMax];
-			sp++) {
-			bfree(B_L, sp->urlPrefix);
-			if (sp->webDir) {
-				bfree(B_L, sp->webDir);
-			}
-		}
-		bfree(B_L, websUrlHandler);
-		websUrlHandlerMax = 0;
-	}
+    websUrlHandlerType *sp;
+
+    if (--urlHandlerOpenCount <= 0) {
+        websAspClose();
+        for (sp = websUrlHandler; sp < &websUrlHandler[websUrlHandlerMax];
+            sp++) {
+            bfree(B_L, sp->urlPrefix);
+            if (sp->webDir) {
+                bfree(B_L, sp->webDir);
+            }
+        }
+        bfree(B_L, websUrlHandler);
+        websUrlHandlerMax = 0;
+    }
 }
 
 
@@ -63,40 +63,40 @@ void websUrlHandlerClose()
  */
 int websUrlHandlerDefine(char_t *urlPrefix, char_t *webDir, int arg, 
         int (*handler)(webs_t wp, char_t *urlPrefix, char_t *webdir, int arg, 
-		char_t *url, char_t *path, char_t *query), int flags)
+        char_t *url, char_t *path, char_t *query), int flags)
 {
-	websUrlHandlerType	*sp;
-	int					len;
+    websUrlHandlerType  *sp;
+    int                 len;
 
-	a_assert(urlPrefix);
-	a_assert(handler);
+    a_assert(urlPrefix);
+    a_assert(handler);
 
     /*
-      	Grow the URL handler array to create a new slot
+        Grow the URL handler array to create a new slot
      */
-	len = (websUrlHandlerMax + 1) * sizeof(websUrlHandlerType);
-	if ((websUrlHandler = brealloc(B_L, websUrlHandler, len)) == NULL) {
-		return -1;
-	}
-	sp = &websUrlHandler[websUrlHandlerMax++];
-	memset(sp, 0, sizeof(websUrlHandlerType));
-
-	sp->urlPrefix = bstrdup(B_L, urlPrefix);
-	sp->len = gstrlen(sp->urlPrefix);
-	if (webDir) {
-		sp->webDir = bstrdup(B_L, webDir);
-	} else {
-		sp->webDir = bstrdup(B_L, T(""));
-	}
-	sp->handler = handler;
-	sp->arg = arg;
-	sp->flags = flags;
+    len = (websUrlHandlerMax + 1) * sizeof(websUrlHandlerType);
+    if ((websUrlHandler = brealloc(B_L, websUrlHandler, len)) == NULL) {
+        return -1;
+    }
+    sp = &websUrlHandler[websUrlHandlerMax++];
+    memset(sp, 0, sizeof(websUrlHandlerType));
+
+    sp->urlPrefix = bstrdup(B_L, urlPrefix);
+    sp->len = gstrlen(sp->urlPrefix);
+    if (webDir) {
+        sp->webDir = bstrdup(B_L, webDir);
+    } else {
+        sp->webDir = bstrdup(B_L, T(""));
+    }
+    sp->handler = handler;
+    sp->arg = arg;
+    sp->flags = flags;
 
     /*
-      	Sort in decreasing URL length order observing the flags for first and last
+        Sort in decreasing URL length order observing the flags for first and last
      */
-	qsort(websUrlHandler, websUrlHandlerMax, sizeof(websUrlHandlerType), websUrlHandlerSort);
-	return 0;
+    qsort(websUrlHandler, websUrlHandlerMax, sizeof(websUrlHandlerType), websUrlHandlerSort);
+    return 0;
 }
 
 
@@ -105,102 +105,102 @@ int websUrlHandlerDefine(char_t *urlPrefix, char_t *webDir, int arg,
     handler is not found.  
  */
 int websUrlHandlerDelete(int (*handler)(webs_t wp, char_t *urlPrefix, 
-	char_t *webDir, int arg, char_t *url, char_t *path, char_t *query))
+    char_t *webDir, int arg, char_t *url, char_t *path, char_t *query))
 {
-	websUrlHandlerType	*sp;
-	int					i;
-
-	for (i = 0; i < websUrlHandlerMax; i++) {
-		sp = &websUrlHandler[i];
-		if (sp->handler == handler) {
-			sp->handler = NULL;
-			return 0;
-		}
-	}
-	return -1;
+    websUrlHandlerType  *sp;
+    int                 i;
+
+    for (i = 0; i < websUrlHandlerMax; i++) {
+        sp = &websUrlHandler[i];
+        if (sp->handler == handler) {
+            sp->handler = NULL;
+            return 0;
+        }
+    }
+    return -1;
 }
 
 
 /*
-  	Sort in decreasing URL length order observing the flags for first and last
+    Sort in decreasing URL length order observing the flags for first and last
  */
 static int websUrlHandlerSort(const void *p1, const void *p2)
 {
-	websUrlHandlerType	*s1, *s2;
-	int					rc;
-
-	a_assert(p1);
-	a_assert(p2);
-
-	s1 = (websUrlHandlerType*) p1;
-	s2 = (websUrlHandlerType*) p2;
-
-	if ((s1->flags & WEBS_HANDLER_FIRST) || (s2->flags & WEBS_HANDLER_LAST)) {
-		return -1;
-	}
-	if ((s2->flags & WEBS_HANDLER_FIRST) || (s1->flags & WEBS_HANDLER_LAST)) {
-		return 1;
-	}
-	if ((rc = gstrcmp(s1->urlPrefix, s2->urlPrefix)) == 0) {
-		if (s1->len < s2->len) {
-			return 1;
-		} else if (s1->len > s2->len) {
-			return -1;
-		}
-	}
-	return -rc; 
+    websUrlHandlerType  *s1, *s2;
+    int                 rc;
+
+    a_assert(p1);
+    a_assert(p2);
+
+    s1 = (websUrlHandlerType*) p1;
+    s2 = (websUrlHandlerType*) p2;
+
+    if ((s1->flags & WEBS_HANDLER_FIRST) || (s2->flags & WEBS_HANDLER_LAST)) {
+        return -1;
+    }
+    if ((s2->flags & WEBS_HANDLER_FIRST) || (s1->flags & WEBS_HANDLER_LAST)) {
+        return 1;
+    }
+    if ((rc = gstrcmp(s1->urlPrefix, s2->urlPrefix)) == 0) {
+        if (s1->len < s2->len) {
+            return 1;
+        } else if (s1->len > s2->len) {
+            return -1;
+        }
+    }
+    return -rc; 
 }
 
 
 /*
-  	Publish a new web directory (Use the default URL handler)
+    Publish a new web directory (Use the default URL handler)
  */
 int websPublish(char_t *urlPrefix, char_t *path)
 {
-	return websUrlHandlerDefine(urlPrefix, path, 0, websPublishHandler, 0);
+    return websUrlHandlerDefine(urlPrefix, path, 0, websPublishHandler, 0);
 }
 
 
 /*
-  	Return the directory for a given prefix. Ignore empty prefixes
+    Return the directory for a given prefix. Ignore empty prefixes
  */
 char_t *websGetPublishDir(char_t *path, char_t **urlPrefix)
 {
-	websUrlHandlerType	*sp;
-	int					i;
-
-	for (i = 0; i < websUrlHandlerMax; i++) {
-		sp = &websUrlHandler[i];
-		if (sp->urlPrefix[0] == '\0') {
-			continue;
-		}
-		if (sp->handler && gstrncmp(sp->urlPrefix, path, sp->len) == 0) {
-			if (urlPrefix) {
-				*urlPrefix = sp->urlPrefix;
-			}
-			return sp->webDir;
-		}
-	}
-	return NULL;
+    websUrlHandlerType  *sp;
+    int                 i;
+
+    for (i = 0; i < websUrlHandlerMax; i++) {
+        sp = &websUrlHandler[i];
+        if (sp->urlPrefix[0] == '\0') {
+            continue;
+        }
+        if (sp->handler && gstrncmp(sp->urlPrefix, path, sp->len) == 0) {
+            if (urlPrefix) {
+                *urlPrefix = sp->urlPrefix;
+            }
+            return sp->webDir;
+        }
+    }
+    return NULL;
 }
 
 
 /*
-  	Publish URL handler. We just patch the web page Directory and let the default handler do the rest.
+    Publish URL handler. We just patch the web page Directory and let the default handler do the rest.
  */
 static int websPublishHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int sid, char_t *url, char_t *path, char_t *query)
 {
-	int		len;
+    int     len;
 
-	a_assert(websValid(wp));
-	a_assert(path);
+    a_assert(websValid(wp));
+    a_assert(path);
 
     /*
         Trim the urlPrefix off the path and set the webdirectory. Add one to step over the trailing '/'
      */
-	len = gstrlen(urlPrefix) + 1;
-	websSetRequestPath(wp, webDir, &path[len]);
-	return 0;
+    len = gstrlen(urlPrefix) + 1;
+    websSetRequestPath(wp, webDir, &path[len]);
+    return 0;
 }
 
 
@@ -210,97 +210,97 @@ static int websPublishHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int
  */
 int websUrlHandlerRequest(webs_t wp)
 {
-	websUrlHandlerType	*sp;
-	int					i, first;
+    websUrlHandlerType  *sp;
+    int                 i, first;
 
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
     /*
         Delete the socket handler as we don't want to start reading any data on the connection as it may be for the next
         pipelined HTTP/1.1 request if using Keep Alive.
      */
-	socketDeleteHandler(wp->sid);
-	wp->state = WEBS_PROCESSING;
-	websStats.handlerHits++;
-	websSetRequestPath(wp, websGetDefaultDir(), NULL);
+    socketDeleteHandler(wp->sid);
+    wp->state = WEBS_PROCESSING;
+    websStats.handlerHits++;
+    websSetRequestPath(wp, websGetDefaultDir(), NULL);
 
     /*
-      	Eliminate security hole
+        Eliminate security hole
      */
- 	websCondenseMultipleChars(wp->path, '/');
-	websCondenseMultipleChars(wp->url, '/');
+    websCondenseMultipleChars(wp->path, '/');
+    websCondenseMultipleChars(wp->url, '/');
 
-	if ((wp->path[0] != '/') || strchr(wp->path, '\\')) {
-		websError(wp, 400, T("Bad request"));
-		return 0;
-	}
+    if ((wp->path[0] != '/') || strchr(wp->path, '\\')) {
+        websError(wp, 400, T("Bad request"));
+        return 0;
+    }
 
     /*
         We loop over each handler in order till one accepts the request.  The security handler will handle the request
         if access is NOT allowed.  
      */
-	first = 1;
-	for (i = 0; i < websUrlHandlerMax; i++) {
-		sp = &websUrlHandler[i];
-		if (sp->handler && gstrncmp(sp->urlPrefix, wp->path, sp->len) == 0) {
-			if (first) {
-				websSetEnv(wp);
-				first = 0;
-			}
-			if ((*sp->handler)(wp, sp->urlPrefix, sp->webDir, sp->arg, wp->url, wp->path, wp->query)) {
-				return 1;
-			}
-			if (!websValid(wp)) {
-				trace(0, T("webs: handler %s called websDone, but didn't return 1\n"), sp->urlPrefix);
-				return 1;
-			}
-		}
-	}
+    first = 1;
+    for (i = 0; i < websUrlHandlerMax; i++) {
+        sp = &websUrlHandler[i];
+        if (sp->handler && gstrncmp(sp->urlPrefix, wp->path, sp->len) == 0) {
+            if (first) {
+                websSetEnv(wp);
+                first = 0;
+            }
+            if ((*sp->handler)(wp, sp->urlPrefix, sp->webDir, sp->arg, wp->url, wp->path, wp->query)) {
+                return 1;
+            }
+            if (!websValid(wp)) {
+                trace(0, T("webs: handler %s called websDone, but didn't return 1\n"), sp->urlPrefix);
+                return 1;
+            }
+        }
+    }
     /*
-      	If no handler processed the request, then return an error. Note: It is the handlers responsibility to call websDone
+        If no handler processed the request, then return an error. Note: It is the handlers responsibility to call websDone
      */
-	if (i >= websUrlHandlerMax) {
-		websError(wp, 200, T("No handler for this URL"));
-	}
-	return 0;
+    if (i >= websUrlHandlerMax) {
+        websError(wp, 200, T("No handler for this URL"));
+    }
+    return 0;
 }
 
 
 
 /*
-  	Convert multiple adjacent occurrences of a given character to a single instance
+    Convert multiple adjacent occurrences of a given character to a single instance
  */
 static char_t *websCondenseMultipleChars(char_t *strToCondense, char_t cCondense)
 {
     char_t  *pStr, *pScan;
 
-	if (strToCondense != NULL) {
-		pStr = pScan = strToCondense;
-		while (*pScan && *pStr) {
+    if (strToCondense != NULL) {
+        pStr = pScan = strToCondense;
+        while (*pScan && *pStr) {
             /*
                 Advance scan pointer over multiple occurences of condense character
              */
-			while ((*pScan == cCondense) && (*(pScan + 1) == cCondense)) {
-				pScan++;
-			}
+            while ((*pScan == cCondense) && (*(pScan + 1) == cCondense)) {
+                pScan++;
+            }
             /*
                 Copy character if an advance of the scan pointer has occurred
              */
-			if (pStr != pScan) {
-				*pStr = *pScan;
-			}
-			
-			pScan++;
-			pStr++;
-		}
+            if (pStr != pScan) {
+                *pStr = *pScan;
+            }
+            
+            pScan++;
+            pStr++;
+        }
         /*
             Zero terminate string if multiple adjacent characters were found and condensed
          */
-		if (pStr != pScan) {
-			*pStr = 0;
-		}
-	}
-	return strToCondense;
+        if (pStr != pScan) {
+            *pStr = 0;
+        }
+    }
+    return strToCondense;
 }
 
 /*
diff --git a/matrixSSLSocket.c b/matrixSSLSocket.c
index 4bd479b3..979f1408 100644
--- a/matrixSSLSocket.c
+++ b/matrixSSLSocket.c
@@ -1,5 +1,5 @@
 /*
-  	matrixSSLSocket.c -	SSL socket layer for MatrixSSL
+    matrixSSLSocket.c - SSL socket layer for MatrixSSL
 
     Copyright (c) All Rights Reserved. See details at the end of the file.
  */
@@ -17,72 +17,72 @@
 #define LINUX 1
 #endif
 
-#define	MAX_WRITE_MSEC	500	/* Fail if we block more than X millisec on write */
+#define MAX_WRITE_MSEC  500 /* Fail if we block more than X millisec on write */
 
 /******************************************************************************/
 /*
-	Socket layer API for the MatrixSSL library.  
+    Socket layer API for the MatrixSSL library.  
 */
 static int waitForWriteEvent(int fd, int msec);
 static void setSocketNonblock(SOCKET sock);
 
 /******************************************************************************/
 /*
-	Server side.  Accept an incomming SSL connection request.
-	'conn' will be filled in with information about the accepted ssl connection
+    Server side.  Accept an incomming SSL connection request.
+    'conn' will be filled in with information about the accepted ssl connection
 
-	return -1 on error, 0 on success, or WOULD_BLOCK for non-blocking sockets
+    return -1 on error, 0 on success, or WOULD_BLOCK for non-blocking sockets
 */
 int sslAccept(sslConn_t **conn, SOCKET fd, sslKeys_t *keys, int32 resume, int32 (*certValidator)(ssl_t *, psX509Cert_t *, int32))
 {
-	sslConn_t		*cp;
-	int				rc;
-	
-	if (resume == 0) {
+    sslConn_t       *cp;
+    int             rc;
+    
+    if (resume == 0) {
         /*
             Associate a new ssl session with this socket.  The session represents the state of the ssl protocol over
             this socket.  Session caching is handled automatically by this api.  
          */
-		cp = balloc(B_L, sizeof(sslConn_t));
-		memset(cp, 0x0, sizeof(sslConn_t));
-		cp->fd = fd;
-		if (matrixSslNewServerSession(&cp->ssl, keys, certValidator) < 0) {
-			sslFreeConnection(&cp);
-			return -1;
-		}
+        cp = balloc(B_L, sizeof(sslConn_t));
+        memset(cp, 0x0, sizeof(sslConn_t));
+        cp->fd = fd;
+        if (matrixSslNewServerSession(&cp->ssl, keys, certValidator) < 0) {
+            sslFreeConnection(&cp);
+            return -1;
+        }
 #ifdef USE_NONBLOCKING_SSL_SOCKETS
-		/* Set this ourselves, "just to make sure" */
-		setSocketNonblock(fd);
+        /* Set this ourselves, "just to make sure" */
+        setSocketNonblock(fd);
 #endif
-	} else {
-		cp = *conn;
-	}
+    } else {
+        cp = *conn;
+    }
     /*
         This call will perform the SSL handshake
      */
-	rc = sslRead(cp, NULL, 0);
-	if (rc < 0) {
-		return -1;
-	}
-	*conn = cp;
-	return 0;
+    rc = sslRead(cp, NULL, 0);
+    if (rc < 0) {
+        return -1;
+    }
+    *conn = cp;
+    return 0;
 }
-	
+    
 
 /*
-	Primary MatrixSSL read function that transparently handles SSL handshakes and the subsequent incoming application data records.
-	
+    Primary MatrixSSL read function that transparently handles SSL handshakes and the subsequent incoming application data records.
+    
     A NULL inbuf parameter is an indication that this is a call to perform a new SSL handshake with an incoming client
     and no out data is expected
-	
-	Params:
-        inbuf	allocated storage for plaintext data to be copied to
-        inlen	length of inbuf
-	
-	Return codes:
-        -1	EOF or internal failure.  caller should free sess and close socket
-        0	success status.  no data is being returned to the caller
-        >0	success status.  number of plaintext bytes written to inbuf
+    
+    Params:
+        inbuf   allocated storage for plaintext data to be copied to
+        inlen   length of inbuf
+    
+    Return codes:
+        -1  EOF or internal failure.  caller should free sess and close socket
+        0   success status.  no data is being returned to the caller
+        >0  success status.  number of plaintext bytes written to inbuf
  
     Note that unlike a standard "socket read", a read of an SSL record can produce data that must be written, for
     example, a response to a handshake message that must be sent before any more data is read. Also, data can be read
@@ -99,190 +99,190 @@ int sslAccept(sslConn_t **conn, SOCKET fd, sslKeys_t *keys, int32 resume, int32
     slow-reading client to a server with full TCP buffers. A non-malicious client in this situation would read
     immediately after a re-handshake request and fail anyway because a buffered appdata record would be read.
 */
-int	sslRead(sslConn_t *cp, char *inbuf, int inlen)
-{	
-	unsigned char	*buf;
-	int				rc, len, transferred;
+int sslRead(sslConn_t *cp, char *inbuf, int inlen)
+{   
+    unsigned char   *buf;
+    int             rc, len, transferred;
 
     /*
         Always first look to see if any plaintext application data is waiting We have two levels of buffer here, one for
         decoded data and one for partial, still encoded SSL records. The partial SSL records are stored transparently in
         MatrixSSL, but the plaintext is stored in 'cp'.
      */
-	if (inbuf != NULL && inlen > 0 && cp->ptBytes > 0 && cp->pt) {
-		if (cp->ptBytes < inlen) {
-			inlen = cp->ptBytes;
-		}
-		memcpy(inbuf, cp->currPt, inlen);
-		cp->currPt += inlen;
-		cp->ptBytes -= inlen;
-		/* Free buffer as we go if empty */
-		if (cp->ptBytes == 0) {
-			bfree(B_L, cp->pt);
-			cp->pt = cp->currPt = NULL;
-		}
-		return inlen;
-	}
+    if (inbuf != NULL && inlen > 0 && cp->ptBytes > 0 && cp->pt) {
+        if (cp->ptBytes < inlen) {
+            inlen = cp->ptBytes;
+        }
+        memcpy(inbuf, cp->currPt, inlen);
+        cp->currPt += inlen;
+        cp->ptBytes -= inlen;
+        /* Free buffer as we go if empty */
+        if (cp->ptBytes == 0) {
+            bfree(B_L, cp->pt);
+            cp->pt = cp->currPt = NULL;
+        }
+        return inlen;
+    }
     /*
         If there is outgoing data buffered, just try to write it here before doing our read on the socket. Because the
         read could produce data to be written, this will ensure we have as much room as possible in that case for the
         written record. Note that there may be data here to send because of a previous sslWrite that got EWOULDBLOCK.
     */
 WRITE_MORE:
-	if ((len = matrixSslGetOutdata(cp->ssl, &buf)) > 0) {
-		transferred = send(cp->fd, buf, len, MSG_NOSIGNAL);
-		if (transferred <= 0) {
-			if (socketGetError() != EWOULDBLOCK) {
-				return -1;
-			}
-			if (waitForWriteEvent(cp->fd, MAX_WRITE_MSEC) == 0) {
-				goto WRITE_MORE;
-			}
-			return -1;
-		} else {
-			/* Indicate that we've written > 0 bytes of data */
-			if ((rc = matrixSslSentData(cp->ssl, transferred)) < 0) {
-				return -1;
-			}
-			if (rc == MATRIXSSL_REQUEST_CLOSE) {
-				return -1;
-			} else if (rc == MATRIXSSL_HANDSHAKE_COMPLETE) {
-				/* If called via sslAccept (NULL buf), then we can just leave */
-				return 0;
-			}
-			/* Try to send again if more data to send */
-			if (rc == MATRIXSSL_REQUEST_SEND || transferred < len) {
-				goto WRITE_MORE;
-			}
-		}
-	} else if (len < 0) {
-		return -1;
-	}
+    if ((len = matrixSslGetOutdata(cp->ssl, &buf)) > 0) {
+        transferred = send(cp->fd, buf, len, MSG_NOSIGNAL);
+        if (transferred <= 0) {
+            if (socketGetError() != EWOULDBLOCK) {
+                return -1;
+            }
+            if (waitForWriteEvent(cp->fd, MAX_WRITE_MSEC) == 0) {
+                goto WRITE_MORE;
+            }
+            return -1;
+        } else {
+            /* Indicate that we've written > 0 bytes of data */
+            if ((rc = matrixSslSentData(cp->ssl, transferred)) < 0) {
+                return -1;
+            }
+            if (rc == MATRIXSSL_REQUEST_CLOSE) {
+                return -1;
+            } else if (rc == MATRIXSSL_HANDSHAKE_COMPLETE) {
+                /* If called via sslAccept (NULL buf), then we can just leave */
+                return 0;
+            }
+            /* Try to send again if more data to send */
+            if (rc == MATRIXSSL_REQUEST_SEND || transferred < len) {
+                goto WRITE_MORE;
+            }
+        }
+    } else if (len < 0) {
+        return -1;
+    }
 
 READ_MORE:
-	/* Get the ssl buffer and how much data it can accept */
-	/* Note 0 is a return failure, unlike with matrixSslGetOutdata */
-	if ((len = matrixSslGetReadbuf(cp->ssl, &buf)) <= 0) {
-		return -1;
-	}
-	if ((transferred = recv(cp->fd, buf, len, MSG_NOSIGNAL)) < 0) {
-		/* Support non-blocking sockets if turned on */
-		if (socketGetError() == EWOULDBLOCK) {
-				return 0;
-		}
-		trace(1, T("RECV error: %d\n"), socketGetError());
-		return -1;
-	}
-	if (transferred == 0) {
-		/* If EOF, remote socket closed. This is semi-normal closure. */	
-		trace(4, T("Closing connection %d on EOF\n"), cp->fd);
-		return -1;
-	}
+    /* Get the ssl buffer and how much data it can accept */
+    /* Note 0 is a return failure, unlike with matrixSslGetOutdata */
+    if ((len = matrixSslGetReadbuf(cp->ssl, &buf)) <= 0) {
+        return -1;
+    }
+    if ((transferred = recv(cp->fd, buf, len, MSG_NOSIGNAL)) < 0) {
+        /* Support non-blocking sockets if turned on */
+        if (socketGetError() == EWOULDBLOCK) {
+                return 0;
+        }
+        trace(1, T("RECV error: %d\n"), socketGetError());
+        return -1;
+    }
+    if (transferred == 0) {
+        /* If EOF, remote socket closed. This is semi-normal closure. */    
+        trace(4, T("Closing connection %d on EOF\n"), cp->fd);
+        return -1;
+    }
     /*
         Notify SSL state machine that we've received more data into the ssl buffer retreived with matrixSslGetReadbuf.
      */
-	if ((rc = matrixSslReceivedData(cp->ssl, transferred, &buf, 
-			(uint32*)&len)) < 0) {
-		return -1;
-	}
-
-PROCESS_MORE:		
-	switch (rc) {
-		case MATRIXSSL_REQUEST_SEND:
-			/* There is a handshake response we must send */
-			goto WRITE_MORE;
-		case MATRIXSSL_REQUEST_RECV:
-			goto READ_MORE;
-		case MATRIXSSL_HANDSHAKE_COMPLETE:
-			/* Session resumption handshake */
-			goto READ_MORE;
-		case MATRIXSSL_RECEIVED_ALERT:
-			/* Any fatal alert will simply cause a read error and exit */
-			if (*buf == SSL_ALERT_LEVEL_FATAL) {
-				trace(1, T("Fatal alert: %d, closing connection.\n"), *(buf + 1));
-				return -1;
-			}
-			/* Closure alert is normal (and best) way to close */
-			if (*(buf + 1) == SSL_ALERT_CLOSE_NOTIFY) {
-				return -1;
-			}
-			/* Eating warning alerts */
-			trace(4, T("Warning alert: %d\n"), *(buf + 1));
-			if ((rc = matrixSslProcessedData(cp->ssl, &buf, (uint32*)&len)) == 0) {
-				/* Possible there was plaintext before the alert */
-				if (inbuf != NULL && inlen > 0 && cp->ptBytes > 0 && cp->pt) {
-					if (cp->ptBytes < inlen) {
-						inlen = cp->ptBytes;
-					}
-					memcpy(inbuf, cp->currPt, inlen);
-					cp->currPt += inlen;
-					cp->ptBytes -= inlen;
-					/* Free buffer as we go if empty */
-					if (cp->ptBytes == 0) {
-						bfree(B_L, cp->pt);
-						cp->pt = cp->currPt = NULL;
-					}
-					return inlen;
-				} else {
-					return 0;
-				}
-			}
-			goto PROCESS_MORE;
-
-		case MATRIXSSL_APP_DATA:
-			if (cp->ptBytes == 0) {
+    if ((rc = matrixSslReceivedData(cp->ssl, transferred, &buf, 
+            (uint32*)&len)) < 0) {
+        return -1;
+    }
+
+PROCESS_MORE:       
+    switch (rc) {
+        case MATRIXSSL_REQUEST_SEND:
+            /* There is a handshake response we must send */
+            goto WRITE_MORE;
+        case MATRIXSSL_REQUEST_RECV:
+            goto READ_MORE;
+        case MATRIXSSL_HANDSHAKE_COMPLETE:
+            /* Session resumption handshake */
+            goto READ_MORE;
+        case MATRIXSSL_RECEIVED_ALERT:
+            /* Any fatal alert will simply cause a read error and exit */
+            if (*buf == SSL_ALERT_LEVEL_FATAL) {
+                trace(1, T("Fatal alert: %d, closing connection.\n"), *(buf + 1));
+                return -1;
+            }
+            /* Closure alert is normal (and best) way to close */
+            if (*(buf + 1) == SSL_ALERT_CLOSE_NOTIFY) {
+                return -1;
+            }
+            /* Eating warning alerts */
+            trace(4, T("Warning alert: %d\n"), *(buf + 1));
+            if ((rc = matrixSslProcessedData(cp->ssl, &buf, (uint32*)&len)) == 0) {
+                /* Possible there was plaintext before the alert */
+                if (inbuf != NULL && inlen > 0 && cp->ptBytes > 0 && cp->pt) {
+                    if (cp->ptBytes < inlen) {
+                        inlen = cp->ptBytes;
+                    }
+                    memcpy(inbuf, cp->currPt, inlen);
+                    cp->currPt += inlen;
+                    cp->ptBytes -= inlen;
+                    /* Free buffer as we go if empty */
+                    if (cp->ptBytes == 0) {
+                        bfree(B_L, cp->pt);
+                        cp->pt = cp->currPt = NULL;
+                    }
+                    return inlen;
+                } else {
+                    return 0;
+                }
+            }
+            goto PROCESS_MORE;
+
+        case MATRIXSSL_APP_DATA:
+            if (cp->ptBytes == 0) {
                 /*
                     Catching here means this is new app data just grabbed off the wire. 
                  */
-				cp->ptBytes = len;
-				cp->pt = balloc(B_L, len);
-				memcpy(cp->pt, buf, len);
-				cp->currPt = cp->pt;
-			} else {
+                cp->ptBytes = len;
+                cp->pt = balloc(B_L, len);
+                memcpy(cp->pt, buf, len);
+                cp->currPt = cp->pt;
+            } else {
                 /*
                     Multi-record.  This case should only ever be possible if no data has already been read out of the
                     'pt' cache so it is fine to assume an unprocessed buffer.
                 */
-				psAssert(cp->pt == cp->currPt);
-				cp->pt = brealloc(B_L, cp->pt, cp->ptBytes + len);
-				memcpy(cp->pt + cp->ptBytes, buf, len);
-				cp->currPt = cp->pt;
-				cp->ptBytes += len;
-			}
-			if ((rc = matrixSslProcessedData(cp->ssl, &buf, (uint32*)&len)) < 0) {
-				return -1;
-			}
-			/* Check for multi-record app data*/
-			if (rc > 0) {
-				goto PROCESS_MORE;
-			}
+                psAssert(cp->pt == cp->currPt);
+                cp->pt = brealloc(B_L, cp->pt, cp->ptBytes + len);
+                memcpy(cp->pt + cp->ptBytes, buf, len);
+                cp->currPt = cp->pt;
+                cp->ptBytes += len;
+            }
+            if ((rc = matrixSslProcessedData(cp->ssl, &buf, (uint32*)&len)) < 0) {
+                return -1;
+            }
+            /* Check for multi-record app data*/
+            if (rc > 0) {
+                goto PROCESS_MORE;
+            }
             /*
                 Otherwise pass back how much the caller wants to read (if any)
              */
-			if (inbuf != 0 && inlen > 0) {
-				if (cp->ptBytes < inlen) {
-					inlen = cp->ptBytes;
-				}
-				memcpy(inbuf, cp->currPt, inlen);
-				cp->currPt += inlen;
-				cp->ptBytes -= inlen;
-				return inlen; /* Just a breakpoint holder */
-			}
-			return 0; /* Have it stored, but caller didn't want any data */
-		default:
-			return -1;
-	}
-	return 0; /* really can never hit this */
+            if (inbuf != 0 && inlen > 0) {
+                if (cp->ptBytes < inlen) {
+                    inlen = cp->ptBytes;
+                }
+                memcpy(inbuf, cp->currPt, inlen);
+                cp->currPt += inlen;
+                cp->ptBytes -= inlen;
+                return inlen; /* Just a breakpoint holder */
+            }
+            return 0; /* Have it stored, but caller didn't want any data */
+        default:
+            return -1;
+    }
+    return 0; /* really can never hit this */
 }
 
 
 /*
-	sslWrite encodes 'data' as a single SSL record.
+    sslWrite encodes 'data' as a single SSL record.
 
-	Return codes:
-        -1	Internal failure. caller should free sess and close socket
-        0	WOULDBLOCK. caller should call back with same input later
-        > 0	success status.  number of plaintext bytes encoded and sent
+    Return codes:
+        -1  Internal failure. caller should free sess and close socket
+        0   WOULDBLOCK. caller should call back with same input later
+        > 0 success status.  number of plaintext bytes encoded and sent
  
     In order for non-blocking sockets to work transparently to the upper layers in webs, we manage the buffering of
     outgoing data and fudge the number of bytes sent until the entire SSL record is sent.
@@ -304,8 +304,8 @@ PROCESS_MORE:
 */
 int sslWrite(sslConn_t *cp, char *data, int len)
 {
-	unsigned char	*buf; 
-	int				rc, transferred, ctLen;
+    unsigned char   *buf; 
+    int             rc, transferred, ctLen;
 
     /*
         If sendBlocked is set, then the previous time into sslWrite with this cp could not send all the requested data,
@@ -313,98 +313,98 @@ int sslWrite(sslConn_t *cp, char *data, int len)
         buffer, and we don't need to re-encode it here.  This assumes that the caller is sending the same 'len' and
         contents of 'data' as they did last time.
      */
-	if (!cp->sendBlocked) {
-		if (matrixSslGetWritebuf(cp->ssl, &buf, len) < len) { 
-			/* SSL buffer must hold requested plaintext + SSL overhead */
-			return -1;
-		}
-		memcpy((char *)buf, data, len); 
-		if (matrixSslEncodeWritebuf(cp->ssl, len) < 0) { 
-			return -1; 
-		}
-	} else {
+    if (!cp->sendBlocked) {
+        if (matrixSslGetWritebuf(cp->ssl, &buf, len) < len) { 
+            /* SSL buffer must hold requested plaintext + SSL overhead */
+            return -1;
+        }
+        memcpy((char *)buf, data, len); 
+        if (matrixSslEncodeWritebuf(cp->ssl, len) < 0) { 
+            return -1; 
+        }
+    } else {
         /*
             Not all previously encoded data could be sent without blocking and 0 bytes was previously returned to caller
             as sent. Ensure caller is retrying with same len (and presumably the same data).
          */
-		if (len != cp->ptReqBytes) {
-			a_assert(len != cp->ptReqBytes);
-			return -1;
-		}
-	}
+        if (len != cp->ptReqBytes) {
+            a_assert(len != cp->ptReqBytes);
+            return -1;
+        }
+    }
 WRITE_MORE:
     /*
         There is a small chance that we are here with sendBlocked set, and yet there is no buffered outdata to send.
         This happens because a send can also happen in sslRead, and that could have flushed the outgoing buffer in
         addition to a handshake message reply.
      */
-	ctLen = matrixSslGetOutdata(cp->ssl, &buf);
-	if (ctLen > 0) {
-		transferred = send(cp->fd, buf, ctLen, MSG_NOSIGNAL); 
-		if (transferred <= 0) {
+    ctLen = matrixSslGetOutdata(cp->ssl, &buf);
+    if (ctLen > 0) {
+        transferred = send(cp->fd, buf, ctLen, MSG_NOSIGNAL); 
+        if (transferred <= 0) {
 #ifdef USE_NONBLOCKING_SSL_SOCKETS
-			if (socketGetError() != EWOULDBLOCK) {
-				return -1;
-			}
-			if (!cp->sendBlocked) {
-				cp->sendBlocked = 1;
-				cp->ptReqBytes = len;
-			} else {
-			}
-			return 0;
+            if (socketGetError() != EWOULDBLOCK) {
+                return -1;
+            }
+            if (!cp->sendBlocked) {
+                cp->sendBlocked = 1;
+                cp->ptReqBytes = len;
+            } else {
+            }
+            return 0;
 #else
-			return -1;
+            return -1;
 #endif
-		}
-		/* Update the SSL buffer that we've written > 0 bytes of data */ 
-		if ((rc = matrixSslSentData(cp->ssl, transferred)) < 0) { 
-			return -1; 
-		}
-		/* There is more data in the SSL buffer to send */
-		if (rc == MATRIXSSL_REQUEST_SEND) {
-			goto WRITE_MORE;
-		}
-	}
-	cp->sendBlocked = 0;
-	cp->ptReqBytes = 0;
-	return len; 
+        }
+        /* Update the SSL buffer that we've written > 0 bytes of data */ 
+        if ((rc = matrixSslSentData(cp->ssl, transferred)) < 0) { 
+            return -1; 
+        }
+        /* There is more data in the SSL buffer to send */
+        if (rc == MATRIXSSL_REQUEST_SEND) {
+            goto WRITE_MORE;
+        }
+    }
+    cp->sendBlocked = 0;
+    cp->ptReqBytes = 0;
+    return len; 
 }
 
 
 void sslWriteClosureAlert(sslConn_t *cp)
 {
-	unsigned char	*buf;
-	int				len;
-	
-	if (cp != NULL) {
-		if (matrixSslEncodeClosureAlert(cp->ssl) >= 0) {
-			if ((len = matrixSslGetOutdata(cp->ssl, &buf)) > 0) {
-				/* Non-blocking hail-mary alert */
-				setSocketNonblock(cp->fd);
-				if ((len = send(cp->fd, buf, len, MSG_DONTWAIT)) > 0) {
-					matrixSslSentData(cp->ssl, len);
-				}
-			}
-		}
-	}
+    unsigned char   *buf;
+    int             len;
+    
+    if (cp != NULL) {
+        if (matrixSslEncodeClosureAlert(cp->ssl) >= 0) {
+            if ((len = matrixSslGetOutdata(cp->ssl, &buf)) > 0) {
+                /* Non-blocking hail-mary alert */
+                setSocketNonblock(cp->fd);
+                if ((len = send(cp->fd, buf, len, MSG_DONTWAIT)) > 0) {
+                    matrixSslSentData(cp->ssl, len);
+                }
+            }
+        }
+    }
 }
 
 
 /*
-	Close a seesion that was opened with sslAccept or sslConnect and free the insock and outsock buffers
+    Close a seesion that was opened with sslAccept or sslConnect and free the insock and outsock buffers
 */
 void sslFreeConnection(sslConn_t **cpp)
 {
-	sslConn_t	*conn;
-
-	conn = *cpp;
-	matrixSslDeleteSession(conn->ssl);
-	conn->ssl = NULL;
-	if (conn->pt != NULL) {
-		bfree(B_L, conn->pt);
-	}
-	bfree(B_L, conn);
-	*cpp = NULL;
+    sslConn_t   *conn;
+
+    conn = *cpp;
+    matrixSslDeleteSession(conn->ssl);
+    conn->ssl = NULL;
+    if (conn->pt != NULL) {
+        bfree(B_L, conn->pt);
+    }
+    bfree(B_L, conn);
+    *cpp = NULL;
 }
 
 
@@ -414,36 +414,36 @@ void sslFreeConnection(sslConn_t **cpp)
  */
 static int waitForWriteEvent(int fd, int msec)
 {
-	struct timeval	tv;
-	fd_set		 	writeFds;
-	
-	FD_ZERO(&writeFds);
-	FD_SET(fd, &writeFds);
-	tv.tv_sec = msec / 1000;
-	tv.tv_usec = (msec % 1000) * 1000;
-	if (select(fd + 1, NULL, &writeFds, NULL, &tv) > 0 && 
-			FD_ISSET(fd, &writeFds)) {
-		return 0;
-	}
-	return -1;
+    struct timeval  tv;
+    fd_set          writeFds;
+    
+    FD_ZERO(&writeFds);
+    FD_SET(fd, &writeFds);
+    tv.tv_sec = msec / 1000;
+    tv.tv_usec = (msec % 1000) * 1000;
+    if (select(fd + 1, NULL, &writeFds, NULL, &tv) > 0 && 
+            FD_ISSET(fd, &writeFds)) {
+        return 0;
+    }
+    return -1;
 }
 
 
 /*
-	Turn off socket blocking mode.
+    Turn off socket blocking mode.
  */
 static void setSocketNonblock(SOCKET sock)
 {
 #if _WIN32
-	int		block = 1;
-	ioctlsocket(sock, FIONBIO, &block);
+    int     block = 1;
+    ioctlsocket(sock, FIONBIO, &block);
 #elif LINUX
-	fcntl(sock, F_SETFL, fcntl(sock, F_GETFL) | O_NONBLOCK);
+    fcntl(sock, F_SETFL, fcntl(sock, F_GETFL) | O_NONBLOCK);
 #endif
 #ifdef MACOSX
-	/* Prevent SIGPIPE when writing to closed socket on OS X */
-	int		onoff = 1;
-	setsockopt(sock, SOL_SOCKET, SO_NOSIGPIPE, (void *)&onoff, sizeof(onoff));
+    /* Prevent SIGPIPE when writing to closed socket on OS X */
+    int     onoff = 1;
+    setsockopt(sock, SOL_SOCKET, SO_NOSIGPIPE, (void *)&onoff, sizeof(onoff));
 #endif
 }
 
diff --git a/matrixSSLSocket.h b/matrixSSLSocket.h
index 37a2e88e..98b1da44 100644
--- a/matrixSSLSocket.h
+++ b/matrixSSLSocket.h
@@ -1,5 +1,5 @@
 /*
-  	matrixSSLSocket.h -	SSL socket layer header for MatrixSSL
+    matrixSSLSocket.h - SSL socket layer header for MatrixSSL
   
     Copyright (c) All Rights Reserved. See details at the end of the file.
  */
@@ -17,67 +17,67 @@ extern "C" {
 #include "matrixssl/matrixsslApi.h"
 
 /*
-	Blocking or non-blocking socket model.  Disable for blocking
+    Blocking or non-blocking socket model.  Disable for blocking
 */
-#define	USE_NONBLOCKING_SSL_SOCKETS
+#define USE_NONBLOCKING_SSL_SOCKETS
 
 #ifdef MACOSX
 #define LINUX 1
 #define OSX 1
 #endif
 /*
-	OS specific macros
+    OS specific macros
 */
 #if WIN32 || WINCE
-	#include	<windows.h>
-	#include	<winsock.h>
-	#define		fcntl(A, B, C)
-	#define		MSG_NOSIGNAL	0
-	#define		MSG_DONTWAIT	0
-	#define		WOULD_BLOCK	WSAEWOULDBLOCK
-	#define		getSocketError()  WSAGetLastError()
+    #include    <windows.h>
+    #include    <winsock.h>
+    #define     fcntl(A, B, C)
+    #define     MSG_NOSIGNAL    0
+    #define     MSG_DONTWAIT    0
+    #define     WOULD_BLOCK WSAEWOULDBLOCK
+    #define     getSocketError()  WSAGetLastError()
 #elif LINUX
-	#include	<sys/socket.h>
-	#include	<netinet/in.h>
-	#include	<netinet/tcp.h>
-	#include	<arpa/inet.h>
+    #include    <sys/socket.h>
+    #include    <netinet/in.h>
+    #include    <netinet/tcp.h>
+    #include    <arpa/inet.h>
 #ifdef OSX
-	#include	<sys/socket.h>
-	#define		MSG_NOSIGNAL	0
+    #include    <sys/socket.h>
+    #define     MSG_NOSIGNAL    0
 #endif /* OSX */
-	#include	<fcntl.h>
-	#include	<unistd.h>
-	#include	<string.h>
-	#include	<errno.h>
-	#define		SOCKET_ERROR -1
-	#define		getSocketError() errno 
-	#define		WOULD_BLOCK	EAGAIN
-	#define		closesocket close
-	#define		MAKEWORD(A, B)
-	#define		WSAStartup(A, B)
-	#define		WSACleanup()
-	#define		INVALID_SOCKET -1
-	typedef int	WSADATA;
-	typedef int	SOCKET;
+    #include    <fcntl.h>
+    #include    <unistd.h>
+    #include    <string.h>
+    #include    <errno.h>
+    #define     SOCKET_ERROR -1
+    #define     getSocketError() errno 
+    #define     WOULD_BLOCK EAGAIN
+    #define     closesocket close
+    #define     MAKEWORD(A, B)
+    #define     WSAStartup(A, B)
+    #define     WSACleanup()
+    #define     INVALID_SOCKET -1
+    typedef int WSADATA;
+    typedef int SOCKET;
 #elif VXWORKS
-	#include	<types.h>
-	#include	<socket.h>
-	#include	<netinet/in.h>
-	#include	<netinet/tcp.h>
-	#include	<fcntl.h>
-	#include	<errno.h>
-	#define		fcntl(A, B, C) ioctl(A, B, C)
-	#define		SOCKET_ERROR -1
-	#define		getSocketError() errno 
-	#define		WOULD_BLOCK	EAGAIN
-	#define		closesocket close
-	#define		MAKEWORD(A, B)
-	#define		WSAStartup(A, B)
-	#define		WSACleanup()
-	#define		INVALID_SOCKET -1
-	#define		MSG_NOSIGNAL	0
-	typedef int	WSADATA;
-	typedef int	SOCKET;
+    #include    <types.h>
+    #include    <socket.h>
+    #include    <netinet/in.h>
+    #include    <netinet/tcp.h>
+    #include    <fcntl.h>
+    #include    <errno.h>
+    #define     fcntl(A, B, C) ioctl(A, B, C)
+    #define     SOCKET_ERROR -1
+    #define     getSocketError() errno 
+    #define     WOULD_BLOCK EAGAIN
+    #define     closesocket close
+    #define     MAKEWORD(A, B)
+    #define     WSAStartup(A, B)
+    #define     WSACleanup()
+    #define     INVALID_SOCKET -1
+    #define     MSG_NOSIGNAL    0
+    typedef int WSADATA;
+    typedef int SOCKET;
 #endif /* OS macros */
 
 #ifdef MACOSX
@@ -86,40 +86,40 @@ extern "C" {
 #endif
 
 #define sslAssert(C) if (C) ; else {fprintf(stderr, "%s:%d sslAssert(%s)\n",\
-						__FILE__, __LINE__, #C); }
+                        __FILE__, __LINE__, #C); }
 #ifndef min
-#define min(a,b)	(((a) < (b)) ? (a) : (b))
+#define min(a,b)    (((a) < (b)) ? (a) : (b))
 #endif /* min */
 
 /*
-	sslRead and sslWrite status values
+    sslRead and sslWrite status values
 */
-#define SSLSOCKET_EOF			0x1
-#define SSLSOCKET_CLOSE_NOTIFY	0x2
+#define SSLSOCKET_EOF           0x1
+#define SSLSOCKET_CLOSE_NOTIFY  0x2
 
 /*
-	Connection structure
+    Connection structure
 */
 typedef struct {
-	ssl_t				*ssl;
-	char				*pt;		/* app data start */
-	char				*currPt;	/* app data current location */
-	int					ptBytes;	/* plaintext bytes remaining */
-	SOCKET				fd;
-	int					ptReqBytes;
-	int					sendBlocked;
+    ssl_t               *ssl;
+    char                *pt;        /* app data start */
+    char                *currPt;    /* app data current location */
+    int                 ptBytes;    /* plaintext bytes remaining */
+    SOCKET              fd;
+    int                 ptReqBytes;
+    int                 sendBlocked;
 } sslConn_t;
 
 /*
-	Secure Socket apis
+    Secure Socket apis
 */
-extern int	sslAccept(sslConn_t **cp, SOCKET fd, sslKeys_t *keys, int32 resume,
-				int (*certValidator)(ssl_t *, psX509Cert_t *, int32));
-extern void	sslFreeConnection(sslConn_t **cp);
+extern int  sslAccept(sslConn_t **cp, SOCKET fd, sslKeys_t *keys, int32 resume,
+                int (*certValidator)(ssl_t *, psX509Cert_t *, int32));
+extern void sslFreeConnection(sslConn_t **cp);
 
-extern int	sslRead(sslConn_t *cp, char *buf, int len);
-extern int	sslWrite(sslConn_t *cp, char *buf, int len);
-extern void	sslWriteClosureAlert(sslConn_t *cp);
+extern int  sslRead(sslConn_t *cp, char *buf, int len);
+extern int  sslWrite(sslConn_t *cp, char *buf, int len);
+extern void sslWriteClosureAlert(sslConn_t *cp);
 
 #ifdef __cplusplus
 }
diff --git a/md5.h b/md5.h
index f17dba4c..3cbae82b 100644
--- a/md5.h
+++ b/md5.h
@@ -1,5 +1,5 @@
 /*
-  	md5.h
+    md5.h
 
     Copyright (c) All Rights Reserved. See details at the end of the file.
  */
@@ -11,7 +11,7 @@
 #ifndef WEBS_SSL_SUPPORT
 
 #ifndef ulong32
-typedef unsigned int	ulong32;
+typedef unsigned int    ulong32;
 #endif
 
 typedef struct {
@@ -21,19 +21,19 @@ typedef struct {
     unsigned char buf[64];
 } psDigestContext_t;
 
-typedef psDigestContext_t	psMd5Context_t;
+typedef psDigestContext_t   psMd5Context_t;
 
 extern void psMd5Init(psMd5Context_t *md);
 extern void psMd5Update(psMd5Context_t *md, unsigned char *buf, unsigned int len);
-extern int	psMd5Final(psMd5Context_t *md, unsigned char *hash);
+extern int  psMd5Final(psMd5Context_t *md, unsigned char *hash);
 
 /* 
     Uncomment below for old API Compatibility
 
-typedef psMdContext_t		MD5_CONTEXT;
-#define MD5Init(A)			psMd5Init(A)
-#define MD5Update(A, B, C)	psMd5Update(A, B, C);
-#define MD5Final(A, B)		psMd5Final(B, A);
+typedef psMdContext_t       MD5_CONTEXT;
+#define MD5Init(A)          psMd5Init(A)
+#define MD5Update(A, B, C)  psMd5Update(A, B, C);
+#define MD5Final(A, B)      psMd5Final(B, A);
 */
 
 #endif /* WEBS_SSL_SUPPORT */
diff --git a/md5c.c b/md5c.c
index 07e703f7..f587e7f3 100644
--- a/md5c.c
+++ b/md5c.c
@@ -1,5 +1,5 @@
 /*
-  	md5c.c - MD5 hash implementation
+    md5c.c - MD5 hash implementation
 
     Copyright (c) All Rights Reserved. See details at the end of the file.
 
@@ -15,26 +15,26 @@
 #include "md5.h"
 typedef int             int32;
 
-#define F(x,y,z)	(z ^ (x & (y ^ z)))
-#define G(x,y,z)	(y ^ (z & (y ^ x)))
-#define H(x,y,z)	(x^y^z)
-#define I(x,y,z)	(y^(x|(~z)))
+#define F(x,y,z)    (z ^ (x & (y ^ z)))
+#define G(x,y,z)    (y ^ (z & (y ^ x)))
+#define H(x,y,z)    (x^y^z)
+#define I(x,y,z)    (y^(x|(~z)))
 
 #ifndef MIN
 #define MIN(x, y) ( ((x)<(y))?(x):(y) )
 #endif
 
 #define STORE32L(x, y)                         \
-	{ (y)[3] = (unsigned char)(((x)>>24)&255); \
-	  (y)[2] = (unsigned char)(((x)>>16)&255); \
-	  (y)[1] = (unsigned char)(((x)>>8)&255);  \
-	  (y)[0] = (unsigned char)((x)&255); }
+    { (y)[3] = (unsigned char)(((x)>>24)&255); \
+      (y)[2] = (unsigned char)(((x)>>16)&255); \
+      (y)[1] = (unsigned char)(((x)>>8)&255);  \
+      (y)[0] = (unsigned char)((x)&255); }
 
 #define LOAD32L(x, y)                           \
-	{ x = ((unsigned long)((y)[3] & 255)<<24) | \
-		  ((unsigned long)((y)[2] & 255)<<16) | \
-		  ((unsigned long)((y)[1] & 255)<<8)  | \
-		  ((unsigned long)((y)[0] & 255)); }
+    { x = ((unsigned long)((y)[3] & 255)<<24) | \
+          ((unsigned long)((y)[2] & 255)<<16) | \
+          ((unsigned long)((y)[1] & 255)<<8)  | \
+          ((unsigned long)((y)[0] & 255)); }
 
 #ifdef SMALL_CODE
 
@@ -43,49 +43,49 @@ typedef int             int32;
 0xFFFFFFFFUL)
 
 #define FF(a,b,c,d,M,s,t) \
-	a = (a + F(b,c,d) + M + t); a = ROL(a, s) + b;
+    a = (a + F(b,c,d) + M + t); a = ROL(a, s) + b;
 
 #define GG(a,b,c,d,M,s,t) \
-	a = (a + G(b,c,d) + M + t); a = ROL(a, s) + b;
+    a = (a + G(b,c,d) + M + t); a = ROL(a, s) + b;
 
 #define HH(a,b,c,d,M,s,t) \
-	a = (a + H(b,c,d) + M + t); a = ROL(a, s) + b;
+    a = (a + H(b,c,d) + M + t); a = ROL(a, s) + b;
 
 #define II(a,b,c,d,M,s,t) \
-	a = (a + I(b,c,d) + M + t); a = ROL(a, s) + b;
+    a = (a + I(b,c,d) + M + t); a = ROL(a, s) + b;
 
 static const unsigned char Worder[64] = {
-	0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
-	1,6,11,0,5,10,15,4,9,14,3,8,13,2,7,12,
-	5,8,11,14,1,4,7,10,13,0,3,6,9,12,15,2,
-	0,7,14,5,12,3,10,1,8,15,6,13,4,11,2,9
+    0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
+    1,6,11,0,5,10,15,4,9,14,3,8,13,2,7,12,
+    5,8,11,14,1,4,7,10,13,0,3,6,9,12,15,2,
+    0,7,14,5,12,3,10,1,8,15,6,13,4,11,2,9
 };
 
 static const unsigned char Rorder[64] = {
-	7,12,17,22,7,12,17,22,7,12,17,22,7,12,17,22,
-	5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20,
-	4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23,
-	6,10,15,21,6,10,15,21,6,10,15,21,6,10,15,21
+    7,12,17,22,7,12,17,22,7,12,17,22,7,12,17,22,
+    5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20,
+    4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23,
+    6,10,15,21,6,10,15,21,6,10,15,21,6,10,15,21
 };
 
 static const ulong32 Korder[] = {
-	0xd76aa478UL, 0xe8c7b756UL, 0x242070dbUL, 0xc1bdceeeUL,
-	0xf57c0fafUL, 0x4787c62aUL, 0xa8304613UL, 0xfd469501UL,
-	0x698098d8UL, 0x8b44f7afUL, 0xffff5bb1UL, 0x895cd7beUL,
-	0x6b901122UL, 0xfd987193UL, 0xa679438eUL, 0x49b40821UL,
-	0xf61e2562UL, 0xc040b340UL, 0x265e5a51UL, 0xe9b6c7aaUL,
-	0xd62f105dUL, 0x02441453UL, 0xd8a1e681UL, 0xe7d3fbc8UL,
-	0x21e1cde6UL, 0xc33707d6UL, 0xf4d50d87UL, 0x455a14edUL,
-	0xa9e3e905UL, 0xfcefa3f8UL, 0x676f02d9UL, 0x8d2a4c8aUL,
-	0xfffa3942UL, 0x8771f681UL, 0x6d9d6122UL, 0xfde5380cUL,
-	0xa4beea44UL, 0x4bdecfa9UL, 0xf6bb4b60UL, 0xbebfbc70UL,
-	0x289b7ec6UL, 0xeaa127faUL, 0xd4ef3085UL, 0x04881d05UL,
-	0xd9d4d039UL, 0xe6db99e5UL, 0x1fa27cf8UL, 0xc4ac5665UL,
-	0xf4292244UL, 0x432aff97UL, 0xab9423a7UL, 0xfc93a039UL,
-	0x655b59c3UL, 0x8f0ccc92UL, 0xffeff47dUL, 0x85845dd1UL,
-	0x6fa87e4fUL, 0xfe2ce6e0UL, 0xa3014314UL, 0x4e0811a1UL,
-	0xf7537e82UL, 0xbd3af235UL, 0x2ad7d2bbUL, 0xeb86d391UL,
-	0xe1f27f3aUL, 0xf5710fb0UL, 0xada0e5c4UL, 0x98e4c919UL
+    0xd76aa478UL, 0xe8c7b756UL, 0x242070dbUL, 0xc1bdceeeUL,
+    0xf57c0fafUL, 0x4787c62aUL, 0xa8304613UL, 0xfd469501UL,
+    0x698098d8UL, 0x8b44f7afUL, 0xffff5bb1UL, 0x895cd7beUL,
+    0x6b901122UL, 0xfd987193UL, 0xa679438eUL, 0x49b40821UL,
+    0xf61e2562UL, 0xc040b340UL, 0x265e5a51UL, 0xe9b6c7aaUL,
+    0xd62f105dUL, 0x02441453UL, 0xd8a1e681UL, 0xe7d3fbc8UL,
+    0x21e1cde6UL, 0xc33707d6UL, 0xf4d50d87UL, 0x455a14edUL,
+    0xa9e3e905UL, 0xfcefa3f8UL, 0x676f02d9UL, 0x8d2a4c8aUL,
+    0xfffa3942UL, 0x8771f681UL, 0x6d9d6122UL, 0xfde5380cUL,
+    0xa4beea44UL, 0x4bdecfa9UL, 0xf6bb4b60UL, 0xbebfbc70UL,
+    0x289b7ec6UL, 0xeaa127faUL, 0xd4ef3085UL, 0x04881d05UL,
+    0xd9d4d039UL, 0xe6db99e5UL, 0x1fa27cf8UL, 0xc4ac5665UL,
+    0xf4292244UL, 0x432aff97UL, 0xab9423a7UL, 0xfc93a039UL,
+    0x655b59c3UL, 0x8f0ccc92UL, 0xffeff47dUL, 0x85845dd1UL,
+    0x6fa87e4fUL, 0xfe2ce6e0UL, 0xa3014314UL, 0x4e0811a1UL,
+    0xf7537e82UL, 0xbd3af235UL, 0x2ad7d2bbUL, 0xeb86d391UL,
+    0xe1f27f3aUL, 0xf5710fb0UL, 0xada0e5c4UL, 0x98e4c919UL
  };
 #else /* SMALL_CODE */
 
@@ -94,13 +94,13 @@ static const ulong32 Korder[] = {
 0xFFFFFFFFUL) 
 
 #define FF(a,b,c,d,M,s,t) \
-	a = (a + F(b,c,d) + M + t); a = ROLc(a, s) + b;
+    a = (a + F(b,c,d) + M + t); a = ROLc(a, s) + b;
 
 #define GG(a,b,c,d,M,s,t) \
-	a = (a + G(b,c,d) + M + t); a = ROLc(a, s) + b;
+    a = (a + G(b,c,d) + M + t); a = ROLc(a, s) + b;
 
 #define HH(a,b,c,d,M,s,t) \
-	a = (a + H(b,c,d) + M + t); a = ROLc(a, s) + b;
+    a = (a + H(b,c,d) + M + t); a = ROLc(a, s) + b;
 
 #define II(a,b,c,d,M,s,t) \
     a = (a + I(b,c,d) + M + t); a = ROLc(a, s) + b;
@@ -109,120 +109,120 @@ static const ulong32 Korder[] = {
 
 static void _md5_compress(psMd5Context_t *md)
 {
-	unsigned long	i, W[16], a, b, c, d;
+    unsigned long   i, W[16], a, b, c, d;
     //  MOB
 #ifdef SMALL_CODE
-	ulong32			t;
+    ulong32         t;
 #endif
 
     /*
         copy the state into 512-bits into W[0..15]
      */
-	for (i = 0; i < 16; i++) {
-		LOAD32L(W[i], md->buf + (4*i));
-	}
+    for (i = 0; i < 16; i++) {
+        LOAD32L(W[i], md->buf + (4*i));
+    }
 
     /*
         copy state
      */
-	a = md->state[0];
-	b = md->state[1];
-	c = md->state[2];
-	d = md->state[3];
+    a = md->state[0];
+    b = md->state[1];
+    c = md->state[2];
+    d = md->state[3];
 
 #ifdef SMALL_CODE
-	for (i = 0; i < 16; ++i) {
-		FF(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
-		t = d; d = c; c = b; b = a; a = t;
-	}
-
-	for (; i < 32; ++i) {
-		GG(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
-		t = d; d = c; c = b; b = a; a = t;
-	}
-
-	for (; i < 48; ++i) {
-		HH(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
-		t = d; d = c; c = b; b = a; a = t;
-	}
-
-	for (; i < 64; ++i) {
-		II(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
-		t = d; d = c; c = b; b = a; a = t;
-	}
+    for (i = 0; i < 16; ++i) {
+        FF(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
+        t = d; d = c; c = b; b = a; a = t;
+    }
+
+    for (; i < 32; ++i) {
+        GG(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
+        t = d; d = c; c = b; b = a; a = t;
+    }
+
+    for (; i < 48; ++i) {
+        HH(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
+        t = d; d = c; c = b; b = a; a = t;
+    }
+
+    for (; i < 64; ++i) {
+        II(a,b,c,d,W[Worder[i]],Rorder[i],Korder[i]);
+        t = d; d = c; c = b; b = a; a = t;
+    }
 
 #else /* SMALL_CODE */
 
-	FF(a,b,c,d,W[0],7,0xd76aa478UL)
-	FF(d,a,b,c,W[1],12,0xe8c7b756UL)
-	FF(c,d,a,b,W[2],17,0x242070dbUL)
-	FF(b,c,d,a,W[3],22,0xc1bdceeeUL)
-	FF(a,b,c,d,W[4],7,0xf57c0fafUL)
-	FF(d,a,b,c,W[5],12,0x4787c62aUL)
-	FF(c,d,a,b,W[6],17,0xa8304613UL)
-	FF(b,c,d,a,W[7],22,0xfd469501UL)
-	FF(a,b,c,d,W[8],7,0x698098d8UL)
-	FF(d,a,b,c,W[9],12,0x8b44f7afUL)
-	FF(c,d,a,b,W[10],17,0xffff5bb1UL)
-	FF(b,c,d,a,W[11],22,0x895cd7beUL)
-	FF(a,b,c,d,W[12],7,0x6b901122UL)
-	FF(d,a,b,c,W[13],12,0xfd987193UL)
-	FF(c,d,a,b,W[14],17,0xa679438eUL)
-	FF(b,c,d,a,W[15],22,0x49b40821UL)
-	GG(a,b,c,d,W[1],5,0xf61e2562UL)
-	GG(d,a,b,c,W[6],9,0xc040b340UL)
-	GG(c,d,a,b,W[11],14,0x265e5a51UL)
-	GG(b,c,d,a,W[0],20,0xe9b6c7aaUL)
-	GG(a,b,c,d,W[5],5,0xd62f105dUL)
-	GG(d,a,b,c,W[10],9,0x02441453UL)
-	GG(c,d,a,b,W[15],14,0xd8a1e681UL)
-	GG(b,c,d,a,W[4],20,0xe7d3fbc8UL)
-	GG(a,b,c,d,W[9],5,0x21e1cde6UL)
-	GG(d,a,b,c,W[14],9,0xc33707d6UL)
-	GG(c,d,a,b,W[3],14,0xf4d50d87UL)
-	GG(b,c,d,a,W[8],20,0x455a14edUL)
-	GG(a,b,c,d,W[13],5,0xa9e3e905UL)
-	GG(d,a,b,c,W[2],9,0xfcefa3f8UL)
-	GG(c,d,a,b,W[7],14,0x676f02d9UL)
-	GG(b,c,d,a,W[12],20,0x8d2a4c8aUL)
-	HH(a,b,c,d,W[5],4,0xfffa3942UL)
-	HH(d,a,b,c,W[8],11,0x8771f681UL)
-	HH(c,d,a,b,W[11],16,0x6d9d6122UL)
-	HH(b,c,d,a,W[14],23,0xfde5380cUL)
-	HH(a,b,c,d,W[1],4,0xa4beea44UL)
-	HH(d,a,b,c,W[4],11,0x4bdecfa9UL)
-	HH(c,d,a,b,W[7],16,0xf6bb4b60UL)
-	HH(b,c,d,a,W[10],23,0xbebfbc70UL)
-	HH(a,b,c,d,W[13],4,0x289b7ec6UL)
-	HH(d,a,b,c,W[0],11,0xeaa127faUL)
-	HH(c,d,a,b,W[3],16,0xd4ef3085UL)
-	HH(b,c,d,a,W[6],23,0x04881d05UL)
-	HH(a,b,c,d,W[9],4,0xd9d4d039UL)
-	HH(d,a,b,c,W[12],11,0xe6db99e5UL)
-	HH(c,d,a,b,W[15],16,0x1fa27cf8UL)
-	HH(b,c,d,a,W[2],23,0xc4ac5665UL)
-	II(a,b,c,d,W[0],6,0xf4292244UL)
-	II(d,a,b,c,W[7],10,0x432aff97UL)
-	II(c,d,a,b,W[14],15,0xab9423a7UL)
-	II(b,c,d,a,W[5],21,0xfc93a039UL)
-	II(a,b,c,d,W[12],6,0x655b59c3UL)
-	II(d,a,b,c,W[3],10,0x8f0ccc92UL)
-	II(c,d,a,b,W[10],15,0xffeff47dUL)
-	II(b,c,d,a,W[1],21,0x85845dd1UL)
-	II(a,b,c,d,W[8],6,0x6fa87e4fUL)
-	II(d,a,b,c,W[15],10,0xfe2ce6e0UL)
-	II(c,d,a,b,W[6],15,0xa3014314UL)
-	II(b,c,d,a,W[13],21,0x4e0811a1UL)
-	II(a,b,c,d,W[4],6,0xf7537e82UL)
-	II(d,a,b,c,W[11],10,0xbd3af235UL)
-	II(c,d,a,b,W[2],15,0x2ad7d2bbUL)
-	II(b,c,d,a,W[9],21,0xeb86d391UL)
+    FF(a,b,c,d,W[0],7,0xd76aa478UL)
+    FF(d,a,b,c,W[1],12,0xe8c7b756UL)
+    FF(c,d,a,b,W[2],17,0x242070dbUL)
+    FF(b,c,d,a,W[3],22,0xc1bdceeeUL)
+    FF(a,b,c,d,W[4],7,0xf57c0fafUL)
+    FF(d,a,b,c,W[5],12,0x4787c62aUL)
+    FF(c,d,a,b,W[6],17,0xa8304613UL)
+    FF(b,c,d,a,W[7],22,0xfd469501UL)
+    FF(a,b,c,d,W[8],7,0x698098d8UL)
+    FF(d,a,b,c,W[9],12,0x8b44f7afUL)
+    FF(c,d,a,b,W[10],17,0xffff5bb1UL)
+    FF(b,c,d,a,W[11],22,0x895cd7beUL)
+    FF(a,b,c,d,W[12],7,0x6b901122UL)
+    FF(d,a,b,c,W[13],12,0xfd987193UL)
+    FF(c,d,a,b,W[14],17,0xa679438eUL)
+    FF(b,c,d,a,W[15],22,0x49b40821UL)
+    GG(a,b,c,d,W[1],5,0xf61e2562UL)
+    GG(d,a,b,c,W[6],9,0xc040b340UL)
+    GG(c,d,a,b,W[11],14,0x265e5a51UL)
+    GG(b,c,d,a,W[0],20,0xe9b6c7aaUL)
+    GG(a,b,c,d,W[5],5,0xd62f105dUL)
+    GG(d,a,b,c,W[10],9,0x02441453UL)
+    GG(c,d,a,b,W[15],14,0xd8a1e681UL)
+    GG(b,c,d,a,W[4],20,0xe7d3fbc8UL)
+    GG(a,b,c,d,W[9],5,0x21e1cde6UL)
+    GG(d,a,b,c,W[14],9,0xc33707d6UL)
+    GG(c,d,a,b,W[3],14,0xf4d50d87UL)
+    GG(b,c,d,a,W[8],20,0x455a14edUL)
+    GG(a,b,c,d,W[13],5,0xa9e3e905UL)
+    GG(d,a,b,c,W[2],9,0xfcefa3f8UL)
+    GG(c,d,a,b,W[7],14,0x676f02d9UL)
+    GG(b,c,d,a,W[12],20,0x8d2a4c8aUL)
+    HH(a,b,c,d,W[5],4,0xfffa3942UL)
+    HH(d,a,b,c,W[8],11,0x8771f681UL)
+    HH(c,d,a,b,W[11],16,0x6d9d6122UL)
+    HH(b,c,d,a,W[14],23,0xfde5380cUL)
+    HH(a,b,c,d,W[1],4,0xa4beea44UL)
+    HH(d,a,b,c,W[4],11,0x4bdecfa9UL)
+    HH(c,d,a,b,W[7],16,0xf6bb4b60UL)
+    HH(b,c,d,a,W[10],23,0xbebfbc70UL)
+    HH(a,b,c,d,W[13],4,0x289b7ec6UL)
+    HH(d,a,b,c,W[0],11,0xeaa127faUL)
+    HH(c,d,a,b,W[3],16,0xd4ef3085UL)
+    HH(b,c,d,a,W[6],23,0x04881d05UL)
+    HH(a,b,c,d,W[9],4,0xd9d4d039UL)
+    HH(d,a,b,c,W[12],11,0xe6db99e5UL)
+    HH(c,d,a,b,W[15],16,0x1fa27cf8UL)
+    HH(b,c,d,a,W[2],23,0xc4ac5665UL)
+    II(a,b,c,d,W[0],6,0xf4292244UL)
+    II(d,a,b,c,W[7],10,0x432aff97UL)
+    II(c,d,a,b,W[14],15,0xab9423a7UL)
+    II(b,c,d,a,W[5],21,0xfc93a039UL)
+    II(a,b,c,d,W[12],6,0x655b59c3UL)
+    II(d,a,b,c,W[3],10,0x8f0ccc92UL)
+    II(c,d,a,b,W[10],15,0xffeff47dUL)
+    II(b,c,d,a,W[1],21,0x85845dd1UL)
+    II(a,b,c,d,W[8],6,0x6fa87e4fUL)
+    II(d,a,b,c,W[15],10,0xfe2ce6e0UL)
+    II(c,d,a,b,W[6],15,0xa3014314UL)
+    II(b,c,d,a,W[13],21,0x4e0811a1UL)
+    II(a,b,c,d,W[4],6,0xf7537e82UL)
+    II(d,a,b,c,W[11],10,0xbd3af235UL)
+    II(c,d,a,b,W[2],15,0x2ad7d2bbUL)
+    II(b,c,d,a,W[9],21,0xeb86d391UL)
 #endif /* SMALL_CODE */
 
-	md->state[0] = md->state[0] + a;
-	md->state[1] = md->state[1] + b;
-	md->state[2] = md->state[2] + c;
-	md->state[3] = md->state[3] + d;
+    md->state[0] = md->state[0] + a;
+    md->state[1] = md->state[1] + b;
+    md->state[2] = md->state[2] + c;
+    md->state[3] = md->state[3] + d;
 }
 
 static void psZeromem(void *dst, int len)
@@ -243,118 +243,118 @@ static void psBurnStack(int len)
 
 static void md5_compress(psMd5Context_t *md)
 {
-	_md5_compress(md);
-	psBurnStack(sizeof(unsigned long) * 21);
+    _md5_compress(md);
+    psBurnStack(sizeof(unsigned long) * 21);
 }
 
 void psMd5Init(psMd5Context_t* md)
 {
-	md->state[0] = 0x67452301UL;
-	md->state[1] = 0xefcdab89UL;
-	md->state[2] = 0x98badcfeUL;
-	md->state[3] = 0x10325476UL;
-	md->curlen = 0;
+    md->state[0] = 0x67452301UL;
+    md->state[1] = 0xefcdab89UL;
+    md->state[2] = 0x98badcfeUL;
+    md->state[3] = 0x10325476UL;
+    md->curlen = 0;
 #ifdef USE_INT64
-	md->length = 0;
+    md->length = 0;
 #else
-	md->lengthHi = 0;
-	md->lengthLo = 0;
+    md->lengthHi = 0;
+    md->lengthLo = 0;
 #endif /* USE_INT64 */
 }
 
 void psMd5Update(psMd5Context_t* md, unsigned char *buf, unsigned int len)
 {
-	unsigned long n;
+    unsigned long n;
 
-	while (len > 0) {
-		n = MIN(len, (64 - md->curlen));
-		memcpy(md->buf + md->curlen, buf, (int)n);
-		md->curlen	+= n;
-		buf			+= n;
-		len			-= n;
+    while (len > 0) {
+        n = MIN(len, (64 - md->curlen));
+        memcpy(md->buf + md->curlen, buf, (int)n);
+        md->curlen  += n;
+        buf         += n;
+        len         -= n;
 
         /*
             is 64 bytes full?
          */
-		if (md->curlen == 64) {
-			md5_compress(md);
+        if (md->curlen == 64) {
+            md5_compress(md);
             //  MOB
 #ifdef USE_INT64
-			md->length += 512;
+            md->length += 512;
 #else
-			n = (md->lengthLo + 512) & 0xFFFFFFFFL;
-			if (n < md->lengthLo) {
-				md->lengthHi++;
-			}
-			md->lengthLo = n;
+            n = (md->lengthLo + 512) & 0xFFFFFFFFL;
+            if (n < md->lengthLo) {
+                md->lengthHi++;
+            }
+            md->lengthLo = n;
 #endif /* USE_INT64 */
-			md->curlen = 0;
-		}
-	}
+            md->curlen = 0;
+        }
+    }
 }
 
 int32 psMd5Final(psMd5Context_t* md, unsigned char *hash)
 {
-	int32 i;
+    int32 i;
 #ifndef USE_INT64
-	unsigned long	n;
+    unsigned long   n;
 #endif
 
-	if (hash == NULL) {
-		return -1;
-	}
+    if (hash == NULL) {
+        return -1;
+    }
     /*
         increase the length of the message
      */
 #ifdef USE_INT64
-	md->length += md->curlen << 3;
+    md->length += md->curlen << 3;
 #else
-	n = (md->lengthLo + (md->curlen << 3)) & 0xFFFFFFFFL;
-	if (n < md->lengthLo) {
-		md->lengthHi++;
-	}
-	md->lengthHi += (md->curlen >> 29);
-	md->lengthLo = n;
+    n = (md->lengthLo + (md->curlen << 3)) & 0xFFFFFFFFL;
+    if (n < md->lengthLo) {
+        md->lengthHi++;
+    }
+    md->lengthHi += (md->curlen >> 29);
+    md->lengthLo = n;
 #endif /* USE_INT64 */
     /*
         Append the '1' bit
      */
-	md->buf[md->curlen++] = (unsigned char)0x80;
+    md->buf[md->curlen++] = (unsigned char)0x80;
     /*
         If the length is currently above 56 bytes we append zeros then compress.  Then we can fall back to padding zeros
         and length encoding like normal.  
      */
-	if (md->curlen > 56) {
-		while (md->curlen < 64) {
-			md->buf[md->curlen++] = (unsigned char)0;
-		}
-		md5_compress(md);
-		md->curlen = 0;
-	}
+    if (md->curlen > 56) {
+        while (md->curlen < 64) {
+            md->buf[md->curlen++] = (unsigned char)0;
+        }
+        md5_compress(md);
+        md->curlen = 0;
+    }
     /*
         pad upto 56 bytes of zeroes
      */
-	while (md->curlen < 56) {
-		md->buf[md->curlen++] = (unsigned char)0;
-	}
+    while (md->curlen < 56) {
+        md->buf[md->curlen++] = (unsigned char)0;
+    }
     /*
         store length
      */
 #ifdef USE_INT64
-	STORE64L(md->length, md->buf+56);
+    STORE64L(md->length, md->buf+56);
 #else
-	STORE32L(md->lengthLo, md->buf+56);
-	STORE32L(md->lengthHi, md->buf+60);
+    STORE32L(md->lengthLo, md->buf+56);
+    STORE32L(md->lengthHi, md->buf+60);
 #endif /* USE_INT64 */
-	md5_compress(md);
+    md5_compress(md);
     /*
         copy output
      */
-	for (i = 0; i < 4; i++) {
-		STORE32L(md->state[i], hash+(4*i));
-	}
-	psZeromem(md, sizeof(psMd5Context_t));
-	return 16;
+    for (i = 0; i < 4; i++) {
+        STORE32L(md->state[i], hash+(4*i));
+    }
+    psZeromem(md, sizeof(psMd5Context_t));
+    return 16;
 }
 #endif /* !WEBS_SSL_SUPPORT */
 #endif /* !DIGEST_ACCESS_SUPPORT */
diff --git a/mime.c b/mime.c
index e0cf1ce5..b31cd8dd 100644
--- a/mime.c
+++ b/mime.c
@@ -8,106 +8,106 @@
 
 /********************************* Includes ***********************************/
 
-#include	"wsIntrn.h"
+#include    "wsIntrn.h"
 
 /******************************** Global Data *********************************/
 /*
-  	Addd entries to the MimeList as required for your content
+    Addd entries to the MimeList as required for your content
     MOB - compare with appweb
  */
 //  MOB - move to config?
-#define MORE_MIME_TYPES	1
+#define MORE_MIME_TYPES 1
 websMimeType websMimeList[] = {
-	{ T("application/java"), T(".class") },
-	{ T("application/java"), T(".jar") },
-	{ T("text/html"), T(".asp") },
-	{ T("text/html"), T(".htm") },
-	{ T("text/html"), T(".html") },
-	{ T("text/xml"), T(".xml") },
-	{ T("image/gif"), T(".gif") },
-	{ T("image/jpeg"), T(".jpg") },
-	{ T("image/png"), T(".png") },
-	{ T("image/vnd.microsoft.icon"), T(".ico") },
-	{ T("text/css"), T(".css") },
-	{ T("text/plain"), T(".txt") },
+    { T("application/java"), T(".class") },
+    { T("application/java"), T(".jar") },
+    { T("text/html"), T(".asp") },
+    { T("text/html"), T(".htm") },
+    { T("text/html"), T(".html") },
+    { T("text/xml"), T(".xml") },
+    { T("image/gif"), T(".gif") },
+    { T("image/jpeg"), T(".jpg") },
+    { T("image/png"), T(".png") },
+    { T("image/vnd.microsoft.icon"), T(".ico") },
+    { T("text/css"), T(".css") },
+    { T("text/plain"), T(".txt") },
    { T("application/x-javascript"), T(".js") },
    { T("application/x-shockwave-flash"), T(".swf") },
 
 #ifdef MORE_MIME_TYPES
-	{ T("application/binary"), T(".exe") },
-	{ T("application/compress"), T(".z") },
-	{ T("application/gzip"), T(".gz") },
-	{ T("application/octet-stream"), T(".bin") },
-	{ T("application/oda"), T(".oda") },
-	{ T("application/pdf"), T(".pdf") },
-	{ T("application/postscript"), T(".ai") },
-	{ T("application/postscript"), T(".eps") },
-	{ T("application/postscript"), T(".ps") },
-	{ T("application/rtf"), T(".rtf") },
-	{ T("application/x-bcpio"), T(".bcpio") },
-	{ T("application/x-cpio"), T(".cpio") },
-	{ T("application/x-csh"), T(".csh") },
-	{ T("application/x-dvi"), T(".dvi") },
-	{ T("application/x-gtar"), T(".gtar") },
-	{ T("application/x-hdf"), T(".hdf") },
-	{ T("application/x-latex"), T(".latex") },
-	{ T("application/x-mif"), T(".mif") },
-	{ T("application/x-netcdf"), T(".nc") },
-	{ T("application/x-netcdf"), T(".cdf") },
-	{ T("application/x-ns-proxy-autoconfig"), T(".pac") },
-	{ T("application/x-patch"), T(".patch") },
-	{ T("application/x-sh"), T(".sh") },
-	{ T("application/x-shar"), T(".shar") },
-	{ T("application/x-sv4cpio"), T(".sv4cpio") },
-	{ T("application/x-sv4crc"), T(".sv4crc") },
-	{ T("application/x-tar"), T(".tar") },
-	{ T("application/x-tgz"), T(".tgz") },
-	{ T("application/x-tcl"), T(".tcl") },
-	{ T("application/x-tex"), T(".tex") },
-	{ T("application/x-texinfo"), T(".texinfo") },
-	{ T("application/x-texinfo"), T(".texi") },
-	{ T("application/x-troff"), T(".t") },
-	{ T("application/x-troff"), T(".tr") },
-	{ T("application/x-troff"), T(".roff") },
-	{ T("application/x-troff-man"), T(".man") },
-	{ T("application/x-troff-me"), T(".me") },
-	{ T("application/x-troff-ms"), T(".ms") },
-	{ T("application/x-ustar"), T(".ustar") },
-	{ T("application/x-wais-source"), T(".src") },
-	{ T("application/zip"), T(".zip") },
-	{ T("audio/basic"), T(".au snd") },
-	{ T("audio/x-aiff"), T(".aif") },
-	{ T("audio/x-aiff"), T(".aiff") },
-	{ T("audio/x-aiff"), T(".aifc") },
-	{ T("audio/x-wav"), T(".wav") },
-	{ T("audio/x-wav"), T(".ram") },
-	{ T("image/ief"), T(".ief") },
-	{ T("image/jpeg"), T(".jpeg") },
-	{ T("image/jpeg"), T(".jpe") },
-	{ T("image/tiff"), T(".tiff") },
-	{ T("image/tiff"), T(".tif") },
-	{ T("image/x-cmu-raster"), T(".ras") },
-	{ T("image/x-portable-anymap"), T(".pnm") },
-	{ T("image/x-portable-bitmap"), T(".pbm") },
-	{ T("image/x-portable-graymap"), T(".pgm") },
-	{ T("image/x-portable-pixmap"), T(".ppm") },
-	{ T("image/x-rgb"), T(".rgb") },
-	{ T("image/x-xbitmap"), T(".xbm") },
-	{ T("image/x-xpixmap"), T(".xpm") },
-	{ T("image/x-xwindowdump"), T(".xwd") },
-	{ T("text/html"), T(".cfm") },
-	{ T("text/html"), T(".shtm") },
-	{ T("text/html"), T(".shtml") },
-	{ T("text/richtext"), T(".rtx") },
-	{ T("text/tab-separated-values"), T(".tsv") },
-	{ T("text/x-setext"), T(".etx") },
-	{ T("video/mpeg"), T(".mpeg mpg mpe") },
-	{ T("video/quicktime"), T(".qt") },
-	{ T("video/quicktime"), T(".mov") },
-	{ T("video/x-msvideo"), T(".avi") },
-	{ T("video/x-sgi-movie"), T(".movie") },
+    { T("application/binary"), T(".exe") },
+    { T("application/compress"), T(".z") },
+    { T("application/gzip"), T(".gz") },
+    { T("application/octet-stream"), T(".bin") },
+    { T("application/oda"), T(".oda") },
+    { T("application/pdf"), T(".pdf") },
+    { T("application/postscript"), T(".ai") },
+    { T("application/postscript"), T(".eps") },
+    { T("application/postscript"), T(".ps") },
+    { T("application/rtf"), T(".rtf") },
+    { T("application/x-bcpio"), T(".bcpio") },
+    { T("application/x-cpio"), T(".cpio") },
+    { T("application/x-csh"), T(".csh") },
+    { T("application/x-dvi"), T(".dvi") },
+    { T("application/x-gtar"), T(".gtar") },
+    { T("application/x-hdf"), T(".hdf") },
+    { T("application/x-latex"), T(".latex") },
+    { T("application/x-mif"), T(".mif") },
+    { T("application/x-netcdf"), T(".nc") },
+    { T("application/x-netcdf"), T(".cdf") },
+    { T("application/x-ns-proxy-autoconfig"), T(".pac") },
+    { T("application/x-patch"), T(".patch") },
+    { T("application/x-sh"), T(".sh") },
+    { T("application/x-shar"), T(".shar") },
+    { T("application/x-sv4cpio"), T(".sv4cpio") },
+    { T("application/x-sv4crc"), T(".sv4crc") },
+    { T("application/x-tar"), T(".tar") },
+    { T("application/x-tgz"), T(".tgz") },
+    { T("application/x-tcl"), T(".tcl") },
+    { T("application/x-tex"), T(".tex") },
+    { T("application/x-texinfo"), T(".texinfo") },
+    { T("application/x-texinfo"), T(".texi") },
+    { T("application/x-troff"), T(".t") },
+    { T("application/x-troff"), T(".tr") },
+    { T("application/x-troff"), T(".roff") },
+    { T("application/x-troff-man"), T(".man") },
+    { T("application/x-troff-me"), T(".me") },
+    { T("application/x-troff-ms"), T(".ms") },
+    { T("application/x-ustar"), T(".ustar") },
+    { T("application/x-wais-source"), T(".src") },
+    { T("application/zip"), T(".zip") },
+    { T("audio/basic"), T(".au snd") },
+    { T("audio/x-aiff"), T(".aif") },
+    { T("audio/x-aiff"), T(".aiff") },
+    { T("audio/x-aiff"), T(".aifc") },
+    { T("audio/x-wav"), T(".wav") },
+    { T("audio/x-wav"), T(".ram") },
+    { T("image/ief"), T(".ief") },
+    { T("image/jpeg"), T(".jpeg") },
+    { T("image/jpeg"), T(".jpe") },
+    { T("image/tiff"), T(".tiff") },
+    { T("image/tiff"), T(".tif") },
+    { T("image/x-cmu-raster"), T(".ras") },
+    { T("image/x-portable-anymap"), T(".pnm") },
+    { T("image/x-portable-bitmap"), T(".pbm") },
+    { T("image/x-portable-graymap"), T(".pgm") },
+    { T("image/x-portable-pixmap"), T(".ppm") },
+    { T("image/x-rgb"), T(".rgb") },
+    { T("image/x-xbitmap"), T(".xbm") },
+    { T("image/x-xpixmap"), T(".xpm") },
+    { T("image/x-xwindowdump"), T(".xwd") },
+    { T("text/html"), T(".cfm") },
+    { T("text/html"), T(".shtm") },
+    { T("text/html"), T(".shtml") },
+    { T("text/richtext"), T(".rtx") },
+    { T("text/tab-separated-values"), T(".tsv") },
+    { T("text/x-setext"), T(".etx") },
+    { T("video/mpeg"), T(".mpeg mpg mpe") },
+    { T("video/quicktime"), T(".qt") },
+    { T("video/quicktime"), T(".mov") },
+    { T("video/x-msvideo"), T(".avi") },
+    { T("video/x-sgi-movie"), T(".movie") },
 #endif
-	{ NULL, NULL},
+    { NULL, NULL},
 };
 
 
diff --git a/mime64.c b/mime64.c
index 686b3ec7..29e8c847 100644
--- a/mime64.c
+++ b/mime64.c
@@ -6,79 +6,79 @@
 
 /********************************* Includes ***********************************/
 
-#include	"wsIntrn.h"
+#include    "wsIntrn.h"
 
 /******************************** Local Data **********************************/
 /*
-  	Mapping of ANSI chars to base64 Mime encoding alphabet (see below)
+    Mapping of ANSI chars to base64 Mime encoding alphabet (see below)
  */
 
-static char_t	map64[] = {
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
-	52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,
-	-1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
+static char_t   map64[] = {
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
+    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,
+    -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
     15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, 
-	-1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
+    -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
     41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 };
 
 /*********************************** Code *************************************/
 /*
-  	Decode a buffer from "string" and into "outbuf"
+    Decode a buffer from "string" and into "outbuf"
  */
 int websDecode64(char_t *outbuf, char_t *string, int outlen)
 {
-	unsigned long	shiftbuf;
-	char_t			*cp, *op;
-	int				c, i, j, shift;
+    unsigned long   shiftbuf;
+    char_t          *cp, *op;
+    int             c, i, j, shift;
 
-	op = outbuf;
-	*op = '\0';
-	cp = string;
-	while (*cp && *cp != '=') {
+    op = outbuf;
+    *op = '\0';
+    cp = string;
+    while (*cp && *cp != '=') {
         /*
             Map 4 (6bit) input bytes and store in a single long (shiftbuf)
          */
-		shiftbuf = 0;
-		shift = 18;
-		for (i = 0; i < 4 && *cp && *cp != '='; i++, cp++) {
-			c = map64[*cp & 0xff];
-			if (c == -1) {
-				error(E_L, E_LOG, T("Bad string: %s at %c index %d"), string,
-					c, i);
-				return -1;
-			} 
-			shiftbuf = shiftbuf | (c << shift);
-			shift -= 6;
-		}
+        shiftbuf = 0;
+        shift = 18;
+        for (i = 0; i < 4 && *cp && *cp != '='; i++, cp++) {
+            c = map64[*cp & 0xff];
+            if (c == -1) {
+                error(E_L, E_LOG, T("Bad string: %s at %c index %d"), string,
+                    c, i);
+                return -1;
+            } 
+            shiftbuf = shiftbuf | (c << shift);
+            shift -= 6;
+        }
         /*
             Interpret as 3 normal 8 bit bytes (fill in reverse order). Check for potential buffer overflow before filling.
          */
-		--i;
-		if ((op + i) >= &outbuf[outlen]) {
-			gstrcpy(outbuf, T("String too big"));
-			return -1;
-		}
-		for (j = 0; j < i; j++) {
-			*op++ = (char_t) ((shiftbuf >> (8 * (2 - j))) & 0xff);
-		}
-		*op = '\0';
-	}
-	return 0;
+        --i;
+        if ((op + i) >= &outbuf[outlen]) {
+            gstrcpy(outbuf, T("String too big"));
+            return -1;
+        }
+        for (j = 0; j < i; j++) {
+            *op++ = (char_t) ((shiftbuf >> (8 * (2 - j))) & 0xff);
+        }
+        *op = '\0';
+    }
+    return 0;
 }
 
 
diff --git a/misc.c b/misc.c
index 252acf7f..3013bfb2 100644
--- a/misc.c
+++ b/misc.c
@@ -6,49 +6,49 @@
 
 /********************************* Includes ***********************************/
 
-#include	"uemf.h"
+#include    "uemf.h"
 
 //  MOB - remove and use this only
 #define kUseMemcopy
 
 /********************************* Defines ************************************/
 /*
-  	Sprintf buffer structure. Make the increment 64 so that a balloc can use a 64 byte block.
+    Sprintf buffer structure. Make the increment 64 so that a balloc can use a 64 byte block.
  */
 
-#define STR_REALLOC		0x1				/* Reallocate the buffer as required */
-#define STR_INC			64				/* Growth increment */
+#define STR_REALLOC     0x1             /* Reallocate the buffer as required */
+#define STR_INC         64              /* Growth increment */
 
 typedef struct {
-	char_t	*s;							/* Pointer to buffer */
-	int		size;						/* Current buffer size */
-	int		max;						/* Maximum buffer size */
-	int		count;						/* Buffer count */
-	int		flags;						/* Allocation flags */
+    char_t  *s;                         /* Pointer to buffer */
+    int     size;                       /* Current buffer size */
+    int     max;                        /* Maximum buffer size */
+    int     count;                      /* Buffer count */
+    int     flags;                      /* Allocation flags */
 } strbuf_t;
 
 /*
-  	Sprintf formatting flags
+    Sprintf formatting flags
  */
 enum flag {
-	flag_none = 0,
-	flag_minus = 1,
-	flag_plus = 2,
-	flag_space = 4,
-	flag_hash = 8,
-	flag_zero = 16,
-	flag_short = 32,
-	flag_long = 64
+    flag_none = 0,
+    flag_minus = 1,
+    flag_plus = 2,
+    flag_space = 4,
+    flag_hash = 8,
+    flag_zero = 16,
+    flag_short = 32,
+    flag_long = 64
 };
 
 /************************** Forward Declarations ******************************/
 
-static int 	dsnprintf(char_t **s, int size, char_t *fmt, va_list arg, int msize);
-static void	put_char(strbuf_t *buf, char_t c);
-static void	put_string(strbuf_t *buf, char_t *s, int len, int width, int prec, enum flag f);
-static void	put_ulong(strbuf_t *buf, unsigned long int value, int base, int upper, char_t *prefix, int width, 
+static int  dsnprintf(char_t **s, int size, char_t *fmt, va_list arg, int msize);
+static void put_char(strbuf_t *buf, char_t c);
+static void put_string(strbuf_t *buf, char_t *s, int len, int width, int prec, enum flag f);
+static void put_ulong(strbuf_t *buf, unsigned long int value, int base, int upper, char_t *prefix, int width, 
         int prec, enum flag f);
-static int	gstrnlen(char_t *s, unsigned int n);
+static int  gstrnlen(char_t *s, unsigned int n);
 
 /************************************ Code ************************************/
 /*
@@ -60,61 +60,61 @@ static int	gstrnlen(char_t *s, unsigned int n);
 #if (!defined (LINUX) && !defined (LYNX) && !defined (MACOSX))
 char_t *basename(char_t *name)
 {
-	char_t	*cp;
+    char_t  *cp;
 
 #if (defined (NW) || defined (WIN))
-	if (((cp = gstrrchr(name, '\\')) == NULL) && ((cp = gstrrchr(name, '/')) == NULL)) {
-		return name;
+    if (((cp = gstrrchr(name, '\\')) == NULL) && ((cp = gstrrchr(name, '/')) == NULL)) {
+        return name;
 #else
-	if ((cp = gstrrchr(name, '/')) == NULL) {
-		return name;
+    if ((cp = gstrrchr(name, '/')) == NULL) {
+        return name;
 #endif
-	} else if (*(cp + 1) == '\0' && cp == name) {
-		return name;
-	} else if (*(cp + 1) == '\0' && cp != name) {
-		return T("");
-	} else {
-		return ++cp;
-	}
+    } else if (*(cp + 1) == '\0' && cp == name) {
+        return name;
+    } else if (*(cp + 1) == '\0' && cp != name) {
+        return T("");
+    } else {
+        return ++cp;
+    }
 }
 #endif /* ! LINUX & ! LYNX & ! MACOSX */
 
 /******************************************************************************/
 /*
-  	Returns a pointer to the directory component of a pathname. bufsize is the size of the buffer in BYTES!
+    Returns a pointer to the directory component of a pathname. bufsize is the size of the buffer in BYTES!
  */
 char_t *dirname(char_t *buf, char_t *name, int bufsize)
 {
-	char_t *cp;
-	int		len;
+    char_t *cp;
+    int     len;
 
-	a_assert(name);
-	a_assert(buf);
-	a_assert(bufsize > 0);
+    a_assert(name);
+    a_assert(buf);
+    a_assert(bufsize > 0);
 
 #if (defined (WIN) || defined (NW))
-	if ((cp = gstrrchr(name, '/')) == NULL && (cp = gstrrchr(name, '\\')) == NULL)
+    if ((cp = gstrrchr(name, '/')) == NULL && (cp = gstrrchr(name, '\\')) == NULL)
 #else
-	if ((cp = gstrrchr(name, '/')) == NULL)
+    if ((cp = gstrrchr(name, '/')) == NULL)
 #endif
-	{
-		gstrcpy(buf, T("."));
-		return buf;
-	}
-	if ((*(cp + 1) == '\0' && cp == name)) {
-		gstrncpy(buf, T("."), TSZ(bufsize));
-		gstrcpy(buf, T("."));
-		return buf;
-	}
-	len = cp - name;
-	if (len < bufsize) {
-		gstrncpy(buf, name, len);
-		buf[len] = '\0';
-	} else {
-		gstrncpy(buf, name, TSZ(bufsize));
-		buf[bufsize - 1] = '\0';
-	}
-	return buf;
+    {
+        gstrcpy(buf, T("."));
+        return buf;
+    }
+    if ((*(cp + 1) == '\0' && cp == name)) {
+        gstrncpy(buf, T("."), TSZ(bufsize));
+        gstrcpy(buf, T("."));
+        return buf;
+    }
+    len = cp - name;
+    if (len < bufsize) {
+        gstrncpy(buf, name, len);
+        buf[len] = '\0';
+    } else {
+        gstrncpy(buf, name, TSZ(bufsize));
+        buf[bufsize - 1] = '\0';
+    }
+    return buf;
 }
 
 
@@ -124,39 +124,39 @@ char_t *dirname(char_t *buf, char_t *name, int bufsize)
  */
 int fmtAlloc(char_t **s, int n, char_t *fmt, ...)
 {
-	va_list	ap;
-	int		result;
+    va_list ap;
+    int     result;
 
-	a_assert(s);
-	a_assert(fmt);
+    a_assert(s);
+    a_assert(fmt);
 
-	*s = NULL;
-	va_start(ap, fmt);
-	result = dsnprintf(s, n, fmt, ap, 0);
-	va_end(ap);
-	return result;
+    *s = NULL;
+    va_start(ap, fmt);
+    result = dsnprintf(s, n, fmt, ap, 0);
+    va_end(ap);
+    return result;
 }
 
 
 /*
-  	Support a static buffer version for small buffers only!
+    Support a static buffer version for small buffers only!
  */
 int fmtStatic(char_t *s, int n, char_t *fmt, ...)
 {
-	va_list	ap;
-	int		result;
-
-	a_assert(s);
-	a_assert(fmt);
-	a_assert(n <= 256);
-
-	if (n <= 0) {
-		return -1;
-	}
-	va_start(ap, fmt);
-	result = dsnprintf(&s, n, fmt, ap, 0);
-	va_end(ap);
-	return result;
+    va_list ap;
+    int     result;
+
+    a_assert(s);
+    a_assert(fmt);
+    a_assert(n <= 256);
+
+    if (n <= 0) {
+        return -1;
+    }
+    va_start(ap, fmt);
+    result = dsnprintf(&s, n, fmt, ap, 0);
+    va_end(ap);
+    return result;
 }
 
 
@@ -165,32 +165,32 @@ int fmtStatic(char_t *s, int n, char_t *fmt, ...)
  */
 int fmtRealloc(char_t **s, int n, int msize, char_t *fmt, ...)
 {
-	va_list	ap;
-	int		result;
-
-	a_assert(s);
-	a_assert(fmt);
-
-	if (msize == -1) {
-		*s = NULL;
-	}
-	va_start(ap, fmt);
-	result = dsnprintf(s, n, fmt, ap, msize);
-	va_end(ap);
-	return result;
+    va_list ap;
+    int     result;
+
+    a_assert(s);
+    a_assert(fmt);
+
+    if (msize == -1) {
+        *s = NULL;
+    }
+    va_start(ap, fmt);
+    result = dsnprintf(s, n, fmt, ap, msize);
+    va_end(ap);
+    return result;
 }
 
 
 /*
-  	A vsprintf replacement.
+    A vsprintf replacement.
  */
 int fmtValloc(char_t **s, int n, char_t *fmt, va_list arg)
 {
-	a_assert(s);
-	a_assert(fmt);
+    a_assert(s);
+    a_assert(fmt);
 
-	*s = NULL;
-	return dsnprintf(s, n, fmt, arg, 0);
+    *s = NULL;
+    return dsnprintf(s, n, fmt, arg, 0);
 }
 
 
@@ -202,303 +202,303 @@ int fmtValloc(char_t **s, int n, char_t *fmt, va_list arg)
  */
 static int dsnprintf(char_t **s, int size, char_t *fmt, va_list arg, int msize)
 {
-	strbuf_t	buf;
-	char_t		c;
-
-	a_assert(s);
-	a_assert(fmt);
-
-	memset(&buf, 0, sizeof(buf));
-	buf.s = *s;
-
-	if (*s == NULL || msize != 0) {
-		buf.max = size;
-		buf.flags |= STR_REALLOC;
-		if (msize != 0) {
-			buf.size = max(msize, 0);
-		}
-		if (*s != NULL && msize != 0) {
-			buf.count = gstrlen(*s);
-		}
-	} else {
-		buf.size = size;
-	}
-	while ((c = *fmt++) != '\0') {
-		if (c != '%' || (c = *fmt++) == '%') {
-			put_char(&buf, c);
-		} else {
-			enum flag f = flag_none;
-			int width = 0;
-			int prec = -1;
-			for ( ; c != '\0'; c = *fmt++) {
-				if (c == '-') { 
-					f |= flag_minus; 
-				} else if (c == '+') { 
-					f |= flag_plus; 
-				} else if (c == ' ') { 
-					f |= flag_space; 
-				} else if (c == '#') { 
-					f |= flag_hash; 
-				} else if (c == '0') { 
-					f |= flag_zero; 
-				} else {
-					break;
-				}
-			}
-			if (c == '*') {
-				width = va_arg(arg, int);
-				if (width < 0) {
-					f |= flag_minus;
-					width = -width;
-				}
-				c = *fmt++;
-			} else {
-				for ( ; gisdigit((int)c); c = *fmt++) {
-					width = width * 10 + (c - '0');
-				}
-			}
-			if (c == '.') {
-				f &= ~flag_zero;
-				c = *fmt++;
-				if (c == '*') {
-					prec = va_arg(arg, int);
-					c = *fmt++;
-				} else {
-					for (prec = 0; gisdigit((int)c); c = *fmt++) {
-						prec = prec * 10 + (c - '0');
-					}
-				}
-			}
-			if (c == 'h' || c == 'l') {
-				f |= (c == 'h' ? flag_short : flag_long);
-				c = *fmt++;
-			}
-			if (c == 'd' || c == 'i') {
-				long int value;
-				if (f & flag_short) {
-					value = (short int) va_arg(arg, int);
-				} else if (f & flag_long) {
-					value = va_arg(arg, long int);
-				} else {
-					value = va_arg(arg, int);
-				}
-				if (value >= 0) {
-					if (f & flag_plus) {
-						put_ulong(&buf, value, 10, 0, T("+"), width, prec, f);
-					} else if (f & flag_space) {
-						put_ulong(&buf, value, 10, 0, T(" "), width, prec, f);
-					} else {
-						put_ulong(&buf, value, 10, 0, NULL, width, prec, f);
-					}
-				} else {
-					put_ulong(&buf, -value, 10, 0, T("-"), width, prec, f);
-				}
-			} else if (c == 'o' || c == 'u' || c == 'x' || c == 'X') {
-				unsigned long int value;
-				if (f & flag_short) {
-					value = (unsigned short int) va_arg(arg, unsigned int);
-				} else if (f & flag_long) {
-					value = va_arg(arg, unsigned long int);
-				} else {
-					value = va_arg(arg, unsigned int);
-				}
-				if (c == 'o') {
-					if (f & flag_hash && value != 0) {
-						put_ulong(&buf, value, 8, 0, T("0"), width, prec, f);
-					} else {
-						put_ulong(&buf, value, 8, 0, NULL, width, prec, f);
-					}
-				} else if (c == 'u') {
-					put_ulong(&buf, value, 10, 0, NULL, width, prec, f);
-				} else {
-					if (f & flag_hash && value != 0) {
-						if (c == 'x') {
-							put_ulong(&buf, value, 16, 0, T("0x"), width, 
-								prec, f);
-						} else {
-							put_ulong(&buf, value, 16, 1, T("0X"), width, 
-								prec, f);
-						}
-					} else {
-						put_ulong(&buf, value, 16, ('X' == c) , NULL, width, prec, f);
-					}
-				}
-
-			} else if (c == 'c') {
-				char_t value = va_arg(arg, int);
-				put_char(&buf, value);
-
-			} else if (c == 's' || c == 'S') {
-				char_t *value = va_arg(arg, char_t *);
-				if (value == NULL) {
-					put_string(&buf, T("(null)"), -1, width, prec, f);
-				} else if (f & flag_hash) {
-					put_string(&buf,
-						value + 1, (char_t) *value, width, prec, f);
-				} else {
-					put_string(&buf, value, -1, width, prec, f);
-				}
-			} else if (c == 'p') {
-				void *value = va_arg(arg, void *);
-				put_ulong(&buf,
-					(unsigned long int) value, 16, 0, T("0x"), width, prec, f);
-			} else if (c == 'n') {
-				if (f & flag_short) {
-					short int *value = va_arg(arg, short int *);
-					*value = buf.count;
-				} else if (f & flag_long) {
-					long int *value = va_arg(arg, long int *);
-					*value = buf.count;
-				} else {
-					int *value = va_arg(arg, int *);
-					*value = buf.count;
-				}
-			} else {
-				put_char(&buf, c);
-			}
-		}
-	}
-	if (buf.s == NULL) {
-		put_char(&buf, '\0');
-	}
+    strbuf_t    buf;
+    char_t      c;
+
+    a_assert(s);
+    a_assert(fmt);
+
+    memset(&buf, 0, sizeof(buf));
+    buf.s = *s;
+
+    if (*s == NULL || msize != 0) {
+        buf.max = size;
+        buf.flags |= STR_REALLOC;
+        if (msize != 0) {
+            buf.size = max(msize, 0);
+        }
+        if (*s != NULL && msize != 0) {
+            buf.count = gstrlen(*s);
+        }
+    } else {
+        buf.size = size;
+    }
+    while ((c = *fmt++) != '\0') {
+        if (c != '%' || (c = *fmt++) == '%') {
+            put_char(&buf, c);
+        } else {
+            enum flag f = flag_none;
+            int width = 0;
+            int prec = -1;
+            for ( ; c != '\0'; c = *fmt++) {
+                if (c == '-') { 
+                    f |= flag_minus; 
+                } else if (c == '+') { 
+                    f |= flag_plus; 
+                } else if (c == ' ') { 
+                    f |= flag_space; 
+                } else if (c == '#') { 
+                    f |= flag_hash; 
+                } else if (c == '0') { 
+                    f |= flag_zero; 
+                } else {
+                    break;
+                }
+            }
+            if (c == '*') {
+                width = va_arg(arg, int);
+                if (width < 0) {
+                    f |= flag_minus;
+                    width = -width;
+                }
+                c = *fmt++;
+            } else {
+                for ( ; gisdigit((int)c); c = *fmt++) {
+                    width = width * 10 + (c - '0');
+                }
+            }
+            if (c == '.') {
+                f &= ~flag_zero;
+                c = *fmt++;
+                if (c == '*') {
+                    prec = va_arg(arg, int);
+                    c = *fmt++;
+                } else {
+                    for (prec = 0; gisdigit((int)c); c = *fmt++) {
+                        prec = prec * 10 + (c - '0');
+                    }
+                }
+            }
+            if (c == 'h' || c == 'l') {
+                f |= (c == 'h' ? flag_short : flag_long);
+                c = *fmt++;
+            }
+            if (c == 'd' || c == 'i') {
+                long int value;
+                if (f & flag_short) {
+                    value = (short int) va_arg(arg, int);
+                } else if (f & flag_long) {
+                    value = va_arg(arg, long int);
+                } else {
+                    value = va_arg(arg, int);
+                }
+                if (value >= 0) {
+                    if (f & flag_plus) {
+                        put_ulong(&buf, value, 10, 0, T("+"), width, prec, f);
+                    } else if (f & flag_space) {
+                        put_ulong(&buf, value, 10, 0, T(" "), width, prec, f);
+                    } else {
+                        put_ulong(&buf, value, 10, 0, NULL, width, prec, f);
+                    }
+                } else {
+                    put_ulong(&buf, -value, 10, 0, T("-"), width, prec, f);
+                }
+            } else if (c == 'o' || c == 'u' || c == 'x' || c == 'X') {
+                unsigned long int value;
+                if (f & flag_short) {
+                    value = (unsigned short int) va_arg(arg, unsigned int);
+                } else if (f & flag_long) {
+                    value = va_arg(arg, unsigned long int);
+                } else {
+                    value = va_arg(arg, unsigned int);
+                }
+                if (c == 'o') {
+                    if (f & flag_hash && value != 0) {
+                        put_ulong(&buf, value, 8, 0, T("0"), width, prec, f);
+                    } else {
+                        put_ulong(&buf, value, 8, 0, NULL, width, prec, f);
+                    }
+                } else if (c == 'u') {
+                    put_ulong(&buf, value, 10, 0, NULL, width, prec, f);
+                } else {
+                    if (f & flag_hash && value != 0) {
+                        if (c == 'x') {
+                            put_ulong(&buf, value, 16, 0, T("0x"), width, 
+                                prec, f);
+                        } else {
+                            put_ulong(&buf, value, 16, 1, T("0X"), width, 
+                                prec, f);
+                        }
+                    } else {
+                        put_ulong(&buf, value, 16, ('X' == c) , NULL, width, prec, f);
+                    }
+                }
+
+            } else if (c == 'c') {
+                char_t value = va_arg(arg, int);
+                put_char(&buf, value);
+
+            } else if (c == 's' || c == 'S') {
+                char_t *value = va_arg(arg, char_t *);
+                if (value == NULL) {
+                    put_string(&buf, T("(null)"), -1, width, prec, f);
+                } else if (f & flag_hash) {
+                    put_string(&buf,
+                        value + 1, (char_t) *value, width, prec, f);
+                } else {
+                    put_string(&buf, value, -1, width, prec, f);
+                }
+            } else if (c == 'p') {
+                void *value = va_arg(arg, void *);
+                put_ulong(&buf,
+                    (unsigned long int) value, 16, 0, T("0x"), width, prec, f);
+            } else if (c == 'n') {
+                if (f & flag_short) {
+                    short int *value = va_arg(arg, short int *);
+                    *value = buf.count;
+                } else if (f & flag_long) {
+                    long int *value = va_arg(arg, long int *);
+                    *value = buf.count;
+                } else {
+                    int *value = va_arg(arg, int *);
+                    *value = buf.count;
+                }
+            } else {
+                put_char(&buf, c);
+            }
+        }
+    }
+    if (buf.s == NULL) {
+        put_char(&buf, '\0');
+    }
     /*
-      	If the user requested a dynamic buffer (*s == NULL), ensure it is returned.
+        If the user requested a dynamic buffer (*s == NULL), ensure it is returned.
      */
-	if (*s == NULL || msize != 0) {
-		*s = buf.s;
-	}
-	if (*s != NULL && size > 0) {
-		if (buf.count < size) {
-			(*s)[buf.count] = '\0';
-		} else {
-			(*s)[buf.size - 1] = '\0';
-		}
-	}
-
-	if (msize != 0) {
-		return buf.size;
-	}
-	return buf.count;
+    if (*s == NULL || msize != 0) {
+        *s = buf.s;
+    }
+    if (*s != NULL && size > 0) {
+        if (buf.count < size) {
+            (*s)[buf.count] = '\0';
+        } else {
+            (*s)[buf.size - 1] = '\0';
+        }
+    }
+
+    if (msize != 0) {
+        return buf.size;
+    }
+    return buf.count;
 }
 
 
 /*
-  	Return the length of a string limited by a given length
+    Return the length of a string limited by a given length
  */
 static int gstrnlen(char_t *s, unsigned int n)
 {
-	unsigned int 	len;
+    unsigned int    len;
 
-	len = gstrlen(s);
-	return min(len, n);
+    len = gstrlen(s);
+    return min(len, n);
 }
 
 
 /*
-  	Add a character to a string buffer
+    Add a character to a string buffer
  */
 static void put_char(strbuf_t *buf, char_t c)
 {
-	if (buf->count >= (buf->size - 1)) {
-		if (! (buf->flags & STR_REALLOC)) {
-			return;
-		}
-		buf->size += STR_INC;
-		if (buf->size > buf->max && buf->size > STR_INC) {
+    if (buf->count >= (buf->size - 1)) {
+        if (! (buf->flags & STR_REALLOC)) {
+            return;
+        }
+        buf->size += STR_INC;
+        if (buf->size > buf->max && buf->size > STR_INC) {
             /*
                 Caller should increase the size of the calling buffer
              */
-			buf->size -= STR_INC;
-			return;
-		}
-		if (buf->s == NULL) {
-			buf->s = balloc(B_L, buf->size * sizeof(char_t));
-		} else {
-			buf->s = brealloc(B_L, buf->s, buf->size * sizeof(char_t));
-		}
-	}
-	buf->s[buf->count] = c;
-	if (c != '\0') {
-		++buf->count;
-	}
+            buf->size -= STR_INC;
+            return;
+        }
+        if (buf->s == NULL) {
+            buf->s = balloc(B_L, buf->size * sizeof(char_t));
+        } else {
+            buf->s = brealloc(B_L, buf->s, buf->size * sizeof(char_t));
+        }
+    }
+    buf->s[buf->count] = c;
+    if (c != '\0') {
+        ++buf->count;
+    }
 }
 
 
 /*
-  	Add a string to a string buffer
+    Add a string to a string buffer
  */
 static void put_string(strbuf_t *buf, char_t *s, int len, int width, int prec, enum flag f)
 {
-	int		i;
-
-	if (len < 0) { 
-		len = gstrnlen(s, prec >= 0 ? prec : ULONG_MAX); 
-	} else if (prec >= 0 && prec < len) { 
-		len = prec; 
-	}
-	if (width > len && !(f & flag_minus)) {
-		for (i = len; i < width; ++i) { 
-			put_char(buf, ' '); 
-		}
-	}
-	for (i = 0; i < len; ++i) { 
-		put_char(buf, s[i]); 
-	}
-	if (width > len && f & flag_minus) {
-		for (i = len; i < width; ++i) { 
-			put_char(buf, ' '); 
-		}
-	}
+    int     i;
+
+    if (len < 0) { 
+        len = gstrnlen(s, prec >= 0 ? prec : ULONG_MAX); 
+    } else if (prec >= 0 && prec < len) { 
+        len = prec; 
+    }
+    if (width > len && !(f & flag_minus)) {
+        for (i = len; i < width; ++i) { 
+            put_char(buf, ' '); 
+        }
+    }
+    for (i = 0; i < len; ++i) { 
+        put_char(buf, s[i]); 
+    }
+    if (width > len && f & flag_minus) {
+        for (i = len; i < width; ++i) { 
+            put_char(buf, ' '); 
+        }
+    }
 }
 
 
 /*
-  	Add a long to a string buffer
+    Add a long to a string buffer
  */
 static void put_ulong(strbuf_t *buf, unsigned long int value, int base, int upper, char_t *prefix, int width, int prec,
         enum flag f) 
 {
-	unsigned long	x, x2;
-	int				len, zeros, i;
-
-	for (len = 1, x = 1; x < ULONG_MAX / base; ++len, x = x2) {
-		x2 = x * base;
-		if (x2 > value) { 
-			break; 
-		}
-	}
-	zeros = (prec > len) ? prec - len : 0;
-	width -= zeros + len;
-	if (prefix != NULL) { 
-		width -= gstrnlen(prefix, ULONG_MAX); 
-	}
-	if (!(f & flag_minus)) {
-		if (f & flag_zero) {
-			for (i = 0; i < width; ++i) { 
-				put_char(buf, '0'); 
-			}
-		} else {
-			for (i = 0; i < width; ++i) { 
-				put_char(buf, ' '); 
-			}
-		}
-	}
-	if (prefix != NULL) { 
-		put_string(buf, prefix, -1, 0, -1, flag_none); 
-	}
-	for (i = 0; i < zeros; ++i) { 
-		put_char(buf, '0'); 
-	}
-	for ( ; x > 0; x /= base) {
-		int digit = (value / x) % base;
-		put_char(buf, (char) ((digit < 10 ? '0' : (upper ? 'A' : 'a') - 10) +
-			digit));
-	}
-	if (f & flag_minus) {
-		for (i = 0; i < width; ++i) { 
-			put_char(buf, ' '); 
-		}
-	}
+    unsigned long   x, x2;
+    int             len, zeros, i;
+
+    for (len = 1, x = 1; x < ULONG_MAX / base; ++len, x = x2) {
+        x2 = x * base;
+        if (x2 > value) { 
+            break; 
+        }
+    }
+    zeros = (prec > len) ? prec - len : 0;
+    width -= zeros + len;
+    if (prefix != NULL) { 
+        width -= gstrnlen(prefix, ULONG_MAX); 
+    }
+    if (!(f & flag_minus)) {
+        if (f & flag_zero) {
+            for (i = 0; i < width; ++i) { 
+                put_char(buf, '0'); 
+            }
+        } else {
+            for (i = 0; i < width; ++i) { 
+                put_char(buf, ' '); 
+            }
+        }
+    }
+    if (prefix != NULL) { 
+        put_string(buf, prefix, -1, 0, -1, flag_none); 
+    }
+    for (i = 0; i < zeros; ++i) { 
+        put_char(buf, '0'); 
+    }
+    for ( ; x > 0; x /= base) {
+        int digit = (value / x) % base;
+        put_char(buf, (char) ((digit < 10 ? '0' : (upper ? 'A' : 'a') - 10) +
+            digit));
+    }
+    if (f & flag_minus) {
+        for (i = 0; i < width; ++i) { 
+            put_char(buf, ' '); 
+        }
+    }
 }
 
 
@@ -509,18 +509,18 @@ static void put_ulong(strbuf_t *buf, unsigned long int value, int base, int uppe
 char_t *ascToUni(char_t *ubuf, char *str, int nBytes)
 {
 #ifdef UNICODE
-	if (MultiByteToWideChar(CP_ACP, 0, str, nBytes / sizeof(char_t), ubuf, nBytes / sizeof(char_t)) < 0) {
-		return (char_t*) str;
-	}
+    if (MultiByteToWideChar(CP_ACP, 0, str, nBytes / sizeof(char_t), ubuf, nBytes / sizeof(char_t)) < 0) {
+        return (char_t*) str;
+    }
 #else
 
 #ifdef kUseMemcopy
    memcpy(ubuf, str, nBytes);
 #else
-	strncpy(ubuf, str, nBytes);
+    strncpy(ubuf, str, nBytes);
 #endif /*kUseMemcopy*/
 #endif
-	return ubuf;
+    return ubuf;
 }
 
 
@@ -554,16 +554,16 @@ char *uniToAsc(char *buf, char_t *ustr, int nBytes)
  */
 char_t *ballocAscToUni(char *cp, int alen)
 {
-	char_t *unip;
-	int ulen;
-
-	ulen = (alen + 1) * sizeof(char_t);
-	if ((unip = balloc(B_L, ulen)) == NULL) {
-		return NULL;
-	}
-	ascToUni(unip, cp, ulen);
-	unip[alen] = 0;
-	return unip;
+    char_t *unip;
+    int ulen;
+
+    ulen = (alen + 1) * sizeof(char_t);
+    if ((unip = balloc(B_L, ulen)) == NULL) {
+        return NULL;
+    }
+    ascToUni(unip, cp, ulen);
+    unip[alen] = 0;
+    return unip;
 }
 
 
@@ -574,14 +574,14 @@ char_t *ballocAscToUni(char *cp, int alen)
  */
 char *ballocUniToAsc(char_t *unip, int ulen)
 {
-	char * cp;
-
-	if ((cp = balloc(B_L, ulen+1)) == NULL) {
-		return NULL;
-	}
-	uniToAsc(cp, unip, ulen);
-	cp[ulen] = '\0';
-	return cp;
+    char * cp;
+
+    if ((cp = balloc(B_L, ulen+1)) == NULL) {
+        return NULL;
+    }
+    uniToAsc(cp, unip, ulen);
+    cp[ulen] = '\0';
+    return cp;
 }
 
 
@@ -591,27 +591,27 @@ char *ballocUniToAsc(char_t *unip, int ulen)
  */
 unsigned int hextoi(char_t *hexstring)
 {
-	register char_t			*h;
-	register unsigned int	c, v;
-
-	v = 0;
-	h = hexstring;
-	if (*h == '0' && (*(h+1) == 'x' || *(h+1) == 'X')) {
-		h += 2;
-	}
-	while ((c = (unsigned int)*h++) != 0) {
-		if (c >= '0' && c <= '9') {
-			c -= '0';
-		} else if (c >= 'a' && c <= 'f') {
-			c = (c - 'a') + 10;
-		} else if (c >=  'A' && c <= 'F') {
-			c = (c - 'A') + 10;
-		} else {
-			break;
-		}
-		v = (v * 0x10) + c;
-	}
-	return v;
+    register char_t         *h;
+    register unsigned int   c, v;
+
+    v = 0;
+    h = hexstring;
+    if (*h == '0' && (*(h+1) == 'x' || *(h+1) == 'X')) {
+        h += 2;
+    }
+    while ((c = (unsigned int)*h++) != 0) {
+        if (c >= '0' && c <= '9') {
+            c -= '0';
+        } else if (c >= 'a' && c <= 'f') {
+            c = (c - 'a') + 10;
+        } else if (c >=  'A' && c <= 'F') {
+            c = (c - 'A') + 10;
+        } else {
+            break;
+        }
+        v = (v * 0x10) + c;
+    }
+    return v;
 }
 
 
@@ -620,11 +620,11 @@ unsigned int hextoi(char_t *hexstring)
  */
 unsigned int gstrtoi(char_t *s)
 {
-	if (*s == '0' && (*(s+1) == 'x' || *(s+1) == 'X')) {
-		s += 2;
-		return hextoi(s);
-	}
-	return gatoi(s);
+    if (*s == '0' && (*(s+1) == 'x' || *(s+1) == 'X')) {
+        s += 2;
+        return hextoi(s);
+    }
+    return gatoi(s);
 }
 
 
diff --git a/page.c b/page.c
index 9072cbce..f3c11a34 100644
--- a/page.c
+++ b/page.c
@@ -9,63 +9,63 @@
 
 /********************************* Includes ***********************************/
 
-#include	"wsIntrn.h"
+#include    "wsIntrn.h"
 
 /*********************************** Code *************************************/
 /*
-  	Open a web page. lpath is the local filename. path is the URL path name.
+    Open a web page. lpath is the local filename. path is the URL path name.
  */
 int websPageOpen(webs_t wp, char_t *lpath, char_t *path, int mode, int perm)
 {
     //  MOB
 #if defined(WIN32)
-	errno_t	error;
+    errno_t error;
 #endif
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
 #ifdef WEBS_PAGE_ROM
-	return websRomPageOpen(wp, path, mode, perm);
+    return websRomPageOpen(wp, path, mode, perm);
 #elif defined(WIN32)
-	error = _sopen_s(&(wp->docfd), lpath, mode, _SH_DENYNO, _S_IREAD);
-	return (wp->docfd = gopen(lpath, mode, _S_IREAD));
+    error = _sopen_s(&(wp->docfd), lpath, mode, _SH_DENYNO, _S_IREAD);
+    return (wp->docfd = gopen(lpath, mode, _S_IREAD));
 #else
-	return (wp->docfd = gopen(lpath, mode, perm));
+    return (wp->docfd = gopen(lpath, mode, perm));
 #endif /* WEBS_PAGE_ROM */
 }
 
 
 void websPageClose(webs_t wp)
 {
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
 #ifdef WEBS_PAGE_ROM
-	websRomPageClose(wp->docfd);
+    websRomPageClose(wp->docfd);
 #else
-	if (wp->docfd >= 0) {
-		close(wp->docfd);
-		wp->docfd = -1;
-	}
+    if (wp->docfd >= 0) {
+        close(wp->docfd);
+        wp->docfd = -1;
+    }
 #endif
 }
 
 
 /*
-  	Stat a web page lpath is the local filename. path is the URL path name.
+    Stat a web page lpath is the local filename. path is the URL path name.
  */
 int websPageStat(webs_t wp, char_t *lpath, char_t *path, websStatType* sbuf)
 {
 #ifdef WEBS_PAGE_ROM
-	return websRomPageStat(path, sbuf);
+    return websRomPageStat(path, sbuf);
 #else
-	gstat_t	s;
-
-	if (gstat(lpath, &s) < 0) {
-		return -1;
-	}
-	sbuf->size = s.st_size;
-	sbuf->mtime = s.st_mtime;
-	sbuf->isDir = s.st_mode & S_IFDIR;
-	return 0;
+    gstat_t s;
+
+    if (gstat(lpath, &s) < 0) {
+        return -1;
+    }
+    sbuf->size = s.st_size;
+    sbuf->mtime = s.st_mtime;
+    sbuf->isDir = s.st_mode & S_IFDIR;
+    return 0;
 #endif
 }
 
@@ -73,53 +73,53 @@ int websPageStat(webs_t wp, char_t *lpath, char_t *path, websStatType* sbuf)
 int websPageIsDirectory(char_t *lpath)
 {
 #ifdef WEBS_PAGE_ROM
-	websStatType	sbuf;
+    websStatType    sbuf;
 
-	if (websRomPageStat(lpath, &sbuf) >= 0) {
-		return(sbuf.isDir);
-	} else {
-		return 0;
-	}
+    if (websRomPageStat(lpath, &sbuf) >= 0) {
+        return(sbuf.isDir);
+    } else {
+        return 0;
+    }
 #else
-	gstat_t sbuf;
+    gstat_t sbuf;
 
-	if (gstat(lpath, &sbuf) >= 0) {
-		return(sbuf.st_mode & S_IFDIR);
-	} else {
-		return 0;
-	}
+    if (gstat(lpath, &sbuf) >= 0) {
+        return(sbuf.st_mode & S_IFDIR);
+    } else {
+        return 0;
+    }
 #endif
 }
 
 
 
 /*
-  	Read a web page. Returns the number of _bytes_ read. len is the size of buf, in bytes.
+    Read a web page. Returns the number of _bytes_ read. len is the size of buf, in bytes.
  */
 int websPageReadData(webs_t wp, char *buf, int nBytes)
 {
 
 #ifdef WEBS_PAGE_ROM
-	a_assert(websValid(wp));
-	return websRomPageReadData(wp, buf, nBytes);
+    a_assert(websValid(wp));
+    return websRomPageReadData(wp, buf, nBytes);
 #else
-	a_assert(websValid(wp));
-	return read(wp->docfd, buf, nBytes);
+    a_assert(websValid(wp));
+    return read(wp->docfd, buf, nBytes);
 #endif
 }
 
 
 /*
-  	Move file pointer offset bytes.
+    Move file pointer offset bytes.
  */
 void websPageSeek(webs_t wp, long offset)
 {
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
 #ifdef WEBS_PAGE_ROM
-	websRomPageSeek(wp, offset, SEEK_CUR);
+    websRomPageSeek(wp, offset, SEEK_CUR);
 #else
-	lseek(wp->docfd, offset, SEEK_CUR);
+    lseek(wp->docfd, offset, SEEK_CUR);
 #endif
 }
 
diff --git a/ringq.c b/ringq.c
index 45e78866..9fe067b4 100644
--- a/ringq.c
+++ b/ringq.c
@@ -1,40 +1,40 @@
 /*
     ringq.c -- Ring queue buffering module
 
-  	A ring queue allows maximum utilization of memory for data storage and is
-  	ideal for input/output buffering.  This module provides a highly efficient
-  	implementation and a vehicle for dynamic strings.
+    A ring queue allows maximum utilization of memory for data storage and is
+    ideal for input/output buffering.  This module provides a highly efficient
+    implementation and a vehicle for dynamic strings.
   
-  	WARNING:  This is a public implementation and callers have full access to
-  	the queue structure and pointers.  Change this module very carefully.
+    WARNING:  This is a public implementation and callers have full access to
+    the queue structure and pointers.  Change this module very carefully.
   
-  	This module follows the open/close model.
+    This module follows the open/close model.
   
-  	Operation of a ringq where rq is a pointer to a ringq :
+    Operation of a ringq where rq is a pointer to a ringq :
   
-  		rq->buflen contains the size of the buffer.
-  		rq->buf will point to the start of the buffer.
-  		rq->servp will point to the first (un-consumed) data byte.
-  		rq->endp will point to the next free location to which new data is added
-  		rq->endbuf will point to one past the end of the buffer.
+        rq->buflen contains the size of the buffer.
+        rq->buf will point to the start of the buffer.
+        rq->servp will point to the first (un-consumed) data byte.
+        rq->endp will point to the next free location to which new data is added
+        rq->endbuf will point to one past the end of the buffer.
   
-  	Eg. If the ringq contains the data "abcdef", it might look like :
+    Eg. If the ringq contains the data "abcdef", it might look like :
   
-  	+-------------------------------------------------------------------+
+    +-------------------------------------------------------------------+
     |   |   |   |   |   |   |   | a | b | c | d | e | f |   |   |   |   |
-  	+-------------------------------------------------------------------+
+    +-------------------------------------------------------------------+
       ^                           ^                       ^               ^
       |                           |                       |               |
     rq->buf                    rq->servp               rq->endp      rq->enduf
        
-  	The queue is empty when servp == endp.  This means that the queue will hold
-  	at most rq->buflen -1 bytes.  It is the filler's responsibility to ensure
-  	the ringq is never filled such that servp == endp.
+    The queue is empty when servp == endp.  This means that the queue will hold
+    at most rq->buflen -1 bytes.  It is the filler's responsibility to ensure
+    the ringq is never filled such that servp == endp.
   
-  	It is the filler's responsibility to "wrap" the endp back to point to
-  	rq->buf when the pointer steps past the end.  Correspondingly it is the
-  	consumers responsibility to "wrap" the servp when it steps to rq->endbuf.
-  	The ringqPutc and ringqGetc routines will do this automatically.
+    It is the filler's responsibility to "wrap" the endp back to point to
+    rq->buf when the pointer steps past the end.  Correspondingly it is the
+    consumers responsibility to "wrap" the servp when it steps to rq->endbuf.
+    The ringqPutc and ringqGetc routines will do this automatically.
 
     Copyright (c) All Rights Reserved. See details at the end of the file.
  */
@@ -42,69 +42,69 @@
 
 /********************************* Includes ***********************************/
 
-#include	"uemf.h"
+#include    "uemf.h"
 
 /*********************************** Defines **********************************/
 /*
-  	Faster than a function call
+    Faster than a function call
  */
 
 #define RINGQ_LEN(rq) \
-	((rq->servp > rq->endp) ? \
-		(rq->buflen + (rq->endp - rq->servp)) : \
-		(rq->endp - rq->servp))
+    ((rq->servp > rq->endp) ? \
+        (rq->buflen + (rq->endp - rq->servp)) : \
+        (rq->endp - rq->servp))
 
 /***************************** Forward Declarations ***************************/
 
-static int	ringqGrow(ringq_t *rq);
-static int	getBinBlockSize(int size);
+static int  ringqGrow(ringq_t *rq);
+static int  getBinBlockSize(int size);
 
 //  MOB - static?
-int			ringqGrowCalls = 0;
+int         ringqGrowCalls = 0;
 
 /*********************************** Code *************************************/
 /*
     Create a new ringq. "increment" is the amount to increase the size of the ringq should it need to grow to accomodate
     data being added. "maxsize" is an upper limit (sanity level) beyond which the q must not grow. Set maxsize to -1 to
-    imply no upper limit. The buffer for the ringq is always *	dynamically allocated. Set maxsize
+    imply no upper limit. The buffer for the ringq is always *  dynamically allocated. Set maxsize
  */
 int ringqOpen(ringq_t *rq, int initSize, int maxsize)
 {
-	int	increment;
-
-	a_assert(rq);
-	a_assert(initSize >= 0);
-
-	increment = getBinBlockSize(initSize);
-	if ((rq->buf = balloc(B_L, (increment))) == NULL) {
-		return -1;
-	}
-	rq->maxsize = maxsize;
-	rq->buflen = increment;
-	rq->increment = increment;
-	rq->endbuf = &rq->buf[rq->buflen];
-	rq->servp = rq->buf;
-	rq->endp = rq->buf;
-	*rq->servp = '\0';
-	return 0;
+    int increment;
+
+    a_assert(rq);
+    a_assert(initSize >= 0);
+
+    increment = getBinBlockSize(initSize);
+    if ((rq->buf = balloc(B_L, (increment))) == NULL) {
+        return -1;
+    }
+    rq->maxsize = maxsize;
+    rq->buflen = increment;
+    rq->increment = increment;
+    rq->endbuf = &rq->buf[rq->buflen];
+    rq->servp = rq->buf;
+    rq->endp = rq->buf;
+    *rq->servp = '\0';
+    return 0;
 }
 
 
 /*
-  	Delete a ringq and free the ringq buffer.
+    Delete a ringq and free the ringq buffer.
  */
 void ringqClose(ringq_t *rq)
 {
-	a_assert(rq);
-	a_assert(rq->buflen == (rq->endbuf - rq->buf));
+    a_assert(rq);
+    a_assert(rq->buflen == (rq->endbuf - rq->buf));
 
-	if (rq == NULL) {
-		return;
-	}
+    if (rq == NULL) {
+        return;
+    }
 
-	ringqFlush(rq);
-	bfree(B_L, (char*) rq->buf);
-	rq->buf = NULL;
+    ringqFlush(rq);
+    bfree(B_L, (char*) rq->buf);
+    rq->buf = NULL;
 }
 
 
@@ -114,39 +114,39 @@ void ringqClose(ringq_t *rq)
  */
 int ringqLen(ringq_t *rq)
 {
-	a_assert(rq);
-	a_assert(rq->buflen == (rq->endbuf - rq->buf));
-
-	if (rq->servp > rq->endp) {
-		return rq->buflen + rq->endp - rq->servp;
-	} else {
-		return rq->endp - rq->servp;
-	}
+    a_assert(rq);
+    a_assert(rq->buflen == (rq->endbuf - rq->buf));
+
+    if (rq->servp > rq->endp) {
+        return rq->buflen + rq->endp - rq->servp;
+    } else {
+        return rq->endp - rq->servp;
+    }
 }
 
 
 /*
-  	Get a byte from the queue
+    Get a byte from the queue
  */
 int ringqGetc(ringq_t *rq)
 {
-	char_t	c;
-	char_t*	cp;
-
-	a_assert(rq);
-	a_assert(rq->buflen == (rq->endbuf - rq->buf));
-
-	if (rq->servp == rq->endp) {
-		return -1;
-	}
-
-	cp = (char_t*) rq->servp;
-	c = *cp++;
-	rq->servp = (unsigned char *) cp;
-	if (rq->servp >= rq->endbuf) {
-		rq->servp = rq->buf;
-	}
-	return (int) ((unsigned char) c);
+    char_t  c;
+    char_t* cp;
+
+    a_assert(rq);
+    a_assert(rq->buflen == (rq->endbuf - rq->buf));
+
+    if (rq->servp == rq->endp) {
+        return -1;
+    }
+
+    cp = (char_t*) rq->servp;
+    c = *cp++;
+    rq->servp = (unsigned char *) cp;
+    if (rq->servp >= rq->endbuf) {
+        rq->servp = rq->buf;
+    }
+    return (int) ((unsigned char) c);
 }
 
 
@@ -156,74 +156,74 @@ int ringqGetc(ringq_t *rq)
  */
 int ringqPutc(ringq_t *rq, char_t c)
 {
-	char_t *cp;
-
-	a_assert(rq);
-	a_assert(rq->buflen == (rq->endbuf - rq->buf));
-
-	if ((ringqPutBlkMax(rq) < (int) sizeof(char_t)) && !ringqGrow(rq)) {
-		return -1;
-	}
-
-	cp = (char_t*) rq->endp;
-	*cp++ = (char_t) c;
-	rq->endp = (unsigned char *) cp;
-	if (rq->endp >= rq->endbuf) {
-		rq->endp = rq->buf;
-	}
-	return 0;
+    char_t *cp;
+
+    a_assert(rq);
+    a_assert(rq->buflen == (rq->endbuf - rq->buf));
+
+    if ((ringqPutBlkMax(rq) < (int) sizeof(char_t)) && !ringqGrow(rq)) {
+        return -1;
+    }
+
+    cp = (char_t*) rq->endp;
+    *cp++ = (char_t) c;
+    rq->endp = (unsigned char *) cp;
+    if (rq->endp >= rq->endbuf) {
+        rq->endp = rq->buf;
+    }
+    return 0;
 }
 
 
 /*
-  	Insert a wide character at the front of the queue
+    Insert a wide character at the front of the queue
  */
 int ringqInsertc(ringq_t *rq, char_t c)
 {
-	char_t *cp;
-
-	a_assert(rq);
-	a_assert(rq->buflen == (rq->endbuf - rq->buf));
-
-	if (ringqPutBlkMax(rq) < (int) sizeof(char_t) && !ringqGrow(rq)) {
-		return -1;
-	}
-	if (rq->servp <= rq->buf) {
-		rq->servp = rq->endbuf;
-	}
-	cp = (char_t*) rq->servp;
-	*--cp = (char_t) c;
-	rq->servp = (unsigned char *) cp;
-	return 0;
+    char_t *cp;
+
+    a_assert(rq);
+    a_assert(rq->buflen == (rq->endbuf - rq->buf));
+
+    if (ringqPutBlkMax(rq) < (int) sizeof(char_t) && !ringqGrow(rq)) {
+        return -1;
+    }
+    if (rq->servp <= rq->buf) {
+        rq->servp = rq->endbuf;
+    }
+    cp = (char_t*) rq->servp;
+    *--cp = (char_t) c;
+    rq->servp = (unsigned char *) cp;
+    return 0;
 }
 
 
 /*
-  	Add a string to the queue. Add a trailing null (maybe two nulls)
+    Add a string to the queue. Add a trailing null (maybe two nulls)
  */
 int ringqPutStr(ringq_t *rq, char_t *str)
 {
-	int		rc;
+    int     rc;
 
-	a_assert(rq);
-	a_assert(str);
-	a_assert(rq->buflen == (rq->endbuf - rq->buf));
+    a_assert(rq);
+    a_assert(str);
+    a_assert(rq->buflen == (rq->endbuf - rq->buf));
 
-	rc = ringqPutBlk(rq, (unsigned char*) str, gstrlen(str) * sizeof(char_t));
-	*((char_t*) rq->endp) = (char_t) '\0';
-	return rc;
+    rc = ringqPutBlk(rq, (unsigned char*) str, gstrlen(str) * sizeof(char_t));
+    *((char_t*) rq->endp) = (char_t) '\0';
+    return rc;
 }
 
 
 /*
-  	Add a null terminator. This does NOT increase the size of the queue
+    Add a null terminator. This does NOT increase the size of the queue
  */
 void ringqAddNull(ringq_t *rq)
 {
-	a_assert(rq);
-	a_assert(rq->buflen == (rq->endbuf - rq->buf));
+    a_assert(rq);
+    a_assert(rq->buflen == (rq->endbuf - rq->buf));
 
-	*((char_t*) rq->endp) = (char_t) '\0';
+    *((char_t*) rq->endp) = (char_t) '\0';
 }
 
 
@@ -231,62 +231,62 @@ void ringqAddNull(ringq_t *rq)
 //  MOB - this should be the same code?
 
 /*
-  	Get a byte from the queue
+    Get a byte from the queue
  */
 int ringqGetcA(ringq_t *rq)
 {
-	unsigned char	c;
+    unsigned char   c;
 
-	a_assert(rq);
-	a_assert(rq->buflen == (rq->endbuf - rq->buf));
+    a_assert(rq);
+    a_assert(rq->buflen == (rq->endbuf - rq->buf));
 
-	if (rq->servp == rq->endp) {
-		return -1;
-	}
+    if (rq->servp == rq->endp) {
+        return -1;
+    }
 
-	c = *rq->servp++;
-	if (rq->servp >= rq->endbuf) {
-		rq->servp = rq->buf;
-	}
-	return c;
+    c = *rq->servp++;
+    if (rq->servp >= rq->endbuf) {
+        rq->servp = rq->buf;
+    }
+    return c;
 }
 
 
 /*
-  	Add a byte to the queue. Note if being used to store strings this does not add a trailing '\0'. Grow the q as required.
+    Add a byte to the queue. Note if being used to store strings this does not add a trailing '\0'. Grow the q as required.
  */
 int ringqPutcA(ringq_t *rq, char c)
 {
-	a_assert(rq);
-	a_assert(rq->buflen == (rq->endbuf - rq->buf));
-
-	if (ringqPutBlkMax(rq) == 0 && !ringqGrow(rq)) {
-		return -1;
-	}
-	*rq->endp++ = (unsigned char) c;
-	if (rq->endp >= rq->endbuf) {
-		rq->endp = rq->buf;
-	}
-	return 0;
+    a_assert(rq);
+    a_assert(rq->buflen == (rq->endbuf - rq->buf));
+
+    if (ringqPutBlkMax(rq) == 0 && !ringqGrow(rq)) {
+        return -1;
+    }
+    *rq->endp++ = (unsigned char) c;
+    if (rq->endp >= rq->endbuf) {
+        rq->endp = rq->buf;
+    }
+    return 0;
 }
 
 
 /*
-  	Insert a byte at the front of the queue
+    Insert a byte at the front of the queue
  */
 int ringqInsertcA(ringq_t *rq, char c)
 {
-	a_assert(rq);
-	a_assert(rq->buflen == (rq->endbuf - rq->buf));
-
-	if (ringqPutBlkMax(rq) == 0 && !ringqGrow(rq)) {
-		return -1;
-	}
-	if (rq->servp <= rq->buf) {
-		rq->servp = rq->endbuf;
-	}
-	*--rq->servp = (unsigned char) c;
-	return 0;
+    a_assert(rq);
+    a_assert(rq->buflen == (rq->endbuf - rq->buf));
+
+    if (ringqPutBlkMax(rq) == 0 && !ringqGrow(rq)) {
+        return -1;
+    }
+    if (rq->servp <= rq->buf) {
+        rq->servp = rq->endbuf;
+    }
+    *--rq->servp = (unsigned char) c;
+    return 0;
 }
 
 
@@ -295,90 +295,90 @@ int ringqInsertcA(ringq_t *rq, char c)
  */
 int ringqPutStrA(ringq_t *rq, char *str)
 {
-	int		rc;
+    int     rc;
 
-	a_assert(rq);
-	a_assert(str);
-	a_assert(rq->buflen == (rq->endbuf - rq->buf));
+    a_assert(rq);
+    a_assert(str);
+    a_assert(rq->buflen == (rq->endbuf - rq->buf));
 
-	rc = ringqPutBlk(rq, (unsigned char*) str, strlen(str));
-	rq->endp[0] = '\0';
-	return rc;
+    rc = ringqPutBlk(rq, (unsigned char*) str, strlen(str));
+    rq->endp[0] = '\0';
+    return rc;
 }
 
 #endif /* UNICODE */
 
 /*
-  	Add a block of data to the ringq. Return the number of bytes added. Grow the q as required.
+    Add a block of data to the ringq. Return the number of bytes added. Grow the q as required.
  */
 int ringqPutBlk(ringq_t *rq, unsigned char *buf, int size)
 {
-	int		this, bytes_put;
+    int     this, bytes_put;
 
-	a_assert(rq);
-	a_assert(rq->buflen == (rq->endbuf - rq->buf));
-	a_assert(buf);
-	a_assert(0 <= size);
+    a_assert(rq);
+    a_assert(rq->buflen == (rq->endbuf - rq->buf));
+    a_assert(buf);
+    a_assert(0 <= size);
 
     /*
-      	Loop adding the maximum bytes we can add in a single straight line copy
+        Loop adding the maximum bytes we can add in a single straight line copy
      */
-	bytes_put = 0;
-	while (size > 0) {
-		this = min(ringqPutBlkMax(rq), size);
-		if (this <= 0) {
-			if (! ringqGrow(rq)) {
-				break;
-			}
-			this = min(ringqPutBlkMax(rq), size);
-		}
-		memcpy(rq->endp, buf, this);
-		buf += this;
-		rq->endp += this;
-		size -= this;
-		bytes_put += this;
-
-		if (rq->endp >= rq->endbuf) {
-			rq->endp = rq->buf;
-		}
-	}
-	return bytes_put;
+    bytes_put = 0;
+    while (size > 0) {
+        this = min(ringqPutBlkMax(rq), size);
+        if (this <= 0) {
+            if (! ringqGrow(rq)) {
+                break;
+            }
+            this = min(ringqPutBlkMax(rq), size);
+        }
+        memcpy(rq->endp, buf, this);
+        buf += this;
+        rq->endp += this;
+        size -= this;
+        bytes_put += this;
+
+        if (rq->endp >= rq->endbuf) {
+            rq->endp = rq->buf;
+        }
+    }
+    return bytes_put;
 }
 
 
 /*
-  	Get a block of data from the ringq. Return the number of bytes returned.
+    Get a block of data from the ringq. Return the number of bytes returned.
  */
 int ringqGetBlk(ringq_t *rq, unsigned char *buf, int size)
 {
-	int		this, bytes_read;
+    int     this, bytes_read;
 
-	a_assert(rq);
-	a_assert(rq->buflen == (rq->endbuf - rq->buf));
-	a_assert(buf);
-	a_assert(0 <= size && size < rq->buflen);
+    a_assert(rq);
+    a_assert(rq->buflen == (rq->endbuf - rq->buf));
+    a_assert(buf);
+    a_assert(0 <= size && size < rq->buflen);
 
     /*
-      	Loop getting the maximum bytes we can get in a single straight line copy
+        Loop getting the maximum bytes we can get in a single straight line copy
      */
-	bytes_read = 0;
-	while (size > 0) {
-		this = ringqGetBlkMax(rq);
-		this = min(this, size);
-		if (this <= 0) {
-			break;
-		}
-		memcpy(buf, rq->servp, this);
-		buf += this;
-		rq->servp += this;
-		size -= this;
-		bytes_read += this;
-
-		if (rq->servp >= rq->endbuf) {
-			rq->servp = rq->buf;
-		}
-	}
-	return bytes_read;
+    bytes_read = 0;
+    while (size > 0) {
+        this = ringqGetBlkMax(rq);
+        this = min(this, size);
+        if (this <= 0) {
+            break;
+        }
+        memcpy(buf, rq->servp, this);
+        buf += this;
+        rq->servp += this;
+        size -= this;
+        bytes_read += this;
+
+        if (rq->servp >= rq->endbuf) {
+            rq->servp = rq->buf;
+        }
+    }
+    return bytes_read;
 }
 
 
@@ -388,15 +388,15 @@ int ringqGetBlk(ringq_t *rq, unsigned char *buf, int size)
  */
 int ringqPutBlkMax(ringq_t *rq)
 {
-	int		space, in_a_line;
+    int     space, in_a_line;
 
-	a_assert(rq);
-	a_assert(rq->buflen == (rq->endbuf - rq->buf));
-	
-	space = rq->buflen - RINGQ_LEN(rq) - 1;
-	in_a_line = rq->endbuf - rq->endp;
+    a_assert(rq);
+    a_assert(rq->buflen == (rq->endbuf - rq->buf));
+    
+    space = rq->buflen - RINGQ_LEN(rq) - 1;
+    in_a_line = rq->endbuf - rq->endp;
 
-	return min(in_a_line, space);
+    return min(in_a_line, space);
 }
 
 
@@ -406,77 +406,77 @@ int ringqPutBlkMax(ringq_t *rq)
  */
 int ringqGetBlkMax(ringq_t *rq)
 {
-	int		len, in_a_line;
+    int     len, in_a_line;
 
-	a_assert(rq);
-	a_assert(rq->buflen == (rq->endbuf - rq->buf));
+    a_assert(rq);
+    a_assert(rq->buflen == (rq->endbuf - rq->buf));
 
-	len = RINGQ_LEN(rq);
-	in_a_line = rq->endbuf - rq->servp;
+    len = RINGQ_LEN(rq);
+    in_a_line = rq->endbuf - rq->servp;
 
-	return min(in_a_line, len);
+    return min(in_a_line, len);
 }
 
 
 /*
-  	Adjust the endp pointer after the user has copied data into the queue.
+    Adjust the endp pointer after the user has copied data into the queue.
  */
 void ringqPutBlkAdj(ringq_t *rq, int size)
 {
-	a_assert(rq);
-	a_assert(rq->buflen == (rq->endbuf - rq->buf));
-	a_assert(0 <= size && size < rq->buflen);
-
-	rq->endp += size;
-	if (rq->endp >= rq->endbuf) {
-		rq->endp -= rq->buflen;
-	}
+    a_assert(rq);
+    a_assert(rq->buflen == (rq->endbuf - rq->buf));
+    a_assert(0 <= size && size < rq->buflen);
+
+    rq->endp += size;
+    if (rq->endp >= rq->endbuf) {
+        rq->endp -= rq->buflen;
+    }
     /*
-      	Flush the queue if the endp pointer is corrupted via a bad size
+        Flush the queue if the endp pointer is corrupted via a bad size
      */
-	if (rq->endp >= rq->endbuf) {
-		error(E_L, E_LOG, T("Bad end pointer"));
-		ringqFlush(rq);
-	}
+    if (rq->endp >= rq->endbuf) {
+        error(E_L, E_LOG, T("Bad end pointer"));
+        ringqFlush(rq);
+    }
 }
 
 
 /*
-  	Adjust the servp pointer after the user has copied data from the queue.
+    Adjust the servp pointer after the user has copied data from the queue.
  */
 void ringqGetBlkAdj(ringq_t *rq, int size)
 {
-	a_assert(rq);
-	a_assert(rq->buflen == (rq->endbuf - rq->buf));
-	a_assert(0 < size && size < rq->buflen);
-
-	rq->servp += size;
-	if (rq->servp >= rq->endbuf) {
-		rq->servp -= rq->buflen;
-	}
+    a_assert(rq);
+    a_assert(rq->buflen == (rq->endbuf - rq->buf));
+    a_assert(0 < size && size < rq->buflen);
+
+    rq->servp += size;
+    if (rq->servp >= rq->endbuf) {
+        rq->servp -= rq->buflen;
+    }
     /*
-      	Flush the queue if the servp pointer is corrupted via a bad size
+        Flush the queue if the servp pointer is corrupted via a bad size
      */
-	if (rq->servp >= rq->endbuf) {
-		error(E_L, E_LOG, T("Bad serv pointer"));
-		ringqFlush(rq);
-	}
+    if (rq->servp >= rq->endbuf) {
+        error(E_L, E_LOG, T("Bad serv pointer"));
+        ringqFlush(rq);
+    }
 }
 
 
 /*
-  	Flush all data in a ring q. Reset the pointers.
+    Flush all data in a ring q. Reset the pointers.
  */
 void ringqFlush(ringq_t *rq)
 {
-	a_assert(rq);
-	a_assert(rq->servp);
-
-	rq->servp = rq->buf;
-	rq->endp = rq->buf;
-	if (rq->servp) {
-		*rq->servp = '\0';
-	}
+    a_assert(rq);
+    a_assert(rq->servp);
+
+    rq->servp = rq->buf;
+    rq->endp = rq->buf;
+    if (rq->servp) {
+        *rq->servp = '\0';
+    }
 }
 
 
@@ -486,33 +486,33 @@ void ringqFlush(ringq_t *rq)
  */
 static int ringqGrow(ringq_t *rq)
 {
-	unsigned char	*newbuf;
-	int 			len;
-
-	a_assert(rq);
-
-	if (rq->maxsize >= 0 && rq->buflen >= rq->maxsize) {
-		return 0;
-	}
-	len = ringqLen(rq);
-	if ((newbuf = balloc(B_L, rq->buflen + rq->increment)) == NULL) {
-		return 0;
-	}
-	ringqGetBlk(rq, newbuf, ringqLen(rq));
-	bfree(B_L, (char*) rq->buf);
-
-	rq->buflen += rq->increment;
-	rq->endp = newbuf;
-	rq->servp = newbuf;
-	rq->buf = newbuf;
-	rq->endbuf = &rq->buf[rq->buflen];
-	ringqPutBlk(rq, newbuf, len);
+    unsigned char   *newbuf;
+    int             len;
+
+    a_assert(rq);
+
+    if (rq->maxsize >= 0 && rq->buflen >= rq->maxsize) {
+        return 0;
+    }
+    len = ringqLen(rq);
+    if ((newbuf = balloc(B_L, rq->buflen + rq->increment)) == NULL) {
+        return 0;
+    }
+    ringqGetBlk(rq, newbuf, ringqLen(rq));
+    bfree(B_L, (char*) rq->buf);
+
+    rq->buflen += rq->increment;
+    rq->endp = newbuf;
+    rq->servp = newbuf;
+    rq->buf = newbuf;
+    rq->endbuf = &rq->buf[rq->buflen];
+    ringqPutBlk(rq, newbuf, len);
 
     /*
-      	Double the increment so the next grow will line up with balloc'ed memory
+        Double the increment so the next grow will line up with balloc'ed memory
      */
-	rq->increment = getBinBlockSize(2 * rq->increment);
-	return 1;
+    rq->increment = getBinBlockSize(2 * rq->increment);
+    return 1;
 }
 
 
@@ -520,15 +520,15 @@ static int ringqGrow(ringq_t *rq)
     Find the smallest binary memory size that "size" will fit into.  This makes the ringq and ringqGrow routines much
     more efficient.  The balloc routine likes powers of 2 minus 1.
  */
-static int	getBinBlockSize(int size)
+static int  getBinBlockSize(int size)
 {
-	int	q;
+    int q;
 
-	size = size >> B_SHIFT;
-	for (q = 0; size; size >>= 1) {
-		q++;
-	}
-	return (1 << (B_SHIFT + q));
+    size = size >> B_SHIFT;
+    for (q = 0; size; size >>= 1) {
+        q++;
+    }
+    return (1 << (B_SHIFT + q));
 }
 
 
diff --git a/rom.c b/rom.c
index 26530a89..d5384984 100644
--- a/rom.c
+++ b/rom.c
@@ -4,65 +4,65 @@
     This module provides web page retrieval from compiled web pages. Use the webcomp program to compile web pages and
     link into the GoAhead WebServer.  This module uses a hashed symbol table for fast page lookup.
   
-  	Usage: webcomp -f webPageFileList -p Prefix >webrom.c
+    Usage: webcomp -f webPageFileList -p Prefix >webrom.c
 
     Copyright (c) All Rights Reserved. See details at the end of the file.
  */
 
 /********************************* Includes ***********************************/
 
-#include	<stdlib.h>
+#include    <stdlib.h>
 
-#include	"wsIntrn.h"
+#include    "wsIntrn.h"
 
 /******************************** Local Data **********************************/
 
 #ifdef WEBS_PAGE_ROM
 
-sym_fd_t	romTab;						/* Symbol table for web pages */
+sym_fd_t    romTab;                     /* Symbol table for web pages */
 
 /*********************************** Code *************************************/
 
 int websRomOpen()
 {
-	websRomPageIndexType	*wip;
-	int						nchars;
-	char_t					name[SYM_MAX];
-
-	romTab = symOpen(WEBS_SYM_INIT);
-
-	for (wip = websRomPageIndex; wip->path; wip++) {
-		gstrncpy(name, wip->path, SYM_MAX);
-		nchars = gstrlen(name) - 1;
-		if (nchars > 0 &&
-			(name[nchars] == '/' || name[nchars] == '\\')) {
-			name[nchars] = '\0';
-		}
-		symEnter(romTab, name, valueInteger((int) wip), 0);
-	}
-	return 0;
+    websRomPageIndexType    *wip;
+    int                     nchars;
+    char_t                  name[SYM_MAX];
+
+    romTab = symOpen(WEBS_SYM_INIT);
+
+    for (wip = websRomPageIndex; wip->path; wip++) {
+        gstrncpy(name, wip->path, SYM_MAX);
+        nchars = gstrlen(name) - 1;
+        if (nchars > 0 &&
+            (name[nchars] == '/' || name[nchars] == '\\')) {
+            name[nchars] = '\0';
+        }
+        symEnter(romTab, name, valueInteger((int) wip), 0);
+    }
+    return 0;
 }
 
 void websRomClose()
 {
-	symClose(romTab);
+    symClose(romTab);
 }
 
 
 int websRomPageOpen(webs_t wp, char_t *path, int mode, int perm)
 {
-	websRomPageIndexType	*wip;
-	sym_t					*sp;
-
-	a_assert(websValid(wp));
-	a_assert(path && *path);
-
-	if ((sp = symLookup(romTab, path)) == NULL) {
-		return -1;
-	}
-	wip = (websRomPageIndexType*) sp->content.value.integer;
-	wip->pos = 0;
-	return (wp->docfd = wip - websRomPageIndex);
+    websRomPageIndexType    *wip;
+    sym_t                   *sp;
+
+    a_assert(websValid(wp));
+    a_assert(path && *path);
+
+    if ((sp = symLookup(romTab, path)) == NULL) {
+        return -1;
+    }
+    wip = (websRomPageIndexType*) sp->content.value.integer;
+    wip->pos = 0;
+    return (wp->docfd = wip - websRomPageIndex);
 }
 
 
@@ -73,78 +73,78 @@ void websRomPageClose(int fd)
 
 int websRomPageStat(char_t *path, websStatType *sbuf)
 {
-	websRomPageIndexType	*wip;
-	sym_t					*sp;
-
-	a_assert(path && *path);
-
-	if ((sp = symLookup(romTab, path)) == NULL) {
-		return -1;
-	}
-	wip = (websRomPageIndexType*) sp->content.value.integer;
-
-	memset(sbuf, 0, sizeof(websStatType));
-	sbuf->size = wip->size;
-	if (wip->page == NULL) {
-		sbuf->isDir = 1;
-	}
-	return 0;
+    websRomPageIndexType    *wip;
+    sym_t                   *sp;
+
+    a_assert(path && *path);
+
+    if ((sp = symLookup(romTab, path)) == NULL) {
+        return -1;
+    }
+    wip = (websRomPageIndexType*) sp->content.value.integer;
+
+    memset(sbuf, 0, sizeof(websStatType));
+    sbuf->size = wip->size;
+    if (wip->page == NULL) {
+        sbuf->isDir = 1;
+    }
+    return 0;
 }
 
 
 int websRomPageReadData(webs_t wp, char *buf, int nBytes)
 {
-	websRomPageIndexType	*wip;
-	int						len;
+    websRomPageIndexType    *wip;
+    int                     len;
 
-	a_assert(websValid(wp));
-	a_assert(buf);
-	a_assert(wp->docfd >= 0);
+    a_assert(websValid(wp));
+    a_assert(buf);
+    a_assert(wp->docfd >= 0);
 
-	wip = &websRomPageIndex[wp->docfd];
+    wip = &websRomPageIndex[wp->docfd];
 
-	len = min(wip->size - wip->pos, nBytes);
-	memcpy(buf, &wip->page[wip->pos], len);
-	wip->pos += len;
-	return len;
+    len = min(wip->size - wip->pos, nBytes);
+    memcpy(buf, &wip->page[wip->pos], len);
+    wip->pos += len;
+    return len;
 }
 
 
 long websRomPageSeek(webs_t wp, long offset, int origin)
 {
-	websRomPageIndexType	*wip;
-	long pos;
-
-	a_assert(websValid(wp));
-	a_assert(origin == SEEK_SET || origin == SEEK_CUR || origin == SEEK_END);
-	a_assert(wp->docfd >= 0);
-
-	wip = &websRomPageIndex[wp->docfd];
-
-	if (origin != SEEK_SET && origin != SEEK_CUR && origin != SEEK_END) {
-		errno = EINVAL;
-		return -1;
-	}
-	if (wp->docfd < 0) {
-		errno = EBADF;
-		return -1;
-	}
-	pos = offset;
-	switch (origin) {
-	case SEEK_CUR:
-		pos = wip->pos + offset;
-		break;
-	case SEEK_END:
-		pos = wip->size + offset;
-		break;
-	default:
-		break;
-	}
-	if (pos < 0) {
-		errno = EBADF;
-		return -1;
-	}
-	return (wip->pos = pos);
+    websRomPageIndexType    *wip;
+    long pos;
+
+    a_assert(websValid(wp));
+    a_assert(origin == SEEK_SET || origin == SEEK_CUR || origin == SEEK_END);
+    a_assert(wp->docfd >= 0);
+
+    wip = &websRomPageIndex[wp->docfd];
+
+    if (origin != SEEK_SET && origin != SEEK_CUR && origin != SEEK_END) {
+        errno = EINVAL;
+        return -1;
+    }
+    if (wp->docfd < 0) {
+        errno = EBADF;
+        return -1;
+    }
+    pos = offset;
+    switch (origin) {
+    case SEEK_CUR:
+        pos = wip->pos + offset;
+        break;
+    case SEEK_END:
+        pos = wip->size + offset;
+        break;
+    default:
+        break;
+    }
+    if (pos < 0) {
+        errno = EBADF;
+        return -1;
+    }
+    return (wip->pos = pos);
 }
 
 #endif /* WEBS_PAGE_ROM */
diff --git a/security.c b/security.c
index e35acc6b..90a70079 100644
--- a/security.c
+++ b/security.c
@@ -6,16 +6,16 @@
 
 /********************************* Includes ***********************************/
 
-#include	"wsIntrn.h"
-#include	"um.h"
+#include    "wsIntrn.h"
+#include    "um.h"
 #ifdef DIGEST_ACCESS_SUPPORT
-#include	"websda.h"
+#include    "websda.h"
 #endif
 
 /********************************** Defines ***********************************/
 /*
-  	The following #defines change the behaviour of security in the absence of User Management.
-  	Note that use of User management functions require prior calling of umInit() to behave correctly
+    The following #defines change the behaviour of security in the absence of User Management.
+    Note that use of User management functions require prior calling of umInit() to behave correctly
  */
 #ifndef USER_MANAGEMENT_SUPPORT
 #define umGetAccessMethodForURL(url) AM_FULL
@@ -28,189 +28,189 @@
 
 /******************************** Local Data **********************************/
 
-static char_t	websPassword[WEBS_MAX_PASS];	/* Access password (decoded) */
+static char_t   websPassword[WEBS_MAX_PASS];    /* Access password (decoded) */
 //  MOB
 #ifdef _DEBUG
-static int		debugSecurity = 1;
+static int      debugSecurity = 1;
 #else
-static int		debugSecurity = 0;
+static int      debugSecurity = 0;
 #endif
 
 /*********************************** Code *************************************/
 /*
-  	Determine if this request should be honored
+    Determine if this request should be honored
  */
 int websSecurityHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t *url, char_t *path, char_t *query)
 {
-	char_t			*type, *userid, *password, *accessLimit;
-	accessMeth_t	am;
-	int				flags, nRet;
+    char_t          *type, *userid, *password, *accessLimit;
+    accessMeth_t    am;
+    int             flags, nRet;
 
-	a_assert(websValid(wp));
-	a_assert(url && *url);
-	a_assert(path && *path);
+    a_assert(websValid(wp));
+    a_assert(url && *url);
+    a_assert(path && *path);
 
     /*
-      	Get the critical request details
+        Get the critical request details
      */
-	type = websGetRequestType(wp);
-	password = websGetRequestPassword(wp);
-	userid = websGetRequestUserName(wp);
-	flags = websGetRequestFlags(wp);
+    type = websGetRequestType(wp);
+    password = websGetRequestPassword(wp);
+    userid = websGetRequestUserName(wp);
+    flags = websGetRequestFlags(wp);
     /*
-      	Get the access limit for the URL.  Exit if none found.
+        Get the access limit for the URL.  Exit if none found.
      */
-	accessLimit = umGetAccessLimit(path);
-	if (accessLimit == NULL) {
-		return 0;
-	}
-		 
+    accessLimit = umGetAccessLimit(path);
+    if (accessLimit == NULL) {
+        return 0;
+    }
+         
     /*
-      	Check to see if URL must be encrypted
+        Check to see if URL must be encrypted
      */
 #ifdef WEBS_SSL_SUPPORT
-	nRet = umGetAccessLimitSecure(accessLimit);
-	if (nRet && ((flags & WEBS_SECURE) == 0)) {
-		websStats.access++;
-		websError(wp, 405, T("Access Denied\nSecure access is required."));
-		trace(3, T("SEC: Non-secure access attempted on <%s>\n"), path);
+    nRet = umGetAccessLimitSecure(accessLimit);
+    if (nRet && ((flags & WEBS_SECURE) == 0)) {
+        websStats.access++;
+        websError(wp, 405, T("Access Denied\nSecure access is required."));
+        trace(3, T("SEC: Non-secure access attempted on <%s>\n"), path);
       /* bugfix 5/24/02 -- we were leaking the memory pointed to by
        * 'accessLimit'. Thanks to Simon Byholm.
        */
       bfree(B_L, accessLimit);
-		return 1;
-	}
+        return 1;
+    }
 #endif
 
     /*
-      	Get the access limit for the URL
+        Get the access limit for the URL
      */
-	am = umGetAccessMethodForURL(accessLimit);
+    am = umGetAccessMethodForURL(accessLimit);
 
-	nRet = 0;
-	if ((flags & WEBS_LOCAL_REQUEST) && (debugSecurity == 0)) {
+    nRet = 0;
+    if ((flags & WEBS_LOCAL_REQUEST) && (debugSecurity == 0)) {
         /*
             Local access is always allowed (defeat when debugging)
          */
-	} else if (am == AM_NONE) {
+    } else if (am == AM_NONE) {
         /*
             URL is supposed to be hidden!  Make like it wasn't found.
          */
-		websStats.access++;
-		websError(wp, 404, T("Page Not Found"));
-		nRet = 1;
-	} else 	if (userid && *userid) {
-		if (!umUserExists(userid)) {
-			websStats.access++;
-			websError(wp, 401, T("Access Denied\nUnknown User"));
-			trace(3, T("SEC: Unknown user <%s> attempted to access <%s>\n"), 
-				userid, path);
-			nRet = 1;
-		} else if (!umUserCanAccessURL(userid, accessLimit)) {
-			websStats.access++;
-			websError(wp, 403, T("Access Denied\nProhibited User"));
-			nRet = 1;
-		} else if (password && * password) {
-			char_t * userpass = umGetUserPassword(userid);
-			if (userpass) {
-				if (gstrcmp(password, userpass) != 0) {
-					websStats.access++;
-					websError(wp, 401, T("Access Denied\nWrong Password"));
-					trace(3, T("SEC: Password fail for user <%s>")
-								T("attempt to access <%s>\n"), userid, path);
-					nRet = 1;
-				} else {
+        websStats.access++;
+        websError(wp, 404, T("Page Not Found"));
+        nRet = 1;
+    } else  if (userid && *userid) {
+        if (!umUserExists(userid)) {
+            websStats.access++;
+            websError(wp, 401, T("Access Denied\nUnknown User"));
+            trace(3, T("SEC: Unknown user <%s> attempted to access <%s>\n"), 
+                userid, path);
+            nRet = 1;
+        } else if (!umUserCanAccessURL(userid, accessLimit)) {
+            websStats.access++;
+            websError(wp, 403, T("Access Denied\nProhibited User"));
+            nRet = 1;
+        } else if (password && * password) {
+            char_t * userpass = umGetUserPassword(userid);
+            if (userpass) {
+                if (gstrcmp(password, userpass) != 0) {
+                    websStats.access++;
+                    websError(wp, 401, T("Access Denied\nWrong Password"));
+                    trace(3, T("SEC: Password fail for user <%s>")
+                                T("attempt to access <%s>\n"), userid, path);
+                    nRet = 1;
+                } else {
                     /*
                         User and password check out.
                      */
-				}
-				bfree (B_L, userpass);
-			}
+                }
+                bfree (B_L, userpass);
+            }
 #ifdef DIGEST_ACCESS_SUPPORT
-		} else if (flags & WEBS_AUTH_DIGEST) {
-			char_t *digestCalc;
+        } else if (flags & WEBS_AUTH_DIGEST) {
+            char_t *digestCalc;
 
             /*
                 Check digest for equivalence
              */
-			wp->password = umGetUserPassword(userid);
-
-			a_assert(wp->digest);
-			a_assert(wp->nonce);
-			a_assert(wp->password);
-							 
-			digestCalc = websCalcDigest(wp);
-			a_assert(digestCalc);
-
-			if (gstrcmp(wp->digest, digestCalc) != 0) {
-				bfree (B_L, digestCalc);
-				digestCalc = websCalcUrlDigest(wp);
-				a_assert(digestCalc);
-				if (gstrcmp(wp->digest, digestCalc) != 0) {
-					websStats.access++;
-
-					websError(wp, 401, T("Access Denied\nWrong Password"));
-					nRet = 1;
-				}
-			}
-
-			bfree (B_L, digestCalc);
+            wp->password = umGetUserPassword(userid);
+
+            a_assert(wp->digest);
+            a_assert(wp->nonce);
+            a_assert(wp->password);
+                             
+            digestCalc = websCalcDigest(wp);
+            a_assert(digestCalc);
+
+            if (gstrcmp(wp->digest, digestCalc) != 0) {
+                bfree (B_L, digestCalc);
+                digestCalc = websCalcUrlDigest(wp);
+                a_assert(digestCalc);
+                if (gstrcmp(wp->digest, digestCalc) != 0) {
+                    websStats.access++;
+
+                    websError(wp, 401, T("Access Denied\nWrong Password"));
+                    nRet = 1;
+                }
+            }
+
+            bfree (B_L, digestCalc);
 #endif
-		} else {
+        } else {
             /*
                 No password has been specified
              */
 #ifdef DIGEST_ACCESS_SUPPORT
-			if (am == AM_DIGEST) {
-				wp->flags |= WEBS_AUTH_DIGEST;
-			}
+            if (am == AM_DIGEST) {
+                wp->flags |= WEBS_AUTH_DIGEST;
+            }
 #endif
-			websStats.errors++;
-			websError(wp, 401, 
-				T("Access to this document requires a password"));
-			nRet = 1;
-		}
-	} else if (am != AM_FULL) {
+            websStats.errors++;
+            websError(wp, 401, 
+                T("Access to this document requires a password"));
+            nRet = 1;
+        }
+    } else if (am != AM_FULL) {
         /*
-          		This will cause the browser to display a password / username dialog
+                This will cause the browser to display a password / username dialog
          */
 #ifdef DIGEST_ACCESS_SUPPORT
-		if (am == AM_DIGEST) {
-			wp->flags |= WEBS_AUTH_DIGEST;
-		}
+        if (am == AM_DIGEST) {
+            wp->flags |= WEBS_AUTH_DIGEST;
+        }
 #endif
-		websStats.errors++;
-		websError(wp, 401, T("Access to this document requires a User ID"));
-		nRet = 1;
-	}
-	bfree(B_L, accessLimit);
-	return nRet;
+        websStats.errors++;
+        websError(wp, 401, T("Access to this document requires a User ID"));
+        nRet = 1;
+    }
+    bfree(B_L, accessLimit);
+    return nRet;
 }
 
 
 void websSecurityDelete()
 {
-	websUrlHandlerDelete(websSecurityHandler);
+    websUrlHandlerDelete(websSecurityHandler);
 }
 
 
 /*
-  	Store the new password, expect a decoded password. Store in websPassword in the decoded form.
+    Store the new password, expect a decoded password. Store in websPassword in the decoded form.
  */
 void websSetPassword(char_t *password)
 {
-	a_assert(password);
+    a_assert(password);
 
-	gstrncpy(websPassword, password, TSZ(websPassword));
+    gstrncpy(websPassword, password, TSZ(websPassword));
 }
 
 
 /*
-  	Get password, return the decoded form
+    Get password, return the decoded form
  */
 char_t *websGetPassword()
 {
-	return bstrdup(B_L, websPassword);
+    return bstrdup(B_L, websPassword);
 }
 
 
diff --git a/sock.c b/sock.c
index 80895d74..c02c819b 100644
--- a/sock.c
+++ b/sock.c
@@ -6,90 +6,90 @@
 
 /********************************** Includes **********************************/
 
-#include	<string.h>
-#include	<stdlib.h>
+#include    <string.h>
+#include    <stdlib.h>
 
-#include	"uemf.h"
+#include    "uemf.h"
 
 /************************************ Locals **********************************/
 
-socket_t	**socketList;			/* List of open sockets */
-int			socketMax;				/* Maximum size of socket */
-int			socketHighestFd = -1;	/* Highest socket fd opened */
+socket_t    **socketList;           /* List of open sockets */
+int         socketMax;              /* Maximum size of socket */
+int         socketHighestFd = -1;   /* Highest socket fd opened */
 
 /***************************** Forward Declarations ***************************/
 
-static int	socketDoOutput(socket_t *sp, char *buf, int toWrite, int *errCode);
-static int	tryAlternateSendTo(int sock, char *buf, int toWrite, int i, struct sockaddr *server);
+static int  socketDoOutput(socket_t *sp, char *buf, int toWrite, int *errCode);
+static int  tryAlternateSendTo(int sock, char *buf, int toWrite, int i, struct sockaddr *server);
 
 /*********************************** Code *************************************/
 /*
     Write to a socket. Absorb as much data as the socket can buffer. Block if the socket is in blocking mode. Returns -1
     on error, otherwise the number of bytes written.
  */
-int	socketWrite(int sid, char *buf, int bufsize)
+int socketWrite(int sid, char *buf, int bufsize)
 {
-	socket_t	*sp;
-	ringq_t		*rq;
-	int			len, bytesWritten, room;
+    socket_t    *sp;
+    ringq_t     *rq;
+    int         len, bytesWritten, room;
 
-	a_assert(buf);
-	a_assert(bufsize >= 0);
+    a_assert(buf);
+    a_assert(bufsize >= 0);
 
-	if ((sp = socketPtr(sid)) == NULL) {
-		return -1;
-	}
+    if ((sp = socketPtr(sid)) == NULL) {
+        return -1;
+    }
     /*
         Loop adding as much data to the output ringq as we can absorb. Initiate a flush when the ringq is too full and
         continue. Block in socketFlush if the socket is in blocking mode.
      */
-	rq = &sp->outBuf;
-	for (bytesWritten = 0; bufsize > 0; ) {
-		if ((room = ringqPutBlkMax(rq)) == 0) {
-			if (socketFlush(sid) < 0) {
-				return -1;
-			}
-			if ((room = ringqPutBlkMax(rq)) == 0) {
-				if (sp->flags & SOCKET_BLOCK) {
+    rq = &sp->outBuf;
+    for (bytesWritten = 0; bufsize > 0; ) {
+        if ((room = ringqPutBlkMax(rq)) == 0) {
+            if (socketFlush(sid) < 0) {
+                return -1;
+            }
+            if ((room = ringqPutBlkMax(rq)) == 0) {
+                if (sp->flags & SOCKET_BLOCK) {
 #if (defined (WIN) || defined (CE))
-					int		errCode;
-					if (! socketWaitForEvent(sp,  FD_WRITE | SOCKET_WRITABLE,
-						&errCode)) {
-						return -1;
-					}
+                    int     errCode;
+                    if (! socketWaitForEvent(sp,  FD_WRITE | SOCKET_WRITABLE,
+                        &errCode)) {
+                        return -1;
+                    }
 #endif
-					continue;
-				}
-				break;
-			}
-			continue;
-		}
-		len = min(room, bufsize);
-		ringqPutBlk(rq, (unsigned char *) buf, len);
-		bytesWritten += len;
-		bufsize -= len;
-		buf += len;
-	}
-	return bytesWritten;
+                    continue;
+                }
+                break;
+            }
+            continue;
+        }
+        len = min(room, bufsize);
+        ringqPutBlk(rq, (unsigned char *) buf, len);
+        bytesWritten += len;
+        bufsize -= len;
+        buf += len;
+    }
+    return bytesWritten;
 }
 
 
 /*
-  	Write a string to a socket
+    Write a string to a socket
  */
-int	socketWriteString(int sid, char_t *buf)
+int socketWriteString(int sid, char_t *buf)
 {
  #ifdef UNICODE
- 	char	*byteBuf;
- 	int		r, len;
+    char    *byteBuf;
+    int     r, len;
  
- 	len = gstrlen(buf);
- 	byteBuf = ballocUniToAsc(buf, len);
- 	r = socketWrite(sid, byteBuf, len);
- 	bfreeSafe(B_L, byteBuf);
- 	return r;
+    len = gstrlen(buf);
+    byteBuf = ballocUniToAsc(buf, len);
+    r = socketWrite(sid, byteBuf, len);
+    bfreeSafe(B_L, byteBuf);
+    return r;
  #else
- 	return socketWrite(sid, buf, strlen(buf));
+    return socketWrite(sid, buf, strlen(buf));
  #endif /* UNICODE */
 }
 
@@ -102,72 +102,72 @@ int	socketWriteString(int sid, char_t *buf)
     Note: this ignores the line buffer, so a previous socketGets which read a partial line may cause a subsequent
     socketRead to miss some data. This routine may block if the socket is in blocking mode.
  */
-int	socketRead(int sid, char *buf, int bufsize)
+int socketRead(int sid, char *buf, int bufsize)
 {
-	socket_t	*sp;
-	ringq_t		*rq;
-	int			len, room, errCode, bytesRead;
+    socket_t    *sp;
+    ringq_t     *rq;
+    int         len, room, errCode, bytesRead;
 
-	a_assert(buf);
-	a_assert(bufsize > 0);
+    a_assert(buf);
+    a_assert(bufsize > 0);
 
-	if ((sp = socketPtr(sid)) == NULL) {
-		return -1;
-	}
+    if ((sp = socketPtr(sid)) == NULL) {
+        return -1;
+    }
 
-	if (sp->flags & SOCKET_EOF) {
-		return 0;
-	}
+    if (sp->flags & SOCKET_EOF) {
+        return 0;
+    }
 
-	rq = &sp->inBuf;
-	for (bytesRead = 0; bufsize > 0; ) {
-		len = min(ringqLen(rq), bufsize);
-		if (len <= 0) {
+    rq = &sp->inBuf;
+    for (bytesRead = 0; bufsize > 0; ) {
+        len = min(ringqLen(rq), bufsize);
+        if (len <= 0) {
             /*
                 If blocking mode and already have data, exit now or it may block forever.
              */
-			if ((sp->flags & SOCKET_BLOCK) &&
-				(bytesRead > 0)) {
-				break;
-			}
+            if ((sp->flags & SOCKET_BLOCK) &&
+                (bytesRead > 0)) {
+                break;
+            }
             /*
                 This flush is critical for readers of datagram packets. If the buffer is not big enough to read the
                 whole datagram in one hit, the recvfrom call will fail. 
              */
-			ringqFlush(rq);
-			room = ringqPutBlkMax(rq);
-			len = socketGetInput(sid, (char *) rq->endp, room, &errCode);
-			if (len < 0) {
-				if (errCode == EWOULDBLOCK) {
-					if ((sp->flags & SOCKET_BLOCK) &&
-						(bytesRead ==  0)) {
-						continue;
-					}
-					if (bytesRead >= 0) {
-						return bytesRead;
-					}
-				}
-				return -1;
-
-			} else if (len == 0) {
+            ringqFlush(rq);
+            room = ringqPutBlkMax(rq);
+            len = socketGetInput(sid, (char *) rq->endp, room, &errCode);
+            if (len < 0) {
+                if (errCode == EWOULDBLOCK) {
+                    if ((sp->flags & SOCKET_BLOCK) &&
+                        (bytesRead ==  0)) {
+                        continue;
+                    }
+                    if (bytesRead >= 0) {
+                        return bytesRead;
+                    }
+                }
+                return -1;
+
+            } else if (len == 0) {
                 /*
                     If bytesRead is 0, this is EOF since socketRead should never be called unless there is data yet to
                     be read. Set the flag. Then pass back the number of bytes read.
                  */
-				if (bytesRead == 0) {
-					sp->flags |= SOCKET_EOF;
-				}
-				return bytesRead;
-			}
-			ringqPutBlkAdj(rq, len);
-			len = min(len, bufsize);
-		}
-		memcpy(&buf[bytesRead], rq->servp, len);
-		ringqGetBlkAdj(rq, len);
-		bufsize -= len;
-		bytesRead += len;
-	}
-	return bytesRead;
+                if (bytesRead == 0) {
+                    sp->flags |= SOCKET_EOF;
+                }
+                return bytesRead;
+            }
+            ringqPutBlkAdj(rq, len);
+            len = min(len, bufsize);
+        }
+        memcpy(&buf[bytesRead], rq->servp, len);
+        ringqGetBlkAdj(rq, len);
+        bufsize -= len;
+        bytesRead += len;
+    }
+    return bytesRead;
 }
 
 
@@ -178,302 +178,302 @@ int	socketRead(int sid, char *buf, int bufsize)
     socketInputBuffered or socketEof can be used to distinguish between EOF and partial line still buffered. This
     routine eats and ignores carriage returns.
  */
-int	socketGets(int sid, char_t **buf)
+int socketGets(int sid, char_t **buf)
 {
-	socket_t	*sp;
-	ringq_t		*lq;
-	char		c;
-	int			rc, len;
-
-	a_assert(buf);
-	*buf = NULL;
-	if ((sp = socketPtr(sid)) == NULL) {
-		return -1;
-	}
-	lq = &sp->lineBuf;
-
-	while (1) {
-		if ((rc = socketRead(sid, &c, 1)) < 0) {
-			return rc;
-		}
-		
-		if (rc == 0) {
+    socket_t    *sp;
+    ringq_t     *lq;
+    char        c;
+    int         rc, len;
+
+    a_assert(buf);
+    *buf = NULL;
+    if ((sp = socketPtr(sid)) == NULL) {
+        return -1;
+    }
+    lq = &sp->lineBuf;
+
+    while (1) {
+        if ((rc = socketRead(sid, &c, 1)) < 0) {
+            return rc;
+        }
+        
+        if (rc == 0) {
             /*
                 If there is a partial line and we are at EOF, pretend we saw a '\n'
              */
-			if (ringqLen(lq) > 0 && (sp->flags & SOCKET_EOF)) {
-				c = '\n';
-			} else {
-				return -1;
-			}
-		}
+            if (ringqLen(lq) > 0 && (sp->flags & SOCKET_EOF)) {
+                c = '\n';
+            } else {
+                return -1;
+            }
+        }
         /* 
             Validate length of request.  Ignore long strings without newlines to safeguard against long URL attacks.
          */
-		if (ringqLen(lq) > E_MAX_REQUEST) {
-			c = '\n';
-		}
+        if (ringqLen(lq) > E_MAX_REQUEST) {
+            c = '\n';
+        }
         /*
             If a newline is seen, return the data excluding the new line to the caller. If carriage return is seen, just
             eat it.  
          */
         if (c == '\n') {
-			len = ringqLen(lq);
-			if (len > 0) {
-				*buf = ballocAscToUni((char *)lq->servp, len);
-			} else {
-				*buf = NULL;
-			}
-			ringqFlush(lq);
-			return len;
-
-		} else if (c == '\r') {
-			continue;
-		}
-		ringqPutcA(lq, c);
-	}
-	return 0;
+            len = ringqLen(lq);
+            if (len > 0) {
+                *buf = ballocAscToUni((char *)lq->servp, len);
+            } else {
+                *buf = NULL;
+            }
+            ringqFlush(lq);
+            return len;
+
+        } else if (c == '\r') {
+            continue;
+        }
+        ringqPutcA(lq, c);
+    }
+    return 0;
 }
 
 
 /*
-  	Flush the socket. Block if the socket is in blocking mode.  This will return -1 on errors and 0 if successful.
+    Flush the socket. Block if the socket is in blocking mode.  This will return -1 on errors and 0 if successful.
  */
 int socketFlush(int sid)
 {
-	socket_t	*sp;
-	ringq_t		*rq;
-	int			len, bytesWritten, errCode;
+    socket_t    *sp;
+    ringq_t     *rq;
+    int         len, bytesWritten, errCode;
 
-	if ((sp = socketPtr(sid)) == NULL) {
-		return -1;
-	}
-	rq = &sp->outBuf;
+    if ((sp = socketPtr(sid)) == NULL) {
+        return -1;
+    }
+    rq = &sp->outBuf;
 
     /*
-      	Set the background flushing flag which socketEventProc will check to continue the flush.
+        Set the background flushing flag which socketEventProc will check to continue the flush.
      */
-	if (! (sp->flags & SOCKET_BLOCK)) {
-		sp->flags |= SOCKET_FLUSHING;
-	}
+    if (! (sp->flags & SOCKET_BLOCK)) {
+        sp->flags |= SOCKET_FLUSHING;
+    }
 
     /*
         Break from loop if not blocking after initiating output. If we are blocking we wait for a write event.
      */
-	while (ringqLen(rq) > 0) {
-		len = ringqGetBlkMax(&sp->outBuf);
-		bytesWritten = socketDoOutput(sp, (char*) rq->servp, len, &errCode);
-		if (bytesWritten < 0) {
-			if (errCode == EINTR) {
-				continue;
-			} else if (errCode == EWOULDBLOCK || errCode == EAGAIN) {
+    while (ringqLen(rq) > 0) {
+        len = ringqGetBlkMax(&sp->outBuf);
+        bytesWritten = socketDoOutput(sp, (char*) rq->servp, len, &errCode);
+        if (bytesWritten < 0) {
+            if (errCode == EINTR) {
+                continue;
+            } else if (errCode == EWOULDBLOCK || errCode == EAGAIN) {
 #if (defined (WIN) || defined (CE))
-				if (sp->flags & SOCKET_BLOCK) {
-					int		errCode;
-					if (! socketWaitForEvent(sp,  FD_WRITE | SOCKET_WRITABLE,
-						&errCode)) {
-						return -1;
-					}
-					continue;
-				} 
+                if (sp->flags & SOCKET_BLOCK) {
+                    int     errCode;
+                    if (! socketWaitForEvent(sp,  FD_WRITE | SOCKET_WRITABLE,
+                        &errCode)) {
+                        return -1;
+                    }
+                    continue;
+                } 
 #endif
                 /*
                     Ensure we get a FD_WRITE message when the socket can absorb more data (non-blocking only.) Store the
                     user's mask if we haven't done it already.
                  */
-				if (sp->saveMask < 0 ) {
-					sp->saveMask = sp->handlerMask;
-					socketRegisterInterest(sp, 
-					sp->handlerMask | SOCKET_WRITABLE);
-				}
-				return 0;
-			}
-			return -1;
-		}
-		ringqGetBlkAdj(rq, bytesWritten);
-	}
+                if (sp->saveMask < 0 ) {
+                    sp->saveMask = sp->handlerMask;
+                    socketRegisterInterest(sp, 
+                    sp->handlerMask | SOCKET_WRITABLE);
+                }
+                return 0;
+            }
+            return -1;
+        }
+        ringqGetBlkAdj(rq, bytesWritten);
+    }
     /*
         If the buffer is empty, reset the ringq pointers to point to the start of the buffer. This is essential to
         ensure that datagrams get written in one single I/O operation.  
      */
-	if (ringqLen(rq) == 0) {
-		ringqFlush(rq);
-	}
+    if (ringqLen(rq) == 0) {
+        ringqFlush(rq);
+    }
     /*
         Restore the users mask if it was saved by the non-blocking code above. Note: saveMask = -1 if empty.
         socketRegisterInterest will set handlerMask 
      */
-	if (sp->saveMask >= 0) {
-		socketRegisterInterest(sp, sp->saveMask);
-		sp->saveMask = -1;
-	}
-	sp->flags &= ~SOCKET_FLUSHING;
-	return 0;
+    if (sp->saveMask >= 0) {
+        socketRegisterInterest(sp, sp->saveMask);
+        sp->saveMask = -1;
+    }
+    sp->flags &= ~SOCKET_FLUSHING;
+    return 0;
 }
 
 
 /*
-  	Return the count of input characters buffered. We look at both the line
-  	buffer and the input (raw) buffer. Return -1 on error or EOF.
+    Return the count of input characters buffered. We look at both the line
+    buffer and the input (raw) buffer. Return -1 on error or EOF.
  */
 int socketInputBuffered(int sid)
 {
-	socket_t	*sp;
-
-	if ((sp = socketPtr(sid)) == NULL) {
-		return -1;
-	}
-	if (socketEof(sid)) {
-		return -1;
-	}
-	return ringqLen(&sp->inBuf);
+    socket_t    *sp;
+
+    if ((sp = socketPtr(sid)) == NULL) {
+        return -1;
+    }
+    if (socketEof(sid)) {
+        return -1;
+    }
+    return ringqLen(&sp->inBuf);
 }
 
 
 /*
-  	Return true if EOF
+    Return true if EOF
  */
 int socketEof(int sid)
 {
-	socket_t	*sp;
+    socket_t    *sp;
 
-	if ((sp = socketPtr(sid)) == NULL) {
-		return -1;
-	}
-	return sp->flags & SOCKET_EOF;
+    if ((sp = socketPtr(sid)) == NULL) {
+        return -1;
+    }
+    return sp->flags & SOCKET_EOF;
 }
 
 
 /*
-  	Return the number of bytes the socket can absorb without blocking
+    Return the number of bytes the socket can absorb without blocking
  */
 int socketCanWrite(int sid)
 {
-	socket_t	*sp;
+    socket_t    *sp;
 
-	if ((sp = socketPtr(sid)) == NULL) {
-		return -1;
-	}
-	return sp->outBuf.buflen - ringqLen(&sp->outBuf) - 1;
+    if ((sp = socketPtr(sid)) == NULL) {
+        return -1;
+    }
+    return sp->outBuf.buflen - ringqLen(&sp->outBuf) - 1;
 }
 
 
 /*
-  	Add one to allow the user to write exactly SOCKET_BUFSIZ
+    Add one to allow the user to write exactly SOCKET_BUFSIZ
  */
 void socketSetBufferSize(int sid, int in, int line, int out)
 {
-	socket_t	*sp;
-
-	if ((sp = socketPtr(sid)) == NULL) {
-		return;
-	}
-	if (in >= 0) {
-		ringqClose(&sp->inBuf);
-		in++;
-		ringqOpen(&sp->inBuf, in, in);
-	}
-	if (line >= 0) {
-		ringqClose(&sp->lineBuf);
-		line++;
-		ringqOpen(&sp->lineBuf, line, line);
-	}
-	if (out >= 0) {
-		ringqClose(&sp->outBuf);
-		out++;
-		ringqOpen(&sp->outBuf, out, out);
-	}
+    socket_t    *sp;
+
+    if ((sp = socketPtr(sid)) == NULL) {
+        return;
+    }
+    if (in >= 0) {
+        ringqClose(&sp->inBuf);
+        in++;
+        ringqOpen(&sp->inBuf, in, in);
+    }
+    if (line >= 0) {
+        ringqClose(&sp->lineBuf);
+        line++;
+        ringqOpen(&sp->lineBuf, line, line);
+    }
+    if (out >= 0) {
+        ringqClose(&sp->outBuf);
+        out++;
+        ringqOpen(&sp->outBuf, out, out);
+    }
 }
 
 
 /*
-  	Create a user handler for this socket. The handler called whenever there
-  	is an event of interest as defined by handlerMask (SOCKET_READABLE, ...)
+    Create a user handler for this socket. The handler called whenever there
+    is an event of interest as defined by handlerMask (SOCKET_READABLE, ...)
  */
 void socketCreateHandler(int sid, int handlerMask, socketHandler_t handler, void* data)
 {
-	socket_t	*sp;
-
-	if ((sp = socketPtr(sid)) == NULL) {
-		return;
-	}
-	sp->handler = handler;
-	sp->handler_data = data;
-	socketRegisterInterest(sp, handlerMask);
+    socket_t    *sp;
+
+    if ((sp = socketPtr(sid)) == NULL) {
+        return;
+    }
+    sp->handler = handler;
+    sp->handler_data = data;
+    socketRegisterInterest(sp, handlerMask);
 }
 
 
 void socketDeleteHandler(int sid)
 {
-	socket_t	*sp;
+    socket_t    *sp;
 
-	if ((sp = socketPtr(sid)) == NULL) {
-		return;
-	}
-	sp->handler = NULL;
-	socketRegisterInterest(sp, 0);
+    if ((sp = socketPtr(sid)) == NULL) {
+        return;
+    }
+    sp->handler = NULL;
+    socketRegisterInterest(sp, 0);
 }
 
 
 /*
-  	Socket output procedure. Return -1 on errors otherwise return the number of bytes written.
+    Socket output procedure. Return -1 on errors otherwise return the number of bytes written.
  */
 static int socketDoOutput(socket_t *sp, char *buf, int toWrite, int *errCode)
 {
-	struct sockaddr_in	server;
-	int					bytes;
+    struct sockaddr_in  server;
+    int                 bytes;
 
-	a_assert(sp);
-	a_assert(buf);
-	a_assert(toWrite > 0);
-	a_assert(errCode);
+    a_assert(sp);
+    a_assert(buf);
+    a_assert(toWrite > 0);
+    a_assert(errCode);
 
-	*errCode = 0;
+    *errCode = 0;
 
 #if (defined (WIN) || defined (CE))
-	if ((sp->flags & SOCKET_ASYNC)
-			&& ! socketWaitForEvent(sp,  FD_CONNECT, errCode)) {
-		return -1;
-	}
+    if ((sp->flags & SOCKET_ASYNC)
+            && ! socketWaitForEvent(sp,  FD_CONNECT, errCode)) {
+        return -1;
+    }
 #endif
 
     /*
-      	Write the data
+        Write the data
      */
-	if (sp->flags & SOCKET_BROADCAST) {
-		server.sin_family = AF_INET;
-		server.sin_addr.s_addr = INADDR_BROADCAST;
-		server.sin_port = htons((short)(sp->port & 0xFFFF));
-		if ((bytes = sendto(sp->sock, buf, toWrite, 0, (struct sockaddr *) &server, sizeof(server))) < 0) {
-			bytes = tryAlternateSendTo(sp->sock, buf, toWrite, 0, (struct sockaddr *) &server);
-		}
-	} else if (sp->flags & SOCKET_DATAGRAM) {
-		server.sin_family = AF_INET;
-		server.sin_addr.s_addr = inet_addr(sp->host);
-		server.sin_port = htons((short)(sp->port & 0xFFFF));
-		bytes = sendto(sp->sock, buf, toWrite, 0, (struct sockaddr *) &server, sizeof(server));
-
-	} else {
-		bytes = send(sp->sock, buf, toWrite, 0);
-	}
-	if (bytes < 0) {
-		*errCode = socketGetError();
+    if (sp->flags & SOCKET_BROADCAST) {
+        server.sin_family = AF_INET;
+        server.sin_addr.s_addr = INADDR_BROADCAST;
+        server.sin_port = htons((short)(sp->port & 0xFFFF));
+        if ((bytes = sendto(sp->sock, buf, toWrite, 0, (struct sockaddr *) &server, sizeof(server))) < 0) {
+            bytes = tryAlternateSendTo(sp->sock, buf, toWrite, 0, (struct sockaddr *) &server);
+        }
+    } else if (sp->flags & SOCKET_DATAGRAM) {
+        server.sin_family = AF_INET;
+        server.sin_addr.s_addr = inet_addr(sp->host);
+        server.sin_port = htons((short)(sp->port & 0xFFFF));
+        bytes = sendto(sp->sock, buf, toWrite, 0, (struct sockaddr *) &server, sizeof(server));
+
+    } else {
+        bytes = send(sp->sock, buf, toWrite, 0);
+    }
+    if (bytes < 0) {
+        *errCode = socketGetError();
 #if (defined (WIN) || defined (CE))
-		sp->currentEvents &= ~FD_WRITE;
+        sp->currentEvents &= ~FD_WRITE;
 #endif
-		return -1;
-	} else if (bytes == 0 && bytes != toWrite) {
-		*errCode = EWOULDBLOCK;
+        return -1;
+    } else if (bytes == 0 && bytes != toWrite) {
+        *errCode = EWOULDBLOCK;
 #if (defined (WIN) || defined (CE))
-		sp->currentEvents &= ~FD_WRITE;
+        sp->currentEvents &= ~FD_WRITE;
 #endif
-		return -1;
-	}
+        return -1;
+    }
 
     /*
-      	Ensure we get to write some more data real soon if the socket can absorb more data
+        Ensure we get to write some more data real soon if the socket can absorb more data
      */
-	return bytes;
+    return bytes;
 }
 
 
@@ -484,214 +484,214 @@ static int socketDoOutput(socket_t *sp, char *buf, int toWrite, int *errCode)
 static int tryAlternateSendTo(int sock, char *buf, int toWrite, int i, struct sockaddr *server)
 {
 #ifdef VXWORKS
-	char *ptr;
+    char *ptr;
 
-	ptr = (char *)server;
-	*ptr = *(ptr+1);
-	*(ptr+1) = 0;
-	return sendto(sock, buf, toWrite, i, server, sizeof(struct sockaddr));
+    ptr = (char *)server;
+    *ptr = *(ptr+1);
+    *(ptr+1) = 0;
+    return sendto(sock, buf, toWrite, i, server, sizeof(struct sockaddr));
 #else
-	return -1;
+    return -1;
 #endif /* VXWORKS */
 }
 
 
 /*
-  	Allocate a new socket structure
+    Allocate a new socket structure
  */
 int socketAlloc(char *host, int port, socketAccept_t accept, int flags)
 {
-	socket_t	*sp;
-	int			sid;
-
-	if ((sid = hAllocEntry((void***) &socketList, &socketMax, sizeof(socket_t))) < 0) {
-		return -1;
-	}
-	sp = socketList[sid];
-	sp->sid = sid;
-	sp->accept = accept;
-	sp->port = port;
-	sp->fileHandle = -1;
-	sp->saveMask = -1;
-
-	if (host) {
-		strncpy(sp->host, host, sizeof(sp->host));
-	}
+    socket_t    *sp;
+    int         sid;
+
+    if ((sid = hAllocEntry((void***) &socketList, &socketMax, sizeof(socket_t))) < 0) {
+        return -1;
+    }
+    sp = socketList[sid];
+    sp->sid = sid;
+    sp->accept = accept;
+    sp->port = port;
+    sp->fileHandle = -1;
+    sp->saveMask = -1;
+
+    if (host) {
+        strncpy(sp->host, host, sizeof(sp->host));
+    }
 
     /*
-      	Preserve only specified flags from the callers open
+        Preserve only specified flags from the callers open
      */
-	a_assert((flags & ~(SOCKET_BROADCAST|SOCKET_DATAGRAM|SOCKET_BLOCK| SOCKET_LISTENING)) == 0);
-	sp->flags = flags & (SOCKET_BROADCAST | SOCKET_DATAGRAM | SOCKET_BLOCK | SOCKET_LISTENING | SOCKET_MYOWNBUFFERS);
+    a_assert((flags & ~(SOCKET_BROADCAST|SOCKET_DATAGRAM|SOCKET_BLOCK| SOCKET_LISTENING)) == 0);
+    sp->flags = flags & (SOCKET_BROADCAST | SOCKET_DATAGRAM | SOCKET_BLOCK | SOCKET_LISTENING | SOCKET_MYOWNBUFFERS);
 
-	if (!(flags & SOCKET_MYOWNBUFFERS)) { 
+    if (!(flags & SOCKET_MYOWNBUFFERS)) { 
         /*
             Add one to allow the user to write exactly SOCKET_BUFSIZ
          */
-		ringqOpen(&sp->inBuf, SOCKET_BUFSIZ, SOCKET_BUFSIZ);
-		ringqOpen(&sp->outBuf, SOCKET_BUFSIZ + 1, SOCKET_BUFSIZ + 1);
-	} else {
-		memset(&sp->inBuf, 0x0, sizeof(ringq_t));
-		memset(&sp->outBuf, 0x0, sizeof(ringq_t));
-	}
-	ringqOpen(&sp->lineBuf, SOCKET_BUFSIZ, -1);
-	return sid;
+        ringqOpen(&sp->inBuf, SOCKET_BUFSIZ, SOCKET_BUFSIZ);
+        ringqOpen(&sp->outBuf, SOCKET_BUFSIZ + 1, SOCKET_BUFSIZ + 1);
+    } else {
+        memset(&sp->inBuf, 0x0, sizeof(ringq_t));
+        memset(&sp->outBuf, 0x0, sizeof(ringq_t));
+    }
+    ringqOpen(&sp->lineBuf, SOCKET_BUFSIZ, -1);
+    return sid;
 }
 
 
 /*
-  	Free a socket structure
+    Free a socket structure
  */
 void socketFree(int sid)
 {
-	socket_t	*sp;
-	char_t		buf[256];
-	int			i;
+    socket_t    *sp;
+    char_t      buf[256];
+    int         i;
 
-	if ((sp = socketPtr(sid)) == NULL) {
-		return;
-	}
+    if ((sp = socketPtr(sid)) == NULL) {
+        return;
+    }
     /*
         To close a socket, remove any registered interests, set it to non-blocking so that the recv which follows won't
         block, do a shutdown on it so peers on the other end will receive a FIN, then read any data not yet retrieved
         from the receive buffer, and finally close it.  If these steps are not all performed RESETs may be sent to the
         other end causing problems.
      */
-	socketRegisterInterest(sp, 0);
-	if (sp->sock >= 0) {
-		socketSetBlock(sid, 0);
-		if (shutdown(sp->sock, 1) >= 0) {
-			recv(sp->sock, buf, sizeof(buf), 0);
-		}
+    socketRegisterInterest(sp, 0);
+    if (sp->sock >= 0) {
+        socketSetBlock(sid, 0);
+        if (shutdown(sp->sock, 1) >= 0) {
+            recv(sp->sock, buf, sizeof(buf), 0);
+        }
 #if (defined (WIN) || defined (CE))
-		closesocket(sp->sock);
+        closesocket(sp->sock);
 #else
-		close(sp->sock);
+        close(sp->sock);
 #endif
-	}
-	if (!(sp->flags & SOCKET_MYOWNBUFFERS)) { 
-		ringqClose(&sp->inBuf);
-		ringqClose(&sp->outBuf);
-	}
-	ringqClose(&sp->lineBuf);
-	bfree(B_L, sp);
-	socketMax = hFree((void***) &socketList, sid);
+    }
+    if (!(sp->flags & SOCKET_MYOWNBUFFERS)) { 
+        ringqClose(&sp->inBuf);
+        ringqClose(&sp->outBuf);
+    }
+    ringqClose(&sp->lineBuf);
+    bfree(B_L, sp);
+    socketMax = hFree((void***) &socketList, sid);
 
     /*
-      	Calculate the new highest socket number
+        Calculate the new highest socket number
      */
-	socketHighestFd = -1;
-	for (i = 0; i < socketMax; i++) {
-		if ((sp = socketList[i]) == NULL) {
-			continue;
-		} 
-		socketHighestFd = max(socketHighestFd, sp->sock);
-	}
+    socketHighestFd = -1;
+    for (i = 0; i < socketMax; i++) {
+        if ((sp = socketList[i]) == NULL) {
+            continue;
+        } 
+        socketHighestFd = max(socketHighestFd, sp->sock);
+    }
 }
 
 
 /*
-  	Validate a socket handle
+    Validate a socket handle
  */
 socket_t *socketPtr(int sid)
 {
-	if (sid < 0 || sid >= socketMax || socketList[sid] == NULL) {
-		a_assert(NULL);
-		errno = EBADF;
-		return NULL;
-	}
-	a_assert(socketList[sid]);
-	return socketList[sid];
+    if (sid < 0 || sid >= socketMax || socketList[sid] == NULL) {
+        a_assert(NULL);
+        errno = EBADF;
+        return NULL;
+    }
+    a_assert(socketList[sid]);
+    return socketList[sid];
 }
 
 
 /*
-  	Get the operating system error code
+    Get the operating system error code
  */
 int socketGetError()
 {
 #if (defined (WIN) || defined (CE))
-	switch (WSAGetLastError()) {
-	case WSAEWOULDBLOCK:
-		return EWOULDBLOCK;
-	case WSAECONNRESET:
-		return ECONNRESET;
-	case WSAENETDOWN:
-		return ENETDOWN;
-	case WSAEPROCLIM:
-		return EAGAIN;
-	case WSAEINTR:
-		return EINTR;
-	default:
-		return EINVAL;
-	}
+    switch (WSAGetLastError()) {
+    case WSAEWOULDBLOCK:
+        return EWOULDBLOCK;
+    case WSAECONNRESET:
+        return ECONNRESET;
+    case WSAENETDOWN:
+        return ENETDOWN;
+    case WSAEPROCLIM:
+        return EAGAIN;
+    case WSAEINTR:
+        return EINTR;
+    default:
+        return EINVAL;
+    }
 #else
-	return errno;
+    return errno;
 #endif
 }
 
 
 /*
-  	Return the underlying socket handle
+    Return the underlying socket handle
  */
 int socketGetHandle(int sid)
 {
-	socket_t	*sp;
+    socket_t    *sp;
 
-	if ((sp = socketPtr(sid)) == NULL) {
-		return -1;
-	}
-	return sp->sock;
+    if ((sp = socketPtr(sid)) == NULL) {
+        return -1;
+    }
+    return sp->sock;
 }
 
 
 /*
-  	Get blocking mode
+    Get blocking mode
  */
 int socketGetBlock(int sid)
 {
-	socket_t	*sp;
+    socket_t    *sp;
 
-	if ((sp = socketPtr(sid)) == NULL) {
-		a_assert(0);
-		return 0;
-	}
-	return (sp->flags & SOCKET_BLOCK);
+    if ((sp = socketPtr(sid)) == NULL) {
+        a_assert(0);
+        return 0;
+    }
+    return (sp->flags & SOCKET_BLOCK);
 }
 
 
 int socketGetMode(int sid)
 {
-	socket_t	*sp;
+    socket_t    *sp;
 
-	if ((sp = socketPtr(sid)) == NULL) {
-		a_assert(0);
-		return 0;
-	}
-	return sp->flags;
+    if ((sp = socketPtr(sid)) == NULL) {
+        a_assert(0);
+        return 0;
+    }
+    return sp->flags;
 }
 
 
 void socketSetMode(int sid, int mode)
 {
-	socket_t	*sp;
+    socket_t    *sp;
 
-	if ((sp = socketPtr(sid)) == NULL) {
-		a_assert(0);
-		return;
-	}
-	sp->flags = mode;
+    if ((sp = socketPtr(sid)) == NULL) {
+        a_assert(0);
+        return;
+    }
+    sp->flags = mode;
 }
 
 
 int socketGetPort(int sid)
 {
-	socket_t	*sp;
+    socket_t    *sp;
 
-	if ((sp = socketPtr(sid)) == NULL) {
-		return -1;
-	}
-	return sp->port;
+    if ((sp = socketPtr(sid)) == NULL) {
+        return -1;
+    }
+    return sp->port;
 }
 
 
diff --git a/sockGen.c b/sockGen.c
index 1e3b8e21..af0c0935 100644
--- a/sockGen.c
+++ b/sockGen.c
@@ -1,5 +1,5 @@
 /*
-  	sockGen.c -- Posix Socket support module for general posix use
+    sockGen.c -- Posix Socket support module for general posix use
 
     Copyright (c) All Rights Reserved. See details at the end of the file.
  */
@@ -12,73 +12,73 @@
 
 #if (!defined (WIN) || defined (LITTLEFOOT) || defined (WEBS))
 #ifndef CE
-#include	<errno.h>
-#include	<fcntl.h>
-#include	<string.h>
-#include	<stdlib.h>
+#include    <errno.h>
+#include    <fcntl.h>
+#include    <string.h>
+#include    <stdlib.h>
 #endif
 
-#include	"uemf.h"
+#include    "uemf.h"
 
 #ifdef VXWORKS
-	#include	<hostLib.h>
+    #include    <hostLib.h>
 #endif
 
 /************************************ Locals **********************************/
 
-extern socket_t		**socketList;			/* List of open sockets */
-extern int			socketMax;				/* Maximum size of socket */
-extern int			socketHighestFd;		/* Highest socket fd opened */
-static int			socketOpenCount = 0;	/* Number of task using sockets */
+extern socket_t     **socketList;           /* List of open sockets */
+extern int          socketMax;              /* Maximum size of socket */
+extern int          socketHighestFd;        /* Highest socket fd opened */
+static int          socketOpenCount = 0;    /* Number of task using sockets */
 
 /***************************** Forward Declarations ***************************/
 
 static void socketAccept(socket_t *sp);
-static int 	socketDoEvent(socket_t *sp);
-static int	tryAlternateConnect(int sock, struct sockaddr *sockaddr);
+static int  socketDoEvent(socket_t *sp);
+static int  tryAlternateConnect(int sock, struct sockaddr *sockaddr);
 
 /*********************************** Code *************************************/
 
 int socketOpen()
 {
 #if (defined (CE) || defined (WIN))
-    WSADATA 	wsaData;
+    WSADATA     wsaData;
 #endif
 
-	if (++socketOpenCount > 1) {
-		return 0;
-	}
+    if (++socketOpenCount > 1) {
+        return 0;
+    }
 
 #if (defined (CE) || defined (WIN))
-	if (WSAStartup(MAKEWORD(1,1), &wsaData) != 0) {
-		return -1;
-	}
-	if (wsaData.wVersion != MAKEWORD(1,1)) {
-		WSACleanup();
-		return -1;
-	}
+    if (WSAStartup(MAKEWORD(1,1), &wsaData) != 0) {
+        return -1;
+    }
+    if (wsaData.wVersion != MAKEWORD(1,1)) {
+        WSACleanup();
+        return -1;
+    }
 #endif
 
-	socketList = NULL;
-	socketMax = 0;
-	socketHighestFd = -1;
+    socketList = NULL;
+    socketMax = 0;
+    socketHighestFd = -1;
 
-	return 0;
+    return 0;
 }
 
 
 void socketClose()
 {
-	int		i;
-
-	if (--socketOpenCount <= 0) {
-		for (i = socketMax; i >= 0; i--) {
-			if (socketList && socketList[i]) {
-				socketCloseConnection(i);
-			}
-		}
-		socketOpenCount = 0;
-	}
+    int     i;
+
+    if (--socketOpenCount <= 0) {
+        for (i = socketMax; i >= 0; i--) {
+            if (socketList && socketList[i]) {
+                socketCloseConnection(i);
+            }
+        }
+        socketOpenCount = 0;
+    }
 }
 
 
@@ -88,178 +88,178 @@ void socketClose()
 int socketOpenConnection(char *host, int port, socketAccept_t accept, int flags)
 {
 #if (!defined (NO_GETHOSTBYNAME) && !defined (VXWORKS))
-	struct hostent		*hostent;					/* Host database entry */
+    struct hostent      *hostent;                   /* Host database entry */
 #endif /* ! (NO_GETHOSTBYNAME || VXWORKS) */
-	socket_t			*sp;
-	struct sockaddr_in	sockaddr;
-	int					sid, bcast, dgram, rc;
-
-	if (port > SOCKET_PORT_MAX) {
-		return -1;
-	}
-	if ((sid = socketAlloc(host, port, accept, flags)) < 0) {
-		return -1;
-	}
-	sp = socketList[sid];
-	a_assert(sp);
-
-	memset((char *) &sockaddr, '\0', sizeof(struct sockaddr_in));
-	sockaddr.sin_family = AF_INET;
-	sockaddr.sin_port = htons((short) (port & 0xFFFF));
-
-	if (host == NULL) {
-		sockaddr.sin_addr.s_addr = INADDR_ANY;
-	} else {
-		sockaddr.sin_addr.s_addr = inet_addr(host);
-		if (sockaddr.sin_addr.s_addr == INADDR_NONE) {
+    socket_t            *sp;
+    struct sockaddr_in  sockaddr;
+    int                 sid, bcast, dgram, rc;
+
+    if (port > SOCKET_PORT_MAX) {
+        return -1;
+    }
+    if ((sid = socketAlloc(host, port, accept, flags)) < 0) {
+        return -1;
+    }
+    sp = socketList[sid];
+    a_assert(sp);
+
+    memset((char *) &sockaddr, '\0', sizeof(struct sockaddr_in));
+    sockaddr.sin_family = AF_INET;
+    sockaddr.sin_port = htons((short) (port & 0xFFFF));
+
+    if (host == NULL) {
+        sockaddr.sin_addr.s_addr = INADDR_ANY;
+    } else {
+        sockaddr.sin_addr.s_addr = inet_addr(host);
+        if (sockaddr.sin_addr.s_addr == INADDR_NONE) {
             /*
                 If the OS does not support gethostbyname functionality, the macro: NO_GETHOSTBYNAME should be defined to
                 skip the use of gethostbyname. Unfortunatly there is no easy way to recover, the following code simply
                 uses the basicGetHost IP for the sockaddr.  
              */
 #ifdef NO_GETHOSTBYNAME
-			if (strcmp(host, basicGetHost()) == 0) {
-				sockaddr.sin_addr.s_addr = inet_addr(basicGetAddress());
-			}
-			if (sockaddr.sin_addr.s_addr == INADDR_NONE) {
-				socketFree(sid);
-				return -1;
-			}
+            if (strcmp(host, basicGetHost()) == 0) {
+                sockaddr.sin_addr.s_addr = inet_addr(basicGetAddress());
+            }
+            if (sockaddr.sin_addr.s_addr == INADDR_NONE) {
+                socketFree(sid);
+                return -1;
+            }
 #elif (defined (VXWORKS))
-			sockaddr.sin_addr.s_addr = (unsigned long) hostGetByName(host);
-			if (sockaddr.sin_addr.s_addr == NULL) {
-				errno = ENXIO;
-				socketFree(sid);
-				return -1;
-			}
+            sockaddr.sin_addr.s_addr = (unsigned long) hostGetByName(host);
+            if (sockaddr.sin_addr.s_addr == NULL) {
+                errno = ENXIO;
+                socketFree(sid);
+                return -1;
+            }
 #else
-			hostent = gethostbyname(host);
-			if (hostent != NULL) {
-				memcpy((char *) &sockaddr.sin_addr, (char *) hostent->h_addr_list[0], (size_t) hostent->h_length);
-			} else {
-				char	*asciiAddress;
-				char_t	*address;
-
-				address = basicGetAddress();
-				asciiAddress = ballocUniToAsc(address, gstrlen(address));
-				sockaddr.sin_addr.s_addr = inet_addr(asciiAddress);
-				bfree(B_L, asciiAddress);
-				if (sockaddr.sin_addr.s_addr == INADDR_NONE) {
-					errno = ENXIO;
-					socketFree(sid);
-					return -1;
-				}
-			}
+            hostent = gethostbyname(host);
+            if (hostent != NULL) {
+                memcpy((char *) &sockaddr.sin_addr, (char *) hostent->h_addr_list[0], (size_t) hostent->h_length);
+            } else {
+                char    *asciiAddress;
+                char_t  *address;
+
+                address = basicGetAddress();
+                asciiAddress = ballocUniToAsc(address, gstrlen(address));
+                sockaddr.sin_addr.s_addr = inet_addr(asciiAddress);
+                bfree(B_L, asciiAddress);
+                if (sockaddr.sin_addr.s_addr == INADDR_NONE) {
+                    errno = ENXIO;
+                    socketFree(sid);
+                    return -1;
+                }
+            }
 #endif /* (NO_GETHOSTBYNAME || VXWORKS) */
-		}
-	}
-	bcast = sp->flags & SOCKET_BROADCAST;
-	if (bcast) {
-		sp->flags |= SOCKET_DATAGRAM;
-	}
-	dgram = sp->flags & SOCKET_DATAGRAM;
+        }
+    }
+    bcast = sp->flags & SOCKET_BROADCAST;
+    if (bcast) {
+        sp->flags |= SOCKET_DATAGRAM;
+    }
+    dgram = sp->flags & SOCKET_DATAGRAM;
 
     /*
-      	Create the socket. Support for datagram sockets. Set the close on exec flag so children don't inherit the socket.
+        Create the socket. Support for datagram sockets. Set the close on exec flag so children don't inherit the socket.
      */
-	sp->sock = socket(AF_INET, dgram ? SOCK_DGRAM: SOCK_STREAM, 0);
-	if (sp->sock < 0) {
-		socketFree(sid);
-		return -1;
-	}
+    sp->sock = socket(AF_INET, dgram ? SOCK_DGRAM: SOCK_STREAM, 0);
+    if (sp->sock < 0) {
+        socketFree(sid);
+        return -1;
+    }
 #ifndef __NO_FCNTL
-	fcntl(sp->sock, F_SETFD, FD_CLOEXEC);
+    fcntl(sp->sock, F_SETFD, FD_CLOEXEC);
 #endif
-	socketHighestFd = max(socketHighestFd, sp->sock);
+    socketHighestFd = max(socketHighestFd, sp->sock);
 
     /*
-      	If broadcast, we need to turn on broadcast capability.
+        If broadcast, we need to turn on broadcast capability.
      */
-	if (bcast) {
-		int broadcastFlag = 1;
-		if (setsockopt(sp->sock, SOL_SOCKET, SO_BROADCAST,
-				(char *) &broadcastFlag, sizeof(broadcastFlag)) < 0) {
-			socketFree(sid);
-			return -1;
-		}
-	}
+    if (bcast) {
+        int broadcastFlag = 1;
+        if (setsockopt(sp->sock, SOL_SOCKET, SO_BROADCAST,
+                (char *) &broadcastFlag, sizeof(broadcastFlag)) < 0) {
+            socketFree(sid);
+            return -1;
+        }
+    }
 
     /*
-      	Host is set if we are the client
+        Host is set if we are the client
      */
-	if (host) {
+    if (host) {
         /*
             Connect to the remote server in blocking mode, then go into non-blocking mode if desired.
          */
-		if (!dgram) {
-			if (! (sp->flags & SOCKET_BLOCK)) {
+        if (!dgram) {
+            if (! (sp->flags & SOCKET_BLOCK)) {
                 /*
                     sockGen.c is only used for Windows products when blocking connects are expected.  This applies to
                     webserver connectws.  Therefore the asynchronous connect code here is not compiled.
                  */
 #if (defined (WIN) || defined (CE)) && (!defined (LITTLEFOOT) && !defined (WEBS))
-				int flag;
+                int flag;
 
-				sp->flags |= SOCKET_ASYNC;
+                sp->flags |= SOCKET_ASYNC;
                 /*
                     Set to non-blocking for an async connect
                  */
-				flag = 1;
-				if (ioctlsocket(sp->sock, FIONBIO, &flag) == SOCKET_ERROR) {
-					socketFree(sid);
-					return -1;
-				}
+                flag = 1;
+                if (ioctlsocket(sp->sock, FIONBIO, &flag) == SOCKET_ERROR) {
+                    socketFree(sid);
+                    return -1;
+                }
 #else
-				socketSetBlock(sid, 1);
+                socketSetBlock(sid, 1);
 #endif /* #if (WIN || CE) && !(LITTLEFOOT || WEBS) */
 
-			}
-			if ((rc = connect(sp->sock, (struct sockaddr *) &sockaddr,
-				sizeof(sockaddr))) < 0 && 
-				(rc = tryAlternateConnect(sp->sock,
-				(struct sockaddr *) &sockaddr)) < 0) {
+            }
+            if ((rc = connect(sp->sock, (struct sockaddr *) &sockaddr,
+                sizeof(sockaddr))) < 0 && 
+                (rc = tryAlternateConnect(sp->sock,
+                (struct sockaddr *) &sockaddr)) < 0) {
 #if (defined (WIN) || defined (CE))
-				if (socketGetError() != EWOULDBLOCK) {
-					socketFree(sid);
-					return -1;
-				}
+                if (socketGetError() != EWOULDBLOCK) {
+                    socketFree(sid);
+                    return -1;
+                }
 #else
-				socketFree(sid);
-				return -1;
+                socketFree(sid);
+                return -1;
 
 #endif /* WIN || CE */
 
-			}
-		}
-	} else {
+            }
+        }
+    } else {
         /*
             Bind to the socket endpoint and the call listen() to start listening
          */
-		rc = 1;
-		setsockopt(sp->sock, SOL_SOCKET, SO_REUSEADDR, (char *)&rc, sizeof(rc));
-		if (bind(sp->sock, (struct sockaddr *) &sockaddr, sizeof(sockaddr)) < 0) {
-			socketFree(sid);
-			return -1;
-		}
-		if (! dgram) {
-			if (listen(sp->sock, SOMAXCONN) < 0) {
-				socketFree(sid);
-				return -1;
-			}
-			sp->flags |= SOCKET_LISTENING;
-		}
-		sp->handlerMask |= SOCKET_READABLE;
-	}
+        rc = 1;
+        setsockopt(sp->sock, SOL_SOCKET, SO_REUSEADDR, (char *)&rc, sizeof(rc));
+        if (bind(sp->sock, (struct sockaddr *) &sockaddr, sizeof(sockaddr)) < 0) {
+            socketFree(sid);
+            return -1;
+        }
+        if (! dgram) {
+            if (listen(sp->sock, SOMAXCONN) < 0) {
+                socketFree(sid);
+                return -1;
+            }
+            sp->flags |= SOCKET_LISTENING;
+        }
+        sp->handlerMask |= SOCKET_READABLE;
+    }
 
     /*
         Set the blocking mode
      */
-	if (flags & SOCKET_BLOCK) {
-		socketSetBlock(sid, 1);
-	} else {
-		socketSetBlock(sid, 0);
-	}
-	return sid;
+    if (flags & SOCKET_BLOCK) {
+        socketSetBlock(sid, 1);
+    } else {
+        socketSetBlock(sid, 0);
+    }
+    return sid;
 }
 
 
@@ -270,88 +270,88 @@ int socketOpenConnection(char *host, int port, socketAccept_t accept, int flags)
 static int tryAlternateConnect(int sock, struct sockaddr *sockaddr)
 {
 #ifdef VXWORKS
-	char *ptr;
+    char *ptr;
 
-	ptr = (char *)sockaddr;
-	*ptr = *(ptr+1);
-	*(ptr+1) = 0;
-	return connect(sock, sockaddr, sizeof(struct sockaddr));
+    ptr = (char *)sockaddr;
+    *ptr = *(ptr+1);
+    *(ptr+1) = 0;
+    return connect(sock, sockaddr, sizeof(struct sockaddr));
 #else
-	return -1;
+    return -1;
 #endif /* VXWORKS */
 }
 
 
 void socketCloseConnection(int sid)
 {
-	socket_t	*sp;
+    socket_t    *sp;
 
-	if ((sp = socketPtr(sid)) == NULL) {
-		return;
-	}
-	socketFree(sid);
+    if ((sp = socketPtr(sid)) == NULL) {
+        return;
+    }
+    socketFree(sid);
 }
 
 
 /*
-  	Accept a connection. Called as a callback on incoming connection.
+    Accept a connection. Called as a callback on incoming connection.
  */
 static void socketAccept(socket_t *sp)
 {
-	struct sockaddr_in	addr;
-	socket_t 			*nsp;
-	size_t				len;
-	char				*pString;
-	int 				newSock, nid;
+    struct sockaddr_in  addr;
+    socket_t            *nsp;
+    size_t              len;
+    char                *pString;
+    int                 newSock, nid;
 
 #ifdef NW
-	NETINET_DEFINE_CONTEXT;
+    NETINET_DEFINE_CONTEXT;
 #endif
 
-	a_assert(sp);
+    a_assert(sp);
 
 /*
- *	Accept the connection and prevent inheriting by children (F_SETFD)
+ *  Accept the connection and prevent inheriting by children (F_SETFD)
  */
-	len = sizeof(struct sockaddr_in);
-	if ((newSock = 
-		accept(sp->sock, (struct sockaddr *) &addr, (socklen_t *) &len)) < 0) {
-		return;
-	}
+    len = sizeof(struct sockaddr_in);
+    if ((newSock = 
+        accept(sp->sock, (struct sockaddr *) &addr, (socklen_t *) &len)) < 0) {
+        return;
+    }
 #ifndef __NO_FCNTL
-	fcntl(newSock, F_SETFD, FD_CLOEXEC);
+    fcntl(newSock, F_SETFD, FD_CLOEXEC);
 #endif
-	socketHighestFd = max(socketHighestFd, newSock);
+    socketHighestFd = max(socketHighestFd, newSock);
 
     /*
-      	Create a socket structure and insert into the socket list
+        Create a socket structure and insert into the socket list
      */
-	nid = socketAlloc(sp->host, sp->port, sp->accept, sp->flags);
-	nsp = socketList[nid];
-	a_assert(nsp);
-	nsp->sock = newSock;
-	nsp->flags &= ~SOCKET_LISTENING;
-
-	if (nsp == NULL) {
-		return;
-	}
+    nid = socketAlloc(sp->host, sp->port, sp->accept, sp->flags);
+    nsp = socketList[nid];
+    a_assert(nsp);
+    nsp->sock = newSock;
+    nsp->flags &= ~SOCKET_LISTENING;
+
+    if (nsp == NULL) {
+        return;
+    }
     /*
-      	Set the blocking mode before calling the accept callback.
+        Set the blocking mode before calling the accept callback.
      */
 
-	socketSetBlock(nid, (nsp->flags & SOCKET_BLOCK) ? 1: 0);
+    socketSetBlock(nid, (nsp->flags & SOCKET_BLOCK) ? 1: 0);
     /*
         Call the user accept callback. The user must call socketCreateHandler to register for further events of interest.
      */
-	if (sp->accept != NULL) {
-		pString = inet_ntoa(addr.sin_addr);
-		if ((sp->accept)(nid, pString, ntohs(addr.sin_port), sp->sid) < 0) {
-			socketFree(nid);
-		}
+    if (sp->accept != NULL) {
+        pString = inet_ntoa(addr.sin_addr);
+        if ((sp->accept)(nid, pString, ntohs(addr.sin_port), sp->sid) < 0) {
+            socketFree(nid);
+        }
 #ifdef VXWORKS
-		free(pString);
+        free(pString);
 #endif
-	}
+    }
 }
 
 
@@ -361,42 +361,42 @@ static void socketAccept(socket_t *sp)
  */
 int socketGetInput(int sid, char *buf, int toRead, int *errCode)
 {
-	struct sockaddr_in 	server;
-	socket_t			*sp;
-	int 				len, bytesRead;
+    struct sockaddr_in  server;
+    socket_t            *sp;
+    int                 len, bytesRead;
 
-	a_assert(buf);
-	a_assert(errCode);
+    a_assert(buf);
+    a_assert(errCode);
 
-	*errCode = 0;
+    *errCode = 0;
 
-	if ((sp = socketPtr(sid)) == NULL) {
-		return -1;
-	}
+    if ((sp = socketPtr(sid)) == NULL) {
+        return -1;
+    }
 
     /*
-      	If we have previously seen an EOF condition, then just return
+        If we have previously seen an EOF condition, then just return
      */
-	if (sp->flags & SOCKET_EOF) {
-		return 0;
-	}
+    if (sp->flags & SOCKET_EOF) {
+        return 0;
+    }
 #if ((defined (WIN) || defined (CE)) && (!defined (LITTLEFOOT) && !defined  (WEBS)))
-	if ( !(sp->flags & SOCKET_BLOCK)
-			&& ! socketWaitForEvent(sp,  FD_CONNECT, errCode)) {
-		return -1;
-	}
+    if ( !(sp->flags & SOCKET_BLOCK)
+            && ! socketWaitForEvent(sp,  FD_CONNECT, errCode)) {
+        return -1;
+    }
 #endif
 
     /*
-      	Read the data
+        Read the data
      */
-	if (sp->flags & SOCKET_DATAGRAM) {
-		len = sizeof(server);
-		bytesRead = recvfrom(sp->sock, buf, toRead, 0,
-			(struct sockaddr *) &server, (socklen_t *) &len);
-	} else {
-		bytesRead = recv(sp->sock, buf, toRead, 0);
-	}
+    if (sp->flags & SOCKET_DATAGRAM) {
+        len = sizeof(server);
+        bytesRead = recvfrom(sp->sock, buf, toRead, 0,
+            (struct sockaddr *) &server, (socklen_t *) &len);
+    } else {
+        bytesRead = recv(sp->sock, buf, toRead, 0);
+    }
     if (bytesRead < 0) {
         *errCode = socketGetError();
         if (*errCode == ECONNRESET) {
@@ -411,8 +411,8 @@ int socketGetInput(int sid, char *buf, int toRead, int *errCode)
 
 void socketRegisterInterest(socket_t *sp, int handlerMask)
 {
-	a_assert(sp);
-	sp->handlerMask = handlerMask;
+    a_assert(sp);
+    sp->handlerMask = handlerMask;
 }
 
 
@@ -421,71 +421,71 @@ void socketRegisterInterest(socket_t *sp, int handlerMask)
  */
 int socketWaitForEvent(socket_t *sp, int handlerMask, int *errCode)
 {
-	int	mask;
-
-	a_assert(sp);
-
-	mask = sp->handlerMask;
-	sp->handlerMask |= handlerMask;
-	while (socketSelect(sp->sid, 1000)) {
-		if (sp->currentEvents & (handlerMask | SOCKET_EXCEPTION)) {
-			break;
-		}
-	}
-	sp->handlerMask = mask;
-	if (sp->currentEvents & SOCKET_EXCEPTION) {
-		return -1;
-	} else if (sp->currentEvents & handlerMask) {
-		return 1;
-	}
-	if (errCode) {
-		*errCode = errno = EWOULDBLOCK;
-	}
-	return 0;
+    int mask;
+
+    a_assert(sp);
+
+    mask = sp->handlerMask;
+    sp->handlerMask |= handlerMask;
+    while (socketSelect(sp->sid, 1000)) {
+        if (sp->currentEvents & (handlerMask | SOCKET_EXCEPTION)) {
+            break;
+        }
+    }
+    sp->handlerMask = mask;
+    if (sp->currentEvents & SOCKET_EXCEPTION) {
+        return -1;
+    } else if (sp->currentEvents & handlerMask) {
+        return 1;
+    }
+    if (errCode) {
+        *errCode = errno = EWOULDBLOCK;
+    }
+    return 0;
 }
 
 
 /*
-  	Return TRUE if there is a socket with an event ready to process,
+    Return TRUE if there is a socket with an event ready to process,
  */
 int socketReady(int sid)
 {
-	socket_t 	*sp;
-	int			all;
-
-	all = 0;
-	if (sid < 0) {
-		sid = 0;
-		all = 1;
-	}
-
-	for (; sid < socketMax; sid++) {
-		if ((sp = socketList[sid]) == NULL) {
-			if (! all) {
-				break;
-			} else {
-				continue;
-			}
-		} 
-		if (sp->flags & SOCKET_CONNRESET) {
-			socketCloseConnection(sid);
-			return 0;
-		}
-		if (sp->currentEvents & sp->handlerMask) {
-			return 1;
-		}
+    socket_t    *sp;
+    int         all;
+
+    all = 0;
+    if (sid < 0) {
+        sid = 0;
+        all = 1;
+    }
+
+    for (; sid < socketMax; sid++) {
+        if ((sp = socketList[sid]) == NULL) {
+            if (! all) {
+                break;
+            } else {
+                continue;
+            }
+        } 
+        if (sp->flags & SOCKET_CONNRESET) {
+            socketCloseConnection(sid);
+            return 0;
+        }
+        if (sp->currentEvents & sp->handlerMask) {
+            return 1;
+        }
         /*
             If there is input data, also call select to test for new events
          */
-		if (sp->handlerMask & SOCKET_READABLE && socketInputBuffered(sid) > 0) {
-			socketSelect(sid, 0);
-			return 1;
-		}
-		if (! all) {
-			break;
-		}
-	}
-	return 0;
+        if (sp->handlerMask & SOCKET_READABLE && socketInputBuffered(sid) > 0) {
+            socketSelect(sid, 0);
+            return 1;
+        }
+        if (! all) {
+            break;
+        }
+    }
+    return 0;
 }
 
 
@@ -496,392 +496,392 @@ int socketReady(int sid)
 
 int socketSelect(int sid, int timeout)
 {
-	struct timeval	tv;
-	socket_t		*sp;
-	fd_set		 	readFds, writeFds, exceptFds;
-	int 			nEvents;
-	int				all, socketHighestFd;	/* Highest socket fd opened */
+    struct timeval  tv;
+    socket_t        *sp;
+    fd_set          readFds, writeFds, exceptFds;
+    int             nEvents;
+    int             all, socketHighestFd;   /* Highest socket fd opened */
 
-	FD_ZERO(&readFds);
-	FD_ZERO(&writeFds);
-	FD_ZERO(&exceptFds);
-	socketHighestFd = -1;
+    FD_ZERO(&readFds);
+    FD_ZERO(&writeFds);
+    FD_ZERO(&exceptFds);
+    socketHighestFd = -1;
 
-	tv.tv_sec = timeout / 1000;
-	tv.tv_usec = (timeout % 1000) * 1000;
+    tv.tv_sec = timeout / 1000;
+    tv.tv_usec = (timeout % 1000) * 1000;
 
     /*
-      	Set the select event masks for events to watch
+        Set the select event masks for events to watch
      */
-	all = nEvents = 0;
-
-	if (sid < 0) {
-		all++;
-		sid = 0;
-	}
-
-	for (; sid < socketMax; sid++) {
-		if ((sp = socketList[sid]) == NULL) {
-			continue;
-		}
-		a_assert(sp);
+    all = nEvents = 0;
+
+    if (sid < 0) {
+        all++;
+        sid = 0;
+    }
+
+    for (; sid < socketMax; sid++) {
+        if ((sp = socketList[sid]) == NULL) {
+            continue;
+        }
+        a_assert(sp);
         /*
-           		Set the appropriate bit in the ready masks for the sp->sock.
+                Set the appropriate bit in the ready masks for the sp->sock.
          */
-		if (sp->handlerMask & SOCKET_READABLE) {
-			FD_SET(sp->sock, &readFds);
-			nEvents++;
-			if (socketInputBuffered(sid) > 0) {
-				tv.tv_sec = 0;
-				tv.tv_usec = 0;
-			}
-		}
-		if (sp->handlerMask & SOCKET_WRITABLE) {
-			FD_SET(sp->sock, &writeFds);
-			nEvents++;
-		}
-		if (sp->handlerMask & SOCKET_EXCEPTION) {
-			FD_SET(sp->sock, &exceptFds);
-			nEvents++;
-		}
-		if (! all) {
-			break;
-		}
-	}
+        if (sp->handlerMask & SOCKET_READABLE) {
+            FD_SET(sp->sock, &readFds);
+            nEvents++;
+            if (socketInputBuffered(sid) > 0) {
+                tv.tv_sec = 0;
+                tv.tv_usec = 0;
+            }
+        }
+        if (sp->handlerMask & SOCKET_WRITABLE) {
+            FD_SET(sp->sock, &writeFds);
+            nEvents++;
+        }
+        if (sp->handlerMask & SOCKET_EXCEPTION) {
+            FD_SET(sp->sock, &exceptFds);
+            nEvents++;
+        }
+        if (! all) {
+            break;
+        }
+    }
 
     /*
         Windows select() fails if no descriptors are set, instead of just sleeping like other, nice select() calls. So,
         if WIN, sleep.  
      */
-	if (nEvents == 0) {
-		Sleep(timeout);
-		return 0;
-	}
+    if (nEvents == 0) {
+        Sleep(timeout);
+        return 0;
+    }
 
     /*
-       	Wait for the event or a timeout.
+        Wait for the event or a timeout.
      */
-	nEvents = select(socketHighestFd+1, &readFds, &writeFds, &exceptFds, &tv);
-
-	if (all) {
-		sid = 0;
-	}
-	for (; sid < socketMax; sid++) {
-		if ((sp = socketList[sid]) == NULL) {
-			continue;
-		}
-
-		if (FD_ISSET(sp->sock, &readFds) || socketInputBuffered(sid) > 0) {
-				sp->currentEvents |= SOCKET_READABLE;
-		}
-		if (FD_ISSET(sp->sock, &writeFds)) {
-				sp->currentEvents |= SOCKET_WRITABLE;
-		}
-		if (FD_ISSET(sp->sock, &exceptFds)) {
-				sp->currentEvents |= SOCKET_EXCEPTION;
-		}
-		if (! all) {
-			break;
-		}
-	}
-
-	return nEvents;
+    nEvents = select(socketHighestFd+1, &readFds, &writeFds, &exceptFds, &tv);
+
+    if (all) {
+        sid = 0;
+    }
+    for (; sid < socketMax; sid++) {
+        if ((sp = socketList[sid]) == NULL) {
+            continue;
+        }
+
+        if (FD_ISSET(sp->sock, &readFds) || socketInputBuffered(sid) > 0) {
+                sp->currentEvents |= SOCKET_READABLE;
+        }
+        if (FD_ISSET(sp->sock, &writeFds)) {
+                sp->currentEvents |= SOCKET_WRITABLE;
+        }
+        if (FD_ISSET(sp->sock, &exceptFds)) {
+                sp->currentEvents |= SOCKET_EXCEPTION;
+        }
+        if (! all) {
+            break;
+        }
+    }
+
+    return nEvents;
 }
 
 #else /* not WIN || CE || NW */
 
 int socketSelect(int sid, int timeout)
 {
-	socket_t		*sp;
-	struct timeval	tv;
-	fd_mask 		*readFds, *writeFds, *exceptFds;
-	int 			all, len, nwords, index, bit, nEvents;
+    socket_t        *sp;
+    struct timeval  tv;
+    fd_mask         *readFds, *writeFds, *exceptFds;
+    int             all, len, nwords, index, bit, nEvents;
 
     /*
-      	Allocate and zero the select masks
+        Allocate and zero the select masks
      */
-	nwords = (socketHighestFd + NFDBITS) / NFDBITS;
-	len = nwords * sizeof(fd_mask);
+    nwords = (socketHighestFd + NFDBITS) / NFDBITS;
+    len = nwords * sizeof(fd_mask);
 
-	readFds = balloc(B_L, len);
-	memset(readFds, 0, len);
-	writeFds = balloc(B_L, len);
-	memset(writeFds, 0, len);
-	exceptFds = balloc(B_L, len);
-	memset(exceptFds, 0, len);
+    readFds = balloc(B_L, len);
+    memset(readFds, 0, len);
+    writeFds = balloc(B_L, len);
+    memset(writeFds, 0, len);
+    exceptFds = balloc(B_L, len);
+    memset(exceptFds, 0, len);
 
-	tv.tv_sec = timeout / 1000;
-	tv.tv_usec = (timeout % 1000) * 1000;
+    tv.tv_sec = timeout / 1000;
+    tv.tv_usec = (timeout % 1000) * 1000;
 
     /*
-      	Set the select event masks for events to watch
+        Set the select event masks for events to watch
      */
-	all = nEvents = 0;
-
-	if (sid < 0) {
-		all++;
-		sid = 0;
-	}
-
-	for (; sid < socketMax; sid++) {
-		if ((sp = socketList[sid]) == NULL) {
-			if (all == 0) {
-				break;
-			} else {
-				continue;
-			}
-		}
-		a_assert(sp);
+    all = nEvents = 0;
+
+    if (sid < 0) {
+        all++;
+        sid = 0;
+    }
+
+    for (; sid < socketMax; sid++) {
+        if ((sp = socketList[sid]) == NULL) {
+            if (all == 0) {
+                break;
+            } else {
+                continue;
+            }
+        }
+        a_assert(sp);
 
         /*
-           		Initialize the ready masks and compute the mask offsets.
+                Initialize the ready masks and compute the mask offsets.
          */
-		index = sp->sock / (NBBY * sizeof(fd_mask));
-		bit = 1 << (sp->sock % (NBBY * sizeof(fd_mask)));
-		
+        index = sp->sock / (NBBY * sizeof(fd_mask));
+        bit = 1 << (sp->sock % (NBBY * sizeof(fd_mask)));
+        
         /*
             Set the appropriate bit in the ready masks for the sp->sock.
          */
-		if (sp->handlerMask & SOCKET_READABLE) {
-			readFds[index] |= bit;
-			nEvents++;
-			if (socketInputBuffered(sid) > 0) {
-				tv.tv_sec = 0;
-				tv.tv_usec = 0;
-			}
-		}
-		if (sp->handlerMask & SOCKET_WRITABLE) {
-			writeFds[index] |= bit;
-			nEvents++;
-		}
-		if (sp->handlerMask & SOCKET_EXCEPTION) {
-			exceptFds[index] |= bit;
-			nEvents++;
-		}
-		if (! all) {
-			break;
-		}
-	}
+        if (sp->handlerMask & SOCKET_READABLE) {
+            readFds[index] |= bit;
+            nEvents++;
+            if (socketInputBuffered(sid) > 0) {
+                tv.tv_sec = 0;
+                tv.tv_usec = 0;
+            }
+        }
+        if (sp->handlerMask & SOCKET_WRITABLE) {
+            writeFds[index] |= bit;
+            nEvents++;
+        }
+        if (sp->handlerMask & SOCKET_EXCEPTION) {
+            exceptFds[index] |= bit;
+            nEvents++;
+        }
+        if (! all) {
+            break;
+        }
+    }
 
     /*
         Wait for the event or a timeout. Reset nEvents to be the number of actual events now.
      */
-	nEvents = select(socketHighestFd + 1, (fd_set *) readFds, (fd_set *) writeFds, (fd_set *) exceptFds, &tv);
-
-	if (nEvents > 0) {
-		if (all) {
-			sid = 0;
-		}
-		for (; sid < socketMax; sid++) {
-			if ((sp = socketList[sid]) == NULL) {
-				if (all == 0) {
-					break;
-				} else {
-					continue;
-				}
-			}
-			index = sp->sock / (NBBY * sizeof(fd_mask));
-			bit = 1 << (sp->sock % (NBBY * sizeof(fd_mask)));
-
-			if (readFds[index] & bit || socketInputBuffered(sid) > 0) {
-				sp->currentEvents |= SOCKET_READABLE;
-			}
-			if (writeFds[index] & bit) {
-				sp->currentEvents |= SOCKET_WRITABLE;
-			}
-			if (exceptFds[index] & bit) {
-				sp->currentEvents |= SOCKET_EXCEPTION;
-			}
-			if (! all) {
-				break;
-			}
-		}
-	}
-	bfree(B_L, readFds);
-	bfree(B_L, writeFds);
-	bfree(B_L, exceptFds);
-	return nEvents;
+    nEvents = select(socketHighestFd + 1, (fd_set *) readFds, (fd_set *) writeFds, (fd_set *) exceptFds, &tv);
+
+    if (nEvents > 0) {
+        if (all) {
+            sid = 0;
+        }
+        for (; sid < socketMax; sid++) {
+            if ((sp = socketList[sid]) == NULL) {
+                if (all == 0) {
+                    break;
+                } else {
+                    continue;
+                }
+            }
+            index = sp->sock / (NBBY * sizeof(fd_mask));
+            bit = 1 << (sp->sock % (NBBY * sizeof(fd_mask)));
+
+            if (readFds[index] & bit || socketInputBuffered(sid) > 0) {
+                sp->currentEvents |= SOCKET_READABLE;
+            }
+            if (writeFds[index] & bit) {
+                sp->currentEvents |= SOCKET_WRITABLE;
+            }
+            if (exceptFds[index] & bit) {
+                sp->currentEvents |= SOCKET_EXCEPTION;
+            }
+            if (! all) {
+                break;
+            }
+        }
+    }
+    bfree(B_L, readFds);
+    bfree(B_L, writeFds);
+    bfree(B_L, exceptFds);
+    return nEvents;
 }
 #endif /* WIN || CE */
 
 
 void socketProcess(int sid)
 {
-	socket_t	*sp;
-	int			all;
-
-	all = 0;
-	if (sid < 0) {
-		all = 1;
-		sid = 0;
-	}
-	for (; sid < socketMax; sid++) {
-		if ((sp = socketList[sid]) == NULL) {
-			if (! all) {
-				break;
-			} else {
-				continue;
-			}
-		}
-		if (socketReady(sid)) {
-			socketDoEvent(sp);
-		}
-		if (! all) {
-			break;
-		}
-	}
+    socket_t    *sp;
+    int         all;
+
+    all = 0;
+    if (sid < 0) {
+        all = 1;
+        sid = 0;
+    }
+    for (; sid < socketMax; sid++) {
+        if ((sp = socketList[sid]) == NULL) {
+            if (! all) {
+                break;
+            } else {
+                continue;
+            }
+        }
+        if (socketReady(sid)) {
+            socketDoEvent(sp);
+        }
+        if (! all) {
+            break;
+        }
+    }
 }
 
 
 static int socketDoEvent(socket_t *sp)
 {
-	ringq_t		*rq;
-	int 		sid;
+    ringq_t     *rq;
+    int         sid;
 
-	a_assert(sp);
+    a_assert(sp);
 
-	sid = sp->sid;
-	if (sp->currentEvents & SOCKET_READABLE) {
-		if (sp->flags & SOCKET_LISTENING) { 
-			socketAccept(sp);
-			sp->currentEvents = 0;
-			return 1;
-		} 
+    sid = sp->sid;
+    if (sp->currentEvents & SOCKET_READABLE) {
+        if (sp->flags & SOCKET_LISTENING) { 
+            socketAccept(sp);
+            sp->currentEvents = 0;
+            return 1;
+        } 
 
-	} else {
+    } else {
         /*
              If there is still read data in the buffers, trigger the read handler
              NOTE: this may busy spin if the read handler doesn't read the data
          */
-		if (sp->handlerMask & SOCKET_READABLE && socketInputBuffered(sid) > 0) {
-			sp->currentEvents |= SOCKET_READABLE;
-		}
-	}
+        if (sp->handlerMask & SOCKET_READABLE && socketInputBuffered(sid) > 0) {
+            sp->currentEvents |= SOCKET_READABLE;
+        }
+    }
     /*
-      	If now writable and flushing in the background, continue flushing
+        If now writable and flushing in the background, continue flushing
      */
-	if (sp->currentEvents & SOCKET_WRITABLE) {
-		if (sp->flags & SOCKET_FLUSHING) {
-			rq = &sp->outBuf;
-			if (ringqLen(rq) > 0) {
-				socketFlush(sp->sid);
-			} else {
-				sp->flags &= ~SOCKET_FLUSHING;
-			}
-		}
-	}
+    if (sp->currentEvents & SOCKET_WRITABLE) {
+        if (sp->flags & SOCKET_FLUSHING) {
+            rq = &sp->outBuf;
+            if (ringqLen(rq) > 0) {
+                socketFlush(sp->sid);
+            } else {
+                sp->flags &= ~SOCKET_FLUSHING;
+            }
+        }
+    }
 
     /*
-      	Now invoke the users socket handler. NOTE: the handler may delete the
-      	socket, so we must be very careful after calling the handler.
+        Now invoke the users socket handler. NOTE: the handler may delete the
+        socket, so we must be very careful after calling the handler.
      */
-	if (sp->handler && (sp->handlerMask & sp->currentEvents)) {
-		(sp->handler)(sid, sp->handlerMask & sp->currentEvents, sp->handler_data);
+    if (sp->handler && (sp->handlerMask & sp->currentEvents)) {
+        (sp->handler)(sid, sp->handlerMask & sp->currentEvents, sp->handler_data);
         /*
             Make sure socket pointer is still valid, then reset the currentEvents.
          */ 
-		if (socketList && sid < socketMax && socketList[sid] == sp) {
-			sp->currentEvents = 0;
-		}
-	}
-	return 1;
+        if (socketList && sid < socketMax && socketList[sid] == sp) {
+            sp->currentEvents = 0;
+        }
+    }
+    return 1;
 }
 
 
 /*
-  	Set the socket blocking mode
+    Set the socket blocking mode
  */
 int socketSetBlock(int sid, int on)
 {
-	socket_t		*sp;
-	unsigned long	flag;
-	int				iflag;
-	int				oldBlock;
-
-	flag = iflag = !on;
-
-	if ((sp = socketPtr(sid)) == NULL) {
-		a_assert(0);
-		return 0;
-	}
-	oldBlock = (sp->flags & SOCKET_BLOCK);
-	sp->flags &= ~(SOCKET_BLOCK);
-	if (on) {
-		sp->flags |= SOCKET_BLOCK;
-	}
+    socket_t        *sp;
+    unsigned long   flag;
+    int             iflag;
+    int             oldBlock;
+
+    flag = iflag = !on;
+
+    if ((sp = socketPtr(sid)) == NULL) {
+        a_assert(0);
+        return 0;
+    }
+    oldBlock = (sp->flags & SOCKET_BLOCK);
+    sp->flags &= ~(SOCKET_BLOCK);
+    if (on) {
+        sp->flags |= SOCKET_BLOCK;
+    }
     /*
-      	Put the socket into block / non-blocking mode
+        Put the socket into block / non-blocking mode
      */
-	if (sp->flags & SOCKET_BLOCK) {
+    if (sp->flags & SOCKET_BLOCK) {
 #if (defined (CE) || defined (WIN))
-		ioctlsocket(sp->sock, FIONBIO, &flag);
+        ioctlsocket(sp->sock, FIONBIO, &flag);
 #elif (defined (ECOS))
-		int off;
-		off = 0;
-		ioctl(sp->sock, FIONBIO, &off);
+        int off;
+        off = 0;
+        ioctl(sp->sock, FIONBIO, &off);
 #elif (defined (VXWORKS) || defined (NW))
-		ioctl(sp->sock, FIONBIO, (int)&iflag);
+        ioctl(sp->sock, FIONBIO, (int)&iflag);
 #else
-		fcntl(sp->sock, F_SETFL, fcntl(sp->sock, F_GETFL) & ~O_NONBLOCK);
+        fcntl(sp->sock, F_SETFL, fcntl(sp->sock, F_GETFL) & ~O_NONBLOCK);
 #endif
 
-	} else {
+    } else {
 #if (defined (CE) || defined (WIN))
-		ioctlsocket(sp->sock, FIONBIO, &flag);
+        ioctlsocket(sp->sock, FIONBIO, &flag);
 #elif (defined (ECOS))
-		int on;
-		on = 1;
-		ioctl(sp->sock, FIONBIO, &on);
+        int on;
+        on = 1;
+        ioctl(sp->sock, FIONBIO, &on);
 #elif (defined (VXWORKS) || defined (NW))
-		ioctl(sp->sock, FIONBIO, (int)&iflag);
+        ioctl(sp->sock, FIONBIO, (int)&iflag);
 #else
-		fcntl(sp->sock, F_SETFL, fcntl(sp->sock, F_GETFL) | O_NONBLOCK);
+        fcntl(sp->sock, F_SETFL, fcntl(sp->sock, F_GETFL) | O_NONBLOCK);
 #endif
-	}
-	/* Prevent SIGPIPE when writing to closed socket on OS X */
+    }
+    /* Prevent SIGPIPE when writing to closed socket on OS X */
 #ifdef MACOSX
-	iflag = 1;
-	setsockopt(sp->sock, SOL_SOCKET, SO_NOSIGPIPE, (void *)&iflag, sizeof(iflag));
+    iflag = 1;
+    setsockopt(sp->sock, SOL_SOCKET, SO_NOSIGPIPE, (void *)&iflag, sizeof(iflag));
 #endif
-	return oldBlock;
+    return oldBlock;
 }
 
 
 /*
-  	Return true if a readable socket has buffered data. - not public
+    Return true if a readable socket has buffered data. - not public
  */
 int socketDontBlock()
 {
-	socket_t	*sp;
-	int			i;
-
-	for (i = 0; i < socketMax; i++) {
-		if ((sp = socketList[i]) == NULL || (sp->handlerMask & SOCKET_READABLE) == 0) {
-			continue;
-		}
-		if (socketInputBuffered(i) > 0) {
-			return 1;
-		}
-	}
-	return 0;
+    socket_t    *sp;
+    int         i;
+
+    for (i = 0; i < socketMax; i++) {
+        if ((sp = socketList[i]) == NULL || (sp->handlerMask & SOCKET_READABLE) == 0) {
+            continue;
+        }
+        if (socketInputBuffered(i) > 0) {
+            return 1;
+        }
+    }
+    return 0;
 }
 
 
 /*
-  	Return true if a particular socket buffered data. - not public
+    Return true if a particular socket buffered data. - not public
  */
 int socketSockBuffered(int sock)
 {
-	socket_t	*sp;
-	int			i;
-
-	for (i = 0; i < socketMax; i++) {
-		if ((sp = socketList[i]) == NULL || sp->sock != sock) {
-			continue;
-		}
-		return socketInputBuffered(i);
-	}
-	return 0;
+    socket_t    *sp;
+    int         i;
+
+    for (i = 0; i < socketMax; i++) {
+        if ((sp = socketList[i]) == NULL || sp->sock != sock) {
+            continue;
+        }
+        return socketInputBuffered(i);
+    }
+    return 0;
 }
 
 #endif /* (!WIN) | LITTLEFOOT | WEBS */
diff --git a/sym.c b/sym.c
index 4dfb8551..15d789e7 100644
--- a/sym.c
+++ b/sym.c
@@ -10,89 +10,89 @@
 
 /********************************* Includes ***********************************/
 
-#include	"uemf.h"
+#include    "uemf.h"
 
 /********************************* Defines ************************************/
 
-typedef struct {						/* Symbol table descriptor */
-	int		inuse;						/* Is this entry in use */
-	int		hash_size;					/* Size of the table below */
-	sym_t	**hash_table;				/* Allocated at run time */
+typedef struct {                        /* Symbol table descriptor */
+    int     inuse;                      /* Is this entry in use */
+    int     hash_size;                  /* Size of the table below */
+    sym_t   **hash_table;               /* Allocated at run time */
 } sym_tabent_t;
 
 /********************************* Globals ************************************/
 
-static sym_tabent_t	**sym;				/* List of symbol tables */
-static int			symMax;				/* One past the max symbol table */
-static int			symOpenCount = 0;	/* Count of apps using sym */
+static sym_tabent_t **sym;              /* List of symbol tables */
+static int          symMax;             /* One past the max symbol table */
+static int          symOpenCount = 0;   /* Count of apps using sym */
 
-static int			htIndex;			/* Current location in table */
-static sym_t*		next;				/* Next symbol in iteration */
+static int          htIndex;            /* Current location in table */
+static sym_t*       next;               /* Next symbol in iteration */
 
 /**************************** Forward Declarations ****************************/
 
-static int		hashIndex(sym_tabent_t *tp, char_t *name);
-static sym_t	*hash(sym_tabent_t *tp, char_t *name);
-static int		calcPrime(int size);
+static int      hashIndex(sym_tabent_t *tp, char_t *name);
+static sym_t    *hash(sym_tabent_t *tp, char_t *name);
+static int      calcPrime(int size);
 
 /*********************************** Code *************************************/
 
 int symSubOpen()
 {
     //  MOB - why keep count?
-	if (++symOpenCount == 1) {
-		symMax = 0;
-		sym = NULL;
-	}
-	return 0;
+    if (++symOpenCount == 1) {
+        symMax = 0;
+        sym = NULL;
+    }
+    return 0;
 }
 
 
 void symSubClose()
 {
-	if (--symOpenCount <= 0) {
-		symOpenCount = 0;
-	}
+    if (--symOpenCount <= 0) {
+        symOpenCount = 0;
+    }
 }
 
 
 sym_fd_t symOpen(int hash_size)
 {
-	sym_fd_t		sd;
-	sym_tabent_t	*tp;
+    sym_fd_t        sd;
+    sym_tabent_t    *tp;
 
-	a_assert(hash_size > 2);
+    a_assert(hash_size > 2);
 
     /*
-      	Create a new handle for this symbol table
+        Create a new handle for this symbol table
      */
-	if ((sd = hAlloc((void***) &sym)) < 0) {
-		return -1;
-	}
+    if ((sd = hAlloc((void***) &sym)) < 0) {
+        return -1;
+    }
 
     /*
-      	Create a new symbol table structure and zero
+        Create a new symbol table structure and zero
      */
-	if ((tp = (sym_tabent_t*) balloc(B_L, sizeof(sym_tabent_t))) == NULL) {
-		symMax = hFree((void***) &sym, sd);
-		return -1;
-	}
-	memset(tp, 0, sizeof(sym_tabent_t));
-	if (sd >= symMax) {
-		symMax = sd + 1;
-	}
-	a_assert(0 <= sd && sd < symMax);
-	sym[sd] = tp;
+    if ((tp = (sym_tabent_t*) balloc(B_L, sizeof(sym_tabent_t))) == NULL) {
+        symMax = hFree((void***) &sym, sd);
+        return -1;
+    }
+    memset(tp, 0, sizeof(sym_tabent_t));
+    if (sd >= symMax) {
+        symMax = sd + 1;
+    }
+    a_assert(0 <= sd && sd < symMax);
+    sym[sd] = tp;
 
     /*
-      	Now create the hash table for fast indexing.
+        Now create the hash table for fast indexing.
      */
-	tp->hash_size = calcPrime(hash_size);
-	tp->hash_table = (sym_t**) balloc(B_L, tp->hash_size * sizeof(sym_t*));
-	a_assert(tp->hash_table);
-	memset(tp->hash_table, 0, tp->hash_size * sizeof(sym_t*));
+    tp->hash_size = calcPrime(hash_size);
+    tp->hash_table = (sym_t**) balloc(B_L, tp->hash_size * sizeof(sym_t*));
+    a_assert(tp->hash_table);
+    memset(tp->hash_table, 0, tp->hash_size * sizeof(sym_t*));
 
-	return sd;
+    return sd;
 }
 
 
@@ -102,29 +102,29 @@ sym_fd_t symOpen(int hash_size)
  */
 void symClose(sym_fd_t sd)
 {
-	sym_tabent_t	*tp;
-	sym_t			*sp, *forw;
-	int				i;
+    sym_tabent_t    *tp;
+    sym_t           *sp, *forw;
+    int             i;
 
-	a_assert(0 <= sd && sd < symMax);
-	tp = sym[sd];
-	a_assert(tp);
+    a_assert(0 <= sd && sd < symMax);
+    tp = sym[sd];
+    a_assert(tp);
 
     /*
-      	Free all symbols in the hash table, then the hash table itself.
+        Free all symbols in the hash table, then the hash table itself.
      */
-	for (i = 0; i < tp->hash_size; i++) {
-		for (sp = tp->hash_table[i]; sp; sp = forw) {
-			forw = sp->forw;
-			valueFree(&sp->name);
-			valueFree(&sp->content);
-			bfree(B_L, (void*) sp);
-			sp = forw;
-		}
-	}
-	bfree(B_L, (void*) tp->hash_table);
-	symMax = hFree((void***) &sym, sd);
-	bfree(B_L, (void*) tp);
+    for (i = 0; i < tp->hash_size; i++) {
+        for (sp = tp->hash_table[i]; sp; sp = forw) {
+            forw = sp->forw;
+            valueFree(&sp->name);
+            valueFree(&sp->content);
+            bfree(B_L, (void*) sp);
+            sp = forw;
+        }
+    }
+    bfree(B_L, (void*) tp->hash_table);
+    symMax = hFree((void***) &sym, sd);
+    bfree(B_L, (void*) tp);
 }
 
 
@@ -134,98 +134,98 @@ void symClose(sym_fd_t sd)
  */
 sym_t* symFirst(sym_fd_t sd)
 {
-	sym_tabent_t	*tp;
-	sym_t			*sp, *forw;
-	int				i;
+    sym_tabent_t    *tp;
+    sym_t           *sp, *forw;
+    int             i;
 
-	a_assert(0 <= sd && sd < symMax);
-	tp = sym[sd];
-	a_assert(tp);
+    a_assert(0 <= sd && sd < symMax);
+    tp = sym[sd];
+    a_assert(tp);
 
     /*
-      	Find the first symbol in the hashtable and return a pointer to it.
+        Find the first symbol in the hashtable and return a pointer to it.
      */
-	for (i = 0; i < tp->hash_size; i++) {
-		for (sp = tp->hash_table[i]; sp; sp = forw) {
-			forw = sp->forw;
-
-			if (forw == NULL) {
-				htIndex = i + 1;
-				next = tp->hash_table[htIndex];
-			} else {
-				htIndex = i;
-				next = forw;
-			}
-			return sp;
-		}
-	}
-	return NULL;
+    for (i = 0; i < tp->hash_size; i++) {
+        for (sp = tp->hash_table[i]; sp; sp = forw) {
+            forw = sp->forw;
+
+            if (forw == NULL) {
+                htIndex = i + 1;
+                next = tp->hash_table[htIndex];
+            } else {
+                htIndex = i;
+                next = forw;
+            }
+            return sp;
+        }
+    }
+    return NULL;
 }
 
 
 /*
-  	Return the next symbol in the hashtable if there is one. See symFirst.
+    Return the next symbol in the hashtable if there is one. See symFirst.
  */
 sym_t* symNext(sym_fd_t sd)
 {
-	sym_tabent_t	*tp;
-	sym_t			*sp, *forw;
-	int				i;
+    sym_tabent_t    *tp;
+    sym_t           *sp, *forw;
+    int             i;
 
-	a_assert(0 <= sd && sd < symMax);
-	tp = sym[sd];
-	a_assert(tp);
+    a_assert(0 <= sd && sd < symMax);
+    tp = sym[sd];
+    a_assert(tp);
 
     /*
-      	Find the first symbol in the hashtable and return a pointer to it.
+        Find the first symbol in the hashtable and return a pointer to it.
      */
-	for (i = htIndex; i < tp->hash_size; i++) {
-		for (sp = next; sp; sp = forw) {
-			forw = sp->forw;
-
-			if (forw == NULL) {
-				htIndex = i + 1;
-				next = tp->hash_table[htIndex];
-			} else {
-				htIndex = i;
-				next = forw;
-			}
-			return sp;
-		}
-		next = tp->hash_table[i + 1];
-	}
-	return NULL;
+    for (i = htIndex; i < tp->hash_size; i++) {
+        for (sp = next; sp; sp = forw) {
+            forw = sp->forw;
+
+            if (forw == NULL) {
+                htIndex = i + 1;
+                next = tp->hash_table[htIndex];
+            } else {
+                htIndex = i;
+                next = forw;
+            }
+            return sp;
+        }
+        next = tp->hash_table[i + 1];
+    }
+    return NULL;
 }
 
 
 /*
-  	Lookup a symbol and return a pointer to the symbol entry. If not present then return a NULL.
+    Lookup a symbol and return a pointer to the symbol entry. If not present then return a NULL.
  */
 sym_t *symLookup(sym_fd_t sd, char_t *name)
 {
-	sym_tabent_t	*tp;
-	sym_t			*sp;
-	char_t			*cp;
+    sym_tabent_t    *tp;
+    sym_t           *sp;
+    char_t          *cp;
 
-	a_assert(0 <= sd && sd < symMax);
-	if ((tp = sym[sd]) == NULL) {
-		return NULL;
-	}
+    a_assert(0 <= sd && sd < symMax);
+    if ((tp = sym[sd]) == NULL) {
+        return NULL;
+    }
 
-	if (name == NULL || *name == '\0') {
-		return NULL;
-	}
+    if (name == NULL || *name == '\0') {
+        return NULL;
+    }
 
     /*
-      	Do an initial hash and then follow the link chain to find the right entry
+        Do an initial hash and then follow the link chain to find the right entry
      */
-	for (sp = hash(tp, name); sp; sp = sp->forw) {
-		cp = sp->name.value.string;
-		if (cp[0] == name[0] && gstrcmp(cp, name) == 0) {
-			break;
-		}
-	}
-	return sp;
+    for (sp = hash(tp, name); sp; sp = sp->forw) {
+        cp = sp->name.value.string;
+        if (cp[0] == name[0] && gstrcmp(cp, name) == 0) {
+            break;
+        }
+    }
+    return sp;
 }
 
 
@@ -236,124 +236,124 @@ sym_t *symLookup(sym_fd_t sd, char_t *name)
  */
 sym_t *symEnter(sym_fd_t sd, char_t *name, value_t v, int arg)
 {
-	sym_tabent_t	*tp;
-	sym_t			*sp, *last;
-	char_t			*cp;
-	int				hindex;
+    sym_tabent_t    *tp;
+    sym_t           *sp, *last;
+    char_t          *cp;
+    int             hindex;
 
-	a_assert(name);
-	a_assert(0 <= sd && sd < symMax);
-	tp = sym[sd];
-	a_assert(tp);
+    a_assert(name);
+    a_assert(0 <= sd && sd < symMax);
+    tp = sym[sd];
+    a_assert(tp);
 
     /*
         Calculate the first daisy-chain from the hash table. If non-zero, then we have daisy-chain, so scan it and look
         for the symbol.  
      */
-	last = NULL;
-	hindex = hashIndex(tp, name);
-	if ((sp = tp->hash_table[hindex]) != NULL) {
-		for (; sp; sp = sp->forw) {
-			cp = sp->name.value.string;
-			if (cp[0] == name[0] && gstrcmp(cp, name) == 0) {
-				break;
-			}
-			last = sp;
-		}
-		if (sp) {
+    last = NULL;
+    hindex = hashIndex(tp, name);
+    if ((sp = tp->hash_table[hindex]) != NULL) {
+        for (; sp; sp = sp->forw) {
+            cp = sp->name.value.string;
+            if (cp[0] == name[0] && gstrcmp(cp, name) == 0) {
+                break;
+            }
+            last = sp;
+        }
+        if (sp) {
             /*
                 Found, so update the value If the caller stores handles which require freeing, they will be lost here.
                 It is the callers responsibility to free resources before overwriting existing contents. We will here
                 free allocated strings which occur due to value_instring().  We should consider providing the cleanup
                 function on the open rather than the close and then we could call it here and solve the problem.
              */
-			if (sp->content.valid) {
-				valueFree(&sp->content);
-			}
-			sp->content = v;
-			sp->arg = arg;
-			return sp;
-		}
+            if (sp->content.valid) {
+                valueFree(&sp->content);
+            }
+            sp->content = v;
+            sp->arg = arg;
+            return sp;
+        }
         /*
             Not found so allocate and append to the daisy-chain
          */
-		sp = (sym_t*) balloc(B_L, sizeof(sym_t));
-		if (sp == NULL) {
-			return NULL;
-		}
-		sp->name = valueString(name, VALUE_ALLOCATE);
-		sp->content = v;
-		sp->forw = (sym_t*) NULL;
-		sp->arg = arg;
-		last->forw = sp;
-
-	} else {
+        sp = (sym_t*) balloc(B_L, sizeof(sym_t));
+        if (sp == NULL) {
+            return NULL;
+        }
+        sp->name = valueString(name, VALUE_ALLOCATE);
+        sp->content = v;
+        sp->forw = (sym_t*) NULL;
+        sp->arg = arg;
+        last->forw = sp;
+
+    } else {
         /*
             Daisy chain is empty so we need to start the chain
          */
-		sp = (sym_t*) balloc(B_L, sizeof(sym_t));
-		if (sp == NULL) {
-			return NULL;
-		}
-		tp->hash_table[hindex] = sp;
-		tp->hash_table[hashIndex(tp, name)] = sp;
-
-		sp->forw = (sym_t*) NULL;
-		sp->content = v;
-		sp->arg = arg;
-		sp->name = valueString(name, VALUE_ALLOCATE);
-	}
-	return sp;
+        sp = (sym_t*) balloc(B_L, sizeof(sym_t));
+        if (sp == NULL) {
+            return NULL;
+        }
+        tp->hash_table[hindex] = sp;
+        tp->hash_table[hashIndex(tp, name)] = sp;
+
+        sp->forw = (sym_t*) NULL;
+        sp->content = v;
+        sp->arg = arg;
+        sp->name = valueString(name, VALUE_ALLOCATE);
+    }
+    return sp;
 }
 
 
 /*
-  	Delete a symbol from a table
+    Delete a symbol from a table
  */
 int symDelete(sym_fd_t sd, char_t *name)
 {
-	sym_tabent_t	*tp;
-	sym_t			*sp, *last;
-	char_t			*cp;
-	int				hindex;
+    sym_tabent_t    *tp;
+    sym_t           *sp, *last;
+    char_t          *cp;
+    int             hindex;
 
-	a_assert(name && *name);
-	a_assert(0 <= sd && sd < symMax);
-	tp = sym[sd];
-	a_assert(tp);
+    a_assert(name && *name);
+    a_assert(0 <= sd && sd < symMax);
+    tp = sym[sd];
+    a_assert(tp);
 
     /*
         Calculate the first daisy-chain from the hash table. If non-zero, then we have daisy-chain, so scan it and look
         for the symbol.  
      */
-	last = NULL;
-	hindex = hashIndex(tp, name);
-	if ((sp = tp->hash_table[hindex]) != NULL) {
-		for ( ; sp; sp = sp->forw) {
-			cp = sp->name.value.string;
-			if (cp[0] == name[0] && gstrcmp(cp, name) == 0) {
-				break;
-			}
-			last = sp;
-		}
-	}
-	if (sp == (sym_t*) NULL) {				/* Not Found */
-		return -1;
-	}
+    last = NULL;
+    hindex = hashIndex(tp, name);
+    if ((sp = tp->hash_table[hindex]) != NULL) {
+        for ( ; sp; sp = sp->forw) {
+            cp = sp->name.value.string;
+            if (cp[0] == name[0] && gstrcmp(cp, name) == 0) {
+                break;
+            }
+            last = sp;
+        }
+    }
+    if (sp == (sym_t*) NULL) {              /* Not Found */
+        return -1;
+    }
 
     /*
          Unlink and free the symbol. Last will be set if the element to be deleted is not first in the chain.
      */
-	if (last) {
-		last->forw = sp->forw;
-	} else {
-		tp->hash_table[hindex] = sp->forw;
-	}
-	valueFree(&sp->name);
-	valueFree(&sp->content);
-	bfree(B_L, (void*) sp);
-
-	return 0;
+    if (last) {
+        last->forw = sp->forw;
+    } else {
+        tp->hash_table[hindex] = sp->forw;
+    }
+    valueFree(&sp->name);
+    valueFree(&sp->content);
+    bfree(B_L, (void*) sp);
+
+    return 0;
 }
 
 
@@ -363,9 +363,9 @@ int symDelete(sym_fd_t sd, char_t *name)
  */
 static sym_t *hash(sym_tabent_t *tp, char_t *name)
 {
-	a_assert(tp);
+    a_assert(tp);
 
-	return tp->hash_table[hashIndex(tp, name)];
+    return tp->hash_table[hashIndex(tp, name)];
 }
 
 
@@ -375,58 +375,58 @@ static sym_t *hash(sym_tabent_t *tp, char_t *name)
  */
 static int hashIndex(sym_tabent_t *tp, char_t *name)
 {
-	unsigned int	sum;
-	int				i;
+    unsigned int    sum;
+    int             i;
 
-	a_assert(tp);
+    a_assert(tp);
     /*
         Add in each character shifted up progressively by 7 bits. The shift amount is rounded so as to not shift too
         far. It thus cycles with each new cycle placing character shifted up by one bit.
      */
-	i = 0;
-	sum = 0;
-	while (*name) {
-		sum += (((int) *name++) << i);
-		i = (i + 7) % (BITS(int) - BITSPERBYTE);
-	}
-	return sum % tp->hash_size;
+    i = 0;
+    sum = 0;
+    while (*name) {
+        sum += (((int) *name++) << i);
+        i = (i + 7) % (BITS(int) - BITSPERBYTE);
+    }
+    return sum % tp->hash_size;
 }
 
 
 /*
-  	Check if this number is a prime
+    Check if this number is a prime
  */
 static int isPrime(int n)
 {
-	int		i, max;
+    int     i, max;
 
-	a_assert(n > 0);
+    a_assert(n > 0);
 
-	max = n / 2;
-	for (i = 2; i <= max; i++) {
-		if (n % i == 0) {
-			return 0;
-		}
-	}
-	return 1;
+    max = n / 2;
+    for (i = 2; i <= max; i++) {
+        if (n % i == 0) {
+            return 0;
+        }
+    }
+    return 1;
 }
 
 
 /*
-  	Calculate the largest prime smaller than size.
+    Calculate the largest prime smaller than size.
  */
 static int calcPrime(int size)
 {
-	int count;
+    int count;
 
-	a_assert(size > 0);
+    a_assert(size > 0);
 
-	for (count = size; count > 0; count--) {
-		if (isPrime(count)) {
-			return count;
-		}
-	}
-	return 1;
+    for (count = size; count > 0; count--) {
+        if (isPrime(count)) {
+            return count;
+        }
+    }
+    return 1;
 }
 
 /*
diff --git a/uemf.c b/uemf.c
index 9e975410..1d569842 100644
--- a/uemf.c
+++ b/uemf.c
@@ -7,219 +7,219 @@
 
 /*********************************** Includes *********************************/
 
-#include	"uemf.h"
+#include    "uemf.h"
 
 /********************************** Local Data ********************************/
 
-int emfInst;							/* Application instance handle */
+int emfInst;                            /* Application instance handle */
 
 /****************************** Forward Declarations **************************/
 
 extern void defaultErrorHandler(int etype, char_t *buf);
 static void (*errorHandler)(int etype, char_t *msg) = defaultErrorHandler;
 
-extern void	defaultTraceHandler(int level, char_t *buf);
+extern void defaultTraceHandler(int level, char_t *buf);
 static void (*traceHandler)(int level, char_t *buf) = defaultTraceHandler;
 
 /************************************* Code ***********************************/
 /*
-  	Error message that doesn't need user attention. Customize this code
-  	to direct error messages to wherever the developer wishes
+    Error message that doesn't need user attention. Customize this code
+    to direct error messages to wherever the developer wishes
  */
 
 void error(E_ARGS_DEC, int etype, char_t *fmt, ...)
 {
-	va_list 	args;
-	char_t		*fmtBuf, *buf;
-
-	va_start(args, fmt);
-	fmtValloc(&fmtBuf, E_MAX_ERROR, fmt, args);
-
-	if (etype == E_LOG) {
-		fmtAlloc(&buf, E_MAX_ERROR, T("%s\n"), fmtBuf);
-	} else if (etype == E_ASSERT) {
-		fmtAlloc(&buf, E_MAX_ERROR, T("Assertion %s, failed at %s %d\n"), fmtBuf, E_ARGS); 
-	} else if (etype == E_USER) {
-		fmtAlloc(&buf, E_MAX_ERROR, T("%s\n"), fmtBuf);
-	} else {
+    va_list     args;
+    char_t      *fmtBuf, *buf;
+
+    va_start(args, fmt);
+    fmtValloc(&fmtBuf, E_MAX_ERROR, fmt, args);
+
+    if (etype == E_LOG) {
+        fmtAlloc(&buf, E_MAX_ERROR, T("%s\n"), fmtBuf);
+    } else if (etype == E_ASSERT) {
+        fmtAlloc(&buf, E_MAX_ERROR, T("Assertion %s, failed at %s %d\n"), fmtBuf, E_ARGS); 
+    } else if (etype == E_USER) {
+        fmtAlloc(&buf, E_MAX_ERROR, T("%s\n"), fmtBuf);
+    } else {
       fmtAlloc(&buf, E_MAX_ERROR, T("Unknown error"));
     }
     va_end(args);
-	bfree(B_L, fmtBuf);
-	if (errorHandler) {
-		errorHandler(etype, buf);
-	}
-	bfreeSafe(B_L, buf);
+    bfree(B_L, fmtBuf);
+    if (errorHandler) {
+        errorHandler(etype, buf);
+    }
+    bfreeSafe(B_L, buf);
 }
 
 
 /*
-  	Replace the default error handler. Return pointer to old error handler.
+    Replace the default error handler. Return pointer to old error handler.
  */
 void (*errorSetHandler(void (*function)(int etype, char_t *msg))) (int etype, char_t *msg)
 {
     //  MOB - typedef for this
-	void (*oldHandler)(int etype, char_t *buf);
+    void (*oldHandler)(int etype, char_t *buf);
 
-	oldHandler = errorHandler;
-	errorHandler = function;
-	return oldHandler;
+    oldHandler = errorHandler;
+    errorHandler = function;
+    return oldHandler;
 }
 
 
 /*
-  	Trace log. Customize this function to log trace output
+    Trace log. Customize this function to log trace output
  */
 void trace(int level, char_t *fmt, ...)
 {
-	va_list 	args;
-	char_t		*buf;
+    va_list     args;
+    char_t      *buf;
 
-	va_start(args, fmt);
-	fmtValloc(&buf, VALUE_MAX_STRING, fmt, args);
+    va_start(args, fmt);
+    fmtValloc(&buf, VALUE_MAX_STRING, fmt, args);
 
-	if (traceHandler) {
-		traceHandler(level, buf);
-	}
-	bfreeSafe(B_L, buf);
-	va_end(args);
+    if (traceHandler) {
+        traceHandler(level, buf);
+    }
+    bfreeSafe(B_L, buf);
+    va_end(args);
 }
 
 
 /*
-  	Trace log. Customize this function to log trace output
+    Trace log. Customize this function to log trace output
  */
 void traceRaw(char_t *buf)
 {
-	if (traceHandler) {
-		traceHandler(0, buf);
-	}
+    if (traceHandler) {
+        traceHandler(0, buf);
+    }
 }
 
 
 /*
-  	Replace the default trace handler. Return a pointer to the old handler.
+    Replace the default trace handler. Return a pointer to the old handler.
  */
 void (*traceSetHandler(void (*function)(int level, char_t *buf))) (int level, char *buf)
 {
-	void (*oldHandler)(int level, char_t *buf);
+    void (*oldHandler)(int level, char_t *buf);
 
-	oldHandler = traceHandler;
-	if (function) {
-		traceHandler = function;
-	}
-	return oldHandler;
+    oldHandler = traceHandler;
+    if (function) {
+        traceHandler = function;
+    }
+    return oldHandler;
 }
 
 
 void emfInstSet(int inst)
 {
-	emfInst = inst;
+    emfInst = inst;
 }
 
 
 int emfInstGet()
 {
-	return emfInst;
+    return emfInst;
 }
 
 
 /*
-  	Convert a string to lower case
+    Convert a string to lower case
  */
 char_t *strlower(char_t *string)
 {
-	char_t	*s;
-
-	a_assert(string);
-
-	if (string == NULL) {
-		return NULL;
-	}
-	s = string;
-	while (*s) {
-		if (gisupper(*s)) {
-			*s = (char_t) gtolower(*s);
-		}
-		s++;
-	}
-	*s = '\0';
-	return string;
+    char_t  *s;
+
+    a_assert(string);
+
+    if (string == NULL) {
+        return NULL;
+    }
+    s = string;
+    while (*s) {
+        if (gisupper(*s)) {
+            *s = (char_t) gtolower(*s);
+        }
+        s++;
+    }
+    *s = '\0';
+    return string;
 }
 
 
 /* 
-  	Convert a string to upper case
+    Convert a string to upper case
  */
 char_t *strupper(char_t *string)
 {
-	char_t	*s;
-
-	a_assert(string);
-	if (string == NULL) {
-		return NULL;
-	}
-	s = string;
-	while (*s) {
-		if (gislower(*s)) {
-			*s = (char_t) gtoupper(*s);
-		}
-		s++;
-	}
-	*s = '\0';
-	return string;
+    char_t  *s;
+
+    a_assert(string);
+    if (string == NULL) {
+        return NULL;
+    }
+    s = string;
+    while (*s) {
+        if (gislower(*s)) {
+            *s = (char_t) gtoupper(*s);
+        }
+        s++;
+    }
+    *s = '\0';
+    return string;
 }
 
 
 /*
-  	Convert integer to ascii string. Allow a NULL string in which case we allocate a dynamic buffer. 
+    Convert integer to ascii string. Allow a NULL string in which case we allocate a dynamic buffer. 
  */
 char_t *stritoa(int n, char_t *string, int width)
 {
-	char_t	*cp, *lim, *s;
-	char_t	buf[16];						/* Just temp to hold number */
-	int		next, minus;
-
-	a_assert(string && width > 0);
-
-	if (string == NULL) {
-		if (width == 0) {
-			width = 10;
-		}
-		if ((string = balloc(B_L, width + 1)) == NULL) {
-			return NULL;
-		}
-	}
-	if (n < 0) {
-		minus = 1;
-		n = -n;
-		width--;
-	} else {
-		minus = 0;
-	}
-
-	cp = buf;
-	lim = &buf[width - 1];
-	while (n > 9 && cp < lim) {
-		next = n;
-		n /= 10;
-		*cp++ = (char_t) (next - n * 10 + '0');
-	}
-	if (cp < lim) {
-		*cp++ = (char_t) (n + '0');
-	}
-
-	s = string;
-	if (minus) {
-		*s++ = '-';
-	}
-
-	while (cp > buf) {
-		*s++ = *--cp;
-	}
-
-	*s++ = '\0';
-	return string;
+    char_t  *cp, *lim, *s;
+    char_t  buf[16];                        /* Just temp to hold number */
+    int     next, minus;
+
+    a_assert(string && width > 0);
+
+    if (string == NULL) {
+        if (width == 0) {
+            width = 10;
+        }
+        if ((string = balloc(B_L, width + 1)) == NULL) {
+            return NULL;
+        }
+    }
+    if (n < 0) {
+        minus = 1;
+        n = -n;
+        width--;
+    } else {
+        minus = 0;
+    }
+
+    cp = buf;
+    lim = &buf[width - 1];
+    while (n > 9 && cp < lim) {
+        next = n;
+        n /= 10;
+        *cp++ = (char_t) (next - n * 10 + '0');
+    }
+    if (cp < lim) {
+        *cp++ = (char_t) (n + '0');
+    }
+
+    s = string;
+    if (minus) {
+        *s++ = '-';
+    }
+
+    while (cp > buf) {
+        *s++ = *--cp;
+    }
+
+    *s++ = '\0';
+    return string;
 }
 
 /******************************************************************************/
@@ -258,17 +258,17 @@ void defaultTraceHandler(int level, char_t *buf)
  */
 char_t *basicGetProduct()
 {
-	return T("uemf");
+    return T("uemf");
 }
 
 char_t *basicGetAddress()
 {
-	return T("localhost");
+    return T("localhost");
 }
 
 int errorOpen(char_t *pname)
 {
-	return 0;
+    return 0;
 }
 
 void errorClose()
diff --git a/uemf.h b/uemf.h
index f14e8d5a..9bc7328d 100644
--- a/uemf.h
+++ b/uemf.h
@@ -10,7 +10,7 @@
 /******************************** Description *********************************/
 
 /* 
- *	GoAhead Web Server header. This defines the Web public APIs
+ *  GoAhead Web Server header. This defines the Web public APIs
  */
 
 /******************************* Per O/S Includes *****************************/
@@ -166,137 +166,137 @@
 #endif
 
 #ifdef WIN
-	#include	<direct.h>
-	#include	<io.h>
-	#include	<sys/stat.h>
-	#include	<limits.h>
-	#include	<tchar.h>
-	#include	<windows.h>
-	#include	<winnls.h>
-	#include	<time.h>
-	#include	<sys/types.h>
-	#include	<stdio.h>
-	#include	<stdlib.h>
-	#include	<fcntl.h>
-	#include	<errno.h>
+    #include    <direct.h>
+    #include    <io.h>
+    #include    <sys/stat.h>
+    #include    <limits.h>
+    #include    <tchar.h>
+    #include    <windows.h>
+    #include    <winnls.h>
+    #include    <time.h>
+    #include    <sys/types.h>
+    #include    <stdio.h>
+    #include    <stdlib.h>
+    #include    <fcntl.h>
+    #include    <errno.h>
 #endif /* WIN */
 
 #ifdef CE
-	/*#include	<errno.h>*/
-	#include	<limits.h>
-	#include	<tchar.h>
-	#include	<windows.h>
-	#include	<winsock.h>
-	#include	<winnls.h>
-	#include	"CE/wincompat.h"
-	#include	<winsock.h>
+    /*#include  <errno.h>*/
+    #include    <limits.h>
+    #include    <tchar.h>
+    #include    <windows.h>
+    #include    <winsock.h>
+    #include    <winnls.h>
+    #include    "CE/wincompat.h"
+    #include    <winsock.h>
 #endif /* CE */
 
 #ifdef NW
-	#include	<direct.h>
-	#include	<io.h>
-	#include	<sys/stat.h>
-	#include	<time.h>
-	#include	<sys/types.h>
-	#include	<stdio.h>
-	#include	<stdlib.h>
-	#include	<fcntl.h>
-	#include	<errno.h>
-	#include	<niterror.h>
-	#define		EINTR EINUSE
-	#define		 WEBS	1
-	#include	<limits.h>
-	#include	<netdb.h>
-	#include	<process.h>
-	#include	<tiuser.h>
-	#include	<sys/time.h>
-	#include	<arpa/inet.h>
-	#include	<sys/types.h>
-	#include	<sys/socket.h>
-	#include	<sys/filio.h>
-	#include	<netinet/in.h>
+    #include    <direct.h>
+    #include    <io.h>
+    #include    <sys/stat.h>
+    #include    <time.h>
+    #include    <sys/types.h>
+    #include    <stdio.h>
+    #include    <stdlib.h>
+    #include    <fcntl.h>
+    #include    <errno.h>
+    #include    <niterror.h>
+    #define     EINTR EINUSE
+    #define      WEBS   1
+    #include    <limits.h>
+    #include    <netdb.h>
+    #include    <process.h>
+    #include    <tiuser.h>
+    #include    <sys/time.h>
+    #include    <arpa/inet.h>
+    #include    <sys/types.h>
+    #include    <sys/socket.h>
+    #include    <sys/filio.h>
+    #include    <netinet/in.h>
 #endif /* NW */
 
 #ifdef SCOV5 
-	#include	<sys/types.h>
-	#include	<stdio.h>
-	#include	"sys/socket.h"
-	#include	"sys/select.h"
-	#include	"netinet/in.h"
-	#include 	"arpa/inet.h"
-	#include 	"netdb.h"
+    #include    <sys/types.h>
+    #include    <stdio.h>
+    #include    "sys/socket.h"
+    #include    "sys/select.h"
+    #include    "netinet/in.h"
+    #include    "arpa/inet.h"
+    #include    "netdb.h"
 #endif /* SCOV5 */
 
 #ifdef UNIX
-	#include	<stdio.h>
+    #include    <stdio.h>
 #endif /* UNIX */
 
 #ifdef LINUX
-	#include	<sys/types.h>
-	#include	<sys/stat.h>
-	#include	<sys/param.h>
-	#include	<limits.h>
-	#include	<stdio.h>
-	#include	<stdlib.h>
-	#include	<unistd.h>
-	#include	<sys/socket.h>
-	#include	<sys/select.h>
-	#include	<netinet/in.h>
-	#include 	<arpa/inet.h>
-	#include 	<netdb.h>
-	#include	<time.h>
-	#include	<fcntl.h>
-	#include	<errno.h>
+    #include    <sys/types.h>
+    #include    <sys/stat.h>
+    #include    <sys/param.h>
+    #include    <limits.h>
+    #include    <stdio.h>
+    #include    <stdlib.h>
+    #include    <unistd.h>
+    #include    <sys/socket.h>
+    #include    <sys/select.h>
+    #include    <netinet/in.h>
+    #include    <arpa/inet.h>
+    #include    <netdb.h>
+    #include    <time.h>
+    #include    <fcntl.h>
+    #include    <errno.h>
 #endif /* LINUX */
 
 #ifdef LYNX
-	#include	<limits.h>
-	#include	<stdarg.h>
-	#include	<stdio.h>
-	#include	<stdlib.h>
-	#include	<unistd.h>
-	#include	<socket.h>
-	#include	<netinet/in.h>
-	#include 	<arpa/inet.h>
-	#include 	<netdb.h>
-	#include	<time.h>
-	#include	<fcntl.h>
-	#include	<errno.h>
+    #include    <limits.h>
+    #include    <stdarg.h>
+    #include    <stdio.h>
+    #include    <stdlib.h>
+    #include    <unistd.h>
+    #include    <socket.h>
+    #include    <netinet/in.h>
+    #include    <arpa/inet.h>
+    #include    <netdb.h>
+    #include    <time.h>
+    #include    <fcntl.h>
+    #include    <errno.h>
 #endif /* LYNX */
 
 #ifdef MACOSX
-	#include	<limits.h>
-	#include	<sys/select.h>
-	#include	<sys/types.h>
-	#include	<sys/stat.h>
-	#include	<stdio.h>
-	#include	<stdlib.h>
-	#include	<unistd.h>
-	#include	<sys/socket.h>
-	#include	<netinet/in.h>
-	#include 	<arpa/inet.h>
-	#include 	<netdb.h>
-	#include	<fcntl.h>
-	#include	<errno.h>
-	#include	<time.h>
+    #include    <limits.h>
+    #include    <sys/select.h>
+    #include    <sys/types.h>
+    #include    <sys/stat.h>
+    #include    <stdio.h>
+    #include    <stdlib.h>
+    #include    <unistd.h>
+    #include    <sys/socket.h>
+    #include    <netinet/in.h>
+    #include    <arpa/inet.h>
+    #include    <netdb.h>
+    #include    <fcntl.h>
+    #include    <errno.h>
+    #include    <time.h>
 #endif /* MACOSX */
 
 #ifdef UW
-	#include	<stdio.h>
+    #include    <stdio.h>
 #endif /* UW */
 
 #ifdef VXWORKS
-	#include	<vxWorks.h>
-	#include	<sockLib.h>
-	#include	<selectLib.h>
-	#include	<inetLib.h>
-	#include	<ioLib.h>
-	#include	<stdio.h>
-	#include	<stat.h>
-	#include	<time.h>
-	#include	<usrLib.h>
-	#include	<fcntl.h>
-	#include	<errno.h>
+    #include    <vxWorks.h>
+    #include    <sockLib.h>
+    #include    <selectLib.h>
+    #include    <inetLib.h>
+    #include    <ioLib.h>
+    #include    <stdio.h>
+    #include    <stat.h>
+    #include    <time.h>
+    #include    <usrLib.h>
+    #include    <fcntl.h>
+    #include    <errno.h>
 #endif /* VXWORKS */
 
 #ifdef sparc
@@ -304,29 +304,29 @@
 #endif /* sparc */
 
 #ifdef SOLARIS
-	#include	<sys/types.h>
-	#include	<limits.h>
-	#include	<stdio.h>
-	#include	<stdlib.h>
-	#include	<unistd.h>
-	#include	<socket.h>
-	#include	<sys/select.h>
-	#include	<netinet/in.h>
-	#include 	<arpa/inet.h>
-	#include 	<netdb.h>
-	#include	<time.h>
-	#include	<fcntl.h>
-	#include	<errno.h>
+    #include    <sys/types.h>
+    #include    <limits.h>
+    #include    <stdio.h>
+    #include    <stdlib.h>
+    #include    <unistd.h>
+    #include    <socket.h>
+    #include    <sys/select.h>
+    #include    <netinet/in.h>
+    #include    <arpa/inet.h>
+    #include    <netdb.h>
+    #include    <time.h>
+    #include    <fcntl.h>
+    #include    <errno.h>
 #endif /* SOLARIS */
 
 #ifdef QNX4
-	#include	<sys/types.h>
-	#include	<stdio.h>
-	#include	<sys/socket.h>
-	#include	<sys/select.h>
-	#include	<netinet/in.h>
-	#include 	<arpa/inet.h>
-	#include 	<netdb.h>
+    #include    <sys/types.h>
+    #include    <stdio.h>
+    #include    <sys/socket.h>
+    #include    <sys/select.h>
+    #include    <netinet/in.h>
+    #include    <arpa/inet.h>
+    #include    <netdb.h>
     #include    <stdlib.h>
     #include    <unistd.h>
     #include    <sys/uio.h>
@@ -334,51 +334,51 @@
 #endif /* QNX4 */
 
 #ifdef ECOS
-	#include	<limits.h>
-	#include	<cyg/infra/cyg_type.h>
-	#include	<cyg/kernel/kapi.h>
-	#include	<time.h>
-	#include	<network.h>
-	#include	<errno.h>
+    #include    <limits.h>
+    #include    <cyg/infra/cyg_type.h>
+    #include    <cyg/kernel/kapi.h>
+    #include    <time.h>
+    #include    <network.h>
+    #include    <errno.h>
 #endif /* ECOS */
 
 /********************************** Includes **********************************/
 
-#include	<ctype.h>
-#include	<stdarg.h>
-#include	<string.h>
+#include    <ctype.h>
+#include    <stdarg.h>
+#include    <string.h>
 
 #ifndef WEBS
-#include	"messages.h"
+#include    "messages.h"
 #endif /* ! WEBS */
 
 /******************************* Per O/S Defines *****************************/
 
 #ifdef UW
-	#define		__NO_PACK		1
+    #define     __NO_PACK       1
 #endif /* UW */
 
 #if (defined (SCOV5) || defined (VXWORKS) || defined (LINUX) || defined (LYNX) || defined (MACOSX))
 #ifndef O_BINARY
-#define O_BINARY 		0
+#define O_BINARY        0
 #endif /* O_BINARY */
-#define	SOCKET_ERROR	-1
+#define SOCKET_ERROR    -1
 #endif /* SCOV5 || VXWORKS || LINUX || LYNX || MACOSX */
 
 #if (defined (WIN) || defined (CE))
 /*
-  	__NO_FCNTL means can't access fcntl function.  Fcntl.h is still available.
+    __NO_FCNTL means can't access fcntl function.  Fcntl.h is still available.
  */
-#define		__NO_FCNTL		1
+#define     __NO_FCNTL      1
 
 #undef R_OK
-#define R_OK	4
+#define R_OK    4
 #undef W_OK
-#define W_OK	2
+#define W_OK    2
 #undef X_OK
-#define X_OK	1
+#define X_OK    1
 #undef F_OK
-#define F_OK	0
+#define F_OK    0
 
 typedef int socklen_t;
 
@@ -387,25 +387,25 @@ typedef int socklen_t;
 #if (defined (LINUX) && !defined (_STRUCT_TIMEVAL))
 struct timeval
 {
-	time_t	tv_sec;		/* Seconds.  */
-	time_t	tv_usec;	/* Microseconds.  */
+    time_t  tv_sec;     /* Seconds.  */
+    time_t  tv_usec;    /* Microseconds.  */
 };
 #define _STRUCT_TIMEVAL 1
 #endif /* LINUX && ! _STRUCT_TIMEVAL */
 
 #ifdef ECOS
-	#define		O_RDONLY		1
-	#define		O_BINARY		2
+    #define     O_RDONLY        1
+    #define     O_BINARY        2
 
-	#define		__NO_PACK		1
-	#define		__NO_EJ_FILE	1
-	#define		__NO_CGI_BIN	1
-	#define		__NO_FCNTL		1
+    #define     __NO_PACK       1
+    #define     __NO_EJ_FILE    1
+    #define     __NO_CGI_BIN    1
+    #define     __NO_FCNTL      1
 
 /*
-  	#define LIBKERN_INLINE to avoid kernel inline functions
+    #define LIBKERN_INLINE to avoid kernel inline functions
  */
-	#define		LIBKERN_INLINE
+    #define     LIBKERN_INLINE
 
 #endif /* ECOS */
 
@@ -415,77 +415,77 @@ struct timeval
 #endif /* QNX4 */
 
 #ifdef MACOSX
-	typedef int32_t			fd_mask;
+    typedef int32_t         fd_mask;
 #endif
 
 #ifdef NW
-	#define fd_mask			fd_set
-	#define INADDR_NONE		-1l
-	#define Sleep			delay
-
-	#define __NO_FCNTL		1
-
-	#undef R_OK
-	#define R_OK    4
-	#undef W_OK
-	#define W_OK    2
-	#undef X_OK
-	#define X_OK    1
-	#undef F_OK
-	#define F_OK    0
+    #define fd_mask         fd_set
+    #define INADDR_NONE     -1l
+    #define Sleep           delay
+
+    #define __NO_FCNTL      1
+
+    #undef R_OK
+    #define R_OK    4
+    #undef W_OK
+    #define W_OK    2
+    #undef X_OK
+    #define X_OK    1
+    #undef F_OK
+    #define F_OK    0
 #endif /* NW */
 
 /********************************** Unicode ***********************************/
 /* 
-  	Constants and limits. Also FNAMESIZE and PATHSIZE are currently defined 
-  	in param.h to be 128 and 512
+    Constants and limits. Also FNAMESIZE and PATHSIZE are currently defined 
+    in param.h to be 128 and 512
  */
-#define TRACE_MAX			(4096 - 48)
-#define VALUE_MAX_STRING	(4096 - 48)
-#define SYM_MAX				(512)
-#define XML_MAX				4096	/* Maximum size for tags/tokens */
-#define BUF_MAX				4096	/* General sanity check for bufs */
+#define TRACE_MAX           (4096 - 48)
+#define VALUE_MAX_STRING    (4096 - 48)
+#define SYM_MAX             (512)
+#define XML_MAX             4096    /* Maximum size for tags/tokens */
+#define BUF_MAX             4096    /* General sanity check for bufs */
 #ifndef LINE_MAX
-#define LINE_MAX			2048	/* General sanity check for a single line */
+#define LINE_MAX            2048    /* General sanity check for a single line */
 #endif /* LINE_MAX */
-#define FMT_STATIC_MAX		256		/* Maximum for fmtStatic calls */
+#define FMT_STATIC_MAX      256     /* Maximum for fmtStatic calls */
 
 #if (defined (LITTLEFOOT) || defined (WEBS))
-#define LF_BUF_MAX		(510)
-#define LF_PATHSIZE		LF_BUF_MAX
+#define LF_BUF_MAX      (510)
+#define LF_PATHSIZE     LF_BUF_MAX
 #else
-#define	LF_BUF_MAX		BUF_MAX
-#define LF_PATHSIZE		PATHSIZE
-#define UPPATHSIZE		PATHSIZE
+#define LF_BUF_MAX      BUF_MAX
+#define LF_PATHSIZE     PATHSIZE
+#define UPPATHSIZE      PATHSIZE
 #endif /* LITTLEFOOT || WEBS */ 
 #ifndef CHAR_T_DEFINED
 #define CHAR_T_DEFINED 1
 #ifdef UNICODE
 /*
-  	To convert strings to UNICODE. We have a level of indirection so things like T(__FILE__) will expand properly.
+    To convert strings to UNICODE. We have a level of indirection so things like T(__FILE__) will expand properly.
  */
-#define	T(x)				__TXT(x)
-#define	__TXT(s)			L ## s
-typedef unsigned short 		char_t;
-typedef unsigned short		uchar_t;
+#define T(x)                __TXT(x)
+#define __TXT(s)            L ## s
+typedef unsigned short      char_t;
+typedef unsigned short      uchar_t;
 
 /*
-  	Text size of buffer macro. A buffer bytes will hold (size / char size) characters. 
+    Text size of buffer macro. A buffer bytes will hold (size / char size) characters. 
  */
-#define	TSZ(x)				(sizeof(x) / sizeof(char_t))
+#define TSZ(x)              (sizeof(x) / sizeof(char_t))
 
 /*
-  	How many ASCII bytes are required to represent this UNICODE string?
+    How many ASCII bytes are required to represent this UNICODE string?
  */
-#define	TASTRL(x)			((wcslen(x) + 1) * sizeof(char_t))
+#define TASTRL(x)           ((wcslen(x) + 1) * sizeof(char_t))
 
 #else
-#define	T(s) 				s
-typedef char				char_t;
-#define	TSZ(x)				(sizeof(x))
-#define	TASTRL(x)			(strlen(x) + 1)
+#define T(s)                s
+typedef char                char_t;
+#define TSZ(x)              (sizeof(x))
+#define TASTRL(x)           (strlen(x) + 1)
 #ifdef WIN
-typedef unsigned char		uchar_t;
+typedef unsigned char       uchar_t;
 #endif /* WIN */
 
 #endif /* UNICODE */
@@ -493,7 +493,7 @@ typedef unsigned char		uchar_t;
 #endif /* ! CHAR_T_DEFINED */
 
 /*
-  	"Boolean" constants
+    "Boolean" constants
  */
 
 #ifndef TRUE
@@ -505,212 +505,212 @@ typedef unsigned char		uchar_t;
 #endif
 
 /*
-  	GoAhead Copyright.
+    GoAhead Copyright.
     MOB - this must be included in some source somewhere
  */
 #define GOAHEAD_COPYRIGHT T("Copyright (c) Embedthis Software Inc., 1993-2012. All Rights Reserved.")
 
 /*
-  	The following include has to be after the unicode defines.  By putting it here, many modules in 
+    The following include has to be after the unicode defines.  By putting it here, many modules in 
     various parts of the tree are cleaner.
  */
 #if (defined (LITTLEFOOT) && defined (INMEM))
-	#include	"lf/inmem.h"
+    #include    "lf/inmem.h"
 #endif /* LITTLEFOOT && INMEM */
 
 /*
-  	Type for unicode systems
+    Type for unicode systems
  */
 #ifdef UNICODE
 
-#define gmain		wmain
-
-#define gasctime	_wasctime
-#define gsprintf	swprintf
-#define gprintf		wprintf
-#define gfprintf	fwprintf
-#define gsscanf		swscanf
-#define gvsprintf	vswprintf
-
-#define gstrcpy		wcscpy
-#define gstrncpy	wcsncpy
-#define gstrncat	wcsncat
-#define gstrlen		wcslen
-#define gstrcat		wcscat
-#define gstrcmp		wcscmp
-#define gstrncmp	wcsncmp
-#define gstricmp	wcsicmp
-#define gstrchr		wcschr
-#define gstrrchr	wcsrchr
-#define gstrtok		wcstok
-#define gstrnset	wcsnset
-#define gstrrchr	wcsrchr
-#define gstrspn	wcsspn
-#define gstrcspn	wcscspn
-#define gstrstr		wcsstr
-#define gstrtol		wcstol
-
-#define gfopen		_wfopen
-#define gopen		_wopen
-#define gclose		close
-#define gcreat		_wcreat
-#define gfgets		fgetws
-#define gfputs		fputws
-#define gfscanf		fwscanf
-#define ggets		_getws
-#define glseek		lseek
-#define gunlink		_wunlink
-#define gread		read
-#define grename		_wrename
-#define gwrite		write
-#define gtmpnam		_wtmpnam
-#define gtempnam	_wtempnam
-#define gfindfirst	_wfindfirst
-#define gfinddata_t	_wfinddata_t
-#define gfindnext	_wfindnext
-#define gfindclose	_findclose
-#define gstat		_wstat
-#define gaccess		_waccess
-#define gchmod		_wchmod
+#define gmain       wmain
+
+#define gasctime    _wasctime
+#define gsprintf    swprintf
+#define gprintf     wprintf
+#define gfprintf    fwprintf
+#define gsscanf     swscanf
+#define gvsprintf   vswprintf
+
+#define gstrcpy     wcscpy
+#define gstrncpy    wcsncpy
+#define gstrncat    wcsncat
+#define gstrlen     wcslen
+#define gstrcat     wcscat
+#define gstrcmp     wcscmp
+#define gstrncmp    wcsncmp
+#define gstricmp    wcsicmp
+#define gstrchr     wcschr
+#define gstrrchr    wcsrchr
+#define gstrtok     wcstok
+#define gstrnset    wcsnset
+#define gstrrchr    wcsrchr
+#define gstrspn wcsspn
+#define gstrcspn    wcscspn
+#define gstrstr     wcsstr
+#define gstrtol     wcstol
+
+#define gfopen      _wfopen
+#define gopen       _wopen
+#define gclose      close
+#define gcreat      _wcreat
+#define gfgets      fgetws
+#define gfputs      fputws
+#define gfscanf     fwscanf
+#define ggets       _getws
+#define glseek      lseek
+#define gunlink     _wunlink
+#define gread       read
+#define grename     _wrename
+#define gwrite      write
+#define gtmpnam     _wtmpnam
+#define gtempnam    _wtempnam
+#define gfindfirst  _wfindfirst
+#define gfinddata_t _wfinddata_t
+#define gfindnext   _wfindnext
+#define gfindclose  _findclose
+#define gstat       _wstat
+#define gaccess     _waccess
+#define gchmod      _wchmod
 
 typedef struct _stat gstat_t;
 
-#define gmkdir		_wmkdir
-#define gchdir		_wchdir
-#define grmdir		_wrmdir
-#define ggetcwd		_wgetcwd
+#define gmkdir      _wmkdir
+#define gchdir      _wchdir
+#define grmdir      _wrmdir
+#define ggetcwd     _wgetcwd
 
-#define gtolower	towlower
-#define gtoupper	towupper
+#define gtolower    towlower
+#define gtoupper    towupper
 #ifdef CE
-#define gisspace	isspace
-#define gisdigit	isdigit
-#define gisxdigit	isxdigit
-#define gisupper	isupper
-#define gislower	islower
-#define gisprint	isprint
+#define gisspace    isspace
+#define gisdigit    isdigit
+#define gisxdigit   isxdigit
+#define gisupper    isupper
+#define gislower    islower
+#define gisprint    isprint
 #else
-#define gremove		_wremove
-#define gisspace	iswspace
-#define gisdigit	iswdigit
-#define gisxdigit	iswxdigit
-#define gisupper	iswupper
-#define gislower	iswlower
-#endif	/* if CE */
-#define gisalnum	iswalnum
-#define gisalpha	iswalpha
-#define gatoi(s)	wcstol(s, NULL, 10)
-
-#define gctime		_wctime
-#define ggetenv		_wgetenv
-#define gexecvp		_wexecvp
+#define gremove     _wremove
+#define gisspace    iswspace
+#define gisdigit    iswdigit
+#define gisxdigit   iswxdigit
+#define gisupper    iswupper
+#define gislower    iswlower
+#endif  /* if CE */
+#define gisalnum    iswalnum
+#define gisalpha    iswalpha
+#define gatoi(s)    wcstol(s, NULL, 10)
+
+#define gctime      _wctime
+#define ggetenv     _wgetenv
+#define gexecvp     _wexecvp
 
 #else /* ! UNICODE */
 
 #ifdef VXWORKS
-#define gchdir		vxchdir
-#define gmkdir		vxmkdir
-#define grmdir		vxrmdir
+#define gchdir      vxchdir
+#define gmkdir      vxmkdir
+#define grmdir      vxrmdir
 #elif (defined (LYNX) || defined (LINUX) || defined (MACOSX) || defined (SOLARIS))
-#define gchdir		chdir
-#define gmkdir(s)	mkdir(s,0755)
-#define grmdir		rmdir
+#define gchdir      chdir
+#define gmkdir(s)   mkdir(s,0755)
+#define grmdir      rmdir
 #else
-#define gchdir		chdir
-#define gmkdir		mkdir
-#define grmdir		rmdir
+#define gchdir      chdir
+#define gmkdir      mkdir
+#define grmdir      rmdir
 #endif /* VXWORKS #elif LYNX || LINUX || MACOSX || SOLARIS*/
 
-#define gclose		close
-#define gclosedir	closedir
-#define gchmod		chmod
-#define ggetcwd		getcwd
-#define glseek		lseek
-#define gloadModule	loadModule
-#define gopen		open
-#define gopendir	opendir
-#define gread		read
-#define greaddir	readdir
-#define grename		rename
-#define gstat		stat
-#define gunlink		unlink
-#define gwrite		write
-
-#define gasctime	asctime
-#define gsprintf	sprintf
-#define gprintf		printf
-#define gfprintf	fprintf
-#define gsscanf		sscanf
-#define gvsprintf	vsprintf
-
-#define gstrcpy		strcpy
-#define gstrncpy	strncpy
-#define gstrncat	strncat
-#define gstrlen		strlen
-#define gstrcat		strcat
-#define gstrcmp		strcmp
-#define gstrncmp	strncmp
-#define gstricmp	strcmpci
-#define gstrchr		strchr
-#define gstrrchr	strrchr
-#define gstrtok		strtok
-#define gstrnset	strnset
-#define gstrrchr	strrchr
-#define gstrspn	strspn
-#define gstrcspn	strcspn
-#define gstrstr		strstr
-#define gstrtol		strtol
-
-#define gfopen		fopen
-#define gcreat		creat
-#define gfgets		fgets
-#define gfputs		fputs
-#define gfscanf		fscanf
-#define ggets		gets
-#define gtmpnam		tmpnam
-#define gtempnam	tempnam
-#define gfindfirst	_findfirst
-#define gfinddata_t	_finddata_t
-#define gfindnext	_findnext
-#define gfindclose	_findclose
-#define gaccess		access
+#define gclose      close
+#define gclosedir   closedir
+#define gchmod      chmod
+#define ggetcwd     getcwd
+#define glseek      lseek
+#define gloadModule loadModule
+#define gopen       open
+#define gopendir    opendir
+#define gread       read
+#define greaddir    readdir
+#define grename     rename
+#define gstat       stat
+#define gunlink     unlink
+#define gwrite      write
+
+#define gasctime    asctime
+#define gsprintf    sprintf
+#define gprintf     printf
+#define gfprintf    fprintf
+#define gsscanf     sscanf
+#define gvsprintf   vsprintf
+
+#define gstrcpy     strcpy
+#define gstrncpy    strncpy
+#define gstrncat    strncat
+#define gstrlen     strlen
+#define gstrcat     strcat
+#define gstrcmp     strcmp
+#define gstrncmp    strncmp
+#define gstricmp    strcmpci
+#define gstrchr     strchr
+#define gstrrchr    strrchr
+#define gstrtok     strtok
+#define gstrnset    strnset
+#define gstrrchr    strrchr
+#define gstrspn strspn
+#define gstrcspn    strcspn
+#define gstrstr     strstr
+#define gstrtol     strtol
+
+#define gfopen      fopen
+#define gcreat      creat
+#define gfgets      fgets
+#define gfputs      fputs
+#define gfscanf     fscanf
+#define ggets       gets
+#define gtmpnam     tmpnam
+#define gtempnam    tempnam
+#define gfindfirst  _findfirst
+#define gfinddata_t _finddata_t
+#define gfindnext   _findnext
+#define gfindclose  _findclose
+#define gaccess     access
 
 typedef struct stat gstat_t;
 
-#define gremove		remove
-
-#define gtolower	tolower
-#define gtoupper	toupper
-#define gisspace	isspace
-#define gisdigit	isdigit
-#define gisxdigit	isxdigit
-#define gisalnum	isalnum
-#define gisalpha	isalpha
-#define gisupper	isupper
-#define gislower	islower
-#define gatoi		atoi
-
-#define gctime		ctime
-#define ggetenv		getenv
-#define gexecvp		execvp
+#define gremove     remove
+
+#define gtolower    tolower
+#define gtoupper    toupper
+#define gisspace    isspace
+#define gisdigit    isdigit
+#define gisxdigit   isxdigit
+#define gisalnum    isalnum
+#define gisalpha    isalpha
+#define gisupper    isupper
+#define gislower    islower
+#define gatoi       atoi
+
+#define gctime      ctime
+#define ggetenv     getenv
+#define gexecvp     execvp
 #ifndef VXWORKS
-#define gmain		main
+#define gmain       main
 #endif /* ! VXWORKS */
 #ifdef VXWORKS
-#define	fcntl(a, b, c)
+#define fcntl(a, b, c)
 #endif /* VXWORKS */
 #endif /* ! UNICODE */
 
 #ifdef WIN32
-#define getcwd	_getcwd
-#define tempnam	_tempnam
-#define open	_open
-#define close	_close
-#define read	_read
-#define write	_write
-#define chdir	_chdir
-#define lseek	_lseek
-#define unlink	_unlink
+#define getcwd  _getcwd
+#define tempnam _tempnam
+#define open    _open
+#define close   _close
+#define read    _read
+#define write   _write
+#define chdir   _chdir
+#define lseek   _lseek
+#define unlink  _unlink
 //#define strtok(x, y) strtok_s(x, y, NULL)
 #define localtime localtime_s
 //#define strcat(x, y) strcat_s(x, elementsof(x), y)
@@ -718,38 +718,38 @@ typedef struct stat gstat_t;
 
 
 /*
-  	Include inmem.h here because it redefines many of the file access fucntions.
-  	Otherwise there would be lots more #if-#elif-#else-#endif ugliness.
+    Include inmem.h here because it redefines many of the file access fucntions.
+    Otherwise there would be lots more #if-#elif-#else-#endif ugliness.
  */
 #ifdef INMEM
-	#include	"lf/inmem.h"
+    #include    "lf/inmem.h"
 #endif
 
 /********************************** Defines ***********************************/
 
 #ifndef FNAMESIZE
-#define FNAMESIZE			254			/* Max length of file names */
+#define FNAMESIZE           254         /* Max length of file names */
 #endif /* FNAMESIZE */
 
-#define E_MAX_ERROR			4096
-#define URL_MAX				4096
-#define E_MAX_REQUEST		2048		/* Request safeguard max */
+#define E_MAX_ERROR         4096
+#define URL_MAX             4096
+#define E_MAX_REQUEST       2048        /* Request safeguard max */
 
 /*
     Error types
  */
-#define	E_ASSERT			0x1			/* Assertion error */
-#define	E_LOG				0x2			/* Log error to log file */
-#define	E_USER				0x3			/* Error that must be displayed */
+#define E_ASSERT            0x1         /* Assertion error */
+#define E_LOG               0x2         /* Log error to log file */
+#define E_USER              0x3         /* Error that must be displayed */
 
-#define E_L					T(__FILE__), __LINE__
-#define E_ARGS_DEC			char_t *file, int line
-#define E_ARGS				file, line
+#define E_L                 T(__FILE__), __LINE__
+#define E_ARGS_DEC          char_t *file, int line
+#define E_ARGS              file, line
 
 #if (defined (ASSERT) || defined (ASSERT_CE))
-	#define a_assert(C)		if (C) ; else error(E_L, E_ASSERT, T("%s"), T(#C))
+    #define a_assert(C)     if (C) ; else error(E_L, E_ASSERT, T("%s"), T(#C))
 #else
-	#define a_assert(C)		if (1) ; else
+    #define a_assert(C)     if (1) ; else
 #endif /* ASSERT || ASSERT_CE */
 
 #define elementsof(X) sizeof(X) / sizeof(X[0])
@@ -758,24 +758,24 @@ typedef struct stat gstat_t;
 /*                                 VALUE                                      */
 /******************************************************************************/
 /*
-  	These values are not prefixed so as to aid code readability
+    These values are not prefixed so as to aid code readability
  */
 
 typedef enum {
-	undefined	= 0,
-	byteint		= 1,
-	shortint	= 2,
-	integer		= 3,
-	hex			= 4,
-	percent 	= 5,
-	octal		= 6,
-	big			= 7,
-	flag		= 8,
-	floating	= 9,
-	string 		= 10,
-	bytes 		= 11,
-	symbol 		= 12,
-	errmsg 		= 13
+    undefined   = 0,
+    byteint     = 1,
+    shortint    = 2,
+    integer     = 3,
+    hex         = 4,
+    percent     = 5,
+    octal       = 6,
+    big         = 7,
+    flag        = 8,
+    floating    = 9,
+    string      = 10,
+    bytes       = 11,
+    symbol      = 12,
+    errmsg      = 13
 } vtype_t;
 
 #ifndef __NO_PACK
@@ -784,27 +784,27 @@ typedef enum {
 
 typedef struct {
 
-	union {
-		char	flag;
-		char	byteint;
-		short	shortint;
-		char	percent;
-		long	integer;
-		long	hex;
-		long	octal;
-		long	big[2];
+    union {
+        char    flag;
+        char    byteint;
+        short   shortint;
+        char    percent;
+        long    integer;
+        long    hex;
+        long    octal;
+        long    big[2];
 #ifdef FLOATING_POINT_SUPPORT
-		double	floating;
+        double  floating;
 #endif /* FLOATING_POINT_SUPPORT */
-		char_t	*string;
-		char	*bytes;
-		char_t	*errmsg;
-		void	*symbol;
-	} value;
-
-	vtype_t			type;
-	unsigned int	valid		: 8;
-	unsigned int	allocated	: 8;		/* String was balloced */
+        char_t  *string;
+        char    *bytes;
+        char_t  *errmsg;
+        void    *symbol;
+    } value;
+
+    vtype_t         type;
+    unsigned int    valid       : 8;
+    unsigned int    allocated   : 8;        /* String was balloced */
 } value_t;
 
 #ifndef __NO_PACK
@@ -812,134 +812,134 @@ typedef struct {
 #endif /* __NO_PACK */
 
 /*
-  	 llocation flags 
+     llocation flags 
  */
-#define VALUE_ALLOCATE		0x1
+#define VALUE_ALLOCATE      0x1
 
-#define value_numeric(t)	(t >= byteint && t <= big)
-#define value_str(t) 		(t >= string && t <= bytes)
-#define value_ok(t) 		(t > undefined && t <= symbol)
+#define value_numeric(t)    (t >= byteint && t <= big)
+#define value_str(t)        (t >= string && t <= bytes)
+#define value_ok(t)         (t > undefined && t <= symbol)
 
-#define VALUE_VALID			{ {0}, integer, 1 }
-#define VALUE_INVALID		{ {0}, undefined, 0 }
+#define VALUE_VALID         { {0}, integer, 1 }
+#define VALUE_INVALID       { {0}, undefined, 0 }
 
 /******************************************************************************/
 /*
-  	A ring queue allows maximum utilization of memory for data storage and is
-  	ideal for input/output buffering. This module provides a highly effecient
-  	implementation and a vehicle for dynamic strings.
+    A ring queue allows maximum utilization of memory for data storage and is
+    ideal for input/output buffering. This module provides a highly effecient
+    implementation and a vehicle for dynamic strings.
   
-  	WARNING:  This is a public implementation and callers have full access to
-  	the queue structure and pointers.  Change this module very carefully.
+    WARNING:  This is a public implementation and callers have full access to
+    the queue structure and pointers.  Change this module very carefully.
   
-  	This module follows the open/close model.
+    This module follows the open/close model.
   
-  	Operation of a ringq where rq is a pointer to a ringq :
+    Operation of a ringq where rq is a pointer to a ringq :
   
-  		rq->buflen contains the size of the buffer.
-  		rq->buf will point to the start of the buffer.
-  		rq->servp will point to the first (un-consumed) data byte.
-  		rq->endp will point to the next free location to which new data is added
-  		rq->endbuf will point to one past the end of the buffer.
+        rq->buflen contains the size of the buffer.
+        rq->buf will point to the start of the buffer.
+        rq->servp will point to the first (un-consumed) data byte.
+        rq->endp will point to the next free location to which new data is added
+        rq->endbuf will point to one past the end of the buffer.
   
-  	Eg. If the ringq contains the data "abcdef", it might look like :
+    Eg. If the ringq contains the data "abcdef", it might look like :
   
-  	+-------------------------------------------------------------------+
+    +-------------------------------------------------------------------+
     |   |   |   |   |   |   |   | a | b | c | d | e | f |   |   |   |   |
-  	+-------------------------------------------------------------------+
+    +-------------------------------------------------------------------+
       ^                           ^                       ^               ^
       |                           |                       |               |
     rq->buf                    rq->servp               rq->endp      rq->enduf
        
-  	The queue is empty when servp == endp.  This means that the queue will hold
-  	at most rq->buflen -1 bytes.  It is the fillers responsibility to ensure
-  	the ringq is never filled such that servp == endp.
+    The queue is empty when servp == endp.  This means that the queue will hold
+    at most rq->buflen -1 bytes.  It is the fillers responsibility to ensure
+    the ringq is never filled such that servp == endp.
   
-  	It is the fillers responsibility to "wrap" the endp back to point to
-  	rq->buf when the pointer steps past the end. Correspondingly it is the
-  	consumers responsibility to "wrap" the servp when it steps to rq->endbuf.
-  	The ringqPutc and ringqGetc routines will do this automatically.
+    It is the fillers responsibility to "wrap" the endp back to point to
+    rq->buf when the pointer steps past the end. Correspondingly it is the
+    consumers responsibility to "wrap" the servp when it steps to rq->endbuf.
+    The ringqPutc and ringqGetc routines will do this automatically.
  */
 
 /*
-  	Ring queue buffer structure
+    Ring queue buffer structure
  */
 typedef struct {
-	unsigned char	*buf;				/* Holding buffer for data */
-	unsigned char	*servp;				/* Pointer to start of data */
-	unsigned char	*endp;				/* Pointer to end of data */
-	unsigned char	*endbuf;			/* Pointer to end of buffer */
-	int				buflen;				/* Length of ring queue */
-	int				maxsize;			/* Maximum size */
-	int				increment;			/* Growth increment */
+    unsigned char   *buf;               /* Holding buffer for data */
+    unsigned char   *servp;             /* Pointer to start of data */
+    unsigned char   *endp;              /* Pointer to end of data */
+    unsigned char   *endbuf;            /* Pointer to end of buffer */
+    int             buflen;             /* Length of ring queue */
+    int             maxsize;            /* Maximum size */
+    int             increment;          /* Growth increment */
 } ringq_t;
 
 /*
-  	Block allocation (balloc) definitions
+    Block allocation (balloc) definitions
  */
-#ifdef	B_STATS
+#ifdef  B_STATS
 #ifndef B_L
-#define B_L				T(__FILE__), __LINE__
-#define B_ARGS_DEC		char_t *file, int line
-#define B_ARGS			file, line
+#define B_L             T(__FILE__), __LINE__
+#define B_ARGS_DEC      char_t *file, int line
+#define B_ARGS          file, line
 #endif /* B_L */
 #endif /* B_STATS */
 
 /*
-  	Block classes are: 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536 
+    Block classes are: 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536 
  */
 typedef struct {
-	union {
-		void	*next;							/* Pointer to next in q */
-		int		size;							/* Actual requested size */
-	} u;
-	int			flags;							/* Per block allocation flags */
+    union {
+        void    *next;                          /* Pointer to next in q */
+        int     size;                           /* Actual requested size */
+    } u;
+    int         flags;                          /* Per block allocation flags */
 } bType;
 
-#define B_SHIFT			4					/* Convert size to class */
-#define B_ROUND			((1 << (B_SHIFT)) - 1)
-#define B_MAX_CLASS		13					/* Maximum class number + 1 */
-#define B_MALLOCED		0x80000000			/* Block was malloced */
-#define B_DEFAULT_MEM	(64 * 1024)			/* Default memory allocation */
-#define B_MAX_FILES		(512)				/* Maximum number of files */
-#define B_FILL_CHAR		(0x77)				/* Fill byte for buffers */
-#define B_FILL_WORD		(0x77777777)		/* Fill word for buffers */
-#define B_MAX_BLOCKS	(64 * 1024)			/* Maximum allocated blocks */
+#define B_SHIFT         4                   /* Convert size to class */
+#define B_ROUND         ((1 << (B_SHIFT)) - 1)
+#define B_MAX_CLASS     13                  /* Maximum class number + 1 */
+#define B_MALLOCED      0x80000000          /* Block was malloced */
+#define B_DEFAULT_MEM   (64 * 1024)         /* Default memory allocation */
+#define B_MAX_FILES     (512)               /* Maximum number of files */
+#define B_FILL_CHAR     (0x77)              /* Fill byte for buffers */
+#define B_FILL_WORD     (0x77777777)        /* Fill word for buffers */
+#define B_MAX_BLOCKS    (64 * 1024)         /* Maximum allocated blocks */
 
 /*
-  	Flags. The integrity value is used as an arbitrary value to fill the flags.
+    Flags. The integrity value is used as an arbitrary value to fill the flags.
  */
-#define B_INTEGRITY			0x8124000		/* Integrity value */
-#define B_INTEGRITY_MASK	0xFFFF000		/* Integrity mask */
-#define B_USE_MALLOC		0x1				/* Okay to use malloc if required */
-#define B_USER_BUF			0x2				/* User supplied buffer for mem */
+#define B_INTEGRITY         0x8124000       /* Integrity value */
+#define B_INTEGRITY_MASK    0xFFFF000       /* Integrity mask */
+#define B_USE_MALLOC        0x1             /* Okay to use malloc if required */
+#define B_USER_BUF          0x2             /* User supplied buffer for mem */
 
 /*
-  	The symbol table record for each symbol entry
+    The symbol table record for each symbol entry
  */
 typedef struct sym_t {
-	struct sym_t	*forw;					/* Pointer to next hash list */
-	value_t			name;					/* Name of symbol */
-	value_t			content;				/* Value of symbol */
-	int				arg;					/* Parameter value */
+    struct sym_t    *forw;                  /* Pointer to next hash list */
+    value_t         name;                   /* Name of symbol */
+    value_t         content;                /* Value of symbol */
+    int             arg;                    /* Parameter value */
 } sym_t;
 
-typedef int sym_fd_t;						/* Returned by symOpen */
+typedef int sym_fd_t;                       /* Returned by symOpen */
 
 /*
-  	Script engines
+    Script engines
  */
-#define EMF_SCRIPT_JSCRIPT			0		/* javascript */
-#define EMF_SCRIPT_TCL	 			1		/* tcl */
-#define EMF_SCRIPT_EJSCRIPT 		2		/* Ejscript */
-#define EMF_SCRIPT_MAX	 			3
+#define EMF_SCRIPT_JSCRIPT          0       /* javascript */
+#define EMF_SCRIPT_TCL              1       /* tcl */
+#define EMF_SCRIPT_EJSCRIPT         2       /* Ejscript */
+#define EMF_SCRIPT_MAX              3
 
 #if !defined(HAVE_MAXINT)
-#define	MAXINT		INT_MAX
+#define MAXINT      INT_MAX
 #endif
 #define BITSPERBYTE 8
-#define BITS(type)	(BITSPERBYTE * (int) sizeof(type))
-#define	STRSPACE	T("\t \n\r\t")
+#define BITS(type)  (BITSPERBYTE * (int) sizeof(type))
+#define STRSPACE    T("\t \n\r\t")
 
 #ifndef max
 #define max(a,b)  (((a) > (b)) ? (a) : (b))
@@ -954,22 +954,22 @@ typedef int sym_fd_t;						/* Returned by symOpen */
 /******************************************************************************/
 
 typedef struct {
-	char_t	*minute;
-	char_t	*hour;
-	char_t	*day;
-	char_t	*month;
-	char_t	*dayofweek;
+    char_t  *minute;
+    char_t  *hour;
+    char_t  *day;
+    char_t  *month;
+    char_t  *dayofweek;
 } cron_t;
 
-extern long		cronUntil(cron_t *cp, int period, time_t testTime);
-extern int		cronAlloc(cron_t *cp, char_t *str);
-extern int		cronFree(cron_t *cp);
+extern long     cronUntil(cron_t *cp, int period, time_t testTime);
+extern int      cronAlloc(cron_t *cp, char_t *str);
+extern int      cronFree(cron_t *cp);
 
 /******************************************************************************/
 /*                                 SOCKET                                     */
 /******************************************************************************/
 /*
-  	Socket flags 
+    Socket flags 
  */
 
 #if ((defined (WIN) || defined (CE)) && defined (WEBS) && !defined(WIN32))
@@ -985,78 +985,78 @@ extern int		cronFree(cron_t *cp);
 #endif
 #endif /* (WIN || CE) && WEBS) */
 
-#define SOCKET_EOF				0x1		/* Seen end of file */
-#define SOCKET_CONNECTING		0x2		/* Connect in progress */
-#define SOCKET_BROADCAST		0x4		/* Broadcast mode */
-#define SOCKET_PENDING			0x8		/* Message pending on this socket */
-#define SOCKET_FLUSHING			0x10	/* Background flushing */
-#define SOCKET_DATAGRAM			0x20	/* Use datagrams */
-#define SOCKET_ASYNC			0x40	/* Use async connect */
-#define SOCKET_BLOCK			0x80	/* Use blocking I/O */
-#define SOCKET_LISTENING		0x100	/* Socket is server listener */
-#define SOCKET_CLOSING			0x200	/* Socket is closing */
-#define SOCKET_CONNRESET		0x400	/* Socket connection was reset */
-#define SOCKET_MYOWNBUFFERS		0x800	/* Not using inBuf/outBuf ringq */
-
-#define SOCKET_PORT_MAX			0xffff	/* Max Port size */
+#define SOCKET_EOF              0x1     /* Seen end of file */
+#define SOCKET_CONNECTING       0x2     /* Connect in progress */
+#define SOCKET_BROADCAST        0x4     /* Broadcast mode */
+#define SOCKET_PENDING          0x8     /* Message pending on this socket */
+#define SOCKET_FLUSHING         0x10    /* Background flushing */
+#define SOCKET_DATAGRAM         0x20    /* Use datagrams */
+#define SOCKET_ASYNC            0x40    /* Use async connect */
+#define SOCKET_BLOCK            0x80    /* Use blocking I/O */
+#define SOCKET_LISTENING        0x100   /* Socket is server listener */
+#define SOCKET_CLOSING          0x200   /* Socket is closing */
+#define SOCKET_CONNRESET        0x400   /* Socket connection was reset */
+#define SOCKET_MYOWNBUFFERS     0x800   /* Not using inBuf/outBuf ringq */
+
+#define SOCKET_PORT_MAX         0xffff  /* Max Port size */
 
 /*
-  	Socket error values
+    Socket error values
  */
-#define SOCKET_WOULDBLOCK		1		/* Socket would block on I/O */
-#define SOCKET_RESET			2		/* Socket has been reset */
-#define SOCKET_NETDOWN			3		/* Network is down */
-#define SOCKET_AGAIN			4		/* Issue the request again */
-#define SOCKET_INTR				5		/* Call was interrupted */
-#define SOCKET_INVAL			6		/* Invalid */
+#define SOCKET_WOULDBLOCK       1       /* Socket would block on I/O */
+#define SOCKET_RESET            2       /* Socket has been reset */
+#define SOCKET_NETDOWN          3       /* Network is down */
+#define SOCKET_AGAIN            4       /* Issue the request again */
+#define SOCKET_INTR             5       /* Call was interrupted */
+#define SOCKET_INVAL            6       /* Invalid */
 
 /*
-  	Handler event masks
+    Handler event masks
  */
-#define SOCKET_READABLE			0x2		/* Make socket readable */ 
-#define SOCKET_WRITABLE			0x4		/* Make socket writable */
-#define SOCKET_EXCEPTION		0x8		/* Interested in exceptions */
-#define EMF_SOCKET_MESSAGE		(WM_USER+13)
+#define SOCKET_READABLE         0x2     /* Make socket readable */ 
+#define SOCKET_WRITABLE         0x4     /* Make socket writable */
+#define SOCKET_EXCEPTION        0x8     /* Interested in exceptions */
+#define EMF_SOCKET_MESSAGE      (WM_USER+13)
 
-#define WEBS_MAX_REQUEST		2048		/* Request safeguard max */
+#define WEBS_MAX_REQUEST        2048        /* Request safeguard max */
 
 #ifdef LITTLEFOOT
-#define SOCKET_BUFSIZ			510		/* Underlying buffer size */
+#define SOCKET_BUFSIZ           510     /* Underlying buffer size */
 #else
-#define SOCKET_BUFSIZ			1024	/* Underlying buffer size */
+#define SOCKET_BUFSIZ           1024    /* Underlying buffer size */
 #endif /* LITTLEFOOT */
 
-typedef void 	(*socketHandler_t)(int sid, int mask, void* data);
-typedef int		(*socketAccept_t)(int sid, char *ipaddr, int port, 
-					int listenSid);
+typedef void    (*socketHandler_t)(int sid, int mask, void* data);
+typedef int     (*socketAccept_t)(int sid, char *ipaddr, int port, 
+                    int listenSid);
 typedef struct {
-	char			host[64];				/* Host name */
-	ringq_t			inBuf;					/* Input ring queue */
-	ringq_t			outBuf;					/* Output ring queue */
-	ringq_t			lineBuf;				/* Line ring queue */
-	socketAccept_t	accept;					/* Accept handler */
-	socketHandler_t	handler;				/* User I/O handler */
-	void			*handler_data;			/* User handler data */
-	int				handlerMask;			/* Handler events of interest */
-	int				sid;					/* Index into socket[] */
-	int				port;					/* Port to listen on */
-	int				flags;					/* Current state flags */
-	int				sock;					/* Actual socket handle */
-	int				fileHandle;				/* ID of the file handler */
-	int				interestEvents;			/* Mask of events to watch for */
-	int				currentEvents;			/* Mask of ready events (FD_xx) */
-	int				selectEvents;			/* Events being selected */
-	int				saveMask;				/* saved Mask for socketFlush */
-	int				error;					/* Last error */
+    char            host[64];               /* Host name */
+    ringq_t         inBuf;                  /* Input ring queue */
+    ringq_t         outBuf;                 /* Output ring queue */
+    ringq_t         lineBuf;                /* Line ring queue */
+    socketAccept_t  accept;                 /* Accept handler */
+    socketHandler_t handler;                /* User I/O handler */
+    void            *handler_data;          /* User handler data */
+    int             handlerMask;            /* Handler events of interest */
+    int             sid;                    /* Index into socket[] */
+    int             port;                   /* Port to listen on */
+    int             flags;                  /* Current state flags */
+    int             sock;                   /* Actual socket handle */
+    int             fileHandle;             /* ID of the file handler */
+    int             interestEvents;         /* Mask of events to watch for */
+    int             currentEvents;          /* Mask of ready events (FD_xx) */
+    int             selectEvents;           /* Events being selected */
+    int             saveMask;               /* saved Mask for socketFlush */
+    int             error;                  /* Last error */
 } socket_t;
 
 /********************************* Prototypes *********************************/
 /*
-  	Balloc module
+    Balloc module
  */
 
-extern void 	 bclose();
-extern int 		 bopen(void *buf, int bufsize, int flags);
+extern void      bclose();
+extern int       bopen(void *buf, int bufsize, int flags);
 
 /*
     Define NO_BALLOC to turn off our balloc module altogether #define NO_BALLOC 1
@@ -1066,7 +1066,7 @@ extern int 		 bopen(void *buf, int bufsize, int flags);
 #define balloc(B_ARGS, num) malloc(num)
 #define bfree(B_ARGS, p) free(p)
 #define bfreeSafe(B_ARGS, p) \
-	if (p) { free(p); } else
+    if (p) { free(p); } else
 #define brealloc(B_ARGS, p, num) realloc(p, num)
 extern char_t *bstrdupNoBalloc(char_t *s);
 extern char *bstrdupANoBalloc(char *s);
@@ -1091,12 +1091,12 @@ extern char *bstrdupANoBalloc(char *s);
 
 #endif /* B_STATS */
 
-#define gstrdup	bstrdup
-extern void		*balloc(B_ARGS_DEC, int size);
-extern void		bfree(B_ARGS_DEC, void *mp);
-extern void		bfreeSafe(B_ARGS_DEC, void *mp);
-extern void		*brealloc(B_ARGS_DEC, void *buf, int newsize);
-extern char_t	*bstrdup(B_ARGS_DEC, char_t *s);
+#define gstrdup bstrdup
+extern void     *balloc(B_ARGS_DEC, int size);
+extern void     bfree(B_ARGS_DEC, void *mp);
+extern void     bfreeSafe(B_ARGS_DEC, void *mp);
+extern void     *brealloc(B_ARGS_DEC, void *buf, int newsize);
+extern char_t   *bstrdup(B_ARGS_DEC, char_t *s);
 
 #ifdef UNICODE
 extern char *bstrdupA(B_ARGS_DEC, char *s);
@@ -1108,55 +1108,55 @@ extern char *bstrdupA(B_ARGS_DEC, char *s);
 extern void bstats(int handle, void (*writefn)(int handle, char_t *fmt, ...));
 
 /*
- 	Flags. The integrity value is used as an arbitrary value to fill the flags.
+    Flags. The integrity value is used as an arbitrary value to fill the flags.
  */
-#define B_USE_MALLOC		0x1				/* Okay to use malloc if required */
-#define B_USER_BUF			0x2				/* User supplied buffer for mem */
+#define B_USE_MALLOC        0x1             /* Okay to use malloc if required */
+#define B_USER_BUF          0x2             /* User supplied buffer for mem */
 
 #ifndef LINUX
-extern char_t	*basename(char_t *name);
+extern char_t   *basename(char_t *name);
 #endif /* !LINUX */
 
-typedef void	(emfSchedProc)(void *data, int id);
-extern int		emfSchedCallback(int delay, emfSchedProc *proc, void *arg);
-extern void 	emfUnschedCallback(int id);
-extern void 	emfReschedCallback(int id, int delay);
-extern void		emfSchedProcess();
-extern int		emfInstGet();
-extern void		emfInstSet(int inst);
-extern void		error(E_ARGS_DEC, int flags, char_t *fmt, ...);
-extern void		(*errorSetHandler(void (*function)(int etype, char_t *msg))) (int etype, char_t *msg);
+typedef void    (emfSchedProc)(void *data, int id);
+extern int      emfSchedCallback(int delay, emfSchedProc *proc, void *arg);
+extern void     emfUnschedCallback(int id);
+extern void     emfReschedCallback(int id, int delay);
+extern void     emfSchedProcess();
+extern int      emfInstGet();
+extern void     emfInstSet(int inst);
+extern void     error(E_ARGS_DEC, int flags, char_t *fmt, ...);
+extern void     (*errorSetHandler(void (*function)(int etype, char_t *msg))) (int etype, char_t *msg);
 
 #ifdef B_STATS
-#define 		hAlloc(x) 				HALLOC(B_L, x)
-#define			hAllocEntry(x, y, z)	HALLOCENTRY(B_L, x, y, z)
-extern int		HALLOC(B_ARGS_DEC, void ***map);
-extern int 		HALLOCENTRY(B_ARGS_DEC, void ***list, int *max, int size);
+#define         hAlloc(x)               HALLOC(B_L, x)
+#define         hAllocEntry(x, y, z)    HALLOCENTRY(B_L, x, y, z)
+extern int      HALLOC(B_ARGS_DEC, void ***map);
+extern int      HALLOCENTRY(B_ARGS_DEC, void ***list, int *max, int size);
 #else
-extern int		hAlloc(void ***map);
-extern int 		hAllocEntry(void ***list, int *max, int size);
+extern int      hAlloc(void ***map);
+extern int      hAllocEntry(void ***list, int *max, int size);
 #endif /* B_STATS */
 
-extern int		hFree(void ***map, int handle);
+extern int      hFree(void ***map, int handle);
 
-extern int	 	ringqOpen(ringq_t *rq, int increment, int maxsize);
-extern void 	ringqClose(ringq_t *rq);
-extern int 		ringqLen(ringq_t *rq);
+extern int      ringqOpen(ringq_t *rq, int increment, int maxsize);
+extern void     ringqClose(ringq_t *rq);
+extern int      ringqLen(ringq_t *rq);
 
-extern int 		ringqPutc(ringq_t *rq, char_t c);
-extern int	 	ringqInsertc(ringq_t *rq, char_t c);
-extern int	 	ringqPutStr(ringq_t *rq, char_t *str);
-extern int 		ringqGetc(ringq_t *rq);
+extern int      ringqPutc(ringq_t *rq, char_t c);
+extern int      ringqInsertc(ringq_t *rq, char_t c);
+extern int      ringqPutStr(ringq_t *rq, char_t *str);
+extern int      ringqGetc(ringq_t *rq);
 
-extern int		fmtValloc(char_t **s, int n, char_t *fmt, va_list arg);
-extern int		fmtAlloc(char_t **s, int n, char_t *fmt, ...);
-extern int		fmtStatic(char_t *s, int n, char_t *fmt, ...);
+extern int      fmtValloc(char_t **s, int n, char_t *fmt, va_list arg);
+extern int      fmtAlloc(char_t **s, int n, char_t *fmt, ...);
+extern int      fmtStatic(char_t *s, int n, char_t *fmt, ...);
 
 #ifdef UNICODE
-extern int 		ringqPutcA(ringq_t *rq, char c);
-extern int	 	ringqInsertcA(ringq_t *rq, char c);
-extern int	 	ringqPutStrA(ringq_t *rq, char *str);
-extern int 		ringqGetcA(ringq_t *rq);
+extern int      ringqPutcA(ringq_t *rq, char c);
+extern int      ringqInsertcA(ringq_t *rq, char c);
+extern int      ringqPutStrA(ringq_t *rq, char *str);
+extern int      ringqGetcA(ringq_t *rq);
 #else
 #define ringqPutcA ringqPutc
 #define ringqInsertcA ringqInsertc
@@ -1164,95 +1164,95 @@ extern int 		ringqGetcA(ringq_t *rq);
 #define ringqGetcA ringqGetc
 #endif /* UNICODE */
 
-extern int 		ringqPutBlk(ringq_t *rq, unsigned char *buf, int len);
-extern int 		ringqPutBlkMax(ringq_t *rq);
-extern void 	ringqPutBlkAdj(ringq_t *rq, int size);
-extern int 		ringqGetBlk(ringq_t *rq, unsigned char *buf, int len);
-extern int 		ringqGetBlkMax(ringq_t *rq);
-extern void 	ringqGetBlkAdj(ringq_t *rq, int size);
-extern void 	ringqFlush(ringq_t *rq);
-extern void 	ringqAddNull(ringq_t *rq);
-
-extern int		scriptSetVar(int engine, char_t *var, char_t *value);
-extern int		scriptEval(int engine, char_t *cmd, char_t **rslt, void* chan);
-
-extern void		socketClose();
-extern void		socketCloseConnection(int sid);
-extern void		socketCreateHandler(int sid, int mask, socketHandler_t handler, void* arg);
-extern void		socketDeleteHandler(int sid);
-extern int		socketEof(int sid);
-extern int 		socketCanWrite(int sid);
-extern void 	socketSetBufferSize(int sid, int in, int line, int out);
-extern int		socketFlush(int sid);
-extern int		socketGets(int sid, char_t **buf);
-extern int		socketGetPort(int sid);
-extern int		socketInputBuffered(int sid);
-extern int		socketOpen();
-extern int 		socketOpenConnection(char *host, int port, socketAccept_t accept, int flags);
-extern void 	socketProcess(int hid);
-extern int		socketRead(int sid, char *buf, int len);
-extern int 		socketReady(int hid);
-extern int		socketWrite(int sid, char *buf, int len);
-extern int		socketWriteString(int sid, char_t *buf);
-extern int 		socketSelect(int hid, int timeout);
-extern int 		socketGetHandle(int sid);
-extern int 		socketSetBlock(int sid, int flags);
-extern int 		socketGetBlock(int sid);
-extern int 		socketAlloc(char *host, int port, socketAccept_t accept, int flags);
-extern void 	socketFree(int sid);
-extern int		socketGetError();
+extern int      ringqPutBlk(ringq_t *rq, unsigned char *buf, int len);
+extern int      ringqPutBlkMax(ringq_t *rq);
+extern void     ringqPutBlkAdj(ringq_t *rq, int size);
+extern int      ringqGetBlk(ringq_t *rq, unsigned char *buf, int len);
+extern int      ringqGetBlkMax(ringq_t *rq);
+extern void     ringqGetBlkAdj(ringq_t *rq, int size);
+extern void     ringqFlush(ringq_t *rq);
+extern void     ringqAddNull(ringq_t *rq);
+
+extern int      scriptSetVar(int engine, char_t *var, char_t *value);
+extern int      scriptEval(int engine, char_t *cmd, char_t **rslt, void* chan);
+
+extern void     socketClose();
+extern void     socketCloseConnection(int sid);
+extern void     socketCreateHandler(int sid, int mask, socketHandler_t handler, void* arg);
+extern void     socketDeleteHandler(int sid);
+extern int      socketEof(int sid);
+extern int      socketCanWrite(int sid);
+extern void     socketSetBufferSize(int sid, int in, int line, int out);
+extern int      socketFlush(int sid);
+extern int      socketGets(int sid, char_t **buf);
+extern int      socketGetPort(int sid);
+extern int      socketInputBuffered(int sid);
+extern int      socketOpen();
+extern int      socketOpenConnection(char *host, int port, socketAccept_t accept, int flags);
+extern void     socketProcess(int hid);
+extern int      socketRead(int sid, char *buf, int len);
+extern int      socketReady(int hid);
+extern int      socketWrite(int sid, char *buf, int len);
+extern int      socketWriteString(int sid, char_t *buf);
+extern int      socketSelect(int hid, int timeout);
+extern int      socketGetHandle(int sid);
+extern int      socketSetBlock(int sid, int flags);
+extern int      socketGetBlock(int sid);
+extern int      socketAlloc(char *host, int port, socketAccept_t accept, int flags);
+extern void     socketFree(int sid);
+extern int      socketGetError();
 extern socket_t *socketPtr(int sid);
-extern int 		socketWaitForEvent(socket_t *sp, int events, int *errCode);
-extern void 	socketRegisterInterest(socket_t *sp, int handlerMask);
-extern int 		socketGetInput(int sid, char *buf, int toRead, int *errCode);
-
-extern char_t	*strlower(char_t *string);
-extern char_t	*strupper(char_t *string);
-
-extern char_t	*stritoa(int n, char_t *string, int width);
-
-extern sym_fd_t	symOpen(int hash_size);
-extern void		symClose(sym_fd_t sd);
-extern sym_t	*symLookup(sym_fd_t sd, char_t *name);
-extern sym_t	*symEnter(sym_fd_t sd, char_t *name, value_t v, int arg);
-extern int		symDelete(sym_fd_t sd, char_t *name);
-extern void 	symWalk(sym_fd_t sd, void (*fn)(sym_t *symp));
-extern sym_t	*symFirst(sym_fd_t sd);
-extern sym_t	*symNext(sym_fd_t sd);
-extern int		symSubOpen();
-extern void 	symSubClose();
-
-extern void		trace(int lev, char_t *fmt, ...);
-extern void		traceRaw(char_t *buf);
-extern void		(*traceSetHandler(void (*function)(int level, char_t *buf))) (int level, char_t *buf);
+extern int      socketWaitForEvent(socket_t *sp, int events, int *errCode);
+extern void     socketRegisterInterest(socket_t *sp, int handlerMask);
+extern int      socketGetInput(int sid, char *buf, int toRead, int *errCode);
+
+extern char_t   *strlower(char_t *string);
+extern char_t   *strupper(char_t *string);
+
+extern char_t   *stritoa(int n, char_t *string, int width);
+
+extern sym_fd_t symOpen(int hash_size);
+extern void     symClose(sym_fd_t sd);
+extern sym_t    *symLookup(sym_fd_t sd, char_t *name);
+extern sym_t    *symEnter(sym_fd_t sd, char_t *name, value_t v, int arg);
+extern int      symDelete(sym_fd_t sd, char_t *name);
+extern void     symWalk(sym_fd_t sd, void (*fn)(sym_t *symp));
+extern sym_t    *symFirst(sym_fd_t sd);
+extern sym_t    *symNext(sym_fd_t sd);
+extern int      symSubOpen();
+extern void     symSubClose();
+
+extern void     trace(int lev, char_t *fmt, ...);
+extern void     traceRaw(char_t *buf);
+extern void     (*traceSetHandler(void (*function)(int level, char_t *buf))) (int level, char_t *buf);
  
-extern value_t 	valueInteger(long value);
-extern value_t	valueString(char_t *value, int flags);
-extern value_t	valueErrmsg(char_t *value);
-extern void 	valueFree(value_t *v);
-extern int		vxchdir(char *dirname);
+extern value_t  valueInteger(long value);
+extern value_t  valueString(char_t *value, int flags);
+extern value_t  valueErrmsg(char_t *value);
+extern void     valueFree(value_t *v);
+extern int      vxchdir(char *dirname);
 
 extern unsigned int hextoi(char_t *hexstring);
 extern unsigned int gstrtoi(char_t *s);
-externtime_t	timeMsec();
-
-extern char_t 	*ascToUni(char_t *ubuf, char *str, int nBytes);
-extern char 	*uniToAsc(char *buf, char_t *ustr, int nBytes);
-extern char_t	*ballocAscToUni(char  *cp, int alen);
-extern char		*ballocUniToAsc(char_t *unip, int ulen);
-
-extern char_t	*basicGetHost();
-extern char_t	*basicGetAddress();
-extern char_t	*basicGetProduct();
-extern void		basicSetHost(char_t *host);
-extern void		basicSetAddress(char_t *addr);
-
-extern int		harnessOpen(char_t **argv);
-extern void		harnessClose(int status);
-extern void		harnessTesting(char_t *msg, ...);
-extern void		harnessPassed();
-extern void		harnessFailed(int line);
-extern int		harnessLevel();
+externtime_t    timeMsec();
+
+extern char_t   *ascToUni(char_t *ubuf, char *str, int nBytes);
+extern char     *uniToAsc(char *buf, char_t *ustr, int nBytes);
+extern char_t   *ballocAscToUni(char  *cp, int alen);
+extern char     *ballocUniToAsc(char_t *unip, int ulen);
+
+extern char_t   *basicGetHost();
+extern char_t   *basicGetAddress();
+extern char_t   *basicGetProduct();
+extern void     basicSetHost(char_t *host);
+extern void     basicSetAddress(char_t *addr);
+
+extern int      harnessOpen(char_t **argv);
+extern void     harnessClose(int status);
+extern void     harnessTesting(char_t *msg, ...);
+extern void     harnessPassed();
+extern void     harnessFailed(int line);
+extern int      harnessLevel();
 
 #endif /* _h_UEMF */
 
diff --git a/um.c b/um.c
index 30866d3a..d68a4f49 100644
--- a/um.c
+++ b/um.c
@@ -1,7 +1,7 @@
 /*
     um.c -- User Management
 
-  	User Management routines for adding/deleting/changing users and groups
+    User Management routines for adding/deleting/changing users and groups
     Also, routines for determining user access
 
     Copyright (c) All Rights Reserved. See details at the end of the file.
@@ -9,121 +9,121 @@
 
 /********************************* Includes ***********************************/
 
-#include	"um.h"
-#include	"emfdb.h"
-#include	"webs.h"
+#include    "um.h"
+#include    "emfdb.h"
+#include    "webs.h"
 
 /********************************** Defines ***********************************/
 
-#define UM_DB_FILENAME	T("um.xml")
-#define UM_TXT_FILENAME	T("umconfig.txt")
+#define UM_DB_FILENAME  T("um.xml")
+#define UM_TXT_FILENAME T("umconfig.txt")
 
 /*
- *	Table names
+ *  Table names
  */
-#define UM_USER_TABLENAME	T("users")
-#define UM_GROUP_TABLENAME	T("groups")
-#define UM_ACCESS_TABLENAME	T("access")
+#define UM_USER_TABLENAME   T("users")
+#define UM_GROUP_TABLENAME  T("groups")
+#define UM_ACCESS_TABLENAME T("access")
 
 /*
- *	Column names
+ *  Column names
  */
-#define UM_NAME			T("name")
-#define UM_PASS			T("password")
-#define UM_GROUP		T("group")
-#define UM_PROT			T("prot")
-#define UM_DISABLE		T("disable")
-#define UM_METHOD		T("method")
-#define UM_PRIVILEGE	T("priv")
-#define UM_SECURE		T("secure")
+#define UM_NAME         T("name")
+#define UM_PASS         T("password")
+#define UM_GROUP        T("group")
+#define UM_PROT         T("prot")
+#define UM_DISABLE      T("disable")
+#define UM_METHOD       T("method")
+#define UM_PRIVILEGE    T("priv")
+#define UM_SECURE       T("secure")
 
 /*
-  	XOR encryption mask
-  	Note:This string should be modified for individual sites
+    XOR encryption mask
+    Note:This string should be modified for individual sites
         in order to enhance user password security.
     MOB - generate or move to config.
  */
-#define UM_XOR_ENCRYPT	T("*j7a(L#yZ98sSd5HfSgGjMj8;Ss;d)(*&^#@$a2s0i3g")
+#define UM_XOR_ENCRYPT  T("*j7a(L#yZ98sSd5HfSgGjMj8;Ss;d)(*&^#@$a2s0i3g")
 
 /********************************** Defines ***********************************/
 /*
-  	User table definition
+    User table definition
  */
-#define NUMBER_OF_USER_COLUMNS	5
+#define NUMBER_OF_USER_COLUMNS  5
 
 //  MOB - should these be static
-char_t	*userColumnNames[NUMBER_OF_USER_COLUMNS] = {
+char_t  *userColumnNames[NUMBER_OF_USER_COLUMNS] = {
         UM_NAME, UM_PASS, UM_GROUP, UM_PROT, UM_DISABLE
 };
 
-int		userColumnTypes[NUMBER_OF_USER_COLUMNS] = {
+int     userColumnTypes[NUMBER_OF_USER_COLUMNS] = {
         T_STRING, T_STRING, T_STRING, T_INT, T_INT
 };
 
 dbTable_t userTable = {
-	UM_USER_TABLENAME,
-	NUMBER_OF_USER_COLUMNS,
-	userColumnNames,
-	userColumnTypes,
-	0,
-	NULL
+    UM_USER_TABLENAME,
+    NUMBER_OF_USER_COLUMNS,
+    userColumnNames,
+    userColumnTypes,
+    0,
+    NULL
 };
 
 /*
-  	Group table definition
+    Group table definition
  */
-#define NUMBER_OF_GROUP_COLUMNS	5
+#define NUMBER_OF_GROUP_COLUMNS 5
 
-char_t	*groupColumnNames[NUMBER_OF_GROUP_COLUMNS] = {
+char_t  *groupColumnNames[NUMBER_OF_GROUP_COLUMNS] = {
         UM_NAME, UM_PRIVILEGE, UM_METHOD, UM_PROT, UM_DISABLE
 };
 
-int		groupColumnTypes[NUMBER_OF_GROUP_COLUMNS] = {
+int     groupColumnTypes[NUMBER_OF_GROUP_COLUMNS] = {
     T_STRING, T_INT, T_INT, T_INT, T_INT
 };
 
 dbTable_t groupTable = {
-	UM_GROUP_TABLENAME,
-	NUMBER_OF_GROUP_COLUMNS,
-	groupColumnNames,
-	groupColumnTypes,
-	0,
-	NULL
+    UM_GROUP_TABLENAME,
+    NUMBER_OF_GROUP_COLUMNS,
+    groupColumnNames,
+    groupColumnTypes,
+    0,
+    NULL
 };
 
 /*
- *	Access Limit table definition
+ *  Access Limit table definition
  */
-#define NUMBER_OF_ACCESS_COLUMNS	4
+#define NUMBER_OF_ACCESS_COLUMNS    4
 
-char_t	*accessColumnNames[NUMBER_OF_ACCESS_COLUMNS] = {
+char_t  *accessColumnNames[NUMBER_OF_ACCESS_COLUMNS] = {
     UM_NAME, UM_METHOD, UM_SECURE, UM_GROUP
 };
 
-int		accessColumnTypes[NUMBER_OF_ACCESS_COLUMNS] = {
+int     accessColumnTypes[NUMBER_OF_ACCESS_COLUMNS] = {
     T_STRING, T_INT, T_INT, T_STRING
 };
 
 dbTable_t accessTable = {
-	UM_ACCESS_TABLENAME,
-	NUMBER_OF_ACCESS_COLUMNS,
-	accessColumnNames,
-	accessColumnTypes,
-	0,
-	NULL
+    UM_ACCESS_TABLENAME,
+    NUMBER_OF_ACCESS_COLUMNS,
+    accessColumnNames,
+    accessColumnTypes,
+    0,
+    NULL
 };
 
 /* 
-  	Database Identifier returned from dbOpen()
+    Database Identifier returned from dbOpen()
  */
-static int  didUM = -1;	
+static int  didUM = -1; 
 
 /* 
-  	Configuration database persist filename
+    Configuration database persist filename
  */
-static char_t	*saveFilename = NULL;
+static char_t   *saveFilename = NULL;
 
-static int		umOpenCount = 0;		/* count of apps using this module */
+static int      umOpenCount = 0;        /* count of apps using this module */
 
 /********************************** Forwards **********************************/
 
@@ -131,596 +131,596 @@ static bool_t umCheckName(char_t *name);
 
 /*********************************** Code *************************************/
 /*
- *	umOpen() registers the UM tables in the fake emf-database 
+ *  umOpen() registers the UM tables in the fake emf-database 
  */
 
 int umOpen()
 {
-	if (++umOpenCount != 1) {
-		return didUM;
-	}
+    if (++umOpenCount != 1) {
+        return didUM;
+    }
 /*
- *	Do not initialize if intialization has already taken place
+ *  Do not initialize if intialization has already taken place
  */
-	if (didUM == -1) {
-		didUM = dbOpen(UM_USER_TABLENAME, UM_DB_FILENAME, NULL, 0);
-		dbRegisterDBSchema(&userTable);
-		dbRegisterDBSchema(&groupTable);
-		dbRegisterDBSchema(&accessTable);
-	}
-	if (saveFilename == NULL) {
-		saveFilename = bstrdup(B_L, UM_TXT_FILENAME);
-	}
-	return didUM;
+    if (didUM == -1) {
+        didUM = dbOpen(UM_USER_TABLENAME, UM_DB_FILENAME, NULL, 0);
+        dbRegisterDBSchema(&userTable);
+        dbRegisterDBSchema(&groupTable);
+        dbRegisterDBSchema(&accessTable);
+    }
+    if (saveFilename == NULL) {
+        saveFilename = bstrdup(B_L, UM_TXT_FILENAME);
+    }
+    return didUM;
 }
 
 
 void umClose()
 {
-	if (--umOpenCount > 0) {
-		return;
-	}
+    if (--umOpenCount > 0) {
+        return;
+    }
     /*
-      	Do not close if intialization has not taken place
+        Do not close if intialization has not taken place
      */
-	if (didUM != -1) {
-		dbClose(didUM);
-		didUM = -1;
-	}
-	if (saveFilename != NULL) {
-		bfree(B_L, saveFilename);
-		saveFilename = NULL;
-	}
+    if (didUM != -1) {
+        dbClose(didUM);
+        didUM = -1;
+    }
+    if (saveFilename != NULL) {
+        bfree(B_L, saveFilename);
+        saveFilename = NULL;
+    }
 }
 
 
 /*
-  	umCommit() persists all of the UM tables
+    umCommit() persists all of the UM tables
  */
-int	umCommit(char_t *filename)
+int umCommit(char_t *filename)
 {
-	if (filename && *filename) {
-		if (saveFilename != NULL) {
-			bfree(B_L, saveFilename);
-		}
-		saveFilename = bstrdup(B_L, filename);
-	}
-	a_assert (saveFilename && *saveFilename);
-	trace(3, T("UM: Writing User Configuration to file <%s>\n"), saveFilename);
-	return dbSave(didUM, saveFilename, 0);
+    if (filename && *filename) {
+        if (saveFilename != NULL) {
+            bfree(B_L, saveFilename);
+        }
+        saveFilename = bstrdup(B_L, filename);
+    }
+    a_assert (saveFilename && *saveFilename);
+    trace(3, T("UM: Writing User Configuration to file <%s>\n"), saveFilename);
+    return dbSave(didUM, saveFilename, 0);
 }
 
 /*
- 	umRestore() loads up the UM tables with persisted data
+    umRestore() loads up the UM tables with persisted data
  */
 int umRestore(char_t *filename)
 {
-	if (filename && *filename) {
-		if (saveFilename != NULL) {
-			bfree(B_L, saveFilename);
-		}
-		saveFilename = bstrdup(B_L, filename);
-	}
-	a_assert(saveFilename && *saveFilename);
-	trace(3, T("UM: Loading User Configuration from file <%s>\n"), saveFilename);
+    if (filename && *filename) {
+        if (saveFilename != NULL) {
+            bfree(B_L, saveFilename);
+        }
+        saveFilename = bstrdup(B_L, filename);
+    }
+    a_assert(saveFilename && *saveFilename);
+    trace(3, T("UM: Loading User Configuration from file <%s>\n"), saveFilename);
     /*
-      	First empty the database, otherwise we wind up with duplicates!
+        First empty the database, otherwise we wind up with duplicates!
      */
-	dbZero(didUM);
-	return dbLoad(didUM, saveFilename, 0);
+    dbZero(didUM);
+    return dbLoad(didUM, saveFilename, 0);
 }
 
 
 /*
-  	Encrypt/Decrypt a text string. Returns the number of characters encrypted.
+    Encrypt/Decrypt a text string. Returns the number of characters encrypted.
  */
 static int umEncryptString(char_t *textString)
 {
-	char_t	*enMask;
-	char_t	enChar;
-	int		numChars;
+    char_t  *enMask;
+    char_t  enChar;
+    int     numChars;
 
-	a_assert(textString);
+    a_assert(textString);
 
-	enMask = UM_XOR_ENCRYPT;
-	numChars = 0;
+    enMask = UM_XOR_ENCRYPT;
+    numChars = 0;
 
-	while (*textString) {
-		enChar = *textString ^ *enMask;
+    while (*textString) {
+        enChar = *textString ^ *enMask;
         /*
             Do not produce encrypted text with embedded linefeeds or tabs. Simply use existing character.
          */
-		if (enChar && !gisspace(enChar)) {
-			*textString = enChar;
+        if (enChar && !gisspace(enChar)) {
+            *textString = enChar;
         }
         /*
             Increment all pointers.
          */
-		enMask++;
-		textString++;
-		numChars++;
+        enMask++;
+        textString++;
+        numChars++;
         /*
             Wrap encryption mask pointer if at end of length.
          */
-		if (*enMask == '\0') {
-			enMask = UM_XOR_ENCRYPT;
-		}
-	}
-	return numChars;
+        if (*enMask == '\0') {
+            enMask = UM_XOR_ENCRYPT;
+        }
+    }
+    return numChars;
 }
 
 /*
-  	umGetFirstRowData() -	return a pointer to the first non-blank key value
-  							in the given column for the given table.
+    umGetFirstRowData() -   return a pointer to the first non-blank key value
+                            in the given column for the given table.
  */
 static char_t *umGetFirstRowData(char_t *tableName, char_t *columnName)
 {
-	char_t	*columnData;
-	int		row;
-	int		check;
+    char_t  *columnData;
+    int     row;
+    int     check;
 
-	a_assert(tableName && *tableName);
-	a_assert(columnName && *columnName);
+    a_assert(tableName && *tableName);
+    a_assert(columnName && *columnName);
 
-	row = 0;
+    row = 0;
     /*
         Move through table until we retrieve the first row with non-null column data.
      */
-	columnData = NULL;
-	while ((check = dbReadStr(didUM, tableName, columnName, row++, 
-		&columnData)) == 0 || (check == DB_ERR_ROW_DELETED)) {
-		if (columnData && *columnData) {
-			return columnData;
-		}
-	}
-
-	return NULL;
+    columnData = NULL;
+    while ((check = dbReadStr(didUM, tableName, columnName, row++, 
+        &columnData)) == 0 || (check == DB_ERR_ROW_DELETED)) {
+        if (columnData && *columnData) {
+            return columnData;
+        }
+    }
+
+    return NULL;
 }
 
 
 /*
-  	umGetNextRowData() -	return a pointer to the first non-blank 
-  						    key value following the given one.
+    umGetNextRowData() -    return a pointer to the first non-blank 
+                            key value following the given one.
  */
 
 static char_t *umGetNextRowData(char_t *tableName, char_t *columnName, 
-								char_t *keyLast)
+                                char_t *keyLast)
 {
-	char_t	*key;
-	int		row;
-	int		check;
+    char_t  *key;
+    int     row;
+    int     check;
 
-	a_assert(tableName && *tableName);
-	a_assert(columnName && *columnName);
-	a_assert(keyLast && *keyLast);
+    a_assert(tableName && *tableName);
+    a_assert(columnName && *columnName);
+    a_assert(keyLast && *keyLast);
 
     /*
-      	Position row counter to row where the given key value was found
+        Position row counter to row where the given key value was found
      */
-	row = 0;
-	key = NULL;
+    row = 0;
+    key = NULL;
 
-	while ((((check = dbReadStr(didUM, tableName, columnName, row++, 
-		&key)) == 0) || (check == DB_ERR_ROW_DELETED)) &&
-		((key == NULL) || (gstrcmp(key, keyLast) != 0))) {
-	}
+    while ((((check = dbReadStr(didUM, tableName, columnName, row++, 
+        &key)) == 0) || (check == DB_ERR_ROW_DELETED)) &&
+        ((key == NULL) || (gstrcmp(key, keyLast) != 0))) {
+    }
     /*
-      	If the last key value was not found, return NULL
+        If the last key value was not found, return NULL
      */
-	if (!key || gstrcmp(key, keyLast) != 0) {
-		return NULL;
-	}
+    if (!key || gstrcmp(key, keyLast) != 0) {
+        return NULL;
+    }
     /*
-      	Move through table until we retrieve the next row with a non-null key
+        Move through table until we retrieve the next row with a non-null key
      */
-	while (((check = dbReadStr(didUM, tableName, columnName, row++, &key)) 
-		== 0) || (check == DB_ERR_ROW_DELETED)) {
-		if (key && *key && (gstrcmp(key, keyLast) != 0)) {
-			return key;
-		}
-	}
-
-	return NULL;
+    while (((check = dbReadStr(didUM, tableName, columnName, row++, &key)) 
+        == 0) || (check == DB_ERR_ROW_DELETED)) {
+        if (key && *key && (gstrcmp(key, keyLast) != 0)) {
+            return key;
+        }
+    }
+
+    return NULL;
 }
 
 
 /*
-  	umAddUser() - Adds a user to the "users" table.
+    umAddUser() - Adds a user to the "users" table.
  */
-int	umAddUser(char_t *user, char_t *pass, char_t *group, bool_t prot, bool_t disabled)
+int umAddUser(char_t *user, char_t *pass, char_t *group, bool_t prot, bool_t disabled)
 {
-	int		row;
-	char_t	*password;
+    int     row;
+    char_t  *password;
 
-	a_assert(user && *user);
-	a_assert(pass && *pass);
-	a_assert(group && *group);
+    a_assert(user && *user);
+    a_assert(pass && *pass);
+    a_assert(group && *group);
 
-	trace(3, T("UM: Adding User <%s>\n"), user);
+    trace(3, T("UM: Adding User <%s>\n"), user);
 
     /*
-      	Do not allow duplicates
+        Do not allow duplicates
      */
-	if (umUserExists(user)) {
-		return UM_ERR_DUPLICATE;
-	}
+    if (umUserExists(user)) {
+        return UM_ERR_DUPLICATE;
+    }
 
     /*
-      	Make sure user name and password contain valid characters
+        Make sure user name and password contain valid characters
      */
-	if (!umCheckName(user)) {
-		return UM_ERR_BAD_NAME;
-	}
+    if (!umCheckName(user)) {
+        return UM_ERR_BAD_NAME;
+    }
 
-	if (!umCheckName(pass)) {
-		return UM_ERR_BAD_PASSWORD;
-	}
+    if (!umCheckName(pass)) {
+        return UM_ERR_BAD_PASSWORD;
+    }
 
     /*
-      	Make sure group exists
+        Make sure group exists
      */
-	if (!umGroupExists(group)) {
-		return UM_ERR_NOT_FOUND;
-	}
+    if (!umGroupExists(group)) {
+        return UM_ERR_NOT_FOUND;
+    }
 
     /*
-      	Now create the user record
+        Now create the user record
      */
-	row = dbAddRow(didUM, UM_USER_TABLENAME);
-
-	if (row < 0) {
-		return UM_ERR_GENERAL;
-	}
-	if (dbWriteStr(didUM, UM_USER_TABLENAME, UM_NAME, row, user) != 0) {
-		return UM_ERR_GENERAL;
-	}
-	password = bstrdup(B_L, pass);
-	umEncryptString(password);
-	dbWriteStr(didUM, UM_USER_TABLENAME, UM_PASS, row, password);
-	bfree(B_L, password);
-	dbWriteStr(didUM, UM_USER_TABLENAME, UM_GROUP, row, group);
-	dbWriteInt(didUM, UM_USER_TABLENAME, UM_PROT, row, prot); 
-	dbWriteInt(didUM, UM_USER_TABLENAME, UM_DISABLE, row, disabled);
-
-	return 0;
+    row = dbAddRow(didUM, UM_USER_TABLENAME);
+
+    if (row < 0) {
+        return UM_ERR_GENERAL;
+    }
+    if (dbWriteStr(didUM, UM_USER_TABLENAME, UM_NAME, row, user) != 0) {
+        return UM_ERR_GENERAL;
+    }
+    password = bstrdup(B_L, pass);
+    umEncryptString(password);
+    dbWriteStr(didUM, UM_USER_TABLENAME, UM_PASS, row, password);
+    bfree(B_L, password);
+    dbWriteStr(didUM, UM_USER_TABLENAME, UM_GROUP, row, group);
+    dbWriteInt(didUM, UM_USER_TABLENAME, UM_PROT, row, prot); 
+    dbWriteInt(didUM, UM_USER_TABLENAME, UM_DISABLE, row, disabled);
+
+    return 0;
 }
 
 
 /*
-  	umDeleteUser() - remove a user from the "users" table
+    umDeleteUser() - remove a user from the "users" table
  */
-int	umDeleteUser(char_t *user)
+int umDeleteUser(char_t *user)
 {
-	int row;
+    int row;
 
-	a_assert(user && *user);
-	trace(3, T("UM: Deleting User <%s>\n"), user);
+    a_assert(user && *user);
+    trace(3, T("UM: Deleting User <%s>\n"), user);
     /*
-      	Check to see if user is delete-protected
+        Check to see if user is delete-protected
      */
-	if (umGetUserProtected(user)) {
-		return UM_ERR_PROTECTED;
-	} 
+    if (umGetUserProtected(user)) {
+        return UM_ERR_PROTECTED;
+    } 
     /*
-      	If found, delete the user from the database
+        If found, delete the user from the database
      */
-	if ((row = dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0)) >= 0) {
-		return dbDeleteRow(didUM, UM_USER_TABLENAME, row);
-	} 
-	return UM_ERR_NOT_FOUND;
+    if ((row = dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0)) >= 0) {
+        return dbDeleteRow(didUM, UM_USER_TABLENAME, row);
+    } 
+    return UM_ERR_NOT_FOUND;
 }
 
 
 /*
-  	umGetFirstUser() -	Returns the user ID of the first user found in the
-  						"users" table.
+    umGetFirstUser() -  Returns the user ID of the first user found in the
+                        "users" table.
  */
 char_t *umGetFirstUser()
 {
-	return umGetFirstRowData(UM_USER_TABLENAME, UM_NAME);
+    return umGetFirstRowData(UM_USER_TABLENAME, UM_NAME);
 }
 
 
 /*
-  	umGetNextUser()	Returns the next user found in the "users" table after
-  					the given user. 	
+    umGetNextUser() Returns the next user found in the "users" table after
+                    the given user.     
  */
 char_t *umGetNextUser(char_t *userLast)
 {
-	return umGetNextRowData(UM_USER_TABLENAME, UM_NAME, userLast);
+    return umGetNextRowData(UM_USER_TABLENAME, UM_NAME, userLast);
 }
 
 
 /*
-  	umUserExists()	Returns TRUE if userid exists.
+    umUserExists()  Returns TRUE if userid exists.
  */
 bool_t umUserExists(char_t *user)
 {
-	a_assert(user && *user);
+    a_assert(user && *user);
 
-	if (dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0) >= 0) {
-		return TRUE;
-	} else {
-		return FALSE;
-	}
+    if (dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0) >= 0) {
+        return TRUE;
+    } else {
+        return FALSE;
+    }
 }
 
 
 /*
-  	umGetUserPassword() returns a de-crypted copy of the user password
+    umGetUserPassword() returns a de-crypted copy of the user password
  */
 char_t *umGetUserPassword(char_t *user)
 {
-	char_t	*password;
-	int		row;
+    char_t  *password;
+    int     row;
 
-	a_assert(user && *user);
+    a_assert(user && *user);
 
-	password = NULL;
-	row = dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0);
+    password = NULL;
+    row = dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0);
 
-	if (row >= 0) {
-		char_t *pass = NULL;
-		dbReadStr(didUM, UM_USER_TABLENAME, UM_PASS, row, &pass);
+    if (row >= 0) {
+        char_t *pass = NULL;
+        dbReadStr(didUM, UM_USER_TABLENAME, UM_PASS, row, &pass);
         /*
-            Decrypt	password. Note, this function returns a copy of the password, which must be deleted at some time in
+            Decrypt password. Note, this function returns a copy of the password, which must be deleted at some time in
             the future.
          */
-		password = bstrdup(B_L, pass);
-		umEncryptString(password);
-	}
-	return password;
+        password = bstrdup(B_L, pass);
+        umEncryptString(password);
+    }
+    return password;
 }
 
 /*
-  	umSetUserPassword() updates the user password in the user "table" after
-  						encrypting the given password
+    umSetUserPassword() updates the user password in the user "table" after
+                        encrypting the given password
  */
-int	umSetUserPassword(char_t *user, char_t *pass)
+int umSetUserPassword(char_t *user, char_t *pass)
 {
-	int		row, nRet;
-	char_t	*password;
+    int     row, nRet;
+    char_t  *password;
 
-	a_assert(user && *user);
-	a_assert(pass && *pass);
-	trace(3, T("UM: Attempting to change the password for user <%s>\n"), user);
+    a_assert(user && *user);
+    a_assert(pass && *pass);
+    trace(3, T("UM: Attempting to change the password for user <%s>\n"), user);
 
     /*
-      	Find the row of the user
+        Find the row of the user
      */
-	if ((row = dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0)) < 0) {
-		return UM_ERR_NOT_FOUND;
-	}
-	password = bstrdup(B_L, pass);
-	umEncryptString(password);
-	nRet = dbWriteStr(didUM, UM_USER_TABLENAME, UM_PASS, row, password);
-	bfree(B_L, password);
-
-	return nRet;
+    if ((row = dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0)) < 0) {
+        return UM_ERR_NOT_FOUND;
+    }
+    password = bstrdup(B_L, pass);
+    umEncryptString(password);
+    nRet = dbWriteStr(didUM, UM_USER_TABLENAME, UM_PASS, row, password);
+    bfree(B_L, password);
+
+    return nRet;
 }
 
 
 /*
-  	umGetUserGroup() returns the name of the user group
+    umGetUserGroup() returns the name of the user group
  */
 char_t *umGetUserGroup(char_t *user)
 {
-	char_t	*group;
-	int		row;
+    char_t  *group;
+    int     row;
 
-	a_assert(user && *user);
-	group = NULL;
+    a_assert(user && *user);
+    group = NULL;
     /*
-      	Find the row of the user
+        Find the row of the user
      */
-	row = dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0);
+    row = dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0);
 
-	if (row >= 0) {
-		dbReadStr(didUM, UM_USER_TABLENAME, UM_GROUP, row, &group);
-	}
-	return group;
+    if (row >= 0) {
+        dbReadStr(didUM, UM_USER_TABLENAME, UM_GROUP, row, &group);
+    }
+    return group;
 }
 
 
 /*
-  	umSetUserGroup() Sets the name of the user group for the user
+    umSetUserGroup() Sets the name of the user group for the user
  */
-int	umSetUserGroup(char_t *user, char_t *group)
+int umSetUserGroup(char_t *user, char_t *group)
 {
-	int row;
+    int row;
 
-	a_assert(user && *user);
-	a_assert(group && *group);
+    a_assert(user && *user);
+    a_assert(group && *group);
 
     /*
-      	Find the row of the user
+        Find the row of the user
      */
-	row = dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0);
-	if (row >= 0) {
-		return dbWriteStr(didUM, UM_USER_TABLENAME, UM_GROUP, row, group);
-	} else {
-		return UM_ERR_NOT_FOUND;
-	}
+    row = dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0);
+    if (row >= 0) {
+        return dbWriteStr(didUM, UM_USER_TABLENAME, UM_GROUP, row, group);
+    } else {
+        return UM_ERR_NOT_FOUND;
+    }
 }
 
 /*
-  	umGetUserEnabled() - returns if the user is enabled
-  	Returns FALSE if the user is not found.
+    umGetUserEnabled() - returns if the user is enabled
+    Returns FALSE if the user is not found.
  */
-bool_t	umGetUserEnabled(char_t *user)
+bool_t  umGetUserEnabled(char_t *user)
 {
-	int disabled, row;
+    int disabled, row;
 
-	a_assert(user && *user);
+    a_assert(user && *user);
 
-	disabled = 1;
+    disabled = 1;
     /*
-      	Find the row of the user
+        Find the row of the user
      */
-	row = dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0);
-	if (row >= 0) {
-		dbReadInt(didUM, UM_USER_TABLENAME, UM_DISABLE, row, &disabled);
-	}
-	return (bool_t)!disabled;
+    row = dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0);
+    if (row >= 0) {
+        dbReadInt(didUM, UM_USER_TABLENAME, UM_DISABLE, row, &disabled);
+    }
+    return (bool_t)!disabled;
 }
 
 
 /*
-  	umSetUserEnabled() Enables/disables the user
+    umSetUserEnabled() Enables/disables the user
  */
-int	umSetUserEnabled(char_t *user, bool_t enabled)
+int umSetUserEnabled(char_t *user, bool_t enabled)
 {
-	int row;
+    int row;
 
-	a_assert(user && *user);
+    a_assert(user && *user);
     /*
-      	Find the row of the user
+        Find the row of the user
      */
-	row = dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0);
-	if (row >= 0) {
-		return dbWriteInt(didUM, UM_USER_TABLENAME, UM_DISABLE, row, !enabled);
-	} else {
-		return UM_ERR_NOT_FOUND;
-	}
+    row = dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0);
+    if (row >= 0) {
+        return dbWriteInt(didUM, UM_USER_TABLENAME, UM_DISABLE, row, !enabled);
+    } else {
+        return UM_ERR_NOT_FOUND;
+    }
 }
 
 
 /*
-  	umGetUserProtected() - determine deletability of user
+    umGetUserProtected() - determine deletability of user
  */
 bool_t umGetUserProtected(char_t *user)
 {
-	int protect, row;
+    int protect, row;
 
-	a_assert(user && *user);
+    a_assert(user && *user);
     /*
-      	Find the row of the user
+        Find the row of the user
      */
-	row = dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0);
-	protect = FALSE;
-	if (row >= 0) {
-		dbReadInt(didUM, UM_USER_TABLENAME, UM_PROT, row, &protect);
-	}
-	return (bool_t)protect;
+    row = dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0);
+    protect = FALSE;
+    if (row >= 0) {
+        dbReadInt(didUM, UM_USER_TABLENAME, UM_PROT, row, &protect);
+    }
+    return (bool_t)protect;
 }
 
 
 /*
-  	umSetUserProtected() sets the delete protection for the user
+    umSetUserProtected() sets the delete protection for the user
  */
-int	umSetUserProtected(char_t *user, bool_t protect)
+int umSetUserProtected(char_t *user, bool_t protect)
 {
-	int row;
+    int row;
 
-	a_assert(user && *user);
+    a_assert(user && *user);
     /*
-      	Find the row of the user
+        Find the row of the user
      */
-	row = dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0);
-	if (row >= 0) {
-		return dbWriteInt(didUM, UM_USER_TABLENAME, UM_PROT, row, protect);
-	} else {
-		return UM_ERR_NOT_FOUND;
-	}
+    row = dbSearchStr(didUM, UM_USER_TABLENAME, UM_NAME, user, 0);
+    if (row >= 0) {
+        return dbWriteInt(didUM, UM_USER_TABLENAME, UM_PROT, row, protect);
+    } else {
+        return UM_ERR_NOT_FOUND;
+    }
 }
 
 
 /*
-  	umAddGroup() adds a group to the "Group" table
+    umAddGroup() adds a group to the "Group" table
  */
-int	umAddGroup(char_t *group, short priv, accessMeth_t am, bool_t prot, bool_t disabled)
+int umAddGroup(char_t *group, short priv, accessMeth_t am, bool_t prot, bool_t disabled)
 {
-	int row;
+    int row;
 
-	a_assert(group && *group);
-	trace(3, T("UM: Adding group <%s>\n"), group);
-	
+    a_assert(group && *group);
+    trace(3, T("UM: Adding group <%s>\n"), group);
+    
     /*
-      	Do not allow duplicates
+        Do not allow duplicates
      */
-	if (umGroupExists(group)) {
-		return UM_ERR_DUPLICATE;
-	}
+    if (umGroupExists(group)) {
+        return UM_ERR_DUPLICATE;
+    }
 
     /*
-      	Only allow valid characters in key field
+        Only allow valid characters in key field
      */
-	if (!umCheckName(group)) {
-		return UM_ERR_BAD_NAME;
-	}
+    if (!umCheckName(group)) {
+        return UM_ERR_BAD_NAME;
+    }
 
     /*
-      	Add a new row to the table
+        Add a new row to the table
      */
-	if ((row = dbAddRow(didUM, UM_GROUP_TABLENAME)) < 0) {
-		return UM_ERR_GENERAL;
-	}
+    if ((row = dbAddRow(didUM, UM_GROUP_TABLENAME)) < 0) {
+        return UM_ERR_GENERAL;
+    }
 
     /*
-      	Write the key field
+        Write the key field
      */
-	if (dbWriteStr(didUM, UM_GROUP_TABLENAME, UM_NAME, row, group) != 0) {
-		return UM_ERR_GENERAL;
-	}
+    if (dbWriteStr(didUM, UM_GROUP_TABLENAME, UM_NAME, row, group) != 0) {
+        return UM_ERR_GENERAL;
+    }
 
     /*
-      	Write the remaining fields
+        Write the remaining fields
      */
-	dbWriteInt(didUM, UM_GROUP_TABLENAME, UM_PRIVILEGE, row, priv);
-	dbWriteInt(didUM, UM_GROUP_TABLENAME, UM_METHOD, row, (int) am);
-	dbWriteInt(didUM, UM_GROUP_TABLENAME, UM_PROT, row, prot);
-	dbWriteInt(didUM, UM_GROUP_TABLENAME, UM_DISABLE, row, disabled);
-	return 0;
+    dbWriteInt(didUM, UM_GROUP_TABLENAME, UM_PRIVILEGE, row, priv);
+    dbWriteInt(didUM, UM_GROUP_TABLENAME, UM_METHOD, row, (int) am);
+    dbWriteInt(didUM, UM_GROUP_TABLENAME, UM_PROT, row, prot);
+    dbWriteInt(didUM, UM_GROUP_TABLENAME, UM_DISABLE, row, disabled);
+    return 0;
 }
 
 
 /*
-  	umDeleteGroup() - Delete a user group, if not protected
+    umDeleteGroup() - Delete a user group, if not protected
  */
-int	umDeleteGroup(char_t *group)
+int umDeleteGroup(char_t *group)
 {
-	int row;
+    int row;
 
-	a_assert(group && *group);
-	trace(3, T("UM: Deleting Group <%s>\n"), group);
+    a_assert(group && *group);
+    trace(3, T("UM: Deleting Group <%s>\n"), group);
 
     /*
-      	Check to see if the group is in use
+        Check to see if the group is in use
      */
-	if (umGetGroupInUse(group)) {
-		return UM_ERR_IN_USE;
-	} 
+    if (umGetGroupInUse(group)) {
+        return UM_ERR_IN_USE;
+    } 
 
     /*
-      	Check to see if the group is delete-protected
+        Check to see if the group is delete-protected
      */
-	if (umGetGroupProtected(group)) {
-		return UM_ERR_PROTECTED;
-	} 
+    if (umGetGroupProtected(group)) {
+        return UM_ERR_PROTECTED;
+    } 
 
     /*
-      	Find the row of the group to delete
+        Find the row of the group to delete
      */
-	if ((row = dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0)) < 0) {
-		return UM_ERR_NOT_FOUND;
-	}
+    if ((row = dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0)) < 0) {
+        return UM_ERR_NOT_FOUND;
+    }
 
-	return dbDeleteRow(didUM, UM_GROUP_TABLENAME, row);
+    return dbDeleteRow(didUM, UM_GROUP_TABLENAME, row);
 }
 
 /*
-  	umGroupExists() returns TRUE if group exists, FALSE otherwise
+    umGroupExists() returns TRUE if group exists, FALSE otherwise
  */
 
 bool_t umGroupExists(char_t *group)
 {
-	a_assert(group && *group);
+    a_assert(group && *group);
 
-	if (dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0) >= 0) {
-		return TRUE;
-	} else {
-		return FALSE;
-	}
+    if (dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0) >= 0) {
+        return TRUE;
+    } else {
+        return FALSE;
+    }
 }
 
 
@@ -729,109 +729,109 @@ bool_t umGroupExists(char_t *group)
  */
 bool_t umGetGroupInUse(char_t *group)
 {
-	a_assert(group && *group);
+    a_assert(group && *group);
 
     /*
-      	First, check the user table
+        First, check the user table
      */
-	if (dbSearchStr(didUM, UM_USER_TABLENAME, UM_GROUP, group, 0) >= 0) {
-		return TRUE;
-	} 
+    if (dbSearchStr(didUM, UM_USER_TABLENAME, UM_GROUP, group, 0) >= 0) {
+        return TRUE;
+    } 
     /*
-      	Second, check the access limit table
+        Second, check the access limit table
      */
-	if (dbSearchStr(didUM, UM_ACCESS_TABLENAME, UM_GROUP, group, 0) >= 0) {
-		return TRUE;
-	} 
-	return FALSE;
+    if (dbSearchStr(didUM, UM_ACCESS_TABLENAME, UM_GROUP, group, 0) >= 0) {
+        return TRUE;
+    } 
+    return FALSE;
 }
 
 
 /*
-  	umGetFirstGroup() - return a pointer to the first non-blank group name
+    umGetFirstGroup() - return a pointer to the first non-blank group name
  */
 char_t *umGetFirstGroup()
 {
-	return umGetFirstRowData(UM_GROUP_TABLENAME, UM_NAME);
+    return umGetFirstRowData(UM_GROUP_TABLENAME, UM_NAME);
 }
 
 /*
-  	umGetNextGroup() -	return a pointer to the first non-blank group name
-  						following the given group name
+    umGetNextGroup() -  return a pointer to the first non-blank group name
+                        following the given group name
  */
 char_t *umGetNextGroup(char_t *groupLast)
 {
-	return umGetNextRowData(UM_GROUP_TABLENAME, UM_NAME, groupLast);
+    return umGetNextRowData(UM_GROUP_TABLENAME, UM_NAME, groupLast);
 }
 
 
 /*
-  	Returns the default access method to use for a given group
+    Returns the default access method to use for a given group
  */
 accessMeth_t umGetGroupAccessMethod(char_t *group)
 {
-	int am, row;
-
-	a_assert(group && *group);
-	row = dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0);
-	if (row >= 0) {
-		dbReadInt(didUM, UM_GROUP_TABLENAME, UM_METHOD, row, (int *)&am);
-	} else {
-		am = AM_INVALID;
-	}
-	return (accessMeth_t) am;
+    int am, row;
+
+    a_assert(group && *group);
+    row = dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0);
+    if (row >= 0) {
+        dbReadInt(didUM, UM_GROUP_TABLENAME, UM_METHOD, row, (int *)&am);
+    } else {
+        am = AM_INVALID;
+    }
+    return (accessMeth_t) am;
 }
 
 
 /*
-  	Set the default access method to use for a given group
+    Set the default access method to use for a given group
  */
-int	umSetGroupAccessMethod(char_t *group, accessMeth_t am)
+int umSetGroupAccessMethod(char_t *group, accessMeth_t am)
 {
-	int row;
-
-	a_assert(group && *group);
-	row = dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0);
-	if (row >= 0) {
-		return dbWriteInt(didUM, UM_GROUP_TABLENAME, UM_METHOD, row, (int) am);
-	} else {
-		return UM_ERR_NOT_FOUND;
-	}
+    int row;
+
+    a_assert(group && *group);
+    row = dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0);
+    if (row >= 0) {
+        return dbWriteInt(didUM, UM_GROUP_TABLENAME, UM_METHOD, row, (int) am);
+    } else {
+        return UM_ERR_NOT_FOUND;
+    }
 }
 
 
 /*
-  	Returns the privilege mask for a given group
+    Returns the privilege mask for a given group
  */
 short umGetGroupPrivilege(char_t *group)
 {
-	int privilege, row;
-
-	a_assert(group && *group);
-	privilege = -1;
-	row = dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0);
-	if (row >= 0) {
-		dbReadInt(didUM, UM_GROUP_TABLENAME, UM_PRIVILEGE, row, &privilege);
-	}
-	return (short) privilege;
+    int privilege, row;
+
+    a_assert(group && *group);
+    privilege = -1;
+    row = dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0);
+    if (row >= 0) {
+        dbReadInt(didUM, UM_GROUP_TABLENAME, UM_PRIVILEGE, row, &privilege);
+    }
+    return (short) privilege;
 }
 
 
 /*
-  	Set the privilege mask for a given group
+    Set the privilege mask for a given group
  */
-int	umSetGroupPrivilege(char_t *group, short privilege)
+int umSetGroupPrivilege(char_t *group, short privilege)
 {
-	int row;
+    int row;
 
-	a_assert(group && *group);
-	row = dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0);
+    a_assert(group && *group);
+    row = dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0);
 
-	if (row >= 0) {
-		return dbWriteInt(didUM, UM_GROUP_TABLENAME, UM_PRIVILEGE, row, (int)privilege);
-	} else {
-		return UM_ERR_NOT_FOUND;
-	}
+    if (row >= 0) {
+        return dbWriteInt(didUM, UM_GROUP_TABLENAME, UM_PRIVILEGE, row, (int)privilege);
+    } else {
+        return UM_ERR_NOT_FOUND;
+    }
 }
 
 
@@ -840,272 +840,272 @@ int	umSetGroupPrivilege(char_t *group, short privilege)
  */
 bool_t umGetGroupEnabled(char_t *group)
 {
-	int disabled, row;
+    int disabled, row;
 
-	a_assert(group && *group);
-	row = dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0);
-	disabled = 1;
+    a_assert(group && *group);
+    row = dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0);
+    disabled = 1;
 
-	if (row >= 0) {
-		dbReadInt(didUM, UM_GROUP_TABLENAME, UM_DISABLE, row, &disabled);
-	}
-	return (bool_t) !disabled;
+    if (row >= 0) {
+        dbReadInt(didUM, UM_GROUP_TABLENAME, UM_DISABLE, row, &disabled);
+    }
+    return (bool_t) !disabled;
 }
 
 
 /*
-  	Sets the enabled setting for a given group.
+    Sets the enabled setting for a given group.
  */
 int umSetGroupEnabled(char_t *group, bool_t enabled)
 {
-	int row;
+    int row;
 
-	a_assert(group && *group);
-	row = dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0);
+    a_assert(group && *group);
+    row = dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0);
 
-	if (row >= 0) {
-		return dbWriteInt(didUM, UM_GROUP_TABLENAME, UM_DISABLE, row, (int) !enabled);
-	} else {
-		return UM_ERR_NOT_FOUND;
-	}
+    if (row >= 0) {
+        return dbWriteInt(didUM, UM_GROUP_TABLENAME, UM_DISABLE, row, (int) !enabled);
+    } else {
+        return UM_ERR_NOT_FOUND;
+    }
 }
 
 
 /*
-  	Returns the protected setting for a given group. Returns FALSE if user is not found
+    Returns the protected setting for a given group. Returns FALSE if user is not found
  */
 bool_t umGetGroupProtected(char_t *group)
 {
-	int protect, row;
+    int protect, row;
 
-	a_assert(group && *group);
+    a_assert(group && *group);
 
-	protect = 0;
-	row = dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0);
-	if (row >= 0) {
-		dbReadInt(didUM, UM_GROUP_TABLENAME, UM_PROT, row, &protect);
-	}
-	return (bool_t) protect;
+    protect = 0;
+    row = dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0);
+    if (row >= 0) {
+        dbReadInt(didUM, UM_GROUP_TABLENAME, UM_PROT, row, &protect);
+    }
+    return (bool_t) protect;
 }
 
 
 /*
-  	Sets the protected setting for a given group
+    Sets the protected setting for a given group
  */
-int	umSetGroupProtected(char_t *group, bool_t protect)
+int umSetGroupProtected(char_t *group, bool_t protect)
 {
-	int row;
+    int row;
 
-	a_assert(group && *group);
-	row = dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0);
+    a_assert(group && *group);
+    row = dbSearchStr(didUM, UM_GROUP_TABLENAME, UM_NAME, group, 0);
 
-	if (row >= 0) {
-		return dbWriteInt(didUM, UM_GROUP_TABLENAME, UM_PROT, row, (int) protect);
-	} else {
-		return UM_ERR_NOT_FOUND;
-	}
+    if (row >= 0) {
+        return dbWriteInt(didUM, UM_GROUP_TABLENAME, UM_PROT, row, (int) protect);
+    } else {
+        return UM_ERR_NOT_FOUND;
+    }
 }
 
 
 /*
-  	umAddAccessLimit() adds an access limit to the "access" table
+    umAddAccessLimit() adds an access limit to the "access" table
  */
-int	umAddAccessLimit(char_t *url, accessMeth_t am, short secure, char_t *group)
+int umAddAccessLimit(char_t *url, accessMeth_t am, short secure, char_t *group)
 {
-	int row;
+    int row;
 
-	a_assert(url && *url);
-	trace(3, T("UM: Adding Access Limit for <%s>\n"), url);
+    a_assert(url && *url);
+    trace(3, T("UM: Adding Access Limit for <%s>\n"), url);
 
     /*
-      	Do not allow duplicates
+        Do not allow duplicates
      */
-	if (umAccessLimitExists(url)) {
-		return UM_ERR_DUPLICATE;
-	}
+    if (umAccessLimitExists(url)) {
+        return UM_ERR_DUPLICATE;
+    }
 
     /*
-      	Add a new row to the table
+        Add a new row to the table
      */
-	if ((row = dbAddRow(didUM, UM_ACCESS_TABLENAME)) < 0) {
-		return UM_ERR_GENERAL;
-	}
+    if ((row = dbAddRow(didUM, UM_ACCESS_TABLENAME)) < 0) {
+        return UM_ERR_GENERAL;
+    }
 
     /*
-      	Write the key field
+        Write the key field
      */
-	if(dbWriteStr(didUM, UM_ACCESS_TABLENAME, UM_NAME, row, url) < 0) {
-		return UM_ERR_GENERAL;
-	}
+    if(dbWriteStr(didUM, UM_ACCESS_TABLENAME, UM_NAME, row, url) < 0) {
+        return UM_ERR_GENERAL;
+    }
 
     /*
-      	Write the remaining fields
+        Write the remaining fields
      */
-	dbWriteInt(didUM, UM_ACCESS_TABLENAME, UM_METHOD, row, (int)am);
-	dbWriteInt(didUM, UM_ACCESS_TABLENAME, UM_SECURE, row, (int)secure);
-	dbWriteStr(didUM, UM_ACCESS_TABLENAME, UM_GROUP, row, group);
-	return 0;
+    dbWriteInt(didUM, UM_ACCESS_TABLENAME, UM_METHOD, row, (int)am);
+    dbWriteInt(didUM, UM_ACCESS_TABLENAME, UM_SECURE, row, (int)secure);
+    dbWriteStr(didUM, UM_ACCESS_TABLENAME, UM_GROUP, row, group);
+    return 0;
 }
 
 
 /*
-  	umDeleteAccessLimit()
+    umDeleteAccessLimit()
  */
-int	umDeleteAccessLimit(char_t *url)
+int umDeleteAccessLimit(char_t *url)
 {
-	int row;
+    int row;
 
-	a_assert(url && *url);
-	trace(3, T("UM: Deleting Access Limit for <%s>\n"), url);
+    a_assert(url && *url);
+    trace(3, T("UM: Deleting Access Limit for <%s>\n"), url);
     /*
-      	Find the row of the access limit to delete
+        Find the row of the access limit to delete
      */
-	if ((row = dbSearchStr(didUM, UM_ACCESS_TABLENAME, UM_NAME, url, 0)) < 0) {
-		return UM_ERR_NOT_FOUND;
-	}
-	return dbDeleteRow(didUM, UM_ACCESS_TABLENAME, row);
+    if ((row = dbSearchStr(didUM, UM_ACCESS_TABLENAME, UM_NAME, url, 0)) < 0) {
+        return UM_ERR_NOT_FOUND;
+    }
+    return dbDeleteRow(didUM, UM_ACCESS_TABLENAME, row);
 }
 
 
 /*
-  	umGetFirstGroup() - return a pointer to the first non-blank access limit
+    umGetFirstGroup() - return a pointer to the first non-blank access limit
  */
 char_t *umGetFirstAccessLimit()
 {
-	return umGetFirstRowData(UM_ACCESS_TABLENAME, UM_NAME);
+    return umGetFirstRowData(UM_ACCESS_TABLENAME, UM_NAME);
 }
 
 
 /*
-  	umGetNextAccessLimit() -	return a pointer to the first non-blank 
-  								access limit following the given one
+    umGetNextAccessLimit() -    return a pointer to the first non-blank 
+                                access limit following the given one
  */
 char_t *umGetNextAccessLimit(char_t *urlLast)
 {
-	return umGetNextRowData(UM_ACCESS_TABLENAME, UM_NAME, urlLast);
+    return umGetNextRowData(UM_ACCESS_TABLENAME, UM_NAME, urlLast);
 }
 
 
 /*
-  	umAccessLimitExists() returns TRUE if this access limit exists
+    umAccessLimitExists() returns TRUE if this access limit exists
  */
-bool_t	umAccessLimitExists(char_t *url)
+bool_t  umAccessLimitExists(char_t *url)
 {
-	a_assert(url && *url);
+    a_assert(url && *url);
 
-	if (dbSearchStr(didUM, UM_ACCESS_TABLENAME, UM_NAME, url, 0) < 0) {
-		return FALSE;
-	} else {
-		return TRUE;
-	}
+    if (dbSearchStr(didUM, UM_ACCESS_TABLENAME, UM_NAME, url, 0) < 0) {
+        return FALSE;
+    } else {
+        return TRUE;
+    }
 }
 
 /*
-  	umGetAccessLimit() returns the Access Method for the URL
+    umGetAccessLimit() returns the Access Method for the URL
  */
 accessMeth_t umGetAccessLimitMethod(char_t *url)
 {
-	int am, row;
+    int am, row;
 
-	am = (int) AM_INVALID;
-	row = dbSearchStr(didUM, UM_ACCESS_TABLENAME, UM_NAME, url, 0);
+    am = (int) AM_INVALID;
+    row = dbSearchStr(didUM, UM_ACCESS_TABLENAME, UM_NAME, url, 0);
 
-	if (row >= 0) {
-		dbReadInt(didUM, UM_ACCESS_TABLENAME, UM_METHOD, row, &am);
-	} 
-	return (accessMeth_t) am;
+    if (row >= 0) {
+        dbReadInt(didUM, UM_ACCESS_TABLENAME, UM_METHOD, row, &am);
+    } 
+    return (accessMeth_t) am;
 }
 
 
 /*
-  	umSetAccessLimitMethod() - set Access Method for Access Limit
+    umSetAccessLimitMethod() - set Access Method for Access Limit
  */
-int	umSetAccessLimitMethod(char_t *url, accessMeth_t am)
+int umSetAccessLimitMethod(char_t *url, accessMeth_t am)
 {
-	int row;
+    int row;
 
-	a_assert(url && *url);
-	row = dbSearchStr(didUM, UM_ACCESS_TABLENAME, UM_NAME, url, 0);
+    a_assert(url && *url);
+    row = dbSearchStr(didUM, UM_ACCESS_TABLENAME, UM_NAME, url, 0);
 
-	if (row >= 0) {
-		return dbWriteInt(didUM, UM_ACCESS_TABLENAME, UM_METHOD, row, (int) am);
-	} else {
-		return UM_ERR_NOT_FOUND;
-	}
+    if (row >= 0) {
+        return dbWriteInt(didUM, UM_ACCESS_TABLENAME, UM_METHOD, row, (int) am);
+    } else {
+        return UM_ERR_NOT_FOUND;
+    }
 }
 
 
 /*
-  	umGetAccessLimitSecure() - returns secure switch for access limit
+    umGetAccessLimitSecure() - returns secure switch for access limit
  */
 short umGetAccessLimitSecure(char_t *url)
 {
-	int secure, row;
+    int secure, row;
 
-	a_assert(url && *url);
-	secure = -1;
-	row = dbSearchStr(didUM, UM_ACCESS_TABLENAME, UM_NAME, url, 0);
+    a_assert(url && *url);
+    secure = -1;
+    row = dbSearchStr(didUM, UM_ACCESS_TABLENAME, UM_NAME, url, 0);
 
-	if (row >= 0) {
-		dbReadInt(didUM, UM_ACCESS_TABLENAME, UM_SECURE, row, &secure);
-	}
+    if (row >= 0) {
+        dbReadInt(didUM, UM_ACCESS_TABLENAME, UM_SECURE, row, &secure);
+    }
 
-	return (short)secure;
+    return (short)secure;
 }
 
 
 /*
-  	umSetAccessLimitSecure() - sets the secure flag for the URL
+    umSetAccessLimitSecure() - sets the secure flag for the URL
  */
-int	umSetAccessLimitSecure(char_t *url, short secure)
+int umSetAccessLimitSecure(char_t *url, short secure)
 {
-	int row;
+    int row;
 
-	a_assert(url && *url);
-	row = dbSearchStr(didUM, UM_ACCESS_TABLENAME, UM_NAME, url, 0);
+    a_assert(url && *url);
+    row = dbSearchStr(didUM, UM_ACCESS_TABLENAME, UM_NAME, url, 0);
 
-	if (row >= 0) {
-		return dbWriteInt(didUM, UM_ACCESS_TABLENAME, UM_SECURE, row, (int)secure);
-	} else {
-		return UM_ERR_NOT_FOUND;
-	}
+    if (row >= 0) {
+        return dbWriteInt(didUM, UM_ACCESS_TABLENAME, UM_SECURE, row, (int)secure);
+    } else {
+        return UM_ERR_NOT_FOUND;
+    }
 }
 
 
 /*
-  	umGetAccessLimitGroup() - returns the user group of the access limit
+    umGetAccessLimitGroup() - returns the user group of the access limit
  */
 char_t *umGetAccessLimitGroup(char_t *url)
 {
-	char_t	*group;
-	int		row;
+    char_t  *group;
+    int     row;
 
-	a_assert(url && *url);
-	group = NULL;
-	row = dbSearchStr(didUM, UM_ACCESS_TABLENAME, UM_NAME, url, 0);
+    a_assert(url && *url);
+    group = NULL;
+    row = dbSearchStr(didUM, UM_ACCESS_TABLENAME, UM_NAME, url, 0);
 
-	if (row >= 0) {
-		dbReadStr(didUM, UM_ACCESS_TABLENAME, UM_GROUP, row, &group);
-	}
-	return group;
+    if (row >= 0) {
+        dbReadStr(didUM, UM_ACCESS_TABLENAME, UM_GROUP, row, &group);
+    }
+    return group;
 }
 
 
 /*
-  	umSetAccessLimitGroup() - sets the user group for the access limit.
+    umSetAccessLimitGroup() - sets the user group for the access limit.
  */
-int	umSetAccessLimitGroup(char_t *url, char_t *group)
+int umSetAccessLimitGroup(char_t *url, char_t *group)
 {
-	int row;
+    int row;
 
-	a_assert(url && *url);
-	row = dbSearchStr(didUM, UM_ACCESS_TABLENAME, UM_NAME, url, 0);
+    a_assert(url && *url);
+    row = dbSearchStr(didUM, UM_ACCESS_TABLENAME, UM_NAME, url, 0);
 
-	if (row >= 0) {
-		return dbWriteStr(didUM, UM_ACCESS_TABLENAME, UM_GROUP, row, group);
-	} else {
-		return UM_ERR_NOT_FOUND;
-	}
+    if (row >= 0) {
+        return dbWriteStr(didUM, UM_ACCESS_TABLENAME, UM_GROUP, row, group);
+    } else {
+        return UM_ERR_NOT_FOUND;
+    }
 }
 
 
@@ -1115,155 +1115,155 @@ int	umSetAccessLimitGroup(char_t *url, char_t *group)
  */
 char_t *umGetAccessLimit(char_t *url)
 {
-	char_t	*urlRet, *urlCheck, *lastChar;
-	int		len;
-	
-	a_assert(url && *url);
-	urlRet = NULL;
-	urlCheck = bstrdup(B_L, url);
-	a_assert(urlCheck);
-	len = gstrlen(urlCheck);
+    char_t  *urlRet, *urlCheck, *lastChar;
+    int     len;
+    
+    a_assert(url && *url);
+    urlRet = NULL;
+    urlCheck = bstrdup(B_L, url);
+    a_assert(urlCheck);
+    len = gstrlen(urlCheck);
     /*
-      	Scan back through URL to see if there is a "parent" access limit
+        Scan back through URL to see if there is a "parent" access limit
      */
-	while (len && !urlRet) {
-		if (umAccessLimitExists(urlCheck)) {
-			urlRet = bstrdup(B_L, urlCheck);
-		} else {
+    while (len && !urlRet) {
+        if (umAccessLimitExists(urlCheck)) {
+            urlRet = bstrdup(B_L, urlCheck);
+        } else {
             /*
-              	Trim the end portion of the URL to the previous directory marker
+                Trim the end portion of the URL to the previous directory marker
              */
-			lastChar = urlCheck + len;
-			lastChar--;
-
-			while ((lastChar >= urlCheck) && ((*lastChar == '/') || 
-				(*lastChar == '\\'))) {
-				*lastChar = 0;
-				lastChar--;
-			}
-			while ((lastChar >= urlCheck) && (*lastChar != '/') && 
-				(*lastChar != '\\')) {
-				*lastChar = 0;
-				lastChar--;
-			}
-			len = gstrlen(urlCheck);
-		}
-	}
-	bfree (B_L, urlCheck);
-
-	return urlRet;
+            lastChar = urlCheck + len;
+            lastChar--;
+
+            while ((lastChar >= urlCheck) && ((*lastChar == '/') || 
+                (*lastChar == '\\'))) {
+                *lastChar = 0;
+                lastChar--;
+            }
+            while ((lastChar >= urlCheck) && (*lastChar != '/') && 
+                (*lastChar != '\\')) {
+                *lastChar = 0;
+                lastChar--;
+            }
+            len = gstrlen(urlCheck);
+        }
+    }
+    bfree (B_L, urlCheck);
+
+    return urlRet;
 }
 
 
 /*
-  	Returns the access method to use for a given URL
+    Returns the access method to use for a given URL
  */
 accessMeth_t umGetAccessMethodForURL(char_t *url)
 {
-	accessMeth_t	amRet;
-	char_t			*urlHavingLimit, *group;
-	
-	urlHavingLimit = umGetAccessLimit(url);
-	if (urlHavingLimit) {
-		group = umGetAccessLimitGroup(urlHavingLimit);
-
-		if (group && *group) {
-			amRet = umGetGroupAccessMethod(group);
-		} else {
-			amRet = umGetAccessLimitMethod(urlHavingLimit);
-		}
-		bfree(B_L, urlHavingLimit);
-	} else {
-		amRet = AM_FULL;
-	}
-	return amRet;
+    accessMeth_t    amRet;
+    char_t          *urlHavingLimit, *group;
+    
+    urlHavingLimit = umGetAccessLimit(url);
+    if (urlHavingLimit) {
+        group = umGetAccessLimitGroup(urlHavingLimit);
+
+        if (group && *group) {
+            amRet = umGetGroupAccessMethod(group);
+        } else {
+            amRet = umGetAccessLimitMethod(urlHavingLimit);
+        }
+        bfree(B_L, urlHavingLimit);
+    } else {
+        amRet = AM_FULL;
+    }
+    return amRet;
 }
 
 
 /*
-  	Returns TRUE if user can access URL
+    Returns TRUE if user can access URL
  */
 bool_t umUserCanAccessURL(char_t *user, char_t *url)
 {
-	accessMeth_t	amURL;
-	char_t			*group, *usergroup, *urlHavingLimit;
-	short			priv;
-	
-	a_assert(user && *user);
-	a_assert(url && *url);
+    accessMeth_t    amURL;
+    char_t          *group, *usergroup, *urlHavingLimit;
+    short           priv;
+    
+    a_assert(user && *user);
+    a_assert(url && *url);
 
     /*
-      	Make sure user exists
+        Make sure user exists
      */
-	if (!umUserExists(user)) {
-		return FALSE;
-	}
+    if (!umUserExists(user)) {
+        return FALSE;
+    }
 
     /*
-      	Make sure user is enabled
+        Make sure user is enabled
      */
-	if (!umGetUserEnabled(user)) {
-		return FALSE;
-	}
+    if (!umGetUserEnabled(user)) {
+        return FALSE;
+    }
 
     /*
-      	Make sure user has sufficient privileges (any will do)
+        Make sure user has sufficient privileges (any will do)
      */
-	usergroup = umGetUserGroup(user);
-	priv = umGetGroupPrivilege(usergroup);
-	if (priv == 0) {
-		return FALSE;
-	}
+    usergroup = umGetUserGroup(user);
+    priv = umGetGroupPrivilege(usergroup);
+    if (priv == 0) {
+        return FALSE;
+    }
 
     /*
-      	Make sure user's group is enabled
+        Make sure user's group is enabled
      */
-	if (!umGetGroupEnabled(usergroup)) {
-		return FALSE;
-	}
+    if (!umGetGroupEnabled(usergroup)) {
+        return FALSE;
+    }
 
     /*
-      	The access method of the user group must not be AM_NONE
+        The access method of the user group must not be AM_NONE
      */
-	if (umGetGroupAccessMethod(usergroup) == AM_NONE) {
-		return FALSE;
-	}
+    if (umGetGroupAccessMethod(usergroup) == AM_NONE) {
+        return FALSE;
+    }
 
     /*
-      	Check to see if there is an Access Limit for this URL
+        Check to see if there is an Access Limit for this URL
      */
-	urlHavingLimit = umGetAccessLimit(url);
-	if (urlHavingLimit) {
-		amURL = umGetAccessLimitMethod(urlHavingLimit);
-		group = umGetAccessLimitGroup(urlHavingLimit);
-		bfree(B_L, urlHavingLimit);
-	} else {
+    urlHavingLimit = umGetAccessLimit(url);
+    if (urlHavingLimit) {
+        amURL = umGetAccessLimitMethod(urlHavingLimit);
+        group = umGetAccessLimitGroup(urlHavingLimit);
+        bfree(B_L, urlHavingLimit);
+    } else {
         /*
             If there isn't an access limit for the URL, user has full access
          */
-		return TRUE;
-	}
+        return TRUE;
+    }
 
     /*
         If the access method for the URL is AM_NONE then the file "doesn't exist".
      */
-	if (amURL == AM_NONE) {
-		return FALSE;
-	} 
-	
+    if (amURL == AM_NONE) {
+        return FALSE;
+    } 
+    
     /*
         If Access Limit has a group specified, then the user must be a member of that group
      */
-	if (group && *group) {
-		if (usergroup && (gstrcmp(group, usergroup) != 0)) {
-			return FALSE;
+    if (group && *group) {
+        if (usergroup && (gstrcmp(group, usergroup) != 0)) {
+            return FALSE;
 
-		}
-	} 
+        }
+    } 
     /*
-      	Otherwise, user can access the URL 
+        Otherwise, user can access the URL 
      */
-	return TRUE;
+    return TRUE;
 
 }
 
@@ -1273,18 +1273,18 @@ bool_t umUserCanAccessURL(char_t *user, char_t *url)
  */
 static bool_t umCheckName(char_t *name)
 {
-	a_assert(name && *name);
-
-	if (name && *name) {
-		while (*name) {
-			if (gisspace(*name)) {
-				return FALSE;
-			}
-			name++;
-		}
-		return TRUE;
-	}
-	return FALSE;
+    a_assert(name && *name);
+
+    if (name && *name) {
+        while (*name) {
+            if (gisspace(*name)) {
+                return FALSE;
+            }
+            name++;
+        }
+        return TRUE;
+    }
+    return FALSE;
 }
 
 
diff --git a/um.h b/um.h
index ae308526..e2d130d1 100644
--- a/um.h
+++ b/um.h
@@ -1,5 +1,5 @@
 /*
-  	um.h -- GoAhead User Management public header
+    um.h -- GoAhead User Management public header
   
     Copyright (c) All Rights Reserved. See details at the end of the file.
  */
@@ -9,31 +9,31 @@
 
 /********************************* Includes ***********************************/
 
-#include	"uemf.h"
+#include    "uemf.h"
 
 /********************************** Defines ***********************************/
 /*
-  	Error Return Flags
+    Error Return Flags
  */
-#define UM_OK				0
-#define UM_ERR_GENERAL		-1
-#define UM_ERR_NOT_FOUND	-2
-#define UM_ERR_PROTECTED	-3
-#define UM_ERR_DUPLICATE	-4
-#define UM_ERR_IN_USE		-5
-#define UM_ERR_BAD_NAME		-6
+#define UM_OK               0
+#define UM_ERR_GENERAL      -1
+#define UM_ERR_NOT_FOUND    -2
+#define UM_ERR_PROTECTED    -3
+#define UM_ERR_DUPLICATE    -4
+#define UM_ERR_IN_USE       -5
+#define UM_ERR_BAD_NAME     -6
 #define UM_ERR_BAD_PASSWORD -7
 
 /*
-  	Privilege Masks
+    Privilege Masks
  */
-#define PRIV_NONE	0x00
-#define PRIV_READ	0x01
-#define PRIV_WRITE	0x02
-#define PRIV_ADMIN	0x04
+#define PRIV_NONE   0x00
+#define PRIV_READ   0x01
+#define PRIV_WRITE  0x02
+#define PRIV_ADMIN  0x04
 
 /*
-  	User classes
+    User classes
  */
 typedef short bool_t;
 
@@ -46,117 +46,117 @@ typedef short bool_t;
 #endif
 
 typedef enum {
-	AM_NONE = 0,
-	AM_FULL,
-	AM_BASIC,
-	AM_DIGEST,
-	AM_INVALID
+    AM_NONE = 0,
+    AM_FULL,
+    AM_BASIC,
+    AM_DIGEST,
+    AM_INVALID
 } accessMeth_t;
 
 /********************************** Prototypes ********************************/
 //  MOB - Doxygen
 /*
-  	umOpen() must be called before accessing User Management functions
+    umOpen() must be called before accessing User Management functions
  */
-extern int				umOpen();
+extern int              umOpen();
 
 /*
-  	umClose() should be called before shutdown to free memory
+    umClose() should be called before shutdown to free memory
  */
-extern void				umClose();
+extern void             umClose();
 
 /*
-  	umCommit() persists the user management database
+    umCommit() persists the user management database
  */
-extern int				umCommit(char_t *filename);
+extern int              umCommit(char_t *filename);
 
 /*
-  	umRestore() loads the user management database
+    umRestore() loads the user management database
  */
-extern int				umRestore(char_t *filename);
+extern int              umRestore(char_t *filename);
 
 /*
-  	umUser functions use a user ID for a key
+    umUser functions use a user ID for a key
  */
-extern int				umAddUser(char_t *user, char_t *password, char_t *group, bool_t protect, bool_t disabled);
+extern int              umAddUser(char_t *user, char_t *password, char_t *group, bool_t protect, bool_t disabled);
 
-extern int				umDeleteUser(char_t *user);
+extern int              umDeleteUser(char_t *user);
 
-extern char_t			*umGetFirstUser();
-extern char_t			*umGetNextUser(char_t *lastUser);
+extern char_t           *umGetFirstUser();
+extern char_t           *umGetNextUser(char_t *lastUser);
 
-extern bool_t			umUserExists(char_t *user);
+extern bool_t           umUserExists(char_t *user);
 
-extern char_t			*umGetUserPassword(char_t *user);
-extern int				umSetUserPassword(char_t *user, char_t *password);
+extern char_t           *umGetUserPassword(char_t *user);
+extern int              umSetUserPassword(char_t *user, char_t *password);
 
-extern char_t			*umGetUserGroup(char_t *user);
-extern int				umSetUserGroup(char_t *user, char_t *password);
+extern char_t           *umGetUserGroup(char_t *user);
+extern int              umSetUserGroup(char_t *user, char_t *password);
 
-extern bool_t			umGetUserEnabled(char_t *user);
-extern int				umSetUserEnabled(char_t *user, bool_t enabled);
+extern bool_t           umGetUserEnabled(char_t *user);
+extern int              umSetUserEnabled(char_t *user, bool_t enabled);
 
-extern bool_t			umGetUserProtected(char_t *user);
-extern int				umSetUserProtected(char_t *user, bool_t protect);
+extern bool_t           umGetUserProtected(char_t *user);
+extern int              umSetUserProtected(char_t *user, bool_t protect);
 
 /*
-  	umGroup functions use a group name for a key
+    umGroup functions use a group name for a key
  */
-extern int				umAddGroup(char_t *group, short privilege, accessMeth_t am, bool_t protect, bool_t disabled);
+extern int              umAddGroup(char_t *group, short privilege, accessMeth_t am, bool_t protect, bool_t disabled);
 
-extern int				umDeleteGroup(char_t *group);
+extern int              umDeleteGroup(char_t *group);
 
-extern char_t 			*umGetFirstGroup();
-extern char_t			*umGetNextGroup(char_t *lastUser);
+extern char_t           *umGetFirstGroup();
+extern char_t           *umGetNextGroup(char_t *lastUser);
 
-extern bool_t			umGroupExists(char_t *group);
-extern bool_t			umGetGroupInUse(char_t *group);
+extern bool_t           umGroupExists(char_t *group);
+extern bool_t           umGetGroupInUse(char_t *group);
 
-extern accessMeth_t		umGetGroupAccessMethod(char_t *group);
-extern int				umSetGroupAccessMethod(char_t *group, accessMeth_t am);
+extern accessMeth_t     umGetGroupAccessMethod(char_t *group);
+extern int              umSetGroupAccessMethod(char_t *group, accessMeth_t am);
 
-extern bool_t			umGetGroupEnabled(char_t *group);
-extern int				umSetGroupEnabled(char_t *group, bool_t enabled);
+extern bool_t           umGetGroupEnabled(char_t *group);
+extern int              umSetGroupEnabled(char_t *group, bool_t enabled);
 
-extern short			umGetGroupPrivilege(char_t *group);
-extern int				umSetGroupPrivilege(char_t *group, short privileges);
+extern short            umGetGroupPrivilege(char_t *group);
+extern int              umSetGroupPrivilege(char_t *group, short privileges);
 
-extern bool_t			umGetGroupProtected(char_t *group);
-extern int				umSetGroupProtected(char_t *group, bool_t protect);
+extern bool_t           umGetGroupProtected(char_t *group);
+extern int              umSetGroupProtected(char_t *group, bool_t protect);
 
 /*
-  	umAccessLimit functions use a URL as a key
+    umAccessLimit functions use a URL as a key
  */
-extern int			umAddAccessLimit(char_t *url, accessMeth_t am,
-						short secure, char_t *group);
+extern int          umAddAccessLimit(char_t *url, accessMeth_t am,
+                        short secure, char_t *group);
 
-extern int			umDeleteAccessLimit(char_t *url);
+extern int          umDeleteAccessLimit(char_t *url);
 
-extern char_t		*umGetFirstAccessLimit();
-extern char_t		*umGetNextAccessLimit(char_t *lastUser);
+extern char_t       *umGetFirstAccessLimit();
+extern char_t       *umGetNextAccessLimit(char_t *lastUser);
 
 /*
-  	Returns the name of an ancestor access limit if
+    Returns the name of an ancestor access limit if
  */
-extern char_t		*umGetAccessLimit(char_t *url);
+extern char_t       *umGetAccessLimit(char_t *url);
 
-extern bool_t		umAccessLimitExists(char_t *url);
+extern bool_t       umAccessLimitExists(char_t *url);
 
-extern accessMeth_t	umGetAccessLimitMethod(char_t *url);
-extern int			umSetAccessLimitMethod(char_t *url, accessMeth_t am);
+extern accessMeth_t umGetAccessLimitMethod(char_t *url);
+extern int          umSetAccessLimitMethod(char_t *url, accessMeth_t am);
 
-extern short		umGetAccessLimitSecure(char_t *url);
-extern int			umSetAccessLimitSecure(char_t *url, short secure);
+extern short        umGetAccessLimitSecure(char_t *url);
+extern int          umSetAccessLimitSecure(char_t *url, short secure);
 
-extern char_t		*umGetAccessLimitGroup(char_t *url);
-extern int			umSetAccessLimitGroup(char_t *url, char_t *group);
+extern char_t       *umGetAccessLimitGroup(char_t *url);
+extern int          umSetAccessLimitGroup(char_t *url, char_t *group);
 
 /*
-  	Convenience Functions
+    Convenience Functions
  */
 
-extern accessMeth_t	umGetAccessMethodForURL(char_t *url);
-extern bool_t		umUserCanAccessURL(char_t *user, char_t *url);
+extern accessMeth_t umGetAccessMethodForURL(char_t *url);
+extern bool_t       umUserCanAccessURL(char_t *user, char_t *url);
 
 #endif /* _h_UM */
 
diff --git a/umui.c b/umui.c
index 7a0acee5..c4c6ea3d 100644
--- a/umui.c
+++ b/umui.c
@@ -6,210 +6,210 @@
 
 /********************************* Includes ***********************************/
 
-#include	"wsIntrn.h"
-#include	"um.h"
+#include    "wsIntrn.h"
+#include    "um.h"
 
 /********************************* Defines ************************************/
 
-#define		NONE_OPTION		T("<NONE>")
-#define		MSG_START		T("<body><h2>")
-#define		MSG_END			T("</h2></body>")
+#define     NONE_OPTION     T("<NONE>")
+#define     MSG_START       T("<body><h2>")
+#define     MSG_END         T("</h2></body>")
 
 /**************************** Forward Declarations ****************************/
 
-static void		formAddUser(webs_t wp, char_t *path, char_t *query);
-static void		formDeleteUser(webs_t wp, char_t *path, char_t *query);
-static void		formDisplayUser(webs_t wp, char_t *path, char_t *query);
-static int		aspGenerateUserList(int eid, webs_t wp, int argc, char_t **argv);
+static void     formAddUser(webs_t wp, char_t *path, char_t *query);
+static void     formDeleteUser(webs_t wp, char_t *path, char_t *query);
+static void     formDisplayUser(webs_t wp, char_t *path, char_t *query);
+static int      aspGenerateUserList(int eid, webs_t wp, int argc, char_t **argv);
 
-static void		formAddGroup(webs_t wp, char_t *path, char_t *query);
-static void		formDeleteGroup(webs_t wp, char_t *path, char_t *query);
-static int		aspGenerateGroupList(int eid, webs_t wp, int argc, char_t **argv);
+static void     formAddGroup(webs_t wp, char_t *path, char_t *query);
+static void     formDeleteGroup(webs_t wp, char_t *path, char_t *query);
+static int      aspGenerateGroupList(int eid, webs_t wp, int argc, char_t **argv);
 
-static void		formAddAccessLimit(webs_t wp, char_t *path, char_t *query);
-static void		formDeleteAccessLimit(webs_t wp, char_t *path, char_t *query);
-static int		aspGenerateAccessLimitList(int eid, webs_t wp, int argc, char_t **argv);
+static void     formAddAccessLimit(webs_t wp, char_t *path, char_t *query);
+static void     formDeleteAccessLimit(webs_t wp, char_t *path, char_t *query);
+static int      aspGenerateAccessLimitList(int eid, webs_t wp, int argc, char_t **argv);
 
-static int		aspGenerateAccessMethodList(int eid, webs_t wp, int argc, char_t **argv);
-static int		aspGeneratePrivilegeList(int eid, webs_t wp, int argc, char_t **argv);
+static int      aspGenerateAccessMethodList(int eid, webs_t wp, int argc, char_t **argv);
+static int      aspGeneratePrivilegeList(int eid, webs_t wp, int argc, char_t **argv);
 
-static void		formSaveUserManagement(webs_t wp, char_t *path, char_t *query);
-static void		formLoadUserManagement(webs_t wp, char_t *path, char_t *query);
+static void     formSaveUserManagement(webs_t wp, char_t *path, char_t *query);
+static void     formLoadUserManagement(webs_t wp, char_t *path, char_t *query);
 
-static void		websMsgStart(webs_t wp);
-static void		websMsgEnd(webs_t wp);
+static void     websMsgStart(webs_t wp);
+static void     websMsgEnd(webs_t wp);
 
 /*********************************** Code *************************************/
 
 void formDefineUserMgmt(void)
 {
-	websAspDefine(T("MakeGroupList"), aspGenerateGroupList);
-	websAspDefine(T("MakeUserList"), aspGenerateUserList);
-	websAspDefine(T("MakeAccessLimitList"), aspGenerateAccessLimitList);
-	websAspDefine(T("MakeAccessMethodList"), aspGenerateAccessMethodList);
-	websAspDefine(T("MakePrivilegeList"), aspGeneratePrivilegeList);
-
-	websFormDefine(T("AddUser"), formAddUser);
-	websFormDefine(T("DeleteUser"), formDeleteUser);
-	websFormDefine(T("DisplayUser"), formDisplayUser);
-	websFormDefine(T("AddGroup"), formAddGroup);
-	websFormDefine(T("DeleteGroup"), formDeleteGroup);
-	websFormDefine(T("AddAccessLimit"), formAddAccessLimit);
-	websFormDefine(T("DeleteAccessLimit"), formDeleteAccessLimit);
-
-	websFormDefine(T("SaveUserManagement"), formSaveUserManagement);
-	websFormDefine(T("LoadUserManagement"), formLoadUserManagement);
+    websAspDefine(T("MakeGroupList"), aspGenerateGroupList);
+    websAspDefine(T("MakeUserList"), aspGenerateUserList);
+    websAspDefine(T("MakeAccessLimitList"), aspGenerateAccessLimitList);
+    websAspDefine(T("MakeAccessMethodList"), aspGenerateAccessMethodList);
+    websAspDefine(T("MakePrivilegeList"), aspGeneratePrivilegeList);
+
+    websFormDefine(T("AddUser"), formAddUser);
+    websFormDefine(T("DeleteUser"), formDeleteUser);
+    websFormDefine(T("DisplayUser"), formDisplayUser);
+    websFormDefine(T("AddGroup"), formAddGroup);
+    websFormDefine(T("DeleteGroup"), formDeleteGroup);
+    websFormDefine(T("AddAccessLimit"), formAddAccessLimit);
+    websFormDefine(T("DeleteAccessLimit"), formDeleteAccessLimit);
+
+    websFormDefine(T("SaveUserManagement"), formSaveUserManagement);
+    websFormDefine(T("LoadUserManagement"), formLoadUserManagement);
 }
 
 
 static void formAddUser(webs_t wp, char_t *path, char_t *query)
 {
-	char_t	*userid, *pass1, *pass2, *group, *enabled, *ok;
-	bool_t bDisable;
-	int	nCheck;
-
-	a_assert(wp);
-
-	userid = websGetVar(wp, T("user"), T("")); 
-	pass1 = websGetVar(wp, T("password"), T("")); 
-	pass2 = websGetVar(wp, T("passconf"), T("")); 
-	group = websGetVar(wp, T("group"), T("")); 
-	enabled = websGetVar(wp, T("enabled"), T("")); 
-	ok = websGetVar(wp, T("ok"), T("")); 
-
-	websHeader(wp);
-	websMsgStart(wp);
-
-	if (gstricmp(ok, T("ok")) != 0) {
-		websWrite(wp, T("Add User Cancelled"));
-	} else if (gstrcmp(pass1, pass2) != 0) {
-		websWrite(wp, T("Confirmation Password did not match."));
-	} else {
-		if (enabled && *enabled && (gstrcmp(enabled, T("on")) == 0)) {
-			bDisable = FALSE;
-		} else {
-			bDisable = TRUE;
-		}
-		nCheck = umAddUser(userid, pass1, group, 0, bDisable);
-		if (nCheck != 0) {
-			char_t * strError;
-
-			switch (nCheck) {
-			case UM_ERR_DUPLICATE:
-				strError = T("User already exists.");
-				break;
-
-			case UM_ERR_BAD_NAME:
-				strError = T("Invalid user name.");
-				break;
-
-			case UM_ERR_BAD_PASSWORD:
-				strError = T("Invalid password.");
-				break;
-
-			case UM_ERR_NOT_FOUND:
-				strError = T("Invalid or unselected group.");
-				break;
-
-			default:
-				strError = T("Error writing user record.");
-				break;
-			}
-
-			websWrite(wp, T("Unable to add user, \"%s\".  %s"),
-				userid, strError);
-		} else {
-			websWrite(wp, T("User, \"%s\" was successfully added."),
-				userid);
-		}
-	}
-	websMsgEnd(wp);
-	websFooter(wp);
-	websDone(wp, 200);
+    char_t  *userid, *pass1, *pass2, *group, *enabled, *ok;
+    bool_t bDisable;
+    int nCheck;
+
+    a_assert(wp);
+
+    userid = websGetVar(wp, T("user"), T("")); 
+    pass1 = websGetVar(wp, T("password"), T("")); 
+    pass2 = websGetVar(wp, T("passconf"), T("")); 
+    group = websGetVar(wp, T("group"), T("")); 
+    enabled = websGetVar(wp, T("enabled"), T("")); 
+    ok = websGetVar(wp, T("ok"), T("")); 
+
+    websHeader(wp);
+    websMsgStart(wp);
+
+    if (gstricmp(ok, T("ok")) != 0) {
+        websWrite(wp, T("Add User Cancelled"));
+    } else if (gstrcmp(pass1, pass2) != 0) {
+        websWrite(wp, T("Confirmation Password did not match."));
+    } else {
+        if (enabled && *enabled && (gstrcmp(enabled, T("on")) == 0)) {
+            bDisable = FALSE;
+        } else {
+            bDisable = TRUE;
+        }
+        nCheck = umAddUser(userid, pass1, group, 0, bDisable);
+        if (nCheck != 0) {
+            char_t * strError;
+
+            switch (nCheck) {
+            case UM_ERR_DUPLICATE:
+                strError = T("User already exists.");
+                break;
+
+            case UM_ERR_BAD_NAME:
+                strError = T("Invalid user name.");
+                break;
+
+            case UM_ERR_BAD_PASSWORD:
+                strError = T("Invalid password.");
+                break;
+
+            case UM_ERR_NOT_FOUND:
+                strError = T("Invalid or unselected group.");
+                break;
+
+            default:
+                strError = T("Error writing user record.");
+                break;
+            }
+
+            websWrite(wp, T("Unable to add user, \"%s\".  %s"),
+                userid, strError);
+        } else {
+            websWrite(wp, T("User, \"%s\" was successfully added."),
+                userid);
+        }
+    }
+    websMsgEnd(wp);
+    websFooter(wp);
+    websDone(wp, 200);
 }
 
 
 static void formDeleteUser(webs_t wp, char_t *path, char_t *query)
 {
-	char_t	*userid, *ok;
-
-	a_assert(wp);
-
-	userid = websGetVar(wp, T("user"), T("")); 
-	ok = websGetVar(wp, T("ok"), T("")); 
-
-	websHeader(wp);
-	websMsgStart(wp);
-
-	if (gstricmp(ok, T("ok")) != 0) {
-		websWrite(wp, T("Delete User Cancelled"));
-	} else if (umUserExists(userid) == FALSE) {
-		websWrite(wp, T("ERROR: User \"%s\" not found"), userid);
-	} else if (umGetUserProtected(userid)) {
-		websWrite(wp, T("ERROR: User, \"%s\" is delete-protected."), userid);
-	} else if (umDeleteUser(userid) != 0) {
-		websWrite(wp, T("ERROR: Unable to delete user, \"%s\" "), userid);
-	} else {
-		websWrite(wp, T("User, \"%s\" was successfully deleted."), userid);
-	}
-
-	websMsgEnd(wp);
-	websFooter(wp);
-	websDone(wp, 200);
+    char_t  *userid, *ok;
+
+    a_assert(wp);
+
+    userid = websGetVar(wp, T("user"), T("")); 
+    ok = websGetVar(wp, T("ok"), T("")); 
+
+    websHeader(wp);
+    websMsgStart(wp);
+
+    if (gstricmp(ok, T("ok")) != 0) {
+        websWrite(wp, T("Delete User Cancelled"));
+    } else if (umUserExists(userid) == FALSE) {
+        websWrite(wp, T("ERROR: User \"%s\" not found"), userid);
+    } else if (umGetUserProtected(userid)) {
+        websWrite(wp, T("ERROR: User, \"%s\" is delete-protected."), userid);
+    } else if (umDeleteUser(userid) != 0) {
+        websWrite(wp, T("ERROR: Unable to delete user, \"%s\" "), userid);
+    } else {
+        websWrite(wp, T("User, \"%s\" was successfully deleted."), userid);
+    }
+
+    websMsgEnd(wp);
+    websFooter(wp);
+    websDone(wp, 200);
 }
 
 
 static void formDisplayUser(webs_t wp, char_t *path, char_t *query)
 {
-	char_t	*userid, *ok, *temp;
-	bool_t	enabled;
-
-	a_assert(wp);
-
-	userid = websGetVar(wp, T("user"), T("")); 
-	ok = websGetVar(wp, T("ok"), T("")); 
-
-	websHeader(wp);
-	websWrite(wp, T("<body>"));
-
-	if (gstricmp(ok, T("ok")) != 0) {
-		websWrite(wp, T("Display User Cancelled"));
-	} else if (umUserExists(userid) == FALSE) {
-		websWrite(wp, T("ERROR: User <b>%s</b> not found.\n"), userid);
-	} else {
-		websWrite(wp, T("<h2>User ID: <b>%s</b></h2>\n"), userid);
-		temp = umGetUserGroup(userid);
-		websWrite(wp, T("<h3>User Group: <b>%s</b></h3>\n"), temp);
-		enabled = umGetUserEnabled(userid);
-		websWrite(wp, T("<h3>Enabled: <b>%d</b></h3>\n"), enabled);
-	}
-
-	websWrite(wp, T("</body>\n"));
-	websFooter(wp);
-	websDone(wp, 200);
+    char_t  *userid, *ok, *temp;
+    bool_t  enabled;
+
+    a_assert(wp);
+
+    userid = websGetVar(wp, T("user"), T("")); 
+    ok = websGetVar(wp, T("ok"), T("")); 
+
+    websHeader(wp);
+    websWrite(wp, T("<body>"));
+
+    if (gstricmp(ok, T("ok")) != 0) {
+        websWrite(wp, T("Display User Cancelled"));
+    } else if (umUserExists(userid) == FALSE) {
+        websWrite(wp, T("ERROR: User <b>%s</b> not found.\n"), userid);
+    } else {
+        websWrite(wp, T("<h2>User ID: <b>%s</b></h2>\n"), userid);
+        temp = umGetUserGroup(userid);
+        websWrite(wp, T("<h3>User Group: <b>%s</b></h3>\n"), temp);
+        enabled = umGetUserEnabled(userid);
+        websWrite(wp, T("<h3>Enabled: <b>%d</b></h3>\n"), enabled);
+    }
+
+    websWrite(wp, T("</body>\n"));
+    websFooter(wp);
+    websDone(wp, 200);
 }
 
 
 static int aspGenerateUserList(int eid, webs_t wp, int argc, char_t **argv)
 {
-	char_t	*userid;
-	int		row, nBytesSent, nBytes;
-
-	a_assert(wp);
-
-	nBytes = websWrite(wp, 
-		T("<SELECT NAME=\"user\" SIZE=\"3\" TITLE=\"Select a User\">"));
-	row = 0;
-	userid = umGetFirstUser();
-	nBytesSent = 0;
-
-	while (userid && (nBytes > 0)) {
-		nBytes = websWrite(wp, T("<OPTION VALUE=\"%s\">%s\n"), userid, userid);
-		userid = umGetNextUser(userid);
-		nBytesSent += nBytes;
-	}
-	nBytesSent += websWrite(wp, T("</SELECT>"));
-	return nBytesSent;
+    char_t  *userid;
+    int     row, nBytesSent, nBytes;
+
+    a_assert(wp);
+
+    nBytes = websWrite(wp, 
+        T("<SELECT NAME=\"user\" SIZE=\"3\" TITLE=\"Select a User\">"));
+    row = 0;
+    userid = umGetFirstUser();
+    nBytesSent = 0;
+
+    while (userid && (nBytes > 0)) {
+        nBytes = websWrite(wp, T("<OPTION VALUE=\"%s\">%s\n"), userid, userid);
+        userid = umGetNextUser(userid);
+        nBytesSent += nBytes;
+    }
+    nBytesSent += websWrite(wp, T("</SELECT>"));
+    return nBytesSent;
 }
 
 
@@ -218,307 +218,307 @@ static int aspGenerateUserList(int eid, webs_t wp, int argc, char_t **argv)
  */
 static void formAddGroup(webs_t wp, char_t *path, char_t *query)
 {
-	char_t			*group, *enabled, *privilege, *method, *ok, *pChar;
-	int				nCheck;
-	short			priv;
-	accessMeth_t	am;
-	bool_t			bDisable;
-
-	a_assert(wp);
-
-	group = websGetVar(wp, T("group"), T("")); 
-	method = websGetVar(wp, T("method"), T("")); 
-	enabled = websGetVar(wp, T("enabled"), T("")); 
-	privilege = websGetVar(wp, T("privilege"), T("")); 
-	ok = websGetVar(wp, T("ok"), T("")); 
-
-	websHeader(wp);
-	websMsgStart(wp);
-
-	if (gstricmp(ok, T("ok")) != 0) {
-		websWrite(wp, T("Add Group Cancelled."));
-	} else if ((group == NULL) || (*group == 0)) {
-		websWrite(wp, T("No Group Name was entered."));
-	} else if (umGroupExists(group)) {
-		websWrite(wp, T("ERROR: Group, \"%s\" already exists."), group);
-	} else {
-		if (privilege && *privilege) {
+    char_t          *group, *enabled, *privilege, *method, *ok, *pChar;
+    int             nCheck;
+    short           priv;
+    accessMeth_t    am;
+    bool_t          bDisable;
+
+    a_assert(wp);
+
+    group = websGetVar(wp, T("group"), T("")); 
+    method = websGetVar(wp, T("method"), T("")); 
+    enabled = websGetVar(wp, T("enabled"), T("")); 
+    privilege = websGetVar(wp, T("privilege"), T("")); 
+    ok = websGetVar(wp, T("ok"), T("")); 
+
+    websHeader(wp);
+    websMsgStart(wp);
+
+    if (gstricmp(ok, T("ok")) != 0) {
+        websWrite(wp, T("Add Group Cancelled."));
+    } else if ((group == NULL) || (*group == 0)) {
+        websWrite(wp, T("No Group Name was entered."));
+    } else if (umGroupExists(group)) {
+        websWrite(wp, T("ERROR: Group, \"%s\" already exists."), group);
+    } else {
+        if (privilege && *privilege) {
             /*
                 privilege is a mulitple <SELECT> var, and must be parsed. Values for these variables are space delimited.
              */
-			priv = 0;
-			for (pChar = privilege; *pChar; pChar++) {
-				if (*pChar == ' ') {
-					*pChar = '\0';
-					priv |= gatoi(privilege);
-					*pChar = ' ';
-					privilege = pChar + 1;
-				}
-			}
-			priv |= gatoi(privilege);
-		} else {
-			priv = 0;
-		}
-		if (method && *method) {
-			am = (accessMeth_t) gatoi(method);
-		} else {
-			am = AM_FULL;
-		}
-		if (enabled && *enabled && (gstrcmp(enabled, T("on")) == 0)) {
-			bDisable = FALSE;
-		} else {
-			bDisable = TRUE;
-		}
-		nCheck = umAddGroup(group, priv, am, 0, bDisable);
-		if (nCheck != 0) {
-			websWrite(wp, T("Unable to add group, \"%s\", code: %d "),
-				group, nCheck);
-		} else {
-			websWrite(wp, T("Group, \"%s\" was successfully added."), 
-				group);
-		}
-	}
-	websMsgEnd(wp);
-	websFooter(wp);
-	websDone(wp, 200);
+            priv = 0;
+            for (pChar = privilege; *pChar; pChar++) {
+                if (*pChar == ' ') {
+                    *pChar = '\0';
+                    priv |= gatoi(privilege);
+                    *pChar = ' ';
+                    privilege = pChar + 1;
+                }
+            }
+            priv |= gatoi(privilege);
+        } else {
+            priv = 0;
+        }
+        if (method && *method) {
+            am = (accessMeth_t) gatoi(method);
+        } else {
+            am = AM_FULL;
+        }
+        if (enabled && *enabled && (gstrcmp(enabled, T("on")) == 0)) {
+            bDisable = FALSE;
+        } else {
+            bDisable = TRUE;
+        }
+        nCheck = umAddGroup(group, priv, am, 0, bDisable);
+        if (nCheck != 0) {
+            websWrite(wp, T("Unable to add group, \"%s\", code: %d "),
+                group, nCheck);
+        } else {
+            websWrite(wp, T("Group, \"%s\" was successfully added."), 
+                group);
+        }
+    }
+    websMsgEnd(wp);
+    websFooter(wp);
+    websDone(wp, 200);
 }
 
 
 static void formDeleteGroup(webs_t wp, char_t *path, char_t *query)
 {
-	char_t	*group, *ok;
-
-	a_assert(wp);
-
-	group = websGetVar(wp, T("group"), T("")); 
-	ok = websGetVar(wp, T("ok"), T("")); 
-
-	websHeader(wp);
-	websMsgStart(wp);
-
-	if (gstricmp(ok, T("ok")) != 0) {
-		websWrite(wp, T("Delete Group Cancelled."));
-	} else if ((group == NULL) || (*group == '\0')) {
-		websWrite(wp, T("ERROR: No group was selected."));
-	} else if (umGetGroupProtected(group)) {
-		websWrite(wp, T("ERROR: Group, \"%s\" is delete-protected."), group);
-	} else if (umGetGroupInUse(group)) {
-		websWrite(wp, T("ERROR: Group, \"%s\" is being used."),	group);
-	} else if (umDeleteGroup(group) != 0) {
-		websWrite(wp, T("ERROR: Unable to delete group, \"%s\" "), group);
-	} else {
-		websWrite(wp, T("Group, \"%s\" was successfully deleted."), group);
-	}
-	websMsgEnd(wp);
-	websFooter(wp);
-	websDone(wp, 200);
+    char_t  *group, *ok;
+
+    a_assert(wp);
+
+    group = websGetVar(wp, T("group"), T("")); 
+    ok = websGetVar(wp, T("ok"), T("")); 
+
+    websHeader(wp);
+    websMsgStart(wp);
+
+    if (gstricmp(ok, T("ok")) != 0) {
+        websWrite(wp, T("Delete Group Cancelled."));
+    } else if ((group == NULL) || (*group == '\0')) {
+        websWrite(wp, T("ERROR: No group was selected."));
+    } else if (umGetGroupProtected(group)) {
+        websWrite(wp, T("ERROR: Group, \"%s\" is delete-protected."), group);
+    } else if (umGetGroupInUse(group)) {
+        websWrite(wp, T("ERROR: Group, \"%s\" is being used."), group);
+    } else if (umDeleteGroup(group) != 0) {
+        websWrite(wp, T("ERROR: Unable to delete group, \"%s\" "), group);
+    } else {
+        websWrite(wp, T("Group, \"%s\" was successfully deleted."), group);
+    }
+    websMsgEnd(wp);
+    websFooter(wp);
+    websDone(wp, 200);
 }
 
 
 static int aspGenerateGroupList(int eid, webs_t wp, int argc, char_t **argv)
 {
-	char_t	*group;
-	int		row, nBytesSent, nBytes;
+    char_t  *group;
+    int     row, nBytesSent, nBytes;
 
-	a_assert(wp);
+    a_assert(wp);
 
-	row = 0;
-	nBytesSent = 0;
-	nBytes = websWrite(wp, T("<SELECT NAME=\"group\" SIZE=\"3\" TITLE=\"Select a Group\">"));
+    row = 0;
+    nBytesSent = 0;
+    nBytes = websWrite(wp, T("<SELECT NAME=\"group\" SIZE=\"3\" TITLE=\"Select a Group\">"));
 
     /*
      *  Add a special "<NONE>" element to allow de-selection
      */
-	nBytes = websWrite(wp, T("<OPTION VALUE=\"\">[NONE]\n"));
-
-	group = umGetFirstGroup();
-	while (group && (nBytes > 0)) {
-		nBytes = websWrite(wp, T("<OPTION VALUE=\"%s\">%s\n"), group, group);
-		group = umGetNextGroup(group);
-		nBytesSent += nBytes;
-	}
-	nBytesSent += websWrite(wp, T("</SELECT>"));
-	return nBytesSent;
+    nBytes = websWrite(wp, T("<OPTION VALUE=\"\">[NONE]\n"));
+
+    group = umGetFirstGroup();
+    while (group && (nBytes > 0)) {
+        nBytes = websWrite(wp, T("<OPTION VALUE=\"%s\">%s\n"), group, group);
+        group = umGetNextGroup(group);
+        nBytesSent += nBytes;
+    }
+    nBytesSent += websWrite(wp, T("</SELECT>"));
+    return nBytesSent;
 }
 
 
 static void formAddAccessLimit(webs_t wp, char_t *path, char_t *query)
 {
-	char_t			*url, *method, *group, *secure, *ok;
-	int				nCheck;
-	accessMeth_t	am;
-	short			nSecure;
-
-	a_assert(wp);
-
-	url = websGetVar(wp, T("url"), T("")); 
-	group = websGetVar(wp, T("group"), T("")); 
-	method = websGetVar(wp, T("method"), T("")); 
-	secure = websGetVar(wp, T("secure"), T("")); 
-	ok = websGetVar(wp, T("ok"), T("")); 
-
-	websHeader(wp);
-	websMsgStart(wp);
-
-	if (gstricmp(ok, T("ok")) != 0) {
-		websWrite(wp, T("Add Access Limit Cancelled."));
-	} else if ((url == NULL) || (*url == 0)) {
-		websWrite(wp, T("ERROR:  No URL was entered."));
-	} else if (umAccessLimitExists(url)) {
-		websWrite(wp, T("ERROR:  An Access Limit for [%s] already exists."), url);
-	} else {
-		if (method && *method) {
-			am = (accessMeth_t) gatoi(method);
-		} else {
-			am = AM_FULL;
-		}
-		if (secure && *secure) {
-			nSecure = (short) gatoi(secure);
-		} else {
-			nSecure = 0;
-		}
-		nCheck = umAddAccessLimit(url, am, nSecure, group);
-		if (nCheck != 0) {
-			websWrite(wp, T("Unable to add Access Limit for [%s]"),	url);
-		} else {
-			websWrite(wp, T("Access limit for [%s], was successfully added."), url);
-		}
-	}
-	websMsgEnd(wp);
-	websFooter(wp);
-	websDone(wp, 200);
+    char_t          *url, *method, *group, *secure, *ok;
+    int             nCheck;
+    accessMeth_t    am;
+    short           nSecure;
+
+    a_assert(wp);
+
+    url = websGetVar(wp, T("url"), T("")); 
+    group = websGetVar(wp, T("group"), T("")); 
+    method = websGetVar(wp, T("method"), T("")); 
+    secure = websGetVar(wp, T("secure"), T("")); 
+    ok = websGetVar(wp, T("ok"), T("")); 
+
+    websHeader(wp);
+    websMsgStart(wp);
+
+    if (gstricmp(ok, T("ok")) != 0) {
+        websWrite(wp, T("Add Access Limit Cancelled."));
+    } else if ((url == NULL) || (*url == 0)) {
+        websWrite(wp, T("ERROR:  No URL was entered."));
+    } else if (umAccessLimitExists(url)) {
+        websWrite(wp, T("ERROR:  An Access Limit for [%s] already exists."), url);
+    } else {
+        if (method && *method) {
+            am = (accessMeth_t) gatoi(method);
+        } else {
+            am = AM_FULL;
+        }
+        if (secure && *secure) {
+            nSecure = (short) gatoi(secure);
+        } else {
+            nSecure = 0;
+        }
+        nCheck = umAddAccessLimit(url, am, nSecure, group);
+        if (nCheck != 0) {
+            websWrite(wp, T("Unable to add Access Limit for [%s]"), url);
+        } else {
+            websWrite(wp, T("Access limit for [%s], was successfully added."), url);
+        }
+    }
+    websMsgEnd(wp);
+    websFooter(wp);
+    websDone(wp, 200);
 }
 
 
 static void formDeleteAccessLimit(webs_t wp, char_t *path, char_t *query)
 {
-	char_t	*url, *ok;
-
-	a_assert(wp);
-
-	url = websGetVar(wp, T("url"), T("")); 
-	ok = websGetVar(wp, T("ok"), T("")); 
-
-	websHeader(wp);
-	websMsgStart(wp);
-
-	if (gstricmp(ok, T("ok")) != 0) {
-		websWrite(wp, T("Delete Access Limit Cancelled"));
-	} else if (umDeleteAccessLimit(url) != 0) {
-		websWrite(wp, T("ERROR: Unable to delete Access Limit for [%s]"), url);
-	} else {
-		websWrite(wp, T("Access Limit for [%s], was successfully deleted."), url);
-	}
-	websMsgEnd(wp);
-	websFooter(wp);
-	websDone(wp, 200);
+    char_t  *url, *ok;
+
+    a_assert(wp);
+
+    url = websGetVar(wp, T("url"), T("")); 
+    ok = websGetVar(wp, T("ok"), T("")); 
+
+    websHeader(wp);
+    websMsgStart(wp);
+
+    if (gstricmp(ok, T("ok")) != 0) {
+        websWrite(wp, T("Delete Access Limit Cancelled"));
+    } else if (umDeleteAccessLimit(url) != 0) {
+        websWrite(wp, T("ERROR: Unable to delete Access Limit for [%s]"), url);
+    } else {
+        websWrite(wp, T("Access Limit for [%s], was successfully deleted."), url);
+    }
+    websMsgEnd(wp);
+    websFooter(wp);
+    websDone(wp, 200);
 }
 
 
 static int aspGenerateAccessLimitList(int eid, webs_t wp, int argc, char_t **argv)
 {
-	char_t	*url;
-	int		row, nBytesSent, nBytes;
-
-	a_assert(wp);
-
-	row = nBytesSent = 0;
-	url = umGetFirstAccessLimit();
-	nBytes = websWrite(wp, T("<SELECT NAME=\"url\" SIZE=\"3\" TITLE=\"Select a URL\">"));
-
-	while (url && (nBytes > 0)) {
-		nBytes = websWrite(wp, T("<OPTION VALUE=\"%s\">%s\n"), url, url);
-		url = umGetNextAccessLimit(url);
-		nBytesSent += nBytes;
-	}
-	nBytesSent += websWrite(wp, T("</SELECT>"));
-	return nBytesSent;
+    char_t  *url;
+    int     row, nBytesSent, nBytes;
+
+    a_assert(wp);
+
+    row = nBytesSent = 0;
+    url = umGetFirstAccessLimit();
+    nBytes = websWrite(wp, T("<SELECT NAME=\"url\" SIZE=\"3\" TITLE=\"Select a URL\">"));
+
+    while (url && (nBytes > 0)) {
+        nBytes = websWrite(wp, T("<OPTION VALUE=\"%s\">%s\n"), url, url);
+        url = umGetNextAccessLimit(url);
+        nBytesSent += nBytes;
+    }
+    nBytesSent += websWrite(wp, T("</SELECT>"));
+    return nBytesSent;
 }
 
 
 static int aspGenerateAccessMethodList(int eid, webs_t wp, int argc, char_t **argv)
 {
-	int		nBytes;
-
-	a_assert(wp);
-	nBytes = websWrite(wp, T("<SELECT NAME=\"method\" SIZE=\"3\" TITLE=\"Select a Method\">"));
-	nBytes += websWrite(wp, T("<OPTION VALUE=\"%d\">FULL ACCESS\n"), AM_FULL);
-	nBytes += websWrite(wp, T("<OPTION VALUE=\"%d\">BASIC ACCESS\n"), AM_BASIC);
-	nBytes += websWrite(wp, T("<OPTION VALUE=\"%d\" SELECTED>DIGEST ACCESS\n"), AM_DIGEST);
-	nBytes += websWrite(wp, T("<OPTION VALUE=\"%d\">NO ACCESS\n"), AM_NONE);
-	nBytes += websWrite(wp, T("</SELECT>")); 
-	return nBytes;
+    int     nBytes;
+
+    a_assert(wp);
+    nBytes = websWrite(wp, T("<SELECT NAME=\"method\" SIZE=\"3\" TITLE=\"Select a Method\">"));
+    nBytes += websWrite(wp, T("<OPTION VALUE=\"%d\">FULL ACCESS\n"), AM_FULL);
+    nBytes += websWrite(wp, T("<OPTION VALUE=\"%d\">BASIC ACCESS\n"), AM_BASIC);
+    nBytes += websWrite(wp, T("<OPTION VALUE=\"%d\" SELECTED>DIGEST ACCESS\n"), AM_DIGEST);
+    nBytes += websWrite(wp, T("<OPTION VALUE=\"%d\">NO ACCESS\n"), AM_NONE);
+    nBytes += websWrite(wp, T("</SELECT>")); 
+    return nBytes;
 }
 
 
 static int aspGeneratePrivilegeList(int eid, webs_t wp, int argc, char_t **argv)
 {
-	int		nBytes;
-
-	a_assert(wp);
-	nBytes = websWrite(wp, T("<SELECT NAME=\"privilege\" SIZE=\"3\" "));
-	nBytes += websWrite(wp, T("MULTIPLE TITLE=\"Choose Privileges\">"));
-	nBytes += websWrite(wp, T("<OPTION VALUE=\"%d\">READ\n"), PRIV_READ);
-	nBytes += websWrite(wp, T("<OPTION VALUE=\"%d\">EXECUTE\n"), PRIV_WRITE);
-	nBytes += websWrite(wp, T("<OPTION VALUE=\"%d\">ADMINISTRATE\n"), PRIV_ADMIN);
-	nBytes += websWrite(wp, T("</SELECT>"));
-	return nBytes;
+    int     nBytes;
+
+    a_assert(wp);
+    nBytes = websWrite(wp, T("<SELECT NAME=\"privilege\" SIZE=\"3\" "));
+    nBytes += websWrite(wp, T("MULTIPLE TITLE=\"Choose Privileges\">"));
+    nBytes += websWrite(wp, T("<OPTION VALUE=\"%d\">READ\n"), PRIV_READ);
+    nBytes += websWrite(wp, T("<OPTION VALUE=\"%d\">EXECUTE\n"), PRIV_WRITE);
+    nBytes += websWrite(wp, T("<OPTION VALUE=\"%d\">ADMINISTRATE\n"), PRIV_ADMIN);
+    nBytes += websWrite(wp, T("</SELECT>"));
+    return nBytes;
 }
 
 
 static void formSaveUserManagement(webs_t wp, char_t *path, char_t *query)
 {
-	char_t	*ok;
-
-	a_assert(wp);
-
-	ok = websGetVar(wp, T("ok"), T("")); 
-	websHeader(wp);
-	websMsgStart(wp);
-
-	if (gstricmp(ok, T("ok")) != 0) {
-		websWrite(wp, T("Save Cancelled."));
-	} else if (umCommit(NULL) != 0) {
-		websWrite(wp, T("ERROR: Unable to save user configuration."));
-	} else {
-		websWrite(wp, T("User configuration was saved successfully."));
-	}
-	websMsgEnd(wp);
-	websFooter(wp);
-	websDone(wp, 200);
+    char_t  *ok;
+
+    a_assert(wp);
+
+    ok = websGetVar(wp, T("ok"), T("")); 
+    websHeader(wp);
+    websMsgStart(wp);
+
+    if (gstricmp(ok, T("ok")) != 0) {
+        websWrite(wp, T("Save Cancelled."));
+    } else if (umCommit(NULL) != 0) {
+        websWrite(wp, T("ERROR: Unable to save user configuration."));
+    } else {
+        websWrite(wp, T("User configuration was saved successfully."));
+    }
+    websMsgEnd(wp);
+    websFooter(wp);
+    websDone(wp, 200);
 }
 
 
 static void formLoadUserManagement(webs_t wp, char_t *path, char_t *query)
 {
-	char_t	*ok;
-
-	a_assert(wp);
-
-	ok = websGetVar(wp, T("ok"), T("")); 
-	websHeader(wp);
-	websMsgStart(wp);
-	if (gstricmp(ok, T("ok")) != 0) {
-		websWrite(wp, T("Load Cancelled."));
-	} else if (umRestore(NULL) != 0) {
-		websWrite(wp, T("ERROR: Unable to load user configuration."));
-	} else {
-		websWrite(wp, T("User configuration was re-loaded successfully."));
-	}
-	websMsgEnd(wp);
-	websFooter(wp);
-	websDone(wp, 200);
+    char_t  *ok;
+
+    a_assert(wp);
+
+    ok = websGetVar(wp, T("ok"), T("")); 
+    websHeader(wp);
+    websMsgStart(wp);
+    if (gstricmp(ok, T("ok")) != 0) {
+        websWrite(wp, T("Load Cancelled."));
+    } else if (umRestore(NULL) != 0) {
+        websWrite(wp, T("ERROR: Unable to load user configuration."));
+    } else {
+        websWrite(wp, T("User configuration was re-loaded successfully."));
+    }
+    websMsgEnd(wp);
+    websFooter(wp);
+    websDone(wp, 200);
 }
 
-static void	websMsgStart(webs_t wp)
+static void websMsgStart(webs_t wp)
 {
-	websWrite(wp, MSG_START);
+    websWrite(wp, MSG_START);
 }
 
 
-static void	websMsgEnd(webs_t wp)
+static void websMsgEnd(webs_t wp)
 {
-	websWrite(wp, MSG_END);
+    websWrite(wp, MSG_END);
 }
 
 
diff --git a/url.c b/url.c
index ace5a196..f09c72ae 100644
--- a/url.c
+++ b/url.c
@@ -7,56 +7,56 @@
 /******************************** Description *********************************/
 
 /*
- *	This module parses URLs into their components.
+ *  This module parses URLs into their components.
  */
 
 /********************************* Includes ***********************************/
 
-#include	"wsIntrn.h"
+#include    "wsIntrn.h"
 
 /********************************* Statics ************************************/
 /*
-  	htmExt is declared in this way to avoid a Linux and Solaris segmentation
-  	fault when a constant string is passed to strlower which could change its
-  	argument.
+    htmExt is declared in this way to avoid a Linux and Solaris segmentation
+    fault when a constant string is passed to strlower which could change its
+    argument.
  */
 //  MOB - static
-char_t	htmExt[] = T(".htm");
+char_t  htmExt[] = T(".htm");
 
 /*********************************** Code *************************************/
 /*
-  	Return the mime type for the given URL given a URL. The caller supplies the buffer to hold the result.
-  	charCnt is the number of characters the buffer will hold, ascii or UNICODE.
+    Return the mime type for the given URL given a URL. The caller supplies the buffer to hold the result.
+    charCnt is the number of characters the buffer will hold, ascii or UNICODE.
  */
 char_t *websUrlType(char_t *url, char_t *buf, int charCnt)
 {
-	sym_t	*sp;
-	char_t	*ext, *parsebuf;
-
-	a_assert(url && *url);
-	a_assert(buf && charCnt > 0);
-
-	if (url == NULL || *url == '\0') {
-		gstrcpy(buf, T("text/plain"));
-		return buf;
-	}
-	if (websUrlParse(url, &parsebuf, NULL, NULL, NULL, NULL, NULL, 
-			NULL, &ext) < 0) {
-		gstrcpy(buf, T("text/plain"));
-		return buf;
-	}
-	strlower(ext);
+    sym_t   *sp;
+    char_t  *ext, *parsebuf;
+
+    a_assert(url && *url);
+    a_assert(buf && charCnt > 0);
+
+    if (url == NULL || *url == '\0') {
+        gstrcpy(buf, T("text/plain"));
+        return buf;
+    }
+    if (websUrlParse(url, &parsebuf, NULL, NULL, NULL, NULL, NULL, 
+            NULL, &ext) < 0) {
+        gstrcpy(buf, T("text/plain"));
+        return buf;
+    }
+    strlower(ext);
 
     /*
-      	Lookup the mime type symbol table to find the relevant content type
+        Lookup the mime type symbol table to find the relevant content type
      */
-	if ((sp = symLookup(websMime, ext)) != NULL) {
-		gstrncpy(buf, sp->content.value.string, charCnt);
-	} else {
-		gstrcpy(buf, T("text/plain"));
-	}
-	bfree(B_L, parsebuf);
-	return buf;
+    if ((sp = symLookup(websMime, ext)) != NULL) {
+        gstrncpy(buf, sp->content.value.string, charCnt);
+    } else {
+        gstrcpy(buf, T("text/plain"));
+    }
+    bfree(B_L, parsebuf);
+    return buf;
 }
 
 
@@ -67,137 +67,137 @@ char_t *websUrlType(char_t *url, char_t *buf, int charCnt)
 int websUrlParse(char_t *url, char_t **pbuf, char_t **phost, char_t **ppath, char_t **pport, char_t **pquery, 
         char_t **pproto, char_t **ptag, char_t **pext)
 {
-	char_t		*tok, *cp, *host, *path, *port, *proto, *tag, *query, *ext;
-	char_t		*hostbuf, *portbuf, *buf;
-	int			c, len, ulen;
+    char_t      *tok, *cp, *host, *path, *port, *proto, *tag, *query, *ext;
+    char_t      *hostbuf, *portbuf, *buf;
+    int         c, len, ulen;
 
-	a_assert(url);
-	a_assert(pbuf);
+    a_assert(url);
+    a_assert(pbuf);
 
-	ulen = gstrlen(url);
+    ulen = gstrlen(url);
     /*
         We allocate enough to store separate hostname and port number fields.  As there are 3 strings in the one buffer,
         we need room for 3 null chars.  We allocate MAX_PORT_LEN char_t's for the port number.  
      */
-	len = ulen * 2 + MAX_PORT_LEN + 3;
-	if ((buf = balloc(B_L, len * sizeof(char_t))) == NULL) {
-		return -1;
-	}
-	portbuf = &buf[len - MAX_PORT_LEN - 1];
-	hostbuf = &buf[ulen+1];
- 	websDecodeUrl(buf, url, ulen);
+    len = ulen * 2 + MAX_PORT_LEN + 3;
+    if ((buf = balloc(B_L, len * sizeof(char_t))) == NULL) {
+        return -1;
+    }
+    portbuf = &buf[len - MAX_PORT_LEN - 1];
+    hostbuf = &buf[ulen+1];
+    websDecodeUrl(buf, url, ulen);
 
-	url = buf;
+    url = buf;
 
     /*
         Convert the current listen port to a string. We use this if the URL has no explicit port setting
      */
-	stritoa(websGetPort(), portbuf, MAX_PORT_LEN);
-	port = portbuf;
-	path = T("/");
-	proto = T("http");
-	host = T("localhost");
-	query = T("");
-	ext = htmExt;
-	tag = T("");
-
-	if (gstrncmp(url, T("http://"), 7) == 0) {
-		tok = &url[7];
-		tok[-3] = '\0';
-		proto = url;
-		host = tok;
-		for (cp = tok; *cp; cp++) {
-			if (*cp == '/') {
-				break;
-			}
-			if (*cp == ':') {
-				*cp++ = '\0';
-				port = cp;
-				tok = cp;
-			}
-		}
-		if ((cp = gstrchr(tok, '/')) != NULL) {
+    stritoa(websGetPort(), portbuf, MAX_PORT_LEN);
+    port = portbuf;
+    path = T("/");
+    proto = T("http");
+    host = T("localhost");
+    query = T("");
+    ext = htmExt;
+    tag = T("");
+
+    if (gstrncmp(url, T("http://"), 7) == 0) {
+        tok = &url[7];
+        tok[-3] = '\0';
+        proto = url;
+        host = tok;
+        for (cp = tok; *cp; cp++) {
+            if (*cp == '/') {
+                break;
+            }
+            if (*cp == ':') {
+                *cp++ = '\0';
+                port = cp;
+                tok = cp;
+            }
+        }
+        if ((cp = gstrchr(tok, '/')) != NULL) {
             /*
                 If a full URL is supplied, we need to copy the host and port portions into static buffers.
              */
-			c = *cp;
-			*cp = '\0';
-			gstrncpy(hostbuf, host, ulen);
-			gstrncpy(portbuf, port, MAX_PORT_LEN);
-			*cp = c;
-			host = hostbuf;
-			port = portbuf;
-			path = cp;
-			tok = cp;
-		}
-	} else {
-		path = url;
-		tok = url;
-	}
+            c = *cp;
+            *cp = '\0';
+            gstrncpy(hostbuf, host, ulen);
+            gstrncpy(portbuf, port, MAX_PORT_LEN);
+            *cp = c;
+            host = hostbuf;
+            port = portbuf;
+            path = cp;
+            tok = cp;
+        }
+    } else {
+        path = url;
+        tok = url;
+    }
 
     /*
-      	Parse the query string
+        Parse the query string
      */
-	if ((cp = gstrchr(tok, '?')) != NULL) {
-		*cp++ = '\0';
-		query = cp;
-		path = tok;
-		tok = query;
-	} 
+    if ((cp = gstrchr(tok, '?')) != NULL) {
+        *cp++ = '\0';
+        query = cp;
+        path = tok;
+        tok = query;
+    } 
 
     /*
-      	Parse the fragment identifier
+        Parse the fragment identifier
      */
-	if ((cp = gstrchr(tok, '#')) != NULL) {
-		*cp++ = '\0';
-		if (*query == 0) {
-			path = tok;
-		}
-	}
+    if ((cp = gstrchr(tok, '#')) != NULL) {
+        *cp++ = '\0';
+        if (*query == 0) {
+            path = tok;
+        }
+    }
 
     /*
-      	Only do the following if asked for the extension
+        Only do the following if asked for the extension
      */
-	if (pext) {
-		/*
+    if (pext) {
+        /*
             Later the path will be cleaned up for trailing slashes and so on.  To be ready, we need to clean up here,
             much as in websValidateUrl.  Otherwise a URL ending in "asp/" or "asP" sends Ejscript source to the browser.
-		*/
-		if ((cp = gstrrchr(path, '.')) != NULL) {
-			const char_t* garbage = T("/\\");
-			int length = gstrcspn(cp, garbage);
-			int garbageLength = gstrspn(cp + length, garbage);
-			int ok = (length + garbageLength == (int) gstrlen(cp));
-
-			if (ok) {
-				cp[length] = '\0';
+        */
+        if ((cp = gstrrchr(path, '.')) != NULL) {
+            const char_t* garbage = T("/\\");
+            int length = gstrcspn(cp, garbage);
+            int garbageLength = gstrspn(cp + length, garbage);
+            int ok = (length + garbageLength == (int) gstrlen(cp));
+
+            if (ok) {
+                cp[length] = '\0';
 #ifdef WIN32
-				strlower(cp);            
+                strlower(cp);            
 #endif
-				ext = cp;
-			}
-		}
-	}
+                ext = cp;
+            }
+        }
+    }
 
     /*
-      	Pass back the fields requested (if not NULL)
+        Pass back the fields requested (if not NULL)
      */
-	if (phost)
-		*phost = host;
-	if (ppath)
-		*ppath = path;
-	if (pport)
-		*pport = port;
-	if (pproto)
-		*pproto = proto;
-	if (pquery)
-		*pquery = query;
-	if (ptag)
-		*ptag = tag;
-	if (pext)
-		*pext = ext;
-	*pbuf = buf;
-	return 0;
+    if (phost)
+        *phost = host;
+    if (ppath)
+        *ppath = path;
+    if (pport)
+        *pport = port;
+    if (pproto)
+        *pproto = proto;
+    if (pquery)
+        *pquery = query;
+    if (ptag)
+        *ptag = tag;
+    if (pext)
+        *pext = ext;
+    *pbuf = buf;
+    return 0;
 }
 
 
diff --git a/utils/webcomp.c b/utils/webcomp.c
index 1304d0d9..6708b868 100644
--- a/utils/webcomp.c
+++ b/utils/webcomp.c
@@ -11,11 +11,11 @@
 /******************************** Description *********************************/
 
 /*
- *	Usage: webcomp prefix filelist >webrom.c
+ *  Usage: webcomp prefix filelist >webrom.c
  *
- *	filelist is a file containing the pathnames of all web pages
- *	prefix is a path prefix to remove from all the web page pathnames
- *	webrom.c is the resulting C source file to compile and link.
+ *  filelist is a file containing the pathnames of all web pages
+ *  prefix is a path prefix to remove from all the web page pathnames
+ *  webrom.c is the resulting C source file to compile and link.
  */
 
 /********************************* Includes ***********************************/
@@ -37,170 +37,170 @@ typedef struct stat stat_t;
 
 /**************************** Forward Declarations ****************************/
 
-static int 	compile(char *fileList, char *prefix);
+static int  compile(char *fileList, char *prefix);
 static void usage();
 
 /*********************************** Code *************************************/
 /*
- *	Main program
+ *  Main program
  */
 
 int main(int argc, char* argv[])
 {
-	char		*fileList, *prefix;
+    char        *fileList, *prefix;
 
-	fileList = NULL;
+    fileList = NULL;
 
-	if (argc != 3) {
-		usage();
-	}
+    if (argc != 3) {
+        usage();
+    }
 
-	prefix = argv[1];
-	fileList = argv[2];
+    prefix = argv[1];
+    fileList = argv[2];
 
-	if (compile(fileList, prefix) < 0) {
-		return -1;
-	}
-	return 0;
+    if (compile(fileList, prefix) < 0) {
+        return -1;
+    }
+    return 0;
 }
 
 /******************************************************************************/
 /*
- *	Output usage message
+ *  Output usage message
  */
 
 static void usage()
 {
-	fprintf(stderr, "usage: webcomp prefix filelist >output.c\n\
+    fprintf(stderr, "usage: webcomp prefix filelist >output.c\n\
     filelist is a file containing the pathnames of all web pages\n\
     prefix is a path prefix to remove from all the web page pathnames\n\
     output.c is the resulting C source file to compile and link.\n");
 
-	exit(2);
+    exit(2);
 }
 
 /******************************************************************************/
 /*
- *	Compile the web pages
+ *  Compile the web pages
  */
 
 static int compile(char *fileList, char *prefix)
 {
-	stat_t			sbuf;
-	FILE			*lp;
-	time_t			now;
-	char			file[FNAMESIZE];
-	char			*cp, *sl;
-	char			buf[512];
-	unsigned char	*p;
-	int				j, i, len, fd, nFile;
+    stat_t          sbuf;
+    FILE            *lp;
+    time_t          now;
+    char            file[FNAMESIZE];
+    char            *cp, *sl;
+    char            buf[512];
+    unsigned char   *p;
+    int             j, i, len, fd, nFile;
 
 /*
- *	Open list of files
+ *  Open list of files
  */
-	if ((lp = fopen(fileList, "r")) == NULL) {
-		fprintf(stderr, "Can't open file list %s\n", fileList);
-		return -1;
-	}
-
-	time(&now);
-	fprintf(stdout, "/*\n * webrom.c -- Compiled Web Pages\n *\n");
-	fprintf(stdout, " * Compiled by GoAhead WebCompile: %s */\n\n", 
-		ctime(&now));
-	fprintf(stdout, "#include \"wsIntrn.h\"\n\n");
-	fprintf(stdout, "#ifndef WEBS_PAGE_ROM\n");
-	fprintf(stdout, "websRomPageIndexType websRomPageIndex[] = {\n");
-	fprintf(stdout, "\t{ 0, 0, 0 }\n};\n");
-	fprintf(stdout, "#else\n");
+    if ((lp = fopen(fileList, "r")) == NULL) {
+        fprintf(stderr, "Can't open file list %s\n", fileList);
+        return -1;
+    }
+
+    time(&now);
+    fprintf(stdout, "/*\n * webrom.c -- Compiled Web Pages\n *\n");
+    fprintf(stdout, " * Compiled by GoAhead WebCompile: %s */\n\n", 
+        ctime(&now));
+    fprintf(stdout, "#include \"wsIntrn.h\"\n\n");
+    fprintf(stdout, "#ifndef WEBS_PAGE_ROM\n");
+    fprintf(stdout, "websRomPageIndexType websRomPageIndex[] = {\n");
+    fprintf(stdout, "\t{ 0, 0, 0 }\n};\n");
+    fprintf(stdout, "#else\n");
 
 /*
- *	Open each input file and compile each web page
+ *  Open each input file and compile each web page
  */
-	nFile = 0;
-	while (fgets(file, sizeof(file), lp) != NULL) {
-		if ((p = (unsigned char *)strchr(file, '\n')) || 
-				(p = (unsigned char *)strchr(file, '\r'))) {
-			*p = '\0';
-		}
-		if (*file == '\0') {
-			continue;
-		}
-		if (stat(file, &sbuf) == 0 && sbuf.st_mode & S_IFDIR) {
-			continue;
-		} 
-		if ((fd = open(file, O_RDONLY | O_BINARY)) < 0) {
-			fprintf(stderr, "Can't open file %s\n", file);
-			return -1;
-		}
-		fprintf(stdout, "/* %s */\n", file);
-		fprintf(stdout, "static unsigned char p%d[] = {\n", nFile);
-
-		while ((len = read(fd, buf, sizeof(buf))) > 0) {
-			p = (unsigned char*)buf;
-			for (i = 0; i < len; ) {
-				fprintf(stdout, "\t");
-				for (j = 0; p<(unsigned char*)(&buf[len]) && j < 16; j++, p++) {
-					fprintf(stdout, "%3d,", *p);
-				}
-				i += j;
-				fprintf(stdout, "\n");
-			}
-		}
-		fprintf(stdout, "\t0 };\n\n");
-
-		close(fd);
-		nFile++;
-	}
-	fclose(lp);
+    nFile = 0;
+    while (fgets(file, sizeof(file), lp) != NULL) {
+        if ((p = (unsigned char *)strchr(file, '\n')) || 
+                (p = (unsigned char *)strchr(file, '\r'))) {
+            *p = '\0';
+        }
+        if (*file == '\0') {
+            continue;
+        }
+        if (stat(file, &sbuf) == 0 && sbuf.st_mode & S_IFDIR) {
+            continue;
+        } 
+        if ((fd = open(file, O_RDONLY | O_BINARY)) < 0) {
+            fprintf(stderr, "Can't open file %s\n", file);
+            return -1;
+        }
+        fprintf(stdout, "/* %s */\n", file);
+        fprintf(stdout, "static unsigned char p%d[] = {\n", nFile);
+
+        while ((len = read(fd, buf, sizeof(buf))) > 0) {
+            p = (unsigned char*)buf;
+            for (i = 0; i < len; ) {
+                fprintf(stdout, "\t");
+                for (j = 0; p<(unsigned char*)(&buf[len]) && j < 16; j++, p++) {
+                    fprintf(stdout, "%3d,", *p);
+                }
+                i += j;
+                fprintf(stdout, "\n");
+            }
+        }
+        fprintf(stdout, "\t0 };\n\n");
+
+        close(fd);
+        nFile++;
+    }
+    fclose(lp);
 
 /*
- *	Now output the page index
+ *  Now output the page index
  */
-	fprintf(stdout, "websRomPageIndexType websRomPageIndex[] = {\n");
-
-	if ((lp = fopen(fileList, "r")) == NULL) {
-		fprintf(stderr, "Can't open file list %s\n", fileList);
-		return -1;
-	}
-	nFile = 0;
-	while (fgets(file, sizeof(file), lp) != NULL) {
-		if ((p = (unsigned char *)strchr(file, '\n')) || 
-				(p = (unsigned char *)strchr(file, '\r'))) {
-			*p = '\0';
-		}
-		if (*file == '\0') {
-			continue;
-		}
+    fprintf(stdout, "websRomPageIndexType websRomPageIndex[] = {\n");
+
+    if ((lp = fopen(fileList, "r")) == NULL) {
+        fprintf(stderr, "Can't open file list %s\n", fileList);
+        return -1;
+    }
+    nFile = 0;
+    while (fgets(file, sizeof(file), lp) != NULL) {
+        if ((p = (unsigned char *)strchr(file, '\n')) || 
+                (p = (unsigned char *)strchr(file, '\r'))) {
+            *p = '\0';
+        }
+        if (*file == '\0') {
+            continue;
+        }
 /*
- *		Remove the prefix and add a leading "/" when we print the path
+ *      Remove the prefix and add a leading "/" when we print the path
  */
-		if (strncmp(file, prefix, strlen(prefix)) == 0) {
-			cp = &file[strlen(prefix)];
-		} else {
-			cp = file;
-		}
-		while((sl = strchr(file, '\\')) != NULL) {
-			*sl = '/';
-		}
-		if (*cp == '/') {
-			cp++;
-		}
-
-		if (stat(file, &sbuf) == 0 && sbuf.st_mode & S_IFDIR) {
-			fprintf(stdout, "\t{ T(\"/%s\"), 0, 0 },\n", cp);
-			continue;
-		}
-		fprintf(stdout, "\t{ T(\"/%s\"), p%d, %d },\n", cp, nFile, 
-			sbuf.st_size);
-		nFile++;
-	}
-	fclose(lp); 
-	
-	fprintf(stdout, "\t{ 0, 0, 0 }\n");
-	fprintf(stdout, "};\n");
-	fprintf(stdout, "#endif /* WEBS_PAGE_ROM */\n");
-	fflush(stdout);
-	return 0;
+        if (strncmp(file, prefix, strlen(prefix)) == 0) {
+            cp = &file[strlen(prefix)];
+        } else {
+            cp = file;
+        }
+        while((sl = strchr(file, '\\')) != NULL) {
+            *sl = '/';
+        }
+        if (*cp == '/') {
+            cp++;
+        }
+
+        if (stat(file, &sbuf) == 0 && sbuf.st_mode & S_IFDIR) {
+            fprintf(stdout, "\t{ T(\"/%s\"), 0, 0 },\n", cp);
+            continue;
+        }
+        fprintf(stdout, "\t{ T(\"/%s\"), p%d, %d },\n", cp, nFile, 
+            sbuf.st_size);
+        nFile++;
+    }
+    fclose(lp); 
+    
+    fprintf(stdout, "\t{ 0, 0, 0 }\n");
+    fprintf(stdout, "};\n");
+    fprintf(stdout, "#endif /* WEBS_PAGE_ROM */\n");
+    fflush(stdout);
+    return 0;
 }
 
 /******************************************************************************/
diff --git a/value.c b/value.c
index c0ab26fc..05c344a5 100644
--- a/value.c
+++ b/value.c
@@ -6,48 +6,48 @@
 
 /********************************* Includes ***********************************/
 
-#include	"uemf.h"
+#include    "uemf.h"
 
 /*********************************** Code *************************************/
 
 value_t valueInteger(long value)
 {
-	value_t	v;
+    value_t v;
 
-	memset(&v, 0x0, sizeof(v));
-	v.valid = 1;
-	v.type = integer;
-	v.value.integer = value;
-	return v;
+    memset(&v, 0x0, sizeof(v));
+    v.valid = 1;
+    v.type = integer;
+    v.value.integer = value;
+    return v;
 }
 
 
 value_t valueString(char_t* value, int flags)
 {
-	value_t	v;
-
-	memset(&v, 0x0, sizeof(v));
-	v.valid = 1;
-	v.type = string;
-	if (flags & VALUE_ALLOCATE) {
-		v.allocated = 1;
-		v.value.string = gstrdup(B_L, value);
-	} else {
-		v.allocated = 0;
-		v.value.string = value;
-	}
-	return v;
+    value_t v;
+
+    memset(&v, 0x0, sizeof(v));
+    v.valid = 1;
+    v.type = string;
+    if (flags & VALUE_ALLOCATE) {
+        v.allocated = 1;
+        v.value.string = gstrdup(B_L, value);
+    } else {
+        v.allocated = 0;
+        v.value.string = value;
+    }
+    return v;
 }
 
 
 void valueFree(value_t* v)
 {
-	if (v->valid && v->allocated && v->type == string && v->value.string != NULL) {
-		bfree(B_L, v->value.string);
-	}
-	v->type = undefined;
-	v->valid = 0;
-	v->allocated = 0;
+    if (v->valid && v->allocated && v->type == string && v->value.string != NULL) {
+        bfree(B_L, v->value.string);
+    }
+    v->type = undefined;
+    v->valid = 0;
+    v->allocated = 0;
 }
 
 
diff --git a/webs.c b/webs.c
index ba12ecb0..2c05d1c2 100644
--- a/webs.c
+++ b/webs.c
@@ -8,15 +8,15 @@
 /******************************** Description *********************************/
 
 /*
- *	This module implements an embedded HTTP/1.1 web server. It supports
- *	loadable URL handlers that define the nature of URL processing performed.
+ *  This module implements an embedded HTTP/1.1 web server. It supports
+ *  loadable URL handlers that define the nature of URL processing performed.
  */
 
 /********************************* Includes ***********************************/
 
-#include	"wsIntrn.h"
+#include    "wsIntrn.h"
 #ifdef DIGEST_ACCESS_SUPPORT
-	#include	"websda.h"
+    #include    "websda.h"
 #endif
 
 //  MOB - mov eto header
@@ -24,254 +24,254 @@ extern socket_t                **socketList;                   /* List of open s
 
 /******************************** Global Data *********************************/
 
-websStatsType	websStats;				/* Web access stats */
-webs_t			*webs;					/* Open connection list head */
-sym_fd_t		websMime;				/* Set of mime types */
-int				websMax;				/* List size */
-int				websPort;				/* Listen port for server */
-char_t			websHost[64];			/* Host name for the server */
-char_t			websIpaddr[64];			/* IP address for the server */
-char_t			*websHostUrl = NULL;	/* URL to access server */
-char_t			*websIpaddrUrl = NULL;	/* URL to access server */
+websStatsType   websStats;              /* Web access stats */
+webs_t          *webs;                  /* Open connection list head */
+sym_fd_t        websMime;               /* Set of mime types */
+int             websMax;                /* List size */
+int             websPort;               /* Listen port for server */
+char_t          websHost[64];           /* Host name for the server */
+char_t          websIpaddr[64];         /* IP address for the server */
+char_t          *websHostUrl = NULL;    /* URL to access server */
+char_t          *websIpaddrUrl = NULL;  /* URL to access server */
 
 /*********************************** Locals ***********************************/
 /*
- *	Standard HTTP error codes
+ *  Standard HTTP error codes
  */
 
 websErrorType websErrors[] = {
-	{ 200, T("Data follows") },
-	{ 204, T("No Content") },
-	{ 301, T("Redirect") },
-	{ 302, T("Redirect") },
-	{ 304, T("Use local copy") },
-	{ 400, T("Page not found") },
-	{ 401, T("Unauthorized") },
-	{ 403, T("Forbidden") },
-	{ 404, T("Site or Page Not Found") },
-	{ 405, T("Access Denied") },
-	{ 500, T("Web Error") },
-	{ 501, T("Not Implemented") },
-	{ 503, T("Site Temporarily Unavailable. Try again.") },
-	{ 0, NULL }
+    { 200, T("Data follows") },
+    { 204, T("No Content") },
+    { 301, T("Redirect") },
+    { 302, T("Redirect") },
+    { 304, T("Use local copy") },
+    { 400, T("Page not found") },
+    { 401, T("Unauthorized") },
+    { 403, T("Forbidden") },
+    { 404, T("Site or Page Not Found") },
+    { 405, T("Access Denied") },
+    { 500, T("Web Error") },
+    { 501, T("Not Implemented") },
+    { 503, T("Site Temporarily Unavailable. Try again.") },
+    { 0, NULL }
 };
 
 #ifdef WEBS_LOG_SUPPORT
-static char_t	websLogname[64] = T("log.txt");	/* Log filename */
-static int 		websLogFd;						/* Log file handle */
+static char_t   websLogname[64] = T("log.txt"); /* Log filename */
+static int      websLogFd;                      /* Log file handle */
 #endif
 
 #ifdef WEBS_TRACE_SUPPORT
-static char_t	websTracename[64] = T("trace.txt");	/* Log filename */
-static int 		websTraceFd;						/* Log file handle */
+static char_t   websTracename[64] = T("trace.txt"); /* Log filename */
+static int      websTraceFd;                        /* Log file handle */
 #endif
 
-static int		websListenSock;					/* Listen socket */
-static char_t	websRealm[64] = T("GoAhead");	/* Realm name */
+static int      websListenSock;                 /* Listen socket */
+static char_t   websRealm[64] = T("GoAhead");   /* Realm name */
 
-static int		websOpenCount = 0;		/* count of apps using this module */
+static int      websOpenCount = 0;      /* count of apps using this module */
 
 /**************************** Forward Declarations ****************************/
 
 
-static int 		websGetInput(webs_t wp, char_t **ptext, int *nbytes);
-static int 		websParseFirst(webs_t wp, char_t *text);
-static void 	websParseRequest(webs_t wp);
-static void		websSocketEvent(int sid, int mask, void* data);
-static int		websGetTimeSinceMark(webs_t wp);
+static int      websGetInput(webs_t wp, char_t **ptext, int *nbytes);
+static int      websParseFirst(webs_t wp, char_t *text);
+static void     websParseRequest(webs_t wp);
+static void     websSocketEvent(int sid, int mask, void* data);
+static int      websGetTimeSinceMark(webs_t wp);
 
 #ifdef WEBS_LOG_SUPPORT
-static void 	websLog(webs_t wp, int code);
+static void     websLog(webs_t wp, int code);
 #endif
 #ifdef WEBS_TRACE_SUPPORT
-static void 	traceHandler(int level, char_t *buf);
+static void     traceHandler(int level, char_t *buf);
 #endif
 #ifdef WEBS_IF_MODIFIED_SUPPORT
-static time_t	dateParse(time_t tip, char_t *cmd);
+static time_t   dateParse(time_t tip, char_t *cmd);
 #endif
 
 /*********************************** Code *************************************/
 
 int websOpenServer(int port, int retries)
 {
-	websMimeType	*mt;
+    websMimeType    *mt;
 
-	if (++websOpenCount != 1) {
-		return websPort;
-	}
-	a_assert(port > 0);
-	a_assert(retries >= 0);
+    if (++websOpenCount != 1) {
+        return websPort;
+    }
+    a_assert(port > 0);
+    a_assert(retries >= 0);
 
-	websDefaultOpen();
+    websDefaultOpen();
 
 #ifdef WEBS_PAGE_ROM
-	websRomOpen();
+    websRomOpen();
 #endif
 
-	webs = NULL;
-	websMax = 0;
+    webs = NULL;
+    websMax = 0;
     /*
-      	Create a mime type lookup table for quickly determining the content type
+        Create a mime type lookup table for quickly determining the content type
      */
-	websMime = symOpen(WEBS_SYM_INIT * 4);
-	a_assert(websMime >= 0);
-	for (mt = websMimeList; mt->type; mt++) {
-		symEnter(websMime, mt->ext, valueString(mt->type, 0), 0);
-	}
+    websMime = symOpen(WEBS_SYM_INIT * 4);
+    a_assert(websMime >= 0);
+    for (mt = websMimeList; mt->type; mt++) {
+        symEnter(websMime, mt->ext, valueString(mt->type, 0), 0);
+    }
 
     /*
         Open the URL handler module. The caller should create the required URL handlers after calling this function.
      */
-	if (websUrlHandlerOpen() < 0) {
-		return -1;
-	}
-	websFormOpen();
+    if (websUrlHandlerOpen() < 0) {
+        return -1;
+    }
+    websFormOpen();
 
 #ifdef WEBS_LOG_SUPPORT
 #ifndef VXWORKS
-	websLogFd = gopen(websLogname, O_CREAT | O_TRUNC | O_APPEND | O_WRONLY, 0666);
+    websLogFd = gopen(websLogname, O_CREAT | O_TRUNC | O_APPEND | O_WRONLY, 0666);
 #else
-	websLogFd = gopen(websLogname, O_CREAT | O_TRUNC | O_WRONLY, 0666);
-	lseek(fd, 0, SEEK_END);
+    websLogFd = gopen(websLogname, O_CREAT | O_TRUNC | O_WRONLY, 0666);
+    lseek(fd, 0, SEEK_END);
 #endif /* VXWORKS */
-	a_assert(websLogFd >= 0);
+    a_assert(websLogFd >= 0);
 #endif
-	
+    
 #ifdef WEBS_TRACE_SUPPORT
 #ifndef VXWORKS
-	websTraceFd = gopen(websTracename, O_CREAT | O_TRUNC | O_APPEND | O_WRONLY, 0666);
+    websTraceFd = gopen(websTracename, O_CREAT | O_TRUNC | O_APPEND | O_WRONLY, 0666);
 #else
-	websTraceFd = gopen(websTracename, O_CREAT | O_TRUNC | O_WRONLY, 0666);
-	lseek(fd, 0, SEEK_END);
+    websTraceFd = gopen(websTracename, O_CREAT | O_TRUNC | O_WRONLY, 0666);
+    lseek(fd, 0, SEEK_END);
 #endif /* VXWORKS */
-	a_assert(websTraceFd >= 0);
-	traceSetHandler(traceHandler);
-#endif	
-	return websOpenListen(port, retries);
+    a_assert(websTraceFd >= 0);
+    traceSetHandler(traceHandler);
+#endif  
+    return websOpenListen(port, retries);
 }
 
 
 void websCloseServer()
 {
-	webs_t	wp;
-	int		wid;
+    webs_t  wp;
+    int     wid;
 
-	if (--websOpenCount > 0) {
-		return;
-	}
-	websCloseListen();
+    if (--websOpenCount > 0) {
+        return;
+    }
+    websCloseListen();
 
-	for (wid = websMax; webs && wid >= 0; wid--) {
-		if ((wp = webs[wid]) == NULL) {
-			continue;
-		}
-		socketCloseConnection(wp->sid);
-		websFree(wp);
-	}
+    for (wid = websMax; webs && wid >= 0; wid--) {
+        if ((wp = webs[wid]) == NULL) {
+            continue;
+        }
+        socketCloseConnection(wp->sid);
+        websFree(wp);
+    }
 
 #ifdef WEBS_LOG_SUPPORT
-	if (websLogFd >= 0) {
-		close(websLogFd);
-		websLogFd = -1;
-	}
+    if (websLogFd >= 0) {
+        close(websLogFd);
+        websLogFd = -1;
+    }
 #endif
 #ifdef WEBS_TRACE_SUPPORT
-	if (websTraceFd >= 0) {
-		close(websTraceFd);
-		websTraceFd = -1;
-	}
+    if (websTraceFd >= 0) {
+        close(websTraceFd);
+        websTraceFd = -1;
+    }
 #endif
 
 #ifdef WEBS_PAGE_ROM
-	websRomClose();
+    websRomClose();
 #endif
-	websDefaultClose();
-	symClose(websMime);
-	websFormClose();
-	websUrlHandlerClose();
+    websDefaultClose();
+    symClose(websMime);
+    websFormClose();
+    websUrlHandlerClose();
 }
 
 
 int websOpenListen(int port, int retries)
 {
-	int		i, orig;
+    int     i, orig;
 
-	a_assert(port > 0);
-	a_assert(retries >= 0);
+    a_assert(port > 0);
+    a_assert(retries >= 0);
 
-	orig = port;
+    orig = port;
 
     /*
-      	Open the webs webs listen port. If we fail, try the next port.
+        Open the webs webs listen port. If we fail, try the next port.
         MOB - not a good idea
      */
-	for (i = 0; i <= retries; i++) {
-		websListenSock = socketOpenConnection(NULL, port, websAccept, 0);
-		if (websListenSock >= 0) {
-			break;
-		}
-		port++;
-	}
-	if (i > retries) {
-		error(E_L, E_USER, T("Couldn't open a socket on ports %d - %d"), orig, port - 1);
-		return -1;
-	} 
+    for (i = 0; i <= retries; i++) {
+        websListenSock = socketOpenConnection(NULL, port, websAccept, 0);
+        if (websListenSock >= 0) {
+            break;
+        }
+        port++;
+    }
+    if (i > retries) {
+        error(E_L, E_USER, T("Couldn't open a socket on ports %d - %d"), orig, port - 1);
+        return -1;
+    } 
 
     /*
-      	Determine the full URL address to access the home page for this web server
+        Determine the full URL address to access the home page for this web server
      */
-	websPort = port;
-	bfreeSafe(B_L, websHostUrl);
-	bfreeSafe(B_L, websIpaddrUrl);
-	websIpaddrUrl = websHostUrl = NULL;
-
-	if (port == 80) {
-		websHostUrl = bstrdup(B_L, websHost);
-		websIpaddrUrl = bstrdup(B_L, websIpaddr);
-	} else {
-		fmtAlloc(&websHostUrl, WEBS_MAX_URL + 80, T("%s:%d"), websHost, port);
-		fmtAlloc(&websIpaddrUrl, WEBS_MAX_URL + 80, T("%s:%d"), websIpaddr, port);
-	}
-	trace(0, T("webs: Listening for HTTP requests at address %s\n"), websIpaddrUrl);
-	return port;
+    websPort = port;
+    bfreeSafe(B_L, websHostUrl);
+    bfreeSafe(B_L, websIpaddrUrl);
+    websIpaddrUrl = websHostUrl = NULL;
+
+    if (port == 80) {
+        websHostUrl = bstrdup(B_L, websHost);
+        websIpaddrUrl = bstrdup(B_L, websIpaddr);
+    } else {
+        fmtAlloc(&websHostUrl, WEBS_MAX_URL + 80, T("%s:%d"), websHost, port);
+        fmtAlloc(&websIpaddrUrl, WEBS_MAX_URL + 80, T("%s:%d"), websIpaddr, port);
+    }
+    trace(0, T("webs: Listening for HTTP requests at address %s\n"), websIpaddrUrl);
+    return port;
 }
 
 
 void websCloseListen()
 {
-	if (websListenSock >= 0) {
-		socketCloseConnection(websListenSock);
-		websListenSock = -1;
-	}
-	bfreeSafe(B_L, websHostUrl);
-	bfreeSafe(B_L, websIpaddrUrl);
-	websIpaddrUrl = websHostUrl = NULL;
+    if (websListenSock >= 0) {
+        socketCloseConnection(websListenSock);
+        websListenSock = -1;
+    }
+    bfreeSafe(B_L, websHostUrl);
+    bfreeSafe(B_L, websIpaddrUrl);
+    websIpaddrUrl = websHostUrl = NULL;
 }
 
 
 int websAccept(int sid, char *ipaddr, int port, int listenSid)
 {
-	webs_t	wp;
-	int		wid;
+    webs_t  wp;
+    int     wid;
     struct sockaddr_in      ifAddr;
     int len;
     char *pString;
 
-	a_assert(ipaddr && *ipaddr);
-	a_assert(sid >= 0);
-	a_assert(port >= 0);
+    a_assert(ipaddr && *ipaddr);
+    a_assert(sid >= 0);
+    a_assert(port >= 0);
 
     /*
         Allocate a new handle for this accepted connection. This will allocate a webs_t structure in the webs[] list
      */
-	if ((wid = websAlloc(sid)) < 0) {
-		return -1;
-	}
-	wp = webs[wid];
-	a_assert(wp);
-	wp->listenSid = listenSid;
+    if ((wid = websAlloc(sid)) < 0) {
+        return -1;
+    }
+    wp = webs[wid];
+    a_assert(wp);
+    wp->listenSid = listenSid;
 
-	ascToUni(wp->ipaddr, ipaddr, min(sizeof(wp->ipaddr), strlen(ipaddr) + 1));
+    ascToUni(wp->ipaddr, ipaddr, min(sizeof(wp->ipaddr), strlen(ipaddr) + 1));
 
     /*
         Get the ip address of the interface that acept the connection.
@@ -287,23 +287,23 @@ int websAccept(int sid, char *ipaddr, int port, int listenSid)
      Check if this is a request from a browser on this system. This is useful to know for permitting administrative
      operations only for local access 
      */
-	if (gstrcmp(wp->ipaddr, T("127.0.0.1")) == 0 || 
-			gstrcmp(wp->ipaddr, websIpaddr) == 0 || 
-			gstrcmp(wp->ipaddr, websHost) == 0) {
-		wp->flags |= WEBS_LOCAL_REQUEST;
-	}
+    if (gstrcmp(wp->ipaddr, T("127.0.0.1")) == 0 || 
+            gstrcmp(wp->ipaddr, websIpaddr) == 0 || 
+            gstrcmp(wp->ipaddr, websHost) == 0) {
+        wp->flags |= WEBS_LOCAL_REQUEST;
+    }
 
     /*
-      	Arrange for websSocketEvent to be called when read data is available
+        Arrange for websSocketEvent to be called when read data is available
      */
-	socketCreateHandler(sid, SOCKET_READABLE, websSocketEvent, wp);
+    socketCreateHandler(sid, SOCKET_READABLE, websSocketEvent, wp);
 
     /*
-      	Arrange for a timeout to kill hung requests
+        Arrange for a timeout to kill hung requests
      */
-	wp->timeout = emfSchedCallback(WEBS_TIMEOUT, websTimeout, (void *) wp);
-	trace(8, T("webs: accept request\n"));
-	return 0;
+    wp->timeout = emfSchedCallback(WEBS_TIMEOUT, websTimeout, (void *) wp);
+    trace(8, T("webs: accept request\n"));
+    return 0;
 }
 
 
@@ -313,22 +313,22 @@ int websAccept(int sid, char *ipaddr, int port, int listenSid)
  */
 static void websSocketEvent(int sid, int mask, void* iwp)
 {
-	webs_t	wp;
+    webs_t  wp;
 
-	wp = (webs_t) iwp;
-	a_assert(wp);
+    wp = (webs_t) iwp;
+    a_assert(wp);
 
-	if (! websValid(wp)) {
-		return;
-	}
-	if (mask & SOCKET_READABLE) {
-		websReadEvent(wp);
-	} 
-	if (mask & SOCKET_WRITABLE) {
-		if (websValid(wp) && wp->writeSocket) {
-			(*wp->writeSocket)(wp);
-		}
-	} 
+    if (! websValid(wp)) {
+        return;
+    }
+    if (mask & SOCKET_READABLE) {
+        websReadEvent(wp);
+    } 
+    if (mask & SOCKET_WRITABLE) {
+        if (websValid(wp) && wp->writeSocket) {
+            (*wp->writeSocket)(wp);
+        }
+    } 
 }
 
 
@@ -338,196 +338,196 @@ static void websSocketEvent(int sid, int mask, void* iwp)
  */
 void websReadEvent(webs_t wp)
 {
-	char_t 	*text;
-	int		rc, nbytes, len, done, fd, size;
+    char_t  *text;
+    int     rc, nbytes, len, done, fd, size;
 
-	a_assert(wp);
-	a_assert(websValid(wp));
+    a_assert(wp);
+    a_assert(websValid(wp));
 
-	websSetTimeMark(wp);
+    websSetTimeMark(wp);
 
     /*
         Read as many lines as possible. socketGets is called to read the header and socketRead is called to read posted
         data.  
      */
-	text = NULL;
-	fd = -1;
-	for (done = 0; !done; ) {
-		if (text) {
-			bfree(B_L, text);
-			text = NULL;
-		}
+    text = NULL;
+    fd = -1;
+    for (done = 0; !done; ) {
+        if (text) {
+            bfree(B_L, text);
+            text = NULL;
+        }
 
         /*
              Get more input into "text". Returns 0, if more data is needed to continue, -1 if finished with the request,
              or 1 if all required data is available for current state.
          */
-		while ((rc = websGetInput(wp, &text, &nbytes)) == 0) {
-			;
-		}
+        while ((rc = websGetInput(wp, &text, &nbytes)) == 0) {
+            ;
+        }
 
         /*
             websGetInput returns -1 if it finishes with the request
          */
-		if (rc < 0) {
-			break;
-		}
+        if (rc < 0) {
+            break;
+        }
 
         /*
             This is the state machine for the web server. 
          */
-		switch(wp->state) {
-		case WEBS_BEGIN:
+        switch(wp->state) {
+        case WEBS_BEGIN:
             /*
                 Parse the first line of the Http header
              */
-			if (websParseFirst(wp, text) < 0) {
-				done++;
-				break;
-			}
-			wp->state = WEBS_HEADER;
-			break;
-		
-		case WEBS_HEADER:
+            if (websParseFirst(wp, text) < 0) {
+                done++;
+                break;
+            }
+            wp->state = WEBS_HEADER;
+            break;
+        
+        case WEBS_HEADER:
             /*
                 Store more of the HTTP header. As we are doing line reads, we need to separate the lines with '\n'
              */
-			if (ringqLen(&wp->header) > 0) {
-				ringqPutStr(&wp->header, T("\n"));
-			}
-			ringqPutStr(&wp->header, text);
-			break;
+            if (ringqLen(&wp->header) > 0) {
+                ringqPutStr(&wp->header, T("\n"));
+            }
+            ringqPutStr(&wp->header, text);
+            break;
 
-		case WEBS_POST_CLEN:
+        case WEBS_POST_CLEN:
             /*
                 POST request with content specified by a content length.  If this is a CGI request, write the data to
                 the cgi stdin.
              */
 #ifndef __NO_CGI_BIN
-			if (wp->flags & WEBS_CGI_REQUEST) {
-				if (fd == -1) {
+            if (wp->flags & WEBS_CGI_REQUEST) {
+                if (fd == -1) {
 #if !defined(WIN32)
-					fd = gopen(wp->cgiStdin, O_CREAT | O_WRONLY | O_BINARY, 0666);
+                    fd = gopen(wp->cgiStdin, O_CREAT | O_WRONLY | O_BINARY, 0666);
 #else
-					_sopen_s(&fd, wp->cgiStdin, O_CREAT | O_WRONLY | O_BINARY, _SH_DENYNO, 0666);
+                    _sopen_s(&fd, wp->cgiStdin, O_CREAT | O_WRONLY | O_BINARY, _SH_DENYNO, 0666);
 #endif
-				}
-				gwrite(fd, text, nbytes);
-			} else 
+                }
+                gwrite(fd, text, nbytes);
+            } else 
 #endif
-			if (wp->query) {
-				if (wp->query[0] && !(wp->flags & WEBS_POST_DATA)) {
+            if (wp->query) {
+                if (wp->query[0] && !(wp->flags & WEBS_POST_DATA)) {
                     /*
                         Special case where the POST request also had query data specified in the URL, ie.
                         url?query_data. In this case the URL query data is separated by a '&' from the posted query
                         data.
                      */
-					len = gstrlen(wp->query);
-					if (text) {
-						size = (len + gstrlen(text) + 2) * sizeof(char_t);
-						wp->query = brealloc(B_L, wp->query, size);
-						wp->query[len++] = '&';
+                    len = gstrlen(wp->query);
+                    if (text) {
+                        size = (len + gstrlen(text) + 2) * sizeof(char_t);
+                        wp->query = brealloc(B_L, wp->query, size);
+                        wp->query[len++] = '&';
 #if !defined(WIN32)
-						strcpy(&wp->query[len], text);
+                        strcpy(&wp->query[len], text);
 #else
-						strcpy_s(&wp->query[len], size - len, text);
+                        strcpy_s(&wp->query[len], size - len, text);
 #endif
-					}
+                    }
 
-				} else {
+                } else {
                     /*
                         The existing query data came from the POST request so just append it.
                      */
                     if (text != NULL) {
                         len = gstrlen(wp->query);
-				        size = (len +	gstrlen(text) + 1) * sizeof(char_t);
+                        size = (len +   gstrlen(text) + 1) * sizeof(char_t);
                         wp->query = brealloc(B_L, wp->query, size);
                         if (wp->query) {
 #if !defined(WIN32)
                             gstrcpy(&wp->query[len], text);
 #else
-					        strcpy_s(&wp->query[len], size - len, text);
+                            strcpy_s(&wp->query[len], size - len, text);
 #endif
                         }
                     }
-				}
+                }
 
-			} else {
-				wp->query = bstrdup(B_L, text);
-			}
+            } else {
+                wp->query = bstrdup(B_L, text);
+            }
             /*
                 Calculate how much more post data is to be read.
              */
-			wp->flags |= WEBS_POST_DATA;
-			wp->clen -= nbytes;
-			if (wp->clen > 0) {
-				if (nbytes > 0) {
-					break;
-				}
-				done++;
-				break;
-			}
+            wp->flags |= WEBS_POST_DATA;
+            wp->clen -= nbytes;
+            if (wp->clen > 0) {
+                if (nbytes > 0) {
+                    break;
+                }
+                done++;
+                break;
+            }
             /*
                 No more data so process the request, (but be sure to close the input file first!).
              */
-			if (fd != -1) {
-				gclose (fd);
-				fd = -1;
-			}
-			websUrlHandlerRequest(wp);
-			done++;
-			break;
-
-		case WEBS_POST:
+            if (fd != -1) {
+                gclose (fd);
+                fd = -1;
+            }
+            websUrlHandlerRequest(wp);
+            done++;
+            break;
+
+        case WEBS_POST:
             /*
                 POST without content-length specification. If this is a CGI request, write the data to the cgi stdin.
                 socketGets was used to get the data and it strips \n's so add them back in here.
              */
 #ifndef __NO_CGI_BIN
-			if (wp->flags & WEBS_CGI_REQUEST) {
-				if (fd == -1) {
+            if (wp->flags & WEBS_CGI_REQUEST) {
+                if (fd == -1) {
 #if !defined(WIN32)
-					fd = gopen(wp->cgiStdin, O_CREAT | O_WRONLY | O_BINARY, 0666);
+                    fd = gopen(wp->cgiStdin, O_CREAT | O_WRONLY | O_BINARY, 0666);
 #else
-					_sopen_s(&fd, wp->cgiStdin, O_CREAT | O_WRONLY | O_BINARY, _SH_DENYNO, 0666);
+                    _sopen_s(&fd, wp->cgiStdin, O_CREAT | O_WRONLY | O_BINARY, _SH_DENYNO, 0666);
 #endif
-				}
+                }
                 gwrite(fd, text, nbytes);
-				gwrite(fd, T("\n"), sizeof(char_t));
-			} else
+                gwrite(fd, T("\n"), sizeof(char_t));
+            } else
 #endif
-			if (wp->query && *wp->query && !(wp->flags & WEBS_POST_DATA)) {
-				len = gstrlen(wp->query);
-				size = (len + gstrlen(text) + 2) * sizeof(char_t);
-				wp->query = brealloc(B_L, wp->query, size);
-				if (wp->query) {
-					wp->query[len++] = '&';
+            if (wp->query && *wp->query && !(wp->flags & WEBS_POST_DATA)) {
+                len = gstrlen(wp->query);
+                size = (len + gstrlen(text) + 2) * sizeof(char_t);
+                wp->query = brealloc(B_L, wp->query, size);
+                if (wp->query) {
+                    wp->query[len++] = '&';
 #if !defined(WIN32)
-					gstrcpy(&wp->query[len], text);
+                    gstrcpy(&wp->query[len], text);
 #else
-					strcpy_s(&wp->query[len], size - len, text);
+                    strcpy_s(&wp->query[len], size - len, text);
 #endif
-				}
-
-			} else {
-				wp->query = bstrdup(B_L, text);
-			}
-			wp->flags |= WEBS_POST_DATA;
-			done++;
-			break;
-
-		default:
-			websError(wp, 404, T("Bad state"));
-			done++;
-			break;
-		}
-	}
-	if (fd != -1) {
-		fd = gclose (fd);
-	}
-	if (text) {
-		bfree(B_L, text);
-	}
+                }
+
+            } else {
+                wp->query = bstrdup(B_L, text);
+            }
+            wp->flags |= WEBS_POST_DATA;
+            done++;
+            break;
+
+        default:
+            websError(wp, 404, T("Bad state"));
+            done++;
+            break;
+        }
+    }
+    if (fd != -1) {
+        fd = gclose (fd);
+    }
+    if (text) {
+        bfree(B_L, text);
+    }
 }
 
 
@@ -541,114 +541,114 @@ void websReadEvent(webs_t wp)
  */
 static int websGetInput(webs_t wp, char_t **ptext, int *pnbytes) 
 {
-	char_t	*text;
-	char	buf[WEBS_SOCKET_BUFSIZ+1];
-	int		nbytes, len, clen;
+    char_t  *text;
+    char    buf[WEBS_SOCKET_BUFSIZ+1];
+    int     nbytes, len, clen;
 
-	a_assert(websValid(wp));
-	a_assert(ptext);
-	a_assert(pnbytes);
+    a_assert(websValid(wp));
+    a_assert(ptext);
+    a_assert(pnbytes);
 
-	*ptext = text = NULL;
-	*pnbytes = 0;
+    *ptext = text = NULL;
+    *pnbytes = 0;
 
     /*
-      	If this request is a POST with a content length, we know the number
-      	of bytes to read so we use socketRead().
+        If this request is a POST with a content length, we know the number
+        of bytes to read so we use socketRead().
      */
-	if (wp->state == WEBS_POST_CLEN) {
-		len = (wp->clen > WEBS_SOCKET_BUFSIZ) ? WEBS_SOCKET_BUFSIZ : wp->clen;
-	} else {
-		len = 0;
-	}
-	if (len > 0) {
+    if (wp->state == WEBS_POST_CLEN) {
+        len = (wp->clen > WEBS_SOCKET_BUFSIZ) ? WEBS_SOCKET_BUFSIZ : wp->clen;
+    } else {
+        len = 0;
+    }
+    if (len > 0) {
 
 #ifdef WEBS_SSL_SUPPORT
-		if (wp->flags & WEBS_SECURE) {
-			nbytes = websSSLRead(wp->wsp, buf, len);
-		} else {
-			nbytes = socketRead(wp->sid, buf, len);
-		}
+        if (wp->flags & WEBS_SECURE) {
+            nbytes = websSSLRead(wp->wsp, buf, len);
+        } else {
+            nbytes = socketRead(wp->sid, buf, len);
+        }
 #else
-		nbytes = socketRead(wp->sid, buf, len);
+        nbytes = socketRead(wp->sid, buf, len);
 #endif
-		if (nbytes < 0) {						/* Error */
-			websDone(wp, 0);
-			return -1;
+        if (nbytes < 0) {                       /* Error */
+            websDone(wp, 0);
+            return -1;
 
-		}  else if (nbytes == 0) {				/* EOF or No data available */
+        }  else if (nbytes == 0) {              /* EOF or No data available */
             /*
                Infinite CPU usage if not all post data is sent. This is a side-effect of socketRead whose return value
                does not distinguish between EOF and no-data and we have to explicitly use the socketEof() to test for it.
              */
-			if (socketEof(wp->sid)) {
-				websDone(wp, 0);
-			}
-			return -1;
+            if (socketEof(wp->sid)) {
+                websDone(wp, 0);
+            }
+            return -1;
 
-		} else {								/* Valid data */
+        } else {                                /* Valid data */
             /*
                 Convert to UNICODE if necessary.  First be sure the string is NULL terminated.
              */
-			buf[nbytes] = '\0';
-			if ((text = ballocAscToUni(buf, nbytes)) == NULL) {
-				websError(wp, 503, T("Insufficient memory"));
-				return -1;
-			}
-		}
-
-	} else {
+            buf[nbytes] = '\0';
+            if ((text = ballocAscToUni(buf, nbytes)) == NULL) {
+                websError(wp, 503, T("Insufficient memory"));
+                return -1;
+            }
+        }
+
+    } else {
 #ifdef WEBS_SSL_SUPPORT
-		if (wp->flags & WEBS_SECURE) {
-			nbytes = websSSLGets(wp->wsp, &text);
-		} else {
-			nbytes = socketGets(wp->sid, &text);
-		}
+        if (wp->flags & WEBS_SECURE) {
+            nbytes = websSSLGets(wp->wsp, &text);
+        } else {
+            nbytes = socketGets(wp->sid, &text);
+        }
 #else
-		nbytes = socketGets(wp->sid, &text);
+        nbytes = socketGets(wp->sid, &text);
 #endif
 
-		if (nbytes < 0) {
-			int eof;
+        if (nbytes < 0) {
+            int eof;
             /*
                 Error, EOF or incomplete
              */
 #ifdef WEBS_SSL_SUPPORT
-			if (wp->flags & WEBS_SECURE) {
+            if (wp->flags & WEBS_SECURE) {
                 /*
-                    If state is WEBS_BEGIN and the request is secure, a -1 will usually	indicate SSL negotiation
+                    If state is WEBS_BEGIN and the request is secure, a -1 will usually indicate SSL negotiation
                  */
-				if (wp->state == WEBS_BEGIN) {
-					eof = 1;
-				} else {
-					eof = websSSLEof(wp->wsp);
-				}
-			} else {
-				eof = socketEof(wp->sid);
-			}
+                if (wp->state == WEBS_BEGIN) {
+                    eof = 1;
+                } else {
+                    eof = websSSLEof(wp->wsp);
+                }
+            } else {
+                eof = socketEof(wp->sid);
+            }
 #else
-			eof = socketEof(wp->sid);
+            eof = socketEof(wp->sid);
 #endif
 
-			if (eof) {
+            if (eof) {
                 /*
                     If this is a post request without content length, process the request as we now have all the data.
                     Otherwise just close the connection.
                  */
-				if (wp->state == WEBS_POST) {
-					websUrlHandlerRequest(wp);
-				} else {
-					websDone(wp, 0);
-				}
-			} else {
+                if (wp->state == WEBS_POST) {
+                    websUrlHandlerRequest(wp);
+                } else {
+                    websDone(wp, 0);
+                }
+            } else {
                 /*
                     If an error occurred and it wasn't an eof, close the connection
                  */
 #ifdef HP_FIX
-				websDone(wp, 0);
+                websDone(wp, 0);
 #endif /*HP_FIX*/
 
-			}
+            }
             /*
                 If state is WEBS_HEADER and the ringq is empty, then this is a simple request with no additional header
                 fields to process and no empty line terminator. NOTE: this fix for earlier versions of browsers is
@@ -656,43 +656,43 @@ static int websGetInput(webs_t wp, char_t **ptext, int *pnbytes)
                 only expecting a one line header, which is not necessarily the case. So we weren't processing the whole
                 header and weren't fufilling requests properly. 
             */
-			return -1;
+            return -1;
 
-		} else if (nbytes == 0) {
-			if (wp->state == WEBS_HEADER) {
+        } else if (nbytes == 0) {
+            if (wp->state == WEBS_HEADER) {
                 /*
                     Valid empty line, now finished with header
                  */
-				websParseRequest(wp);
-				if (wp->flags & WEBS_POST_REQUEST) {
-					if (wp->flags & WEBS_CLEN) {
-						wp->state = WEBS_POST_CLEN;
-						clen = wp->clen;
-					} else {
-						wp->state = WEBS_POST;
-						clen = 1;
-					}
-					if (clen > 0) {
+                websParseRequest(wp);
+                if (wp->flags & WEBS_POST_REQUEST) {
+                    if (wp->flags & WEBS_CLEN) {
+                        wp->state = WEBS_POST_CLEN;
+                        clen = wp->clen;
+                    } else {
+                        wp->state = WEBS_POST;
+                        clen = 1;
+                    }
+                    if (clen > 0) {
                         /*
                             Return 0 to get more data.
                          */
-						return 0;
-					}
-					return 1;
-				}
+                        return 0;
+                    }
+                    return 1;
+                }
                 /*
                     We've read the header so go and handle the request
                  */
-				websUrlHandlerRequest(wp);
-			}
-			return -1;
-		}
-	}
-	a_assert(text);
-	a_assert(nbytes > 0);
-	*ptext = text;
-	*pnbytes = nbytes;
-	return 1;
+                websUrlHandlerRequest(wp);
+            }
+            return -1;
+        }
+    }
+    a_assert(text);
+    a_assert(nbytes > 0);
+    *ptext = text;
+    *pnbytes = nbytes;
+    return 1;
 }
 
 
@@ -701,366 +701,366 @@ static int websGetInput(webs_t wp, char_t **ptext, int *pnbytes)
  */
 static int websParseFirst(webs_t wp, char_t *text)
 {
-	char_t 	*op, *proto, *protoVer, *url, *host, *query, *path, *port, *ext;
-	char_t	*buf;
-	int		testPort;
+    char_t  *op, *proto, *protoVer, *url, *host, *query, *path, *port, *ext;
+    char_t  *buf;
+    int     testPort;
 
-	a_assert(websValid(wp));
-	a_assert(text && *text);
+    a_assert(websValid(wp));
+    a_assert(text && *text);
 
     /*
-      	Determine the request type: GET, HEAD or POST
+        Determine the request type: GET, HEAD or POST
      */
-	op = gstrtok(text, T(" \t"));
-	if (op == NULL || *op == '\0') {
-		websError(wp, 400, T("Bad HTTP request"));
-		return -1;
-	}
-	if (gstrcmp(op, T("GET")) != 0) {
-		if (gstrcmp(op, T("POST")) == 0) {
-			wp->flags |= WEBS_POST_REQUEST;
-		} else if (gstrcmp(op, T("HEAD")) == 0) {
-			wp->flags |= WEBS_HEAD_REQUEST;
-		} else {
-			websError(wp, 400, T("Bad request type"));
-			return -1;
-		}
-	}
+    op = gstrtok(text, T(" \t"));
+    if (op == NULL || *op == '\0') {
+        websError(wp, 400, T("Bad HTTP request"));
+        return -1;
+    }
+    if (gstrcmp(op, T("GET")) != 0) {
+        if (gstrcmp(op, T("POST")) == 0) {
+            wp->flags |= WEBS_POST_REQUEST;
+        } else if (gstrcmp(op, T("HEAD")) == 0) {
+            wp->flags |= WEBS_HEAD_REQUEST;
+        } else {
+            websError(wp, 400, T("Bad request type"));
+            return -1;
+        }
+    }
 
     /*
-      	Store result in the form (CGI) variable store
+        Store result in the form (CGI) variable store
      */
-	websSetVar(wp, T("REQUEST_METHOD"), op);
+    websSetVar(wp, T("REQUEST_METHOD"), op);
 
-	url = gstrtok(NULL, T(" \t\n"));
-	if (url == NULL || *url == '\0') {
-		websError(wp, 400, T("Bad HTTP request"));
-		return -1;
-	}
-	protoVer = gstrtok(NULL, T(" \t\n"));
+    url = gstrtok(NULL, T(" \t\n"));
+    if (url == NULL || *url == '\0') {
+        websError(wp, 400, T("Bad HTTP request"));
+        return -1;
+    }
+    protoVer = gstrtok(NULL, T(" \t\n"));
 
     /*
         Parse the URL and store all the various URL components. websUrlParse returns an allocated buffer in buf which we
         must free. We support both proxied and non-proxied requests. Proxied requests will have http://host/ at the
         start of the URL. Non-proxied will just be local path names.
      */
-	host = path = port = proto = query = ext = NULL;
-	if (websUrlParse(url, &buf, &host, &path, &port, &query, &proto, NULL, &ext) < 0) {
-		websError(wp, 400, T("Bad URL format"));
-		return -1;
-	}
-	wp->url = bstrdup(B_L, url);
+    host = path = port = proto = query = ext = NULL;
+    if (websUrlParse(url, &buf, &host, &path, &port, &query, &proto, NULL, &ext) < 0) {
+        websError(wp, 400, T("Bad URL format"));
+        return -1;
+    }
+    wp->url = bstrdup(B_L, url);
 
 #ifndef __NO_CGI_BIN
-	if (gstrstr(url, CGI_BIN) != NULL) {
-		wp->flags |= WEBS_CGI_REQUEST;
-		if (wp->flags & WEBS_POST_REQUEST) {
-			wp->cgiStdin = websGetCgiCommName();
-		}
-	}
+    if (gstrstr(url, CGI_BIN) != NULL) {
+        wp->flags |= WEBS_CGI_REQUEST;
+        if (wp->flags & WEBS_POST_REQUEST) {
+            wp->cgiStdin = websGetCgiCommName();
+        }
+    }
 #endif
-	wp->query = bstrdup(B_L, query);
-	wp->host = bstrdup(B_L, host);
-	wp->path = bstrdup(B_L, path);
-	wp->protocol = bstrdup(B_L, proto);
-	wp->protoVersion = bstrdup(B_L, protoVer);
-	
-	if ((testPort = socketGetPort(wp->listenSid)) >= 0) {
-		wp->port = testPort;
-	} else {
-		wp->port = gatoi(port);
-	}
-	if (gstrcmp(ext, T(".asp")) == 0) {
-		wp->flags |= WEBS_ASP;
-	}
-	bfree(B_L, buf);
-
-	websUrlType(url, wp->type, TSZ(wp->type));
+    wp->query = bstrdup(B_L, query);
+    wp->host = bstrdup(B_L, host);
+    wp->path = bstrdup(B_L, path);
+    wp->protocol = bstrdup(B_L, proto);
+    wp->protoVersion = bstrdup(B_L, protoVer);
+    
+    if ((testPort = socketGetPort(wp->listenSid)) >= 0) {
+        wp->port = testPort;
+    } else {
+        wp->port = gatoi(port);
+    }
+    if (gstrcmp(ext, T(".asp")) == 0) {
+        wp->flags |= WEBS_ASP;
+    }
+    bfree(B_L, buf);
+
+    websUrlType(url, wp->type, TSZ(wp->type));
 
 #ifdef WEBS_PROXY_SUPPORT
     /*
-      	Determine if this is a request for local webs data. If it is not a proxied 
-      	request from the browser, we won't see the "http://" or the system name, so
-      	we assume it must be talking to us directly for local webs data.
-      	Note: not fully implemented yet.
+        Determine if this is a request for local webs data. If it is not a proxied 
+        request from the browser, we won't see the "http://" or the system name, so
+        we assume it must be talking to us directly for local webs data.
+        Note: not fully implemented yet.
      */
-	if (gstrstr(wp->url, T("http://")) == NULL || ((gstrcmp(wp->host, T("localhost")) == 0 || 
+    if (gstrstr(wp->url, T("http://")) == NULL || ((gstrcmp(wp->host, T("localhost")) == 0 || 
             gstrcmp(wp->host, websHost) == 0) && (wp->port == websPort))) {
-		wp->flags |= WEBS_LOCAL_PAGE;
-		if (gstrcmp(wp->path, T("/")) == 0) {
-			wp->flags |= WEBS_HOME_PAGE;
-		}
-	}
+        wp->flags |= WEBS_LOCAL_PAGE;
+        if (gstrcmp(wp->path, T("/")) == 0) {
+            wp->flags |= WEBS_HOME_PAGE;
+        }
+    }
 #endif
-	ringqFlush(&wp->header);
-	return 0;
+    ringqFlush(&wp->header);
+    return 0;
 }
 
 
 /*
-  	Parse a full request
+    Parse a full request
  */
 #define isgoodchar(s) (gisalnum((s)) || ((s) == '/') || ((s) == '_') || ((s) == '.')  || ((s) == '-') )
 
 static void websParseRequest(webs_t wp)
 {
-	char_t	*authType, *upperKey, *cp, *browser, *lp, *key, *value;
+    char_t  *authType, *upperKey, *cp, *browser, *lp, *key, *value;
 
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
     /*
-      	Define default CGI values
+        Define default CGI values
      */
-	websSetVar(wp, T("HTTP_AUTHORIZATION"), T(""));
+    websSetVar(wp, T("HTTP_AUTHORIZATION"), T(""));
 
     /* 
-      	Parse the header and create the Http header keyword variables
-      	We rewrite the header as we go for non-local requests.  NOTE: this
-       	modifies the header string directly and tokenizes each line with '\0'.
+        Parse the header and create the Http header keyword variables
+        We rewrite the header as we go for non-local requests.  NOTE: this
+        modifies the header string directly and tokenizes each line with '\0'.
     */
-	browser = NULL;
-	for (lp = (char_t*) wp->header.servp; lp && *lp; ) {
-		cp = lp;
-		if ((lp = gstrchr(lp, '\n')) != NULL) {
-			lp++;
-		}
-		if ((key = gstrtok(cp, T(": \t\n"))) == NULL) {
-			continue;
-		}
-		if ((value = gstrtok(NULL, T("\n"))) == NULL) {
-			value = T("");
-		}
-		while (gisspace(*value)) {
-			value++;
-		}
-		strlower(key);
+    browser = NULL;
+    for (lp = (char_t*) wp->header.servp; lp && *lp; ) {
+        cp = lp;
+        if ((lp = gstrchr(lp, '\n')) != NULL) {
+            lp++;
+        }
+        if ((key = gstrtok(cp, T(": \t\n"))) == NULL) {
+            continue;
+        }
+        if ((value = gstrtok(NULL, T("\n"))) == NULL) {
+            value = T("");
+        }
+        while (gisspace(*value)) {
+            value++;
+        }
+        strlower(key);
 
         /*
             Create a variable (CGI) for each line in the header
          */
-		fmtAlloc(&upperKey, (gstrlen(key) + 6), T("HTTP_%s"), key);
-		for (cp = upperKey; *cp; cp++) {
-			if (*cp == '-') {
-				*cp = '_';
+        fmtAlloc(&upperKey, (gstrlen(key) + 6), T("HTTP_%s"), key);
+        for (cp = upperKey; *cp; cp++) {
+            if (*cp == '-') {
+                *cp = '_';
             }
-		}
-		strupper(upperKey);
-		websSetVar(wp, upperKey, value);
-		bfree(B_L, upperKey);
+        }
+        strupper(upperKey);
+        websSetVar(wp, upperKey, value);
+        bfree(B_L, upperKey);
 
         /*
             Track the requesting agent (browser) type
          */
-		if (gstrcmp(key, T("user-agent")) == 0) {
-			wp->userAgent = bstrdup(B_L, value);
+        if (gstrcmp(key, T("user-agent")) == 0) {
+            wp->userAgent = bstrdup(B_L, value);
 
         /*
             Parse the user authorization. ie. password
          */
-		} else if (gstricmp(key, T("authorization")) == 0) {
+        } else if (gstricmp(key, T("authorization")) == 0) {
             /*
                 Determine the type of Authorization Request
              */
-			authType = bstrdup (B_L, value);
-			a_assert (authType);
-            /*			
+            authType = bstrdup (B_L, value);
+            a_assert (authType);
+            /*          
                 Truncate authType at the next non-alpha character
              */
-			cp = authType;
-			while (gisalpha(*cp)) {
-				cp++;
-			}
-			*cp = '\0';
+            cp = authType;
+            while (gisalpha(*cp)) {
+                cp++;
+            }
+            *cp = '\0';
 
-			wp->authType = bstrdup(B_L, authType);
-			bfree(B_L, authType);
+            wp->authType = bstrdup(B_L, authType);
+            bfree(B_L, authType);
 
-			if (gstricmp(wp->authType, T("basic")) == 0) {
-				char_t	userAuth[FNAMESIZE];
+            if (gstricmp(wp->authType, T("basic")) == 0) {
+                char_t  userAuth[FNAMESIZE];
                 /*
                     The incoming value is username:password (Basic authentication)
                  */
-				if ((cp = gstrchr(value, ' ')) != NULL) {
-					*cp = '\0';
+                if ((cp = gstrchr(value, ' ')) != NULL) {
+                    *cp = '\0';
                    bfree(B_L, wp->authType);
-					wp->authType = bstrdup(B_L, value);
-					websDecode64(userAuth, ++cp, sizeof(userAuth));
-				} else {
-					websDecode64(userAuth, value, sizeof(userAuth));
-				}
+                    wp->authType = bstrdup(B_L, value);
+                    websDecode64(userAuth, ++cp, sizeof(userAuth));
+                } else {
+                    websDecode64(userAuth, value, sizeof(userAuth));
+                }
                 /*
                     Split userAuth into userid and password
                  */
-				if ((cp = gstrchr(userAuth, ':')) != NULL) {
-					*cp++ = '\0';
-				}
-				if (cp) {
-					wp->userName = bstrdup(B_L, userAuth);
-					wp->password = bstrdup(B_L, cp);
-				} else {
-					wp->userName = bstrdup(B_L, T(""));
-					wp->password = bstrdup(B_L, T(""));
-				}
+                if ((cp = gstrchr(userAuth, ':')) != NULL) {
+                    *cp++ = '\0';
+                }
+                if (cp) {
+                    wp->userName = bstrdup(B_L, userAuth);
+                    wp->password = bstrdup(B_L, cp);
+                } else {
+                    wp->userName = bstrdup(B_L, T(""));
+                    wp->password = bstrdup(B_L, T(""));
+                }
                 /*
                     Set the flags to indicate digest authentication
                  */
-				wp->flags |= WEBS_AUTH_BASIC;
-			} else {
+                wp->flags |= WEBS_AUTH_BASIC;
+            } else {
 #ifdef DIGEST_ACCESS_SUPPORT
                 /*
                     The incoming value is slightly more complicated (Digest)
                  */
-				char_t *np;		/* pointer to end of tag name */
-				char_t tp;		/* temporary character holding space */
-				char_t *vp;		/* pointer to value */
-				char_t *npv;	/* pointer to end of value, "next" pointer */
-				char_t tpv;		/* temporary character holding space */
+                char_t *np;     /* pointer to end of tag name */
+                char_t tp;      /* temporary character holding space */
+                char_t *vp;     /* pointer to value */
+                char_t *npv;    /* pointer to end of value, "next" pointer */
+                char_t tpv;     /* temporary character holding space */
 
                 /*
                     Set the flags to indicate digest authentication
                  */
-				wp->flags |= WEBS_AUTH_DIGEST;
+                wp->flags |= WEBS_AUTH_DIGEST;
                 /*
                     Move cp to Next word beyond "Digest", vp to first char after '='.
                  */
- 				cp = value;
-				while (isgoodchar(*cp)) {
-					cp++;
-				}
-				while (!isgoodchar(*cp)) {
-					cp++;
-				}
+                cp = value;
+                while (isgoodchar(*cp)) {
+                    cp++;
+                }
+                while (!isgoodchar(*cp)) {
+                    cp++;
+                }
 
                 /*
                     Find beginning of value
                  */
-				vp = gstrchr(cp, '=');
-				while (vp) {
+                vp = gstrchr(cp, '=');
+                while (vp) {
                     /*
                         Zero-terminate tag name
                      */
-					np = cp;
-					while (isgoodchar(*np)) {
-						np++;
-					}
-					tp = *np;
-					*np = 0;
+                    np = cp;
+                    while (isgoodchar(*np)) {
+                        np++;
+                    }
+                    tp = *np;
+                    *np = 0;
                     /*
                         Advance value pointer to first legit character
                      */
-					vp++;
-					while (!isgoodchar(*vp)) {
-						vp++;
-					}
+                    vp++;
+                    while (!isgoodchar(*vp)) {
+                        vp++;
+                    }
                     /*
                         Zero-terminate value
                      */
-					npv = vp;
-					while (isgoodchar(*npv)) {
-						npv++;
-					}
-					tpv = *npv;
-					*npv = 0;
+                    npv = vp;
+                    while (isgoodchar(*npv)) {
+                        npv++;
+                    }
+                    tpv = *npv;
+                    *npv = 0;
                     /*
                         Extract the fields
                      */
-					if (gstricmp(cp, T("username")) == 0) {
-						wp->userName = bstrdup(B_L, vp);
-					} else if (gstricmp(cp, T("response")) == 0) {
-						wp->digest = bstrdup(B_L, vp);
-					} else if (gstricmp(cp, T("opaque")) == 0) {
-						wp->opaque = bstrdup(B_L, vp);
-					} else if (gstricmp(cp, T("uri")) == 0) {
-						wp->uri = bstrdup(B_L, vp);
-					} else if (gstricmp(cp, T("realm")) == 0) {
-						wp->realm = bstrdup(B_L, vp);
-					} else if (gstricmp(cp, T("nonce")) == 0) {
-						wp->nonce = bstrdup(B_L, vp);
-					} else if (gstricmp(cp, T("nc")) == 0) {
-						wp->nc = bstrdup(B_L, vp);
-					} else if (gstricmp(cp, T("cnonce")) == 0) {
-						wp->cnonce = bstrdup(B_L, vp);
-					} else if (gstricmp(cp, T("qop")) == 0) {
-						wp->qop = bstrdup(B_L, vp);
-					}
+                    if (gstricmp(cp, T("username")) == 0) {
+                        wp->userName = bstrdup(B_L, vp);
+                    } else if (gstricmp(cp, T("response")) == 0) {
+                        wp->digest = bstrdup(B_L, vp);
+                    } else if (gstricmp(cp, T("opaque")) == 0) {
+                        wp->opaque = bstrdup(B_L, vp);
+                    } else if (gstricmp(cp, T("uri")) == 0) {
+                        wp->uri = bstrdup(B_L, vp);
+                    } else if (gstricmp(cp, T("realm")) == 0) {
+                        wp->realm = bstrdup(B_L, vp);
+                    } else if (gstricmp(cp, T("nonce")) == 0) {
+                        wp->nonce = bstrdup(B_L, vp);
+                    } else if (gstricmp(cp, T("nc")) == 0) {
+                        wp->nc = bstrdup(B_L, vp);
+                    } else if (gstricmp(cp, T("cnonce")) == 0) {
+                        wp->cnonce = bstrdup(B_L, vp);
+                    } else if (gstricmp(cp, T("qop")) == 0) {
+                        wp->qop = bstrdup(B_L, vp);
+                    }
                     /*
                         Restore tag name and value zero-terminations
                      */
-					*np = tp;
-					*npv = tpv;
+                    *np = tp;
+                    *npv = tpv;
                     /*
                         Advance tag name and value pointers
                      */
- 					cp = npv;
-					while (*cp && isgoodchar(*cp)) {
-						cp++;
-					}
-					while (*cp && !isgoodchar(*cp)) {
-						cp++;
-					}
-
-					if (*cp) {
-						vp = gstrchr(cp, '=');
-					} else {
-						vp = NULL;
-					}
-				}
+                    cp = npv;
+                    while (*cp && isgoodchar(*cp)) {
+                        cp++;
+                    }
+                    while (*cp && !isgoodchar(*cp)) {
+                        cp++;
+                    }
+
+                    if (*cp) {
+                        vp = gstrchr(cp, '=');
+                    } else {
+                        vp = NULL;
+                    }
+                }
 #endif /* DIGEST_ACCESS_SUPPORT */
-			}
-		} else if (gstrcmp(key, T("content-length")) == 0) {
+            }
+        } else if (gstrcmp(key, T("content-length")) == 0) {
             wp->clen = gatoi(value);
             if (wp->clen > 0) {
-			    wp->flags |= WEBS_CLEN;			
-			    websSetVar(wp, T("CONTENT_LENGTH"), value);
+                wp->flags |= WEBS_CLEN;         
+                websSetVar(wp, T("CONTENT_LENGTH"), value);
             } else {
                 wp->clen = 0;
             }
-		} else if (gstrcmp(key, T("content-type")) == 0) {
-			websSetVar(wp, T("CONTENT_TYPE"), value);
+        } else if (gstrcmp(key, T("content-type")) == 0) {
+            websSetVar(wp, T("CONTENT_TYPE"), value);
 
 #ifdef WEBS_KEEP_ALIVE_SUPPORT
-		} else if (gstrcmp(key, T("connection")) == 0) {
-			strlower(value);
-			if (gstrcmp(value, T("keep-alive")) == 0) {
-				wp->flags |= WEBS_KEEP_ALIVE;
-			}
+        } else if (gstrcmp(key, T("connection")) == 0) {
+            strlower(value);
+            if (gstrcmp(value, T("keep-alive")) == 0) {
+                wp->flags |= WEBS_KEEP_ALIVE;
+            }
 #endif
 
 #ifdef WEBS_PROXY_SUPPORT
         /*
             This may be useful if you wish to keep a local cache of web pages for proxied requests.
          */
-		} else if (gstrcmp(key, T("pragma")) == 0) {
-			char_t	tmp[256];
-			gstrncpy(tmp, value, TSZ(tmp));
-			strlower(tmp);
-			if (gstrstr(tmp, T("no-cache"))) {
-				wp->flags |= WEBS_DONT_USE_CACHE;
-			}
+        } else if (gstrcmp(key, T("pragma")) == 0) {
+            char_t  tmp[256];
+            gstrncpy(tmp, value, TSZ(tmp));
+            strlower(tmp);
+            if (gstrstr(tmp, T("no-cache"))) {
+                wp->flags |= WEBS_DONT_USE_CACHE;
+            }
 #endif /* WEBS_PROXY_SUPPORT */
 
-		} else if (gstrcmp(key, T("cookie")) == 0) {
-			wp->flags |= WEBS_COOKIE;
-			wp->cookie = bstrdup(B_L, value);
+        } else if (gstrcmp(key, T("cookie")) == 0) {
+            wp->flags |= WEBS_COOKIE;
+            wp->cookie = bstrdup(B_L, value);
 
 #ifdef WEBS_IF_MODIFIED_SUPPORT
-		} else if (gstrcmp(key, T("if-modified-since")) == 0) {
-			char_t *cmd;
-			time_t tip = 0;
+        } else if (gstrcmp(key, T("if-modified-since")) == 0) {
+            char_t *cmd;
+            time_t tip = 0;
 
-			if ((cp = gstrchr(value, ';')) != NULL) {
-				*cp = '\0';
-			}
+            if ((cp = gstrchr(value, ';')) != NULL) {
+                *cp = '\0';
+            }
 
-			fmtAlloc(&cmd, 64, T("%s"), value);
+            fmtAlloc(&cmd, 64, T("%s"), value);
 
-			if ((wp->since = dateParse(tip, cmd)) != 0) {
-				wp->flags |= WEBS_IF_MODIFIED;
-			}
-			bfreeSafe(B_L, cmd);
+            if ((wp->since = dateParse(tip, cmd)) != 0) {
+                wp->flags |= WEBS_IF_MODIFIED;
+            }
+            bfreeSafe(B_L, cmd);
 #endif /* WEBS_IF_MODIFIED_SUPPORT */
-		}
-	}
+        }
+    }
 }
 
 /*
@@ -1069,59 +1069,59 @@ static void websParseRequest(webs_t wp)
  */
 void websSetEnv(webs_t wp)
 {
-	char_t	portBuf[8];
-	char_t	*keyword, *value, *valCheck, *valNew;
-
-	a_assert(websValid(wp));
-
-	websSetVar(wp, T("QUERY_STRING"), wp->query);
-	websSetVar(wp, T("GATEWAY_INTERFACE"), T("CGI/1.1"));
-	websSetVar(wp, T("SERVER_HOST"), websHost);
-	websSetVar(wp, T("SERVER_NAME"), websHost);
-	websSetVar(wp, T("SERVER_URL"), websHostUrl);
-	websSetVar(wp, T("REMOTE_HOST"), wp->ipaddr);
-	websSetVar(wp, T("REMOTE_ADDR"), wp->ipaddr);
-	websSetVar(wp, T("PATH_INFO"), wp->path);
-	stritoa(websPort, portBuf, sizeof(portBuf));
-	websSetVar(wp, T("SERVER_PORT"), portBuf);
+    char_t  portBuf[8];
+    char_t  *keyword, *value, *valCheck, *valNew;
+
+    a_assert(websValid(wp));
+
+    websSetVar(wp, T("QUERY_STRING"), wp->query);
+    websSetVar(wp, T("GATEWAY_INTERFACE"), T("CGI/1.1"));
+    websSetVar(wp, T("SERVER_HOST"), websHost);
+    websSetVar(wp, T("SERVER_NAME"), websHost);
+    websSetVar(wp, T("SERVER_URL"), websHostUrl);
+    websSetVar(wp, T("REMOTE_HOST"), wp->ipaddr);
+    websSetVar(wp, T("REMOTE_ADDR"), wp->ipaddr);
+    websSetVar(wp, T("PATH_INFO"), wp->path);
+    stritoa(websPort, portBuf, sizeof(portBuf));
+    websSetVar(wp, T("SERVER_PORT"), portBuf);
        websSetVar(wp, T("SERVER_ADDR"), wp->ifaddr);
 #ifdef WEBS_SSL_SUPPORT
-	fmtAlloc(&value, FNAMESIZE, T("%s/%s %s/%s"), WEBS_NAME, WEBS_VERSION, SSL_NAME, SSL_VERSION);
+    fmtAlloc(&value, FNAMESIZE, T("%s/%s %s/%s"), WEBS_NAME, WEBS_VERSION, SSL_NAME, SSL_VERSION);
 #else
-	fmtAlloc(&value, FNAMESIZE, T("%s/%s"), WEBS_NAME, WEBS_VERSION);
+    fmtAlloc(&value, FNAMESIZE, T("%s/%s"), WEBS_NAME, WEBS_VERSION);
 #endif
-	websSetVar(wp, T("SERVER_SOFTWARE"), value);
-	bfreeSafe(B_L, value);
-	websSetVar(wp, T("SERVER_PROTOCOL"), wp->protoVersion);
+    websSetVar(wp, T("SERVER_SOFTWARE"), value);
+    bfreeSafe(B_L, value);
+    websSetVar(wp, T("SERVER_PROTOCOL"), wp->protoVersion);
 
     /*
         Decode and create an environment query variable for each query keyword. We split into pairs at each '&', then
         split pairs at the '='.  Note: we rely on wp->decodedQuery preserving the decoded values in the symbol table.
      */
-	wp->decodedQuery = bstrdup(B_L, wp->query);
-	keyword = gstrtok(wp->decodedQuery, T("&"));
-	while (keyword != NULL) {
-		if ((value = gstrchr(keyword, '=')) != NULL) {
-			*value++ = '\0';
-			websDecodeUrl(keyword, keyword, gstrlen(keyword));
-			websDecodeUrl(value, value, gstrlen(value));
-		} else {
-			value = T("");
-		}
-		if (*keyword) {
+    wp->decodedQuery = bstrdup(B_L, wp->query);
+    keyword = gstrtok(wp->decodedQuery, T("&"));
+    while (keyword != NULL) {
+        if ((value = gstrchr(keyword, '=')) != NULL) {
+            *value++ = '\0';
+            websDecodeUrl(keyword, keyword, gstrlen(keyword));
+            websDecodeUrl(value, value, gstrlen(value));
+        } else {
+            value = T("");
+        }
+        if (*keyword) {
             /*
                 If keyword has already been set, append the new value to what has been stored.
              */
-			if ((valCheck = websGetVar(wp, keyword, NULL)) != 0) {
-				fmtAlloc(&valNew, 256, T("%s %s"), valCheck, value);
-				websSetVar(wp, keyword, valNew);
-				bfreeSafe(B_L, valNew);
-			} else {
-				websSetVar(wp, keyword, value);
-			}
-		}
-		keyword = gstrtok(NULL, T("&"));
-	}
+            if ((valCheck = websGetVar(wp, keyword, NULL)) != 0) {
+                fmtAlloc(&valNew, 256, T("%s %s"), valCheck, value);
+                websSetVar(wp, keyword, valNew);
+                bfreeSafe(B_L, valNew);
+            } else {
+                websSetVar(wp, keyword, value);
+            }
+        }
+        keyword = gstrtok(NULL, T("&"));
+    }
 }
 
 
@@ -1131,38 +1131,38 @@ void websSetEnv(webs_t wp)
  */
 void websSetVar(webs_t wp, char_t *var, char_t *value)
 {
-	value_t		 v;
+    value_t      v;
 
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
     /*
-      	value_instring will allocate the string if required.
+        value_instring will allocate the string if required.
      */
-	if (value) {
-		v = valueString(value, VALUE_ALLOCATE);
-	} else {
-		v = valueString(T(""), VALUE_ALLOCATE);
-	}
-	symEnter(wp->cgiVars, var, v, 0);
+    if (value) {
+        v = valueString(value, VALUE_ALLOCATE);
+    } else {
+        v = valueString(T(""), VALUE_ALLOCATE);
+    }
+    symEnter(wp->cgiVars, var, v, 0);
 }
 
 
 /*
- *	Return TRUE if a webs variable exists for this connection.
+ *  Return TRUE if a webs variable exists for this connection.
  */
 int websTestVar(webs_t wp, char_t *var)
 {
-	sym_t		*sp;
+    sym_t       *sp;
 
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
-	if (var == NULL || *var == '\0') {
-		return 0;
-	}
-	if ((sp = symLookup(wp->cgiVars, var)) == NULL) {
-		return 0;
-	}
-	return 1;
+    if (var == NULL || *var == '\0') {
+        return 0;
+    }
+    if ((sp = symLookup(wp->cgiVars, var)) == NULL) {
+        return 0;
+    }
+    return 1;
 }
 
 
@@ -1172,187 +1172,187 @@ int websTestVar(webs_t wp, char_t *var)
  */
 char_t *websGetVar(webs_t wp, char_t *var, char_t *defaultGetValue)
 {
-	sym_t	*sp;
+    sym_t   *sp;
 
-	a_assert(websValid(wp));
-	a_assert(var && *var);
+    a_assert(websValid(wp));
+    a_assert(var && *var);
  
-	if ((sp = symLookup(wp->cgiVars, var)) != NULL) {
-		a_assert(sp->content.type == string);
-		if (sp->content.value.string) {
-			return sp->content.value.string;
-		} else {
-			return T("");
-		}
-	}
-	return defaultGetValue;
+    if ((sp = symLookup(wp->cgiVars, var)) != NULL) {
+        a_assert(sp->content.type == string);
+        if (sp->content.value.string) {
+            return sp->content.value.string;
+        } else {
+            return T("");
+        }
+    }
+    return defaultGetValue;
 }
 
 
 /*
-  	Return TRUE if a webs variable is set to a given value
+    Return TRUE if a webs variable is set to a given value
  */
 int websCompareVar(webs_t wp, char_t *var, char_t *value)
 {
-	a_assert(websValid(wp));
-	a_assert(var && *var);
+    a_assert(websValid(wp));
+    a_assert(var && *var);
  
-	if (gstrcmp(value, websGetVar(wp, var, T(" __UNDEF__ "))) == 0) {
-		return 1;
-	}
-	return 0;
+    if (gstrcmp(value, websGetVar(wp, var, T(" __UNDEF__ "))) == 0) {
+        return 1;
+    }
+    return 0;
 }
 
 
 /*
-  	Cancel the request timeout. Note may be called multiple times.
+    Cancel the request timeout. Note may be called multiple times.
  */
 void websTimeoutCancel(webs_t wp)
 {
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
-	if (wp->timeout >= 0) {
-		emfUnschedCallback(wp->timeout);
-		wp->timeout = -1;
-	}
+    if (wp->timeout >= 0) {
+        emfUnschedCallback(wp->timeout);
+        wp->timeout = -1;
+    }
 }
 
 
 /*
-  	Output a HTTP response back to the browser. If redirect is set to a 
-  	URL, the browser will be sent to this location.
+    Output a HTTP response back to the browser. If redirect is set to a 
+    URL, the browser will be sent to this location.
  */
 void websResponse(webs_t wp, int code, char_t *message, char_t *redirect)
 {
-	char_t		*date;
+    char_t      *date;
 
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
     /*
-      	IE3.0 needs no Keep Alive for some return codes.
+        IE3.0 needs no Keep Alive for some return codes.
         MOB - OPT REMOVE
      */
-	wp->flags &= ~WEBS_KEEP_ALIVE;
+    wp->flags &= ~WEBS_KEEP_ALIVE;
 
     /*
-      	Only output the header if a header has not already been output.
+        Only output the header if a header has not already been output.
      */
-	if ( !(wp->flags & WEBS_HEADER_DONE)) {
-		wp->flags |= WEBS_HEADER_DONE;
+    if ( !(wp->flags & WEBS_HEADER_DONE)) {
+        wp->flags |= WEBS_HEADER_DONE;
         /*
             Redirect behaves much better when sent with HTTP/1.0
          */
-		if (redirect != NULL) {
-			websWrite(wp, T("HTTP/1.0 %d %s\r\n"), code, websErrorMsg(code));
-		} else {
-			websWrite(wp, T("HTTP/1.1 %d %s\r\n"), code, websErrorMsg(code));
-		}
+        if (redirect != NULL) {
+            websWrite(wp, T("HTTP/1.0 %d %s\r\n"), code, websErrorMsg(code));
+        } else {
+            websWrite(wp, T("HTTP/1.1 %d %s\r\n"), code, websErrorMsg(code));
+        }
         /*
             The Server HTTP header below must not be modified unless explicitly allowed by licensing terms.
          */
 #ifdef WEBS_SSL_SUPPORT
-		websWrite(wp, T("Server: %s/%s %s/%s\r\n"), WEBS_NAME, WEBS_VERSION, SSL_NAME, SSL_VERSION);
+        websWrite(wp, T("Server: %s/%s %s/%s\r\n"), WEBS_NAME, WEBS_VERSION, SSL_NAME, SSL_VERSION);
 #else
-		websWrite(wp, T("Server: %s/%s\r\n"), WEBS_NAME, WEBS_VERSION);
+        websWrite(wp, T("Server: %s/%s\r\n"), WEBS_NAME, WEBS_VERSION);
 #endif
-        /*		
+        /*      
             Timestamp/Date is usually the next to go
          */
-		if ((date = websGetDateString(NULL)) != NULL) {
-			websWrite(wp, T("Date: %s\r\n"), date);
-			bfree(B_L, date);
-		}
+        if ((date = websGetDateString(NULL)) != NULL) {
+            websWrite(wp, T("Date: %s\r\n"), date);
+            bfree(B_L, date);
+        }
         /*
             If authentication is required, send the auth header info
          */
-		if (code == 401) {
-			if (!(wp->flags & WEBS_AUTH_DIGEST)) {
-				websWrite(wp, T("WWW-Authenticate: Basic realm=\"%s\"\r\n"), websGetRealm());
+        if (code == 401) {
+            if (!(wp->flags & WEBS_AUTH_DIGEST)) {
+                websWrite(wp, T("WWW-Authenticate: Basic realm=\"%s\"\r\n"), websGetRealm());
 #ifdef DIGEST_ACCESS_SUPPORT
-			} else {
-				char_t *nonce, *opaque;
-
-				nonce = websCalcNonce(wp);
-				opaque = websCalcOpaque(wp); 
-				websWrite(wp, 
-					T("WWW-Authenticate: Digest realm=\"%s\", domain=\"%s\",")
-					T("qop=\"%s\", nonce=\"%s\", opaque=\"%s\",")
-					T("algorithm=\"%s\", stale=\"%s\"\r\n"), 
-					websGetRealm(),
-					websGetHostUrl(),
-					T("auth"),
-					nonce,
-					opaque, T("MD5"), T("FALSE"));
-				bfree(B_L, nonce);
-				bfree(B_L, opaque);
+            } else {
+                char_t *nonce, *opaque;
+
+                nonce = websCalcNonce(wp);
+                opaque = websCalcOpaque(wp); 
+                websWrite(wp, 
+                    T("WWW-Authenticate: Digest realm=\"%s\", domain=\"%s\",")
+                    T("qop=\"%s\", nonce=\"%s\", opaque=\"%s\",")
+                    T("algorithm=\"%s\", stale=\"%s\"\r\n"), 
+                    websGetRealm(),
+                    websGetHostUrl(),
+                    T("auth"),
+                    nonce,
+                    opaque, T("MD5"), T("FALSE"));
+                bfree(B_L, nonce);
+                bfree(B_L, opaque);
 #endif
-			}
-		}
-
-		if (wp->flags & WEBS_KEEP_ALIVE) {
-			websWrite(wp, T("Connection: keep-alive\r\n"));
-		}
-		websWrite(wp, T("Pragma: no-cache\r\nCache-Control: no-cache\r\n"));
-		websWrite(wp, T("Content-Type: text/html\r\n"));
-		if (redirect) {
-			websWrite(wp, T("Location: %s\r\n"), redirect);
-		}
-		websWrite(wp, T("\r\n"));
-	}
+            }
+        }
+
+        if (wp->flags & WEBS_KEEP_ALIVE) {
+            websWrite(wp, T("Connection: keep-alive\r\n"));
+        }
+        websWrite(wp, T("Pragma: no-cache\r\nCache-Control: no-cache\r\n"));
+        websWrite(wp, T("Content-Type: text/html\r\n"));
+        if (redirect) {
+            websWrite(wp, T("Location: %s\r\n"), redirect);
+        }
+        websWrite(wp, T("\r\n"));
+    }
 
     /*
-      	If the browser didn't do a HEAD only request, send the message as well.
+        If the browser didn't do a HEAD only request, send the message as well.
      */
-	if ((wp->flags & WEBS_HEAD_REQUEST) == 0 && message && *message) {
-		websWrite(wp, T("%s\r\n"), message);
-	}
-	websDone(wp, code);
+    if ((wp->flags & WEBS_HEAD_REQUEST) == 0 && message && *message) {
+        websWrite(wp, T("%s\r\n"), message);
+    }
+    websDone(wp, code);
 }
 
 
 /*
-  	Redirect the user to another webs page
+    Redirect the user to another webs page
  */
 void websRedirect(webs_t wp, char_t *url)
 {
-	char_t	*msgbuf, *urlbuf, *redirectFmt;
+    char_t  *msgbuf, *urlbuf, *redirectFmt;
 
-	a_assert(websValid(wp));
-	a_assert(url);
+    a_assert(websValid(wp));
+    a_assert(url);
 
-	websStats.redirects++;
-	msgbuf = urlbuf = NULL;
+    websStats.redirects++;
+    msgbuf = urlbuf = NULL;
 
     /*
-      	Some browsers require a http://host qualified URL for redirection
+        Some browsers require a http://host qualified URL for redirection
      */
-	if (gstrstr(url, T("http://")) == NULL) {
-		if (*url == '/') {
-			url++;
-		}
-		redirectFmt = T("http://%s/%s");
+    if (gstrstr(url, T("http://")) == NULL) {
+        if (*url == '/') {
+            url++;
+        }
+        redirectFmt = T("http://%s/%s");
 
 #ifdef WEBS_SSL_SUPPORT
-		if (wp->flags & WEBS_SECURE) {
-			redirectFmt = T("https://%s/%s");
-		}
+        if (wp->flags & WEBS_SECURE) {
+            redirectFmt = T("https://%s/%s");
+        }
 #endif
-		fmtAlloc(&urlbuf, WEBS_MAX_URL + 80, redirectFmt, websGetVar(wp, T("HTTP_HOST"), 	websHostUrl), url);
-		url = urlbuf;
-	}
+        fmtAlloc(&urlbuf, WEBS_MAX_URL + 80, redirectFmt, websGetVar(wp, T("HTTP_HOST"),    websHostUrl), url);
+        url = urlbuf;
+    }
 
     /*
-      	Add human readable message for completeness. Should not be required.
+        Add human readable message for completeness. Should not be required.
      */
-	fmtAlloc(&msgbuf, WEBS_MAX_URL + 80, 
-		T("<html><head></head><body>\r\n\
-		This document has moved to a new <a href=\"%s\">location</a>.\r\n\
-		Please update your documents to reflect the new location.\r\n\
-		</body></html>\r\n"), url);
+    fmtAlloc(&msgbuf, WEBS_MAX_URL + 80, 
+        T("<html><head></head><body>\r\n\
+        This document has moved to a new <a href=\"%s\">location</a>.\r\n\
+        Please update your documents to reflect the new location.\r\n\
+        </body></html>\r\n"), url);
 
-	websResponse(wp, 302, msgbuf, url);
-	bfreeSafe(B_L, msgbuf);
-	bfreeSafe(B_L, urlbuf);
+    websResponse(wp, 302, msgbuf, url);
+    bfreeSafe(B_L, msgbuf);
+    bfreeSafe(B_L, urlbuf);
 }
 
 
@@ -1437,20 +1437,20 @@ static char_t* websSafeUrl(const char_t* url)
 
 
 
-/*	
-  	Output an error message and cleanup
+/*  
+    Output an error message and cleanup
  */
 void websError(webs_t wp, int code, char_t *fmt, ...)
 {
-	va_list		args;
-	char_t		*msg, *userMsg, *buf;
+    va_list     args;
+    char_t      *msg, *userMsg, *buf;
    char_t*     safeUrl = NULL;
    char_t*     safeMsg = NULL;
 
-	a_assert(websValid(wp));
-	a_assert(fmt);
+    a_assert(websValid(wp));
+    a_assert(fmt);
 
-	websStats.errors++;
+    websStats.errors++;
 
     safeUrl = websSafeUrl(wp->url);
     bfreeSafe(B_L, wp->url);
@@ -1465,31 +1465,31 @@ void websError(webs_t wp, int code, char_t *fmt, ...)
     userMsg = safeMsg;
     safeMsg  = NULL;
 
-	msg = T("<html><head><title>Document Error: %s</title></head>\r\n\
-		<body><h2>Access Error: %s</h2>\r\n\
-		<p>%s</p></body></html>\r\n");
-	buf = NULL;
-	fmtAlloc(&buf, WEBS_BUFSIZE, msg, websErrorMsg(code), websErrorMsg(code), userMsg);
-	websResponse(wp, code, buf, NULL);
-	bfreeSafe(B_L, buf);
-	bfreeSafe(B_L, userMsg);
+    msg = T("<html><head><title>Document Error: %s</title></head>\r\n\
+        <body><h2>Access Error: %s</h2>\r\n\
+        <p>%s</p></body></html>\r\n");
+    buf = NULL;
+    fmtAlloc(&buf, WEBS_BUFSIZE, msg, websErrorMsg(code), websErrorMsg(code), userMsg);
+    websResponse(wp, code, buf, NULL);
+    bfreeSafe(B_L, buf);
+    bfreeSafe(B_L, userMsg);
 }
 
 
 /*
-  	Return the error message for a given code
+    Return the error message for a given code
  */
 char_t *websErrorMsg(int code)
 {
-	websErrorType	*ep;
+    websErrorType   *ep;
 
-	for (ep = websErrors; ep->code; ep++) {
-		if (code == ep->code) {
-			return ep->msg;
-		}
-	}
-	a_assert(0);
-	return T("");
+    for (ep = websErrors; ep->code; ep++) {
+        if (code == ep->code) {
+            return ep->msg;
+        }
+    }
+    a_assert(0);
+    return T("");
 }
 
 
@@ -1498,26 +1498,26 @@ char_t *websErrorMsg(int code)
  */
 int websWrite(webs_t wp, char_t *fmt, ...)
 {
-	va_list		 vargs;
-	char_t		*buf;
-	int			 rc;
-	
-	a_assert(websValid(wp));
+    va_list      vargs;
+    char_t      *buf;
+    int          rc;
+    
+    a_assert(websValid(wp));
 
-	va_start(vargs, fmt);
+    va_start(vargs, fmt);
 
-	buf = NULL;
-	rc = 0;
-	if (fmtValloc(&buf, WEBS_BUFSIZE, fmt, vargs) >= WEBS_BUFSIZE) {
-		trace(0, T("webs: websWrite lost data, buffer overflow\n"));
-	}
-	va_end(vargs);
-	a_assert(buf);
-	if (buf) {
-		rc = websWriteBlock(wp, buf, gstrlen(buf));
-		bfree(B_L, buf);
-	}
-	return rc;
+    buf = NULL;
+    rc = 0;
+    if (fmtValloc(&buf, WEBS_BUFSIZE, fmt, vargs) >= WEBS_BUFSIZE) {
+        trace(0, T("webs: websWrite lost data, buffer overflow\n"));
+    }
+    va_end(vargs);
+    a_assert(buf);
+    if (buf) {
+        rc = websWriteBlock(wp, buf, gstrlen(buf));
+        bfree(B_L, buf);
+    }
+    return rc;
 }
 
 
@@ -1530,50 +1530,50 @@ int websWrite(webs_t wp, char_t *fmt, ...)
  */
 int websWriteBlock(webs_t wp, char_t *buf, int nChars)
 {
-	int		len, done;
-	char	*asciiBuf, *pBuf;
+    int     len, done;
+    char    *asciiBuf, *pBuf;
 
-	a_assert(wp);
-	a_assert(websValid(wp));
-	a_assert(buf);
-	a_assert(nChars >= 0);
+    a_assert(wp);
+    a_assert(websValid(wp));
+    a_assert(buf);
+    a_assert(nChars >= 0);
 
-	done = len = 0;
+    done = len = 0;
 
     /*
-      	ballocUniToAsc will convert Unicode to strings to Ascii.  If Unicode is
-      	not turned on then ballocUniToAsc will not do the conversion.
+        ballocUniToAsc will convert Unicode to strings to Ascii.  If Unicode is
+        not turned on then ballocUniToAsc will not do the conversion.
      */
-	pBuf = asciiBuf = ballocUniToAsc(buf, nChars);
+    pBuf = asciiBuf = ballocUniToAsc(buf, nChars);
 
-	while (nChars > 0) {  
+    while (nChars > 0) {  
 #ifdef WEBS_SSL_SUPPORT
-		if (wp->flags & WEBS_SECURE) {
-			if ((len = websSSLWrite(wp->wsp, pBuf, nChars)) < 0) {
-				bfree(B_L, asciiBuf);
-				return -1;
-			}
-			websSSLFlush(wp->wsp);
-		} else {
-			if ((len = socketWrite(wp->sid, pBuf, nChars)) < 0) {
-				bfree(B_L, asciiBuf);
-				return -1;
-			}
-			socketFlush(wp->sid);
-		}
+        if (wp->flags & WEBS_SECURE) {
+            if ((len = websSSLWrite(wp->wsp, pBuf, nChars)) < 0) {
+                bfree(B_L, asciiBuf);
+                return -1;
+            }
+            websSSLFlush(wp->wsp);
+        } else {
+            if ((len = socketWrite(wp->sid, pBuf, nChars)) < 0) {
+                bfree(B_L, asciiBuf);
+                return -1;
+            }
+            socketFlush(wp->sid);
+        }
 #else /* ! WEBS_SSL_SUPPORT */
-		if ((len = socketWrite(wp->sid, pBuf, nChars)) < 0) {
-			bfree(B_L, asciiBuf);
-			return -1;
-		}
-		socketFlush(wp->sid);
+        if ((len = socketWrite(wp->sid, pBuf, nChars)) < 0) {
+            bfree(B_L, asciiBuf);
+            return -1;
+        }
+        socketFlush(wp->sid);
 #endif /* WEBS_SSL_SUPPORT */
-		nChars -= len;
-		pBuf += len;
-		done += len;
-	}
-	bfree(B_L, asciiBuf);
-	return done;
+        nChars -= len;
+        pBuf += len;
+        done += len;
+    }
+    bfree(B_L, asciiBuf);
+    return done;
 }
 
 
@@ -1585,139 +1585,139 @@ int websWriteBlock(webs_t wp, char_t *buf, int nChars)
  */
 int websWriteDataNonBlock(webs_t wp, char *buf, int nChars)
 {
-	int r;
+    int r;
 
-	a_assert(wp);
-	a_assert(websValid(wp));
-	a_assert(buf);
-	a_assert(nChars >= 0);
+    a_assert(wp);
+    a_assert(websValid(wp));
+    a_assert(buf);
+    a_assert(nChars >= 0);
 
 #ifdef WEBS_SSL_SUPPORT
-	if (wp->flags & WEBS_SECURE) {
-		r = websSSLWrite(wp->wsp, buf, nChars);
-		websSSLFlush(wp->wsp);
-	} else {
-		r = socketWrite(wp->sid, buf, nChars);
-		socketFlush(wp->sid);
-	}
+    if (wp->flags & WEBS_SECURE) {
+        r = websSSLWrite(wp->wsp, buf, nChars);
+        websSSLFlush(wp->wsp);
+    } else {
+        r = socketWrite(wp->sid, buf, nChars);
+        socketFlush(wp->sid);
+    }
 #else
-	r = socketWrite(wp->sid, buf, nChars);
-	socketFlush(wp->sid);
+    r = socketWrite(wp->sid, buf, nChars);
+    socketFlush(wp->sid);
 #endif
-	return r;
+    return r;
 }
 
 
 /*
-  	Decode a URL (or part thereof). Allows insitu decoding.
+    Decode a URL (or part thereof). Allows insitu decoding.
  */
 void websDecodeUrl(char_t *decoded, char_t *token, int len)
 {
-	char_t	*ip,  *op;
-	int		num, i, c;
-	
-	a_assert(decoded);
-	a_assert(token);
-
-	op = decoded;
-	for (ip = token; *ip && len > 0; ip++, op++) {
-		if (*ip == '+') {
-			*op = ' ';
-		} else if (*ip == '%' && gisxdigit(ip[1]) && gisxdigit(ip[2])) {
+    char_t  *ip,  *op;
+    int     num, i, c;
+    
+    a_assert(decoded);
+    a_assert(token);
+
+    op = decoded;
+    for (ip = token; *ip && len > 0; ip++, op++) {
+        if (*ip == '+') {
+            *op = ' ';
+        } else if (*ip == '%' && gisxdigit(ip[1]) && gisxdigit(ip[2])) {
             /*
                 Convert %nn to a single character
              */
-			ip++;
-			for (i = 0, num = 0; i < 2; i++, ip++) {
-				c = tolower(*ip);
-				if (c >= 'a' && c <= 'f') {
-					num = (num * 16) + 10 + c - 'a';
-				} else {
-					num = (num * 16) + c - '0';
-				}
-			}
-			*op = (char_t) num;
-			ip--;
-
-		} else {
-			*op = *ip;
-		}
-		len--;
-	}
-	*op = '\0';
+            ip++;
+            for (i = 0, num = 0; i < 2; i++, ip++) {
+                c = tolower(*ip);
+                if (c >= 'a' && c <= 'f') {
+                    num = (num * 16) + 10 + c - 'a';
+                } else {
+                    num = (num * 16) + c - '0';
+                }
+            }
+            *op = (char_t) num;
+            ip--;
+
+        } else {
+            *op = *ip;
+        }
+        len--;
+    }
+    *op = '\0';
 }
 
 
 #ifdef WEBS_LOG_SUPPORT
 /*
-  	Output a log message in Common Log Format
-  		http://httpd.apache.org/docs/1.3/logs.html#common
-  	If WEBS_SIMPLE_TIME is defined, then only the time() external API is used
-  		and a simple, non-standard log format is used.
-  	If WEBS_LOG_QUERY is defined, then the query string will be printed to
-  		the log, in addition to the URL path.  This can be a security issue
-  		if the query string contains sensitive information that shouldn't
-  		be hanging around in log files.
-  	TODO - the number of bytes written is always 0 for goform, asp and cgi
+    Output a log message in Common Log Format
+        http://httpd.apache.org/docs/1.3/logs.html#common
+    If WEBS_SIMPLE_TIME is defined, then only the time() external API is used
+        and a simple, non-standard log format is used.
+    If WEBS_LOG_QUERY is defined, then the query string will be printed to
+        the log, in addition to the URL path.  This can be a security issue
+        if the query string contains sensitive information that shouldn't
+        be hanging around in log files.
+    TODO - the number of bytes written is always 0 for goform, asp and cgi
  */
 static void websLog(webs_t wp, int code)
 {
-	char_t	*buf;
-	char	*abuf;
-	int		len;
+    char_t  *buf;
+    char    *abuf;
+    int     len;
 #ifndef WEBS_SIMPLE_TIME
-	time_t timer;
-	struct tm localt;
+    time_t timer;
+    struct tm localt;
 #ifdef WIN
-	DWORD	dwRet;
-	TIME_ZONE_INFORMATION	tzi;
+    DWORD   dwRet;
+    TIME_ZONE_INFORMATION   tzi;
 #endif /* WIN */
-	char_t timeStr[28];
-	char_t zoneStr[6];
-	char_t dataStr[16];
+    char_t timeStr[28];
+    char_t zoneStr[6];
+    char_t dataStr[16];
 #endif
-	a_assert(websValid(wp));
-	buf = NULL;
+    a_assert(websValid(wp));
+    buf = NULL;
 #ifndef WEBS_SIMPLE_TIME
-	time(&timer);
-	localtime_r(&timer, &localt);
-	strftime(timeStr, sizeof(timeStr), "%d/%b/%Y:%H:%M:%S", &localt); 
-	timeStr[sizeof(timeStr) - 1] = '\0';
+    time(&timer);
+    localtime_r(&timer, &localt);
+    strftime(timeStr, sizeof(timeStr), "%d/%b/%Y:%H:%M:%S", &localt); 
+    timeStr[sizeof(timeStr) - 1] = '\0';
 #ifdef WIN
-	dwRet = GetTimeZoneInformation(&tzi);
-	snprintf(zoneStr, sizeof(zoneStr), "%+03d00", -(int)(tzi.Bias/60));
+    dwRet = GetTimeZoneInformation(&tzi);
+    snprintf(zoneStr, sizeof(zoneStr), "%+03d00", -(int)(tzi.Bias/60));
 #else
-	snprintf(zoneStr, sizeof(zoneStr), "%+03d00", (int)(localt.tm_gmtoff/3600));
+    snprintf(zoneStr, sizeof(zoneStr), "%+03d00", (int)(localt.tm_gmtoff/3600));
 #endif /* WIN */
-	zoneStr[sizeof(zoneStr) - 1] = '\0';
-	if (wp->written != 0) {
-		snprintf(dataStr, sizeof(dataStr), "%d", wp->written);
-		dataStr[sizeof(dataStr) - 1] = '\0';
-	} else {
-		dataStr[0] = '-'; dataStr[1] = '\0';
-	}
-	fmtAlloc(&buf, WEBS_MAX_URL + 80, 
-		T("%s - %s [%s %s] \"%s %s %s\" %d %s\n"), 
-		wp->ipaddr,
-		wp->userName == NULL ? "-" : wp->userName,
-		timeStr, zoneStr,
-		wp->flags & WEBS_POST_REQUEST ? "POST" : 
-			(wp->flags & WEBS_HEAD_REQUEST ? "HEAD" : "GET"),
+    zoneStr[sizeof(zoneStr) - 1] = '\0';
+    if (wp->written != 0) {
+        snprintf(dataStr, sizeof(dataStr), "%d", wp->written);
+        dataStr[sizeof(dataStr) - 1] = '\0';
+    } else {
+        dataStr[0] = '-'; dataStr[1] = '\0';
+    }
+    fmtAlloc(&buf, WEBS_MAX_URL + 80, 
+        T("%s - %s [%s %s] \"%s %s %s\" %d %s\n"), 
+        wp->ipaddr,
+        wp->userName == NULL ? "-" : wp->userName,
+        timeStr, zoneStr,
+        wp->flags & WEBS_POST_REQUEST ? "POST" : 
+            (wp->flags & WEBS_HEAD_REQUEST ? "HEAD" : "GET"),
 #ifdef WEBS_LOG_QUERY
-		wp->url, /* SECURITY - Printing the query can 'leak' private data */
+        wp->url, /* SECURITY - Printing the query can 'leak' private data */
 #else
-		wp->path,
+        wp->path,
 #endif /* WEBS_LOG_QUERY */
-		wp->protoVersion, code, dataStr);
+        wp->protoVersion, code, dataStr);
 #else
-	fmtAlloc(&buf, WEBS_MAX_URL + 80, T("%d %s %d %d\n"), time(0), 
-		wp->url, code, wp->written);
+    fmtAlloc(&buf, WEBS_MAX_URL + 80, T("%d %s %d %d\n"), time(0), 
+        wp->url, code, wp->written);
 #endif
-	len = gstrlen(buf);
-	abuf = ballocUniToAsc(buf, len+1);
-	write(websLogFd, abuf, len);
-	bfreeSafe(B_L, buf);
-	bfreeSafe(B_L, abuf);
+    len = gstrlen(buf);
+    abuf = ballocUniToAsc(buf, len+1);
+    write(websLogFd, abuf, len);
+    bfreeSafe(B_L, buf);
+    bfreeSafe(B_L, abuf);
 }
 #endif /* WEBS_LOG_SUPPORT */
 
@@ -1726,15 +1726,15 @@ static void websLog(webs_t wp, int code)
 #ifdef WEBS_TRACE_SUPPORT
 static void traceHandler(int level, char_t *buf)
 {
-	int		len;
-	char	*abuf;
+    int     len;
+    char    *abuf;
 
-	if (level <= WEBS_TRACE_LEVEL) {	
-		len = gstrlen(buf);
-		abuf = ballocUniToAsc(buf, len+1);
-		write(websTraceFd, abuf, len);
-		bfreeSafe(B_L, abuf);
-	}
+    if (level <= WEBS_TRACE_LEVEL) {    
+        len = gstrlen(buf);
+        abuf = ballocUniToAsc(buf, len+1);
+        write(websTraceFd, abuf, len);
+        bfreeSafe(B_L, abuf);
+    }
 }
 
 #endif /* WEBS_TRACE_SUPPORT */
@@ -1745,26 +1745,26 @@ static void traceHandler(int level, char_t *buf)
  */
 void websTimeout(void *arg, int id)
 {
-	webs_t		wp;
-	int			delay, tm;
+    webs_t      wp;
+    int         delay, tm;
 
-	wp = (webs_t) arg;
-	a_assert(websValid(wp));
+    wp = (webs_t) arg;
+    a_assert(websValid(wp));
 
-	tm = websGetTimeSinceMark(wp) * 1000;
-	if (tm >= WEBS_TIMEOUT) {
-		websStats.timeouts++;
-		emfUnschedCallback(id);
+    tm = websGetTimeSinceMark(wp) * 1000;
+    if (tm >= WEBS_TIMEOUT) {
+        websStats.timeouts++;
+        emfUnschedCallback(id);
         /*
             Clear the timeout id
          */
-		wp->timeout = -1;
-		websDone(wp, 404);
-	} else {
-		delay = WEBS_TIMEOUT - tm;
-		a_assert(delay > 0);
-		emfReschedCallback(id, delay);
-	}
+        wp->timeout = -1;
+        websDone(wp, 404);
+    } else {
+        delay = WEBS_TIMEOUT - tm;
+        a_assert(delay > 0);
+        emfReschedCallback(id, delay);
+    }
 }
 
 
@@ -1773,426 +1773,426 @@ void websTimeout(void *arg, int id)
  */
 void websDone(webs_t wp, int code)
 {
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
     /*
-       	Disable socket handler in case keep alive set.
+        Disable socket handler in case keep alive set.
      */
-	socketDeleteHandler(wp->sid);
+    socketDeleteHandler(wp->sid);
 
-	if (code != 200) {
-		wp->flags &= ~WEBS_KEEP_ALIVE;
-	}
+    if (code != 200) {
+        wp->flags &= ~WEBS_KEEP_ALIVE;
+    }
 #ifdef WEBS_PROXY_SUPPORT
-	if (! (wp->flags & WEBS_LOCAL_PAGE)) {
-		websStats.activeNetRequests--;
-	}
+    if (! (wp->flags & WEBS_LOCAL_PAGE)) {
+        websStats.activeNetRequests--;
+    }
 #endif
 
 #ifdef WEBS_LOG_SUPPORT
-	if (! (wp->flags & WEBS_REQUEST_DONE)) {
-		websLog(wp, code);
-	}
+    if (! (wp->flags & WEBS_REQUEST_DONE)) {
+        websLog(wp, code);
+    }
 #endif
 
     /*
-      	Close any opened document by a handler
+        Close any opened document by a handler
      */
-	websPageClose(wp);
+    websPageClose(wp);
 
     /*
-      	Exit if secure
+        Exit if secure
      */
 #ifdef WEBS_SSL_SUPPORT
-	if (wp->flags & WEBS_SECURE) {
-		websTimeoutCancel(wp);
-		websSSLFlush(wp->wsp);
-		socketCloseConnection(wp->sid);
-		websFree(wp);
-		return;
-	}
+    if (wp->flags & WEBS_SECURE) {
+        websTimeoutCancel(wp);
+        websSSLFlush(wp->wsp);
+        socketCloseConnection(wp->sid);
+        websFree(wp);
+        return;
+    }
 #endif
 
     /*
         If using Keep Alive (HTTP/1.1) we keep the socket open for a period while waiting for another request on the socket. 
      */
-	if (wp->flags & WEBS_KEEP_ALIVE) {
-		if (socketFlush(wp->sid) == 0) {
-			wp->state = WEBS_BEGIN;
-			wp->flags |= WEBS_REQUEST_DONE;
-			if (wp->header.buf) {
-				ringqFlush(&wp->header);
-			}
-			socketCreateHandler(wp->sid, SOCKET_READABLE, websSocketEvent, 
-				wp);
-			websTimeoutCancel(wp);
-			wp->timeout = emfSchedCallback(WEBS_TIMEOUT, websTimeout,
-				(void *) wp);
-			return;
-		}
-	} else {
-		websTimeoutCancel(wp);
-		socketSetBlock(wp->sid, 1);
-		socketFlush(wp->sid);
-		socketCloseConnection(wp->sid);
-	}
-	websFree(wp);
+    if (wp->flags & WEBS_KEEP_ALIVE) {
+        if (socketFlush(wp->sid) == 0) {
+            wp->state = WEBS_BEGIN;
+            wp->flags |= WEBS_REQUEST_DONE;
+            if (wp->header.buf) {
+                ringqFlush(&wp->header);
+            }
+            socketCreateHandler(wp->sid, SOCKET_READABLE, websSocketEvent, 
+                wp);
+            websTimeoutCancel(wp);
+            wp->timeout = emfSchedCallback(WEBS_TIMEOUT, websTimeout,
+                (void *) wp);
+            return;
+        }
+    } else {
+        websTimeoutCancel(wp);
+        socketSetBlock(wp->sid, 1);
+        socketFlush(wp->sid);
+        socketCloseConnection(wp->sid);
+    }
+    websFree(wp);
 }
 
 
 int websAlloc(int sid)
 {
-	webs_t		wp;
-	int			wid;
-
-	if ((wid = hAllocEntry((void***) &webs, &websMax, sizeof(struct websRec))) < 0) {
-		return -1;
-	}
-	wp = webs[wid];
-	wp->wid = wid;
-	wp->sid = sid;
-	wp->state = WEBS_BEGIN;
-	wp->docfd = -1;
-	wp->timeout = -1;
-	wp->dir = NULL;
-	wp->authType = NULL;
-	wp->protocol = NULL;
-	wp->protoVersion = NULL;
-	wp->password = NULL;
-	wp->userName = NULL;
+    webs_t      wp;
+    int         wid;
+
+    if ((wid = hAllocEntry((void***) &webs, &websMax, sizeof(struct websRec))) < 0) {
+        return -1;
+    }
+    wp = webs[wid];
+    wp->wid = wid;
+    wp->sid = sid;
+    wp->state = WEBS_BEGIN;
+    wp->docfd = -1;
+    wp->timeout = -1;
+    wp->dir = NULL;
+    wp->authType = NULL;
+    wp->protocol = NULL;
+    wp->protoVersion = NULL;
+    wp->password = NULL;
+    wp->userName = NULL;
 #ifdef DIGEST_ACCESS_SUPPORT
-	wp->realm = NULL;
-	wp->nonce = NULL;
-	wp->digest = NULL;
-	wp->uri = NULL;
-	wp->opaque = NULL;
-	wp->nc = NULL;
-	wp->cnonce = NULL;
-	wp->qop = NULL;
+    wp->realm = NULL;
+    wp->nonce = NULL;
+    wp->digest = NULL;
+    wp->uri = NULL;
+    wp->opaque = NULL;
+    wp->nc = NULL;
+    wp->cnonce = NULL;
+    wp->qop = NULL;
 #endif
 #ifdef WEBS_SSL_SUPPORT
-	wp->wsp = NULL;
+    wp->wsp = NULL;
 #endif
 
-	ringqOpen(&wp->header, WEBS_HEADER_BUFINC, WEBS_MAX_HEADER);
+    ringqOpen(&wp->header, WEBS_HEADER_BUFINC, WEBS_MAX_HEADER);
 
     /*
         Create storage for the CGI variables. We supply the symbol tables for both the CGI variables and for the global
         functions. The function table is common to all webs instances (ie. all browsers)
      */
-	wp->cgiVars = symOpen(WEBS_SYM_INIT);
+    wp->cgiVars = symOpen(WEBS_SYM_INIT);
 
-	return wid;
+    return wid;
 }
 
 
 void websFree(webs_t wp)
 {
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
     //  MOB _ better if bfree permits a null
-	if (wp->path)
-		bfree(B_L, wp->path);
-	if (wp->url)
-		bfree(B_L, wp->url);
-	if (wp->host)
-		bfree(B_L, wp->host);
-	if (wp->lpath)
-		bfree(B_L, wp->lpath);
-	if (wp->query)
-		bfree(B_L, wp->query);
-	if (wp->decodedQuery)
-		bfree(B_L, wp->decodedQuery);
-	if (wp->authType)
-		bfree(B_L, wp->authType);
-	if (wp->password)
-		bfree(B_L, wp->password);
-	if (wp->userName)
-		bfree(B_L, wp->userName);
-	if (wp->cookie)
-		bfree(B_L, wp->cookie);
-	if (wp->userAgent)
-		bfree(B_L, wp->userAgent);
-	if (wp->dir)
-		bfree(B_L, wp->dir);
-	if (wp->protocol)
-		bfree(B_L, wp->protocol);
-	if (wp->protoVersion)
-		bfree(B_L, wp->protoVersion);
-	if (wp->cgiStdin)
-		bfree(B_L, wp->cgiStdin);
+    if (wp->path)
+        bfree(B_L, wp->path);
+    if (wp->url)
+        bfree(B_L, wp->url);
+    if (wp->host)
+        bfree(B_L, wp->host);
+    if (wp->lpath)
+        bfree(B_L, wp->lpath);
+    if (wp->query)
+        bfree(B_L, wp->query);
+    if (wp->decodedQuery)
+        bfree(B_L, wp->decodedQuery);
+    if (wp->authType)
+        bfree(B_L, wp->authType);
+    if (wp->password)
+        bfree(B_L, wp->password);
+    if (wp->userName)
+        bfree(B_L, wp->userName);
+    if (wp->cookie)
+        bfree(B_L, wp->cookie);
+    if (wp->userAgent)
+        bfree(B_L, wp->userAgent);
+    if (wp->dir)
+        bfree(B_L, wp->dir);
+    if (wp->protocol)
+        bfree(B_L, wp->protocol);
+    if (wp->protoVersion)
+        bfree(B_L, wp->protoVersion);
+    if (wp->cgiStdin)
+        bfree(B_L, wp->cgiStdin);
 
 #ifdef DIGEST_ACCESS_SUPPORT
-	if (wp->realm)
-		bfree(B_L, wp->realm);
-	if (wp->uri)
-		bfree(B_L, wp->uri);
-	if (wp->digest)
-		bfree(B_L, wp->digest);
-	if (wp->opaque)
-		bfree(B_L, wp->opaque);
-	if (wp->nonce)
-		bfree(B_L, wp->nonce);
-	if (wp->nc)
-		bfree(B_L, wp->nc);
-	if (wp->cnonce)
-		bfree(B_L, wp->cnonce);
-	if (wp->qop)
-		bfree(B_L, wp->qop);
+    if (wp->realm)
+        bfree(B_L, wp->realm);
+    if (wp->uri)
+        bfree(B_L, wp->uri);
+    if (wp->digest)
+        bfree(B_L, wp->digest);
+    if (wp->opaque)
+        bfree(B_L, wp->opaque);
+    if (wp->nonce)
+        bfree(B_L, wp->nonce);
+    if (wp->nc)
+        bfree(B_L, wp->nc);
+    if (wp->cnonce)
+        bfree(B_L, wp->cnonce);
+    if (wp->qop)
+        bfree(B_L, wp->qop);
 #endif
 #ifdef WEBS_SSL_SUPPORT
-	websSSLFree(wp->wsp);
+    websSSLFree(wp->wsp);
 #endif
-	symClose(wp->cgiVars);
+    symClose(wp->cgiVars);
 
-	if (wp->header.buf) {
-		ringqClose(&wp->header);
-	}
+    if (wp->header.buf) {
+        ringqClose(&wp->header);
+    }
 
-	websMax = hFree((void***) &webs, wp->wid);
-	bfree(B_L, wp);
-	a_assert(websMax >= 0);
+    websMax = hFree((void***) &webs, wp->wid);
+    bfree(B_L, wp);
+    a_assert(websMax >= 0);
 }
 
 
 char_t *websGetHost()
 {
-	return websHost;
+    return websHost;
 }
 
 
 char_t *websGetIpaddrUrl()
 {
-	return websIpaddrUrl;
+    return websIpaddrUrl;
 }
 
 
 char_t *websGetHostUrl()
 {
-	return websHostUrl;
+    return websHostUrl;
 }
 
 
 int websGetPort()
 {
-	return websPort;
+    return websPort;
 }
 
 
 int websGetRequestBytes(webs_t wp)
 {
-	a_assert(websValid(wp));
-	return wp->numbytes;
+    a_assert(websValid(wp));
+    return wp->numbytes;
 }
 
 
 char_t *websGetRequestDir(webs_t wp)
 {
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
-	if (wp->dir == NULL) {
-		return T("");
-	}
-	return wp->dir;
+    if (wp->dir == NULL) {
+        return T("");
+    }
+    return wp->dir;
 }
 
 
 int websGetRequestFlags(webs_t wp)
 {
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
-	return wp->flags;
+    return wp->flags;
 }
 
 
 char_t *websGetRequestIpaddr(webs_t wp)
 {
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
-	return wp->ipaddr;
+    return wp->ipaddr;
 }
 
 
 char_t *websGetRequestLpath(webs_t wp)
 {
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
     //  MOB - unify
 #ifdef WEBS_PAGE_ROM
-	return wp->path;
+    return wp->path;
 #else
-	return wp->lpath;
+    return wp->lpath;
 #endif
 }
 
 
 char_t *websGetRequestPath(webs_t wp)
 {
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
-	if (wp->path == NULL) {
-		return T("");
-	}
-	return wp->path;
+    if (wp->path == NULL) {
+        return T("");
+    }
+    return wp->path;
 }
 
 
 char_t *websGetRequestPassword(webs_t wp)
 {
-	a_assert(websValid(wp));
-	return wp->password;
+    a_assert(websValid(wp));
+    return wp->password;
 }
 
 
 char_t *websGetRequestType(webs_t wp)
 {
-	a_assert(websValid(wp));
-	return wp->type;
+    a_assert(websValid(wp));
+    return wp->type;
 }
 
 
 char_t *websGetRequestUserName(webs_t wp)
 {
-	a_assert(websValid(wp));
-	return wp->userName;
+    a_assert(websValid(wp));
+    return wp->userName;
 }
 
 
 int websGetRequestWritten(webs_t wp)
 {
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
-	return wp->written;
+    return wp->written;
 }
 
 
 void websSetHost(char_t *host)
 {
-	gstrncpy(websHost, host, TSZ(websHost));
+    gstrncpy(websHost, host, TSZ(websHost));
 }
 
 
 void websSetHostUrl(char_t *url)
 {
-	a_assert(url && *url);
+    a_assert(url && *url);
 
-	bfreeSafe(B_L, websHostUrl);
-	websHostUrl = gstrdup(B_L, url);
+    bfreeSafe(B_L, websHostUrl);
+    websHostUrl = gstrdup(B_L, url);
 }
 
 
 void websSetIpaddr(char_t *ipaddr)
 {
-	a_assert(ipaddr && *ipaddr);
-	gstrncpy(websIpaddr, ipaddr, TSZ(websIpaddr));
+    a_assert(ipaddr && *ipaddr);
+    gstrncpy(websIpaddr, ipaddr, TSZ(websIpaddr));
 }
 
 
 void websSetRequestBytes(webs_t wp, int bytes)
 {
-	a_assert(websValid(wp));
-	a_assert(bytes >= 0);
-	wp->numbytes = bytes;
+    a_assert(websValid(wp));
+    a_assert(bytes >= 0);
+    wp->numbytes = bytes;
 }
 
 
 void websSetRequestFlags(webs_t wp, int flags)
 {
-	a_assert(websValid(wp));
-	wp->flags = flags;
+    a_assert(websValid(wp));
+    wp->flags = flags;
 }
 
 
 void websSetRequestLpath(webs_t wp, char_t *lpath)
 {
-	a_assert(websValid(wp));
-	a_assert(lpath && *lpath);
+    a_assert(websValid(wp));
+    a_assert(lpath && *lpath);
 
-	if (wp->lpath) {
-		bfree(B_L, wp->lpath);
-	}
-	wp->lpath = bstrdup(B_L, lpath);
-	websSetVar(wp, T("PATH_TRANSLATED"), wp->lpath);
+    if (wp->lpath) {
+        bfree(B_L, wp->lpath);
+    }
+    wp->lpath = bstrdup(B_L, lpath);
+    websSetVar(wp, T("PATH_TRANSLATED"), wp->lpath);
 }
 
 
 /*
-  	Update the URL path and the directory containing the web page
+    Update the URL path and the directory containing the web page
  */
 void websSetRequestPath(webs_t wp, char_t *dir, char_t *path)
 {
-	char_t	*tmp;
+    char_t  *tmp;
 
-	a_assert(websValid(wp));
+    a_assert(websValid(wp));
 
-	if (dir) { 
-		tmp = wp->dir;
-		wp->dir = bstrdup(B_L, dir);
-		if (tmp) {
-			bfree(B_L, tmp);
-		}
-	}
-	if (path) {
-		tmp = wp->path;
-		wp->path = bstrdup(B_L, path);
-		websSetVar(wp, T("PATH_INFO"), wp->path);
-		if (tmp) {
-			bfree(B_L, tmp);
-		}
-	}
+    if (dir) { 
+        tmp = wp->dir;
+        wp->dir = bstrdup(B_L, dir);
+        if (tmp) {
+            bfree(B_L, tmp);
+        }
+    }
+    if (path) {
+        tmp = wp->path;
+        wp->path = bstrdup(B_L, path);
+        websSetVar(wp, T("PATH_INFO"), wp->path);
+        if (tmp) {
+            bfree(B_L, tmp);
+        }
+    }
 }
 
 
 /*
-  	Set the Write handler for this socket
+    Set the Write handler for this socket
  */
 void websSetRequestSocketHandler(webs_t wp, int mask, void (*fn)(webs_t wp))
 {
-	a_assert(websValid(wp));
-	wp->writeSocket = fn;
-	socketCreateHandler(wp->sid, SOCKET_WRITABLE, websSocketEvent, wp);
+    a_assert(websValid(wp));
+    wp->writeSocket = fn;
+    socketCreateHandler(wp->sid, SOCKET_WRITABLE, websSocketEvent, wp);
 }
 
 
 void websSetRequestWritten(webs_t wp, int written)
 {
-	a_assert(websValid(wp));
-	wp->written = written;
+    a_assert(websValid(wp));
+    wp->written = written;
 }
 
 
 int websValid(webs_t wp)
 {
-	int		wid;
+    int     wid;
 
-	for (wid = 0; wid < websMax; wid++) {
-		if (wp == webs[wid]) {
-			return 1;
-		}
-	}
-	return 0;
+    for (wid = 0; wid < websMax; wid++) {
+        if (wp == webs[wid]) {
+            return 1;
+        }
+    }
+    return 0;
 }
 
 
 /*
-  	Build an ASCII time string.  If sbuf is NULL we use the current time, else we use the last modified time of sbuf;
+    Build an ASCII time string.  If sbuf is NULL we use the current time, else we use the last modified time of sbuf;
  */
 char_t *websGetDateString(websStatType *sbuf)
 {
-	char_t*	cp, *r;
-	time_t	now;
+    char_t* cp, *r;
+    time_t  now;
 
-	if (sbuf == NULL) {
-		time(&now);
-	} else {
-		now = sbuf->mtime;
-	}
-	if ((cp = gctime(&now)) != NULL) {
-		cp[gstrlen(cp) - 1] = '\0';
-		r = bstrdup(B_L, cp);
-		return r;
-	}
-	return NULL;
+    if (sbuf == NULL) {
+        time(&now);
+    } else {
+        now = sbuf->mtime;
+    }
+    if ((cp = gctime(&now)) != NULL) {
+        cp[gstrlen(cp) - 1] = '\0';
+        r = bstrdup(B_L, cp);
+        return r;
+    }
+    return NULL;
 }
 
 
@@ -2202,181 +2202,181 @@ char_t *websGetDateString(websStatType *sbuf)
  */
 void websSetTimeMark(webs_t wp)
 {
-	wp->timestamp = time(0);
+    wp->timestamp = time(0);
 }
 
 
 /*
-  	Get the number of seconds since the last mark.
+    Get the number of seconds since the last mark.
  */
 static int websGetTimeSinceMark(webs_t wp)
 {
-	return time(0) - wp->timestamp;
+    return time(0) - wp->timestamp;
 }
 
 
 /*
-  	Store the new realm name
+    Store the new realm name
  */
 void websSetRealm(char_t *realmName)
 {
-	a_assert(realmName);
+    a_assert(realmName);
 
-	gstrncpy(websRealm, realmName, TSZ(websRealm));
+    gstrncpy(websRealm, realmName, TSZ(websRealm));
 }
 
 
 /*
-  	Return the realm name (used for authorization)
+    Return the realm name (used for authorization)
  */
 char_t *websGetRealm()
 {
-	return websRealm;
+    return websRealm;
 }
 
 
 #ifdef WEBS_IF_MODIFIED_SUPPORT
 //  MOB - move all into a date.c
-/*	
-  	These functions are intended to closely mirror the syntax for HTTP-date 
-  	from RFC 2616 (HTTP/1.1 spec).  This code was submitted by Pete Bergstrom.
-  	
-  	RFC1123Date	= wkday "," SP date1 SP time SP "GMT"
-  	RFC850Date	= weekday "," SP date2 SP time SP "GMT"
-  	ASCTimeDate	= wkday SP date3 SP time SP 4DIGIT
+/*  
+    These functions are intended to closely mirror the syntax for HTTP-date 
+    from RFC 2616 (HTTP/1.1 spec).  This code was submitted by Pete Bergstrom.
+    
+    RFC1123Date = wkday "," SP date1 SP time SP "GMT"
+    RFC850Date  = weekday "," SP date2 SP time SP "GMT"
+    ASCTimeDate = wkday SP date3 SP time SP 4DIGIT
   
-  	Each of these functions tries to parse the value and update the index to 
-  	the point it leaves off parsing.
+    Each of these functions tries to parse the value and update the index to 
+    the point it leaves off parsing.
  */
 
 typedef enum { JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC } MonthEnumeration;
 typedef enum { SUN, MON, TUE, WED, THU, FRI, SAT } WeekdayEnumeration;
 
-/*	
-  	Parse an N-digit value
+/*  
+    Parse an N-digit value
  */
 
 static int parseNDIGIT(char_t *buf, int digits, int *index) 
 {
-	int tmpIndex, returnValue;
+    int tmpIndex, returnValue;
 
-	returnValue = 0;
-	for (tmpIndex = *index; tmpIndex < *index+digits; tmpIndex++) {
-		if (gisdigit(buf[tmpIndex])) {
-			returnValue = returnValue * 10 + (buf[tmpIndex] - T('0'));
-		}
-	}
-	*index = tmpIndex;
-	return returnValue;
+    returnValue = 0;
+    for (tmpIndex = *index; tmpIndex < *index+digits; tmpIndex++) {
+        if (gisdigit(buf[tmpIndex])) {
+            returnValue = returnValue * 10 + (buf[tmpIndex] - T('0'));
+        }
+    }
+    *index = tmpIndex;
+    return returnValue;
 }
 
 
 /*
-  	Return an index into the month array
+    Return an index into the month array
  */
 
 static int parseMonth(char_t *buf, int *index) 
 {
-    /*	
-      	"Jan" | "Feb" | "Mar" | "Apr" | "May" | "Jun" | 
-      	"Jul" | "Aug" | "Sep" | "Oct" | "Nov" | "Dec"
+    /*  
+        "Jan" | "Feb" | "Mar" | "Apr" | "May" | "Jun" | 
+        "Jul" | "Aug" | "Sep" | "Oct" | "Nov" | "Dec"
      */
-	int tmpIndex, returnValue;
-	returnValue = -1;
-	tmpIndex = *index;
-
-	switch (buf[tmpIndex]) {
-		case 'A':
-			switch (buf[tmpIndex+1]) {
-				case 'p':
-					returnValue = APR;
-					break;
-				case 'u':
-					returnValue = AUG;
-					break;
-			}
-			break;
-		case 'D':
-			returnValue = DEC;
-			break;
-		case 'F':
-			returnValue = FEB;
-			break;
-		case 'J':
-			switch (buf[tmpIndex+1]) {
-				case 'a':
-					returnValue = JAN;
-					break;
-				case 'u':
-					switch (buf[tmpIndex+2]) {
-						case 'l':
-							returnValue = JUL;
-							break;
-						case 'n':
-							returnValue = JUN;
-							break;
-					}
-					break;
-			}
-			break;
-		case 'M':
-			switch (buf[tmpIndex+1]) {
-				case 'a':
-					switch (buf[tmpIndex+2]) {
-						case 'r':
-							returnValue = MAR;
-							break;
-						case 'y':
-							returnValue = MAY;
-							break;
-					}
-					break;
-			}
-			break;
-		case 'N':
-			returnValue = NOV;
-			break;
-		case 'O':
-			returnValue = OCT;
-			break;
-		case 'S':
-			returnValue = SEP;
-			break;
-	}
-	if (returnValue >= 0) {
-		*index += 3;
-	}
-	return returnValue;
+    int tmpIndex, returnValue;
+    returnValue = -1;
+    tmpIndex = *index;
+
+    switch (buf[tmpIndex]) {
+        case 'A':
+            switch (buf[tmpIndex+1]) {
+                case 'p':
+                    returnValue = APR;
+                    break;
+                case 'u':
+                    returnValue = AUG;
+                    break;
+            }
+            break;
+        case 'D':
+            returnValue = DEC;
+            break;
+        case 'F':
+            returnValue = FEB;
+            break;
+        case 'J':
+            switch (buf[tmpIndex+1]) {
+                case 'a':
+                    returnValue = JAN;
+                    break;
+                case 'u':
+                    switch (buf[tmpIndex+2]) {
+                        case 'l':
+                            returnValue = JUL;
+                            break;
+                        case 'n':
+                            returnValue = JUN;
+                            break;
+                    }
+                    break;
+            }
+            break;
+        case 'M':
+            switch (buf[tmpIndex+1]) {
+                case 'a':
+                    switch (buf[tmpIndex+2]) {
+                        case 'r':
+                            returnValue = MAR;
+                            break;
+                        case 'y':
+                            returnValue = MAY;
+                            break;
+                    }
+                    break;
+            }
+            break;
+        case 'N':
+            returnValue = NOV;
+            break;
+        case 'O':
+            returnValue = OCT;
+            break;
+        case 'S':
+            returnValue = SEP;
+            break;
+    }
+    if (returnValue >= 0) {
+        *index += 3;
+    }
+    return returnValue;
 }
 
 
 /* 
-  	Parse a year value (either 2 or 4 digits)
+    Parse a year value (either 2 or 4 digits)
  */
 static int parseYear(char_t *buf, int *index) 
 {
-	int tmpIndex, returnValue;
+    int tmpIndex, returnValue;
 
-	tmpIndex = *index;
-	returnValue = parseNDIGIT(buf, 4, &tmpIndex);
+    tmpIndex = *index;
+    returnValue = parseNDIGIT(buf, 4, &tmpIndex);
 
-	if (returnValue >= 0) {
-		*index = tmpIndex;
-	} else {
-		returnValue = parseNDIGIT(buf, 2, &tmpIndex);
-		if (returnValue >= 0) {
+    if (returnValue >= 0) {
+        *index = tmpIndex;
+    } else {
+        returnValue = parseNDIGIT(buf, 2, &tmpIndex);
+        if (returnValue >= 0) {
             /*
                 Assume that any year earlier than the start of the epoch for time_t (1970) specifies 20xx
              */
-			if (returnValue < 70) {
-				returnValue += 2000;
-			} else {
-				returnValue += 1900;
-			}
-			*index = tmpIndex;
-		}
-	}
-	return returnValue;
+            if (returnValue < 70) {
+                returnValue += 2000;
+            } else {
+                returnValue += 1900;
+            }
+            *index = tmpIndex;
+        }
+    }
+    return returnValue;
 }
 
 
@@ -2397,17 +2397,17 @@ const int GregorianEpoch = 1;
  */
 int GregorianLeapYearP(long year) 
 {
-	int		result;
-	long	tmp;
-	
-	tmp = year % 400;
+    int     result;
+    long    tmp;
+    
+    tmp = year % 400;
 
-	if ((year % 4 == 0) && (tmp != 100) && (tmp != 200) && (tmp != 300)) {
-		result = TRUE;
-	} else {
-		result = FALSE;
-	}
-	return result;
+    if ((year % 4 == 0) && (tmp != 100) && (tmp != 200) && (tmp != 300)) {
+        result = TRUE;
+    } else {
+        result = FALSE;
+    }
+    return result;
 }
 
 
@@ -2416,23 +2416,23 @@ int GregorianLeapYearP(long year)
  */
 long FixedFromGregorian(long month, long day, long year) 
 {
-	long fixedDate;
+    long fixedDate;
 
-	fixedDate = (long)(GregorianEpoch - 1 + 365 * (year - 1) + 
-		floor((year - 1) / 4.0) -
-		floor((double)(year - 1) / 100.0) + 
-		floor((double)(year - 1) / 400.0) + 
-		floor((367.0 * ((double)month) - 362.0) / 12.0));
+    fixedDate = (long)(GregorianEpoch - 1 + 365 * (year - 1) + 
+        floor((year - 1) / 4.0) -
+        floor((double)(year - 1) / 100.0) + 
+        floor((double)(year - 1) / 400.0) + 
+        floor((367.0 * ((double)month) - 362.0) / 12.0));
 
-	if (month <= 2) {
-		fixedDate += 0;
-	} else if (TRUE == GregorianLeapYearP(year)) {
-		fixedDate += -1;
-	} else {
-		fixedDate += -2;
-	}
-	fixedDate += day;
-	return fixedDate;
+    if (month <= 2) {
+        fixedDate += 0;
+    } else if (TRUE == GregorianLeapYearP(year)) {
+        fixedDate += -1;
+    } else {
+        fixedDate += -2;
+    }
+    fixedDate += day;
+    return fixedDate;
 }
 
 
@@ -2441,105 +2441,105 @@ long FixedFromGregorian(long month, long day, long year)
  */
 long GregorianYearFromFixed(long fixedDate) 
 {
-	long result, d0, n400, d1, n100, d2, n4, d3, n1, d4, year;
-
-	d0 =	fixedDate - GregorianEpoch;
-	n400 =	(long)(floor((double)d0 / (double)146097));
-	d1 =	d0 % 146097;
-	n100 =	(long)(floor((double)d1 / (double)36524));
-	d2 =	d1 % 36524;
-	n4 =	(long)(floor((double)d2 / (double)1461));
-	d3 =	d2 % 1461;
-	n1 =	(long)(floor((double)d3 / (double)365));
-	d4 =	(d3 % 365) + 1;
-	year =	400 * n400 + 100 * n100 + 4 * n4 + n1;
-
-	if ((n100 == 4) || (n1 == 4)) {
-		result = year;
-	} else {
-		result = year + 1;
-	}
-	return result;
+    long result, d0, n400, d1, n100, d2, n4, d3, n1, d4, year;
+
+    d0 =    fixedDate - GregorianEpoch;
+    n400 =  (long)(floor((double)d0 / (double)146097));
+    d1 =    d0 % 146097;
+    n100 =  (long)(floor((double)d1 / (double)36524));
+    d2 =    d1 % 36524;
+    n4 =    (long)(floor((double)d2 / (double)1461));
+    d3 =    d2 % 1461;
+    n1 =    (long)(floor((double)d3 / (double)365));
+    d4 =    (d3 % 365) + 1;
+    year =  400 * n400 + 100 * n100 + 4 * n4 + n1;
+
+    if ((n100 == 4) || (n1 == 4)) {
+        result = year;
+    } else {
+        result = year + 1;
+    }
+    return result;
 }
 
 
 /* 
-  	Returns the Gregorian date from a fixed date (not needed for this use, but included for completeness)
+    Returns the Gregorian date from a fixed date (not needed for this use, but included for completeness)
  */
 #if UNUSED && KEEP
 GregorianFromFixed(long fixedDate, long *month, long *day, long *year) 
 {
-	long priorDays, correction;
+    long priorDays, correction;
 
-	*year =			GregorianYearFromFixed(fixedDate);
-	priorDays =		fixedDate - FixedFromGregorian(1, 1, *year);
+    *year =         GregorianYearFromFixed(fixedDate);
+    priorDays =     fixedDate - FixedFromGregorian(1, 1, *year);
 
-	if (fixedDate < FixedFromGregorian(3,1,*year)) {
-		correction = 0;
-	} else if (true == GregorianLeapYearP(*year)) {
-		correction = 1;
-	} else {
-		correction = 2;
-	}
-	*month = (long)(floor((12.0 * (double)(priorDays + correction) + 373.0) / 367.0));
-	*day = fixedDate - FixedFromGregorian(*month, 1, *year);
+    if (fixedDate < FixedFromGregorian(3,1,*year)) {
+        correction = 0;
+    } else if (true == GregorianLeapYearP(*year)) {
+        correction = 1;
+    } else {
+        correction = 2;
+    }
+    *month = (long)(floor((12.0 * (double)(priorDays + correction) + 373.0) / 367.0));
+    *day = fixedDate - FixedFromGregorian(*month, 1, *year);
 }
 #endif
 
 
 /* 
-  	Returns the difference between two Gregorian dates
+    Returns the difference between two Gregorian dates
  */
 long GregorianDateDifferenc(long month1, long day1, long year1,
-							long month2, long day2, long year2) 
+                            long month2, long day2, long year2) 
 {
-	return FixedFromGregorian(month2, day2, year2) - FixedFromGregorian(month1, day1, year1);
+    return FixedFromGregorian(month2, day2, year2) - FixedFromGregorian(month1, day1, year1);
 }
 
 
 /*
-  	Return the number of seconds into the current day
+    Return the number of seconds into the current day
  */
 #define SECONDS_PER_DAY 24*60*60
 
 static int parseTime(char_t *buf, int *index) 
 {
-    /*	
-      	Format of buf is - 2DIGIT ":" 2DIGIT ":" 2DIGIT
+    /*  
+        Format of buf is - 2DIGIT ":" 2DIGIT ":" 2DIGIT
      */
-	int returnValue, tmpIndex, hourValue, minuteValue, secondValue;
+    int returnValue, tmpIndex, hourValue, minuteValue, secondValue;
 
-	hourValue = minuteValue = secondValue = -1;
-	returnValue = -1;
-	tmpIndex = *index;
+    hourValue = minuteValue = secondValue = -1;
+    returnValue = -1;
+    tmpIndex = *index;
 
-	hourValue = parseNDIGIT(buf, 2, &tmpIndex);
+    hourValue = parseNDIGIT(buf, 2, &tmpIndex);
 
-	if (hourValue >= 0) {
-		tmpIndex++;
-		minuteValue = parseNDIGIT(buf, 2, &tmpIndex);
-		if (minuteValue >= 0) {
-			tmpIndex++;
-			secondValue = parseNDIGIT(buf, 2, &tmpIndex);
-		}
-	}
-	if ((hourValue >= 0) && (minuteValue >= 0) && (secondValue >= 0)) {
-		returnValue = (((hourValue * 60) + minuteValue) * 60) + secondValue;
-		*index = tmpIndex;
-	}
-	return returnValue;
+    if (hourValue >= 0) {
+        tmpIndex++;
+        minuteValue = parseNDIGIT(buf, 2, &tmpIndex);
+        if (minuteValue >= 0) {
+            tmpIndex++;
+            secondValue = parseNDIGIT(buf, 2, &tmpIndex);
+        }
+    }
+    if ((hourValue >= 0) && (minuteValue >= 0) && (secondValue >= 0)) {
+        returnValue = (((hourValue * 60) + minuteValue) * 60) + secondValue;
+        *index = tmpIndex;
+    }
+    return returnValue;
 }
 
 
 /*
-  	Return the equivalent of time() given a gregorian date
+    Return the equivalent of time() given a gregorian date
  */
 static time_t dateToTimet(int year, int month, int day) 
 {
-	long dayDifference;
+    long dayDifference;
 
-	dayDifference = FixedFromGregorian(month + 1, day, year) - FixedFromGregorian(1, 1, 1970);
-	return dayDifference * SECONDS_PER_DAY;
+    dayDifference = FixedFromGregorian(month + 1, day, year) - FixedFromGregorian(1, 1, 1970);
+    return dayDifference * SECONDS_PER_DAY;
 }
 
 
@@ -2548,120 +2548,120 @@ static time_t dateToTimet(int year, int month, int day)
  */
 static time_t parseDate1or2(char_t *buf, int *index) 
 {
-    /*	
-      	Format of buf is either
-      	2DIGIT SP month SP 4DIGIT
-      	or
-      	2DIGIT "-" month "-" 2DIGIT
+    /*  
+        Format of buf is either
+        2DIGIT SP month SP 4DIGIT
+        or
+        2DIGIT "-" month "-" 2DIGIT
      */
-	int		dayValue, monthValue, yearValue, tmpIndex;
-	time_t	returnValue;
+    int     dayValue, monthValue, yearValue, tmpIndex;
+    time_t  returnValue;
 
-	returnValue = (time_t) -1;
-	tmpIndex = *index;
+    returnValue = (time_t) -1;
+    tmpIndex = *index;
 
-	dayValue = monthValue = yearValue = -1;
+    dayValue = monthValue = yearValue = -1;
 
-	if (buf[tmpIndex] == T(',')) {
+    if (buf[tmpIndex] == T(',')) {
         /* 
             Skip over the ", " 
          */
-		tmpIndex += 2; 
+        tmpIndex += 2; 
 
-		dayValue = parseNDIGIT(buf, 2, &tmpIndex);
-		if (dayValue >= 0) {
+        dayValue = parseNDIGIT(buf, 2, &tmpIndex);
+        if (dayValue >= 0) {
             /*
                 Skip over the space or hyphen
              */
-			tmpIndex++; 
-			monthValue = parseMonth(buf, &tmpIndex);
-			if (monthValue >= 0) {
+            tmpIndex++; 
+            monthValue = parseMonth(buf, &tmpIndex);
+            if (monthValue >= 0) {
                 /*
                     Skip over the space or hyphen
                  */
-				tmpIndex++; 
-				yearValue = parseYear(buf, &tmpIndex);
-			}
-		}
-
-		if ((dayValue >= 0) &&
-			(monthValue >= 0) &&
-			(yearValue >= 0)) {
-			if (yearValue < 1970) {
-                /*				
+                tmpIndex++; 
+                yearValue = parseYear(buf, &tmpIndex);
+            }
+        }
+
+        if ((dayValue >= 0) &&
+            (monthValue >= 0) &&
+            (yearValue >= 0)) {
+            if (yearValue < 1970) {
+                /*              
                     Allow for Microsoft IE's year 1601 dates 
                  */
-				returnValue = 0; 
-			} else {
-				returnValue = dateToTimet(yearValue, monthValue, dayValue);
-			}
-			*index = tmpIndex;
-		}
-	}
-	
-	return returnValue;
+                returnValue = 0; 
+            } else {
+                returnValue = dateToTimet(yearValue, monthValue, dayValue);
+            }
+            *index = tmpIndex;
+        }
+    }
+    
+    return returnValue;
 }
 
 
 /*
-  	Return the number of seconds between Jan 1, 1970 and the parsed date
+    Return the number of seconds between Jan 1, 1970 and the parsed date
  */
 static time_t parseDate3Time(char_t *buf, int *index) 
 {
     /*
-      	Format of buf is month SP ( 2DIGIT | ( SP 1DIGIT ))
+        Format of buf is month SP ( 2DIGIT | ( SP 1DIGIT ))
      */
-	int		dayValue, monthValue, yearValue, timeValue, tmpIndex;
-	time_t	returnValue;
+    int     dayValue, monthValue, yearValue, timeValue, tmpIndex;
+    time_t  returnValue;
 
-	returnValue = (time_t) -1;
-	tmpIndex = *index;
+    returnValue = (time_t) -1;
+    tmpIndex = *index;
 
-	dayValue = monthValue = yearValue = timeValue = -1;
+    dayValue = monthValue = yearValue = timeValue = -1;
 
-	monthValue = parseMonth(buf, &tmpIndex);
-	if (monthValue >= 0) {
-        /*		
+    monthValue = parseMonth(buf, &tmpIndex);
+    if (monthValue >= 0) {
+        /*      
             Skip over the space 
          */
-		tmpIndex++; 
-		if (buf[tmpIndex] == T(' ')) {
+        tmpIndex++; 
+        if (buf[tmpIndex] == T(' ')) {
             /*
                 Skip over this space too 
              */
-			tmpIndex++; 
-			dayValue = parseNDIGIT(buf, 1, &tmpIndex);
-		} else {
-			dayValue = parseNDIGIT(buf, 2, &tmpIndex);
-		}
-        /*		
+            tmpIndex++; 
+            dayValue = parseNDIGIT(buf, 1, &tmpIndex);
+        } else {
+            dayValue = parseNDIGIT(buf, 2, &tmpIndex);
+        }
+        /*      
             Now get the time and time SP 4DIGIT
          */
-		timeValue = parseTime(buf, &tmpIndex);
-		if (timeValue >= 0) {
-            /*			
+        timeValue = parseTime(buf, &tmpIndex);
+        if (timeValue >= 0) {
+            /*          
                 Now grab the 4DIGIT year value
              */
-			yearValue = parseYear(buf, &tmpIndex);
-		}
-	}
+            yearValue = parseYear(buf, &tmpIndex);
+        }
+    }
 
-	if ((dayValue >= 0) && (monthValue >= 0) && (yearValue >= 0)) {
-		returnValue = dateToTimet(yearValue, monthValue, dayValue);
-		returnValue += timeValue;
-		*index = tmpIndex;
-	}
-	return returnValue;
+    if ((dayValue >= 0) && (monthValue >= 0) && (yearValue >= 0)) {
+        returnValue = dateToTimet(yearValue, monthValue, dayValue);
+        returnValue += timeValue;
+        *index = tmpIndex;
+    }
+    return returnValue;
 }
 
 
 //  MOB - macro and rename
 static int bufferIndexIncrementGivenNTest(char_t *buf, int testIndex, char_t testChar, int foundIncrement, int notfoundIncrement) 
 {
-	if (buf[testIndex] == testChar) {
-		return foundIncrement;
-	}
-	return notfoundIncrement;
+    if (buf[testIndex] == testChar) {
+        return foundIncrement;
+    }
+    return notfoundIncrement;
 }
 
 
@@ -2670,103 +2670,103 @@ static int bufferIndexIncrementGivenNTest(char_t *buf, int testIndex, char_t tes
  */
 static int parseWeekday(char_t *buf, int *index) 
 {
-    /*	
-      	Format of buf is either
-      	    "Mon" | "Tue" | "Wed" | "Thu" | "Fri" | "Sat" | "Sun"
-      	or
-      	    "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"
+    /*  
+        Format of buf is either
+            "Mon" | "Tue" | "Wed" | "Thu" | "Fri" | "Sat" | "Sun"
+        or
+            "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"
      */
-	int tmpIndex, returnValue;
-
-	returnValue = -1;
-	tmpIndex = *index;
-
-	switch (buf[tmpIndex]) {
-		case 'F':
-			returnValue = FRI;
-			*index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'd', sizeof("Friday"), 3);
-			break;
-		case 'M':
-			returnValue = MON;
-			*index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'd', sizeof("Monday"), 3);
-			break;
-		case 'S':
-			switch (buf[tmpIndex+1]) {
-				case 'a':
-					returnValue = SAT;
-					*index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'u', sizeof("Saturday"), 3);
-					break;
-				case 'u':
-					returnValue = SUN;
-					*index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'd', sizeof("Sunday"), 3);
-					break;
-			}
-			break;
-		case 'T':
-			switch (buf[tmpIndex+1]) {
-				case 'h':
-					returnValue = THU;
-					*index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'r', sizeof("Thursday"), 3);
-					break;
-				case 'u':
-					returnValue = TUE;
-					*index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 's', sizeof("Tuesday"), 3);
-					break;
-			}
-			break;
-		case 'W':
-			returnValue = WED;
-			*index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'n', sizeof("Wednesday"), 3);
-			break;
-	}
-	return returnValue;
+    int tmpIndex, returnValue;
+
+    returnValue = -1;
+    tmpIndex = *index;
+
+    switch (buf[tmpIndex]) {
+        case 'F':
+            returnValue = FRI;
+            *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'd', sizeof("Friday"), 3);
+            break;
+        case 'M':
+            returnValue = MON;
+            *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'd', sizeof("Monday"), 3);
+            break;
+        case 'S':
+            switch (buf[tmpIndex+1]) {
+                case 'a':
+                    returnValue = SAT;
+                    *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'u', sizeof("Saturday"), 3);
+                    break;
+                case 'u':
+                    returnValue = SUN;
+                    *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'd', sizeof("Sunday"), 3);
+                    break;
+            }
+            break;
+        case 'T':
+            switch (buf[tmpIndex+1]) {
+                case 'h':
+                    returnValue = THU;
+                    *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'r', sizeof("Thursday"), 3);
+                    break;
+                case 'u':
+                    returnValue = TUE;
+                    *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 's', sizeof("Tuesday"), 3);
+                    break;
+            }
+            break;
+        case 'W':
+            returnValue = WED;
+            *index += bufferIndexIncrementGivenNTest(buf, tmpIndex+3, 'n', sizeof("Wednesday"), 3);
+            break;
+    }
+    return returnValue;
 }
 
 
 /*
-  		Parse the date and time string.
+        Parse the date and time string.
  */
 static time_t dateParse(time_t tip, char_t *cmd)
 {
-	int index, tmpIndex, weekday, timeValue;
-	time_t parsedValue, dateValue;
+    int index, tmpIndex, weekday, timeValue;
+    time_t parsedValue, dateValue;
 
-	parsedValue = (time_t) 0;
-	index =	timeValue = 0;
-	weekday = parseWeekday(cmd, &index);
+    parsedValue = (time_t) 0;
+    index = timeValue = 0;
+    weekday = parseWeekday(cmd, &index);
 
-	if (weekday >= 0) {
-		tmpIndex = index;
-		dateValue = parseDate1or2(cmd, &tmpIndex);
-		if (dateValue >= 0) {
-			index = tmpIndex + 1;
+    if (weekday >= 0) {
+        tmpIndex = index;
+        dateValue = parseDate1or2(cmd, &tmpIndex);
+        if (dateValue >= 0) {
+            index = tmpIndex + 1;
             /*
                 One of these two forms is being used
                 wkday "," SP date1 SP time SP "GMT"
                 weekday "," SP date2 SP time SP "GMT"
              */
-			timeValue = parseTime(cmd, &index);
-			if (timeValue >= 0) {
-                /*				
+            timeValue = parseTime(cmd, &index);
+            if (timeValue >= 0) {
+                /*              
                     Now match up that "GMT" string for completeness
-                  	Compute the final value if there were no problems in the parse
+                    Compute the final value if there were no problems in the parse
                  */
-				if ((weekday >= 0) &&
-					(dateValue >= 0) &&
-					(timeValue >= 0)) {
-					parsedValue = dateValue + timeValue;
-				}
-			}
-		} else {
+                if ((weekday >= 0) &&
+                    (dateValue >= 0) &&
+                    (timeValue >= 0)) {
+                    parsedValue = dateValue + timeValue;
+                }
+            }
+        } else {
             /* 
                 Try the other form - wkday SP date3 SP time SP 4DIGIT
              */
-			tmpIndex = index;
-			parsedValue = parseDate3Time(cmd, &tmpIndex);
-		}
-	}
+            tmpIndex = index;
+            parsedValue = parseDate3Time(cmd, &tmpIndex);
+        }
+    }
 
-	return parsedValue;
+    return parsedValue;
 }
 
 #endif /* WEBS_IF_MODIFIED_SUPPORT */
diff --git a/webs.h b/webs.h
index 625dd54c..b3e791c3 100644
--- a/webs.h
+++ b/webs.h
@@ -1,5 +1,5 @@
 /* 
-  	webs.h -- GoAhead Web public header
+    webs.h -- GoAhead Web public header
   
     Copyright (c) All Rights Reserved. See details at the end of the file.
  */
@@ -9,21 +9,21 @@
 
 /********************************* Includes ***********************************/
 
-#include	"ej.h"
+#include    "ej.h"
 #ifdef WEBS_SSL_SUPPORT
-	#include	"websSSL.h"
+    #include    "websSSL.h"
 #endif
 
 /*************************** User Configurable Defines ************************/
 
 //  MOB - move to a config.h
 
-#define WEBS_DEFAULT_HOME		T("home.htm") /* Default home page */
-#define WEBS_DEFAULT_PORT		8080		/* Default HTTP port */
-#define WEBS_DEFAULT_SSL_PORT	4433		/* Default HTTPS port */
+#define WEBS_DEFAULT_HOME       T("home.htm") /* Default home page */
+#define WEBS_DEFAULT_PORT       8080        /* Default HTTP port */
+#define WEBS_DEFAULT_SSL_PORT   4433        /* Default HTTPS port */
 
 /* Enable Whitelist access to files */
-#define WEBS_WHITELIST_SUPPORT	1
+#define WEBS_WHITELIST_SUPPORT  1
 
 /* Enable logging of web accesses to a file */
 #define WEBS_LOG_SUPPORT 1
@@ -43,196 +43,196 @@
 
 /****************************** Immutable Defines *****************************/
 /*
-  	By license terms the software name and version defined in this section of code must not be modified.
+    By license terms the software name and version defined in this section of code must not be modified.
  */
-#define WEBS_NAME				T("GoAhead")
-#define WEBS_VERSION			T("2.5.0")
+#define WEBS_NAME               T("GoAhead")
+#define WEBS_VERSION            T("2.5.0")
 #ifdef WEBS_SSL_SUPPORT
-#define SSL_NAME				T("PeerSec-MatrixSSL")
-#define SSL_VERSION				T(MATRIXSSL_VERSION)
+#define SSL_NAME                T("PeerSec-MatrixSSL")
+#define SSL_VERSION             T(MATRIXSSL_VERSION)
 #endif /* WEBS_SSL_SUPPORT */
 
 /********************************** Defines ***********************************/
 
-#define WEBS_HEADER_BUFINC 		512			/* Header buffer size */
-#define WEBS_ASP_BUFINC			512			/* Asp expansion increment */
-#define WEBS_MAX_PASS			32			/* Size of password */
-#define WEBS_BUFSIZE			960		/* websWrite max output string */
-#define WEBS_MAX_HEADER			(5 * 1024)	/* Sanity check header */
-#define WEBS_MAX_URL			2048		/* Maximum URL size for sanity */
-#define WEBS_SOCKET_BUFSIZ		256			/* Bytes read from socket */
+#define WEBS_HEADER_BUFINC      512         /* Header buffer size */
+#define WEBS_ASP_BUFINC         512         /* Asp expansion increment */
+#define WEBS_MAX_PASS           32          /* Size of password */
+#define WEBS_BUFSIZE            960     /* websWrite max output string */
+#define WEBS_MAX_HEADER         (5 * 1024)  /* Sanity check header */
+#define WEBS_MAX_URL            2048        /* Maximum URL size for sanity */
+#define WEBS_SOCKET_BUFSIZ      256         /* Bytes read from socket */
 
-#define WEBS_HTTP_PORT			T("httpPort")
-#define CGI_BIN					T("cgi-bin")
+#define WEBS_HTTP_PORT          T("httpPort")
+#define CGI_BIN                 T("cgi-bin")
 
 /* 
- *	Request flags. Also returned by websGetRequestFlags().
+ *  Request flags. Also returned by websGetRequestFlags().
  */
-#define WEBS_LOCAL_PAGE			0x1			/* Request for local webs page */ 
-#define WEBS_KEEP_ALIVE			0x2			/* HTTP/1.1 keep alive */
-#define WEBS_DONT_USE_CACHE		0x4			/* Not implemented cache support */
-#define WEBS_COOKIE				0x8			/* Cookie supplied in request */
-#define WEBS_IF_MODIFIED		0x10		/* If-modified-since in request */
-#define WEBS_POST_REQUEST		0x20		/* Post request operation */
-#define WEBS_LOCAL_REQUEST		0x40		/* Request from this system */
-#define WEBS_HOME_PAGE			0x80		/* Request for the home page */ 
-#define WEBS_ASP				0x100		/* ASP request */ 
-#define WEBS_HEAD_REQUEST		0x200		/* Head request */
-#define WEBS_CLEN				0x400		/* Request had a content length */
-#define WEBS_FORM				0x800		/* Request is a form */
-#define WEBS_REQUEST_DONE		0x1000		/* Request complete */
-#define WEBS_POST_DATA			0x2000		/* Already appended post data */
-#define WEBS_CGI_REQUEST		0x4000		/* cgi-bin request */
-#define WEBS_SECURE				0x8000		/* connection uses SSL */
-#define WEBS_AUTH_BASIC			0x10000		/* Basic authentication request */
-#define WEBS_AUTH_DIGEST		0x20000		/* Digest authentication request */
-#define WEBS_HEADER_DONE		0x40000		/* Already output the HTTP header */
+#define WEBS_LOCAL_PAGE         0x1         /* Request for local webs page */ 
+#define WEBS_KEEP_ALIVE         0x2         /* HTTP/1.1 keep alive */
+#define WEBS_DONT_USE_CACHE     0x4         /* Not implemented cache support */
+#define WEBS_COOKIE             0x8         /* Cookie supplied in request */
+#define WEBS_IF_MODIFIED        0x10        /* If-modified-since in request */
+#define WEBS_POST_REQUEST       0x20        /* Post request operation */
+#define WEBS_LOCAL_REQUEST      0x40        /* Request from this system */
+#define WEBS_HOME_PAGE          0x80        /* Request for the home page */ 
+#define WEBS_ASP                0x100       /* ASP request */ 
+#define WEBS_HEAD_REQUEST       0x200       /* Head request */
+#define WEBS_CLEN               0x400       /* Request had a content length */
+#define WEBS_FORM               0x800       /* Request is a form */
+#define WEBS_REQUEST_DONE       0x1000      /* Request complete */
+#define WEBS_POST_DATA          0x2000      /* Already appended post data */
+#define WEBS_CGI_REQUEST        0x4000      /* cgi-bin request */
+#define WEBS_SECURE             0x8000      /* connection uses SSL */
+#define WEBS_AUTH_BASIC         0x10000     /* Basic authentication request */
+#define WEBS_AUTH_DIGEST        0x20000     /* Digest authentication request */
+#define WEBS_HEADER_DONE        0x40000     /* Already output the HTTP header */
 
 /*
-  	URL handler flags
+    URL handler flags
  */
-#define WEBS_HANDLER_FIRST	0x1			/* Process this handler first */
-#define WEBS_HANDLER_LAST	0x2			/* Process this handler last */
+#define WEBS_HANDLER_FIRST  0x1         /* Process this handler first */
+#define WEBS_HANDLER_LAST   0x2         /* Process this handler last */
 
 /* 
-  	Per socket connection webs structure
+    Per socket connection webs structure
  */
 typedef struct websRec {
-	ringq_t			header;				/* Header dynamic string */
-	time_t			since;				/* Parsed if-modified-since time */
-	sym_fd_t		cgiVars;			/* CGI standard variables */
-	sym_fd_t		cgiQuery;			/* CGI decoded query string */
-	time_t			timestamp;			/* Last transaction with browser */
-	int				timeout;			/* Timeout handle */
-	char_t			ipaddr[32];			/* Connecting ipaddress */
-	char_t			ifaddr[32];			/* Local interface ipaddress */
-	char_t			type[64];			/* Mime type */
-	char_t			*dir;				/* Directory containing the page */
-	char_t			*path;				/* Path name without query */
-	char_t			*url;				/* Full request url */
-	char_t			*host;				/* Requested host */
-	char_t			*lpath;				/* Cache local path name */
-	char_t			*query;				/* Request query */
-	char_t			*decodedQuery;		/* Decoded request query */
-	char_t			*authType;			/* Authorization type (Basic/DAA) */
-	char_t			*password;			/* Authorization password */
-	char_t			*userName;			/* Authorization username */
-	char_t			*cookie;			/* Cookie string */
-	char_t			*userAgent;			/* User agent (browser) */
-	char_t			*protocol;			/* Protocol (normally HTTP) */
-	char_t			*protoVersion;		/* Protocol version */
-	int				sid;				/* Socket id (handler) */
-	int				listenSid;			/* Listen Socket id */
-	int				port;				/* Request port number */
-	int				state;				/* Current state */
-	int				flags;				/* Current flags -- see above */
-	int				code;				/* Request result code */
-	int				clen;				/* Content length */
-	int				wid;				/* Index into webs */
-	char_t			*cgiStdin;			/* filename for CGI stdin */
-	int				docfd;				/* Document file descriptor */
-	int				numbytes;			/* Bytes to transfer to browser */
-	int				written;			/* Bytes actually transferred */
-	void			(*writeSocket)(struct websRec *wp);
+    ringq_t         header;             /* Header dynamic string */
+    time_t          since;              /* Parsed if-modified-since time */
+    sym_fd_t        cgiVars;            /* CGI standard variables */
+    sym_fd_t        cgiQuery;           /* CGI decoded query string */
+    time_t          timestamp;          /* Last transaction with browser */
+    int             timeout;            /* Timeout handle */
+    char_t          ipaddr[32];         /* Connecting ipaddress */
+    char_t          ifaddr[32];         /* Local interface ipaddress */
+    char_t          type[64];           /* Mime type */
+    char_t          *dir;               /* Directory containing the page */
+    char_t          *path;              /* Path name without query */
+    char_t          *url;               /* Full request url */
+    char_t          *host;              /* Requested host */
+    char_t          *lpath;             /* Cache local path name */
+    char_t          *query;             /* Request query */
+    char_t          *decodedQuery;      /* Decoded request query */
+    char_t          *authType;          /* Authorization type (Basic/DAA) */
+    char_t          *password;          /* Authorization password */
+    char_t          *userName;          /* Authorization username */
+    char_t          *cookie;            /* Cookie string */
+    char_t          *userAgent;         /* User agent (browser) */
+    char_t          *protocol;          /* Protocol (normally HTTP) */
+    char_t          *protoVersion;      /* Protocol version */
+    int             sid;                /* Socket id (handler) */
+    int             listenSid;          /* Listen Socket id */
+    int             port;               /* Request port number */
+    int             state;              /* Current state */
+    int             flags;              /* Current flags -- see above */
+    int             code;               /* Request result code */
+    int             clen;               /* Content length */
+    int             wid;                /* Index into webs */
+    char_t          *cgiStdin;          /* filename for CGI stdin */
+    int             docfd;              /* Document file descriptor */
+    int             numbytes;           /* Bytes to transfer to browser */
+    int             written;            /* Bytes actually transferred */
+    void            (*writeSocket)(struct websRec *wp);
 #ifdef DIGEST_ACCESS_SUPPORT
-    char_t			*realm;		/* usually the same as "host" from websRec */
-    char_t			*nonce;		/* opaque-to-client string sent by server */
-    char_t			*digest;	/* digest form of user password */
-    char_t			*uri;		/* URI found in DAA header */
-    char_t			*opaque;	/* opaque value passed from server */
-    char_t			*nc;		/* nonce count */
-    char_t			*cnonce;	/* check nonce */
-    char_t			*qop;		/* quality operator */
+    char_t          *realm;     /* usually the same as "host" from websRec */
+    char_t          *nonce;     /* opaque-to-client string sent by server */
+    char_t          *digest;    /* digest form of user password */
+    char_t          *uri;       /* URI found in DAA header */
+    char_t          *opaque;    /* opaque value passed from server */
+    char_t          *nc;        /* nonce count */
+    char_t          *cnonce;    /* check nonce */
+    char_t          *qop;       /* quality operator */
 #endif
 #ifdef WEBS_SSL_SUPPORT
-	websSSL_t		*wsp;		/* SSL data structure */
+    websSSL_t       *wsp;       /* SSL data structure */
 #endif
 } websRec;
 
-typedef websRec	*webs_t;
+typedef websRec *webs_t;
 typedef websRec websType;
 
 /******************************** Prototypes **********************************/
 
-extern int		 websAccept(int sid, char *ipaddr, int port, int listenSid);
-extern int 		 websAspDefine(char_t *name, int (*fn)(int ejid, webs_t wp, int argc, char_t **argv));
-extern int 		 websAspRequest(webs_t wp, char_t *lpath);
-extern void		 websCloseListen();
-extern int 		 websDecode64(char_t *outbuf, char_t *string, int buflen);
-extern void		 websDecodeUrl(char_t *token, char_t *decoded, int len);
-extern void  	 websDone(webs_t wp, int code);
-extern void 	 websEncode64(char_t *outbuf, char_t *string, int buflen);
-extern void  	 websError(webs_t wp, int code, char_t *msg, ...);
+extern int       websAccept(int sid, char *ipaddr, int port, int listenSid);
+extern int       websAspDefine(char_t *name, int (*fn)(int ejid, webs_t wp, int argc, char_t **argv));
+extern int       websAspRequest(webs_t wp, char_t *lpath);
+extern void      websCloseListen();
+extern int       websDecode64(char_t *outbuf, char_t *string, int buflen);
+extern void      websDecodeUrl(char_t *token, char_t *decoded, int len);
+extern void      websDone(webs_t wp, int code);
+extern void      websEncode64(char_t *outbuf, char_t *string, int buflen);
+extern void      websError(webs_t wp, int code, char_t *msg, ...);
 /* function websErrorMsg() made extern 03 Jun 02 BgP */
-extern char_t 	*websErrorMsg(int code);
-extern void  	 websFooter(webs_t wp);
-extern int 		 websFormDefine(char_t *name, void (*fn)(webs_t wp, char_t *path, char_t *query));
-extern char_t 	*websGetDefaultDir();
-extern char_t 	*websGetDefaultPage();
-extern char_t 	*websGetHostUrl();
-extern char_t 	*websGetIpaddrUrl();
-extern char_t 	*websGetPassword();
-extern int		 websGetPort();
-extern char_t 	*websGetPublishDir(char_t *path, char_t **urlPrefix);
-extern char_t 	*websGetRealm();
-extern int 		 websGetRequestBytes(webs_t wp);
-extern char_t	*websGetRequestDir(webs_t wp);
-extern int		 websGetRequestFlags(webs_t wp);
-extern char_t	*websGetRequestIpaddr(webs_t wp);
-extern char_t 	*websGetRequestLpath(webs_t wp);
-extern char_t	*websGetRequestPath(webs_t wp);
-extern char_t	*websGetRequestPassword(webs_t wp);
-extern char_t	*websGetRequestType(webs_t wp);
-extern int 		 websGetRequestWritten(webs_t wp);
-extern char_t 	*websGetVar(webs_t wp, char_t *var, char_t *def);
-extern int 		 websCompareVar(webs_t wp, char_t *var, char_t *value);
-extern void 	 websHeader(webs_t wp);
-extern int		 websOpenListen(int port, int retries);
-extern int 		 websPageOpen(webs_t wp, char_t *lpath, char_t *path, int mode, int perm);
-extern void 	 websPageClose(webs_t wp);
-extern int 		 websPublish(char_t *urlPrefix, char_t *path);
-extern void		 websRedirect(webs_t wp, char_t *url);
-extern void 	 websSecurityDelete();
-extern int 		 websSecurityHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t *url, char_t *path, 
-					char_t *query);
-extern void 	websSetDefaultDir(char_t *dir);
-extern void 	websSetDefaultPage(char_t *page);
-extern void 	websSetEnv(webs_t wp);
-extern void 	websSetHost(char_t *host);
-extern void 	websSetIpaddr(char_t *ipaddr);
-extern void 	websSetPassword(char_t *password);
-extern void 	websSetRealm(char_t *realmName);
-extern void 	websSetRequestBytes(webs_t wp, int bytes);
-extern void		websSetRequestFlags(webs_t wp, int flags);
-extern void 	websSetRequestLpath(webs_t wp, char_t *lpath);
-extern void 	websSetRequestPath(webs_t wp, char_t *dir, char_t *path);
+extern char_t   *websErrorMsg(int code);
+extern void      websFooter(webs_t wp);
+extern int       websFormDefine(char_t *name, void (*fn)(webs_t wp, char_t *path, char_t *query));
+extern char_t   *websGetDefaultDir();
+extern char_t   *websGetDefaultPage();
+extern char_t   *websGetHostUrl();
+extern char_t   *websGetIpaddrUrl();
+extern char_t   *websGetPassword();
+extern int       websGetPort();
+extern char_t   *websGetPublishDir(char_t *path, char_t **urlPrefix);
+extern char_t   *websGetRealm();
+extern int       websGetRequestBytes(webs_t wp);
+extern char_t   *websGetRequestDir(webs_t wp);
+extern int       websGetRequestFlags(webs_t wp);
+extern char_t   *websGetRequestIpaddr(webs_t wp);
+extern char_t   *websGetRequestLpath(webs_t wp);
+extern char_t   *websGetRequestPath(webs_t wp);
+extern char_t   *websGetRequestPassword(webs_t wp);
+extern char_t   *websGetRequestType(webs_t wp);
+extern int       websGetRequestWritten(webs_t wp);
+extern char_t   *websGetVar(webs_t wp, char_t *var, char_t *def);
+extern int       websCompareVar(webs_t wp, char_t *var, char_t *value);
+extern void      websHeader(webs_t wp);
+extern int       websOpenListen(int port, int retries);
+extern int       websPageOpen(webs_t wp, char_t *lpath, char_t *path, int mode, int perm);
+extern void      websPageClose(webs_t wp);
+extern int       websPublish(char_t *urlPrefix, char_t *path);
+extern void      websRedirect(webs_t wp, char_t *url);
+extern void      websSecurityDelete();
+extern int       websSecurityHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t *url, char_t *path, 
+                    char_t *query);
+extern void     websSetDefaultDir(char_t *dir);
+extern void     websSetDefaultPage(char_t *page);
+extern void     websSetEnv(webs_t wp);
+extern void     websSetHost(char_t *host);
+extern void     websSetIpaddr(char_t *ipaddr);
+extern void     websSetPassword(char_t *password);
+extern void     websSetRealm(char_t *realmName);
+extern void     websSetRequestBytes(webs_t wp, int bytes);
+extern void     websSetRequestFlags(webs_t wp, int flags);
+extern void     websSetRequestLpath(webs_t wp, char_t *lpath);
+extern void     websSetRequestPath(webs_t wp, char_t *dir, char_t *path);
 extern char_t  *websGetRequestUserName(webs_t wp);
-extern void 	websSetRequestWritten(webs_t wp, int written);
-extern void 	websSetVar(webs_t wp, char_t *var, char_t *value);
-extern int 		websTestVar(webs_t wp, char_t *var);
-extern void		websTimeoutCancel(webs_t wp);
-extern int 		websUrlHandlerDefine(char_t *urlPrefix, char_t *webDir, int arg, int (*fn)(webs_t wp, char_t *urlPrefix, 
-					char_t *webDir, int arg, char_t *url, char_t *path, char_t *query), int flags);
-extern int 		websUrlHandlerDelete(int (*fn)(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t *url, char_t *path, 
-					char_t *query));
-extern int		websUrlHandlerRequest(webs_t wp);
-extern int 		websUrlParse(char_t *url, char_t **buf, char_t **host, char_t **path, char_t **port, char_t **query, 
-					char_t **proto, char_t **tag, char_t **ext);
-extern char_t 	*websUrlType(char_t *webs, char_t *buf, int charCnt);
-extern int 		 websWrite(webs_t wp, char_t* fmt, ...);
-extern int 		 websWriteBlock(webs_t wp, char_t *buf, int nChars);
-extern int 		 websWriteDataNonBlock(webs_t wp, char *buf, int nChars);
-extern int 		 websValid(webs_t wp);
-extern int 		 websValidateUrl(webs_t wp, char_t *path);
-extern void		 websSetTimeMark(webs_t wp);
+extern void     websSetRequestWritten(webs_t wp, int written);
+extern void     websSetVar(webs_t wp, char_t *var, char_t *value);
+extern int      websTestVar(webs_t wp, char_t *var);
+extern void     websTimeoutCancel(webs_t wp);
+extern int      websUrlHandlerDefine(char_t *urlPrefix, char_t *webDir, int arg, int (*fn)(webs_t wp, char_t *urlPrefix, 
+                    char_t *webDir, int arg, char_t *url, char_t *path, char_t *query), int flags);
+extern int      websUrlHandlerDelete(int (*fn)(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t *url, char_t *path, 
+                    char_t *query));
+extern int      websUrlHandlerRequest(webs_t wp);
+extern int      websUrlParse(char_t *url, char_t **buf, char_t **host, char_t **path, char_t **port, char_t **query, 
+                    char_t **proto, char_t **tag, char_t **ext);
+extern char_t   *websUrlType(char_t *webs, char_t *buf, int charCnt);
+extern int       websWrite(webs_t wp, char_t* fmt, ...);
+extern int       websWriteBlock(webs_t wp, char_t *buf, int nChars);
+extern int       websWriteDataNonBlock(webs_t wp, char *buf, int nChars);
+extern int       websValid(webs_t wp);
+extern int       websValidateUrl(webs_t wp, char_t *path);
+extern void      websSetTimeMark(webs_t wp);
 
 /*
-  	The following prototypes are used by the SSL layer websSSL.c
+    The following prototypes are used by the SSL layer websSSL.c
  */
-extern int 		websAlloc(int sid);
-extern void 	websFree(webs_t wp);
-extern void 	websTimeout(void *arg, int id);
-extern void 	websReadEvent(webs_t wp);
+extern int      websAlloc(int sid);
+extern void     websFree(webs_t wp);
+extern void     websTimeout(void *arg, int id);
+extern void     websReadEvent(webs_t wp);
 
 #endif /* _h_WEBS */
 
diff --git a/websSSL.c b/websSSL.c
index 415a2a3a..59ec2f54 100644
--- a/websSSL.c
+++ b/websSSL.c
@@ -20,14 +20,14 @@
 
 /******************************* Definitions **********************************/
 
-static int			sslListenSock   = -1;            /* Listen socket */
-static sslKeys_t	*sslKeys = NULL;
+static int          sslListenSock   = -1;            /* Listen socket */
+static sslKeys_t    *sslKeys = NULL;
 
 /******************************* Prototypes  **********************************/
 
-static int	websSSLAccept(int sid, char *ipaddr, int port, int listenSid);
-static void	websSSLSocketEvent(int sid, int mask, void *iwp);
-static int	websSSLReadEvent(webs_t wp);
+static int  websSSLAccept(int sid, char *ipaddr, int port, int listenSid);
+static void websSSLSocketEvent(int sid, int mask, void *iwp);
+static int  websSSLReadEvent(webs_t wp);
 
 /******************************************************************************/
 /*
@@ -39,32 +39,32 @@ static int	websSSLReadEvent(webs_t wp);
  */
 int websSSLOpen()
 {
-	if (matrixSslOpen() < 0) {
-		return -1;
+    if (matrixSslOpen() < 0) {
+        return -1;
     }
-	if (matrixSslNewKeys(&sslKeys) < 0) {
-		trace(0, T("Failed to allocate keys in websSSLOpen\n"));
-		return -1;
-	}
-	if (matrixSslLoadRsaKeys(sslKeys, DEFAULT_CERT_FILE, DEFAULT_KEY_FILE, 
-							  NULL /* privPass */,  
-							  NULL /* trustedCAFile */) < 0) {
-		trace(0, T("Failed to read certificate %s in websSSLOpen\n"),
-			DEFAULT_CERT_FILE);
-		trace(0, T("SSL support is disabled\n"));
-		return -1;
+    if (matrixSslNewKeys(&sslKeys) < 0) {
+        trace(0, T("Failed to allocate keys in websSSLOpen\n"));
+        return -1;
+    }
+    if (matrixSslLoadRsaKeys(sslKeys, DEFAULT_CERT_FILE, DEFAULT_KEY_FILE, 
+                              NULL /* privPass */,  
+                              NULL /* trustedCAFile */) < 0) {
+        trace(0, T("Failed to read certificate %s in websSSLOpen\n"),
+            DEFAULT_CERT_FILE);
+        trace(0, T("SSL support is disabled\n"));
+        return -1;
     }
 
 #ifdef USE_NONBLOCKING_SSL_SOCKETS
-	sslListenSock = socketOpenConnection(NULL, WEBS_DEFAULT_SSL_PORT, websSSLAccept, SOCKET_MYOWNBUFFERS);
+    sslListenSock = socketOpenConnection(NULL, WEBS_DEFAULT_SSL_PORT, websSSLAccept, SOCKET_MYOWNBUFFERS);
 #else
-	sslListenSock = socketOpenConnection(NULL, WEBS_DEFAULT_SSL_PORT, websSSLAccept, SOCKET_BLOCK | SOCKET_MYOWNBUFFERS);
+    sslListenSock = socketOpenConnection(NULL, WEBS_DEFAULT_SSL_PORT, websSSLAccept, SOCKET_BLOCK | SOCKET_MYOWNBUFFERS);
 #endif
-	if (sslListenSock < 0) {
-		trace(0, T("SSL: Unable to open SSL socket on port %d.\n"), WEBS_DEFAULT_SSL_PORT);
-		return -1;
+    if (sslListenSock < 0) {
+        trace(0, T("SSL: Unable to open SSL socket on port %d.\n"), WEBS_DEFAULT_SSL_PORT);
+        return -1;
     }
-	trace(0, T("webs: Listening for HTTPS requests at port %d\n"), WEBS_DEFAULT_SSL_PORT);
+    trace(0, T("webs: Listening for HTTPS requests at port %d\n"), WEBS_DEFAULT_SSL_PORT);
     return 0;
 }
 
@@ -77,46 +77,46 @@ int websSSLAccept(int sid, char *ipaddr, int port, int listenSid)
 {
     webs_t    wp;
     int        wid;
-	
+    
     a_assert(ipaddr && *ipaddr);
     a_assert(sid >= 0);
     a_assert(port >= 0);
-	
-	/*
-	    Allocate a new handle for this accepted connection. This will allocate a webs_t structure in the webs[] list
-	 */
+    
+    /*
+        Allocate a new handle for this accepted connection. This will allocate a webs_t structure in the webs[] list
+     */
     if ((wid = websAlloc(sid)) < 0) {
         return -1;
     }
     wp = webs[wid];
     a_assert(wp);
     wp->listenSid = listenSid;
-	
+    
     ascToUni(wp->ipaddr, ipaddr, min(sizeof(wp->ipaddr), strlen(ipaddr)+1));
-	
-	/*
+    
+    /*
         Check if this is a request from a browser on this system. This is useful to know for permitting administrative
         operations only for local access 
      */
     if (gstrcmp(wp->ipaddr, T("127.0.0.1")) == 0 ||
-		gstrcmp(wp->ipaddr, websIpaddr) == 0 ||
-		gstrcmp(wp->ipaddr, websHost) == 0) {
+        gstrcmp(wp->ipaddr, websIpaddr) == 0 ||
+        gstrcmp(wp->ipaddr, websHost) == 0) {
         wp->flags |= WEBS_LOCAL_REQUEST;
     }
 
-	/*
-	  	Since the acceptance came in on this channel, it must be secure
-	 */
+    /*
+        Since the acceptance came in on this channel, it must be secure
+     */
     wp->flags |= WEBS_SECURE;
-	
-	/*
-	  	Arrange for websSocketEvent to be called when read data is available
-	 */
+    
+    /*
+        Arrange for websSocketEvent to be called when read data is available
+     */
     socketCreateHandler(sid, SOCKET_READABLE, websSSLSocketEvent, wp);
-	
-	/*
-	  	Arrange for a timeout to kill hung requests
-	 */
+    
+    /*
+        Arrange for a timeout to kill hung requests
+     */
     wp->timeout = emfSchedCallback(WEBS_TIMEOUT, websTimeout, (void *) wp);
     trace(8, T("websSSLAccept(): webs: accept request\n"));
     return 0;
@@ -128,9 +128,9 @@ int websSSLAccept(int sid, char *ipaddr, int port, int listenSid)
  */
 int websSSLRead(websSSL_t *wsp, char_t *buf, int len)
 {
-	a_assert(wsp);
-	a_assert(buf);
-	return sslRead(wsp->sslConn, buf, len);
+    a_assert(wsp);
+    a_assert(buf);
+    return sslRead(wsp->sslConn, buf, len);
 }
 
 
@@ -145,72 +145,72 @@ int websSSLRead(websSSL_t *wsp, char_t *buf, int len)
  */
 int websSSLGets(websSSL_t *wsp, char_t **buf)
 { 
-	socket_t    *sp;
-	ringq_t       *lq;
-	char        c;
-	int         len;
-	webs_t      wp;
-	int         sid;
-	int         numBytesReceived;
-	
-	a_assert(wsp);
-	a_assert(buf);
-	
-	*buf = NULL;
-	
-	wp  = wsp->wp;
-	sid = wp->sid;
-	
-	if ((sp = socketPtr(sid)) == NULL) {
-		return -1;
-	}
-	lq = &sp->lineBuf;
-	
-	while (1) {
-		
-		/* read one byte at a time */
-		numBytesReceived = sslRead(wsp->sslConn, &c, 1);
-		
-		if (numBytesReceived < 0) {
-			return -1;
-		}
-		
-		if (numBytesReceived == 0) {
-			/*
-			    If there is a partial line and we are at EOF, pretend we saw a '\n'
-			 */
-			if (ringqLen(lq) > 0 && (sp->flags & SOCKET_EOF)) {
-				c = '\n';
-			} else {
-				len = ringqLen(lq);
-				if (len > 0) {
-					*buf = ballocAscToUni((char *)lq->servp, len);
-				} else {
-					*buf = NULL;
-				}
-				ringqFlush(lq);
-				return len;
-			}
-		}
-		/*
-		    If a newline is seen, return the data excluding the new line to the caller. If carriage return is seen, just eat it.
-		 */
-		if (c == '\n') {
-			len = ringqLen(lq);
-			if (len > 0) {
-				*buf = ballocAscToUni((char *)lq->servp, len);
-			} else {
-				*buf = NULL;
-			}
-			ringqFlush(lq);
-			return len;
-			
-		} else if (c == '\r') {
-			continue;
-		}
-		ringqPutcA(lq, c);
-	}
-	return 0;
+    socket_t    *sp;
+    ringq_t       *lq;
+    char        c;
+    int         len;
+    webs_t      wp;
+    int         sid;
+    int         numBytesReceived;
+    
+    a_assert(wsp);
+    a_assert(buf);
+    
+    *buf = NULL;
+    
+    wp  = wsp->wp;
+    sid = wp->sid;
+    
+    if ((sp = socketPtr(sid)) == NULL) {
+        return -1;
+    }
+    lq = &sp->lineBuf;
+    
+    while (1) {
+        
+        /* read one byte at a time */
+        numBytesReceived = sslRead(wsp->sslConn, &c, 1);
+        
+        if (numBytesReceived < 0) {
+            return -1;
+        }
+        
+        if (numBytesReceived == 0) {
+            /*
+                If there is a partial line and we are at EOF, pretend we saw a '\n'
+             */
+            if (ringqLen(lq) > 0 && (sp->flags & SOCKET_EOF)) {
+                c = '\n';
+            } else {
+                len = ringqLen(lq);
+                if (len > 0) {
+                    *buf = ballocAscToUni((char *)lq->servp, len);
+                } else {
+                    *buf = NULL;
+                }
+                ringqFlush(lq);
+                return len;
+            }
+        }
+        /*
+            If a newline is seen, return the data excluding the new line to the caller. If carriage return is seen, just eat it.
+         */
+        if (c == '\n') {
+            len = ringqLen(lq);
+            if (len > 0) {
+                *buf = ballocAscToUni((char *)lq->servp, len);
+            } else {
+                *buf = NULL;
+            }
+            ringqFlush(lq);
+            return len;
+            
+        } else if (c == '\r') {
+            continue;
+        }
+        ringqPutcA(lq, c);
+    }
+    return 0;
 }
 
 
@@ -221,10 +221,10 @@ int websSSLGets(websSSL_t *wsp, char_t **buf)
 static void websSSLSocketEvent(int sid, int mask, void *iwp)
 {
     webs_t    wp;
-	
+    
     wp = (webs_t) iwp;
     a_assert(wp);
-	
+    
     if (! websValid(wp)) {
         return;
     }
@@ -247,21 +247,21 @@ static int websSSLReadEvent (webs_t wp)
     int ret = 07, sock, resume;
     socket_t *sptr;
     sslConn_t* sslConn;
-	
+    
     a_assert (wp);
     a_assert(websValid(wp));
-	
+    
     sptr = socketPtr(wp->sid);
     a_assert(sptr);
-	
+    
     sock = sptr->sock;
-	
-	if (wp->wsp == NULL) {
-		resume = 0;
-	} else {
-		resume = 1;
-		sslConn = (wp->wsp)->sslConn;
-	}
+    
+    if (wp->wsp == NULL) {
+        resume = 0;
+    } else {
+        resume = 1;
+        sslConn = (wp->wsp)->sslConn;
+    }
     /*
         This handler is essentially two back-to-back calls to sslRead.  The first is here in sslAccept where the
         handshake is to take place.  The second is in websReadEvent below where it is expected the client was contacting
@@ -273,22 +273,22 @@ static int websSSLReadEvent (webs_t wp)
         used (which is what the resume variable is all about))
     */
     if (sslAccept(&sslConn, sock, sslKeys, resume, NULL) < 0) {
-		websTimeoutCancel(wp);
-		socketCloseConnection(wp->sid);
-		websFree(wp);
-		return -1;
+        websTimeoutCancel(wp);
+        socketCloseConnection(wp->sid);
+        websFree(wp);
+        return -1;
     }
-	
-	if (resume == 0) {
+    
+    if (resume == 0) {
         /*
             Create the SSL data structure in the wp.
          */
-		wp->wsp = balloc(B_L, sizeof(websSSL_t));
-		a_assert (wp->wsp);
-	
-		(wp->wsp)->sslConn = sslConn;
-		(wp->wsp)->wp = wp;
-	}
+        wp->wsp = balloc(B_L, sizeof(websSSL_t));
+        a_assert (wp->wsp);
+    
+        (wp->wsp)->sslConn = sslConn;
+        (wp->wsp)->wp = wp;
+    }
     websReadEvent(wp);
     return ret;
 }
@@ -302,22 +302,22 @@ int websSSLIsOpen()
 
 int websSSLWrite(websSSL_t *wsp, char_t *buf, int len)
 {
-	int sslBytesSent = 0;
-	
-	a_assert(wsp);
-	a_assert(buf);
-	
-	if (wsp == NULL) {
-		return -1;
-	}
+    int sslBytesSent = 0;
+    
+    a_assert(wsp);
+    a_assert(buf);
+    
+    if (wsp == NULL) {
+        return -1;
+    }
     /*
         Send on socket. If non-blocking, 0 may be returned from this call,
         indicating that data could not be sent due to EWOULDBLOCK.
      */
-	if ((sslBytesSent = sslWrite(wsp->sslConn, buf, len)) < 0) {
-		sslBytesSent = -1;
-	}
-	return sslBytesSent;
+    if ((sslBytesSent = sslWrite(wsp->sslConn, buf, len)) < 0) {
+        sslBytesSent = -1;
+    }
+    return sslBytesSent;
 }
 
 
@@ -325,9 +325,9 @@ int websSSLEof(websSSL_t *wsp)
 {
     webs_t      wp;
     int         sid;
-	
+    
     a_assert(wsp);
-	
+    
     wp  = wsp->wp;
     sid = wp->sid;
     return socketEof(sid);
@@ -348,9 +348,9 @@ int websSSLFlush(websSSL_t *wsp)
 int websSSLFree(websSSL_t *wsp)
 {
     if (wsp != NULL) {
-		sslWriteClosureAlert(wsp->sslConn);
-		sslFreeConnection(&wsp->sslConn);
-		bfree(B_L, wsp);
+        sslWriteClosureAlert(wsp->sslConn);
+        sslFreeConnection(&wsp->sslConn);
+        bfree(B_L, wsp);
     }
     return 0;
 }
@@ -358,8 +358,8 @@ int websSSLFree(websSSL_t *wsp)
 
 void websSSLClose()
 {
-	matrixSslDeleteKeys(sslKeys);
-	matrixSslClose();
+    matrixSslDeleteKeys(sslKeys);
+    matrixSslClose();
 }
 
 #endif /* WEBS_SSL_SUPPORT */
diff --git a/websSSL.h b/websSSL.h
index 21bb739f..06484801 100644
--- a/websSSL.h
+++ b/websSSL.h
@@ -1,5 +1,5 @@
 /* 
-  	websSSL.h -- MatrixSSL Layer Header
+    websSSL.h -- MatrixSSL Layer Header
 
     Copyright (c) All Rights Reserved. See details at the end of the file.
  */
@@ -18,35 +18,35 @@
 
 /********************************** Defines ***********************************/
 
-#define DEFAULT_CERT_FILE   "./certSrv.pem"		/* Public key certificate */
-#define DEFAULT_KEY_FILE    "./privkeySrv.pem"	/* Private key file */
+#define DEFAULT_CERT_FILE   "./certSrv.pem"     /* Public key certificate */
+#define DEFAULT_KEY_FILE    "./privkeySrv.pem"  /* Private key file */
 
 typedef struct {
-	sslConn_t* sslConn;
-	struct websRec* wp;
+    sslConn_t* sslConn;
+    struct websRec* wp;
 } websSSL_t;
 
 /*************************** User Code Prototypes *****************************/
 
-extern int	websSSLOpen();
-extern int	websSSLIsOpen();
+extern int  websSSLOpen();
+extern int  websSSLIsOpen();
 extern void websSSLClose();
 #ifdef WEBS_WHITELIST_SUPPORT
-extern int	websRequireSSL(char *url);
+extern int  websRequireSSL(char *url);
 #endif /* WEBS_WHITELIST_SUPPORT */
 
 /*************************** Internal Prototypes *****************************/
 
-extern int	websSSLWrite(websSSL_t *wsp, char_t *buf, int nChars);
-extern int	websSSLGets(websSSL_t *wsp, char_t **buf);
-extern int	websSSLRead(websSSL_t *wsp, char_t *buf, int nChars);
-extern int	websSSLEof(websSSL_t *wsp);
+extern int  websSSLWrite(websSSL_t *wsp, char_t *buf, int nChars);
+extern int  websSSLGets(websSSL_t *wsp, char_t **buf);
+extern int  websSSLRead(websSSL_t *wsp, char_t *buf, int nChars);
+extern int  websSSLEof(websSSL_t *wsp);
 
-extern int	websSSLFree(websSSL_t *wsp);
-extern int	websSSLFlush(websSSL_t *wsp);
+extern int  websSSLFree(websSSL_t *wsp);
+extern int  websSSLFlush(websSSL_t *wsp);
 
-extern int	websSSLSetKeyFile(char_t *keyFile);
-extern int	websSSLSetCertFile(char_t *certFile);
+extern int  websSSLSetKeyFile(char_t *keyFile);
+extern int  websSSLSetCertFile(char_t *certFile);
 
 #endif /* WEBS_SSL_SUPPORT */
 
diff --git a/websda.c b/websda.c
index ce1e2bdf..e3ba5ece 100644
--- a/websda.c
+++ b/websda.c
@@ -7,103 +7,103 @@
 /******************************** Description *********************************/
 
 /*
- *	Routines for generating DAA data.
+ *  Routines for generating DAA data.
  */
 
 /********************************* Includes ***********************************/
 
 //  MOB - move to headers
 #ifndef CE
-#include	<time.h>
+#include    <time.h>
 #endif
-#include	"websda.h"
-#include	"md5.h"
+#include    "websda.h"
+#include    "md5.h"
 
 #ifdef DIGEST_ACCESS_SUPPORT
 /******************************** Local Data **********************************/
 
-#define RANDOMKEY	T("onceuponatimeinparadise")
-#define NONCE_SIZE	34
+#define RANDOMKEY   T("onceuponatimeinparadise")
+#define NONCE_SIZE  34
 #define HASH_SIZE   16
 
 /*********************************** Code *************************************/
 /*
-  	websMD5binary returns the MD5 hash
+    websMD5binary returns the MD5 hash
  */
 
 char *websMD5binary(unsigned char *buf, int length)
 {
-    const char		*hex = "0123456789abcdef";
-    psDigestContext_t	md5ctx;
-    unsigned char	hash[HASH_SIZE];
-    char			*r, *strReturn;
-	char			result[(HASH_SIZE * 2) + 1];
-    int				i;
+    const char      *hex = "0123456789abcdef";
+    psDigestContext_t   md5ctx;
+    unsigned char   hash[HASH_SIZE];
+    char            *r, *strReturn;
+    char            result[(HASH_SIZE * 2) + 1];
+    int             i;
 
     /*
-      	Take the MD5 hash of the string argument.
+        Take the MD5 hash of the string argument.
      */
-	psMd5Init(&md5ctx);
-	psMd5Update(&md5ctx, buf, (unsigned int)length);
-	psMd5Final(&md5ctx, hash);
+    psMd5Init(&md5ctx);
+    psMd5Update(&md5ctx, buf, (unsigned int)length);
+    psMd5Final(&md5ctx, hash);
 
     /*
-      	Prepare the resulting hash string
+        Prepare the resulting hash string
      */
     for (i = 0, r = result; i < 16; i++) {
-		*r++ = hex[hash[i] >> 4];
-		*r++ = hex[hash[i] & 0xF];
+        *r++ = hex[hash[i] >> 4];
+        *r++ = hex[hash[i] & 0xF];
     }
     /*
-      	Zero terminate the hash string
+        Zero terminate the hash string
      */
     *r = '\0';
 
     /*
-      	Allocate a new copy of the hash string
+        Allocate a new copy of the hash string
      */
-	i = elementsof(result);
-	strReturn = balloc(B_L, i);
-	strncpy(strReturn, result, i);
+    i = elementsof(result);
+    strReturn = balloc(B_L, i);
+    strncpy(strReturn, result, i);
 
     return strReturn;
 }
 
 /*
-  	Convenience call to websMD5binary (Performs char_t to char conversion and back)
+    Convenience call to websMD5binary (Performs char_t to char conversion and back)
  */
 char_t *websMD5(char_t *string)
 {
-	char_t	*strReturn;
+    char_t  *strReturn;
 
-	a_assert(string && *string);
+    a_assert(string && *string);
 
-	if (string && *string) {
-		char	*strTemp, *strHash;
-		int		nLen;
+    if (string && *string) {
+        char    *strTemp, *strHash;
+        int     nLen;
         /*
             Convert input char_t string to char string
          */
-		nLen = gstrlen(string);
-		strTemp = ballocUniToAsc(string, nLen + 1);
+        nLen = gstrlen(string);
+        strTemp = ballocUniToAsc(string, nLen + 1);
         /*
             Execute the digest calculation
          */
-		strHash = websMD5binary((unsigned char *)strTemp, nLen);
+        strHash = websMD5binary((unsigned char *)strTemp, nLen);
         /*
             Convert the returned char string digest to a char_t string
          */
-		nLen = strlen(strHash);
-		strReturn = ballocAscToUni(strHash, nLen);
+        nLen = strlen(strHash);
+        strReturn = ballocAscToUni(strHash, nLen);
         /*
             Free up the temporary allocated resources
          */
-		bfree(B_L, strTemp);
-		bfree(B_L, strHash);
-	} else {
-		strReturn = NULL;
-	}
-	return strReturn;
+        bfree(B_L, strTemp);
+        bfree(B_L, strHash);
+    } else {
+        strReturn = NULL;
+    }
+    return strReturn;
 }
 
 
@@ -113,105 +113,105 @@ char_t *websMD5(char_t *string)
  */
 char_t *websCalcNonce(webs_t wp)
 {
-	char_t		*nonce, *prenonce;
-	time_t		longTime;
+    char_t      *nonce, *prenonce;
+    time_t      longTime;
 #if defined(WIN32)
-	char_t		buf[26];
-	errno_t	error;
-	struct tm	newtime;
+    char_t      buf[26];
+    errno_t error;
+    struct tm   newtime;
 #else
-	struct tm	*newtime;
+    struct tm   *newtime;
 #endif
 
-	a_assert(wp);
-	time(&longTime);
+    a_assert(wp);
+    time(&longTime);
 #if !defined(WIN32)
-	newtime = localtime(&longTime);
+    newtime = localtime(&longTime);
 #else
-	error = localtime_s(&newtime, &longTime);
+    error = localtime_s(&newtime, &longTime);
 #endif
 
 #if !defined(WIN32)
-	prenonce = NULL;
-	fmtAlloc(&prenonce, 256, T("%s:%s:%s"), RANDOMKEY, gasctime(newtime), wp->realm); 
+    prenonce = NULL;
+    fmtAlloc(&prenonce, 256, T("%s:%s:%s"), RANDOMKEY, gasctime(newtime), wp->realm); 
 #else
-	asctime_s(buf, elementsof(buf), &newtime);
-	fmtAlloc(&prenonce, 256, T("%s:%s:%s"), RANDOMKEY, buf, RANDOMKEY); 
+    asctime_s(buf, elementsof(buf), &newtime);
+    fmtAlloc(&prenonce, 256, T("%s:%s:%s"), RANDOMKEY, buf, RANDOMKEY); 
 #endif
 
-	a_assert(prenonce);
+    a_assert(prenonce);
     nonce = websMD5(prenonce);
-	bfreeSafe(B_L, prenonce);
-	return nonce;
+    bfreeSafe(B_L, prenonce);
+    return nonce;
 }
 
 
 /*
-  	Get an Opaque value for passing along to the client
+    Get an Opaque value for passing along to the client
  */
 char_t *websCalcOpaque(webs_t wp)
 {
-	char_t *opaque;
-	a_assert(wp);
+    char_t *opaque;
+    a_assert(wp);
     /*
-      	MOB ??? Temporary stub!
+        MOB ??? Temporary stub!
      */
     opaque = bstrdup(B_L, T("5ccc069c403ebaf9f0171e9517f40e41"));
-	return opaque;
+    return opaque;
 }
 
 
 /*
-  	Get a Digest value using the MD5 algorithm
+    Get a Digest value using the MD5 algorithm
  */
 char_t *websCalcDigest(webs_t wp)
 {
-	char_t	*digest, *a1, *a1prime, *a2, *a2prime, *preDigest, *method;
+    char_t  *digest, *a1, *a1prime, *a2, *a2prime, *preDigest, *method;
 
-	a_assert(wp);
-	digest = NULL;
+    a_assert(wp);
+    digest = NULL;
 
     /*
-      	Calculate first portion of digest H(A1)
+        Calculate first portion of digest H(A1)
      */
-	a1 = NULL;
-	fmtAlloc(&a1, 255, T("%s:%s:%s"), wp->userName, wp->realm, wp->password);
-	a_assert(a1);
-	a1prime = websMD5(a1);
-	bfreeSafe(B_L, a1);
+    a1 = NULL;
+    fmtAlloc(&a1, 255, T("%s:%s:%s"), wp->userName, wp->realm, wp->password);
+    a_assert(a1);
+    a1prime = websMD5(a1);
+    bfreeSafe(B_L, a1);
 
     /*
         Calculate second portion of digest H(A2)
      */
-	method = websGetVar(wp, T("REQUEST_METHOD"), NULL);
-	a_assert(method);
-	a2 = NULL;
-	fmtAlloc(&a2, 255, T("%s:%s"), method, wp->uri); 
-	a_assert(a2);
-	a2prime = websMD5(a2);
-	bfreeSafe(B_L, a2);
+    method = websGetVar(wp, T("REQUEST_METHOD"), NULL);
+    a_assert(method);
+    a2 = NULL;
+    fmtAlloc(&a2, 255, T("%s:%s"), method, wp->uri); 
+    a_assert(a2);
+    a2prime = websMD5(a2);
+    bfreeSafe(B_L, a2);
 
     /*
         Construct final digest KD(H(A1):nonce:H(A2))
      */
-	a_assert(a1prime);
-	a_assert(a2prime);
-	a_assert(wp->nonce);
-
-	preDigest = NULL;
-	if (!wp->qop) {
-		fmtAlloc(&preDigest, 255, T("%s:%s:%s"), a1prime, wp->nonce, a2prime);
-	} else {
-		fmtAlloc(&preDigest, 255, T("%s:%s:%s:%s:%s:%s"), 
-			a1prime, wp->nonce, wp->nc, wp->cnonce, wp->qop, a2prime);
-	}
-
-	a_assert(preDigest);
-	digest = websMD5(preDigest);
-	bfreeSafe(B_L, a1prime);
-	bfreeSafe(B_L, a2prime);
-	bfreeSafe(B_L, preDigest);
-	return digest;
+    a_assert(a1prime);
+    a_assert(a2prime);
+    a_assert(wp->nonce);
+
+    preDigest = NULL;
+    if (!wp->qop) {
+        fmtAlloc(&preDigest, 255, T("%s:%s:%s"), a1prime, wp->nonce, a2prime);
+    } else {
+        fmtAlloc(&preDigest, 255, T("%s:%s:%s:%s:%s:%s"), 
+            a1prime, wp->nonce, wp->nc, wp->cnonce, wp->qop, a2prime);
+    }
+
+    a_assert(preDigest);
+    digest = websMD5(preDigest);
+    bfreeSafe(B_L, a1prime);
+    bfreeSafe(B_L, a2prime);
+    bfreeSafe(B_L, preDigest);
+    return digest;
 }
 
 
@@ -221,54 +221,54 @@ char_t *websCalcDigest(webs_t wp)
  */
 char_t *websCalcUrlDigest(webs_t wp)
 {
-	char_t	*digest, *a1, *a1prime, *a2, *a2prime, *preDigest, *method;
+    char_t  *digest, *a1, *a1prime, *a2, *a2prime, *preDigest, *method;
 
-	a_assert(wp);
-	digest = NULL;
+    a_assert(wp);
+    digest = NULL;
 
     /*
-      	Calculate first portion of digest H(A1)
+        Calculate first portion of digest H(A1)
      */
-	a1 = NULL;
-	fmtAlloc(&a1, 255, T("%s:%s:%s"), wp->userName, wp->realm, wp->password);
-	a_assert(a1);
-	a1prime = websMD5(a1);
-	bfreeSafe(B_L, a1);
+    a1 = NULL;
+    fmtAlloc(&a1, 255, T("%s:%s:%s"), wp->userName, wp->realm, wp->password);
+    a_assert(a1);
+    a1prime = websMD5(a1);
+    bfreeSafe(B_L, a1);
 
     /*
-      	Calculate second portion of digest H(A2)
+        Calculate second portion of digest H(A2)
      */
-	method = websGetVar(wp, T("REQUEST_METHOD"), NULL);
-	a_assert(method);
-	a2 = balloc(B_L, (gstrlen(method) +2 + gstrlen(wp->url) ) * sizeof(char_t));
-	a_assert(a2);
-	gsprintf(a2, T("%s:%s"), method, wp->url);
-	a2prime = websMD5(a2);
-	bfreeSafe(B_L, a2);
+    method = websGetVar(wp, T("REQUEST_METHOD"), NULL);
+    a_assert(method);
+    a2 = balloc(B_L, (gstrlen(method) +2 + gstrlen(wp->url) ) * sizeof(char_t));
+    a_assert(a2);
+    gsprintf(a2, T("%s:%s"), method, wp->url);
+    a2prime = websMD5(a2);
+    bfreeSafe(B_L, a2);
 
     /*
-      	Construct final digest KD(H(A1):nonce:H(A2))
+        Construct final digest KD(H(A1):nonce:H(A2))
      */
-	a_assert(a1prime);
-	a_assert(a2prime);
-	a_assert(wp->nonce);
-
-	preDigest = NULL;
-	if (!wp->qop) {
-		fmtAlloc(&preDigest, 255, T("%s:%s:%s"), a1prime, wp->nonce, a2prime);
-	} else {
-		fmtAlloc(&preDigest, 255, T("%s:%s:%s:%s:%s:%s"), 
-			a1prime, wp->nonce, wp->nc, wp->cnonce, wp->qop, a2prime);
-	}
-	a_assert(preDigest);
-	digest = websMD5(preDigest);
+    a_assert(a1prime);
+    a_assert(a2prime);
+    a_assert(wp->nonce);
+
+    preDigest = NULL;
+    if (!wp->qop) {
+        fmtAlloc(&preDigest, 255, T("%s:%s:%s"), a1prime, wp->nonce, a2prime);
+    } else {
+        fmtAlloc(&preDigest, 255, T("%s:%s:%s:%s:%s:%s"), 
+            a1prime, wp->nonce, wp->nc, wp->cnonce, wp->qop, a2prime);
+    }
+    a_assert(preDigest);
+    digest = websMD5(preDigest);
     /*
-      	Now clean up
+        Now clean up
      */
-	bfreeSafe(B_L, a1prime);
-	bfreeSafe(B_L, a2prime);
-	bfreeSafe(B_L, preDigest);
-	return digest;
+    bfreeSafe(B_L, a1prime);
+    bfreeSafe(B_L, a2prime);
+    bfreeSafe(B_L, preDigest);
+    return digest;
 }
 
 #endif /* DIGEST_ACCESS_SUPPORT */
diff --git a/websda.h b/websda.h
index 1f28fbb1..0fc829a0 100644
--- a/websda.h
+++ b/websda.h
@@ -1,5 +1,5 @@
 /* 
-  	websda.h -- GoAhead Digest Access Authentication public header
+    websda.h -- GoAhead Digest Access Authentication public header
   
     Copyright (c) All Rights Reserved. See details at the end of the file.
  */
@@ -9,15 +9,15 @@
 
 /********************************* Includes ***********************************/
 
-#include	"uemf.h"
-#include	"webs.h"
+#include    "uemf.h"
+#include    "webs.h"
 
 /****************************** Definitions ***********************************/
 
-extern char_t 	*websCalcNonce(webs_t wp);
-extern char_t 	*websCalcOpaque(webs_t wp);
-extern char_t 	*websCalcDigest(webs_t wp);
-extern char_t 	*websCalcUrlDigest(webs_t wp);
+extern char_t   *websCalcNonce(webs_t wp);
+extern char_t   *websCalcOpaque(webs_t wp);
+extern char_t   *websCalcDigest(webs_t wp);
+extern char_t   *websCalcUrlDigest(webs_t wp);
 
 #endif /* _h_WEBSDA */
 
diff --git a/websuemf.c b/websuemf.c
index 40c244af..95cd8167 100644
--- a/websuemf.c
+++ b/websuemf.c
@@ -6,44 +6,44 @@
 
 /*********************************** Includes *********************************/
 
-#include	"ejIntrn.h"
-#include	"wsIntrn.h"
+#include    "ejIntrn.h"
+#include    "wsIntrn.h"
 
 /*********************************** Defines **********************************/
 
 /*
- *	This structure stores scheduled events.
+ *  This structure stores scheduled events.
  */
 typedef struct {
-	void	(*routine)(void *arg, int id);
-	void	*arg;
-	time_t	at;
-	int		schedid;
+    void    (*routine)(void *arg, int id);
+    void    *arg;
+    time_t  at;
+    int     schedid;
 } sched_t;
 
 /*********************************** Locals ***********************************/
 
-static sched_t		**sched;
-static int			schedMax;
+static sched_t      **sched;
+static int          schedMax;
 
 /************************************* Code ***********************************/
 /*
-  	Evaluate a script
+    Evaluate a script
  */
 
 int scriptEval(int engine, char_t *cmd, char_t **result, void* chan)
 {
-	int		ejid;
-
-	if (engine == EMF_SCRIPT_EJSCRIPT) {
-		ejid = (int) chan;
-		if (ejEval(ejid, cmd, result) ) {
-			return 0;
-		} else {
-			return -1;
-		}
-	}
-	return -1;
+    int     ejid;
+
+    if (engine == EMF_SCRIPT_EJSCRIPT) {
+        ejid = (int) chan;
+        if (ejEval(ejid, cmd, result) ) {
+            return 0;
+        } else {
+            return -1;
+        }
+    }
+    return -1;
 }
 
 /*
@@ -54,137 +54,137 @@ int scriptEval(int engine, char_t *cmd, char_t **result, void* chan)
  */
 int strcmpci(char_t *s1, char_t *s2)
 {
-	int		rc;
-
-	a_assert(s1 && s2);
-	if (s1 == NULL || s2 == NULL) {
-		return 0;
-	}
-
-	if (s1 == s2) {
-		return 0;
-	}
-
-	do {
-		rc = gtolower(*s1) - gtolower(*s2);
-		if (*s1 == '\0') {
-			break;
-		}
-		s1++;
-		s2++;
-	} while (rc == 0);
-	return rc;
+    int     rc;
+
+    a_assert(s1 && s2);
+    if (s1 == NULL || s2 == NULL) {
+        return 0;
+    }
+
+    if (s1 == s2) {
+        return 0;
+    }
+
+    do {
+        rc = gtolower(*s1) - gtolower(*s2);
+        if (*s1 == '\0') {
+            break;
+        }
+        s1++;
+        s2++;
+    } while (rc == 0);
+    return rc;
 }
 
 
 /*
-  	This function is called when a scheduled process time has come.
+    This function is called when a scheduled process time has come.
     MOB - why caps?  Static?
  */
 void TimerProc(int schedid)
 {
-	sched_t	*s;
+    sched_t *s;
 
-	a_assert(0 <= schedid && schedid < schedMax);
-	s = sched[schedid];
-	a_assert(s);
+    a_assert(0 <= schedid && schedid < schedMax);
+    s = sched[schedid];
+    a_assert(s);
 
-	(s->routine)(s->arg, s->schedid);
+    (s->routine)(s->arg, s->schedid);
 }
 
 
 /*
-  	Schedule an event in delay milliseconds time. We will use 1 second granularity for webServer.
+    Schedule an event in delay milliseconds time. We will use 1 second granularity for webServer.
  */
 int emfSchedCallback(int delay, emfSchedProc *proc, void *arg)
 {
-	sched_t	*s;
-	int		schedid;
-
-	if ((schedid = hAllocEntry((void***) &sched, &schedMax,
-		sizeof(sched_t))) < 0) {
-		return -1;
-	}
-	s = sched[schedid];
-	s->routine = proc;
-	s->arg = arg;
-	s->schedid = schedid;
+    sched_t *s;
+    int     schedid;
+
+    if ((schedid = hAllocEntry((void***) &sched, &schedMax,
+        sizeof(sched_t))) < 0) {
+        return -1;
+    }
+    s = sched[schedid];
+    s->routine = proc;
+    s->arg = arg;
+    s->schedid = schedid;
 
     /*
-      	Round the delay up to seconds.
+        Round the delay up to seconds.
      */
-	s->at = ((delay + 500) / 1000) + time(0);
-	return schedid;
+    s->at = ((delay + 500) / 1000) + time(0);
+    return schedid;
 }
 
 
 /*
-  	Reschedule to a new delay.
+    Reschedule to a new delay.
  */
 void emfReschedCallback(int schedid, int delay)
 {
-	sched_t	*s;
+    sched_t *s;
 
-	if (sched == NULL || schedid == -1 || schedid >= schedMax || (s = sched[schedid]) == NULL) {
-		return;
-	}
-	s->at = ((delay + 500) / 1000) + time(0);
+    if (sched == NULL || schedid == -1 || schedid >= schedMax || (s = sched[schedid]) == NULL) {
+        return;
+    }
+    s->at = ((delay + 500) / 1000) + time(0);
 }
 
 
 void emfUnschedCallback(int schedid)
 {
-	sched_t	*s;
+    sched_t *s;
 
-	if (sched == NULL || schedid == -1 || schedid >= schedMax || (s = sched[schedid]) == NULL) {
-		return;
-	}
-	bfree(B_L, s);
-	schedMax = hFree((void***) &sched, schedid);
+    if (sched == NULL || schedid == -1 || schedid >= schedMax || (s = sched[schedid]) == NULL) {
+        return;
+    }
+    bfree(B_L, s);
+    schedMax = hFree((void***) &sched, schedid);
 }
 
 
 /*
-  	Take tasks off the queue in a round robin fashion.
+    Take tasks off the queue in a round robin fashion.
  */
 void emfSchedProcess()
 {
-	sched_t		*s;
-	int			schedid;
-	static int	next = 0;	
+    sched_t     *s;
+    int         schedid;
+    static int  next = 0;   
 
     /*
         If schedMax is 0, there are no tasks scheduled, so just return.
      */
-	if (schedMax <= 0) {
-		return;
-	}
+    if (schedMax <= 0) {
+        return;
+    }
 
     /*
-      	If next >= schedMax, the schedule queue was reduced in our absence
-      	so reset next to 0 to start from the begining of the queue again.
+        If next >= schedMax, the schedule queue was reduced in our absence
+        so reset next to 0 to start from the begining of the queue again.
      */
-	if (next >= schedMax) {
-		next = 0;
-	}
-
-	schedid = next;
-	for (;;) {
-		if ((s = sched[schedid]) != NULL &&	(int)s->at <= (int)time(0)) {
-			TimerProc(schedid);
-			next = schedid + 1;
-			return;
-		}
-		if (++schedid >= schedMax) {
-			schedid = 0;
-		}
-		if (schedid == next) {
+    if (next >= schedMax) {
+        next = 0;
+    }
+
+    schedid = next;
+    for (;;) {
+        if ((s = sched[schedid]) != NULL && (int)s->at <= (int)time(0)) {
+            TimerProc(schedid);
+            next = schedid + 1;
+            return;
+        }
+        if (++schedid >= schedMax) {
+            schedid = 0;
+        }
+        if (schedid == next) {
             /*
                 We've gone all the way through the queue without finding anything to do so just return.
              */
-			return;
-		}
-	}
+            return;
+        }
+    }
 }
 
 /*
diff --git a/wsIntrn.h b/wsIntrn.h
index ac8cbbcd..53f19449 100644
--- a/wsIntrn.h
+++ b/wsIntrn.h
@@ -1,5 +1,5 @@
 /* 
-  	wsIntrn.h -- Internal GoAhead Web server header
+    wsIntrn.h -- Internal GoAhead Web server header
   
     Copyright (c) All Rights Reserved. See details at the end of the file.
  */
@@ -10,255 +10,255 @@
 /******************************** Description *********************************/
 
 /* 
- *	Internal GoAhead Web Server header. This defines the Web private APIs
- *	Include this header when you want to create URL handlers.
+ *  Internal GoAhead Web Server header. This defines the Web private APIs
+ *  Include this header when you want to create URL handlers.
  */
 
 /*********************************** Defines **********************************/
 
 /********************************** Includes **********************************/
 
-#include	<ctype.h>
-#include	<stdlib.h>
-#include	<string.h>
-#include	<stdarg.h>
+#include    <ctype.h>
+#include    <stdlib.h>
+#include    <string.h>
+#include    <stdarg.h>
 
 #ifdef NETWARE
-	#include	<fcntl.h>
-	#include	<sys/stat.h>
-	#include	<signal.h>
-	#include	<io.h>
+    #include    <fcntl.h>
+    #include    <sys/stat.h>
+    #include    <signal.h>
+    #include    <io.h>
 #endif
 
 #ifdef WIN
-	#include	<fcntl.h>
-	#include	<sys/stat.h>
-	#include	<io.h>
-#define localtime_r(A, B)	localtime_s(B,A)
-	#include	<share.h>
-#define snprintf			_snprintf
+    #include    <fcntl.h>
+    #include    <sys/stat.h>
+    #include    <io.h>
+#define localtime_r(A, B)   localtime_s(B,A)
+    #include    <share.h>
+#define snprintf            _snprintf
 #endif
 
 #ifdef NW
-	#include	<fcntl.h>
-	#include	<sys/stat.h>
+    #include    <fcntl.h>
+    #include    <sys/stat.h>
 #endif
 
 #ifdef SCOV5
-	#include	<fcntl.h>
-	#include	<sys/stat.h>
-	#include	<signal.h>
-	#include	<unistd.h>
+    #include    <fcntl.h>
+    #include    <sys/stat.h>
+    #include    <signal.h>
+    #include    <unistd.h>
 #endif
 
 #ifdef LYNX
-	#include	<fcntl.h>
-	#include	<sys/stat.h>
-	#include	<signal.h>
-	#include	<unistd.h>
+    #include    <fcntl.h>
+    #include    <sys/stat.h>
+    #include    <signal.h>
+    #include    <unistd.h>
 #endif
 
 #ifdef UNIX
-	#include	<fcntl.h>
-	#include	<sys/stat.h>
-	#include	<signal.h>
-	#include	<unistd.h>
+    #include    <fcntl.h>
+    #include    <sys/stat.h>
+    #include    <signal.h>
+    #include    <unistd.h>
 #endif
 
 #ifdef QNX4
-	#include	<fcntl.h>
-	#include	<sys/stat.h>
-	#include	<signal.h>
-	#include	<unistd.h>
-	#include	<unix.h>
+    #include    <fcntl.h>
+    #include    <sys/stat.h>
+    #include    <signal.h>
+    #include    <unistd.h>
+    #include    <unix.h>
 #endif
 
 #ifdef UW
-	#include	<fcntl.h>
-	#include	<sys/stat.h>
+    #include    <fcntl.h>
+    #include    <sys/stat.h>
 #endif
 
 #ifdef VXWORKS
-	#include	<vxWorks.h>
-	#include	<fcntl.h>
-	#include	<sys/stat.h>
+    #include    <vxWorks.h>
+    #include    <fcntl.h>
+    #include    <sys/stat.h>
 #endif
 
 #ifdef SOLARIS
-	#include	<macros.h>
-	#include	<fcntl.h>
-	#include	<sys/stat.h>
+    #include    <macros.h>
+    #include    <fcntl.h>
+    #include    <sys/stat.h>
 #endif
 
-#include	"uemf.h"
-#include	"ejIntrn.h"
-#include	"webs.h"
+#include    "uemf.h"
+#include    "ejIntrn.h"
+#include    "webs.h"
 
 /********************************** Defines ***********************************/
 /* 
- *	Read handler flags and state
+ *  Read handler flags and state
  */
-#define WEBS_BEGIN			0x1			/* Beginning state */
-#define WEBS_HEADER			0x2			/* Ready to read first line */
-#define WEBS_POST			0x4			/* POST without content */
-#define WEBS_POST_CLEN		0x8			/* Ready to read content for POST */
-#define WEBS_PROCESSING		0x10		/* Processing request */
-#define WEBS_KEEP_TIMEOUT	15000		/* Keep-alive timeout (15 secs) */
-#define WEBS_TIMEOUT		60000		/* General request timeout (60) */
-
-#define PAGE_READ_BUFSIZE	512			/* bytes read from page files */
-#define MAX_PORT_LEN		10			/* max digits in port number */
-#define WEBS_SYM_INIT		64			/* initial # of sym table entries */
+#define WEBS_BEGIN          0x1         /* Beginning state */
+#define WEBS_HEADER         0x2         /* Ready to read first line */
+#define WEBS_POST           0x4         /* POST without content */
+#define WEBS_POST_CLEN      0x8         /* Ready to read content for POST */
+#define WEBS_PROCESSING     0x10        /* Processing request */
+#define WEBS_KEEP_TIMEOUT   15000       /* Keep-alive timeout (15 secs) */
+#define WEBS_TIMEOUT        60000       /* General request timeout (60) */
+
+#define PAGE_READ_BUFSIZE   512         /* bytes read from page files */
+#define MAX_PORT_LEN        10          /* max digits in port number */
+#define WEBS_SYM_INIT       64          /* initial # of sym table entries */
 
 /*
- *	URL handler structure. Stores the leading URL path and the handler
- *	function to call when the URL path is seen.
+ *  URL handler structure. Stores the leading URL path and the handler
+ *  function to call when the URL path is seen.
  */ 
 typedef struct {
-	int		(*handler)(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, 
-			char_t *url, char_t *path, 
-			char_t *query);					/* Callback URL handler function */
-	char_t	*webDir;						/* Web directory if required */
-	char_t	*urlPrefix;						/* URL leading prefix */
-	int		len;							/* Length of urlPrefix for speed */
-	int		arg;							/* Argument to provide to handler */
-	int		flags;							/* Flags */
+    int     (*handler)(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, 
+            char_t *url, char_t *path, 
+            char_t *query);                 /* Callback URL handler function */
+    char_t  *webDir;                        /* Web directory if required */
+    char_t  *urlPrefix;                     /* URL leading prefix */
+    int     len;                            /* Length of urlPrefix for speed */
+    int     arg;                            /* Argument to provide to handler */
+    int     flags;                          /* Flags */
 } websUrlHandlerType;
 
 /* 
- *	Webs statistics
+ *  Webs statistics
  */
 typedef struct {
-	long			errors;					/* General errors */
-	long			redirects;
-	long			net_requests;
-	long			activeNetRequests;
-	long			activeBrowserRequests;
-	long 			timeouts;
-	long			access;					/* Access violations */
-	long 			localHits;
-	long 			remoteHits;
-	long 			formHits;
-	long 			cgiHits;
-	long 			handlerHits;
+    long            errors;                 /* General errors */
+    long            redirects;
+    long            net_requests;
+    long            activeNetRequests;
+    long            activeBrowserRequests;
+    long            timeouts;
+    long            access;                 /* Access violations */
+    long            localHits;
+    long            remoteHits;
+    long            formHits;
+    long            cgiHits;
+    long            handlerHits;
 } websStatsType;
 
-extern websStatsType websStats;				/* Web access stats */
+extern websStatsType websStats;             /* Web access stats */
 
 /* 
- *	Error code list
+ *  Error code list
  */
 typedef struct {
-	int		code;							/* HTTP error code */
-	char_t	*msg;							/* HTTP error message */
+    int     code;                           /* HTTP error code */
+    char_t  *msg;                           /* HTTP error message */
 } websErrorType;
 
 /* 
- *	Mime type list
+ *  Mime type list
  */
 typedef struct {
-	char_t	*type;							/* Mime type */
-	char_t	*ext;							/* File extension */
+    char_t  *type;                          /* Mime type */
+    char_t  *ext;                           /* File extension */
 } websMimeType;
 
 /*
- *	File information structure.
+ *  File information structure.
  */
 typedef struct {
-	unsigned long	size;					/* File length */
-	int				isDir;					/* Set if directory */
-	time_t			mtime;					/* Modified time */
+    unsigned long   size;                   /* File length */
+    int             isDir;                  /* Set if directory */
+    time_t          mtime;                  /* Modified time */
 } websStatType;
 
 /*
- *	Compiled Rom Page Index
+ *  Compiled Rom Page Index
  */
 typedef struct {
-	char_t			*path;					/* Web page URL path */
-	unsigned char	*page;					/* Web page data */
-	int				size;					/* Size of web page in bytes */
-	int				pos;					/* Current read position */
+    char_t          *path;                  /* Web page URL path */
+    unsigned char   *page;                  /* Web page data */
+    int             size;                   /* Size of web page in bytes */
+    int             pos;                    /* Current read position */
 } websRomPageIndexType;
 
 /*
- *	Defines for file open.
+ *  Defines for file open.
  */
 #ifndef CE
-#define	SOCKET_RDONLY	O_RDONLY
-#define	SOCKET_BINARY	O_BINARY
+#define SOCKET_RDONLY   O_RDONLY
+#define SOCKET_BINARY   O_BINARY
 #else /* CE */
-#define	SOCKET_RDONLY	0x1
-#define	SOCKET_BINARY	0x2
+#define SOCKET_RDONLY   0x1
+#define SOCKET_BINARY   0x2
 #endif /* CE */
 
-extern websRomPageIndexType	websRomPageIndex[];
-extern websMimeType		websMimeList[];		/* List of mime types */
-extern sym_fd_t			websMime;			/* Set of mime types */
-extern webs_t*			webs;				/* Session list head */
-extern int				websMax;			/* List size */
-extern char_t			websHost[64];		/* Name of this host */
-extern char_t			websIpaddr[64];		/* IP address of this host */
-extern char_t			*websHostUrl;		/* URL for this host */
-extern char_t			*websIpaddrUrl;		/* URL for this host */
-extern int				websPort;			/* Port number */
+extern websRomPageIndexType websRomPageIndex[];
+extern websMimeType     websMimeList[];     /* List of mime types */
+extern sym_fd_t         websMime;           /* Set of mime types */
+extern webs_t*          webs;               /* Session list head */
+extern int              websMax;            /* List size */
+extern char_t           websHost[64];       /* Name of this host */
+extern char_t           websIpaddr[64];     /* IP address of this host */
+extern char_t           *websHostUrl;       /* URL for this host */
+extern char_t           *websIpaddrUrl;     /* URL for this host */
+extern int              websPort;           /* Port number */
 
 /******************************** Prototypes **********************************/
 
-extern int		 websAspOpen();
-extern void		 websAspClose();
-extern void		 websFormOpen();
-extern void		 websFormClose();
-extern int		 websAspWrite(int ejid, webs_t wp, int argc, char_t **argv);
+extern int       websAspOpen();
+extern void      websAspClose();
+extern void      websFormOpen();
+extern void      websFormClose();
+extern int       websAspWrite(int ejid, webs_t wp, int argc, char_t **argv);
 
-extern void  	 websDefaultOpen();
-extern void  	 websDefaultClose();
+extern void      websDefaultOpen();
+extern void      websDefaultClose();
 
 #ifdef WEBS_WHITELIST_SUPPORT
 #define WHITELIST_SSL 0x001   /* File only accessible through https */
 #define WHITELIST_CGI 0x002   /* Node is in the cgi-bin dir */
-extern int		websBuildWhitelist(void);
-extern int		websWhitelistCheck(char *path);
-extern void		websDeleteWhitelist(void);
+extern int      websBuildWhitelist(void);
+extern int      websWhitelistCheck(char *path);
+extern void     websDeleteWhitelist(void);
 #endif /* WEBS_WHITELIST_SUPPORT */
 
-extern int 		 websDefaultHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t *url, char_t *path, 
-					char_t *query);
-extern int 		 websFormHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t *url, char_t *path, char_t *query);
-extern int 		 websCgiHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
-					int arg, char_t *url, char_t *path, char_t *query);
-extern void		 websCgiCleanup();
-extern int		 websCheckCgiProc(int handle);
-extern char_t	 *websGetCgiCommName();
-
-extern int		 websLaunchCgiProc(char_t *cgiPath, char_t **argp, char_t **envp, char_t *stdIn, char_t *stdOut);
-extern int 		 websOpen(int sid);
-extern void 	 websResponse(webs_t wp, int code, char_t *msg, char_t *redirect);
-extern int 		 websJavaScriptEval(webs_t wp, char_t *script);
-extern int 		 websPageReadData(webs_t wp, char *buf, int nBytes);
-extern int		 websPageOpen(webs_t wp, char_t *lpath, char_t *path, int mode, int perm);
-extern void		 websPageClose(webs_t wp);
-extern void		 websPageSeek(webs_t wp, long offset);
-extern int 	 	 websPageStat(webs_t wp, char_t *lpath, char_t *path, websStatType *sbuf);
-extern int		 websPageIsDirectory(char_t *lpath);
-extern int 		 websRomOpen();
-extern void		 websRomClose();
-extern int 		 websRomPageOpen(webs_t wp, char_t *path, int mode, int perm);
-extern void 	 websRomPageClose(int fd);
-extern int 		 websRomPageReadData(webs_t wp, char *buf, int len);
-extern int 	 	 websRomPageStat(char_t *path, websStatType *sbuf);
-extern long		 websRomPageSeek(webs_t wp, long offset, int origin);
-extern void 	 websSetRequestSocketHandler(webs_t wp, int mask, 
-					void (*fn)(webs_t wp));
-extern int 		 websSolutionHandler(webs_t wp, char_t *urlPrefix,
-					char_t *webDir, int arg, char_t *url, char_t *path, 
-					char_t *query);
-extern void 	 websUrlHandlerClose();
-extern int 		 websUrlHandlerOpen();
-extern int 		 websOpenServer(int port, int retries);
-extern void 	 websCloseServer();
-extern char_t*	 websGetDateString(websStatType* sbuf);
-
-extern int		strcmpci(char_t* s1, char_t* s2);
+extern int       websDefaultHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t *url, char_t *path, 
+                    char_t *query);
+extern int       websFormHandler(webs_t wp, char_t *urlPrefix, char_t *webDir, int arg, char_t *url, char_t *path, char_t *query);
+extern int       websCgiHandler(webs_t wp, char_t *urlPrefix, char_t *webDir,
+                    int arg, char_t *url, char_t *path, char_t *query);
+extern void      websCgiCleanup();
+extern int       websCheckCgiProc(int handle);
+extern char_t    *websGetCgiCommName();
+
+extern int       websLaunchCgiProc(char_t *cgiPath, char_t **argp, char_t **envp, char_t *stdIn, char_t *stdOut);
+extern int       websOpen(int sid);
+extern void      websResponse(webs_t wp, int code, char_t *msg, char_t *redirect);
+extern int       websJavaScriptEval(webs_t wp, char_t *script);
+extern int       websPageReadData(webs_t wp, char *buf, int nBytes);
+extern int       websPageOpen(webs_t wp, char_t *lpath, char_t *path, int mode, int perm);
+extern void      websPageClose(webs_t wp);
+extern void      websPageSeek(webs_t wp, long offset);
+extern int       websPageStat(webs_t wp, char_t *lpath, char_t *path, websStatType *sbuf);
+extern int       websPageIsDirectory(char_t *lpath);
+extern int       websRomOpen();
+extern void      websRomClose();
+extern int       websRomPageOpen(webs_t wp, char_t *path, int mode, int perm);
+extern void      websRomPageClose(int fd);
+extern int       websRomPageReadData(webs_t wp, char *buf, int len);
+extern int       websRomPageStat(char_t *path, websStatType *sbuf);
+extern long      websRomPageSeek(webs_t wp, long offset, int origin);
+extern void      websSetRequestSocketHandler(webs_t wp, int mask, 
+                    void (*fn)(webs_t wp));
+extern int       websSolutionHandler(webs_t wp, char_t *urlPrefix,
+                    char_t *webDir, int arg, char_t *url, char_t *path, 
+                    char_t *query);
+extern void      websUrlHandlerClose();
+extern int       websUrlHandlerOpen();
+extern int       websOpenServer(int port, int retries);
+extern void      websCloseServer();
+extern char_t*   websGetDateString(websStatType* sbuf);
+
+extern int      strcmpci(char_t* s1, char_t* s2);
 
 #ifdef CE
 extern int writeUniToAsc(int fid, void *buf, unsigned int len);

