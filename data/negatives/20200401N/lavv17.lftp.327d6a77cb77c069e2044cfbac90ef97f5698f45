commit 327d6a77cb77c069e2044cfbac90ef97f5698f45
Author: Alexander V. Lukyanov <lavv17f@gmail.com>
Date:   Tue May 27 10:50:29 2014 +0400

    make NetAccess::Poll/CheckHangup not disconnect but rather return error message
    
    In particular, this fixes a coredump in ftp, when an error with data socket
    happens. Ftp needs to check conn->fixed_pasv but conn was zeroed after
    Poll/CheckHangup/Disconnect.

diff --git a/src/Http.cc b/src/Http.cc
index d4afecda..bcf5961d 100644
--- a/src/Http.cc
+++ b/src/Http.cc
@@ -1070,6 +1070,7 @@ int Http::Do()
 {
    int m=STALL;
    int res;
+   const char *error;
    const char *buf;
    int len;
 
@@ -1291,9 +1292,11 @@ int Http::Do()
       timeout_timer.Reset();
 
    case CONNECTING:
-      res=Poll(conn->sock,POLLOUT);
+      res=Poll(conn->sock,POLLOUT,&error);
       if(res==-1)
       {
+	 LogError(0,_("Socket error (%s) - reconnecting"),error);
+	 Disconnect(error);
 	 NextPeer();
 	 return MOVED;
       }
diff --git a/src/NetAccess.cc b/src/NetAccess.cc
index ba73c056..c4fedd32 100644
--- a/src/NetAccess.cc
+++ b/src/NetAccess.cc
@@ -104,43 +104,28 @@ void NetAccess::Reconfig(const char *name)
       rate_limit->Reconfig(name,c);
 }
 
-int NetAccess::CheckHangup(const struct pollfd *pfd,int num)
+const char *NetAccess::CheckHangup(const struct pollfd *pfd,int num)
 {
    for(int i=0; i<num; i++)
    {
 #ifdef SO_ERROR
-      int   s_errno=0;
-      socklen_t len;
-
+      int s_errno=0;
       errno=0;
-
+      socklen_t len=sizeof(s_errno);
+      getsockopt(pfd[i].fd,SOL_SOCKET,SO_ERROR,(char*)&s_errno,&len);
 // Where does the error number go - to errno or to the pointer?
 // It seems that to errno, but if the pointer is NULL it dumps core.
 // (solaris 2.5)
 // It seems to be different on glibc 2.0 - check both errno and s_errno
-
-      len=sizeof(s_errno);
-      getsockopt(pfd[i].fd,SOL_SOCKET,SO_ERROR,(char*)&s_errno,&len);
-      if(errno==ENOTSOCK)
-	 return 0;
-      if(errno!=0 || s_errno!=0)
-      {
-	 const char *error=strerror(errno?errno:s_errno);
-	 LogError(0,_("Socket error (%s) - reconnecting"),error);
-	 Disconnect(error);
-	 return 1;
-      }
+      if((errno!=0 || s_errno!=0) && errno!=ENOTSOCK)
+	 return strerror(errno?errno:s_errno);
 #endif /* SO_ERROR */
       if(pfd[i].revents&POLLERR)
-      {
-	 LogError(0,"POLLERR on fd %d",pfd[i].fd);
-	 Disconnect("POLLERR");
-	 return 1;
-      }
+	 return "POLLERR";
    } /* end for */
    return 0;
 }
-int NetAccess::Poll(int fd,int ev)
+int NetAccess::Poll(int fd,int ev,const char **err)
 {
    struct pollfd pfd;
    pfd.fd=fd;
@@ -149,7 +134,8 @@ int NetAccess::Poll(int fd,int ev)
    int res=poll(&pfd,1,0);
    if(res<1)
       return 0;
-   if(CheckHangup(&pfd,1))
+   *err=CheckHangup(&pfd,1);
+   if(*err)
       return -1;
    if(pfd.revents)
       timeout_timer.Reset();
diff --git a/src/NetAccess.h b/src/NetAccess.h
index 1cc9bfa6..e41e1a73 100644
--- a/src/NetAccess.h
+++ b/src/NetAccess.h
@@ -61,8 +61,8 @@ protected:
    int SocketCreate(int af,int type,int proto) { return Networker::SocketCreate(af,type,proto,hostname); }
    int SocketCreateTCP(int af) { return Networker::SocketCreateTCP(af,hostname); }
 
-   int Poll(int fd,int ev);
-   int CheckHangup(const struct pollfd *pfd,int num);
+   int Poll(int fd,int ev,const char **err);
+   const char *CheckHangup(const struct pollfd *pfd,int num);
 
    xstring_c proxy;
    xstring_c proxy_port;
diff --git a/src/ftpclass.cc b/src/ftpclass.cc
index c6de0c63..aa4cf6a2 100644
--- a/src/ftpclass.cc
+++ b/src/ftpclass.cc
@@ -1214,6 +1214,7 @@ int   Ftp::Do()
    const unsigned char *p;
    automate_state oldstate;
    int	 m=STALL;
+   const char *error;
 
    // check if idle time exceeded
    if(mode==CLOSED && conn && idle_timer.Stopped())
@@ -1370,9 +1371,12 @@ int   Ftp::Do()
    /* fallthrough */
    case(CONNECTING_STATE):
       assert(conn && conn->control_sock!=-1);
-      res=Poll(conn->control_sock,POLLOUT);
-      if(res==-1)
+      res=Poll(conn->control_sock,POLLOUT,&error);
+      if(res==-1) {
+	 LogError(0,_("Socket error (%s) - reconnecting"),error);
+	 Disconnect(error);
 	 return MOVED;
+      }
       if(!(res&POLLOUT))
 	 goto usual_return;
 
@@ -2122,9 +2126,12 @@ int   Ftp::Do()
       if(state!=ACCEPTING_STATE || Error())
          return MOVED;
 
-      res=Poll(conn->data_sock,POLLIN);
-      if(res==-1)
+      res=Poll(conn->data_sock,POLLIN,&error);
+      if(res==-1) {
+	 LogError(0,_("Data socket error (%s) - reconnecting"),error);
+	 Disconnect(error);
          return MOVED;
+      }
 
       if(!(res&POLLIN))
 	 goto usual_return;
@@ -2213,14 +2220,16 @@ int   Ftp::Do()
 	 m=MOVED;
       /* fallthrough */
       case PASV_DATASOCKET_CONNECTING:
-	 res=Poll(conn->data_sock,POLLOUT);
+	 res=Poll(conn->data_sock,POLLOUT,&error);
 	 if(res==-1)
 	 {
+	    LogError(0,_("Data socket error (%s) - reconnecting"),error);
 	    if(conn->fixed_pasv && QueryBool("auto-passive-mode",hostname))
 	    {
 	       LogNote(2,_("Switching passive mode off"));
 	       SetFlag(PASSIVE_MODE,0);
 	    }
+	    Disconnect(error);
 	    return MOVED;
 	 }
 	 if(!(res&POLLOUT))

