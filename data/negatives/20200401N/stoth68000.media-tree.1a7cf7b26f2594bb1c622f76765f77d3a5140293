commit 1a7cf7b26f2594bb1c622f76765f77d3a5140293
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Wed Nov 11 12:37:58 2015 +0200

    dmaengine: omap-dma: Handle cases when the channel is polled for completion
    
    When a DMA client driver decides that it is not providing callback for
    completion of a transfer (and/or does not set the DMA_PREP_INTERRUPT) but
    it will poll the status of the transfer (in case of short memcpy for
    example) we will not get interrupt for the completion of the transfer and
    will not mark the transaction as done.
    Check the channel enable bit in the CCR when the status is queried and if
    the channel is no longer active, we call the omap_dma_callback() to handle
    the transfer completion.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/omap-dma.c b/drivers/dma/omap-dma.c
index 4e4642f561f5..f86827ac0c8a 100644
--- a/drivers/dma/omap-dma.c
+++ b/drivers/dma/omap-dma.c
@@ -673,8 +673,14 @@ static enum dma_status omap_dma_tx_status(struct dma_chan *chan,
 	struct omap_chan *c = to_omap_dma_chan(chan);
 	struct virt_dma_desc *vd;
 	enum dma_status ret;
+	uint32_t ccr;
 	unsigned long flags;
 
+	ccr = omap_dma_chan_read(c, CCR);
+	/* The channel is no longer active, handle the completion right away */
+	if (!(ccr & CCR_ENABLE))
+		omap_dma_callback(c->dma_ch, 0, c);
+
 	ret = dma_cookie_status(chan, cookie, txstate);
 	if (ret == DMA_COMPLETE || !txstate)
 		return ret;

