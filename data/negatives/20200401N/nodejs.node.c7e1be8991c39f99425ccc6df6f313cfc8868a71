commit c7e1be8991c39f99425ccc6df6f313cfc8868a71
Author: Timothy Gu <timothygu99@gmail.com>
Date:   Sun Jan 29 02:39:10 2017 -0800

    src: remove usage of V8 deprecated API in node_url.cc
    
    Also:
    
    - Avoid using 'override' as variable name
    - Use explicit static_cast instead of C-style cast
    
    PR-URL: https://github.com/nodejs/node/pull/11066
    Reviewed-By: Anna Henningsen <anna@addaleax.net>
    Reviewed-By: James M Snell <jasnell@gmail.com>
    Reviewed-By: MichaÃ«l Zasso <targos@protonmail.com>

diff --git a/src/node_url.cc b/src/node_url.cc
index 7f21051c54..0d5e695a3c 100644
--- a/src/node_url.cc
+++ b/src/node_url.cc
@@ -512,7 +512,7 @@ namespace url {
     return true;
   }
 
-  static inline void Copy(Isolate* isolate,
+  static inline void Copy(Environment* env,
                           Local<Array> ary,
                           std::vector<std::string>* vec) {
     const int32_t len = ary->Length();
@@ -520,28 +520,30 @@ namespace url {
       return;  // nothing to copy
     vec->reserve(len);
     for (int32_t n = 0; n < len; n++) {
-      Local<Value> val = ary->Get(n);
+      Local<Value> val = ary->Get(env->context(), n).ToLocalChecked();
       if (val->IsString()) {
-        Utf8Value value(isolate, val.As<String>());
+        Utf8Value value(env->isolate(), val.As<String>());
         vec->push_back(std::string(*value, value.length()));
       }
     }
   }
 
-  static inline Local<Array> Copy(Isolate* isolate,
+  static inline Local<Array> Copy(Environment* env,
                                   std::vector<std::string> vec) {
+    Isolate* isolate = env->isolate();
     Local<Array> ary = Array::New(isolate, vec.size());
     for (size_t n = 0; n < vec.size(); n++)
-      ary->Set(n, UTF8STRING(isolate, vec[n]));
+      ary->Set(env->context(), n, UTF8STRING(isolate, vec[n])).FromJust();
     return ary;
   }
 
   static inline void HarvestBase(Environment* env,
                                  struct url_data* base,
                                  Local<Object> base_obj) {
+    Local<Context> context = env->context();
     Local<Value> flags = GET(env, base_obj, "flags");
     if (flags->IsInt32())
-      base->flags = flags->Int32Value();
+      base->flags = flags->Int32Value(context).FromJust();
 
     GET_AND_SET(env, base_obj, scheme, base, URL_FLAGS_HAS_SCHEME);
     GET_AND_SET(env, base_obj, username, base, URL_FLAGS_HAS_USERNAME);
@@ -551,11 +553,11 @@ namespace url {
     GET_AND_SET(env, base_obj, fragment, base, URL_FLAGS_HAS_FRAGMENT);
     Local<Value> port = GET(env, base_obj, "port");
     if (port->IsInt32())
-      base->port = port->Int32Value();
+      base->port = port->Int32Value(context).FromJust();
     Local<Value> path = GET(env, base_obj, "path");
     if (path->IsArray()) {
       base->flags |= URL_FLAGS_HAS_PATH;
-      Copy(env->isolate(), path.As<Array>(), &(base->path));
+      Copy(env, path.As<Array>(), &(base->path));
     }
   }
 
@@ -564,7 +566,7 @@ namespace url {
                                     Local<Object> context_obj) {
     Local<Value> flags = GET(env, context_obj, "flags");
     if (flags->IsInt32()) {
-      int32_t _flags = flags->Int32Value();
+      int32_t _flags = flags->Int32Value(env->context()).FromJust();
       if (_flags & URL_FLAGS_SPECIAL)
         context->flags |= URL_FLAGS_SPECIAL;
       if (_flags & URL_FLAGS_CANNOT_BE_BASE)
@@ -577,7 +579,7 @@ namespace url {
     }
     Local<Value> port = GET(env, context_obj, "port");
     if (port->IsInt32())
-      context->port = port->Int32Value();
+      context->port = port->Int32Value(env->context()).FromJust();
   }
 
   // Single dot segment can be ".", "%2e", or "%2E"
@@ -635,7 +637,7 @@ namespace url {
                     Local<Value> recv,
                     const char* input,
                     const size_t len,
-                    enum url_parse_state override,
+                    enum url_parse_state state_override,
                     Local<Value> base_obj,
                     Local<Value> context_obj,
                     Local<Function> cb) {
@@ -669,8 +671,9 @@ namespace url {
     buffer.reserve(len);
 
     // Set the initial parse state.
-    const bool state_override = override != kUnknownState;
-    enum url_parse_state state = state_override ? override : kSchemeStart;
+    const bool has_state_override = state_override != kUnknownState;
+    enum url_parse_state state = has_state_override ? state_override :
+                                                      kSchemeStart;
 
     const char* p = input;
     const char* end = input + len;
@@ -702,7 +705,7 @@ namespace url {
           if (ASCII_ALPHA(ch)) {
             buffer += TO_LOWER(ch);
             state = kScheme;
-          } else if (!state_override) {
+          } else if (!has_state_override) {
             state = kNoScheme;
             continue;
           } else {
@@ -714,7 +717,7 @@ namespace url {
             buffer += TO_LOWER(ch);
             p++;
             continue;
-          } else if (ch == ':' || (state_override && ch == kEOL)) {
+          } else if (ch == ':' || (has_state_override && ch == kEOL)) {
             buffer += ':';
             if (buffer.size() > 0) {
               SET_HAVE_SCHEME()
@@ -725,7 +728,7 @@ namespace url {
             } else {
               url.flags &= ~URL_FLAGS_SPECIAL;
             }
-            if (state_override)
+            if (has_state_override)
               goto done;
             buffer.clear();
             if (url.scheme == "file:") {
@@ -746,7 +749,7 @@ namespace url {
               url.path.push_back("");
               state = kCannotBeBase;
             }
-          } else if (!state_override) {
+          } else if (!has_state_override) {
             buffer.clear();
             state = kNoScheme;
             p = input;
@@ -1000,7 +1003,7 @@ namespace url {
               URL_FAILED()
             buffer.clear();
             state = kPort;
-            if (override == kHostname)
+            if (state_override == kHostname)
               TERMINATE()
           } else if (ch == kEOL ||
                      ch == '/' ||
@@ -1015,7 +1018,7 @@ namespace url {
               URL_FAILED()
             buffer.clear();
             state = kPathStart;
-            if (state_override)
+            if (has_state_override)
               TERMINATE()
           } else {
             if (ch == '[')
@@ -1028,7 +1031,7 @@ namespace url {
         case kPort:
           if (ASCII_DIGIT(ch)) {
             buffer += ch;
-          } else if (state_override ||
+          } else if (has_state_override ||
                      ch == kEOL ||
                      ch == '/' ||
                      ch == '?' ||
@@ -1040,7 +1043,7 @@ namespace url {
                 port = port * 10 + buffer[i] - '0';
               if (port >= 0 && port <= 0xffff) {
                 url.port = NormalizePort(url.scheme, port);
-              } else if (!state_override) {
+              } else if (!has_state_override) {
                 URL_FAILED()
               }
               buffer.clear();
@@ -1181,7 +1184,7 @@ namespace url {
           if (ch == kEOL ||
               ch == '/' ||
               special_back_slash ||
-              (!state_override && (ch == '?' || ch == '#'))) {
+              (!has_state_override && (ch == '?' || ch == '#'))) {
             if (IsDoubleDotSegment(buffer)) {
               ShortenUrlPath(&url);
               if (ch != '/' && !special_back_slash) {
@@ -1233,7 +1236,7 @@ namespace url {
           }
           break;
         case kQuery:
-          if (ch == kEOL || (!state_override && ch == '#')) {
+          if (ch == kEOL || (!has_state_override && ch == '#')) {
             SET_HAVE_QUERY()
             url.query = buffer;
             buffer.clear();
@@ -1296,7 +1299,7 @@ namespace url {
       if (url.port > -1)
         argv[ARG_PORT] = Integer::New(isolate, url.port);
       if (DOES_HAVE_PATH(url))
-        argv[ARG_PATH] = Copy(isolate, url.path);
+        argv[ARG_PATH] = Copy(env, url.path);
     }
 
     (void)cb->Call(context, recv, 9, argv);
@@ -1314,13 +1317,15 @@ namespace url {
           args[3]->IsObject());
     CHECK(args[4]->IsFunction());
     Utf8Value input(env->isolate(), args[0]);
-    enum url_parse_state override = kUnknownState;
-    if (args[1]->IsNumber())
-      override = (enum url_parse_state)(args[1]->Uint32Value());
+    enum url_parse_state state_override = kUnknownState;
+    if (args[1]->IsNumber()) {
+      state_override = static_cast<enum url_parse_state>(
+          args[1]->Uint32Value(env->context()).FromJust());
+    }
 
     Parse(env, args.This(),
           *input, input.length(),
-          override,
+          state_override,
           args[2],
           args[3],
           args[4].As<Function>());

