commit a49147af7825f8ca882741a5f3cd03ec115dcbfa
Author: Tom Lane <tgl@sss.pgh.pa.us>
Date:   Mon Jan 18 18:17:45 2010 +0000

    Fix an oversight in convert_EXISTS_sublink_to_join: we can't convert an
    EXISTS that contains a WITH clause.  This would usually lead to a
    "could not find CTE" error later in planning, because the WITH wouldn't
    get processed at all.  Noted while playing with an example from Ken Marshall.

diff --git a/src/backend/optimizer/plan/subselect.c b/src/backend/optimizer/plan/subselect.c
index 887f360c0e..2e99cc6b4b 100644
--- a/src/backend/optimizer/plan/subselect.c
+++ b/src/backend/optimizer/plan/subselect.c
@@ -7,7 +7,7 @@
  * Portions Copyright (c) 1994, Regents of the University of California
  *
  * IDENTIFICATION
- *	  $PostgreSQL: pgsql/src/backend/optimizer/plan/subselect.c,v 1.157 2010/01/02 16:57:47 momjian Exp $
+ *	  $PostgreSQL: pgsql/src/backend/optimizer/plan/subselect.c,v 1.158 2010/01/18 18:17:45 tgl Exp $
  *
  *-------------------------------------------------------------------------
  */
@@ -1114,6 +1114,17 @@ convert_EXISTS_sublink_to_join(PlannerInfo *root, SubLink *sublink,
 
 	Assert(sublink->subLinkType == EXISTS_SUBLINK);
 
+	/*
+	 * Can't flatten if it contains WITH.  (We could arrange to pull up the
+	 * WITH into the parent query's cteList, but that risks changing the
+	 * semantics, since a WITH ought to be executed once per associated query
+	 * call.)  Note that convert_ANY_sublink_to_join doesn't have to reject
+	 * this case, since it just produces a subquery RTE that doesn't have to
+	 * get flattened into the parent query.
+	 */
+	if (subselect->cteList)
+		return NULL;
+
 	/*
 	 * Copy the subquery so we can modify it safely (see comments in
 	 * make_subplan).

