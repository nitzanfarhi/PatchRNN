commit f85bd42ebc78ed5010d286105bc1fae19ad8e170
Author: Kevin McCarthy <kevin@8t8.us>
Date:   Tue Feb 20 19:09:16 2018 -0800

    Improve index color cache flushing behavior
    
    Flush when redefining the colors for an existing color line, in
    addition to when defining a new color line.
    
    Flush only when uncoloring the index.

diff --git a/color.c b/color.c
index 6d57b7522..5e5a32231 100644
--- a/color.c
+++ b/color.c
@@ -574,7 +574,11 @@ static int parse_uncolor(struct Buffer *buf, struct Buffer *s, unsigned long dat
   else if (object == MT_COLOR_INDEX_TAG)
     do_uncolor(buf, s, &ColorIndexTagList, &do_cache, parse_uncolor);
 
-  if (do_cache && !OPT_NO_CURSES)
+  bool is_index = ((object == MT_COLOR_INDEX) || (object == MT_COLOR_INDEX_AUTHOR) ||
+                   (object == MT_COLOR_INDEX_FLAGS) || (object == MT_COLOR_INDEX_SUBJECT) ||
+                   (object == MT_COLOR_INDEX_TAG));
+
+  if (is_index && do_cache && !OPT_NO_CURSES)
   {
     mutt_set_menu_redraw_full(MENU_MAIN);
     /* force re-caching of index colors */
@@ -655,9 +659,6 @@ static int add_pattern(struct ColorLineHead *top, const char *s, int sensitive,
         free_color_line(tmp, 1);
         return -1;
       }
-      /* force re-caching of index colors */
-      for (int i = 0; Context && i < Context->msgcount; i++)
-        Context->hdrs[i]->pair = 0;
     }
     else
     {
@@ -689,6 +690,13 @@ static int add_pattern(struct ColorLineHead *top, const char *s, int sensitive,
     STAILQ_INSERT_HEAD(top, tmp, entries);
   }
 
+  /* force re-caching of index colors */
+  if (is_index)
+  {
+    for (int i = 0; Context && i < Context->msgcount; i++)
+      Context->hdrs[i]->pair = 0;
+  }
+
   return 0;
 }
 

