commit c2feb87d7616b3d9080723bc7665da9d7d9b21c2
Author: Bron Gondwana <brong@fastmail.fm>
Date:   Mon Jun 28 12:04:06 2010 +0000

    Remove unused mailbox_sync
    
    It's a big pile of unused API that's getting in the way of cleaning up.

diff --git a/imap/mailbox.c b/imap/mailbox.c
index 57245f542..9f6c79b58 100644
--- a/imap/mailbox.c
+++ b/imap/mailbox.c
@@ -39,7 +39,7 @@
  * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
  * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  *
- * $Id: mailbox.c,v 1.199 2010/01/06 17:01:36 murch Exp $
+ * $Id: mailbox.c,v 1.200 2010/06/28 12:04:06 brong Exp $
  */
 
 #include <config.h>
@@ -3194,271 +3194,6 @@ int mailbox_rename_cleanup(struct mailbox *oldmailbox, int isinbox)
     return r;
 }
 
-
-/*
- * Synchronize 'new' mailbox to 'old' mailbox.
- */
-int
-mailbox_sync(const char *oldname, const char *oldpath,
-	     const char *oldmpath, const char *oldacl, 
-	     const char *newname, char *newpath, char *newmpath, int docreate, 
-	     bit32 *olduidvalidityp, bit32 *newuidvalidityp,
-	     struct mailbox *mailboxp)
-{
-    int r, r2;
-    struct mailbox oldmailbox, newmailbox;
-    unsigned int flag, oldmsgno, newmsgno;
-    struct index_record oldrecord, newrecord;
-    char oldfname[MAX_MAILBOX_PATH+1], newfname[MAX_MAILBOX_PATH+1];
-    size_t oldfname_len, newfname_len, fn_len;
-    char *oldfnametail, *newfnametail;
-    struct txn *tid = NULL;
-
-    /* Open old mailbox and lock */
-    mailbox_open_header_path(oldname, oldpath, oldmpath,
-			     oldacl, 0, &oldmailbox, 0);
-
-    if (oldmailbox.format == MAILBOX_FORMAT_NETNEWS) {
-	mailbox_close(&oldmailbox);
-	return IMAP_MAILBOX_NOTSUPPORTED;
-    }
-
-    r =  mailbox_lock_header(&oldmailbox);
-    if (!r) r = mailbox_open_index(&oldmailbox);
-    if (!r) r = mailbox_lock_index(&oldmailbox);
-    if (r) {
-	mailbox_close(&oldmailbox);
-	return r;
-    }
-
-    if (docreate) {
-	/* Create new mailbox */
-	r = mailbox_create(newname, newpath, 
-			   oldmailbox.acl, oldmailbox.uniqueid, oldmailbox.format,
-			   &newmailbox);
-    }
-    else {
-	/* Open new mailbox and lock */
-	r = mailbox_open_header_path(newname, newpath, newmpath,
-				     oldacl, 0, &newmailbox, 0);
-	r =  mailbox_lock_header(&newmailbox);
-	if (!r) r = mailbox_open_index(&newmailbox);
-	if (!r) r = mailbox_lock_index(&newmailbox);
-	if (r) {
-	    mailbox_close(&newmailbox);
-	}
-    }
-    if (r) {
-	mailbox_close(&oldmailbox);
-	return r;
-    }
-
-    newmailbox.uidvalidity = oldmailbox.uidvalidity;
-    if (olduidvalidityp) *olduidvalidityp = oldmailbox.uidvalidity;
-    if (newuidvalidityp) *newuidvalidityp = newmailbox.uidvalidity;
-
-    /* Copy flag names */
-    for (flag = 0; flag < MAX_USER_FLAGS; flag++) {
-	if (oldmailbox.flagname[flag]) {
-	    newmailbox.flagname[flag] = xstrdup(oldmailbox.flagname[flag]);
-	}
-    }
-    r = mailbox_write_header(&newmailbox);
-    if (r) {
-	mailbox_close(&newmailbox);
-	mailbox_close(&oldmailbox);
-	return r;
-    }
-
-    /* Check quota if necessary */
-    if (newmailbox.quota.root) {
-	r = quota_read(&newmailbox.quota, &tid, 1);
-	if (!oldmailbox.quota.root ||
-	    strcmp(oldmailbox.quota.root, newmailbox.quota.root) != 0) {
-	    if (!r && newmailbox.quota.limit >= 0 &&
-		newmailbox.quota.used + oldmailbox.quota_mailbox_used >
-		((uquota_t) newmailbox.quota.limit * QUOTA_UNITS)) {
-		r = IMAP_QUOTA_EXCEEDED;
-	    }
-	}
-	if (r && r != IMAP_QUOTAROOT_NONEXISTENT) {
-	    mailbox_close(&newmailbox);
-	    mailbox_close(&oldmailbox);
-	    return r;
-	}
-    }
-
-    strlcpy(oldfname, oldmailbox.path, sizeof(oldfname));
-    strlcat(oldfname, "/", sizeof(oldfname));
-    oldfname_len = strlen(oldfname);
-    oldfnametail = oldfname + oldfname_len;
-
-    strlcpy(newfname, newmailbox.path, sizeof(newfname));
-    strlcat(newfname, "/", sizeof(newfname));
-    newfname_len = strlen(newfname);
-    newfnametail = newfname + newfname_len;
-
-    /*
-     * Copy over new message files and delete expunged ones.
-     *
-     * We use the fact that UIDs are monotonically increasing to our
-     * advantage; we compare the UIDs from each mailbox in order, and:
-     *
-     *  - if UID in "slave" mailbox < UID in "master" mailbox,
-     *    then the message has been deleted from "master" since last sync,
-     *    so delete it from "slave" and move on to next "slave" UID
-     *  - if UID in "slave" mailbox == UID in "master" mailbox,
-     *    then message is still current and we already have a copy,
-     *    so move on to next UID in each mailbox
-     *  - if UID in "master" mailbox > last UID in "slave" mailbox, 
-     *    then this is a new arrival in "master" since last sync,
-     *    so copy it to "slave" and move on to next "master" UID
-     */
-    newmsgno = 1;
-    for (oldmsgno = 1; oldmsgno <= oldmailbox.exists; oldmsgno++) {
-	r = mailbox_read_index_record(&oldmailbox, oldmsgno, &oldrecord);
-	if (r) break;
-	if (newmsgno <= newmailbox.exists) {
-	    do {
-		r = mailbox_read_index_record(&newmailbox, newmsgno,
-					      &newrecord);
-		if (r) goto fail;
-		newmsgno++;
-
-		if (newrecord.uid < oldrecord.uid) {
-		    /* message expunged since last sync - delete message file */
-		    mailbox_message_get_fname(&newmailbox, newrecord.uid,
-					      newfnametail,
-					      sizeof(newfname) - strlen(newfname));
-		    unlink(newfname);
-		}
-	    } while ((newrecord.uid < oldrecord.uid) &&
-		     (newmsgno <= newmailbox.exists));
-	}
-	/* we check 'exists' instead of last UID in case of empty mailbox */
-	if (newmsgno > newmailbox.exists) {
-	    /* message arrived since last sync - copy message file */
-	    mailbox_message_get_fname(&oldmailbox, oldrecord.uid,
-				      oldfnametail,
-				      sizeof(oldfname) - strlen(oldfname));
-	    strcpy(newfnametail, oldfnametail);
-	    r = mailbox_copyfile(oldfname, newfname, 0);
-	    if (r) break;
-	}
-    }
-    if (!r) r = seen_copy(&oldmailbox, &newmailbox, NULL);
-
-    if (!r) {
-	/* Copy over index/cache files */
-	oldfnametail--;
-	newfnametail--;
-
-	fn_len = strlen(FNAME_INDEX);
-	if((oldfname_len - 1) + fn_len > sizeof(oldfname))
-	{
-	    syslog(LOG_ERR, "IOERROR: Path too long (%s + %s)",
-		   oldfname, FNAME_INDEX);
-	    fatal("Path too long", EC_OSFILE);
-	}
-	if((newfname_len - 1) + fn_len > sizeof(oldfname))
-	{
-	    syslog(LOG_ERR, "IOERROR: Path too long (%s + %s)",
-		   newfname, FNAME_INDEX);
-	    fatal("Path too long", EC_OSFILE);
-	}
-
-	strlcpy(oldfnametail, FNAME_INDEX,
-		sizeof(oldfname) - (oldfname_len - 1));
-	strlcpy(newfnametail, FNAME_INDEX,
-	        sizeof(newfname) - (newfname_len - 1));
-
-	unlink(newfname);		/* Make link() possible */
-	r = mailbox_copyfile(oldfname, newfname, 0);
-
-	fn_len = strlen(FNAME_CACHE);
-	if((oldfname_len - 1) + fn_len > sizeof(oldfname))
-	{
-	    syslog(LOG_ERR, "IOERROR: Path too long (%s + %s)",
-		   oldfname, FNAME_CACHE);
-	    fatal("Path too long", EC_OSFILE);
-	}
-	if((newfname_len - 1) + fn_len > sizeof(oldfname))
-	{
-	    syslog(LOG_ERR, "IOERROR: Path too long (%s + %s)",
-		   newfname, FNAME_CACHE);
-	    fatal("Path too long", EC_OSFILE);
-	}
-
-	strlcpy(oldfnametail, FNAME_CACHE,
-		sizeof(oldfname) - (oldfname_len - 1));
-	strlcpy(newfnametail, FNAME_CACHE,
-	        sizeof(newfname) - (newfname_len - 1));
-
-	unlink(newfname);
-	if (!r) r = mailbox_copyfile(oldfname, newfname, 0);
-
-	if (r) {
-	    mailbox_close(&newmailbox);
-	    mailbox_close(&oldmailbox);
-	    return r;
-	}
-
-	/* Re-open index file and store new uidvalidity  */
-	close(newmailbox.index_fd);
-	newmailbox.index_fd = dup(oldmailbox.index_fd);
-	(void) mailbox_read_index_header(&newmailbox);
-	newmailbox.generation_no = oldmailbox.generation_no;
-	(void) mailbox_write_index_header(&newmailbox);
-    }
-
-    /* Record new quota usage */
-    if (!r && newmailbox.quota.root) {
-	newmailbox.quota.used += oldmailbox.quota_mailbox_used;
-	r = quota_write(&newmailbox.quota, &tid);
-	if (!r) quota_commit(&tid);
-	tid = NULL;
-    }
-    if (r) goto fail;
-
-    if (r && newmailbox.quota.root) {
-	r2 = quota_read(&newmailbox.quota, &tid, 1);
-	newmailbox.quota.used += newmailbox.quota_mailbox_used;
-	if (!r2) {
-	    r2 = quota_write(&newmailbox.quota, &tid);
-	    if (!r2) quota_commit(&tid);
-	}
-	else if (r2 == IMAP_QUOTAROOT_NONEXISTENT) r2 = 0;
-	if (r2) {
-	    syslog(LOG_ERR,
-	      "LOSTQUOTA: unable to record use of " UQUOTA_T_FMT " bytes in quota %s",
-		   newmailbox.quota_mailbox_used, newmailbox.quota.root);
-	}
-    }
-    if (r) goto fail;
-
-    mailbox_close(&oldmailbox);
-    if (mailboxp) {
-	*mailboxp = newmailbox;
-    } else {
-	mailbox_close(&newmailbox);
-    }
-    return 0;
-
- fail:
-#if 0
-    for (msgno = 1; msgno <= oldmailbox.exists; msgno++) {
-	if (mailbox_read_index_record(&oldmailbox, msgno, &record)) continue;
-	mailbox_message_get_fname(&oldmailbox, record.uid, newfnametail,
-				  sizeof(newfname) - strlen(newfname));
-	(void) unlink(newfname);
-    }
-#endif
-    mailbox_close(&newmailbox);
-    mailbox_close(&oldmailbox);
-    return r;
-}
-
-    
 /*
  * Copy (or link) the file 'from' to the file 'to'
  */
diff --git a/imap/mailbox.h b/imap/mailbox.h
index f1859ce7f..fc46dffad 100644
--- a/imap/mailbox.h
+++ b/imap/mailbox.h
@@ -39,7 +39,7 @@
  * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
  * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  *
- * $Id: mailbox.h,v 1.96 2010/01/06 17:01:36 murch Exp $
+ * $Id: mailbox.h,v 1.97 2010/06/28 12:04:06 brong Exp $
  */
 
 #ifndef INCLUDED_MAILBOX_H
@@ -448,13 +448,6 @@ extern int mailbox_rename_copy(struct mailbox *oldmailbox,
                                int ignorequota);
 extern int mailbox_rename_cleanup(struct mailbox *oldmailbox, int isinbox);
 
-extern int mailbox_sync(const char *oldname, const char *oldpath, 
-			const char *oldmpath, const char *oldacl, 
-			const char *newname, char *newpath, char *newmpath,
-			int docreate,
-			bit32 *olduidvalidityp, bit32 *newuidvalidtyp,
-			struct mailbox *mailboxp);
-
 extern int mailbox_copyfile(const char *from, const char *to, int nolink);
 extern void mailbox_hash_mbox(char *buf, size_t buf_len,
 			      const char *root, const char *name);

