commit 63d4c1677e7e9d9652ee450e9abe1e877db91093
Author: unknown <tomas@poseidon.ndb.mysql.com>
Date:   Mon Feb 13 15:47:46 2006 +0100

    Bug #17325      HA Testing: Node failed takeover for failed node (Array index out of range)
    wrong arrGuard, see MAX_REPLICAS+1 0n row 6457
    + changed all 4 constants to MAX_REPLICAS
    + moved some arrGuards out of loops for optim reasons

diff --git a/ndb/src/kernel/blocks/dbtc/DbtcMain.cpp b/ndb/src/kernel/blocks/dbtc/DbtcMain.cpp
index d7232030c41..c3f0794c569 100644
--- a/ndb/src/kernel/blocks/dbtc/DbtcMain.cpp
+++ b/ndb/src/kernel/blocks/dbtc/DbtcMain.cpp
@@ -3045,7 +3045,7 @@ void Dbtc::tckeyreq050Lab(Signal* signal)
       /*       NODE IF POSSIBLE TO AVOID UNNECESSARY COMMUNICATION   */
       /*       WITH SIMPLE READS.                                    */
       /*-------------------------------------------------------------*/
-      arrGuard(tnoOfBackup, 4);
+      arrGuard(tnoOfBackup, MAX_REPLICAS);
       UintR Tindex;
       UintR TownNode = cownNodeid;
       for (Tindex = 1; Tindex <= tnoOfBackup; Tindex++) {
@@ -6302,7 +6302,7 @@ void Dbtc::timeOutFoundLab(Signal* signal, Uint32 TapiConPtr)
     jam();
     tcConnectptr.i = apiConnectptr.p->currentTcConnect;
     ptrCheckGuard(tcConnectptr, ctcConnectFilesize, tcConnectRecord);
-    arrGuard(apiConnectptr.p->currentReplicaNo, 4);
+    arrGuard(apiConnectptr.p->currentReplicaNo, MAX_REPLICAS);
     hostptr.i = tcConnectptr.p->tcNodedata[apiConnectptr.p->currentReplicaNo];
     ptrCheckGuard(hostptr, chostFilesize, hostRecord);
     if (hostptr.p->hostStatus == HS_ALIVE) {
@@ -6328,7 +6328,7 @@ void Dbtc::timeOutFoundLab(Signal* signal, Uint32 TapiConPtr)
     jam();
     tcConnectptr.i = apiConnectptr.p->currentTcConnect;
     ptrCheckGuard(tcConnectptr, ctcConnectFilesize, tcConnectRecord);
-    arrGuard(apiConnectptr.p->currentReplicaNo, 4);
+    arrGuard(apiConnectptr.p->currentReplicaNo, MAX_REPLICAS);
     hostptr.i = tcConnectptr.p->tcNodedata[apiConnectptr.p->currentReplicaNo];
     ptrCheckGuard(hostptr, chostFilesize, hostRecord);
     if (hostptr.p->hostStatus == HS_ALIVE) {
@@ -6354,7 +6354,7 @@ void Dbtc::timeOutFoundLab(Signal* signal, Uint32 TapiConPtr)
     jam();
     tcConnectptr.i = apiConnectptr.p->currentTcConnect;
     ptrCheckGuard(tcConnectptr, ctcConnectFilesize, tcConnectRecord);
-    arrGuard(apiConnectptr.p->currentReplicaNo, 4);
+    arrGuard(apiConnectptr.p->currentReplicaNo, MAX_REPLICAS);
     hostptr.i = tcConnectptr.p->tcNodedata[apiConnectptr.p->currentReplicaNo];
     ptrCheckGuard(hostptr, chostFilesize, hostRecord);
     if (hostptr.p->hostStatus == HS_ALIVE) {
@@ -6491,7 +6491,7 @@ void Dbtc::sendAbortedAfterTimeout(Signal* signal, int Tcheck)
       // in time to the ABORT signal we will declare it as dead.
       /*------------------------------------------------------------------*/
       UintR Ti = 0;
-      arrGuard(tcConnectptr.p->noOfNodes, 4);
+      arrGuard(tcConnectptr.p->noOfNodes, MAX_REPLICAS+1);
       for (Ti = 0; Ti < tcConnectptr.p->noOfNodes; Ti++) {
         jam();
         if (tcConnectptr.p->tcNodedata[Ti] != 0) {
@@ -7548,7 +7548,7 @@ void Dbtc::execABORTCONF(Signal* signal)
     warningReport(signal, 18);
     return;
   }//if
-  arrGuard(apiConnectptr.p->currentReplicaNo, 4);
+  arrGuard(apiConnectptr.p->currentReplicaNo, MAX_REPLICAS);
   if (tcConnectptr.p->tcNodedata[apiConnectptr.p->currentReplicaNo] !=
       tnodeid) {
     warningReport(signal, 19);
@@ -7564,7 +7564,7 @@ void Dbtc::toAbortHandlingLab(Signal* signal)
   do {
     if (tcurrentReplicaNo != (Uint8)Z8NIL) {
       jam();
-      arrGuard(tcurrentReplicaNo, 4);
+      arrGuard(tcurrentReplicaNo, MAX_REPLICAS);
       const LqhTransConf::OperationStatus stat = 
 	(LqhTransConf::OperationStatus)
 	tcConnectptr.p->failData[tcurrentReplicaNo];
@@ -7698,7 +7698,7 @@ void Dbtc::execCOMMITCONF(Signal* signal)
     warningReport(signal, 10);
     return;
   }//if
-  arrGuard(apiConnectptr.p->currentReplicaNo, 4);
+  arrGuard(apiConnectptr.p->currentReplicaNo, MAX_REPLICAS);
   if (tcConnectptr.p->tcNodedata[apiConnectptr.p->currentReplicaNo] !=
       tnodeid) {
     warningReport(signal, 11);
@@ -7718,7 +7718,7 @@ void Dbtc::toCommitHandlingLab(Signal* signal)
   do {
     if (tcurrentReplicaNo != (Uint8)Z8NIL) {
       jam();
-      arrGuard(tcurrentReplicaNo, 4);
+      arrGuard(tcurrentReplicaNo, MAX_REPLICAS);
       switch (tcConnectptr.p->failData[tcurrentReplicaNo]) {
       case LqhTransConf::InvalidStatus:
         jam();
@@ -7843,7 +7843,7 @@ void Dbtc::execCOMPLETECONF(Signal* signal)
     warningReport(signal, 14);
     return;
   }//if
-  arrGuard(apiConnectptr.p->currentReplicaNo, 4);
+  arrGuard(apiConnectptr.p->currentReplicaNo, MAX_REPLICAS);
   if (tcConnectptr.p->tcNodedata[apiConnectptr.p->currentReplicaNo] !=
       tnodeid) {
     warningReport(signal, 15);
@@ -7863,7 +7863,7 @@ void Dbtc::toCompleteHandlingLab(Signal* signal)
   do {
     if (tcurrentReplicaNo != (Uint8)Z8NIL) {
       jam();
-      arrGuard(tcurrentReplicaNo, 4);
+      arrGuard(tcurrentReplicaNo, MAX_REPLICAS);
       switch (tcConnectptr.p->failData[tcurrentReplicaNo]) {
       case LqhTransConf::InvalidStatus:
         jam();
@@ -8152,6 +8152,7 @@ void Dbtc::setupFailData(Signal* signal)
     case OS_PREPARED:
     case OS_COMMITTING:
       jam();
+      arrGuard(tcConnectptr.p->lastReplicaNo, MAX_REPLICAS);
       for (tindex = 0; tindex <= tcConnectptr.p->lastReplicaNo; tindex++) {
 	jam();
 	/*-------------------------------------------------------------------
@@ -8159,13 +8160,13 @@ void Dbtc::setupFailData(Signal* signal)
 	 * IN THIS CASE ALL LQH'S ARE PREPARED AND WAITING FOR 
 	 * COMMIT/ABORT DECISION.                 
 	 *------------------------------------------------------------------*/
-	arrGuard(tindex, 4);
 	tcConnectptr.p->failData[tindex] = LqhTransConf::Prepared;
       }//for
       break;
     case OS_COMMITTED:
     case OS_COMPLETING:
       jam();
+      arrGuard(tcConnectptr.p->lastReplicaNo, MAX_REPLICAS);
       for (tindex = 0; tindex <= tcConnectptr.p->lastReplicaNo; tindex++) {
 	jam();
 	/*-------------------------------------------------------------------
@@ -8173,19 +8174,18 @@ void Dbtc::setupFailData(Signal* signal)
 	 * IN THIS CASE ALL LQH'S ARE COMMITTED AND WAITING FOR 
 	 * COMPLETE MESSAGE.                     
 	 *------------------------------------------------------------------*/
-	arrGuard(tindex, 4);
 	tcConnectptr.p->failData[tindex] = LqhTransConf::Committed;
       }//for
       break;
     case OS_COMPLETED:
       jam();
+      arrGuard(tcConnectptr.p->lastReplicaNo, MAX_REPLICAS);
       for (tindex = 0; tindex <= tcConnectptr.p->lastReplicaNo; tindex++) {
 	jam();
 	/*-------------------------------------------------------------------
 	 * KEYDATA IS USED TO KEEP AN INDICATION OF STATE IN LQH. 
 	 * IN THIS CASE ALL LQH'S ARE COMPLETED.
 	 *-------------------------------------------------------------------*/
-	arrGuard(tindex, 4);
 	tcConnectptr.p->failData[tindex] = LqhTransConf::InvalidStatus;
       }//for
       break;

