commit c7c0d8de45b0edaf40c4be555b9507a6e54a593c
Author: Andrei Pelinescu-Onciul <andrei@iptel.org>
Date:   Fri Sep 7 15:51:02 2007 +0000

    - fix: binrpc_write_int return overlfow check was wrong -- it failed if
     already at the end of the packet/send buffer and a 0 was written (which
      is represented with a 0 length integer in binrpc). Because of the 0 length
     the overflow check failed and 1 byte was written (the type).

diff --git a/modules_s/ctl/binrpc.h b/modules_s/ctl/binrpc.h
index 6da0ce53c..459af35d3 100644
--- a/modules_s/ctl/binrpc.h
+++ b/modules_s/ctl/binrpc.h
@@ -218,7 +218,8 @@ inline static int binrpc_add_tag(struct binrpc_pkt* pkt, int type, int end)
 
 /*  writes a minimal int, returns the new offset and sets
  * len to the number of bytes written (<=4)
- * to check for oveflow use: returned_value-p < *len
+ * to check for oveflow use: returned_value>=end
+ * or returned_value-p < *len && *len!=0
  */
 inline static unsigned char* binrpc_write_int(	unsigned char* p,
 												unsigned char* end,
@@ -346,7 +347,7 @@ inline static int binrpc_add_int_type(struct binrpc_pkt* pkt, int i, int type)
 	int size;
 	
 	p=binrpc_write_int(pkt->crt+1, pkt->end, i, &size);
-	if ((int)(p-pkt->crt)<(size+1)) goto error_len;
+	if (p>=pkt->end) goto error_len;
 	*(pkt->crt)=(size<<4) | type;
 	pkt->crt=p;
 	return 0;
@@ -398,7 +399,7 @@ inline static int binrpc_add_str_mark(struct binrpc_pkt* pkt, int type,
 		p=pkt->crt+1;
 	}else{ /* we need a separate len */
 		p=binrpc_write_int(pkt->crt+1, pkt->end, l, &size);
-		if ((int)(p-pkt->crt)<(size+1)) goto error_len;
+		if (p>=pkt->end) goto error_len;
 		size|=8; /* mark it as having external len  */
 	}
 	*(pkt->crt)=(size)<<4|type;

