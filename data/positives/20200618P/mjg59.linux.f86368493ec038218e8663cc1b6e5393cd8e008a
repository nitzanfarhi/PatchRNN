commit f86368493ec038218e8663cc1b6e5393cd8e008a
Author: Avi Kivity <avi@redhat.com>
Date:   Thu Feb 3 15:07:07 2011 +0200

    KVM: Fix race between nmi injection and enabling nmi window
    
    The interrupt injection logic looks something like
    
      if an nmi is pending, and nmi injection allowed
        inject nmi
      if an nmi is pending
        request exit on nmi window
    
    the problem is that "nmi is pending" can be set asynchronously by
    the PIT; if it happens to fire between the two if statements, we
    will request an nmi window even though nmi injection is allowed.  On
    SVM, this has disasterous results, since it causes eflags.TF to be
    set in random guest code.
    
    The fix is simple; make nmi_pending synchronous using the standard
    vcpu->requests mechanism; this ensures the code above is completely
    synchronous wrt nmi_pending.
    
    Signed-off-by: Avi Kivity <avi@redhat.com>

diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 8575d85202d7..bd59e8ede88e 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -360,8 +360,8 @@ void kvm_propagate_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)
 
 void kvm_inject_nmi(struct kvm_vcpu *vcpu)
 {
+	kvm_make_request(KVM_REQ_NMI, vcpu);
 	kvm_make_request(KVM_REQ_EVENT, vcpu);
-	vcpu->arch.nmi_pending = 1;
 }
 EXPORT_SYMBOL_GPL(kvm_inject_nmi);
 
@@ -5180,6 +5180,8 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 			r = 1;
 			goto out;
 		}
+		if (kvm_check_request(KVM_REQ_NMI, vcpu))
+			vcpu->arch.nmi_pending = true;
 	}
 
 	r = kvm_mmu_reload(vcpu);
diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
index 3751ea0d1f92..ab428552af8e 100644
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@ -43,6 +43,7 @@
 #define KVM_REQ_DEACTIVATE_FPU    10
 #define KVM_REQ_EVENT             11
 #define KVM_REQ_APF_HALT          12
+#define KVM_REQ_NMI               13
 
 #define KVM_USERSPACE_IRQ_SOURCE_ID	0
 

