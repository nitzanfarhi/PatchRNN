commit 676bd99178cd962ed24ffdad222b7069d330a969
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Thu Oct 1 15:37:19 2015 -0700

    dmapool: fix overflow condition in pool_find_page()
    
    If a DMA pool lies at the very top of the dma_addr_t range (as may
    happen with an IOMMU involved), the calculated end address of the pool
    wraps around to zero, and page lookup always fails.
    
    Tweak the relevant calculation to be overflow-proof.
    
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Cc: Sumit Semwal <sumit.semwal@linaro.org>
    Cc: Sakari Ailus <sakari.ailus@iki.fi>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/mm/dmapool.c b/mm/dmapool.c
index 71a8998cd03a..312a716fa14c 100644
--- a/mm/dmapool.c
+++ b/mm/dmapool.c
@@ -394,7 +394,7 @@ static struct dma_page *pool_find_page(struct dma_pool *pool, dma_addr_t dma)
 	list_for_each_entry(page, &pool->page_list, page_list) {
 		if (dma < page->dma)
 			continue;
-		if (dma < (page->dma + pool->allocation))
+		if ((dma - page->dma) < pool->allocation)
 			return page;
 	}
 	return NULL;

