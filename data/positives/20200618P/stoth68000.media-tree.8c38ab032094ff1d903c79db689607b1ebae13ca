commit 8c38ab032094ff1d903c79db689607b1ebae13ca
Author: David Chinner <david@fromorbit.com>
Date:   Thu Oct 30 17:38:00 2008 +1100

    [XFS] Prevent looping in xfs_sync_inodes_ag
    
    If the last block of the AG has inodes in it and the AG is an exactly
    power-of-2 size then the last inode in the AG points to the last block in
    the AG. If we try to find the next inode in the AG by adding one to the
    inode number, we increment the inode number past the size of the AG. The
    result is that the macro XFS_INO_TO_AGINO() will strip the AG portion of
    the inode number and return an inode number of zero.
    
    That is, instead of terminating the lookup loop because we hit the inode
    number went outside the valid range for the AG, the search index returns
    to zero and we start traversing the radix tree from the start again. This
    results in an endless loop in xfs_sync_inodes_ag().
    
    Fix it be detecting if the new search index decreases as a result of
    incrementing the current inode number. That indicate an overflow and hence
    that we have finished processing the AG so we can terminate the loop.
    
    SGI-PV: 988142
    
    SGI-Modid: xfs-linux-melb:xfs-kern:32335a
    
    Signed-off-by: David Chinner <david@fromorbit.com>
    Signed-off-by: Lachlan McIlroy <lachlan@sgi.com>
    Signed-off-by: Christoph Hellwig <hch@infradead.org>

diff --git a/fs/xfs/linux-2.6/xfs_sync.c b/fs/xfs/linux-2.6/xfs_sync.c
index 22006b5733c4..ee1648b179f7 100644
--- a/fs/xfs/linux-2.6/xfs_sync.c
+++ b/fs/xfs/linux-2.6/xfs_sync.c
@@ -59,7 +59,7 @@ xfs_sync_inodes_ag(
 {
 	xfs_perag_t	*pag = &mp->m_perag[ag];
 	int		nr_found;
-	int		first_index = 0;
+	uint32_t	first_index = 0;
 	int		error = 0;
 	int		last_error = 0;
 	int		fflag = XFS_B_ASYNC;
@@ -97,8 +97,17 @@ xfs_sync_inodes_ag(
 			break;
 		}
 
-		/* update the index for the next lookup */
+		/*
+		 * Update the index for the next lookup. Catch overflows
+		 * into the next AG range which can occur if we have inodes
+		 * in the last block of the AG and we are currently
+		 * pointing to the last inode.
+		 */
 		first_index = XFS_INO_TO_AGINO(mp, ip->i_ino + 1);
+		if (first_index < XFS_INO_TO_AGINO(mp, ip->i_ino)) {
+			read_unlock(&pag->pag_ici_lock);
+			break;
+		}
 
 		/*
 		 * skip inodes in reclaim. Let xfs_syncsub do that for
@@ -702,7 +711,7 @@ xfs_reclaim_inodes_ag(
 	xfs_inode_t	*ip = NULL;
 	xfs_perag_t	*pag = &mp->m_perag[ag];
 	int		nr_found;
-	int		first_index;
+	uint32_t	first_index;
 	int		skipped;
 
 restart:
@@ -724,8 +733,17 @@ xfs_reclaim_inodes_ag(
 			break;
 		}
 
-		/* update the index for the next lookup */
+		/*
+		 * Update the index for the next lookup. Catch overflows
+		 * into the next AG range which can occur if we have inodes
+		 * in the last block of the AG and we are currently
+		 * pointing to the last inode.
+		 */
 		first_index = XFS_INO_TO_AGINO(mp, ip->i_ino + 1);
+		if (first_index < XFS_INO_TO_AGINO(mp, ip->i_ino)) {
+			read_unlock(&pag->pag_ici_lock);
+			break;
+		}
 
 		ASSERT(xfs_iflags_test(ip, (XFS_IRECLAIMABLE|XFS_IRECLAIM)));
 

