commit 2b4de2d21c152c45f4caea1d81d6e7e2a856c6de
Author: Yehuda Sadeh <yehuda@redhat.com>
Date:   Tue Sep 15 17:03:23 2015 -0700

    rgw: initial work on data sync run
    
    Signed-off-by: Yehuda Sadeh <yehuda@redhat.com>

diff --git a/src/rgw/rgw_admin.cc b/src/rgw/rgw_admin.cc
index e547822c5a..1f20e016d9 100644
--- a/src/rgw/rgw_admin.cc
+++ b/src/rgw/rgw_admin.cc
@@ -3869,6 +3869,26 @@ next:
     }
   }
 
+  if (opt_cmd == OPT_DATA_SYNC_RUN) {
+    if (source_zone.empty()) {
+      cerr << "ERROR: source zone not specified" << std::endl;
+      return EINVAL;
+    }
+    RGWDataSyncStatusManager sync(store, source_zone);
+
+    int ret = sync.init();
+    if (ret < 0) {
+      cerr << "ERROR: sync.init() returned ret=" << ret << std::endl;
+      return -ret;
+    }
+
+    ret = sync.run();
+    if (ret < 0) {
+      cerr << "ERROR: sync.run() returned ret=" << ret << std::endl;
+      return -ret;
+    }
+  }
+
   if (opt_cmd == OPT_BILOG_LIST) {
     if (bucket_name.empty()) {
       cerr << "ERROR: bucket not specified" << std::endl;
diff --git a/src/rgw/rgw_cr_rados.h b/src/rgw/rgw_cr_rados.h
index 76db4cfb01..e84419236f 100644
--- a/src/rgw/rgw_cr_rados.h
+++ b/src/rgw/rgw_cr_rados.h
@@ -406,4 +406,36 @@ public:
   }
 };
 
+class RGWShardedOmapCRManager {
+  RGWAsyncRadosProcessor *async_rados;
+  RGWRados *store;
+  RGWCoroutine *op;
+
+  int num_shards;
+
+  vector<RGWOmapAppend *> shards;
+public:
+  RGWShardedOmapCRManager(RGWAsyncRadosProcessor *_async_rados, RGWRados *_store, RGWCoroutine *_op, int _num_shards, rgw_bucket& pool, const string& oid_prefix)
+                      : async_rados(_async_rados),
+		        store(_store), op(_op), num_shards(_num_shards) {
+    shards.reserve(num_shards);
+    for (int i = 0; i < num_shards; ++i) {
+      char buf[oid_prefix.size() + 16];
+      snprintf(buf, sizeof(buf), "%s.%d", oid_prefix.c_str(), i);
+      RGWOmapAppend *shard = new RGWOmapAppend(async_rados, store, pool, buf);
+      shards.push_back(shard);
+      op->spawn(shard, false);
+    }
+  }
+  void append(const string& entry) {
+    int shard_id = store->key_to_shard_id(entry, shards.size());
+    shards[shard_id]->append(entry);
+  }
+  void finish() {
+    for (vector<RGWOmapAppend *>::iterator iter = shards.begin(); iter != shards.end(); ++iter) {
+      (*iter)->finish();
+    }
+  }
+};
+
 #endif
diff --git a/src/rgw/rgw_data_sync.cc b/src/rgw/rgw_data_sync.cc
index de6d27f754..a9d3892865 100644
--- a/src/rgw/rgw_data_sync.cc
+++ b/src/rgw/rgw_data_sync.cc
@@ -364,6 +364,115 @@ int RGWRemoteDataLog::init_sync_status(int num_shards)
   return run(new RGWInitDataSyncStatusCoroutine(async_rados, store, &http_manager, obj_ctx, source_zone, num_shards));
 }
 
+int RGWRemoteDataLog::set_sync_info(const rgw_data_sync_info& sync_info)
+{
+  return run(new RGWSimpleRadosWriteCR<rgw_data_sync_info>(async_rados, store, store->get_zone_params().log_pool,
+				 datalog_sync_status_oid, sync_info));
+}
+
+class RGWListBucketIndexesCR : public RGWCoroutine {
+  RGWRados *store;
+  RGWHTTPManager *http_manager;
+  RGWAsyncRadosProcessor *async_rados;
+
+  RGWRESTConn *conn;
+  string source_zone;
+  int num_shards;
+
+  int req_ret;
+
+  list<string> result;
+
+  RGWShardedOmapCRManager *entries_index;
+
+  string oid_prefix;
+
+public:
+  RGWListBucketIndexesCR(RGWRados *_store, RGWHTTPManager *_mgr, RGWAsyncRadosProcessor *_async_rados,
+                         RGWRESTConn *_conn,
+                         const string& _source_zone, int _num_shards) : RGWCoroutine(_store->ctx()), store(_store),
+                                                      http_manager(_mgr),
+						      async_rados(_async_rados),
+						      conn(_conn), source_zone(_source_zone), num_shards(_num_shards),
+						      req_ret(0), entries_index(NULL) {
+    oid_prefix = datalog_sync_full_sync_index_prefix + "." + source_zone; 
+  }
+  ~RGWListBucketIndexesCR() {
+    delete entries_index;
+  }
+
+  int operate() {
+    reenter(this) {
+      entries_index = new RGWShardedOmapCRManager(async_rados, store, this, num_shards,
+						  store->get_zone_params().log_pool,
+                                                  oid_prefix);
+      yield {
+        string entrypoint = string("/admin/metadata/bucket.instance");
+#warning need a better scaling solution here, requires streaming output
+        call(new RGWReadRESTResourceCR<list<string> >(store->ctx(), conn, http_manager,
+                                                      entrypoint, NULL, &result));
+      }
+      yield {
+        if (get_ret_status() < 0) {
+          ldout(store->ctx(), 0) << "ERROR: failed to fetch metadata for section bucket.index" << dendl;
+          return set_state(RGWCoroutine_Error);
+        }
+        for (list<string>::iterator iter = result.begin(); iter != result.end(); ++iter) {
+          ldout(store->ctx(), 20) << "list metadata: section=bucket.index key=" << *iter << dendl;
+          entries_index->append(*iter);
+#warning error handling of shards
+        }
+      }
+      yield entries_index->finish();
+      int ret;
+      while (collect(&ret)) {
+	if (ret < 0) {
+	  return set_state(RGWCoroutine_Error);
+	}
+        yield;
+      }
+      yield return set_state(RGWCoroutine_Done);
+    }
+    return 0;
+  }
+};
+
+int RGWRemoteDataLog::run_sync(int num_shards, rgw_data_sync_status& sync_status)
+{
+  RGWObjectCtx obj_ctx(store, NULL);
+
+  int r = run(new RGWReadDataSyncStatusCoroutine(async_rados, store, obj_ctx, source_zone, &sync_status));
+  if (r < 0) {
+    ldout(store->ctx(), 0) << "ERROR: failed to fetch sync status" << dendl;
+    return r;
+  }
+
+  switch ((rgw_data_sync_info::SyncState)sync_status.sync_info.state) {
+    case rgw_data_sync_info::StateInit:
+      ldout(store->ctx(), 20) << __func__ << "(): init" << dendl;
+      r = run(new RGWInitDataSyncStatusCoroutine(async_rados, store, &http_manager, obj_ctx, source_zone, num_shards));
+      /* fall through */
+    case rgw_data_sync_info::StateBuildingFullSyncMaps:
+      ldout(store->ctx(), 20) << __func__ << "(): building full sync maps" << dendl;
+      r = run(new RGWListBucketIndexesCR(store, &http_manager, async_rados, conn, source_zone, num_shards));
+      sync_status.sync_info.state = rgw_data_sync_info::StateSync;
+      r = set_sync_info(sync_status.sync_info);
+      if (r < 0) {
+        ldout(store->ctx(), 0) << "ERROR: failed to update sync status" << dendl;
+        return r;
+      }
+      /* fall through */
+    case rgw_data_sync_info::StateSync:
+#warning FIXME
+      break;
+    default:
+      ldout(store->ctx(), 0) << "ERROR: bad sync state!" << dendl;
+      return -EIO;
+  }
+
+  return 0;
+}
+
 int RGWDataSyncStatusManager::init()
 {
   map<string, RGWRESTConn *>::iterator iter = store->zone_conn_map.find(source_zone);
diff --git a/src/rgw/rgw_sync.cc b/src/rgw/rgw_sync.cc
index c849248e0e..4e1fcaf3a8 100644
--- a/src/rgw/rgw_sync.cc
+++ b/src/rgw/rgw_sync.cc
@@ -515,38 +515,6 @@ int RGWReadSyncStatusCoroutine::handle_data(rgw_meta_sync_info& data)
   return 0;
 }
 
-class RGWShardedOmapCRManager {
-  RGWAsyncRadosProcessor *async_rados;
-  RGWRados *store;
-  RGWCoroutine *op;
-
-  int num_shards;
-
-  vector<RGWOmapAppend *> shards;
-public:
-  RGWShardedOmapCRManager(RGWAsyncRadosProcessor *_async_rados, RGWRados *_store, RGWCoroutine *_op, int _num_shards, rgw_bucket& pool, const string& oid_prefix)
-                      : async_rados(_async_rados),
-		        store(_store), op(_op), num_shards(_num_shards) {
-    shards.reserve(num_shards);
-    for (int i = 0; i < num_shards; ++i) {
-      char buf[oid_prefix.size() + 16];
-      snprintf(buf, sizeof(buf), "%s.%d", oid_prefix.c_str(), i);
-      RGWOmapAppend *shard = new RGWOmapAppend(async_rados, store, pool, buf);
-      shards.push_back(shard);
-      op->spawn(shard, false);
-    }
-  }
-  void append(const string& entry) {
-    int shard_id = store->key_to_shard_id(entry, shards.size());
-    shards[shard_id]->append(entry);
-  }
-  void finish() {
-    for (vector<RGWOmapAppend *>::iterator iter = shards.begin(); iter != shards.end(); ++iter) {
-      (*iter)->finish();
-    }
-  }
-};
-
 class RGWFetchAllMetaCR : public RGWCoroutine {
   RGWRados *store;
   RGWHTTPManager *http_manager;

