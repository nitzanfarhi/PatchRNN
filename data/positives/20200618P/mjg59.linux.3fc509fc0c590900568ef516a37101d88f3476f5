commit 3fc509fc0c590900568ef516a37101d88f3476f5
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Thu Aug 16 16:38:55 2012 -0400

    xen/p2m: When revectoring deal with holes in the P2M array.
    
    When we free the PFNs and then subsequently populate them back
    during bootup:
    
    Freeing 20000-20200 pfn range: 512 pages freed
    1-1 mapping on 20000->20200
    Freeing 40000-40200 pfn range: 512 pages freed
    1-1 mapping on 40000->40200
    Freeing bad80-badf4 pfn range: 116 pages freed
    1-1 mapping on bad80->badf4
    Freeing badf6-bae7f pfn range: 137 pages freed
    1-1 mapping on badf6->bae7f
    Freeing bb000-100000 pfn range: 282624 pages freed
    1-1 mapping on bb000->100000
    Released 283999 pages of unused memory
    Set 283999 page(s) to 1-1 mapping
    Populating 1acb8a-1f20e9 pfn range: 283999 pages added
    
    We end up having the P2M array (that is the one that was
    grafted on the P2M tree) filled with IDENTITY_FRAME or
    INVALID_P2M_ENTRY) entries. The patch titled
    
    "xen/p2m: Reuse existing P2M leafs if they are filled with 1:1 PFNs or INVALID."
    recycles said slots and replaces the P2M tree leaf's with
     &mfn_list[xx] with p2m_identity or p2m_missing.
    
    And re-uses the P2M array sections for other P2M tree leaf's.
    For the above mentioned bootup excerpt, the PFNs at
    0x20000->0x20200 are going to be IDENTITY based:
    
    P2M[0][256][0] -> P2M[0][257][0] get turned in IDENTITY_FRAME.
    
    We can re-use that and replace P2M[0][256] to point to p2m_identity.
    The "old" page (the grafted P2M array provided by Xen) that was at
    P2M[0][256] gets put somewhere else. Specifically at P2M[6][358],
    b/c when we populate back:
    
    Populating 1acb8a-1f20e9 pfn range: 283999 pages added
    
    we fill P2M[6][358][0] (and P2M[6][358], P2M[6][359], ...) with
    the new MFNs.
    
    That is all OK, except when we revector we assume that the PFN
    count would be the same in the grafted P2M array and in the
    newly allocated. Since that is no longer the case, as we have
    holes in the P2M that point to p2m_missing or p2m_identity we
    have to take that into account.
    
    [v2: Check for overflow]
    [v3: Move within the __va check]
    [v4: Fix the computation]
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/arch/x86/xen/p2m.c b/arch/x86/xen/p2m.c
index 996ee2bf7bdb..c3e92912c3fb 100644
--- a/arch/x86/xen/p2m.c
+++ b/arch/x86/xen/p2m.c
@@ -396,6 +396,7 @@ unsigned long __init xen_revector_p2m_tree(void)
 	unsigned long va_start;
 	unsigned long va_end;
 	unsigned long pfn;
+	unsigned long pfn_free = 0;
 	unsigned long *mfn_list = NULL;
 	unsigned long size;
 
@@ -442,11 +443,18 @@ unsigned long __init xen_revector_p2m_tree(void)
 		if (mid_p >= (unsigned long *)va_start && mid_p <= (unsigned long *)va_end) {
 			unsigned long *new;
 
-			new = &mfn_list[pfn];
+			if (pfn_free  > (size / sizeof(unsigned long))) {
+				WARN(1, "Only allocated for %ld pages, but we want %ld!\n",
+				     size / sizeof(unsigned long), pfn_free);
+				return 0;
+			}
+			new = &mfn_list[pfn_free];
 
 			copy_page(new, mid_p);
-			p2m_top[topidx][mididx] = &mfn_list[pfn];
-			p2m_top_mfn_p[topidx][mididx] = virt_to_mfn(&mfn_list[pfn]);
+			p2m_top[topidx][mididx] = &mfn_list[pfn_free];
+			p2m_top_mfn_p[topidx][mididx] = virt_to_mfn(&mfn_list[pfn_free]);
+
+			pfn_free += P2M_PER_PAGE;
 
 		}
 		/* This should be the leafs allocated for identity from _brk. */

