commit 99c2594f0e13de1ca84f97efc3f9e7bc49f91e11
Author: Adrian Hunter <ext-adrian.hunter@nokia.com>
Date:   Thu Mar 29 11:00:47 2007 +0300

    [JFFS2] Prevent list corruption when handling write errors
    
    If a write error occurs, the affected block is placed on the
    bad_used_list.  In the case that the write error occured
    when writing summary data the block was also being placed on
    the dirty_list, which caused list corruption and ultimately
    a soft lockup in jffs2_mark_node_obsolete. This fixes that.
    
    Signed-off-by: Adrian Hunter <ext-adrian.hunter@nokia.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/fs/jffs2/nodemgmt.c b/fs/jffs2/nodemgmt.c
index d88376992ed9..c8b50dea9e14 100644
--- a/fs/jffs2/nodemgmt.c
+++ b/fs/jffs2/nodemgmt.c
@@ -172,6 +172,11 @@ int jffs2_reserve_space_gc(struct jffs2_sb_info *c, uint32_t minsize,
 static void jffs2_close_nextblock(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
 {
 
+	if (c->nextblock == NULL) {
+		D1(printk(KERN_DEBUG "jffs2_close_nextblock: Erase block at 0x%08x has already been placed in a list\n",
+		  jeb->offset));
+		return;
+	}
 	/* Check, if we have a dirty block now, or if it was dirty already */
 	if (ISDIRTY (jeb->wasted_size + jeb->dirty_size)) {
 		c->dirty_size += jeb->wasted_size;

