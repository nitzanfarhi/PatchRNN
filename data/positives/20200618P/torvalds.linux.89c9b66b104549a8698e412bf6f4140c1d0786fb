commit 89c9b66b104549a8698e412bf6f4140c1d0786fb
Author: Jan Glauber <jang@linux.vnet.ibm.com>
Date:   Sun Jul 24 10:48:27 2011 +0200

    [S390] race safe external interrupt registration
    
    The (un-)register_external_interrupt functions are not race safe if
    more than one interrupt handler is added or deleted for an external
    interrupt concurrently.
    
    Make the registration / unregistration of external interrupts race safe
    by using RCU and a spinlock. RCU is used to avoid a performance penalty
    in the external interrupt handler, the register and unregister functions
    are protected by the spinlock and are not performance critical.
    call_rcu must be used since the SCLP driver uses the interface with
    IRQs disabled. Also use the generic list implementation rather than
    homebrewn list code.
    
    Signed-off-by: Jan Glauber <jang@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/arch/s390/kernel/irq.c b/arch/s390/kernel/irq.c
index e3264f6a9720..1f4050d45f78 100644
--- a/arch/s390/kernel/irq.c
+++ b/arch/s390/kernel/irq.c
@@ -87,15 +87,6 @@ int show_interrupts(struct seq_file *p, void *v)
         return 0;
 }
 
-/*
- * For compatibilty only. S/390 specific setup of interrupts et al. is done
- * much later in init_channel_subsystem().
- */
-void __init init_IRQ(void)
-{
-	/* nothing... */
-}
-
 /*
  * Switch to the asynchronous interrupt stack for softirq execution.
  */
@@ -144,28 +135,45 @@ void init_irq_proc(void)
 #endif
 
 /*
- * ext_int_hash[index] is the start of the list for all external interrupts
- * that hash to this index. With the current set of external interrupts
- * (0x1202 external call, 0x1004 cpu timer, 0x2401 hwc console, 0x4000
- * iucv and 0x2603 pfault) this is always the first element.
+ * ext_int_hash[index] is the list head for all external interrupts that hash
+ * to this index.
  */
+static struct list_head ext_int_hash[256];
 
 struct ext_int_info {
-	struct ext_int_info *next;
 	ext_int_handler_t handler;
 	u16 code;
+	struct list_head entry;
+	struct rcu_head rcu;
 };
 
-static struct ext_int_info *ext_int_hash[256];
+/* ext_int_hash_lock protects the handler lists for external interrupts */
+DEFINE_SPINLOCK(ext_int_hash_lock);
+
+static void __init init_external_interrupts(void)
+{
+	int idx;
+
+	for (idx = 0; idx < ARRAY_SIZE(ext_int_hash); idx++)
+		INIT_LIST_HEAD(&ext_int_hash[idx]);
+}
 
 static inline int ext_hash(u16 code)
 {
 	return (code + (code >> 9)) & 0xff;
 }
 
+static void ext_int_hash_update(struct rcu_head *head)
+{
+	struct ext_int_info *p = container_of(head, struct ext_int_info, rcu);
+
+	kfree(p);
+}
+
 int register_external_interrupt(u16 code, ext_int_handler_t handler)
 {
 	struct ext_int_info *p;
+	unsigned long flags;
 	int index;
 
 	p = kmalloc(sizeof(*p), GFP_ATOMIC);
@@ -174,33 +182,27 @@ int register_external_interrupt(u16 code, ext_int_handler_t handler)
 	p->code = code;
 	p->handler = handler;
 	index = ext_hash(code);
-	p->next = ext_int_hash[index];
-	ext_int_hash[index] = p;
+
+	spin_lock_irqsave(&ext_int_hash_lock, flags);
+	list_add_rcu(&p->entry, &ext_int_hash[index]);
+	spin_unlock_irqrestore(&ext_int_hash_lock, flags);
 	return 0;
 }
 EXPORT_SYMBOL(register_external_interrupt);
 
 int unregister_external_interrupt(u16 code, ext_int_handler_t handler)
 {
-	struct ext_int_info *p, *q;
-	int index;
+	struct ext_int_info *p;
+	unsigned long flags;
+	int index = ext_hash(code);
 
-	index = ext_hash(code);
-	q = NULL;
-	p = ext_int_hash[index];
-	while (p) {
-		if (p->code == code && p->handler == handler)
-			break;
-		q = p;
-		p = p->next;
-	}
-	if (!p)
-		return -ENOENT;
-	if (q)
-		q->next = p->next;
-	else
-		ext_int_hash[index] = p->next;
-	kfree(p);
+	spin_lock_irqsave(&ext_int_hash_lock, flags);
+	list_for_each_entry_rcu(p, &ext_int_hash[index], entry)
+		if (p->code == code && p->handler == handler) {
+			list_del_rcu(&p->entry);
+			call_rcu(&p->rcu, ext_int_hash_update);
+		}
+	spin_unlock_irqrestore(&ext_int_hash_lock, flags);
 	return 0;
 }
 EXPORT_SYMBOL(unregister_external_interrupt);
@@ -224,15 +226,22 @@ void __irq_entry do_extint(struct pt_regs *regs, unsigned int ext_int_code,
 	kstat_cpu(smp_processor_id()).irqs[EXTERNAL_INTERRUPT]++;
 	if (code != 0x1004)
 		__get_cpu_var(s390_idle).nohz_delay = 1;
+
 	index = ext_hash(code);
-	for (p = ext_int_hash[index]; p; p = p->next) {
+	rcu_read_lock();
+	list_for_each_entry_rcu(p, &ext_int_hash[index], entry)
 		if (likely(p->code == code))
 			p->handler(ext_int_code, param32, param64);
-	}
+	rcu_read_unlock();
 	irq_exit();
 	set_irq_regs(old_regs);
 }
 
+void __init init_IRQ(void)
+{
+	init_external_interrupts();
+}
+
 static DEFINE_SPINLOCK(sc_irq_lock);
 static int sc_irq_refcount;
 

