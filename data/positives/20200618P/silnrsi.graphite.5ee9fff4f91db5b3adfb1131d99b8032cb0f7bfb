commit 5ee9fff4f91db5b3adfb1131d99b8032cb0f7bfb
Author: Martin Hosken <martin_hosken@sil.org>
Date:   Fri Dec 14 15:14:04 2012 +0700

    Freeing a slot disconnects parents and children

diff --git a/src/Segment.cpp b/src/Segment.cpp
index 6e6687c..6893c31 100644
--- a/src/Segment.cpp
+++ b/src/Segment.cpp
@@ -185,6 +185,13 @@ void Segment::freeSlot(Slot *aSlot)
 {
     if (m_last == aSlot) m_last = aSlot->prev();
     if (m_first == aSlot) m_first = aSlot->next();
+    if (aSlot->attachedTo())
+        aSlot->attachedTo()->removeChild(aSlot);
+    while (aSlot->firstChild())
+    {
+        aSlot->firstChild()->attachTo(NULL);
+        aSlot->removeChild(aSlot->firstChild());
+    }
     // reset the slot incase it is reused
     ::new (aSlot) Slot;
     memset(aSlot->userAttrs(), 0, m_silf->numUser() * sizeof(int16));
diff --git a/src/Slot.cpp b/src/Slot.cpp
index 350cb68..4ec68ea 100644
--- a/src/Slot.cpp
+++ b/src/Slot.cpp
@@ -352,6 +352,7 @@ bool Slot::removeChild(Slot *ap)
     if (this == ap || !m_child) return false;
     else if (ap == m_child)
     {
+        m_child->sibling(NULL);
         m_child = m_child->nextSibling();
         return true;
     }

