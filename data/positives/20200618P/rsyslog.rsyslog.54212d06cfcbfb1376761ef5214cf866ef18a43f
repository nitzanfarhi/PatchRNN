commit 54212d06cfcbfb1376761ef5214cf866ef18a43f
Author: Tomas Heinrich <theinric@redhat.com>
Date:   Wed Jul 16 17:03:16 2014 +0200

    bugfix: prevent an invalid free() and plug a memleak
    
    pbMustBeFreed must not be set when returning a constant.

diff --git a/runtime/msg.c b/runtime/msg.c
index 09ad6f1a4..2d811b234 100644
--- a/runtime/msg.c
+++ b/runtime/msg.c
@@ -3038,13 +3038,15 @@ uchar *MsgGetProp(msg_t * const pMsg, struct templateEntry *pTpe,
 			if((pRes = (uchar*) MALLOC(sizeof(uchar) * 32)) == NULL) {
 				RET_OUT_OF_MEMORY;
 			}
-			*pbMustBeFreed = 1;
  
 			if(clock_gettime(CLOCK_UPTIME, &tp) == -1) {
+				free(pRes);
  				*pPropLen = sizeof("**SYSCALL FAILED**") - 1;
  				return(UCHAR_CONSTANT("**SYSCALL FAILED**"));
  			}
  
+			*pbMustBeFreed = 1;
+
 			snprintf((char*) pRes, sizeof(uchar) * 32, "%ld", tp.tv_sec);
  			}
 
@@ -3056,13 +3058,15 @@ uchar *MsgGetProp(msg_t * const pMsg, struct templateEntry *pTpe,
 			if((pRes = (uchar*) MALLOC(sizeof(uchar) * 32)) == NULL) {
 				RET_OUT_OF_MEMORY;
 			}
-			*pbMustBeFreed = 1;
 
 			if(sysinfo(&s_info) < 0) {
+				free(pRes);
 				*pPropLen = sizeof("**SYSCALL FAILED**") - 1;
 				return(UCHAR_CONSTANT("**SYSCALL FAILED**"));
 			}
 
+			*pbMustBeFreed = 1;
+
 			snprintf((char*) pRes, sizeof(uchar) * 32, "%ld", s_info.uptime);
 			}
 #			endif

