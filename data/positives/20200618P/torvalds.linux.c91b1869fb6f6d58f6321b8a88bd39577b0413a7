commit c91b1869fb6f6d58f6321b8a88bd39577b0413a7
Author: Malcolm Priestley <tvboxspy@gmail.com>
Date:   Thu May 15 22:49:19 2014 +0100

    staging: vt6656: lock changes: usbpipe.c add mutex lock.
    
    PIPEnsControlOut and PIPEnsControlIn are nolonger
    atomic but they do need a usb lock.
    
    Add new mutex lock for these functions and PIPEnsControlOutAsyn.
    
    Signed-off-by: Malcolm Priestley <tvboxspy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vt6656/device.h b/drivers/staging/vt6656/device.h
index f36a2eb826b7..622cf02f5c8a 100644
--- a/drivers/staging/vt6656/device.h
+++ b/drivers/staging/vt6656/device.h
@@ -363,6 +363,7 @@ struct vnt_private {
 	u8 byRxMode;
 
 	spinlock_t lock;
+	struct mutex usb_lock;
 
 	u32 rx_bytes;
 
diff --git a/drivers/staging/vt6656/main_usb.c b/drivers/staging/vt6656/main_usb.c
index e99d2a9378a5..14e649a66beb 100644
--- a/drivers/staging/vt6656/main_usb.c
+++ b/drivers/staging/vt6656/main_usb.c
@@ -695,6 +695,8 @@ vt6656_probe(struct usb_interface *intf, const struct usb_device_id *id)
 
 	device_set_options(pDevice);
 	spin_lock_init(&pDevice->lock);
+	mutex_init(&pDevice->usb_lock);
+
 	INIT_DELAYED_WORK(&pDevice->run_command_work, vRunCommand);
 	INIT_DELAYED_WORK(&pDevice->second_callback_work, BSSvSecondCallBack);
 	INIT_WORK(&pDevice->read_work_item, RXvWorkItem);
diff --git a/drivers/staging/vt6656/usbpipe.c b/drivers/staging/vt6656/usbpipe.c
index 836da00bfaac..934d0a92363b 100644
--- a/drivers/staging/vt6656/usbpipe.c
+++ b/drivers/staging/vt6656/usbpipe.c
@@ -82,6 +82,8 @@ int PIPEnsControlOutAsyn(struct vnt_private *pDevice, u8 byRequest,
         return STATUS_FAILURE;
     }
 
+	mutex_lock(&pDevice->usb_lock);
+
     ntStatus = usb_control_msg(
                             pDevice->usb,
                             usb_sndctrlpipe(pDevice->usb , 0),
@@ -100,6 +102,8 @@ int PIPEnsControlOutAsyn(struct vnt_private *pDevice, u8 byRequest,
         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"usb_sndctrlpipe fail, ntStatus= %d\n", ntStatus);
     }
 
+	mutex_unlock(&pDevice->usb_lock);
+
     return ntStatus;
 }
 
@@ -123,6 +127,8 @@ int PIPEnsControlOut(struct vnt_private *pDevice, u8 byRequest, u16 wValue,
 	if (pDevice->pControlURB->hcpriv)
 		return STATUS_FAILURE;
 
+	mutex_lock(&pDevice->usb_lock);
+
 	MP_SET_FLAG(pDevice, fMP_CONTROL_WRITES);
 
 	pDevice->sUsbCtlRequest.bRequestType = 0x40;
@@ -143,6 +149,7 @@ int PIPEnsControlOut(struct vnt_private *pDevice, u8 byRequest, u16 wValue,
 			"control send request submission failed: %d\n",
 				ntStatus);
 		MP_CLEAR_FLAG(pDevice, fMP_CONTROL_WRITES);
+		mutex_unlock(&pDevice->usb_lock);
 		return STATUS_FAILURE;
 	}
 
@@ -157,10 +164,13 @@ int PIPEnsControlOut(struct vnt_private *pDevice, u8 byRequest, u16 wValue,
 		DBG_PRT(MSG_LEVEL_DEBUG,
 			KERN_INFO "control send request submission timeout\n");
             MP_CLEAR_FLAG(pDevice, fMP_CONTROL_WRITES);
+	    mutex_unlock(&pDevice->usb_lock);
             return STATUS_FAILURE;
         }
     }
 
+	mutex_unlock(&pDevice->usb_lock);
+
     return STATUS_SUCCESS;
 }
 
@@ -184,6 +194,8 @@ int PIPEnsControlIn(struct vnt_private *pDevice, u8 byRequest, u16 wValue,
 	if (pDevice->pControlURB->hcpriv)
 		return STATUS_FAILURE;
 
+	mutex_lock(&pDevice->usb_lock);
+
 	MP_SET_FLAG(pDevice, fMP_CONTROL_READS);
 
 	pDevice->sUsbCtlRequest.bRequestType = 0xC0;
@@ -202,6 +214,7 @@ int PIPEnsControlIn(struct vnt_private *pDevice, u8 byRequest, u16 wValue,
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO
 			"control request submission failed: %d\n", ntStatus);
 		MP_CLEAR_FLAG(pDevice, fMP_CONTROL_READS);
+		mutex_unlock(&pDevice->usb_lock);
 		return STATUS_FAILURE;
 	}
 
@@ -216,10 +229,13 @@ int PIPEnsControlIn(struct vnt_private *pDevice, u8 byRequest, u16 wValue,
 		DBG_PRT(MSG_LEVEL_DEBUG,
 			KERN_INFO "control rcv request submission timeout\n");
             MP_CLEAR_FLAG(pDevice, fMP_CONTROL_READS);
+	    mutex_unlock(&pDevice->usb_lock);
             return STATUS_FAILURE;
         }
     }
 
+	mutex_unlock(&pDevice->usb_lock);
+
     return ntStatus;
 }
 

