commit 660ddcb4abdbe7899f3a139dc73760178dda0473
Author: axel <axel@liljencrantz.se>
Date:   Sat Oct 1 04:28:26 2005 +1000

    Cast null pointers to (void *) in vararg functions
    
    darcs-hash:20050930182826-ac50b-fa9960404bf69e57531ad02becb5015aaed35d69.gz

diff --git a/builtin.c b/builtin.c
index b5a7f0b4..3eb679c9 100644
--- a/builtin.c
+++ b/builtin.c
@@ -115,13 +115,13 @@ static void builtin_wperror( const wchar_t *s)
 {
 	if( s != 0 )
 	{
-		sb_append2( sb_err, s, L": ", 0 );
+		sb_append2( sb_err, s, L": ", (void *)0 );
 	}
 	char *err = strerror( errno );
 	wchar_t *werr = str2wcs( err );
 	if( werr )
 	{
-		sb_append2( sb_err,  werr, L"\n", 0 );	
+		sb_append2( sb_err,  werr, L"\n", (void *)0 );	
 		free( werr );
 	}	
 }
@@ -297,7 +297,7 @@ static int builtin_builtin(  wchar_t **argv )
 							L" ",
 							long_options[opt_index].name,
 							L"\n",
-							0);				
+							(void *)0);				
 				builtin_print_help( argv[0], sb_err );
 	
 				
@@ -340,7 +340,7 @@ static int builtin_builtin(  wchar_t **argv )
 			sb_append2( sb_out,
 						names_arr[i],
 						L"\n",
-						0 );			
+						(void *)0 );			
 		}
 		free( names_arr );
 		al_destroy( &names );			
@@ -395,7 +395,7 @@ static int builtin_generic( wchar_t **argv )
 							L" ",
 							long_options[opt_index].name,
 							L"\n",
-							0);				
+							(void *)0);				
 				builtin_print_help( argv[0], sb_err );
 				return 1;
 				
@@ -459,7 +459,7 @@ static int builtin_exec( wchar_t **argv )
 							L" ",
 							long_options[opt_index].name,
 							L"\n",
-							0);				
+							(void *)0);				
 				builtin_print_help( argv[0], sb_err );
 				return 1;
 				
@@ -545,7 +545,7 @@ static int builtin_functions( wchar_t **argv )
 							L" ",
 							long_options[opt_index].name,
 							L"\n",
-							0);				
+							(void *)0);				
 				builtin_print_help( argv[0], sb_err );
 	
 				
@@ -586,7 +586,7 @@ static int builtin_functions( wchar_t **argv )
 		sb_append2( sb_err,
 					argv[0],
 					L": Invalid combination of options\n",
-					0);				
+					(void *)0);				
 		builtin_print_help( argv[0], sb_err );
 		
 		return 1;
@@ -608,7 +608,7 @@ static int builtin_functions( wchar_t **argv )
 		{
 			sb_append2( sb_err,
 						L"functions: Expected exactly one function name\n",
-						0);				
+						(void *)0);				
 			builtin_print_help( argv[0], sb_err );
 			
 			return 1;
@@ -620,7 +620,7 @@ static int builtin_functions( wchar_t **argv )
 						L"functions: Function ",
 						func,
 						L" does not exist\n",
-						0);				
+						(void *)0);				
 			builtin_print_help( argv[0], sb_err );
 			
 			return 1;			
@@ -644,7 +644,7 @@ static int builtin_functions( wchar_t **argv )
 			sb_append2( sb_out,
 						names_arr[i],
 						L"\n",
-						0 );			
+						(void *)0 );			
 		}
 		free( names_arr );
 		al_destroy( &names );			
@@ -672,7 +672,7 @@ static int builtin_functions( wchar_t **argv )
 							L"\n\t",
 							function_get_definition(names_arr[i]),
 							L"\nend\n\n",
-							0);
+							(void *)0);
 			}
 			free( names_arr );
 			al_destroy( &names );			
@@ -688,7 +688,7 @@ static int builtin_functions( wchar_t **argv )
 							L"\n\t",
 							function_get_definition(argv[i]),
 							L"\nend\n\n",
-							0);
+							(void *)0);
 
 			break;
 		}
@@ -769,7 +769,7 @@ static int builtin_function( wchar_t **argv )
 							L" ",
 							long_options[opt_index].name,
 							L"\n",
-							0);				
+							(void *)0);				
 				builtin_print_help( argv[0], sb_err );
 				
 				return 1;
@@ -807,7 +807,7 @@ static int builtin_function( wchar_t **argv )
 					L": illegal function name \'", 
 					argv[woptind], 
 					L"\'\n", 
-					0 );
+					(void *)0 );
 
 		res=1;	
 	}	
@@ -819,7 +819,7 @@ static int builtin_function( wchar_t **argv )
 					L": the name \'",
                     argv[woptind],
                     L"\' is reserved,\nand can not be used as a function name\n",
-                    0 );
+                    (void *)0 );
         res=1;
     }
 	
@@ -852,7 +852,7 @@ static int builtin_function( wchar_t **argv )
 			}
 			
 			sb_append2( sb_err,
-						nxt, L"  ", 0 );			
+						nxt, L"  ", (void *)0 );			
 		}
 		free( names_arr );
 		al_destroy( &names );
@@ -922,7 +922,7 @@ static int builtin_random( wchar_t **argv )
 							L" ",
 							long_options[opt_index].name,
 							L"\n",
-							0);				
+							(void *)0);				
 				builtin_print_help( argv[0], sb_err );
 				
 				return 1;
@@ -965,7 +965,7 @@ static int builtin_random( wchar_t **argv )
 			{
 				sb_append2( sb_err, 
 							argv[0],
-							L": Seed value '" , argv[woptind], L"' is not a valid number\n", 0);
+							L": Seed value '" , argv[woptind], L"' is not a valid number\n", (void *)0);
 				
 				return 1;
 			}
@@ -1058,7 +1058,7 @@ static int builtin_read( wchar_t **argv )
 							L" ",
 							long_options[opt_index].name,
 							L"\n",
-							0 );
+							(void *)0 );
 				builtin_print_help( argv[0], sb_err );
 
 				return 1;
@@ -1099,7 +1099,7 @@ static int builtin_read( wchar_t **argv )
 					L"\n",
 					parser_current_line(),
 					L"\n",
-					0 );
+					(void *)0 );
 		builtin_print_help( argv[0], sb_err );		
 		return 1;		
 	}
@@ -1112,7 +1112,7 @@ static int builtin_read( wchar_t **argv )
 					L"\n",
 					parser_current_line(),
 					L"\n",
-					0 );
+					(void *)0 );
 		builtin_print_help( argv[0], sb_err );		
 		
 		return 1;		
@@ -1126,7 +1126,7 @@ static int builtin_read( wchar_t **argv )
 					L"\n",
 					parser_current_line(),
 					L"\n",
-					0 );
+					(void *)0 );
 		builtin_print_help( argv[0], sb_err );				
 		return 1;				
 	}
@@ -1295,7 +1295,7 @@ static int builtin_status( wchar_t **argv )
 							L" ",
 							long_options[opt_index].name,
 							L"\n",
-							0);				
+							(void *)0);				
 				builtin_print_help( argv[0], sb_err );
 				
 				return 1;
@@ -1399,7 +1399,7 @@ static int builtin_exit( wchar_t **argv )
 			ec = wcstol(argv[1],&end,10);
 			if( errno || *end != 0)
 			{
-				sb_append2( sb_err, argv[0], L": Argument must be an integer '", argv[1], L"'\n", 0 );
+				sb_append2( sb_err, argv[0], L": Argument must be an integer '", argv[1], L"'\n", (void *)0 );
 				builtin_print_help( argv[0], sb_err );				
 				return 1;
 			}
@@ -1407,7 +1407,7 @@ static int builtin_exit( wchar_t **argv )
 		}
 		
 		default:
-			sb_append2( sb_err, argv[0], L": Too many arguments\n", 0 );
+			sb_append2( sb_err, argv[0], L": Too many arguments\n", (void *)0 );
 			builtin_print_help( argv[0], sb_err );				
 			return 1;
 				
@@ -1452,7 +1452,7 @@ static int builtin_cd( wchar_t **argv )
 			sb_append2( sb_err,
 						argv[0], 
 						L": Could not find home directory\n",
-						0 );			
+						(void *)0 );			
 			
 		}		
 	}	
@@ -1468,10 +1468,10 @@ static int builtin_cd( wchar_t **argv )
 					L": ",
 					dir_in,
 					L" is not a directory or you do not have permission to enter it\n",
-					0 );
+					(void *)0 );
 		sb_append2( sb_err, 
 					parser_current_line(),
-					0 );			
+					(void *)0 );			
 		return 1;
 	}		
 
@@ -1482,10 +1482,10 @@ static int builtin_cd( wchar_t **argv )
 					L": ",
 					dir,
 					L" is not a directory\n",
-					0 );
+					(void *)0 );
 		sb_append2( sb_err, 
 					parser_current_line(),
-					0 );
+					(void *)0 );
 		
 		free( dir );
 		
@@ -1611,7 +1611,7 @@ static int builtin_complete( wchar_t **argv )
 							L": Unknown option ",
 							long_options[opt_index].name,
 							L"\n",
-							0 );
+							(void *)0 );
 				sb_append( sb_err, 
 						   parser_current_line() );
 //				builtin_print_help( argv[0], sb_err );
@@ -1658,7 +1658,7 @@ static int builtin_complete( wchar_t **argv )
 								L": Parameter too long ",
 								woptarg,
 								L"\n",
-								0);
+								(void *)0);
 					sb_append( sb_err, 
 							   parser_current_line() );
 //				builtin_print_help( argv[0], sb_err );
@@ -1711,7 +1711,7 @@ static int builtin_complete( wchar_t **argv )
 		sb_append2( sb_err, 
 					argv[0],
 					L": Too many arguments\n",
-					0);
+					(void *)0);
 		sb_append( sb_err, 
 				   parser_current_line() );
 		//			builtin_print_help( argv[0], sb_err );
@@ -1782,7 +1782,7 @@ static int builtin_source( wchar_t ** argv )
 	if( (argv[1] == 0) || (argv[2]!=0) )
 	{
 		
-		sb_append2( sb_err, argv[0], L": Expected exactly one argument\n", 0 );
+		sb_append2( sb_err, argv[0], L": Expected exactly one argument\n", (void *)0 );
 		builtin_print_help( argv[0], sb_err );
 
 		return 1;
@@ -1904,7 +1904,7 @@ static int builtin_fg( wchar_t **argv )
 			sb_append2( sb_err, 
 						argv[0],
 						L": Ambiguous job\n",
-						0);	
+						(void *)0);	
 		}
 		else
 		{
@@ -1912,7 +1912,7 @@ static int builtin_fg( wchar_t **argv )
 						argv[0], 
 						L": Not a job (", 
 						argv[1], 
-						L")\n", 0 );
+						L")\n", (void *)0 );
 		}
 		builtin_print_help( argv[0], sb_err );
 		
@@ -1929,7 +1929,7 @@ static int builtin_fg( wchar_t **argv )
 		sb_append2( sb_err,
 					argv[0], 
 					L": No suitable job\n",
-					0);
+					(void *)0);
 		builtin_print_help( argv[0], sb_err );
 		return 1;
 	}
@@ -1976,7 +1976,7 @@ static void send_to_bg( job_t *j, wchar_t *name )
 {
 	if( j == 0 )
 	{
-		sb_append2( sb_err, L"bg", L": Unknown job ", name, L"\n", 0 );
+		sb_append2( sb_err, L"bg", L": Unknown job ", name, L"\n", (void *)0 );
 		builtin_print_help( L"bg", sb_err );
 		return;
 	}	
@@ -2106,7 +2106,7 @@ static int builtin_jobs( wchar_t **argv )
 							L": Unknown option ",
 							long_options[opt_index].name,
 							L"\n",
-							0 );
+							(void *)0 );
 				sb_append( sb_err, 
 						   parser_current_line() );
 //				builtin_print_help( argv[0], sb_err );
@@ -2162,13 +2162,13 @@ static int builtin_jobs( wchar_t **argv )
 				sb_printf( sb_out, L"%d\t", cpu_use(j) );
 #endif
 				sb_append2( sb_out, job_is_stopped(j)?L"stopped\t":L"running\t", 
-							j->command, L"\n", 0 );
+							j->command, L"\n", (void *)0 );
 			
 			}
 		}
 		if( !found )
 		{
-			sb_append2( sb_out, argv[0], L": There are no running jobs\n", 0 );
+			sb_append2( sb_out, argv[0], L": There are no running jobs\n", (void *)0 );
 		}
 	}
 	else
@@ -2179,7 +2179,7 @@ static int builtin_jobs( wchar_t **argv )
 		
 		if( woptind != argc-1 )
 		{
-			sb_append2( sb_err, argv[0], L": Expected exactly one argument\n", 0 );
+			sb_append2( sb_err, argv[0], L": Expected exactly one argument\n", (void *)0 );
 		}
 
 			
@@ -2187,7 +2187,7 @@ static int builtin_jobs( wchar_t **argv )
 		pid=wcstol( argv[woptind], &end, 10 );
 		if( errno || *end )
 		{
-			sb_append2( sb_err, argv[0], L": Not a process id: ", argv[woptind], L"\n", 0 );
+			sb_append2( sb_err, argv[0], L": Not a process id: ", argv[woptind], L"\n", (void *)0 );
 			return 1;
 				
 		}
@@ -2235,7 +2235,7 @@ static int builtin_for( wchar_t **argv )
 		sb_append2( sb_err, 
 					argv[0],
 					L": Expected at least two arguments\n",
-					0);				
+					(void *)0);				
 		builtin_print_help( argv[0], sb_err );
 	}
 	else if ( !wcsvarname(argv[1]) )
@@ -2245,7 +2245,7 @@ static int builtin_for( wchar_t **argv )
 					L": \'",
 					argv[1],
 					L"\' invalid variable name\n",
-					0);				
+					(void *)0);				
 		builtin_print_help( argv[0], sb_err );
 	}
 	else if (wcscmp( argv[2], L"in") != 0 )
@@ -2253,7 +2253,7 @@ static int builtin_for( wchar_t **argv )
 		sb_append2( sb_err,
 					argv[0],
 					L": Second argument must be \'in\'\n",
-					0);				
+					(void *)0);				
 		builtin_print_help( argv[0], sb_err );
 	}
 	else
@@ -2313,7 +2313,7 @@ static int builtin_end( wchar_t **argv )
 		sb_append2( sb_err,
 					argv[0],
 					L": Not inside of block\n",
-					0);
+					(void *)0);
 		builtin_print_help( argv[0], sb_err );
 		return 1;
 	}
@@ -2435,7 +2435,7 @@ static int builtin_else( wchar_t **argv )
 		sb_append2( sb_err,
 					argv[0],
 					L": not inside of if block\n",
-					0);
+					(void *)0);
 		builtin_print_help( argv[0], sb_err );
 		return 1;
 	}
@@ -2468,7 +2468,7 @@ static int builtin_break_continue( wchar_t **argv )
 	{
 		sb_append2( sb_err, 
 					argv[0], 
-					L": Unknown option \'", argv[1], L"\'", 0 );
+					L": Unknown option \'", argv[1], L"\'", (void *)0 );
 		builtin_print_help( argv[0], sb_err );
 		return 1;		
 	}
@@ -2485,7 +2485,7 @@ static int builtin_break_continue( wchar_t **argv )
 	{
 		sb_append2( sb_err, 
 					argv[0], 
-					L": Not inside of loop\n", 0 );
+					L": Not inside of loop\n", (void *)0 );
 		builtin_print_help( argv[0], sb_err );
 		return 1;
 	}
@@ -2528,7 +2528,7 @@ static int builtin_return( wchar_t **argv )
 							L": Argument must be an integer '", 
 							argv[1],
 							L"'\n", 
-							0 );
+							(void *)0 );
 				builtin_print_help( argv[0], sb_err );				
 				return 1;
 			}
@@ -2538,7 +2538,7 @@ static int builtin_return( wchar_t **argv )
 		default:
 			sb_append2( sb_err, 
 						argv[0], 
-						L": Too many arguments\n", 0 );
+						L": Too many arguments\n", (void *)0 );
 			builtin_print_help( argv[0], sb_err );
 			return 1;		
 	}
@@ -2554,7 +2554,7 @@ static int builtin_return( wchar_t **argv )
 	{
 		sb_append2( sb_err, 
 					argv[0], 
-					L": Not inside of function\n", 0 );
+					L": Not inside of function\n", (void *)0 );
 		builtin_print_help( argv[0], sb_err );
 		return 1;
 	}
@@ -2615,7 +2615,7 @@ static int builtin_case( wchar_t **argv )
 		sb_append2( sb_err,
 					argv[0],
 					L": syntax error, case command while not in switch block\n",
-					0);
+					(void *)0);
 		builtin_print_help( L"case", sb_err );
 		return 1;
 	}
diff --git a/builtin_commandline.c b/builtin_commandline.c
index 8b915868..0406d6a0 100644
--- a/builtin_commandline.c
+++ b/builtin_commandline.c
@@ -127,7 +127,7 @@ void write_part( wchar_t *begin,
 			switch( tok_last_type( &tok ) )
 			{
 				case TOK_STRING:
-					sb_append2( &out, tok_last( &tok), L"\n", 0 );
+					sb_append2( &out, tok_last( &tok), L"\n", (void *)0 );
 					break;
 								
 			}						
@@ -175,7 +175,7 @@ int builtin_commandline( wchar_t **argv )
 		sb_append2( sb_err,
 					argv[0],
 					L": Can not set commandline in non-interactive mode\n",
-					0 );
+					(void *)0 );
 		builtin_print_help( argv[0], sb_err );
 		return 1;		
 	}	
@@ -254,7 +254,7 @@ int builtin_commandline( wchar_t **argv )
 							L" ",
 							long_options[opt_index].name,
 							L"\n",
-							0 );
+							(void *)0 );
 				builtin_print_help( argv[0], sb_err );
 
 				return 1;
@@ -312,7 +312,7 @@ int builtin_commandline( wchar_t **argv )
 					   L"\n",
 					   parser_current_line(),
 					   L"\n",
-					   0);
+					   (void *)0);
 			return 1;
 		}
 		
@@ -325,7 +325,7 @@ int builtin_commandline( wchar_t **argv )
 						L"\n",
 						parser_current_line(),
 						L"\n",
-						0 );
+						(void *)0 );
 			builtin_print_help( argv[0], sb_err );
 			return 1;
  		}
@@ -352,7 +352,7 @@ int builtin_commandline( wchar_t **argv )
 							L"'\n",
 							parser_current_line(),
 							L"\n",
-							0 );
+							(void *)0 );
 				builtin_print_help( argv[0], sb_err );
 				return 1;
 			}
@@ -370,7 +370,7 @@ int builtin_commandline( wchar_t **argv )
 		sb_append2( sb_err,
 					argv[0],
 					L": Too many arguments\n",
-					0 );
+					(void *)0 );
 		builtin_print_help( argv[0], sb_err );
 		return 1;
 	}
@@ -382,7 +382,7 @@ int builtin_commandline( wchar_t **argv )
 					argv[0],
 					BUILTIN_ERR_COMBO,
 					L",\n --cut-at-cursor and --tokenize can not be used when setting the commandline",
-					0 );
+					(void *)0 );
 		builtin_print_help( argv[0], sb_err );
 		return 1;
 	}
@@ -393,7 +393,7 @@ int builtin_commandline( wchar_t **argv )
                     argv[0],
                     BUILTIN_ERR_COMBO,
                     L",\n insertion mode switches can not be used when not in insertion mode",
-                    0 );
+                    (void *)0 );
         builtin_print_help( argv[0], sb_err );		
         return 1;
 	}
diff --git a/builtin_set.c b/builtin_set.c
index 6e702bf4..cf22e840 100644
--- a/builtin_set.c
+++ b/builtin_set.c
@@ -43,7 +43,7 @@ static int parse_fill_name( string_buffer_t *name,
 	
 		sb_append(sb_err, L"set: Invalid character in variable name: ");
 		sb_append_char(sb_err, *src);
-		sb_append2(sb_err, L"\n", 				  parser_current_line(), L"\n", 0 );
+		sb_append2(sb_err, L"\n", 				  parser_current_line(), L"\n", (void *)0 );
 //		builtin_print_help( L"set", sb_err );
 
 		return -1;
@@ -242,7 +242,7 @@ static void print_variables(int include_values, int escape, int scope)
 		{
 			wchar_t *value = env_get(key);
 			wchar_t *e_value = escape ? expand_escape_variable(value) : wcsdup(value);
-			sb_append2(sb_out, L" ", e_value, 0);
+			sb_append2(sb_out, L" ", e_value, (void *)0);
 			free(e_value);
 		}
 		
@@ -369,7 +369,7 @@ int builtin_set( wchar_t **argv )
 				  L"\n",
 				  parser_current_line(),
 				  L"\n",
-				  0);
+				  (void *)0);
 		builtin_print_help( argv[0], sb_err );
 		return 1;
 	}
@@ -384,7 +384,7 @@ int builtin_set( wchar_t **argv )
 				  L"\n",
 				  parser_current_line(),
 				  L"\n",
-				  0);
+				  (void *)0);
 		builtin_print_help( argv[0], sb_err );
 		return 1;
 	}
@@ -408,7 +408,7 @@ int builtin_set( wchar_t **argv )
 				   L"\n",
 				   parser_current_line(),
 				   L"\n", 
-				   0);
+				   (void *)0);
 		builtin_print_help( argv[0], sb_err );
 		return 1;
 	}
@@ -492,7 +492,7 @@ int builtin_set( wchar_t **argv )
 							L": Erase needs a variable name\n", 
 							parser_current_line(), 
 							L"\n",
-							0 );
+							(void *)0 );
 				builtin_print_help( argv[0], sb_err );
 				retcode = 1;
 			}
@@ -530,7 +530,7 @@ int builtin_set( wchar_t **argv )
 							L": Values cannot be specfied with erase\n",
 							parser_current_line(),
 							L"\n",
-							0 );
+							(void *)0 );
 				builtin_print_help( argv[0], sb_err );
 				retcode = 1;
 			} 
diff --git a/complete.c b/complete.c
index ea6999cb..3ec43de8 100644
--- a/complete.c
+++ b/complete.c
@@ -1489,7 +1489,7 @@ void complete_load( wchar_t *cmd,
 		struct stat buf;		
 		wchar_t *next = (wchar_t *)al_get( &path_list, i );		
 		sb_clear( &path );
-		sb_append2( &path, next, L"/", cmd, L".fish", 0 );
+		sb_append2( &path, next, L"/", cmd, L".fish", (void *)0 );
 		if( (wstat( (wchar_t *)path.buff, &buf )== 0) && 
 			(waccess( (wchar_t *)path.buff, R_OK ) == 0) )
 		{
@@ -1708,7 +1708,7 @@ static int complete_param( wchar_t *cmd_orig,
 					{
 						string_buffer_t whole_opt;
 						sb_init( &whole_opt );
-						sb_append2( &whole_opt, o->old_mode?L"-":L"--", o->long_opt, 0 );
+						sb_append2( &whole_opt, o->old_mode?L"-":L"--", o->long_opt, (void *)0 );
 						
 						if( wcsncmp( str, (wchar_t *)whole_opt.buff, wcslen(str) )==0)
 						{							
diff --git a/expand.c b/expand.c
index 77bdd613..f85e3623 100644
--- a/expand.c
+++ b/expand.c
@@ -173,7 +173,7 @@ wchar_t *expand_escape_variable( const wchar_t *in )
 							L"\'",
 							el,
 							L"\'",
-							0 );
+							(void *)0 );
 			}
 			else
 			{
@@ -199,7 +199,7 @@ wchar_t *expand_escape_variable( const wchar_t *in )
 								L"\'",
 								el,
 								L"\'",
-								0 );
+								(void *)0 );
 				}
 				else
 				{
diff --git a/parser.c b/parser.c
index 1345e31d..00919822 100644
--- a/parser.c
+++ b/parser.c
@@ -272,12 +272,13 @@ int parser_skip_arguments( const wchar_t *cmd )
     return contains_str( cmd,
 						 L"else",
 						 L"begin",
-						 0 );
+						 (void *)0 );
 }
 
 
 int parser_is_subcommand( const wchar_t *cmd )
 {
+	
 	return parser_skip_arguments( cmd ) ||
 		contains_str( cmd,
 					  L"command", 
@@ -288,7 +289,7 @@ int parser_is_subcommand( const wchar_t *cmd )
 					  L"and",
 					  L"or",
 					  L"not",
-					  0 );
+					  (void *)0 );
 }
 
 /**
@@ -304,7 +305,7 @@ static int parser_is_block( wchar_t *word)
 						 L"function",
 						 L"switch", 
 						 L"begin",
-						 0 );
+						 (void *)0 );
 }
 
 int parser_is_reserved( wchar_t *word)
@@ -318,7 +319,7 @@ int parser_is_reserved( wchar_t *word)
 					  L"return",
 					  L"continue",
 					  L"break",
-					  0 );
+					  (void *)0 );
 }
 
 int parser_is_pipe_forbidden( wchar_t *word )
@@ -329,7 +330,7 @@ int parser_is_pipe_forbidden( wchar_t *word )
 						 L"break",
 						 L"return", 
 						 L"continue", 
-						 0 );
+						 (void *)0 );
 }
 
 static const wchar_t *parser_find_end( const wchar_t * buff ) 
diff --git a/wildcard.c b/wildcard.c
index bc030771..600f8c39 100644
--- a/wildcard.c
+++ b/wildcard.c
@@ -242,11 +242,11 @@ void get_desc( wchar_t *fn, string_buffer_t *sb, int is_cmd )
 	
 	if( sz >= 0 && S_ISDIR(buf.st_mode) )
 	{
-		sb_append2( sb, desc, 0 );							
+		sb_append2( sb, desc, (void *)0 );							
 	}
 	else
 	{							
-		sb_append2( sb, desc, L", ", 0 );
+		sb_append2( sb, desc, L", ", (void *)0 );
 		if( sz < 0 )
 		{
 			sb_append( sb, L"unknown" );

