commit c8d2d47a9cbb4222ae4e993aa0e3703430c8193c
Author: Xiaotian Feng <xtfeng@gmail.com>
Date:   Tue Aug 6 20:06:42 2013 +0800

    cpumask: Fix cpumask leak in partition_sched_domains()
    
    If doms_new is NULL, partition_sched_domains() will reset ndoms_cur
    to 0, and free old sched domains with free_sched_domains(doms_cur, ndoms_cur).
    As ndoms_cur is 0, the cpumask will not be freed.
    
    Signed-off-by: Xiaotian Feng <xtfeng@gmail.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/1375790802-11857-1-git-send-email-xtfeng@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index b7415cfdd7de..cf8f100433e0 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -6184,8 +6184,9 @@ void partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[],
 		;
 	}
 
+	n = ndoms_cur;
 	if (doms_new == NULL) {
-		ndoms_cur = 0;
+		n = 0;
 		doms_new = &fallback_doms;
 		cpumask_andnot(doms_new[0], cpu_active_mask, cpu_isolated_map);
 		WARN_ON_ONCE(dattr_new);
@@ -6193,7 +6194,7 @@ void partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[],
 
 	/* Build new domains */
 	for (i = 0; i < ndoms_new; i++) {
-		for (j = 0; j < ndoms_cur && !new_topology; j++) {
+		for (j = 0; j < n && !new_topology; j++) {
 			if (cpumask_equal(doms_new[i], doms_cur[j])
 			    && dattrs_equal(dattr_new, i, dattr_cur, j))
 				goto match2;

