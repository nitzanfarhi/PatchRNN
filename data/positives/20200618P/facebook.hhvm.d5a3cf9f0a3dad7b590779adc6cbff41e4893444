commit d5a3cf9f0a3dad7b590779adc6cbff41e4893444
Author: Otto Ebeling <otto@fb.com>
Date:   Mon Sep 15 11:04:43 2014 -0700

    Fix heap corruption in exif_ifd_make_value
    
    Summary: CVE-2014-3670
    
    The logic for writing float/double arrays in exif_ifd_make_value is flat out wrong. Firstly, the whole size of the target buffer is `byte_count`, yet `byte_count` is used as if it was the size of an individual element in the array.
    
    Furthermore, the source pointer for the memmove is wrong as well. The expression `info_data->value.f` access the union (`_image_info_value`) as a float, even though it is a pointer in this case. See line 5857 for an example where - in the case of an array - the list member is derefenced properly as a pointer to an array. This ends up being simultaneous out-of-bounds read and write.
    
    Reviewed By: @oyamauchi
    
    Differential Revision: D1553388

diff --git a/hphp/runtime/ext/gd/ext_gd.cpp b/hphp/runtime/ext/gd/ext_gd.cpp
index d89a684471..e4cc98d2ed 100644
--- a/hphp/runtime/ext/gd/ext_gd.cpp
+++ b/hphp/runtime/ext/gd/ext_gd.cpp
@@ -5901,11 +5901,11 @@ static void* exif_ifd_make_value(image_info_data *info_data,
         data_ptr += 8;
         break;
       case TAG_FMT_SINGLE:
-        memmove(data_ptr, &info_data->value.f, byte_count);
+        memmove(data_ptr, &info_value->f, 4);
         data_ptr += 4;
         break;
       case TAG_FMT_DOUBLE:
-        memmove(data_ptr, &info_data->value.d, byte_count);
+        memmove(data_ptr, &info_value->d, 8);
         data_ptr += 8;
         break;
       }

