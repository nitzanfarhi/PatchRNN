commit cf54772b913b6dcfcbe2f4f909bb65f5beff748d
Author: Robert Baldyga <r.baldyga@samsung.com>
Date:   Thu Jan 15 12:11:36 2015 +0100

    usb: dwc2: call dwc2_is_controller_alive() under spinlock
    
    This patch fixes the following problem: data transmission in direction
    IN break unless the GSNPSID register access is done with spinlock held.
    This issue occurs at least in Exynos4412 SoC, probably in many SoC's
    from Exynos familly.
    
    The problem is described here:
    https://lkml.org/lkml/2014/12/22/185
    And there is linux mailing list discussion:
    https://lkml.org/lkml/2015/1/14/17
    
    Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
    Signed-off-by: Felipe Balbi <balbi@ti.com>

diff --git a/drivers/usb/dwc2/core_intr.c b/drivers/usb/dwc2/core_intr.c
index ad43c5bc1ef1..02e3e2d4ea56 100644
--- a/drivers/usb/dwc2/core_intr.c
+++ b/drivers/usb/dwc2/core_intr.c
@@ -476,13 +476,13 @@ irqreturn_t dwc2_handle_common_intr(int irq, void *dev)
 	u32 gintsts;
 	irqreturn_t retval = IRQ_NONE;
 
+	spin_lock(&hsotg->lock);
+
 	if (!dwc2_is_controller_alive(hsotg)) {
 		dev_warn(hsotg->dev, "Controller is dead\n");
 		goto out;
 	}
 
-	spin_lock(&hsotg->lock);
-
 	gintsts = dwc2_read_common_intr(hsotg);
 	if (gintsts & ~GINTSTS_PRTINT)
 		retval = IRQ_HANDLED;
@@ -515,8 +515,8 @@ irqreturn_t dwc2_handle_common_intr(int irq, void *dev)
 		}
 	}
 
-	spin_unlock(&hsotg->lock);
 out:
+	spin_unlock(&hsotg->lock);
 	return retval;
 }
 EXPORT_SYMBOL_GPL(dwc2_handle_common_intr);

