commit a07fd74d5ea9c45a5c6e41f7cb4b997cf40d50f3
Author: Denys Vlasenko <dvlasenk@redhat.com>
Date:   Wed Apr 20 17:45:55 2016 +0200

    e1000e: e1000e_cyclecounter_read(): fix er32(SYSTIML) overflow check
    
    If two consecutive reads of the counter are the same, it is also
    not an overflow.  "systimel_1 < systimel_2" should be
    "systimel_1 <= systimel_2".
    
    Before the patch, we could perform an *erroneous* correction:
    
    Let's say that systimel_1 == systimel_2 == 0xffffffff.
    "systimel_1 < systimel_2" is false, we think it's an overflow,
    we read "systimeh = er32(SYSTIMH)" which meanwhile had incremented,
    and use "(systimeh << 32) + systimel_2" value which is 2^32 too large.
    
    Signed-off-by: Denys Vlasenko <dvlasenk@redhat.com>
    CC: intel-wired-lan@lists.osuosl.org
    Tested-by: Aaron Brown <aaron.f.brown@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/drivers/net/ethernet/intel/e1000e/netdev.c b/drivers/net/ethernet/intel/e1000e/netdev.c
index 4969f647db88..02c64bcda71d 100644
--- a/drivers/net/ethernet/intel/e1000e/netdev.c
+++ b/drivers/net/ethernet/intel/e1000e/netdev.c
@@ -4287,7 +4287,7 @@ static cycle_t e1000e_cyclecounter_read(const struct cyclecounter *cc)
 	systimeh = er32(SYSTIMH);
 	systimel_2 = er32(SYSTIML);
 	/* Check for overflow. If there was no overflow, use the values */
-	if (systimel_1 < systimel_2) {
+	if (systimel_1 <= systimel_2) {
 		systim = (cycle_t)systimel_1;
 		systim |= (cycle_t)systimeh << 32;
 	} else {

