commit c8a5e4e86d998274306dc906f5a24bb0e96aa14c
Author: Archit Taneja <archit@ti.com>
Date:   Thu Jul 5 12:52:46 2012 +0530

    OMAPDSS: DPI: Add locking for DPI interface
    
    The DPI interface driver currently relies on the panel driver to ensure calls
    like omapdss_dpi_display_enable() and omapdss_dpi_display_disable() are executed
    sequentially. Also, currently, there is no way to protect the DPI driver data.
    
    All DPI panel drivers don't ensure this, and in general, a DPI panel driver
    should use it's lock to that ensure it's own driver data and omap_dss_device
    states are taken care of, and not worry about the DPI interface.
    
    Add mutex locking in the DPI enable/disable/set_timings ops.
    
    Signed-off-by: Archit Taneja <archit@ti.com>

diff --git a/drivers/video/omap2/dss/dpi.c b/drivers/video/omap2/dss/dpi.c
index 3266be23fc0d..15c2c3301f48 100644
--- a/drivers/video/omap2/dss/dpi.c
+++ b/drivers/video/omap2/dss/dpi.c
@@ -39,6 +39,8 @@ static struct {
 	struct regulator *vdds_dsi_reg;
 	struct platform_device *dsidev;
 
+	struct mutex lock;
+
 	struct dss_lcd_mgr_config mgr_config;
 } dpi;
 
@@ -169,14 +171,18 @@ int omapdss_dpi_display_enable(struct omap_dss_device *dssdev)
 {
 	int r;
 
+	mutex_lock(&dpi.lock);
+
 	if (cpu_is_omap34xx() && !dpi.vdds_dsi_reg) {
 		DSSERR("no VDSS_DSI regulator\n");
-		return -ENODEV;
+		r = -ENODEV;
+		goto err_no_reg;
 	}
 
 	if (dssdev->manager == NULL) {
 		DSSERR("failed to enable display: no manager\n");
-		return -ENODEV;
+		r = -ENODEV;
+		goto err_no_mgr;
 	}
 
 	r = omap_dss_start_device(dssdev);
@@ -217,6 +223,8 @@ int omapdss_dpi_display_enable(struct omap_dss_device *dssdev)
 	if (r)
 		goto err_mgr_enable;
 
+	mutex_unlock(&dpi.lock);
+
 	return 0;
 
 err_mgr_enable:
@@ -234,12 +242,17 @@ int omapdss_dpi_display_enable(struct omap_dss_device *dssdev)
 err_reg_enable:
 	omap_dss_stop_device(dssdev);
 err_start_dev:
+err_no_mgr:
+err_no_reg:
+	mutex_unlock(&dpi.lock);
 	return r;
 }
 EXPORT_SYMBOL(omapdss_dpi_display_enable);
 
 void omapdss_dpi_display_disable(struct omap_dss_device *dssdev)
 {
+	mutex_lock(&dpi.lock);
+
 	dss_mgr_disable(dssdev->manager);
 
 	if (dpi_use_dsi_pll(dssdev)) {
@@ -254,6 +267,8 @@ void omapdss_dpi_display_disable(struct omap_dss_device *dssdev)
 		regulator_disable(dpi.vdds_dsi_reg);
 
 	omap_dss_stop_device(dssdev);
+
+	mutex_unlock(&dpi.lock);
 }
 EXPORT_SYMBOL(omapdss_dpi_display_disable);
 
@@ -263,6 +278,9 @@ void dpi_set_timings(struct omap_dss_device *dssdev,
 	int r;
 
 	DSSDBG("dpi_set_timings\n");
+
+	mutex_lock(&dpi.lock);
+
 	dssdev->panel.timings = *timings;
 	if (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE) {
 		r = dispc_runtime_get();
@@ -275,6 +293,8 @@ void dpi_set_timings(struct omap_dss_device *dssdev,
 	} else {
 		dss_mgr_set_timings(dssdev->manager, timings);
 	}
+
+	mutex_unlock(&dpi.lock);
 }
 EXPORT_SYMBOL(dpi_set_timings);
 
@@ -377,6 +397,8 @@ static void __init dpi_probe_pdata(struct platform_device *pdev)
 
 static int __init omap_dpi_probe(struct platform_device *pdev)
 {
+	mutex_init(&dpi.lock);
+
 	dpi_probe_pdata(pdev);
 
 	return 0;

