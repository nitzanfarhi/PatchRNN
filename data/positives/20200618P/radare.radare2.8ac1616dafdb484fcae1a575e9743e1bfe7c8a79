commit 8ac1616dafdb484fcae1a575e9743e1bfe7c8a79
Author: jvoisin <julien.voisin@dustri.org>
Date:   Wed Jan 14 02:53:34 2015 +0100

    Fix some coverity issues

diff --git a/libr/anal/var.c b/libr/anal/var.c
index d12c48259..485b19d6a 100644
--- a/libr/anal/var.c
+++ b/libr/anal/var.c
@@ -296,4 +296,5 @@ R_API void r_anal_var_list_show(RAnal *anal, RAnalFunction *fcn, int kind) {
 				var->delta
 			);
 	}
+	r_free_list (list);
 }
diff --git a/libr/asm/arch/arm/armass.c b/libr/asm/arch/arm/armass.c
index 465231814..08a49b2fa 100644
--- a/libr/asm/arch/arm/armass.c
+++ b/libr/asm/arch/arm/armass.c
@@ -117,7 +117,7 @@ static char *getrange(char *s) {
 			*p=0;
 		}
 		if (*s=='[' || *s==']')
-			strcpy (s, s+1);
+			memmove (s, s+1, strlen (s+1));
 		if (*s=='}')
 			*s=0;
 		s++;
diff --git a/libr/bin/dwarf.c b/libr/bin/dwarf.c
index 873aa3357..92d7723b1 100644
--- a/libr/bin/dwarf.c
+++ b/libr/bin/dwarf.c
@@ -1501,6 +1501,7 @@ R_API RList *r_bin_dwarf_parse_line(RBin *a, int mode) {
 		buf = calloc (1,len);
 		ret = r_buf_read_at (binfile->buf, section->paddr, buf, len);
 		if (!ret) {
+			r_list_free (list);
 			free (buf);
 			return NULL;
 		}
diff --git a/libr/core/bin.c b/libr/core/bin.c
index c6d273526..4fbd3d594 100644
--- a/libr/core/bin.c
+++ b/libr/core/bin.c
@@ -391,9 +391,9 @@ static int bin_info (RCore *r, int mode) {
 			pair ("lsyms", r_str_bool (R_BIN_DBG_SYMS &info->dbg_info));
 			pair ("relocs", r_str_bool (R_BIN_DBG_RELOCS &info->dbg_info));
 			pair ("rpath", info->rpath);
-			if (info->guid && *info->guid)
+			if (info->guid && *(info->guid))
 				pair ("guid", info->guid);
-			if (info->debug_file_name && *info->debug_file_name)
+			if (info->debug_file_name && *(info->debug_file_name))
 				pair ("dbg_file", info->debug_file_name);
 
 			for (i=0; info->sum[i].type; i++) {
diff --git a/libr/core/cmd_anal.c b/libr/core/cmd_anal.c
index 3f1350bff..262c70ba6 100644
--- a/libr/core/cmd_anal.c
+++ b/libr/core/cmd_anal.c
@@ -98,6 +98,7 @@ static int var_cmd(RCore *core, const char *str) {
 			const char kind = (char) type;
 			r_str_split(old_name, ' ');
 			r_anal_var_rename (core->anal, fcn->addr, R_ANAL_VAR_SCOPE_LOCAL, kind, old_name, new_name);
+			free (old_name);
 			goto end;
 		case 'j':
 			list = r_anal_var_list (core->anal, fcn, type);
@@ -1723,6 +1724,7 @@ static boolt cmd_anal_refs(RCore *core, const char *input) {
 				}
 				r_list_free (list);
 			}
+			free (buf_asm);
 		}
 		break;
 	case 'F':
diff --git a/libr/core/cmd_search.c b/libr/core/cmd_search.c
index 2c2a3a19e..1a311a47b 100644
--- a/libr/core/cmd_search.c
+++ b/libr/core/cmd_search.c
@@ -505,8 +505,8 @@ static ut64 findprevopsz(RCore *core, ut64 addr, ut8 *buf) {
 	return UT64_MAX;
 }
 
-static boolt is_end_gadget(const RAnalOp aop, const ut8 crop) {
-	switch(aop.type) {
+static boolt is_end_gadget(const RAnalOp* aop, const ut8 crop) {
+	switch(aop->type) {
 	case R_ANAL_OP_TYPE_TRAP:
 	case R_ANAL_OP_TYPE_RET:
 	case R_ANAL_OP_TYPE_UCALL:
@@ -516,7 +516,7 @@ static boolt is_end_gadget(const RAnalOp aop, const ut8 crop) {
 		return R_TRUE;
 	}
 	if (crop) { //if conditional jumps, calls and returns should be used for the gadget-search too
-		switch (aop.type) {
+		switch (aop->type) {
 		case R_ANAL_OP_TYPE_CJMP:
 		case R_ANAL_OP_TYPE_UCJMP:
 		case R_ANAL_OP_TYPE_CCALL:
@@ -704,7 +704,7 @@ static int r_core_search_rop(RCore *core, ut64 from, ut64 to, int opt, const cha
 	int delta = 0;
 	ut8 *buf;
 	RIOMap *map;
-	RList/*<RIOMap>*/ *list;
+	RList/*<RIOMap>*/ *list = NULL;
 	RAsmOp asmop;
 	RListIter *itermap = NULL;
 	boolt json_first = 1;
@@ -718,6 +718,8 @@ static int r_core_search_rop(RCore *core, ut64 from, ut64 to, int opt, const cha
 	const ut8 crop = r_config_get_i (core->config, "rop.conditional");	//decide if cjmp, cret, and ccall should be used too for the gadget-search
 	const ut8 max_instr = r_config_get_i (core->config, "rop.len");
 	if (max_instr <= 0) {
+		r_list_free (badstart);
+		r_list_free (end_list);
 		eprintf ("ROP length (rop.len) must be greater than 0\n");
 		return R_FALSE;
 	}
@@ -781,6 +783,7 @@ static int r_core_search_rop(RCore *core, ut64 from, ut64 to, int opt, const cha
 			if (delta < 1) {
 				free (gregexp);
 				r_list_free (rx_list);
+				r_list_free (end_list);
 				r_list_free (badstart);
 				return R_FALSE;
 			}
@@ -804,7 +807,7 @@ static int r_core_search_rop(RCore *core, ut64 from, ut64 to, int opt, const cha
 					delta-i) <= 0) {
 				continue;
 			}
-			if (is_end_gadget (end_gadget, crop)) {
+			if (is_end_gadget (&end_gadget, crop)) {
 				if (maxhits && r_list_length (end_list) >= maxhits) {
 					// limit number of high level rop gadget results
 					break;
diff --git a/libr/core/disasm.c b/libr/core/disasm.c
index 64f83857b..f65455294 100644
--- a/libr/core/disasm.c
+++ b/libr/core/disasm.c
@@ -797,6 +797,8 @@ static void handle_show_functions (RCore *core, RDisasmState *ds) {
 									var->delta);
 						}
 					}
+					r_list_free (vars);
+					r_list_free (args);
 				}
 			}
 		}
@@ -2506,6 +2508,7 @@ R_API int r_core_print_disasm_json(RCore *core, ut64 addr, ut8 *buf, int nb_byte
 						r_anal_xrefs_type_tostring (ref->type));
 				}
 				r_cons_printf ("]");
+				r_list_free (xrefs);
 			}
 		}
 
diff --git a/libr/core/syscmd.c b/libr/core/syscmd.c
index 73b4b2381..376d20532 100644
--- a/libr/core/syscmd.c
+++ b/libr/core/syscmd.c
@@ -11,7 +11,7 @@ static void showfile(const int nth, const char *fpath, const char *name, int pri
 	struct stat sb;
 #endif
 	const char *n = fpath;
-	char *nn, *u_rwx = "";
+	char *nn, *u_rwx = NULL;
 	int sz = r_file_size (n);
 	int perm, isdir, uid = 0, gid = 0;
 	int fch = '-';
diff --git a/libr/core/vmenus.c b/libr/core/vmenus.c
index 80e7ccd9a..ad561848e 100644
--- a/libr/core/vmenus.c
+++ b/libr/core/vmenus.c
@@ -1325,7 +1325,7 @@ R_API void r_core_visual_define (RCore *core) {
 			r_cons_flush ();
 			r_line_set_prompt ("format: ");
 			strcpy (cmd, "Cf 0 ");
-			if (r_cons_fgets (cmd+5, sizeof (cmd)-4, 0, NULL) > 0) {
+			if (r_cons_fgets (cmd+5, sizeof (cmd)-6, 0, NULL) > 0) {
 				r_core_cmd (core, cmd, 0);
 				r_cons_set_raw (1);
 				r_cons_show_cursor (R_FALSE);
diff --git a/libr/parse/p/parse_arm_pseudo.c b/libr/parse/p/parse_arm_pseudo.c
index e66585a25..1fe82a297 100644
--- a/libr/parse/p/parse_arm_pseudo.c
+++ b/libr/parse/p/parse_arm_pseudo.c
@@ -205,6 +205,7 @@ static int varsub(RParse *p, RAnalFunction *f, char *data, char *str, int len) {
 		str[strlen (tstr)] = 0;
 	} else {
 		// TOO BIG STRING CANNOT REPLACE HERE
+		free (tstr);
 		return R_FALSE;
 	}
 	free (tstr);
diff --git a/libr/util/file.c b/libr/util/file.c
index 3d8e98ddc..121cf7f5a 100644
--- a/libr/util/file.c
+++ b/libr/util/file.c
@@ -164,8 +164,11 @@ R_API char *r_file_path(const char *bin) {
 R_API char *r_stdin_slurp (int *sz) {
 #define BS 1024
 #if __UNIX__
-	int i, ret, newfd = dup(0);
-	char *buf = malloc (BS);
+	int i, ret, newfd;
+	char *buf;
+	if (!(newfd = dup(0)))
+		return NULL;
+	buf = malloc (BS);
 	for (i=ret=0;;i+=ret) {
 		buf = realloc (buf, i+BS);
 		ret = read (0, buf+i, BS);

