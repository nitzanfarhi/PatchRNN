commit 4f8010293506d4e08d184e66bf4af44ef3483611
Author: Junjie Hu <junjie.hu@mediatek.com>
Date:   Wed Nov 11 12:52:25 2015 +0800

    Fix potential race condition on CTS TC pthread_gettid_np
    
    Root cause:
    If start_routine thread exits before pthread_gettid_np is invokded, the "tid" field
    will be cleared so that pthread_gettid_np will get "0" (which is cleared by kernel,
    due to the flag "CLONE_CHILD_CLEARTID" is set while calling clone system call inside
    pthread_create).
    
    Proposed patch:
    Use a mutex to guarantee pthread_gettid_np will be invoked and returned before the
    start_routine exits
    
    Signed-off-by: Junjie Hu <junjie.hu@mediatek.com>
    
    Change-Id: I22411f1b0f7446d76a0373cef4ccec858fac7018

diff --git a/tests/pthread_test.cpp b/tests/pthread_test.cpp
old mode 100644
new mode 100755
index 8ae28d81e..f15cdabf6
--- a/tests/pthread_test.cpp
+++ b/tests/pthread_test.cpp
@@ -1244,8 +1244,11 @@ TEST(pthread, pthread_attr_getstack_18908062) {
 }
 
 #if defined(__BIONIC__)
+static pthread_mutex_t gettid_mutex;
 static void* pthread_gettid_np_helper(void* arg) {
+  pthread_mutex_lock(&gettid_mutex);
   *reinterpret_cast<pid_t*>(arg) = gettid();
+  pthread_mutex_unlock(&gettid_mutex);
   return NULL;
 }
 #endif
@@ -1256,11 +1259,15 @@ TEST(pthread, pthread_gettid_np) {
 
   pid_t t_gettid_result;
   pthread_t t;
+  pthread_mutex_init(&gettid_mutex, NULL);
+  pthread_mutex_lock(&gettid_mutex);
   pthread_create(&t, NULL, pthread_gettid_np_helper, &t_gettid_result);
 
   pid_t t_pthread_gettid_np_result = pthread_gettid_np(t);
+  pthread_mutex_unlock(&gettid_mutex);
 
   pthread_join(t, NULL);
+  pthread_mutex_destroy(&gettid_mutex);
 
   ASSERT_EQ(t_gettid_result, t_pthread_gettid_np_result);
 #else

