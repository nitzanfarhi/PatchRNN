commit 56cf6504fc1c0c221b82cebc16a444b684140fb7
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri May 5 17:57:52 2006 +0100

    [BLOCK] Fix oops on removal of SD/MMC card
    
    The block layer keeps a reference (driverfs_dev) to the struct
    device associated with the block device, and uses it internally
    for generating uevents in block_uevent.
    
    Block device uevents include umounting the partition, which can
    occur after the backing device has been removed.
    
    Unfortunately, this reference is not counted.  This means that
    if the struct device is removed from the device tree, the block
    layers reference will become stale.
    
    Guard against this by holding a reference to the struct device
    in add_disk(), and only drop the reference when we're releasing
    the gendisk kobject - in other words when we can be sure that no
    further uevents will be generated for this block device.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Jens Axboe <axboe@suse.de>

diff --git a/block/genhd.c b/block/genhd.c
index 5a8d3bf02f17..d96572589621 100644
--- a/block/genhd.c
+++ b/block/genhd.c
@@ -182,6 +182,7 @@ static int exact_lock(dev_t dev, void *data)
  */
 void add_disk(struct gendisk *disk)
 {
+	get_device(disk->driverfs_dev);
 	disk->flags |= GENHD_FL_UP;
 	blk_register_region(MKDEV(disk->major, disk->first_minor),
 			    disk->minors, NULL, exact_match, exact_lock, disk);
@@ -427,6 +428,7 @@ static struct attribute * default_attrs[] = {
 static void disk_release(struct kobject * kobj)
 {
 	struct gendisk *disk = to_disk(kobj);
+	put_device(disk->driverfs_dev);
 	kfree(disk->random);
 	kfree(disk->part);
 	free_disk_stats(disk);

