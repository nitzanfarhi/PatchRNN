commit 4d33cca7632f5b04651d2762f33a1c862acbc7a0
Author: Jan Janak <jan@iptel.org>
Date:   Wed Apr 11 09:09:53 2007 +0000

    - updated to the new db api
      registration avps still need some work

diff --git a/modules_s/usrloc/dlist.c b/modules_s/usrloc/dlist.c
index 1dc1a0434..a415e1419 100644
--- a/modules_s/usrloc/dlist.c
+++ b/modules_s/usrloc/dlist.c
@@ -181,7 +181,7 @@ static inline int new_dlist(str* _n, dlist_t** _d)
 	}
 	memset(ptr, 0, sizeof(dlist_t));
 
-	ptr->name.s = (char*)shm_malloc(_n->len);
+	ptr->name.s = (char*)shm_malloc(_n->len + 1);
 	if (ptr->name.s == 0) {
 		LOG(L_ERR, "new_dlist(): No memory left 2\n");
 		shm_free(ptr);
@@ -189,6 +189,7 @@ static inline int new_dlist(str* _n, dlist_t** _d)
 	}
 
 	memcpy(ptr->name.s, _n->s, _n->len);
+	ptr->name.s[_n->len] = '\0';
 	ptr->name.len = _n->len;
 
 	if (new_udomain(&(ptr->name), &(ptr->d)) < 0) {
@@ -203,6 +204,7 @@ static inline int new_dlist(str* _n, dlist_t** _d)
 }
 
 
+
 /*
  * Function registers a new domain with usrloc
  * if the domain exists, pointer to existing structure
@@ -213,8 +215,6 @@ int register_udomain(const char* _n, udomain_t** _d)
 {
 	dlist_t* d;
 	str s;
-	int ver;
-	db_con_t* con;
 
 	s.s = (char*)_n;
 	s.len = strlen(_n);
@@ -228,34 +228,29 @@ int register_udomain(const char* _n, udomain_t** _d)
 		LOG(L_ERR, "register_udomain(): Error while creating new domain\n");
 		return -1;
 	} 
-
-	     /* Preload domain with data from database if we are gonna
-	      * to use database
-	      */
+	
+	/* Preload domain with data from database if we are gonna
+	 * to use database
+	 */
 	if (db_mode != NO_DB) {
-		con = ul_dbf.init(db_url.s);
-		if (!con) {
-			LOG(L_ERR, "register_udomain(): Can not open database connection\n");
-			goto err;
-		}
-
-		ver = table_version(&ul_dbf, con, &s);
-
-		if (ver < 0) {
-			LOG(L_ERR, "register_udomain(): Error while querying table version\n");
-			goto err;
-		} else if (ver < TABLE_VERSION) {
-			LOG(L_ERR, "register_udomain(): Invalid table version (use ser_mysql.sh reinstall)\n");
+		db = db_ctx("usrloc");
+		if (db == NULL) {
+			ERR("Error while initializing database layer\n");
 			goto err;
 		}
 		
-		if (preload_udomain(con, d->d) < 0) {
+		if (db_add_db(db, db_url.s) < 0) goto err;
+		if (db_connect(db) < 0) goto err;
+		
+		if (preload_udomain(d->d) < 0) {
 			LOG(L_ERR, "register_udomain(): Error while preloading domain '%.*s'\n",
 			    s.len, ZSW(s.s));
 			goto err;
 		}
 
-		ul_dbf.close(con);
+		db_disconnect(db);
+		db_ctx_free(db);
+		db = NULL;
 	}
 
 	d->next = root;
@@ -265,7 +260,11 @@ int register_udomain(const char* _n, udomain_t** _d)
 	return 0;
 
  err:
-	if (con) ul_dbf.close(con);
+	if (db) {
+		db_disconnect(db);
+		db_ctx_free(db);
+		db = NULL;
+	}
 	free_udomain(d->d);
 	shm_free(d->name.s);
 	shm_free(d);
diff --git a/modules_s/usrloc/reg_avps.h b/modules_s/usrloc/reg_avps.h
index b0006d8ae..81ff51b7d 100644
--- a/modules_s/usrloc/reg_avps.h
+++ b/modules_s/usrloc/reg_avps.h
@@ -16,7 +16,7 @@ int update_reg_avps(struct ucontact* c);
 int db_save_reg_avps(struct ucontact* c);
 int db_delete_reg_avps(struct ucontact* c);
 int db_update_reg_avps(struct ucontact* c);
-int db_read_reg_avps(db_con_t* con, struct ucontact *c);
+int db_read_reg_avps(struct ucontact *c);
 	
 int set_reg_avpflag_name(char *name);
 
diff --git a/modules_s/usrloc/reg_avps_db.c b/modules_s/usrloc/reg_avps_db.c
index b52c8311d..f1080cf89 100644
--- a/modules_s/usrloc/reg_avps_db.c
+++ b/modules_s/usrloc/reg_avps_db.c
@@ -185,204 +185,31 @@ int serialize_avps(avp_t *first, str *dst) {
 /* ************************************************************** */
 /* database operations */
 
-#define string_val(v,s)	(v).type = DB_STR; \
-	if (s) { (v).val.str_val=*s; (v).nul = 0; }  \
-	else (v).nul=1; 
-#define int_val(v,t)	(v).type = DB_INT; \
-	(v).val.int_val=t;\
-	(v).nul=0; 
-
-#define get_str_val(rvi,dst)	do{if(!rvi.nul){dst.s=(char*)rvi.val.string_val;dst.len=strlen(dst.s);}}while(0)
-#define get_int_val(rvi,dst)	do{if(!rvi.nul){dst=rvi.val.int_val;}else dst=0;}while(0)
-
 static inline int can_write_db()
 {
 	if (((db_mode == WRITE_THROUGH) || (db_mode == WRITE_BACK))) {
-		if (ul_dbh) return 1;
-	}
-	return 0;
-}
-	
-int db_read_reg_avps_et(db_con_t* con, struct ucontact *c)
-{
-	/* load on startup, ... */
-	db_key_t keys[] = { regavp_uid_column, regavp_contact_column };
-	db_op_t ops[] = { OP_EQ, OP_EQ };
-	db_val_t k_vals[2];
-	int i;
-	db_res_t *res = NULL;
-	db_key_t result_cols[] = { regavp_name_column, 
-		regavp_type_column, regavp_value_column, regavp_flags_column };
-	avp_t *first = NULL;
-	avp_t *last = NULL;
-	avp_t *avp;
-
-	if (db_mode == NO_DB) {
-		INFO("not reading attrs\n");
-		return 0;
-	}
-
-/*	INFO("reading attrs for uid: %.*s, contact: %.*s\n",
-			c->uid->len, c->uid->s, 
-			c->c.len, c->c.s);*/
-	
-	string_val(k_vals[0], c->uid);
-	string_val(k_vals[1], &c->c);
-	
-	if (ul_dbf.use_table(con, reg_avp_table) < 0) {
-		ERR("Error in use_table\n");
-		return -1;
-	}
-
-	if (ul_dbf.query (con, keys, ops, k_vals,
-			result_cols, 2, sizeof(result_cols) / sizeof(db_key_t), 
-			0, &res) < 0) {
-		ERR("Error while querying contact attrs\n");
-		return -1;
+		if (db) return 1;
 	}
-	
-	if (!res) return 0; /* ? */
-	
-	for (i = 0; i < res->n; i++) {
-		int flags = 0;
-		int type = 0;
-		str value = STR_NULL;
-		avp_value_t val;
-		avp_name_t name;
-		db_row_t *row = &res->rows[i];
-		db_val_t *row_vals = ROW_VALUES(row);
-		
-		get_str_val(row_vals[0], name.s);
-		get_int_val(row_vals[1], type);
-		get_str_val(row_vals[2], value);
-		get_int_val(row_vals[3], flags);
-
-		if (type == AVP_VAL_STR) val.s = value;
-		else str2int(&value, (unsigned int*)&val.n);
-		avp = create_avp(flags, name, val);
-
-		if (last) last->next = avp;
-		else first = avp;
-		last = avp;
-	}
-	ul_dbf.free_result(con, res);
-	
-	c->avps = first;
 	return 0;
 }
 
-int db_delete_reg_avps_et(struct ucontact *c)
-{
-	db_key_t keys[] = { regavp_uid_column, regavp_contact_column };
-	db_op_t ops[] = { OP_EQ, OP_EQ };
-	db_val_t k_vals[2];
-
-	if (!can_write_db()) return 0;
-	
-	string_val(k_vals[0], c->uid);
-	string_val(k_vals[1], &c->c);
-
-	if (ul_dbf.use_table(ul_dbh, reg_avp_table) < 0) {
-		ERR("Error in use_table\n");
-		return -1;
-	}
-
-	if (ul_dbf.delete(ul_dbh, keys, ops, k_vals, 2) < 0) {
-		LOG(L_ERR, "Error while removing data\n");
-		return -1;
-	}
-	
-	return 0;
-}
-
-static inline int db_save_avp_et(avp_t *avp, str *uid, str *contact)
-{
-	db_key_t cols[10];
-	db_val_t vals[10];
-	str *s;
-	str v;
-	int type;
-	
-	int n = -1;
-
-	cols[++n] = regavp_uid_column;
-	string_val(vals[n], uid);
-	
-	cols[++n] = regavp_contact_column;
-	string_val(vals[n], contact);
-	
-	s = get_avp_name(avp);
-	cols[++n] = regavp_name_column;
-	string_val(vals[n], s);
-	
-	get_avp_value_ex(avp, &v, &type);
-	cols[++n] = regavp_value_column;
-	string_val(vals[n], &v);
-	
-	cols[++n] = regavp_type_column;
-	int_val(vals[n], type);
-	
-	cols[++n] = regavp_flags_column;
-	int_val(vals[n], avp->flags);
-
-	if (ul_dbf.insert(ul_dbh, cols, vals, n + 1) < 0) {
-		ERR("Can't insert record into DB\n");
-		return -1;
-	}
-	
-	return 0;
-}
-
-int db_save_reg_avps_et(struct ucontact *c)
-{
-	avp_t *avp = c->avps;
-	int res = 0;
-
-	if (!can_write_db()) return 0;
-
-	if (avp) {
-		if (ul_dbf.use_table(ul_dbh, reg_avp_table) < 0) {
-			ERR("Error in use_table\n");
-			return -1;
-		}
-	}
-
-	while (avp) {
-		if (db_save_avp_et(avp, c->uid, &c->c) < 0) res = -1;
-		avp = avp->next;
-	}
-	
-	return res;
-}
-
-int db_update_reg_avps_et(struct ucontact* _c)
-{
-	db_delete_reg_avps(_c);
-	return db_save_reg_avps(_c);
-}
 
 /* AVPs are stored into 'location' table into "serialized_avp_column" column - hack for
  * existing database */
 
 int db_delete_reg_avps_lt(struct ucontact *c) /* !!! FIXME: hacked version !!! */
 {
+	/*
 	db_key_t cols[] = { serialized_reg_avp_column };
 	db_val_t vals[1];
-	
 	db_key_t keys[] = { regavp_uid_column, regavp_contact_column };
 	db_op_t ops[] = { OP_EQ, OP_EQ };
 	db_val_t k_vals[2];
-	char b[256];
 	
 	if (!can_write_db()) return 0;
 
-	memcpy(b, c->domain->s, c->domain->len);
-	b[c->domain->len] = '\0';
-	
-	if (ul_dbf.use_table(ul_dbh, b) < 0) {
-		ERR("Error in use_table\n");
-		return -1;
-	}
+	del_avps[cur_cmd]->params[0].v.str = *c->uid;
+	del_avps[cur_cmd]->params[1].v.str = c->c;
 
 	string_val(k_vals[0], c->uid);
 	string_val(k_vals[1], &c->c);
@@ -398,6 +225,9 @@ int db_delete_reg_avps_lt(struct ucontact *c) /* !!! FIXME: hacked version !!! *
 	}
 	
 	return 0;
+	*/
+	ERR("No implemented\n");
+	return -1;
 }
 
 int db_update_reg_avps_lt(struct ucontact *c) /* !!! FIXME: hacked version !!! */
@@ -408,6 +238,7 @@ int db_update_reg_avps_lt(struct ucontact *c) /* !!! FIXME: hacked version !!! *
 
 int db_save_reg_avps_lt(struct ucontact *c) /* !!! FIXME: hacked version !!! */
 {
+	/*
 	avp_t *avp = c->avps;
 	db_key_t cols[] = { serialized_reg_avp_column };
 	db_val_t vals[1];
@@ -445,61 +276,48 @@ int db_save_reg_avps_lt(struct ucontact *c) /* !!! FIXME: hacked version !!! */
 	}
 
 	if (s.s) pkg_free(s.s);
-	
+	*/
+	ERR("No implemented yet\n");
 	return 0;
 }
 
-int db_read_reg_avps_lt(db_con_t* con, struct ucontact *c) /* !!! FIXME: hacked version !!! */
+int db_read_reg_avps_lt(struct ucontact *c) /* !!! FIXME: hacked version !!! */
 {
 	/* load on startup, ... */
+	/*
 	db_key_t keys[] = { regavp_uid_column, regavp_contact_column };
 	db_op_t ops[] = { OP_EQ, OP_EQ };
 	db_val_t k_vals[2];
-	db_res_t *res = NULL;
 	db_key_t result_cols[] = { serialized_reg_avp_column };
 	char b[256];
+	*/
+	db_res_t *res = NULL;
+	db_rec_t* rec;
 
 	if (db_mode == NO_DB) {
 		INFO("not reading attrs\n");
 		return 0;
 	}
 
-	memcpy(b, c->domain->s, c->domain->len);
-	b[c->domain->len] = '\0';
-	
 /*	INFO("reading attrs for uid: %.*s, contact: %.*s\n",
 			c->uid->len, c->uid->s, 
 			c->c.len, c->c.s);*/
-	
-	string_val(k_vals[0], c->uid);
-	string_val(k_vals[1], &c->c);
-	
-	if (ul_dbf.use_table(con, b) < 0) {
-		ERR("Error in use_table\n");
-		return -1;
-	}
 
-	if (ul_dbf.query (con, keys, ops, k_vals,
-			result_cols, 2, sizeof(result_cols) / sizeof(db_key_t), 
-			0, &res) < 0) {
+	read_avps[cmd_n]->params[0].v.str = *c->uid;
+	read_avps[cmd_n]->params[1].v.str = c->c;
+	
+	if (db_exec(&res, read_avps[cur_cmd]) < 0) {
 		ERR("Error while querying contact attrs\n");
 		return -1;
 	}
 	
-	if (!res) return 0; /* ? */
-	
-	if (res->n > 0) {
-		str serialized_avps = STR_NULL;
-		db_row_t *row = &res->rows[0];
-		db_val_t *row_vals = ROW_VALUES(row);
-		
-		get_str_val(row_vals[0], serialized_avps);
-		/* INFO("reading AVPs from db: %.*s\n", serialized_avps.len, serialized_avps.s); */
-		c->avps = deserialize_avps(&serialized_avps);
-
+	for(rec = db_first(res); rec; rec = db_next(res)) {
+		if ((rec->fld[0].flags & DB_NULL) != DB_NULL) {
+			c->avps = deserialize_avps(&rec->fld[0].v.str);
+		}
 	}
-	ul_dbf.free_result(con, res);
-	
+
+	db_res_free(res);
 	return 0;
 }
 
@@ -524,41 +342,25 @@ static inline int serialize_reg_avps()
 
 int db_save_reg_avps(struct ucontact* c)
 {
-	if (!use_reg_avps()) return 0;
-	
-	if (serialize_reg_avps())
-		return db_save_reg_avps_lt(c);
-	else 
-		return db_save_reg_avps_et(c);
+	if (!use_reg_avps() || !serialize_reg_avps()) return 0;
+	return db_save_reg_avps_lt(c);
 }
 
 int db_delete_reg_avps(struct ucontact* c)
 {
-	if (!use_reg_avps()) return 0;
-	
-	if (serialize_reg_avps())
-		return db_delete_reg_avps_lt(c);
-	else 
-		return db_delete_reg_avps_et(c);
+	if (!use_reg_avps() || !serialize_reg_avps()) return 0;
+	return db_delete_reg_avps_lt(c);
 }
 
 int db_update_reg_avps(struct ucontact* c)
 {
-	if (!use_reg_avps()) return 0;
-
-	if (serialize_reg_avps())
-		return db_update_reg_avps_lt(c);
-	else 
-		return db_update_reg_avps_et(c);
+	if (!use_reg_avps() || !serialize_reg_avps()) return 0;
+	return db_update_reg_avps_lt(c);
 }
 
-int db_read_reg_avps(db_con_t* con, struct ucontact *c)
+int db_read_reg_avps(struct ucontact *c)
 {
-	if (!use_reg_avps()) return 0;
-
-	if (serialize_reg_avps())
-		return db_read_reg_avps_lt(con, c);
-	else 
-		return db_read_reg_avps_et(con, c);
+	if (!use_reg_avps() || !serialize_reg_avps()) return 0;
+	return db_read_reg_avps_lt(c);
 }
 
diff --git a/modules_s/usrloc/ucontact.c b/modules_s/usrloc/ucontact.c
index 6dfdd4191..7ec928a87 100644
--- a/modules_s/usrloc/ucontact.c
+++ b/modules_s/usrloc/ucontact.c
@@ -490,213 +490,47 @@ int st_flush_ucontact(ucontact_t* _c)
 /*
  * Insert contact into the database
  */
-int db_insert_ucontact(ucontact_t* _c)
+int db_store_ucontact(ucontact_t* _c)
 {
-	char b[256];
-	db_key_t keys[11];
-	db_val_t vals[11];
-	
-	if (_c->flags & FL_MEM) {
-		return 0;
-	}
-
-	keys[0] = uid_col.s;
-	keys[1] = contact_col.s;
-	keys[2] = expires_col.s;
-	keys[3] = q_col.s;
-	keys[4] = callid_col.s;
-	keys[5] = cseq_col.s;
-	keys[6] = flags_col.s;
-	keys[7] = user_agent_col.s;
-	keys[8] = received_col.s;
-	keys[9] = instance_col.s;
-	keys[10] = aor_col.s;
-
-	vals[0].type = DB_STR;
-	vals[0].nul = 0;
-	vals[0].val.str_val.s = _c->uid->s;
-	vals[0].val.str_val.len = _c->uid->len;
-
-	vals[1].type = DB_STR;
-	vals[1].nul = 0;
-	vals[1].val.str_val.s = _c->c.s; 
-	vals[1].val.str_val.len = MIN(_c->c.len, 255);
-
-	vals[2].type = DB_DATETIME;
-	vals[2].nul = 0;
-	vals[2].val.time_val = _c->expires;
-
-	vals[3].type = DB_FLOAT;
-	vals[3].nul = 0;
-	vals[3].val.float_val = (float)q2double(_c->q);
-
-	vals[4].type = DB_STR;
-	vals[4].nul = 0;
-	vals[4].val.str_val.s = _c->callid.s;
-	vals[4].val.str_val.len = MIN(_c->callid.len, 255);
-
-	vals[5].type = DB_INT;
-	vals[5].nul = 0;
-	vals[5].val.int_val = _c->cseq;
-
-	vals[6].type = DB_INT;
-	vals[6].nul = 0;
-	vals[6].val.bitmap_val = _c->flags;
-
-	vals[7].type = DB_STR;
-	vals[7].nul = 0;
-	vals[7].val.str_val.s = _c->user_agent.s;
-	vals[7].val.str_val.len = MIN(_c->user_agent.len, 64);
-
-	vals[8].type = DB_STR;
-
-	if (_c->received.s == 0) {
-		vals[8].nul = 1;
-	} else {
-		vals[8].nul = 0;
-		vals[8].val.str_val.s = _c->received.s;
-		vals[8].val.str_val.len = _c->received.len;
-	}
-
-	vals[9].type = DB_STR;
-	if (_c->instance.s == 0) {
-		vals[9].nul = 1;
-	} else {
-		vals[9].nul = 0;
-		vals[9].val.str_val.s = _c->instance.s;
-		vals[9].val.str_val.len = _c->instance.len;
-	}
-
-	vals[10].type = DB_STR;
-	vals[10].nul = 0;
-	vals[10].val.str_val.s = _c->aor.s;
-	vals[10].val.str_val.len = MIN(_c->aor.len, 255);
-
-
-	     /* FIXME */
-	memcpy(b, _c->domain->s, _c->domain->len);
-	b[_c->domain->len] = '\0';
-	if (ul_dbf.use_table(ul_dbh, b) < 0) {
-		LOG(L_ERR, "db_insert_ucontact(): Error in use_table\n");
-		return -1;
-	}
-
-	if (ul_dbf.insert(ul_dbh, keys, vals, 11) < 0) {
-		LOG(L_ERR, "db_insert_ucontact(): Error while inserting contact\n");
-		return -1;
-	}
-
-	return 0;
-}
-
-
-/*
- * Update contact in the database
- */
-int db_update_ucontact(ucontact_t* _c)
-{
-	char b[256];
-	db_key_t keys1[2];
-	db_val_t vals1[2];
-
-	db_key_t keys2[9];
-	db_val_t vals2[9];
-
 	if (_c->flags & FL_MEM) {
 		return 0;
 	}
 
-	keys1[0] = uid_col.s;
-	if (_c->instance.s == 0) {
-		keys1[1] = contact_col.s;
-		keys2[7] = instance_col.s;
-	} else {
-		keys1[1] = instance_col.s;
-		keys2[7] = contact_col.s;
-	}
-	keys2[0] = expires_col.s;
-	keys2[1] = q_col.s;
-	keys2[2] = callid_col.s;
-	keys2[3] = cseq_col.s;
-	keys2[4] = flags_col.s;
-	keys2[5] = user_agent_col.s;
-	keys2[6] = received_col.s;
-	keys2[8] = aor_col.s;
-
-	vals1[0].type = DB_STR;
-	vals1[0].nul = 0;
-	vals1[0].val.str_val = *_c->uid;
-
-	vals1[1].type = DB_STR;
-	vals1[1].nul = 0;
-	if (_c->instance.s == 0) {
-		vals1[1].val.str_val.s = _c->c.s;
-		vals1[1].val.str_val.len = MIN(_c->c.len, 255);
-	} else {
-		vals1[1].val.str_val.s = _c->instance.s;
-		vals1[1].val.str_val.len = MIN(_c->instance.len, 255);
-	}
-
-	vals2[0].type = DB_DATETIME;
-	vals2[0].nul = 0;
-	vals2[0].val.time_val = _c->expires;
-
-	vals2[1].type = DB_FLOAT;
-	vals2[1].nul = 0;
-	vals2[1].val.float_val = (float)q2double(_c->q);
-
-	vals2[2].type = DB_STR;
-	vals2[2].nul = 0;
-	vals2[2].val.str_val.s = _c->callid.s;
-	vals2[2].val.str_val.len = MIN(_c->callid.len, 255);
-
-	vals2[3].type = DB_INT;
-	vals2[3].nul = 0;
-	vals2[3].val.int_val = _c->cseq;
+	ins_contact[cur_cmd]->params[0].v.str = *_c->uid;
+	ins_contact[cur_cmd]->params[1].v.str.s = _c->c.s;
+	ins_contact[cur_cmd]->params[1].v.str.len = MIN(_c->c.len, 255);
+	ins_contact[cur_cmd]->params[2].v.time = _c->expires;
+	ins_contact[cur_cmd]->params[3].v.flt = (float)q2double(_c->q);
+	ins_contact[cur_cmd]->params[4].v.str.s = _c->callid.s;
+	ins_contact[cur_cmd]->params[4].v.str.len = MIN(_c->callid.len, 255);
+	ins_contact[cur_cmd]->params[5].v.int4 = _c->cseq;
+	ins_contact[cur_cmd]->params[6].v.bitmap = _c->flags;
+	ins_contact[cur_cmd]->params[7].v.str.s = _c->user_agent.s;
+	ins_contact[cur_cmd]->params[7].v.str.len = MIN(_c->user_agent.len, 64);
 
-	vals2[4].type = DB_INT;
-	vals2[4].nul = 0;
-	vals2[4].val.bitmap_val = _c->flags;
-
-	vals2[5].type = DB_STR;
-	vals2[5].nul = 0;
-	vals2[5].val.str_val.s = _c->user_agent.s;
-	vals2[5].val.str_val.len = MIN(_c->user_agent.len, 64);
-
-	vals2[6].type = DB_STR;
 	if (_c->received.s == 0) {
-		vals2[6].nul = 1;
+		ins_contact[cur_cmd]->params[8].flags |= DB_NULL;
 	} else {
-		vals2[6].nul = 0;
-		vals2[6].val.str_val = _c->received;
+		ins_contact[cur_cmd]->params[8].flags &= ~DB_NULL;
+		ins_contact[cur_cmd]->params[8].v.str = _c->received;
 	}
 
-	vals2[7].type = DB_STR;
 	if (_c->instance.s == 0) {
-		vals2[7].nul = 1;
+		ins_contact[cur_cmd]->params[9].flags |= DB_NULL;
 	} else {
-		vals2[7].nul = 0;
-		vals2[7].val.str_val = _c->c;
+		ins_contact[cur_cmd]->params[9].flags &= ~DB_NULL;
+		ins_contact[cur_cmd]->params[9].v.str = _c->instance;
 	}
 
-	vals2[8].type = DB_STR;
-	vals2[8].nul = 0;
-	vals2[8].val.str_val.s = _c->aor.s;
-	vals2[8].val.str_val.len = MIN(_c->aor.len, 255);
+	ins_contact[cur_cmd]->params[10].v.str.s = _c->aor.s;
+	ins_contact[cur_cmd]->params[10].v.str.len = MIN(_c->aor.len, 255);
 
 	     /* FIXME */
-	memcpy(b, _c->domain->s, _c->domain->len);
-	b[_c->domain->len] = '\0';
-	if (ul_dbf.use_table(ul_dbh, b) < 0) {
-		LOG(L_ERR, "db_upd_ucontact(): Error in use_table\n");
+	if (db_exec(NULL, ins_contact[cur_cmd]) < 0) {
+		ERR("Error while storing contact in database\n");
 		return -1;
 	}
-
-	if (ul_dbf.update(ul_dbh, keys1, 0, vals1, keys2, vals2, 2, 9) < 0) {
-		LOG(L_ERR, "db_upd_ucontact(): Error while updating database\n");
-		return -1;
-	}
-
+	
 	return 0;
 }
 
@@ -706,35 +540,15 @@ int db_update_ucontact(ucontact_t* _c)
  */
 int db_delete_ucontact(ucontact_t* _c)
 {
-	char b[256];
-	db_key_t keys[2];
-	db_val_t vals[2];
-
 	if (_c->flags & FL_MEM) {
 		return 0;
 	}
 
-	keys[0] = uid_col.s;
-	keys[1] = contact_col.s;
-
-	vals[0].type = DB_STR;
-	vals[0].nul = 0;
-	vals[0].val.str_val = *_c->uid;
-
-	vals[1].type = DB_STR;
-	vals[1].nul = 0;
-	vals[1].val.str_val = _c->c;
-
-	     /* FIXME */
-	memcpy(b, _c->domain->s, _c->domain->len);
-	b[_c->domain->len] = '\0';
-	if (ul_dbf.use_table(ul_dbh, b) < 0) {
-		LOG(L_ERR, "db_del_ucontact: Error in use_table\n");
-		return -1;
-	}
+	del_contact[cur_cmd]->params[0].v.str = *_c->uid;
+	del_contact[cur_cmd]->params[1].v.str = _c->c;
 
-	if (ul_dbf.delete(ul_dbh, keys, 0, vals, 2) < 0) {
-		LOG(L_ERR, "db_del_ucontact(): Error while deleting from database\n");
+	if (db_exec(NULL, del_contact[cur_cmd]) < 0) {
+		ERR("Error while deleting contact from database\n");
 		return -1;
 	}
 
@@ -763,7 +577,7 @@ int update_ucontact(ucontact_t* _c, str* _u, str* aor, time_t _e, qvalue_t _q, s
 	st_update_ucontact(_c);
 	update_reg_avps(_c);
 	if (db_mode == WRITE_THROUGH) {
-		if (db_update_ucontact(_c) < 0) {
+		if (db_store_ucontact(_c) < 0) {
 			LOG(L_ERR, "update_ucontact(): Error while updating database\n");
 		}
 		db_update_reg_avps(_c);
diff --git a/modules_s/usrloc/ucontact.h b/modules_s/usrloc/ucontact.h
index 43a3aa29b..da92f282c 100644
--- a/modules_s/usrloc/ucontact.h
+++ b/modules_s/usrloc/ucontact.h
@@ -167,13 +167,7 @@ int st_flush_ucontact(ucontact_t* _c);
 /*
  * Insert contact into the database
  */
-int db_insert_ucontact(ucontact_t* _c);
-
-
-/*
- * Update contact in the database
- */
-int db_update_ucontact(ucontact_t* _c);
+int db_store_ucontact(ucontact_t* _c);
 
 
 /*
diff --git a/modules_s/usrloc/udomain.c b/modules_s/usrloc/udomain.c
index 25bd5181a..f314d1701 100644
--- a/modules_s/usrloc/udomain.c
+++ b/modules_s/usrloc/udomain.c
@@ -278,165 +278,124 @@ static struct socket_info* find_socket(str* received)
 
 
 
-int preload_udomain(db_con_t* _c, udomain_t* _d)
+int preload_udomain(udomain_t* _d)
 {
-	char b[256];
-	db_key_t columns[11];
-	db_res_t* res;
-	db_row_t* row;
-	int i, cseq;
-	unsigned int flags;
+	db_fld_t columns[] = {
+		{.name = uid_col.s,        .type = DB_STR},
+		{.name = contact_col.s,    .type = DB_STR},
+		{.name = expires_col.s,    .type = DB_STR},
+		{.name = q_col.s,          .type = DB_DOUBLE},
+		{.name = callid_col.s,     .type = DB_STR},
+		{.name = cseq_col.s,       .type = DB_INT},
+		{.name = flags_col.s,      .type = DB_BITMAP},
+		{.name = user_agent_col.s, .type = DB_STR},
+		{.name = received_col.s,   .type = DB_STR},
+		{.name = instance_col.s,   .type = DB_STR},
+		{.name = aor_col.s,        .type = DB_STR},
+		{.name = NULL}
+	};
+
+	db_res_t* res = NULL;
+	db_rec_t* rec;
+	db_cmd_t* get_all = NULL;
+
 	struct socket_info* sock;
-	str uid, contact, callid, ua, received, instance, aor;
-	str* rec;
-	time_t expires;
+	str callid, ua, instance, aor;
+	str* receivedp;
 	qvalue_t q;
 
 	urecord_t* r;
 	ucontact_t* c;
 
-	columns[0] = uid_col.s;
-	columns[1] = contact_col.s;
-	columns[2] = expires_col.s;
-	columns[3] = q_col.s;
-	columns[4] = callid_col.s;
-	columns[5] = cseq_col.s;
-	columns[6] = flags_col.s;
-	columns[7] = user_agent_col.s;
-	columns[8] = received_col.s;
-	columns[9] = instance_col.s;
-	columns[10] = aor_col.s;
-	
-	memcpy(b, _d->name->s, _d->name->len);
-	b[_d->name->len] = '\0';
-
-	if (ul_dbf.use_table(_c, b) < 0) {
-		LOG(L_ERR, "preload_udomain(): Error in use_table\n");
+	get_all = db_cmd(DB_GET, db, _d->name->s, columns, NULL);
+	if (get_all == NULL) {
+		ERR("Error while compiling DB_GET command\n");
 		return -1;
 	}
 
-	if (ul_dbf.query(_c, 0, 0, 0, columns, 0, 11, 0, &res) < 0) {
-		LOG(L_ERR, "preload_udomain(): Error while doing db_query\n");
-		return -1;
-	}
+	if (db_exec(&res, get_all) < 0) goto error;
 
-	if (RES_ROW_N(res) == 0) {
+	rec = db_first(res);
+	if (rec == NULL) {
 		DBG("preload_udomain(): Table is empty\n");
-		ul_dbf.free_result(_c, res);
+		db_res_free(res);
+		db_cmd_free(get_all);
 		return 0;
 	}
 
 	lock_udomain(_d);
 
-	for(i = 0; i < RES_ROW_N(res); i++) {
-		row = RES_ROWS(res) + i;
-		
-		uid.s      = (char*)VAL_STRING(ROW_VALUES(row));
-		if (uid.s == 0) {
+	for(; rec != NULL; rec = db_next(res)) {
+		/* UID column must never be NULL */
+		if (rec->fld[0].flags & DB_NULL) {
 			LOG(L_CRIT, "preload_udomain: ERROR: bad uid "
-							"record in table %s\n", b);
-			LOG(L_CRIT, "preload_udomain: ERROR: skipping...\n");
+				"record in table %.*s, skipping...\n", 
+				_d->name->len, _d->name->s);
 			continue;
-		} else {
-			uid.len = strlen(uid.s);
 		}
 
-		contact.s = (char*)VAL_STRING(ROW_VALUES(row) + 1);
-		if (contact.s == 0) {
-			LOG(L_CRIT, "preload_udomain: ERROR: bad contact "
-							"record in table %s\n", b);
-			LOG(L_CRIT, "preload_udomain: ERROR: for username %.*s\n",
-							uid.len, uid.s);
-			LOG(L_CRIT, "preload_udomain: ERROR: skipping...\n");
+		/* Contact column must never be NULL */
+		if (rec->fld[1].flags & DB_NULL) {
+			LOG(L_CRIT, "ERROR: Bad contact for uid %.*s in table %.*s, skipping\n",
+				rec->fld[0].v.str.len, rec->fld[0].v.str.s,
+				_d->name->len, _d->name->s);
 			continue;
-		} else {
-			contact.len = strlen(contact.s);
-		}
-		expires     = VAL_TIME  (ROW_VALUES(row) + 2);
-		q           = double2q(VAL_DOUBLE(ROW_VALUES(row) + 3));
-		cseq        = VAL_INT   (ROW_VALUES(row) + 5);
-		callid.s    = (char*)VAL_STRING(ROW_VALUES(row) + 4);
-		if (callid.s == 0) {
-			LOG(L_CRIT, "preload_udomain: ERROR: bad callid record in"
-							" table %s\n", b);
-			LOG(L_CRIT, "preload_udomain: ERROR: for username %.*s,"
-							" contact %.*s\n",
-							uid.len, uid.s, contact.len, contact.s);
-			LOG(L_CRIT, "preload_udomain: ERROR: skipping...\n");
-			continue;
-		} else {
-			callid.len  = strlen(callid.s);
 		}
 
-		flags  = VAL_BITMAP(ROW_VALUES(row) + 6);
+		q = double2q(rec->fld[3].v.dbl);
 
-		ua.s  = (char*)VAL_STRING(ROW_VALUES(row) + 7);
-		if (ua.s) {
-			ua.len = strlen(ua.s);
+		if (rec->fld[4].flags & DB_NULL) {
+			callid.s = NULL;
+			callid.len = 0;
 		} else {
-			ua.len = 0;
+			callid = rec->fld[4].v.str;
 		}
 
-		if (!VAL_NULL(ROW_VALUES(row) + 8)) {
-			received.s  = (char*)VAL_STRING(ROW_VALUES(row) + 8);
-			if (received.s) {
-				received.len = strlen(received.s);
-				rec = &received;
-
-				sock = find_socket(&received);
-			} else {
-				received.len = 0;
-				rec = 0;
-				sock = 0;
-			}
+		if (rec->fld[7].flags & DB_NULL) {
+			ua.s = NULL;
+			ua.len = 0;
 		} else {
-			received.s = 0;
-			received.len = 0;
-			rec = 0;
-			sock = 0;
+			ua = rec->fld[7].v.str;
 		}
 
-		if (!VAL_NULL(ROW_VALUES(row) + 9)) {
-			instance.s  = (char*)VAL_STRING(ROW_VALUES(row) + 9);
-			if (instance.s) {
-				instance.len = strlen(instance.s);
-			} else {
-				instance.len = 0;
-			}
+		if (rec->fld[8].flags & DB_NULL) {
+			receivedp = 0;
+			sock = 0;
 		} else {
-			instance.s = 0;
-			instance.len = 0;
+			receivedp = &rec->fld[8].v.str;
+			sock = find_socket(receivedp);
 		}
 
-		if (!VAL_NULL(ROW_VALUES(row) + 10)) {
-			aor.s  = (char*)VAL_STRING(ROW_VALUES(row) + 10);
-			if (aor.s) {
-				aor.len = strlen(aor.s);
-			} else {
-				aor.len = 0;
-			}
+		if (rec->fld[9].flags & DB_NULL) {
+			instance.s = NULL;
+			instance.len = 0;
 		} else {
-			aor.s = 0;
+			instance = rec->fld[9].v.str;
+		}
+
+		if (rec->fld[10].flags & DB_NULL) {
+			aor.s = NULL;
 			aor.len = 0;
+		} else {
+			aor = rec->fld[10].v.str;
 		}
 
-		if (get_urecord(_d, &uid, &r) > 0) {
-			if (mem_insert_urecord(_d, &uid, &r) < 0) {
+		if (get_urecord(_d, &rec->fld[0].v.str, &r) > 0) {
+			if (mem_insert_urecord(_d, &rec->fld[0].v.str, &r) < 0) {
 				LOG(L_ERR, "preload_udomain(): Can't create a record\n");
-				ul_dbf.free_result(_c, res);
 				unlock_udomain(_d);
-				return -2;
+				goto error;
 			}
 		}
 		
-		if (mem_insert_ucontact(r, &aor, &contact, expires, q, &callid, cseq, flags, &c, &ua, rec, sock, &instance) < 0) {
+		if (mem_insert_ucontact(r, &aor, &rec->fld[1].v.str, rec->fld[2].v.int4, 
+								q, &callid, rec->fld[5].v.int4, rec->fld[6].v.bitmap, &c, &ua, receivedp, sock, &instance) < 0) {
 			LOG(L_ERR, "preload_udomain(): Error while inserting contact\n");
-			ul_dbf.free_result(_c, res);
 			unlock_udomain(_d);
-			return -3;
+			goto error;
 		}
 
-		db_read_reg_avps(_c, c);
+		db_read_reg_avps(c);
 
 		     /* We have to do this, because insert_ucontact sets state to CS_NEW
 		      * and we have the contact in the database already
@@ -446,9 +405,15 @@ int preload_udomain(db_con_t* _c, udomain_t* _d)
 		c->state = CS_SYNC;
 	}
 
-	ul_dbf.free_result(_c, res);
 	unlock_udomain(_d);
+	db_res_free(res);
+	db_cmd_free(get_all);
 	return 0;
+
+ error:
+	if (res) db_res_free(res);
+	if (get_all) db_cmd_free(get_all);
+	return -1;
 }
 
 
@@ -527,6 +492,7 @@ int timer_udomain(udomain_t* _d)
 void lock_udomain(udomain_t* _d)
 {
 	lock_get(&_d->lock);
+	cur_cmd = _d->db_cmd_idx;
 }
 
 
@@ -588,7 +554,7 @@ int delete_urecord(udomain_t* _d, str* _uid)
 	if (get_urecord(_d, _uid, &r) > 0) {
 		return 0;
 	}
-		
+
 	c = r->contacts;
 	while(c) {
 		t = c;
diff --git a/modules_s/usrloc/udomain.h b/modules_s/usrloc/udomain.h
index fbc56e191..b6f8d5ade 100644
--- a/modules_s/usrloc/udomain.h
+++ b/modules_s/usrloc/udomain.h
@@ -62,6 +62,7 @@ typedef struct udomain {
 	str* name;                     /* Domain name */
 	int users;                     /* Number of registered users */
 	int expired;                   /* Number of expired contacts */
+	int db_cmd_idx;                /* Index into db_cmd arrays */
 	struct hslot* table;           /* Hash table - array of collision slots */
 	struct {                       /* Linked list of all elements in the domain */
 		int n;                 /* Number of element in the linked list */
@@ -98,7 +99,7 @@ void print_udomain(FILE* _f, udomain_t* _d);
 /*
  * Load data from a database
  */
-int preload_udomain(db_con_t* _c, udomain_t* _d);
+int preload_udomain(udomain_t* _d);
 
 
 /*
diff --git a/modules_s/usrloc/ul_mod.c b/modules_s/usrloc/ul_mod.c
index eed2941df..1633c6b62 100644
--- a/modules_s/usrloc/ul_mod.c
+++ b/modules_s/usrloc/ul_mod.c
@@ -102,8 +102,10 @@ int db_mode         = 0;              /* Database sync scheme: 0-no db, 1-write
 int desc_time_order = 0;              /* By default do not enable timestamp ordering */
 
 
-db_con_t* ul_dbh = 0; /* Database connection handle */
-db_func_t ul_dbf;
+db_ctx_t* db = NULL;
+db_cmd_t** del_contact = NULL;
+db_cmd_t** ins_contact = NULL;
+int cmd_n = 0, cur_cmd = 0;
 
 static char *reg_avp_flag_name = NULL;
 
@@ -154,8 +156,8 @@ static param_export_t params[] = {
 	{"instance_column",   PARAM_STR, &instance_col   },
 	{"aor_column",        PARAM_STR, &aor_col        },
 	{"reg_avp_table",     PARAM_STRING, &reg_avp_table  },
-	{"reg_avp_column",       PARAM_STRING, &serialized_reg_avp_column  },	
-	{"regavp_uid_column", PARAM_STRING, &regavp_uid_column  },
+	{"reg_avp_column",        PARAM_STRING, &serialized_reg_avp_column  },	
+	{"regavp_uid_column",     PARAM_STRING, &regavp_uid_column  },
 	{"regavp_contact_column", PARAM_STRING, &regavp_contact_column  },
 	{"regavp_name_column",    PARAM_STRING, &regavp_name_column  },
 	{"regavp_value_column",   PARAM_STRING, &regavp_value_column  },
@@ -200,59 +202,128 @@ static int mod_init(void)
 		return -1;
 	}
 
-	/* Shall we use database ? */
-	if (db_mode != NO_DB) { /* Yes */
-		if (bind_dbmod(db_url.s, &ul_dbf) < 0) { /* Find database module */
-			LOG(L_ERR, "ERROR: mod_init(): Can't bind database module\n");
-			return -1;
-		}
-		if (!DB_CAPABILITY(ul_dbf, DB_CAP_ALL)) {
-			LOG(L_ERR, "usrloc:mod_init: Database module does not implement"
-						" all functions needed by the module\n");
-			return -1;
-		}
+	set_reg_avpflag_name(reg_avp_flag_name);
+
+	return 0;
+}
+
+
+static int build_db_cmds(void)
+{
+	db_fld_t del_contact_params[] = {
+		{.name = uid_col.s, .type = DB_STR},
+		{.name = contact_col.s, .type = DB_STR},
+		{.name = NULL},
+	};
+	
+	db_fld_t ins_contact_params[] = {
+		{.name = uid_col.s,        .type = DB_STR},
+		{.name = contact_col.s,    .type = DB_STR},
+		{.name = expires_col.s,    .type = DB_DATETIME},
+		{.name = q_col.s,          .type = DB_DOUBLE},
+		{.name = callid_col.s,     .type = DB_STR},
+		{.name = cseq_col.s,       .type = DB_INT},
+		{.name = flags_col.s,      .type = DB_BITMAP},
+		{.name = user_agent_col.s, .type = DB_STR},
+		{.name = received_col.s,   .type = DB_STR},
+		{.name = instance_col.s,   .type = DB_STR},
+		{.name = aor_col.s,        .type = DB_STR},
+		{.name = NULL},
+	};
+	
+	dlist_t* ptr;
+	int i;
+
+	for(cmd_n = 0, ptr = root; ptr; cmd_n++, ptr = ptr->next);
+
+	del_contact = pkg_malloc(cmd_n);
+	if (del_contact == NULL) {
+		ERR("No memory left\n");
+		return -1;
 	}
+	memset(del_contact, '\0', sizeof(del_contact) * cmd_n);
 
-	set_reg_avpflag_name(reg_avp_flag_name);
+	ins_contact = pkg_malloc(cmd_n);
+	if (ins_contact == NULL) {
+		ERR("No memory left\n");
+		return -1;
+	}
+	memset(ins_contact, '\0', sizeof(ins_contact) * cmd_n);
 
+	for(i = 0, ptr = root; ptr; ptr = ptr->next, i++) {
+		del_contact[i] = db_cmd(DB_DEL, db, ptr->name.s, NULL, del_contact_params);
+		if (del_contact[i] == NULL) return -1;
+	}
+
+	for(i = 0, ptr = root; ptr; ptr = ptr->next, i++) {
+		ins_contact[i] = db_cmd(DB_PUT, db, ptr->name.s, NULL, ins_contact_params);
+		if (ins_contact[i] == NULL) return -1;
+	}
 	return 0;
 }
 
 
+
 static int child_init(int _rank)
 {
 	if (_rank==PROC_MAIN || _rank==PROC_TCP_MAIN)
 		return 0; /* do nothing for the main or tcp_main processes */
 	     /* Shall we use database ? */
 	if ( db_mode != NO_DB) { /* Yes */
-		ul_dbh = ul_dbf.init(db_url.s); /* Get a new database connection */
-		if (!ul_dbh) {
-			LOG(L_ERR, "ERROR: child_init(%d): "
-			    "Error while connecting database\n", _rank);
+		db = db_ctx("usrloc");
+		if (db == NULL) {
+			ERR("Error while initializing database layer\n");
 			return -1;
 		}
+
+		if (db_add_db(db, db_url.s) < 0) return -1;
+		if (db_connect(db) < 0) return -1;
+		if (build_db_cmds() < 0) return -1;
 	}
 
 	return 0;
 }
 
 
+
 /*
  * Module destroy function
  */
 static void destroy(void)
 {
+	int i;
+
 	/* Parent only, synchronize the world
 	* and then nuke it */
-	if (is_main && ul_dbh) {
+	if (is_main && db) {
 		if (synchronize_all_udomains() != 0) {
 			LOG(L_ERR, "timer(): Error while flushing cache\n");
 		}
 		free_all_udomains();
 	}
 
-	/* All processes close database connection */
-	if (ul_dbh) ul_dbf.close(ul_dbh);
+	if (del_rec) {
+		for(i = 0; i < cmd_n; i++) {
+			if (del_rec[i]) db_cmd_free(del_rec[i]);
+		}
+		pkg_free(del_rec);
+	}
+
+	if (del_contact) {
+		for(i = 0; i < cmd_n; i++) {
+			if (del_contact[i]) db_cmd_free(del_contact[i]);
+		}
+		pkg_free(del_rec);
+	}
+
+	if (ins_contact) {
+		for(i = 0; i < cmd_n; i++) {
+			if (ins_contact[i]) db_cmd_free(ins_contact[i]);
+		}
+		pkg_free(del_rec);
+	}
+
+	if (db) db_ctx_free(db);
 
 	/* free callbacks list */
 	destroy_ulcb_list();
diff --git a/modules_s/usrloc/ul_mod.h b/modules_s/usrloc/ul_mod.h
index 0f9d69c6c..6aeb32296 100644
--- a/modules_s/usrloc/ul_mod.h
+++ b/modules_s/usrloc/ul_mod.h
@@ -57,8 +57,6 @@ enum ul_db_type {
 #define WRITE_BACK    2
 #define READONLY      3
 
-#define TABLE_VERSION 9
-
 extern str uid_col;
 extern str contact_col;
 extern str expires_col;
@@ -76,8 +74,11 @@ extern int timer_interval;
 extern int db_mode;
 extern int desc_time_order;
 
-extern db_con_t* ul_dbh;   /* Database connection handle */
-extern db_func_t ul_dbf;
-
+extern db_ctx_t* db;
+extern db_cmd_t** del_rec;
+extern db_cmd_t** del_contact;
+extern db_cmd_t** ins_contact;
+extern db_cmd_t** read_avps;
+extern int cmd_n, cur_cmd;
 
 #endif /* UL_MOD_H */
diff --git a/modules_s/usrloc/urecord.c b/modules_s/usrloc/urecord.c
index 9b9784895..dc8fddc19 100644
--- a/modules_s/usrloc/urecord.c
+++ b/modules_s/usrloc/urecord.c
@@ -345,14 +345,14 @@ static inline int wb_timer(urecord_t* _r)
 				break;
 
 			case 1: /* insert */
-				if (db_insert_ucontact(ptr) < 0) {
+				if (db_store_ucontact(ptr) < 0) {
 					LOG(L_ERR, "wb_timer(): Error while inserting contact into database\n");
 				}
 				db_save_reg_avps(ptr);
 				break;
 
 			case 2: /* update */
-				if (db_update_ucontact(ptr) < 0) {
+				if (db_store_ucontact(ptr) < 0) {
 					LOG(L_ERR, "wb_timer(): Error while updating contact in db\n");
 				}
 				db_update_reg_avps(ptr);
@@ -393,38 +393,6 @@ int timer_urecord(urecord_t* _r)
 }
 
 
-
-int db_delete_urecord(urecord_t* _r)
-{
-	static char b[256];
-	db_key_t keys[1];
-	db_val_t vals[1];
-
-	keys[0] = uid_col.s;
-	vals[0].type = DB_STR;
-	vals[0].nul = 0;
-	vals[0].val.str_val.s = _r->uid.s;
-	vals[0].val.str_val.len = _r->uid.len;
-
-	     /* FIXME */
-	memcpy(b, _r->domain->s, _r->domain->len);
-	b[_r->domain->len] = '\0';
-	if (ul_dbf.use_table(ul_dbh, b) < 0) {
-		LOG(L_ERR, "ERROR: db_delete_urecord():"
-		                " Error in use_table\n");
-		return -1;
-	}
-
-	if (ul_dbf.delete(ul_dbh, keys, 0, vals, 1) < 0) {
-		LOG(L_ERR, "ERROR: db_delete_urecord():"
-				" Error while deleting from database\n");
-		return -1;
-	}
-
-	return 0;
-}
-
-
 /*
  * Release urecord previously obtained
  * through get_urecord
@@ -458,7 +426,7 @@ int insert_ucontact(urecord_t* _r, str* aor, str* _c, time_t _e, qvalue_t _q, st
 	save_reg_avps(*_con);
 	
 	if (db_mode == WRITE_THROUGH) {
-		if (db_insert_ucontact(*_con) < 0) {
+		if (db_store_ucontact(*_con) < 0) {
 			LOG(L_ERR, "insert_ucontact(): Error while inserting in database\n");
 		}
 		(*_con)->state = CS_SYNC;
diff --git a/modules_s/usrloc/urecord.h b/modules_s/usrloc/urecord.h
index 67b7ef40f..8f3e7833c 100644
--- a/modules_s/usrloc/urecord.h
+++ b/modules_s/usrloc/urecord.h
@@ -111,12 +111,6 @@ void mem_delete_ucontact(urecord_t* _r, ucontact_t* _c);
 int timer_urecord(urecord_t* _r);
 
 
-/*
- * Delete the whole record from database
- */
-int db_delete_urecord(urecord_t* _r);
-
-
 /* ===== Module interface ======== */
 
 

