commit 1f9cafc3adff803bc667aa1331f2108943001574
Author: Sean Paul <seanpaul@chromium.org>
Date:   Thu Jan 30 16:19:03 2014 -0500

    drm/exynos: Add an initialize function to manager and display
    
    This patch adds an initialize function to the manager and display
    operations. This allows them to keep track of drm_device in their
    local context, as well as adds an initialization hook right after
    the encoder is created.
    
    Signed-off-by: Sean Paul <seanpaul@chromium.org>
    Reviewed-by: Tomasz Figa <t.figa@samsung.com>
    Signed-off-by: Inki Dae <inki.dae@samsung.com>

diff --git a/drivers/gpu/drm/exynos/exynos_drm_drv.h b/drivers/gpu/drm/exynos/exynos_drm_drv.h
index 4288d0adf59a..2811486bb066 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_drv.h
+++ b/drivers/gpu/drm/exynos/exynos_drm_drv.h
@@ -123,6 +123,7 @@ struct exynos_drm_overlay {
  *	- this structure is common to analog tv, digital tv and lcd panel.
  *
  * @type: one of EXYNOS_DISPLAY_TYPE_LCD and HDMI.
+ * @initialize: initializes the display with drm_dev
  * @is_connected: check for that display is connected or not.
  * @get_edid: get edid modes from display driver.
  * @get_panel: get panel object from display driver.
@@ -131,6 +132,7 @@ struct exynos_drm_overlay {
  */
 struct exynos_drm_display_ops {
 	enum exynos_drm_output_type type;
+	int (*initialize)(struct device *dev, struct drm_device *drm_dev);
 	bool (*is_connected)(struct device *dev);
 	struct edid *(*get_edid)(struct device *dev,
 			struct drm_connector *connector);
@@ -142,6 +144,7 @@ struct exynos_drm_display_ops {
 /*
  * Exynos drm manager ops
  *
+ * @initialize: initializes the manager with drm_dev
  * @dpms: control device power.
  * @apply: set timing, vblank and overlay data to registers.
  * @mode_fixup: fix mode data comparing to hw specific display mode.
@@ -159,6 +162,8 @@ struct exynos_drm_display_ops {
  * @win_disable: disable hardware specific overlay.
  */
 struct exynos_drm_manager_ops {
+	int (*initialize)(struct device *subdrv_dev,
+			struct drm_device *drm_dev);
 	void (*dpms)(struct device *subdrv_dev, int mode);
 	void (*apply)(struct device *subdrv_dev);
 	void (*mode_fixup)(struct device *subdrv_dev,
diff --git a/drivers/gpu/drm/exynos/exynos_drm_encoder.c b/drivers/gpu/drm/exynos/exynos_drm_encoder.c
index c255341ed174..a9eb2b0b933d 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_encoder.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_encoder.c
@@ -316,6 +316,7 @@ exynos_drm_encoder_create(struct drm_device *dev,
 {
 	struct drm_encoder *encoder;
 	struct exynos_drm_encoder *exynos_encoder;
+	int ret;
 
 	if (!manager || !possible_crtcs)
 		return NULL;
@@ -339,9 +340,29 @@ exynos_drm_encoder_create(struct drm_device *dev,
 
 	drm_encoder_helper_add(encoder, &exynos_encoder_helper_funcs);
 
+	if (manager->ops && manager->ops->initialize) {
+		ret = manager->ops->initialize(manager->dev, dev);
+		if (ret) {
+			DRM_ERROR("Manager initialize failed %d\n", ret);
+			goto error;
+		}
+	}
+
+	if (manager->display_ops && manager->display_ops->initialize) {
+		ret = manager->display_ops->initialize(manager->dev, dev);
+		if (ret) {
+			DRM_ERROR("Display initialize failed %d\n", ret);
+			goto error;
+		}
+	}
+
 	DRM_DEBUG_KMS("encoder has been created\n");
 
 	return encoder;
+
+error:
+	exynos_drm_encoder_destroy(&exynos_encoder->drm_encoder);
+	return NULL;
 }
 
 struct exynos_drm_manager *exynos_drm_get_manager(struct drm_encoder *encoder)

