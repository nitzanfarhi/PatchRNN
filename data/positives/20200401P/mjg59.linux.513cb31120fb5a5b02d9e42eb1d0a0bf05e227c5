commit 513cb31120fb5a5b02d9e42eb1d0a0bf05e227c5
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Mon Feb 22 14:14:31 2016 +0530

    ASoC: fix memory leak
    
    If dai_link is already bound then we just returned and leaked rtd and
    rtd->codec_dais which were allocated by soc_new_pcm_runtime(). We do not
    need this newly allocated rtd to check if dai_link is already binded. Lets
    check first if it is already binded before allocating this memory.
    
    Signed-off-by: Sudip Mukherjee <sudip.mukherjee@codethink.co.uk>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 790ee2bf1a47..d2e62b159610 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -986,16 +986,16 @@ static int soc_bind_dai_link(struct snd_soc_card *card,
 
 	dev_dbg(card->dev, "ASoC: binding %s\n", dai_link->name);
 
-	rtd = soc_new_pcm_runtime(card, dai_link);
-	if (!rtd)
-		return -ENOMEM;
-
 	if (soc_is_dai_link_bound(card, dai_link)) {
 		dev_dbg(card->dev, "ASoC: dai link %s already bound\n",
 			dai_link->name);
 		return 0;
 	}
 
+	rtd = soc_new_pcm_runtime(card, dai_link);
+	if (!rtd)
+		return -ENOMEM;
+
 	cpu_dai_component.name = dai_link->cpu_name;
 	cpu_dai_component.of_node = dai_link->cpu_of_node;
 	cpu_dai_component.dai_name = dai_link->cpu_dai_name;

