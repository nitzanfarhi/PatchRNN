commit da191be852fa3e12e87b846210b949cfe2bc69dc
Author: David Beer <dbeer@adaptivecomputing.com>
Date:   Wed Jun 12 15:51:48 2013 -0600

    TRQ-1978. Fix a segfault in BLCR checkpointing if pbs_server cannot be contacted.

diff --git a/src/lib/Libifl/pbsD_connect.c b/src/lib/Libifl/pbsD_connect.c
index 2654ee006..cfa93b358 100644
--- a/src/lib/Libifl/pbsD_connect.c
+++ b/src/lib/Libifl/pbsD_connect.c
@@ -1435,7 +1435,7 @@ int pbs_disconnect_socket(
     DIS_tcp_cleanup(chan);
   close(sock);
   return(0);
-  }  /* END pbs_disconnect() */
+  }  /* END pbs_disconnect_socket() */
 
 
 int pbs_disconnect(
@@ -1445,6 +1445,10 @@ int pbs_disconnect(
   {
   int  sock;
 
+  if ((connect < 0) ||
+      (connect > PBS_NET_MAX_CONNECTIONS))
+    return(-1);
+
   pthread_mutex_lock(connection[connect].ch_mutex);
 
   /* send close-connection message */
diff --git a/src/resmom/checkpoint.c b/src/resmom/checkpoint.c
index 3b5481974..c49677aa3 100644
--- a/src/resmom/checkpoint.c
+++ b/src/resmom/checkpoint.c
@@ -84,6 +84,8 @@
 #include "../lib/Libifl/lib_ifl.h"
 #include "mom_config.h"
 
+#define MAX_CONN_RETRY 3
+
 extern int exiting_tasks;
 extern     int             lockfds;
 extern int ForceServerUpdate;
@@ -868,6 +870,52 @@ void mom_checkpoint_check_periodic_timer(
 
 
 
+/*
+ * establish_server_connection()
+ *
+ * establishes a conncection to pjob's server if possible.
+ * @pre-cond pjob must have a server attribute and be a valid job
+ * @param - pjob the job whose server we should connect to
+ * @return - the index of the connection to pjob's server, or -1 on error
+ */
+
+int establish_server_connection(
+    
+  job &pjob)
+
+  {
+  int num_attempts = 0;
+  int connection   = -1;
+
+  if (pjob.ji_wattr[JOB_ATR_at_server].at_val.at_str == NULL)
+    return(connection);
+
+  while ((connection < 0) &&
+         (num_attempts < MAX_CONN_RETRY))
+    {
+    if (num_attempts > 0)
+      sleep(1);
+
+    connection = pbs_connect(pjob.ji_wattr[JOB_ATR_at_server].at_val.at_str);
+
+    if (connection < 0)
+      {
+      num_attempts++;
+      }
+    }
+  
+  if (num_attempts == MAX_CONN_RETRY)
+    {
+    sprintf(log_buffer,"Job %s failed %d times to get connection to %s",
+      pjob.ji_qs.ji_jobid,
+      MAX_CONN_RETRY,
+      pjob.ji_wattr[JOB_ATR_at_server].at_val.at_str);
+    log_err(-1, __func__, log_buffer);
+    }
+
+  return(connection);
+  } /* END establish_server_connection() */
+
 
 
 /**
@@ -883,7 +931,6 @@ void mom_checkpoint_check_periodic_timer(
  * @returns PBSE_NONE if no error
  */
 
-#define MAX_CONN_RETRY 3
 
 int blcr_checkpoint_job(
 
@@ -1078,43 +1125,46 @@ int blcr_checkpoint_job(
         }
       }
 
-    set_attr(&attrib, ATTR_comment, err_buf);
-
-    err = pbs_alterjob_err(conn, pjob->ji_qs.ji_jobid, attrib, NULL, &local_errno);
-
-    if (err != 0)
+    if (conn >= 0)
       {
-      sprintf(buf, "pbs_alterjob requested on job %s failed (%d-%s)\n",
-          pjob->ji_qs.ji_jobid, err, pbs_strerror(err));
-      log_err(-1, __func__, buf);
-      if (err == PBSE_UNKJOBID)
+      set_attr(&attrib, ATTR_comment, err_buf);
+      
+      err = pbs_alterjob_err(conn, pjob->ji_qs.ji_jobid, attrib, NULL, &local_errno);
+
+      if (err != 0)
         {
-        /* TODO: GB - can the job exit while waiting for the checkpoint
-            script to exit?? call log_err */
-        pbs_disconnect(conn);
-        goto done;
+        sprintf(buf, "pbs_alterjob requested on job %s failed (%d-%s)\n",
+            pjob->ji_qs.ji_jobid, err, pbs_strerror(err));
+        log_err(-1, __func__, buf);
+        if (err == PBSE_UNKJOBID)
+          {
+          /* TODO: GB - can the job exit while waiting for the checkpoint
+              script to exit?? call log_err */
+          pbs_disconnect(conn);
+          goto done;
+          }
         }
-      }
 
-    if (abort != 0)
-      {
-      /*
-       * we need to tell the server to release the hold (abort is non-zero
-       * which means we are trying to hold the job)
-       */
+      if (abort != 0)
+        {
+        /*
+         * we need to tell the server to release the hold (abort is non-zero
+         * which means we are trying to hold the job)
+         */
 
 
-      /*
-       * send release job request, the job will still be running,
-       * so it shouldn't have any holds set so we will send "uos"
-       * to clear all holds
-       */
-      pbs_rlsjob_err(conn, pjob->ji_qs.ji_jobid, (char *)"uos", NULL, &local_errno);
+        /*
+         * send release job request, the job will still be running,
+         * so it shouldn't have any holds set so we will send "uos"
+         * to clear all holds
+         */
+        pbs_rlsjob_err(conn, pjob->ji_qs.ji_jobid, (char *)"uos", NULL, &local_errno);
 
-      } /* END if (abort != 0) */
+        } /* END if (abort != 0) */
 
 
-    pbs_disconnect(conn);
+      pbs_disconnect(conn);
+      }
 
     } /* END if (rc != 0) */
   else
@@ -1144,59 +1194,62 @@ int blcr_checkpoint_job(
         }
       }
 
-    sprintf(timestr,"%ld",
-        (long)pjob->ji_wattr[JOB_ATR_checkpoint_time].at_val.at_long);
-    epoch = (time_t)pjob->ji_wattr[JOB_ATR_checkpoint_time].at_val.at_long;
-
-    sprintf(err_buf,"Job %s was checkpointed and %s to %s/%s at %s",
-      pjob->ji_qs.ji_jobid,
-      (request_type == PBS_BATCH_HoldJob) ? "terminated" : "continued",
-      namebuf,
-      pjob->ji_wattr[JOB_ATR_checkpoint_name].at_val.at_str,
-      ctime(&epoch));
-
-    set_attr(&attrib, ATTR_comment, err_buf);
-    set_attr(&attrib, ATTR_checkpoint_name,
-        pjob->ji_wattr[JOB_ATR_checkpoint_name].at_val.at_str);
-    set_attr(&attrib, ATTR_checkpoint_time, timestr);
-
-    err = pbs_alterjob_err(conn, 
-        pjob->ji_qs.ji_jobid, attrib,
-        (request_type == PBS_BATCH_HoldJob) ? (char *)CHECKPOINTHOLD : (char *)CHECKPOINTCONT,
-        &local_errno);
-
-    if (err != 0)
+    if (conn >= 0)
       {
-      sprintf(buf, "pbs_alterjob requested on job %s failed (%d-%s)\n",
-          pjob->ji_qs.ji_jobid, err, pbs_strerror(err));
-      log_err(-1, __func__, buf);
-      if (err == PBSE_UNKJOBID)
-        {
-        /* TODO: GB - can the job exit while waiting for the checkpoint
-            script to exit?? call log_err */
-        pbs_disconnect(conn);
-
-        /*
-         * If we get an unknown jobid after succesfully doing a non-hold
-         * checkpoint, then it is most likely the result of a periodic
-         * checkpoint for a job that had a qdel -p done, so we get rid of
-         * any local checkpoint / restart files
-         */
+      sprintf(timestr,"%ld",
+          (long)pjob->ji_wattr[JOB_ATR_checkpoint_time].at_val.at_long);
+      epoch = (time_t)pjob->ji_wattr[JOB_ATR_checkpoint_time].at_val.at_long;
 
-        if (request_type == 0)
+      sprintf(err_buf,"Job %s was checkpointed and %s to %s/%s at %s",
+        pjob->ji_qs.ji_jobid,
+        (request_type == PBS_BATCH_HoldJob) ? "terminated" : "continued",
+        namebuf,
+        pjob->ji_wattr[JOB_ATR_checkpoint_name].at_val.at_str,
+        ctime(&epoch));
+
+      set_attr(&attrib, ATTR_comment, err_buf);
+      set_attr(&attrib, ATTR_checkpoint_name,
+          pjob->ji_wattr[JOB_ATR_checkpoint_name].at_val.at_str);
+      set_attr(&attrib, ATTR_checkpoint_time, timestr);
+
+      err = pbs_alterjob_err(conn, 
+          pjob->ji_qs.ji_jobid, attrib,
+          (request_type == PBS_BATCH_HoldJob) ? (char *)CHECKPOINTHOLD : (char *)CHECKPOINTCONT,
+          &local_errno);
+
+      if (err != 0)
+        {
+        sprintf(buf, "pbs_alterjob requested on job %s failed (%d-%s)\n",
+            pjob->ji_qs.ji_jobid, err, pbs_strerror(err));
+        log_err(-1, __func__, buf);
+        if (err == PBSE_UNKJOBID)
           {
-          delete_blcr_checkpoint_files(pjob);
+          /* TODO: GB - can the job exit while waiting for the checkpoint
+              script to exit?? call log_err */
+          pbs_disconnect(conn);
+
+          /*
+           * If we get an unknown jobid after succesfully doing a non-hold
+           * checkpoint, then it is most likely the result of a periodic
+           * checkpoint for a job that had a qdel -p done, so we get rid of
+           * any local checkpoint / restart files
+           */
+
+          if (request_type == 0)
+            {
+            delete_blcr_checkpoint_files(pjob);
+            }
+          goto done;
           }
-        goto done;
         }
-      }
 
-    pbs_disconnect(conn);
+      pbs_disconnect(conn);
 
-    if (rc == 0)
-      {
-      /* Normally, this is an empty routine and does nothing. */
-      rc = site_mom_postchk(pjob,abort);
+      if (rc == 0)
+        {
+        /* Normally, this is an empty routine and does nothing. */
+        rc = site_mom_postchk(pjob,abort);
+        }
       }
     }
 
diff --git a/src/resmom/test/checkpoint/scaffolding.c b/src/resmom/test/checkpoint/scaffolding.c
index 5207e1439..2e661d578 100644
--- a/src/resmom/test/checkpoint/scaffolding.c
+++ b/src/resmom/test/checkpoint/scaffolding.c
@@ -24,7 +24,7 @@ resource_def *svr_resc_def; /* resc_def_all.c */
 char *path_spool; /* mom_main.c */
 int pbs_rm_port; /* mom_main.c */
 int LOGLEVEL = 7; /* force logging code to be exercised as tests run */ /* mom_main.c/pbsd_main.c */
-
+bool connect_fail;
 
 int job_save(job *pjob, int updatetype, int mom_port)
  {
@@ -46,8 +46,10 @@ task *pbs_task_create(job *pjob, tm_task_id taskid)
 
 int pbs_connect(char *server_name_ptr)
  {
- fprintf(stderr, "The call to pbs_connect needs to be mocked!!\n");
- exit(1);
+ if (connect_fail == true)
+   return(-1);
+ else
+   return(1);
  }
 
 int pbs_disconnect(int connect)
diff --git a/src/resmom/test/checkpoint/test_checkpoint.c b/src/resmom/test/checkpoint/test_checkpoint.c
index 6f4055d1b..56655e1f5 100644
--- a/src/resmom/test/checkpoint/test_checkpoint.c
+++ b/src/resmom/test/checkpoint/test_checkpoint.c
@@ -1,15 +1,24 @@
 #include "license_pbs.h" /* See here for the software license */
-#include "checkpoint.h"
-#include "test_checkpoint.h"
 #include <stdlib.h>
 #include <stdio.h>
 
+#include "checkpoint.h"
+#include "test_checkpoint.h"
+#include "pbs_job.h"
 
 #include "pbs_error.h"
 
-START_TEST(test_one)
+int establish_server_connection(job *pjob);
+
+extern bool connect_fail;
+
+START_TEST(establish_server_connection_test)
   {
+  job pjob;
+
+  memset(&pjob, 0, sizeof(pjob));
 
+  fail_unless(establish_server_connection(pjob) == -1);
 
   }
 END_TEST
@@ -24,8 +33,8 @@ END_TEST
 Suite *checkpoint_suite(void)
   {
   Suite *s = suite_create("checkpoint_suite methods");
-  TCase *tc_core = tcase_create("test_one");
-  tcase_add_test(tc_core, test_one);
+  TCase *tc_core = tcase_create("establish_server_connection_test");
+  tcase_add_test(tc_core, establish_server_connection_test);
   suite_add_tcase(s, tc_core);
 
   tc_core = tcase_create("test_two");

