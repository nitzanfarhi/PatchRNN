commit 0096c5bf1d4477db0f89602d41b3a2548d9f7818
Author: pancake <pancake@nopcode.org>
Date:   Sun Aug 30 23:34:21 2015 +0200

    Fix null deref issues in anal reflines

diff --git a/libr/anal/reflines.c b/libr/anal/reflines.c
index e36201a8f..1fa617394 100644
--- a/libr/anal/reflines.c
+++ b/libr/anal/reflines.c
@@ -1,11 +1,9 @@
-/* radare - LGPL - Copyright 2009-2014 - pancake, nibble */
+/* radare - LGPL - Copyright 2009-2015 - pancake, nibble */
 
 #include <r_core.h>
 #include <r_util.h>
 #include <r_cons.h>
 
-
-
 static void free_refline_list (struct list_head *head){
 	struct list_head *pos, *n;
 	RAnalRefline *ref;
@@ -28,7 +26,7 @@ R_API struct r_anal_refline_t *r_anal_reflines_get(RAnal *anal,
 	int sz = 0, index = 0;
 	int count = 0;
 
-	list = R_NEW (RAnalRefline);
+	list = R_NEW0 (RAnalRefline);
 	if (!list) return NULL;
 
 	INIT_LIST_HEAD (&(list->list));
@@ -70,7 +68,7 @@ R_API struct r_anal_refline_t *r_anal_reflines_get(RAnal *anal,
 					goto __next;
 				if (op.jump == 0LL)
 					goto __next;
-				list2 = R_NEW (RAnalRefline);
+				list2 = R_NEW0 (RAnalRefline);
 				if (!list2) {
 					eprintf ("not enough memory in %s - %d", __FILE__, __LINE__);
 					free_refline_list (&(list->list));
@@ -145,7 +143,7 @@ R_API struct r_anal_refline_t *r_anal_reflines_fcn_get( struct r_anal_t *anal, R
 		control_type &= R_ANAL_BB_TYPE_SWITCH | R_ANAL_BB_TYPE_JMP | R_ANAL_BB_TYPE_COND | R_ANAL_BB_TYPE_CALL;
 
 		// handle call
-		if ( (control_type & R_ANAL_BB_TYPE_CALL) == R_ANAL_BB_TYPE_CALL &&  !linescall) {
+		if ( (control_type & R_ANAL_BB_TYPE_CALL) == R_ANAL_BB_TYPE_CALL && !linescall) {
 			continue;
 		}
 
@@ -182,7 +180,7 @@ R_API struct r_anal_refline_t *r_anal_reflines_fcn_get( struct r_anal_t *anal, R
 		}
 
 		// XXX - Todo test handle swith op
-		if ( control_type & R_ANAL_BB_TYPE_SWITCH) {
+		if (control_type & R_ANAL_BB_TYPE_SWITCH) {
 			if (bb->switch_op) {
 				RAnalCaseOp *caseop;
 				RListIter *iter;
@@ -190,7 +188,7 @@ R_API struct r_anal_refline_t *r_anal_reflines_fcn_get( struct r_anal_t *anal, R
 					if (caseop) {
 						if (!linesout)// && (op.jump > opc+len || op.jump < pc))
 							continue;
-						list2 = R_NEW (RAnalRefline);
+						list2 = R_NEW0 (RAnalRefline);
 						if (!list2){
 							eprintf ("not enough memory in %s - %d", __FILE__, __LINE__);
 							free_refline_list (&(list->list));
diff --git a/libr/core/disasm.c b/libr/core/disasm.c
index 3c00b4382..fea74651d 100644
--- a/libr/core/disasm.c
+++ b/libr/core/disasm.c
@@ -589,7 +589,10 @@ R_API RAnalHint *r_core_hint_begin (RCore *core, RAnalHint* hint, ut64 at) {
 
 // this is another random hack for reflines.. crappy stuff
 static char *filter_refline2(RCore *core, const char *str) {
-	char *p, *s = strdup (str);
+	char *p, *s;
+	if (!core || !str)
+		return NULL;
+	s = strdup (str);
 	for (p=s; *p; p++) {
 		switch (*p) {
 		case '`': *p = '|'; break;
@@ -630,8 +633,10 @@ static char *filter_refline2(RCore *core, const char *str) {
 }
 
 static char *filter_refline(RCore *core, const char *str) {
-	char *p = strdup (str);
-
+	char *p;
+	if (!core || !str)
+		return NULL;
+	p = strdup (str);
 	p = r_str_replace (p, "`",
 		core->cons->vline[LINE_VERT], 1); // "`" -> "|"
 	p = r_str_replace (p,
@@ -1091,10 +1096,14 @@ static void handle_update_ref_lines (RCore *core, RDisasmState *ds) {
 		ds->line = r_anal_reflines_str (core, ds->at, ds->linesopts);
 		ds->refline = filter_refline (core, ds->line);
 		ds->refline2 = filter_refline2 (core, ds->refline);
-		if (strchr (ds->line, '<'))
-			ds->indent_level++;
-		if (strchr (ds->line, '>'))
-			ds->indent_level--;
+		if (ds->line) {
+			if (strchr (ds->line, '<'))
+				ds->indent_level++;
+			if (strchr (ds->line, '>'))
+				ds->indent_level--;
+		} else {
+			ds->indent_level = 0;
+		}
 	} else {
 		free (ds->line);
 		free (ds->refline);

