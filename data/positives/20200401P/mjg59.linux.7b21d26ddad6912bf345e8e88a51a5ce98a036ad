commit 7b21d26ddad6912bf345e8e88a51a5ce98a036ad
Author: Ralph Campbell <ralph.campbell@qlogic.com>
Date:   Thu Mar 15 14:44:50 2007 -0700

    IB/ipath: NMI cpu lockup if local loopback used
    
    If a post send is done in loopback and there is no receive queue
    entry, the sending QP is put on a timeout list for a while so the
    receiver has a chance to post a receive buffer. If the another post
    send is done, the code incorrectly tried to put the QP on the timeout
    list again an corrupted the timeout list. This eventually leads to a
    spin lock deadlock NMI due to the timer function looping forever with
    the lock held.
    
    Signed-off-by: Bryan O'Sullivan <bryan.osullivan@qlogic.com>
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/hw/ipath/ipath_ruc.c b/drivers/infiniband/hw/ipath/ipath_ruc.c
index 146db8516997..cda84933bb43 100644
--- a/drivers/infiniband/hw/ipath/ipath_ruc.c
+++ b/drivers/infiniband/hw/ipath/ipath_ruc.c
@@ -265,7 +265,8 @@ static void ipath_ruc_loopback(struct ipath_qp *sqp)
 again:
 	spin_lock_irqsave(&sqp->s_lock, flags);
 
-	if (!(ib_ipath_state_ops[sqp->state] & IPATH_PROCESS_SEND_OK)) {
+	if (!(ib_ipath_state_ops[sqp->state] & IPATH_PROCESS_SEND_OK) ||
+	    qp->s_rnr_timeout) {
 		spin_unlock_irqrestore(&sqp->s_lock, flags);
 		goto done;
 	}

