commit 41bcdd168a3ef758b6c738557ef81b0808e96fe0
Author: aland <aland>
Date:   Mon Sep 29 15:19:59 2003 +0000

            Increased the size of the temporary 'send packet' buffer, to allow
            RADIUS packets to "overflow" it by one attribute.  This makes the
            logic to catch the overflow significantly simpler.
    
            i.e. It's easier to post-facto catch an error, than try to figure
            out before hand what the code will do.
    
            Once the packet has "overflowed" the 4k boundary, we log an error
            message, and return an error, without sending the packet.
    
            Bug found by Nils-Henner Krueger

diff --git a/src/lib/radius.c b/src/lib/radius.c
index 35b14b1ae..37fd4d6a4 100644
--- a/src/lib/radius.c
+++ b/src/lib/radius.c
@@ -184,7 +184,13 @@ int rad_send(RADIUS_PACKET *packet, const RADIUS_PACKET *original,
 		  u_short		total_length;
 		  int			len, allowed;
 		  int			msg_auth_offset = 0;
-		  uint8_t		data[MAX_PACKET_LEN];
+
+		  /*
+		   *	For simplicity in the following logic, we allow
+		   *	the attributes to "overflow" the 4k maximum
+		   *	RADIUS packet size, by one attribute.
+		   */
+		  uint8_t		data[MAX_PACKET_LEN + 256];
 		  
 		  /*
 		   *	Use memory on the stack, until we know how
@@ -228,6 +234,19 @@ int rad_send(RADIUS_PACKET *packet, const RADIUS_PACKET *original,
 				  continue;
 			  }
 
+			  /*
+			   *	Check that the packet is no more than
+			   *	4k in size, AFTER over-flowing the 4k
+			   *	boundary.  Note that the 'data'
+			   *	buffer, above, is one attribute longer
+			   *	than necessary, in order to permit
+			   *	this overflow.
+			   */
+			  if (total_length > MAX_PACKET_LEN) {
+				  librad_log("ERROR: Too many attributes for packet, result is larger than RFC maximum of 4k");
+				  return -1;
+			  }
+
 			  /*
 			   *	Do stuff for Message-Authenticator
 			   */
@@ -580,7 +599,8 @@ int rad_send(RADIUS_PACKET *packet, const RADIUS_PACKET *original,
 			  case PW_AUTHENTICATION_REJECT:
 			  case PW_ACCESS_CHALLENGE:
 			    if (original) {
-			      memcpy(hdr->vector, original->vector, AUTH_VECTOR_LEN);
+				    memcpy(hdr->vector, original->vector,
+					   AUTH_VECTOR_LEN);
 			    }
 			    break;
 			  }

