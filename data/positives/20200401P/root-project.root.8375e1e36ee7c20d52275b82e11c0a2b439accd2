commit 8375e1e36ee7c20d52275b82e11c0a2b439accd2
Author: Lorenzo Moneta <Lorenzo.Moneta@cern.ch>
Date:   Tue Mar 1 16:53:28 2016 +0100

    Apply patch from Bastian Beischer to avoid creating and destroying GSL objects. This fixes ROOT-8029

diff --git a/math/mathmore/src/GSLMultiFit.h b/math/mathmore/src/GSLMultiFit.h
index 5b5a887efb..68fccc3e5c 100644
--- a/math/mathmore/src/GSLMultiFit.h
+++ b/math/mathmore/src/GSLMultiFit.h
@@ -60,7 +60,11 @@ public:
    GSLMultiFit (const gsl_multifit_fdfsolver_type * type = 0) :
       fSolver(0),
       fVec(0),
+      fTmp(0),
       fCov(0),
+#if GSL_MAJOR_VERSION > 1
+      fJac(0),
+#endif
       fType(type)
    {
       if (fType == 0) fType = gsl_multifit_fdfsolver_lmsder; // default value
@@ -72,7 +76,11 @@ public:
    ~GSLMultiFit ()  {
       if (fSolver) gsl_multifit_fdfsolver_free(fSolver);
       if (fVec != 0) gsl_vector_free(fVec);
+      if (fTmp != 0) gsl_vector_free(fTmp);
       if (fCov != 0) gsl_matrix_free(fCov);
+#if GSL_MAJOR_VERSION > 1
+      if (fJac != 0) gsl_matrix_free(fJac);
+#endif
    }
 
 private:
@@ -98,6 +106,16 @@ public:
    void CreateSolver(unsigned int npoints, unsigned int npar) {
       if (fSolver) gsl_multifit_fdfsolver_free(fSolver);
       fSolver = gsl_multifit_fdfsolver_alloc(fType, npoints, npar);
+      if (fVec != 0) gsl_vector_free(fVec);
+      fVec = gsl_vector_alloc( npar );
+      if (fTmp != 0) gsl_vector_free(fTmp);
+      fTmp = gsl_vector_alloc( npar );
+      if (fCov != 0) gsl_matrix_free(fCov);
+      fCov = gsl_matrix_alloc( npar, npar );
+#if GSL_MAJOR_VERSION > 1
+      if (fJac != 0) gsl_matrix_free(fJac);
+      fJac = gsl_matrix_alloc( npoints, npar );
+#endif
    }
 
    /// set the solver parameters
@@ -116,11 +134,18 @@ public:
       fFunc.SetFunction(funcVec, npts, npar);
       // create solver object
       CreateSolver( npts, npar );
+      assert(fSolver != 0);
       // set initial values
-      if (fVec != 0) gsl_vector_free(fVec);
-      fVec = gsl_vector_alloc( npar );
+      assert(fVec != 0);
       std::copy(x,x+npar, fVec->data);
-      assert(fSolver != 0);
+      assert(fTmp != 0);
+      gsl_vector_set_zero(fTmp);
+      assert(fCov != 0);
+      gsl_matrix_set_zero(fCov);
+#if GSL_MAJOR_VERSION > 1
+      assert(fJac != 0);
+      gsl_matrix_set_zero(fJac);
+#endif
       return gsl_multifit_fdfsolver_set(fSolver, fFunc.GetFunc(), fVec);
    }
 
@@ -155,15 +180,10 @@ public:
    /// return covariance matrix of the parameters
    const double * CovarMatrix() const {
       if (fSolver == 0) return 0;
-      if (fCov != 0) gsl_matrix_free(fCov);
-      unsigned int npar = fSolver->fdf->p;
-      fCov = gsl_matrix_alloc( npar, npar );
       static double kEpsrel = 0.0001;
 #if GSL_MAJOR_VERSION > 1
-      gsl_matrix* J = gsl_matrix_alloc(npar,npar);
-      gsl_multifit_fdfsolver_jac (fSolver, J);
-      int ret = gsl_multifit_covar(J, kEpsrel, fCov);
-      gsl_matrix_free(J);
+      gsl_multifit_fdfsolver_jac (fSolver, fJac);
+      int ret = gsl_multifit_covar(fJac, kEpsrel, fCov);
 #else
       int ret = gsl_multifit_covar(fSolver->J, kEpsrel, fCov);
 #endif
@@ -193,10 +213,9 @@ public:
       if (g == 0) return edm;
       const double * c = CovarMatrix();
       if (c == 0) return edm;
-      gsl_vector * tmp = gsl_vector_alloc( fSolver->fdf->p );
-      int status =   gsl_blas_dgemv(CblasNoTrans, 1.0, fCov, fVec, 0.,tmp);
-      if (status == 0) status |= gsl_blas_ddot(fVec, tmp, &edm);
-      gsl_vector_free(tmp);
+      if (fTmp == 0) return edm;
+      int status =   gsl_blas_dgemv(CblasNoTrans, 1.0, fCov, fVec, 0.,fTmp);
+      if (status == 0) status |= gsl_blas_ddot(fVec, fTmp, &edm);
       if (status != 0) return -1;
       // need to divide by 2 ??
       return 0.5*edm;
@@ -210,7 +229,11 @@ private:
    gsl_multifit_fdfsolver * fSolver;
    // cached vector to avoid re-allocating every time a new one
    mutable gsl_vector * fVec;
+   mutable gsl_vector * fTmp;
    mutable gsl_matrix * fCov;
+#if GSL_MAJOR_VERSION > 1
+   mutable gsl_matrix * fJac;
+#endif
    const gsl_multifit_fdfsolver_type * fType;
 
 };

