commit 248736c2a57206388c86f8cdd3392ee986e84f9f
Author: Eric Sesterhenn <snakebyte@gmx.de>
Date:   Sat Oct 18 20:28:02 2008 -0700

    hfsplus: fix possible deadlock when handling corrupted extents
    
    A corrupted extent for the extent file itself may try to get an impossible
    extent, causing a deadlock if I see it correctly.
    
    Check the inode number after the first_blocks checks and fail if it's the
    extent file, as according to the spec the extent file should have no
    extent for itself.
    
    Signed-off-by: Eric Sesterhenn <snakebyte@gmx.de>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/hfsplus/extents.c b/fs/hfsplus/extents.c
index fec8f61227ff..0022eec63cda 100644
--- a/fs/hfsplus/extents.c
+++ b/fs/hfsplus/extents.c
@@ -199,6 +199,9 @@ int hfsplus_get_block(struct inode *inode, sector_t iblock,
 		goto done;
 	}
 
+	if (inode->i_ino == HFSPLUS_EXT_CNID)
+		return -EIO;
+
 	mutex_lock(&HFSPLUS_I(inode).extents_lock);
 	res = hfsplus_ext_read_extent(inode, ablock);
 	if (!res) {

