commit b251319f2ae1298bff583773d78fedb5f87d7e84
Author: Andreas Ericsson <ae@op5.se>
Date:   Thu Dec 8 12:12:02 2011 +0000

    core: Fix passive check result freshness test after restart
    
    The last version of the code to avoid sending notifications about stale
    checks on start confused event_start and last_check - it would trigger
    whenever nagios took less than 60 seconds to start, and it had been
    turned off for some time before, and would override the last check
    timestamp with the nagios start time.
    
    Signed-off-by: Robin Sonefors <robin.sonefors@op5.com>
    
    git-svn-id: https://nagios.svn.sourceforge.net/svnroot/nagios/nagioscore/trunk@1848 5f96b256-904b-4d8d-8c98-d829582c6739

diff --git a/base/checks.c b/base/checks.c
index 21d5123a..2ee80e6c 100644
--- a/base/checks.c
+++ b/base/checks.c
@@ -2093,15 +2093,15 @@ int is_service_result_fresh(service *temp_service, time_t current_time, int log_
 	 * If the check was last done passively, we assume it's going
 	 * to continue that way and we need to handle the fact that
 	 * Nagios might have been shut off for quite a long time. If so,
-	 * we mustn't spam freshness notifications but use program_start_time
+	 * we mustn't spam freshness notifications but use event_start
 	 * instead of last_check to determine freshness expiration time.
 	 * The threshold for "long time" is determined as 61.8% of the normal
 	 * freshness threshold based on vast heuristical research (ie, "some
 	 * guy once told me the golden ratio is good for loads of stuff").
 	 */
 	if (temp_service->check_type == SERVICE_CHECK_PASSIVE) {
-		if (event_start < program_start + 60 &&
-			event_start - last_program_stop < (freshness_threshold * 0.618))
+		if (temp_service->last_check < event_start &&
+			event_start - last_program_stop < freshness_threshold * 0.618)
 		{
 			expiration_time = event_start + freshness_threshold;
 		}
@@ -2521,15 +2521,15 @@ int is_host_result_fresh(host *temp_host, time_t current_time, int log_this) {
 	 * If the check was last done passively, we assume it's going
 	 * to continue that way and we need to handle the fact that
 	 * Nagios might have been shut off for quite a long time. If so,
-	 * we mustn't spam freshness notifications but use program_start_time
+	 * we mustn't spam freshness notifications but use event_start
 	 * instead of last_check to determine freshness expiration time.
 	 * The threshold for "long time" is determined as 61.8% of the normal
 	 * freshness threshold based on vast heuristical research (ie, "some
 	 * guy once told me the golden ratio is good for loads of stuff").
 	 */
 	if (temp_host->check_type == HOST_CHECK_PASSIVE) {
-		if (event_start < program_start + 60 &&
-			event_start - last_program_stop < (freshness_threshold * 0.618))
+		if (temp_host->last_check < event_start &&
+			event_start - last_program_stop > freshness_threshold * 0.618)
 		{
 			expiration_time = event_start + freshness_threshold;
 		}

