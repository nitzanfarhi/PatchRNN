commit 70c57dcd606f218b507372a05e633b23351258f0
Author: Darrick J. Wong <darrick.wong@oracle.com>
Date:   Wed Jan 24 20:48:53 2018 -0800

    xfs: skip CoW writes past EOF when writeback races with truncate
    
    Every so often we blow the ASSERT(type != XFS_IO_COW) in xfs_map_blocks
    when running fsstress, as we do in generic/269.  The cause of this is
    writeback racing with truncate -- writeback doesn't take the iolock, so
    truncate can sneak in to decrease i_size and truncate page cache while
    writeback is gathering buffer heads to schedule writeout.
    
    If we hit this race on a block that has a CoW mapping, we'll get a valid
    imap from the CoW fork but the reduced i_size trims the mapping to zero
    length (which makes it invalid), so we call xfs_map_blocks to try again.
    This doesn't do much anyway, since any mapping we get out of that will
    also be invalid, so we might as well skip the assert and just stop.
    
    Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>

diff --git a/fs/xfs/xfs_aops.c b/fs/xfs/xfs_aops.c
index 2e094c76bd45..9c6a830da0ee 100644
--- a/fs/xfs/xfs_aops.c
+++ b/fs/xfs/xfs_aops.c
@@ -390,6 +390,19 @@ xfs_map_blocks(
 	if (XFS_FORCED_SHUTDOWN(mp))
 		return -EIO;
 
+	/*
+	 * Truncate can race with writeback since writeback doesn't take the
+	 * iolock and truncate decreases the file size before it starts
+	 * truncating the pages between new_size and old_size.  Therefore, we
+	 * can end up in the situation where writeback gets a CoW fork mapping
+	 * but the truncate makes the mapping invalid and we end up in here
+	 * trying to get a new mapping.  Bail out here so that we simply never
+	 * get a valid mapping and so we drop the write altogether.  The page
+	 * truncation will kill the contents anyway.
+	 */
+	if (type == XFS_IO_COW && offset > i_size_read(inode))
+		return 0;
+
 	ASSERT(type != XFS_IO_COW);
 	if (type == XFS_IO_UNWRITTEN)
 		bmapi_flags |= XFS_BMAPI_IGSTATE;

