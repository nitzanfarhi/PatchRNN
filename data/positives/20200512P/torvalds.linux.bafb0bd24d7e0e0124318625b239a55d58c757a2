commit bafb0bd24d7e0e0124318625b239a55d58c757a2
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Aug 25 15:12:05 2011 +0200

    TTY: serial, move locking in uart_close
    
    So now, when we handle CLOSING flag, there is no point to hold
    port->mutex over the start of uart_close.
    
    Yes, there are still several things to reason about:
    * port->count etc is and always was protected by a spinlock
    * ->stop_rx is protected by a spinlock. Otherwise it would
      race with interrupts.
    * uart_wait_until_sent -- that one is already called without
      port->mutex from set_termios and tty_set_ldisc. Should anything
      be protected there, it would be tx_empty. And by a spinlock.
      8250 does this internally...
    
    This step is needed to fix system stalls. To not create an AB-BA lock
    dependency (see next patches).
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index 849bd0d06b2c..0464360781fe 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -1253,7 +1253,6 @@ static void uart_close(struct tty_struct *tty, struct file *filp)
 
 	pr_debug("uart_close(%d) called\n", uport->line);
 
-	mutex_lock(&port->mutex);
 	spin_lock_irqsave(&port->lock, flags);
 
 	if (tty_hung_up_p(filp)) {
@@ -1312,6 +1311,7 @@ static void uart_close(struct tty_struct *tty, struct file *filp)
 		uart_wait_until_sent(tty, uport->timeout);
 	}
 
+	mutex_lock(&port->mutex);
 	uart_shutdown(tty, state);
 	uart_flush_buffer(tty);
 

