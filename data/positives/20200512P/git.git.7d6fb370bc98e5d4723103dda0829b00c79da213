commit 7d6fb370bc98e5d4723103dda0829b00c79da213
Author: Eric Wong <normalperson@yhbt.net>
Date:   Sat Dec 24 04:12:43 2005 -0800

    short circuit out of a few places where we would allocate zero bytes
    
    dietlibc versions of malloc, calloc and realloc all return NULL if
    they're told to allocate 0 bytes, causes the x* wrappers to die().
    
    There are several more places where these calls could end up asking
    for 0 bytes, too...
    
    Maybe simply not die()-ing in the x* wrappers if 0/NULL is returned
    when the requested size is zero is a safer and easier way to go.
    
    Signed-off-by: Eric Wong <normalperson@yhbt.net>
    Signed-off-by: Junio C Hamano <junkio@cox.net>

diff --git a/commit.c b/commit.c
index e867b86e6..edd4dedcd 100644
--- a/commit.c
+++ b/commit.c
@@ -560,6 +560,9 @@ void sort_in_topological_order(struct commit_list ** list)
 		next = next->next;
 		count++;
 	}
+	
+	if (!count)
+		return;
 	/* allocate an array to help sort the list */
 	nodes = xcalloc(count, sizeof(*nodes));
 	/* link the list to the array */
diff --git a/diffcore-rename.c b/diffcore-rename.c
index dba965c0b..39d9126cb 100644
--- a/diffcore-rename.c
+++ b/diffcore-rename.c
@@ -282,7 +282,7 @@ void diffcore_rename(struct diff_options *options)
 		else if (detect_rename == DIFF_DETECT_COPY)
 			register_rename_src(p->one, 1);
 	}
-	if (rename_dst_nr == 0 ||
+	if (rename_dst_nr == 0 || rename_src_nr == 0 ||
 	    (0 < rename_limit && rename_limit < rename_dst_nr))
 		goto cleanup; /* nothing to do */
 

