commit 7e5a5104c6af709a8d97d5f4711e7c917761d464
Author: Minchan Kim <minchan@kernel.org>
Date:   Wed Jan 30 11:41:39 2013 +0900

    zram: Fix deadlock bug in partial read/write
    
    Now zram allocates new page with GFP_KERNEL in zram I/O path
    if IO is partial. Unfortunately, It may cause deadlock with
    reclaim path like below.
    
    write_page from fs
    fs_lock
    allocation(GFP_KERNEL)
    reclaim
    pageout
                                    write_page from fs
                                    fs_lock <-- deadlock
    
    This patch fixes it by using GFP_NOIO.  In read path, we
    reorganize code flow so that kmap_atomic is called after the
    GFP_NOIO allocation.
    
    Cc: stable@vger.kernel.org
    Acked-by: Jerome Marchand <jmarchand@redhat.com>
    Acked-by: Nitin Gupta <ngupta@vflare.org>
    [ penberg@kernel.org: don't use GFP_ATOMIC ]
    Signed-off-by: Pekka Enberg <penberg@kernel.org>
    Signed-off-by: Minchan Kim <minchan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/zram/zram_drv.c b/drivers/staging/zram/zram_drv.c
index 941b7c62ea20..262265e4fa2e 100644
--- a/drivers/staging/zram/zram_drv.c
+++ b/drivers/staging/zram/zram_drv.c
@@ -217,11 +217,12 @@ static int zram_bvec_read(struct zram *zram, struct bio_vec *bvec,
 		return 0;
 	}
 
-	user_mem = kmap_atomic(page);
 	if (is_partial_io(bvec))
 		/* Use  a temporary buffer to decompress the page */
-		uncmem = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	else
+		uncmem = kmalloc(PAGE_SIZE, GFP_NOIO);
+
+	user_mem = kmap_atomic(page);
+	if (!is_partial_io(bvec))
 		uncmem = user_mem;
 
 	if (!uncmem) {
@@ -268,7 +269,7 @@ static int zram_bvec_write(struct zram *zram, struct bio_vec *bvec, u32 index,
 		 * This is a partial IO. We need to read the full page
 		 * before to write the changes.
 		 */
-		uncmem = kmalloc(PAGE_SIZE, GFP_KERNEL);
+		uncmem = kmalloc(PAGE_SIZE, GFP_NOIO);
 		if (!uncmem) {
 			pr_info("Error allocating temp memory!\n");
 			ret = -ENOMEM;

