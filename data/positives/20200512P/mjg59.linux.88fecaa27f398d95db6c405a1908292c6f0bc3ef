commit 88fecaa27f398d95db6c405a1908292c6f0bc3ef
Author: john stultz <johnstul@us.ibm.com>
Date:   Mon Jul 3 00:24:04 2006 -0700

    [PATCH] time initialisation fix
    
    We're not reay to take a timer interrupt until timekeeping_init() has run.
    But time_init() will start the time interrupt and if it is called with
    local interrupts enabled we'll immediately take an interrupt and die.
    
    Fix that by running timekeeping_init() prior to time_init().
    
    We don't know _why_ local interrupts got enabled on Jesse Brandeburg's
    machine.  That's a separate as-yet-unsolved problem.  THe patch adds a little
    bit of debugging to detect that.
    
    This whole requirement that local interrupts be held off during early boot
    keeps on biting us.
    
    Signed-off-by: John Stultz <johnstul@us.ibm.com>
    Cc: Jesse Brandeburg <jesse.brandeburg@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/init/main.c b/init/main.c
index b2f3b566790e..c8960b9df623 100644
--- a/init/main.c
+++ b/init/main.c
@@ -496,8 +496,8 @@ asmlinkage void __init start_kernel(void)
 	init_timers();
 	hrtimers_init();
 	softirq_init();
-	time_init();
 	timekeeping_init();
+	time_init();
 
 	/*
 	 * HACK ALERT! This is early. We're enabling the console before
@@ -508,6 +508,8 @@ asmlinkage void __init start_kernel(void)
 	if (panic_later)
 		panic(panic_later, panic_param);
 	profile_init();
+	if (!irqs_disabled())
+		printk("start_kernel(): bug: interrupts were enabled early\n");
 	local_irq_enable();
 #ifdef CONFIG_BLK_DEV_INITRD
 	if (initrd_start && !initrd_below_start_ok &&

