commit 5443bd2794c874d6a32c71b62120b011344ceaf1
Author: Danny Auble <da@schedmd.com>
Date:   Tue Apr 12 15:36:57 2016 -0700

    Various memory leak fixes.

diff --git a/src/plugins/mpi/pmi2/client.c b/src/plugins/mpi/pmi2/client.c
index 2d5ac7e9f1..0e3a1e660e 100644
--- a/src/plugins/mpi/pmi2/client.c
+++ b/src/plugins/mpi/pmi2/client.c
@@ -186,6 +186,7 @@ client_req_free(client_req_t *req)
 {
 	if (req) {
 		xfree(req->buf);
+		xfree(req->pairs);
 		xfree(req);
 	}
 }
diff --git a/src/plugins/mpi/pmi2/pmi2.c b/src/plugins/mpi/pmi2/pmi2.c
index 69061aaaa7..71ac79289e 100644
--- a/src/plugins/mpi/pmi2/pmi2.c
+++ b/src/plugins/mpi/pmi2/pmi2.c
@@ -252,6 +252,9 @@ _handle_ring(int fd, int lrank, client_req_t *req)
 
         rc = pmix_ring_in(ring_id, count, left, right);
 
+	xfree(left);
+	xfree(right);
+
         /* the repsonse is sent back to client from the pmix_ring_out call */
 
 	debug3("mpi/pmi2: out _handle_ring");
@@ -272,6 +275,8 @@ _handle_kvs_put(int fd, int lrank, client_req_t *req)
 
 	/* no need to add k-v to hash. just get it ready to be up-forward */
 	rc = temp_kvs_add(key, val);
+	xfree(key);
+	xfree(val);
 
 	resp = client_resp_new();
 	client_resp_append(resp, CMD_KEY"="KVSPUTRESP_CMD";" RC_KEY"=%d;", rc);
@@ -322,7 +327,7 @@ _handle_kvs_get(int fd, int lrank, client_req_t *req)
 {
 	int rc;
 	client_resp_t *resp;
-	char *key, *val;
+	char *key = NULL, *val;
 
 	debug3("mpi/pmi2: in _handle_kvs_get");
 
@@ -330,6 +335,7 @@ _handle_kvs_get(int fd, int lrank, client_req_t *req)
 	client_req_get_str(req, KEY_KEY, &key);
 
 	val = kvs_get(key);
+	xfree(key);
 
 	resp = client_resp_new();
 	if (val != NULL) {
@@ -352,7 +358,7 @@ _handle_info_getnodeattr(int fd, int lrank, client_req_t *req)
 {
 	int rc = 0;
 	client_resp_t *resp;
-	char *key, *val;
+	char *key = NULL, *val;
 	bool wait = false;
 
 	debug3("mpi/pmi2: in _handle_info_getnodeattr from lrank %d", lrank);
@@ -378,7 +384,7 @@ _handle_info_getnodeattr(int fd, int lrank, client_req_t *req)
 	} else {
 		rc = enqueue_nag_req(fd, lrank, key);
 	}
-
+	xfree(key);
 	debug3("mpi/pmi2: out _handle_info_getnodeattr");
 	return rc;
 }
@@ -398,8 +404,12 @@ _handle_info_putnodeattr(int fd, int lrank, client_req_t *req)
 
 	rc = node_attr_put(key, val);
 
+	xfree(key);
+	xfree(val);
+
 	resp = client_resp_new();
-	client_resp_append(resp, CMD_KEY"="PUTNODEATTRRESP_CMD";" RC_KEY"=%d;", rc);
+	client_resp_append(resp,
+			   CMD_KEY"="PUTNODEATTRRESP_CMD";" RC_KEY"=%d;", rc);
 	rc = client_resp_send(resp, fd);
 	client_resp_free(resp);
 
@@ -410,7 +420,7 @@ _handle_info_putnodeattr(int fd, int lrank, client_req_t *req)
 static int
 _handle_info_getjobattr(int fd, int lrank, client_req_t *req)
 {
-	char *key, *val;
+	char *key = NULL, *val;
 	client_resp_t *resp;
 	int rc;
 
@@ -419,11 +429,13 @@ _handle_info_getjobattr(int fd, int lrank, client_req_t *req)
 	client_req_get_str(req, KEY_KEY, &key);
 
 	val = job_attr_get(key);
+	xfree(key);
 
 	resp = client_resp_new();
 	client_resp_append(resp, CMD_KEY"="GETJOBATTRRESP_CMD";" RC_KEY"=0;");
 	if (val != NULL) {
-		client_resp_append(resp, FOUND_KEY"="TRUE_VAL";" VALUE_KEY"=%s;",
+		client_resp_append(resp,
+				   FOUND_KEY"="TRUE_VAL";" VALUE_KEY"=%s;",
 				   val);
 	} else {
 		client_resp_append(resp, FOUND_KEY"="FALSE_VAL";");
@@ -448,7 +460,7 @@ _handle_name_publish(int fd, int lrank, client_req_t *req)
 	client_req_parse_body(req);
 	client_req_get_str(req, NAME_KEY, &name);
 	client_req_get_str(req, PORT_KEY, &port);
-	
+
 	rc = name_publish_up(name, port);
 	xfree(name);
 	xfree(port);
@@ -474,7 +486,7 @@ _handle_name_unpublish(int fd, int lrank, client_req_t *req)
 
 	client_req_parse_body(req);
 	client_req_get_str(req, NAME_KEY, &name);
-	
+
 	rc = name_unpublish_up(name);
 	xfree(name);
 
diff --git a/src/slurmd/slurmstepd/slurmstepd_job.c b/src/slurmd/slurmstepd/slurmstepd_job.c
index 8267d004af..531b57527a 100644
--- a/src/slurmd/slurmstepd/slurmstepd_job.c
+++ b/src/slurmd/slurmstepd/slurmstepd_job.c
@@ -317,6 +317,11 @@ stepd_step_rec_create(launch_tasks_request_msg_t *msg, uint16_t protocol_version
 
 	job->eio     = eio_handle_create(0);
 	job->sruns   = list_create((ListDelF) _srun_info_destructor);
+
+	/* Based on my testing the next 3 lists here could use the
+	 * eio_obj_destroy, but if you do you can get an invalid read.  Since
+	 * these stay until the end of the job it isn't that big of a deal.
+	 */
 	job->clients = list_create(NULL); /* FIXME! Needs destructor */
 	job->stdout_eio_objs = list_create(NULL); /* FIXME! Needs destructor */
 	job->stderr_eio_objs = list_create(NULL); /* FIXME! Needs destructor */
@@ -576,7 +581,14 @@ stepd_step_rec_destroy(stepd_step_rec_t *job)
 
 	for (i = 0; i < job->node_tasks; i++)
 		_task_info_destroy(job->task[i], job->multi_prog);
+	eio_handle_destroy(job->eio);
 	FREE_NULL_LIST(job->sruns);
+	FREE_NULL_LIST(job->clients);
+	FREE_NULL_LIST(job->stdout_eio_objs);
+	FREE_NULL_LIST(job->stderr_eio_objs);
+	FREE_NULL_LIST(job->free_incoming);
+	FREE_NULL_LIST(job->free_outgoing);
+	FREE_NULL_LIST(job->outgoing_cache);
 	xfree(job->envtp);
 	xfree(job->node_name);
 	mpmd_free(job);

