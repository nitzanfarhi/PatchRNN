commit 49106c6568c0c3d1a95bf02feb8e02eabc453914
Author: Eyal Birger <eyal.birger@gmail.com>
Date:   Mon Aug 25 22:22:15 2014 +0300

    Adapt vcprintf() to treat hex input (%x/%Lx) as unsigned so that jsiConsolePrintf("%x\n", 0xffffffff) would print an expected "ffffffff"

diff --git a/src/jsutils.c b/src/jsutils.c
index a3db66e2..58fb27ac 100644
--- a/src/jsutils.c
+++ b/src/jsutils.c
@@ -386,10 +386,10 @@ char itoch(int val) {
   return (char)('a'+val-10);
 }
 
-void itostr(JsVarInt vals,char *str,unsigned int base) {
+void itostr_extra(JsVarInt vals,char *str,bool signedVal, unsigned int base) {
   JsVarIntUnsigned val;
   // handle negative numbers
-  if (vals<0) {
+  if (signedVal && vals<0) {
     *(str++)='-';
     val = (JsVarIntUnsigned)(-vals);
   } else {
@@ -508,11 +508,12 @@ void vcbprintf(vcbprintf_callback user_callback, void *user_data, const char *fm
         break;
       }
       case 'd': itostr(va_arg(argp, int), buf, 10); user_callback(buf,user_data); break;
-      case 'x': itostr(va_arg(argp, int), buf, 16); user_callback(buf,user_data); break;
+      case 'x': itostr_extra(va_arg(argp, int), buf, false, 16); user_callback(buf,user_data); break;
       case 'L': {
         unsigned int rad = 10;
-        if (*fmt=='x') { rad=16; fmt++; }
-        itostr(va_arg(argp, JsVarInt), buf, rad); user_callback(buf,user_data);
+        bool signedVal = true;
+        if (*fmt=='x') { rad=16; fmt++; signedVal = false; }
+        itostr_extra(va_arg(argp, JsVarInt), buf, signedVal, rad); user_callback(buf,user_data);
       } break;
       case 'f': ftoa_bounded(va_arg(argp, JsVarFloat), buf, sizeof(buf)); user_callback(buf,user_data);  break;
       case 's': user_callback(va_arg(argp, char *), user_data); break;
diff --git a/src/jsutils.h b/src/jsutils.h
index 0d84b290..45d0e1a7 100644
--- a/src/jsutils.h
+++ b/src/jsutils.h
@@ -417,7 +417,11 @@ unsigned int rand();
 JsVarFloat stringToFloatWithRadix(const char *s, int forceRadix);
 JsVarFloat stringToFloat(const char *str);
 
-void itostr(JsVarInt val,char *str,unsigned int base); // like itoa, but uses JsVarInt (good on non-32 bit systems)
+void itostr_extra(JsVarInt vals,char *str,bool signedVal,unsigned int base); // like itoa, but uses JsVarInt (good on non-32 bit systems)
+static inline void itostr(JsVarInt val,char *str,unsigned int base) {
+    itostr_extra(val, str, true, base);
+}
+
 char itoch(int val);
 
 // super ftoa that does fixed point and radix

