commit 9f81036c54ed1f860d2807c5a6aa4f2b30c21204
Author: Michael S. Tsirkin <mst@dev.mellanox.co.il>
Date:   Mon May 21 19:06:54 2007 +0300

    IB/cm: Improve local id allocation
    
    The IB CM uses an idr for local id allocations, with a running counter
    as start_id.  This fails to generate distinct ids if
    
    1. An id is constantly created and destroyed
    2. A chunk of ids just beyond the current next_id value is occupied
    
    This in turn leads to an increased chance of connection request being
    mis-detected as a duplicate, sometimes for several retries, until
    next_id gets past the block of allocated ids. This has been observed
    in practice.
    
    As a fix, remember the last id allocated and start immediately above it.
    This also fixes a problem with the old code, where next_id might
    overflow and become negative.
    
    Signed-off-by: Michael S. Tsirkin <mst@dev.mellanox.co.il>
    Acked-by: Sean Hefty <sean.hefty@intel.com>
    Signed-off-by: Roland Dreier <rolandd@cisco.com>

diff --git a/drivers/infiniband/core/cm.c b/drivers/infiniband/core/cm.c
index eff591deeb46..e840434a96d8 100644
--- a/drivers/infiniband/core/cm.c
+++ b/drivers/infiniband/core/cm.c
@@ -306,7 +306,9 @@ static int cm_alloc_id(struct cm_id_private *cm_id_priv)
 	do {
 		spin_lock_irqsave(&cm.lock, flags);
 		ret = idr_get_new_above(&cm.local_id_table, cm_id_priv,
-					next_id++, &id);
+					next_id, &id);
+		if (!ret)
+			next_id = ((unsigned) id + 1) & MAX_ID_MASK;
 		spin_unlock_irqrestore(&cm.lock, flags);
 	} while( (ret == -EAGAIN) && idr_pre_get(&cm.local_id_table, GFP_KERNEL) );
 

