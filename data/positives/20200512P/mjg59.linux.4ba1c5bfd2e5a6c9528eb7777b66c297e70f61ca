commit 4ba1c5bfd2e5a6c9528eb7777b66c297e70f61ca
Author: Sunil Mushran <sunil.mushran@oracle.com>
Date:   Fri Apr 18 15:03:59 2008 -0700

    ocfs2: Use GFP_NOFS in kmalloc during localalloc window move
    
    kmalloc() during a localalloc window move can trigger the mm to prune
    the dcache which inturn can trigger the fs to delete an inode causing
    it start a recursive transaction.
    
    The fix also makes the change in kmalloc during localalloc shutdown
    just to be safe.
    
    Fixes oss bugzilla#901
    http://oss.oracle.com/bugzilla/show_bug.cgi?id=901
    
    Signed-off-by: Sunil Mushran <sunil.mushran@oracle.com>
    Signed-off-by: Mark Fasheh <mfasheh@suse.com>

diff --git a/fs/ocfs2/localalloc.c b/fs/ocfs2/localalloc.c
index ce0dc147602a..be774bdc8b36 100644
--- a/fs/ocfs2/localalloc.c
+++ b/fs/ocfs2/localalloc.c
@@ -260,7 +260,7 @@ void ocfs2_shutdown_local_alloc(struct ocfs2_super *osb)
 	bh = osb->local_alloc_bh;
 	alloc = (struct ocfs2_dinode *) bh->b_data;
 
-	alloc_copy = kmalloc(bh->b_size, GFP_KERNEL);
+	alloc_copy = kmalloc(bh->b_size, GFP_NOFS);
 	if (!alloc_copy) {
 		status = -ENOMEM;
 		goto out_commit;
@@ -931,7 +931,7 @@ static int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,
 	 * local alloc shutdown won't try to double free main bitmap
 	 * bits. Make a copy so the sync function knows which bits to
 	 * free. */
-	alloc_copy = kmalloc(osb->local_alloc_bh->b_size, GFP_KERNEL);
+	alloc_copy = kmalloc(osb->local_alloc_bh->b_size, GFP_NOFS);
 	if (!alloc_copy) {
 		status = -ENOMEM;
 		mlog_errno(status);

