commit a198996c7afae0097c67a61851f19863e59697b2
Author: Andi Kleen <ak@linux.intel.com>
Date:   Thu Jul 18 15:33:46 2013 -0700

    perf bench: Fix memcpy benchmark for large sizes
    
    The glibc calloc() function has an optimization to not explicitely
    memset() very large calloc allocations that just came from mmap(),
    because they are known to be zero.
    
    This could result in the perf memcpy benchmark reading only from
    the zero page, which gives unrealistic results.
    
    Always call memset explicitly on the source area to avoid this problem.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: Hitoshi Mitake <h.mitake@gmail.com>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Link: http://lkml.kernel.org/n/tip-pzz2qrdq9eymxda0y8yxdn33@git.kernel.org
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/tools/perf/bench/mem-memcpy.c b/tools/perf/bench/mem-memcpy.c
index 25fd3f1966f1..8cdca43016b2 100644
--- a/tools/perf/bench/mem-memcpy.c
+++ b/tools/perf/bench/mem-memcpy.c
@@ -117,6 +117,8 @@ static void alloc_mem(void **dst, void **src, size_t length)
 	*src = zalloc(length);
 	if (!*src)
 		die("memory allocation failed - maybe length is too large?\n");
+	/* Make sure to always replace the zero pages even if MMAP_THRESH is crossed */
+	memset(*src, 0, length);
 }
 
 static u64 do_memcpy_cycle(memcpy_t fn, size_t len, bool prefault)

