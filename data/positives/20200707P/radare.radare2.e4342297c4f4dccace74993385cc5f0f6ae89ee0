commit e4342297c4f4dccace74993385cc5f0f6ae89ee0
Author: Giovanni <wargio@libero.it>
Date:   Tue Aug 29 12:39:49 2017 +0200

    Various fixes for bugs from coverity + bonus (#8372)
    
    * 1356014 Resource leak
    * 1356012 Resource leak
    * 1356010 Resource leak
    * 1355967 Resource leak
    * 1355960 Resource leak
    * 1352987 Resource leak
    * 1352986 Unintentional integer overflow
    * 1352985 Unintentional integer overflow
    * fixed coverity missed null deref
    * 1347178 Resource leak
    * 1347178 Resource leak
    * 1346910, 1363297 Resource leak

diff --git a/libr/bin/pdb/tpi.c b/libr/bin/pdb/tpi.c
index 633818d78..2e5b3b062 100644
--- a/libr/bin/pdb/tpi.c
+++ b/libr/bin/pdb/tpi.c
@@ -2126,7 +2126,7 @@ static int parse_lf_vtshape(SLF_VTSHAPE *lf_vtshape, unsigned char *leaf_data, u
 
 #define PARSE_LF(lf_type, lf_func) { \
 	lf_type *lf = (lf_type *) malloc(sizeof(lf_type)); \
-	if (!lf) return 0; \
+	if (!lf) { free (leaf_data); return 0; }\
 	parse_##lf_func(lf, leaf_data + 2, &read_bytes, type->length); \
 	type->type_data.type_info = (void *) lf; \
 	init_stype_info(&type->type_data); \
diff --git a/libr/core/cmd.c b/libr/core/cmd.c
index 700533c9c..387c7f2df 100644
--- a/libr/core/cmd.c
+++ b/libr/core/cmd.c
@@ -2266,6 +2266,7 @@ next_arroba:
 					eprintf ("Usage: / ABCD @..0x1000 0x3000\n");
 					free (tmpeval);
 					free (tmpasm);
+					free (tmpbits)
 					goto fail;
 				}
 				*p = '\x00';
diff --git a/libr/core/cmd_anal.c b/libr/core/cmd_anal.c
index da3cca545..3f780f92a 100644
--- a/libr/core/cmd_anal.c
+++ b/libr/core/cmd_anal.c
@@ -1789,16 +1789,19 @@ static bool fcnNeedsPrefix(const char *name) {
 
 /* TODO: move into r_anal_fcn_rename(); */
 static bool setFunctionName(RCore *core, ut64 off, const char *name, bool prefix) {
+	bool allocated = false;
 	char *oname, *nname = NULL;
 	RAnalFunction *fcn;
 	if (!core || !name) {
 		return false;
 	}
+	name = strdup (name);
 	const char *fcnpfx = r_config_get (core->config, "anal.fcnprefix");
 	if (!fcnpfx) {
 		fcnpfx = "fcn";
 	}
 	if (r_reg_get (core->anal->reg, name, -1)) {
+		allocated = true;
 		name = r_str_newf ("%s.%s", fcnpfx, name);
 	}
 	fcn = r_anal_get_fcn_in (core->anal, off,
@@ -1820,6 +1823,9 @@ static bool setFunctionName(RCore *core, ut64 off, const char *name, bool prefix
 	}
 	free (oname);
 	free (nname);
+	if (allocated) {
+		free (name);
+	}
 	return true;
 }
 
diff --git a/libr/core/cmd_print.c b/libr/core/cmd_print.c
index 1abacd2f8..ef4b5f3b5 100644
--- a/libr/core/cmd_print.c
+++ b/libr/core/cmd_print.c
@@ -2017,7 +2017,7 @@ static void disasm_strings(RCore *core, const char *input, RAnalFunction *fcn) {
 			}
 		}
 		// XXX leak
-		str = strstr (line, " str.");
+		str = strdup (strstr (line, " str."));
 		if (str) {
 			char *qoe = NULL;
 			if (!qoe) {
@@ -2030,36 +2030,32 @@ static void disasm_strings(RCore *core, const char *input, RAnalFunction *fcn) {
 				qoe = strchr (str + 1, ' ');
 			}
 			if (qoe) {
+				free (string2);
 				string2 = r_str_ndup (str + 1, qoe - str - 1);
 			} else {
+				free (string2);
 				string2 = strdup (str + 1);
 			}
 			if (string2) {
-				/* the str.* flag will win over naked "string",
-				 * since it's generally more accurate */
-				if (string) {
-					R_FREE (string);
-				}
+				R_FREE (string);
 				string = string2;
 				string2 = NULL;
 			}
 		}
-		if (string2) {
-			R_FREE (string2);
-		}
+		R_FREE (string2);
 		_handle_call (core, line, &str);
 		if (!str) {
-			str = strstr (line, "sym.");
+			str = strdup (strstr (line, "sym."));
 			if (!str) {
-				str = strstr (line, "fcn.");
+				str = strdup (strstr (line, "fcn."));
 			}
 		}
 		if (str) {
 			char *qoe = strstr (str, ";");
 			if (qoe) {
-				// XXX str leaks
+				char* t = str;
 				str = r_str_ndup (str, qoe - str);
-				is_free_pending = true;
+				free (t);
 			}
 		}
 		if (str) {
@@ -2161,9 +2157,7 @@ static void disasm_strings(RCore *core, const char *input, RAnalFunction *fcn) {
 	free (string2);
 	free (string);
 	free (s);
-	if (is_free_pending) {
-		free (str);
-	}
+	free (str);
 }
 
 static void algolist(int mode) {
@@ -2444,7 +2438,7 @@ static void cmd_print_bars(RCore *core, const char *input) {
 	int totalsize = -1;
 	int skipblocks = -1;
 
-	int blocksize = -1;
+	ut64 blocksize = 0;
 	int mode = 'b'; // e, p, b, ...
 	int submode = 0; // q, j, ...
 
@@ -2512,7 +2506,7 @@ static void cmd_print_bars(RCore *core, const char *input) {
 		case 'z': // zero terminated strings
 			{
 				ut8 *p;
-				int i, j, k;
+				ut64 i, j, k;
 				ptr = calloc (1, nblocks);
 				if (!ptr) {
 					eprintf ("Error: failed to malloc memory");
@@ -2526,7 +2520,7 @@ static void cmd_print_bars(RCore *core, const char *input) {
 				}
 				int len = 0;
 				for (i = 0; i < nblocks; i++) {
-					ut64 off = (i + skipblocks) * blocksize;
+					ut64 off = blocksize * (i + skipblocks);
 					r_core_read_at (core, off, p, blocksize);
 					for (j = k = 0; j < blocksize; j++) {
 						switch (submode) {
@@ -2582,7 +2576,7 @@ static void cmd_print_bars(RCore *core, const char *input) {
 				goto beach;
 			}
 			for (i = 0; i < nblocks; i++) {
-				ut64 off = core->offset + (i + skipblocks) * blocksize;
+				ut64 off = core->offset + (blocksize * (i + skipblocks));
 				r_core_read_at (core, off, p, blocksize);
 				ptr[i] = (ut8) (256 * r_hash_entropy_fraction (p, blocksize));
 			}
@@ -2650,7 +2644,7 @@ static void cmd_print_bars(RCore *core, const char *input) {
 			goto beach;
 		}
 		for (i = 0; i < nblocks; i++) {
-			ut64 off = core->offset + (i + skipblocks) * blocksize;
+			ut64 off = core->offset + (blocksize * (i + skipblocks));
 			for (j = 0; j < blocksize; j++) {
 				if (r_flag_get_at (core->flags, off + j, false)) {
 					matchBar (ptr, i);
@@ -2677,7 +2671,7 @@ static void cmd_print_bars(RCore *core, const char *input) {
 			goto beach;
 		}
 		for (i = 0; i < nblocks; i++) {
-			ut64 off = core->offset + (i + skipblocks) * blocksize;
+			ut64 off = core->offset + (blocksize * (i + skipblocks));
 			r_core_read_at (core, off, p, blocksize);
 			ptr[i] = (ut8) (256 * r_hash_entropy_fraction (p, blocksize));
 		}
@@ -2691,7 +2685,7 @@ static void cmd_print_bars(RCore *core, const char *input) {
 	case 'z': // zero terminated strings
 	{
 		ut8 *p;
-		int i, j, k;
+		ut64 i, j, k;
 		ptr = calloc (1, nblocks);
 		if (!ptr) {
 			eprintf ("Error: failed to malloc memory");
@@ -2705,7 +2699,7 @@ static void cmd_print_bars(RCore *core, const char *input) {
 		}
 		int len = 0;
 		for (i = 0; i < nblocks; i++) {
-			ut64 off = (i + skipblocks) * blocksize;
+			ut64 off = blocksize * (i + skipblocks);
 			r_core_read_at (core, off, p, blocksize);
 			for (j = k = 0; j < blocksize; j++) {
 				switch (mode) {
@@ -2792,6 +2786,7 @@ static void cmd_print_bars(RCore *core, const char *input) {
 		}
 	}
 beach:
+	free (ptr);
 	return;
 }
 
diff --git a/libr/core/graph.c b/libr/core/graph.c
index db2285666..5fc9e9ffb 100644
--- a/libr/core/graph.c
+++ b/libr/core/graph.c
@@ -3124,17 +3124,18 @@ R_API int r_core_visual_graph(RCore *core, RAGraph *g, RAnalFunction *_fcn, int
 			eprintf ("No function in current seek\n");
 			r_config_restore (hc);
 			r_config_hold_free (hc);
+			r_cons_canvas_free (can);
 			return false;
 		}
 		g = r_agraph_new (can);
-		g->is_tiny = is_interactive == 2;
-		g->layout = r_config_get_i (core->config, "graph.layout");
 		if (!g) {
 			r_cons_canvas_free (can);
 			r_config_restore (hc);
 			r_config_hold_free (hc);
 			return false;
 		}
+		g->is_tiny = is_interactive == 2;
+		g->layout = r_config_get_i (core->config, "graph.layout");
 	} else {
 		o_can = g->can;
 	}
@@ -3156,6 +3157,7 @@ R_API int r_core_visual_graph(RCore *core, RAGraph *g, RAnalFunction *_fcn, int
 		r_cons_canvas_free (can);
 		r_config_restore (hc);
 		r_config_hold_free (hc);
+		r_agraph_free (g);
 		return false;
 	}
 	grd->g = g;
diff --git a/libr/debug/p/native/linux/linux_coredump.c b/libr/debug/p/native/linux/linux_coredump.c
index a95f5fb9d..6c293c298 100644
--- a/libr/debug/p/native/linux/linux_coredump.c
+++ b/libr/debug/p/native/linux/linux_coredump.c
@@ -330,11 +330,12 @@ static bool dump_this_map(char *buff_smaps, linux_map_entry_t *entry, ut8 filter
 	char *aux = NULL;
 	ut8 vmflags = 0, perms = entry->perms;
 
-	/* if the map doesn't have r/w quit right here */
-	if ((!(perms & R_IO_READ) && !(perms & R_IO_WRITE))) {
+	if (!identity) {
 		return false;
 	}
-	if (!identity) {
+	/* if the map doesn't have r/w quit right here */
+	if ((!(perms & R_IO_READ) && !(perms & R_IO_WRITE))) {
+		free (identity);
 		return false;
 	}
 	aux = strdup (buff_smaps);
@@ -553,6 +554,7 @@ static linux_map_entry_t *linux_get_mapped_files(RDebug *dbg, ut8 filter_flags)
 error:
 	free (buff_maps);
 	free (buff_smaps);
+	free (file);
 	clean_maps (me_head);
 	return NULL;
 }

