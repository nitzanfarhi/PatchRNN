commit e1e5a9f84e4dbd3567bb8b0d5e79db6e1e5ebc35
Author: Lino Sanfilippo <LinoSanfilippo@gmx.de>
Date:   Mon Jul 8 15:59:45 2013 -0700

    inotify: fix race when adding a new watch
    
    In inotify_new_watch() the number of watches for a group is compared
    against the max number of allowed watches and increased afterwards.  The
    check and incrementation is not done atomically, so it is possible for
    multiple concurrent threads to pass the check and increment the number
    of marks above the allowed max.
    
    This patch uses an inotify groups mark_lock to ensure that both check
    and incrementation are done atomic.  Furthermore we dont have to worry
    about the race that allows a concurrent thread to add a watch just after
    inotify_update_existing_watch() returned with -ENOENT anymore, since
    this is also synchronized by the groups mark mutex now.
    
    Signed-off-by: Lino Sanfilippo <LinoSanfilippo@gmx.de>
    Cc: Eric Paris <eparis@redhat.com>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/notify/inotify/inotify_user.c b/fs/notify/inotify/inotify_user.c
index 959815c1e017..60f954a891ab 100644
--- a/fs/notify/inotify/inotify_user.c
+++ b/fs/notify/inotify/inotify_user.c
@@ -636,7 +636,8 @@ static int inotify_new_watch(struct fsnotify_group *group,
 		goto out_err;
 
 	/* we are on the idr, now get on the inode */
-	ret = fsnotify_add_mark(&tmp_i_mark->fsn_mark, group, inode, NULL, 0);
+	ret = fsnotify_add_mark_locked(&tmp_i_mark->fsn_mark, group, inode,
+				       NULL, 0);
 	if (ret) {
 		/* we failed to get on the inode, get off the idr */
 		inotify_remove_from_idr(group, tmp_i_mark);
@@ -660,19 +661,13 @@ static int inotify_update_watch(struct fsnotify_group *group, struct inode *inod
 {
 	int ret = 0;
 
-retry:
+	mutex_lock(&group->mark_mutex);
 	/* try to update and existing watch with the new arg */
 	ret = inotify_update_existing_watch(group, inode, arg);
 	/* no mark present, try to add a new one */
 	if (ret == -ENOENT)
 		ret = inotify_new_watch(group, inode, arg);
-	/*
-	 * inotify_new_watch could race with another thread which did an
-	 * inotify_new_watch between the update_existing and the add watch
-	 * here, go back and try to update an existing mark again.
-	 */
-	if (ret == -EEXIST)
-		goto retry;
+	mutex_unlock(&group->mark_mutex);
 
 	return ret;
 }

