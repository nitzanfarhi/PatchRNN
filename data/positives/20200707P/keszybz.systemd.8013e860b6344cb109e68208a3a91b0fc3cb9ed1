commit 8013e860b6344cb109e68208a3a91b0fc3cb9ed1
Author: Lennart Poettering <lennart@poettering.net>
Date:   Fri Aug 21 12:28:59 2015 +0200

    resolved: make DnsQuestion logic handle NULL arrays as empty arrays
    
    Following our usual logic of treating NULL arrays as empty arrays (for
    example, see strv.c) do the same for questions too.

diff --git a/src/resolve/resolved-dns-question.c b/src/resolve/resolved-dns-question.c
index 0efe740d1..7590bc541 100644
--- a/src/resolve/resolved-dns-question.c
+++ b/src/resolve/resolved-dns-question.c
@@ -68,9 +68,11 @@ int dns_question_add(DnsQuestion *q, DnsResourceKey *key) {
         unsigned i;
         int r;
 
-        assert(q);
         assert(key);
 
+        if (!q)
+                return -ENOSPC;
+
         for (i = 0; i < q->n_keys; i++) {
                 r = dns_resource_key_equal(q->keys[i], key);
                 if (r < 0)
@@ -90,9 +92,11 @@ int dns_question_matches_rr(DnsQuestion *q, DnsResourceRecord *rr) {
         unsigned i;
         int r;
 
-        assert(q);
         assert(rr);
 
+        if (!q)
+                return 0;
+
         for (i = 0; i < q->n_keys; i++) {
                 r = dns_resource_key_match_rr(q->keys[i], rr);
                 if (r != 0)
@@ -106,9 +110,11 @@ int dns_question_matches_cname(DnsQuestion *q, DnsResourceRecord *rr) {
         unsigned i;
         int r;
 
-        assert(q);
         assert(rr);
 
+        if (!q)
+                return 0;
+
         for (i = 0; i < q->n_keys; i++) {
                 r = dns_resource_key_match_cname(q->keys[i], rr);
                 if (r != 0)
@@ -123,7 +129,8 @@ int dns_question_is_valid(DnsQuestion *q) {
         unsigned i;
         int r;
 
-        assert(q);
+        if (!q)
+                return 0;
 
         if (q->n_keys <= 0)
                 return 0;
@@ -151,16 +158,19 @@ int dns_question_is_superset(DnsQuestion *q, DnsQuestion *other) {
         unsigned j;
         int r;
 
-        assert(q);
-        assert(other);
-
         /* Checks if all keys in "other" are also contained in "q" */
 
+        if (!other)
+                return 1;
+
         for (j = 0; j < other->n_keys; j++) {
                 DnsResourceKey *b = other->keys[j];
                 bool found = false;
                 unsigned i;
 
+                if (!q)
+                        return 0;
+
                 for (i = 0; i < q->n_keys; i++) {
                         DnsResourceKey *a = q->keys[i];
 
@@ -192,9 +202,11 @@ int dns_question_contains(DnsQuestion *a, DnsResourceKey *k) {
         unsigned j;
         int r;
 
-        assert(a);
         assert(k);
 
+        if (!a)
+                return 0;
+
         for (j = 0; j < a->n_keys; j++) {
                 r = dns_resource_key_equal(a->keys[j], k);
                 if (r != 0)
@@ -208,8 +220,10 @@ int dns_question_is_equal(DnsQuestion *a, DnsQuestion *b) {
         unsigned j;
         int r;
 
-        assert(a);
-        assert(b);
+        if (!a)
+                return !b || b->n_keys == 0;
+        if (!b)
+                return a->n_keys == 0;
 
         /* Checks if all keys in a are also contained b, and vice versa */
 
@@ -234,10 +248,19 @@ int dns_question_cname_redirect(DnsQuestion *q, const char *name, DnsQuestion **
         unsigned i;
         int r;
 
-        assert(q);
         assert(name);
         assert(ret);
 
+        if (!q) {
+                n = dns_question_new(0);
+                if (!n)
+                        return -ENOMEM;
+
+                *ret = n;
+                n = 0;
+                return 0;
+        }
+
         for (i = 0; i < q->n_keys; i++) {
                 r = dns_name_equal(DNS_RESOURCE_KEY_NAME(q->keys[i]), name);
                 if (r < 0)
@@ -281,9 +304,11 @@ int dns_question_cname_redirect(DnsQuestion *q, const char *name, DnsQuestion **
 int dns_question_endswith(DnsQuestion *q, const char *suffix) {
         unsigned i;
 
-        assert(q);
         assert(suffix);
 
+        if (!q)
+                return 1;
+
         for (i = 0; i < q->n_keys; i++) {
                 int k;
 
@@ -298,10 +323,12 @@ int dns_question_endswith(DnsQuestion *q, const char *suffix) {
 int dns_question_extract_reverse_address(DnsQuestion *q, int *family, union in_addr_union *address) {
         unsigned i;
 
-        assert(q);
         assert(family);
         assert(address);
 
+        if (!q)
+                return 0;
+
         for (i = 0; i < q->n_keys; i++) {
                 int k;
 

