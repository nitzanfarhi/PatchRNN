commit ff57aa346544af20dd7d17e5df78777a4d6e6fbe
Author: jonas@perch.ndb.mysql.com <>
Date:   Fri May 19 16:17:38 2006 +0200

    ndb -
      Fix recursive mutex lock in drop index (ndbapi programs only)

diff --git a/storage/ndb/src/ndbapi/NdbDictionaryImpl.cpp b/storage/ndb/src/ndbapi/NdbDictionaryImpl.cpp
index 5a842d1ecc5..d2d8c43a064 100644
--- a/storage/ndb/src/ndbapi/NdbDictionaryImpl.cpp
+++ b/storage/ndb/src/ndbapi/NdbDictionaryImpl.cpp
@@ -3002,63 +3002,6 @@ NdbDictionaryImpl::removeCachedObject(NdbTableImpl & impl)
   DBUG_RETURN(0);
 }
 
-/*****************************************************************
- * Get index info
- */
-NdbIndexImpl*
-NdbDictionaryImpl::getIndexImpl(const char * externalName,
-				const BaseString& internalName)
-{
-  ASSERT_NOT_MYSQLD;
-  Ndb_local_table_info * info = get_local_table_info(internalName);
-  if(info == 0){
-    m_error.code = 4243;
-    return 0;
-  }
-  NdbTableImpl * tab = info->m_table_impl;
-
-  if(tab->m_indexType == NdbDictionary::Object::TypeUndefined)
-  {
-    // Not an index
-    m_error.code = 4243;
-    return 0;
-  }
-
-  NdbTableImpl* prim = getTable(tab->m_primaryTable.c_str());
-  if(prim == 0){
-    m_error.code = 4243;
-    return 0;
-  }
-
-  return getIndexImpl(externalName, internalName, *tab, *prim);
-}
-
-NdbIndexImpl*
-NdbDictionaryImpl::getIndexImpl(const char * externalName,
-                                const BaseString& internalName,
-				NdbTableImpl &tab,
-                                NdbTableImpl &prim)
-{
-  DBUG_ENTER("NdbDictionaryImpl::getIndexImpl");
-  DBUG_ASSERT(tab.m_indexType != NdbDictionary::Object::TypeUndefined);
-  /**
-   * Create index impl
-   */
-  NdbIndexImpl* idx;
-  if(NdbDictInterface::create_index_obj_from_table(&idx, &tab, &prim) == 0){
-    idx->m_table = &tab;
-    idx->m_externalName.assign(externalName);
-    idx->m_internalName.assign(internalName);
-    idx->m_table_id = prim.getObjectId();
-      idx->m_table_version = prim.getObjectVersion();
-    // TODO Assign idx to tab->m_index
-    // Don't do it right now since assign can't asign a table with index
-    // tab->m_index = idx;
-    DBUG_RETURN(idx);
-  }
-  DBUG_RETURN(0);
-}
-
 int
 NdbDictInterface::create_index_obj_from_table(NdbIndexImpl** dst,
 					      NdbTableImpl* tab,
@@ -3116,6 +3059,9 @@ NdbDictInterface::create_index_obj_from_table(NdbIndexImpl** dst,
       tab->m_columns[i]->m_distributionKey = 0;
   }
 
+  idx->m_table_id = prim->getObjectId();
+  idx->m_table_version = prim->getObjectVersion();
+  
   * dst = idx;
   DBUG_PRINT("exit", ("m_id: %d  m_version: %d", idx->m_id, idx->m_version));
   DBUG_RETURN(0);
diff --git a/storage/ndb/src/ndbapi/NdbDictionaryImpl.hpp b/storage/ndb/src/ndbapi/NdbDictionaryImpl.hpp
index 5a7a1ebb0ab..cf30abc6c3f 100644
--- a/storage/ndb/src/ndbapi/NdbDictionaryImpl.hpp
+++ b/storage/ndb/src/ndbapi/NdbDictionaryImpl.hpp
@@ -617,6 +617,7 @@ public:
     get_local_table_info(const BaseString& internalTableName);
   NdbIndexImpl * getIndex(const char * indexName,
 			  const char * tableName);
+  NdbIndexImpl * getIndex(const char * indexName, const NdbTableImpl& prim);
   NdbEventImpl * getEvent(const char * eventName, NdbTableImpl* = NULL);
   NdbEventImpl * getBlobEvent(const NdbEventImpl& ev, uint col_no);
   NdbEventImpl * getEventImpl(const char * internalName);
@@ -958,51 +959,36 @@ NdbDictionaryImpl::get_local_table_info(const BaseString& internalTableName)
   DBUG_RETURN(info); // autoincrement already initialized
 }
 
-class InitIndexGlobal : public GlobalCacheInitObject
+class InitIndex : public GlobalCacheInitObject
 {
 public:
   const char *m_index_name;
-  NdbTableImpl &m_prim;
+  const NdbTableImpl &m_prim;
 
-  InitIndexGlobal(NdbDictionaryImpl *dict,
-                  const BaseString &internal_indexname,
-                  const char *index_name,
-            NdbTableImpl &prim) :
-    GlobalCacheInitObject(dict, internal_indexname),
+  InitIndex(const BaseString &internal_indexname,
+	    const char *index_name,
+	    const NdbTableImpl &prim) :
+    GlobalCacheInitObject(0, internal_indexname),
     m_index_name(index_name),
     m_prim(prim)
-  {}
-  int init(NdbTableImpl &tab) const
-  {
-    tab.m_index= m_dict->getIndexImpl(m_index_name, m_name, tab, m_prim);
-    if (tab.m_index == 0)
-      return 1;
-    tab.m_index->m_table= &tab;
-    return 0;
-  }
-};
-
-class InitIndex : public GlobalCacheInitObject
-{
-public:
-  const char *m_index_name;
-
-  InitIndex(NdbDictionaryImpl *dict,
-            const BaseString &internal_indexname,
-            const char *index_name) :
-    GlobalCacheInitObject(dict, internal_indexname),
-    m_index_name(index_name)
-  {}
-  int init(NdbTableImpl &tab) const
-  {
-    DBUG_ASSERT(tab.m_index == 0);
-    tab.m_index= m_dict->getIndexImpl(m_index_name, m_name);
-    if (tab.m_index)
+    {}
+  
+  int init(NdbTableImpl &tab) const {
+    DBUG_ENTER("InitIndex::init");
+    DBUG_ASSERT(tab.m_indexType != NdbDictionary::Object::TypeUndefined);
+    /**
+     * Create index impl
+     */
+    NdbIndexImpl* idx;
+    if(NdbDictInterface::create_index_obj_from_table(&idx, &tab, &m_prim) == 0)
     {
-      tab.m_index->m_table= &tab;
-      return 0;
+      idx->m_table = &tab;
+      idx->m_externalName.assign(m_index_name);
+      idx->m_internalName.assign(m_name);
+      tab.m_index = idx;
+      DBUG_RETURN(0);
     }
-    return 1;
+    DBUG_RETURN(1);
   }
 };
 
@@ -1019,14 +1005,14 @@ NdbDictionaryImpl::getIndexGlobal(const char * index_name,
   while (retry)
   {
     NdbTableImpl *tab=
-      fetchGlobalTableImplRef(InitIndexGlobal(this, internal_indexname,
-                                              index_name, ndbtab));
+      fetchGlobalTableImplRef(InitIndex(internal_indexname,
+					index_name, ndbtab));
     if (tab)
     {
       // tab->m_index sould be set. otherwise tab == 0
       NdbIndexImpl *idx= tab->m_index;
-      if (idx->m_table_id != ndbtab.getObjectId() ||
-          idx->m_table_version != ndbtab.getObjectVersion())
+      if (idx->m_table_id != (unsigned)ndbtab.getObjectId() ||
+          idx->m_table_version != (unsigned)ndbtab.getObjectVersion())
       {
         releaseIndexGlobal(*idx, 1);
         retry--;
@@ -1067,41 +1053,54 @@ NdbIndexImpl *
 NdbDictionaryImpl::getIndex(const char * index_name,
 			    const char * table_name)
 {
-  while (table_name || m_ndb.usingFullyQualifiedNames())
+  if (table_name == 0)
   {
-    const BaseString internal_indexname(
-      (table_name)
-      ?
-      m_ndb.internalize_index_name(getTable(table_name), index_name)
-      :
-      m_ndb.internalize_table_name(index_name)); // Index is also a table
-
-    if (internal_indexname.length())
-    {
-      Ndb_local_table_info *info= m_localHash.get(internal_indexname.c_str());
-      NdbTableImpl *tab;
-      if (info == 0)
-      {
-        tab= fetchGlobalTableImplRef(InitIndex(this, internal_indexname,
-                                               index_name));
-        if (tab)
-        {
-          info= Ndb_local_table_info::create(tab, 0);
-          if (info)
-            m_localHash.put(internal_indexname.c_str(), info);
-          else
-            break;
-        }
-        else
-          break;
-      }
-      else
-        tab= info->m_table_impl;
-      return tab->m_index;
-    }
-    break;
+    assert(0);
+    m_error.code= 4243;
+    return 0;
+  }
+  
+  
+  NdbTableImpl* prim = getTable(table_name);
+  if (prim == 0)
+  {
+    m_error.code= 4243;
+    return 0;
   }
 
+  return getIndex(index_name, *prim);
+}
+
+inline
+NdbIndexImpl * 
+NdbDictionaryImpl::getIndex(const char* index_name,
+			    const NdbTableImpl& prim)
+{
+
+  const BaseString
+    internal_indexname(m_ndb.internalize_index_name(&prim, index_name));
+
+  Ndb_local_table_info *info= m_localHash.get(internal_indexname.c_str());
+  NdbTableImpl *tab;
+  if (info == 0)
+  {
+    tab= fetchGlobalTableImplRef(InitIndex(internal_indexname,
+					   index_name,
+					   prim));
+    if (!tab)
+      goto err;
+
+    info= Ndb_local_table_info::create(tab, 0);
+    if (!info)
+      goto err;
+    m_localHash.put(internal_indexname.c_str(), info);
+  }
+  else
+    tab= info->m_table_impl;
+  
+  return tab->m_index;
+  
+err:
   m_error.code= 4243;
   return 0;
 }

