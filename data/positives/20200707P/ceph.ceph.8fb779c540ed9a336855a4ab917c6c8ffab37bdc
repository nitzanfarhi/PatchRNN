commit 8fb779c540ed9a336855a4ab917c6c8ffab37bdc
Author: Haomai Wang <haomai@xsky.com>
Date:   Sat May 27 09:59:11 2017 +0800

    msg/async: avoid requeue racing with handle_write
    
    when the thread is calling AsyncConnection::handle_write, another thread may
    replace it and requeue all messages. Because we remove the write_lock
    protection for handle_write caller, it may happen sent racing with out_q
    
    Fix: http://tracker.ceph.com/issues/20093
    
    Signed-off-by: Haomai Wang <haomai@xsky.com>

diff --git a/src/msg/async/AsyncConnection.cc b/src/msg/async/AsyncConnection.cc
index 585e0b8083..7cc6fe9715 100644
--- a/src/msg/async/AsyncConnection.cc
+++ b/src/msg/async/AsyncConnection.cc
@@ -1679,7 +1679,6 @@ ssize_t AsyncConnection::handle_connect_msg(ceph_msg_connect &connect, bufferlis
       existing->delay_state->flush();
       assert(!delay_state);
     }
-    existing->requeue_sent();
     existing->reset_recv_state();
 
     auto temp_cs = std::move(cs);
@@ -1706,8 +1705,11 @@ ssize_t AsyncConnection::handle_connect_msg(ceph_msg_connect &connect, bufferlis
       // we need to delete time event in original thread
       {
         std::lock_guard<std::mutex> l(existing->lock);
+        existing->write_lock.lock();
+        existing->requeue_sent();
         existing->outcoming_bl.clear();
         existing->open_write = false;
+        existing->write_lock.unlock();
         if (existing->state == STATE_NONE) {
           existing->shutdown_socket();
           existing->cs = std::move(cs);

