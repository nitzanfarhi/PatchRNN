commit 7bed50c5edf5cba8dd515a31191cbfb6065ddc85
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Apr 26 11:33:18 2011 +0200

    ACPI / PM: Avoid infinite recurrence while registering power resources
    
    There is at least one BIOS with a DSDT containing a power resource
    object with a _PR0 entry pointing back to that power resource.  In
    consequence, while registering that power resource
    acpi_bus_get_power_flags() sees that it depends on itself and tries
    to register it again, which leads to an infinitely deep recurrence.
    This problem was introduced by commit bf325f9538d8c89312be305b9779e
    (ACPI / PM: Register power resource devices as soon as they are
    needed).
    
    To fix this problem use the observation that power resources cannot
    be power manageable and prevent acpi_bus_get_power_flags() from
    being called for power resource objects.
    
    References: https://bugzilla.kernel.org/show_bug.cgi?id=31872
    Reported-and-tested-by: Pascal Dormeau <pdormeau@free.fr>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Len Brown <lenb@kernel.org>
    Cc: stable@kernel.org

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index b136c9c1e531..449c556274c0 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -943,6 +943,10 @@ static int acpi_bus_get_flags(struct acpi_device *device)
 	if (ACPI_SUCCESS(status))
 		device->flags.lockable = 1;
 
+	/* Power resources cannot be power manageable. */
+	if (device->device_type == ACPI_BUS_TYPE_POWER)
+		return 0;
+
 	/* Presence of _PS0|_PR0 indicates 'power manageable' */
 	status = acpi_get_handle(device->handle, "_PS0", &temp);
 	if (ACPI_FAILURE(status))

