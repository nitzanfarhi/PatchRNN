commit cd79007634854f9e936e2369890f2512f94b8759
Author: Milton Miller <miltonm@bga.com>
Date:   Wed Oct 17 16:55:11 2007 +0200

    sched: more robust sd-sysctl entry freeing
    
    It occurred to me this morning that the procname field was dynamically
    allocated and needed to be freed.  I started to put in break statements
    when allocation failed but it was approaching 50% error handling code.
    
    I came up with this alternative of looping while entry->mode is set and
    checking proc_handler instead of ->table.  Alternatively, the string
    version of the domain name and cpu number could be stored the structs.
    
    I verified by compiling CONFIG_DEBUG_SLAB and checking the allocation
    counts after taking a cpuset exclusive and back.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/kernel/sched.c b/kernel/sched.c
index 0da2b2635c54..5e220bf7d4c4 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -5272,11 +5272,20 @@ static struct ctl_table *sd_alloc_ctl_entry(int n)
 
 static void sd_free_ctl_entry(struct ctl_table **tablep)
 {
-	struct ctl_table *entry = *tablep;
+	struct ctl_table *entry;
 
-	for (entry = *tablep; entry->procname; entry++)
+	/*
+	 * In the intermediate directories, both the child directory and
+	 * procname are dynamically allocated and could fail but the mode
+	 * will always be set.  In the lowest directory the names are
+	 * static strings and all have proc handlers.
+	 */
+	for (entry = *tablep; entry->mode; entry++) {
 		if (entry->child)
 			sd_free_ctl_entry(&entry->child);
+		if (entry->proc_handler == NULL)
+			kfree(entry->procname);
+	}
 
 	kfree(*tablep);
 	*tablep = NULL;

