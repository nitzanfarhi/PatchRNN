commit 0ff6fabdb0a862b22df4dd75873578392478e64d
Author: Miao Xie <miaox@cn.fujitsu.com>
Date:   Wed Nov 28 10:28:54 2012 +0000

    Btrfs: fix off-by-one error of the reserved size of btrfs_allocate()
    
    alloc_end is not the real end of the current extent, it is the start of the
    next adjoining extent. So we needn't +1 when calculating the size the space
    that is about to be reserved.
    
    Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
    Reviewed-by: Liu Bo <bo.li.liu@oracle.com>
    Signed-off-by: Chris Mason <chris.mason@fusionio.com>

diff --git a/fs/btrfs/file.c b/fs/btrfs/file.c
index a43d0aef6ee1..8e3d6788d6dd 100644
--- a/fs/btrfs/file.c
+++ b/fs/btrfs/file.c
@@ -2072,7 +2072,7 @@ static long btrfs_fallocate(struct file *file, int mode,
 	 * Make sure we have enough space before we do the
 	 * allocation.
 	 */
-	ret = btrfs_check_data_free_space(inode, alloc_end - alloc_start + 1);
+	ret = btrfs_check_data_free_space(inode, alloc_end - alloc_start);
 	if (ret)
 		return ret;
 
@@ -2179,7 +2179,7 @@ static long btrfs_fallocate(struct file *file, int mode,
 out:
 	mutex_unlock(&inode->i_mutex);
 	/* Let go of our reservation. */
-	btrfs_free_reserved_data_space(inode, alloc_end - alloc_start + 1);
+	btrfs_free_reserved_data_space(inode, alloc_end - alloc_start);
 	return ret;
 }
 

