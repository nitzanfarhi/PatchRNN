commit cf8039036a6e9c5f7144841925f212a957faf1aa
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Tue Oct 25 09:18:41 2011 -0400

    ext4: prevent stack overrun in ext4_file_open
    
    In ext4_file_open, the filesystem records the mountpoint of the first
    file that is opened after mounting the filesystem.  It does this by
    allocating a 64-byte stack buffer, calling d_path() to grab the mount
    point through which this file was accessed, and then memcpy()ing 64
    bytes into the superblock's s_last_mounted field, starting from the
    return value of d_path(), which is stored as "cp".  However, if cp >
    buf (which it frequently is since path components are prepended
    starting at the end of buf) then we can end up copying stack data into
    the superblock.
    
    Writing stack variables into the superblock doesn't sound like a great
    idea, so use strlcpy instead.  Andi Kleen suggested using strlcpy
    instead of strncpy.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>

diff --git a/fs/ext4/file.c b/fs/ext4/file.c
index e4095e988eba..9781099337ec 100644
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@ -181,8 +181,8 @@ static int ext4_file_open(struct inode * inode, struct file * filp)
 		path.dentry = mnt->mnt_root;
 		cp = d_path(&path, buf, sizeof(buf));
 		if (!IS_ERR(cp)) {
-			memcpy(sbi->s_es->s_last_mounted, cp,
-			       sizeof(sbi->s_es->s_last_mounted));
+			strlcpy(sbi->s_es->s_last_mounted, cp,
+				sizeof(sbi->s_es->s_last_mounted));
 			ext4_mark_super_dirty(sb);
 		}
 	}

