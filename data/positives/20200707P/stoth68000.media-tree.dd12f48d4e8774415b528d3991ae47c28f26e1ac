commit dd12f48d4e8774415b528d3991ae47c28f26e1ac
Author: Bhavesh P. Davda <bhavesh@avaya.com>
Date:   Wed Aug 17 12:26:33 2005 -0600

    [PATCH] NPTL signal delivery deadlock fix
    
    This bug is quite subtle and only happens in a very interesting
    situation where a real-time threaded process is in the middle of a
    coredump when someone whacks it with a SIGKILL.  However, this deadlock
    leaves the system pretty hosed and you have to reboot to recover.
    
    Not good for real-time priority-preemption applications like our
    telephony application, with 90+ real-time (SCHED_FIFO and SCHED_RR)
    processes, many of them multi-threaded, interacting with each other for
    high volume call processing.
    
    Acked-by: Roland McGrath <roland@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/kernel/signal.c b/kernel/signal.c
index ca1186eef938..d282fea81138 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -692,7 +692,7 @@ static void handle_stop_signal(int sig, struct task_struct *p)
 {
 	struct task_struct *t;
 
-	if (p->flags & SIGNAL_GROUP_EXIT)
+	if (p->signal->flags & SIGNAL_GROUP_EXIT)
 		/*
 		 * The process is in the middle of dying already.
 		 */

