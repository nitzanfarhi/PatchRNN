commit e2eca69dc6c09d968d69312b9899968a9b03a4a9
Author: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
Date:   Thu Jul 17 11:44:14 2014 +0800

    Btrfs: fix wrong extent mapping for DirectIO
    
    btrfs_next_leaf() will use current leaf's last key to search
    and then return a bigger one. So it may still return a file extent
    item that is smaller than expected value and we will
    get an overflow here for @em->len.
    
    This is easy to reproduce for Btrfs Direct writting, it did not
    cause any problem, because writting will re-insert right mapping later.
    
    However, by hacking code to make DIO support compression, wrong extent
    mapping is kept and it encounter merging failure(EEXIST) quickly.
    
    Fix this problem by looping to find next file extent item that is bigger
    than @start or we could not find anything more.
    
    Signed-off-by: Wang Shilong <wangsl.fnst@cn.fujitsu.com>
    Reviewed-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Chris Mason <clm@fb.com>

diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c
index 73fadc7ead0e..a3c6e76f5a4e 100644
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -6275,6 +6275,8 @@ struct extent_map *btrfs_get_extent(struct inode *inode, struct page *page,
 			goto not_found;
 		if (start + len <= found_key.offset)
 			goto not_found;
+		if (start > found_key.offset)
+			goto next;
 		em->start = start;
 		em->orig_start = start;
 		em->len = found_key.offset - start;

