commit 7895086afde2a05fa24a0e410d8e6b75ca7c8fdd
Author: Mathias Nyman <mathias.nyman@linux.intel.com>
Date:   Mon Aug 3 16:07:48 2015 +0300

    xhci: fix off by one error in TRB DMA address boundary check
    
    We need to check that a TRB is part of the current segment
    before calculating its DMA address.
    
    Previously a ring segment didn't use a full memory page, and every
    new ring segment got a new memory page, so the off by one
    error in checking the upper bound was never seen.
    
    Now that we use a full memory page, 256 TRBs (4096 bytes), the off by one
    didn't catch the case when a TRB was the first element of the next segment.
    
    This is triggered if the virtual memory pages for a ring segment are
    next to each in increasing order where the ring buffer wraps around and
    causes errors like:
    
    [  106.398223] xhci_hcd 0000:00:14.0: ERROR Transfer event TRB DMA ptr not part of current TD ep_index 0 comp_code 1
    [  106.398230] xhci_hcd 0000:00:14.0: Looking for event-dma fffd3000 trb-start fffd4fd0 trb-end fffd5000 seg-start fffd4000 seg-end fffd4ff0
    
    The trb-end address is one outside the end-seg address.
    
    Cc: <stable@vger.kernel.org>
    Tested-by: Arkadiusz Mi≈õkiewicz <arekm@maven.pl>
    Signed-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 6a8fc52aed58..32f4d564494a 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -82,7 +82,7 @@ dma_addr_t xhci_trb_virt_to_dma(struct xhci_segment *seg,
 		return 0;
 	/* offset in TRBs */
 	segment_offset = trb - seg->trbs;
-	if (segment_offset > TRBS_PER_SEGMENT)
+	if (segment_offset >= TRBS_PER_SEGMENT)
 		return 0;
 	return seg->dma + (segment_offset * sizeof(*trb));
 }

