commit 16a5971d28ae3ac72a9e38b00d73162ec24d56a9
Author: wm4 <wm4@nowhere>
Date:   Mon Dec 22 12:45:43 2014 +0100

    vo_opengl_cb: free context on exit
    
    Minor memory leak.
    
    Actually, this also exposes some problems in the QtQuick example. This
    will have to be fixed in the example.

diff --git a/player/main.c b/player/main.c
index 52bbc97733..f9d860d193 100644
--- a/player/main.c
+++ b/player/main.c
@@ -152,6 +152,9 @@ void mp_destroy(struct MPContext *mpctx)
 
     mp_clients_destroy(mpctx);
 
+    talloc_free(mpctx->gl_cb_ctx);
+    mpctx->gl_cb_ctx = NULL;
+
     osd_free(mpctx->osd);
 
     if (cas_terminal_owner(mpctx, mpctx)) {
diff --git a/video/out/vo_opengl_cb.c b/video/out/vo_opengl_cb.c
index a6731c6a51..363b6a333f 100644
--- a/video/out/vo_opengl_cb.c
+++ b/video/out/vo_opengl_cb.c
@@ -79,10 +79,18 @@ struct mpv_opengl_cb_context {
     struct vo *active;
 };
 
+static void free_ctx(void *ptr)
+{
+    mpv_opengl_cb_context *ctx = ptr;
+
+    pthread_mutex_destroy(&ctx->lock);
+}
+
 struct mpv_opengl_cb_context *mp_opengl_create(struct mpv_global *g,
                                                struct osd_state *osd)
 {
     mpv_opengl_cb_context *ctx = talloc_zero(NULL, mpv_opengl_cb_context);
+    talloc_set_destructor(ctx, free_ctx);
     ctx->log = mp_log_new(ctx, g->log, "opengl-cb");
     pthread_mutex_init(&ctx->lock, NULL);
 

