commit 6c0db4664b49417d80988953e69c323721353227
Author: Hugh Dickins <hugh.dickins@tiscali.co.uk>
Date:   Tue Jun 16 15:31:50 2009 -0700

    mm: alloc_large_system_hash check order
    
    On an x86_64 with 4GB ram, tcp_init()'s call to alloc_large_system_hash(),
    to allocate tcp_hashinfo.ehash, is now triggering an mmotm WARN_ON_ONCE on
    order >= MAX_ORDER - it's hoping for order 11.  alloc_large_system_hash()
    had better make its own check on the order.
    
    Signed-off-by: Hugh Dickins <hugh.dickins@tiscali.co.uk>
    Cc: David Miller <davem@davemloft.net>
    Cc: Mel Gorman <mel@csn.ul.ie>
    Cc: Eric Dumazet <dada1@cosmosbay.com>
    Cc: Christoph Lameter <cl@linux.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index 7cc3179e3591..cbed869fd831 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -4511,7 +4511,10 @@ void *__init alloc_large_system_hash(const char *tablename,
 			table = __vmalloc(size, GFP_ATOMIC, PAGE_KERNEL);
 		else {
 			unsigned long order = get_order(size);
-			table = (void*) __get_free_pages(GFP_ATOMIC, order);
+
+			if (order < MAX_ORDER)
+				table = (void *)__get_free_pages(GFP_ATOMIC,
+								order);
 			/*
 			 * If bucketsize is not a power-of-two, we may free
 			 * some pages at the end of hash table.

