commit 175359f89df39f4faed663c8cfd6ee0222d2fa1e
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Thu Feb 11 13:13:10 2010 +0100

    reiserfs: Fix softlockup while waiting on an inode
    
    When we wait for an inode through reiserfs_iget(), we hold
    the reiserfs lock. And waiting for an inode may imply waiting
    for its writeback. But the inode writeback path may also require
    the reiserfs lock, which leads to a deadlock.
    
    We just need to release the reiserfs lock from reiserfs_iget()
    to fix this.
    
    Reported-by: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Tested-by: Christian Kujau <lists@nerdbynature.de>
    Cc: Chris Mason <chris.mason@oracle.com>

diff --git a/fs/reiserfs/inode.c b/fs/reiserfs/inode.c
index 9087b10209e6..2df0f5c7c60b 100644
--- a/fs/reiserfs/inode.c
+++ b/fs/reiserfs/inode.c
@@ -1497,9 +1497,11 @@ struct inode *reiserfs_iget(struct super_block *s, const struct cpu_key *key)
 
 	args.objectid = key->on_disk_key.k_objectid;
 	args.dirid = key->on_disk_key.k_dir_id;
+	reiserfs_write_unlock(s);
 	inode = iget5_locked(s, key->on_disk_key.k_objectid,
 			     reiserfs_find_actor, reiserfs_init_locked_inode,
 			     (void *)(&args));
+	reiserfs_write_lock(s);
 	if (!inode)
 		return ERR_PTR(-ENOMEM);
 

