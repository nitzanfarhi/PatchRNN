commit 2918d09c93b572660e7c47935409e8d93efba094
Author: dormando <dormando@rydia.net>
Date:   Tue Jan 23 22:15:35 2018 -0800

    quick fix for slab mover deadlock
    
    this fix may be replaced with a better restructuring; as this was done more
    properly in the result handler code below. Not releasing the slab lock while
    unlinking can cause a deadlock:
    
    item A unlinks, which locks LRU, then tries to lock SLAB
    page mover locks SLAB, locks item B, tries to unlink item B
    if done after A locks LRU, it deadlocks while B tries to lock LRU.
    
    doh :/

diff --git a/slabs.c b/slabs.c
index cedb1e8..6f59b17 100644
--- a/slabs.c
+++ b/slabs.c
@@ -862,7 +862,9 @@ static int slab_rebalance_move(void) {
                             // Only safe to hold slabs lock because refcount
                             // can't drop to 0 until we release item lock.
                             STORAGE_delete(storage, it);
+                            pthread_mutex_unlock(&slabs_lock);
                             do_item_unlink(it, hv);
+                            pthread_mutex_lock(&slabs_lock);
                         }
                         status = MOVE_BUSY;
                     } else {

