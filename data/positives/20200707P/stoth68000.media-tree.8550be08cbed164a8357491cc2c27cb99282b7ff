commit 8550be08cbed164a8357491cc2c27cb99282b7ff
Author: Seth Jennings <sjenning@linux.vnet.ibm.com>
Date:   Thu Oct 6 14:28:26 2011 -0500

    staging: zcache: fix crash on cpu remove
    
    In the case that a cpu is taken offline before zcache_do_preload() is
    ever called on the cpu, the per-cpu zcache_preloads structure will
    be uninitialized.  In the CPU_DEAD case for zcache_cpu_notifier(),
    kp->obj is not checked before calling kmem_cache_free() on it.
    If it is NULL, a crash results.
    
    This patch ensures that both kp->obj and kp->page are not NULL before
    calling the respective free functions. In practice, just checking
    one or the other should be sufficient since they are assigned together
    in zcache_do_preload(), but I check both for safety.
    
    Signed-off-by: Seth Jennings <sjenning@linux.vnet.ibm.com>
    Acked-by: Dave Hansen <dave@linux.vnet.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/zcache/zcache-main.c b/drivers/staging/zcache/zcache-main.c
index fbb400193e9e..dae2f4ee06a6 100644
--- a/drivers/staging/zcache/zcache-main.c
+++ b/drivers/staging/zcache/zcache-main.c
@@ -1357,8 +1357,14 @@ static int zcache_cpu_notifier(struct notifier_block *nb,
 			kp->objnodes[kp->nr - 1] = NULL;
 			kp->nr--;
 		}
-		kmem_cache_free(zcache_obj_cache, kp->obj);
-		free_page((unsigned long)kp->page);
+		if (kp->obj) {
+			kmem_cache_free(zcache_obj_cache, kp->obj);
+			kp->obj = NULL;
+		}
+		if (kp->page) {
+			free_page((unsigned long)kp->page);
+			kp->page = NULL;
+		}
 		break;
 	default:
 		break;

