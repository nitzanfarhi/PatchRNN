commit 2f42d612e7d4c4fb1819ea7b2b6e18938714ae7a
Author: Jie Liu <jeff.liu@oracle.com>
Date:   Wed Nov 20 16:08:53 2013 +0800

    xfs: don't perform discard if the given range length is less than block size
    
    For discard operation, we should return EINVAL if the given range length
    is less than a block size, otherwise it will go through the file system
    to discard data blocks as the end range might be evaluated to -1, e.g,
    # fstrim -v -o 0 -l 100 /xfs7
    /xfs7: 9811378176 bytes were trimmed
    
    This issue can be triggered via xfstests/generic/288.
    
    Also, it seems to get the request queue pointer via bdev_get_queue()
    instead of the hard code pointer dereference is not a bad thing.
    
    Signed-off-by: Jie Liu <jeff.liu@oracle.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Ben Myers <bpm@sgi.com>
    
    (cherry picked from commit f9fd0135610084abef6867d984e9951c3099950d)

diff --git a/fs/xfs/xfs_discard.c b/fs/xfs/xfs_discard.c
index 8367d6dc18c9..4f11ef011139 100644
--- a/fs/xfs/xfs_discard.c
+++ b/fs/xfs/xfs_discard.c
@@ -157,7 +157,7 @@ xfs_ioc_trim(
 	struct xfs_mount		*mp,
 	struct fstrim_range __user	*urange)
 {
-	struct request_queue	*q = mp->m_ddev_targp->bt_bdev->bd_disk->queue;
+	struct request_queue	*q = bdev_get_queue(mp->m_ddev_targp->bt_bdev);
 	unsigned int		granularity = q->limits.discard_granularity;
 	struct fstrim_range	range;
 	xfs_daddr_t		start, end, minlen;
@@ -180,7 +180,8 @@ xfs_ioc_trim(
 	 * matter as trimming blocks is an advisory interface.
 	 */
 	if (range.start >= XFS_FSB_TO_B(mp, mp->m_sb.sb_dblocks) ||
-	    range.minlen > XFS_FSB_TO_B(mp, XFS_ALLOC_AG_MAX_USABLE(mp)))
+	    range.minlen > XFS_FSB_TO_B(mp, XFS_ALLOC_AG_MAX_USABLE(mp)) ||
+	    range.len < mp->m_sb.sb_blocksize)
 		return -XFS_ERROR(EINVAL);
 
 	start = BTOBB(range.start);

