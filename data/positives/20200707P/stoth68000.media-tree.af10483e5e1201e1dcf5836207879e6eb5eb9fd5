commit af10483e5e1201e1dcf5836207879e6eb5eb9fd5
Author: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
Date:   Wed Oct 21 15:15:14 2015 -0500

    cxlflash: Fix to prevent stale AFU RRQ
    
    Following an adapter reset, the AFU RRQ that resides in host memory
    holds stale data. This can lead to a condition where the RRQ interrupt
    handler tries to process stale entries and/or endlessly loops due to an
    out of sync generation bit.
    
    To fix, the AFU RRQ in host memory needs to be cleared after each reset.
    
    Signed-off-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
    Signed-off-by: Manoj N. Kumar <manoj@linux.vnet.ibm.com>
    Reviewed-by: Brian King <brking@linux.vnet.ibm.com>
    Reviewed-by: Daniel Axtens <dja@axtens.net>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/cxlflash/main.c b/drivers/scsi/cxlflash/main.c
index eeb1c4798207..c77cb929dacb 100644
--- a/drivers/scsi/cxlflash/main.c
+++ b/drivers/scsi/cxlflash/main.c
@@ -1598,6 +1598,9 @@ static int start_afu(struct cxlflash_cfg *cfg)
 
 	init_pcr(cfg);
 
+	/* After an AFU reset, RRQ entries are stale, clear them */
+	memset(&afu->rrq_entry, 0, sizeof(afu->rrq_entry));
+
 	/* Initialize RRQ pointers */
 	afu->hrrq_start = &afu->rrq_entry[0];
 	afu->hrrq_end = &afu->rrq_entry[NUM_RRQ_ENTRY - 1];

