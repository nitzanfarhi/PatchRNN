commit ebf905fc7a6e7c99c53b5afc888d8f950da90aff
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Thu May 29 19:00:24 2014 +0200

    perf: Fix use after free in perf_remove_from_context()
    
    While that mutex should guard the elements, it doesn't guard against the
    use-after-free that's from list_for_each_entry_rcu().
    __perf_event_exit_task() can actually free the event.
    
    And because list addition/deletion is guarded by both ctx->mutex and
    ctx->lock, holding ctx->mutex is sufficient for reading the list, so we
    don't actually need the rcu list iteration.
    
    Fixes: 3a497f48637e ("perf: Simplify perf_event_exit_task_context()")
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Tested-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Dave Jones <davej@redhat.com>
    Cc: acme@ghostprotocols.net
    Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Link: http://lkml.kernel.org/r/20140529170024.GA2315@laptop.programming.kicks-ass.net
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/kernel/events/core.c b/kernel/events/core.c
index ed50b0943213..a62d142ad498 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -7431,7 +7431,7 @@ __perf_event_exit_task(struct perf_event *child_event,
 
 static void perf_event_exit_task_context(struct task_struct *child, int ctxn)
 {
-	struct perf_event *child_event;
+	struct perf_event *child_event, *next;
 	struct perf_event_context *child_ctx;
 	unsigned long flags;
 
@@ -7485,7 +7485,7 @@ static void perf_event_exit_task_context(struct task_struct *child, int ctxn)
 	 */
 	mutex_lock(&child_ctx->mutex);
 
-	list_for_each_entry_rcu(child_event, &child_ctx->event_list, event_entry)
+	list_for_each_entry_safe(child_event, next, &child_ctx->event_list, event_entry)
 		__perf_event_exit_task(child_event, child_ctx, child);
 
 	mutex_unlock(&child_ctx->mutex);

