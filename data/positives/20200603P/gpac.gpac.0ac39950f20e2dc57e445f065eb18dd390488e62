commit 0ac39950f20e2dc57e445f065eb18dd390488e62
Author: Jean Le Feuvre <jeanlf@users.sourceforge.net>
Date:   Fri Feb 1 07:25:37 2013 +0000

    Fixed memory leaks in DASH segmenter (live mode now stable) and improvements in DASH client
    
    git-svn-id: http://svn.code.sf.net/p/gpac/code/trunk/gpac@4289 63c20433-aa62-49bd-875c-5a186b69a8fb

diff --git a/applications/mp4box/main.c b/applications/mp4box/main.c
index a3f26d2e1..0d598499d 100644
--- a/applications/mp4box/main.c
+++ b/applications/mp4box/main.c
@@ -304,6 +304,7 @@ void PrintDASHUsage()
 			" -cprt string         adds copyright string to MPD\n"
 			" -dash-live[=F] dur   generates a live DASH session using dur segment duration, optionnally writing live context to F\n" 
 			"                       MP4Box will run the live session until \'q\' is pressed or a fatal error occurs.\n"
+			" -ddbg-live[=F] dur   same as -dash-live without time regulation for debug purposes.\n"
 			" -dash-ctx FILE       stores/restore DASH timing from FILE.\n"
 			" -dynamic             uses dynamic MPD type instead of static.\n"
 			" -mpd-refresh TIME    specifies MPD update time in seconds.\n"
@@ -1284,6 +1285,7 @@ enum
 	if (brand_add) gf_free(brand_add); \
 	if (brand_rem) gf_free(brand_rem); \
 	if (dash_inputs) gf_free(dash_inputs); \
+	gf_sys_close();	\
 	return __ret_code; \
 
 
@@ -1366,6 +1368,7 @@ int mp4boxMain(int argc, char **argv)
 	Bool daisy_chain_sidx=0;
 	Bool single_segment=0;
 	Bool single_file=0;
+	Bool segment_timeline=0;
 	GF_DashProfile dash_profile = GF_DASH_PROFILE_UNKNOWN;
 	Bool use_url_template=0;
 	Bool seg_at_rap=0;
@@ -1379,11 +1382,6 @@ int mp4boxMain(int argc, char **argv)
 	const char *dash_source = NULL;
 	const char *dash_more_info = NULL;
 
-	if (argc < 2) {
-		PrintUsage();
-		MP4BOX_EXIT_WITH_CODE(1);
-	}
-
 	nb_tsel_acts = nb_add = nb_cat = nb_track_act = nb_sdp_ex = max_ptime = raw_sample_num = nb_meta_act = rtp_rate = major_brand = nb_alt_brand_add = nb_alt_brand_rem = car_dur = minor_version = 0;
 	e = GF_OK;
 	split_duration = 0.0;
@@ -1425,6 +1423,26 @@ int mp4boxMain(int argc, char **argv)
 	swf_flatten_angle = 0.0f;
 	tmpdir = NULL;
 
+
+
+	for (i = 1; i < (u32) argc ; i++) {
+		if (!strcmp(argv[i], "-mem-track")) {
+#ifdef GPAC_MEMORY_TRACKING
+			enable_mem_tracker = 1;
+#else
+			fprintf(stderr, "WARNING - GPAC not compiled with Memory Tracker - ignoring \"-mem-track\"\n"); 
+#endif
+			break;
+		}
+	}
+
+	gf_sys_init(enable_mem_tracker);
+	if (argc < 2) {
+		PrintUsage();
+		MP4BOX_EXIT_WITH_CODE(1);
+	}
+
+
 	/*parse our args*/
 	for (i = 1; i < (u32) argc ; i++) {
 		arg = argv[i];
@@ -1457,6 +1475,8 @@ int mp4boxMain(int argc, char **argv)
 		else if (!stricmp(arg, "-version")) { PrintVersion(); MP4BOX_EXIT_WITH_CODE(0); }
 		else if (!stricmp(arg, "-sdp")) print_sdp = 1;
 		else if (!stricmp(arg, "-quiet")) quiet = 2;
+		else if (!strcmp(argv[i], "-mem-track")) continue;
+
 		else if (!stricmp(arg, "-logs")) {
 			CHECK_NEXT_ARG
 			gf_logs = argv[i+1];
@@ -1663,13 +1683,7 @@ int mp4boxMain(int argc, char **argv)
 		}
 		else if (!stricmp(arg, "-cprt")) { CHECK_NEXT_ARG cprt = argv[i+1]; i++; if (!dash_duration) open_edit = 1; }
 		else if (!stricmp(arg, "-chap")) { CHECK_NEXT_ARG chap_file = argv[i+1]; i++; open_edit = 1; }
-		else if (!strcmp(arg, "-mem-track")) {
-#ifdef GPAC_MEMORY_TRACKING
-			enable_mem_tracker = 1;
-#else
-			fprintf(stderr, "WARNING - GPAC not compiled with Memory Tracker - ignoring \"-mem-track\"\n"); 
-#endif
-		} else if (!strcmp(arg, "-strict-error")) {
+		else if (!strcmp(arg, "-strict-error")) {
 			gf_log_set_strict_error(1);
 		} else if (!stricmp(arg, "-inter") || !stricmp(arg, "-old-inter")) {
 			CHECK_NEXT_ARG
@@ -1779,8 +1793,9 @@ int mp4boxMain(int argc, char **argv)
 			if ((arg[13]=='=') && arg[14]) {
 				if (!strcmp( &arg[14], "simulate")) use_url_template = 2;
 			}
-		}		
-		else if (!stricmp(arg, "-itags")) { CHECK_NEXT_ARG itunes_tags = argv[i+1]; i++; open_edit = 1; }
+		} else if (!stricmp(arg, "-segment-timeline")) {
+			segment_timeline = 1;
+		} else if (!stricmp(arg, "-itags")) { CHECK_NEXT_ARG itunes_tags = argv[i+1]; i++; open_edit = 1; }
 #ifndef GPAC_DISABLE_ISOM_HINTING
 		else if (!stricmp(arg, "-hint")) { open_edit = 1; HintIt = 1; }
 		else if (!stricmp(arg, "-unhint")) { open_edit = 1; remove_hint = 1; }
@@ -2455,7 +2470,10 @@ int mp4boxMain(int argc, char **argv)
 	}
 
 	/*init libgpac*/
-	gf_sys_init(enable_mem_tracker);
+	if (enable_mem_tracker) {
+		gf_sys_close();
+		gf_sys_init(enable_mem_tracker);
+	}
 
 	if (gf_logs) {
 		gf_log_set_tools_levels(gf_logs);
@@ -2735,7 +2753,8 @@ int mp4boxMain(int argc, char **argv)
 		strcpy(szMPD, outfile);
 		strcat(szMPD, ".mpd");
 
-		fprintf(stderr, "Live DASH-ing - press 'q' to quit, 's' to save context and quit\n");
+		if (dash_dynamic)
+			fprintf(stderr, "Live DASH-ing - press 'q' to quit, 's' to save context and quit\n");
 
 		if (!dash_ctx_file && dash_live) {
 			dash_ctx = gf_cfg_new(NULL, NULL);
@@ -2759,9 +2778,10 @@ int mp4boxMain(int argc, char **argv)
 		}
 
 		while (!do_abort) {
+
 			e = gf_dasher_segment_files(szMPD, dash_inputs, nb_dash_inputs, dash_profile, dash_title, dash_source, cprt, dash_more_info,
 										(const char **) mpd_base_urls, nb_mpd_base_urls, 
-									   use_url_template, single_segment, single_file, bitstream_switching_mode, 
+									   use_url_template, segment_timeline,  single_segment, single_file, bitstream_switching_mode,
 									   seg_at_rap, dash_duration, seg_name, seg_ext,
 									   interleaving_time, subsegs_per_sidx, daisy_chain_sidx, frag_at_rap, tmpdir,
 									   dash_ctx, dash_dynamic, mpd_update_time, time_shift_depth, dash_subduration, min_buffer, ast_shift_sec);
@@ -2776,11 +2796,14 @@ int mp4boxMain(int argc, char **argv)
 						if (c=='q') { do_abort = 1; break; }
 						if (c=='s') { do_abort = 2; break; }
 					}
-					if (sleep_for<100) break;
 
-					if (dash_dynamic != 2) {
-						gf_sleep(100);
+					if (dash_dynamic == 2) {
+						break;
 					}
+					if (sleep_for<100) 
+						break;
+					gf_sleep(100);
+
 					sleep_for = gf_dasher_next_update_time(dash_ctx, mpd_update_time);
 				}
 			} else {
@@ -2801,7 +2824,6 @@ int mp4boxMain(int argc, char **argv)
 		}
 		if (e) fprintf(stderr, "Error DASHing file: %s\n", gf_error_to_string(e));
 
-		gf_sys_close();
 		MP4BOX_EXIT_WITH_CODE( (e!=GF_OK) ? 1 : 0 );
 	}
 
@@ -3134,7 +3156,6 @@ int mp4boxMain(int argc, char **argv)
 	}
 	if (!open_edit && !needSave) {
 		if (file) gf_isom_delete(file);
-		gf_sys_close();
 		MP4BOX_EXIT_WITH_CODE(0);
 	}
 
@@ -3198,7 +3219,6 @@ int mp4boxMain(int argc, char **argv)
 	if (!encode) {
 		if (!file) {
 			fprintf(stderr, "Nothing to do - exiting\n");
-			gf_sys_close();
 			MP4BOX_EXIT_WITH_CODE(0);
 		}
 		if (outName) {
@@ -3543,7 +3563,6 @@ int mp4boxMain(int argc, char **argv)
 			if (gf_delete_file(inName)) fprintf(stderr, "Error removing file %s\n", inName);
 			else if (gf_move_file(outfile, inName)) fprintf(stderr, "Error renaming file %s to %s\n", outfile, inName);
 		}
-		gf_sys_close();
 		MP4BOX_EXIT_WITH_CODE( (e!=GF_OK) ? 1 : 0 );
 	}
 #endif
@@ -3659,21 +3678,17 @@ int mp4boxMain(int argc, char **argv)
 	} else {
 		gf_isom_delete(file);
 	}
-	/*close libgpac*/
-	gf_sys_close();
 
 	if (e) fprintf(stderr, "Error: %s\n", gf_error_to_string(e));
 	MP4BOX_EXIT_WITH_CODE( (e!=GF_OK) ? 1 : 0 );
 #else
 	/*close libgpac*/
-	gf_sys_close();
 	gf_isom_delete(file);
 	fprintf(stderr, "Error: Read-only version of MP4Box.\n");
 	MP4BOX_EXIT_WITH_CODE(1);
 #endif
 err_exit:
 	/*close libgpac*/
-	gf_sys_close();
 	if (file) gf_isom_delete(file);		
 	fprintf(stderr, "\n\tError: %s\n", gf_error_to_string(e));
 	MP4BOX_EXIT_WITH_CODE(1);
diff --git a/include/gpac/dash.h b/include/gpac/dash.h
index 828ea7d64..b1f7af632 100644
--- a/include/gpac/dash.h
+++ b/include/gpac/dash.h
@@ -57,6 +57,9 @@ typedef enum
 	GF_DASH_EVENT_CREATE_PLAYBACK,
 	/*event sent when reseting groups at period switch or at exit - user should unload playback chain(s) at this point*/
 	GF_DASH_EVENT_DESTROY_PLAYBACK,
+
+	GF_DASH_EVENT_BUFFERING,
+	GF_DASH_EVENT_BUFFER_DONE,
 } GF_DASHEventType;
 
 /*structure used for all IO operations for DASH*/
@@ -125,7 +128,8 @@ GF_DashClient *gf_dash_new(GF_DASHFileIO *dash_io,
 						   u32 auto_switch_count, 
 						   Bool keep_files, 
 						   Bool disable_switching, 
-						   GF_DASHInitialSelectionMode first_select_mode);
+						   GF_DASHInitialSelectionMode first_select_mode,
+						   Bool enable_buffering);
 
 /*delete the DASH client*/
 void gf_dash_del(GF_DashClient *dash);
@@ -223,6 +227,7 @@ void gf_dash_allow_local_mpd_update(GF_DashClient *dash, Bool allow_local_mpd_up
 /*gets media info for representation*/
 GF_Err gf_dash_group_get_representation_info(GF_DashClient *dash, u32 idx, u32 representation_idx, u32 *width, u32 *height, u32 *audio_samplerate, u32 *bandwidth, const char **codecs);
 
+void gf_dash_get_buffer_info_buffering(GF_DashClient *dash, u32 *total_buffer, u32 *media_buffered);
 
 #endif //GPAC_DISABLE_DASH_CLIENT
 
diff --git a/include/gpac/internal/media_dev.h b/include/gpac/internal/media_dev.h
index daf53d203..f3f4169d6 100644
--- a/include/gpac/internal/media_dev.h
+++ b/include/gpac/internal/media_dev.h
@@ -410,7 +410,7 @@ typedef enum
 	GF_DASH_TEMPLATE_REPINDEX,
 } GF_DashTemplateSegmentType;
 
-GF_Err gf_media_mpd_format_segment_name(GF_DashTemplateSegmentType seg_type, Bool is_bs_switching, char *segment_name, const char *output_file_name, const char *rep_id, const char *seg_rad_name, const char *seg_ext, u64 start_time, u32 bandwidth, u32 segment_number);
+GF_Err gf_media_mpd_format_segment_name(GF_DashTemplateSegmentType seg_type, Bool is_bs_switching, char *segment_name, const char *output_file_name, const char *rep_id, const char *seg_rad_name, const char *seg_ext, u64 start_time, u32 bandwidth, u32 segment_number, Bool use_segment_timeline);
 
 #endif		/*_GF_MEDIA_DEV_H_*/
 
diff --git a/include/gpac/media_tools.h b/include/gpac/media_tools.h
index bfbcea641..7d25dc67c 100644
--- a/include/gpac/media_tools.h
+++ b/include/gpac/media_tools.h
@@ -296,7 +296,7 @@ typedef enum
 GF_Err gf_dasher_segment_files(const char *mpd_name, GF_DashSegmenterInput *inputs, u32 nb_inputs, GF_DashProfile profile, 
 							   const char *mpd_title, const char *mpd_source, const char *mpd_copyright,
 							   const char *mpd_moreInfoURL, const char **mpd_base_urls, u32 nb_mpd_base_urls, 
-							   Bool use_url_template, Bool single_segment, Bool single_file, GF_DashSwitchingMode bitstream_switching_mode,
+							   Bool use_url_template, Bool use_segment_timeline,  Bool single_segment, Bool single_file, GF_DashSwitchingMode bitstream_switching_mode,
 							   Bool segments_start_with_rap, Double dash_duration_sec, char *seg_rad_name, char *seg_ext,
 							   Double frag_duration_sec, s32 subsegs_per_sidx, Bool daisy_chain_sidx, Bool fragments_start_with_rap, const char *tmp_dir,  
 							   GF_Config *dash_ctx, u32 dash_dynamic, u32 mpd_update_time, u32 time_shift_depth, Double subduration, Double min_buffer, u32 ast_shift_sec);
diff --git a/modules/mpd_in/mpd_in.c b/modules/mpd_in/mpd_in.c
index 689092c27..de80bbb46 100644
--- a/modules/mpd_in/mpd_in.c
+++ b/modules/mpd_in/mpd_in.c
@@ -152,10 +152,14 @@ static GF_Err MPD_ClientQuery(GF_InputService *ifce, GF_NetworkCommand *param)
 			return GF_SERVICE_ERROR;
 		}
 
+		if (discard_first_cache_entry) {
+			gf_dash_group_discard_segment(mpdin->dash, group_idx);
+		}
+
 		while (gf_dash_is_running(mpdin->dash) ) {
 			group_done=0;
 			nb_segments_cached = gf_dash_group_get_num_segments_ready(mpdin->dash, group_idx, &group_done);
-			if (nb_segments_cached>=2) 
+			if (nb_segments_cached>=1) 
 				break;
 
 			if (group_done) {
@@ -178,17 +182,13 @@ static GF_Err MPD_ClientQuery(GF_InputService *ifce, GF_NetworkCommand *param)
         }
 	
 		nb_segments_cached = gf_dash_group_get_num_segments_ready(mpdin->dash, group_idx, &group_done);
-        if (nb_segments_cached < 2) {
+        if (nb_segments_cached < 1) {
             GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[MPD_IN] No more file in cache, EOS\n"));
             return GF_EOS;
         } else {
             GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[MPD_IN] Had to wait for %u ms for the only cache file to be downloaded\n", (gf_sys_clock() - timer)));
         }
 
-		if (discard_first_cache_entry) {
-			gf_dash_group_discard_segment(mpdin->dash, group_idx);
-		}
-
 		gf_dash_group_get_next_segment_location(mpdin->dash, group_idx, &param->url_query.next_url, &param->url_query.start_range, &param->url_query.end_range, 
 								NULL, &param->url_query.next_url_init_or_switch_segment, &param->url_query.switch_start_range , &param->url_query.switch_end_range,
 								&src_url);
@@ -467,8 +467,14 @@ GF_Err mpdin_dash_io_on_dash_event(GF_DASHFileIO *dashio, GF_DASHEventType dash_
 			gf_dash_set_group_udta(mpdin->dash, i, NULL);
 		}
 		mpdin->service->subservice_disconnect = 0;
+		return GF_OK;
 	}
 
+	if (dash_evt==GF_DASH_EVENT_BUFFERING) {
+		u32 tot, done;
+		gf_dash_get_buffer_info_buffering(mpdin->dash, &tot, &done);
+		fprintf(stderr, "DASH: Buffering %g%% out of %d ms\n", (100.0*done)/tot, tot);
+	}
 	return GF_OK;
 }
 
@@ -480,7 +486,7 @@ GF_Err MPD_ConnectService(GF_InputService *plug, GF_ClientService *serv, const c
     GF_Err e;
 	u32 max_cache_duration, auto_switch_count;
 	GF_DASHInitialSelectionMode first_select_mode;
-	Bool keep_files, disable_switching;
+	Bool keep_files, disable_switching, enable_buffering;
 
     GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[MPD_IN] Received Service Connection request (%p) from terminal for %s\n", serv, url));
 
@@ -546,11 +552,14 @@ GF_Err MPD_ConnectService(GF_InputService *plug, GF_ClientService *serv, const c
 	if (!opt) gf_modules_set_option((GF_BaseInterface *)plug, "DASH", "ImmediateSwitching", "no");
 	mpdin->immediate_switch = (opt && !strcmp(opt, "yes")) ? 1 : 0;
 	
-	
+	opt = gf_modules_get_option((GF_BaseInterface *)plug, "DASH", "EnableBuffering");
+	if (!opt) gf_modules_set_option((GF_BaseInterface *)plug, "DASH", "EnableBuffering", "yes");
+	enable_buffering = (opt && !strcmp(opt, "yes")) ? 1 : 0;
+
 	mpdin->in_seek = 0;
 	mpdin->previous_start_range = -1;
 
-	mpdin->dash = gf_dash_new(&mpdin->dash_io, max_cache_duration, auto_switch_count, keep_files, disable_switching, first_select_mode);
+	mpdin->dash = gf_dash_new(&mpdin->dash_io, max_cache_duration, auto_switch_count, keep_files, disable_switching, first_select_mode, enable_buffering);
 
 	if (!mpdin->dash) {
         GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[MPD_IN] Error - cannot create DASH Client for %s\n", url));
diff --git a/src/compositor/audio_input.c b/src/compositor/audio_input.c
index 475d40394..5728d2f97 100644
--- a/src/compositor/audio_input.c
+++ b/src/compositor/audio_input.c
@@ -81,7 +81,7 @@ static char *gf_audio_input_fetch_frame(void *callback, u32 *size, u32 audio_del
 #ifdef ENABLE_EARLY_FRAME_DETECTION
 	/*too early (silence insertions), skip*/
 	if (drift < 0) {
-		GF_LOG(GF_LOG_INFO, GF_LOG_AUDIO, ("[Audio Input] audio too early of %d (CTS %d at OTB %d with audio delay %d ms)\n", drift + audio_delay_ms, ts, obj_time, audio_delay_ms));
+		GF_LOG(GF_LOG_INFO, GF_LOG_AUDIO, ("[Audio Input] audio too early of %d (CTS %u at OTB %u with audio delay %d ms)\n", drift + audio_delay_ms, ts, obj_time, audio_delay_ms));
 		ai->need_release = 0;
 		gf_mo_release_data(ai->stream, 0, 0);
 		return NULL;
diff --git a/src/export.cpp b/src/export.cpp
index d075e1fbd..4afb1d1d1 100644
--- a/src/export.cpp
+++ b/src/export.cpp
@@ -1744,6 +1744,7 @@
 #pragma comment (linker, EXPORT_SYMBOL(gf_dash_group_get_presentation_time_offset) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_dash_group_get_video_info) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_dash_group_get_representation_info) )
+#pragma comment (linker, EXPORT_SYMBOL(gf_dash_get_buffer_info_buffering) )
 
 #pragma comment (linker, EXPORT_SYMBOL(gf_media_hevc_read_vps) )
 #pragma comment (linker, EXPORT_SYMBOL(gf_media_hevc_read_sps) )
diff --git a/src/isomedia/data_map.c b/src/isomedia/data_map.c
index 298c3cb89..3cf068e28 100644
--- a/src/isomedia/data_map.c
+++ b/src/isomedia/data_map.c
@@ -179,38 +179,44 @@ GF_Err gf_isom_datamap_open(GF_MediaBox *mdia, u32 dataRefIndex, u8 Edit)
 {
 	GF_DataEntryBox *ent;
 	GF_MediaInformationBox *minf;
-	u32 SelfCont;
+	u32 SelfCont, count;
 	GF_Err e = GF_OK;
 	if ((mdia == NULL) || (! mdia->information) || !dataRefIndex)
 		return GF_ISOM_INVALID_MEDIA;
 
 	minf = mdia->information;
 
-	if (dataRefIndex > gf_list_count(minf->dataInformation->dref->other_boxes))
-		return GF_BAD_PARAM;
+	count = gf_list_count(minf->dataInformation->dref->other_boxes);
+	if (!count) {
+		SelfCont = 1;
+	} else {
+		if (dataRefIndex > gf_list_count(minf->dataInformation->dref->other_boxes))
+			return GF_BAD_PARAM;
 
-	ent = (GF_DataEntryBox*)gf_list_get(minf->dataInformation->dref->other_boxes, dataRefIndex - 1);
-	if (ent == NULL) return GF_ISOM_INVALID_MEDIA;
+		ent = (GF_DataEntryBox*)gf_list_get(minf->dataInformation->dref->other_boxes, dataRefIndex - 1);
+		if (ent == NULL) return GF_ISOM_INVALID_MEDIA;
 
-	//if the current dataEntry is the desired one, and not self contained, return
-	if ((minf->dataEntryIndex == dataRefIndex) && (ent->flags != 1)) {
-		return GF_OK;
+		//if the current dataEntry is the desired one, and not self contained, return
+		if ((minf->dataEntryIndex == dataRefIndex) && (ent->flags != 1)) {
+			return GF_OK;
+		}
+
+		SelfCont = 0;
+		switch (ent->type) {
+		case GF_ISOM_BOX_TYPE_URL:
+		case GF_ISOM_BOX_TYPE_URN:
+			if (ent->flags == 1) SelfCont = 1;
+			break;
+		default:
+			SelfCont = 1;
+			break;
+		}
 	}
 
 	//we need to open a new one
 	//first close the existing one
 	if (minf->dataHandler) gf_isom_datamap_close(minf);
 
-	SelfCont = 0;
-	switch (ent->type) {
-	case GF_ISOM_BOX_TYPE_URL:
-	case GF_ISOM_BOX_TYPE_URN:
-		if (ent->flags == 1) SelfCont = 1;
-		break;
-	default:
-		SelfCont = 1;
-		break;
-	}
 	//if self-contained, assign the input file
 	if (SelfCont) {
 		//if no edit, open the input file
@@ -408,7 +414,8 @@ void gf_isom_fdm_del(GF_FileDataMap *ptr)
 {
 	if (!ptr || (ptr->type != GF_ISOM_DATA_FILE)) return;
 	if (ptr->bs) gf_bs_del(ptr->bs);
-	if (ptr->stream && !ptr->is_stdout) fclose(ptr->stream);
+	if (ptr->stream && !ptr->is_stdout)
+		fclose(ptr->stream);
 
 #ifndef GPAC_DISABLE_ISOM_WRITE
 	if (ptr->temp_file) {
diff --git a/src/isomedia/isom_write.c b/src/isomedia/isom_write.c
index 587f9c0e7..c5b9294eb 100644
--- a/src/isomedia/isom_write.c
+++ b/src/isomedia/isom_write.c
@@ -2405,6 +2405,8 @@ GF_Err gf_isom_clone_movie(GF_ISOFile *orig_file, GF_ISOFile *dest_file, Bool cl
 		orig_file->moov->trackList = old_tracks;
 		gf_list_del(tracks);
 		orig_file->moov->iods = (GF_ObjectDescriptorBox*)iods;
+		gf_list_add(dest_file->TopBoxes, dest_file->moov);
+
 		if (clone_tracks) { 
 			for (i=0; i<gf_list_count(orig_file->moov->trackList); i++) {
 				GF_TrackBox *trak = gf_list_get( orig_file->moov->trackList, i);
diff --git a/src/media_tools/dash_client.c b/src/media_tools/dash_client.c
index b2b47137e..ad4a0d6da 100644
--- a/src/media_tools/dash_client.c
+++ b/src/media_tools/dash_client.c
@@ -40,6 +40,8 @@
 /*set to 1 if you want MPD to use SegmentTemplate if possible instead of SegmentList*/
 #define M3U8_TO_MPD_USE_TEMPLATE	0
 
+/*uncomment to only play the first representation set*/
+//#define DEBUG_FIRST_SET_ONLY
 
 typedef enum {
 	GF_DASH_STATE_STOPPED = 0,
@@ -64,9 +66,10 @@ struct __dash_client
 
 	u32 max_cache_duration;
 	u32 auto_switch_count;
-	Bool keep_files, disable_switching, allow_local_mpd_update;
+	Bool keep_files, disable_switching, allow_local_mpd_update, enable_buffering;
 	Bool is_m3u8;
 
+	u64 mpd_fetch_time;
 	GF_DASHInitialSelectionMode first_select_mode;
 
 	/* MPD downloader*/
@@ -86,6 +89,8 @@ struct __dash_client
 
 	u64 start_time_in_active_period;
 
+	Bool ignore_mpd_duration;
+
 	/*list of groups in the active period*/
 	GF_List *groups;
 
@@ -99,6 +104,7 @@ struct __dash_client
 	Bool mpd_stop_request;
 	Bool in_period_setup;
 
+	u32 nb_buffering;
 
 	/* TODO - handle playback status for SPEED/SEEK through SIDX */
 	Double playback_start_range;
@@ -116,6 +122,7 @@ typedef struct
 	/*representation index in adaptation_set->representations*/
 	u32 representation_index;
 	Bool do_not_delete;
+	u32 duration;
 } segment_cache_entry;
 
 typedef enum
@@ -156,6 +163,9 @@ struct __dash_group
 	u32 nb_segments_in_rep;
 	Double segment_duration;
 
+	/*for debug purpose of templates only*/
+	u32 start_number;
+
 	Bool was_segment_base;
 	/*local file playback, do not delete them*/
 	Bool local_files;
@@ -164,6 +174,8 @@ struct __dash_group
 	/*number of segments pruged since the start of the period*/
 	u32 nb_segments_purged;
 
+	u32 nb_retry_on_last_segment;
+
 	/*next file (cached) to delete at next GF_NET_SERVICE_QUERY_NEXT for this group*/
 	char * urlToDeleteNext;
 	volatile u32 max_cached_segments, nb_cached_segments;
@@ -176,9 +188,13 @@ struct __dash_group
 	u64 local_url_start_range, local_url_end_range;
 
 	u32 nb_segments_done;
+	u32 last_segment_time;
 
 	Bool segment_must_be_streamed;
 	Bool broken_timing;
+	Bool buffering;
+	Bool maybe_end_of_stream;
+	u32 cache_duration;
 
 	u32 force_representation_idx_plus_one;
 
@@ -200,6 +216,68 @@ static const char *gf_dash_get_mime_type(GF_MPD_SubRepresentation *subrep, GF_MP
 	return NULL;
 }
 
+static void gf_dash_buffer_off(GF_DASH_Group *group, GF_DashClient *dash) 
+{
+	if (!dash->enable_buffering) return;
+	if (group->buffering) { 
+		assert(dash->nb_buffering); 
+		dash->nb_buffering--;	
+		if (!dash->nb_buffering) {
+			dash->dash_io->on_dash_event(dash->dash_io, GF_DASH_EVENT_BUFFER_DONE, GF_OK); 
+			GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[DASH] Session buffering done\n"));
+		}
+		group->buffering = 0;
+	} 
+}
+
+static void gf_dash_buffer_on(GF_DASH_Group *group, GF_DashClient *dash) 
+{
+	if (!dash->enable_buffering) return;
+	if ((group->selection==GF_DASH_GROUP_SELECTED) && !group->buffering) {
+		if (!dash->nb_buffering) {
+			GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[DASH] Starting session buffering\n"));
+		}
+		dash->nb_buffering++; 
+		group->buffering = 1;
+	}
+}
+
+
+void gf_dash_get_buffer_info_buffering(GF_DashClient *dash, u32 *total_buffer, u32 *media_buffered)
+{
+	if (dash->nb_buffering) {
+		u32 i, j, nb_groups;
+		*total_buffer = 0;
+		*media_buffered = 0;
+		nb_groups = gf_list_count(dash->groups);
+		for (i=0; i<nb_groups; i++) {
+			GF_DASH_Group *group = gf_list_get(dash->groups, i);
+			if (group->buffering) {
+				u32 buffer = 0;
+				*total_buffer += group->cache_duration;
+				for (j=0; j<group->nb_cached_segments; j++) {
+					buffer += group->cached[i].duration;
+				}
+				if (buffer>group->cache_duration) buffer = group->cache_duration;
+				*media_buffered += buffer;
+			}
+		}
+		*total_buffer /= dash->nb_buffering;
+		*media_buffered /= dash->nb_buffering;
+	}
+}
+
+static void gf_dash_update_buffering(GF_DASH_Group *group, GF_DashClient *dash)
+{
+	if (dash->nb_buffering) {
+		dash->dash_io->on_dash_event(dash->dash_io, GF_DASH_EVENT_BUFFERING, GF_OK);
+
+		if (group->nb_cached_segments>=group->max_cached_segments) 
+			gf_dash_buffer_off(group, dash);
+	}
+}
+
+
 GF_EXPORT
 Bool gf_dash_check_mpd_root_type(const char *local_url)
 {
@@ -219,19 +297,19 @@ Bool gf_dash_check_mpd_root_type(const char *local_url)
 
 static u64 gf_dash_get_utc_clock()
 {
+	u64 current_time;
 	u32 sec, frac;
 
 #ifndef _WIN32_WCE
 	time_t gtime;
-	struct tm *_t;
+	struct tm _t;
 #endif
-	u64 current_time;
 
 	gf_net_get_ntp(&sec, &frac);
 
 #ifndef _WIN32_WCE
 	gtime = sec - GF_NTP_SEC_1900_TO_1970;
-	_t = gmtime(&gtime);
+	_t = * gmtime(&gtime);
 
 #ifdef GPAC_ANDROID
 	{
@@ -244,15 +322,19 @@ static u64 gf_dash_get_utc_clock()
 	t_local = *localtime(&t_time);
 	
 	t_timezone = (t_gmt.tm_hour - t_local.tm_hour) * 3600;
-	current_time = mktime(_t) - t_timezone;
+	current_time = mktime(&_t) - t_timezone;
 	}
 #else
-	current_time = mktime(_t) - timezone;
+	{
+		s32 val = timezone;
+		current_time = mktime(&_t) - val;
+	}
 #endif
 
 #else
 	current_time = sec - GF_NTP_SEC_1900_TO_1970;
 #endif
+
 	return current_time;
 }
 
@@ -270,10 +352,17 @@ static void gf_dash_group_timeline_setup(GF_MPD *mpd, GF_DASH_Group *group)
 	if (group->dash->is_m3u8)
 		return;
 
-	current_time = gf_dash_get_utc_clock();
+	current_time = group->dash->mpd_fetch_time;
+
+	{
+		struct tm t1, t2;
+		t1 = * gmtime(&current_time);
+		t2 = * gmtime(&mpd->availabilityStartTime);
+		t1.tm_year = t2.tm_year;
+	}
 
 	if (current_time < mpd->availabilityStartTime) current_time = 0;
-	else current_time -= mpd->availabilityStartTime;
+	else current_time -= mpd->availabilityStartTime;	
 
 	if (current_time < group->period->start/1000) current_time = 0;
 	else current_time -= group->period->start/1000;
@@ -357,11 +446,19 @@ static void gf_dash_group_timeline_setup(GF_MPD *mpd, GF_DASH_Group *group)
 	}
 
 	if (group->segment_duration) {
+		u32 nb_segs_in_update = (u32) (mpd->minimum_update_period / (1000*group->segment_duration) );
 		Double nb_seg = (Double) current_time;
 		nb_seg /= group->segment_duration;
 		shift = (u32) nb_seg;
 		group->download_segment_index = shift;
-		group->nb_segments_in_rep = shift + 10;
+
+		GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] UTC time indicates first segment in period is %d, MPD indicates %d segments are available ...\n", group->download_segment_index , group->nb_segments_in_rep));
+
+		if (group->nb_segments_in_rep && (group->download_segment_index + nb_segs_in_update > group->nb_segments_in_rep)) {
+			GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[DASH] Not enough segments (%d needed vs %d indicated) to reach period endTime indicated in MPD - ignoring MPD duration\n", nb_segs_in_update, group->nb_segments_in_rep - group->download_segment_index ));
+			group->nb_segments_in_rep = shift + nb_segs_in_update;
+			group->dash->ignore_mpd_duration = 1;
+		}
 	} else {
 		GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Segment duration unknown - cannot estimate current startNumber\n"));
 	}
@@ -372,6 +469,10 @@ void gf_dash_group_check_switch(GF_DASHFileIO *dash_io, GF_DASH_Group *group, Bo
 	u32 download_rate;
 
 	if (group->dash->disable_switching) return;
+
+/*	if (group->min_bandwidth_selected && group->buffering)
+		return;
+*/
 	download_rate = dash_io->get_bytes_per_sec(dash_io, group->segment_download);
 	if (!download_rate) return;
 
@@ -706,8 +807,10 @@ static Double gf_dash_get_segment_start_time(GF_DASH_Group *group, Double *segme
 	set = group->adaptation_set;
 	period = group->period;
 	segment_index = 0;
-	if (group->download_segment_index >= group->nb_cached_segments)
-		segment_index = group->download_segment_index - group->nb_cached_segments;
+	if (group->download_segment_index >= group->nb_cached_segments) {
+//		segment_index = group->download_segment_index - group->nb_cached_segments;
+		segment_index = group->download_segment_index;
+	}
 
 	/*single segment: return nothing*/
 	if (rep->segment_base || set->segment_base || period->segment_base) {
@@ -748,16 +851,19 @@ static Double gf_dash_get_segment_start_time(GF_DASH_Group *group, Double *segme
 		if (period->segment_template->duration) duration = period->segment_template->duration;
 		if (period->segment_template->timescale) timescale = period->segment_template->timescale;
 		if (period->segment_template->segment_timeline) timeline = period->segment_template->segment_timeline;
+		if (period->segment_template->start_number) group->start_number = period->segment_template->start_number;
 	}
 	if (set->segment_template) {
 		if (set->segment_template->duration) duration = set->segment_template->duration;
 		if (set->segment_template->timescale) timescale = set->segment_template->timescale;
 		if (set->segment_template->segment_timeline) timeline = set->segment_template->segment_timeline;
+		if (set->segment_template->start_number) group->start_number = set->segment_template->start_number;
 	}
 	if (rep->segment_template) {
 		if (rep->segment_template->duration) duration = rep->segment_template->duration;
 		if (rep->segment_template->timescale) timescale = rep->segment_template->timescale;
 		if (rep->segment_template->segment_timeline) timeline = rep->segment_template->segment_timeline;
+		if (rep->segment_template->start_number) group->start_number = rep->segment_template->start_number;
 	}
 	if (!timescale) timescale=1;
 
@@ -775,10 +881,11 @@ static Double gf_dash_get_segment_start_time(GF_DASH_Group *group, Double *segme
 	return start_time;
 }
 
-u64 gf_dash_get_segment_availability_start_time(GF_MPD *mpd, GF_DASH_Group *group, u32 segment_index)
+u64 gf_dash_get_segment_availability_start_time(GF_MPD *mpd, GF_DASH_Group *group, u32 segment_index, u32 *seg_dur_ms)
 {
 	Double seg_ast, seg_dur;
 	seg_ast = gf_dash_get_segment_start_time(group, &seg_dur);
+	if (seg_dur_ms) *seg_dur_ms = (u32) (seg_dur * 1000);
 
 	seg_ast += seg_dur;
 	seg_ast += group->period->start/1000;
@@ -968,11 +1075,15 @@ static GF_Err gf_dash_update_manifest(GF_DashClient *dash)
 {
 	GF_Err e;
 	u32 group_idx, rep_idx, i, j;
+	u64 fetch_time=0;
 	GF_DOMParser *mpd_parser;
+	u8 signature[sizeof(dash->lastMPDSignature)];
 	GF_MPD_Period *period, *new_period;
 	const char *local_url;
 	char mime[128];
 	char * purl;
+	Double timeline_start_time;
+	GF_MPD *new_mpd;
 
 	if (!dash->mpd_dnload) {
 		local_url = purl = NULL;
@@ -1045,247 +1156,294 @@ static GF_Err gf_dash_update_manifest(GF_DashClient *dash)
 		gf_free(purl);
 		purl = NULL;
 	}
+	fetch_time = gf_dash_get_utc_clock();
 
 	if (!gf_dash_check_mpd_root_type(local_url)) {
 		GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error - cannot update playlist: MPD file type is not correct %s\n", local_url));
 		return GF_NON_COMPLIANT_BITSTREAM;
 	}
-	{
-		u8 signature[sizeof(dash->lastMPDSignature)];
-		if (gf_sha1_file( local_url, signature)) {
-			GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] : cannot SHA1 file %s\n", local_url));
+
+	if (gf_sha1_file( local_url, signature)) {
+		GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] : cannot SHA1 file %s\n", local_url));
+		return GF_IO_ERR;
+	} 
+
+	if (! memcmp( signature, dash->lastMPDSignature, sizeof(dash->lastMPDSignature))) {
+		dash->reload_count++;
+		GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] MPD file did not change for %d consecutive reloads\n", dash->reload_count));
+		/*if the MPD did not change, we should refresh "soon" but cannot wait a full refresh cycle in case of 
+		low latencies as we could miss a segment*/
+
+		if (dash->is_m3u8) {
+			dash->last_update_time += dash->mpd->minimum_update_period/2;
 		} else {
-			if (! memcmp( signature, dash->lastMPDSignature, sizeof(dash->lastMPDSignature))) {
-				dash->reload_count++;
-				GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] MPD file did not change for %d consecutive reloads\n", dash->reload_count));
-				/*if the MPD did not change, we should refresh "soon" but cannot wait a full refresh cycle in case of 
-				low latencies as we could miss a segment*/
-				dash->last_update_time += dash->mpd->minimum_update_period/2;
-			} else {
-				Double timeline_start_time;
-				GF_MPD *new_mpd;
-				dash->reload_count = 0;
-				memccpy(dash->lastMPDSignature, signature, sizeof(char), sizeof(dash->lastMPDSignature));
-
-				/* It means we have to reparse the file ... */
-				/* parse the MPD */
-				mpd_parser = gf_xml_dom_new();
-				e = gf_xml_dom_parse(mpd_parser, local_url, NULL, NULL);
-				if (e != GF_OK) {
-					gf_xml_dom_del(mpd_parser);
-					GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error - cannot update playlist: error in XML parsing %s\n", gf_error_to_string(e)));
-					return GF_NON_COMPLIANT_BITSTREAM;
-				}
-				new_mpd = gf_mpd_new();
-				e = gf_mpd_init_from_dom(gf_xml_dom_get_root(mpd_parser), new_mpd, purl);
-				gf_xml_dom_del(mpd_parser);
-				if (e) {
-					GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error - cannot update playlist: error in MPD creation %s\n", gf_error_to_string(e)));
-					gf_mpd_del(new_mpd);
-					return GF_NON_COMPLIANT_BITSTREAM;
-				}
+			dash->last_update_time = gf_sys_clock();
+		}
+		return GF_OK;
+	} 
+
+	dash->reload_count = 0;
+	memccpy(dash->lastMPDSignature, signature, sizeof(char), sizeof(dash->lastMPDSignature));
+
+	/* It means we have to reparse the file ... */
+	/* parse the MPD */
+	mpd_parser = gf_xml_dom_new();
+	e = gf_xml_dom_parse(mpd_parser, local_url, NULL, NULL);
+	if (e != GF_OK) {
+		gf_xml_dom_del(mpd_parser);
+		GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error - cannot update playlist: error in XML parsing %s\n", gf_error_to_string(e)));
+		return GF_NON_COMPLIANT_BITSTREAM;
+	}
+	new_mpd = gf_mpd_new();
+	e = gf_mpd_init_from_dom(gf_xml_dom_get_root(mpd_parser), new_mpd, purl);
+	gf_xml_dom_del(mpd_parser);
+	if (e) {
+		GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error - cannot update playlist: error in MPD creation %s\n", gf_error_to_string(e)));
+		gf_mpd_del(new_mpd);
+		return GF_NON_COMPLIANT_BITSTREAM;
+	}
+
+	/*TODO - check periods are the same !!*/
+	period = gf_list_get(dash->mpd->periods, dash->active_period_index);
+	new_period = gf_list_get(new_mpd->periods, dash->active_period_index);
+	if (!new_period) {
+		GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error - cannot update playlist: missing period\n"));
+		gf_mpd_del(new_mpd);
+		return GF_NON_COMPLIANT_BITSTREAM;
+	}
+
+	if (gf_list_count(period->adaptation_sets) != gf_list_count(new_period->adaptation_sets)) {
+		GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error - cannot update playlist: missing AdaptationSet\n"));
+		gf_mpd_del(new_mpd);
+		return GF_NON_COMPLIANT_BITSTREAM;
+	}
+
+	timeline_start_time = 0;
+	/*if not infinity for timeShift, compute min media time before merge and adjust it*/
+	if (dash->mpd->time_shift_buffer_depth != (u32) -1) {
+		Double timeshift = dash->mpd->time_shift_buffer_depth;
+		timeshift /= 1000;
+
+		for (group_idx=0; group_idx<gf_list_count(dash->groups); group_idx++) {
+			GF_DASH_Group *group = gf_list_get(dash->groups, group_idx);
+			Double group_start = gf_dash_get_segment_start_time(group, NULL);
+			if (!group_idx || (timeline_start_time > group_start) ) timeline_start_time = group_start;
+		}
+		/*we can rewind our segments from timeshift*/
+		if (timeline_start_time > timeshift) timeline_start_time -= timeshift;
+		/*we can rewind all segments*/
+		else timeline_start_time = 0;
+	}
+
+	/*update segmentTimeline at Period level*/
+	e = gf_dash_merge_segment_timeline(period->segment_list, period->segment_template, new_period->segment_list, new_period->segment_template, timeline_start_time);
+	if (e) {
+		gf_mpd_del(new_mpd);
+		return e;
+	}
+
+	for (group_idx=0; group_idx<gf_list_count(dash->groups); group_idx++) {
+		Double seg_dur;
+		Bool reset_segment_count;
+		GF_MPD_AdaptationSet *set, *new_set;
+		GF_DASH_Group *group = gf_list_get(dash->groups, group_idx);
+
+		/*update info even if the group is not selected !*/
 
-				/*TODO - check periods are the same !!*/
-				period = gf_list_get(dash->mpd->periods, dash->active_period_index);
-				new_period = gf_list_get(new_mpd->periods, dash->active_period_index);
-				if (!new_period) {
-					GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error - cannot update playlist: missing period\n"));
+
+		set = group->adaptation_set;
+		new_set = gf_list_get(new_period->adaptation_sets, group_idx);
+
+		if (gf_list_count(new_set->representations) != gf_list_count(group->adaptation_set->representations)) {
+			GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error - cannot update playlist: missing representation in adaptation set\n"));
+			gf_mpd_del(new_mpd);
+			return GF_NON_COMPLIANT_BITSTREAM;
+		}
+
+		/*get all representations in both periods*/
+		for (rep_idx = 0; rep_idx <gf_list_count(group->adaptation_set->representations); rep_idx++) {
+			GF_List *segments, *new_segments;
+			GF_MPD_Representation *rep = gf_list_get(group->adaptation_set->representations, rep_idx);
+			GF_MPD_Representation *new_rep = gf_list_get(new_set->representations, rep_idx);
+
+			if (rep->segment_base || group->adaptation_set->segment_base || period->segment_base) {
+				if (!new_rep->segment_base && !new_set->segment_base && !new_period->segment_base) {
+					GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error - cannot update playlist: representation does not use segment base as previous version\n"));
 					gf_mpd_del(new_mpd);
 					return GF_NON_COMPLIANT_BITSTREAM;
 				}
+				/*what else should we check ??*/
 
-				if (gf_list_count(period->adaptation_sets) != gf_list_count(new_period->adaptation_sets)) {
-					GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error - cannot update playlist: missing AdaptationSet\n"));
+				/*OK, this rep is fine*/
+			}
+
+			else if (rep->segment_template || group->adaptation_set->segment_template || period->segment_template) {
+				u32 start;
+				if (!new_rep->segment_template && !new_set->segment_template && !new_period->segment_template) {
+					GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error - cannot update playlist: representation does not use segment template as previous version\n"));
 					gf_mpd_del(new_mpd);
 					return GF_NON_COMPLIANT_BITSTREAM;
 				}
+				start = 0;
+				/*override new startNum with old one - otherwise we would need to get rid of the entries before the start number in the MPD ...*/
+				if (period->segment_template && (period->segment_template->start_number != (u32) -1) ) start = period->segment_template->start_number;
+				if (set->segment_template && (set->segment_template->start_number != (u32) -1) ) start = set->segment_template->start_number;
+				if (rep->segment_template && (rep->segment_template->start_number != (u32) -1) ) start = rep->segment_template->start_number;
 
-				timeline_start_time = 0;
-				/*if not infinity for timeShift, compute min media time before merge and adjust it*/
-				if (dash->mpd->time_shift_buffer_depth != (u32) -1) {
-					Double timeshift = dash->mpd->time_shift_buffer_depth;
-					timeshift /= 1000;
+				if (new_period->segment_template && (new_period->segment_template->start_number != (u32) -1) ) new_period->segment_template->start_number = start;
+				if (new_set->segment_template && (new_set->segment_template->start_number != (u32) -1) ) new_set->segment_template->start_number = start;
+				if (new_rep->segment_template && (new_rep->segment_template->start_number != (u32) -1) ) new_rep->segment_template->start_number = start;
 
-					for (group_idx=0; group_idx<gf_list_count(dash->groups); group_idx++) {
-						GF_DASH_Group *group = gf_list_get(dash->groups, group_idx);
-						Double group_start = gf_dash_get_segment_start_time(group, NULL);
-						if (!group_idx || (timeline_start_time > group_start) ) timeline_start_time = group_start;
-					}
-					/*we can rewind our segments from timeshift*/
-					if (timeline_start_time > timeshift) timeline_start_time -= timeshift;
-					/*we can rewind all segments*/
-					else timeline_start_time = 0;
-				}
+				/*OK, this rep is fine*/
+			}
+			else {
+				/*we're using segment list*/
+				assert(rep->segment_list || group->adaptation_set->segment_list || period->segment_list);
 
-				/*update segmentTimeline at Period level*/
-				e = gf_dash_merge_segment_timeline(period->segment_list, period->segment_template, new_period->segment_list, new_period->segment_template, timeline_start_time);
-				if (e) {
+				if (!new_rep->segment_list && !new_set->segment_list && !new_period->segment_list) {
+					GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error - cannot update playlist: representation does not use segment list as previous version\n"));
 					gf_mpd_del(new_mpd);
-					return e;
+					return GF_NON_COMPLIANT_BITSTREAM;
 				}
-
-				for (group_idx=0; group_idx<gf_list_count(dash->groups); group_idx++) {
-					GF_MPD_AdaptationSet *set, *new_set;
-					GF_DASH_Group *group = gf_list_get(dash->groups, group_idx);
-
-					if (group->selection != GF_DASH_GROUP_SELECTED) continue;
-					set = group->adaptation_set;
-					new_set = gf_list_get(new_period->adaptation_sets, group_idx);
-
-					if (gf_list_count(new_set->representations) != gf_list_count(group->adaptation_set->representations)) {
-						GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error - cannot update playlist: missing representation in adaptation set\n"));
-						gf_mpd_del(new_mpd);
-						return GF_NON_COMPLIANT_BITSTREAM;
+				/*get the segment list*/
+				segments = new_segments = NULL;
+				if (period->segment_list && period->segment_list->segment_URLs) segments = period->segment_list->segment_URLs;
+				if (set->segment_list && set->segment_list->segment_URLs) segments = set->segment_list->segment_URLs;
+				if (rep->segment_list && rep->segment_list->segment_URLs) segments = rep->segment_list->segment_URLs;
+
+				if (new_period->segment_list && new_period->segment_list->segment_URLs) new_segments = new_period->segment_list->segment_URLs;
+				if (new_set->segment_list && new_set->segment_list->segment_URLs) new_segments = new_set->segment_list->segment_URLs;
+				if (new_rep->segment_list && new_rep->segment_list->segment_URLs) new_segments = new_rep->segment_list->segment_URLs;
+
+
+				for (i=0; i<gf_list_count(new_segments); i++) {
+					GF_MPD_SegmentURL *new_seg = gf_list_get(new_segments, i);
+					Bool found = 0;
+					for (j=0; j<gf_list_count(segments); j++) {
+						GF_MPD_SegmentURL *seg = gf_list_get(segments, j);
+						if (seg->media && new_seg->media && !strcmp(seg->media, new_seg->media)) {
+							found=1;
+							break;
+						}
+						if (seg->media_range && new_seg->media_range && (seg->media_range->start_range==new_seg->media_range->start_range) && (seg->media_range->end_range==new_seg->media_range->end_range) ) {
+							found=1;
+							break;
+						}
+					}
+					/*this is a new segment, merge it: we remove from new list and push to old one, before doing a final swap
+					this ensures that indexing in the segment_list is still correct after merging*/
+					if (!found) {
+						gf_list_rem(new_segments, i);
+						i--;
+						gf_list_add(segments, new_seg);
+						GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Representation #%d: Adding new segment %s\n", rep_idx+1, new_seg->media));
 					}
+				}
 
-					/*get all representations in both periods*/
-					for (rep_idx = 0; rep_idx <gf_list_count(group->adaptation_set->representations); rep_idx++) {
-						GF_List *segments, *new_segments;
-						GF_MPD_Representation *rep = gf_list_get(group->adaptation_set->representations, rep_idx);
-						GF_MPD_Representation *new_rep = gf_list_get(new_set->representations, rep_idx);
-
-						if (rep->segment_base || group->adaptation_set->segment_base || period->segment_base) {
-							if (!new_rep->segment_base && !new_set->segment_base && !new_period->segment_base) {
-								GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error - cannot update playlist: representation does not use segment base as previous version\n"));
-								gf_mpd_del(new_mpd);
-								return GF_NON_COMPLIANT_BITSTREAM;
-							}
-							/*what else should we check ??*/
+				/*what else should we check ?*/
 
-							/*OK, this rep is fine*/
-						}
+				/*swap segment list content*/
+				gf_list_swap(new_segments, segments);
 
-						else if (rep->segment_template || group->adaptation_set->segment_template || period->segment_template) {
-							u32 start;
-							if (!new_rep->segment_template && !new_set->segment_template && !new_period->segment_template) {
-								GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error - cannot update playlist: representation does not use segment template as previous version\n"));
-								gf_mpd_del(new_mpd);
-								return GF_NON_COMPLIANT_BITSTREAM;
-							}
-							start = 0;
-							/*override new startNum with old one - otherwise we would need to get rid of the entries before the start number in the MPD ...*/
-							if (period->segment_template && (period->segment_template->start_number != (u32) -1) ) start = period->segment_template->start_number;
-							if (set->segment_template && (set->segment_template->start_number != (u32) -1) ) start = set->segment_template->start_number;
-							if (rep->segment_template && (rep->segment_template->start_number != (u32) -1) ) start = rep->segment_template->start_number;
-
-							if (new_period->segment_template && (new_period->segment_template->start_number != (u32) -1) ) new_period->segment_template->start_number = start;
-							if (new_set->segment_template && (new_set->segment_template->start_number != (u32) -1) ) new_set->segment_template->start_number = start;
-							if (new_rep->segment_template && (new_rep->segment_template->start_number != (u32) -1) ) new_rep->segment_template->start_number = start;
+				/*current representation is the active one in the group - update the number of segments*/
+				if (group->active_rep_index==rep_idx) {
+					group->nb_segments_in_rep = gf_list_count(new_segments);
+				}
+			}
 
-							/*OK, this rep is fine*/
-						}
-						else {
-							/*we're using segment list*/
-							assert(rep->segment_list || group->adaptation_set->segment_list || period->segment_list);
-
-							if (!new_rep->segment_list && !new_set->segment_list && !new_period->segment_list) {
-								GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error - cannot update playlist: representation does not use segment list as previous version\n"));
-								gf_mpd_del(new_mpd);
-								return GF_NON_COMPLIANT_BITSTREAM;
-							}
-							/*get the segment list*/
-							segments = new_segments = NULL;
-							if (period->segment_list && period->segment_list->segment_URLs) segments = period->segment_list->segment_URLs;
-							if (set->segment_list && set->segment_list->segment_URLs) segments = set->segment_list->segment_URLs;
-							if (rep->segment_list && rep->segment_list->segment_URLs) segments = rep->segment_list->segment_URLs;
-
-							if (new_period->segment_list && new_period->segment_list->segment_URLs) new_segments = new_period->segment_list->segment_URLs;
-							if (new_set->segment_list && new_set->segment_list->segment_URLs) new_segments = new_set->segment_list->segment_URLs;
-							if (new_rep->segment_list && new_rep->segment_list->segment_URLs) new_segments = new_rep->segment_list->segment_URLs;
-
-
-							for (i=0; i<gf_list_count(new_segments); i++) {
-								GF_MPD_SegmentURL *new_seg = gf_list_get(new_segments, i);
-								Bool found = 0;
-								for (j=0; j<gf_list_count(segments); j++) {
-									GF_MPD_SegmentURL *seg = gf_list_get(segments, j);
-									if (seg->media && new_seg->media && !strcmp(seg->media, new_seg->media)) {
-										found=1;
-										break;
-									}
-									if (seg->media_range && new_seg->media_range && (seg->media_range->start_range==new_seg->media_range->start_range) && (seg->media_range->end_range==new_seg->media_range->end_range) ) {
-										found=1;
-										break;
-									}
-								}
-								/*this is a new segment, merge it: we remove from new list and push to old one, before doing a final swap
-								this ensures that indexing in the segment_list is still correct after merging*/
-								if (!found) {
-									gf_list_rem(new_segments, i);
-									i--;
-									gf_list_add(segments, new_seg);
-									GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Representation #%d: Adding new segment %s\n", rep_idx+1, new_seg->media));
-								}
-							}
+			e = gf_dash_merge_segment_timeline(rep->segment_list, rep->segment_template, new_rep->segment_list, new_rep->segment_template, timeline_start_time);
+			if (e) {
+				gf_mpd_del(new_mpd);
+				return e;
+			}
 
-							/*what else should we check ?*/
+			/*what else should we check ??*/
 
-							/*swap segment list content*/
-							gf_list_swap(new_segments, segments);
 
-							/*current representation is the active one in the group - update the number of segments*/
-							if (group->active_rep_index==rep_idx) {
-								group->nb_segments_in_rep = gf_list_count(new_segments);
-							}
-						}
-
-						e = gf_dash_merge_segment_timeline(rep->segment_list, rep->segment_template, new_rep->segment_list, new_rep->segment_template, timeline_start_time);
-						if (e) {
-							gf_mpd_del(new_mpd);
-							return e;
-						}
-
-						/*what else should we check ??*/
+			/*switch all intertnal GPAC stuff*/
+			memcpy(&new_rep->playback, &rep->playback, sizeof(GF_DASH_RepresentationPlayback));
+			if (rep->playback.cached_init_segment_url) rep->playback.cached_init_segment_url = NULL;
 
+			if (!new_rep->mime_type) {
+				new_rep->mime_type = rep->mime_type;
+				rep->mime_type = NULL;
+			}
+		}
+		/*update group/period to new period*/
+		j = gf_list_find(group->period->adaptation_sets, group->adaptation_set);
+		group->adaptation_set = gf_list_get(new_period->adaptation_sets, j);
+		group->period = new_period;
 
-						/*switch all intertnal GPAC stuff*/
-						memcpy(&new_rep->playback, &rep->playback, sizeof(GF_DASH_RepresentationPlayback));
-						if (rep->playback.cached_init_segment_url) rep->playback.cached_init_segment_url = NULL;
+		j = gf_list_count(group->adaptation_set->representations);
+		assert(j);
 
-						if (!new_rep->mime_type) {
-							new_rep->mime_type = rep->mime_type;
-							rep->mime_type = NULL;
-						}
-					}
-					/*update group/period to new period*/
-					j = gf_list_find(group->period->adaptation_sets, group->adaptation_set);
-					group->adaptation_set = gf_list_get(new_period->adaptation_sets, j);
-					group->period = new_period;
+		/*update segmentTimeline at AdaptationSet level*/
+		e = gf_dash_merge_segment_timeline(set->segment_list, set->segment_template, new_set->segment_list, new_set->segment_template, timeline_start_time);
+		if (e) {
+			gf_mpd_del(new_mpd);
+			return e;
+		}
 
-					/*update segmentTimeline at AdaptationSet level*/
-					e = gf_dash_merge_segment_timeline(set->segment_list, set->segment_template, new_set->segment_list, new_set->segment_template, timeline_start_time);
-					if (e) {
-						gf_mpd_del(new_mpd);
-						return e;
-					}
+		/*now that all possible SegmentXXX have been updated, purge them if needed: all segments ending before timeline_start_time
+		will be removed from MPD*/
+		if (timeline_start_time) {
+			u32 nb_segments_removed = gf_dash_purge_segment_timeline(group, timeline_start_time);
+			if (nb_segments_removed) {
+				GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] AdaptationSet %d - removed %d segments from timeline (%d since start of the period)\n", group_idx+1, nb_segments_removed, group->nb_segments_purged));
+			}
+		}
 
-					/*now that all possible SegmentXXX have been updated, purge them if needed: all segments ending before timeline_start_time
-					will be removed from MPD*/
-					if (timeline_start_time) {
-						u32 nb_segments_removed = gf_dash_purge_segment_timeline(group, timeline_start_time);
-						if (nb_segments_removed) {
-							GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] AdaptationSet %d - removed %d segments from timeline (%d since start of the period)\n", group_idx+1, nb_segments_removed, group->nb_segments_purged));
-						}
-					}
+		if (new_mpd->availabilityStartTime != dash->mpd->availabilityStartTime) {
+			gf_dash_group_timeline_setup(new_mpd, group);
+		}
 
-					if (new_mpd->availabilityStartTime != dash->mpd->availabilityStartTime) {
-						gf_dash_group_timeline_setup(new_mpd, group);
-					}
+		group->maybe_end_of_stream = 0;
+		reset_segment_count = 0;
+		/*compute fetchTime + minUpdatePeriod and check period end time*/
+		if (new_mpd->minimum_update_period && new_mpd->media_presentation_duration) {
+			u32 endTime = (u32) (fetch_time - new_mpd->availabilityStartTime - period->start);
+			if (endTime > new_mpd->media_presentation_duration) {
+				GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Period EndTime is signaled to %d, less than fetch time %d ! Ignoring mediaPresentationDuration\n", new_mpd->media_presentation_duration, endTime));
+				new_mpd->media_presentation_duration = 0;
+				reset_segment_count = 1;
+			} else {
+				endTime += new_mpd->minimum_update_period/1000;
+				if (endTime > new_mpd->media_presentation_duration) {
+					GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Period EndTime is signaled to %d, less than fetch time + next update - maybe end of stream ?\n", new_mpd->availabilityStartTime, endTime));
+					group->maybe_end_of_stream = 1;
+				}
+			}
+		}
 
-					/*update number of segments in active rep*/
-					gf_dash_get_segment_duration(gf_list_get(group->adaptation_set->representations, group->active_rep_index), group->adaptation_set, group->period, new_mpd, &group->nb_segments_in_rep, NULL);
+		/*update number of segments in active rep*/
+		gf_dash_get_segment_duration(gf_list_get(group->adaptation_set->representations, group->active_rep_index), group->adaptation_set, group->period, new_mpd, &group->nb_segments_in_rep, &seg_dur);
 
-					GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Updated AdaptationSet %d - %d segments\n", group_idx+1, group->nb_segments_in_rep));
+		if (reset_segment_count) {
+			u32 nb_segs_in_mpd_period = (u32) (dash->mpd->minimum_update_period / (1000*seg_dur) );
+			group->nb_segments_in_rep = group->download_segment_index + nb_segs_in_mpd_period;
+		} 
+		/*check if number of segments are coherent ...*/
+		else if (!group->maybe_end_of_stream && new_mpd->minimum_update_period && new_mpd->media_presentation_duration) {
+			u32 nb_segs_in_mpd_period = (u32) (dash->mpd->minimum_update_period / (1000*seg_dur) );
 
-				}
-				/*swap representations - we don't need to update download_segment_index as it still points to the right entry in the merged list*/
-				if (dash->mpd)
-					gf_mpd_del(dash->mpd);
-				dash->mpd = new_mpd;
-				dash->last_update_time = gf_sys_clock();
+			if (group->download_segment_index + nb_segs_in_mpd_period >= group->nb_segments_in_rep) {
+				GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Period has %d segments but %d are needed until next refresh. Maybe end of stream is near ?\n", group->nb_segments_in_rep, group->download_segment_index + nb_segs_in_mpd_period));
+				group->maybe_end_of_stream = 1;
 			}
 		}
+
+		GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Updated AdaptationSet %d - %d segments\n", group_idx+1, group->nb_segments_in_rep));
+
 	}
+	/*swap representations - we don't need to update download_segment_index as it still points to the right entry in the merged list*/
+	if (dash->mpd)
+		gf_mpd_del(dash->mpd);
+	dash->mpd = new_mpd;
+	dash->last_update_time = gf_sys_clock();
+	dash->mpd_fetch_time = fetch_time;
+
+//	dash->mpd->minimum_update_period = 3000;
+
 	return GF_OK;
 }
 
@@ -1299,12 +1457,13 @@ static void gf_dash_set_group_representation(GF_DASH_Group *group, GF_MPD_Repres
 	u32 k;
 	GF_MPD_AdaptationSet *set;
 	GF_MPD_Period *period;
+	u32 nb_segs;
 	u32 i = gf_list_find(group->adaptation_set->representations, rep);
 	assert((s32) i >= 0);
 
 	group->active_rep_index = i;
 	group->active_bitrate = rep->bandwidth;
-	group->nb_segments_in_rep = 1;
+	nb_segs = group->nb_segments_in_rep;
 
 	group->min_bandwidth_selected = 1;
 	for (k=0; k<gf_list_count(group->adaptation_set->representations); k++) {
@@ -1331,15 +1490,18 @@ static void gf_dash_set_group_representation(GF_DASH_Group *group, GF_MPD_Repres
 	if (group->max_bitrate) GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("\tmax download bandwidth: %d kbps\n", group->max_bitrate/1024));
 	if (width&&height) {
 		GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("\tWidth %d Height %d", width, height));
-		if (framerate) GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("framerate %d/%d", framerate->num, framerate->den));
+		if (framerate) GF_LOG(GF_LOG_INFO, GF_LOG_DASH, (" framerate %d/%d", framerate->num, framerate->den));
 		GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("\n"));
 	} else if (samplerate) {
 		GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("\tsamplerate %d\n", samplerate));
 	}
 #endif
 
-
 	gf_dash_get_segment_duration(rep, set, period, group->dash->mpd, &group->nb_segments_in_rep, &group->segment_duration);
+
+	/*if broken indication in duration restore previous seg count*/
+	if (group->dash->ignore_mpd_duration)
+		group->nb_segments_in_rep = nb_segs;
 }
 
 static void gf_dash_switch_group_representation(GF_DashClient *mpd, GF_DASH_Group *group)
@@ -1464,7 +1626,7 @@ GF_Err gf_dash_resolve_url(GF_MPD *mpd, GF_MPD_Representation *rep, GF_DASH_Grou
 	}
 
 	gf_dash_resolve_duration(rep, set, period, segment_duration, &timescale, NULL, NULL);
-	*segment_duration = (u32) ((Double) (*segment_duration) * 1000.0 / timescale);
+	*segment_duration = (resolve_type==GF_DASH_RESOLVE_URL_MEDIA) ? (u32) ((Double) (*segment_duration) * 1000.0 / timescale) : 0;
 
 	/*single URL*/
 //	if (rep->segment_base || set->segment_base || period->segment_base) {
@@ -1819,6 +1981,10 @@ static GF_Err gf_dash_download_init_segment(GF_DashClient *dash, GF_DASH_Group *
 		group->nb_cached_segments = 1;
 		/*do not erase local files*/
 		group->local_files = group->was_segment_base ? 0 : 1;
+		if (group->local_files) {
+			gf_dash_buffer_off(group, dash);
+		}
+
 		group->download_segment_index += nb_segment_read;
 		group->segment_local_url = group->cached[0].cache;
 		group->local_url_start_range = start_range;
@@ -1956,12 +2122,15 @@ static GF_Err gf_dash_download_init_segment(GF_DashClient *dash, GF_DASH_Group *
 		group->cached[0].cache = gf_strdup(group->segment_local_url);
 		group->cached[0].url = gf_strdup( dash->dash_io->get_url(dash->dash_io, group->segment_download) );
 		group->cached[0].representation_index = group->active_rep_index;
+		group->cached[0].duration = (u32) group->current_downloaded_segment_duration;
 		rep->playback.cached_init_segment_url = gf_strdup(group->segment_local_url);
 		rep->playback.init_start_range = 0;
 		rep->playback.init_end_range = 0;
 
 		group->nb_cached_segments = 1;
 		group->download_segment_index += nb_segment_read;
+		gf_dash_update_buffering(group, dash);
+
 		GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Adding initialization segment %s to cache: %s\n", group->segment_local_url, group->cached[0].url ));
 		gf_mx_v(dash->dl_mutex);
 		gf_free(base_init_url);
@@ -2052,7 +2221,7 @@ static void gf_dash_reset_groups(GF_DashClient *dash)
 }
 
 
-/* create groups (implemntation of adaptations set) */
+/* create groups (implementation of adaptations set) */
 GF_Err gf_dash_setup_groups(GF_DashClient *dash)
 {
 	GF_Err e;
@@ -2069,7 +2238,6 @@ GF_Err gf_dash_setup_groups(GF_DashClient *dash)
 
 	count = gf_list_count(period->adaptation_sets);
 	for (i=0; i<count; i++) {
-		u32 cache_duration;
 		Double seg_dur;
 		GF_DASH_Group *group;
 		Bool found = 0;
@@ -2111,12 +2279,12 @@ GF_Err gf_dash_setup_groups(GF_DashClient *dash)
 			GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[DASH] Cannot compute default segment duration\n"));
 		}
 
-		cache_duration = dash->max_cache_duration * 1000;
+		group->cache_duration = dash->max_cache_duration * 1000;
 		if (dash->mpd->min_buffer_time)
-			cache_duration = dash->mpd->min_buffer_time;
+			group->cache_duration = dash->mpd->min_buffer_time;
 		group->max_cached_segments = 1;
 		if (seg_dur) {
-			while (group->max_cached_segments * seg_dur * 1000 < cache_duration)
+			while (group->max_cached_segments * seg_dur * 1000 < group->cache_duration)
 				group->max_cached_segments ++;
 
 			/*we need one more entry in cache for segment being currently played*/
@@ -2445,26 +2613,27 @@ static GF_Err gf_dash_setup_period(GF_DashClient *dash)
 			if (rep_i) {
 				Bool ok;
 				char *sep;
-				if ( !rep->codecs || !rep_sel->codecs) continue;
-
-				sep = strchr(rep_sel->codecs, '.');
-				if (sep) sep[0] = 0;
-				ok = !strnicmp(rep->codecs, rep_sel->codecs, strlen(rep_sel->codecs) );
-				if (sep) sep[0] = '.';
-				if (!ok) {
-					GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[DASH] Different codec types (%s vs %s) in same AdaptationSet - disabling %s\n", rep_sel->codecs, rep->codecs, rep->codecs));
-					rep->playback.disabled = 1;
-					continue;
-				}
-				if (rep->dependency_id) {
-					GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[DASH] Representation dependent on representation %d - not supported\n", rep->dependency_id));
-					rep->playback.disabled = 1;
-					continue;
-				}
-				if (rep->segment_list && rep->segment_list->xlink_href) {
-					GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[DASH] Representation SegmentList uses xlink:href to %s - disabling because not supported\n", rep->segment_list->xlink_href));
-					rep->playback.disabled = 1;
-					continue;
+				if (rep->codecs && rep_sel->codecs) {
+
+					sep = strchr(rep_sel->codecs, '.');
+					if (sep) sep[0] = 0;
+					ok = !strnicmp(rep->codecs, rep_sel->codecs, strlen(rep_sel->codecs) );
+					if (sep) sep[0] = '.';
+					if (!ok) {
+						GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[DASH] Different codec types (%s vs %s) in same AdaptationSet - disabling %s\n", rep_sel->codecs, rep->codecs, rep->codecs));
+						rep->playback.disabled = 1;
+						continue;
+					}
+					if (rep->dependency_id) {
+						GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[DASH] Representation dependent on representation %d - not supported\n", rep->dependency_id));
+						rep->playback.disabled = 1;
+						continue;
+					}
+					if (rep->segment_list && rep->segment_list->xlink_href) {
+						GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[DASH] Representation SegmentList uses xlink:href to %s - disabling because not supported\n", rep->segment_list->xlink_href));
+						rep->playback.disabled = 1;
+						continue;
+					}
 				}
 			}
 
@@ -2532,6 +2701,10 @@ static GF_Err gf_dash_setup_period(GF_DashClient *dash)
 
 		group->selection = GF_DASH_GROUP_NOT_SELECTED;
 		nb_groups_ok++;
+
+#ifdef DEBUG_FIRST_SET_ONLY
+		break;
+#endif
 	}
 
 	period = gf_list_get(dash->mpd->periods, dash->active_period_index);
@@ -2558,6 +2731,8 @@ static u32 dash_main_thread_proc(void *par)
 	GF_MPD_Representation *rep;
 	u32 i, group_count, ret = 0;
 	Bool go_on = 1;
+	u32 min_wait = 0;
+	Bool first_period_in_mpd = 1;
 	char *new_base_seg_url;
 	assert(dash);
 	if (!dash->mpd) {
@@ -2581,7 +2756,6 @@ restart_period:
 		ret = 1;
 		goto exit;
 	}
-
 	dash->dash_io->on_dash_event(dash->dash_io, GF_DASH_EVENT_SELECT_GROUPS, GF_OK);
 
 	e = GF_OK;
@@ -2589,10 +2763,14 @@ restart_period:
 	for (i=0; i<group_count; i++) {
 		GF_DASH_Group *group = gf_list_get(dash->groups, i);
 		if (group->selection != GF_DASH_GROUP_SELECTED) continue;
+		if (first_period_in_mpd) {
+			gf_dash_buffer_on(group, dash);
+		}
 		e = gf_dash_download_init_segment(dash, group);
 		if (e) break;
 	}
 	dash->mpd_stop_request=0;
+	first_period_in_mpd = 0;
 
 	/*if error signal to the user*/
 	if (e != GF_OK) {
@@ -2625,23 +2803,39 @@ restart_period:
 	dash->dash_state = GF_DASH_STATE_RUNNING;
 	gf_mx_v(dash->dl_mutex);
 
+	min_wait = 0;
 	while (go_on) {
 		const char *local_file_name = NULL;
 		const char *resource_name = NULL;
+
 		/*wait until next segment is needed*/
 		while (!dash->mpd_stop_request) {
 			u32 timer = gf_sys_clock() - dash->last_update_time;
 
+			/*refresh MPD*/
 			if (dash->mpd->minimum_update_period && (timer > dash->mpd->minimum_update_period)) {
-				GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Time to update the playlist (%u ms ellapsed since last refresh and min reoad rate is %u)\n", timer, dash->mpd->minimum_update_period));
+				u32 diff = gf_sys_clock();
+				GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] At %d Time to update the playlist (%u ms ellapsed since last refresh and min reoad rate is %u)\n", gf_sys_clock() , timer, dash->mpd->minimum_update_period));
 				e = gf_dash_update_manifest(dash);
 				group_count = gf_list_count(dash->groups);
+				diff = gf_sys_clock() - diff;
 				if (e) {
 					GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error updating MPD %s\n", gf_error_to_string(e)));
+				} else {
+					GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[DASH] Updated MPD in %d ms\n", diff));
 				}
 			} else {
 				Bool all_groups_done = 1;
 				Bool cache_full = 1;
+
+				/*wait if nothing is ready to be downloaded*/
+				if (min_wait) {
+					u32 sleep_for = min_wait/2;
+					GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] No segments available on the server until %d ms - going to sleep\n", sleep_for));
+					gf_sleep(sleep_for);
+				}
+
+				/*check if cache is not full*/
 				gf_mx_p(dash->dl_mutex);
 				for (i=0; i<group_count; i++) {
 					GF_DASH_Group *group = gf_list_get(dash->groups, i);
@@ -2653,6 +2847,7 @@ restart_period:
 					}
 				}
 				gf_mx_v(dash->dl_mutex);
+
 				if (!cache_full) break;
 
 				if (dash->request_period_switch==2) all_groups_done = 1;
@@ -2666,7 +2861,6 @@ restart_period:
 
 					goto restart_period;
 				}
-
 				gf_sleep(30);
 			}
 		}
@@ -2677,8 +2871,11 @@ restart_period:
 			break;
 		}
 
+		min_wait = 0;
+
 		/*for each selected groups*/
 		for (i=0; i<group_count; i++) {		
+			Bool in_segment_avail_time;
 			u64 start_range, end_range;
 			Bool use_byterange;
 			u32 representation_index;
@@ -2688,6 +2885,7 @@ restart_period:
 
 
 			if (group->nb_cached_segments>=group->max_cached_segments) {
+				GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] At %d Cache is full for this group - skipping\n", gf_sys_clock() ));
 				continue;
 			}
 
@@ -2723,7 +2921,10 @@ restart_period:
 				if (group->download_segment_index >= group->nb_segments_in_rep) {
 					/* if there is a specified update period, we redo the whole process */
 					if (dash->mpd->minimum_update_period || dash->mpd->type==GF_MPD_TYPE_DYNAMIC) {
-						continue;
+						if (! group->maybe_end_of_stream) {
+							GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[DASH] End of segment list reached (%d segments but idx is %d), waiting for next MPD update\n", group->nb_segments_in_rep, group->download_segment_index));
+							continue;
+						}
 					} else {
 						/* if not, we are really at the end of the playlist, we can quit */
 						GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[DASH] End of playlist reached... downloading remaining elements..."));
@@ -2735,6 +2936,7 @@ restart_period:
 			gf_mx_p(dash->dl_mutex);
 
 			if (group->force_switch_bandwidth && !dash->auto_switch_count) {
+				GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[DASH] Forcing representation switch, retesting group"));
 				gf_dash_switch_group_representation(dash, group);
 				/*restart*/
 				i--;
@@ -2742,17 +2944,39 @@ restart_period:
 				continue;
 			}
 
+			in_segment_avail_time = 0;
+
 			/*check availablity start time of segment in Live !!*/
 			if (!group->broken_timing && (dash->mpd->type==GF_MPD_TYPE_DYNAMIC) && !dash->is_m3u8) {
-				u64 segment_ast = gf_dash_get_segment_availability_start_time(dash->mpd, group, group->download_segment_index);
-				u64 now = gf_dash_get_utc_clock();
+				u32 clock_time = gf_sys_clock();
+				s32 to_wait = 0;
+				u32 seg_dur_ms=0;
+				s64 segment_ast = (s64) gf_dash_get_segment_availability_start_time(dash->mpd, group, group->download_segment_index, &seg_dur_ms);
+				s64 now = (s64) gf_dash_get_utc_clock();
+				
+				to_wait = (s32) (segment_ast - now);
+
 				/*if segment AST is greater than now, it is not yet available ...*/
-				if (segment_ast > now ) {
-					GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Next segment %d is not yet available on server - requesting later (in %d ms)\n", group->download_segment_index, segment_ast - now));
+				if (to_wait > 0) {
+					GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Set #%d At %d Next segment %d (AST "LLD") is not yet available on server - requesting later in %d s\n", i+1, gf_sys_clock(), group->download_segment_index + group->start_number, segment_ast, to_wait));
+					if (group->last_segment_time) {
+						GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] %d ms ellapsed since previous segment download\n", clock_time - group->last_segment_time));
+					}
 					gf_mx_v(dash->dl_mutex);
+					if (!min_wait || ((u32) 1000*to_wait < min_wait))
+						min_wait = 1000*to_wait;
 					continue;
+				} else {
+					GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Set #%d At %d Next segment %d (AST "LLD") should now be available on server since %d sec - requesting it\n", i+1, gf_sys_clock(), group->download_segment_index + group->start_number, segment_ast, -to_wait));
+					if (group->last_segment_time) {
+						GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] %d ms ellapsed since previous segment download\n", clock_time - group->last_segment_time));
+					}
+					/*check if we are in the segment availability end time*/
+					if (now < segment_ast + (seg_dur_ms + group->dash->mpd->time_shift_buffer_depth) /1000 )
+						in_segment_avail_time = 1;
 				}
 			}
+			min_wait = 0;
 
 			/* At this stage, there are some segments left to be downloaded */
 			e = gf_dash_resolve_url(dash->mpd, rep, group, dash->base_url, GF_DASH_RESOLVE_URL_MEDIA, group->download_segment_index, &new_base_seg_url, &start_range, &end_range, &group->current_downloaded_segment_duration, NULL);
@@ -2773,6 +2997,7 @@ restart_period:
 				e = GF_OK;
 				/*do not erase local files*/
 				group->local_files = 1;
+				gf_dash_buffer_off(group, dash);
 				if (group->force_switch_bandwidth && !dash->auto_switch_count) {
 					gf_dash_switch_group_representation(dash, group);
 					/*restart*/
@@ -2794,8 +3019,20 @@ restart_period:
 
 				/*TODO decide what is the best, fetch from another representation or ignore ...*/
 				if (e != GF_OK) {
-					GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error in downloading new segment: %s %s\n", new_base_seg_url, gf_error_to_string(e)));
-					group->download_segment_index++;
+					if (group->maybe_end_of_stream) {
+						if (group->maybe_end_of_stream==2) {
+							GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[DASH] Couldn't get segment %s (error %s) and end of period was guessed during last update - stoping playback\n", new_base_seg_url, gf_error_to_string(e)));
+							group->maybe_end_of_stream = 0;
+							group->done = 1;
+						}
+						group->maybe_end_of_stream++;
+					} else if (in_segment_avail_time) {
+						GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[DASH] Couldn't get segment %s during its availability period (%s) - retrying\n", new_base_seg_url, gf_error_to_string(e)));
+						min_wait = 30;
+					} else {
+						GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Error in downloading new segment: %s %s\n", new_base_seg_url, gf_error_to_string(e)));
+						group->download_segment_index++;
+					}
 					continue;
 				}
 
@@ -2821,17 +3058,17 @@ restart_period:
 
 				total_size = dash->dash_io->get_total_size(dash->dash_io, group->segment_download);
 				bytes_per_sec = dash->dash_io->get_bytes_per_sec(dash->dash_io, group->segment_download);
+				
+				group->last_segment_time = gf_sys_clock();
 
-				if (total_size && bytes_per_sec && group->current_downloaded_segment_duration) {
+				if (/*(!group->buffering || !group->min_bandwidth_selected) && */ total_size && bytes_per_sec && group->current_downloaded_segment_duration) {
 					Double bitrate, time;
 					bitrate = 8*total_size;
-					bitrate *= 1000;
 					bitrate /= group->current_downloaded_segment_duration;
-					bitrate /= 1024;
 					time = total_size;
 					time /= bytes_per_sec;
 
-					GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[DASH] Downloaded segment %d bytes in %g seconds - duration %g sec - Bandwidth (kbps): indicated %d - computed %d - download %d\n", total_size, time, group->current_downloaded_segment_duration/1000.0, rep->bandwidth/1024, (u32) bitrate, 8*bytes_per_sec/1024));
+					GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[DASH] Downloaded segment %d bytes in %g seconds - duration %g sec - Bandwidth (kbps): indicated %d - computed %d - download %d\n", total_size, time, group->current_downloaded_segment_duration/1000.0, rep->bandwidth/1000, (u32) bitrate, 8*bytes_per_sec/1000));
 
 					if (rep->bandwidth < 8*bytes_per_sec) {
 						u32 k;
@@ -2862,6 +3099,8 @@ restart_period:
 				group->cached[group->nb_cached_segments].start_range = 0;
 				group->cached[group->nb_cached_segments].end_range = 0;
 				group->cached[group->nb_cached_segments].representation_index = representation_index;
+				group->cached[group->nb_cached_segments].duration = (u32) group->current_downloaded_segment_duration;
+
 				if (group->local_files && use_byterange) {
 					group->cached[group->nb_cached_segments].start_range = start_range;
 					group->cached[group->nb_cached_segments].end_range = end_range;
@@ -2870,6 +3109,7 @@ restart_period:
 					GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[DASH] Added file to cache (%u/%u in cache): %s\n", group->nb_cached_segments+1, group->max_cached_segments, group->cached[group->nb_cached_segments].url));
 				}
 				group->nb_cached_segments++;
+				gf_dash_update_buffering(group, dash);
 				group->download_segment_index++;
 				if (dash->auto_switch_count) {
 					group->nb_segments_done++;
@@ -3029,7 +3269,7 @@ static void gf_dash_seek_group(GF_DashClient *dash, GF_DASH_Group *group)
 
 	group->force_segment_switch = 1;
 	group->download_segment_index = segment_idx;
-
+	
 	if (group->segment_download) 
 		dash->dash_io->abort(dash->dash_io, group->segment_download);
 
@@ -3185,6 +3425,7 @@ GF_Err gf_dash_open(GF_DashClient *dash, const char *manifest_url)
 		if (!f) return GF_URL_ERROR;
 		fclose(f);
 	}
+	dash->mpd_fetch_time = gf_dash_get_utc_clock();
 
 	if (dash->is_m3u8) {
 		if (is_local) {
@@ -3289,7 +3530,7 @@ void gf_dash_close(GF_DashClient *dash)
 }
 
 GF_EXPORT
-GF_DashClient *gf_dash_new(GF_DASHFileIO *dash_io, u32 max_cache_duration_sec, u32 auto_switch_count, Bool keep_files, Bool disable_switching, GF_DASHInitialSelectionMode first_select_mode)
+GF_DashClient *gf_dash_new(GF_DASHFileIO *dash_io, u32 max_cache_duration_sec, u32 auto_switch_count, Bool keep_files, Bool disable_switching, GF_DASHInitialSelectionMode first_select_mode, Bool enable_buffering)
 {
 	GF_DashClient *dash;
 	GF_SAFEALLOC(dash, GF_DashClient);
@@ -3300,6 +3541,7 @@ GF_DashClient *gf_dash_new(GF_DASHFileIO *dash_io, u32 max_cache_duration_sec, u
 	dash->mimeTypeForM3U8Segments = gf_strdup( "video/mp2t" );
 
 	dash->max_cache_duration = max_cache_duration_sec;
+	dash->enable_buffering = enable_buffering;
 
 	dash->auto_switch_count = auto_switch_count;
 	dash->keep_files = keep_files;
@@ -3414,6 +3656,8 @@ void gf_dash_switch_quality(GF_DashClient *dash, Bool switch_up, Bool immediate_
 				for remote, we should let the user decide*/
 				while (group->nb_cached_segments>1) {
 					group->nb_cached_segments--;
+					gf_dash_update_buffering(group, dash);
+
 					gf_free(group->cached[group->nb_cached_segments].url);
 					group->cached[group->nb_cached_segments].url = NULL;
 					if (!group->local_files && group->cached[group->nb_cached_segments].cache) {
@@ -3424,6 +3668,7 @@ void gf_dash_switch_quality(GF_DashClient *dash, Bool switch_up, Bool immediate_
 					group->cached[group->nb_cached_segments].representation_index = 0;
 					group->cached[group->nb_cached_segments].start_range = 0;
 					group->cached[group->nb_cached_segments].end_range = 0;
+					group->cached[group->nb_cached_segments].duration = (u32) group->current_downloaded_segment_duration;
 					if (group->download_segment_index>1)
 						group->download_segment_index--;
 				}
@@ -3568,6 +3813,10 @@ u32 gf_dash_group_get_num_segments_ready(GF_DashClient *dash, u32 idx, Bool *gro
 	} else {
 		*group_is_done = group->done;
 		res = group->nb_cached_segments;
+
+		if (group->buffering) {
+			res = 0;
+		}
 	}
 	gf_mx_v(dash->dl_mutex);
 	return res;
@@ -3607,6 +3856,7 @@ void gf_dash_group_discard_segment(GF_DashClient *dash, u32 idx)
 		group->cached[0].url = NULL;
 		group->cached[0].cache = NULL;
 		group->cached[0].representation_index = 0;
+		group->cached[0].duration = 0;
 	}
 	memmove(&group->cached[0], &group->cached[1], sizeof(segment_cache_entry)*(group->nb_cached_segments-1));
 	memset(&(group->cached[group->nb_cached_segments-1]), 0, sizeof(segment_cache_entry));
diff --git a/src/media_tools/dash_segmenter.c b/src/media_tools/dash_segmenter.c
index e49ab4ff1..1aa527cee 100644
--- a/src/media_tools/dash_segmenter.c
+++ b/src/media_tools/dash_segmenter.c
@@ -64,6 +64,7 @@ typedef struct
 	s32 subsegs_per_sidx;
 	Bool daisy_chain_sidx;
 	Bool use_url_template;
+	Bool use_segment_timeline;
 	u32 single_file_mode;
 	s32 time_shift_depth;
 	Double subduration;
@@ -131,7 +132,7 @@ struct _dash_segment_input
 			char_template+=1;	\
 
 GF_EXPORT
-GF_Err gf_media_mpd_format_segment_name(GF_DashTemplateSegmentType seg_type, Bool is_bs_switching, char *segment_name, const char *output_file_name, const char *rep_id, const char *seg_rad_name, const char *seg_ext, u64 start_time, u32 bandwidth, u32 segment_number)
+GF_Err gf_media_mpd_format_segment_name(GF_DashTemplateSegmentType seg_type, Bool is_bs_switching, char *segment_name, const char *output_file_name, const char *rep_id, const char *seg_rad_name, const char *seg_ext, u64 start_time, u32 bandwidth, u32 segment_number, Bool use_segment_timeline)
 {
 	char szFmt[20];
 	Bool has_number=0;
@@ -178,6 +179,7 @@ GF_Err gf_media_mpd_format_segment_name(GF_DashTemplateSegmentType seg_type, Boo
 				strcat(szFmt, &LLD[1]);
 				sprintf(tmp, szFmt, start_time);
 				strcat(segment_name, tmp);
+				has_number=1;
 			}
 			else if (!is_template && !strnicmp(& seg_rad_name[char_template], "$Number", 7)) {
 				EXTRACT_FORMAT(7);
@@ -216,7 +218,7 @@ GF_Err gf_media_mpd_format_segment_name(GF_DashTemplateSegmentType seg_type, Boo
 		}
 	}
 
-	if (is_template && !strstr(seg_rad_name, "$Number"))
+	if (is_template && ! use_segment_timeline && !strstr(seg_rad_name, "$Number"))
 		strcat(segment_name, "$Number$");
 
 	if (needs_init)
@@ -382,12 +384,16 @@ static GF_Err gf_media_isom_segment_file(GF_ISOFile *input, const char *output_f
 	Bool flush_all_samples = 0;
 	Bool simulation_pass = 0;
 	Bool init_segment_deleted = 0;
+	Bool first_segment_in_timeline = 1;
+	u64 previous_segment_duration = 0;
+	u32 segment_timeline_repeat_count = 0;
 	u64 last_ref_cts = 0;
 	u64 start_range, end_range, file_size, init_seg_size, ref_track_first_dts, ref_track_next_cts;
 	u32 tfref_timescale = 0;
 	u32 bandwidth = 0;
 	GF_ISOMTrackFragmenter *tf, *tfref;
 	GF_BitStream *mpd_bs = NULL;
+	GF_BitStream *mpd_timeline_bs = NULL;
 	char szMPDTempLine[2048];
 	char SegmentName[GF_MAX_PATH];
 	char RepSecName[200];
@@ -472,7 +478,7 @@ static GF_Err gf_media_isom_segment_file(GF_ISOFile *input, const char *output_f
 			output = gf_isom_open(opt, GF_ISOM_OPEN_CAT_FRAGMENTS, NULL);
 			dash_moov_setup = 1;
 		} else {
-			gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_INITIALIZATION, is_bs_switching, SegmentName, output_file, dash_input->representationID, seg_rad_name, !stricmp(seg_ext, "null") ? NULL : "mp4", 0, bandwidth, 0);
+			gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_INITIALIZATION, is_bs_switching, SegmentName, output_file, dash_input->representationID, seg_rad_name, !stricmp(seg_ext, "null") ? NULL : "mp4", 0, bandwidth, 0, dash_cfg->use_segment_timeline);
 			output = gf_isom_open(SegmentName, GF_ISOM_OPEN_WRITE, NULL);
 		}
 		if (!output) {
@@ -500,6 +506,8 @@ static GF_Err gf_media_isom_segment_file(GF_ISOFile *input, const char *output_f
 			opt = gf_cfg_get_key(dash_cfg->dash_ctx, RepSecName, "BitstreamSwitching");
 			if (opt && !strcmp(opt, "yes")) {
 				is_bs_switching = 1;
+				if (bs_switch_segment) 
+					gf_isom_delete(bs_switch_segment);
 				bs_switch_segment = output;
 				bs_switching_is_output = 1;
 				bs_switching_segment_name = gf_url_get_resource_name(gf_isom_get_filename(bs_switch_segment));
@@ -509,6 +517,12 @@ static GF_Err gf_media_isom_segment_file(GF_ISOFile *input, const char *output_f
 			if (opt) sscanf(opt, "%u", &bandwidth);
 		}
 		mpd_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
+		if (first_in_set && dash_cfg->use_segment_timeline) {
+			mpd_timeline_bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
+			sprintf(szMPDTempLine, "   <SegmentTimeline>\n");
+			gf_bs_write_data(mpd_timeline_bs, szMPDTempLine, strlen(szMPDTempLine));
+		}
+		
 	} else {
 		output = gf_isom_open(output_file, GF_ISOM_OPEN_WRITE, NULL);
 		if (!output) return gf_isom_last_error(NULL);
@@ -894,7 +908,7 @@ restart_fragmentation_pass:
 			} else {
 				start_range = gf_isom_get_file_size(output);
 				if (seg_rad_name) {
-					gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_SEGMENT, is_bs_switching, SegmentName, output_file, dash_input->representationID, seg_rad_name, !stricmp(seg_ext, "null") ? NULL : seg_ext, (u64) ( period_duration * timeline_timescale + segment_start_time), bandwidth, cur_seg);
+					gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_SEGMENT, is_bs_switching, SegmentName, output_file, dash_input->representationID, seg_rad_name, !stricmp(seg_ext, "null") ? NULL : seg_ext, (u64) ( period_duration * timeline_timescale + segment_start_time), bandwidth, cur_seg, dash_cfg->use_segment_timeline);
 					e = gf_isom_start_segment(output, SegmentName);
 
 					gf_dasher_store_segment_info(dash_cfg, SegmentName, period_duration + segment_start_time / 1000.0);
@@ -1198,6 +1212,32 @@ restart_fragmentation_pass:
 			}
 
 			if (force_switch_segment || ((SegmentDuration >= MaxSegmentDuration) && (!split_seg_at_rap || next_sample_rap))) {
+
+				if (mpd_timeline_bs) {
+
+					if (previous_segment_duration == SegmentDuration) {
+						segment_timeline_repeat_count ++;
+					} else {
+						if (previous_segment_duration) {
+							if (segment_timeline_repeat_count) {
+								sprintf(szMPDTempLine, " r=\"%d\"/>\n", segment_timeline_repeat_count);
+							} else {
+								sprintf(szMPDTempLine, "/>\n", segment_timeline_repeat_count);
+							}
+							gf_bs_write_data(mpd_timeline_bs, szMPDTempLine, strlen(szMPDTempLine));
+						}
+						previous_segment_duration = SegmentDuration;
+						if (first_segment_in_timeline) {
+							sprintf(szMPDTempLine, "    <S t=\""LLU"\" d=\""LLU"\"", (u64) (segment_start_time*timeline_timescale), (u64) SegmentDuration );
+							first_segment_in_timeline = 0;
+						} else {
+							sprintf(szMPDTempLine, "    <S d=\""LLU"\"", (u64) SegmentDuration);
+						}
+						gf_bs_write_data(mpd_timeline_bs, szMPDTempLine, strlen(szMPDTempLine));
+						segment_timeline_repeat_count = 0;
+					}	
+				}
+
 				segment_start_time += SegmentDuration;
 				nb_segments++;
 				if (max_segment_duration * 1000 <= SegmentDuration) {
@@ -1308,6 +1348,34 @@ restart_fragmentation_pass:
 			} else {
 				file_size += gf_isom_get_file_size(output);
 			}
+
+			if (mpd_timeline_bs) {
+				if (previous_segment_duration == SegmentDuration) {
+					segment_timeline_repeat_count ++;
+					sprintf(szMPDTempLine, " r=\"%d\"/>\n", segment_timeline_repeat_count);
+					gf_bs_write_data(mpd_timeline_bs, szMPDTempLine, strlen(szMPDTempLine));
+				} else {
+					if (previous_segment_duration) {
+						if (segment_timeline_repeat_count) {
+							sprintf(szMPDTempLine, " r=\"%d\"/>\n", segment_timeline_repeat_count);
+						} else {
+							sprintf(szMPDTempLine, "/>\n", segment_timeline_repeat_count);
+						}
+						gf_bs_write_data(mpd_timeline_bs, szMPDTempLine, strlen(szMPDTempLine));
+					}
+					if (first_segment_in_timeline) {
+						sprintf(szMPDTempLine, "    <S t=\""LLU"\" d=\""LLU"\"/>\n", (u64) (segment_start_time*timeline_timescale), (u64) SegmentDuration );
+						first_segment_in_timeline = 0;
+					} else {
+						sprintf(szMPDTempLine, "    <S d=\""LLU"\"/>\n", (u64) SegmentDuration);
+					}
+					gf_bs_write_data(mpd_timeline_bs, szMPDTempLine, strlen(szMPDTempLine));
+				}
+			}
+		}
+		if (mpd_timeline_bs) {
+			sprintf(szMPDTempLine, "   </SegmentTimeline>\n");
+			gf_bs_write_data(mpd_timeline_bs, szMPDTempLine, strlen(szMPDTempLine));
 		}
 
 		if (!bandwidth)
@@ -1317,27 +1385,62 @@ restart_fragmentation_pass:
 			/*segment template does not depend on file name, write the template at the adaptationSet level*/
 			if (!dash_cfg->variable_seg_rad_name && first_in_set) {
 				const char *rad_name = gf_url_get_resource_name(seg_rad_name);
-				gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_TEMPLATE, is_bs_switching, SegmentName, output_file, dash_input->representationID, rad_name, !stricmp(seg_ext, "null") ? NULL : seg_ext, 0, 0, 0);
+				gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_TEMPLATE, is_bs_switching, SegmentName, output_file, dash_input->representationID, rad_name, !stricmp(seg_ext, "null") ? NULL : seg_ext, 0, 0, 0, dash_cfg->use_segment_timeline);
 				fprintf(dash_cfg->mpd, "   <SegmentTemplate timescale=\"1000\" duration=\"%d\" media=\"%s\" startNumber=\"%d\"", (u32) (max_segment_duration*1000), SegmentName, startNumber - startNumberRewind);	
 				/*in BS switching we share the same IS for all reps*/
 				if (is_bs_switching) {
 					strcpy(SegmentName, bs_switching_segment_name);
 				} else {
-					gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_INITIALIZATION_TEMPLATE, is_bs_switching, SegmentName, output_file, dash_input->representationID, rad_name, !stricmp(seg_ext, "null") ? NULL : "mp4", 0, 0, 0);
+					gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_INITIALIZATION_TEMPLATE, is_bs_switching, SegmentName, output_file, dash_input->representationID, rad_name, !stricmp(seg_ext, "null") ? NULL : "mp4", 0, 0, 0, dash_cfg->use_segment_timeline);
 				}
 				fprintf(dash_cfg->mpd, " initialization=\"%s\"", SegmentName);
 				if (presentationTimeOffset) 
 					fprintf(dash_cfg->mpd, " presentationTimeOffset=\"%d\"", presentationTimeOffset);
-				fprintf(dash_cfg->mpd, "/>\n");
+
+				if (mpd_timeline_bs) {
+					char *mpd_seg_info = NULL;
+					u32 size;
+					fprintf(dash_cfg->mpd, ">\n");
+
+					gf_bs_get_content(mpd_timeline_bs, &mpd_seg_info, &size);
+					gf_fwrite(mpd_seg_info, 1, size, dash_cfg->mpd);
+					gf_free(mpd_seg_info);
+					fprintf(dash_cfg->mpd, "   </SegmentTemplate>\n");
+				} else {
+					fprintf(dash_cfg->mpd, "/>\n");
+				}
 			}
 			/*in BS switching we share the same IS for all reps, write the SegmentTemplate for the init segment*/
 			else if (is_bs_switching && first_in_set) {
 				fprintf(dash_cfg->mpd, "   <SegmentTemplate initialization=\"%s\"", bs_switching_segment_name);
 				if (presentationTimeOffset) 
 					fprintf(dash_cfg->mpd, " presentationTimeOffset=\"%d\"", presentationTimeOffset);
-				fprintf(dash_cfg->mpd, "/>\n");
+
+				if (mpd_timeline_bs) {
+					char *mpd_seg_info = NULL;
+					u32 size;
+					fprintf(dash_cfg->mpd, ">\n");
+
+					gf_bs_get_content(mpd_timeline_bs, &mpd_seg_info, &size);
+					gf_fwrite(mpd_seg_info, 1, size, dash_cfg->mpd);
+					gf_free(mpd_seg_info);
+					fprintf(dash_cfg->mpd, "   </SegmentTemplate>\n");
+				} else {
+					fprintf(dash_cfg->mpd, "/>\n");
+				}
 			}
 		}
+		else if ((dash_cfg->single_file_mode!=1) && mpd_timeline_bs) {
+			char *mpd_seg_info = NULL;
+			u32 size;
+
+			fprintf(dash_cfg->mpd, "    <SegmentList>\n");
+
+			gf_bs_get_content(mpd_timeline_bs, &mpd_seg_info, &size);
+			gf_fwrite(mpd_seg_info, 1, size, dash_cfg->mpd);
+			gf_free(mpd_seg_info);
+			fprintf(dash_cfg->mpd, "   </SegmentList>\n");
+		}
 
 
 		fprintf(dash_cfg->mpd, "   <Representation ");
@@ -1395,10 +1498,10 @@ restart_fragmentation_pass:
 			/*segment template depends on file name, but the template at the representation level*/
 			if (dash_cfg->variable_seg_rad_name) {
 				const char *rad_name = gf_url_get_resource_name(seg_rad_name);
-				gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_TEMPLATE, is_bs_switching, SegmentName, output_file, dash_input->representationID, rad_name, !stricmp(seg_ext, "null") ? NULL : seg_ext, 0, bandwidth, 0);
+				gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_TEMPLATE, is_bs_switching, SegmentName, output_file, dash_input->representationID, rad_name, !stricmp(seg_ext, "null") ? NULL : seg_ext, 0, bandwidth, 0, dash_cfg->use_segment_timeline);
 				fprintf(dash_cfg->mpd, "    <SegmentTemplate timescale=\"1000\" duration=\"%d\" media=\"%s\" startNumber=\"%d\"", (u32) (max_segment_duration*1000), SegmentName, startNumber - startNumberRewind);	
 				if (!is_bs_switching) {
-					gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_INITIALIZATION_TEMPLATE, is_bs_switching, SegmentName, output_file, dash_input->representationID, rad_name, !stricmp(seg_ext, "null") ? NULL : "mp4", 0, 0, 0);
+					gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_INITIALIZATION_TEMPLATE, is_bs_switching, SegmentName, output_file, dash_input->representationID, rad_name, !stricmp(seg_ext, "null") ? NULL : "mp4", 0, 0, 0, dash_cfg->use_segment_timeline);
 					fprintf(dash_cfg->mpd, " initialization=\"%s\"", SegmentName);
 				}
 				if (presentationTimeOffset) 
@@ -1425,7 +1528,7 @@ restart_fragmentation_pass:
 				if (!seg_rad_name) {
 					fprintf(dash_cfg->mpd, " range=\"0-"LLD"\"", init_seg_size-1);
 				} else {
-					gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_INITIALIZATION, is_bs_switching, SegmentName, output_file, dash_input->representationID, gf_url_get_resource_name( seg_rad_name) , !stricmp(seg_ext, "null") ? NULL : "mp4", 0, bandwidth, 0);
+					gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_INITIALIZATION, is_bs_switching, SegmentName, output_file, dash_input->representationID, gf_url_get_resource_name( seg_rad_name) , !stricmp(seg_ext, "null") ? NULL : "mp4", 0, bandwidth, 0, dash_cfg->use_segment_timeline);
 					fprintf(dash_cfg->mpd, " sourceURL=\"%s\"", SegmentName);
 				}
 				fprintf(dash_cfg->mpd, "/>\n");
@@ -1508,6 +1611,7 @@ err_exit:
 		gf_isom_delete(bs_switch_segment);
 	gf_set_progress("ISO File Fragmenting", nb_samp, nb_samp);
 	if (mpd_bs) gf_bs_del(mpd_bs);
+	if (mpd_timeline_bs) gf_bs_del(mpd_timeline_bs);
 	return e;
 }
 
@@ -1562,7 +1666,12 @@ static GF_Err dasher_isom_get_input_components_info(GF_DashSegInput *input, GF_D
 static GF_Err dasher_isom_classify_input(GF_DashSegInput *dash_inputs, u32 nb_dash_inputs, u32 input_idx, u32 *current_group_id, u32 *max_sap_type)
 {
 	u32 i, j;
-	GF_ISOFile *set_file = gf_isom_open(dash_inputs[input_idx].file_name, GF_ISOM_OPEN_READ, NULL);
+	GF_ISOFile *set_file;
+	
+	if (input_idx+1>=nb_dash_inputs)
+		return GF_OK;
+
+	set_file = gf_isom_open(dash_inputs[input_idx].file_name, GF_ISOM_OPEN_READ, NULL);
 
 	for (i=input_idx+1; i<nb_dash_inputs; i++) {
 		Bool valid_in_adaptation_set = 1;
@@ -1666,6 +1775,7 @@ static GF_Err dasher_isom_classify_input(GF_DashSegInput *dash_inputs, u32 nb_da
 			dash_inputs[i].group_id = (*current_group_id);
 		}
 	}
+	gf_isom_close(set_file);
 	return GF_OK;
 }
 
@@ -2560,7 +2670,7 @@ static GF_Err dasher_mp2t_segment_file(GF_DashSegInput *dash_input, const char *
 #ifndef GPAC_DISABLE_ISOM_FRAGMENTS
 		GF_SegmentTypeBox *styp;
 
-		gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_REPINDEX, 1, IdxName, szOutName, dash_input->representationID, dash_cfg->seg_rad_name, "six", 0, 0, 0);	
+		gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_REPINDEX, 1, IdxName, szOutName, dash_input->representationID, dash_cfg->seg_rad_name, "six", 0, 0, 0, dash_cfg->use_segment_timeline);	
 
 		ts_seg.index_file = gf_f64_open(IdxName, "wb");
 		if (!ts_seg.index_file) {
@@ -2582,7 +2692,7 @@ static GF_Err dasher_mp2t_segment_file(GF_DashSegInput *dash_input, const char *
 #endif
 	}
 
-	gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_REPINDEX, 1, IdxName, basename, dash_input->representationID, dash_cfg->seg_rad_name, "six", 0, 0, 0);	
+	gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_REPINDEX, 1, IdxName, basename, dash_input->representationID, dash_cfg->seg_rad_name, "six", 0, 0, 0, dash_cfg->use_segment_timeline);	
 
 	ts_seg.PCR_DTS_initial_diff = (u64) -1;
 	ts_seg.subduration = (u32) (dash_cfg->subduration * 90000);
@@ -2635,7 +2745,7 @@ static GF_Err dasher_mp2t_segment_file(GF_DashSegInput *dash_input, const char *
 	m2ts_sidx_finalize_size(&ts_seg, ts_seg.file_size);
 	GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[DASH]: Indexing done (1 sidx, %d entries).\n", ts_seg.sidx->nb_refs));
 
-	gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_REPINDEX, 1, IdxName, basename, dash_input->representationID, gf_url_get_resource_name(dash_cfg->seg_rad_name), "six", 0, 0, 0);	
+	gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_REPINDEX, 1, IdxName, basename, dash_input->representationID, gf_url_get_resource_name(dash_cfg->seg_rad_name), "six", 0, 0, 0, dash_cfg->use_segment_timeline);	
 
 
 	memset(is_pes, 0, sizeof(u8)*GF_M2TS_MAX_STREAMS);
@@ -2678,10 +2788,10 @@ static GF_Err dasher_mp2t_segment_file(GF_DashSegInput *dash_input, const char *
 
 	/*write segment template for all representations*/
 	if (first_in_set && dash_cfg->seg_rad_name && dash_cfg->use_url_template && !dash_cfg->variable_seg_rad_name) {
-		gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_TEMPLATE, 1, SegName, basename, dash_input->representationID, gf_url_get_resource_name(dash_cfg->seg_rad_name), "ts", 0, bandwidth, segment_index);
+		gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_TEMPLATE, 1, SegName, basename, dash_input->representationID, gf_url_get_resource_name(dash_cfg->seg_rad_name), "ts", 0, bandwidth, segment_index, dash_cfg->use_segment_timeline);
 		fprintf(dash_cfg->mpd, "   <SegmentTemplate timescale=\"90000\" duration=\"%d\" startNumber=\"%d\" media=\"%s\"", (u32) (90000*dash_cfg->segment_duration), segment_index - startNumberRewind, SegName); 
 		if (!dash_cfg->dash_ctx) {
-			gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_INITIALIZATION_TEMPLATE, 1, IdxName, basename, dash_input->representationID, gf_url_get_resource_name(dash_cfg->seg_rad_name), "six", 0, bandwidth, segment_index);
+			gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_INITIALIZATION_TEMPLATE, 1, IdxName, basename, dash_input->representationID, gf_url_get_resource_name(dash_cfg->seg_rad_name), "six", 0, bandwidth, segment_index, dash_cfg->use_segment_timeline);
 			fprintf(dash_cfg->mpd, " index=\"%s\"", IdxName); 
 		} 
 		fprintf(dash_cfg->mpd, "/>\n");
@@ -2710,7 +2820,7 @@ static GF_Err dasher_mp2t_segment_file(GF_DashSegInput *dash_input, const char *
 	fprintf(dash_cfg->mpd, ">\n");
 
 	if (dash_cfg->single_file_mode==1) {
-		gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_SEGMENT, 1, SegName, basename, dash_input->representationID, gf_url_get_resource_name(dash_cfg->seg_rad_name), "ts", 0, bandwidth, segment_index);
+		gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_SEGMENT, 1, SegName, basename, dash_input->representationID, gf_url_get_resource_name(dash_cfg->seg_rad_name), "ts", 0, bandwidth, segment_index, dash_cfg->use_segment_timeline);
 		fprintf(dash_cfg->mpd, "    <BaseURL>%s</BaseURL>\n", SegName);
 
 		fprintf(dash_cfg->mpd, "    <SegmentBase>\n");
@@ -2722,10 +2832,10 @@ static GF_Err dasher_mp2t_segment_file(GF_DashSegInput *dash_input, const char *
 	} else {
 		if (dash_cfg->seg_rad_name && dash_cfg->use_url_template) {
 			if (dash_cfg->variable_seg_rad_name) {
-				gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_TEMPLATE, 1, SegName, basename, dash_input->representationID, gf_url_get_resource_name(dash_cfg->seg_rad_name), "ts", 0, bandwidth, segment_index);
+				gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_TEMPLATE, 1, SegName, basename, dash_input->representationID, gf_url_get_resource_name(dash_cfg->seg_rad_name), "ts", 0, bandwidth, segment_index, dash_cfg->use_segment_timeline);
 				fprintf(dash_cfg->mpd, "    <SegmentTemplate timescale=\"90000\" duration=\"%d\" startNumber=\"%d\" media=\"%s\"", (u32) (9000*dash_cfg->segment_duration), segment_index, SegName); 
 				if (!dash_cfg->dash_ctx) {
-					gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_INITIALIZATION_TEMPLATE, 1, IdxName, basename, dash_input->representationID, gf_url_get_resource_name(dash_cfg->seg_rad_name), "six", 0, bandwidth, segment_index);
+					gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_INITIALIZATION_TEMPLATE, 1, IdxName, basename, dash_input->representationID, gf_url_get_resource_name(dash_cfg->seg_rad_name), "six", 0, bandwidth, segment_index, dash_cfg->use_segment_timeline);
 					fprintf(dash_cfg->mpd, " index=\"%s\"", IdxName); 
 				}
 
@@ -2737,7 +2847,7 @@ static GF_Err dasher_mp2t_segment_file(GF_DashSegInput *dash_input, const char *
 				GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH]: PTSOffset "LLD" - startNumber %d - time %g\n", ts_seg.sidx->earliest_presentation_time + pcr_shift, segment_index, (Double) (s64) (ts_seg.sidx->earliest_presentation_time + pcr_shift) / 90000.0));
 			}
 		} else {
-			gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_SEGMENT, 1, SegName, basename, dash_input->representationID, gf_url_get_resource_name(dash_cfg->seg_rad_name), "ts", 0, bandwidth, segment_index);
+			gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_SEGMENT, 1, SegName, basename, dash_input->representationID, gf_url_get_resource_name(dash_cfg->seg_rad_name), "ts", 0, bandwidth, segment_index, dash_cfg->use_segment_timeline);
 			if (dash_cfg->single_file_mode)
 				fprintf(dash_cfg->mpd, "    <BaseURL>%s</BaseURL>\n",SegName);
 			fprintf(dash_cfg->mpd, "    <SegmentList timescale=\"90000\" duration=\"%d\"", (u32) (90000*dash_cfg->segment_duration)); 
@@ -2783,7 +2893,7 @@ static GF_Err dasher_mp2t_segment_file(GF_DashSegInput *dash_input, const char *
 				char buf[NB_TSPCK_IO_BYTES];
 				GF_SIDXReference *ref = &ts_seg.sidx->refs[i];
 
-				gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_SEGMENT, 1, SegName, szOutName, dash_input->representationID, dash_cfg->seg_rad_name, "ts", 0, bandwidth, segment_index);
+				gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_SEGMENT, 1, SegName, szOutName, dash_input->representationID, dash_cfg->seg_rad_name, "ts", 0, bandwidth, segment_index, dash_cfg->use_segment_timeline);
 
 				/*warning - we may introduce repeated sequence number when concatenating files. We should use switching 
 				segments to force reset of the continuity counter for all our pids - we don't because most players don't car ...*/
@@ -2826,7 +2936,7 @@ static GF_Err dasher_mp2t_segment_file(GF_DashSegInput *dash_input, const char *
 				start += ref->reference_size;
 
 				if (!dash_cfg->use_url_template) {
-					gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_SEGMENT, 1, SegName, basename, dash_input->representationID, dash_cfg->seg_rad_name, "ts", 0, bandwidth, segment_index);
+					gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_SEGMENT, 1, SegName, basename, dash_input->representationID, dash_cfg->seg_rad_name, "ts", 0, bandwidth, segment_index, dash_cfg->use_segment_timeline);
 					fprintf(dash_cfg->mpd, "     <SegmentURL media=\"%s\"/>\n", SegName);
 
 					if (dash_cfg->dash_ctx) {
@@ -2853,7 +2963,7 @@ static GF_Err dasher_mp2t_segment_file(GF_DashSegInput *dash_input, const char *
 		u64 fsize, done;
 		char buf[NB_TSPCK_IO_BYTES];
 
-		gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_SEGMENT, 1, SegName, dash_cfg->seg_rad_name ? basename : szOutName, dash_input->representationID, gf_url_get_resource_name(dash_cfg->seg_rad_name), "ts", 0, bandwidth, segment_index);
+		gf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_SEGMENT, 1, SegName, dash_cfg->seg_rad_name ? basename : szOutName, dash_input->representationID, gf_url_get_resource_name(dash_cfg->seg_rad_name), "ts", 0, bandwidth, segment_index, dash_cfg->use_segment_timeline);
 		out = gf_f64_open(SegName, "wb");
 		if (!out) {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH]: Cannot create segment file %s\n", SegName));
@@ -2967,34 +3077,44 @@ GF_Err gf_dash_segmenter_probe_input(GF_DashSegInput *dash_input)
 
 static GF_Err write_mpd_header(FILE *mpd, const char *mpd_name, GF_Config *dash_ctx, GF_DashProfile profile, Bool is_mpeg2, const char *title, const char *source, const char *copyright, const char *moreInfoURL, const char **mpd_base_urls, u32 nb_mpd_base_urls, Bool dash_dynamic, u32 time_shift_depth, Double mpd_duration, Double mpd_update_period, Double min_buffer, u32 ast_shift_sec)
 {
+#ifndef _WIN32_WCE
+		u32 sec, frac;
+		time_t gtime;
+		struct tm *t;
+#endif
 	u32 h, m, i;
 	Double s;
 
+	gf_net_get_ntp(&sec, &frac);
+	sec += ast_shift_sec;
+	
 	fprintf(mpd, "<?xml version=\"1.0\"?>\n");
-	fprintf(mpd, "<!-- MPD file Generated with GPAC version "GPAC_FULL_VERSION" -->\n");
+	fprintf(mpd, "<!-- MPD file Generated with GPAC version "GPAC_FULL_VERSION" ");
+
+#ifndef _WIN32_WCE
+	gtime = sec - GF_NTP_SEC_1900_TO_1970;
+	t = gmtime(&gtime);
+	fprintf(mpd, " on %d-%02d-%02dT%02d:%02d:%02dZ", 1900+t->tm_year, t->tm_mon+1, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
+	GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[DASH] Generating MPD at time %d-%02d-%02dT%02d:%02d:%02dZ\n", 1900+t->tm_year, t->tm_mon+1, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec) );
+#endif
+	fprintf(mpd, "-->\n");
 
 	/*TODO what should we put for minBufferTime */
 	fprintf(mpd, "<MPD xmlns=\"urn:mpeg:dash:schema:mpd:2011\" minBufferTime=\"PT%fS\" type=\"%s\"", min_buffer, dash_dynamic ? "dynamic" : "static"); 
 	if (dash_dynamic) {
 #ifndef _WIN32_WCE
-		u32 sec, frac;
-		time_t gtime;
-		struct tm *t;
-		gf_net_get_ntp(&sec, &frac);
 
-		/*if time shift buffer depth is set, set availability start time to now minus timeshift buffer depth*/
-		if ((s32)time_shift_depth>=0) {
-			sec -= time_shift_depth;
-		} 
 		/*otherwise timeshift is infinite, use original availability start time*/
-		else if (dash_ctx) {
+		if ((s32)time_shift_depth<0) {
 			const char *opt = gf_cfg_get_key(dash_ctx, "DASH", "GenerationNTP");
 			sscanf(opt, "%u", &sec);
 		}
 		gtime = sec - GF_NTP_SEC_1900_TO_1970;
-		gtime += ast_shift_sec;
 		t = gmtime(&gtime);
 		fprintf(mpd, " availabilityStartTime=\"%d-%02d-%02dT%02d:%02d:%02dZ\"", 1900+t->tm_year, t->tm_mon+1, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
+		if (ast_shift_sec) {
+			GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[DASH] MPD AvailabilityStartTime %d-%02d-%02dT%02d:%02d:%02dZ\n", 1900+t->tm_year, t->tm_mon+1, t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec) );
+		}
 #endif
 
 		if ((s32)time_shift_depth>=0) {
@@ -3168,7 +3288,7 @@ static GF_Err gf_dasher_init_context(GF_Config *dash_ctx, u32 *dynamic, u32 *tim
 	Bool first_run = 0;
 	u32 sec, frac;
 #ifndef _WIN32_WCE
-		time_t gtime;
+	time_t gtime;
 #endif
 
 	if (!dash_ctx) return GF_BAD_PARAM;
@@ -3193,6 +3313,7 @@ static GF_Err gf_dasher_init_context(GF_Config *dash_ctx, u32 *dynamic, u32 *tim
 	gf_cfg_set_key(dash_ctx, "DASH", "PeriodSwitch", "no");
 	
 	gf_net_get_ntp(&sec, &frac);
+
 	if (first_run) {
 #ifndef _WIN32_WCE
 		gtime = sec - GF_NTP_SEC_1900_TO_1970;
@@ -3272,7 +3393,7 @@ u32 gf_dasher_next_update_time(GF_Config *dash_ctx, u32 mpd_update_time)
 }
 
 /*peform all file cleanup*/
-static Bool gf_dasher_cleanup(GF_Config *dash_ctx, u32 dash_dynamic, u32 mpd_update_time, u32 time_shift_depth, Double dash_duration)
+static Bool gf_dasher_cleanup(GF_Config *dash_ctx, u32 dash_dynamic, u32 mpd_update_time, u32 time_shift_depth, Double dash_duration, u32 ast_shift_sec)
 {
 	Double max_dur = 0;
 	Double ellapsed = 0;
@@ -3331,9 +3452,17 @@ static Bool gf_dasher_cleanup(GF_Config *dash_ctx, u32 dash_dynamic, u32 mpd_upd
 				break;
 
 			seg_time = atof(MPDTime);
-			if (seg_time + dash_duration + time_shift_depth >= ellapsed )
+			seg_time += ast_shift_sec;
+			seg_time += dash_duration + time_shift_depth;
+			seg_time -= ellapsed;
+			/*safety gard of one second*/
+			if (seg_time >= -1)
 				break;
 
+			if (dash_dynamic!=2) {
+				GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[DASH] Removing segment %s - %g sec too late\n", fileName, -seg_time));
+			}
+
 			e = gf_delete_file(fileName);
 			if (e) {
 				GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[DASH] Could not remove file %s: %s\n", fileName, gf_error_to_string(e) ));
@@ -3370,7 +3499,7 @@ GF_EXPORT
 GF_Err gf_dasher_segment_files(const char *mpdfile, GF_DashSegmenterInput *inputs, u32 nb_dash_inputs, GF_DashProfile dash_profile, 
 							   const char *mpd_title, const char *mpd_source, const char *mpd_copyright,
 							   const char *mpd_moreInfoURL, const char **mpd_base_urls, u32 nb_mpd_base_urls, 
-							   Bool use_url_template, Bool single_segment, Bool single_file, GF_DashSwitchingMode bitstream_switching, 
+							   Bool use_url_template, Bool use_segment_timeline,  Bool single_segment, Bool single_file, GF_DashSwitchingMode bitstream_switching, 
 							   Bool seg_at_rap, Double dash_duration, char *seg_name, char *seg_ext,
 							   Double frag_duration, s32 subsegs_per_sidx, Bool daisy_chain_sidx, Bool frag_at_rap, const char *tmpdir,
 							   GF_Config *dash_ctx, u32 dash_dynamic, u32 mpd_update_time, u32 time_shift_depth, Double subduration, Double min_buffer, u32 ast_shift_sec)
@@ -3415,7 +3544,7 @@ GF_Err gf_dasher_segment_files(const char *mpdfile, GF_DashSegmenterInput *input
 			}
 
 			/*peform all file cleanup*/
-			regenerate = gf_dasher_cleanup(dash_ctx, dash_dynamic, mpd_update_time, time_shift_depth, dash_duration);
+			regenerate = gf_dasher_cleanup(dash_ctx, dash_dynamic, mpd_update_time, time_shift_depth, dash_duration, ast_shift_sec);
 			if (!regenerate) return GF_OK;
 		}
 	}
@@ -3470,7 +3599,8 @@ GF_Err gf_dasher_segment_files(const char *mpdfile, GF_DashSegmenterInput *input
 	}
 	if (dash_dynamic && max_period>1) {
 		GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[DASH] Multiple periods in live mode not supported\n"));
-		return GF_NOT_SUPPORTED;
+		e = GF_NOT_SUPPORTED;
+		goto exit;
 	}
 
 	for (cur_period=0; cur_period<max_period; cur_period++) {
@@ -3497,7 +3627,8 @@ GF_Err gf_dasher_segment_files(const char *mpdfile, GF_DashSegmenterInput *input
 		}
 		if (none_supported) {
 			GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[DASH]: None of the input types are supported for DASHing - nothing to do ...\n"));
-			return GF_OK;
+			e = GF_OK;
+			goto exit;
 		}
 	}
 
@@ -3575,6 +3706,7 @@ GF_Err gf_dasher_segment_files(const char *mpdfile, GF_DashSegmenterInput *input
 	dash_opts.daisy_chain_sidx = daisy_chain_sidx;
 	dash_opts.subsegs_per_sidx = subsegs_per_sidx;
 	dash_opts.use_url_template = use_url_template;
+	dash_opts.use_segment_timeline = use_segment_timeline;
 	dash_opts.single_file_mode = segment_mode;
 	dash_opts.fragments_start_with_rap = frag_at_rap;
 	dash_opts.fragment_duration = frag_duration;
@@ -3617,7 +3749,8 @@ GF_Err gf_dasher_segment_files(const char *mpdfile, GF_DashSegmenterInput *input
 	mpd = gf_f64_open(szTempMPD, "wt");
 	if (!mpd) {
 		GF_LOG(GF_LOG_INFO, GF_LOG_AUTHOR, ("[MPD] Cannot open MPD file %s for writing\n", szTempMPD));
-		return GF_IO_ERR;
+		e = GF_IO_ERR;
+		goto exit;
 	}
 
 	dash_opts.mpd = mpd;
@@ -3787,12 +3920,12 @@ GF_Err gf_dasher_segment_files(const char *mpdfile, GF_DashSegmenterInput *input
 	fprintf(mpd, "</MPD>");
 
 exit:
-
 	if (mpd) {
 		fclose(mpd);
 		if (!e && dash_dynamic)
 			gf_move_file(szTempMPD, mpdfile);
 	}
+	gf_free(dash_inputs);
 	return e;
 }
 
diff --git a/src/terminal/channel.c b/src/terminal/channel.c
index be98760c7..ef13d030f 100644
--- a/src/terminal/channel.c
+++ b/src/terminal/channel.c
@@ -692,9 +692,9 @@ void gf_es_dispatch_raw_media_au(GF_Channel *ch, char *payload, u32 payload_size
 		if (ch->MinBuffer && (ch->is_raw_channel==2)) {
 			ch->clock->clock_init = 0;
 			gf_clock_set_time(ch->clock, cts);
-			GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[ODM%d] Raw Frame dispatched at OTB %d but frame TS is %d ms - adjusting clock\n", ch->odm->OD->objectDescriptorID, now, cts));
+			GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[ODM%d] Raw Frame dispatched at OTB %u but frame TS is %u ms - adjusting clock\n", ch->odm->OD->objectDescriptorID, now, cts));
 		} else {
-			GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[ODM%d] Raw Frame dispatched at OTB %d but frame TS is %d ms - DROPPING\n", ch->odm->OD->objectDescriptorID, now, cts));
+			GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[ODM%d] Raw Frame dispatched at OTB %u but frame TS is %u ms - DROPPING\n", ch->odm->OD->objectDescriptorID, now, cts));
 		}
 		return;
 	}
@@ -815,7 +815,7 @@ void gf_es_receive_sl_packet(GF_ClientService *serv, GF_Channel *ch, char *paylo
 			u32 ck;
 			u32 OCR_TS = (u32) ( hdr.objectClockReference / 27000);
 			ck = gf_clock_time(ch->clock);
-			GF_LOG(GF_LOG_DEBUG, GF_LOG_SYNC, ("[SyncLayer] ES%d: At OTB %d - OCR Discontinuity OCR: adjusting to %d (original TS "LLD") - original clock %d\n", ch->esd->ESID, gf_clock_real_time(ch->clock), OCR_TS, hdr.objectClockReference, ck));
+			GF_LOG(GF_LOG_DEBUG, GF_LOG_SYNC, ("[SyncLayer] ES%d: At OTB %u - OCR Discontinuity OCR: adjusting to %d (original TS "LLD") - original clock %d\n", ch->esd->ESID, gf_clock_real_time(ch->clock), OCR_TS, hdr.objectClockReference, ck));
 //			gf_clock_set_time(ch->clock, (u32) OCR_TS);
 		}
 		/*compute clock drift*/
@@ -828,7 +828,7 @@ void gf_es_receive_sl_packet(GF_ClientService *serv, GF_Channel *ch, char *paylo
 				OCR_TS = (u32) ( (s64) (hdr.objectClockReference) * ch->ocr_scale);
 			}
 			ck = gf_clock_time(ch->clock);
-			GF_LOG(GF_LOG_DEBUG, GF_LOG_SYNC, ("[SyncLayer] ES%d: At OTB %d adjusting OCR to %d (original TS "LLD") - diff %d\n", ch->esd->ESID, gf_clock_real_time(ch->clock), OCR_TS, hdr.objectClockReference, (s32) OCR_TS - (s32) ck));
+			GF_LOG(GF_LOG_DEBUG, GF_LOG_SYNC, ("[SyncLayer] ES%d: At OTB %u adjusting OCR to %d (original TS "LLD") - diff %d\n", ch->esd->ESID, gf_clock_real_time(ch->clock), OCR_TS, hdr.objectClockReference, (s32) OCR_TS - (s32) ck));
 //			gf_clock_set_time(ch->clock, (u32) OCR_TS);
 		}
 #else
@@ -841,7 +841,7 @@ void gf_es_receive_sl_packet(GF_ClientService *serv, GF_Channel *ch, char *paylo
 				OCR_TS = (u32) ( (s64) (hdr.objectClockReference) * ch->ocr_scale);
 			}
 			ck = gf_clock_time(ch->clock);
-			GF_LOG(GF_LOG_DEBUG, GF_LOG_SYNC, ("[SyncLayer] ES%d: At OTB %d got OCR %d (original TS "LLD") - diff %d%s\n", ch->esd->ESID, gf_clock_real_time(ch->clock), OCR_TS, hdr.objectClockReference, (s32) OCR_TS - (s32) ck, (hdr.m2ts_pcr==2) ? " - PCR Discontinuity flag" : "" ));
+			GF_LOG(GF_LOG_DEBUG, GF_LOG_SYNC, ("[SyncLayer] ES%d: At OTB %u got OCR %u (original TS "LLU") - diff %d%s\n", ch->esd->ESID, gf_clock_real_time(ch->clock), OCR_TS, hdr.objectClockReference, (s32) OCR_TS - (s32) ck, (hdr.m2ts_pcr==2) ? " - PCR Discontinuity flag" : "" ));
 		}
 #endif
 		if (!payload_size) return;
diff --git a/src/terminal/clock.c b/src/terminal/clock.c
index b559596c9..e979e47c0 100644
--- a/src/terminal/clock.c
+++ b/src/terminal/clock.c
@@ -228,7 +228,7 @@ u32 gf_clock_real_time(GF_Clock *ck)
 u32 gf_clock_time(GF_Clock *ck)
 {
 	u32 time = gf_clock_real_time(ck);
-	if ((s32) time < ck->drift) return 0;
+	if ((ck->drift>0) && (time < (u32) ck->drift)) return 0;
 	return time - ck->drift;
 }
 
diff --git a/src/terminal/media_object.c b/src/terminal/media_object.c
index 189dc0b2b..e93c66947 100644
--- a/src/terminal/media_object.c
+++ b/src/terminal/media_object.c
@@ -430,7 +430,7 @@ char *gf_mo_fetch_data(GF_MediaObject *mo, Bool resync, Bool *eos, u32 *timestam
 			}
 			nb_droped ++;
 			if (nb_droped>1) {
-				GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("[ODM%d] At OTB %d dropped frame TS %d\n", mo->odm->OD->objectDescriptorID, obj_time, CU->TS));
+				GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("[ODM%d] At OTB %u dropped frame TS %u\n", mo->odm->OD->objectDescriptorID, obj_time, CU->TS));
 				mo->odm->codec->nb_droped++;
 			}
 			/*discard*/
@@ -454,7 +454,7 @@ char *gf_mo_fetch_data(GF_MediaObject *mo, Bool resync, Bool *eos, u32 *timestam
 			mo->odm->parentscene->root_od->current_time = mo->odm->current_time;
 
 		mo->timestamp = CU->TS;
-		GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, ("[ODM%d] At OTB %d fetch frame TS %d size %d - %d unit in CB\n", mo->odm->OD->objectDescriptorID, gf_clock_time(mo->odm->codec->ck), mo->timestamp, mo->framesize, mo->odm->codec->CB->UnitCount));
+		GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, ("[ODM%d] At OTB %u fetch frame TS %u size %d - %d unit in CB\n", mo->odm->OD->objectDescriptorID, gf_clock_time(mo->odm->codec->ck), mo->timestamp, mo->framesize, mo->odm->codec->CB->UnitCount));
 		/*signal EOS after rendering last frame, not while rendering it*/
 		*eos = 0;
 	}
diff --git a/src/terminal/object_manager.c b/src/terminal/object_manager.c
index 49eebf4e0..2f1171971 100644
--- a/src/terminal/object_manager.c
+++ b/src/terminal/object_manager.c
@@ -1351,7 +1351,7 @@ void gf_odm_start(GF_ObjectManager *odm, u32 media_queue_state)
 			before one starts playing*/
 			while ( (ch = (GF_Channel*)gf_list_enum(odm->channels, &i)) ) {
 				gf_es_start(ch);
-				GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("[ODM%d] CH%d: At OTB %d starting channel\n", odm->OD->objectDescriptorID, ch->esd->ESID, gf_clock_time(ch->clock)));
+				GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("[ODM%d] CH%d: At OTB %u starting channel\n", odm->OD->objectDescriptorID, ch->esd->ESID, gf_clock_time(ch->clock)));
 			}
 			skip_register = 0;
 		}
@@ -1526,7 +1526,7 @@ void gf_odm_play(GF_ObjectManager *odm)
 			}
 		} else {
 			gf_term_service_command(ch->service, &com);
-			GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("[ODM%d] CH%d: At OTB %d requesting PLAY from %g to %g (clock init %d)\n", odm->OD->objectDescriptorID, ch->esd->ESID, gf_clock_time(ch->clock), com.play.start_range, com.play.end_range, ch->clock->clock_init));
+			GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("[ODM%d] CH%d: At OTB %u requesting PLAY from %g to %g (clock init %d)\n", odm->OD->objectDescriptorID, ch->esd->ESID, gf_clock_time(ch->clock), com.play.start_range, com.play.end_range, ch->clock->clock_init));
 		}
 	}
 //	odm->media_start_time = 0;
@@ -1672,7 +1672,7 @@ void gf_odm_stop(GF_ObjectManager *odm, Bool force_close)
 		if (ch->service) {
 			com.base.on_channel = ch;
 			gf_term_service_command(ch->service, &com);
-			GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("[ODM%d] CH %d At OTB %d requesting STOP\n", odm->OD->objectDescriptorID, ch->esd->ESID, gf_clock_time(ch->clock)));
+			GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("[ODM%d] CH %d At OTB %u requesting STOP\n", odm->OD->objectDescriptorID, ch->esd->ESID, gf_clock_time(ch->clock)));
 		}
 	}
 	gf_term_service_media_event(odm, GF_EVENT_ABORT);
@@ -1840,7 +1840,7 @@ void gf_odm_pause(GF_ObjectManager *odm)
 		gf_clock_pause(ch->clock);
 		com.base.on_channel = ch;
 		gf_term_service_command(ch->service, &com);
-		GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("[ODM%d] CH%d: At OTB %d requesting PAUSE (clock init %d)\n", odm->OD->objectDescriptorID, ch->esd->ESID, gf_clock_time(ch->clock), ch->clock->clock_init ));
+		GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("[ODM%d] CH%d: At OTB %u requesting PAUSE (clock init %d)\n", odm->OD->objectDescriptorID, ch->esd->ESID, gf_clock_time(ch->clock), ch->clock->clock_init ));
 	}
 
 #ifndef GPAC_DISABLE_VRML
@@ -1892,7 +1892,7 @@ void gf_odm_resume(GF_ObjectManager *odm)
 		gf_clock_resume(ch->clock);
 		com.base.on_channel = ch;
 		gf_term_service_command(ch->service, &com);
-		GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("[ODM%d] CH%d: At OTB %d requesting RESUME (clock init %d)\n", odm->OD->objectDescriptorID, ch->esd->ESID, gf_clock_time(ch->clock), ch->clock->clock_init ));
+		GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("[ODM%d] CH%d: At OTB %u requesting RESUME (clock init %d)\n", odm->OD->objectDescriptorID, ch->esd->ESID, gf_clock_time(ch->clock), ch->clock->clock_init ));
 
 		/*override speed with MC*/
 		if (ctrl) {
diff --git a/src/utils/downloader.c b/src/utils/downloader.c
index ccdde23ea..4b3c947cf 100644
--- a/src/utils/downloader.c
+++ b/src/utils/downloader.c
@@ -2186,7 +2186,7 @@ static GF_Err wait_for_header_and_parse(GF_DownloadSession *sess, char * sHTTP)
     u32 res;
     s32 LinePos, Pos;
     u32 rsp_code, ContentLength, first_byte, last_byte, total_size, range, no_range;
-    char buf[1024];
+    char buf[1025];
     char comp[400];
     GF_Err e;
     char * new_location;
@@ -2510,7 +2510,11 @@ static GF_Err wait_for_header_and_parse(GF_DownloadSession *sess, char * sHTTP)
     case 404:
         /* File not found */
         gf_dm_sess_user_io(sess, &par);
-        e = GF_URL_ERROR;
+		if ((BodyStart < (s32) bytesRead)) {
+			sHTTP[bytesRead] = 0;
+			GF_LOG(GF_LOG_ERROR, GF_LOG_NETWORK, ("[HTTP] Failure: %s\n", sHTTP + BodyStart));
+		}
+		e = GF_URL_ERROR;
         goto exit;
         break;
     case 416:

