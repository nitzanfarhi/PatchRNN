commit ffa9f12a41ec117207e8d953f90b9c179546c8d7
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Sep 25 00:32:59 2009 -0600

    module: don't call percpu_modfree on NULL pointer.
    
    The general one handles NULL, the static obsolescent
    (CONFIG_HAVE_LEGACY_PER_CPU_AREA) one in module.c doesn't; Eric's
    commit 720eba31 assumed it did, and various frobbings since then kept
    that assumption.
    
    All other callers in module.c all protect it with an if; this effectively
    does the same as free_init is only goto if we fail percpu_modalloc().
    
    Reported-by: Kamalesh Babulal <kamalesh@linux.vnet.ibm.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Eric Dumazet <dada1@cosmosbay.com>
    Cc: Masami Hiramatsu <mhiramat@redhat.com>
    Cc: Am√©rico Wang <xiyou.wangcong@gmail.com>
    Tested-by: Kamalesh Babulal <kamalesh@linux.vnet.ibm.com>

diff --git a/kernel/module.c b/kernel/module.c
index c54f10d90e1c..5a29397ca4b6 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -2523,8 +2523,8 @@ static noinline struct module *load_module(void __user *umod,
  free_unload:
 	module_unload_free(mod);
 #if defined(CONFIG_MODULE_UNLOAD) && defined(CONFIG_SMP)
- free_init:
 	percpu_modfree(mod->refptr);
+ free_init:
 #endif
 	module_free(mod, mod->module_init);
  free_core:

