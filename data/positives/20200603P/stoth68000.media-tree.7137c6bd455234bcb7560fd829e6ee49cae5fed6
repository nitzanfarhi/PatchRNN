commit 7137c6bd455234bcb7560fd829e6ee49cae5fed6
Author: Jan Kara <jack@suse.cz>
Date:   Fri Feb 25 14:44:27 2011 -0800

    aio: fix race between io_destroy() and io_submit()
    
    A race can occur when io_submit() races with io_destroy():
    
     CPU1                                           CPU2
    io_submit()
      do_io_submit()
        ...
        ctx = lookup_ioctx(ctx_id);
                                                    io_destroy()
        Now do_io_submit() holds the last reference to ctx.
        ...
        queue new AIO
        put_ioctx(ctx) - frees ctx with active AIOs
    
    We solve this issue by checking whether ctx is being destroyed in AIO
    submission path after adding new AIO to ctx.  Then we are guaranteed that
    either io_destroy() waits for new AIO or we see that ctx is being
    destroyed and bail out.
    
    Cc: Nick Piggin <npiggin@kernel.dk>
    Reviewed-by: Jeff Moyer <jmoyer@redhat.com>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/fs/aio.c b/fs/aio.c
index b4dd668fbccc..26869cde3953 100644
--- a/fs/aio.c
+++ b/fs/aio.c
@@ -1642,6 +1642,23 @@ static int io_submit_one(struct kioctx *ctx, struct iocb __user *user_iocb,
 		goto out_put_req;
 
 	spin_lock_irq(&ctx->ctx_lock);
+	/*
+	 * We could have raced with io_destroy() and are currently holding a
+	 * reference to ctx which should be destroyed. We cannot submit IO
+	 * since ctx gets freed as soon as io_submit() puts its reference.  The
+	 * check here is reliable: io_destroy() sets ctx->dead before waiting
+	 * for outstanding IO and the barrier between these two is realized by
+	 * unlock of mm->ioctx_lock and lock of ctx->ctx_lock.  Analogously we
+	 * increment ctx->reqs_active before checking for ctx->dead and the
+	 * barrier is realized by unlock and lock of ctx->ctx_lock. Thus if we
+	 * don't see ctx->dead set here, io_destroy() waits for our IO to
+	 * finish.
+	 */
+	if (ctx->dead) {
+		spin_unlock_irq(&ctx->ctx_lock);
+		ret = -EINVAL;
+		goto out_put_req;
+	}
 	aio_run_iocb(req);
 	if (!list_empty(&ctx->run_list)) {
 		/* drain the run list */

