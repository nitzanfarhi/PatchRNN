commit 2848e2ffca9bf7bcac15368f39d81ac54398f718
Author: David Vossel <dvossel@redhat.com>
Date:   Mon Nov 3 12:07:24 2014 -0500

    Fix: dbus ref count leaks

diff --git a/lib/services/dbus.c b/lib/services/dbus.c
index 8c6890830..b62c1af5c 100644
--- a/lib/services/dbus.c
+++ b/lib/services/dbus.c
@@ -314,6 +314,9 @@ pcmk_dbus_lookup_cb(DBusPendingCall *pending, void *user_data)
 
     pcmk_dbus_lookup_result(reply, user_data);
 
+    if(pending) {
+        dbus_pending_call_unref(pending);
+    }
     if(reply) {
         dbus_message_unref(reply);
     }
diff --git a/lib/services/systemd.c b/lib/services/systemd.c
index df815561a..51ade44aa 100644
--- a/lib/services/systemd.c
+++ b/lib/services/systemd.c
@@ -196,6 +196,9 @@ systemd_loadunit_cb(DBusPendingCall *pending, void *user_data)
     }
     systemd_loadunit_result(reply, user_data);
 
+    if(pending) {
+        dbus_pending_call_unref(pending);
+    }
     if(reply) {
         dbus_message_unref(reply);
     }
@@ -247,6 +250,7 @@ systemd_unit_by_name(const gchar * arg_name, svc_action_t *op)
     }
 
     pcmk_dbus_send(msg, systemd_proxy, systemd_loadunit_cb, op);
+    dbus_message_unref(msg);
     return NULL;
 }
 
@@ -585,6 +589,7 @@ systemd_unit_exec_with_unit(svc_action_t * op, const char *unit)
     if (op->synchronous == FALSE) {
         DBusPendingCall* pending = pcmk_dbus_send(msg, systemd_proxy, systemd_async_dispatch, op);
 
+        dbus_message_unref(msg);
         if(pending) {
             dbus_pending_call_ref(pending);
             op->opaque->pending = pending;
@@ -596,22 +601,15 @@ systemd_unit_exec_with_unit(svc_action_t * op, const char *unit)
         DBusError error;
 
         reply = pcmk_dbus_send_recv(msg, systemd_proxy, &error);
+        dbus_message_unref(msg);
         systemd_exec_result(reply, op);
 
         if(reply) {
             dbus_message_unref(reply);
         }
-        if(msg) {
-            dbus_message_unref(msg);
-        }
-
         return FALSE;
     }
 
-    if(msg) {
-        dbus_message_unref(msg);
-    }
-
   cleanup:
     if (op->synchronous == FALSE) {
         operation_finalize(op);

