commit 44424c34049f41123a3a8b4853822f47f4ff03a2
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Tue Jul 30 23:09:46 2013 +0100

    ARM: 7803/1: Fix deadlock scenario with smp_send_stop()
    
    If one process calls sys_reboot and that process then stops other
    CPUs while those CPUs are within a spin_lock() region we can
    potentially encounter a deadlock scenario like below.
    
    CPU 0                   CPU 1
    -----                   -----
                            spin_lock(my_lock)
    smp_send_stop()
     <send IPI>             handle_IPI()
                             disable_preemption/irqs
                              while(1);
     <PREEMPT>
    spin_lock(my_lock) <--- Waits forever
    
    We shouldn't attempt to run any other tasks after we send a stop
    IPI to a CPU so disable preemption so that this task runs to
    completion. We use local_irq_disable() here for cross-arch
    consistency with x86.
    
    Reported-by: Sundarajan Srinivasan <sundaraj@codeaurora.com>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c
index d3ca4f6915af..08b47ebd3144 100644
--- a/arch/arm/kernel/process.c
+++ b/arch/arm/kernel/process.c
@@ -197,6 +197,7 @@ void machine_shutdown(void)
  */
 void machine_halt(void)
 {
+	local_irq_disable();
 	smp_send_stop();
 
 	local_irq_disable();
@@ -211,6 +212,7 @@ void machine_halt(void)
  */
 void machine_power_off(void)
 {
+	local_irq_disable();
 	smp_send_stop();
 
 	if (pm_power_off)
@@ -230,6 +232,7 @@ void machine_power_off(void)
  */
 void machine_restart(char *cmd)
 {
+	local_irq_disable();
 	smp_send_stop();
 
 	arm_pm_restart(reboot_mode, cmd);

