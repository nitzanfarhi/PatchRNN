commit d1ed3ba4e3d76b4ebec239c64f990c26d7935700
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Mar 8 18:46:13 2016 -0800

    watchdog: Ensure that wdd is not dereferenced if NULL
    
    Smatch rightfully complains that wdd is dereferenced in the watchdog
    release function after being checked for NULL. Also make sure that it
    is not accessed outside mutex protection to avoid use-after-free problems.
    
    Fixes: e6c71e84e4c0 ("watchdog: Introduce WDOG_HW_RUNNING flag")
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wim Van Sebroeck <wim@iguana.be>

diff --git a/drivers/watchdog/watchdog_dev.c b/drivers/watchdog/watchdog_dev.c
index 2d6110278eac..e2c5abbb45ff 100644
--- a/drivers/watchdog/watchdog_dev.c
+++ b/drivers/watchdog/watchdog_dev.c
@@ -711,6 +711,7 @@ static int watchdog_release(struct inode *inode, struct file *file)
 	struct watchdog_core_data *wd_data = file->private_data;
 	struct watchdog_device *wdd;
 	int err = -EBUSY;
+	bool running;
 
 	mutex_lock(&wd_data->lock);
 
@@ -742,14 +743,15 @@ static int watchdog_release(struct inode *inode, struct file *file)
 	clear_bit(_WDOG_DEV_OPEN, &wd_data->status);
 
 done:
+	running = wdd && watchdog_hw_running(wdd);
 	mutex_unlock(&wd_data->lock);
 	/*
 	 * Allow the owner module to be unloaded again unless the watchdog
 	 * is still running. If the watchdog is still running, it can not
 	 * be stopped, and its driver must not be unloaded.
 	 */
-	if (!watchdog_hw_running(wdd)) {
-		module_put(wdd->ops->owner);
+	if (!running) {
+		module_put(wd_data->cdev.owner);
 		kref_put(&wd_data->kref, watchdog_core_data_release);
 	}
 	return 0;

