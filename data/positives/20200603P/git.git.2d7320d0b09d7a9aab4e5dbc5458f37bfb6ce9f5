commit 2d7320d0b09d7a9aab4e5dbc5458f37bfb6ce9f5
Author: Jonas Fonseca <fonseca@diku.dk>
Date:   Fri Sep 1 00:32:39 2006 +0200

    Use xmalloc instead of malloc
    
    Signed-off-by: Jonas Fonseca <fonseca@diku.dk>
    Signed-off-by: Junio C Hamano <junkio@cox.net>

diff --git a/builtin-fmt-merge-msg.c b/builtin-fmt-merge-msg.c
index 76d22b47b..ed59e77e1 100644
--- a/builtin-fmt-merge-msg.c
+++ b/builtin-fmt-merge-msg.c
@@ -140,14 +140,14 @@ static int handle_line(char *line)
 	if (!strcmp(".", src) || !strcmp(src, origin)) {
 		int len = strlen(origin);
 		if (origin[0] == '\'' && origin[len - 1] == '\'') {
-			char *new_origin = malloc(len - 1);
+			char *new_origin = xmalloc(len - 1);
 			memcpy(new_origin, origin + 1, len - 2);
 			new_origin[len - 1] = 0;
 			origin = new_origin;
 		} else
 			origin = strdup(origin);
 	} else {
-		char *new_origin = malloc(strlen(origin) + strlen(src) + 5);
+		char *new_origin = xmalloc(strlen(origin) + strlen(src) + 5);
 		sprintf(new_origin, "%s of %s", origin, src);
 		origin = new_origin;
 	}
@@ -214,7 +214,7 @@ static void shortlog(const char *name, unsigned char *sha1,
 
 		if (eol) {
 			int len = eol - bol;
-			oneline = malloc(len + 1);
+			oneline = xmalloc(len + 1);
 			memcpy(oneline, bol, len);
 			oneline[len] = 0;
 		} else
diff --git a/builtin-repo-config.c b/builtin-repo-config.c
index 6560cf1c2..a1756c858 100644
--- a/builtin-repo-config.c
+++ b/builtin-repo-config.c
@@ -84,7 +84,7 @@ static int get_value(const char* key_, const char* regex_)
 		*tl = tolower(*tl);
 
 	if (use_key_regexp) {
-		key_regexp = (regex_t*)malloc(sizeof(regex_t));
+		key_regexp = (regex_t*)xmalloc(sizeof(regex_t));
 		if (regcomp(key_regexp, key, REG_EXTENDED)) {
 			fprintf(stderr, "Invalid key pattern: %s\n", key_);
 			goto free_strings;
@@ -97,7 +97,7 @@ static int get_value(const char* key_, const char* regex_)
 			regex_++;
 		}
 
-		regexp = (regex_t*)malloc(sizeof(regex_t));
+		regexp = (regex_t*)xmalloc(sizeof(regex_t));
 		if (regcomp(regexp, regex_, REG_EXTENDED)) {
 			fprintf(stderr, "Invalid pattern: %s\n", regex_);
 			goto free_strings;
diff --git a/config.c b/config.c
index d9f2b787b..c0897cc80 100644
--- a/config.c
+++ b/config.c
@@ -565,7 +565,7 @@ int git_config_set_multivar(const char* key, const char* value,
 	/*
 	 * Validate the key and while at it, lower case it for matching.
 	 */
-	store.key = (char*)malloc(strlen(key)+1);
+	store.key = xmalloc(strlen(key) + 1);
 	dot = 0;
 	for (i = 0; key[i]; i++) {
 		unsigned char c = key[i];
@@ -633,7 +633,7 @@ int git_config_set_multivar(const char* key, const char* value,
 			} else
 				store.do_not_match = 0;
 
-			store.value_regex = (regex_t*)malloc(sizeof(regex_t));
+			store.value_regex = (regex_t*)xmalloc(sizeof(regex_t));
 			if (regcomp(store.value_regex, value_regex,
 					REG_EXTENDED)) {
 				fprintf(stderr, "Invalid pattern: %s\n",
diff --git a/git.c b/git.c
index bd07289d7..05871ad42 100644
--- a/git.c
+++ b/git.c
@@ -29,7 +29,7 @@ static void prepend_to_path(const char *dir, int len)
 
 	path_len = len + strlen(old_path) + 1;
 
-	path = malloc(path_len + 1);
+	path = xmalloc(path_len + 1);
 
 	memcpy(path, dir, len);
 	path[len] = ':';
diff --git a/help.c b/help.c
index 9ecdefdb0..0824c2522 100644
--- a/help.c
+++ b/help.c
@@ -184,7 +184,7 @@ static void show_man_page(const char *git_cmd)
 		page = git_cmd;
 	else {
 		int page_len = strlen(git_cmd) + 4;
-		char *p = malloc(page_len + 1);
+		char *p = xmalloc(page_len + 1);
 		strcpy(p, "git-");
 		strcpy(p + 4, git_cmd);
 		p[page_len] = 0;
diff --git a/merge-recursive.c b/merge-recursive.c
index 39a1eae89..48b2763de 100644
--- a/merge-recursive.c
+++ b/merge-recursive.c
@@ -283,7 +283,7 @@ static int save_files_dirs(const unsigned char *sha1,
 		unsigned int mode, int stage)
 {
 	int len = strlen(path);
-	char *newpath = malloc(baselen + len + 1);
+	char *newpath = xmalloc(baselen + len + 1);
 	memcpy(newpath, base, baselen);
 	memcpy(newpath + baselen, path, len);
 	newpath[baselen + len] = '\0';
@@ -455,7 +455,7 @@ static int remove_path(const char *name)
 	if (ret)
 		return ret;
 	len = strlen(name);
-	dirs = malloc(len+1);
+	dirs = xmalloc(len+1);
 	memcpy(dirs, name, len);
 	dirs[len] = '\0';
 	while ((slash = strrchr(name, '/'))) {
@@ -572,7 +572,7 @@ void update_file_flags(const unsigned char *sha,
 			flush_buffer(fd, buf, size);
 			close(fd);
 		} else if (S_ISLNK(mode)) {
-			char *lnk = malloc(size + 1);
+			char *lnk = xmalloc(size + 1);
 			memcpy(lnk, buf, size);
 			lnk[size] = '\0';
 			mkdir_p(path, 0777);
diff --git a/mktag.c b/mktag.c
index be23e589f..3448a5dde 100644
--- a/mktag.c
+++ b/mktag.c
@@ -119,7 +119,7 @@ static int verify_tag(char *buffer, unsigned long size)
 int main(int argc, char **argv)
 {
 	unsigned long size = 4096;
-	char *buffer = malloc(size);
+	char *buffer = xmalloc(size);
 	unsigned char result_sha1[20];
 
 	if (argc != 1)
diff --git a/send-pack.c b/send-pack.c
index fd79a6192..ac4501d34 100644
--- a/send-pack.c
+++ b/send-pack.c
@@ -53,7 +53,7 @@ static void exec_rev_list(struct ref *refs)
 		if (900 < i)
 			die("git-rev-list environment overflow");
 		if (!is_zero_sha1(ref->new_sha1)) {
-			char *buf = malloc(100);
+			char *buf = xmalloc(100);
 			args[i++] = buf;
 			snprintf(buf, 50, "%s", sha1_to_hex(ref->new_sha1));
 			buf += 50;
@@ -75,7 +75,7 @@ static void exec_rev_list(struct ref *refs)
 		if (is_zero_sha1(ref->new_sha1) &&
 		    !is_zero_sha1(ref->old_sha1) &&
 		    has_sha1_file(ref->old_sha1)) {
-			char *buf = malloc(42);
+			char *buf = xmalloc(42);
 			args[i++] = buf;
 			snprintf(buf, 42, "^%s", sha1_to_hex(ref->old_sha1));
 		}
diff --git a/sha1_file.c b/sha1_file.c
index 46272b591..af2bf72ba 100644
--- a/sha1_file.c
+++ b/sha1_file.c
@@ -1756,7 +1756,7 @@ int read_pipe(int fd, char** return_buf, unsigned long* return_size)
 int index_pipe(unsigned char *sha1, int fd, const char *type, int write_object)
 {
 	unsigned long size = 4096;
-	char *buf = malloc(size);
+	char *buf = xmalloc(size);
 	int ret;
 	unsigned char hdr[50];
 	int hdrlen;

