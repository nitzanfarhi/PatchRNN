From 61fc6d3030a4d4283105cb5fb46b27b42fa5575e Mon Sep 17 00:00:00 2001
From: Johannes Schultz <sagamusix@openmpt.org>
Date: Fri, 2 Feb 2018 15:42:41 +0000
Subject: [PATCH] [Fix] STP: Possible out-of-bounds memory read with malformed
 STP files (caught with afl-fuzz).

git-svn-id: https://source.openmpt.org/svn/openmpt/trunk/OpenMPT@9567 56274372-70c3-4bfc-bfc3-4c3a0b034d27
---
 contrib/fuzzing/all_formats.dict | 15 ++++----
 soundlib/Load_stp.cpp            | 65 +++++++++++++++++---------------
 2 files changed, 42 insertions(+), 38 deletions(-)

diff --git a/contrib/fuzzing/all_formats.dict b/contrib/fuzzing/all_formats.dict
index dc7042782..8761c0956 100644
--- a/contrib/fuzzing/all_formats.dict
+++ b/contrib/fuzzing/all_formats.dict
@@ -138,9 +138,9 @@ ice="IT10"
 pt36="CMNT"
 pt36="PTDT"
 sfx="SO31"
-# There is currently no way to fuzz external Startrekker instrument files.
-#stam="ST1.3 ModuleINFO"
-#stam="AudioSculpture10"
+# External Startrekker instrument files.
+stam="ST1.3 ModuleINFO"
+stam="AudioSculpture10"
 
 mptm="->MPT_ORIGINAL_IT<-"
 mptm=".tpm"
@@ -204,10 +204,9 @@ ptm="\x1A\x03\x02"
 s3m="SCRM"
 s3m="SCRS"
 
-stm="!Scream!\x1A\x02"
-#stm="BMOD2STM\x1A\x02"
+stm="\x1A\x02\x15"
 
-stp="STP3\x00"
+stp="STP3\x02"
 
 ult="MAS_UTrack_V004"
 
@@ -217,7 +216,7 @@ umx="sound"
 
 xm="Extended Module: "
 xm="OpenMPT "
-xm="FastTracker v 2.00  "
+#xm="FastTracker v 2.00  "
 xm="MilkyTracker        "
 xm="text"
 xm="MIDI"
@@ -302,4 +301,4 @@ plugin_dbproecho="DBM0Echo"
 midi="MThd\x00\x00\x00\x06\x00\x01\x00\x01\x01\xE0MTrk"
 
 wave="WAVEfmt "
-wave="data"
\ No newline at end of file
+wave="data"
diff --git a/soundlib/Load_stp.cpp b/soundlib/Load_stp.cpp
index 207521d7e..4389a4f35 100644
--- a/soundlib/Load_stp.cpp
+++ b/soundlib/Load_stp.cpp
@@ -20,7 +20,7 @@
 
 OPENMPT_NAMESPACE_BEGIN
 
-// File header (except for "STP3" magic)
+// File header
 struct STPFileHeader
 {
 	char     magic[4];
@@ -108,10 +108,14 @@ static TEMPO ConvertTempo(uint16 ciaSpeed)
 
 static void ConvertLoopSlice(ModSample &src, ModSample &dest, SmpLength start, SmpLength len, bool loop)
 {
-	if(!src.HasSampleData()) return;
+	if(!src.HasSampleData()
+		|| start >= src.nLength
+		|| src.nLength - start < len)
+	{
+		return;
+	}
 
 	dest.FreeSample();
-
 	dest = src;
 	dest.nLength = len;
 	dest.pSample = nullptr;
@@ -150,16 +154,16 @@ static void ConvertLoopSequence(ModSample &smp, STPLoopList &loopList)
 
 	size_t numLoops = loopList.size();
 
-	// get the total length of the sample after combining all looped sections
+	// Get the total length of the sample after combining all looped sections
 	for(size_t i = 0; i < numLoops; i++)
 	{
 		STPLoopInfo &info = loopList[i];
 
-		// if adding this loop would cause the sample length to exceed maximum,
+		// If adding this loop would cause the sample length to exceed maximum,
 		// then limit and bail out
-		if((newSmp.nLength + info.loopLength > MAX_SAMPLE_LENGTH) ||
-		   (info.loopLength > MAX_SAMPLE_LENGTH) ||
-		   (info.loopStart + info.loopLength > smp.nLength))
+		if(info.loopStart >= smp.nLength
+			|| smp.nLength - info.loopStart < info.loopLength
+			|| newSmp.nLength > MAX_SAMPLE_LENGTH - info.loopLength)
 		{
 			numLoops = i;
 			break;
@@ -264,7 +268,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 	ReadOrderFromArray(Order(), fileHeader.orderList, fileHeader.numOrders);
 
 	std::vector<STPLoopList> loopInfo;
-	// non-looped versions of samples with loops (when needed)
+	// Non-looped versions of samples with loops (when needed)
 	std::vector<SAMPLEINDEX> nonLooped;
 
 	// Load sample headers
@@ -380,6 +384,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 	};
 	std::vector<ChannelMemory> channelMemory(m_nChannels);
 	uint8 globalVolSlide = 0;
+	uint8 speedFrac = static_cast<uint8>(fileHeader.speedFrac);
 
 	for(uint16 pat = 0; pat < numPatterns; pat++)
 	{
@@ -409,7 +414,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 
 			// if a fractional speed value is in use then determine if we should stick a fine pattern delay somewhere
 			bool shouldDelay;
-			switch(fileHeader.speedFrac & 3)
+			switch(speedFrac & 3)
 			{
 			default: shouldDelay = false; break;
 			// 1/4
@@ -475,7 +480,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 					chnMem.autoPortaDown = 0;
 					chnMem.autoTonePorta = 0;
 
-					m.command = m.param = 0;
+					m.command = CMD_NONE;
 					break;
 
 				case 0x04: // auto fine portamento down
@@ -484,7 +489,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 					chnMem.autoPortaDown = 0;
 					chnMem.autoTonePorta = 0;
 
-					m.command = m.param = 0;
+					m.command = CMD_NONE;
 					break;
 
 				case 0x05: // auto portamento up
@@ -493,7 +498,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 					chnMem.autoPortaDown = 0;
 					chnMem.autoTonePorta = 0;
 
-					m.command = m.param = 0;
+					m.command = CMD_NONE;
 					break;
 
 				case 0x06: // auto portamento down
@@ -502,7 +507,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 					chnMem.autoPortaDown = m.param;
 					chnMem.autoTonePorta = 0;
 
-					m.command = m.param = 0;
+					m.command = CMD_NONE;
 					break;
 
 				case 0x07: // set global volume
@@ -512,7 +517,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 
 				case 0x08: // auto global fine volume slide
 					globalVolSlide = swapped;
-					m.command = m.param = 0;
+					m.command = CMD_NONE;
 					break;
 
 				case 0x09: // fine portamento up
@@ -527,14 +532,14 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 
 				case 0x0B: // auto fine volume slide
 					chnMem.autoVolSlide = swapped;
-					m.command = m.param = 0;
+					m.command = CMD_NONE;
 					break;
 
 				case 0x0C: // set volume
 					m.volcmd = VOLCMD_VOLUME;
 					m.vol = m.param;
 					chnMem.autoVolSlide = 0;
-					m.command = m.param = 0;
+					m.command = CMD_NONE;
 					break;
 
 				case 0x0D: // volume slide (param is swapped compared to .mod)
@@ -548,7 +553,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 						m.vol = m.param & 0xF;
 					}
 					chnMem.autoVolSlide = 0;
-					m.command = m.param = 0;
+					m.command = CMD_NONE;
 					break;
 
 				case 0x0E: // set filter (also uses opposite value compared to .mod)
@@ -558,14 +563,14 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 
 				case 0x0F: // set speed
 					m.command = CMD_SPEED;
-					fileHeader.speedFrac = m.param & 0xF;
+					speedFrac = m.param & 0x0F;
 					m.param >>= 4;
 					break;
 
 				case 0x10: // auto vibrato
 					chnMem.autoVibrato = m.param;
 					chnMem.vibratoMem = 0;
-					m.command = m.param = 0;
+					m.command = CMD_NONE;
 					break;
 
 				case 0x11: // auto tremolo
@@ -573,7 +578,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 						chnMem.autoTremolo = m.param;
 					else
 						chnMem.autoTremolo = 0;
-					m.command = m.param = 0;
+					m.command = CMD_NONE;
 					break;
 
 				case 0x12: // pattern break
@@ -587,7 +592,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 					chnMem.autoTonePorta = m.param;
 
 					chnMem.tonePortaMem = 0;
-					m.command = m.param = 0;
+					m.command = CMD_NONE;
 					break;
 
 				case 0x14: // position jump
@@ -607,7 +612,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 						}
 					}
 
-					m.command = m.param = 0;
+					m.command = CMD_NONE;
 					break;
 
 				case 0x17: // play only loop nn
@@ -624,7 +629,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 						}
 					}
 
-					m.command = m.param = 0;
+					m.command = CMD_NONE;
 					break;
 
 				case 0x18: // play sequence without loop
@@ -644,7 +649,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 						m.instr = static_cast<ModCommand::INSTR>(nonLooped[m.instr - 1]);
 					}
 
-					m.command = m.param = 0;
+					m.command = CMD_NONE;
 					break;
 
 				case 0x19: // play only loop nn without loop
@@ -661,7 +666,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 						}
 					}
 
-					m.command = m.param = 0;
+					m.command = CMD_NONE;
 					break;
 
 				case 0x1D: // fine volume slide (nibble order also swapped)
@@ -679,7 +684,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 					if(m.param & 0xF0)
 					{
 						chnMem.autoVolSlide = m.param >> 4;
-						m.command = m.param = 0;
+						m.command = CMD_NONE;
 					} else
 					{
 						m.command = CMD_MODCMDEX;
@@ -705,14 +710,14 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 					if((m.param & 0xF0) == 0x60 || (m.param & 0xF0) == 0xE0)
 						m.command = CMD_MODCMDEX;
 					else
-						m.command = m.param = 0;
+						m.command = CMD_NONE;
 					break;
 
 				case 0x4F: // set speed/tempo
 					if(m.param < 0x20)
 					{
 						m.command = CMD_SPEED;
-						fileHeader.speedFrac = 0;
+						speedFrac = 0;
 					} else
 					{
 						m.command = CMD_TEMPO;
@@ -727,7 +732,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)
 				bool didVolSlide = false;
 
 				// try to put volume slide in volume command
-				if(chnMem.autoVolSlide && !m.volcmd)
+				if(chnMem.autoVolSlide && m.volcmd == VOLCMD_NONE)
 				{
 					if(chnMem.autoVolSlide & 0xF0)
 					{
